- en: Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: One of the biggest new features of C++17 is its `<filesystem>` library. This
    library, like many other major features of modern C++, originated in the Boost
    project. In 2015, it went into a standard technical specification to gather feedback,
    and finally, was merged into the C++17 standard with some changes based on that
    feedback.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 最大的新特性之一是其 `<filesystem>` 库。这个库，就像现代 C++ 的许多其他主要特性一样，起源于 Boost 项目。2015
    年，它成为了一个标准技术规范以收集反馈，最终，根据这些反馈进行了一些修改后，被合并到 C++17 标准中。
- en: 'In this chapter, you''ll learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How `<filesystem>` returns dynamically typed errors without throwing exceptions,
    and how you can too
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<filesystem>` 如何返回动态类型错误而不抛出异常，以及你如何也能做到'
- en: The format of a *path,* and the fundamentally incompatible positions of POSIX
    and Windows on the subject
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路径* 的格式，以及 POSIX 和 Windows 在这个问题上的根本不兼容立场'
- en: How to stat files and walk directories using portable C++17
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用可移植的 C++17 来获取文件状态和遍历目录
- en: How to create, copy, rename, and remove files and directories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建、复制、重命名和删除文件和目录
- en: How to fetch the free space of a filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取文件系统的空闲空间
- en: A note about namespaces
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于命名空间的一些说明
- en: 'The standard C++17 filesystem facilities are all provided in a single header,
    `<filesystem>`, and everything in that header is placed in its own namespace:
    `namespace std::filesystem`. This follows the precedent set by C++11''s `<chrono>`
    header with its `namespace std::chrono`. (This book omits a full treatment of
    `<chrono>`. Its interactions with `std::thread` and `std::timed_mutex` are covered
    briefly in [Chapter 7](part0108.html#36VSO0-2fdac365b8984feebddfbb9250eaf20d),
    *Concurrency*.)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 C++17 文件系统功能都包含在一个单独的头文件中，即 `<filesystem>`，并且该头文件中的所有内容都放置在其自己的命名空间中：`namespace
    std::filesystem`。这遵循了 C++11 的 `<chrono>` 头文件及其 `namespace std::chrono` 所设定的先例。（本书省略了对
    `<chrono>` 的全面介绍。它与 `std::thread` 和 `std::timed_mutex` 的交互在 [第 7 章](part0108.html#36VSO0-2fdac365b8984feebddfbb9250eaf20d)，*并发*
    中简要介绍。）
- en: 'This namespacing strategy means that when you use the `<filesystem>` facilities,
    you''ll be using identifiers such as `std::filesystem::directory_iterator` and
    `std::filesystem::temp_directory_path()`. These fully qualified names are quite
    unwieldy! But pulling the entire namespace into your current context with a `using`
    declaration is probably an overkill, especially, if you have to do it at file
    scope. We''ve all been taught over the past decade never to write `using namespace
    std`, and that advice won''t change, no matter how deeply the standard library
    nests its namespaces. Consider the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名空间策略意味着当你使用 `<filesystem>` 功能时，你将使用诸如 `std::filesystem::directory_iterator`
    和 `std::filesystem::temp_directory_path()` 这样的标识符。这些完全限定名称相当难以处理！但是，使用 `using`
    声明将整个命名空间拉入当前上下文可能是一种过度行为，尤其是如果你需要在文件作用域中这样做。在过去十年中，我们都被告知永远不要写 `using namespace
    std`，而且无论标准库的命名空间嵌套有多深，这条建议都不会改变。考虑以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A better solution for everyday purposes is to define a *namespace alias* at
    file scope (in a `.cc` file) or namespace scope (in a `.h` file). A namespace
    alias allows you to refer to an existing namespace by a new name, as seen in the
    following example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日常用途来说，更好的解决方案是在文件作用域（在`.cc`文件中）或命名空间作用域（在`.h`文件中）定义一个*命名空间别名*。命名空间别名允许你通过一个新名称来引用现有的命名空间，如下面的示例所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the remainder of this chapter, I will be using the namespace alias `fs` to
    refer to `namespace std::filesystem`. When I say `fs::path`, I mean `std::filesystem::path`.
    When I say `fs::remove`, I mean `std::filesystem::remove`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将使用命名空间别名 `fs` 来引用 `namespace std::filesystem`。当我提到 `fs::path` 时，我的意思是
    `std::filesystem::path`。当我提到 `fs::remove` 时，我的意思是 `std::filesystem::remove`。
- en: 'Defining a namespace alias `fs` somewhere global has another pragmatic benefit
    as well. At press time, of all the major library vendors, only Microsoft Visual
    Studio claims to have implemented the C++17 `<filesystem>` header. However, the
    facilities of `<filesystem>` are very similar to those provided by libstdc++ and
    libc++ in `<experimental/filesystem>`, and by Boost in `<boost/filesystem.hpp>`.
    So, if you consistently refer to these facilities by a custom namespace alias,
    such as `fs`, you''ll be able to switch from one vendor''s implementation to another
    just by changing the target of that alias--a one-line change, as opposed to a
    massive and error-prone search-and-replace operation on your entire codebase.
    This can be seen in the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个全局位置定义一个命名空间别名 `fs` 也有另一个实用的好处。截至出版时，在所有主要的库供应商中，只有 Microsoft Visual Studio
    声称已经实现了 C++17 `<filesystem>` 头文件。然而，`<filesystem>` 提供的功能与 `<experimental/filesystem>`
    中由 libstdc++ 和 libc++ 提供的功能以及 Boost 中的 `<boost/filesystem.hpp>` 非常相似。因此，如果你始终通过自定义命名空间别名，如
    `fs`，来引用这些功能，你将能够通过更改该别名的目标来从一家供应商的实现切换到另一家——只需一行更改，而不是在整个代码库上进行大量且容易出错的搜索和替换操作。这可以在以下示例中看到：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A very long note on error-reporting
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于错误报告的非常长的笔记
- en: C++ has a love-hate relationship with error-reporting. By "error-reporting"
    in this context, I mean "what to do, when you can't do what you were asked". The
    classical, typical, and still the best-practice way to report this kind of "disappointment"
    in C++ is to throw an exception. We have seen in the previous chapters that, sometimes,
    throwing an exception is the *only* sensible thing to do, because there is no
    way to return to your caller. For example, if your task was to construct an object,
    and construction fails, you cannot return; when a constructor fails, the only
    same course of action is to throw. However, we have *also* seen (in [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d)*,
    Iostreams*) that C++'s own `<iostream>` library does not take this sane course
    of action! If the construction of a `std::fstream` object fails (because the named
    file cannot be opened), you will get an exception; you'll get a fully constructed
    `fstream` object where `f.fail() && !f.is_open()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 与错误报告有着爱恨交加的关系。在这里，“错误报告”指的是“当你无法完成所要求的事情时，应该怎么做”。在 C++ 中，报告这类“失望”的经典、典型且至今仍被视为最佳实践的方法是抛出一个异常。我们在前面的章节中看到，有时抛出异常是唯一合理的做法，因为没有其他方式可以返回调用者。例如，如果你的任务是构建一个对象，而构建失败，你无法返回；当构造函数失败时，唯一相同的行动就是抛出异常。然而，我们也已经看到（在第
    9 章[Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d)*，Iostreams*），C++
    自身的 `<iostream>` 库并没有采取这种理智的行动！如果一个 `std::fstream` 对象的构建失败（因为无法打开指定的文件），你会得到一个异常；你将得到一个完全构建的
    `fstream` 对象，其中 `f.fail() && !f.is_open()`。
- en: The reason we gave in [Chapter 9](https://cdp.packtpub.com/mastering_c___stl/wp-admin/post.php?post=64&action=edit#post_58)*,
    Iostreams*, for the "bad" behavior of `fstream` was the *relatively high likelihood*
    that the named file will not be openable. Throwing an exception every time a file
    can't be opened is uncomfortably close to using exceptions for control flow, which
    we have been taught--properly--to avoid. So, rather than force the programmer
    to write `try` and `catch` blocks everywhere, the library returns as if the operation
    had succeeded, but allows the user to check (with a normal `if`, not a `catch`)
    whether the operation really did succeed or not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 9 章[Chapter 9](https://cdp.packtpub.com/mastering_c___stl/wp-admin/post.php?post=64&action=edit#post_58)*，Iostreams*
    中给出的理由是 `fstream` 的“不良”行为是“相对较高的文件无法打开的可能性”。每次文件无法打开时都抛出异常，这让人不舒服地接近使用异常进行控制流，这是我们被正确教导要避免的。因此，而不是强迫程序员在所有地方都编写
    `try` 和 `catch` 块，库返回操作似乎已成功完成，但允许用户检查（使用正常的 `if`，而不是 `catch`）操作是否真的成功了。
- en: 'That is, we can avoid writing this cumbersome code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以避免编写以下繁琐的代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead, we can simply write this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以简单地写这个：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The iostreams approach works pretty well when the result of the operation is
    described by a heavyweight object (such as an `fstream`) which has a natural *failed*
    state, or where such a *failed* state can be added during the design stage. However,
    it has some downsides as well, and it flatly cannot be used if there is no heavyweight
    type involved. We saw this scenario at the end of [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams*, when we looked at ways of parsing integers from strings. If we don''t
    expect failure, or don''t mind the performance hit of "using exceptions for control
    flow," then we use `std::stoi`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作的结果可以用一个重型的对象（如 `fstream`）描述，该对象具有自然的 *失败* 状态，或者在设计阶段可以添加这样的 *失败* 状态时，iostreams
    方法工作得相当好。然而，它也有一些缺点，如果没有涉及重型的类型，则根本不能使用。我们在 [第 9 章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d)
    的末尾看到了这种情况，*iostreams*，当时我们讨论了从字符串中解析整数的方法。如果我们不期望失败，或者不介意“使用异常进行控制流”的性能损失，那么我们使用
    `std::stoi`：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we need portability to C++03, we use `strtol`, which reports errors via
    the thread-local global variable `errno`, as seen in this code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要 C++03 的可移植性，我们使用 `strtol`，它通过线程局部全局变量 `errno` 报告错误，如以下代码所示：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And in bleeding-edge C++17 style, we use `std::from_chars`, which returns a
    lightweight struct containing the end-of-string pointer and a value of the strong
    enum type `std::errc` indicating success or failure, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 bleeding-edge C++17 风格中，我们使用 `std::from_chars`，它返回一个包含字符串结束指针和表示成功或失败的强枚举类型
    `std::errc` 的轻量级结构体，如下所示：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `<filesystem>` library needs approximately the same capacity for error-reporting
    as `std::from_chars`. Pretty much any operation you can perform on your filesystem
    might fail due to the actions of other processes running on the system; so, throwing
    an exception on every failure (á là `std::stoi`) seems uncomfortably close to
    using exceptions for control flow. But threading an "error result" like `ec` through
    your entire codebase can also be tedious and (no pun intended) error-prone. So,
    the standard library decided to have its cake and eat it too by providing *two
    interfaces* to almost every function in the `<filesystem>` header!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`<filesystem>` 库在错误报告方面的容量大约与 `std::from_chars` 相同。几乎你可以在文件系统中进行的任何操作都可能因为系统上运行的其他进程的操作而失败；因此，每次失败时抛出异常（类似于
    `std::stoi`）似乎与使用异常进行控制流非常接近。但是，将“错误结果”如 `ec` 在整个代码库中传递也可能很繁琐，并且（不是字面意义上的）容易出错。因此，标准库决定既要吃蛋糕又要吃蛋糕，为
    `<filesystem>` 头文件中的几乎每个函数都提供了 *两个接口*！'
- en: 'For example, the following are the two `<filesystem>` functions for determining
    the size of a file on disk:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是在磁盘上确定文件大小的两个 `<filesystem>` 函数：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both the preceding functions take an `fs::path` (which we'll discuss more further
    in the chapter), and return a `uintmax_t` telling the size of the named file in
    bytes. But what if the file doesn't exist, or it exists, but the current user-account
    doesn't have permission to query its size? Then, the first overload will simply
    *throw an exception* of type `fs::filesystem_error`, indicating what went wrong.
    But the second overload will never throw (in fact, it's marked `noexcept`). Instead,
    it takes an out-parameter of type `std::error_code`, which the library will fill
    in with an indication of what went wrong (or clear, if nothing went wrong at all).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个函数都接受一个 `fs::path`（我们将在本章后面进一步讨论），并返回一个 `uintmax_t`，表示以字节为单位命名的文件的大小。但如果文件不存在，或者文件存在，但当前用户账户没有查询其大小的权限呢？那么，第一个重载将简单地
    *抛出一个异常*，类型为 `fs::filesystem_error`，指示出了什么问题。但第二个重载永远不会抛出（实际上，它被标记为 `noexcept`）。相反，它接受一个类型为
    `std::error_code` 的输出参数，库将填充一个指示出错的指示（如果没有出错，则清除）。
- en: Comparing the signatures of `fs::file_size` and `std::from_chars`, you might
    notice that `from_chars` deals in `std::errc`, and `file_size` deals in `std::error_code`.
    These two types, while related, are not the same! To understand the difference--and
    the entire design of the non-throwing `<filesystem>` API--we'll have to take a
    quick detour into another part of the C++11 standard library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 比较一下 `fs::file_size` 和 `std::from_chars` 的签名，你可能会注意到 `from_chars` 处理的是 `std::errc`，而
    `file_size` 处理的是 `std::error_code`。这两个类型虽然相关，但并不相同！要理解这种差异——以及非抛出 `<filesystem>`
    API 的整个设计——我们不得不快速浏览一下 C++11 标准库的另一个部分。
- en: Using <system_error>
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `<system_error>`
- en: The difference between the error-reporting mechanisms of `std::from_chars` and
    `fs::file_size` is a difference in their intrinsic complexity. `from_chars` can
    fail in exactly two ways-- either the given string had no initial string of digits
    at all, else there were so *many* digits that it would cause an overflow to read
    them all. In the former case, a classic (but inefficient and, generally, dangerous)
    way to report the error would be to set `errno` to `EINVAL` (and return some useless
    value such as `0`). In the latter case, a classic approach would be to set `errno`
    to `ERANGE` (and return some useless value). This is more or less (but rather
    less than more) the approach taken by `strtol`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::from_chars` 和 `fs::file_size` 的错误报告机制之间的区别在于它们固有的复杂性。`from_chars` 可以以两种方式失败——要么给定的字符串根本没有任何初始数字字符串，要么有太多的数字，以至于读取它们会导致溢出。在前一种情况下，报告错误的一个经典（但效率低下且通常危险的）方法是将
    `errno` 设置为 `EINVAL`（并返回一些无用的值，如 `0`）。在后一种情况下，一个经典的方法是将 `errno` 设置为 `ERANGE`（并返回一些无用的值）。这大致上是（但远不如前者）`strtol`
    所采取的方法。'
- en: 'The salient point is that with `from_chars`, there are exactly two things that
    can possibly *ever* go wrong, and they are completely describable by the single
    set of error codes provided by POSIX `<errno.h>`. So, in order to bring the 1980''s
    `strtol` into the twenty-first century, all we need to fix is to make it return
    its error code directly to the caller rather than indirectly, via the thread-local
    `errno`. And so, that''s all the standard library did. The classic POSIX `<errno.h>`
    values are still provided as macros via `<cerrno>`, but as of C++11, they''re
    also provided via a strongly typed enumeration in `<system_error>`, as shown in
    the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的要点是，使用 `from_chars` 时，可能出错的两种情况是完全可以由 POSIX `<errno.h>` 提供的单个错误代码集来描述的。因此，为了将
    1980 年代的 `strtol` 带入 21 世纪，我们只需要修复使其直接将错误代码返回给调用者，而不是通过线程局部 `errno` 间接返回。这就是标准库所做的一切。经典的
    POSIX `<errno.h>` 值仍然通过 `<cerrno>` 作为宏提供，但自 C++11 以来，它们也通过 `<system_error>` 中的强类型枚举提供，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`std::from_chars` reports errors by returning a struct (`struct from_chars_result`)
    containing a member variable of type `enum std::errc`, which will be either `0`
    for *no error*, or one of the two possible error-indicating values.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::from_chars` 通过返回一个包含类型为 `enum std::errc` 的成员变量的结构体（`struct from_chars_result`）来报告错误，该成员变量可以是
    `0` 表示 *无错误*，或者两个可能的错误指示值之一。'
- en: Now, what about `fs::file_size`? The set of possible errors encountered by `file_size`
    is much much larger--in fact, when you think of the number of operating systems
    in existence, and the number of different filesystems supported by each, and the
    fact that some filesystems (such as NFS) are distributed over *networks* of various
    types, the set of possible errors seems an awful lot like an *open set*. It might
    be possible to boil them all down onto the seventy-eight standard `sys::errc`
    enumerators (one for each POSIX `errno` value except `EDQUOT`, `EMULTIHOP`, and
    `ESTALE`), but that would lose a lot of information. Heck, at least one of the
    missing POSIX enumerators (`ESTALE`) is a legitimate failure mode of `fs::file_size`!
    And, of course, your underlying filesystem might want to report its own filesystem-specific
    errors; for example, while there is a standard POSIX error code for *name too
    long*, there is no POSIX error code for *name contains disallowed character* (for
    reasons we'll see in the next major section of this chapter). A filesystem might
    want to report exactly that error without worrying that `fs::file_size` was going
    to squash it down onto some fixed enumeration type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于 `fs::file_size` 呢？`file_size` 可能遇到的一组错误要多得多——实际上，当你想到存在的操作系统的数量，以及每个操作系统支持的不同文件系统的数量，以及某些文件系统（如
    NFS）分布在各种类型的 *网络* 上时，可能出现的错误集合看起来就像一个 *开集*。可能可以将它们全部归结为七十八个标准的 `sys::errc` 枚举器（每个
    POSIX `errno` 值一个，除了 `EDQUOT`、`EMULTIHOP` 和 `ESTALE`），但这会丢失很多信息。实际上，至少缺失的 POSIX
    枚举器之一（`ESTALE`）是 `fs::file_size` 的一个合法失败模式！当然，你的底层文件系统可能想要报告它自己的特定于文件系统的错误；例如，虽然有一个标准的
    POSIX 错误代码用于 *名称过长*，但没有 POSIX 错误代码用于 *名称包含不允许的字符*（原因将在本章下一主要部分中看到）。文件系统可能想要报告那个错误，而不用担心
    `fs::file_size` 会将其压缩到某种固定的枚举类型中。
- en: The essential issue here is that the errors reported by `fs::file_size` might
    not all come from the same *domain*, and therefore, they cannot be represented
    by a single fixed-in-stone *type* (for example, `std::errc`). C++ exception-handling
    solves this problem elegantly; it is fine and natural for different levels of
    the program to throw different types of exceptions. If the lowest level of a program
    throws `myfs::DisallowedCharacterInName`, the topmost level can catch it--either
    by name, by base class, or by `...`. If we follow the general rule that everything
    thrown in a program should derive from `std::exception`, then any `catch` block
    will be able to use `e.what()` so that at least the user gets some vaguely human-readable
    indication of the problem, no matter what the problem was.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里基本的问题是，`fs::file_size`报告的错误可能并不都来自同一个*域*，因此，它们不能由一个固定的*类型*（例如，`std::errc`）来表示。C++异常处理优雅地解决了这个问题；程序的不同级别抛出不同类型的异常是正常且自然的。如果程序最低级别抛出`myfs::DisallowedCharacterInName`，则最高级别可以捕获它——无论是通过名称、基类还是通过`...`。如果我们遵循在程序中抛出的所有内容都应该从`std::exception`派生的通用规则，那么任何`catch`块都将能够使用`e.what()`，这样至少用户可以得到一些模糊上可读的问题指示，无论问题是什么。
- en: 'The standard library *reifies* the idea of multiple error domains into the
    base class `std::error_category`, as seen in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库将多个错误域的概念具体化为基类`std::error_category`，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`error_category` behaves a lot like `memory_resource` from [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*; it defines a classically polymorphic interface, and certain kinds
    of libraries are expected to subclass it. With `memory_resource`, we saw that
    some subclasses are global singletons, and some aren''t. With `error_category`,
    *each* subclass *must* be a global singleton, or it''s not going to work.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_category`的行为与第8章中提到的`memory_resource`非常相似，*分配器*；它定义了一个经典的多态接口，某些类型的库预期会从它派生。我们看到了，一些`memory_resource`的子类是全球单例，而另一些则不是。对于`error_category`，*每个*子类*必须*是一个全局单例，否则它将无法工作。'
- en: To make memory resources useful, the library gives us *containers* (see [Chapter
    4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container Zoo*).
    At the most basic level, a container is a pointer representing some allocated
    memory, plus a handle to the *memory resource* that knows how to deallocate that
    pointer. (Recall that a handle to a memory resource is called an *allocator*.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内存资源有用，库为我们提供了*容器*（参见第4章，*容器动物园*）。在最基本层面上，一个容器是一个表示某些已分配内存的指针，以及一个指向*内存资源*的句柄，该资源知道如何释放该指针。（回想一下，指向内存资源的句柄被称为*分配器*。）
- en: 'To make the `error_category` subclasses useful, the library gives us `std::error_code`.
    At the most basic level (which is the *only* level, in this case), an `error_code`
    is an `int` representing an error enumerator plus a handle to the `error_category`
    that knows how to interpret that enumerator. It looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`error_category`子类有用，库为我们提供了`std::error_code`。在最基本层面上（在这个例子中，这是*唯一*的层面），一个`error_code`是一个表示错误枚举的`int`值，以及一个指向`error_category`的句柄，该句柄知道如何解释该枚举。它看起来是这样的：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, to create a finicky filesystem library subsystem, we could write the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建一个挑剔的文件系统库子系统，我们可以编写以下代码：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This preceding code defines a new error domain, the `FinickyFS::Error` domain,
    reified as `FinickyFS::ErrorCategory::instance()`. It allows us to create objects
    of type `std::error_code` via expressions such as `make_error_code(FinickyFS::Error::forbidden_word)`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个新的错误域，即`FinickyFS::Error`域，通过`FinickyFS::ErrorCategory::instance()`实例化。这允许我们通过如`make_error_code(FinickyFS::Error::forbidden_word)`这样的表达式创建`std::error_code`类型的对象。
- en: 'Notice that **argument-dependent lookup** (**ADL**) will find the correct overload
    of `make_error_code` without any help from us. `make_error_code` is a customization
    point in exactly the same way as `swap`: just define a function with that name
    in your enum''s namespace, and it will work without any additional effort.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**依赖参数的查找**（**ADL**）将无需我们的任何帮助就找到`make_error_code`的正确重载。`make_error_code`与`swap`一样，是一个定制点：只需在枚举的命名空间中定义一个具有该名称的函数，它就会工作而无需任何额外的工作。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now have a way to pass `FinickyFS::Error` codes losslessly through the system--by
    wrapping them inside trivially copyable `std::error_code` objects, and getting
    the original error back out at the topmost level. When I put it that way, it sounds
    almost like magic--like exception handling without exceptions! But as we've just
    seen, it's very simple to implement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种方法，可以通过将它们包装在简单可复制的 `std::error_code` 对象中来无损地传递 `FinickyFS::Error` 代码——并在最高级别获取原始错误。当我那样说的时候，它听起来几乎像是魔法——就像没有异常的异常处理！但正如我们刚才看到的，实现起来非常简单。
- en: Error codes and error conditions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误代码和错误条件
- en: 'Notice that `FinickyFS::Error` is not implicitly convertible to `std::error_code`;
    in the last example, we used the syntax `make_error_code(FinickyFS::Error::forbidden_word)`
    to construct our initial `error_code` object. We can make `FinickyFS::Error` more
    convenient for the programmer if we tell `<system_error>` to enable implicit conversions
    from `FinickyFS::Error` to `std::error_code`, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `FinickyFS::Error` 不能隐式转换为 `std::error_code`；在最后一个例子中，我们使用了 `make_error_code(FinickyFS::Error::forbidden_word)`
    语法来构造我们的初始 `error_code` 对象。如果我们告诉 `<system_error>` 启用从 `FinickyFS::Error` 到 `std::error_code`
    的隐式转换，那么 `FinickyFS::Error` 对程序员来说会更加方便，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Be careful when reopening namespace `std`--remember that you must be outside
    any other namespace when you do it! Otherwise, you'll be creating a nested namespace
    such as namespace `FinickyFS::std`. In this particular case, if you get it wrong,
    the compiler will helpfully error out when you try to specialize the non-existent
    `FinickyFS::std::is_error_code_enum`. As long as you only ever reopen namespace
    `std` in order to specialize templates (and as long as you don't mess up the template-specialization
    syntax), you won't have to worry too much about anything *quietly* failing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新打开 `std` 命名空间时要小心——记住，当你这样做的时候，你必须处于任何其他命名空间之外！否则，你将创建一个嵌套的命名空间，例如 `FinickyFS::std`
    命名空间。在这种情况下，如果你出错，编译器会在你尝试特化不存在的 `FinickyFS::std::is_error_code_enum` 时友好地报错。只要你在特化模板时只重新打开
    `std` 命名空间（并且只要你不搞砸模板特化语法），你就不必太担心任何 *静默* 失败。
- en: 'Once you''ve specialized `std::is_error_code_enum` for your enum type, the
    library takes care of the rest, as seen in this code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为你的枚举类型特化了 `std::is_error_code_enum`，库就会处理其余部分，如下代码所示：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The implicit conversion seen in the previous code enables convenient syntax
    such as direct comparisons via `==`, but because each `std::error_code` object
    carries its domain along with it, comparisons are strongly typed. Value-equality
    for the `error_code` objects depends not only on their *integer* *value*, but
    also the *address* of their associated error-category singletons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中看到的隐式转换使得方便的语法变得可能，例如通过 `==` 进行直接比较，但由于每个 `std::error_code` 对象都携带其域，比较是强类型的。`error_code`
    对象的值相等不仅取决于它们的 *整数* *值*，还取决于它们相关错误类别单例的 *地址*。
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Specializing `is_error_code_enum<X>` is helpful if you''re often going to be
    assigning `X` to variables of type `std::error_code`, or returning it from functions
    that return `std::error_code`. In other words, it''s useful if your type `X` really
    does represent *the source of an error*--the throwing side of the equation, so
    to speak. But what about the catching side? Suppose you notice that you''ve written
    this function, and several more like it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 特化 `is_error_code_enum<X>` 对于你经常将 `X` 赋值给 `std::error_code` 类型的变量，或者从返回 `std::error_code`
    的函数中返回 `X` 来说是有帮助的。换句话说，如果你的类型 `X` 真正代表 *错误的来源*——方程的抛出方，那么关于捕获方呢？假设你注意到你已经编写了这个函数，以及几个类似的函数：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding function defines a *unary* *predicate* over the entire universe
    of error codes; it returns `true` for any error code associated with the concept
    of malformed names as far as our `FinickyFS` library is concerned. We can just
    drop this function straight into our library as `FinickyFS::is_malformed_name()`--and,
    in fact, that''s the approach I personally recommend--but the standard library
    also provides another possible approach. You can define not an `error_code`, but
    an `error_condition`, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数定义了一个在整个错误代码宇宙上的 *一元* *谓词*；就我们的 `FinickyFS` 库而言，它对任何与名称格式错误概念相关的错误代码返回
    `true`。我们只需将此函数直接放入我们的库中作为 `FinickyFS::is_malformed_name()`——实际上，这正是我个人的推荐做法——但标准库还提供了另一种可能的方法。你可以定义一个
    `error_condition` 而不是 `error_code`，如下所示：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you''ve done this, you can get the effect of calling `FinickyFS::is_malformed_name(ec)`
    by writing the comparison `(ec == FinickyFS::Condition::malformed_name)`, like
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，你可以通过编写比较 `(ec == FinickyFS::Condition::malformed_name)` 来获得调用 `FinickyFS::is_malformed_name(ec)`
    的效果，如下所示：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, because we did not provide a function `make_error_code(FinickyFS::Condition)`,
    there will be no easy way to construct a `std::error_code`} object holding one
    of these conditions. This is appropriate; condition enums are for testing against
    on the catching side, not for converting to `error_code` on the throwing side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为我们没有提供一个函数 `make_error_code(FinickyFS::Condition)`，将无法轻松构造一个包含这些条件的 `std::error_code`
    对象。这是合适的；条件枚举是在捕获侧进行测试的，而不是在抛出侧转换为 `error_code`。
- en: The standard library provides two code enum types (`std::future_errc` and `std::io_errc`),
    and one condition enum type (`std::errc`). That's right--the POSIX error enum
    `std::errc` actually enumerates *conditions*, not *codes*! This means that if
    you're trying to stuff POSIX error codes into a `std::error_code` object, you're
    doing it wrong; they are *conditions*, which means they're for *testing* *against*
    on the catching side, not for throwing. Sadly, the standard library gets this
    wrong in at least two ways. First, as we've seen, `std::from_chars` does throw
    a value of type `std::errc` (which is doubly inconvenient; it would be more consistent
    to throw a `std::error_code`). Second, the function `std::make_error_code(std::errc)`
    exists, cluttering up the semantic space, when really only `std::make_error_condition(std::errc)`
    should (and does) exist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了两种代码枚举类型（`std::future_errc` 和 `std::io_errc`），以及一种条件枚举类型（`std::errc`）。没错——POSIX
    错误枚举 `std::errc` 实际上枚举的是 *条件*，而不是 *代码*！这意味着如果你试图将 POSIX 错误代码塞入一个 `std::error_code`
    对象中，你做错了；它们是 *条件*，这意味着它们是在捕获侧 *测试* 的，而不是用于抛出的。遗憾的是，标准库至少在两个方面犯了错误。首先，正如我们所看到的，`std::from_chars`
    会抛出一个 `std::errc` 类型的值（这很不方便；抛出一个 `std::error_code` 会更一致）。其次，存在一个函数 `std::make_error_code(std::errc)`，这会弄乱语义空间，而实际上只需要存在
    `std::make_error_condition(std::errc)`（它确实存在）。
- en: Throwing errors with std::system_error
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::system_error 抛出错误
- en: So far, we've considered `std::error_code`, a nifty non-throwing alternative
    to C++ exception-handling. But sometimes, you need to mix non-throwing and throwing
    libraries at different levels of the system. The standard library has your back--for
    one-half of the problem, anyway. `std::system_error` is a concrete exception type
    derived from `std::runtime_error`, which has just enough storage for a single
    `error_code`. So, if you are writing a library API which is throw-based, not `error_code`-based,
    and you receive an `error_code` indicating failure from a lower level of the system,
    it is perfectly appropriate to wrap that `error_code` in a `system_error` object,
    and `throw` it upward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑了 `std::error_code`，这是 C++ 异常处理的一个巧妙的非抛出替代方案。但有时，你需要在不同级别的系统中混合非抛出和抛出库。标准库为你解决了问题——至少是问题的一半。`std::system_error`
    是从 `std::runtime_error` 派生出的具体异常类型，它有足够的空间存储单个 `error_code`。因此，如果你正在编写一个基于抛出而不是
    `error_code` 的库 API，并且从系统较低级别收到表示失败的 `error_code`，将那个 `error_code` 包装在 `system_error`
    对象中并向上抛出是完全合适的。
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the opposite case--where you''ve written your library API to be non-throwing,
    but you make calls into lower levels that might throw--the standard library provides,
    basically, no help. But you can write an `error_code` unwrapper fairly easily
    yourself:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在相反的情况下——当你编写了非抛出异常的库 API，但你调用较低级别的可能抛出异常的代码时——标准库基本上没有提供帮助。但你可以自己轻松地编写一个 `error_code`
    解包器：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This concludes our digression into the confusing world of `<system_error>`.
    We now return you to your regularly scheduled `<filesystem>`, already in progress.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 `<system_error>` 中混乱世界的离题讨论。我们现在回到你正在进行的常规 `<filesystem>`。
- en: Filesystems and paths
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统和路径
- en: In [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d), *Iostreams*,
    we discussed the POSIX concept of file descriptors. A file descriptor
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d) *Iostreams*
    中，我们讨论了 POSIX 的文件描述符概念。
- en: represents a source or sink of data which can be targeted by `read` and/or `write`;
    often, but not always, it corresponds to a file on disk. (Recall that file descriptor
    number `1` refers to `stdout`, which is usually connected to the human user's
    screen. File descriptors can also refer to network sockets, devices such as `/dev/random`,
    and so on.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数据源或汇，可以通过 `read` 和/或 `write` 来定位；通常，但不总是，它对应于磁盘上的一个文件。（回想一下，文件描述符号 `1` 指的是
    `stdout`，它通常连接到人类的屏幕。文件描述符还可以指网络套接字、例如 `/dev/random` 的设备等。）
- en: Furthermore, POSIX file descriptors, `<stdio.h>`, and `<iostream>` are all concerned,
    specifically, with the *contents* of a file on disk (or wherever)--the sequence
    of bytes that makes up the *contents* of the file. A file in the *file**system*
    sense has many more salient attributes that are not exposed by the file-reading-and-writing
    APIs. We cannot use the APIs of [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams*, to determine the ownership of a file, or its last-modified date;
    nor can we determine the number of files in a given directory. The purpose of
    `<filesystem>` is to allow our C++ programs to interact with these *filesystem*
    attributes in a portable, cross-platform way.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，POSIX文件描述符、`<stdio.h>` 和 `<iostream>` 都与磁盘上文件（或任何地方）的 *内容* 有关，具体来说，是与构成文件
    *内容* 的字节序列有关。在 *文件系统* 意义上的文件有许多显著的属性，这些属性并未通过文件读取和写入API暴露出来。我们不能使用[第9章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d)的API，即
    *Iostreams*，来确定文件的所有权或其最后修改日期；也不能确定给定目录中的文件数量。《<filesystem>`的目的就是允许我们的C++程序以可移植、跨平台的方式与这些
    *文件系统* 属性交互。
- en: 'Let''s begin again. What is a filesystem? A filesystem is an abstract mapping
    from *paths* to *files*, by means of *directory* *entries*. Perhaps a diagram
    will help, if you take it with a large grain of salt:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次开始。什么是文件系统？文件系统是通过 *路径* 到 *文件* 的 *目录条目* 的抽象映射。如果你能以宽容的心态看待，也许一个图表会帮到你：
- en: '![](img/00025.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: 'At the top of the preceding diagram, we have the somewhat abstract world of
    "names." We have a mapping from those names (such as `speech.txt`) onto concrete
    structures that POSIX calls *inodes*. The term "inode" is not used by the C++
    standard--it uses the generic term "file"--but I will try to use the term inode
    when I want to be precise. Each inode contains a full set of attributes describing
    a single file on disk: its owner, its date of last modification, its *type*, and
    so on. Most importantly, the inode also tells exactly how big the file is, and
    gives a pointer to its actual contents (similarly to how a `std::vector` or `std::list`
    holds a pointer to *its* contents). The exact representation of inodes and blocks
    on disk depends on what kind of filesystem you''re running; names of some common
    filesystems include ext4 (common on Linux), HFS+ (on OS X), and NTFS (on Windows).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图的最上方，我们有一个相对抽象的“名称”世界。我们有一个从那些名称（如 `speech.txt`）到POSIX称为 *inode* 的具体结构的映射。术语“inode”在C++标准中并未使用——它使用通用术语“文件”——但当我需要精确时，我会尝试使用inode这个术语。每个inode包含一组完整的属性，描述磁盘上的单个文件：其所有者、其最后修改日期、其
    *类型* 等。最重要的是，inode还确切地说明了文件的大小，并提供了一个指向其实际内容的指针（类似于`std::vector`或`std::list`持有指向其内容的指针）。inode和块在磁盘上的确切表示取决于你运行的是哪种类型的文件系统；一些常见文件系统的名称包括ext4（在Linux上常见）、HFS+（在OS
    X上）和NTFS（在Windows上）。
- en: Notice that a few of the blocks in that diagram hold data that is just a tabular
    mapping of *names* to *inode numbers*. This brings us full circle! A *directory*
    is just an inode with a certain *type*, whose contents are a tabular mapping of
    names to inode numbers. Each filesystem has one special well-known inode called
    its *root directory*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到图中的一些块包含的数据只是将 *名称* 映射到 *inode编号* 的表格映射。这让我们回到了起点！一个 *目录* 只是一个具有特定 *类型* 的inode，其内容是名称到inode编号的表格映射。每个文件系统都有一个特殊的、众所周知的inode，称为其
    *根目录*。
- en: 'Suppose that the inode labeled "`2`" in our diagram is the *root directory*.
    Then we can unambiguously identify the file containing "Now is the time..." by
    a path of names that leads from the root directory down to that file. For example,
    `/My Documents/speech.txt` is such a path: starting from the root directory, `My
    Documents` maps to inode 42, which is a directory where `speech.txt` maps to inode
    17, which is a normal file whose contents on disk are "Now is the time...". We
    use slashes to compose these individual names into a single path, and we put a
    single slash on the front to indicate that we''re starting from the root directory.
    (In Windows, each partition or drive has a separate root directory. So, instead
    of writing just `/My Documents/speech.txt`, we might write `c:/My Documents/speech.txt`
    to indicate that we''re starting from drive C''s root directory.)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们图中的inode标签为"`2`"的是*根目录*。那么我们可以明确地通过一系列从根目录到该文件的名称路径来识别包含"现在是时候..."的文件。例如，`/My
    Documents/speech.txt`就是这样一条路径：从根目录开始，`My Documents`映射到inode 42，这是一个包含`speech.txt`映射到inode
    17的目录，它是一个包含磁盘上内容为"现在是时候..."的普通文件。我们使用斜杠将这些单个名称组合成一个路径，并在前面加上一个斜杠以表示我们从根目录开始。（在Windows中，每个分区或驱动器都有一个独立的根目录。因此，我们可能写成`c:/My
    Documents/speech.txt`来表示我们从驱动器C的根目录开始。）
- en: Alternatively, "`/alices-speech.txt`" is a path leading straight from the root
    directory to inode 17\. We say that these two paths ("`/My Documents/speech.txt`"
    and "`/alices-speech.txt`") are both *hard*-*links* for the same underlying inode,
    which is to say, the same underlying *file*. Some filesystems (such as the FAT
    filesystem used by many USB sticks) do not support having multiple hard links
    to the same file. When multiple hard links *are* supported, the filesystem must
    count the number of references to each inode so that it knows when it's safe to
    delete and free up an inode--in a procedure exactly analogous to the `shared_ptr`
    reference-counting we saw in [Chapter 6](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d),
    *Smart Pointers*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，"`/alices-speech.txt`" 是从根目录直接指向inode 17的路径。我们说这两个路径（"`/My Documents/speech.txt`"
    和 "`/alices-speech.txt`"）都是对同一底层inode的*硬链接*，也就是说，对同一底层*文件*的链接。某些文件系统（例如许多USB闪存驱动器使用的FAT文件系统）不支持对同一文件有多个硬链接。当支持多个硬链接时，文件系统必须计算每个inode的引用次数，以便知道何时可以安全地删除和释放inode--这个过程与我们在[第6章](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d)中看到的`shared_ptr`引用计数过程完全类似，即*智能指针*。
- en: When we ask a library function such as `open` or `fopen` to "open a file," this
    is the process it's going through deep down in the innards of the filesystem.
    It takes the filename you gave it and treats it as a *path*--splits it up at the
    slashes, and descends into the directory structure of the filesystem until it
    finally reaches the inode of the file you asked for (or until it hits a dead end).
    Notice that once we have reached the inode, there is no longer any sense in asking
    "What is the name of this file?", as it has at least as many names as there are
    hard-links to it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求库函数（如`open`或`fopen`）"打开文件"时，这就是它在文件系统内部深处所经历的过程。它接受你给出的文件名并将其视为*路径*--在斜杠处将其拆分，并进入文件系统的目录结构，直到最终到达你请求的文件的inode（或者直到它遇到死胡同）。请注意，一旦我们到达inode，就不再有意义地问"这个文件的名称是什么？"，因为它至少有与它的硬链接一样多的名称。
- en: Representing paths in C++
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中表示路径
- en: Throughout [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams*, every function that expected a "filename" (that is, a path) as a
    parameter was happy to take that path as a simple const char `*`. But in the `<filesystem>`
    library, we're going to complicate that picture, all because of Windows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d)的*Iostreams*中，每个期望参数为"文件名"（即路径）的函数都乐于接受这个路径作为一个简单的const
    char `*`。但在`<filesystem>`库中，我们将因为Windows而使这个情况复杂化。
- en: All POSIX filesystems store names (like `speech.txt`) as simple raw byte strings.
    The only rules in POSIX are that your names can't contain `'\0'`, and your names
    can't contain `'/'` (because that's the character we're going to split on). On
    POSIX, `"\xC1.h"` is a perfectly valid filename, despite the fact that it is *not*
    valid UTF-8 and *not* valid ASCII, and the way it'll display on your screen when
    you `ls .` is completely dependent on your current locale and codepage. After
    all, it's just a string of three bytes, none of which are `'/'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有POSIX文件系统都将名称（如`speech.txt`）存储为简单的原始字节字符串。POSIX中的唯一规则是，你的名称不能包含`'\0'`，并且你的名称不能包含`'/'`（因为这是我们将要分割的字符）。在POSIX中，`"\xC1.h"`是一个完全有效的文件名，尽管它**不是**有效的UTF-8，**不是**有效的ASCII，并且当你`ls
    .`时它在屏幕上的显示完全取决于你的当前区域设置和代码页。毕竟，它只是一个由三个字节组成的字符串，其中没有一个字节是`'/'`。
- en: 'On the other hand, Window''s native file APIs, such as `CreateFileW`, always
    store names as UTF-16\. This means that, by definition, paths in Windows are always
    valid Unicode strings. This is a major philosophical difference between POSIX
    and NTFS! Let me say it again, slowly: In POSIX, file names are *strings of bytes*.
    In Windows, file names are *strings of Unicode characters*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Windows的本地文件API，例如`CreateFileW`，总是以UTF-16存储名称。这意味着，根据定义，Windows中的路径始终是有效的Unicode字符串。这是POSIX和NTFS之间的一大哲学差异！让我再慢一点说一遍：在POSIX中，文件名是**字节字符串**。在Windows中，文件名是**Unicode字符字符串**。
- en: 'If you follow the general principle from [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams* that everything in the world should be encoded with UTF-8, then the
    difference between POSIX and Windows will be manageable--maybe, even negligible.
    But if you are ever required to debug problems with strangely named files on one
    or the other system, keep in mind: In POSIX, filenames are strings of bytes. In
    Windows, filenames are strings of characters.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循第9章中的一般原则[第9章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d)，即世界上所有东西都应该使用UTF-8编码，那么POSIX和Windows之间的差异将是可管理的——也许甚至可以忽略不计。但如果你需要在某个系统上调试具有奇怪名称的文件的问题，请记住：在POSIX中，文件名是字节字符串。在Windows中，文件名是字符字符串。
- en: 'Since Windows APIs expect UTF-16 strings (`std::u16string`) and POSIX APIs
    expect byte strings (`std::string`), neither representation is exactly appropriate
    for a cross-platform library. So, `<filesystem>` invents a new type: `fs::path`.
    (Recall that we''re using our namespace alias throughout this chapter. That''s
    `std::filesystem::path` in reality.) `fs::path` looks something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Windows API期望UTF-16字符串（`std::u16string`）和POSIX API期望字节字符串（`std::string`），这两种表示方法对于跨平台库来说都不是完全合适的。因此，`<filesystem>`发明了一个新的类型：`fs::path`。（回想一下，在本章中我们使用的是我们的命名空间别名。实际上，那就是`std::filesystem::path`。）`fs::path`看起来像这样：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that `fs::path::value_type` is `wchar_t` in Windows, even though C++11's
    UTF-16 character type `char16_t` would be more appropriate. This is just an artifact
    of the library's historical roots in Boost, which dates back to before C++11\.
    In this chapter, whenever we talk about `wchar_t`, you can assume we're talking
    about UTF-16, and vice versa.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Windows中`fs::path::value_type`是`wchar_t`，尽管C++11的UTF-16字符类型`char16_t`可能更合适。这仅仅是库历史根源在Boost中的体现，Boost的历史可以追溯到C++11之前。在本章中，每当提到`wchar_t`时，你可以假设我们在谈论UTF-16，反之亦然。
- en: To write portable code, pay attention to the return type of any function you
    use to convert an `fs::path` to a string. For example, notice that the return
    type of `path.c_str()` is not the const char `*`--it's const value_type `*`!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写可移植的代码，请注意你使用的任何将`fs::path`转换为字符串的函数的返回类型。例如，请注意`path.c_str()`的返回类型不是const
    char `*`——它是const value_type `*`！
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding example, case `c`, is guaranteed to compile, but its behavior
    differs on the two platforms: in POSIX platforms, it''ll give you the raw byte-string
    you want, and in Windows, it''ll expensively convert `path.native()` from UTF-16
    to UTF-8 (which is exactly what you asked for--but your program might be faster
    if you found a way to avoid asking).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例，情况`c`，保证可以编译，但在两个平台上的行为不同：在POSIX平台上，它会给你想要的原始字节字符串，而在Windows上，它会昂贵地将`path.native()`从UTF-16转换为UTF-8（这正是你要求的——但如果你找到了避免请求的方法，你的程序可能会更快）。
- en: '`fs::path` has a templated constructor that can construct a `path` from just
    about any argument. The argument can be a sequence of any character type (`char`,
    `wchar_t`, `char16_t`, or `char32_t`), and that sequence can be expressed as a
    pointer to a null-terminated string, an *iterator* to a null-terminated string,
    a `basic_string`, a `basic_string_view`, or an iterator-pair. As usual, I mention
    this huge variety of overloads not because you''ll want to use any of them beyond
    the basics, but so that you''ll know how to avoid them.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs::path` 有一个模板构造函数，可以从几乎任何参数构建一个 `path`。参数可以是任何字符类型的序列（`char`、`wchar_t`、`char16_t`
    或 `char32_t`），并且该序列可以表示为指向空终止字符串的指针、空终止字符串的 *迭代器*、`basic_string`、`basic_string_view`
    或迭代器对。像往常一样，我提到这种大量的重载不是因为你想要使用它们中的任何一个，而是让你知道如何避免它们。'
- en: The standard also provides the free function `fs::u8path("path")`, which is
    just a synonym for `fs::path("path")`, but might serve as a reminder that the
    string you're passing in is supposed to be UTF-8-encoded. I recommend ignoring
    `u8path`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标准还提供了一个自由函数 `fs::u8path("path")`，它是 `fs::path("path")` 的同义词，但可能作为提醒，你传递的字符串应该是
    UTF-8 编码的。我建议忽略 `u8path`。
- en: This all might sound scarier than it is. Bear in mind that if you stick to ASCII
    filenames, you won't need to worry about encoding issues; and if you remember
    to avoid the "native" accessor methods, `path.native()` and `path.c_str()`, and
    avoid the implicit conversion to `fs::path::string_type`, then you won't have
    to worry too much about portability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切可能听起来比实际情况要可怕。请记住，如果你坚持使用ASCII文件名，你就不必担心编码问题；如果你记得避免使用“本地”访问器方法，`path.native()`
    和 `path.c_str()`，以及避免隐式转换为 `fs::path::string_type`，那么你就不必过于担心可移植性。
- en: Operations on paths
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径操作
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, for example, given the path `p = "c:/foo/hello.txt"`, we have `p.root_name()
    == "c:"`, `p.root_directory() == "/"`, `p.relative_path() == "foo/hello.txt"`,
    `p.stem() == "hello"`, and `p.extension() == ".txt"`. At least, that's what we'd
    have in Windows! Notice that in Windows, an absolute path requires both a root
    name and a root directory (neither "`c:foo/hello.txt`" nor "`/foo/hello.txt`"
    is an absolute path), whereas, in POSIX, where root names don't exist, an absolute
    path requires only a root directory ("`/foo/hello.txt`" is an absolute path, and
    "`c:foo/hello.txt`" is a relative path that starts with the funny-looking directory
    name "`c:foo`").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定路径 `p = "c:/foo/hello.txt"`，我们有 `p.root_name() == "c:"`，`p.root_directory()
    == "/"`，`p.relative_path() == "foo/hello.txt"`，`p.stem() == "hello"`，和 `p.extension()
    == ".txt"`。至少，在 Windows 上是这样的！请注意，在 Windows 上，绝对路径需要根名称和根目录（`"c:foo/hello.txt"`
    或 `"/foo/hello.txt"` 都不是绝对路径），而在 POSIX 中，由于不存在根名称，绝对路径只需要根目录（`"/foo/hello.txt"`
    是绝对路径，而 `"c:foo/hello.txt"` 是以奇怪目录名称 `"c:foo"` 开头的相对路径）。
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Paths also support concatenation with and without slashes under the confusing
    member-function names `path.concat("foo")` (without slash) and `path.append("foo")`(with
    slash). Beware that this is exactly backwards from what you'd expect! Therefore,
    I strongly advise never to use the named member functions; always use the operators
    (perhaps including your custom-defined `operator+` as described in the preceding
    code).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 路径还支持在令人困惑的成员函数名 `path.concat("foo")`（不带斜杠）和 `path.append("foo")`(带斜杠) 下进行带斜杠和不带斜杠的连接。请注意，这与你的预期正好相反！因此，我强烈建议永远不要使用命名成员函数；始终使用运算符（可能包括你在前面代码中描述的自定义定义的
    `operator+`）。
- en: 'The last potentially confusing thing about `fs::path` is that it provides `begin`
    and `end` methods, just like `std::string`. But unlike `std::string`, the unit
    of iteration is not the single character--the unit of iteration is the *name*!
    This is seen in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `fs::path` 的最后一个可能令人困惑的问题是，它提供了 `begin` 和 `end` 方法，就像 `std::string` 一样。但与
    `std::string` 不同，迭代的单位不是单个字符——迭代的单位是 *名称*！这在以下示例中可以看到：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You'll never have a reason to iterate over an absolute `fs::path` in real code.
    Iterating over `p.relative_path().parent_path()`--where every iterated element
    is guaranteed to be a directory name--might have some value in unusual circumstances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，你永远不会有一个迭代绝对 `fs::path` 的理由。在 `p.relative_path().parent_path()` 上迭代——其中每个迭代的元素都保证是目录名称——在特殊情况下可能有一些价值。
- en: Statting files with directory_entry
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 directory_entry 检查文件状态
- en: Beware! `directory_entry` is the most bleeding-edge part of the C++17 `<filesystem>`
    library. What I am about to describe is neither implemented by Boost, nor by `<experimental/filesystem>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！`directory_entry` 是 C++17 `<filesystem>` 库中最前沿的部分。我即将描述的内容既不是由 Boost 实现的，也不是由
    `<experimental/filesystem>` 实现的。
- en: Retrieving a file's metadata from its inode is done by querying an object of
    type `fs::directory_entry`. If you're familiar with the POSIX approach to retrieving
    metadata, imagine that a `fs::directory_entry` contains a member of `type fs::path`
    and a member of type `std::optional<struct stat>`. Calling `entry.refresh()` is,
    basically, the same thing as calling the POSIX function `stat()`; and calling
    any `accessor` method, such as `entry.file_size()`, will implicitly call `stat()`
    if and only if the optional member is still disengaged. Merely constructing an
    instance of `fs::directory_entry` won't query the filesystem; the library waits
    until you ask a specific question before it acts. Asking a specific question,
    such as `entry.file_size()`, may cause the library to query the filesystem, or
    (if the optional member is already engaged) it might just use the cached value
    from the last time it queried.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件的inode中检索文件元数据是通过查询类型为`fs::directory_entry`的对象来完成的。如果你熟悉POSIX方法来检索元数据，想象一下`fs::directory_entry`包含一个`type
    fs::path`类型的成员和一个`type std::optional<struct stat>`类型的成员。调用`entry.refresh()`基本上等同于调用POSIX函数`stat()`；调用任何`accessor`方法，例如`entry.file_size()`，如果可选成员仍然未连接，则会隐式调用`stat()`；如果可选成员已经连接，则可能只是使用上次查询时缓存的值。仅仅构造一个`fs::directory_entry`实例并不会查询文件系统；库会在你提出具体问题之前保持等待。提出具体问题，例如`entry.file_size()`，可能会使库查询文件系统，或者（如果可选成员已经连接）它可能只是使用上次查询时缓存的值。
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An older way to accomplish the same goal is to use `fs::status("path")` or
    `fs::symlink_status("path")` to retrieve an instance of the class `fs::file_status`,
    and then to pull information out of the `file_status` object via cumbersome operations
    such as `status.type() == fs::file_type::directory`. I recommend you not try to
    use `fs::file_status`; prefer to use `entry.is_directory()` and so on. For the
    masochistic, you can still retrieve a `fs::file_status` instance directly from
    a `directory_entry`: `entry.status()` is the equivalent of `fs::status(entry.path())`,
    and `entry.symlink_status()` is the equivalent of `fs::symlink_status(entry.path())`,
    which, in turn, is a slightly faster equivalent of'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同目标的一种较老的方法是使用`fs::status("path")`或`fs::symlink_status("path")`来检索`fs::file_status`类的实例，然后通过诸如`status.type()
    == fs::file_type::directory`之类的繁琐操作从`file_status`对象中提取信息。我建议你不要尝试使用`fs::file_status`；最好使用`entry.is_directory()`等。对于喜欢自虐的人，你仍然可以直接从`directory_entry`中检索`fs::file_status`实例：`entry.status()`等同于`fs::status(entry.path())`，而`entry.symlink_status()`等同于`fs::symlink_status(entry.path())`，这反过来又是一个稍微快一点的等效操作。
- en: '`fs::status(entry.is_symlink() ? fs::read_symlink(entry.path()) : entry.path())`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs::status(entry.is_symlink() ? fs::read_symlink(entry.path()) : entry.path())`.'
- en: Incidentally, the free function `fs::equivalent(p, q)` can tell you if two paths
    are both hard-linked to the same inode; and `entry.hard_link_count()` can tell
    you the total number of hard-links to this particular inode. (The only way to
    determine the *names* of those hard-links is to walk the entire filesystem; and
    even then, your current user account might not have the permission to stat those
    paths.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，自由函数`fs::equivalent(p, q)`可以告诉你两个路径是否都硬链接到同一个inode；而`entry.hard_link_count()`可以告诉你这个特定inode的总硬链接数。（确定那些硬链接的*名称*的唯一方法是在整个文件系统中进行遍历；即使如此，你的当前用户账户可能没有权限对这些路径进行`stat`操作。）
- en: Walking directories with directory_iterator
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用directory_iterator遍历目录
- en: 'A `fs::directory_iterator` is just what it says on the tin. An object of this
    type lets you walk the contents of a single directory, entry by entry:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs::directory_iterator`正是其名字所暗示的。这种类型的对象允许你逐个条目地遍历单个目录的内容：'
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Incidentally, notice the use of `entry.path().string()` in the preceding code.
    This is required, because `operator<<` acts extremely bizarrely on path objects--it
    always outputs as if you'd written `std::quoted(path.string())`. If you want the
    path itself, with no extra quotes, you always have to convert to `std::string`
    before outputting. (Similarly, `std::cin >> path` won't work to get a path from
    the user, but that's less obnoxious, since you should never use `operator>>` anyway.
    See [Chapters 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d), *Iostreams*,
    and [Chapter 10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d), *Regular
    Expressions*, for more information on lexing and parsing input from the user.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Recursive directory walking
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recurse down a whole directory tree, in the style of Python''s `os.walk()`,
    you can use this recursive function modeled on the previous code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or, you can simply use a `fs::recursive_directory_iterator`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The constructor of `fs::recursive_directory_iterator` can take an extra argument
    of type `fs::directory_options`, which modifies the exact nature of the recursion.
    For example, you can pass `fs::directory_options::follow_directory_symlink` to
    follow symlinks, although this is a good way to wind up in an infinite loop if
    a malicious user creates a symlink pointing back to its own parent directory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the filesystem
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the `<filesystem>` header''s facilities are concerned with examining
    the filesystem, not modifying it. But there are several gems hidden in the rubble.
    Many of these functions seem designed to make the effects of the classic POSIX
    command-line utilities available in portable C++:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '`fs::copy_file(old_path, new_path)` : Copy the file at `old_path` to a new
    file (that is, a new inode) at `new_path`, as if by `cp -n`. Error if `new_path`
    already exists.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::copy_file(old_path, new_path, fs::copy_options::overwrite_existing)`:
    Copy `old_path` to `new_path`. Overwrite `new_path` if possible. Error if `new_path`
    exists and is not a regular file, or if it''s the same as `old_path`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::copy_file(old_path, new_path, fs::copy_options::update_existing)`: Copy
    `old_path` to `new_path`. Overwrite `new_path` if and only if it''s older than
    the file at `old_path`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::copy(old_path, new_path, fs::copy_options::recursive | fs::copy_options::copy_symlinks)`:
    Copy an entire directory from `old_path` to `new_path` as if by `cp -R`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::create_directory(new_path)`: Create a directory as if by `mkdir`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::create_directories(new_path)`: Create a directory as if by mkdir `-p`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::create_directory(new_path, old_path)` (notice the reversal of the arguments!):
    Create a directory, but copy its attributes from those of the directory at `old_path`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::create_symlink(old_path, new_path)`: Create a symlink from `new_path`
    to `old_path`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::remove(path)`: Remove a file or an empty directory as if by `rm`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::remove_all(path)`: Remove a file or directory as if by `rm -r`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs::rename(old_path, new_path)`: Rename a file or directory as if by `mv`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs::rename(old_path, new_path)`: 通过 `mv` 重命名文件或目录。'
- en: '`fs::resize_file(path, new_size)`: Extend (with zeroes) or truncate a regular
    file.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs::resize_file(path, new_size)`: 通过零扩展或截断常规文件。'
- en: Reporting disk usage
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告磁盘使用情况
- en: 'Speaking of classic command-line utilities, one final thing we might want to
    do with a filesystem is ask how full it is. This is the domain of the command-line
    utility `df -h` or the POSIX library function `statvfs`. In C++17, we can do it
    with `fs::space("path")`, which returns (by value) a struct of type `fs::space_info`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 说到经典的命令行工具，我们可能还想要对文件系统做的一件事是询问它有多满。这是命令行工具 `df -h` 或 POSIX 库函数 `statvfs` 的领域。在
    C++17 中，我们可以使用 `fs::space("path")` 来实现，它返回一个类型为 `fs::space_info` 的结构体：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Each of these fields is measured in bytes, and we should have `available <=
    free <= capacity`. The distinction between `available` and `free` has to do with
    user limits: On some filesystems, a portion of the free space might be reserved
    for the root user, and on others, there might be per-user-account disk quotas.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些字段都是以字节为单位的，我们应该有 `available <= free <= capacity`。`available` 和 `free` 之间的区别与用户限制有关：在一些文件系统中，一部分空闲空间可能被保留给root用户，而在其他系统中，可能会有每个用户账户的磁盘配额。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Use namespace aliases to save typing, and to allow dropping in alternative implementations
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间别名以节省输入，并允许使用替代实现
- en: of a library namespace, such as Boost.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 库命名空间，例如 Boost。
- en: '`std::error_code` provides a very neat way to pass integer error codes up the
    stack without exception handling; consider using it if you work in a domain where
    exception handling is frowned upon. (In which case, that is likely *all* you will
    be able to take away from this particular chapter! The `<filesystem>` library
    provides both throwing and non-throwing APIs; however, both APIs use the heap-allocating
    (and, potentially, throwing `fs::path` as a vocabulary type. The only reason to
    use the non-throwing API is if it eliminates a case of "using exceptions for control
    flow.)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::error_code` 提供了一种非常巧妙的方式来向上传递整数错误代码，而不需要异常处理；如果你在一个不赞成异常处理的领域中工作，请考虑使用它。（在这种情况下，这可能是你从这个特定章节中能得到的唯一东西！`<filesystem>`
    库提供了抛出异常和非抛出异常的 API；然而，两个 API 都使用堆分配（并且可能抛出 `fs::path` 作为词汇类型。使用非抛出 API 的唯一原因是在某些情况下消除“使用异常进行控制流”的情况。）'
- en: '`std::error_condition` provides only syntactic sugar for "catching" error codes;
    avoid it like the plague.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::error_condition` 只提供了“捕获”错误代码的语法糖；像瘟疫一样避免使用它。'
- en: A `path` consists of a `root_name`, a `root_directory`, and a `relative_path`;
    the last of these is made up of *names* separated by slashes. To POSIX, a *name*
    is a string of raw bytes; to Windows, a *name* is a string of Unicode characters.
    The `fs::path` type attempts to use the appropriate kind of string for each platform.
    To avoid portability problems, beware of `path.c_str()` and implicit conversions
    to `fs::path::string_type`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `path` 由一个 `root_name`、一个 `root_directory` 和一个 `relative_path` 组成；最后一个是由斜杠分隔的
    `names`。对于 POSIX，一个 `name` 是一串原始字节；对于 Windows，一个 `name` 是一串 Unicode 字符。`fs::path`
    类型试图为每个平台使用适当的字符串类型。为了避免可移植性问题，请注意 `path.c_str()` 和隐式转换为 `fs::path::string_type`。
- en: Directories store mappings from *names* to *inodes* (which the C++ standard
    just calls "files"). In C++, you can loop over an `fs::directory_iterator` to
    retrieve `fs::directory_entry` objects; methods on the `fs::directory_entry` allow
    you to query the corresponding inode. Restatting an inode is as simple as calling
    `entry.refresh()`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目录存储从 `names` 到 `inodes` 的映射（C++ 标准将其称为“files”）。在 C++ 中，你可以通过 `fs::directory_iterator`
    循环来检索 `fs::directory_entry` 对象；`fs::directory_entry` 上的方法允许你查询相应的inode。重置inode就像调用
    `entry.refresh()` 一样简单。
- en: '`<filesystem>` provides a whole zoo of free functions for creating, copying,
    renaming, removing, and resizing files and directories, and one last function
    to get the total capacity of the filesystem.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`<filesystem>` 提供了一系列用于创建、复制、重命名、删除和调整文件和目录大小的免费函数，以及一个用于获取文件系统总容量的最后函数。'
- en: Much of what was discussed in this chapter (the `<filesystem>` parts, at least)
    is bleeding-edge C++17 that, as of press time, has not been implemented by any
    compiler vendor. Use such new features with caution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的大部分内容（至少是 `<filesystem>` 部分）都是 C++17 的前沿技术，截至出版时，任何编译器供应商都没有实现。使用这些新功能时请谨慎。
