["```cpp\n sudo apt-get update sudo apt-get dist-upgrade\n\n```", "```cpp\n       sudo apt-get install libglm-dev graphviz libxcb-dri3-0 \n       libxcb-present0 libpciaccess0 cmake libpng-dev libxcb-dri3-\n       dev libx11-dev\n\n```", "```cpp\n       chmod ugo+x vulkansdk-linux-x86_64-<version>.run\n\n```", "```cpp\n       ./vulkansdk-linux-x86_64-<version>.run\n\n```", "```cpp\n sudo su VULKAN_SDK=$PWD/x86_64\n echo export PATH=$PATH:$VULKAN_SDK/bin >> /etc/environment\n echo export VK_LAYER_PATH=$VULKAN_SDK/etc/explicit_layer.d >> \n      /etc/environment\n echo $VULKAN_SDK/lib >> /etc/ld.so.conf.d/vulkan.conf\n ldconfig\n\n```", "```cpp\n              setx VK_INSTANCE_LAYERS \n              VK_LAYER_LUNARG_standard_validation\n\n```", "```cpp\n              export\n              VK_INSTANCE_LAYERS=VK_LAYER_LUNARG_standard_validation\n\n```", "```cpp\nsetx VK_INSTANCE_LAYERS VK_LAYER_LUNARG_api_dump;VK_LAYER_LUNARG_core_validation\n\n```", "```cpp\nexport VK_INSTANCE_LAYERS=VK_LAYER_LUNARG_api_dump:VK_LAYER_LUNARG _core_validation\n\n```", "```cpp\n#if defined _WIN32 \nvulkan_library = LoadLibrary( \"vulkan-1.dll\" ); \n#elif defined __linux \nvulkan_library = dlopen( \"libvulkan.so.1\", RTLD_NOW ); \n#endif \n\nif( vulkan_library == nullptr ) { \n  std::cout << \"Could not connect with a Vulkan Runtime library.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\n      #ifndef EXPORTED_VULKAN_FUNCTION \n      #define EXPORTED_VULKAN_FUNCTION( function ) \n      #endif \n\n      #undef EXPORTED_VULKAN_FUNCTION \n      // \n      #ifndef GLOBAL_LEVEL_VULKAN_FUNCTION \n      #define GLOBAL_LEVEL_VULKAN_FUNCTION( function ) \n      #endif \n\n      #undef GLOBAL_LEVEL_VULKAN_FUNCTION \n      // \n      #ifndef INSTANCE_LEVEL_VULKAN_FUNCTION \n      #define INSTANCE_LEVEL_VULKAN_FUNCTION( function ) \n      #endif \n\n      #undef INSTANCE_LEVEL_VULKAN_FUNCTION \n      // \n      #ifndef INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION \n      #define INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( function,       extension ) \n      #endif \n\n      #undef INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION \n      // \n      #ifndef DEVICE_LEVEL_VULKAN_FUNCTION \n      #define DEVICE_LEVEL_VULKAN_FUNCTION( function ) \n      #endif \n\n      #undef DEVICE_LEVEL_VULKAN_FUNCTION \n      // \n      #ifndef DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION \n      #define DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( function,\n      extension ) \n      #endif \n\n      #undef DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION\n\n```", "```cpp\n      #include \"vulkan.h\" \n\n      namespace VulkanCookbook { \n\n      #define EXPORTED_VULKAN_FUNCTION( name ) extern PFN_##name name; \n      #define GLOBAL_LEVEL_VULKAN_FUNCTION( name ) extern PFN_##name \n      name; \n      #define INSTANCE_LEVEL_VULKAN_FUNCTION( name ) extern PFN_##name \n      name; \n      #define INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( name,\n      extension ) extern PFN_##name name; \n      #define DEVICE_LEVEL_VULKAN_FUNCTION( name ) extern PFN_##name \n      name; \n      #define DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( name, \n      extension ) extern PFN_##name name; \n\n      #include \"ListOfVulkanFunctions.inl\" \n\n      } // namespace VulkanCookbook\n\n```", "```cpp\n      #include \"VulkanFunctions.h\" \n\n      namespace VulkanCookbook { \n\n      #define EXPORTED_VULKAN_FUNCTION( name ) PFN_##name name; \n      #define GLOBAL_LEVEL_VULKAN_FUNCTION( name ) PFN_##name name; \n      #define INSTANCE_LEVEL_VULKAN_FUNCTION( name ) PFN_##name name; \n      #define INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( name, \n      extension ) PFN_##name name; \n      #define DEVICE_LEVEL_VULKAN_FUNCTION( name ) PFN_##name name; \n      #define DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( name, \n      extension ) PFN_##name name; \n\n      #include \"ListOfVulkanFunctions.inl\" \n\n      } // namespace VulkanCookbook\n\n```", "```cpp\n#ifndef EXPORTED_VULKAN_FUNCTION \n#define EXPORTED_VULKAN_FUNCTION( function ) \n#endif \n\nEXPORTED_VULKAN_FUNCTION( vkGetInstanceProcAddr ) \n\n#undef EXPORTED_VULKAN_FUNCTION\n\n```", "```cpp\n#if defined _WIN32 \n#define LoadFunction GetProcAddress \n#elif defined __linux \n#define LoadFunction dlsym \n#endif \n\n#define EXPORTED_VULKAN_FUNCTION( name )                          \\\nname = (PFN_##name)LoadFunction( vulkan_library, #name );         \\\nif( name == nullptr ) {                                           \\\n  std::cout << \"Could not load exported Vulkan function named: \"  \\\n    #name << std::endl;                                           \\\n  return false;                                                   \\\n} \n\n#include \"ListOfVulkanFunctions.inl\" \n\nreturn true;\n\n```", "```cpp\n#ifndef GLOBAL_LEVEL_VULKAN_FUNCTION \n#define GLOBAL_LEVEL_VULKAN_FUNCTION( function ) \n#endif \n\nGLOBAL_LEVEL_VULKAN_FUNCTION( vkEnumerateInstanceExtensionProperties ) \nGLOBAL_LEVEL_VULKAN_FUNCTION( vkEnumerateInstanceLayerProperties ) \nGLOBAL_LEVEL_VULKAN_FUNCTION( vkCreateInstance ) \n\n#undef GLOBAL_LEVEL_VULKAN_FUNCTION\n\n```", "```cpp\n#define GLOBAL_LEVEL_VULKAN_FUNCTION( name )                      \\\nname = (PFN_##name)vkGetInstanceProcAddr( nullptr, #name );       \\\nif( name == nullptr ) {                                           \\\n  std::cout << \"Could not load global-level function named: \"     \\\n    #name << std::endl;                                           \\\n  return false;                                                   \\\n} \n\n#include \"ListOfVulkanFunctions.inl\" \n\nreturn true;\n\n```", "```cpp\nuint32_t extensions_count = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkEnumerateInstanceExtensionProperties( nullptr, &extensions_count, nullptr ); \nif( (result != VK_SUCCESS) || \n    (extensions_count == 0) ) { \n  std::cout << \"Could not get the number of Instance extensions.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\navailable_extensions.resize( extensions_count ); \nresult = vkEnumerateInstanceExtensionProperties( nullptr, &extensions_count, &available_extensions[0] ); \nif( (result != VK_SUCCESS) || \n    (extensions_count == 0) ) { \n  std::cout << \"Could not enumerate Instance extensions.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nstd::vector<VkExtensionProperties> available_extensions; \nif( !CheckAvailableInstanceExtensions( available_extensions ) ) { \n  return false; \n} \n\nfor( auto & extension : desired_extensions ) { \n  if( !IsExtensionSupported( available_extensions, extension ) ) { \n    std::cout << \"Extension named '\" << extension << \"' is not supported.\" << std::endl; \n    return false; \n  } \n}\n\n```", "```cpp\nVkApplicationInfo application_info = { \n  VK_STRUCTURE_TYPE_APPLICATION_INFO, \n  nullptr, \n  application_name, \n  VK_MAKE_VERSION( 1, 0, 0 ), \n  \"Vulkan Cookbook\", \n  VK_MAKE_VERSION( 1, 0, 0 ), \n  VK_MAKE_VERSION( 1, 0, 0 ) \n};\n\n```", "```cpp\nVkInstanceCreateInfo instance_create_info = { \n  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, \n  nullptr, \n  0, \n  &application_info, \n  0, \n  nullptr, \n  static_cast<uint32_t>(desired_extensions.size()), \n  desired_extensions.size() > 0 ? &desired_extensions[0] : nullptr \n};\n\n```", "```cpp\nVkResult result = vkCreateInstance( &instance_create_info, nullptr, &instance ); \nif( (result != VK_SUCCESS) || \n    (instance == VK_NULL_HANDLE) ) { \n  std::cout << \"Could not create Vulkan Instance.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\n#ifndef INSTANCE_LEVEL_VULKAN_FUNCTION \n#define INSTANCE_LEVEL_VULKAN_FUNCTION( function ) \n#endif \n\nINSTANCE_LEVEL_VULKAN_FUNCTION( vkEnumeratePhysicalDevices ) \nINSTANCE_LEVEL_VULKAN_FUNCTION( vkGetPhysicalDeviceProperties ) \nINSTANCE_LEVEL_VULKAN_FUNCTION( vkGetPhysicalDeviceFeatures ) \nINSTANCE_LEVEL_VULKAN_FUNCTION( vkCreateDevice ) \nINSTANCE_LEVEL_VULKAN_FUNCTION( vkGetDeviceProcAddr ) \n//... \n\n#undef INSTANCE_LEVEL_VULKAN_FUNCTION \n\n// \n\n#ifndef INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION \n#define INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( function, extension ) \n#endif \n\nINSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkGetPhysicalDeviceSurfaceSupportKHR, VK_KHR_SURFACE_EXTENSION_NAME ) \nINSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkGetPhysicalDeviceSurfaceCapabilitiesKHR, VK_KHR_SURFACE_EXTENSION_NAME ) \nINSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkGetPhysicalDeviceSurfaceFormatsKHR, VK_KHR_SURFACE_EXTENSION_NAME ) \n\n#ifdef VK_USE_PLATFORM_WIN32_KHR \nINSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkCreateWin32SurfaceKHR, VK_KHR_WIN32_SURFACE_EXTENSION_NAME ) \n#elif defined VK_USE_PLATFORM_XCB_KHR \nINSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkCreateXcbSurfaceKHR, VK_KHR_XLIB_SURFACE_EXTENSION_NAME ) \n#elif defined VK_USE_PLATFORM_XLIB_KHR \nINSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkCreateXlibSurfaceKHR, VK_KHR_XCB_SURFACE_EXTENSION_NAME ) \n#endif \n\n#undef INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION\n\n```", "```cpp\n#define INSTANCE_LEVEL_VULKAN_FUNCTION( name )                        \\  \nname = (PFN_##name)vkGetInstanceProcAddr( instance, #name );          \\ \nif( name == nullptr ) {                                               \\ \n  std::cout << \"Could not load instance-level Vulkan function named: \"\\\n    #name << std::endl;                                               \\ \n  return false;                                                       \\ \n} \n\n#include \"ListOfVulkanFunctions.inl\" \n\nreturn true;\n\n```", "```cpp\n#define INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( name, extension )                                                                 \\\nfor( auto & enabled_extension : enabled_extensions ) {            \\\n  if( std::string( enabled_extension ) == std::string( extension ) ) \n{                                                                 \\  \n    name = (PFN_##name)vkGetInstanceProcAddr( instance, #name );  \\\n    if( name == nullptr ) {                                       \\\n      std::cout << \"Could not load instance-level Vulkan function named: \"                                                          \\\n        #name << std::endl;                                       \\\n      return false;                                               \\\n    }                                                             \\\n  }                                                               \\\n} \n\n#include \"ListOfVulkanFunctions.inl\" \n\nreturn true;\n\n```", "```cpp\nuint32_t devices_count = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkEnumeratePhysicalDevices( instance, &devices_count, nullptr ); \nif( (result != VK_SUCCESS) || \n    (devices_count == 0) ) { \n  std::cout << \"Could not get the number of available physical devices.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\navailable_devices.resize( devices_count ); \nresult = vkEnumeratePhysicalDevices( instance, &devices_count, &available_devices[0] ); \nif( (result != VK_SUCCESS) || \n    (devices_count == 0) ) { \n  std::cout << \"Could not enumerate physical devices.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nuint32_t extensions_count = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &extensions_count, nullptr ); \nif( (result != VK_SUCCESS) || \n    (extensions_count == 0) ) { \n  std::cout << \"Could not get the number of device extensions.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\navailable_extensions.resize( extensions_count ); \nresult = vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &extensions_count, &available_extensions[0] ); \nif( (result != VK_SUCCESS) || \n    (extensions_count == 0) ) { \n  std::cout << \"Could not enumerate device extensions.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nvkGetPhysicalDeviceFeatures( physical_device, &device_features ); \n\nvkGetPhysicalDeviceProperties( physical_device, &device_properties );\n\n```", "```cpp\nuint32_t queue_families_count = 0; \n\nvkGetPhysicalDeviceQueueFamilyProperties( physical_device, &queue_families_count, nullptr ); \nif( queue_families_count == 0 ) { \n  std::cout << \"Could not get the number of queue families.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nqueue_families.resize( queue_families_count ); \nvkGetPhysicalDeviceQueueFamilyProperties( physical_device, &queue_families_count, &queue_families[0] ); \nif( queue_families_count == 0 ) { \n  std::cout << \"Could not acquire properties of queue families.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nstd::vector<VkQueueFamilyProperties> queue_families; \nif( !CheckAvailableQueueFamiliesAndTheirProperties( physical_device, queue_families ) ) { \n  return false; \n}\n\n```", "```cpp\nfor( uint32_t index = 0; index < static_cast<uint32_t>(queue_families.size()); ++index ) { \n  if( (queue_families[index].queueCount > 0) && \n      (queue_families[index].queueFlags & desired_capabilities ) ) { \n    queue_family_index = index; \n    return true; \n  } \n} \nreturn false;\n\n```", "```cpp\nstruct QueueInfo { \n  uint32_t           FamilyIndex; \n  std::vector<float> Priorities; \n};\n\n```", "```cpp\nstd::vector<VkExtensionProperties> available_extensions; \nif( !CheckAvailableDeviceExtensions( physical_device, available_extensions ) ) { \n  return false; \n} \n\nfor( auto & extension : desired_extensions ) { \n  if( !IsExtensionSupported( available_extensions, extension ) ) { \n    std::cout << \"Extension named '\" << extension << \"' is not supported by a physical device.\" << std::endl; \n    return false; \n  } \n}\n\n```", "```cpp\nstd::vector<VkDeviceQueueCreateInfo> queue_create_infos; \n\nfor( auto & info : queue_infos ) { \n  queue_create_infos.push_back( { \n    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, \n    nullptr, \n    0, \n    info.FamilyIndex, \n    static_cast<uint32_t>(info.Priorities.size()), \n    info.Priorities.size() > 0 ? &info.Priorities[0] : nullptr \n  } ); \n};\n\n```", "```cpp\nVkDeviceCreateInfo device_create_info = { \n  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(queue_create_infos.size()), \n  queue_create_infos.size() > 0 ? &queue_create_infos[0] : nullptr, \n  0, \n  nullptr, \n  static_cast<uint32_t>(desired_extensions.size()), \n  desired_extensions.size() > 0 ? &desired_extensions[0] : nullptr, \n  desired_features \n};\n\n```", "```cpp\nVkResult result = vkCreateDevice( physical_device, &device_create_info, nullptr, &logical_device ); \nif( (result != VK_SUCCESS) || \n    (logical_device == VK_NULL_HANDLE) ) { \n  std::cout << \"Could not create logical device.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\n#ifndef DEVICE_LEVEL_VULKAN_FUNCTION \n#define DEVICE_LEVEL_VULKAN_FUNCTION( function ) \n#endif \n\nDEVICE_LEVEL_VULKAN_FUNCTION( vkGetDeviceQueue ) \nDEVICE_LEVEL_VULKAN_FUNCTION( vkDeviceWaitIdle ) \nDEVICE_LEVEL_VULKAN_FUNCTION( vkDestroyDevice ) \n\nDEVICE_LEVEL_VULKAN_FUNCTION( vkCreateBuffer ) \nDEVICE_LEVEL_VULKAN_FUNCTION( vkGetBufferMemoryRequirements ) \n// ... \n\n#undef DEVICE_LEVEL_VULKAN_FUNCTION \n\n// \n\n#ifndef DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION \n#define DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( function, extension ) \n#endif \n\nDEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkCreateSwapchainKHR, VK_KHR_SWAPCHAIN_EXTENSION_NAME ) \nDEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkGetSwapchainImagesKHR, VK_KHR_SWAPCHAIN_EXTENSION_NAME ) \nDEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkAcquireNextImageKHR, VK_KHR_SWAPCHAIN_EXTENSION_NAME ) \nDEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkQueuePresentKHR, VK_KHR_SWAPCHAIN_EXTENSION_NAME ) \nDEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( vkDestroySwapchainKHR, VK_KHR_SWAPCHAIN_EXTENSION_NAME ) \n\n#undef DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION\n\n```", "```cpp\n#define DEVICE_LEVEL_VULKAN_FUNCTION( name )                      \\\nname = (PFN_##name)vkGetDeviceProcAddr( device, #name );          \\\nif( name == nullptr ) {                                           \\\n  std::cout << \"Could not load device-level Vulkan function named: \" #name << std::endl;                                      \\\n  return false;                                                   \\\n} \n\n#include \"ListOfVulkanFunctions.inl\" \n\nreturn true;\n\n```", "```cpp\n#define DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION( name, \nextension )                                                         \\         \nfor( auto & enabled_extension : enabled_extensions ) {              \\         \n  if( std::string( enabled_extension ) == std::string( extension )\n ) {                                                                \\  \n    name = (PFN_##name)vkGetDeviceProcAddr( logical_device, #name );\\                                                          \n    if( name == nullptr ) {                                         \\        \n      std::cout << \"Could not load device-level Vulkan function named: \"                                                                   \\  \n        #name << std::endl;                                         \\         \n      return false;                                                 \\         \n    }                                                               \\         \n  }                                                                 \\         \n} \n\n#include \"ListOfVulkanFunctions.inl\" \n\nreturn true;\n\n```", "```cpp\nvkGetDeviceQueue( logical_device, queue_family_index, queue_index, &queue );\n\n```", "```cpp\nstd::vector<VkPhysicalDevice> physical_devices; \nEnumerateAvailablePhysicalDevices( instance, physical_devices );\n\n```", "```cpp\nfor( auto & physical_device : physical_devices ) { \n  VkPhysicalDeviceFeatures device_features; \n  VkPhysicalDeviceProperties device_properties; \n  GetTheFeaturesAndPropertiesOfAPhysicalDevice( physical_device, device_features, device_properties ); \n\n  if( !device_features.geometryShader ) { \n    continue; \n  } else { \n    device_features = {}; \n    device_features.geometryShader = VK_TRUE; \n  }\n\n```", "```cpp\n  uint32_t graphics_queue_family_index; \n  if( !SelectIndexOfQueueFamilyWithDesiredCapabilities( physical_device, VK_QUEUE_GRAPHICS_BIT, graphics_queue_family_index ) ) { \n    continue; \n  } \n\n  uint32_t compute_queue_family_index; \n  if( !SelectIndexOfQueueFamilyWithDesiredCapabilities( physical_device, VK_QUEUE_COMPUTE_BIT, compute_queue_family_index ) ) { \n    continue; \n  }\n\n```", "```cpp\n  std::vector<QueueInfo> requested_queues = { { graphics_queue_family_index, { 1.0f } } }; \n  if( graphics_queue_family_index != compute_queue_family_index ) { \n    requested_queues.push_back( { compute_queue_family_index, { 1.0f } } ); \n  }\n\n```", "```cpp\n  if( !CreateLogicalDevice( physical_device, requested_queues, {}, &device_features, logical_device ) ) { \n    continue; \n  } else { \n    if( !LoadDeviceLevelFunctions( logical_device, {} ) ) { \n      return false; \n    } \n    GetDeviceQueue( logical_device, graphics_queue_family_index, 0, graphics_queue ); \n    GetDeviceQueue( logical_device, compute_queue_family_index, 0, compute_queue ); \n    return true; \n  } \n} \nreturn false;\n\n```", "```cpp\nif( logical_device ) { \n  vkDestroyDevice( logical_device, nullptr ); \n  logical_device = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( instance ) { \n  vkDestroyInstance( instance, nullptr ); \n  instance = VK_NULL_HANDLE; \n}\n\n```", "```cpp\n#if defined _WIN32 \nFreeLibrary( vulkan_library ); \n#elif defined __linux \ndlclose( vulkan_library ); \n#endif \nvulkan_library = nullptr;\n\n```"]