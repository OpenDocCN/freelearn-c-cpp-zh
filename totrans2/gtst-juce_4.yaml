- en: Chapter 4. Using Media Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 使用媒体文件
- en: 'JUCE provides its own classes for reading and writing files and many helper
    classes for specific media formats. This chapter introduces the main examples
    of these classes. In this chapter we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE提供了自己的文件读写类以及许多针对特定媒体格式的辅助类。本章介绍了这些类的主要示例。在本章中，我们将涵盖以下主题：
- en: Using simple input and output streams
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的输入输出流
- en: Reading and writing image files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写图像文件
- en: Playing audio files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频文件
- en: Working with the Binary Builder tool to turn binary files into source code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二进制构建工具将二进制文件转换为源代码
- en: By the end of this chapter, you will be able to manipulate a range of media
    files using JUCE.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用JUCE操作一系列媒体文件。
- en: Using simple input and output streams
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单的输入输出流
- en: In [Chapter 3](ch03.html "Chapter 3. Essential Data Structures"), *Essential
    Data Structures*, we introduced the JUCE `File` class, which is used for specifying
    file paths in a cross-platform manner. In addition, the `File` class includes
    some convenience functions for reading and writing files as blocks of data or
    strings of text. In many cases these functions are sufficient, but in others,
    raw access to input and output streams may be more useful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 基本数据结构")中，我们介绍了JUCE的`File`类，该类用于以跨平台的方式指定文件路径。此外，`File`类还包含一些方便的函数，用于以数据块或文本字符串的形式读写文件。在许多情况下，这些函数是足够的，但在其他情况下，对输入输出流的原始访问可能更有用。
- en: Reading and writing text files
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读写文本文件
- en: 'First, create a console application project in the Introjucer application and
    name it `Chapter04_01`. In this simple example, we will declare two functions,
    one for writing text to the file—`writeFile()` , and one for reading the contents
    of the file—`readFile()` . Each of these functions is passed the same file path
    reference created in the way we did in [Chapter 3](ch03.html "Chapter 3. Essential
    Data Structures"), *Essential Data Structures*. Replace the contents of the `Main.cpp`
    file with the following, where we declare the file reading and writing functions,
    and define a `main()` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Introjucer应用程序中创建一个控制台应用程序项目，并将其命名为`Chapter04_01`。在这个简单的例子中，我们将声明两个函数，一个用于将文本写入文件——`writeFile()`，另一个用于读取文件内容——`readFile()`。这些函数都传递了以我们[第3章](ch03.html
    "第3章. 基本数据结构")中介绍的方式创建的相同文件路径引用。将`Main.cpp`文件的内容替换为以下内容，其中我们声明了文件读写函数，并定义了一个`main()`函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add the definition for the `writeFile()` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`writeFile()`函数的定义：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we create a `FileOutputStream` object, passing it the `File` object that
    refers to the file path. The `FileOutputStream` class inherits from the base class
    `OutputStream` that represents the general notions of writing data to a stream.
    There can be other types of output stream, such as the `MemoryOutputStream` class
    for writing data to areas of computer memory in a stream-like manner. The default
    behavior of the `FileOutputStream` class on construction is to position the stream's
    write position at the end of the file if the file already exists (or to create
    an empty file if it doesn't). The calls to the `FileOutputStream::setPosition()`
    and `FileOutputStream::truncate()` functions effectively empty the file each time
    before we write it. Of course, in a real application you may not want to do this
    each time. The call to the `FileOutputStream::writeText()` function is almost
    equivalent to the `File::appendText()` function, although the flags for controlling
    the output in Unicode UTF16 format are implicit for the `File::appendText()` function,
    but need to be specified explicitly for the `FileOutputStream::writeText()` function.
    Here, we write the data in UTF8 format by setting both flags to `false`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`FileOutputStream`对象，将其传递给指向文件路径的`File`对象。`FileOutputStream`类继承自表示将数据写入流的一般概念的基类`OutputStream`。还可以有其他类型的输出流，例如用于以流式方式将数据写入计算机内存区域的`MemoryOutputStream`类。`FileOutputStream`类在构造时的默认行为是将流的写入位置定位在文件的末尾（如果文件已存在），或者（如果不存在）创建一个空文件。对`FileOutputStream::setPosition()`和`FileOutputStream::truncate()`函数的调用在每次写入之前实际上清空了文件。当然，在实际应用中，你可能不希望每次都这样做。对`FileOutputStream::writeText()`函数的调用几乎等同于`File::appendText()`函数，尽管`File::appendText()`函数的输出控制标志在Unicode
    UTF16格式下是隐式的，但需要显式指定`FileOutputStream::writeText()`函数的标志。在这里，我们通过将两个标志都设置为`false`以UTF8格式写入数据。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The UFT8 format is probably most convenient, because the text we are writing
    is plain ASCII text, which is compatible with UTF8 encoding.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: UFT8格式可能最方便，因为我们正在写入的是纯ASCII文本，它与UTF8编码兼容。
- en: 'Finally, add the definition for the `readFile()` function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`readFile()`函数的定义：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we attempt to read the entire stream into a `String`, and post it to the
    log. We use a `FileInputStream` object, which inherits from the more general `InputStream`
    class. In both the `writeFile()` and `readFile()` functions we check that the
    streams opened successfully before proceeding. In addition to this, the stream
    objects gracefully close the streams when they go out of scope.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试将整个流读取到一个`String`中，并将其记录到日志中。我们使用一个继承自更通用的`InputStream`类的`FileInputStream`对象。在`writeFile()`和`readFile()`函数中，我们在继续之前检查是否成功打开了流。此外，当流超出作用域时，流对象会优雅地关闭流。
- en: Reading and writing binary files
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入二进制文件
- en: The output and input streams can be used for binary data too, and offer much
    greater functionality over the `File` class convenience functions. Here, you can
    write raw numerical data, and choose the byte order for multibyte data types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出和输入流也可以用于二进制数据，并且比`File`类便利函数提供更强大的功能。在这里，您可以写入原始数值数据，并选择多字节数据类型的字节序。
- en: 'Create a new console application in the Introjucer application and name it
    `Chapter04_02`. The following example writes `int`, `float`, and `double` data
    types to a file, and then reads this data back in, posting the result to the log.
    Replace the contents of `Main.cpp` file with the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Introjucer应用程序中创建一个新的控制台应用程序，并将其命名为`Chapter04_02`。以下示例将`int`、`float`和`double`数据类型写入文件，然后读取这些数据，并将结果记录到日志中。将`Main.cpp`文件的内容替换为以下代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `OutputStream` and `InputStream` classes and their respective subclasses,
    support writing and reading the various built-in types using functions `writeInt()`,
    `writeFloat()`, `readInt()`, `readFloat()`, and so on. These versions of the functions
    write these multi-byte types using little endian byte order. For file formats
    requiring big endian storage, there are equivalent functions `writeIntBigEndian()`,
    `writeFloatBigEndian()`, `readIntBigEndian` `()`, `readFloatBigEndian()` , and
    so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`OutputStream`和`InputStream`类及其相应的子类支持使用`writeInt()`、`writeFloat()`、`readInt()`、`readFloat()`等函数写入和读取各种内置类型。这些函数的版本使用小端字节序写入这些多字节类型。对于需要大端存储的文件格式，有等效的函数`writeIntBigEndian()`、`writeFloatBigEndian()`、`readIntBigEndian()`、`readFloatBigEndian()`等。'
- en: The JUCE stream classes are useful but quite low level. For many purposes, JUCE
    already includes high-level classes for reading and writing specific file types.
    Of course, these are built on top of the stream classes, but, unless you are dealing
    with a custom data format, it is likely to be more sensible to use built-in functionality
    for handling things such as images, audio, and other formats such as **Extensible
    Markup Language** (**XML**) and **JavaScript Object Notation** (**JSON**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE流类很有用，但相当底层。对于许多用途，JUCE已经包括用于读取和写入特定文件类型的高级类。当然，这些类建立在流类之上，但除非您处理自定义数据格式，否则使用内置功能处理图像、音频和其他格式（如**可扩展标记语言**（**XML**）和**JavaScript对象表示法**（**JSON**））可能更合理。
- en: Reading and writing image files
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入图像文件
- en: 'JUCE includes built-in support for reading and writing GIF, PNG, and JPEG image
    files. JUCE also includes its own `Image` class for holding bitmap images. The
    following example illustrates how to present a native file browser to choose an
    image file, load the image file, and display it in an `ImageComponent` object.
    Create a new GUI project in the Introjucer application with a basic window named
    `Chapter04_03`. and make the window resizable in the `Main.cpp` file, as we did
    in earlier chapters. You should then change the `MainComponent.h` file to contain:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE包括内置支持读取和写入GIF、PNG和JPEG图像文件。JUCE还包括自己的`Image`类来存储位图图像。以下示例说明如何显示一个本地文件浏览器以选择图像文件，加载图像文件，并在`ImageComponent`对象中显示它。在Introjucer应用程序中创建一个新的GUI项目，并命名为`Chapter04_03`。在`Main.cpp`文件中，将其设置为可调整大小的，就像我们在前面的章节中所做的那样。然后，您应该将`MainComponent.h`文件修改为包含以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change `MainComponent.cpp` to contain:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MainComponent.cpp`修改为包含以下内容：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we create a `FileChooser` object in response to the user clicking on
    the **Read Image File…** button. This presents a native dialog window that allows
    the user to choose a file. We use the `ImageFileFormat::loadFrom()` function to
    attempt to load the file as an image. Because we didn''t limit the file types
    displayed or enabled in the file chooser, the user may not have chosen a valid
    image file. We check the validity of the image, and if it is valid we pass the
    loaded image to the `ImageComponent` object for display. The `ImageComponent`
    class has various options to control the way the image is positioned and scaled,
    depending on how the original image size and component rectangle compare. These
    can be controlled using the `ImageComponent::setImagePlacement()` function. The
    following screenshot shows the application that reads an image file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个 `FileChooser` 对象以响应用户点击 **读取图像文件…** 按钮。这会弹出一个原生对话框，允许用户选择文件。我们使用
    `ImageFileFormat::loadFrom()` 函数尝试将文件作为图像加载。因为我们没有限制文件选择器中显示或启用的文件类型，用户可能没有选择有效的图像文件。我们检查图像的有效性，如果有效，我们将加载的图像传递给
    `ImageComponent` 对象以进行显示。`ImageComponent` 类有各种选项来控制图像的位置和缩放方式，这取决于原始图像大小和组件矩形的比较。这些可以通过使用
    `ImageComponent::setImagePlacement()` 函数来控制。以下截图显示了读取图像文件的程序：
- en: '![Reading and writing image files](img/3316_04_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![读取和写入图像文件](img/3316_04_01.jpg)'
- en: The `Image` class is similar to the `String` class, in that it uses a reference-counted
    object internally such that several `Image` objects may share the same internal
    data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image` 类类似于 `String` 类，因为它在内部使用引用计数的对象，这样几个 `Image` 对象可以共享相同的数据。'
- en: Manipulating image data
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作图像数据
- en: 'In the next example we will add a slider to control the brightness of the displayed
    image and a button to write this processed image as a PNG file. Change the contents
    of the `MainComponent.h` file, where the changes are highlighted in the following
    code listing:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将添加一个滑块来控制显示图像的亮度，并添加一个按钮将此处理后的图像作为 PNG 文件写入。更改 `MainComponent.h`
    文件的内容，以下代码列表中突出显示了更改：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now replace the `MainComponent.cpp` file with the include directive and the
    constructor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用包含指令和构造函数替换 `MainComponent.cpp` 文件：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the `resized()` function that positions the components:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `resized()` 函数以定位组件：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `buttonClicked()` function that responds to the button interactions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加响应按钮交互的 `buttonClicked()` 函数：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, add the `sliderValueChanged()` function that responds to the slider
    interaction:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加响应滑块交互的 `sliderValueChanged()` 函数：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we keep a copy of the original image and a processed version. Each time
    the slider changes, the image is updated with the new brightness by iterating
    over each of the pixels. When the **Write Image File…** button is clicked, we
    create a `FileChooser` object and present this to the user with the `FileChooser::browseForFileToSave()`
    function, rather than the `FileChooser::browseForFileToOpen()` function as we
    did for reading the file. Then the `PNGImageFormat` class is used to write the
    processed image to the selected file as a file stream. The image processing here
    could be significantly optimized, but that is beyond the scope of this book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保留原始图像和经过处理的副本。每次滑块改变时，通过遍历每个像素，图像都会用新的亮度更新。当点击 **写入图像文件…** 按钮时，我们创建一个
    `FileChooser` 对象，并使用 `FileChooser::browseForFileToSave()` 函数将其呈现给用户，而不是像读取文件时那样使用
    `FileChooser::browseForFileToOpen()` 函数。然后使用 `PNGImageFormat` 类将处理后的图像作为文件流写入所选文件。这里的图像处理可以显著优化，但这超出了本书的范围。
- en: Playing audio files
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频文件
- en: 'JUCE provides a sophisticated set of classes for dealing with audio. This includes:
    sound file reading and writing utilities, interfacing with the native audio hardware,
    audio data conversion functions, and a cross-platform framework for creating audio
    plugins for a range of well-known host applications. Covering all of these aspects
    is beyond the scope of this book, but the examples in this section will outline
    the principles of playing sound files and communicating with the audio hardware.
    In addition to showing the audio features of JUCE, in this section we will also
    create the GUI and autogenerate some other aspects of the code using the Introjucer
    application.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE提供了一套复杂的类来处理音频。这包括：声音文件读写工具、与原生音频硬件接口、音频数据转换函数，以及为一系列知名宿主应用程序创建音频插件的跨平台框架。涵盖所有这些方面超出了本书的范围，但本节中的示例将概述播放声音文件和与音频硬件通信的原则。除了展示JUCE的音频功能外，本节我们还将使用Introjucer应用程序创建GUI并自动生成代码的其他一些方面。
- en: Creating a GUI to control audio file play
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于控制音频文件播放的GUI
- en: Create a new GUI application Introjucer project named `Chapter04_04`, selecting
    the option to create a basic window. In the Introjucer application, select the
    **Config** panel, and select **Modules** in the hierarchy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter04_04`的新GUI应用程序Introjucer项目，选择创建基本窗口的选项。在Introjucer应用程序中，选择**配置**面板，并在层次结构中选择**模块**。
- en: For this project we need the `juce_audio_utils` module (which contains a special
    `Component` class for configuring the audio device hardware); therefore, turn
    `ON` this module. Even though we created a basic window and a basic component,
    we are going to create the GUI using the Introjucer application in a similar way
    to that at the end of [Chapter 2](ch02.html "Chapter 2. Building User Interfaces"),
    *Building User Interfaces*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要`juce_audio_utils`模块（其中包含用于配置音频设备硬件的特殊`Component`类）；因此，打开此模块。尽管我们创建了一个基本窗口和一个基本组件，但我们将以与[第2章](ch02.html
    "第2章。构建用户界面")末尾的相同方式使用Introjucer应用程序创建GUI，即*构建用户界面*。
- en: Navigate to the **Files** panel and right-click (on the Mac, press *control*
    and click) on the **Source** folder in the hierarchy, and select **Add New GUI
    Component…** from the contextual menu.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**文件**面板，在层次结构中右键单击（在Mac上，按*control*键并单击）**源**文件夹，然后从上下文菜单中选择**添加新GUI组件…**。
- en: 'When asked, name the header `MediaPlayer.h` and click on **Save**. In the **Files**
    hierarchy, select the `MediaPlayer.cpp` file. First select the **Class** panel
    and change the **Class name** from `NewComponent` to `MediaPlayer`. We will need
    four buttons for this basic project: a button to open an audio file, a **Play**
    button, a **Stop** button, and an audio device settings button. Select the **Subcomponents**
    panel, and add four `TextButton` components to the editor by right-clicking to
    access the contextual menu. Space the buttons equally near the top of the editor,
    and configure each button as outlined in the table as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当被要求时，将头文件命名为`MediaPlayer.h`并点击**保存**。在**文件**层次结构中，选择`MediaPlayer.cpp`文件。首先选择**类**面板，并将**类名**从`NewComponent`更改为`MediaPlayer`。我们在这个基本项目中需要四个按钮：一个用于打开音频文件的按钮、一个**播放**按钮、一个**停止**按钮和一个音频设备设置按钮。选择**子组件**面板，并通过右键单击以访问上下文菜单，向编辑器添加四个`TextButton`组件。将按钮均匀地分布在编辑器顶部附近，并按照以下表格中的说明配置每个按钮：
- en: '| Purpose | member name | name | text | background (normal) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 成员名称 | 名称 | 文本 | 背景（正常） |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Open file | `openButton` | `open` | `Open…` | Default |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 打开文件 | `openButton` | `open` | `打开…` | 默认 |'
- en: '| Play/pause file | `playButton` | `play` | `Play` | Green |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 播放/暂停文件 | `playButton` | `play` | `播放` | 绿色 |'
- en: '| Stop playback | `stopButton` | `stop` | `Stop` | Red |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 停止播放 | `stopButton` | `stop` | `停止` | 红色 |'
- en: '| Configure audio | `settingsButton` | `settings` | `Audio Settings…` | Default
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 配置音频 | `settingsButton` | `settings` | `音频设置…` | 默认 |'
- en: 'Arrange the buttons as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下截图所示排列按钮：
- en: '![Creating a GUI to control audio file play](img/3316_04_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建用于控制音频文件播放的GUI](img/3316_04_02.jpg)'
- en: For each button, access the **mode** pop-up menu for the **width** setting,
    and choose **Subtracted from width of parent**. This will keep the right-hand
    side of the buttons the same distance from the right-hand side of the window if
    the window is resized. There are more customizations to be done in the Introjucer
    project, but for now, make sure that you have saved the `MediaPlayer.h` file,
    the `MediaPlayer.cpp` file, and the Introjucer project before you open your native
    IDE project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个按钮，访问**模式**弹出菜单以设置**宽度**，并选择**从父宽度减去**。如果调整窗口大小，这将保持按钮的右侧与窗口右侧的距离相同。在Introjucer项目中还有更多自定义设置要做，但在此阶段，请确保在打开本机IDE项目之前已保存`MediaPlayer.h`文件、`MediaPlayer.cpp`文件和Introjucer项目。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that you have saved all of these files in the Introjucer application;
    otherwise the files may not get correctly updated in the file system when the
    project is opened in the IDE.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在Introjucer应用程序中已保存所有这些文件；否则，当项目在IDE中打开时，文件可能无法在文件系统中正确更新。
- en: 'In the IDE we need to replace the `MainContentComponent` class code to place
    a `MediaPlayer` object within it. Change the `MainComponent.h` file as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成开发环境（IDE）中，我们需要替换`MainContentComponent`类的代码，以便在其中放置一个`MediaPlayer`对象。按照以下方式修改`MainComponent.h`文件：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, change the `MainComponent.cpp` file to:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改`MainComponent.cpp`文件：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, make the window resizable in the `Main.cpp` file (as we did in the
    *Adding child components* section of [Chapter 2](ch02.html "Chapter 2. Building
    User Interfaces"), *Building User Interfaces*), and build and run the project
    to check that the window appears as expected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Main.cpp`文件中使窗口可调整大小（正如我们在[第2章](ch02.html "第2章。构建用户界面")的*添加子组件*部分所做的那样），构建并运行项目以检查窗口是否按预期显示。
- en: Adding audio file playback support
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加音频文件播放支持
- en: 'Quit the application and return to the `Introjucer` project. Select the `MediaPlayer.cpp`
    file in the **Files** panel hierarchy and select its **Class** panel. The **Parent
    classes** setting already contains `public Component`. We are going to be listening
    for state changes from two of our member objects that are `ChangeBroadcaster`
    objects. To do this, we need our `MediaPlayer` class to inherit from the `ChangeListener`
    class. Change the **Parent classes** setting such that it reads:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 退出应用程序并返回到`Introjucer`项目。在**文件**面板层次结构中选择`MediaPlayer.cpp`文件，并选择其**类**面板。**父类**设置已经包含`public
    Component`。我们将监听来自两个成员对象的状态变化，这两个成员对象是`ChangeBroadcaster`对象。为此，我们需要我们的`MediaPlayer`类继承自`ChangeListener`类。修改**父类**设置，使其读取如下：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save the `MediaPlayer.h` file, the `MediaPlayer.cpp` file, and the `Introjucer`
    project again, and open it into your IDE. Notice in the `MediaPlayer.h` file that
    the parent classes have been updated to reflect this change. For convenience,
    we are going to add some enumerated constants to reflect the current playback
    state of our `MediaPlayer` object, and a function to centralize the change of
    this state (which will, in turn, update the state of various objects, such as
    the text displayed on the buttons). The `ChangeListener` class also has one pure
    virtual function, which we need to add. Add the following code to the `[UserMethods]`
    section of `MediaPlayer.h`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次保存`MediaPlayer.h`文件、`MediaPlayer.cpp`文件和Introjucer项目，并将其打开到您的IDE中。注意在`MediaPlayer.h`文件中，父类已经被更新以反映这一变化。为了方便起见，我们将添加一些枚举常量来反映我们的`MediaPlayer`对象的当前播放状态，以及一个函数来集中更改此状态（这将反过来更新各种对象的状态，例如按钮上显示的文本）。`ChangeListener`类还有一个纯虚函数，我们需要添加。将以下代码添加到`MediaPlayer.h`文件的`[UserMethods]`部分：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need some additional member variables to support our audio playback.
    Add these to the `[UserVariables]` section:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些额外的成员变量来支持我们的音频播放。将这些添加到`[UserVariables]`部分：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `AudioDeviceManager` object will manage our interface between the application
    and the audio hardware. The `AudioFormatManager` object will assist in creating
    an object that will read and decode the audio data from an audio file. This object
    will be stored in the `ScopedPointer<AudioFormatReaderSource>` object. The `AudioTransportSource`
    object will control the playback of the audio file and perform any sampling rate
    conversion that may be required (if the sampling rate of the audio file differs
    from the audio hardware sampling rate). The `AudioSourcePlayer` object will stream
    audio from the `AudioTransportSource` object to the `AudioDeviceManager` object.
    The `state` variable will store one of our enumerated constants to reflect the
    current playback state of our `MediaPlayer` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioDeviceManager` 对象将管理应用程序与音频硬件之间的接口。`AudioFormatManager` 对象将协助创建一个对象，该对象将读取和解码音频文件中的音频数据。此对象将存储在
    `ScopedPointer<AudioFormatReaderSource>` 对象中。`AudioTransportSource` 对象将控制音频文件的播放并执行可能需要的任何采样率转换（如果音频文件的采样率与音频硬件采样率不同）。`AudioSourcePlayer`
    对象将从 `AudioTransportSource` 对象流式传输音频到 `AudioDeviceManager` 对象。`state` 变量将存储我们的枚举常量之一，以反映
    `MediaPlayer` 对象当前的播放状态。'
- en: 'Now add some code to the `MediaPlayer.cpp` file. In the `[Constructor]` section
    of the constructor, add following two lines:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向 `MediaPlayer.cpp` 文件添加一些代码。在构造函数的 `[Constructor]` 部分中，添加以下两行：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This sets the **Play** and **Stop** buttons to be disabled (and grayed out)
    initially. Later, we enable the **Play** button once a valid file is loaded, and
    change the state of each button and the text displayed on the buttons, depending
    on whether the file is currently playing or not. In this `[Constructor]` section
    you should also initialize the `AudioFormatManager` as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 **播放** 和 **停止** 按钮最初处于禁用状态（并变为灰色）。稍后，一旦加载了有效的文件，我们将启用 **播放** 按钮，并根据文件是否正在播放更改每个按钮的状态和按钮上显示的文本。在此
    `[Constructor]` 部分中，您还应按照以下方式初始化 `AudioFormatManager`：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This allows the `AudioFormatManager` object to detect different audio file
    formats and create appropriate file reader objects. We also need to connect the
    `AudioSourcePlayer`, `AudioTransportSource` and `AudioDeviceManager` objects together,
    and initialize the `AudioDeviceManager` object. To do this, add the following
    lines to the `[Constructor]` section:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许 `AudioFormatManager` 对象检测不同的音频文件格式并创建适当的文件读取器对象。我们还需要将 `AudioSourcePlayer`、`AudioTransportSource`
    和 `AudioDeviceManager` 对象连接在一起，并初始化 `AudioDeviceManager` 对象。为此，将以下行添加到 `[Constructor]`
    部分中：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first line connects the `AudioTransportSource` object to the `AudioSourcePlayer`
    object. The second line connects the `AudioSourcePlayer` object to the `AudioDeviceManager`
    object. The final line initializes the `AudioDeviceManager` object with:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 `AudioTransportSource` 对象连接到 `AudioSourcePlayer` 对象。第二行将 `AudioSourcePlayer`
    对象连接到 `AudioDeviceManager` 对象。最后一行使用以下内容初始化 `AudioDeviceManager` 对象：
- en: The number of required audio input channels (`0` in this case).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的音频输入通道数（在本例中为 `0`）。
- en: The number of required audio output channels (`2` in this case, for stereo output).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的音频输出通道数（在本例中为 `2`，用于立体声输出）。
- en: An optional "saved state" for the `AudioDeviceManager` object (`nullptr` initializes
    from scratch).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioDeviceManager` 对象的可选 "保存状态"（`nullptr` 从头开始初始化）。'
- en: Whether to open the default device if the saved state fails to open. As we are
    not using a saved state, this argument is irrelevant, but it is useful to set
    this to `true` in any case.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果保存状态失败是否打开默认设备。由于我们未使用保存状态，此参数无关紧要，但无论如何将其设置为 `true` 是有用的。
- en: 'The final three lines to add to the `[Constructor]` section to configure our
    `MediaPlayer` object as a listener to the `AudioDeviceManager` and `AudioTransportSource`
    objects, and sets the current state to `Stopped`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[Constructor]` 部分添加最后三行以配置我们的 `MediaPlayer` 对象作为 `AudioDeviceManager` 和 `AudioTransportSource`
    对象的监听器，并将当前状态设置为 `Stopped`：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `buttonClicked()` function we need to add some code to the various sections.
    In the `[UserButtonCode_openButton]` section, add:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buttonClicked()` 函数中，我们需要在各个部分添加一些代码。在 `[UserButtonCode_openButton]` 部分中，添加：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the `openButton` button is clicked, this will create a `FileChooser` object
    that allows the user to select a file using the native interface for the platform.
    The types of files that are allowed to be selected are limited using the wildcard
    `*.wav` to allow only files with the `.wav` file extension to be selected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 `openButton` 按钮时，这将创建一个 `FileChooser` 对象，允许用户使用平台的本地界面选择文件。允许选择的文件类型通过通配符
    `*.wav` 限制，以允许仅选择具有 `.wav` 文件扩展名的文件。
- en: If the user actually selects a file (rather than cancels the operation), the
    code can call the `FileChooser::getResult()` function to retrieve a reference
    to the file that was selected. This file is then passed to the `AudioFormatManager`
    object to create a file reader object, which in turn is passed to create an `AudioFormatReaderSource`
    object that will manage and own this file reader object. Finally, the `AudioFormatReaderSource`
    object is connected to the `AudioTransportSource` object and the **Play** button
    is enabled.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户实际选择了文件（而不是取消操作），代码可以调用 `FileChooser::getResult()` 函数来检索所选文件的引用。然后，该文件传递给
    `AudioFormatManager` 对象以创建文件读取器对象，该对象随后传递以创建一个 `AudioFormatReaderSource` 对象，该对象将管理和拥有此文件读取器对象。最后，`AudioFormatReaderSource`
    对象连接到 `AudioTransportSource` 对象，并启用 **Play** 按钮。
- en: The handlers for the `playButton` and `stopButton` objects will make a call
    to our `changeState()` function depending on the current transport state. We will
    define the `changeState()` function in a moment where its purpose should become
    clear.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`playButton` 和 `stopButton` 对象的处理程序将根据当前传输状态调用我们的 `changeState()` 函数。我们将在稍后定义
    `changeState()` 函数，届时其目的将变得清晰。'
- en: 'In the `[UserButtonCode_playButton]` section, add the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[UserButtonCode_playButton]` 部分，添加以下代码：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This changes the state to `Starting` if the current state is either `Stopped`
    or `Paused`, and changes the state to `Pausing` if the current state is `Playing`.
    This is in order to have a button with combined play and pause functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前状态是 `Stopped` 或 `Paused`，则将状态更改为 `Starting`，如果当前状态是 `Playing`，则将状态更改为 `Pausing`。这是为了有一个具有播放和暂停功能的按钮。
- en: 'In the `[UserButtonCode_stopButton]` section, add the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[UserButtonCode_stopButton]` 部分，添加以下代码：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This sets the state to `Stopped` if the current state is `Paused`, and sets
    it to `Stopping` in other cases. Again, we will add the `changeState()` function
    in a moment, where these state changes update various objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前状态是 `Paused`，则将状态设置为 `Stopped`，在其他情况下设置为 `Stopping`。我们将在稍后添加 `changeState()`
    函数，其中这些状态变化将更新各种对象。
- en: 'In the `[UserButtonCode_settingsButton]` section add the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[UserButtonCode_settingsButton]` 部分，添加以下代码：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This presents a useful interface to configure the audio device settings.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个有用的界面来配置音频设备设置。
- en: 'We need to add the `changeListenerCallback()` function to respond to changes
    in the `AudioDeviceManager` and `AudioTransportSource` objects. Add the following
    to the `[MiscUserCode]` section of the `MediaPlayer.cpp` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加 `changeListenerCallback()` 函数以响应 `AudioDeviceManager` 和 `AudioTransportSource`
    对象的变化。将以下内容添加到 `MediaPlayer.cpp` 文件的 `[MiscUserCode]` 部分：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If our `MediaPlayer` object receives a message that the `AudioDeviceManager`
    object changed in some way, we need to check that this change wasn't to disable
    all of the audio output channels, by obtaining the setup information from the
    device manager. If the number of output channels is zero, we disconnect our `AudioSourcePlayer`
    object from the `AudioTransportSource` object (otherwise our application may crash)
    by setting the source to `nullptr`. If the number of output channels becomes nonzero
    again, we reconnect these objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 `MediaPlayer` 对象收到 `AudioDeviceManager` 对象发生某种变化的消息，我们需要检查这种变化不是禁用所有音频输出通道，通过从设备管理器获取设置信息来做到这一点。如果输出通道的数量为零，我们将通过将源设置为
    `nullptr` 来断开我们的 `AudioSourcePlayer` 对象与 `AudioTransportSource` 对象的连接（否则我们的应用程序可能会崩溃）。如果输出通道的数量再次变为非零，我们将重新连接这些对象。
- en: If our `AudioTransportSource` object has changed, this is likely to be a change
    in its playback state. It is important to note the difference between requesting
    the transport to start or stop, and this change actually taking place. This is
    why we created the enumerated constants for all the other states (including transitional
    states). Again we issue calls to the `changeState()` function depending on the
    current value of our `state` variable and the state of the `AudioTransportSource`
    object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`AudioTransportSource`对象已更改，这可能是其播放状态的变化。重要的是要注意请求传输开始或停止与这种变化实际发生之间的区别。这就是为什么我们为所有其他状态（包括过渡状态）创建了枚举常量。根据我们的`state`变量的当前值和`AudioTransportSource`对象的状态，我们再次调用`changeState()`函数。
- en: 'Finally, add the important `changeState()` function to the `[MiscUserCode]`
    section of the `MediaPlayer.cpp` file that handles all of these state changes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将重要的`changeState()`函数添加到`MediaPlayer.cpp`文件的`[MiscUserCode]`部分，该函数处理所有这些状态变化：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After checking that the `newState` value is different from the current value
    of the `state` variable, we update the `state` variable with the new value. Then,
    we perform the appropriate actions for this particular point in the cycle of state
    changes. These are summarized as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`newState`值与`state`变量的当前值不同之后，我们将`state`变量更新为新值。然后，我们执行循环中这个特定点的适当操作。这些总结如下：
- en: In the `Stopped` state, the buttons are configured with the **Play** and **Stop**
    labels, the **Stop** button is disabled, and the transport is positioned to the
    start of the audio file.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`停止`状态中，按钮配置为**播放**和**停止**标签，**停止**按钮被禁用，并且传输定位到音频文件的开头。
- en: In the `Starting` state, the `AudioTransportSource` object is told to start.
    Once the `AudioTransportSource` object has actually started playing, the system
    will be in the `Playing` state. Here we update the `playButton` button to display
    the text **Pause**, ensure the `stopButton` button displays the text **Stop**,
    and we enable the **Stop** button.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`启动`状态中，`AudioTransportSource`对象被告知开始。一旦`AudioTransportSource`对象实际上开始播放，系统将处于`播放`状态。在这里，我们更新`playButton`按钮以显示文本**暂停**，确保`stopButton`按钮显示文本**停止**，并启用**停止**按钮。
- en: If the **Pause** button is clicked, the state becomes `Pausing`, and the transport
    is told to stop. Once the transport has actually stopped, the state changes to
    `Paused`, the `playButton` button is updated to display the text **Resume** and
    the `stopButton` button is updated to display **Return to Zero**.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击了**暂停**按钮，状态变为`暂停中`，并告知传输停止。一旦传输实际上停止，状态变为`暂停`，`playButton`按钮更新以显示文本**继续**，`stopButton`按钮更新以显示**返回零**。
- en: If the **Stop** button is clicked, the state is changed to `Stopping`, and the
    transport is told to stop. Once the transport has actually stopped, the state
    changes to `Stopped` (as described in the first point).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击了**停止**按钮，状态变为`停止中`，并告知传输停止。一旦传输实际上停止，状态变为`停止`（如第一点所述）。
- en: If the **Return to Zero** button is clicked, the state is changed directly to
    `Stopped` (again, as previously described).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击了**返回零**按钮，状态将直接变为`停止`（再次，如前所述）。
- en: When the audio file reaches the end of the file, the state is also changed to
    `Stopped`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当音频文件到达文件末尾时，状态也会变为`停止`。
- en: Build and run the application. You should be able to select a `.wav` audio file
    after clicking the **Open...** button, play, pause, resume, and stop the audio
    file using the respective buttons, and configure the audio device using the **Audio
    Settings…** button. The audio settings window allows you to select the input and
    output device, the sample rate, and the hardware buffer size. It also provides
    a **Test** button that plays a tone through the selected output device.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。点击**打开...**按钮后，你应该能够选择一个`.wav`音频文件，使用相应的按钮播放、暂停、继续和停止音频文件，并使用**音频设置…**按钮配置音频设备。音频设置窗口允许你选择输入和输出设备、采样率和硬件缓冲区大小。它还提供了一个**测试**按钮，可以通过选定的输出设备播放一个音调。
- en: Working with the Binary Builder tool
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二进制构建工具
- en: One problem with writing cross-platform applications is the packaging of binary
    files for use within the application. JUCE includes the **Binary Builder** tool
    that transforms binary files into source code, which is then compiled into the
    application's code. This ensures that the files will behave identically on all
    platforms, rather than relying on peculiarities of the runtime machine. Although
    the Binary Builder is available as a separate project (in `juce/extras/binarybuilder`),
    its functionality is available within the Introjucer application's GUI component
    editor.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写跨平台应用程序时，一个问题是需要在应用程序内部使用二进制文件的打包。JUCE 包含一个名为 **Binary Builder** 的工具，该工具可以将二进制文件转换为源代码，然后编译到应用程序的代码中。这确保了文件在所有平台上表现一致，而不是依赖于运行时机器的特定性。尽管
    Binary Builder 作为独立项目（在 `juce/extras/binarybuilder` 中）提供，但其功能在 Introjucer 应用程序的
    GUI 组件编辑器中可用。
- en: Embedding an image file using the Introjucer application
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Introjucer 应用程序嵌入图像文件
- en: 'Create a new Introjucer project named `Chapter04_05` with a basic window. Add
    a new GUI component as before; this time name it `EmbeddedImage` (remembering
    to also change the name in its **Class** panel). In its **Subcomponents** panel,
    right-click in the canvas and choose **New Generic Component** and resize it to
    fill the canvas with a small border around the edge. Change the **member name**
    and **name** to `image`, and change the **class** to `ImageComponent`. In the
    **Resources** panel, choose **Add new resource…** and select an image file to
    add. This will create a resource that is the binary file converted to code. It
    will be given a variable name within this component based on the original filename,
    and will be stored as a static variable. For example, a file named `sample.png`
    will be named `sample_png`. In addition to this a static variable storing this
    resource''s size as an integer will be created and will have `Size` appended to
    this name, for example, `sample_pngSize`. Save the project and open it into your
    IDE. Update the `MainComponent` file''s contents as before. Change the `MainComponent.h`
    file as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter04_05` 的新 Introjucer 项目，包含一个基本窗口。像之前一样添加一个新的 GUI 组件；这次将其命名为 `EmbeddedImage`（记得也要更改其
    **类** 面板中的名称）。在其 **子组件** 面板中，在画布上右键单击并选择 **新建通用组件**，并将其调整大小以填充画布并边缘留有少量边框。将 **成员名称**
    和 **名称** 更改为 `image`，并将 **类** 更改为 `ImageComponent`。在 **资源** 面板中，选择 **添加新资源…**
    并选择一个图像文件以添加。这将创建一个资源，它是转换为代码的二进制文件。它将在该组件内部根据原始文件名获得一个变量名，并作为静态变量存储。例如，名为 `sample.png`
    的文件将被命名为 `sample_png`。此外，还会创建一个存储该资源大小的静态变量，并将其名称附加 `Size`，例如，`sample_pngSize`。保存项目并将其打开到您的
    IDE 中。像之前一样更新 `MainComponent` 文件的內容。按照以下方式更改 `MainComponent.h` 文件：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then change the `MainComponent.cpp` file to:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 `MainComponent.cpp` 文件更改为：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally in the `EmbeddedImage.cpp` file notice the large arrays of numbers
    at the end of the file, this is the image file converted to code. In the `[Constructor]`
    section, add the following two lines (although you may need to use different names
    from `sample_png`, `sample_pngSize`, depending on the file resource you added
    previously):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `EmbeddedImage.cpp` 文件中注意文件末尾的大数组，这是转换为代码的图像文件。在 `[构造函数]` 部分中，添加以下两行（尽管您可能需要使用与
    `sample_png`、`sample_pngSize` 不同的名称，具体取决于您之前添加的文件资源）：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a memory stream from our resource, providing the data pointer and
    the data size (the final `false` argument tells the memory stream not to copy
    the data). Then we load the image as before using the `ImageFileFormat` class.
    Build and run the application, and the image should be displayed into the application's
    window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个从我们的资源创建的内存流，提供了数据指针和数据大小（最后的 `false` 参数告诉内存流不要复制数据）。然后我们像之前一样使用 `ImageFileFormat`
    类加载图像。构建并运行应用程序，图像应该显示在应用程序的窗口中。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered a range of techniques for dealing with files in JUCE,
    focusing in particular on image and audio files. You are encouraged to explore
    the online JUCE documentation, which provides even more detail on many of the
    possibilities introduced here. We have also introduced the Binary Builder tool
    that provides a means of transforming media files into source code that is suitable
    for cross-platform use. You are encouraged to read the online JUCE documentation
    for each of the classes introduced in this chapter. This chapter has given only
    an introduction to get you started; there are many other options and alternative
    approaches, which may suit different circumstances. The JUCE documentation will
    take you through each of these and point you to related classes and functions.
    The next chapter covers some useful utilities available within JUCE for creating
    cross-platform applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了处理 JUCE 中文件的各种技术，特别是针对图像和音频文件。鼓励您探索在线 JUCE 文档，它提供了关于这里介绍的大多数可能性的更多细节。我们还介绍了
    Binary Builder 工具，该工具提供了一种将媒体文件转换为适用于跨平台使用的源代码的方法。鼓励您阅读本章中介绍的所有类的在线 JUCE 文档。本章仅提供了一个入门介绍；还有许多其他选项和替代方法，可能适合不同的环境。JUCE
    文档将带您了解这些方法，并指向相关的类和函数。下一章将介绍 JUCE 中可用于创建跨平台应用程序的一些有用工具。
