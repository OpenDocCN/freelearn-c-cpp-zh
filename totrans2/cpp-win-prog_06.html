<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Building a Word Processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building a Word Processor</h1></div></div></div><p>In this chapter, we build a word processor that is capable of handling text on character level: that is, a single character that has its own font, color, size, and style. We also introduce caret handling, printing and print previewing, and file dropping, as well as clipboard handling with ASCII and Unicode text, which means that we can cut and paste between this application and, for instance, a text editor.</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_001.jpg" alt="Building a Word Processor"/></div><p>
</p><div class="section" title="Auxiliary classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Auxiliary classes</h1></div></div></div><p>A document in this application is made up of pages, paragraphs, lines, and characters. Let me try to explain how it all hangs together:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First of all, the document is made up of a list of characters. Each character has its own font and pointers to the paragraph and line it belongs to. The character information is stored in objects of the <code class="literal">CharInfo</code> class. The <code class="literal">charList</code> field in the <code class="literal">WordDocument</code> class is a list of <code class="literal">CharInfo</code> objects.</li><li class="listitem" style="list-style-type: disc">The characters are divided into paragraphs. A paragraph does not hold its own character list. Instead, it holds the indexes in the character list of its first and last characters. The <code class="literal">paragraphList</code> field in <code class="literal">WordDocument</code> is a list of <code class="literal">Paragraph</code> objects. The last character of each paragraph is always a newline.</li><li class="listitem" style="list-style-type: disc">Each paragraph is divided into a list of lines. The <code class="literal">Paragraph</code> class below holds a list of <code class="literal">Line</code> objects. A line holds the indexes of its first and last characters relative to the beginning of the paragraph.</li><li class="listitem" style="list-style-type: disc">Finally, the document is also divided into pages. A page holds as many whole paragraphs as possible.</li></ul></div><p>Every time something is changed in the document, the current line and paragraph are recalculated. The page list is also recalculated.</p><p>Let's continue to look into the <code class="literal">CharInfo</code>, <code class="literal">LineInfo</code>, and <code class="literal">Paragraph</code> classes.</p><div class="section" title="Character information"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec37"/>Character information</h2></div></div></div><p>The <code class="literal">CharInfo</code> class is a structure that holds the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A character and its font</li><li class="listitem" style="list-style-type: disc">Its enclosing rectangle, which is used when drawing the character</li><li class="listitem" style="list-style-type: disc">Pointers to the line and the paragraph it belongs to</li></ul></div><p>
<span class="strong"><strong>CharInfo.h</strong></span>
</p><pre class="programlisting">class LineInfo; &#13;
class Paragraph; &#13;
 &#13;
class CharInfo { &#13;
  public: &#13;
    CharInfo(Paragraph* paragraphPtr = nullptr, &#13;
             TCHAR tChar = TEXT('\0'), &#13;
             Font font = SystemFont, Rect rect = ZeroRect); &#13;
 &#13;
    CharInfo(const CharInfo&amp; charInfo); &#13;
    CharInfo&amp; operator=(const CharInfo&amp; charInfo); &#13;
 &#13;
    bool WriteCharInfoToStream(ostream&amp; outStream) const; &#13;
    bool ReadCharInfoFromStream(istream&amp; inStream); &#13;
 &#13;
    void WriteCharInfoToClipboard(InfoList&amp; infoList) const; &#13;
    void ReadCharInfoFromClipboard(InfoList&amp; infoList); &#13;
</pre><p>Each of the private fields in this class has its own method for getting and setting the value. The first set of methods is constant and returns the value itself, which means that the value of the field cannot be changed by these methods. The second set of methods is nonconstant and returns a reference to the field, which means that the value can be changed. However, they cannot be called from a constant object.</p><pre class="programlisting">    TCHAR Char() const {return tChar;} &#13;
    Font CharFont() const {return charFont;} &#13;
    Rect CharRect() const {return charRect;} &#13;
    LineInfo* LineInfoPtr() const {return lineInfoPtr;} &#13;
    Paragraph* ParagraphPtr() const {return paragraphPtr;} &#13;
 &#13;
    TCHAR&amp; Char() {return tChar;} &#13;
    Font&amp; CharFont() {return charFont;} &#13;
    Rect&amp; CharRect() {return charRect;} &#13;
    LineInfo*&amp; LineInfoPtr() {return lineInfoPtr;} &#13;
    Paragraph*&amp; ParagraphPtr() {return paragraphPtr;} &#13;
</pre><p>The <code class="literal">tChar</code> and <code class="literal">charFont</code> fields hold the character itself and its font, and the <code class="literal">charRect</code> coordinates are relative to the top-left position of the paragraph the character belongs to. Each character belongs to a paragraph and one of the lines of that paragraph, which <code class="literal">paragraphPtr</code> and <code class="literal">lineInfoPtr</code> point at.</p><pre class="programlisting">  private: &#13;
    TCHAR tChar; &#13;
    Font charFont; &#13;
    Rect charRect; &#13;
    Paragraph* paragraphPtr; &#13;
    LineInfo* lineInfoPtr; &#13;
};</pre><p>
<span class="strong"><strong>CharInfo.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "CharInfo.h"</pre><p>The default value of the <code class="literal">font</code> parameter is the system font that gives the default font. It is often 10 point Arial.</p><pre class="programlisting">CharInfo::CharInfo(Paragraph* paragraphPtr /* = nullptr */, &#13;
                   TCHAR tChar /* = TEXT('\0') */, &#13;
                   Font font/* = SystemFont */,  &#13;
                   Rect rect /* = ZeroRect */) &#13;
 :lineInfoPtr(nullptr), &#13;
  paragraphPtr(paragraphPtr), &#13;
  tChar(tChar), &#13;
  charFont(font), &#13;
  charRect(rect) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>The copy constructor and assignment operator copies the fields. They are called on several occasions when the characters are written to and read from file streams, or when they are cut, copied, or pasted.</p><pre class="programlisting">CharInfo::CharInfo(const CharInfo&amp; charInfo) &#13;
 :lineInfoPtr(charInfo.lineInfoPtr), &#13;
  paragraphPtr(charInfo.paragraphPtr), &#13;
  tChar(charInfo.tChar), &#13;
  charFont(charInfo.charFont), &#13;
  charRect(charInfo.charRect) { &#13;
  // Empty. &#13;
} &#13;
 &#13;
CharInfo&amp; CharInfo::operator=(const CharInfo&amp; charInfo) { &#13;
  lineInfoPtr = charInfo.lineInfoPtr; &#13;
  paragraphPtr = charInfo.paragraphPtr; &#13;
  tChar = charInfo.tChar; &#13;
  charFont = charInfo.charFont; &#13;
  charRect = charInfo.charRect; &#13;
  return *this; &#13;
} &#13;
</pre><p>The <code class="literal">WriteCharInfoToStream</code> method writes and the <code class="literal">ReadCharInfoFromStream</code> method reads the values of the class to and from a file stream and the clipboard. Note that we omit the <code class="literal">paragraphPtr</code> and <code class="literal">lineInfoPtr</code> pointers since it would be meaningless to save pointer addresses to a stream. Instead, their values are set by the <code class="literal">ReadDocumentFromStream</code> method in the <code class="literal">WordDocument</code> class after calling the <code class="literal">ReadCharInfoFromStream</code> method.</p><pre class="programlisting">bool CharInfo::WriteCharInfoToStream(ostream&amp; outStream) const { &#13;
  outStream.write((char*) &amp;tChar, sizeof tChar); &#13;
  charFont.WriteFontToStream(outStream); &#13;
  charRect.WriteRectToStream(outStream); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool CharInfo::ReadCharInfoFromStream(istream&amp; inStream) { &#13;
  inStream.read((char*) &amp;tChar, sizeof tChar); &#13;
  charFont.ReadFontFromStream(inStream); &#13;
  charRect.ReadRectFromStream(inStream); &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre><p>The <code class="literal">WriteCharInfoToClipboard</code> method writes and the <code class="literal">ReadCharInfoFromClipboard</code> method reads the values to and from the clipboard. Also, in this case, we omit the <code class="literal">paragraphPtr</code> and <code class="literal">lineInfoPtr</code> pointers. These pointers are set by the <code class="literal">PasteGeneric</code> method in the <code class="literal">WordDocument</code> class after the call to the <code class="literal">ReadCharInfoFromClipboard</code> method.</p><pre class="programlisting">void CharInfo::WriteCharInfoToClipboard(InfoList&amp; infoList) const{ &#13;
  infoList.AddValue&lt;TCHAR&gt;(tChar); &#13;
  charFont.WriteFontToClipboard(infoList);  &#13;
} &#13;
 &#13;
void CharInfo::ReadCharInfoFromClipboard(InfoList&amp; infoList) { &#13;
  infoList.GetValue&lt;TCHAR&gt;(tChar); &#13;
  charFont.ReadFontFromClipboard(infoList); &#13;
} &#13;
</pre></div><div class="section" title="Line information"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Line information</h2></div></div></div><p>The <code class="literal">LineInfo</code> method is a small structure holding information about a line in a paragraph:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The integer index of its first and last characters</li><li class="listitem" style="list-style-type: disc">Its height and ascent, that is, the height and ascent of the largest character on the line.</li><li class="listitem" style="list-style-type: disc">The top position of the line relative to its paragraph top position</li></ul></div><p>
<span class="strong"><strong>LineInfo.h</strong></span>
</p><pre class="programlisting">class LineInfo { &#13;
  public: &#13;
    LineInfo(); &#13;
    LineInfo(int first, int last, int top, &#13;
             int height, int ascent); &#13;
 &#13;
    bool WriteLineInfoToStream(ostream&amp; outStream) const; &#13;
    bool ReadLineInfoFromStream(istream&amp; inStream); &#13;
</pre><p>Similar to the <code class="literal">CharInfo</code> method mentioned previously, the <code class="literal">LineInfo</code> method holds a set of constant methods for inspecting the class fields and a set of nonconstant methods for modifying them.</p><pre class="programlisting">    int First() const {return first;} &#13;
    int Last() const {return last;} &#13;
    int Top() const {return top;} &#13;
    int Height() const {return height;} &#13;
    int Ascent() const {return ascent;} &#13;
    int&amp; First() {return first;} &#13;
    int&amp; Last() {return last;} &#13;
    int&amp; Top() {return top;} &#13;
    int&amp; Height() {return height;} &#13;
    int&amp; Ascent() {return ascent;} &#13;
</pre><p>The fields of this class are four integer values; the <code class="literal">first</code> and <code class="literal">last</code> fields refer to the first and last characters on the line, respectively. The <code class="literal">top</code>, <code class="literal">height</code>, and <code class="literal">ascent</code> fields are the top position of the line relative to the top position of the paragraph, the maximum height, and ascent of the line.</p><pre class="programlisting">  private: &#13;
    int first, last, top, height, ascent; &#13;
};</pre><p>
<span class="strong"><strong>LineInfo.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "LineInfo.h"</pre><p>The default construct is called when the user reads a document from a stream, while the second constructor is called when new lines of a paragraph are being generated.</p><pre class="programlisting">LineInfo::LineInfo() { &#13;
  // Empty. &#13;
} &#13;
 &#13;
LineInfo::LineInfo(int first, int last, int top, &#13;
                   int height, int ascent) &#13;
 :first(first), &#13;
  last(last), &#13;
  top(top), &#13;
  height(height), &#13;
  ascent(ascent) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>The <code class="literal">WriteLineInfoToStream</code> and <code class="literal">ReadLineInfoFromStream</code> methods simply write and read, respectively, the field value. Note that there are no corresponding methods for cut, copy, and paste since the line list of a paragraph is regenerated each time the paragraph is pasted.</p><pre class="programlisting">bool LineInfo::WriteLineInfoToStream(ostream&amp; outStream) const { &#13;
  outStream.write((char*) &amp;first, sizeof first); &#13;
  outStream.write((char*) &amp;last, sizeof last); &#13;
  outStream.write((char*) &amp;ascent, sizeof ascent); &#13;
  outStream.write((char*) &amp;top, sizeof top); &#13;
  outStream.write((char*) &amp;height, sizeof height); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool LineInfo::ReadLineInfoFromStream(istream&amp; inStream) { &#13;
  inStream.read((char*) &amp;first, sizeof first); &#13;
  inStream.read((char*) &amp;last, sizeof last); &#13;
  inStream.read((char*) &amp;ascent, sizeof ascent); &#13;
  inStream.read((char*) &amp;top, sizeof top); &#13;
  inStream.read((char*) &amp;height, sizeof height); &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre></div><div class="section" title="The Paragraph class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>The Paragraph class</h2></div></div></div><p>A document is made up of a sequence of paragraphs. The <code class="literal">Paragraph</code> structure holds the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The index of its first and last characters</li><li class="listitem" style="list-style-type: disc">Its top position relative to the beginning of the document, and its height</li><li class="listitem" style="list-style-type: disc">Its index in the document paragraph pointer list</li><li class="listitem" style="list-style-type: disc">Its alignment–a paragraph can be left, center, justified, or right aligned</li><li class="listitem" style="list-style-type: disc">Whether it holds a page break, that is, whether this paragraph will be located at the beginning of the next page</li></ul></div><p>
<span class="strong"><strong>Paragraph.h</strong></span>
</p><pre class="programlisting">enum Alignment {Left, Center, Right, Justified}; &#13;
class WordDocument:&#13;
&#13;
class Paragraph { &#13;
  public: &#13;
    Paragraph(); &#13;
    Paragraph(int first, int last, &#13;
              Alignment alignment, int index); &#13;
 &#13;
    bool WriteParagraphToStream(ostream&amp; outStream) const; &#13;
    bool ReadParagraphFromStream(WordDocument* wordDocumentPtr, &#13;
                                 istream&amp; inStream); &#13;
 &#13;
    void WriteParagraphToClipboard(InfoList&amp; infoList) const; &#13;
    void ReadParagraphFromClipboard(InfoList&amp; infoList); &#13;
 &#13;
    int&amp; First() {return first;} &#13;
    int&amp; Last() {return last;} &#13;
    int&amp; Top() {return top;} &#13;
    int&amp; Index() {return index;} &#13;
    int&amp; Height() {return height;} &#13;
    bool&amp; PageBreak() {return pageBreak;} &#13;
</pre><p>As you can see, we name the <code class="literal">AlignmentField</code> method instead of just the <code class="literal">Alignment</code> method. The reason for this is that there already is a class named <code class="literal">Alignment</code>. We cannot give the same name to both the class and method. Therefore, we add the <code class="literal">Field</code> suffix to the method name.</p><pre class="programlisting">    Alignment&amp; AlignmentField() {return alignment;}&#13;
    DynamicList&lt;LineInfo*&gt;&amp; LinePtrList() {return linePtrList;}</pre><p>The <code class="literal">first</code> and <code class="literal">last</code> fields are the index in the document character list of the first and last characters in the paragraph, respectively; the last character of the paragraph is always a newline. The <code class="literal">top</code> field is the top position of the paragraph relative to the beginning of the document, which is always zero for the first paragraph of the document and positive for the other paragraphs. The <code class="literal">height</code> is the height of the paragraph, and <code class="literal">index</code> refers to the index of the paragraph in the document paragraph pointer list. If <code class="literal">pageBreak</code> is <code class="literal">true</code>, the paragraph will always be located at the beginning of a page.</p><pre class="programlisting">    int first, last, top, height, index; &#13;
    bool pageBreak; &#13;
</pre><p>A paragraph can be left, right, centered, and justified aligned. In the justified case, the spaces are extended in order for the words to be distributed over the whole width of the page.</p><pre class="programlisting">    Alignment alignment; &#13;
</pre><p>A paragraph is made up of at least one line. The indexes of the <code class="literal">linePtrList</code> list are relative to the index of the first character in the paragraph (not the document), and the coordinates are relative to the top of the paragraph (again, not the document).</p><pre class="programlisting">    DynamicList&lt;LineInfo*&gt; linePtrList; &#13;
};</pre><p>
<span class="strong"><strong>Paragraph.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "CharInfo.h"&#13;
#include "LineInfo.h"&#13;
#include "Paragraph.h"&#13;
#include "WordDocument.h"&#13;
Paragraph::Paragraph() { /* Empty. */ }&#13;
Paragraph::Paragraph(int first, int last, Alignment alignment, int index)&#13;
:top(-1), first(first), last(last), index(index), pageBreak(false), alignment(alignment) { /* Empty. */ }</pre><p>The idea is that the <code class="literal">WriteParagraphToStream</code> and <code class="literal">ReadParagraphFromStream</code> methods write and read, respectively, all information about the paragraph. Remember that all coordinates are given in logical units (hundredths of millimeters), which means that works to save and open the file on screens with different resolutions.</p><pre class="programlisting">bool Paragraph::WriteParagraphToStream(ostream&amp; outStream) const { &#13;
  outStream.write((char*) &amp;first, sizeof first); &#13;
  outStream.write((char*) &amp;last, sizeof last); &#13;
  outStream.write((char*) &amp;top, sizeof top); &#13;
  outStream.write((char*) &amp;height, sizeof height); &#13;
  outStream.write((char*) &amp;index, sizeof index); &#13;
  outStream.write((char*) &amp;pageBreak, sizeof pageBreak); &#13;
  outStream.write((char*) &amp;alignment, sizeof alignment); &#13;
 &#13;
  { int linePtrListSize = linePtrList.Size(); &#13;
    outStream.write((char*) &amp;linePtrListSize, &#13;
                    sizeof linePtrListSize); &#13;
 &#13;
    for (const LineInfo* lineInfoPtr : linePtrList) { &#13;
      lineInfoPtr-&gt;WriteLineInfoToStream(outStream); &#13;
    } &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool Paragraph::ReadParagraphFromStream &#13;
                (WordDocument* wordDocumentPtr, istream&amp; inStream){&#13;
  inStream.read((char*) &amp;first, sizeof first); &#13;
  inStream.read((char*) &amp;last, sizeof last); &#13;
  inStream.read((char*) &amp;top, sizeof top); &#13;
  inStream.read((char*) &amp;height, sizeof height); &#13;
  inStream.read((char*) &amp;index, sizeof index); &#13;
  inStream.read((char*) &amp;pageBreak, sizeof pageBreak); &#13;
  inStream.read((char*) &amp;alignment, sizeof alignment);</pre><p>When we have read indexes of the first and last character of the paragraph, we need to set the paragraph pointer of each character.</p><pre class="programlisting">  for (int charIndex = first; charIndex &lt;= last; ++charIndex) {&#13;
    wordDocumentPtr-&gt;CharList()[charIndex].ParagraphPtr() = this;&#13;
  }&#13;
&#13;
  { int linePtrListSize = linePtrList.Size(); &#13;
    inStream.read((char*) &amp;linePtrListSize, &#13;
                  sizeof linePtrListSize); &#13;
&#13;
    for (int count = 0; count &lt; linePtrListSize; ++count) { &#13;
      LineInfo* lineInfoPtr = new LineInfo(); &#13;
      assert(lineInfoPtr != nullptr); &#13;
      lineInfoPtr-&gt;ReadLineInfoFromStream(inStream); &#13;
      linePtrList.PushBack(lineInfoPtr);&#13;
&#13;
</pre><p>In the same way as in the paragraph pointer case above, we need to set the line pointer of each character.</p><pre class="programlisting">      for (int charIndex = lineInfoPtr-&gt;First();&#13;
           charIndex &lt;= lineInfoPtr-&gt;Last(); ++charIndex) {&#13;
        wordDocumentPtr-&gt;CharList()[first + charIndex].&#13;
          LineInfoPtr() = lineInfoPtr;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  return ((bool) inStream);&#13;
}</pre><p>On the other hand, the <code class="literal">WriteParagraphToClipboard</code> and <code class="literal">ReadParagraphFromClipboard</code> methods only write and read, respectively, the essential information. After the paragraph has been read, the <code class="literal">CalaulateParagraph</code> method is then called, which calculates the character rectangles and the height of the paragraph and generates its line pointer list.</p><pre class="programlisting">void Paragraph::WriteParagraphToClipboard(InfoList&amp; infoList) const { &#13;
  infoList.AddValue&lt;int&gt;(first); &#13;
  infoList.AddValue&lt;int&gt;(last); &#13;
  infoList.AddValue&lt;int&gt;(top); &#13;
  infoList.AddValue&lt;int&gt;(index); &#13;
  infoList.AddValue&lt;bool&gt;(pageBreak); &#13;
  infoList.AddValue&lt;Alignment&gt;(alignment); &#13;
} &#13;
 &#13;
void Paragraph::ReadParagraphFromClipboard(InfoList&amp; infoList) { &#13;
  infoList.GetValue&lt;int&gt;(first); &#13;
  infoList.GetValue&lt;int&gt;(last); &#13;
  infoList.GetValue&lt;int&gt;(top); &#13;
  infoList.GetValue&lt;int&gt;(index); &#13;
  infoList.GetValue&lt;bool&gt;(pageBreak); &#13;
  infoList.GetValue&lt;Alignment&gt;(alignment); &#13;
} &#13;
</pre></div></div></div>
<div class="section" title="The MainWindow class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>The MainWindow class</h1></div></div></div><p>The <code class="literal">MainWindow</code> class is nearly identical to the versions of the previous chapters. It sets the application name to <code class="literal">Word</code> and returns the address of a <code class="literal">WordDocument</code> instance:</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "CharInfo.h" &#13;
#include "LineInfo.h" &#13;
#include "Paragraph.h" &#13;
#include "WordDocument.h" &#13;
 &#13;
void MainWindow(vector&lt;String&gt; /* argumentList */, &#13;
                WindowShow windowShow) { &#13;
  Application::ApplicationName() = TEXT("Word"); &#13;
  Application::MainWindowPtr() = new WordDocument(windowShow); &#13;
} &#13;
</pre></div>
<div class="section" title="The WordDocument class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>The WordDocument class</h1></div></div></div><p>The <code class="literal">WordDocument</code> class is the main class of the application. It extends the <code class="literal">StandardDocument</code> class and takes advantage of its document-based functionality.</p><p>
<span class="strong"><strong>WordDocument.h</strong></span>
</p><pre class="programlisting">class WordDocument : public StandardDocument { &#13;
  public: &#13;
    WordDocument(WindowShow windowShow); &#13;
</pre><p>The <code class="literal">InitDocument</code> class is called by the constructor, the <code class="literal">ClearDocument</code>, and <code class="literal">Delete</code> classes.</p><pre class="programlisting">    void InitDocument(); &#13;
</pre><p>The <code class="literal">OnKeyboardMode</code> method is called every time the user presses the <span class="emphasis"><em>Insert</em></span> key. The <code class="literal">UpdateCaret</code> method sets the caret to a vertical bar in <code class="literal">insert</code> mode and a block in <code class="literal">overwrite</code> mode. When the user marks one or several characters, the caret is cleared.</p><pre class="programlisting">    void OnKeyboardMode(KeyboardMode keyboardMode); &#13;
    void UpdateCaret(); &#13;
</pre><p>When the user presses, moves, and releases the mouse, we need to find the index of the character located at the mouse position. The <code class="literal">MousePointToIndex</code> method finds the paragraph, and the <code class="literal">MousePointToParagraphIndex</code> method finds the character in the paragraph. The <code class="literal">InvalidateBlock</code> method invalidates the characters from the smallest index, inclusive, to the largest index, exclusive.</p><pre class="programlisting">    void OnMouseDown(MouseButton mouseButtons, Point mousePoint, &#13;
                     bool shiftPressed, &#13;
                     bool controlPressed); &#13;
    void OnMouseMove(MouseButton mouseButtons, Point mousePoint, &#13;
                     bool shiftPressed, &#13;
                     bool controlPressed); &#13;
    void OnMouseUp(MouseButton mouseButtons, Point mousePoint, &#13;
                   bool shiftPressed, &#13;
                   bool controlPressed); &#13;
    int MousePointToIndex(Point mousePoint) const; &#13;
    int MousePointToParagraphIndex(Paragraph* paragraphPtr, &#13;
                                   Point mousePoint) const; &#13;
    void InvalidateBlock(int firstIndex, int lastIndex); &#13;
</pre><p>When the user double-clicks on a word, it will be marked. The <code class="literal">GetFirstWordIndex</code> and <code class="literal">GetLastWordIndex</code> methods find the first and last index of the word, respectively, if in fact the user double-clicks on a word (rather than a space, period, comma, or question mark).</p><pre class="programlisting">    void OnDoubleClick(MouseButton mouseButtons, Point mousePoint, &#13;
                       bool shiftPressed, bool controlPressed); &#13;
    int GetFirstWordIndex(int charIndex) const; &#13;
    int GetLastWordIndex(int charIndex) const; &#13;
</pre><p>In this application, we introduce touchscreen handling. Unlike mouse clicks, it is possible to touch the screen in several locations at the same time. Therefore, the parameter is a list of points rather that one individual point.</p><pre class="programlisting">    void OnTouchDown(vector&lt;Point&gt; pointList); &#13;
    void OnTouchMove(vector&lt;Point&gt; pointList); &#13;
</pre><p>The <code class="literal">OnPageSetup</code> method is called when the user has changed the page setting by selecting the <span class="strong"><strong>Page Setup</strong></span> menu item in the <span class="strong"><strong>File</strong></span> menu, which allows the user to modify the page and paragraphs settings. The <code class="literal">CalculateDocument</code> method distributes the paragraphs on the pages. If a paragraph is marked with a page break, or if it does not completely fit on the rest of the current page, it is placed at the beginning of the next page.</p><pre class="programlisting">    void OnPageSetup(PageSetupInfo pageSetupInfo); &#13;
    void CalculateDocument(); &#13;
</pre><p>Unlike the applications in the previous chapters, we override both the <code class="literal">OnPaint</code> and <code class="literal">OnDraw</code> methods. The <code class="literal">OnPaint</code> method is called when the client area needs to be redrawn. It performs paint-specific actions, that is, actions that will be performed only when the document is drawn in a window, but not when it is sent to the printer. More specifically, we add page break markers in the client area, but not in the printer text.</p><p>The <code class="literal">OnPaint</code> method then calls the <code class="literal">OnDraw</code> method that performs the actual drawing of the document. There is also a method <code class="literal">OnPrint</code> in the <code class="literal">StandardDocument</code> class (which we do not override) that calls the <code class="literal">OnDraw</code> method when printing the document.</p><pre class="programlisting">    void OnPaint(Graphics&amp; graphics) const; &#13;
    void OnDraw(Graphics&amp; graphics, DrawMode drawMode) const; &#13;
</pre><p>Similar to the applications in the previous chapters, the <code class="literal">ClearDocument</code>, <code class="literal">WriteDocumentToStream</code>, and <code class="literal">ReadDocumentFromStream</code> methods are called when the user selects the <span class="strong"><strong>New</strong></span>, <span class="strong"><strong>Save</strong></span>, <span class="strong"><strong>Save As</strong></span>, or <span class="strong"><strong>Open</strong></span> menu items in the <span class="strong"><strong>File</strong></span> menu.</p><pre class="programlisting">    void ClearDocument(); &#13;
    bool WriteDocumentToStream(String name, ostream&amp; outStream) &#13;
                               const; &#13;
    bool ReadDocumentFromStream(String name, istream&amp; inStream); &#13;
</pre><p>The <code class="literal">CopyEnable</code> method returns <code class="literal">true</code> when text is ready to be copied, that is, when the user has marked a part of the text. The <code class="literal">CopyAscii</code> and <code class="literal">CopyUnicode</code> methods are called when the user selects the <span class="strong"><strong>Cut</strong></span> or <span class="strong"><strong>Copy</strong></span> menu item and copies the marked text into a string list. The <code class="literal">CopyGeneric</code> method is also called when the user selects the <span class="strong"><strong>Cut</strong></span> or <span class="strong"><strong>Copy</strong></span> menu item and copies the marked text in an application-specific format that also copies the font and style of the characters.</p><pre class="programlisting">    bool CopyEnable() const; &#13;
    bool IsCopyAsciiReady() const; &#13;
    bool IsCopyUnicodeReady() const; &#13;
    bool IsCopyGenericReady(int format) const; &#13;
 &#13;
    void CopyAscii(vector&lt;String&gt;&amp; textList) const; &#13;
    void CopyUnicode(vector&lt;String&gt;&amp; textList) const; &#13;
    void CopyGeneric(int format, InfoList&amp; infoList) const; &#13;
</pre><p>The <code class="literal">PasteAscii</code>, <code class="literal">PasteUnicode</code>, and <code class="literal">PasteGeneric</code> methods are called when the user selects the <span class="strong"><strong>Paste</strong></span> menu item. One difference between copying and pasting is that all the three aforementioned methods are called when copying, but only one method when pasting, in the order the format is given in the <code class="literal">StandardDocument</code> constructor call.</p><pre class="programlisting">    void PasteAscii(const vector&lt;String&gt;&amp; textList); &#13;
    void PasteUnicode(const vector&lt;String&gt;&amp; textList); &#13;
    void PasteGeneric(int format, InfoList&amp; infoList); &#13;
</pre><p>We do not override the <code class="literal">CutEnable</code> or <code class="literal">OnCut</code> methods, since the <code class="literal">CutEnable</code> method in the <code class="literal">StandardDocument</code> class calls the <code class="literal">CopyEnable</code> method, and the <code class="literal">OnCut</code> method calls the <code class="literal">OnDelete</code> method followed by the <code class="literal">OnCopy</code> method.</p><p>The <span class="strong"><strong>Delete</strong></span> menu item is enabled unless the input position is at the end of the document, in which case there is nothing to delete. The <code class="literal">Delete</code> method is a general method for deleting text and is called when the user presses the <span class="emphasis"><em>Delete</em></span> or <span class="emphasis"><em>Backspace</em></span> keys or when a marked text block is being overwritten.</p><pre class="programlisting">    bool DeleteEnable() const; &#13;
    void OnDelete(); &#13;
    void Delete(int firstIndex, int lastIndex); &#13;
</pre><p>The <code class="literal">OnPageBreak</code> method sets the page break status of the edit paragraph. In case of a page break, the paragraph will be placed at the beginning of the next page. The <code class="literal">OnFont</code> method displays the standard font dialog that sets the font and color of the next character to be input or the font of the marked block.</p><pre class="programlisting">    DEFINE_BOOL_LISTENER(WordDocument, PageBreakEnable) &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnPageBreak) &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnFont) &#13;
</pre><p>A paragraph can be left, center, right, or justified aligned. The radio mark is present if the paragraph currently edited or all paragraphs currently marked have the alignment in question. All the listeners call the <code class="literal">IsAlignment</code> and <code class="literal">SetAlignment</code> methods, which returns the current alignment and sets the alignment, respectively, for the edited paragraph or all marked paragraphs.</p><pre class="programlisting">    DEFINE_BOOL_LISTENER(WordDocument, LeftRadio) &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnLeft) &#13;
    DEFINE_BOOL_LISTENER(WordDocument, CenterRadio) &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnCenter) &#13;
    DEFINE_BOOL_LISTENER(WordDocument, RightRadio) &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnRight) &#13;
    DEFINE_BOOL_LISTENER(WordDocument, JustifiedRadio) &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnJustified)     &#13;
 &#13;
    bool IsAlignment(Alignment alignment) const; &#13;
    void SetAlignment(Alignment alignment); &#13;
</pre><p>The <code class="literal">OnChar</code> method is called every time the user presses a graphical character; it calls the <code class="literal">InsertChar</code> or <code class="literal">OverwriteChar</code> method, depending on whether the keyboard holds <code class="literal">insert</code> or <code class="literal">overwrite</code> mode. When the text is marked and the user changes the font, the font is set on all marked characters. However, when editing text, the font of the next character to be input is set.</p><p>When the user does anything else than input the next character, such as clicking the mouse or pressing any of the arrow keys, the <code class="literal">ClearNextFont</code> method is called, which clears the next font by setting it to the <code class="literal">SystemFont</code> method.</p><pre class="programlisting">    void OnChar(TCHAR tChar); &#13;
    void InsertChar(TCHAR tChar, Paragraph* paragraphPtr); &#13;
    void OverwriteChar(TCHAR tChar, Paragraph* paragraphPtr);   &#13;
    void ClearNextFont(); &#13;
</pre><p>The <code class="literal">OnKeyDown</code> method is called every time the user presses a key, such as the arrow keys, <span class="emphasis"><em>Page Up</em></span> and <span class="emphasis"><em>Page Down</em></span>, <span class="emphasis"><em>Home</em></span> and <span class="emphasis"><em>End</em></span>, <span class="emphasis"><em>Delete</em></span>, or <span class="emphasis"><em>Backspace</em></span>:</p><pre class="programlisting">    bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                   bool controlPressed); &#13;
    void OnRegularKey(WORD key); &#13;
    void EnsureEditStatus(); &#13;
    void OnLeftArrowKey(); &#13;
    void OnRightArrowKey(); &#13;
    void OnUpArrowKey(); &#13;
    void OnDownArrowKey(); &#13;
    int MousePointToIndexDown(Point mousePoint) const; &#13;
    void OnPageUpKey(); &#13;
    void OnPageDownKey(); &#13;
    void OnHomeKey(); &#13;
    void OnEndKey(); &#13;
</pre><p>When the user presses the key without pressing the <span class="emphasis"><em>Shift</em></span> key at the same time, the caret is moved. However, when they press the <span class="emphasis"><em>Shift</em></span> key, the marking of the text is changed.</p><pre class="programlisting">    void OnShiftKey(WORD key); &#13;
    void EnsureMarkStatus(); &#13;
    void OnShiftLeftArrowKey(); &#13;
    void OnShiftRightArrowKey(); &#13;
    void OnShiftUpArrowKey(); &#13;
    void OnShiftDownArrowKey(); &#13;
    void OnShiftPageUpKey(); &#13;
    void OnShiftPageDownKey(); &#13;
    void OnShiftHomeKey(); &#13;
    void OnShiftEndKey(); &#13;
</pre><p>When the user presses the <span class="emphasis"><em>Home</em></span> or <span class="emphasis"><em>End</em></span> key together with the <span class="emphasis"><em>Ctrl</em></span> key, the caret is placed at the beginning or end of the document. If they also press the <span class="emphasis"><em>Shift</em></span> key, the text is marked.</p><p>The reason we use listener instead of regular methods is that all actions involving the <span class="emphasis"><em>Ctrl</em></span> key are interpreted as accelerators by Small Windows. The listeners are also added to a menu in the following constructor.</p><pre class="programlisting">    DEFINE_VOID_LISTENER(WordDocument, OnControlHomeKey); &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnControlEndKey); &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnShiftControlHomeKey); &#13;
    DEFINE_VOID_LISTENER(WordDocument, OnShiftControlEndKey); &#13;
</pre><p>There are also the <span class="emphasis"><em>Return</em></span>, <span class="emphasis"><em>Backspace</em></span>, and <span class="emphasis"><em>Delete</em></span> keys, in which case we do not care whether the <span class="emphasis"><em>Shift</em></span> or <span class="emphasis"><em>Ctrl</em></span> key is pressed. The <span class="emphasis"><em>Delete</em></span> key is handled by the <span class="strong"><strong>Delete</strong></span> menu item accelerator.</p><pre class="programlisting">    void OnNeutralKey(WORD key); &#13;
    void OnReturnKey(); &#13;
    void OnBackspaceKey(); &#13;
</pre><p>When the user moves the caret with the keyboard, the edit character will be visible. The <code class="literal">MakeVisible</code> method makes sure it is visible, even if it means scrolling the document.</p><pre class="programlisting">    void MakeVisible(); &#13;
</pre><p>When something happens to the paragraph (characters are added or deleted, the font or alignment is changed, or the page setup), the positions of the characters need to be calculated. The <code class="literal">GenerateParagraph</code> method calculates the surrounding rectangle for each of its character and generates its line list by calling the <code class="literal">GenerateSizeAndAscentList</code> method to calculate the size and ascent line for the characters, the <code class="literal">GenerateLineList</code> method to divide the paragraph into lines, the <code class="literal">GenerateRegularLineRectList</code> method to generate the character rectangles for left, center, or right aligned paragraphs or the <code class="literal">GenerateJustifiedLineRectList</code> method for justified paragraphs, and the <code class="literal">GenerateRepaintSet</code> method to invalidate the changed characters.</p><pre class="programlisting">    void GenerateParagraph(Paragraph* paragraphPtr); &#13;
    void GenerateSizeAndAscentList(Paragraph* paragraphPtr, &#13;
                                   DynamicList&lt;Size&gt;&amp; sizeList, &#13;
                                   DynamicList&lt;int&gt;&amp; ascentList); &#13;
    void GenerateLineList(Paragraph* paragraphPtr, &#13;
                          DynamicList&lt;Size&gt;&amp; sizeList, &#13;
                          DynamicList&lt;int&gt;&amp; ascentList); &#13;
&#13;
&#13;
    void GenerateRegularLineRectList(Paragraph* paragraphPtr, &#13;
                                     LineInfo* lineInfoPtr, &#13;
                                     DynamicList&lt;Size&gt;&amp; sizeList, &#13;
                                     DynamicList&lt;int&gt;&amp;ascentList); &#13;
    void GenerateJustifiedLineRectList(Paragraph* paragraphPtr, &#13;
                                  LineInfo* lineInfoPtr, &#13;
                                  DynamicList&lt;Size&gt;&amp; sizeList, &#13;
                                  DynamicList&lt;int&gt;&amp; ascentList); &#13;
    void InvalidateRepaintSet(Paragraph* paragraphPtr, &#13;
                            DynamicList&lt;CharInfo&gt;&amp; prevRectList);&#13;
    DynamicList&lt;CharInfo&gt;&amp; CharList() {return charList;}</pre><p>One central part of this application is the <code class="literal">wordMode</code> method. At a certain time, the application can be set to <code class="literal">edit</code> mode (the caret is visible), in which case <code class="literal">wordMode</code> is the <code class="literal">WordEdit</code> method, or <code class="literal">mark</code> mode (a part of the text is marked), in which case <code class="literal">wordMode</code> is the <code class="literal">WordMark</code> method. Later in the chapter, we will encounter expressions such as <span class="strong"><strong>in edit mode</strong></span> and <span class="strong"><strong>in mark mode</strong></span>, which refer to the value of <code class="literal">wordMode</code>: <code class="literal">WordEdit</code> or <code class="literal">WordMark</code>.</p><p>We will also encounter the expressions <span class="strong"><strong>in insert mode</strong></span> and <span class="strong"><strong>in overwrite mode</strong></span>, which refer to the <code class="literal">input</code> mode of the keyboard, the <code class="literal">InsertKeyboard</code> or <code class="literal">OverwriteKeyboard</code> method, which is returned by the <code class="literal">GetKeyboardMode</code> method in the Small Windows class <code class="literal">Document</code>.</p><p>The <code class="literal">totalPages</code> field holds the number of pages, which is used when printing and when setting the vertical scroll bar. The list of characters is stored in the <code class="literal">charList</code> list, and the list of paragraph pointers is stored in the <code class="literal">paragraphList</code> list. Note that the paragraphs are dynamically created and deleted <code class="literal">Paragraph</code> objects while the characters are static <code class="literal">CharInfo</code> objects. Also note that each paragraph does not hold a character list. There is only one <code class="literal">charList</code>, which is common to all paragraphs. However, each paragraph holds its own list of <code class="literal">Line</code> pointers that are local to the paragraph.</p><p>In this chapter, we will also encounter expressions such as <span class="strong"><strong>the edit character</strong></span>, which refers to the character with index <code class="literal">editIndex</code> in the <code class="literal">charList</code> list. As mentioned at the beginning of this chapter, each character has pointers to its paragraph and line. The expressions <span class="strong"><strong>the edit paragraph</strong></span> and <span class="strong"><strong>the edit line</strong></span> refer to the paragraph and line pointed at by the edit character.</p><p>The <code class="literal">firstMarkIndex</code> and <code class="literal">lastMarkIndex</code> fields hold the indexes of the first and last marked characters in <code class="literal">mark</code> mode. They are also referred to in expressions such as <span class="strong"><strong>the first marked character</strong></span>, <span class="strong"><strong>the first marked paragraph</strong></span>, and <span class="strong"><strong>the first marked line</strong></span> as well as <span class="strong"><strong>the last marked character</strong></span>, <span class="strong"><strong>the last marked paragraph</strong></span>, and <span class="strong"><strong>the last marked line</strong></span>. Note that the two fields refer to the chronological order, not necessarily their physical order. When needed, we will define the <code class="literal">minIndex</code> and <code class="literal">maxIndex</code> methods to refer to the first and last markings in the document in physical order.</p><p>When the user sets the font in <code class="literal">edit</code> mode, it is stored in the <code class="literal">nextFont</code> font, which is then used when the user inputs the next character. The caret takes into consideration the status of the <code class="literal">nextFont</code> font, that is, if the  <code class="literal">nextFont</code> font is not equal to the <code class="literal">ZeroFont</code> font, it is used to set the caret. However, the <code class="literal">nextFont</code> font is cleared as soon as the user does anything else.</p><p>The user can zoom the document by menu items or by touching the screen. In that case, we need the <code class="literal">initZoom</code> and <code class="literal">initDistance</code> fields to keep track of the zooming. Finally, we need the <code class="literal">WordFormat</code> field to identify cut, copied, and pasted application-specific information. It is given the arbitrary value of 1002.</p><pre class="programlisting">  private: &#13;
    enum {WordEdit, WordMark} wordMode; &#13;
 &#13;
    int totalPages; &#13;
    DynamicList&lt;CharInfo&gt; charList; &#13;
    DynamicList&lt;Paragraph*&gt; paragraphList; &#13;
 &#13;
    int editIndex, firstMarkIndex, lastMarkIndex; &#13;
    Font nextFont; &#13;
 &#13;
    double initZoom, initDistance;  &#13;
    static const unsigned int WordFormat = 1002; &#13;
};</pre><p>
<span class="strong"><strong>WordDocument.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "CharInfo.h"&#13;
#include "LineInfo.h"&#13;
#include "Paragraph.h"&#13;
#include "WordDocument.h"</pre><p>The <code class="literal">WordDocument</code> constructor calls the <code class="literal">StandardDocument</code> constructor. The <code class="literal">UnicodeFormat</code> and <code class="literal">AsciiFormat</code> methods are general formats defined by Small Windows, while the <code class="literal">WordFormat</code> method is specific to this application.</p><pre class="programlisting">WordDocument::WordDocument(WindowShow windowShow) &#13;
 :StandardDocument(LogicalWithScroll, USLetterPortrait, &#13;
                   TEXT("Word Files, wrd; Text Files, txt"), &#13;
                   nullptr, OverlappedWindow, windowShow, &#13;
                   {WordFormat, UnicodeFormat, AsciiFormat}, &#13;
                   {WordFormat, UnicodeFormat, AsciiFormat}) { &#13;
</pre><p>The <span class="strong"><strong>Format</strong></span> menu holds the <span class="strong"><strong>Font</strong></span> and <span class="strong"><strong>Page Break</strong></span> menu items. Unlike the earlier applications in this book, we send <code class="literal">true</code> to <code class="literal">StandardFileMenu</code>. It indicates that we want to include the <span class="strong"><strong>Page Setup</strong></span>, <span class="strong"><strong>Print Preview</strong></span>, and <span class="strong"><strong>Print</strong></span> menu items in the <span class="strong"><strong>File</strong></span> menu.</p><pre class="programlisting">  Menu menuBar(this); &#13;
  menuBar.AddMenu(StandardFileMenu(true)); &#13;
  menuBar.AddMenu(StandardEditMenu()); &#13;
 &#13;
  Menu formatMenu(this, TEXT("F&amp;ormat")); &#13;
  formatMenu.AddItem(TEXT("&amp;Font\tCtrl+F"), OnFont); &#13;
  formatMenu.AddItem(TEXT("&amp;Page Break\tCtrl+B"), &#13;
                     OnPageBreak, PageBreakEnable); &#13;
  menuBar.AddMenu(formatMenu); &#13;
</pre><p>The <span class="strong"><strong>Alignment</strong></span> menu holds items for the left, center, right, and justified alignment:</p><pre class="programlisting">  Menu alignmentMenu(this, TEXT("&amp;Alignment")); &#13;
  alignmentMenu.AddItem(TEXT("&amp;Left\tCtrl+L"), OnLeft, &#13;
                        nullptr, nullptr, LeftRadio); &#13;
  alignmentMenu.AddItem(TEXT("&amp;Center\tCtrl+E"), OnCenter, &#13;
                        nullptr, nullptr, CenterRadio); &#13;
  alignmentMenu.AddItem(TEXT("&amp;Right\tCtrl+R"), OnRight, &#13;
                        nullptr, nullptr, RightRadio); &#13;
  alignmentMenu.AddItem(TEXT("&amp;Justified\tCtrl+J"), OnJustified, &#13;
                        nullptr, nullptr, JustifiedRadio); &#13;
  menuBar.AddMenu(alignmentMenu); &#13;
 &#13;
  menuBar.AddMenu(StandardHelpMenu()); &#13;
  SetMenuBar(menuBar); &#13;
</pre><p>The <code class="literal">extraMenu</code> menu is only added for the accelerators; note that we do not add it to the menu bar. The text of the menu, or its items, does not matter either. We only want to allow the user to jump to the beginning or end of the document by pressing the <span class="emphasis"><em>Ctrl</em></span> key with <span class="emphasis"><em>Home</em></span> or <span class="emphasis"><em>End</em></span>, and possibly <span class="emphasis"><em>Shift</em></span>.</p><pre class="programlisting">  Menu extraMenu(this); &#13;
  extraMenu.AddItem(TEXT("&amp;A\tCtrl+Home"), OnControlHomeKey); &#13;
  extraMenu.AddItem(TEXT("&amp;B\tCtrl+End"), OnControlEndKey); &#13;
  extraMenu.AddItem(TEXT("&amp;C\tShift+Ctrl+Home"), &#13;
                    OnShiftControlHomeKey); &#13;
  extraMenu.AddItem(TEXT("&amp;D\tShift+Ctrl+End"), &#13;
                    OnShiftControlEndKey); &#13;
</pre><p>Finally, we call the <code class="literal">InitDocument</code> method that initializes the empty document. The <code class="literal">InitDocument</code> method is also called by the <code class="literal">ClearDocument</code> and <code class="literal">Delete</code> classes as follows, when the initialization code is placed in its own method.</p><pre class="programlisting">  InitDocument(); &#13;
} &#13;
</pre><p>A document always holds at least one paragraph, which, in turn, holds at least a newline. We create the first character and the first left-justified paragraph. The paragraph and character are added to the <code class="literal">paragraphList</code> and <code class="literal">charList</code> lists.</p><p>Then, the paragraph is calculated by the <code class="literal">GenerateParagraph</code> method and distributed on the document by the <code class="literal">CalculateDocument</code> method. Finally, the caret is updated by the <code class="literal">UpdateCaret</code> method.</p><pre class="programlisting">void WordDocument::InitDocument() { &#13;
  wordMode = WordEdit; &#13;
  editIndex = 0; &#13;
  Paragraph* firstParagraphPtr = new Paragraph(0, 0, Left, 0); &#13;
  assert(firstParagraphPtr != nullptr); &#13;
  Font font(TEXT("Times New Roman"), 36, false, true); &#13;
  charList.PushBack(CharInfo(firstParagraphPtr, NewLine, font)); &#13;
  GenerateParagraph(firstParagraphPtr); &#13;
  paragraphList.PushBack(firstParagraphPtr); &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
} &#13;
</pre><div class="section" title="The caret"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>The caret</h2></div></div></div><p>Since in this chapter we introduce text handling, we need to keep track of the caret: the blinking vertical bar (in <code class="literal">insert</code> mode) or block (in <code class="literal">overwrite</code> mode) indicating where to input the character. The <code class="literal">UpdateCaret</code> method is called by the <code class="literal">OnKeyboardMode</code> method (which is called when the user presses the <span class="emphasis"><em>Insert</em></span> key) as well as other methods when the input position is being modified.</p><pre class="programlisting">void WordDocument::OnKeyboardMode(KeyboardMode/*=KeyboardMode*/) { &#13;
  UpdateCaret(); &#13;
} &#13;
 &#13;
void WordDocument::UpdateCaret() { &#13;
  switch (wordMode) { &#13;
    case WordEdit: { &#13;
        CharInfo charInfo = charList[editIndex];&#13;
        Rect caretRect = charList[editIndex].CharRect();</pre><p>In <code class="literal">edit</code> mode, the caret will be visible, and we obtain the area from the edit character. However, if the <code class="literal">nextFont</code> font is active (does not equal the <code class="literal">SystemFont</code> font), the user has changed the font, which we must take into consideration. In that case, we set the width and height of the caret in accordance with the size of an average character of the <code class="literal">nextFont</code> font.</p><pre class="programlisting">        if (nextFont != SystemFont) { &#13;
          int width = GetCharacterAverageWidth(nextFont), &#13;
              height = GetCharacterHeight(nextFont); &#13;
          caretRect.Right() = caretRect.Left() + width; &#13;
          caretRect.Top() = caretRect.Bottom() - height; &#13;
        } &#13;
</pre><p>If the <code class="literal">nextFont</code> font is not active, we check whether the keyboard holds <code class="literal">insert</code> mode and the caret is not located at the beginning of the paragraph. In that case, the caret's vertical coordinates will reflect the font size of the preceding character, since the next character to be input will be given its font.</p><pre class="programlisting">        else if ((GetKeyboardMode() == InsertKeyboard) &amp;&amp; &#13;
                 (charInfo.ParagraphPtr()-&gt;First() &lt; editIndex)) { &#13;
          Rect prevCharRect = charList[editIndex - 1].CharRect(); &#13;
          caretRect.Top() = caretRect.Bottom() – prevCharRect.Height(); &#13;
        }&#13;
</pre><p>If the keyboard holds the <code class="literal">insert</code> mode, the caret will be a vertical bar, regardless of whether the <code class="literal">nextFont</code> font is active. It is given the width of one unit (which is later rounded to the width of one physical pixel).</p><pre class="programlisting">        if (GetKeyboardMode() == InsertKeyboard) { &#13;
          caretRect.Right() = caretRect.Left() + 1; &#13;
        } &#13;
</pre><p>The caret will not extend outside the page. If it does, its right border is set to the page's border.</p><pre class="programlisting">        if (caretRect.Right() &gt;= PageInnerWidth()) { &#13;
          caretRect.Right() = PageInnerWidth() - 1; &#13;
        } &#13;
</pre><p>Finally, we need the top position of the edit paragraph, since the caret so far is calculated relative to its top position.</p><pre class="programlisting">        Paragraph* paragraphPtr = &#13;
          charList[editIndex].ParagraphPtr(); &#13;
        Point topLeft = Point(0, paragraphPtr-&gt;Top()); &#13;
        SetCaret(topLeft + caretRect); &#13;
      } &#13;
      break; &#13;
</pre><p>In <code class="literal">mark</code> mode, the caret will be invisible. Therefore, we call <code class="literal">ClearCaret</code> as follows:</p><pre class="programlisting">    case WordMark: &#13;
      ClearCaret(); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Mouse input"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Mouse input</h2></div></div></div><p>The <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseMove</code>, <code class="literal">OnMouseUp</code>, and <code class="literal">OnDoubleClick</code> methods take the pressed buttons and the mouse coordinates. In all four cases, we check that the left mouse button is pressed. The <code class="literal">OnMouseDown</code> method first calls the <code class="literal">EnsureEditStatus</code> method in order to clear any potential marked area. Then it sets the application to <code class="literal">mark</code> mode (which may later be changed by the <code class="literal">OnMouseUp</code> method) and looks up the index of the character pointed at by calling the <code class="literal">MousePointToIndex</code> method. The <code class="literal">nextFont</code> field is cleared by a call to the <code class="literal">ClearNextFont</code> method. We also call the <code class="literal">UpdateCaret</code> method, since the caret will be cleared while the user drags the mouse.</p><pre class="programlisting">void WordDocument::OnMouseDown(MouseButton mouseButtons, &#13;
                          Point mousePoint, bool shiftPressed, &#13;
                          bool controlPressed) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    EnsureEditStatus(); &#13;
    ClearNextFont(); &#13;
    wordMode = WordMark; &#13;
    firstMarkIndex = lastMarkIndex = &#13;
      MousePointToIndex(mousePoint); &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">OnMouseMove</code> method, we retrieve the paragraph and character of the mouse by calling the <code class="literal">MousePointToIndex</code> method. If the mouse has been moved to a new character since the last call to the <code class="literal">OnMouseDown</code> or <code class="literal">OnMouseMove</code> method, we update the marked text by calling the <code class="literal">InvalidateBlock</code> method with the current and new mouse position, which invalidates the part of the text between the current and previous mouse event. Note that we do not invalidate the whole marked block. We only invalidate the block between the previous and current mouse positions in order to avoid dazzles.</p><pre class="programlisting">void WordDocument::OnMouseMove(MouseButton mouseButtons, &#13;
                          Point mousePoint, bool shiftPressed, &#13;
                          bool controlPressed) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    int newLastMarkIndex = MousePointToIndex(mousePoint); &#13;
 &#13;
    if (lastMarkIndex != newLastMarkIndex) { &#13;
      InvalidateBlock(lastMarkIndex, newLastMarkIndex); &#13;
      lastMarkIndex = newLastMarkIndex; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">OnMouseUp</code> method, we just have to check the last position. If it is the same as the first position (the user pressed and released the mouse at the same character), we change the application to <code class="literal">edit</code> mode and call the <code class="literal">UpdateCaret</code> method to make the caret visible.</p><pre class="programlisting">void WordDocument::OnMouseUp(MouseButton mouseButtons, &#13;
                             Point mousePoint, bool shiftPressed, &#13;
                             bool controlPressed) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    if (firstMarkIndex == lastMarkIndex) { &#13;
      wordMode = WordEdit; &#13;
      editIndex = min(firstMarkIndex, charList.Size() - 1); &#13;
      UpdateCaret(); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">MousePointToIndex</code> method finds the paragraph that the user has clicked on and calls the <code class="literal">MousePointToParagraphIndex</code> method to find the character in the paragraph. The reason we divide the functionality into two methods is that the <code class="literal">MousePointToIndexDown</code> method in <a class="link" href="ch07.html" title="Chapter 7. Keyboard Input and Character Calculation">Chapter 7</a>, <span class="emphasis"><em>Keyboard Input and Character Calculation</em></span>, also calls the <code class="literal">MousePointToParagraphIndex</code> method, which iterates through the paragraph list. If the vertical position is less than the top position of a paragraph, the correct paragraph is the previous one.</p><p>This somewhat cumbersome way of finding the correct paragraph is due to the fact that paragraphs are distributed over the pages in such manner that when a paragraph does not fit on the rest of the page, or if it is marked with a page break, it is placed at the beginning of the next page. This may result in parts of the document where no paragraph is located. If the user clicks on such an area, we want the paragraph located before that area to be the correct one. In the same way, if the user clicks below the last paragraph of the document, it becomes the correct one.</p><pre class="programlisting">int WordDocument::MousePointToIndex(Point mousePoint) const{ &#13;
  for (int parIndex = 1; parIndex &lt; paragraphList.Size(); &#13;
       ++parIndex) { &#13;
    Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
 &#13;
    if (mousePoint.Y() &lt; paragraphPtr-&gt;Top()) { &#13;
      return MousePointToParagraphIndex &#13;
             (paragraphList[parIndex - 1], mousePoint); &#13;
    } &#13;
  } &#13;
 &#13;
  return MousePointToParagraphIndex &#13;
         (paragraphList[paragraphList.Size() - 1], mousePoint); &#13;
} &#13;
</pre><p>The <code class="literal">MousePointToParagraphIndex</code> method finds the clicked character in the paragraph. First, we subtract the paragraph's top position from the mouse position, since the paragraph's line coordinates are relative to the paragraph's top position.</p><pre class="programlisting">int WordDocument::MousePointToParagraphIndex &#13;
                          (Paragraph* paragraphPtr,Point mousePoint) const{ &#13;
  mousePoint.Y() -= paragraphPtr-&gt;Top(); &#13;
</pre><p>As mentioned previously, the user may click on a position below the paragraph's area. In that case, we set the mouse position to its height, <code class="literal">-1</code>, which is equivalent to the user clicking on the last line of the paragraph.</p><pre class="programlisting">  if (mousePoint.Y() &gt;= paragraphPtr-&gt;Height()) { &#13;
    mousePoint.Y() = paragraphPtr-&gt;Height() - 1; &#13;
  } &#13;
</pre><p>First, we need to find the correct line in the paragraph. We check every line and test if the mouse position is located within the line by comparing it to the sum of the line's top position and its height. Compared to the paragraph search in the <code class="literal">MousePointToIndex</code> method, as mentioned previously, this search is a bit simpler, since there is no space between the lines in the paragraph as there may be between the paragraphs in the document.</p><pre class="programlisting">  int firstChar = paragraphPtr-&gt;First();&#13;
  for (LineInfo* lineInfoPtr : paragraphPtr-&gt;LinePtrList()) { &#13;
    if (mousePoint.Y() &lt; (lineInfoPtr-&gt;Top() + &#13;
                          lineInfoPtr-&gt;Height())) { &#13;
      Rect firstRect =&#13;
              charList[firstChar +lineInfoPtr-&gt;First()].CharRect(),&#13;
            lastRect =&#13;
              charList[firstChar + lineInfoPtr-&gt;Last()].CharRect(); &#13;
</pre><p>When we have found the correct line, we have three cases to consider: the user may have clicked on the left of the text (if the paragraph is center or right aligned), to its right (if it is left or center aligned), or on the text itself. If they have clicked on the left or right of the line, we return the index of the first or last character of the line. Note that we add the index of the first character of the paragraph, since the indexes of the lines are relative to the paragraph's first index.</p><pre class="programlisting">      if (mousePoint.X() &lt; firstRect.Left()) { &#13;
        return paragraphPtr-&gt;First() + lineInfoPtr-&gt;First(); &#13;
      } &#13;
      else if (lastRect.Right() &lt;= mousePoint.X()) { &#13;
        return paragraphPtr-&gt;First() + lineInfoPtr-&gt;Last(); &#13;
      } &#13;
</pre><p>If the user has clicked on the text, we need to find the correct character. We iterate through the characters of the line and compare the mouse position to the right-hand border of the character. When we have found the correct character, we need to decide whether the user has clicked near the character's left or right border. In case of the right border, we add one to the character index.</p><pre class="programlisting">      else { &#13;
        for (int charIndex = lineInfoPtr-&gt;First(); &#13;
             charIndex &lt;= lineInfoPtr-&gt;Last(); ++charIndex) { &#13;
          Rect charRect = charList[charIndex].CharRect(); &#13;
 &#13;
          if (mousePoint.X() &lt; charRect.Right()) { &#13;
            int leftSize = mousePoint.X() - charRect.Left(), &#13;
                rightSide = charRect.Right() - mousePoint.X(); &#13;
 &#13;
            return paragraphPtr-&gt;First() + &#13;
              ((leftSize &lt; rightSide) ? charIndex &#13;
                                      : (charIndex + 1)); &#13;
          } &#13;
        } &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>As mentioned previously, there is no space between the lines in a paragraph. Therefore, we will always find the correct line and never reach this point. However, in order to avoid compiler errors, we still have to return a value. In this book, we will on a few occasions use the following notation:</p><pre class="programlisting">  assert(false); &#13;
  return 0; &#13;
} &#13;
 &#13;
void WordDocument::InvalidateBlock(int firstIndex, int lastIndex){ &#13;
  int minIndex = min(firstIndex, lastIndex), &#13;
      maxIndex = min(max(firstIndex, lastIndex).&#13;
                     charList.Size() - 1); &#13;
 &#13;
  for (int charIndex = minIndex; charIndex &lt;= maxIndex; &#13;
       ++charIndex) { &#13;
    CharInfo charInfo = charList[charIndex]; &#13;
    Point topLeft(0, charInfo.ParagraphPtr()-&gt;Top()); &#13;
    Invalidate(topLeft + charInfo.CharRect()); &#13;
  } &#13;
} &#13;
</pre><p>When the user double-clicks the left mouse button, the word hit by the mouse will be marked. The application has been set to <code class="literal">edit</code> mode and the <code class="literal">editIndex</code> method has been properly set, because the call to the <code class="literal">OnDoubleClick</code> method is always preceded by calls to the <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseUp</code> methods. If the mouse hits a word, we mark the word and set the application to <code class="literal">mark</code> mode.</p><p>We find the indexes of the first and last characters in a word by calling the <code class="literal">GetFirstWordIndex</code> and <code class="literal">GetLastWordIndex</code> methods. If the first index is less than the last index, the user has double-clicked on an actual word, which we mark. If the first index is not less than the last index, the user has double-clicked on a space or a delimiter, in which case the double-click has no effect.</p><pre class="programlisting">void WordDocument::OnDoubleClick(MouseButton mouseButtons, &#13;
                     Point mousePoint, bool shiftPressed, &#13;
                     bool controlPressed) { &#13;
  int firstIndex = GetFirstWordIndex(editIndex), &#13;
      lastIndex = GetLastWordIndex(editIndex); &#13;
 &#13;
  if (firstIndex &lt; lastIndex) { &#13;
    wordMode = WordMark; &#13;
    firstMarkIndex = firstIndex; &#13;
    lastMarkIndex = lastIndex; &#13;
 &#13;
    UpdateCaret(); &#13;
    InvalidateBlock(firstMarkIndex, lastMarkIndex); &#13;
    UpdateWindow(); &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">GetFirstWordIndex</code> method, we find the index of the first character of the word by going backward in the character list until we reach the beginning of the document or a character that is not a letter.</p><pre class="programlisting">int WordDocument::GetFirstWordIndex(int charIndex) const{ &#13;
  while ((charIndex &gt;= 0) &amp;&amp; &#13;
         (isalpha(charList[charIndex].Char()))) { &#13;
    --charIndex; &#13;
  } &#13;
  return (charIndex + 1); &#13;
} &#13;
</pre><p>In the <code class="literal">GetLastWordIndex</code> method, we do not need to check the end of the character list, since the last character always is a newline, which is not a letter. Note that in this case we return the index of the character after the last character of the word, since the marking of text is valid up to, but not inclusive of, the last character.</p><pre class="programlisting">int WordDocument::GetLastWordIndex(int charIndex) const{ &#13;
  while (isalpha(charList[charIndex].Char())) { &#13;
    ++charIndex; &#13;
  } &#13;
  return charIndex; &#13;
} &#13;
</pre></div><div class="section" title="Touchscreen"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Touchscreen</h2></div></div></div><p>On a touchscreen, the user can zoom the document by dragging two fingers on the screen. The <code class="literal">OnTouchDown</code> method is called when the user touches the screen, and the <code class="literal">OnTouchMove</code> method is called when they move their fingers. Unlike the mouse input methods mentioned previously, the user can touch several points on the screen at the same time. The points are stored in the <code class="literal">pointList</code> list.</p><p>If the list does not hold two points, we just let the <code class="literal">Window</code> class perform the default action, which is to convert each touch action to a mouse action.</p><pre class="programlisting">void WordDocument::OnTouchDown(vector&lt;Point&gt; pointList) { &#13;
  if (pointList.size() == 2) { &#13;
    initZoom = GetZoom(); &#13;
    Point firstInitPoint = pointList[0], &#13;
          secondInitPoint = pointList[1]; &#13;
    double width = firstInitPoint.X() - secondInitPoint.X(), &#13;
           height = firstInitPoint.Y() - secondInitPoint.Y(), &#13;
    initDistance = sqrt((width * width) + (height * height)); &#13;
  } &#13;
  else { &#13;
    Window::OnTouchDown(pointList); &#13;
  } &#13;
} &#13;
</pre><p>When the user moves their fingers on the screen, the distance between the fingers is calculated and the zoom is set with regard to the initial distance. The zooming is allowed to range between 10% (factor 0.1) and 1,000% (factor 10.0):</p><pre class="programlisting">void WordDocument::OnTouchMove(vector&lt;Point&gt; pointList) { &#13;
  if (pointList.size() == 2) { &#13;
    Point firstPoint = pointList[0], secondPoint = pointList[1]; &#13;
 &#13;
    int width = firstPoint.X() - secondPoint.X(), &#13;
        height = firstPoint.Y() - secondPoint.Y(); &#13;
    double distance = sqrt((width * width) + (height * height)); &#13;
 &#13;
    double factor = distance / initDistance; &#13;
    double newZoom = factor * initZoom; &#13;
    SetZoom(min(max(newZoom, 0.1), 10.0)); &#13;
 &#13;
    UpdateCaret(); &#13;
    Invalidate(); &#13;
    UpdateWindow(); &#13;
  } &#13;
  else { &#13;
    Window::OnTouchMove(pointList); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Page setup and calculation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Page setup and calculation</h2></div></div></div><p>The <code class="literal">OnPageSetup</code> method is called when the user selects the standard <span class="strong"><strong>Page Setup</strong></span> menu item in the <span class="strong"><strong>File</strong></span> menu. Since the page settings have been altered, we need to recalculate each paragraph as well as the whole document.</p><pre class="programlisting">void WordDocument::OnPageSetup(PageSetupInfo pageSetupInfo) { &#13;
  ClearNextFont(); &#13;
 &#13;
  for (Paragraph* paragraphPtr : paragraphList) { &#13;
    GenerateParagraph(paragraphPtr); &#13;
  } &#13;
 &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre><p>A small change may affect the whole document, and we need to calculate the paragraphs and distribute them on the pages in the document.</p><pre class="programlisting">void WordDocument::CalculateDocument() { &#13;
  int pageInnerWidth = PageInnerWidth(), &#13;
      pageInnerHeight = PageInnerHeight(), &#13;
      documentHeight = 0, newTotalPages = 1; &#13;
</pre><p>We iterate through the paragraph list, and in case the current document height differs from the paragraph's top position, we update its top position and invalidate it.</p><pre class="programlisting">  for (int parIndex = 0; parIndex &lt; paragraphList.Size(); &#13;
       ++parIndex) { &#13;
    Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
 &#13;
    if (paragraphPtr-&gt;Top() != documentHeight) { &#13;
      paragraphPtr-&gt;Top() = documentHeight; &#13;
      Invalidate(Rect(0, paragraphPtr-&gt;Top(), pageInnerWidth, &#13;
                 paragraphPtr-&gt;Top() + paragraphPtr-&gt;Height())); &#13;
    } &#13;
</pre><p>We have a page break if the paragraph is marked with a page break and if it is not already located at the top of a page.</p><pre class="programlisting">    bool pageBreak = paragraphPtr-&gt;PageBreak() &amp;&amp; &#13;
                     ((paragraphPtr-&gt;Top() % pageInnerHeight) != 0); &#13;
</pre><p>The paragraph does not fit on the rest of the page if its top position plus its height is greater than the page height.</p><pre class="programlisting">    bool notFitOnPage = &#13;
      (documentHeight &gt; 0) &amp;&amp;&#13;
      ((paragraphPtr-&gt;Top() + paragraphPtr-&gt;Height()) &gt; &#13;
      (newTotalPages * pageInnerHeight)); &#13;
</pre><p>If we have a page break, or if the paragraph does not fit on the rest of the page, we invalidate the rest of the page and place the paragraph at the top of the next page.</p><pre class="programlisting">    if (pageBreak || notFitOnPage) { &#13;
      Rect restOfPage(0, documentHeight, pageInnerWidth, &#13;
                      newTotalPages * pageInnerHeight); &#13;
      Invalidate(restOfPage); &#13;
      paragraphPtr-&gt;Top() = (newTotalPages++) * pageInnerHeight;</pre><p>Since the paragraph has been moved to a new position, we need to invalidate its new area.</p><pre class="programlisting">      Invalidate(Rect(0, paragraphPtr-&gt;Top(), pageInnerWidth,&#13;
                 paragraphPtr-&gt;Top() + paragraphPtr-&gt;Height()));&#13;
      documentHeight = paragraphPtr-&gt;Top() + &#13;
                       paragraphPtr-&gt;Height(); &#13;
    } &#13;
</pre><p>If the paragraph fits on the rest of the document, we just increase the document height.</p><pre class="programlisting">    else { &#13;
      documentHeight += paragraphPtr-&gt;Height(); &#13;
    } &#13;
  } &#13;
</pre><p>After the last paragraph, we need to invalidate the rest of the last page.</p><pre class="programlisting">  Rect restOfPage(0, documentHeight, pageInnerWidth, &#13;
                  newTotalPages * pageInnerHeight); &#13;
  Invalidate(restOfPage); &#13;
</pre><p>If the number of pages has changed, we invalidate the pages that differ.</p><pre class="programlisting">  if (totalPages != newTotalPages) { &#13;
    int minTotalPages = min(totalPages, newTotalPages), &#13;
        maxTotalPages = max(totalPages, newTotalPages); &#13;
    Invalidate(Rect(0, minTotalPages * pageInnerHeight, &#13;
                    pageInnerWidth, maxTotalPages * pageInnerHeight));     &#13;
    totalPages = newTotalPages; &#13;
    SetVerticalScrollTotalHeight(totalPages * pageInnerHeight);&#13;
  }&#13;
} &#13;
</pre></div><div class="section" title="Painting and drawing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Painting and drawing</h2></div></div></div><p>The <code class="literal">OnPaint</code> method performs the action that is specific to drawing the client area, while the <code class="literal">OnPrint</code> method performs the action specific to printing. The default behavior for both the <code class="literal">OnPaint</code> and <code class="literal">OnPrint</code> methods in the <code class="literal">StandardDocument</code> class is to call the <code class="literal">OnDraw</code> method.</p><p>In the application of the previous chapters, we have overridden only the <code class="literal">OnDraw</code> method, resulting in the same drawing regardless of whether the drawing occurs in the client area or is sent to a printer. However, in this application, we also override the <code class="literal">OnPaint</code> method, which fills the parts of the client area outside the document with a light gray color and places the text <span class="strong"><strong>Page Break</strong></span> between every pair of pages, and finally calls the <code class="literal">OnDraw</code> method that performs the actual drawing of the document.</p><pre class="programlisting">void WordDocument::OnPaint(Graphics&amp; graphics) const { &#13;
  int pageInnerWidth = PageInnerWidth(), &#13;
      pageInnerHeight = PageInnerHeight(); &#13;
 &#13;
  int documentInnerHeight = totalPages * pageInnerHeight; &#13;
  Size clientSize = GetClientSize(); &#13;
 &#13;
  if (pageInnerWidth() &lt; clientSize.Width()) {&#13;
    int maxHeight = max(documentInnerHeight, clientSize.Height());&#13;
    Rect rightRect(pageInnerWidth, 0,&#13;
                   clientSize.Width(), maxHeight);&#13;
    graphics.FillRectangle(rightRect, LightGray, LightGray); &#13;
  } &#13;
 &#13;
  if (documentInnerHeight() &lt; clientSize.Height()) { &#13;
    Rect bottomRect(0, documentInnerHeight(), &#13;
                    pageInnerWidth(), clientSize.Height()); &#13;
    graphics.FillRectangle(bottomRect, LightGray, LightGray); &#13;
  } &#13;
&#13;
  OnDraw(graphics, Paint);&#13;
 &#13;
  int breakWidth = min(clientSize.Width()), &#13;
      breakHeight = GetCharacterHeight(SystemFont); &#13;
  Size breakSize(breakWidth, breakHeight); &#13;
 &#13;
  for (int pageIndex = 1; pageIndex &lt; totalPages; ++pageIndex) { &#13;
    int line = pageIndex * pageInnerHeight; &#13;
    graphics.DrawLine(Point(0, line), Point(pageInnerWidth, line), &#13;
                      Black); &#13;
 &#13;
    Point topLeft(0, line - (breakHeight / 2)); &#13;
    graphics.DrawText(Rect(topLeft, breakSize), &#13;
                      TEXT("Page Break"), SystemFont,Black,White); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnDraw</code> method draws every character in the <code class="literal">charList</code> list. The <code class="literal">drawMode</code> parameter is <code class="literal">Paint</code> if the <code class="literal">OnDraw</code> method is called by the <code class="literal">OnPaint</code> method, and <code class="literal">Print</code> if it is called by the <code class="literal">OnPrint</code> method. In the previous applications, we have ignored the <code class="literal">drawMode</code> method. However, in this application, we draw a small square at every paragraph marked with a page break, if called by the <code class="literal">OnPaint</code> method.</p><pre class="programlisting">void WordDocument::OnDraw(Graphics&amp; graphics, DrawMode drawMode) const { &#13;
  minCharIndex = min(firstMarkIndex, lastMarkIndex), &#13;
  maxCharIndex = max(firstMarkIndex, lastMarkIndex); &#13;
 &#13;
  for (int charIndex = 0; charIndex &lt;= charList.Size() - 1; &#13;
       ++charIndex) { &#13;
    CharInfo charInfo = charList[charIndex]; &#13;
    Point topLeft(0, charInfo.ParagraphPtr()-&gt;Top()); &#13;
 &#13;
    Color textColor = charInfo.CharFont().GetColor(); &#13;
    Color backColor = textColor.Inverse(); &#13;
</pre><p>If the character is marked, its text and background colors are inverted.</p><pre class="programlisting">    if ((wordMode == WordMark) &amp;&amp; &#13;
        (minCharIndex &lt;= charIndex)&amp;&amp;(charIndex &lt; maxCharIndex)) { &#13;
      swap(textColor, backColor); &#13;
    } &#13;
</pre><p>If the character is newline, a space is drawn instead.</p><pre class="programlisting">    TCHAR tChar = (charInfo.Char() == NewLine)&#13;
                  ? Space: charInfo.Char(); &#13;
    TCHAR text[] = {tChar, TEXT('\0')}; &#13;
</pre><p>If the character's rectangle is located outside the page, its right border is set to the page right border.</p><pre class="programlisting">    Rect charRect = charList[charIndex].CharRect(); &#13;
    if (charRect.Right() &gt;= pageWidth) { &#13;
      charRect.Right() = pageWidth - 1; &#13;
    } &#13;
</pre><p>Finally, the character is drawn:</p><pre class="programlisting">    graphics.DrawText(topLeft + charRect, text, &#13;
                      charInfo.CharFont(), textColor, backColor); &#13;
  } &#13;
</pre><p>Actually, there is one more thing: if the <code class="literal">OnDraw</code> method has been called by the <code class="literal">OnPaint</code> method, we draw a small red square (2 × 2 millimeters) at its top-left position for every paragraph marked with a page break.</p><pre class="programlisting">  if (drawMode == Paint) { &#13;
    for (Paragraph* paragraphPtr : paragraphList) { &#13;
      if (paragraphPtr-&gt;PageBreak()) { &#13;
        Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
        graphics.FillRectangle(Rect(topLeft, topLeft + &#13;
                                    Size(200, 200)), Red, Red); &#13;
      } &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="File management"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>File management</h2></div></div></div><p>The <code class="literal">ClearDocument</code> method is called by the <code class="literal">StandardDocument</code> class when the user selects the <span class="strong"><strong>New</strong></span> menu item in the <span class="strong"><strong>File</strong></span> menu; the <code class="literal">WriteDocumentToStream</code> method is called when they select the <span class="strong"><strong>Save</strong></span> or <span class="strong"><strong>Save As</strong></span> menu items in the <span class="strong"><strong>File</strong></span> menu, and the <code class="literal">ReadDocumentFromStream</code> method is called when they select the <span class="strong"><strong>Open</strong></span> menu item.</p><p>The <code class="literal">ClearDocument</code> method deletes every paragraph in the <code class="literal">paragraphList</code> list by calling the <code class="literal">DeleteParagraph</code> method, which, in turn, deletes each line of the paragraph. This is actually the only memory we need to delete, since it is the only dynamically allocated memory of this application. Finally, the <code class="literal">InitDocument</code> method is called, which initializes an empty document.</p><pre class="programlisting">void DeleteParagraph(Paragraph* paragraphPtr) { &#13;
  for (LineInfo* lineInfoPtr : paragraphPtr-&gt;LinePtrList()) { &#13;
    delete lineInfoPtr; &#13;
  } &#13;
 &#13;
  delete paragraphPtr; &#13;
} &#13;
 &#13;
void WordDocument::ClearDocument() { &#13;
  nextFont = SystemFont; &#13;
 &#13;
  for (Paragraph* paragraphPtr : paragraphList) { &#13;
    DeleteParagraph(paragraphPtr); &#13;
  } &#13;
 &#13;
  charList.Clear(); &#13;
  paragraphList.Clear(); &#13;
  InitDocument(); &#13;
} &#13;
</pre><p>The <code class="literal">WriteDocumentToStream</code> method writes all the information about the document to the stream: the <code class="literal">application</code> mode (edit or mark), the index of the edit character, the indexes of the first and last marked characters, the number of pages in the document, and the next font. The idea is that the document will be opened in the exact same shape as it was written.</p><pre class="programlisting">bool WordDocument::WriteDocumentToStream(String name, &#13;
                                         ostream&amp; outStream)const{ &#13;
  if (EndsWith(name, TEXT(".wrd")) &amp;&amp; &#13;
      WritePageSetupInfoToStream(outStream)){ &#13;
    outStream.write((char*) &amp;wordMode, sizeof wordMode); &#13;
    outStream.write((char*) &amp;editIndex, sizeof editIndex); &#13;
&#13;
    outStream.write((char*) &amp;firstMarkIndex, &#13;
                    sizeof firstMarkIndex); &#13;
    outStream.write((char*) &amp;lastMarkIndex, sizeof lastMarkIndex); &#13;
    outStream.write((char*) &amp;totalPages, sizeof totalPages); &#13;
    nextFont.WriteFontToStream(outStream); &#13;
 &#13;
    { int charInfoListSize = charList.Size(); &#13;
      outStream.write((char*) &amp;charInfoListSize, &#13;
                      sizeof charInfoListSize); &#13;
      for (CharInfo charInfo : charList) { &#13;
        charInfo.WriteCharInfoToStream(outStream); &#13;
      } &#13;
    } &#13;
 &#13;
    { int paragraphListSize = paragraphList.Size(); &#13;
      outStream.write((char*) &amp;paragraphListSize, &#13;
                      sizeof paragraphListSize); &#13;
 &#13;
      for (const Paragraph* paragraphPtr : paragraphList) { &#13;
        paragraphPtr-&gt;WriteParagraphToStream(outStream); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>However, if the file suffix is <code class="literal">.txt</code>, we save the word in text format and discard all formatting.</p><pre class="programlisting">  else if (EndsWith(name, TEXT(".txt"))) { &#13;
    for (CharInfo charInfo : charList) { &#13;
      char c = (char) charInfo.Char(); &#13;
      outStream.write(&amp;c, sizeof c); &#13;
    } &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
</pre><p>The <code class="literal">ReadDocumentFromStream</code> method reads the information written by the <code class="literal">WriteDocumentToStream</code> method. Note that the <code class="literal">MakeVisible</code> method is called at the end in order to make the current position visible.</p><pre class="programlisting">bool WordDocument::ReadDocumentFromStream(String name, &#13;
                                          istream&amp; inStream) { &#13;
  if (EndsWith(name, TEXT(".wrd")) &amp;&amp; &#13;
      ReadPageSetupInfoFromStream(inStream)){ &#13;
    inStream.read((char*) &amp;wordMode, sizeof wordMode); &#13;
    inStream.read((char*) &amp;editIndex, sizeof editIndex); &#13;
    inStream.read((char*) &amp;firstMarkIndex, sizeof firstMarkIndex); &#13;
    inStream.read((char*) &amp;lastMarkIndex, sizeof lastMarkIndex); &#13;
    inStream.read((char*) &amp;totalPages, sizeof totalPages); &#13;
    nextFont.ReadFontFromStream(inStream); &#13;
 &#13;
    { charList.Clear(); &#13;
      int charInfoListSize; &#13;
      inStream.read((char*) &amp;charInfoListSize, &#13;
                    sizeof charInfoListSize); &#13;
 &#13;
      for (int count = 0; count &lt; charInfoListSize; ++count) { &#13;
        CharInfo charInfo; &#13;
        charInfo.ReadCharInfoFromStream(inStream); &#13;
        charList.PushBack(charInfo); &#13;
      } &#13;
    } &#13;
 &#13;
    { paragraphList.Clear(); &#13;
      int paragraphListSize; &#13;
      inStream.read((char*) &amp;paragraphListSize, &#13;
                    sizeof paragraphListSize); &#13;
 &#13;
      for (int count = 0; count &lt; paragraphListSize; ++count) { &#13;
        Paragraph* paragraphPtr = new Paragraph(); &#13;
        assert(paragraphPtr != nullptr); &#13;
        paragraphPtr-&gt;ReadParagraphFromStream(this, inStream); &#13;
        paragraphList.PushBack(paragraphPtr); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>However, if the file has the file suffix <code class="literal">.txt</code>, we just read the characters, and all characters are given the system font.</p><pre class="programlisting">  else if (EndsWith(name, TEXT(".txt"))) { &#13;
    wordMode = WordEdit; &#13;
    editIndex = 0; &#13;
    firstMarkIndex = 0; &#13;
    lastMarkIndex = 0; &#13;
    totalPages = 0; &#13;
    nextFont = SystemFont; &#13;
 &#13;
    Paragraph* paragraphPtr = new Paragraph(0, 0, Left, 0); &#13;
    int charIndex = 0, paragraphIndex = 0; &#13;
    char c; &#13;
 &#13;
    while (inStream &gt;&gt; c) { &#13;
      CharInfo charInfo(paragraphPtr, (TCHAR) c, &#13;
                        SystemFont, ZeroRect); &#13;
      charList.PushBack(charInfo); &#13;
 &#13;
      if (c == '\n') { &#13;
        paragraphPtr-&gt;Last() = charIndex;&#13;
        for (int index = paragraphPtr-&gt;First();&#13;
             index &lt;= paragraphPtr-&gt;Last(); ++index) {&#13;
          charList[index].ParagraphPtr() = paragraphPtr;&#13;
        }&#13;
&#13;
        GenerateParagraph(paragraphPtr);&#13;
        paragraphList.PushBack(paragraphPtr); &#13;
        Paragraph* paragraphPtr = &#13;
          new Paragraph(charIndex + 1, 0, Left, ++paragraphIndex); &#13;
      } &#13;
 &#13;
      ++charIndex; &#13;
    } &#13;
 &#13;
    paragraphPtr-&gt;Last() = charIndex;&#13;
    for (int index = paragraphPtr-&gt;First();&#13;
         index &lt;= paragraphPtr-&gt;Last(); ++index) {&#13;
      charList[index].ParagraphPtr() = paragraphPtr;&#13;
    }&#13;
&#13;
    GenerateParagraph(paragraphPtr); &#13;
    paragraphList.PushBack(paragraphPtr); &#13;
    CalculateDocument(); &#13;
  } &#13;
 &#13;
  MakeVisible(); &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre></div><div class="section" title="Cut, copy, and paste"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Cut, copy, and paste</h2></div></div></div><p>The <span class="strong"><strong>Copy</strong></span> item in the <span class="strong"><strong>Edit</strong></span> menu is enabled in <code class="literal">mark</code> mode:</p><pre class="programlisting">bool WordDocument::CopyEnable() const { &#13;
  return (wordMode == WordMark); &#13;
} &#13;
</pre><p>As long as the <code class="literal">CopyEnable</code> method mentioned previously returns <code class="literal">true</code>, we are always ready to copy in every format. Therefore, we must let the <code class="literal">IsCopyAsciiReady</code>, <code class="literal">IsCopyUnicodeReady</code>, and <code class="literal">IsCopyGenericReady</code> methods return <code class="literal">true</code> (if they return <code class="literal">false</code> in the <code class="literal">StandardDocument</code> class).</p><pre class="programlisting">bool WordDocument::IsCopyAsciiReady() const { &#13;
  return true; &#13;
} &#13;
 &#13;
bool WordDocument::IsCopyUnicodeReady() const { &#13;
  return true; &#13;
} &#13;
 &#13;
bool WordDocument::IsCopyGenericReady(int /* format */) const { &#13;
  return true; &#13;
} &#13;
</pre><p>The <code class="literal">CopyAscii</code> method simply calls the <code class="literal">CopyUnicode</code> method, since the text is stored in the generic text format and is transformed into ASCII and Unicode when saved to the global clipboard. The <code class="literal">CopyUnicode</code> method iterates through the marked paragraphs and, for each marked paragraph, extracts the marked text that is stored in the paragraph to the <code class="literal">textList</code> parameter. When it encounters a newline, it pushes the current text in the <code class="literal">textList</code> parameter.</p><pre class="programlisting">void WordDocument::CopyAscii(vector&lt;String&gt;&amp; textList) { &#13;
  CopyUnicode(textList); &#13;
} &#13;
 &#13;
void WordDocument::CopyUnicode(vector&lt;String&gt;&amp; textList) { &#13;
  int minCharIndex = min(firstMarkIndex, lastMarkIndex), &#13;
      maxCharIndex = max(firstMarkIndex, lastMarkIndex); &#13;
 &#13;
  String text; &#13;
  for (int charIndex = minCharIndex; charIndex &lt; maxCharIndex; &#13;
       ++charIndex) { &#13;
    CharInfo charInfo = charList[charIndex]; &#13;
    text.push_back(charInfo.Char()); &#13;
 &#13;
    if (charInfo.Char() == NewLine) { &#13;
      textList.push_back(text); &#13;
      text.clear(); &#13;
    } &#13;
  } &#13;
 &#13;
  textList.push_back(text); &#13;
} &#13;
</pre><p>The <code class="literal">CopyGeneric</code> method is simpler than the <code class="literal">CopyUnicode</code> method. It first saves the number of characters to be copied, then iterates through the marked characters (not the paragraphs), and then calls the <code class="literal">WriteCharInfoToClipboard</code> method for each character. This works, since each pair of paragraphs is already separated by a newline in the <code class="literal">charList</code> list. We really do not care about the format, since there is just one format (<code class="literal">WordFormat</code>) for generic cut, copy, and paste operations in this application.</p><pre class="programlisting">void WordDocument::CopyGeneric(int /* format */, &#13;
                               InfoList&amp; infoList) const { &#13;
  int minCharIndex = min(firstMarkIndex, lastMarkIndex), &#13;
      maxCharIndex = max(firstMarkIndex, lastMarkIndex); &#13;
  int copySize = maxCharIndex - minCharIndex; &#13;
  infoList.AddValue&lt;int&gt;(copySize); &#13;
 &#13;
  for (int charIndex = minCharIndex; charIndex &lt; maxCharIndex; &#13;
       ++charIndex) { &#13;
    CharInfo charInfo = charList[charIndex]; &#13;
    charInfo.WriteCharInfoToClipboard(infoList); &#13;
  } &#13;
} &#13;
</pre><p>One difference between copying and pasting is that when the user selects <span class="strong"><strong>Cut</strong></span> or <span class="strong"><strong>Copy</strong></span>, the marked text is copied in all three formats (ASCII, Unicode, and generic) given in the preceding <code class="literal">StandardDocument</code> constructor. Their order does not really matter. When pasting, on the other hand, the <code class="literal">StandardDocument</code> constructor tries to paste the text in the formats order given in the constructor call. If it finds pasted information in one format in the global clipboard, it does not continue to check the other format. In this application, it means that if there is text copied in the generic format (<code class="literal">WordFormat</code>), then that text is pasted regardless of whether there is text in the ASCII of Unicode format (<code class="literal">AsciiFormat</code> or <code class="literal">UnicodeFormat</code>).</p><p>The <code class="literal">PasteAscii</code> method calls the <code class="literal">PasteUnicode</code> method (again, both ASCII and Unicode text are transformed into the generic text type), which iterates through the <code class="literal">textList</code> parameter and inserts a new paragraph for each text. Note that we do not override the <code class="literal">PasteEnable</code> method, since the <code class="literal">StandardDocument</code> constructor handles it by checking if there is a clipboard buffer with any of the formats defined in the <code class="literal">StandardDocument</code> constructor call.</p><p>The idea is that the first and last text in text list will be merged by the first and last part of the edit paragraph. The potential remaining text will be inserted as paragraphs in between. First we delete the marked text, if present, ensure <code class="literal">edit</code> mode, and clear the <code class="literal">nextFont</code> parameter (setting it to <code class="literal">SystemFont</code>).</p><pre class="programlisting">void WordDocument::PasteUnicode(const vector&lt;String&gt;&amp; textList) { &#13;
  if (wordMode == WordMark) { &#13;
    Delete(firstMarkIndex, lastMarkIndex); &#13;
    EnsureEditStatus(); &#13;
  } &#13;
&#13;
  else { &#13;
    ClearNextFont(); &#13;
  } &#13;
</pre><p>We remove the edit paragraph from the paragraph list, which makes it easier to insert the pasted paragraphs later on.</p><pre class="programlisting">  Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); &#13;
  paragraphList.Erase(paragraphPtr-&gt;Index()); &#13;
</pre><p>We use the font of the edit character and the alignment of the edit paragraph for the pasted characters and paragraphs.</p><pre class="programlisting">  Alignment alignment = paragraphPtr-&gt;AlignmentField(); &#13;
  Font font = charList[editIndex].CharFont(); &#13;
</pre><p>We save the number of the remaining characters of the edit paragraph. We also save the current edit index in order to calculate the total number of pasted characters at the end.</p><pre class="programlisting">  int restChars = paragraphPtr-&gt;Last() - editIndex, &#13;
      prevEditIndex = editIndex, textListSize = textList.size(); &#13;
</pre><p>We insert the characters of each text in the edit paragraph.</p><pre class="programlisting">  for (int textIndex = 0; textIndex &lt; textListSize; ++textIndex) { &#13;
    for (TCHAR tChar : textList[textIndex]) { &#13;
      charList.Insert(editIndex++, &#13;
                      CharInfo(paragraphPtr, tChar, font)); &#13;
    } &#13;
</pre><p>Since each text will finish a paragraph, except the last one, we create and insert a new paragraph.</p><pre class="programlisting">    if (textIndex &lt; (textListSize - 1)) { &#13;
      charList.Insert(editIndex++, &#13;
                      CharInfo(paragraphPtr, NewLine)); &#13;
      paragraphPtr-&gt;Last() = editIndex - 1;&#13;
      for (int index = paragraphPtr-&gt;First();&#13;
           index &lt;= paragraphPtr-&gt;Last(); ++index) {&#13;
        charList[index].ParagraphPtr() = paragraphPtr;&#13;
      }&#13;
      &#13;
      GenerateParagraph(paragraphPtr); &#13;
      paragraphList.Insert(paragraphPtr-&gt;Index(), paragraphPtr); &#13;
      paragraphPtr = new Paragraph(editIndex, 0, alignment, &#13;
                                   paragraphPtr-&gt;Index() + 1); &#13;
    } &#13;
</pre><p>For the last text, we use the original edit paragraph and change its last character index.</p><pre class="programlisting">    else { &#13;
      paragraphPtr-&gt;Last() = editIndex + restChars;&#13;
      for (int index = paragraphPtr-&gt;First();&#13;
           index &lt;= paragraphPtr-&gt;Last(); ++index) {&#13;
        charList[index].ParagraphPtr() = paragraphPtr;&#13;
      }&#13;
      &#13;
      GenerateParagraph(paragraphPtr); &#13;
      paragraphList.Insert(paragraphPtr-&gt;Index(), paragraphPtr); &#13;
    } &#13;
  } &#13;
</pre><p>We may also need to update the index of the succeeding paragraphs, since more than one paragraph may have been pasted. Since we know that at least one character has been pasted, we certainly need to at least modify the first and last index of the succeeding paragraphs.</p><pre class="programlisting">  int totalAddedChars = editIndex - prevEditIndex; &#13;
  for (int parIndex = paragraphPtr-&gt;Index() + 1; &#13;
       parIndex &lt; paragraphList.Size(); ++parIndex) { &#13;
    Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
    paragraphPtr-&gt;Index() = parIndex; &#13;
    paragraphPtr-&gt;First() += totalAddedChars; &#13;
    paragraphPtr-&gt;Last() += totalAddedChars; &#13;
  } &#13;
 &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre><p>The <code class="literal">PasteGeneric</code> method reads and inserts the generic paragraph information stored in the clipboard in a way similar to the preceding <code class="literal">PasteUnicode</code> method. The difference is that the paragraphs are separated to be newlines and that each pasted character comes with its own font.</p><pre class="programlisting">void WordDocument::PasteGeneric(int /* format */, &#13;
                                InfoList&amp; infoList) { &#13;
  if (wordMode == WordMark) { &#13;
    Delete(firstMarkIndex, lastMarkIndex); &#13;
    EnsureEditStatus(); &#13;
  } &#13;
  else { &#13;
    ClearNextFont(); &#13;
  } &#13;
</pre><p>We erase the edit paragraph in order to make the insertion easier, just as in the preceding <code class="literal">PasteUnicode</code> method. We use the alignment of the edit paragraph, but not the font of the edit character since each pasted character has its own font.</p><pre class="programlisting">  Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); &#13;
  paragraphList.Erase(paragraphPtr-&gt;Index()); &#13;
  Alignment alignment = paragraphPtr-&gt;AlignmentField(); &#13;
</pre><p>We read the paste size, which is the number of character to be pasted.</p><pre class="programlisting">  int pasteSize, restChars = paragraphPtr-&gt;Last() - editIndex; &#13;
  infoList.GetValue&lt;int&gt;(pasteSize); &#13;
</pre><p>We read each character from the paste buffer and insert the characters into the character list. When we encounter a newline, we insert a new paragraph.</p><pre class="programlisting">  for (int pasteCount = 0; pasteCount &lt; pasteSize; ++pasteCount) { &#13;
    CharInfo charInfo(paragraphPtr); &#13;
    charInfo.ReadCharInfoFromClipboard(infoList); &#13;
    charList.Insert(editIndex++, charInfo); &#13;
 &#13;
    if (charInfo.Char() == NewLine) { &#13;
      paragraphPtr-&gt;Last() = editIndex - 1; &#13;
      GenerateParagraph(paragraphPtr); &#13;
      paragraphList.Insert(paragraphPtr-&gt;Index(), paragraphPtr); &#13;
      paragraphPtr = new Paragraph(editIndex, 0, alignment, &#13;
                                   paragraphPtr-&gt;Index() + 1); &#13;
      assert(paragraphPtr != nullptr); &#13;
    } &#13;
  } &#13;
 &#13;
  paragraphPtr-&gt;Last() = editIndex + restChars; &#13;
  for (int charIndex = editIndex; &#13;
       charIndex &lt;= paragraphPtr-&gt;Last(); ++charIndex) { &#13;
    charList[charIndex].ParagraphPtr() = paragraphPtr; &#13;
  } &#13;
</pre><p>We need to calculate the original paragraph before we insert it.</p><pre class="programlisting">  GenerateParagraph(paragraphPtr); &#13;
  paragraphList.Insert(paragraphPtr-&gt;Index(), paragraphPtr); &#13;
</pre><p>Similar to the preceding <code class="literal">PasteUnicode</code> case, we may need to update the index of the succeeding paragraphs, since more than one paragraph may have been pasted. We also need to modify their first and last index, since at least one character has been pasted.</p><pre class="programlisting">  for (int parIndex = paragraphPtr-&gt;Index() + 1; &#13;
    parIndex &lt; paragraphList.Size(); ++parIndex) { &#13;
    Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
    paragraphPtr-&gt;Index() = parIndex; &#13;
    paragraphPtr-&gt;First() += pasteSize; &#13;
    paragraphPtr-&gt;Last() += pasteSize; &#13;
  } &#13;
 &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div><div class="section" title="Delete"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Delete</h2></div></div></div><p>In <code class="literal">edit</code> mode, it is possible to delete a character unless it is located at the very end of the document. In <code class="literal">mark</code> mode, the marked text can always always be deleted:</p><pre class="programlisting">bool WordDocument::DeleteEnable() const { &#13;
  switch (wordMode) { &#13;
    case WordEdit: &#13;
      return (editIndex &lt; (charList.Size() - 1)); &#13;
 &#13;
    case WordMark: &#13;
      return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>In <code class="literal">edit</code> mode, we delete the edit character, and in <code class="literal">mark</code> mode, we delete the marked text. In both cases, we call the <code class="literal">Delete</code> method to perform the actual deleting.</p><pre class="programlisting">void WordDocument::OnDelete() { &#13;
  switch (wordMode) { &#13;
    case WordEdit: &#13;
      ClearNextFont(); &#13;
      Delete(editIndex, editIndex + 1); &#13;
      break; &#13;
 &#13;
    case WordMark: &#13;
      Delete(firstMarkIndex, lastMarkIndex); &#13;
      editIndex = min(firstMarkIndex, lastMarkIndex); &#13;
      wordMode = WordEdit; &#13;
      break; &#13;
  } &#13;
 &#13;
  SetDirty(true); &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre><p>The <code class="literal">Delete</code> method is called by the <code class="literal">OnDelete</code>, <code class="literal">EnsureEditStatus</code>, <code class="literal">PasteUnicode</code>, and <code class="literal">PasteGeneric</code> methods. It removes the characters between the given indexes, which do not have to be in order. The removed paragraphs are deleted and the succeeding paragraphs are updated.</p><pre class="programlisting">void WordDocument::Delete(int firstIndex, int lastIndex) { &#13;
  int minCharIndex = min(firstIndex, lastIndex), &#13;
      maxCharIndex = max(firstIndex, lastIndex); &#13;
 &#13;
  Paragraph* minParagraphPtr = &#13;
    charList[minCharIndex].ParagraphPtr(); &#13;
  Paragraph* maxParagraphPtr = &#13;
    charList[maxCharIndex].ParagraphPtr(); &#13;
</pre><p>The deleted area covers at least two paragraphs, we set the characters of the maximal paragraph to point at the minimal paragraph, since they will be merged. We also set their rectangles to zero, to ensure that they will be redrawn.</p><pre class="programlisting">  if (minParagraphPtr != maxParagraphPtr) {&#13;
    for (int charIndex = maxParagraphPtr-&gt;First();&#13;
         charIndex &lt;= maxParagraphPtr-&gt;Last(); ++charIndex) {&#13;
      CharInfo&amp; charInfo = charList[charIndex];&#13;
      charInfo.ParagraphPtr() = minParagraphPtr;&#13;
      charInfo.CharRect() = ZeroRect;&#13;
    }&#13;
  }</pre><p>The characters are removed from the <code class="literal">charList</code> list and the last index of the minimal paragraph is updated. It is set to the last character of the maximal paragraph (that may be the same paragraph as the minimal paragraph) minus the number of the characters to be deleted. The minimal paragraph is then regenerated.</p><pre class="programlisting">  int deleteChars = maxCharIndex - minCharIndex; &#13;
  minParagraphPtr-&gt;Last() = maxParagraphPtr-&gt;Last() - deleteChars;&#13;
  charList.Remove(minCharIndex, maxCharIndex - 1);&#13;
  GenerateParagraph(minParagraphPtr);</pre><p>The paragraphs between the minimal and maximal paragraphs, if any, are deleted and the indexes of the succeeding paragraphs are set. We call <code class="literal">DeleteParagraph</code> for each paragraph to delete their dynamically allocated memory.</p><pre class="programlisting">  int minParIndex = minParagraphPtr-&gt;Index(), &#13;
      maxParIndex = maxParagraphPtr-&gt;Index(); &#13;
&#13;
  if (minParIndex &lt; maxParIndex) {&#13;
    for (int parIndex = minParIndex + 1; &#13;
         parIndex &lt;= maxParIndex; ++parIndex) { &#13;
      DeleteParagraph(paragraphList[parIndex]); &#13;
    } &#13;
    paragraphList.Remove(minParIndex + 1, maxParIndex); &#13;
  }&#13;
</pre><p>Finally, we need to set the indexes of the succeeding paragraphs. Note that we have to update the first and last index regardless of whether any paragraphs have been removed, since we have removed at least one character.</p><pre class="programlisting">  int deleteParagraphs = maxParIndex - minParIndex;&#13;
  for (int parIndex = minParagraphPtr-&gt;Index() + 1; &#13;
       parIndex &lt; paragraphList.Size(); ++parIndex) { &#13;
    Paragraph* paragraphPtr = paragraphList[parIndex];&#13;
    paragraphPtr-&gt;Index() -= deleteParagraphs;&#13;
    paragraphPtr-&gt;First() -= deleteChars; &#13;
    paragraphPtr-&gt;Last() -= deleteChars; &#13;
  } &#13;
</pre><p>When the delete process is finished, the application is set to <code class="literal">edit</code> mode, and the edit index is set to the first marked character.</p><pre class="programlisting">  wordMode = WordEdit; &#13;
  editIndex = minCharIndex;&#13;
} &#13;
</pre></div><div class="section" title="Page break"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Page break</h2></div></div></div><p>The <span class="strong"><strong>PageBreak</strong></span> menu item is enabled in <code class="literal">edit</code> mode, and the <code class="literal">OnPageBreak</code> method is also quite simple. It just inverses the page break status of the edit paragraph:</p><pre class="programlisting">bool WordDocument::PageBreakEnable() const { &#13;
  return (wordMode == WordEdit); &#13;
} &#13;
 &#13;
void WordDocument::OnPageBreak() { &#13;
  Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); &#13;
  paragraphPtr-&gt;PageBreak() = !paragraphPtr-&gt;PageBreak(); &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
} &#13;
</pre></div><div class="section" title="Font"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Font</h2></div></div></div><p>The <code class="literal">OnFont</code> method is called when the user selects the <span class="strong"><strong>Font</strong></span> menu item and it displays the font dialog. In <code class="literal">edit</code> mode, we first need to find the default font to use in the dialog. If the <code class="literal">nextFont</code> parameter is active (does not equal <code class="literal">SystemFont</code>), we use it. If it is not active, we check whether the edit character is the first character in the paragraph. If it is the first character, we use its font. If it is not the first character, we use the font of its preceding character. This is the same procedure as in the preceding <code class="literal">UpdateCaret</code> method:</p><pre class="programlisting">void WordDocument::OnFont() { &#13;
  switch (wordMode) { &#13;
    case WordEdit: { &#13;
        Font font; &#13;
 &#13;
        if (nextFont != SystemFont) { &#13;
          font = nextFont; &#13;
        } &#13;
        else if (editIndex == &#13;
                 charList[editIndex].ParagraphPtr()-&gt;First()) { &#13;
          font = charList[editIndex].CharFont(); &#13;
        } &#13;
        else { &#13;
          font = charList[editIndex - 1].CharFont(); &#13;
        } &#13;
</pre><p>If the user closes the font dialog by choosing <span class="strong"><strong>Ok</strong></span>, we set the <code class="literal">nextFont</code> parameter and recalculate the edit paragraph.</p><pre class="programlisting">        if (StandardDialog::FontDialog(this, font)) { &#13;
          nextFont = font; &#13;
          Paragraph* paragraphPtr = &#13;
            charList[editIndex].ParagraphPtr(); &#13;
          GenerateParagraph(paragraphPtr); &#13;
          SetDirty(true); &#13;
          CalculateDocument(); &#13;
          UpdateCaret(); &#13;
          UpdateWindow(); &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>In <code class="literal">mark</code> mode, we choose the font of the marked character with the lowest index to be the default font in the font dialog.</p><pre class="programlisting">    case WordMark: { &#13;
        int minCharIndex = min(firstMarkIndex, lastMarkIndex), &#13;
            maxCharIndex = max(firstMarkIndex, lastMarkIndex); &#13;
        Font font = charList[minCharIndex].CharFont(); &#13;
</pre><p>If the user chooses <span class="strong"><strong>Ok</strong></span>, we set the font of every marked character and recalculate each of their paragraphs.</p><pre class="programlisting">        if (StandardDialog::FontDialog(this, font)) { &#13;
          for (int charIndex = minCharIndex; &#13;
               charIndex &lt; maxCharIndex; ++charIndex) { &#13;
            charList[charIndex].CharFont() = font; &#13;
          } &#13;
           &#13;
          int minParIndex = &#13;
                charList[minCharIndex].ParagraphPtr()-&gt;Index(), &#13;
              maxParIndex = &#13;
                charList[maxCharIndex].ParagraphPtr()-&gt;Index(); &#13;
 &#13;
          for (int parIndex = minParIndex; &#13;
               parIndex &lt;= maxParIndex; ++parIndex) { &#13;
            Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
            GenerateParagraph(paragraphPtr); &#13;
          } &#13;
 &#13;
          SetDirty(true); &#13;
          CalculateDocument(); &#13;
          UpdateCaret(); &#13;
          UpdateWindow(); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Alignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Alignment</h2></div></div></div><p>All the radio alignment listeners call the <code class="literal">IsAlignment</code> method, and all selection listeners call the <code class="literal">SetAlignment</code> method.</p><pre class="programlisting">bool WordDocument::LeftRadio() const { &#13;
  return IsAlignment(Left); &#13;
} &#13;
 &#13;
void WordDocument::OnLeft() { &#13;
  SetAlignment(Left); &#13;
} &#13;
 &#13;
bool WordDocument::CenterRadio() const { &#13;
  return IsAlignment(Center); &#13;
} &#13;
 &#13;
void WordDocument::OnCenter() { &#13;
  SetAlignment(Center); &#13;
} &#13;
 &#13;
bool WordDocument::RightRadio() const { &#13;
  return IsAlignment(Right); &#13;
} &#13;
 &#13;
void WordDocument::OnRight() { &#13;
  SetAlignment(Right); &#13;
} &#13;
 &#13;
bool WordDocument::JustifiedRadio() const { &#13;
  return IsAlignment(Justified); &#13;
} &#13;
 &#13;
void WordDocument::OnJustified() { &#13;
  SetAlignment(Justified); &#13;
} &#13;
</pre><p>In <code class="literal">edit</code> mode, the <code class="literal">IsAlignment</code> method checks whether the edit paragraph has the given alignment. In <code class="literal">mark</code> mode, it checks if all partly or completely marked paragraph have the given alignment. This implies that if several paragraphs are marked with different alignments, no alignment menu item will be marked with a radio button.</p><pre class="programlisting">bool WordDocument::IsAlignment(Alignment alignment) const { &#13;
  switch (wordMode) { &#13;
    case WordEdit: { &#13;
        Alignment editAlignment = &#13;
          charList[editIndex].ParagraphPtr()-&gt;AlignmentField(); &#13;
        return (editAlignment == alignment); &#13;
      } &#13;
       &#13;
    case WordMark: { &#13;
        int minCharIndex = min(firstMarkIndex, lastMarkIndex), &#13;
            maxCharIndex = max(firstMarkIndex, lastMarkIndex); &#13;
 &#13;
        int minParIndex = &#13;
              charList[minCharIndex].ParagraphPtr()-&gt;Index(), &#13;
            maxParIndex = &#13;
              charList[maxCharIndex].ParagraphPtr()-&gt;Index(); &#13;
 &#13;
        for (int parIndex = minParIndex; parIndex &lt; maxParIndex; &#13;
             ++parIndex) { &#13;
          Alignment markAlignment = &#13;
            paragraphList[parIndex]-&gt;AlignmentField(); &#13;
 &#13;
          if (markAlignment != alignment) { &#13;
            return false; &#13;
          } &#13;
        } &#13;
 &#13;
        return true; &#13;
      } &#13;
  } &#13;
 &#13;
  assert(false); &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">SetAlignment</code> method sets the alignment of the edited or marked paragraphs. In <code class="literal">edit</code> mode, we just set the alignment of the edit paragraph. Remember that this method can only be called when the paragraph has another alignment. In <code class="literal">mark</code> mode, we traverse the marked paragraphs and set the alignment on those paragraphs that do not have the alignment already in question. Also remember that this method can only be called if at least one paragraph does not hold the alignment in question. The paragraphs that have changed alignment need to be recalculated. However, the new alignment does not affect the height of the paragraph, which implies that we do not need to call the <code class="literal">CalculateDocument</code> method for the remaining paragraphs.</p><pre class="programlisting">void WordDocument::SetAlignment(Alignment alignment) { &#13;
  switch (wordMode) { &#13;
    case WordEdit: { &#13;
        Paragraph* paragraphPtr = &#13;
          charList[editIndex].ParagraphPtr(); &#13;
        paragraphPtr-&gt;AlignmentField() = alignment; &#13;
        GenerateParagraph(paragraphPtr); &#13;
        UpdateCaret(); &#13;
      } &#13;
      break; &#13;
 &#13;
    case WordMark: { &#13;
        int minCharIndex = min(firstMarkIndex, lastMarkIndex), &#13;
            maxCharIndex = max(firstMarkIndex, lastMarkIndex); &#13;
 &#13;
        int minParIndex = &#13;
              charList[minCharIndex].ParagraphPtr()-&gt;Index(), &#13;
            maxParIndex = &#13;
              charList[maxCharIndex].ParagraphPtr()-&gt;Index(); &#13;
 &#13;
        for (int parIndex = minParIndex; parIndex &lt; maxParIndex; &#13;
             ++parIndex) { &#13;
          Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
          paragraphPtr-&gt;AlignmentField() = alignment; &#13;
          GenerateParagraph(paragraphPtr); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
 &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, you started to develop a word processor capable of handling individual characters. The word processor supports the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Individual font and style of each character</li><li class="listitem" style="list-style-type: disc">Left, center, right, and justified alignment of each paragraph</li><li class="listitem" style="list-style-type: disc">Paragraphs that are distributed over the pages</li><li class="listitem" style="list-style-type: disc">Scrolling and zooming</li><li class="listitem" style="list-style-type: disc">Touchscreen</li><li class="listitem" style="list-style-type: disc">Cut, copy, and paste with ASCII or Unicode text, as well as application-specific generic information</li></ul></div><p>In <a class="link" href="ch07.html" title="Chapter 7. Keyboard Input and Character Calculation">Chapter 7</a>, <span class="emphasis"><em>Keyboard Input and Character Calculation</em></span>, we will continue with the keyboard input and character calculation.</p></div></body></html>