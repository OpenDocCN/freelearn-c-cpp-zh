- en: Chapter 8. Designing Visual Output Feedback
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interaction is everything about control and feedback. You control a system by
    performing actions upon it. You can even modify it. The system gives you feedback
    by providing useful information about what it does when you modify it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned more about us controlling Arduino than Arduino
    giving us feedback. For instance, we used buttons and knobs to send data to Arduino,
    making it working for us. Of course, there are a lot of point of view, and we
    can easily consider controlling an LED and giving feedback to Arduino. But usually,
    we talk about feedback when we want to qualify a return of information from the
    system to us.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Arkalgud Ramaprasad, Professor at the Department of Information and Decision
    Sciences at the College of Business Administration, University of Illinois, Chicago,
    defines feedback as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '"Information about the gap between the actual level and the reference level
    of a system parameter which is used to alter the gap in some way."'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We already talked about some visual output in [Chapter 5](ch05.html "Chapter 5. Sensing
    with Digital Inputs"), *Sensing Digital Inputs*, when we tried to visualize the
    result of our button push events. This visual rendering resulting from our push
    events was feedback.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to talk about the design of visual feedback systems based especially
    on LEDs driven by the Arduino board. LEDs are the easiest systems with which to
    provide visual feedback from Arduino.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: How to use basic monochromatic LEDs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make LED matrices and how to multiplex LEDs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use RGB LEDs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will finish the chapter by introducing the LCD display device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Using LEDs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LEDs can be monochromatic or polychromatic. Indeed, there are many types of
    LEDs. Before going though some examples, let's discover some of these LED types.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Different types of LEDs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, LEDs are used both to block the current coming from a line to its
    cathode leg and to give light feedback when the current goes into its anode:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Different types of LEDs](img/7584_08_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'The different models that we can find are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Basic LEDs
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OLED** (**Organic LED** made by layering the organic semi-conductor part)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AMOLED** (**Active Matrix OLED** provides a high density of pixels for big
    size screens)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FOLED** (**Flexible** **OLED**)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will only talk about basic LEDs here. By the term "basic", I mean an LED
    with discrete components like the one in the preceding image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The package can vary from two-legged components with a molded epoxy-like lens
    at the top, to surface components that provide many connectors, as shown in the
    following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Different types of LEDs](img/7584OS_08_002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'We can also sort them, using their light''s color characteristics, into:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Monochromatic LEDs
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polychromatic LEDs
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each case, the visible color of an LED is given by the color of the molded
    epoxy cap; the LED itself emits the same wavelength.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Monochromatic LEDS
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Monochromatic LEDs emit one color only.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The most usual monochromatic LEDs emit constant colors at each voltage need.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Polychromatic LEDs
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polychromatic LEDs can emit more than one color, depending on several parameters
    such as voltage but also depending on the leg fed with current in case of an LED
    with more than one leg.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The most important characteristic here is controllability. Polychromatic LEDs
    have to be easily controllable. This means that we should be able to control each
    color by switching it on or off.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a classic RGB LED with common cathode and three different anodes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Polychromatic LEDs](img/7584OS_08_003.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: This type of LED is the way to go with our Arduino stuff. They aren't expensive
    (around 1.2 Euros per 100 LEDs ), considering the fact that we can control them
    easily and produce a very huge range of colors with them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We are going to understand how we can deal with multiple LEDs and also polychromatic
    RGB LEDs in the following pages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Remembering the Hello LED example
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Hello LED, we made an LED blink for 250 ms of every 1000 ms that pass. Let''s
    see its schematic view once again to maintain the flow of your reading:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Remembering the Hello LED example](img/7584OS_08_032.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'The code for Hello LED is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Intuitively, in the next examples, we are going to try using more than one LED,
    playing with both monochromatic and polychromatic LEDs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Multiple monochromatic LEDs
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are talking about feedback here, and not just pure output, we will
    build a small example showing you how to deal with multiple buttons and multiple
    LEDs. Don't worry if you are totally unable to understand this right now; just
    continue reading.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Two buttons and two LEDs
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already spoke about playing with multiple buttons in [Chapter 5](ch05.html
    "Chapter 5. Sensing with Digital Inputs"), *Sensing Digital Inputs*. Let's build
    a new circuit now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the schematics:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Two buttons and two LEDs](img/7584_08_004.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: It's preferable to continue drawing the electric diagram related for each schematic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the multiple buttons example from [Chapter 5](ch05.html "Chapter 5. Sensing
    with Digital Inputs"), *Sensing Digital Inputs*; however, we have removed one
    button and added two LEDs instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Two buttons and two LEDs](img/7584_08_005.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: As you know, the digital pins of Arduino can be used as inputs or outputs. We
    can see that two switches are connected on one side to a 5 V Arduino pin and on
    the other side to the digital pins 2 and 3, with one pull-down resistor related
    to each of those latter pins, sinking the current to Arduino's ground pin.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that an LED is connected each to digital pin 8 and 9 on one
    side; both are connected to Arduino's ground pin.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Nothing's really incredible about that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you design a dedicated firmware, you need to briefly cover something
    very important: coupling. It is a must to know for any interface design; more
    widely for interaction design.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Control and feedback coupling in interaction design
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互设计中的控制和反馈耦合
- en: 'This section is considered a subchapter for two main reasons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节被视为子章节有两个主要原因：
- en: Firstly, it sounds great and is key to keeping the motivation groove on
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它听起来很棒，并且是保持动机流畅的关键。
- en: Secondly, this part is the key for all your future human-machine interface design
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，这部分是您未来所有人机界面设计的关键。
- en: As you already know, Arduino (thanks to its firmware) links the control and
    feedback sides. It is really important to keep this in mind.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，Arduino（得益于其固件）连接了控制和反馈两侧。这一点非常重要，需要牢记在心。
- en: Whatever the type of the external system may be, it is often considered as human
    from the Arduino point of view. As soon as you want to design an interaction system,
    you will have to deal with that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论外部系统的类型如何，从Arduino的角度来看，它通常被视为人类。一旦您想要设计一个交互系统，您就必须处理这一点。
- en: We can summarize this concept with a very simple schematic in order to fix things
    in the mind.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个非常简单的示意图来总结这个概念，以便在脑海中固定下来。
- en: Indeed, you have to understand that the firmware we are about to design will
    create a control-feedback coupling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您必须理解，我们即将设计的固件将创建一个控制-反馈耦合。
- en: A **control/feedback coupling** is a set of rules that define how a system behaves
    when it receives orders from us and how it reacts by giving us (or not) feedback.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制/反馈耦合**是一组规则，定义了系统在接收到我们的命令时如何表现，以及它如何通过给我们（或不给我们）反馈来做出反应。'
- en: This hard-coded set of rules is very important to understand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这组硬编码的规则非常重要，需要理解。
- en: '![Control and feedback coupling in interaction design](img/7584_08_006.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![交互设计中的控制和反馈耦合](img/7584_08_006.jpg)'
- en: But, imagine that you want to control another system with Arduino. In that case,
    you may want to make the coupling outside Arduino itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，想象一下，您想用Arduino控制另一个系统。在这种情况下，您可能希望将耦合放在Arduino本身之外。
- en: 'See the second figure **EXTERNAL SYSTEM 2**, where I put the coupling outside
    Arduino. Usually, **EXTERNAL SYSTEM 1** is us and **EXTERNAL SYSTEM 2** is a computer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看第二个图**外部系统2**，我把耦合放在Arduino之外。通常，**外部系统1**是我们，**外部系统2**是计算机：
- en: '![Control and feedback coupling in interaction design](img/7584_08_007.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![交互设计中的控制和反馈耦合](img/7584_08_007.jpg)'
- en: We can now quote a real-life example. As with many users of interfaces and remote
    controllers, I like and I need to control complex software on my computer with
    minimalistic hardware gears.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以引用一个现实生活中的例子。就像许多界面和遥控器的用户一样，我喜欢并且需要用简约的硬件设备控制我电脑上的复杂软件。
- en: I like the minimalistic and open source **Monome interface** ([http://monome.org](http://monome.org))
    designed by Brian Crabtree. I used it a lot, and still use it sometimes. It is
    basically a matrix of LEDs and buttons. The amazing trick under the hood is that
    there is NO coupling inside the gear.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢由Brian Crabtree设计的简约且开源的**Monome界面**([http://monome.org](http://monome.org))。我经常使用它，有时还在使用。它基本上是一个LED和按钮的矩阵。令人惊叹的技巧是，在内部没有任何耦合。
- en: '![Control and feedback coupling in interaction design](img/7584OS_08_008.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![交互设计中的控制和反馈耦合](img/7584OS_08_008.jpg)'
- en: The preceding image is of Monome 256 by Brian Crabtree and its very well-made
    wooden case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片是Brian Crabtree设计的Monome 256及其非常精美的木质外壳。
- en: 'If it isn''t directly written like that in all the docs, I would like to define
    it to my friends and students like this: "The Monome concept is the most minimalistic
    interface you''ll ever need because it only provides a way of controlling LEDs;
    beside of that, you have many buttons, but there are no logical or physical links
    between buttons and LEDs."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有文档中都没有直接这样写，我希望能够这样定义给我的朋友和学生：“Monome概念是您需要的最简约的界面，因为它只提供控制LEDs的方式；除此之外，您有很多按钮，但按钮和LEDs之间没有逻辑或物理连接。”
- en: If Monome doesn't provide a real, already made coupling between buttons and
    LEDs, it's because it would be very restrictive and would even remove all the
    creativity!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Monome不提供按钮和LEDs之间的真实、现成的耦合，那是因为这将非常限制性，甚至可能消除所有创造力！
- en: Since there is a very raw and efficient protocol designed ([http://monome.org/data/monome256_protocol.txt](http://monome.org/data/monome256_protocol.txt))
    to especially control LEDs and read buttons pushes, we are ourselves able to create
    and design our own coupling. Monome is also provided with the **Monome Serial
    Router**, which is a very small application that basically translates the raw
    protocol into **OSC** ([http://archive.cnmat.berkeley.edu/OpenSoundControl/](http://archive.cnmat.berkeley.edu/OpenSoundControl/))
    or **MIDI** ([http://www.midi.org/](http://www.midi.org/)). We will discuss them
    in later sections of this chapter. These are very common in multimedia interaction
    design; OSC can be transported over networks, while MIDI is very suited for links
    between music-related equipment such as sequencers and synthesizers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有一个非常原始且高效的协议设计（[http://monome.org/data/monome256_protocol.txt](http://monome.org/data/monome256_protocol.txt)），专门用于控制LED和读取按钮的按下，我们能够自己创建和设计我们的耦合。Monome还提供了**Monome
    Serial Router**，这是一个非常小的应用程序，基本上将原始协议转换为**OSC**（[http://archive.cnmat.berkeley.edu/OpenSoundControl/](http://archive.cnmat.berkeley.edu/OpenSoundControl/)）或**MIDI**（[http://www.midi.org/](http://www.midi.org/)）。我们将在本章的后续部分讨论它们。这些在多媒体交互设计中非常常见；OSC可以在网络上传输，而MIDI非常适合连接音乐相关设备，如序列器和合成器。
- en: This short digression wouldn't be complete without another schematic about the
    Monome.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不附上关于Monome的另一个原理图，这次简短的离题就不会完整。
- en: 'Check it and let''s learn more about it after that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一下，然后我们再深入了解：
- en: '![Control and feedback coupling in interaction design](img/7584_08_009.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![交互设计中的控制和反馈耦合](img/7584_08_009.jpg)'
- en: The smart minimalistic Monome interface in its usual computer-based setup
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 智能简约的Monome界面在其通常的基于计算机的设置中
- en: Here is a schematic of the Monome 64 interface, in that usual computer-based
    setup inside of which the coupling occurs. This is the real setup that I used
    on stage for a music performance many times ([https://vimeo.com/20110773](https://vimeo.com/20110773)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Monome 64界面的原理图，在通常的基于计算机的设置中，耦合就在其中发生。这是我多次在音乐表演中使用过的实际设置（[https://vimeo.com/20110773](https://vimeo.com/20110773)）。
- en: I designed a specific coupling inside Max 6, translating specific messages from/to
    the Monome itself, but from/to the software too, especially Ableton Live ([https://www.ableton.com](https://www.ableton.com)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Max 6中设计了一个特定的耦合，将特定的消息从/到Monome本身，以及从/到软件转换，特别是Ableton Live（[https://www.ableton.com](https://www.ableton.com)）。
- en: This is a very powerful system that controls things and provides feedback with
    which you can basically build your coupling from the ground up and transform your
    raw and minimalistic interface into whatever you need.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的系统，它可以控制事物并提供反馈，你可以基本上从头开始构建你的耦合，并将你的原始简约界面转变为你需要的样子。
- en: This was a small part of a more global monologue about interaction design.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是关于交互设计的一个更广泛独白的一部分。
- en: Let's build this coupling firmware right now, and see how we can couple controls
    and feedback into a basic sample code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建这个耦合固件，看看我们如何可以将控制和反馈耦合到基本的示例代码中。
- en: The coupling firmware
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 耦合固件
- en: Here, we only use the Arduino switches and LEDs and no computer actually.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只使用了Arduino的开关和LED，实际上没有使用电脑。
- en: 'Let''s design a basic firmware, including coupling, based on this pseudocode:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个基本的固件，包括耦合，基于这个伪代码：
- en: If I push switch 1, LED 1 is switched on, and if I release it, LED 1 is switched
    off
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我按下开关1，LED 1将被打开，如果我释放它，LED 1将被关闭
- en: If I push switch 2, LED 2 is switched on, and if I release it, LED 2 is switched
    off
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我按下开关2，LED 2将被打开，如果我释放它，LED 2将被关闭
- en: 'In order to manipulate new elements and ideas, we are going to use a library
    named `Bounce`. It provides an easy way to debounce digital pin inputs. We already
    spoke about debouncing in the *Understanding the debounce concept* section of
    [Chapter 5](ch05.html "Chapter 5. Sensing with Digital Inputs"), *Sensing Digital
    Inputs*. Reminding you of that a bit: if no button absorbs the bounce totally
    when you push it, we can smoothen things and filter the non-desired harsh value
    jumps by using software.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作新的元素和想法，我们将使用一个名为`Bounce`的库。它提供了一个简单的方法来去抖动数字引脚输入。我们已经在[第5章](ch05.html "第5章.
    使用数字输入进行感应")的*理解去抖概念*部分中讨论过去抖动，*感应数字输入*。提醒一下：如果你按下按钮时没有按钮完全吸收抖动，我们可以通过软件平滑事物并过滤掉不希望的非理想值跳跃。
- en: You can find instructions about the `Bounce` library at [http://arduino.cc/playground/Code/Bounce](http://arduino.cc/playground/Code/Bounce).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://arduino.cc/playground/Code/Bounce](http://arduino.cc/playground/Code/Bounce)找到关于`Bounce`库的说明。
- en: 'Let''s check that piece of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这段代码：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can find it in the `Chapter08/feedbacks_2x2/` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/feedbacks_2x2/`文件夹中找到它。
- en: This code includes the Bounce header file, that is, the Bounce library, at the
    beginning.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在开头包含了Bounce头文件，即Bounce库。
- en: Then I defined four constants according to the digital input and output pins,
    where we put switches and LEDs in the circuit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我根据数字输入和输出引脚定义了四个常量，其中我们在电路中放置开关和LED。
- en: 'The Bounce library requires to instantiate each debouncer, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Bounce库要求实例化每个去抖动器，如下所示：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I chose a debounce time of 7 ms. This means, if you remember correctly, that
    two value changes occurring (voluntarily or non-voluntarily) very fast in a time
    interval of less than 7ms wouldn't be considered by the system, avoiding strange
    and uncanny bouncing results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了7毫秒的去抖动时间。这意味着，如果你记得正确的话，在小于7毫秒的时间间隔内发生的两次值变化（自愿或非自愿）不会被系统考虑，从而避免了奇怪和不寻常的抖动结果。
- en: The `setup()` block isn't really difficult, it only defines digital pins as
    inputs for buttons and outputs for LEDs (please remember that digital pins can
    be both and that you have to choose at some point).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`块并不复杂，它只定义了数字引脚作为按钮的输入和LED的输出（请记住，数字引脚可以是输入也可以是输出，你必须在某个时候做出选择）。'
- en: '`loop()` begins by the update of both debouncers, after which we read each
    debounced button state value.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数首先更新两个去抖动器，之后我们读取每个去抖动按钮状态值。'
- en: At last, we handle the LED controls, depending on the button states. Where does
    the coupling occur? Of course, at this very last step. We couple our control (buttons
    pushed) to our feedback (LED lights) in that firmware. Let's upload and test it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理LED控制，这取决于按钮状态。耦合发生在哪里？当然是在这个最后的步骤。我们在该固件中将我们的控制（按钮按下）与我们的反馈（LED灯）耦合起来。让我们上传并测试它。
- en: More LEDs?
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多LED？
- en: We basically just saw how to attach more than one LED to our Arduino. Of course,
    we could do the very same way with more than two LEDs. You can find code handling
    six LEDs and six switches in the `Chapter05/feedbacks_6x6/` folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上只是看到了如何将多个LED连接到我们的Arduino上。当然，我们也可以用相同的方式连接超过两个LED。你可以在`Chapter05/feedbacks_6x6/`文件夹中找到处理六个LED和六个开关的代码。
- en: 'But hey, I have a question for you: how would you handle more LEDs with an
    Arduino Uno? Please don''t answer that by saying "I''ll buy an Arduino MEGA" because
    then I would ask you how you would handle more than 50 LEDs.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我有一个问题要问你：你将如何用Arduino Uno处理更多的LED？请不要回答说“我会买一个Arduino MEGA”，因为那样我会问你如何处理超过50个LED。
- en: The right answer is **multiplexing**. Let's check how we can handle a lot of
    LEDs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的答案是**多路复用**。让我们看看我们如何处理大量的LED。
- en: Multiplexing LEDs
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用LED
- en: The concept of multiplexing is an interesting and efficient one. It is the key
    to having a bunch of peripherals connected to our Arduino boards.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用的概念既有趣又高效。它是将许多外围设备连接到我们的Arduino板的关键。
- en: Multiplexing provides a way to use few I/O pins on the board while using a lot
    of external components. The link between Arduino and these external components
    is made by using a multiplexer/demultiplexer (also shortened to mux/demux).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用提供了一种方法，在板上使用很少的I/O引脚，同时使用大量的外部组件。Arduino与这些外部组件之间的连接是通过使用多路复用器/解复用器（也简称为mux/demux）来实现的。
- en: We spoke about input multiplexing in [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Playing with Analog Inputs*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch06.html "第6章。感知世界 – 使用模拟输入进行游戏")中讨论了输入多路复用，*使用模拟输入进行游戏*。
- en: We are going to use the 74HC595 component here. Its datasheet can be found at
    [http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf](http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用74HC595组件。其数据表可以在[http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf](http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf)找到。
- en: This component is an 8-bit serial-in / serial-or-parallel-out. This means it
    is controlled through a serial interface, basically using three pins with Arduino
    and can drive with eight of its pins.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件是一个8位串行输入/串行或并行输出。这意味着它通过串行接口控制，基本上使用Arduino的三个引脚，并且可以用其八个引脚驱动。
- en: I'm going to show you how you can control eight LEDs with only three pins of
    your Arduino. Since Arduino Uno contains 12 digital usable pins (I'm not taking
    0 and 1, as usual), we can easily imagine using 4 x 75HC595 to control 4 x 8 =
    32 monochromatic LEDs with this system. I'll provide the code to do that as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Connecting 75HC595 to Arduino and LEDs
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we learnt together with the CD4051 and the multiplexing of analog inputs,
    we are going to wire the chip to a 75HC595 shift register in order to mux/demux
    eight digital output pins. Let''s check the wiring:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting 75HC595 to Arduino and LEDs](img/7584_08_010.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: We have the Arduino supplying power to the breadboard. Each resistor provides
    220 ohms resistance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The 75HC595 grabs the GND and 5 V potential for its own supply and configuration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Basically, 74HC595 needs to be connected through pins 11, 12, and 14 in order
    to be controlled by a serial protocol handled here by Arduino.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check 74HC595 itself:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting 75HC595 to Arduino and LEDs](img/7584_08_011.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Pins 8 and 16 are used for internal power supply.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 10 is named **Master Reset**, and in order to activate it, you have to connect
    this pin to the ground. That is the reason why, in normal operational states of
    work, we drive it to 5 V.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 13 is the output enable input pin and has to be kept active in order to
    make the whole device output currents. Connecting it to the ground does this.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 11 is the shift register clock input.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 12 is the storage register clock input, also named **Latch**.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 14 is the serial data input.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 15 and pins 1 to 7 are the output pins.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our small and inexpensive serial link to the Arduino, handled by pins 11, 12
    and 14, provides an easy way to control and basically load eight bits into the
    device. We can cycle over the eight bits and send them serially to the device
    that stores them in its registers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: These types of devices are usually referred to as **Shift Registers** we shift
    bits from 0 to 7 while loading them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Then, each state is outputted to the correct output from Q0 to Q7, transposing
    the previously transmitted states over serial.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: This is a direct illustration of the serial-to-parallel conversion that we talked
    about in the previous chapter. We had a data flow coming sequentially, retained
    until the register is globally loaded, then pushing this to many output pins.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s visualize the wiring diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting 75HC595 to Arduino and LEDs](img/7584_08_012.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: An eight-LED array with resistors wired to the 74HC595 shift register
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Firmware for shift register handling
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to learn how to design a firmware specifically for these kinds
    of shift registers. This firmware is basically made for the 595 but wouldn't require
    a lot of modifications to be used with other integrated circuits. You'd specially
    have to take care about three serial pins, Latch, Clock, and Data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Because I want to teach you each time a bit more than the exact content evoked
    by each chapter title, I created a very inexpensive and small random groove machine
    for you. Its purpose is to generate random bytes. These bytes will then be sent
    to the shift register in order to feed or not each LED. You'll then have then
    a neat random pattern of LEDs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我想每次都教给你比每个章节标题所激发的精确内容更多一点，所以我为你创造了一台非常便宜且小巧的随机凹槽机。它的目的是生成随机字节。然后，这些字节将被发送到移位寄存器，以便为每个LED供电或不供电。这样，你将得到一个整洁的随机LED图案。
- en: You can find the code for this in the `Chapter08/ Multiplexing_8Leds/` folder.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/Multiplexing_8Leds/`文件夹中找到这个代码。
- en: 'Let''s check it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Global shift register programming pattern
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局移位寄存器编程模式
- en: First, let's check the global structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查全局结构。
- en: I first define the 3 three pins of the 595 shift register. Then, I set up each
    of them as output in the `setup()` block.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先定义了595移位寄存器的3个引脚。然后，我在`setup()`块中将它们每个都设置为输出。
- en: 'Then, I have a pattern that looks similar to the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我有一个看起来类似的模式：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the usual pattern for shift- registering operations.The `latch-pin`,
    as evoked explained before, is the one providing us a way to inform the integrated
    circuit about the fact that we want to load it with data, and then we want it
    to apply these this data to its outputs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是移位寄存器操作的常规模式。正如之前所解释的，“锁存引脚”是提供给我们一种方式来通知集成电路我们想要将其加载数据，然后我们希望它将这些数据应用到其输出。
- en: 'This is a bit like saying:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像说：
- en: Latch-pin LOW = "Hi there, let's store what I'm about to send to you."
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁存引脚低电平 = “嗨，让我们存储我即将发送给你的内容。”
- en: Latch-pin HIGH = "Ok, now use the data I just sent to commute to your outputs
    or not."
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁存引脚高电平 = “好的，现在使用我刚刚发送的数据来转换到你的输出或不输出。”
- en: Then, we have this `shiftOut()`. This function provides an easy way to send
    data per entire bytes packets to a specific pin (the data pin) using a specific
    clock/ rate speed over a particular pin (the clock pin), and given an order of
    transmission (`MSBFIRST` or `LSBFIRST`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有这个`shiftOut()`函数。这个函数提供了一个简单的方法，通过特定的时钟/速率速度，将整个字节数据包发送到特定的引脚（数据引脚），并且给定一个传输顺序（MSBFIRST或LSBFIRST）。
- en: Even though we aren't going to describe the things under- the- hood here, you
    have to understand the MSB and LSB concept.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这里不会描述底层的细节，但你必须理解MSB和LSB的概念。
- en: 'Let''s consider a byte: `1 0 1 0 0 1 1 0`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个字节：`1 0 1 0 0 1 1 0`。
- en: The **MSB** is the abbreviation of **Most Significant Bit**. This bit is at
    the left-most position (the one of the bit having of the greatest value). Here,
    its value is `1`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSB**是**最高有效位**的缩写。这个位位于最左侧位置（具有最大值的位）。在这里，它的值是`1`。'
- en: The **LSB** is stands for the **Least Significant Bit**. This bit is at the
    right-most position (the bit of the smallest value) It is the bit the most at
    the right (the one of the bit having the smallest value). Here, its value is `0`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**LSB**代表**最低有效位**。这个位位于最右侧位置（最小值的位）。它是位于最右侧的位（具有最小值的位）。在这里，它的值是`0`。'
- en: 'By fixing this argument in the `shiftOut()` function, we are providing special
    information about the sense of the transmission. Indeed, we can send the previous
    byte by sending these bits: `1` then, `0`, then `1 0 0 1 1 0` (MSBFIRST), or by
    sending these bits: `0 1 1 0 0 1 0 1` (LSBFIRST).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`shiftOut()`函数中固定这个参数，我们提供了有关传输方向的特殊信息。实际上，我们可以通过发送这些位来发送前一个字节：`1`然后，`0`，然后`1
    0 0 1 1 0`（MSBFIRST），或者通过发送这些位：`0 1 1 0 0 1 0 1`（LSBFIRST）。
- en: Playing with chance and random seeds
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转机会和随机种子
- en: I would like to provide an example from my personal ways of programming. Here,
    I'm going to describe an inexpensive and small system generating random bytes.
    These bytes will then be sent to the the 595, and our 8 eight-LEDs array will
    have a very random state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要提供一个关于我个人编程方式的例子。在这里，我将描述一个便宜且小巧的系统，它可以生成随机字节。然后，这些字节将被发送到595，我们的8个LED数组将处于一个非常随机的状态。
- en: Random, in computers, isn't really random. Indeed, the `random()` function is
    a pseudo-random number generator. It can also be named a **deterministic random
    bit generator** (**DRBG**). Indeed, the sequence is (totally) determined by a
    small set of initial values, including the seed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，随机并不是真正的随机。实际上，`random()`函数是一个伪随机数生成器。它也可以被称为**确定性随机比特生成器**（**DRBG**）。确实，序列是由一组小的初始值（包括种子）完全确定的。
- en: For a particular seed, a pseudo-random number generator generates the same number
    sequences each time the same number sequences.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: But, we you can use a trick here to disturb determinism a little bit more.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you make the seed vary sometimes. You can also introduce an external
    factor of randomness into your system. As we already explained before in this
    book, there is always some electronic noises coming going to from to the ADC even
    if nothing is wired to the analog inputs. You can use that external/physical noise
    by reading the analog input 0, for instance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As we now well know, analog `analogRead()` provides a number from 0 to 1023\.
    This is a huge resolution for our purpose here.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This is what I have put in the firmware.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: I defined a counter variable and a byte. I'm first reading the value coming
    from the ADC for the analog pin 0 in the `setup()` first. Then, I'm generating
    generated a random byte with a `for()` loop and the `bitWrite()` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: I'm writing each bit of the byte `LED_states` using numbers generated by the
    `random(2)` number function, which gives 0 or 1, randomly. Then, I'm using use
    the pseudo-random-generated byte into the structure previously described.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: I'm redefining each 5000 `loop()` execution of the seed by reading the ADC for
    the analog pin 0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use `random()` with computers, including Arduino and embedded
    systems, grab some physical and external noise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move further.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We can use many 74HC595 shift registers for LED handling, but imagine that you
    need to save some more digital pins. Okay, we saw we can save a lot using shift
    registers. One shift registers requires three digital pins and drives eight LEDs.
    It means we save five pins with each shift register, considering we wire eight
    LEDs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: What if you need A LOT more? What if you need to save all the other pins for
    switches handling, for instance?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Let's daisy chain now!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Daisy chaining multiple 74HC595 shift registers
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **daisy chain** is a wiring scheme used to link multiple devices in a sequence
    or even a ring.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, since we already understood a bit more about how shift registers work,
    we could have the idea to extend this to multiple shift registers wired together,
    couldn't we?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to show you how to do this by using the **ShiftOutX** library by Juan
    Hernandez. I had very nice results with Version 1.0, and I advise you to use this
    one.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download it here: [http://arduino.cc/playground/Main/ShiftOutX](http://arduino.cc/playground/Main/ShiftOutX).
    You can install it by following the procedure explained in the appendice.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Linking multiple shift registers
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What would each shift register need to know about?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The serial clock, the latch, and the data are the necessary points of information
    that have to be transmitted all along the device chain. Let''s check a schematic:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking multiple shift registers](img/7584_08_013.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Two shift registers daisy chained driving 16 monochromatic LEDs with only three
    digital pins on the Arduino
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: I used the same colors as with the previous circuit for the clock (blue), latch
    (green), and serial data (orange).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The serial clock and latch are shared across the shift registers. The command/order
    coming from Arduino to synchronize serial communication with the clock and to
    tell shift registers to store or apply data received to their output has to be
    coherent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The serial data coming from Arduino first goes into the first shift register,
    which sends the serial data to the second one. This is the core of the chaining
    concept.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the circuit diagram to put this in mind:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking multiple shift registers](img/7584_08_014.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Circuit diagram of two daisy-chained shift registers driving 16 monochromatic
    LEDs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Firmware handling two shift registers and 16 LEDs
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The firmware includes the `ShiftOutX` library ShiftOutX as wrote before. It
    provides very easy and smooth handling for daisy chaining of shift registers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Here is the the code for the firmware.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in the `Chapter08/Multiplexing_WithDaisyChain/` folder:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The ShiftOutX library can be used in many ways. We are using it here following
    in the same way that we did with `ShiftOut`, the library part of the core and
    suited for the use of only one shift register.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to include the library by using **Sketch | Import Library | ShiftOutX**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: It includes two header files at the beginning, namely, `ShiftOutX.h` and `ShiftPinNo.h`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a new variable storing the number of shift registers in the
    chain.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we instantiate the ShiftOutX library by using the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code in `setup()` changed a bit. Indeed, there are no more setup statements
    for digital pins. This part is handled by the library, which can look weird but
    is very usual. Indeed, when you instantiated the library before, you passed three
    pins of Arduino as arguments, and in fact, this statement also sets up the pins
    as outputs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` block is almost the same as before. Indeed, I included again the
    small random groove machine with the analog read trick. But I'm creating two random
    bytes, this time. Indeed, this is because I need 16 values and I want to use the
    `shiftOut_16` function to send all my data in the same statement. It is quite
    easy and usual to generate bytes, then aggregate them into an `unsigned short
    int` datatype by using bitwise operators.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Let's detail this operation a bit.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'When we generate random bytes, we have two series of 8 eight bits. Let''s take
    the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we want to store them in one place, what could we do? We can shift one and
    then add the shifted one to the other one, couldn't we?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, if we add a byte using the bitwise operator (`|`), we get:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result seems to be a concatenation of all the bits.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This is what we are doing in this part of the code. Then we use `shiftOut_16()`
    to send all the data to the two shift registers. Hey, what should we do with the
    four shift registers? The same thing in the same way!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Probably we would have to shift more using `<< 32`, `<< 16`, and again `<<8`,
    in order to store all our the bytes into a variable that we could send using `shiftOut_32()`
    functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: By using this library, you can have two groups, each one containing eight shift
    registers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: It means that you can drive 2 x 8 x 8 = 128 outputs using only four pins (two
    latches but common serial clock and data). It sounds crazy, doesn't it?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In real life, it is totally possible to use only one Arduino to make this kind
    of architecture, but we would have to take care of something very important, the
    current amount. In this particular case of 128 LEDs, we should imagine the worst
    case when all the LEDs would be switched on. The amount of current driven could
    even burn the Arduino board, which would protect itself by resetting, sometimes.
    But personally, I wouldn't even try.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Current short considerations
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino board, using USB power supply, cannot drive more than 500 mA. All
    combined pins cannot drive more than 200 mA, and no pin can drive more than 40
    mA. It can vary a bit from one board type to another, but these are real, absolute
    maximum ratings.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We didn't make these considerations and the following calculations because,
    in our examples, we only used a few devices and components, but you could sometimes
    be tempted to build a huge device such as I made sometimes, for example, with
    the Protodeck controller.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example in order to look closer at some current calculations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have an LED that needs around 10 mA to bright light up correctly
    (without burning at the second blink!!)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: This would mean you'd have 8 x 10 mA for one eight -LEDs array, driven by one
    595 shift register, if all LEDs were to be switched on at the same time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 80 mA would be the global current driven by one 595 shift register from the
    Arduino Vcc source.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: If you had more 595 shift registers, the magnitude of the current would increase.
    You have to know that all integrated circuits also consume current. Their consumption
    isn't generally taken into consideration, because it is very small. For instance,
    the 595 shift register circuit only consumes around 80 micro Amperes itself, which
    means 0.008 mA. Compared to our LEDs, it is negligible. Resistors consume current
    too, even if they are often used to protect LEDs, they are very useful.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, we are about to learn another very neat and smart trick that can be
    used for monochromatic or RGB LEDs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to a world full of colors.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Using RGB LEDs
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RGB stands for Red, Green, and Blue, as you were probably guessing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: I don't talk about LEDs that can change their color according to the voltage
    you apply to them. LEDs of this kind exists, but as far as I experimented, these
    aren't the way to go, especially while still learning steps.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: I'm talking about common cathode and common anode RGB LEDs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Some control concepts
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What do you need to control an LED?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: You need to be able to apply a current to its legs. More precisely, you need
    to be able to create a difference of potential between its legs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The direct application of this principle is what we have already tested in
    the first part of this chapter, which remind us how we can switch on an LED: we
    you need to control the current using digital output pins of our Arduino, knowing
    the LED we want to control has its node wired to the output pin and its cathode
    wired to the ground, with a resistor on the line too.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We can discuss the different ways of controls, and you are going to understand
    that very quickly with the next image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In order to make a digital output sourcing current, we need to write with `digitalWrite`
    to it a value of `HIGH`. In that this case, the considered digital output will
    be internally connected to a 5 V battery and will produce a voltage of 5 V. That
    means that the wired LED between it and the ground will be fed by a current.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In the other case, if we apply 5 V to an LED and if we want to switch it on,
    we need to write a value of `LOW` to the digital pin to which it is linked. In
    this case, the digital pin will be internally connected to the ground and will
    sink the current.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: These are the two ways of controlling the current.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the following diagram:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Some control concepts](img/7584_08_015.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Different types of RGB LEDs
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s check the two common RGB LEDs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Different types of RGB LEDs](img/7584_08_016.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: There are basically three LEDs in one package, with different types of wiring
    inside. The way of making this package isn't really about wiring inside, but I
    won't debate that here.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: If you followed me correctly, you may have guessed that we need more digital
    outputs to connect RGB LEDs. Indeed, the previous section talked about saving
    digital pins. I guess you understand why it could be important to save pins and
    to plan our circuit architectures carefully.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Lighting an RGB LED
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Check this basic circuit:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting an RGB LED](img/7584_08_017.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: An RGB LED wired to Arduino
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Check the code now. You can find it in the `Chapter08/One_RGB_LED/` folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, some tips are present inside this code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Red, Green, and Blue light components and colors
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, what is the point here? I want to make the RGB LED cycle through all
    the possible states. Some math can help to list all the states.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an ordered list of three elements, each one of which can be on or off.
    Thus, there are 23 states, that which means eight states in total:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| R | G | B | Resulting color |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| Off | Off | Off | OFF |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| Off | Off | On | Blue |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| Off | On | Off | Green |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| Off | On | On | Cyan |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| On | Off | Off | Red |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| On | Off | On | Purple |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| On | On | Off | Orange |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| On | On | On | White |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: Only by switching each color component on or off, can we change the global RGB
    LED state.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that the system works exactly as if we were controlling three monochromatic
    LEDS through three digital outputs from Arduino.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: First, we define three variables storing the different colors LED connectors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `setup()`, we set those 3 three pins as output.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Multiple imbricated for() loops
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At last, the `loop()` block contains triple-imbricated `for()` loops. What''s
    that? It is nice efficient way to be sure to match all the cases possible. It
    is also an easy way to cycle each number possible. Let''s check the first steps,
    in order to understand this imbricated loops concept better.:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '1st step: **r = 0, g = 0, and b = 0** implies everything is OFF, then pauses
    for 150ms in that state'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2nd step: **r = 0, g = 0, and b = 1** implies only BLUE is switched on, then
    pauses for 150ms in that state'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3rd step: **r = 0, g = 1, and b = 0** implies only GREEN is switched on, then
    pauses for 150ms in that state'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The innermost loop is always the one executed the most number of times.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Is that okay? You bet, it is!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: You also may have noticed that I didn't write HIGH or LOW as arguments for the
    `digitalWrite()` function. Indeed, HIGH and LOW are constants defined in the Arduino
    core library and are only replace the values 1 and 0, respectively.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In order to prove this, and especially to show you for the first time where
    the Arduino core files sit, the important file to check here is `Arduino.h`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: On a Windows systems, it can be found in the `Arduino` folder inside some subdirectories,
    depending upon the version of the IDE.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: On OS X, it is in `Arduino.app/Contents/Resources/Java/hardware/arduino/cores/arduino/Arduino.h`.
    We can see the content of an application package by right-clicking on the package
    itself.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In this file, we can read a big list of constants, among many other definitions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we can retrieve the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Yes, the HIGH and LOW keywords are just constants for 1 and 0.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why I'm directly feeding `digitalWrite()` with `0` and `1`
    through the imbricated loops, cycling over all the states possible for each LED,
    and as a consequence, over all states for the RGB LED.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Using this concept, we are going to dig further by making an LED array.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Building LED arrays
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LED arrays are basically LEDs wired as a matrix.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We are going to build a 3 x 3 LEDs matrix together. This is not that hard, and
    we'll approach this task with a really nice, neat and smart concept that can really
    optimize your hardware designs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the simplest schematic of this book:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Building LED arrays](img/7584_08_018.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: An LED can blink when a current feeds it, when a voltage is applied to its legs
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In order to switch off the LED shown in the preceding screenshot, we can stop
    to create the 5 V current at its node. No voltage means no current feeding. We
    can also cut the circuit itself to switch off the LED. And at last, we can change
    the ground by putting adding a 5 V source current.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: This means that as soon as the difference of potential is cancelled, the LED
    is switched off.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: An LED array is based on these double controls possible.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We are going to introduce a new component right here, the transistor.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: A new friend named transistor
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **transistor** is a special component that we introduced a bit in the first
    part of this book.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![A new friend named transistor](img/7584_08_019.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: The usual NPN transistor with its three legs
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'This component is usually used in three main cases:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: As a digital switch in a logical circuit
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a signal amplifier
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a voltage stabilizer combined with other components
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transistors are the most widespread components in the world. They are not only
    used as discrete components (independent ones) but are also combined with many
    others into a high-density system, for instance, in processors.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The Darlington transistors array, ULN2003
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use a transistor here, as included inside an integrated circuit
    named ULN2003\. What a pretty name! A more explicit one is **High-current** **Darlington
    Transistors Array**. Ok, I know that doesn't help!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![The Darlington transistors array, ULN2003](img/7584_08_020.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Its datasheet can be found at
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.ti.com/lit/ds/symlink/uln2003a.pdf](http://www.ti.com/lit/ds/symlink/uln2003a.pdf).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: It contains seven pins named inputs and seven named outputs. We can see also
    a 0 V pin (the number 8) and the COM pin 9 too.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle is simple and amazing:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 0 V has to be connected to the ground
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you apply 5 V to the input *n*, the output *n* is commuted to ground
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you apply 0 V to the input *n*, the output *n* will get disconnected.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: This can easily be used as a current sink array of switches.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Combined with 74HC595, we''ll drive our 3 x 3 LED matrix right now:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![The Darlington transistors array, ULN2003](img/7584_08_021.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: A case where inputs 1 and 2 are fed, resulting in the commutation of outputs
    1 and 2 (pin 16 and 14)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The LED matrix
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's check how we can wire our matrix, keeping in mind that we have to be able
    to control each LED independently, of course.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: This kind of design is very usual. You can easily find ready made matrices of
    LEDs wired like this, sold in packages with connectors available related to rows
    and columns.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'An LED matrix is basically an array where:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Each row pops out a connector related to all the anodes of that row
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each column pops out a connector related to all the cathodes of that column
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is not law, and I found some matrices wired totally in the opposite way
    and sometimes quite strangely. So, be careful and check the datasheet. Here, we
    are going to study a very basic LED matrix in order to dig into that concept:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![The LED matrix](img/7584_08_022.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: A basic 3 x 3 LED matrix
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the LED matrix architecture concept.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: How can we control it? By controlling, I mean addressing the good LED to a good
    behavior, from being switched on or off.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that, if we want to light up the **LED 2**, we have to:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Connect **ROW 1** to 5 V
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect **COLUMN 2** to the ground
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good! We can light up that **LED 2**.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move further. Let''s imagine that, if we want to light up the **LED
    2** and **LED 4**, we have to:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Connect **ROW 1** to 5 V
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect **COLUMN 2** to the ground
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect **ROW 2** to 5 V
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect **COLUMN 1** to the ground
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice something?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'If you follow the steps carefully, you should have something strange on your
    matrix:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**LED 1**, **LED 2**, **LED 4**, and **LED5** would be switched ON'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem appeared: if we put 5 V to the **ROW 1**, how can you distinguish **COLUMN
    1** and **COLUMN 2**?'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: We are going to see that it isn't hard at all and that it just uses a small
    trick related to our persistence of vision.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Cycling and POV
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can take care of the problem encountered in the previous section by cycling
    our matrix quickly.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The trick is switching ON only one column at a time. This could also work by
    switching ON only one row at a time, of course.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our previous problem: If we want to light up the **LED 2** and
    **LED 4**, we have to:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Connect **ROW 1** to 5 V and **COLUMN 1** to 5 V only
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, put connect **ROW 2** to 5 V and **COLUMN 2** to 5 V only
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we we are doing that this very quickly, our eyes won't see that there is
    only one LED switched on at a time.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudo code would be:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The circuit
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, the circuit has to be designed. Here is how it looks:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit](img/7584_08_023.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: Arduino wired to a 595 shift register driving each row and column through an
    ULN2003
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now check the circuit diagram:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit](img/7584_08_024.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: Circuit diagram showing the handling of matrix rows and columns
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: We have the now well-known shift register 74HC595.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: This one is wired to a ULN2003 shift register and to the matrix' rows, the ULN2003
    being wired to the columns of the matrix.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: What is that design pattern?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The shift register grabs data from the serial protocol-based messages sent by
    the Arduino from its digital pin 2\. As we tested before, the shift register is
    clocked to Arduino, and as soon as its latch pin is connected to HIGH (=(equal
    to 5 V), it drives an output to 5V or not, depending upon the data sent to it
    by Arduino. As a consequence, we can control each row of the matrix, feeding them
    rows with 5V or not through the data sent to the shift register.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: In order to switch on LEDs, we have to close the circuit on which they are plugged,
    the electrical line, I mean. We can feed the **ROW 1** with a 5V current, but
    if we don't put this or that column to the ground, the circuit won't be closed
    and no LED will be switched on. Right?
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The ULN2003 was made precisely for the purpose of ground commutation, as we
    already saw. And if we feed 5V to one of its input, it commutes the corresponding
    out *n* pin to the ground. So, with our 595 shift registers, we can control the
    5V commutation for rows, and the ground commutation for columns. We now have total
    control over our matrix.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Especially, we are going to check the code, including the power cycle of columns
    previously explained.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The 3 x 3 LED matrix code
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find the following 3 x 3 LED matrix code in the `Chapter08/LedMatrix3x3/`
    folder:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/LedMatrix3x3/`文件夹中找到以下3x3 LED矩阵代码：
- en: '[PRE13]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code is quite self-explanatory with comments, but let's check it out a
    bit more.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码带有注释，相当自解释，但让我们更详细地检查一下。
- en: The global structure reminds the one in Multiplexing_8Leds.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 全局结构让人联想到Multiplexing_8Leds中的结构。
- en: 'We have an integers array named LED_states. We are storing data for each LED
    state inside of it. The setup() block is quite easy, defining each digital pin
    used in the communication with the 595 shift- register and then grabbing a random
    seed from the ADC. The loop() is a bit more tricky. At first, we generating nine
    random values and store them in the LED_states array. Then, we initialize/define
    some values:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为LED_states的整数数组。我们在其中存储每个LED状态的值。`setup()`块相当简单，定义用于与595移位寄存器通信的每个数字引脚，然后从ADC获取一个随机种子。`loop()`函数稍微复杂一些。首先，我们生成九个随机值并将它们存储在LED_states数组中。然后，我们初始化/定义一些值：
- en: '`data` is the byte sent to the shift register'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 是发送到移位寄存器的字节。'
- en: '`dataRow` is the part of the byte handling row state (commuted to 5V or not)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataRow` 是处理行状态的字节部分（是否转换为5V）。'
- en: '`dataColumn` is the part of the byte handling column state (commuted to the
    ground or not)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataColumn` 是处理列状态的字节部分（是否转换为地）。'
- en: '`currentLed` keeps the trace of the current handled handled by the LED'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentLed` 保留当前由LED处理的跟踪。'
- en: Then, those imbricated loops occur.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，那些嵌套的循环发生。
- en: 'For each column (first for() loop), we activate it the loop by using a small/cheap
    and fast bitwise operator:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一列（第一个for()循环），我们通过使用一个小巧、便宜且快速的位运算符来激活循环：
- en: '[PRE14]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`(4 – c)` goes from `4` to `2`, all along this first `loop()` ; function; then,
    `dataColumn` goes from: `0 0 0 1 0 0 0 0` to `0 0 0 0 1 0 0 0`, and at last `0
    0 0 0 0 1 0 0`.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`(4 – c)` 从`4`到`2`，在整个第一个`loop()`函数中；然后，`dataColumn`从`0 0 0 1 0 0 0 0`变为`0
    0 0 0 1 0 0 0`，最后变为`0 0 0 0 0 1 0 0`。'
- en: What's going on right here? It is all about coding.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？一切都是关于编码。
- en: The first three bits (beginning at the left, the MSB bit) handle the rows of
    our matrix. Indeed the three rows are connected to the `Q0`, `Q1`, and `Q2` pins
    of the 595 shift register.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 前三位（从左边开始，最高位MSB）处理矩阵的行。确实，三行连接到595移位寄存器的`Q0`、`Q1`和`Q2`引脚。
- en: The second three-bit group handles the ULN2003, which itself handles the columns.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个三位组处理ULN2003，它本身处理列。
- en: By feeding 5 V from `Q0`, `Q1`, and `Q2` of the 595, we handle rows. By feeding
    5 V from `Q3`, `Q4`, and `Q5` of the 595, we handle columns through the ULN2003.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从595的`Q0`、`Q1`和`Q2`提供5V，我们处理行。通过从595的`Q3`、`Q4`和`Q5`提供5V，我们通过ULN2003处理列。
- en: Good!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！
- en: We still have two bits not unused bits right here, the last two.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有两个未使用的位在这里，最后两个。
- en: Let's take look at our our code again.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的代码。
- en: At each column turn of the for() loop, we move the bit corresponding to the
    column to the right, commuting each column to the ground cyclically.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在for()循环的每次列转换中，我们将对应于列的位向右移动，将每个列循环性地转换为地。
- en: Then, for each column, we cycle the row on the same mode, testing the state
    of the corresponding LED that we have to push to the 595\. If the LED has to be
    switched on, we store the corresponding bit in the dataRow variable with the same
    bitwise operation trick.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每一列，我们以相同的模式循环行，测试我们必须要推送到595的相应LED的状态。如果LED需要打开，我们使用相同的位运算技巧将相应的位存储在`dataRow`变量中。
- en: Then, we sum those two parts, resulting in the data variable.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这两部分相加，得到数据变量。
- en: 'For instance, if we are on the second row and the second column and the LED
    has to be switched on, then the data stored will be:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们处于第二行和第二列，并且需要打开LED，那么存储的数据将是：
- en: '`0 1 0 0 1 0 0 0`.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`0 1 0 0 1 0 0 0`。'
- en: 'If we are at (1,3), then the data stored will be data will store:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于（1,3），那么存储的数据将是：
- en: '`1 0 0 0 0 1 0 0`.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 0 0 0 0 1 0 0`.'
- en: Then, we have the pattern that adds Latch to LOW, shifting out bits stored in
    data to the shift- register, and then putting adds Latch to HIGH to commit data
    to the Q0 to Q7 outputs, feeding the right elements in the circuits.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个模式，将锁存器设置为低电平，将存储在数据中的位移出到移位寄存器，然后通过将锁存器设置为高电平将数据提交到Q0到Q7输出，为电路中的正确元素提供能量。
- en: At the end of each row handled, we reset the three bits corresponding to the
    first three rows and increment the `currentLed` variable.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完每一行后，我们重置对应于前三个行的三位，并增加`currentLed`变量。
- en: At the end of each column handled, we reset the three bits corresponding to
    the next three columns.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完每一列的末尾，我们重置与下一列对应的三个位。
- en: This global imbricated structure makes us ensures that we'll have only one LED
    switched on at a time.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这种全局嵌套结构确保我们一次只能有一个LED开启。
- en: What is the consequence of the current consumption?
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 电流消耗会有什么后果？
- en: We'll only have one LED fed, which means we'll have our maximum consumption
    potentially divided by nine. Yes, that sounds great!
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个LED供电，这意味着我们的最大功耗可能被九等分。是的，听起来很棒！
- en: Then, we have the pattern grabbing that grabs a new seed, each 5000 loop() turn.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有模式抓取，每次5000次loop()循环抓取一个新的种子。
- en: We just learned how to handle LED matrices quite easily and to reduce our power
    consumption at the same time.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了如何轻松地处理LED矩阵，同时减少功耗。
- en: But, I'm not satisfied. Usually, creators and artists are generally never completely
    satisfied, but here, trust me it's different; we could do better things than just
    switching on and off LEDs. We could dim them too and switch them from a very low
    intensity to a very high one, making some different shades of light.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我不满意。通常，创造者和艺术家通常永远不会完全满意，但在这里，请相信我，情况不同；我们可以做得比仅仅开关LED更好。我们还可以调节亮度，从非常低的强度切换到非常高的强度，产生不同的光色。
- en: Simulating analog outputs with PWM
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PWM模拟模拟输出
- en: As we know very well by now, it's okay to switch on/off LEDs, and as we are
    going to see in the next chapter, to switch on/off many things too by using digital
    pins as output on the Arduino.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，开关LED是没问题的，而且正如我们将在下一章中看到的，使用Arduino的数字引脚作为输出开关许多东西也是可以的。
- en: We also know how to read states from digital pins set up as inputs, and even
    values from 0 to 1023 from the analog inputs from in the ADC.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也知道如何从设置为输入的数字引脚读取状态，甚至从ADC中的模拟输入读取0到1023的值。
- en: As far as we know, there isn't analog output on the Arduino.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们所知，Arduino上没有模拟输出。
- en: What would an analog output add? It would provide a way to write values other
    than only 0 and 1, I mean 0 V and 5 V. This would be nice but would require an
    expensive DAC.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟输出会添加什么？它会提供一种写入除了只有0和1之外的其他值的方法，我的意思是0V和5V。这会很棒，但需要昂贵的DAC。
- en: Indeed, there isn't a DAC on Arduino boards.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Arduino板上没有DAC。
- en: The pulse-width modulation concept
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脉宽调制概念
- en: The **pulse-width modulation** is a very common technique used to mimic analog
    output behavior.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉宽调制**是一种非常常见的用于模拟输出行为的模拟技术。'
- en: Let's put that another way.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换一种说法。
- en: Our digital outputs can only be at 0 V or 5 V. But at a particular time-interval,
    if we switch them on/off quickly, then we can calculate a mean value depending
    on the time passed at 0 V or 5 V. This mean can easily be used as a value.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数字输出只能处于0V或5V。但在特定的时间间隔内，如果我们快速开关它们，那么我们可以根据在0V或5V下经过的时间计算平均值。这个平均值可以很容易地用作一个值。
- en: 'Check the following schematic to know know more about the concept of duty cycle:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下电路图以了解更多关于占空比的概念：
- en: '![The pulse-width modulation concept](img/7584_08_025.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![脉宽调制概念](img/7584_08_025.jpg)'
- en: The concept of duty cycle and PWM
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比和PWM的概念
- en: The mean of the time spent at 5V defines the duty cycle. This value is the mean
    time when the pin is at 5V and is given as a percentage.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在5V下花费的平均时间定义了占空比。这个值是引脚在5V时的平均时间，并以百分比给出。
- en: '`analogWrite()` is a special function that can generate a steady square wave
    at a specific duty cycle until the next call.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`analogWrite()`是一个特殊函数，可以在特定的占空比下生成稳定的方波，直到下一次调用。'
- en: According to the Arduino core documentation, the PWM signal pulses at a frequency
    of 490 Hz. I didn't (yet) verify this, but it would really only be possible with
    an oscilloscope, for instance.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Arduino核心文档，PWM信号以490Hz的频率脉冲。我还没有（现在）验证这一点，但使用示波器等工具才能真正实现。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Be careful: PWM isn''t available on every pin of your board!'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：不是你板上的每个引脚都支持PWM！
- en: For instance, Arduino Uno and Leonardo provide PWM on digital pins numbers 3,
    5, 6, 9, 10, and 11.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Arduino Uno和Leonardo在数字引脚3、5、6、9、10和11上提供PWM。
- en: You have to know this before trying anything.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试任何操作之前，你必须知道这一点。
- en: Dimming an LED
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调暗LED
- en: 'Let''s check a basic circuit in order to test PWM:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个基本电路来测试PWM：
- en: '![Dimming an LED](img/7584_08_026.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![调暗LED](img/7584_08_026.jpg)'
- en: 'Let''s look at the circuit diagram, even if it''s obvious:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看电路图，即使它很明显：
- en: '![Dimming an LED](img/7584_08_027.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![调暗LED](img/7584_08_027.jpg)'
- en: We'll use the Fading example by David A. Mellis and modified by Tom Igoe. Check
    it in **File** | **examples** | **03.Analog** | **Fading**. We are going to change
    the `ledPin` value from `9` to `11` to fit our circuit.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用David A. Mellis的Fading示例，并由Tom Igoe修改。在**文件** | **示例** | **03.模拟** | **Fading**中检查它。我们将把`ledPin`值从`9`改为`11`以适应我们的电路。
- en: 'Here it is, modified:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是修改后的样子：
- en: '[PRE15]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Upload it, test it, and love it!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 上传它，测试它，并爱上它！
- en: A higher resolution PWM driver component
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更高分辨率的PWM驱动组件
- en: 'Of course, there are components providing higher resolutions of PWM. Here,
    with native Arduino boards, we have an 8-bit resolution (256 values). I wanted
    to point out to you the Texas Instrument, TLC5940\. You can find its datasheet
    here: [http://www.ti.com/lit/ds/symlink/tlc5940.pdf](http://www.ti.com/lit/ds/symlink/tlc5940.pdf).'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有提供更高PWM分辨率的组件。在这里，使用原生的Arduino板，我们有8位分辨率（256个值）。我想指出的是德州仪器的TLC5940。您可以在以下位置找到其数据表：[http://www.ti.com/lit/ds/symlink/tlc5940.pdf](http://www.ti.com/lit/ds/symlink/tlc5940.pdf)。
- en: '![A higher resolution PWM driver component](img/7584_08_028.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![更高分辨率的PWM驱动组件](img/7584_08_028.jpg)'
- en: TLC5950, the 16-channel LED driver that provides PWM control
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: TLC5950，一个提供PWM控制的16通道LED驱动器
- en: Be careful, it is a constant-current sink driver. This means that it sinks the
    current and does not feed the current. For instance, you'd have to connect cathodes
    of your LEDs to the `OUT0` and `OUT15` pins, not anodes. If you want to use a
    specific driver like that, you won't use `analogWrite()`, of course. Why? Because
    this driver works as a shift register, wired through a serial connection with
    our Arduino.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，它是一个恒流源驱动器。这意味着它会吸收电流而不是提供电流。例如，您需要将LED的阴极连接到`OUT0`和`OUT15`引脚，而不是阳极。如果您想使用这样的特定驱动器，当然不会使用`analogWrite()`。为什么？因为这个驱动器作为一个移位寄存器，通过串行连接与我们的Arduino相连。
- en: I'd suggest using a nice library named tlc5940arduino, and available on Google
    code at
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用一个名为tlc5940arduino的库，它可在Google代码上找到
- en: '[http://code.google.com/p/tlc5940arduino/](http://code.google.com/p/tlc5940arduino/)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/tlc5940arduino/](http://code.google.com/p/tlc5940arduino/)'
- en: 'We''ll see, in the third part of this book, how to write messages on LED matrices.
    But, there is also a nice way to use highest resolution displays: LCD.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第三部分，我们将看到如何在LED矩阵上写消息。但是，也有一种使用最高分辨率显示器的不错方法：LCD。
- en: Quick introduction to LCD
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LCD快速入门
- en: '**LCD** means **Liquid Crystal Display**. We use LCD technology everyday in
    watches, digicode display, and so on. Look around you, and check these small or
    great LCDs.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**LCD**代表**液晶显示器**。我们在日常生活中使用LCD技术，如手表、数字码显示等。环顾四周，检查这些小或大的LCD。'
- en: 'There exist two big families of LCD displays:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种主要的LCD显示器系列：
- en: Character LCD is based on a matrix of characters (columns x rows)
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符LCD基于字符矩阵（列 x 行）
- en: Graphical LCD , is based on a pixel matrix
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形LCD，基于像素矩阵
- en: We can find a lot of printed circuit boards that include an LCD and the connectors
    to interface them with Arduino and other systems for cheap, nowadays.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以以便宜的价格找到许多包含LCD和连接器，用于将它们与Arduino和其他系统接口的印刷电路板。
- en: There is now a library included in the Arduino Core that is really easy to use.
    Its name is **LiquidCrystal**, and it works with all LCD displays that are compatible
    with the Hitachi HD44780 driver. This driver is really common.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Arduino核心中包含了一个库，使用起来非常简单。它的名字是**LiquidCrystal**，它与所有兼容Hitachi HD44780驱动器的LCD显示器一起工作。这个驱动器非常常见。
- en: 'Hitachi developed it as a very dedicated driver, that includes a micro-controller
    itself, specifically to drive alphanumeric characters LCDs and to connect to the
    external world easily too, which can be done by a specific link using, usually,
    16 connectors, including power supply for the external circuit itself and the
    backlight supply too:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 日立将其开发为一个非常专用的驱动器，它本身包含一个微控制器，专门用于驱动字符LCD并轻松连接到外部世界，这可以通过一个特定的链接完成，通常使用16个连接器，包括为外部电路本身和背光供电：
- en: '![Quick introduction to LCD](img/7584_08_029.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![LCD快速入门](img/7584_08_029.jpg)'
- en: A 16 x 2 character LCD
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 16 x 2字符LCD
- en: We are going to wire it and display some messages on it.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对其进行布线并在其上显示一些消息。
- en: HD44780-compatible LCD display circuit
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容HD44780的LCD显示电路
- en: 'Here is the basic circuit of the HD44780-compatible LCD display:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HD44780兼容LCD显示电路的基本电路：
- en: '![HD44780-compatible LCD display circuit](img/7584_08_030.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![兼容HD44780的LCD显示电路](img/7584_08_030.jpg)'
- en: A 16 x 2 character LCD wired to Arduino and a potentiometer controlling its
    contrast
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连接到Arduino和电位器的16 x 2字符LCD，用于控制其对比度
- en: 'The corresponding circuit diagram is as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电路图如下：
- en: '![HD44780-compatible LCD display circuit](img/7584_08_031.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![HD44780兼容的LCD显示电路](img/7584_08_031.jpg)'
- en: Circuit diagram of the character LCD, the potentiometer, and the Arduino board
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 字符LCD、电位器和Arduino板电路图
- en: LED+ and LED- aren't necessary as far as you have sufficient light. Using the
    potentiometer, you can also set the contrast of the LCD in order to have enough
    readability.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有足够的光线，LED+和LED-不是必需的。使用电位器，你还可以设置LCD的对比度，以便有足够的可读性。
- en: By the way, LED+ and LED- are, respectively, backlight anode and backlight cathode
    of the internal LED used for the backlight. You can drive these from Arduino,
    but it can lead to more consumption. Please read the LCD instructions and datasheet
    carefully.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，LED+和LED-分别是内部LED的背光阳极和背光阴极。你可以从Arduino驱动这些，但这可能会导致更多的功耗。请仔细阅读LCD说明和数据表。
- en: Displaying some random messages
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示一些随机消息
- en: 'Here is some neat firmware. You can find it in the `Chapter08/basicLCD/` folder:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些整洁的固件。你可以在`Chapter08/basicLCD/`文件夹中找到它：
- en: '[PRE16]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we have to include the `LiquidCrystal` library. Then, we define two
    variables:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须包含`LiquidCrystal`库。然后，我们定义两个变量：
- en: '`manyMessages` is an array of String for message storage'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manyMessages`是一个用于存储消息的String数组'
- en: '`counter` is a variable used for time tracing'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter`是一个用于时间追踪的变量'
- en: 'Then, we initialize the `LiquidCrystal` library by passing some variables to
    its constructor, corresponding to each pin used to wired the LCD to the Arduino.
    Of course, the order of pins matters. It is: `rs`, `enable`, `d4`, `d5`, `d6`,
    and `d7.`'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过向其构造函数传递一些变量来初始化`LiquidCrystal`库，这些变量对应于连接LCD到Arduino所使用的每个引脚。当然，引脚的顺序很重要。它是：`rs`、`enable`、`d4`、`d5`、`d6`和`d7`。
- en: In the `setup()`, we define the size of the LCD according to the hardware, here
    that would be 16 columns and two rows.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`中，我们根据硬件定义LCD的大小，这里将是16列和两行。
- en: Then, we statically store some messages in each element of the String array.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在String数组的每个元素中静态存储一些消息。
- en: In the `loop()` block, we first place the cursor to the first place of the LCD.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`块中，我们首先将光标放置在LCD的第一位置。
- en: We test the expression `(millis() – counter > 5000)` , and if it is true, we
    clear the whole LCD. Then, I'm printing a message defined by chance. Indeed, `random(4)`
    produces a pseudo-random number between 0 and 3 , and that index being random,
    we print a random message to the LCD from among the four defined in `setup()`
    to the LCD, on the first row.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试表达式`(millis() – counter > 5000)`，如果为真，则清除整个LCD。然后，我打印一个随机定义的消息。实际上，`random(4)`生成一个介于0和3之间的伪随机数，由于索引是随机的，我们在`setup()`中定义的四个消息之一随机打印到LCD的第一行。
- en: Then, we store the current time in order to be able to measure the time passed
    since the last random message was displayed.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们存储当前时间，以便能够测量自上次显示随机消息以来经过的时间。
- en: Then, we put the cursor at the first column of the second row, then, we print
    a String composed by constant and variable parts displaying the time in milliseconds
    since the last reset of the Arduino board.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将光标置于第二行的第一列，然后打印一个由常数和变量部分组成的String，显示自Arduino板上次重置以来的毫秒数。
- en: Summary
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this long chapter, we learned to deal with many things, including monochromatic
    LEDs to RGB LEDs, using shift registers and transistor arrays, and even introduce
    the LCD display. We dug a bit deeper into displaying visual feedbacks from the
    Arduino without necessarily using a computer.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个漫长的章节中，我们学习了如何处理许多事情，包括单色LED到RGB LED，使用移位寄存器和晶体管阵列，甚至介绍了LCD显示。我们深入研究了在不使用电脑的情况下从Arduino显示视觉反馈。
- en: In many cases of real life design, we can find projects using Arduino boards
    totally standalone and, without a computer. Using special libraries and specific
    components, we now know that we can make our Arduino feeling, expressing, and
    reacting.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际设计案例中，我们可以找到完全独立使用Arduino板的项目，无需电脑。通过使用特殊库和特定组件，我们现在知道我们可以让我们的Arduino感觉、表达和反应。
- en: In the following chapter, we are going to explain and dig into some other concepts,
    such as making Arduino move and eventually generating sounds too.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解释并深入研究一些其他概念，例如让Arduino移动，最终生成声音。
