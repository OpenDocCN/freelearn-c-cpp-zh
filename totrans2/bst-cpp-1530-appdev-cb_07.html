<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Manipulating Strings</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Changing cases and case-insensitive comparison</li><li class="listitem" style="list-style-type: disc">Matching strings using regular expressions</li><li class="listitem" style="list-style-type: disc">Searching and replacing strings using regular expressions</li><li class="listitem" style="list-style-type: disc">Formatting strings using safe printf-like functions</li><li class="listitem" style="list-style-type: disc">Replacing and erasing strings</li><li class="listitem" style="list-style-type: disc">Representing a string with two iterators</li><li class="listitem" style="list-style-type: disc">Using a reference to string type</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Introduction</h1></div></div></div><p>This whole chapter is devoted to different aspects of changing, searching, and representing strings. We'll see how some common string-related tasks can be easily done using the Boost libraries. This chapter is easy enough; it addresses very common string manipulation tasks. So, let's begin!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Changing cases and case-insensitive comparison</h1></div></div></div><p>This is a pretty common task. <a id="id431" class="indexterm"/>We have two non-Unicode or ANSI character strings:</p><div><pre class="programlisting">#include &lt;string&gt;
std::string str1 = "Thanks for reading me!";
std::string str2 = "Thanks for reading ME!";</pre></div><p> We need to compare them in a case-<a id="id432" class="indexterm"/>insensitive manner. There are a lot of methods to do that; let's take a look at Boost's.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec269"/>Getting ready</h2></div></div></div><p>Basic knowledge of <code class="literal">std::string</code> is all we need here.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec270"/>How to do it...</h2></div></div></div><p>Here are some different ways to do case-insensitive comparisons:</p><div><ol class="orderedlist arabic"><li class="listitem">The most trivial one is:<div><pre class="programlisting">#include &lt;boost/algorithm/string/predicate.hpp&gt;

boost::iequals(str1, str2)</pre></div></li><li class="listitem">Using the Boost predicate and STL method:<div><pre class="programlisting">#include &lt;boost/algorithm/string/compare.hpp&gt;
#include &lt;algorithm&gt;

str1.size() == str2.size() &amp;&amp; std::equal(
  str1.begin(),
  str1.end(),
  str2.begin(),
  boost::is_iequal()
)</pre></div></li><li class="listitem">Making a lowercase <a id="id433" class="indexterm"/>copy of both the strings:<div><pre class="programlisting">#include &lt;boost/algorithm/string/case_conv.hpp&gt;

std::string str1_low = boost::to_lower_copy(str1);
std::string str2_low = boost::to_lower_copy(str2);
assert(str1_low == str2_low);</pre></div></li><li class="listitem">Making an uppercase <a id="id434" class="indexterm"/>copy of the original strings:<div><pre class="programlisting">#include &lt;boost/algorithm/string/case_conv.hpp&gt;

std::string str1_up = boost::to_upper_copy(str1);
std::string str2_up = boost::to_upper_copy(str2);
assert(str1_up == str2_up);</pre></div></li><li class="listitem">Converting the original strings to lowercase:<div><pre class="programlisting">#include &lt;boost/algorithm/string/case_conv.hpp&gt;

boost::to_lower(str1);
boost::to_lower(str2);
assert(str1 == str2);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec271"/>How it works...</h2></div></div></div><p>The second method is not an obvious one. In the second method, we compare the length of the strings; if they have the same length, we compare the strings character by character using an instance of the <a id="id435" class="indexterm"/>
<code class="literal">boost::is_iequal</code> predicate. The <code class="literal">boost::is_iequal</code> predicate compares two characters in a case-insensitive way.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>The <code class="literal">Boost.StringAlgorithm</code> library uses <code class="literal">i</code> in the name of the method or class, if this method is case-insensitive. For example, <code class="literal">boost::is_iequal</code>, <code class="literal">boost::iequals</code>, <code class="literal">boost::is_iless</code>, and others.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec272"/>There's more...</h2></div></div></div><p>Each function and the functional object <a id="id436" class="indexterm"/>of the <code class="literal">Boost.StringAlgorithm</code> library that work with cases accept <code class="literal">std::locale</code>. <a id="id437" class="indexterm"/>By default (and in our examples), methods and classes use a default constructed <code class="literal">std::locale</code>. If we work a lot with strings, it may be a good optimization to construct a <code class="literal">std::locale</code> variable <a id="id438" class="indexterm"/>once and pass it to all the methods. Another good optimization would be to use the 'C' locale (if your application logic permits that) via <code class="literal">std::locale::classic()</code>:</p><div><pre class="programlisting">  // On some platforms std::locale::classic() works
  // faster than std::locale()
  boost::iequals(str1, str2, std::locale::classic());</pre></div><div><div><h3 class="title"><a id="note28"/>Note</h3><p>Nothing forbids you to use both optimizations.</p></div></div><p>Unfortunately, C++11 has no string functions from <code class="literal">Boost.StringAlgorithm</code>. All the algorithms are fast and reliable, so do not be afraid to use them in your code.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec273"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Official documentation on the <a id="id439" class="indexterm"/>Boost String Algorithms library can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html">http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html</a></li><li class="listitem" style="list-style-type: disc">See the <em>C++ Coding Standards</em> book by Andrei Alexandrescu and Herb Sutter for an example on how to make a case-insensitive string with a few lines of code</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Matching strings using regular expressions</h1></div></div></div><p>Let's do something useful! It's common that the user's input must be checked using some regular <a id="id440" class="indexterm"/>expression-specific pattern that provides a flexible means of match. The problem is that there are a lot of regex syntaxes; expressions written using <a id="id441" class="indexterm"/>one syntax are not handled well by the other syntax. Another problem is that long regexes are not easy to write.</p><p>So in this recipe, we'll write a program that may use different types of regular expression syntaxes and checks that the input strings match the specified regexes.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec274"/>Getting ready</h2></div></div></div><p>This recipe requires basic knowledge of STL. Knowledge of regular expression syntax can be helpful, but it is not really required.</p><p>Linking examples against the <code class="literal">libboost_regex</code> library is required.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec275"/>How to do it...</h2></div></div></div><p>This regex matcher consists of a few lines of <a id="id442" class="indexterm"/>code in the <code class="literal">main()</code> function; however, I use it a lot. It'll help you some day.</p><div><ol class="orderedlist arabic"><li class="listitem">To implement it, we'll need the following headers:<div><pre class="programlisting">#include &lt;boost/regex.hpp&gt;
#include &lt;iostream&gt;</pre></div></li><li class="listitem">At the start of the program, we need to output the available regex syntaxes:<div><pre class="programlisting">int main() {
  std::cout 
    &lt;&lt; "Available regex syntaxes:\n"
    &lt;&lt; "\t[0] Perl\n"
    &lt;&lt; "\t[1] Perl case insensitive\n"
    &lt;&lt; "\t[2] POSIX extended\n"
    &lt;&lt; "\t[3] POSIX extended case insensitive\n"
    &lt;&lt; "\t[4] POSIX basic\n"
    &lt;&lt; "\t[5] POSIX basic case insensitive\n"
    &lt;&lt; "Choose regex syntax: ";</pre></div></li><li class="listitem">Now correctly set up <a id="id443" class="indexterm"/>flags, <a id="id444" class="indexterm"/>according to the chosen syntax:<div><pre class="programlisting">  boost::regex::flag_type flag;
  switch (std::cin.get()) {
    case '0': flag = boost::regex::perl;
      break;
    case '1': flag = boost::regex::perl|boost::regex::icase;
      break;

    case '2': flag = boost::regex::extended;
      break;
    case '3': flag = boost::regex::extended|boost::regex::icase;
      break;
    case '4': flag = boost::regex::basic;
      break;

    case '5': flag = boost::regex::basic|boost::regex::icase;
      break;
    default:
      std::cout &lt;&lt; "Inccorect number of regex syntax."
                &lt;&lt;"Exiting... \n";
      return -1;
  } 
  // Disabling exceptions
  flag |= boost::regex::no_except;</pre></div></li><li class="listitem">Now we'll be requesting regex patterns in a loop:<div><pre class="programlisting">  // Restoring std::cin
  std::cin.ignore();
  std::cin.clear();

  std::string regex, str;
  do {
    std::cout &lt;&lt; "Input regex: ";
    if (!std::getline(std::cin, regex) || regex.empty()) {
      return 0;
    }

    // Without `boost::regex::no_except`flag this 
    // constructor may throw
    const boost::regex e(regex, flag);
    if (e.status()) {
      std::cout &lt;&lt; "Incorrect regex pattern!\n";
      continue;
    }</pre></div></li><li class="listitem">Getting a string to match in a loop:<div><pre class="programlisting">    std::cout &lt;&lt; "String to match: ";
    while (std::getline(std::cin, str) &amp;&amp; !str.empty()) {</pre></div></li><li class="listitem">Applying regex to it and <a id="id445" class="indexterm"/>outputting the result:<div><pre class="programlisting">      bool matched = boost::regex_match(str, e);
      std::cout &lt;&lt; (matched ? "MATCH\n" : "DOES NOT MATCH\n");
      std::cout &lt;&lt; "String to match: ";
    } // end of `while (std::getline(std::cin, str))`</pre></div></li><li class="listitem">Finishing our example by <a id="id446" class="indexterm"/>restoring <code class="literal">std::cin</code> and requesting new regex patterns:<div><pre class="programlisting">    // Restoring std::cin
    std::cin.ignore();
    std::cin.clear();
  } while (1);
} // int main()</pre></div><p>Now if we run the preceding example, we'll get the following output:</p><div><pre class="programlisting">Available regex syntaxes:
        [0] Perl
        [1] Perl case insensitive
        [2] POSIX extended
        [3] POSIX extended case insensitive
        [4] POSIX basic
        [5] POSIX basic case insensitive
Choose regex syntax: 0
Input regex: (\d{3}[#-]){2}
String to match: 123-123#
MATCH
String to match: 312-321-
MATCH
String to match: 21-123-
DOES NOT MATCH
String to match: ^Z
Input regex: \l{3,5}
String to match: qwe
MATCH
String to match: qwert
MATCH
String to match: qwerty
DOES NOT MATCH
String to match: QWE
DOES NOT MATCH
String to match: ^Z

Input regex: ^Z
Press any key to continue . . .</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec276"/>How it works...</h2></div></div></div><p>All this is done by the <code class="literal">boost::regex</code> class. <a id="id447" class="indexterm"/>It constructs an object that is capable of regex parsing and compilation. The <code class="literal">flags</code> variable adds additional configuration options.</p><p>If the regular expression is incorrect, it <a id="id448" class="indexterm"/>throws an exception; if the <a id="id449" class="indexterm"/>
<code class="literal">boost::regex::no_except</code> flag was passed, it reports an error returning as non-zero in the <code class="literal">status()</code> call (just like in our example):</p><div><pre class="programlisting">if (e.status()) {
  std::cout &lt;&lt; "Incorrect regex pattern!\n";
  continue;
}</pre></div><p>This will result in:</p><div><pre class="programlisting">Input regex: (incorrect regex(
Incorrect regex pattern!
Input regex:
</pre></div><p>Regular expression matching is done by a call to the <code class="literal">boost::regex_match</code> function. It returns <code class="literal">true</code> in case of a successful match. Additional flags may be passed to <code class="literal">regex_match</code>, but we avoided their usage for brevity of the example.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec277"/>There's more...</h2></div></div></div><p>C++11 contains almost all the <code class="literal">Boost.Regex</code> classes and flags. They can be found in the <code class="literal">&lt;regex&gt;</code> header of the <code class="literal">std::</code> namespace <a id="id450" class="indexterm"/> (instead of <code class="literal">boost::</code>). <a id="id451" class="indexterm"/>Official documentation provides information about the differences between C++11 and <code class="literal">Boost.Regex</code>. It also contains some performance measures that tell <code class="literal">Boost.Regex</code> is fast.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec278"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Searching and replacing strings using regular expressions</em> recipe will give you more information about <code class="literal">Boost.Regex</code> usage</li><li class="listitem" style="list-style-type: disc">You may also consider official documentation to get more information about flags, performance measures, regular expression syntaxes, and C++11 conformance at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Searching and replacing strings using regular expressions</h1></div></div></div><p>My wife enjoyed the <em>Matching strings using regular expressions</em> recipe very much and told me that I'll get no food until I improve<a id="id452" class="indexterm"/> it to be able to replace parts of the <a id="id453" class="indexterm"/>input string according to a regex match. <a id="id454" class="indexterm"/>Each matched subexpression (part of the regex in parenthesis) must get a unique number starting from 1; this number will be used to create a new string.</p><p>This is how an updated program will <a id="id455" class="indexterm"/>work like:</p><div><pre class="programlisting">Available regex syntaxes:
        [0] Perl
        [1] Perl case insensitive
        [2] POSIX extended
        [3] POSIX extended case insensitive
        [4] POSIX basic
        [5] POSIX basic case insensitive
Choose regex syntax: 0

Input regex: (\d)(\d)
String to match: 00
MATCH: 0, 0,
Replace pattern: \1#\2
RESULT: 0#0
String to match: 42
MATCH: 4, 2,
Replace pattern: ###\1-\1-\2-\1-\1###
RESULT: ###4-4-2-4-4###
…</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec279"/>Getting ready</h2></div></div></div><p>We'll be using the code <a id="id456" class="indexterm"/>from <a id="id457" class="indexterm"/>the <em>Matching strings using regular expressions</em> recipe. You should read it before getting your hands on this one.</p><p>Linking the example against the <code class="literal">libboost_regex</code> library is required.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec280"/>How to do it...</h2></div></div></div><p>This recipe is based <a id="id458" class="indexterm"/>on the code <a id="id459" class="indexterm"/>from the previous one. Let's see what must be changed.</p><div><ol class="orderedlist arabic"><li class="listitem">No additional headers will be included; however, we'll need an additional string to store the replace pattern:<div><pre class="programlisting">  std::string regex, str, replace_string;</pre></div></li><li class="listitem">We'll replace <code class="literal">boost::regex_match</code> with <code class="literal">boost::regex_find</code> and output matched results:<div><pre class="programlisting">  std::cout &lt;&lt; "String to match: ";
  while (std::getline(std::cin, str) &amp;&amp; !str.empty()) {
    boost::smatch results;
    bool matched = regex_search(str, results, e);
    if (matched) {
      std::cout &lt;&lt; "MATCH: ";
      std::copy(
        results.begin() + 1, 
        results.end(), 
        std::ostream_iterator&lt;std::string&gt;( std::cout, ", ")
      );</pre></div></li><li class="listitem">After that, we need to get the replace pattern and apply it:<div><pre class="programlisting">      std::cout &lt;&lt; "\nReplace pattern: ";
      if (std::getline(std::cin, replace_string) &amp;&amp; !replace_string.empty()) {
        std::cout &lt;&lt; "RESULT: " &lt;&lt; boost::regex_replace(str, e, replace_string); 
      } else {
        // Restoring std::cin
        std::cin.ignore();
        std::cin.clear();
      }
    } else { // `if (matched) `
      std::cout &lt;&lt; "DOES NOT MATCH";
    }</pre></div></li></ol></div><p>That's it! Everyone's <a id="id460" class="indexterm"/>happy and <a id="id461" class="indexterm"/>I'm fed.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec281"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::regex_search</code> <a id="id462" class="indexterm"/>function doesn't only return a true or a false (such as the <code class="literal">boost::regex_match</code> function does) value, but also stores matched parts. We output matched parts using the following construction:</p><div><pre class="programlisting">    std::copy(
      results.begin() + 1, 
      results.end(), 
      std::ostream_iterator&lt;std::string&gt;( std::cout, ", ")
    );</pre></div><p>Note that we outputted the results by skipping the first result (<code class="literal">results.begin() + 1</code>); that is because <code class="literal">results.begin()</code> contains the whole regex match.</p><p>The <code class="literal">boost::regex_replace</code> function <a id="id463" class="indexterm"/>does all the replacing and returns the modified string.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec282"/>There's more...</h2></div></div></div><p>There are different variants of the <code class="literal">regex_*</code> function; some of them receive bidirectional iterators instead of strings and some provide output to the iterator.</p><p><code class="literal">boost::smatch</code> is a <code class="literal">typedef</code> for <code class="literal">boost::match_results&lt;std::string::const_iterator&gt;</code>; so if you are using some other bidirectional iterators instead of <code class="literal">std::string::const_iterator</code>, you will need to use the type of your bidirectional iterators as a template parameter for <code class="literal">match_results</code>.</p><p><code class="literal">match_results</code> has a format <a id="id464" class="indexterm"/>function, so <a id="id465" class="indexterm"/>we can tune our example with it. Instead of:</p><div><pre class="programlisting">std::cout &lt;&lt; "RESULT: " &lt;&lt; boost::regex_replace(str, e, replace_string);</pre></div><p>We may use the following:</p><div><pre class="programlisting">std::cout &lt;&lt; "RESULT: " &lt;&lt; results.format(replace_string);</pre></div><p>By the way, <code class="literal">replace_string</code> may have different formats:</p><div><pre class="programlisting">Input regex: (\d)(\d)
String to match: 12
MATCH: 1, 2,
Replace pattern: $1-$2---$&amp;---$$
RESULT: 1-2---12---$</pre></div><p>All the classes and functions <a id="id466" class="indexterm"/>from this <a id="id467" class="indexterm"/>recipe exist in C++11, in the <code class="literal">std::</code> namespace of the <code class="literal">&lt;regex&gt;</code> header.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec283"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation on <code class="literal">Boost.Regex</code> will give you more examples and information about performance, C++11 standard compatibility, and regular expression syntax at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html</a>. The <em>Matching strings using regular expressions</em> recipe will tell you the basics of <code class="literal">Boost.Regex</code>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Formatting strings using safe printf-like functions</h1></div></div></div><p>The <code class="literal">printf</code> family of <a id="id468" class="indexterm"/>functions is a threat to security. It is a very bad design to allow users to put their own strings as a type and format the <a id="id469" class="indexterm"/>specifiers. So what do we do when user-defined format is required? How shall we implement the <code class="literal">std::string to_string(const std::string&amp; format_specifier) const;</code> member function of the following class?</p><div><pre class="programlisting">class i_hold_some_internals {
  int i;
  std::string s;
  char c;
  // ...
};</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec284"/>Getting ready</h2></div></div></div><p>Basic knowledge of STL is more than enough for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec285"/>How to do it...</h2></div></div></div><p>We wish to allow users to specify their own output format for a string.</p><div><ol class="orderedlist arabic"><li class="listitem">To do that in a safe manner, we'll need the following header:<div><pre class="programlisting">#include &lt;boost/format.hpp&gt;</pre></div></li><li class="listitem">Now we will add some comments for the user:<div><pre class="programlisting">  // fmt parameter must contain the following:
  //  $1$ for outputting integer 'i'
  //  $2$ for outputting string 's'
  //  $3$ for outputting character 'c'
  std::string 
    to_string(const std::string&amp; format_specifier) const {</pre></div></li><li class="listitem">Now it is time to make <a id="id470" class="indexterm"/>all of them work:<div><pre class="programlisting">    boost::format f(format_specifier);
    unsigned char flags = boost::io::all_error_bits;
    flags ^= boost::io::too_many_args_bit;
    f.exceptions(flags);
    return (f % i % s % c).str();
  }</pre></div><p>That's all. Take a look at this code:</p><div><pre class="programlisting">  i_hold_some_internals class_instance;

  std::cout &lt;&lt; class_instance.to_string(
    "Hello, dear %2%! "
    "Did you read the book for %1% %% %3%\n"
  );

  std::cout &lt;&lt; class_instance.to_string(
    "%1% == %1% &amp;&amp; %1%%% != %1%\n\n"
  );</pre></div><p>Imagine that <code class="literal">class_instance</code> has a member <code class="literal">i</code> equal to <code class="literal">100</code>, an <code class="literal">s</code> member equal to <code class="literal">"Reader"</code>, and a member <code class="literal">c</code> equal to <code class="literal">'!'</code>. Then, the program will output the following:</p><div><pre class="programlisting">Hello, dear Reader! Did you read the book for 100 % !
100 == 100 &amp;&amp; 100% != 100</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec286"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::format</code> class <a id="id471" class="indexterm"/>accepts the string that specifies the resulting string. Arguments are passed to <code class="literal">boost::format</code> using <code class="literal">operator%</code>. Values <code class="literal">%1%</code>, <code class="literal">%2%</code>, <code class="literal">%3%</code>, <code class="literal">%4%</code>, and so on, in the format specifying <a id="id472" class="indexterm"/>string, will be replaced by arguments passed to <code class="literal">boost::format</code>.</p><p>We disable the exceptions for cases when a format string contains fewer arguments than passed to <code class="literal">boost::format</code>:</p><div><pre class="programlisting">  boost::format f(format_specifier);
  unsigned char flags = boost::io::all_error_bits;
  flags ^= boost::io::too_many_args_bit;</pre></div><p>This is done to allow some <a id="id473" class="indexterm"/>formats like this:</p><div><pre class="programlisting">  // Outputs 'Reader'
  std::cout &lt;&lt; class_instance.to_string("%2%\n\n");</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec287"/>There's more...</h2></div></div></div><p>And what will happen in case of an incorrect format?</p><div><pre class="programlisting">  try {
    class_instance.to_string("%1% %2% %3% %4% %5%\n");
    assert(false);
  } catch (const std::exception&amp; e) {
    // boost::io::too_few_args exception must be caught
    std::cout &lt;&lt; e.what() &lt;&lt; '\n';
  }</pre></div><p>Well, in that case, no assertion will be triggered and the following lines will be outputted to the console:</p><div><pre class="programlisting">boost::too_few_args: format-string referred to more arguments than were passed</pre></div><p>C++11 has no <code class="literal">std::format</code>. The <code class="literal">Boost.Format</code> library is not a very fast library; try not to use it much in performance critical sections.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec288"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation contains <a id="id474" class="indexterm"/>more information about the performance of the <code class="literal">Boost.Format</code> library. More examples and documentation on extended printf-like format is available at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/format/">http://www.boost.org/doc/libs/1_53_0/libs/format/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Replacing and erasing strings</h1></div></div></div><p>Situations where we need to <a id="id475" class="indexterm"/>erase something in a string, replace a part of the string, or erase the first or last occurrence of some substring are very common. STL allows us to do most <a id="id476" class="indexterm"/>of this, but it usually involves writing too much code.</p><p>We saw the <code class="literal">Boost.StringAlgorithm</code> library in action in the <em>Changing cases and case-insensitive comparison</em> recipe. Let's see how it can be used to simplify our lives when we need to modify some strings:</p><div><pre class="programlisting">#include &lt;string&gt;
const std::string str = "Hello, hello, dear Reader.";</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec289"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is required for this example.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec290"/>How to do it...</h2></div></div></div><p>This recipe shows how different string-erasing and replacing methods from the <code class="literal">Boost.StringAlgorithm</code> library <a id="id477" class="indexterm"/>work.</p><p>Erasing requires the <code class="literal">#include &lt;boost/algorithm/string/erase.hpp&gt;</code> header:</p><div><pre class="programlisting">namespace ba = boost::algorithm;
std::cout &lt;&lt; "\n erase_all_copy   :" &lt;&lt; ba::erase_all_copy(str, ",");
std::cout &lt;&lt; "\n erase_first_copy :" &lt;&lt; ba::erase_first_copy(str, ",");
std::cout &lt;&lt; "\n erase_last_copy  :" &lt;&lt; ba::erase_last_copy(str, ",");
std::cout &lt;&lt; "\n ierase_all_copy  :" &lt;&lt; ba::ierase_all_copy(str, "hello");
std::cout &lt;&lt; "\n ierase_nth_copy  :" &lt;&lt; ba::ierase_nth_copy(str, ",", 1);</pre></div><p>This code will output the following:</p><div><pre class="programlisting">erase_all_copy     :Hello hello dear Reader.
erase_first_copy   :Hello hello, dear Reader.
erase_last_copy    :Hello, hello dear Reader.
ierase_all_copy    :, , dear Reader.
ierase_nth_copy    :Hello, hello dear Reader.</pre></div><p>Replacing requires the <code class="literal">&lt;boost/algorithm/string/replace.hpp&gt;</code> header:</p><div><pre class="programlisting">namespace ba = boost::algorithm;

std::cout &lt;&lt; "\n replace_all_copy  :" &lt;&lt; ba::replace_all_copy(str, ",", "!");
std::cout &lt;&lt; "\n replace_first_copy  :" &lt;&lt; ba::replace_first_copy(str, ",", "!");
std::cout &lt;&lt; "\n replace_head_copy  :" &lt;&lt; ba::replace_head_copy(str, 6, "Whaaaaaaa!");</pre></div><p>This code will output the following:</p><div><pre class="programlisting">replace_all_copy    :Hello! hello! dear Reader.
replace_first_copy  :Hello! hello, dear Reader.
replace_head_copy   :Whaaaaaaa! hello, dear Reader.</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec291"/>How it works...</h2></div></div></div><p>All the examples are self-documenting. The only one that is not obvious is the <code class="literal">replace_head_copy</code> function. It <a id="id478" class="indexterm"/>accepts a number of bytes to replace as a second parameter and a replace string as the third <a id="id479" class="indexterm"/>parameter. So, in the preceding example, <code class="literal">Hello</code> gets replaced with <code class="literal">Whaaaaaaa!</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec292"/>There's more...</h2></div></div></div><p>There are also methods that modify <a id="id480" class="indexterm"/>strings in-place. They don't just end on <code class="literal">_copy</code> and return <code class="literal">void</code>. All the case insensitive methods (the ones that start with <code class="literal">i</code>) accept <code class="literal">std::locale</code> as the last parameter, and use a default constructed locale as a default parameter.</p><p>C++11 does not have <code class="literal">Boost.StringAlgorithm</code> methods and classes.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec293"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation contains a lot of examples and a full reference on all the methods at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html">http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html</a></li><li class="listitem" style="list-style-type: disc">See the <em>Changing cases and case-insensitive comparison</em> recipe from this chapter for more information about the <code class="literal">Boost.StringAlgorithm</code> library.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Representing a string with two iterators</h1></div></div></div><p>There are situations <a id="id481" class="indexterm"/>when we need to split some strings into substrings and do something with those substrings. For example, count whitespaces in the string and, of course, we want to use Boost and be as efficient as possible.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec294"/>Getting ready</h2></div></div></div><p>You'll need some basic knowledge of STL algorithms for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec295"/>How to do it...</h2></div></div></div><p>We won't be counting whitespaces; instead we'll split the string into sentences. You'll see that it is very easy with Boost.</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, include the right headers:<div><pre class="programlisting">#include &lt;boost/algorithm/string/split.hpp&gt;
#include &lt;boost/algorithm/string/classification.hpp&gt;
#include &lt;algorithm&gt;</pre></div></li><li class="listitem">Now let's define our test string:<div><pre class="programlisting">int main() {
  const char str[] 
    = "This is a long long character array."
      "Please split this character array to sentences!"
      "Do you know, that sentences are separated using period, "
      "exclamation mark and question mark? :-)"
  ; </pre></div></li><li class="listitem">Now we make <a id="id482" class="indexterm"/>a <code class="literal">typedef</code> for our splitting iterator:<div><pre class="programlisting">typedef boost::split_iterator&lt;const char*&gt; split_iter_t;</pre></div></li><li class="listitem">Construct that iterator:<div><pre class="programlisting">  split_iter_t sentences = boost::make_split_iterator(str, 
    boost::algorithm::token_finder(boost::is_any_of("?!."))
  );  </pre></div></li><li class="listitem">Now we can iterate between matches:<div><pre class="programlisting">  for (unsigned int i = 1; !sentences.eof(); ++sentences, ++i) {
    boost::iterator_range&lt;const char*&gt; range = *sentences;
    std::cout &lt;&lt; "Sentence #" &lt;&lt; i &lt;&lt; " : \t" &lt;&lt; range &lt;&lt; '\n';</pre></div></li><li class="listitem">Count the number of characters:<div><pre class="programlisting">    std::cout &lt;&lt; "Sentence has " &lt;&lt; range.size() &lt;&lt; " characters.\n";</pre></div></li><li class="listitem">And count the whitespaces:<div><pre class="programlisting">    std::cout 
      &lt;&lt; "Sentence has " 
      &lt;&lt; std::count(range.begin(), range.end(), ' ') 
      &lt;&lt; " whitespaces.\n\n";
  } // end of for(...) loop
} // end of main()</pre></div><p>That's it. Now if we run this example, it will output:</p><div><pre class="programlisting">Sentence #1 :   This is a long long character array
Sentence has 35 characters.
Sentence has 6 whitespaces.

Sentence #2 :   Please split this character array to sentences
Sentence has 46 characters.
Sentence has 6 whitespaces.

Sentence #3 :   Do you know, that sentences are separated using dot,
exclamation mark and question mark
Sentence has 87 characters.
Sentence has 13 whitespaces.

Sentence #4 :    :-)
Sentence has 4 characters.
Sentence has 1 whitespaces.</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec296"/>How it works...</h2></div></div></div><p>The main idea of this recipe is that we do not need to construct <code class="literal">std::string</code> from substrings. We even do not need to <a id="id483" class="indexterm"/>tokenize the whole string at once. All we need to do is find the first substring and return it as a pair of iterators to the beginning and to the end of substring. If we need more substrings, find the next substring and return a pair of iterators for that substring.</p><div><img src="img/4880OS_07_02.jpg" alt="How it works..."/></div><p>Now let's take a closer look at <code class="literal">boost::split_iterator</code>. We constructed one using the <code class="literal">boost::make_split_iterator</code> <a id="id484" class="indexterm"/>function that takes <code class="literal">range</code> as the first argument and a binary finder predicate (or binary predicate) as the second. When <code class="literal">split_iterator</code> is dereferenced, it returns the first <a id="id485" class="indexterm"/>substring as <code class="literal">boost::iterator_range&lt;const char*&gt;</code>, which just holds a pair of iterators and has a few methods to work with them. When we increment <code class="literal">split_iterator</code>, it will try to find the next substring, and if there is no substring found, <code class="literal">split_iterator::eof()</code> will return <code class="literal">true</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec297"/>There's more...</h2></div></div></div><p>The <code class="literal">boost::iterator_range</code> <a id="id486" class="indexterm"/>class is widely used across all the Boost libraries. You may find it useful for your own code and libraries in situations where a pair of iterators must be returned or where a function should accept/work with a pair of iterators.</p><p>The <code class="literal">boost::split_iterator&lt;&gt;</code> and <code class="literal">boost::iterator_range&lt;&gt;</code> classes accept a forward iterator type as a template parameter. Because we were working with a character array in the preceding example, we provided <code class="literal">const char*</code> as iterators. If we were working with <code class="literal">std::wstring</code>, we would need to use the <code class="literal">boost::split_iterator&lt;std::wstring::const_iterator&gt;</code> and <code class="literal">boost::iterator_range&lt;std::wstring::const_iterator&gt;</code> types.</p><p>C++11 has neither <code class="literal">iterator_range</code> nor <code class="literal">split_iterator</code>.</p><p>As the <code class="literal">boost::iterator_range</code> class <a id="id487" class="indexterm"/>has no virtual functions and no dynamic memory allocations, it is fast and efficient. However, its output stream operator <code class="literal">&lt;&lt;</code> has no specific optimizations for character arrays, so streaming it is slow.</p><p>The <code class="literal">boost::split_iterator</code> class <a id="id488" class="indexterm"/>has a <code class="literal">boost::function</code> class in it, so constructing it may be slow; however, iterating adds <a id="id489" class="indexterm"/>only a tiny overhead that you won't notice even in performance critical sections.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec298"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipe will tell you about a nice replacement for <code class="literal">boost::iterator_range&lt;const char*&gt;</code>.</li><li class="listitem" style="list-style-type: disc">The official documentation for <code class="literal">Boost.StringAlgorithm</code> will provide you with more detailed information about classes and a whole bunch of examples at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html">http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html</a>.</li><li class="listitem" style="list-style-type: disc">More information about <a id="id490" class="indexterm"/><code class="literal">boost::iterator_range</code> can be found here: <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html">http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html</a>. It is a part of the <code class="literal">Boost.Range</code> library that is not described in this book, but you may wish to study it by yourself.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Using a reference to string type</h1></div></div></div><p>This recipe is the most important <a id="id491" class="indexterm"/>recipe in this chapter! Let's take a look at a very common case, where we write a function that accepts a string and returns the part of the string between character values passed in the <code class="literal">starts</code> and <code class="literal">ends</code> arguments:</p><div><pre class="programlisting">#include &lt;string&gt;
#include &lt;algorithm&gt;

std::string between_str(const std::string&amp; input, char starts,
   char ends)
{
  std::string::const_iterator pos_beg 
    = std::find(input.begin(), input.end(), starts);

  if (pos_beg == input.end()) {
    return std::string(); // Empty
  }

  ++ pos_beg;
  std::string::const_iterator pos_end 
    = std::find(input.begin(), input.end(), ends);

  return std::string(pos_beg, pos_end);
}</pre></div><p>Do you like this implementation? In my opinion, it looks awful; consider the following call to it:</p><div><pre class="programlisting">between_str("Getting expression (between brackets)", '(', ')');</pre></div><p>In this example, a temporary <code class="literal">std::string</code> variable will be constructed from <code class="literal">"Getting expression (between brackets)"</code>. The character array is long enough, so there is a big chance that dynamic memory allocation will be called inside the <code class="literal">std::string</code> constructor and the character array will be copied into it. Then, somewhere inside the <code class="literal">between_str</code> function, new <code class="literal">std::string</code> will be constructed, which may also lead to another dynamic memory allocation and result in copying.</p><p>So, this simple function may, and in most cases will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call dynamic memory <a id="id492" class="indexterm"/>allocation (twice)</li><li class="listitem" style="list-style-type: disc">Copy string (twice)</li><li class="listitem" style="list-style-type: disc">Deallocate memory (twice)</li></ul></div><p>Can we do better?</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec299"/>Getting ready</h2></div></div></div><p>This recipe requires basic knowledge of STL and C++.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec300"/>How to do it...</h2></div></div></div><p>We do not really need a <a id="id493" class="indexterm"/>
<code class="literal">std::string</code> class here, we only need some pointer to the character array and the array's size. Boost has the <code class="literal">std::string_ref</code> class.</p><div><ol class="orderedlist arabic"><li class="listitem">To use the <code class="literal">boost::string_ref</code> class, include the following header:<div><pre class="programlisting">#include &lt;boost/utility/string_ref.hpp&gt;</pre></div></li><li class="listitem">Change the method's signature:<div><pre class="programlisting">boost::string_ref between(
  const boost::string_ref&amp; input, 
  char starts, 
  char ends) </pre></div></li><li class="listitem">Change <code class="literal">std::string</code> to <code class="literal">boost::string_ref:</code> everywhere inside the function body:<div><pre class="programlisting">{
  boost::string_ref::const_iterator pos_beg 
    = std::find(input.cbegin(), input.cend(), starts);
  if (pos_beg == input.cend()) {
    return boost::string_ref(); // Empty
  }
  ++ pos_beg;
  boost::string_ref::const_iterator pos_end 
    = std::find(input.cbegin(), input.cend(), ends);
  // ...</pre></div></li><li class="listitem">The <code class="literal">boost::string_ref</code> <a id="id494" class="indexterm"/>constructor accepts size as a second parameter, so we need to slightly change the code:<div><pre class="programlisting">  if (pos_end == input.cend()) {
    return boost::string_ref(pos_beg, input.end() - pos_beg);
  }
  return boost::string_ref(pos_beg, pos_end - pos_beg);
}</pre></div><p>That's it! Now we may call <code class="literal">between("Getting expression (between brackets)", '(', ')')</code> and it will work without any dynamic memory allocation and characters copying. And we can still use it for <code class="literal">std::string</code>:</p><div><pre class="programlisting">between(std::string("(expression)"), '(', ')')</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec301"/>How it works...</h2></div></div></div><p>As already mentioned, <code class="literal">boost::string_ref</code> contains only a pointer to the character array and size of data. It has a lot of <a id="id495" class="indexterm"/>constructors and may be initialized in different ways:</p><div><pre class="programlisting">  boost::string_ref r0("^_^");

  std::string O_O("O__O");
  boost::string_ref r1 = O_O;

  std::vector&lt;char&gt; chars_vec(10, '#');
  boost::string_ref r2(&amp;chars_vec.front(), chars_vec.size());</pre></div><p>The <code class="literal">boost::string_ref</code> <a id="id496" class="indexterm"/>class has all the methods required by the container class, so it is usable with STL algorithms and Boost algorithms:</p><div><pre class="programlisting">#include &lt;boost/algorithm/string/case_conv.hpp&gt;
#include &lt;boost/algorithm/string/replace.hpp&gt;
#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;iterator&gt;

void string_ref_algorithms_examples() {
  boost::string_ref r("O_O");
  // Finding symbol
  std::find(r.cbegin(), r.cend(), '_');

  // Will print 'o_o'
  boost::to_lower_copy(std::ostream_iterator&lt;char&gt;(std::cout), r);
  std::cout &lt;&lt; '\n';

  // Will print 'O_O'
  std::cout &lt;&lt; r &lt;&lt; '\n';

  // Will print '^_^'
  boost::replace_all_copy(
    std::ostream_iterator&lt;char&gt;(std::cout), r, "O", "^"
  );
}</pre></div><div><div><h3 class="title"><a id="note29"/>Note</h3><p>The <code class="literal">boost::string_ref</code> <a id="id497" class="indexterm"/>class does not really own string, so all its methods return constant iterators. Because of that, we cannot use it in methods that modify data, such as <code class="literal">boost::to_lower(r)</code>.</p></div></div><p>While working with <code class="literal">boost::string_ref</code>, we should take additional care about data that it refers to; it must exist and be valid for the <a id="id498" class="indexterm"/>whole lifetime of <code class="literal">boost::string_ref</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec302"/>There's more...</h2></div></div></div><p>The <code class="literal">boost::string_ref</code> class is not a part of C++11, but it is proposed for inclusion in the next standard.</p><p>The <code class="literal">string_ref</code> classes are fast and efficient; use them wherever it is possible.</p><p>The <code class="literal">boost::string_ref</code> class is actually a typedef in the <code class="literal">boost::</code> namespace:</p><div><pre class="programlisting">typedef basic_string_ref&lt;char, std::char_traits&lt;char&gt; &gt;
   string_ref;</pre></div><p>You may also find useful the following typedefs for wide characters in the <code class="literal">boost::</code> namespace:</p><div><pre class="programlisting">typedef basic_string_ref&lt;wchar_t,  std::char_traits&lt;wchar_t&gt; &gt; 
   wstring_ref;

typedef basic_string_ref&lt;char16_t, std::char_traits&lt;char16_t&gt; &gt; 
   u16string_ref;

typedef basic_string_ref&lt;char32_t, std::char_traits&lt;char32_t&gt; &gt; 
   u32string_ref;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec303"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official <code class="literal">string_ref</code> proposal for inclusion in C++ standard can be found at <a class="ulink" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html</a></li><li class="listitem" style="list-style-type: disc">Boost documentation for <a id="id499" class="indexterm"/><code class="literal">string_ref</code> could be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html">http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html</a></li></ul></div></div></div></body></html>