- en: Chapter 9. Templates and Commonly Used Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。模板和常用容器
- en: In [Chapter 7](part0051_split_000.html#1GKCM1-dd4a3f777fc247568443d5ffb917736d
    "Chapter 7. Dynamic Memory Allocation"), *Dynamic Memory Allocation*, we spoke
    about how you will use dynamic memory allocation if you want to create a new array
    whose size isn't known at compile time. Dynamic memory allocations are of the
    form `int * array = new int[ number_of_elements ]`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](part0051_split_000.html#1GKCM1-dd4a3f777fc247568443d5ffb917736d "第
    7 章。动态内存分配")，*动态内存分配*中，我们讨论了如果你想要创建一个在编译时大小未知的数组时，如何使用动态内存分配。动态内存分配的形式为 `int *
    array = new int[ number_of_elements ]`。
- en: You also saw that dynamic allocations using the `new[]` keyword require you
    to call `delete[]` on the array later, otherwise you'd have a memory leak. Having
    to manage memory this way is hard work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到，使用 `new[]` 关键字进行动态分配需要你在稍后对数组调用 `delete[]`，否则你会有一个内存泄漏。必须以这种方式管理内存是件辛苦的工作。
- en: Is there a way to create an array of dynamic size and have the memory automatically
    managed for you by C++? The answer is yes. There are C++ object types (commonly
    called containers) that handle dynamic memory allocations and deallocations automatically.
    UE4 provides a couple of container types to store your data in dynamically resizable
    collections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种方法可以创建一个动态大小的数组，并且由 C++ 自动为你管理内存？答案是肯定的。C++ 有一些对象类型（通常称为容器），可以自动处理动态内存的分配和释放。UE4
    提供了几种容器类型，用于在动态可调整大小的集合中存储你的数据。
- en: There are two different groups of template containers. There is the UE4 family
    of containers (beginning with `T*`) and the C++ **Standard Template Library**
    (**STL**) family of containers. There are some differences between the UE4 containers
    and the C++ STL containers, but the differences are not major. UE4 containers
    sets are written with game performance in mind. C++ STL containers also perform
    well, and their interfaces are a little more consistent (consistency in an API
    is something that you'd prefer). Which container set you use is up to you. However,
    it is recommended that you use the UE4 container set since it guarantees that
    you won't have cross-platform issues when you try to compile your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种不同的模板容器组。有 UE4 容器家族（以 `T*` 开头）和 C++ **标准模板库**（**STL**）容器家族。UE4 容器和 C++ STL
    容器之间有一些差异，但这些差异并不大。UE4 容器集合的设计考虑了游戏性能。C++ STL 容器也表现良好，它们的接口稍微一致一些（API 的一致性是你更愿意看到的）。你使用哪个容器集合取决于你。然而，建议你使用
    UE4 容器集合，因为它保证当你尝试编译代码时，不会出现跨平台问题。
- en: Debugging the output in UE4
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4 中的调试输出
- en: All of the code in this chapter (as well as in the later chapters) will require
    you to work in a UE4 project. For the purpose of testing `TArray`, I created a
    basic code project called `TArrays`. In the `ATArraysGameMode::ATArraysGameMode`
    constructor, I am using the debug output feature to print text to the console.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章（以及后续章节）中的所有代码都需要你在 UE4 项目中工作。为了测试 `TArray`，我创建了一个基本的代码项目，名为 `TArrays`。在 `ATArraysGameMode::ATArraysGameMode`
    构造函数中，我正在使用调试输出功能将文本打印到控制台。
- en: 'Here''s how the code will look:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的样式：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you compile and run this project, you will see the debug text in the top-left
    corner of your game window when you start the game. You can use a debug output
    to see the internals of your program at any time. Just make sure that the `GEngine`
    object exists at the time of debugging the output. The output of the preceding
    code is shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行此项目，当你开始游戏时，你将在游戏窗口的左上角看到调试文本。你可以使用调试输出在任何时候查看程序的内部结构。只需确保在调试输出时 `GEngine`
    对象存在。前面代码的输出如下所示：
- en: '![Debugging the output in UE4](img/00133.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![UE4 中的调试输出](img/00133.jpeg)'
- en: UE4's TArray<T>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4 的 `TArray<T>`
- en: TArrays are UE4's version of a dynamic array. To understand what a `TArray<T>`
    variable is, you first have to know what the `<T>` option between angle brackets
    stands for. The `<T>` option means that the type of data stored in the array is
    a variable. Do you want an array of `int`? Then create a `TArray<int>` variable.
    A `TArray` variable of `double`? Create a `TArray<double>` variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`TArrays` 是 UE4 的动态数组版本。要了解 `TArray<T>` 变量的含义，你首先必须知道尖括号 `<T>` 选项代表什么。《T>`
    选项意味着数组中存储的数据类型是变量。你想要一个 `int` 类型的数组吗？那么创建一个 `TArray<int>` 变量。一个 `double` 类型的
    `TArray` 变量？创建一个 `TArray<double>` 变量。'
- en: So, in general, wherever a `<T>` appears, you can plug in a C++ type of your
    choice. Let's move on and show this with an example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，一般来说，无论哪里出现`<T>`，你都可以插入你选择的C++类型。让我们继续，并通过示例来展示这一点。
- en: An example that uses TArray<T>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TArray<T>的示例
- en: A `TArray<int>` variable is just an array of `int`. A `TArray<Player*>` variable
    will be an array of `Player*` pointers. An array is dynamically resizable, and
    elements can be added at the end of the array after its creation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`TArray<int>`变量只是一个`int`类型的数组。`TArray<Player*>`变量将是一个`Player*`指针的数组。数组是动态可调整大小的，并且可以在创建后向数组的末尾添加元素。'
- en: 'To create a `TArray<int>` variable, all you have to do is use the normal variable
    allocation syntax:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`TArray<int>`变量，你只需要使用正常的变量分配语法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Changes to the `TArray` variable are done using member functions. There are
    a couple of member functions that you can use on a `TArray` variable. The first
    member function that you need to know about is the way you add a value to the
    array, as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用成员函数对`TArray`变量进行更改。有一些成员函数可以在`TArray`变量上使用。你需要了解的第一个成员函数是向数组添加值的方式，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These four lines of code will produce the array value in memory, as shown in
    the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行代码将在内存中产生数组值，如下面的图所示：
- en: '![An example that uses TArray<T>](img/00134.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用TArray<T>的示例](img/00134.jpeg)'
- en: When you call `array.Add( number )`, the new number goes to the end of the array.
    Since we added the numbers **1**, **10**, **5**, and **20** to the array, in this
    order, that is the order in which they will go into the array.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`array.Add(number)`时，新数字会添加到数组的末尾。由于我们按照顺序将数字**1**、**10**、**5**和**20**添加到数组中，这就是它们将进入数组中的顺序。
- en: 'If you want to insert a number in the front or middle of the array, it is also
    possible. All you have to do is use the `array.Insert(value, index)` function,
    as shown in the following line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的开头或中间插入一个数字，这也是可能的。你只需要使用`array.Insert(value, index)`函数，如下面的代码行所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function will push the number **9** into the position **0** of the array
    (at the front). This means that the rest of the array elements will be offset
    to the right, as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将数字**9**推入数组的**0**位置（即前面）。这意味着数组中的其余元素将向右偏移，如下面的图所示：
- en: '![An example that uses TArray<T>](img/00135.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用TArray<T>的示例](img/00135.jpeg)'
- en: 'We can insert another element into position **2** of the array using the following
    line of code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码行将另一个元素插入到数组的**2**位置：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function will rearrange the array as shown in the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将数组重新排列，如下面的图所示：
- en: '![An example that uses TArray<T>](img/00136.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用TArray<T>的示例](img/00136.jpeg)'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you insert a number into a position in the array that is out of bounds, UE4
    will crash. So be careful not to do that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个数字插入到数组中超出边界的位置，UE4将会崩溃。所以请小心，不要这样做。
- en: Iterating a TArray
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历TArray
- en: 'You can iterate (walk over) the elements of a `TArray` variable in two ways:
    either using integer-based indexing or using an iterator. I will show you both
    the ways here.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种方式遍历（遍历）`TArray`变量的元素：要么使用基于整数的索引，要么使用迭代器。我将在下面展示这两种方法。
- en: The vanilla for loop and square brackets notation
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 普通for循环和方括号表示法
- en: 'Using integers to index the elements of an array is sometimes called a "vanilla"
    `for` loop. The elements of the array can be accessed using `array[ index ]`,
    where `index` is the numerical position of the element in the array:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数来索引数组元素有时被称为“普通”的`for`循环。可以使用`array[index]`来访问数组元素，其中`index`是元素在数组中的数值位置：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Iterators
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'You can also use an iterator to walk over the elements of the array one by
    one, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用迭代器逐个遍历数组的元素，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Iterators are pointers into the array. Iterators can be used to inspect or
    change values inside the array. An example of an iterator is shown in the following
    figure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是数组的指针。迭代器可以用来检查或更改数组内的值。以下图示了一个迭代器的示例：
- en: '![Iterators](img/00137.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![迭代器](img/00137.jpeg)'
- en: 'The concept of an iterator: it is an external object that can look into and
    inspect the values of an array. Doing ++ it moves the iterator to examine the
    next element.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的概念：它是一个外部对象，可以查看并检查数组的值。执行++操作将迭代器移动到检查下一个元素。
- en: An iterator must be suitable for the collection it is walking through. To walk
    through a `TArray<int>` variable, you need a `TArray<int>::TIterator` type iterator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器必须适合它正在遍历的集合。要遍历 `TArray<int>` 变量，你需要一个 `TArray<int>::TIterator` 类型的迭代器。
- en: We use `*` to look at the value behind an iterator. In the preceding code, we
    used `(*it)` to get the integer value from the iterator. This is called dereferencing.
    To dereference an iterator means to look at its value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `*` 来查看迭代器后面的值。在上面的代码中，我们使用 `(*it)` 从迭代器中获取整数值。这被称为解引用。解引用迭代器意味着查看其值。
- en: The `++it` operation that happens at the end of each iteration of the `for`
    loop increments the iterator, moving it on to point to the next element in the
    list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环的每次迭代结束时发生的 `++it` 操作会增加迭代器，将其移动到列表中的下一个元素。
- en: 'Insert the code into the program and try it out now. Here''s the example program
    we have created so far using `TArray` (all in the `ATArraysGameMode::ATArraysGameMode()`
    constructor):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码插入程序并尝试运行。以下是到目前为止我们创建的示例程序，使用 `TArray`（所有内容都在 `ATArraysGameMode::ATArraysGameMode()`
    构造函数中）：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code is shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '![Iterators](img/00138.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![迭代器](img/00138.jpeg)'
- en: Finding whether an element is in the TArray
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 TArray 中查找元素是否存在
- en: 'Searching out UE4 containers is easy. It is commonly done using the `Find`
    member function. Using the array we created previously, we can find the index
    of the value `10` by typing the following line of code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE4 中搜索容器非常简单。通常使用 `Find` 成员函数来完成。使用我们之前创建的数组，我们可以通过以下代码行找到值 `10` 的索引：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: TSet<T>
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSet<T>
- en: A `TSet<int>` variable stores a set of integers. A `TSet<FString>` variable.
    stores a set of strings. The main difference between `TSet` and `TArray` is that
    `TSet` does not allow duplicates—all the elements inside a `TSet` are guaranteed
    to be unique. A `TArray` variable does not mind duplicates of the same elements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSet<int>` 变量存储一组整数。`TSet<FString>` 变量存储一组字符串。`TSet` 和 `TArray` 之间的主要区别在于
    `TSet` 不允许重复——`TSet` 内部的所有元素都保证是唯一的。`TArray` 变量不介意相同元素的重复。'
- en: 'To add numbers to `TSet`, simply call `Add`. Take an example of the following
    declaration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 `TSet` 添加数字，只需调用 `Add`。以下是一个示例声明：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is how `TSet` will look, as shown in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `TSet` 在以下图中的样子：
- en: '![TSet<T>](img/00139.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![TSet<T>](img/00139.jpeg)'
- en: 'Duplicate entries of the same value in the `TSet` will not be allowed. Notice
    how the entries in a `TSet` aren''t numbered, as they were in a `TArray`: you
    can''t use square brackets to access an entry in `TSet` arrays.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSet` 中不允许有相同值的重复条目。注意 `TSet` 中的条目没有编号，就像在 `TArray` 中那样：你无法使用方括号来访问 `TSet`
    数组中的条目。'
- en: Iterating a TSet
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历 TSet
- en: 'In order to look into a `TSet` array, you must use an iterator. You can''t
    use square brackets notation to access the elements of a `TSet`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看 `TSet` 数组，你必须使用迭代器。你不能使用方括号表示法来访问 `TSet` 的元素：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Intersecting TSet
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交集 TSet
- en: 'The `TSet`array has two special functions that the `TArray` variable does not.
    The intersection of two `TSet` arrays is basically the elements they have in common.
    If we have two `TSet` arrays such as `X` and `Y` and we intersect them, the result
    will be a third, new `TSet` array that contains only the elements common between
    them. Look at the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSet` 数组有两个特殊函数，而 `TArray` 变量没有。两个 `TSet` 数组的交集基本上是它们共有的元素。如果我们有两个 `TSet`
    数组，如 `X` 和 `Y`，并且我们将它们相交，结果将是一个新的第三个 `TSet` 数组，它只包含它们共有的元素。查看以下示例：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The common elements between `X` and `Y` will then just be the element `2`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`X` 和 `Y` 之间的公共元素将是元素 `2`。'
- en: Unioning TSet
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并集 TSet
- en: Mathematically, the union of two sets is when you basically insert all the elements
    into the same set. Since we are talking about sets here, there won't be any duplicates.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，两个集合的并集就是将所有元素插入到同一个集合中。由于我们在这里讨论的是集合，所以不会有任何重复。
- en: 'If we take the `X` and `Y` sets from the previous example and create a union,
    we will get a new set, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从上一个示例中的 `X` 和 `Y` 集合创建一个并集，我们将得到一个新的集合，如下所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finding TSet
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找 TSet
- en: You can determine whether an element is inside a `TSet` or not by using the
    `Find()` member function on the set. The `TSet` will return a pointer to the entry
    in the `TSet` that matches your query if the element exists in the `TSet`, or
    it will return `NULL` if the element you're asking for does not exist in the `TSet`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在集合上使用 `Find()` 成员函数来确定一个元素是否在 `TSet` 中。如果元素存在于 `TSet` 中，`TSet` 将返回匹配查询的
    `TSet` 中的条目指针；如果请求的元素不存在于 `TSet` 中，它将返回 `NULL`。
- en: TMap<T, S>
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TMap<T, S>
- en: A `TMap<T, S>` creates a table of sorts in the RAM. A `TMap` represents a mapping
    of the keys at the left to the values on the right-hand side. You can visualize
    a `TMap` as a two-column table, with keys in the left column and values in the
    right column.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`TMap<T, S>` 创建了一种在 RAM 中的表格。`TMap` 表示将左侧的键映射到右侧的值。你可以将 `TMap` 视为一个两列的表格，其中键位于左侧列，值位于右侧列。'
- en: A list of items for the player's inventory
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家物品清单
- en: For example, say we wanted to create a C++ data structure in order to store
    a list of items for the player's inventory. On the left-hand side of the table
    (the keys), we'd have an `FString` for the item's name. On the right-hand side
    (the values), we'd have an `int` for the quantity of that item.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要创建一个 C++ 数据结构来存储玩家的物品清单。在表格的左侧（键），我们会有一个 `FString` 用于物品的名称。在右侧（值），我们会有一个
    `int` 用于该物品的数量。
- en: '| Item (Key) | Quantity (Value) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 项目（键） | 数量（值） |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| apples | 4 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 苹果 | 4 |'
- en: '| donuts | 12 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 饼干 | 12 |'
- en: '| swords | 1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 剑 | 1 |'
- en: '| shields | 2 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 防护盾 | 2 |'
- en: 'To do this in code, we''d simply use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中实现这一点，我们只需使用以下代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once you have created your `TMap`, you can access values inside the `TMap` using
    square brackets and by passing a key between the brackets. For example, in the
    `items` map in the preceding code, `items[ "apples" ]` is 4.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的 `TMap`，你可以通过使用方括号并传递一个键到括号之间来访问 `TMap` 内的值。例如，在上面的代码中的 `items` 映射中，`items[
    "apples" ]` 的值是 4。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: UE4 will crash if you use square brackets to access a key that doesn't exist
    in the map yet, so be careful! The C++ STL does not crash if you do this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用方括号访问映射中尚不存在的键，UE4 将会崩溃，所以请小心！C++ STL 在这样做时不会崩溃。
- en: Iterating a TMap
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代 TMap
- en: 'In order to iterate a `TMap`, you use an iterator as well:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了迭代 `TMap`，你也需要使用迭代器：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`TMap` iterators are slightly different from `TArray` or `TSet` iterators.
    A `TMap` iterator contains both a `Key` and a `Value`. We can access the key inside
    with `it->Key` and the value inside the `TMap` with `it->Value`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`TMap` 迭代器与 `TArray` 或 `TSet` 迭代器略有不同。`TMap` 迭代器包含一个 `Key` 和一个 `Value`。我们可以使用
    `it->Key` 访问内部的键，以及使用 `it->Value` 访问 `TMap` 内部的值。'
- en: '![Iterating a TMap](img/00140.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![迭代 TMap](img/00140.jpeg)'
- en: C++ STL versions of commonly used containers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用容器的 C++ STL 版本
- en: I want to cover the C++ STL versions of a couple of containers. STL is the standard
    template library, which is shipped with most C++ compilers. The reason why I want
    to cover these STL versions is that they behave somewhat differently than the
    UE4 versions of the same containers. In some ways, their behavior is very good,
    but game programmers often complain of STL having performance issues. In particular,
    I want to cover STL's `set` and `map` containers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我想介绍几个容器的 C++ STL 版本。STL 是标准模板库，大多数 C++ 编译器都附带它。我想介绍这些 STL 版本的原因是它们的行为与 UE4
    中相同容器的行为略有不同。在某些方面，它们的行为非常好，但游戏程序员经常抱怨 STL 存在性能问题。特别是，我想介绍 STL 的 `set` 和 `map`
    容器。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you like STL's interface but want better performance, there is a well-known
    reimplementation of the STL library by Electronic Arts called EASTL, which you
    can use. It provides the same functionality as STL but is implemented with better
    performance (basically by doing things such as eliminating bounds checking). It
    is available on GitHub at [https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢 STL 的接口但想要更好的性能，有一个由电子艺界（Electronic Arts）实现的 STL 库的知名重实现，称为 EASTL，你可以使用它。它提供了与
    STL 相同的功能，但实现了更好的性能（基本上是通过消除边界检查等方式）。它可在 GitHub 上找到：[https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL)。
- en: C++ STL set
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ STL 集合
- en: A C++ set is a bunch of items that are unique and sorted. The good feature about
    the STL `set` is that it keeps the set elements sorted. A quick and dirty way
    to sort a bunch of values is actually to just shove them into the same `set`.
    The `set` will take care of the sorting for you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++ set 是一些独特且排序的项。关于 STL `set` 的优点是它保持了集合元素的排序。快速排序一串值的一种简单方法是只是将它们放入同一个 `set`
    中。`set` 会为您处理排序。
- en: 'We can return to a simple C++ console application for the usage of sets. To
    use the C++ STL set you need to include `<set>`, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到一个简单的 C++ 控制台应用程序来使用集合。要使用 C++ STL set，您需要包含 `<set>`，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the output of the preceding code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是前一个代码的输出：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The duplicate `7` is filtered out, and the elements are kept in increasing order
    inside the `set`. The way we iterate over the elements of an STL container is
    similar to UE4's `TSet` array. The `intSet.begin()` function returns an iterator
    that points to the head of the `intSet`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的 `7` 被过滤掉，元素在 `set` 中按递增顺序保持。我们遍历 STL 容器元素的方式与 UE4 的 `TSet` 数组类似。`intSet.begin()`
    函数返回一个指向 `intSet` 头部的迭代器。
- en: 'The condition to stop iterating is when `it` becomes `intSet.end()`. `intSet.end()`
    is actually one position past the end of the `set`, as shown in the following
    figure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 停止迭代的条件是当 `it` 成为 `intSet.end()`。`intSet.end()` 实际上是 `set` 结束之后的一个位置，如下面的图所示：
- en: '![C++ STL set](img/00141.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![C++ STL set](img/00141.jpeg)'
- en: Finding an element in a <set>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 `<set>` 中查找元素
- en: 'To find an element inside an STL `set`, we can use the `find()` member function.
    If the item we''re looking for turns up in the `set`, we get an iterator that
    points to the element we were searching for. If the item that we were looking
    for is not in the `set`, we get back `set.end()`instead, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 STL `set` 中查找一个元素，我们可以使用 `find()` 成员函数。如果我们正在寻找的项目在 `set` 中，我们会得到一个指向我们正在搜索的元素的迭代器。如果我们正在寻找的项目不在
    `set` 中，我们会得到 `set.end()`，如下所示：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Exercise
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Ask the user for a set of three unique names. Take each name in, one by one,
    and then print them in a sorted order. If the user repeats a name, then ask them
    for another one until you get to three.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户一组三个独特的名字。逐个输入每个名字，然后按顺序打印它们。如果用户重复一个名字，则要求他们输入另一个名字，直到您得到三个。
- en: Solution
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution of the preceding exercise can be found using the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习的解决方案可以使用以下代码找到：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: C++ STL map
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ STL map
- en: The C++ STL `map` object is a lot like UE4's `TMap` object. The one thing it
    does that `TMap` does not is to maintain a sorted order inside the map as well.
    Sorting introduces an additional cost, but if you want your map to be sorted,
    opting for the STL version might be a good choice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL `map` 对象与 UE4 的 `TMap` 对象非常相似。它所做的唯一一件事是 `TMap` 不做的是在映射内部保持排序顺序。排序引入了额外的成本，但如果您希望您的映射是排序的，选择
    STL 版本可能是一个不错的选择。
- en: 'To use the C++ STL `map` object, we include `<map>`. In the following example
    program, we populate a map of items with some key-value pairs:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 C++ STL `map` 对象，我们需要包含 `<map>`。在以下示例程序中，我们使用一些键值对填充项目映射：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the output of the preceding program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前一个程序的输出：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice how the iterator''s syntax for an STL map is slightly different than
    that of `TMap`: we access the key using `it->first` and the value using `it->second`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 STL map 的迭代器语法与 `TMap` 的语法略有不同：我们使用 `it->first` 访问键，使用 `it->second` 访问值。
- en: Notice how C++ STL also offers a bit of syntactic sugar over `TMap`; you can
    use square brackets to insert into the C++ STL `map`. You cannot use square brackets
    to insert into a `TMap`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 C++ STL 还在 `TMap` 上提供了一些语法糖；您可以使用方括号来插入 C++ STL `map`。您不能使用方括号来插入 `TMap`。
- en: Finding an element in a <map>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 `<map>` 中查找元素
- en: You can search a map for a <`key`, `value`> pair using the STL map's `find`
    member function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 STL map 的 `find` 成员函数在映射中搜索一个 `<key, value>` 对。
- en: Exercise
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Ask the user to enter five items and their quantities into an empty `map`. Print
    the results in sorted order.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户将五个项目和它们的数量输入到一个空的 `map` 中。按顺序打印结果。
- en: Solution
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution of the preceding exercise uses the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习的解决方案使用了以下代码：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this solution code, we start by creating `map<string, int> items` to store
    all the items we're going to take in. Ask the user for an item and a quantity;
    then we save the `item` in the `items` map using square brackets notation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案代码中，我们首先创建 `map<string, int> items` 来存储我们打算取的所有项目。询问用户一个项目和数量；然后我们使用方括号符号将
    `item` 保存到 `items` 映射中。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: UE4's containers and the C++ STL family of containers are both excellent for
    storing game data. Often, a programming problem can be simplified many times by
    selecting the right type of data container.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: UE4的容器和C++ STL家族的容器都非常适合存储游戏数据。通常，通过选择合适的数据容器，编程问题可以简化很多次。
- en: In the next chapter, we will actually get to programming the beginning of our
    game by keeping track of what the player is carrying and storing that information
    in a `TMap` object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过跟踪玩家携带的物品并将这些信息存储在`TMap`对象中，实际上开始编写我们游戏的开头部分。
