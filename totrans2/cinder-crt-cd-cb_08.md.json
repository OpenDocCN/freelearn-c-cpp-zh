["```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Camera.h\"\n\nusing namespace ci;\n```", "```cpp\n    Vec3f mCubePos, mCubeSize;\n    Vec3f mSphereCenter;\n    float mSphereRadius; \n    Vec3f mLineBegin, mLineEnd; \n    Vec3f mTorusPos;\n    float mTorusOuterRadius, mTorusInnerRadius; \n    Vec3f mCylinderPos;\n    float mCylinderBaseRadius, mCylinderTopRadius, mCylinderHeight;\n    ```", "```cpp\n    mCubePos = Vec3f( 100.0f, 300.0f, 100.0f );\n    mCubeSize = Vec3f( 100.0f, 100.0f, 100.0f );\n\n    mSphereCenter = Vec3f( 500, 250, 0.0f );\n    mSphereRadius = 100.0f;\n\n    mLineBegin = Vec3f( 200, 0, 200 );\n    mLineEnd = Vec3f( 500, 500, -200 );\n\n    mTorusPos = Vec3f( 300.0f, 100.0f, 0.0f );\n    mTorusOuterRadius = 100.0f;\n    mTorusInnerRadius = 20.0f;\n\n    mCylinderPos = Vec3f( 500.0f, 0.0f, -200.0f );\n    mCylinderBaseRadius = 50.0f;\n    mCylinderTopRadius = 80.0f;\n    mCylinderHeight = 100.0f;\n    ```", "```cpp\n    CameraPerspmCamera;\n    ```", "```cpp\n    mCamera = CameraPersp( getWindowWidth(), getWindowHeight(), 60.0f );\n    ```", "```cpp\n    Vec2f windowCenter = getWindowCenter();\n    floatcameraAngle = getElapsedSeconds();\n    floatcameraDist = 450.0f;\n    float x = sinf( cameraAngle ) * cameraDist + windowCenter.x;\n    float z = cosf( cameraAngle ) * cameraDist;\n    mCamera.setEyePoint( Vec3f( x, windowCenter.y, z ) );\n    mCamera.lookAt( Vec3f( windowCenter.x, windowCenter.y, 0.0f ) );\n    ```", "```cpp\n      gl::clear( Color::black() ); \n      gl::setMatrices( mCamera );\n      gl::enableDepthRead();\n      gl::enableDepthWrite();\n    ```", "```cpp\n    gl::color( Color::white() );\n    gl::drawCube( mCubePos, mCubeSize );\n    gl::color( Color::black() );\n    gl::drawStrokedCube( mCubePos, mCubeSize );\n    ```", "```cpp\n    gl::color( Color::white() );\n    gl::drawSphere( mSphereCenter, mSphereRadius, 30 );\n    ```", "```cpp\n    gl::drawLine( mLineBegin, mLineEnd );\n    ```", "```cpp\n    gl::pushMatrices();\n    gl::translate( mTorusPos );\n    gl::drawTorus( mTorusOutterRadius, mTorusInnerRadius );\n    gl::popMatrices();\n    ```", "```cpp\n    gl::pushMatrices();\n    gl::translate( mCylinderPos );\n    gl::drawCylinder( mCylinderBaseRadius, mCylinderTopRadius, mCylinderHeight );\n    gl::popMatrices();\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n        Vec3f mTranslation;\n        Vec3f mScale;\n        Vec3f mRotation;\n    ```", "```cpp\n    mTranslation.x = getWindowWidth() / 2;\n    mTranslation.y = getWindowHeight() / 2;\n    mTranslation.z = 0.0f;\n    ```", "```cpp\n    mScale.x = 100.0f;\n    mScale.y = 200.0f;\n    mScale.z = 100.0f;\n    ```", "```cpp\n    mRotation.x += 1.0f;\n    mRotation.y += 1.0f;\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    gl::pushMatrices();\n    gl::translate( mTranslation );\n    gl::scale( mScale );\n    gl::rotate( mRotation );\n    ```", "```cpp\n    gl::color( Color::white() );\n    gl::drawCube( Vec3f(), Vec3f( 1.0f, 1.0f, 1.0f ) );\n    gl::color( Color::black() );\n    gl::drawStrokedCube( Vec3f(), Vec3f( 1.0f, 1.0f, 1.0f ) );\n    ```", "```cpp\n    gl::popMatrices();\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/gl/Fbo.h\"\n\nusing namespace ci;\n```", "```cpp\n    gl::FbomFbo;\n    Vec3f mCubeRotation;\n    ```", "```cpp\n    mFbo = gl::Fbo( 256, 256 );\n    ```", "```cpp\n    mCubeRotation.x += 1.0f;\n    mCubeRotation.y += 1.0f;\n    ```", "```cpp\n    void drawToFbo();\n    ```", "```cpp\n    gl::SaveFramebufferBinding fboBindingSave;\n    mFbo.bindFramebuffer();\n    ```", "```cpp\n    gl::clear( Color( 0.3f, 0.3f, 0.3f ) );\n    gl::setMatricesWindowPersp( mFbo.getWidth(), mFbo.getHeight() );\n    ```", "```cpp\n    gl::pushMatrices();\n    Vec3f cubeTranslate( mFbo.getWidth() / 2, mFbo.getHeight() / 2, 0.0f );\n    gl::translate( cubeTranslate );\n    gl::rotate( mCubeRotation );\n    gl::drawColorCube( Vec3f(), Vec3f( 100, 100, 100 ) );\n    gl::popMatrices();\n    ```", "```cpp\n    drawToFbo();\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    gl::draw( mFbo.getTexture(), Rectf( 0.0f, 0.0f, 100.0f, 100.0f ) );\n    ```", "```cpp\n    mFbo.getTexture().enableAndBind();\n    ```", "```cpp\n    gl::pushMatrices();\n    Vec3f center( getWindowWidth() / 2, getWindowHeight() / 2, 0.0f );\n    gl::translate( center );\n    gl::rotate( mCubeRotation );\n    gl::drawCube( Vec3f(), Vec3f( 200.0f, 200.0f, 200.0f ) );\n    gl::popMatrices();\n    ```", "```cpp\n    mFbo.unbindTexture();\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Camera.h\"\n#include \"cinder/MayaCamUI.h\"\n#include \"cinder/PolyLine.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    MayaCamUI mCamera;\n    vector<PolyLine<Vec3f> > mLines;\n    ```", "```cpp\n    CameraPersp cameraPersp( getWindowWidth(),getWindowHeight(), 60.0f );\n    Vec3f center( getWindowWidth() / 2, getWindowHeight() / 2,0.0f );\n    cameraPersp.setCenterOfInterestPoint( center );\n    mCamera.setCurrentCam( cameraPersp );\n    ```", "```cpp\n      gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatrices( mCamera.getCamera() );\n    ```", "```cpp\n    for( vector<PolyLine<Vec3f> > ::iterator it = mLines.begin(); it != mLines.end(); ++it ){\n    gl::draw( *it );\n        }\n    ```", "```cpp\n        Vec3f screenToWorld( const Vec2f&point ) const;\n    ```", "```cpp\n    float u = point.x / (float)getWindowWidth();\n    float v = point.y / (float)getWindowHeight();\n\n    const CameraPersp& cameraPersp = mCamera.getCamera();\n\n    Ray ray = cameraPersp.generateRay( u, 1.0f - v, cameraPersp.getAspectRatio() );\n    ```", "```cpp\n    float result = 0.0f;\n    Vec3f planePos = cameraPersp.getCenterOfInterestPoint();\n    Vec3f normal = cameraPersp.getViewDirection();\n\n    ray.calcPlaneIntersection( planePos, normal, &result );\n\n    Vec3f intersection= ray.calcPosition( result );\n    return intersection;\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\n    void mouseDrag( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      if( event.isShiftDown() ){\n      mCamera.mouseDown( event.getPos() );\n        }\n    else {    \n            mLines.push_back( PolyLine<Vec3f>() );\n            Vec3f point = screenToWorld( event.getPos() );\n            mLines.back().push_back( point );\n        }\n    }\n    ```", "```cpp\n    void Pick3dApp::mouseDrag( MouseEvent event ){\n        if( event.isShiftDown() ){\n        mCamera.mouseDrag( event.getPos(), event.isLeftDown(), event.isMiddleDown(), event.isRightDown() );\n        } else {\n            Vec3f point = screenToWorld( event.getPos() );\n            mLines.back().push_back( point );\n        }\n    }\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/gl/Light.h\"\n#include \"cinder/gl/Material.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    gl::Material mMaterial;\n    Vec3f mLightPos;\n    ```", "```cpp\n    mMaterial.setAmbient( Color::black() );\n    mMaterial.setDiffuse( Color( 1.0f, 0.0f, 0.0f ) );\n    mMaterial.setSpecular( Color::white() );\n    mMaterial.setEmission( Color::black() );\n    mMaterial.setShininess( 128.0f );\n    ```", "```cpp\n    mLightPos.x = getMousePos().x;\n    mLightPos.y = getMousePos().y;\n    mLightPos.z = 200.0f;\n    ```", "```cpp\n    gl::clear( Color::black() );\n    gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );\n    gl::enableDepthWrite();\n    gl::enableDepthRead();\n    ```", "```cpp\n    gl::Light light( gl::Light::POINT, 0 );\n    light.setPosition( mLightPos );\n    light.setAttenuation( 1.0f, 0.0f, 0.0f );\n    ```", "```cpp\n    glEnable( GL_LIGHTING );\n    light.enable();\n    mMaterial.apply();\n    ```", "```cpp\n    gl::pushMatrices();\n    gl::translate( getWindowCenter() );\n    float seconds = (float)getElapsedSeconds() * 100.0f;\n    glRotatef( seconds, 1.0f, 0.0f, 0.0f );\n    glRotatef( seconds, 0.0f, 1.0f, 0.0f );\n    gl::drawTorus( 100.0f, 40.0f, 30, 30 );\n    gl::popMatrices();\n    ```", "```cpp\n    light.disable();\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/gl/Texture.h\"\n#include \"cinder/gl/Light.h\"\n#include \"cinder/gl/Material.h\"\n#include \"cinder/TriMesh.h\"\n#include \"cinder/ImageIo.h\"\n#include \"cinder/MayaCamUI.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    TriMesh mMesh;\n    gl::Texture mTexture;\n    MayaCamUI mCam;\n    bool mIntersects;\n    Vec3f mNormal, mHitPos;\n    AxisAlignedBox3f mMeshBounds;\n    gl::Material mMaterial;\n    ```", "```cpp\n    void calcIntersectionWithMeshTriangles( const ci::Ray& ray );\n    ```", "```cpp\n    mMesh.read( loadAsset( \"ducky.msh\" ) );\n    mTexture = loadImage( loadAsset( \"ducky.png\" ) );\n    mMeshBounds = mMesh.calcBoundingBox();\n    ```", "```cpp\n    CameraPersp cam;\n    Vec3f modelCenter = mMeshBounds.getCenter();\n    cam.setEyePoint( modelCenter + Vec3f( 0.0f, 0.0f, 20.0f ) );\n    cam.setCenterOfInterestPoint( modelCenter );\n    mCam.setCurrentCam( cam );\n    ```", "```cpp\n    mMaterial.setAmbient( Color::black() );\n    mMaterial.setDiffuse( Color::white() );\n    mMaterial.setEmission( Color::black() );\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\n    void mouseDrag( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      mCam.mouseDown( event.getPos() );\n    }\n\n    void MyApp::mouseDrag( MouseEvent event ){\n      mCam.mouseDrag( event.getPos(), event.isLeftDown(), event.isMiddleDown(), event.isRightDown() );\n    }\n    ```", "```cpp\n    Vec2f mousePos = getMousePos();\n    float u = mousePos.x / (float)getWindowWidth();\n    float v = mousePos.y / (float)getWindowHeight();\n    CameraPersp cameraPersp = mCam.getCamera();\n    Ray ray = cameraPersp.generateRay( u, 1.0f - v, cameraPersp.getAspectRatio() );\n    ```", "```cpp\n        if( mMeshBounds.intersects( ray ) == false ){\n      mIntersects = false;\n        } else {\n      calcIntersectionWithMeshTriangles( ray );\n        }\n    ```", "```cpp\n    float distance = 0.0f;\n    float resultDistance = 999999999.9f;\n    int resultIndex = -1;\n    int numTriangles = mMesh.getNumTriangles();\n    for( int i=0; i<numTriangles; i++ ){\n            Vec3f v1, v2, v3;\n            mMesh.getTriangleVertices( i, &v1, &v2, &v3 );\n            if( ray.calcTriangleIntersection( v1, v2, v3, &distance ) ){\n            if( distance <resultDistance ){\n            resultDistance = distance;\n            resultIndex = i;\n                }\n            }\n        }\n    ```", "```cpp\n    if( resultIndex> -1 ){\n            mHitPos = ray.calcPosition( resultDistance );\n            mIntersects = true;\n            Vec3f v1, v2, v3;\n            mMesh.getTriangleVertices( resultIndex, &v1, &v2, &v3 );\n            mNormal = ( v2 - v1 ).cross( v3 - v1 );\n            mNormal.normalize();\n        } else {\n          mIntersects = false;\n        }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatrices( mCam.getCamera() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    gl::Light light( gl::Light::POINT, 0 );\n    light.setPosition( mCam.getCamera().getEyePoint() );\n    light.setAttenuation( 1.0f, 0.0f, 0.0f );\n    glEnable( GL_LIGHTING );\n    light.enable();\n    mMaterial.apply();\n    ```", "```cpp\n    mTexture.enableAndBind();\n    gl::draw( mMesh );\n    mTexture.unbind();\n    glDisable( GL_LIGHTING ); \n    ```", "```cpp\n    if( mIntersects ){\n      gl::color( Color::white() );\n      gl::drawSphere( mHitPos, 0.2f );\n      gl::drawVector( mHitPos, mHitPos + ( mNormal * 2.0f ) );\n        }\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Surface.h\"\n#include \"cinder/gl/Vbo.h\"\n#include \"cinder/MayaCamUI.h\"\n#include \"cinder/ImageIo.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    Surface32f mImage;\n    gl::VboMesh mPointCloud;gl::VboMesh mPointCloud;\n    MayaCamUI mCam;\n    ```", "```cpp\n    fs::path imagePath = getOpenFilePath( \"\", ImageIo::getLoadExtensions() );\n    if( imagePath.empty() == false ){\n    ```", "```cpp\n    mImage = loadImage( imagePath );\n    int numPixels = mImage.getWidth() * mImage.getHeight();\n    gl::VboMesh::Layout layout;\n    layout.setDynamicColorsRGB();\n    layout.setDynamicPositions();\n    mPointCloud = gl::VboMesh( numPixels, 0, layout, GL_POINTS );\n    ```", "```cpp\n    Surface32f::IterpixelIt = mImage.getIter();\n    gl::VboMesh::VertexItervertexIt( mPointCloud );\n    while( pixelIt.line() ){\n      while( pixelIt.pixel() ){\n                        Color color( pixelIt.r(), pixelIt.g(), pixelIt.b() );\n        float height = color.get( CM_RGB ).length();\n        float x = pixelIt.x();\n        float y = mImage.getHeight() - pixelIt.y();\n        float z = height * 100.0f;\n        vertexIt.setPosition( x,y, z );\n        vertexIt.setColorRGB( color );\n                        ++vertexIt;\n                    }\n                }\n    ```", "```cpp\n            Vec3f center( (float)mImage.getWidth()/2.0f, (float)mImage.getHeight()/2.0f, 50.0f );\n        CameraPersp camera( getWindowWidth(), getWindowHeight(), 60.0f );\n        camera.setEyePoint( Vec3f( center.x, center.y, (float)mImage.getHeight() ) );\n        camera.setCenterOfInterestPoint( center );\n        mCam.setCurrentCam( camera );\n        }\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\t\n    void mouseDrag( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      mCam.mouseDown( event.getPos() );\n    }\n\n    void MyApp::mouseDrag( MouseEvent event ){\n      mCam.mouseDrag( event.getPos(), event.isLeft(), event.isMiddle(), event.isRight() );\n    }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatrices( mCam.getCamera() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    if( mPointCloud ){\n      gl::draw( mPointCloud );\n        }\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Perlin.h\"\n#include \"cinder/MayaCamUI.h\"\n#include \"cinder/CinderMath.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    struct Vertice{\n        Vec3f position;\n        Color color;\n    };\n    ```", "```cpp\n    vector< vector<Vertice> > mTerrain;\n    int mNumRows, mNumLines;\n    MayaCamUI mCam;\n    Perlin mPerlin;\n    ```", "```cpp\n    mNumRows = 50;\n    mNumLines = 50;\n    float gap = 5.0f;\n    ```", "```cpp\n       mTerrain.resize( mNumRows );\n        for( int i=0; i<mNumRows; i++ ){\n            mTerrain[i].resize( mNumLines );\n            for( int j=0; j<mNumLines; j++ ){\n                float x = (float)i * gap;\n                float z = (float)j * gap;\n                float y = mPerlin.noise( x*0.01f, z*0.01 ) * 100.0f;\n                mTerrain[i][j].position = Vec3f( x, y, z );\n                float colorVal = lmap( y, -100.0f, 100.0f, 0.0f, 1.0f );\n                mTerrain[i][j].color = Color( colorVal, colorVal, colorVal );\n            }\n        }\n    ```", "```cpp\n    float width = mNumRows * gap;\n    float height = mNumLines * gap;\n    Vec3f center( width/2.0f, height/2.0f, 0.0f );\n    Vec3f eye( center.x, center.y, 300.0f );\n    CameraPersp camera( getWindowWidth(), getWindowHeight(), 60.0f );\n    camera.setEyePoint( eye );\n    camera.setCenterOfInterestPoint( center );\n    mCam.setCurrentCam( camera );\n    ```", "```cpp\n    Void mouseDown( MouseEvent event );\n    void mouseDrag( MouseEvent event );\n            }\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      mCam.mouseDown( event.getPos() );\n    }\n    void MyApp::mouseDrag( MouseEvent event ){\n      mCam.mouseDrag( event.getPos(), event.isLeft(), event.isMiddle(), event.isRight() );\n    }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatrices( mCam.getCamera() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    glEnableClientState( GL_VERTEX_ARRAY );\n    glEnableClientState( GL_COLOR_ARRAY );\n    ```", "```cpp\n    for( int i=0; i<mNumRows-1; i++ ){\n      vector<Vec3f> vertices;\n      vector<ColorA> colors;\n      for( int j=0; j<mNumLines; j++ ){\n\n        vertices.push_back( mTerrain[i][j].position );\n        vertices.push_back( mTerrain[i+1][j].position );\n        colors.push_back( mTerrain[i][j].color );\n        colors.push_back( mTerrain[i+1][j].color );\n\n                }\n      glColor3f( 1.0f, 1.0f, 1.0f );\n      glVertexPointer( 3, GL_FLOAT, 0, &vertices[0] );\n      glColorPointer( 4, GL_FLOAT, 0, &colors[0] );\n      glDrawArrays( GL_TRIANGLE_STRIP, 0, vertices.size() );\n      }\n    ```", "```cpp\nfloat offsetX, offsetZ;\n```", "```cpp\noffsetX = 0.0f;\noffsetZ = 0.0f;\n```", "```cpp\noffsetX += 0.01f;\noffsetZ += 0.01f;\n```", "```cpp\n  for( int i=0; i<mNumRows; i++ ){\n  for( int j=0; j<mNumLines; j++ ){\n  Vertice& vertice = mTerrain[i][j];\n  float x = vertice.position.x;\n  float z = vertice.position.z;\n  float y = mPerlin.noise( x*0.01f + offsetX, z*0.01f + offsetZ ) * 100.0f;\n            vertice.position.y = y;\n        }\n    }\n```", "```cpp\n    #include \"cinder/ObjLoader.h\"\n    #include \"cinder/Utilities.h\"\n    ```", "```cpp\n    if( event.getChar() == 's' ) {\n      fs::path path = getSaveFilePath(getDocumentsDirectory() / fs::path(\"mesh.trimesh\") );\n      if( ! path.empty() ) {\n        mMesh.write( writeFile( path ) );\n            }\n    }\n      else if( event.getChar() == 'o' ) {\n      fs::path path = getSaveFilePath(getDocumentsDirectory() / fs::path(\"mesh.obj\") );\n      if( ! path.empty() ) {\n      ObjLoader::write( writeFile( path ), mMesh );\n        }\n    }\n    ```"]