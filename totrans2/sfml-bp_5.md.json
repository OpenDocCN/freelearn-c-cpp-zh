["```cpp\nclass Widget : public sf::Drawable\n{\n  public:\n  Widget(Widget* parent=nullptr);\n  virtual ~Widget();\n\n  void setPosition(const sf::Vector2f& pos);\n  void setPosition(float x,float y);\n  const sf::Vector2f& getPosition()const;\n  virtual sf::Vector2f getSize()const = 0;\n\n  protected:\n  virtual bool processEvent(const sf::Event& event,const sf::Vector2f& parent_pos);\n  virtual void processEvents(const sf::Vector2f& parent_pos);\n  virtual void updateShape();\n\n  Widget* _parent;\n  sf::Vector2f _position;\n};\n```", "```cpp\nWidget::Widget(Widget* parent) : _parent(parent){}\nWidget::~Widget(){}\nvoid Widget::setPosition(const sf::Vector2f& pos) {_position = pos;}\nvoid Widget::setPosition(float x,float y)\n{\n  _position.x = x;\n  _position.y = y;\n}\nconst sf::Vector2f& Widget::getPosition()const {return _position;}\nbool Widget::processEvent(const sf::Event& event,const sf::Vector2f& parent_pos) {return false;}\nvoid Widget::processEvents(const sf::Vector2f& parent_pos) {}\n```", "```cpp\nvoid Widget::updateShape()\n{\n  if(_parent)\n  _parent->updateShape();\n}\n```", "```cpp\nclass Label : public Widget\n{\n  public:\n  Label(const std::string& text, Widget* parent=nullptr);\n  virtual ~Label();\n\n  void setText(const std::string& text);\n  void setCharacterSize(unsigned int size);\n  unsigned int getCharacterSize()const;\n  void setTextColor(const sf::Color& color);\n  virtual sf::Vector2f getSize()const override;\n\n  private:\n  sf::Text _text;\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n};\n```", "```cpp\nLabel::Label(const std::string& text, Widget* parent) : Widget(parent)\n{\n  _text.setFont(Configuration::fonts.get(Configuration::Fonts::Gui));\n  setText(text);\n  setTextColor(sf::Color(180,93,23));\n}\n```", "```cpp\nLabel::~Label() {}\nvoid Label::setText(const std::string& text)\n{   _text.setString(text);\n  updateShape();\n}\nvoid Label::setCharacterSize(unsigned int size)\n{\n  _text.setCharacterSize(size);\n  updateShape();\n}\n```", "```cpp\nunsigned int Label::getCharacterSize()const {return _text.getCharacterSize();}\n\nvoid Label::setTextColor(const sf::Color& color) {_text.setColor(color);}\n\nsf::Vector2f Label::getSize()const\n{\n  sf::FloatRect rect = _text.getGlobalBounds();\n  return sf::Vector2f(rect.width,rect.height);\n}\n```", "```cpp\nvoid Label::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  states.transform.translate(_position);\n  target.draw(_text,states);\n}\n```", "```cpp\nclass Button : public Widget\n{\n  public:\n  using FuncType = std::function<void(const sf::Event& event,Button& self)>;\n  static FuncType defaultFunc;\n  Button(Widget* parent=nullptr);\n\n  virtual ~Button();\n  FuncType onClick;\n\n  protected:\n  virtual bool processEvent(const sf::Event& event,const sf::Vector2f& parent_pos)override;\n  virtual void onMouseEntered();\n  virtual void onMouseLeft();\n\n  private:\n  enum Status {None =0,Hover = 1};\n  int _status;\n};\n```", "```cpp\nButton::FuncType Button::defaultFunc = [](const sf::Event&,Button&)->void{};\n```", "```cpp\nButton::Button(Widget* parent) : Widget(parent), onClick(defaultFunc), _status(Status::None) {}\n```", "```cpp\nButton::~Button() {}\nbool Button::processEvent(const sf::Event& event,const \nsf::Vector2f& parent_pos)\n{\n  bool res = false;\n  if(event.type == sf::Event::MouseButtonReleased)\n  {\n    const sf::Vector2f pos = _position + parent_pos;\n    const sf::Vector2f size = getSize();\n    sf::FloatRect rect;\n    rect.left = pos.x;\n    rect.top = pos.y;\n    rect.width = size.x;\n    rect.height = size.y;\n    if(rect.contains(event.mouseButton.x,event.mouseButton.y)) \n{\n      onClick(event,*this);\n        res = true;\n    }\n  } else if (event.type == sf::Event::MouseMoved) {\n    const sf::Vector2f pos = _position + parent_pos;\n    const sf::Vector2f size = getSize();\n    sf::FloatRect rect;\n    rect.left = pos.x;\n    rect.top = pos.y;\n    rect.width = size.x;\n    rect.height = size.y;\n    int old_status = _status;\n    _status = Status::None;\n    const sf::Vector2f \n    mouse_pos(event.mouseMove.x,event.mouseMove.y);\n    if(rect.contains(mouse_pos))\n      _status=Status::Hover;\n    if((old_status & Status::Hover) and not (_status & \n      Status::Hover))\n        onMouseLeft();\n    else if(not (old_status & Status::Hover) and (_status & \n      Status::Hover))\n        onMouseEntered();\n  }\n  return res;\n}\n```", "```cpp\nvoid Button::onMouseEntered() {}\nvoid Button::onMouseLeft() {}\n```", "```cpp\nclass TextButton : public\n{\n  public:\n  TextButton(const std::string& text, Widget* parent=nullptr);\n  virtual ~TextButton();\n\n  void setText(const std::string& text);\n  void setCharacterSize(unsigned int size);\n\n  void setTextColor(const sf::Color& color);\n  void setFillColor(const sf::Color& color);\n  void setOutlineColor(const sf::Color& color);\n  void setOutlineThickness(float thickness);\n  virtual sf::Vector2f getSize()const override;\n\n  private:\n  sf::RectangleShape _shape;\n  Label _label;\n  void updateShape()override;\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n  sf::Color _fillColor;\n  sf::Color _outlineColor;\n  virtual void onMouseEntered()override;\n  virtual void onMouseLeft()override;\n};\n```", "```cpp\nTextButton::TextButton(const std::string& text,Widget* parent) : Button(parent), _label(text,this)\n{\n  setFillColor(sf::Color(86,20,19));\n  setOutlineThickness(5);\n  setOutlineColor(sf::Color(146,20,19));\n}\n```", "```cpp\nTextButton::~TextButton() {}\nvoid TextButton::setText(const std::string& text) {_label.setText(text);}\nvoid TextButton::setCharacterSize(unsigned int size) {_label.setCharacterSize(size);}\nvoid TextButton::setTextColor(const sf::Color& color) {_label.setTextColor(color);}\n\nvoid TextButton::setFillColor(const sf::Color& color)\n{\n  _fillColor = color;\n  _shape.setFillColor(_fillColor);\n}\n\nvoid TextButton::setOutlineColor(const sf::Color& color)\n{\n  _outlineColor = color;\n  _shape.setOutlineColor(_outlineColor);\n}\n\nvoid TextButton::setOutlineThickness(float thickness) {_shape.setOutlineThickness(thickness);}\n\nsf::Vector2f TextButton::getSize()const\n{\n  sf::FloatRect rect = _shape.getGlobalBounds();\n  return sf::Vector2f(rect.width,rect.height);\n}\n```", "```cpp\nvoid TextButton::updateShape()\n{\n  sf::Vector2f label_size = _label.getSize();\n  unsigned int char_size = _label.getCharacterSize();\n  _shape.setSize(sf::Vector2f(char_size*2 + label_size.x ,char_size*2 + label_size.y));\n  _label.setPosition(char_size,char_size);\n  Widget::updateShape();\n}\n```", "```cpp\nvoid TextButton::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  states.transform.translate(_position);\n  target.draw(_shape,states);\n  target.draw(_label,states);\n}\n```", "```cpp\nvoid TextButton::onMouseEntered()\n{\n  const float light = 1.4f;\n  _shape.setOutlineColor(sf::Color(_outlineColor.r*light,\n  _outlineColor.g*light,\n  _outlineColor.b*light));\n  _shape.setFillColor(sf::Color(_fillColor.r*light,\n  _fillColor.b*light,\n  _fillColor.b*light));\n}\n\nvoid TextButton::onMouseLeft()\n{\n  _shape.setOutlineColor(_outlineColor);\n  _shape.setFillColor(_fillColor);\n}\n```", "```cpp\nclass Container  : public Widget\n{\n  public:\n  Container(Widget* parent=nullptr);\n  virtual ~Container();\n\n  void setLayout(Layout* layout);\n  Layout* getLayout()const;\n\n  virtual sf::Vector2f getSize()const override;\n\n  protected:\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n  virtual bool processEvent(const sf::Event& event,const sf::Vector2f& parent_pos)override;\n  virtual void processEvents(const sf::Vector2f& parent_pos)override;\n\n  private:\n  Layout* _layout;\n};\n```", "```cpp\nContainer::Container(Widget* parent) : Widget(parent), _layout(nullptr) {}\nContainer::~Container()\n{\n  if(_layout != nullptr and _layout->_parent == this) {\n    _layout->_parent = nullptr;\n    delete _layout;\n  }\n}\n```", "```cpp\nvoid Container::setLayout(Layout* layout)\n{\n  if(_layout != nullptr and _layout->_parent == this) {\n    _layout->_parent = nullptr;\n  }\n  if((_layout = layout) != nullptr) {\n    _layout->_parent = this;\n    _layout->updateShape();\n  }\n}\n```", "```cpp\nLayout* Container::getLayout()const {return _layout;}\nsf::Vector2f Container::getSize()const\n{\n  sf::Vector2f res(0,0);\n  if(_layout)\n  res = _layout->getSize();\n  return res;\n}\nvoid Container::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  if(_layout)\n  target.draw(*_layout,states);\n}\n```", "```cpp\nbool Container::processEvent(const sf::Event& event,const sf::Vector2f& parent_pos)\n{\n    bool res = false;\n    if(and _layout)\n        res = _layout->processEvent(event,parent_pos);\n    return res;\n}\nvoid Container::processEvents(const sf::Vector2f& parent_pos)\n{\n    if(_layout)\n        _layout->processEvents(parent_pos);\n}\n```", "```cpp\nclass Frame : public Container, protected ActionTarget<int>\n{\n  public:\n  using ActionTarget<int>::FuncType;\n  Frame(sf::RenderWindow& window);\n  virtual ~Frame();\n\n  void processEvents();\n  bool processEvent(const sf::Event& event);\n\n  void bind(int key,const FuncType& callback);\n  void unbind(int key);\n\n  void draw();\n  virtual sf::Vector2f getSize()const override;\n\n  private:\n  sf::RenderWindow& _window;\n\n  virtual bool processEvent(const sf::Event& event,const sf::Vector2f& parent_pos)override;\n  virtual void processEvents(const sf::Vector2f& parent_pos)override;\n};\n```", "```cpp\nFrame::Frame(sf::RenderWindow& window) : Container(nullptr), ActionTarget(Configuration::gui_inputs), _window(window) {}\nFrame::~Frame(){}\n\nvoid Frame::draw() {_window.draw(*this);}\n\nvoid Frame::bind(int key,const FuncType& callback) {ActionTarget::bind(key,callback);}\n\nvoid Frame::unbind(int key) {ActionTarget::unbind(key);}\n\nsf::Vector2f Frame::getSize()const\n{\n  sf::Vector2u size = _window.getSize();\n  return sf::Vector2f(size.x,size.y);\n}\n```", "```cpp\nvoid Frame::processEvents()\n{\n    sf::Vector2f parent_pos(0,0);\n    processEvents(parent_pos);\n}\nbool Frame::processEvent(const sf::Event& event)\n{\n    sf::Vector2f parent_pos(0,0);\n    return processEvent(event,parent_pos);\n}\n```", "```cpp\nbool Frame::processEvent(const sf::Event& event,const sf::Vector2f& parent_pos)\n{\n  bool res = ActionTarget::processEvent(event);\n  if(not res)\n  res = Container::processEvent(event,parent_pos);\n  return res;\n}\n\nvoid Frame::processEvents(const sf::Vector2f& parent_pos)\n{\n  ActionTarget::processEvents();\n  Container::processEvents(parent_pos);\n  sf::Event event;\n  while(_window.pollEvent(event))\n  Container::processEvent(event,parent_pos);\n}\n```", "```cpp\nclass Layout : protected Widget\n{\n  public:\n  Layout(Widget* parent=nullptr);\n  virtual ~Layout();\n\n  void setSpace(float pixels);\n\n  protected:\n  friend class Container;   float _space;\n};\n```", "```cpp\nLayout::Layout(Widget* parent): Widget(parent), _space(5) {}\n\nLayout::~Layout() {}\nvoid Layout::setSpace(float pixels)\n{\n    if(pixels >= 0) {\n        _space = pixels;\n        updateShape();\n    }\n    else\n        throw std::invalid_argument(\"pixel value must be >= 0\");\n}\n```", "```cpp\nclass VLayout : public Layout\n{\n  public:\n  VLayout(const VLayout&) = delete;\n  VLayout& operator=(const VLayout&) = delete;\n  VLayout(Widget* parent = nullptr);\n  ~Vlayout();\n\n  void add(Widget* widget);\n  Widget* at(unsigned int index)const;\n  virtual sf::Vector2f getSize()const override;\n\n  protected:\n  virtual bool processEvent(const sf::Event& event,const sf::Vector2f& parent_pos) override;\n  virtual void processEvents(const sf::Vector2f& parent_pos) override;\n\n  private:\n  std::vector<Widget*> _widgets;\n  virtual void updateShape() override;\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n};\n```", "```cpp\nVLayout::VLayout(Widget* parent) : Layout(parent) {}\nVLayout::~VLayout()\n{\n    for(Widget* widget : _widgets) {\n        if(widget->_parent == this)\n            delete widget;\n    }\n}\n```", "```cpp\nvoid VLayout::add(Widget* widget)\n{\n  widget->_parent = this;\n  _widgets.emplace_back(widget);\n  updateShape();\n}\nWidget* VLayout::at(unsigned int index)const {return _widgets.at(index);}\n```", "```cpp\nsf::Vector2f VLayout::getSize()const\n{\n  float max_x = 0;\n  float y = 0;\n  for(Widget* widget : _widgets)\n  {\n    sf::Vector2f size = widget->getSize();\n    if(size.x > max_x)\n    max_x = size.x;\n    y+= _space + size.y;\n  }\n  return sf::Vector2f(max_x+_space*2,y+_space);\n}\n```", "```cpp\nbool VLayout::processEvent(const sf::Event& event,const sf::Vector2f& parent_pos)\n{\n  for(Widget* widget : _widgets) \n{\n    if(widget->processEvent(event,parent_pos))\n    return true;\n  }\n    return false ;\n}\n\nvoid VLayout::processEvents(const sf::Vector2f& parent_pos)\n{\n  for(Widget* widget : _widgets)\n  widget->processEvents(parent_pos);\n}\n```", "```cpp\nvoid VLayout::updateShape()\n{\n  float max_x = (_parentparent->getSize().x:0);\n  for(Widget* widget : _widgets) {\n  sf::Vector2f size = widget->getSize();\n  float widget_x = size.x;\n  if(widget_x > max_x)\n  max_x = widget_x;\n}\n  float pos_y = _space;\n  if(_parent)\n  pos_y = (_parent->getSize().y - getSize().y)/2.f;\n  for(Widget* widget : _widgets) \n{\n    sf::Vector2f size = widget->getSize();\n    widget->setPosition((max_x-size.x)/2.0,pos_y);\n    pos_y += size.y + _space;\n  }\n  Widget::updateShape();\n}\n```", "```cpp\nvoid VLayout::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  for(Widget* widget : _widgets)\n  target.draw(*widget,states);\n}\n```", "```cpp\ngui::Frame _mainMenu;\n```", "```cpp\nenum Status {StatusMainMenu,StatusGame,StatusConfiguration,StatusPaused,StatusExit} _status\n```", "```cpp\nvoid initGui();\n```", "```cpp\nGame::Game(int X, int Y,int word_x,int word_y) : ActionTarget(Configuration::player_inputs), \n_window(sf::VideoMode(X,Y),\"05_Gui\"), _current_piece(nullptr), \n_world(word_x,word_y), _mainMenu(_window), \n_status(Status::StatusMainMenu)\n{\n  //...\n  initGui();\n}\n```", "```cpp\nvoid Game::initGui()\n{\n  book::gui::VLayout* layout = new book::gui::VLayout;\n  layout->setSpace(25);\n  book::gui::TextButton* newGame = new book::gui::TextButton(\"New Game\");\n  newGame->onClick = [this](const sf::Event&, book::gui::Button& button){\n  initGame();\n  _status = Status::StatusGame;\n};\n\nlayout->add(newGame);\nbook::gui::TextButton* configuration = new book::gui::TextButton(\"Configuration\");\nconfiguration->onClick = [this](const sf::Event&, book::gui::Button& button){\n  _status = Status::StatusConfiguration;\n};\n\nlayout->add(configuration);\nbook::gui::TextButton* exit = new book::gui::TextButton(\"Exit\");\nexit->onClick = [this](const sf::Event&, book::gui::Button& button){\n  _window.close();\n};\nlayout->add(exit);\n_mainMenu.setLayout(layout);\n_mainMenu.bind(Configuration::GuiInputs::Escape,[this](const sf::Event& event){\n    this->_window.close();\n  });\n}\n```", "```cpp\nif(_status == StatusGame and not _stats.isGameOver())\n```", "```cpp\nvoid Game::processEvents()\n{\n  sf::Event event;\n  while(_window.pollEvent(event))\n  {\n    if (event.type == sf::Event::Closed)\n    _window.close();\n    else if (event.type == sf::Event::KeyPressed and event.key.code == sf::Keyboard::Escape and _status == Status::StatusGame)\n    _status = StatusPaused;\n    else\n    {\n      switch(_status)\n      {\n        case StatusMainMenu: _mainMenu.processEvent(event);break;\n        case StatusGame : ActionTarget::processEvent(event);break;\n        default : break;\n      }\n    }\n  }\n  switch(_status)\n  {\n    case StatusMainMenu: _mainMenu.processEvents();break;\n    case StatusGame :  ActionTarget::processEvents();break;\n    default : break;\n  }\n}\n```", "```cpp\nvoid Game::render()\n{\n  _window.clear();\n  switch(_status)\n  {\n    case StatusMainMenu: _window.draw(_mainMenu);break;\n    case StatusGame :\n    {\nif(not _stats.isGameOver())\n  _window.draw(_world);\n  _window.draw(_stats);\n    }break;\n    default : break;\n  }\n_window.display();\n}\n```", "```cpp\nvoid Game::initGui()\n{\n  //...\n  book::gui::VLayout* layout = new book::gui::VLayout;\n  layout->setSpace(50);\n  book::gui::Label* pause = new book::gui::Label(\"Pause\");\n  pause->setCharacterSize(70);\n  layout->add(pause);\n  book::gui::TextButton* exit = new book::gui::TextButton(\"Exit\");\n  exit->onClick = [this](const sf::Event&, book::gui::Button& button)\n  {\n    _status = StatusMainMenu;\n  };\n\n  layout->add(exit);\n  _pauseMenu.setLayout(layout);\n  _pauseMenu.bind(Configuration::GuiInputs::Escape,[this](const sf::Event& event){\n  _status = StatusGame;\n  });\n}\n```", "```cpp\ncase StatusPaused :_pauseMenu.processEvent(event);break;\n```", "```cpp\ncase StatusPaused : _pauseMenu.processEvents();break;\n```", "```cpp\ncase StatusPaused :\n{\n    if(not _stats.isGameOver())\n        _window.draw(_world);\n    _window.draw(_pauseMenu);\n}break;\n```", "```cpp\n_configurationMenu.bind(Configuration::GuiInputs::Escape,[this](const sf::Event& event){\n    _status = StatusMainMenu;\n});\n```", "```cpp\nunsigned int _initialLvl;\n```", "```cpp\nvoid setLevel(int lvl);\n```", "```cpp\n_nbLvl = _nbRows / 10;\n```", "```cpp\n_nbLvl = _initialLvl + (_nbRows / 10);\n```", "```cpp\nvoid Stats::setLevel(int lvl)\n{\n  _initialLvl = lvl;\n  _textLvl.setString(\"lvl : \"+std::to_string(lvl));\n}\n\nint Stats::getLevel()const\n{\n  return _initialLvl + _nbLvl;\n}\n```", "```cpp\nsfg::SFGUI _sfgui;\nsfg::Desktop _sfgDesktop;\n```", "```cpp\nvoid Game::initGui()\n{\n  //...\n  auto title = sfg::Label::Create(\"Enter your starting level\");\n  auto level = sfg::Entry::Create();\n  auto error = sfg::Label::Create();\n  auto button = sfg::Button::Create( \"Ok\" );\n  button->GetSignal( sfg::Button::OnLeftClick ).Connect(\n    [level,error,this](){\n      int lvl = 0;\n      std::stringstream sstr(static_cast<std::string>(level->GetText()));\n      sstr >> lvl;\n      if(lvl < 1 or lvl > 100)\n      error->SetText(\"Enter a number from 1 to 100.\");\n      else\n      {\n        error->SetText(\"\");\n        initGame();\n        _stats.setLevel(lvl);\n        _status = Status::StatusGame;\n      }\n    }\n  );\n\n  auto table = sfg::Table::Create();\n  table->SetRowSpacings(10);\n  table->Attach(title,sf::Rect<sf::Uint32>(0,0,1,1));\n  table->Attach(level,sf::Rect<sf::Uint32>(0,1,1,1));\n  table->Attach(button,sf::Rect<sf::Uint32>(0,2,1,1));\n  table->Attach(error,sf::Rect<sf::Uint32>(0,3,1,1));\n  table->SetAllocation(sf::FloatRect((_window.getSize().x-300)/2,\n  (_window.getSize().y-200)/2,\n  300,200));\n  _sfgDesktop.Add(table);\n}\n```", "```cpp\ncase StatusConfiguration :\n{\n  _configurationMenu.processEvent(event);\n  _sfgDesktop.HandleEvent(event);\n}break;\n```", "```cpp\ncase StatusConfiguration:\n{\n  _sfgDesktop.Update(0.0);\n  _sfgui.Display(_window);\n  _window.draw(_configurationMenu);\n}break;\n```"]