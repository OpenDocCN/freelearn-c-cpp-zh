<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Controlling Physics</h1></div></div></div><p>The following topics will be covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the physics engine</li><li class="listitem" style="list-style-type: disc">Detecting collisions</li><li class="listitem" style="list-style-type: disc">Using joints</li><li class="listitem" style="list-style-type: disc">Changing gravity by using the acceleration sensor</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Introduction</h1></div></div></div><p>Physics<a id="id331" class="indexterm"/> is really important for games. Players need to simulate real-world situations. You can add physical realism to your game by using a physics engine. As you know, there are two famous physics engines: Box2D and Chipmunk. In Cocos2d-x version 2.x, you have to use these physics engines. However, it is pretty difficult to use them. Since Cocos2d-x version 3.x, Cocos2d-x has a useful physics engine wrapped in Chipmunk. Therefore, the physics engine is no longer a concern for us as it is scalable and CPU friendly. In this chapter, you will learn how to use the physics engine easily in your game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec74"/>Using the physics engine</h1></div></div></div><p>What should you do when you <a id="id332" class="indexterm"/>realize that your game needs to simulate real-world situations? You know that the answer is to use a physics engine. When you start using a physics engine, you have to use some new classes and methods. In this recipe, you will learn how to use the basic physics engine in Cocos2d-x.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec202"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you have to create the physics world in your scene. You can create it by using the following code:<div><pre class="programlisting">Scene* HelloWorld::createScene()
{
    auto scene = Scene::createWithPhysics();
    auto layer = HelloWorld::create();
    scene-&gt;addChild(layer);
	return scene;
}</pre></div></li><li class="listitem">Next, you have to<a id="id333" class="indexterm"/> add the physics bodies in the physics world. A physics body is not visible. It is a physical shape such as a square or a circle or a more complex shape. Here, let's create a square shape. You have to create it and set it to the sprite to be visible.<div><pre class="programlisting">bool HelloWorld::init()
{
    if ( !Layer::init() )
    {
        return false;
    }
    Size visibleSize = Director::getInstance()-&gt;getVisibleSize();
    Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();

    auto wall = Node::create();
    auto wallBody = PhysicsBody::createEdgeBox(visibleSize, 
PhysicsMaterial(0.1f, 1.0f, 0.0f)); 
    wall-&gt;setPhysicsBody(wallBody);
    wall-&gt;setPosition(Vec2(visibleSize.width/2+origin.x, 
VisibleSize.height/2+origin.y));
    addChild(wall);

    auto sprite = Sprite::create("CloseNormal.png");
    sprite-&gt;setPosition(visibleSize/2);
    auto physicsBody = PhysicsBody::createCircle(sprite-
&gt;getContentSize().width/2);
    physicsBody-&gt;setDynamic(true); 
    sprite-&gt;setPhysicsBody(physicsBody);
    this-&gt;addChild(sprite);

    return true;
}</pre></div></li><li class="listitem">Finally, you have to run the preceding code. You can then see the sprite falling and bouncing on the ground.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec203"/>How it works...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you have to create the physics world in the scene by using the <code class="literal">Scene::createWithPhysics</code> method. In this way, you can use the physics engine in your game.</li><li class="listitem">Next, you have to create the wall upside down and from the left to the right on the screen edge. If you remove this wall and run the code, the sprite object will be falling forever. You can create an edge box by using the <code class="literal">PhysicsBody::createEdgeBox</code> method with this size and material setting. In this case, the <a id="id334" class="indexterm"/>wall will be of the same size as the screen. The material setting is specified as <code class="literal">PhysicsMaterial(0.1f, 1.0f, 0.0f)</code>. This means that the density is <code class="literal">1.0f</code>, restitution is <code class="literal">1.0f</code>, and friction is <code class="literal">0.0f</code>. Let's try to change this parameter and check it in the given situation.</li><li class="listitem">Finally, you can create the physics body with the sprite. In this case, the sprite is circular in shape. So, you need to use the <code class="literal">PhysicsBody::createCircle</code> method to create the circular physics body. Then, add the physics body to the sprite by using the <code class="literal">Sprite::setPhysicsBody</code> method.</li><li class="listitem">Cocos2d-x has a lot of physics body shapes as listed in the following table:</li></ol></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Shape</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>PhysicsShapeCircle</p>
</td><td style="text-align: left" valign="top">
<p>Solid circle shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhysicsShapePolygon</p>
</td><td style="text-align: left" valign="top">
<p>Solid polygon shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhysicsShapeBox</p>
</td><td style="text-align: left" valign="top">
<p>Solid box shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhysicsShapeEdgeSegment</p>
</td><td style="text-align: left" valign="top">
<p>Segment shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhysicsShapeEdgePolygon</p>
</td><td style="text-align: left" valign="top">
<p>Hollow polygon shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhysicsShapeEdgeBox</p>
</td><td style="text-align: left" valign="top">
<p>Hollow box shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhysicsShapeEdgeChain</p>
</td><td style="text-align: left" valign="top">
<p>To connect many edges </p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec204"/>There's more…</h2></div></div></div><p>Then, you can get a <code class="literal">PhysicsWorld</code> instance by using the <code class="literal">Scene::getPhysicsWorld</code> method. In this recipe, we set <code class="literal">PhysicsWorld::DEBUGDRAW_ALL</code> to the physics world. That's why you can see that the edges of all physics objects are red lines. When you release your game, you will have to remove this setting.</p><div><pre class="programlisting">Scene* HelloWorld::createScene()
{
    auto scene = Scene::createWithPhysics();
    auto layer = HelloWorld::create();
    scene-&gt;addChild(layer);
    
    PhysicsWorld* world = scene-&gt;getPhysicsWorld();
    world-&gt;setDebugDrawMask(PhysicsWorld::DEBUGDRAW_ALL);

    return scene;
}</pre></div><div><img src="img/B0561_09_01.jpg" alt="There's more…"/></div><p>Further, you can set the <a id="id335" class="indexterm"/>original gravity value to <code class="literal">PhysicsWorld</code>. For example, you can change the gravity when the device was tilted. The following code is how to change the gravity:</p><div><pre class="programlisting">PhysicsWorld* world = scene-&gt;getPhysicsWorld();
auto gravity = Vec2(0, 98.0f);
world-&gt;setGravity(gravity);</pre></div><p>The above code is against the force of the earth's gravity. The default gravity value is <code class="literal">Vec2(0, -98.0f)</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Detecting collisions</h1></div></div></div><p>When a collision<a id="id336" class="indexterm"/> between physics objects occurs, you want to take action against the physics bodies, for example, showing an explosion and showing a particle. In this recipe, you learn how to detect a collision in the physics world.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec205"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you have to<a id="id337" class="indexterm"/> create the event listener in the <code class="literal">init</code> method as follows:<div><pre class="programlisting">auto contactListener = 
EventListenerPhysicsContact::create();
contactListener-&gt;onContactBegin = [](PhysicsContact&amp; contact){
    CCLOG("contact begin");
    auto shapeA = contact.getShapeA();
    auto bodyA = shapeA-&gt;getBody();
        
    auto shapeB = contact.getShapeB();
    auto bodyB = shapeB-&gt;getBody();
    return true;
};
this-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(contactListener, this);</pre></div></li><li class="listitem">Next, you have to set the contact test bit mask to the physics bodies that you want to check the collisions for. In this recipe, you set the wall body and the sprite body as follows:<div><pre class="programlisting">auto wallBody = PhysicsBody::createEdgeBox(visibleSize, PhysicsMaterial(0.1f, 1.0f, 0.0f)); 
wallBody-&gt;setContactTestBitmask(1);

auto physicsBody = PhysicsBody::createCircle(sprite-&gt;getContentSize().width/2);
physicsBody-&gt;setContactTestBitmask(1);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec206"/>How it works...</h2></div></div></div><p>You can detect a collision in the physics world by using the <code class="literal">EventListenerPhysicsContact</code> class. It will receive all the contact callbacks in the physics world. If you set the <code class="literal">onContactBegin</code> method in this listener, you can catch the collision of the physics bodies. You can get two physics shapes from the parameter's <code class="literal">PhysicsContact</code> instance in the <code class="literal">onContactBegin</code> method by using the <code class="literal">getShapeA</code>, <code class="literal">getShapeB</code>, and <code class="literal">getBody</code> method as follows:</p><div><pre class="programlisting">contactListener-&gt;onContactBegin = [](PhysicsContact&amp; contact){
    CCLOG("contact begin");
    auto shapeA = contact.getShapeA();
    auto bodyA = shapeA-&gt;getBody();
        
    auto shapeB = contact.getShapeB();
    auto bodyB = shapeA-&gt;getBody();
    return true;
};</pre></div><p>The <code class="literal">onContactBegin</code> method<a id="id338" class="indexterm"/> returns true or false. If it returns true, the two physics bodies will collide. If it returns false, there will not be a collision response. So, you decide to check the type of collision  of the two bodies any way.</p><p>The <code class="literal">setContactTestBitmask</code> method has a parameter to contact the test bit mask. This mask defines which categories of bodies cause intersection notifications with this physics body. When two bodies share the same space, each body's category mask is tested against the other body's contact mask by performing a logical AND operation. If either comparison results in a non-zero value, the <code class="literal">PhysicsContact</code> object is created and passed to the physics world's delegate. For best performance, only set bits in the contacts mask for the interactions you need. The bitmask is an integer number. The default value is <code class="literal">0x00000000</code> (all bits cleared). </p><p>
<code class="literal">PhysicsContact</code> has some other<a id="id339" class="indexterm"/> events as listed in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Event</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onContactBegin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called when two shapes start to contact</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onContactPreSolve</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Two shapes are touching</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onContactPostSolve</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Two shapes' collision responses have been processed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onContactSeparate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called when two shapes separate</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Using joints</h1></div></div></div><p>Joints are used to connect<a id="id340" class="indexterm"/> two physics bodies to each other. Then, you can create a complex shape to join some shapes. In addition, you can create objects such as a gear or a motor to use joints. Cocos2d-x has many different types of joints. In this recipe, we explain a typical joint type.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec207"/>Getting ready</h2></div></div></div><p>You will create a method that creates a physics object. That's why you have to create multiple physics objects. This method is called<a id="id341" class="indexterm"/> <strong>makeSprite</strong>. You have to add the following code in <code class="literal">HelloWorld.h</code>:</p><div><pre class="programlisting">cocos2d::Sprite* makeSprite();</pre></div><p>You have to add the following code in <code class="literal">HelloWorld.cpp</code>:</p><div><pre class="programlisting">Sprite* HelloWorld::makeSprite()
{
    auto sprite = Sprite::create("CloseNormal.png");
    auto physicsBody = PhysicsBody::createCircle(sprite-&gt;getContentSize().width/2);
    physicsBody-&gt;setDynamic(true);
    physicsBody-&gt;setContactTestBitmask(true);
    sprite-&gt;setPhysicsBody(physicsBody);
    return sprite;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec208"/>How to do it...</h2></div></div></div><p>In this recipe, we<a id="id342" class="indexterm"/> explain <code class="literal">PhysicsJointGear</code>. This joint works to keep the angular velocity ratio of a pair of bodies.</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you have to add the following code in <code class="literal">HelloWorld.h</code>:<div><pre class="programlisting">void onEnter();
cocos2d::DrawNode* _drawNode;
cocos2d::PhysicsWorld* _world;</pre></div></li><li class="listitem">Secondly, you have to add the <code class="literal">onEnter</code> method to create a gear joint by using two physics objects and the <code class="literal">PhysicsJointGear</code> class in <code class="literal">HelloWorld.cpp</code>:<div><pre class="programlisting">void HelloWorld::onEnter()
{
    Layer::onEnter();

    Size visibleSize = Director::getInstance()-&gt;getVisibleSize();
    Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();

    _world = Director::getInstance()-&gt;getRunningScene()-&gt;getPhysicsWorld();

    // wall
    auto wall = Node::create();
    auto wallBody = PhysicsBody::createEdgeBox(visibleSize, PhysicsMaterial(0.1f, 1.0f, 0.0f));
    wallBody-&gt;setContactTestBitmask(true);
    wall-&gt;setPhysicsBody(wallBody);
    wall-&gt;setPosition(Vec2(visibleSize.width/2+origin.x, visibleSize.height/2+origin.y));
    addChild(wall);

    // gear object 1
    auto sp1 = this-&gt;makeSprite();
    sp1-&gt;setPosition(visibleSize/2);
    this-&gt;addChild(sp1);
    // gear object 2
   auto sp2 = this-&gt;makeSprite();
    sp2-&gt;setPosition(Vec2(visibleSize.width/2+2, visibleSize.height));
    this-&gt;addChild(sp2);

    // joint: gear
    auto body1 = sp1-&gt;getPhysicsBody();
    auto body2 = sp2-&gt;getPhysicsBody();
    auto pin1 = PhysicsJointPin::construct(body1, wallBody, sp1-&gt;getPosition());  
    _world-&gt;addJoint(pin1);
    auto pin2 = PhysicsJointPin::construct(body2, wallBody, sp2-&gt;getPosition());
    _world-&gt;addJoint(pin2);
    auto joint = PhysicsJointGear::construct(body1, body2, 0.0f, 2.0f);
    _world-&gt;addJoint(joint);
}</pre></div></li><li class="listitem">Next, you have<a id="id343" class="indexterm"/> to be able to touch physics objects. Add in <code class="literal">HellowWorld.h</code>, the following code:<div><pre class="programlisting">bool onTouchBegan(cocos2d::Touch* touch, cocos2d::Event* event);
void onTouchMoved(cocos2d::Touch* touch, cocos2d::Event* event);
void onTouchEnded(cocos2d::Touch* touch, cocos2d::Event* event);
cocos2d::Node* _touchNode;</pre></div><p>Then, add to the <code class="literal">HelloWorld::onEnter</code> method in <code class="literal">HelloWorld.cpp</code>, the following code:</p><div><pre class="programlisting">auto touchListener = EventListenerTouchOneByOne::create();
touchListener-&gt;onTouchBegan = CC_CALLBACK_2(HelloWorld::onTouchBegan, this);
touchListener-&gt;onTouchMoved = CC_CALLBACK_2(HelloWorld::onTouchMoved, this);
touchListener-&gt;onTouchEnded = CC_CALLBACK_2(HelloWorld::onTouchEnded, this);
_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, this);</pre></div></li><li class="listitem">Next, you write the executing codes in three touch methods as follows:<div><pre class="programlisting">bool HelloWorld::onTouchBegan(Touch* touch, Event* event)
{
    auto location = touch-&gt;getLocation();
    auto shapes = _world-&gt;getShapes(location);
    if (shapes.size()&lt;=0) {
        return false;
	}
    PhysicsShape* shape = shapes.front();
    PhysicsBody* body = shape-&gt;getBody();
    if (body != nullptr) {
        _touchNode = Node::create();
        auto touchBody = PhysicsBody::create(PHYSICS_INFINITY, PHYSICS_INFINITY);
        _touchNode-&gt;setPhysicsBody(touchBody);
        _touchNode-&gt;getPhysicsBody()-&gt;setDynamic(false);
        _touchNode-&gt;setPosition(location);
        this-&gt;addChild(_touchNode);
        PhysicsJointPin* joint = PhysicsJointPin::construct(touchBody, body, location);
        joint-&gt;setMaxForce(5000.0f * body-&gt;getMass());
        _world-&gt;addJoint(joint);
        return true;
    }
    return false;
}

void HelloWorld::onTouchMoved(Touch* touch, Event* event)
{
    if (_touchNode!=nullptr) {
        _touchNode-&gt;setPosition(touch-&gt;getLocation());
    }
}

void HelloWorld::onTouchEnded(Touch* touch, Event* event)
{
    if (_touchNode!=nullptr) {
        _touchNode-&gt;removeFromParent();
        _touchNode = nullptr;
    }
}</pre></div></li><li class="listitem">Finally, you will <a id="id344" class="indexterm"/>run and test the gear joint by touching the physics objects.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec209"/>How it works...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you have to fix gear objects on the wall, as gear objects will drop to the floor if they are not fixed. To fix them, you use the <code class="literal">PhysicsJointPin</code> class.<div><pre class="programlisting">auto pin1 = PhysicsJointPin::construct(body1, wallBody, sp1-&gt;getPosition());</pre></div></li><li class="listitem">Next, you create a gear joint by using the <code class="literal">PhysicsJointGear</code> class. In the <code class="literal">PhysicsJointGear::construct</code> method, you specify two physics bodies, namely phase value and ratio value. The phase value is the initial angular offset of the two bodies. The ratio value is the gear ratio. If the ratio value is <code class="literal">2.0f</code>, one axis will be rotated twice and the other axis will be rotated once.<div><pre class="programlisting">auto joint = PhysicsJointGear::construct(body1, body2, 0.0f, 2.0f);
_world-&gt;addJoint(joint);</pre></div></li><li class="listitem">You were able to create the gear joint in Step 2. However, you cannot move this gear. That's why you enable the touching of the screen and the moving of the physics objects. In the <code class="literal">onTouchBegan</code> method, we check the physics object in the touch<a id="id345" class="indexterm"/> area. If the object didn't exist in the touch location, it returns <code class="literal">false</code>.<div><pre class="programlisting">auto location = touch-&gt;getLocation();
auto shapes = _world-&gt;getShapes(location);
if (shapes.size()&lt;=0) {
    return false;
}</pre></div></li><li class="listitem">If the object existed in the touch location, get the physics body from the physics shape. Then, create a node on the touch location and add a physics body to this node. This node is used in the <code class="literal">onTouchMoved</code> method.<div><pre class="programlisting">PhysicsShape* shape = shapes.front();
PhysicsBody* body = shape-&gt;getBody();
if (body != nullptr) {
    _touchNode = Node::create();
    auto touchBody = PhysicsBody::create(PHYSICS_INFINITY, PHYSICS_INFINITY);
    _touchNode-&gt;setPhysicsBody(touchBody);
    _touchNode-&gt;getPhysicsBody()-&gt;setDynamic(false);
    _touchNode-&gt;setPosition(location);
    this-&gt;addChild(_touchNode);</pre></div></li><li class="listitem">To add force to this object, add <code class="literal">PhysicsJointPin</code> by using <code class="literal">touchBody</code> and the touch <code class="literal">location</code>. Then, set the force by using the <code class="literal">setMaxForce</code> method.<div><pre class="programlisting">PhysicsJointPin* joint = PhysicsJointPin::construct(touchBody, body, location);
joint-&gt;setMaxForce(5000.0f * body-&gt;getMass());
_world-&gt;addJoint(joint);</pre></div></li><li class="listitem">In the <code class="literal">onTouchMoved</code> method, move the touch node as follows:<div><pre class="programlisting">void HelloWorld::onTouchMoved(Touch* touch, Event* event)
{
    if (_touchNode!=nullptr) {
        _touchNode-&gt;setPosition(touch-&gt;getLocation());
    }
}</pre></div></li><li class="listitem">In the <code class="literal">onTouchEnded</code> method, remove the touch node as follows:<div><pre class="programlisting">void HelloWorld::onTouchEnded(Touch* touch, Event* event)
{
    if (_touchNode!=nullptr) {
        _touchNode-&gt;removeFromParent();
        _touchNode = nullptr;
    }}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec210"/>There's more…</h2></div></div></div><p>Cocos2d-x has a lot of joints. Each<a id="id346" class="indexterm"/> joint has a different task as given in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Joint</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointFixed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A fixed <a id="id347" class="indexterm"/>joint connects the two bodies together at a reference point. Fixed joints are useful for creating complex shapes that can be broken apart later.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointLimit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A limit joint<a id="id348" class="indexterm"/> imposes the maximum distance between the two bodies.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointPin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allowing<a id="id349" class="indexterm"/> two bodies to independently rotate around the pin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointDistance</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Jointing <a id="id350" class="indexterm"/>two bodies with a fixed distance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointSpring</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Connecting<a id="id351" class="indexterm"/> two bodies with a spring</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointRotarySpring</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like a <a id="id352" class="indexterm"/>spring joint which rotates</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointRotaryLimit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like a<a id="id353" class="indexterm"/> limit joint which rotates</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointRatchet</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Like a<a id="id354" class="indexterm"/> socket wrench</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointGear</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Keeps <a id="id355" class="indexterm"/>the angular velocity ratio of a pair of bodies</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PhysicsJointMotor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Keeps the<a id="id356" class="indexterm"/> relative angular velocity of a pair of bodies</p>
</td></tr></tbody></table></div><p>This is difficult to explain by text. So, you should check the cpp-tests application that was provided by Cocos2d-x. You run the cpp-tests application and select <code class="literal">Node::Physics</code> from the menu. You can check the following image:</p><div><img src="img/B0561_09_02.jpg" alt="There's more…"/></div><p>Then, you can touch or <a id="id357" class="indexterm"/>drag these physics objects, so, you can see each joint's working. </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Changing gravity by using the acceleration sensor</h1></div></div></div><p>A game with a <a id="id358" class="indexterm"/>physics engine will often change the direction<a id="id359" class="indexterm"/> of gravity by tilting the device. By doing so, it is possible to add realism in the game. In this recipe, you can change the direction of gravity by using an acceleration sensor.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec211"/>Getting ready</h2></div></div></div><p>To avoid screen rotation, you have to change some code and settings. Firstly, you should set <strong>Device Orientation</strong> to only <strong>Landscape Right</strong> as shown in the following image:</p><div><img src="img/B0561_09_03.jpg" alt="Getting ready"/></div><p>Secondly, you change the <code class="literal">shouldAutorotate</code> method's return value to false in <code class="literal">RootViewController.mm</code>.</p><div><pre class="programlisting">- (BOOL) shouldAutorotate {
    return NO;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec212"/>How to do it...</h2></div></div></div><p>You check the <a id="id360" class="indexterm"/>acceleration sensor value in <code class="literal">HelloWorld.cpp</code> as follows:</p><div><pre class="programlisting">Device::setAccelerometerEnabled(true);
auto listener = EventListenerAcceleration::create([=](Acceleration* acc, Event* event){
    auto gravity = Vec2(acc-&gt;x*100.0f, acc-&gt;y*100.0f);
    world-&gt;setGravity(gravity);
});
this-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, this);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec213"/>How it works...</h2></div></div></div><p>If you tilt the <a id="id361" class="indexterm"/>device, you can get the changing acceleration <code class="literal">x</code> and <code class="literal">y</code> values. At this time, we have 100 times the value of the x-axis and y-axis. That's why the value of acceleration is pretty small for using gravity.</p><div><pre class="programlisting">auto gravity = Vec2(acc-&gt;x*100.0f, acc-&gt;y*100.0f);</pre></div><p>While rotating the device, the home button is at the right, then it is the home position. At this time, the acceleration y value is negative. While rotating, if the home button is at the left side; the acceleration y value is positive. While rotating, if it is in the portrait position, then the acceleration x value is positive. Or, while rotating, if it is upside down, then the acceleration x value is negative. Then, to change gravity by using the acceleration sensor value, you can realize real gravity in your game.</p></div></div></body></html>