["```cpp\n    numeric_expr := number\n    ```", "```cpp\n    paran_expr := '(' expression ')'\n    ```", "```cpp\n    identifier_expr\n    := identifier\n    := identifier '('expr_list ')'\n    ```", "```cpp\n    expr_list\n    := (empty)\n    := expression (',' expression)*\n    ```", "```cpp\n    primary := identifier_expr\n    :=numeric_expr\n    :=paran_expr\n    ```", "```cpp\n    expression := primary binoprhs\n    ```", "```cpp\n    binoprhs := ( binoperator primary )*\n    binoperators := '+'/'-'/'*'/'/'\n    ```", "```cpp\n    func_decl := identifier '(' identifier_list ')'\n    identifier_list := (empty)\n                            := (identifier)*\n    ```", "```cpp\n    function_defn := 'def' func_decl expression\n    ```", "```cpp\n    toplevel_expr := expression  \n    ```", "```cpp\ndef foo (x , y)\nx +y * 16\n```", "```cpp\n$ vim toy.cpp\n```", "```cpp\n    $ vim toy.cpp\n    ```", "```cpp\n    enum Token_Type {\n    EOF_TOKEN = 0,\n    NUMERIC_TOKEN,\n    IDENTIFIER_TOKEN,\n    PARAN_TOKEN,\n    DEF_TOKEN\n    };\n    ```", "```cpp\n    static int Numeric_Val;\n    ```", "```cpp\n        static std::string Identifier_string;\n    ```", "```cpp\n    static int get_token() {\n      static int LastChar = ' ';\n\n      while(isspace(LastChar))\n      LastChar = fgetc(file);\n\n      if(isalpha(LastChar)) {\n        Identifier_string = LastChar;\n        while(isalnum((LastChar = fgetc(file))))\n        Identifier_string += LastChar;\n\n        if(Identifier_string == \"def\")\n        return DEF_TOKEN;\n        return IDENTIFIER_TOKEN;\n      }\n\n      if(isdigit(LastChar)) {\n        std::string NumStr;\n        do {\n          NumStr += LastChar;\n          LastChar = fgetc(file);\n        } while(isdigit(LastChar));\n\n        Numeric_Val = strtod(NumStr.c_str(), 0);\n        return NUMERIC_TOKEN;\n      }\n\n      if(LastChar == '#') {\n        do LastChar = fgetc(file);\n        while(LastChar != EOF && LastChar != '\\n'\n        && LastChar != '\\r');\n\n        if(LastChar != EOF) return get_token();\n      }\n\n      if(LastChar == EOF) return EOF_TOKEN;\n\n      int ThisChar = LastChar;\n      LastChar = fgetc(file);\n      return ThisChar;\n    }\n    ```", "```cpp\ndef foo (x , y)\nx + y * 16\n```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    class BaseAST {\n      public :\n      virtual ~BaseAST();\n    };\n    ```", "```cpp\n    class VariableAST  : public BaseAST{\n      std::string Var_Name;  \n    // string object to store name of\n    // the variable.\n      public:\n      VariableAST (std::string &name) : Var_Name(name) {}  // ..// parameterized constructor of variable AST class to be initialized with the string passed to the constructor.\n    };\n    ```", "```cpp\n    class NumericAST : public BaseAST {\n      int numeric_val;\n      public :\n      NumericAST (intval) :numeric_val(val)  {}\n    };\n    ```", "```cpp\n    Class BinaryAST : public BaseAST {\n      std::string Bin_Operator;  // string object to store\n      // binary operator\n      BaseAST  *LHS, *RHS;  // Objects used to store LHS and   \n    // RHS of a binary Expression. The LHS and RHS binary   \n    // operation can be of any type, hence a BaseAST object \n    // is used to store them.\n      public:\n      BinaryAST (std::string op, BaseAST *lhs, BaseAST *rhs ) :\n      Bin_Operator(op), LHS(lhs), RHS(rhs) {}  // Constructor\n      //to initialize binary operator, lhs and rhs of the binary\n      //expression.\n    };\n    ```", "```cpp\n    class FunctionDeclAST {\n      std::string Func_Name;\n      std::vector<std::string> Arguments;\n      public:\n      FunctionDeclAST(const std::string &name, const       std::vector<std::string> &args) :\n      Func_Name(name), Arguments(args) {};\n    };\n    ```", "```cpp\n    class FunctionDefnAST {\n      FunctionDeclAST *Func_Decl;\n      BaseAST* Body;\n      public:\n      FunctionDefnAST(FunctionDeclAST *proto, BaseAST *body) :\n      Func_Decl(proto), Body(body) {}\n    };\n    ```", "```cpp\n    class FunctionCallAST : public BaseAST {\n      std::string Function_Callee;\n      std::vector<BaseAST*> Function_Arguments;\n      public:\n      FunctionCallAST(const std::string &callee, std::vector<BaseAST*> &args) :\n      Function_Callee(callee), Function_Arguments(args) {}\n    };\n    ```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    static int Current_token;\n    ```", "```cpp\n    static void next_token() {\n      Current_token =  get_token();\n    }\n    ```", "```cpp\n    static BaseAST* Base_Parser() {\n      switch (Current_token) {\n        default: return 0;\n        case IDENTIFIER_TOKEN : return identifier_parser();\n        case NUMERIC_TOKEN : return numeric_parser();\n        case '(' : return paran_parser();\n      }\n    }\n    ```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    static BaseAST *numeric_parser() {\n      BaseAST *Result = new NumericAST(Numeric_Val);\n      next_token();\n      return Result;\n    }\n    ```", "```cpp\n    static BaseAST* identifier_parser() {\n      std::string IdName = Identifier_string;\n\n      next_token();\n\n      if(Current_token != '(')\n      return new VariableAST(IdName);\n\n      next_token();\n\n      std::vector<BaseAST*> Args;\n      if(Current_token != ')') {\n        while(1) {\n          BaseAST* Arg = expression_parser();\n          if(!Arg) return 0;\n          Args.push_back(Arg);\n\n          if(Current_token == ')') break;\n\n          if(Current_token != ',')\n          return 0;\n          next_token();\n        }\n      }\n      next_token();\n\n      return new FunctionCallAST(IdName, Args);\n    }\n    ```", "```cpp\n    static FunctionDeclAST *func_decl_parser() {\n      if(Current_token != IDENTIFIER_TOKEN)\n      return 0;\n\n      std::string FnName = Identifier_string;\n      next_token();\n\n      if(Current_token != '(')\n      return 0;\n\n      std::vector<std::string> Function_Argument_Names;\n      while(next_token() == IDENTIFIER_TOKEN)\n      Function_Argument_Names.push_back(Identifier_string);\n      if(Current_token != ')')\n      return 0;\n\n      next_token();\n\n      return new FunctionDeclAST(FnName, Function_Argument_Names);\n    }\n    ```", "```cpp\n    static FunctionDefnAST *func_defn_parser() {\n      next_token();\n      FunctionDeclAST *Decl = func_decl_parser();\n      if(Decl == 0) return 0;\n\n      if(BaseAST* Body = expression_parser())\n      return new FunctionDefnAST(Decl, Body);\n      return 0;\n    }\n    ```", "```cpp\n    static BaseAST* expression_parser() {\n      BaseAST *LHS = Base_Parser();\n      if(!LHS) return 0;\n      return binary_op_parser(0, LHS);\n    }\n    ```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    static std::map<char, int>Operator_Precedence;\n    ```", "```cpp\n    static void init_precedence() {\n      Operator_Precedence['-'] = 1;\n      Operator_Precedence['+'] = 2;\n      Operator_Precedence['/'] = 3;\n      Operator_Precedence['*'] = 4;\n    }\n    ```", "```cpp\n    static int getBinOpPrecedence() {\n      if(!isascii(Current_token))\n    return -1;\n\n      int TokPrec = Operator_Precedence[Current_token];\n      if(TokPrec <= 0) return -1;\n      return TokPrec;\n    }\n    ```", "```cpp\n    static BaseAST* binary_op_parser(int Old_Prec, BaseAST *LHS) {\n      while(1) {\n        int Operator_Prec = getBinOpPrecedence();\n\n        if(Operator_Prec < Old_Prec)\n        return LHS;\n\n        int BinOp = Current_token;\n        next_token();\n\n        BaseAST* RHS = Base_Parser();\n        if(!RHS) return 0;\n\n        int Next_Prec = getBinOpPrecedence();\n        if(Operator_Prec < Next_Prec) {\n          RHS = binary_op_parser(Operator_Prec+1, RHS);\n          if(RHS == 0) return 0;\n        }\n\n        LHS = new BinaryAST(std::to_string(BinOp), LHS, RHS);\n      }\n    }\n    ```", "```cpp\n    static BaseAST* paran_parser() {\n      next_token();\n      BaseAST* V = expression_parser();\n      if (!V) return 0;\n\n      if(Current_token != ')')\n        return 0;\n      return V;\n    }\n    ```", "```cpp\n    static void HandleDefn() {\n      if (FunctionDefnAST *F = func_defn_parser()) {\n        if(Function* LF = F->Codegen()) {\n      }\n      }\n      else {\n        next_token();\n      }\n    }\n\n    static void HandleTopExpression() {\n      if(FunctionDefnAST *F = top_level_parser()) {\n        if(Function *LF = F->Codegen()) {\n      }\n      }\n      else {\n        next_token();\n      }\n    }\n    ```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    static void Driver() {\n      while(1) {\n        switch(Current_token) {\n        case EOF_TOKEN : return;\n        case ';' : next_token(); break;\n        case DEF_TOKEN : HandleDefn(); break;\n        default : HandleTopExpression(); break;\n      }\n      }\n    }\n    ```", "```cpp\n    int main(int argc, char* argv[]) {\n      LLVMContext &Context = getGlobalContext();\n      init_precedence();\n      file = fopen(argv[1], \"r\");\n      if(file == 0) {\n        printf(\"Could not open file\\n\");\n      }\n      next_token();\n      Module_Ob = new Module(\"my compiler\", Context);\n      Driver();\n      Module_Ob->dump();\n          return 0;\n    }\n    ```", "```cpp\n    $ clang++ toy.cpp  -O3 -o toy\n    ```", "```cpp\n    $ cat example\n    def foo(x , y)\n    x + y * 16\n    ```", "```cpp\n    $ ./toy example\n    ```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    class BaseAST {\n      …\n      …\n      virtual Value* Codegen() = 0;\n    };\n    class NumericAST : public BaseAST {\n      …\n      …\n      virtual Value* Codegen();\n    };\n    class VariableAST : public BaseAST {\n      …\n      …\n      virtual Value* Codegen();\n    };\n    ```", "```cpp\n    static Module *Module_Ob;\n    static IRBuilder<> Builder(getGlobalContext());\n    static std::map<std::string, Value*>Named_Values;\n    ```", "```cpp\n    $ vi toy.cpp\n    ```", "```cpp\n    Value *NumericAST::Codegen() {\n      return ConstantInt::get(Type::getInt32Ty(getGlobalContext()), numeric_val);\n    }\n    ```", "```cpp\n    Value *VariableAST::Codegen() {\n      Value *V = Named_Values[Var_Name];\n      return V ? V : 0;\n    }\n    ```", "```cpp\n    Value *BinaryAST::Codegen() {\n      Value *L = LHS->Codegen();\n      Value *R = RHS->Codegen();\n      if(L == 0 || R == 0) return 0;\n\n      switch(atoi(Bin_Operator.c_str())) {\n        case '+' : return Builder.CreateAdd(L, R, \"addtmp\");\n        case '-' : return Builder.CreateSub(L, R, \"subtmp\");\n        case '*' : return Builder.CreateMul(L, R, \"multmp\");\n        case '/' : return Builder.CreateUDiv(L, R, \"divtmp\");\n        default : return 0;\n      }\n    }\n    ```", "```cpp\n    Value *FunctionCallAST::Codegen() {\n      Function *CalleeF =\n      Module_Ob->getFunction(Function_Callee);\n      std::vector<Value*>ArgsV;\n      for(unsigned i = 0, e = Function_Arguments.size();\n      i != e; ++i) {\n        ArgsV.push_back(Function_Arguments[i]->Codegen());\n        if(ArgsV.back() == 0) return 0;\n      }\n      return Builder.CreateCall(CalleeF, ArgsV, \"calltmp\");\n    }\n    ```", "```cpp\n    Function *FunctionDeclAST::Codegen() {\n      std::vector<Type*>Integers(Arguments.size(), Type::getInt32Ty(getGlobalContext()));\n      FunctionType *FT = FunctionType::get(Type::getInt32Ty(getGlobalContext()), Integers, false);\n      Function *F = Function::Create(FT,  Function::ExternalLinkage, Func_Name, Module_Ob);\n\n      if(F->getName() != Func_Name) {\n        F->eraseFromParent();\n        F = Module_Ob->getFunction(Func_Name);\n\n        if(!F->empty()) return 0;\n\n        if(F->arg_size() != Arguments.size()) return 0;\n\n      }\n\n      unsigned Idx = 0;\n      for(Function::arg_iterator Arg_It = F->arg_begin(); Idx != Arguments.size(); ++Arg_It, ++Idx) {\n        Arg_It->setName(Arguments[Idx]);\n        Named_Values[Arguments[Idx]] = Arg_It;\n      }\n\n      return F;\n    }\n    ```", "```cpp\n    Function *FunctionDefnAST::Codegen() {\n      Named_Values.clear();\n\n      Function *TheFunction = Func_Decl->Codegen();\n      if(TheFunction == 0) return 0;\n\n      BasicBlock *BB = BasicBlock::Create(getGlobalContext(),\"entry\", TheFunction);\n      Builder.SetInsertPoint(BB);\n\n      if(Value *RetVal = Body->Codegen()) {\n        Builder.CreateRet(RetVal);\n        verifyFunction(*TheFunction);\n        return TheFunction;\n      }\n\n      TheFunction->eraseFromParent();\n      return 0;\n    }\n    ```", "```cpp\n    static void HandleDefn() {\n      if (FunctionDefnAST *F = func_defn_parser()) {\n        if(Function* LF = F->Codegen()) {\n        }\n      }\n      else {\n        next_token();\n      }\n    }\n    static void HandleTopExpression() {\n      if(FunctionDefnAST *F = top_level_parser()) {\n        if(Function *LF = F->Codegen()) {\n        }\n      }\n      else {\n        next_token();\n      }\n    }\n    ```", "```cpp\n    llvm-config  --cxxflags  --ldflags  --system-libs  --libs core.\n    ```", "```cpp\n    $ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n\n    ```", "```cpp\n    $ ./toy example\n\n    define i32 @foo (i32 %x, i32 %y) {\n      entry:\n      %multmp = muli32 %y, 16\n      %addtmp = add i32 %x, %multmp\n      reti32 %addtmp\n    }\n    ```", "```cpp\n    foo(5, 6);\n    ```", "```cpp\n    $ ./toy example2\n    define i32 @1 () {\n      entry:\n      %calltmp = call i32@foo(i32 5, i32 6)\n      reti32 %calltmp\n    }\n    ```", "```cpp\n    static FunctionPassManager *Global_FP;\n    ```", "```cpp\n    FunctionPassManager My_FP(TheModule);\n    ```", "```cpp\n    My_FP.add(createBasicAliasAnalysisPass());\n    My_FP.add(createInstructionCombiningPass());\n    My_FP.add(createReassociatePass());\n    My_FP.add(createGVNPass());\n    My_FP.doInitialization();\n    ```", "```cpp\n    Global_FP = &My_FP;\n    Driver();\n    ```", "```cpp\n    Function* FunctionDefnAST::Codegen() {\n      Named_Values.clear();\n      Function *TheFunction = Func_Decl->Codegen();\n      if (!TheFunction) return 0;\n      BasicBlock *BB = BasicBlock::Create(getGlobalContext(), \"entry\", TheFunction);\n      Builder.SetInsertPoint(BB);\n      if (Value* Return_Value = Body->Codegen()) {\n        Builder.CreateRet(Return_Value);\n        verifyFunction(*TheFunction);\n        Global_FP->run(*TheFunction);\n        returnTheFunction;\n      }\n      TheFunction->eraseFromParent();\n      return 0;\n    }\n    ```"]