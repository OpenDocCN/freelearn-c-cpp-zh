<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Working with Resource Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Working with Resource Files</h1></div></div></div><p>Games have a lot of resources such as images and audio files. Cocos2d-x has a management system of resources. The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Selecting resource files</li><li class="listitem" style="list-style-type: disc">Managing resource files</li><li class="listitem" style="list-style-type: disc">Using SQLite</li><li class="listitem" style="list-style-type: disc">Using .xml files</li><li class="listitem" style="list-style-type: disc">Using .plist files</li><li class="listitem" style="list-style-type: disc">Using .json files</li></ul></div><div class="section" title="Selecting resource files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Selecting resource files</h1></div></div></div><p>Your game has<a id="id290" class="indexterm"/> images of each resolution for multiresolution adaption. If you have resolved to find an image for each resolution, your application logic is very complicated. Cocos2d-x has a search path mechanism for solving this problem. In this recipe, we will explain this search path mechanism.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec163"/>Getting ready</h2></div></div></div><p>If you want to share some resources between different resolutions, then you can put all the shared resources in the <code class="literal">Resources</code> folder, and put the resolution-specified resources in different folders as shown in the following image.</p><div class="mediaobject"><img src="graphics/B00561_07_01.jpg" alt="Getting ready"/></div><p>
<code class="literal">CloseNormal.png</code> and <code class="literal">CloseSelected.png</code> are shared resources between different resolutions. However, <code class="literal">HelloWorld.png</code> is a resolution-specified resource.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec164"/>How to do it...</h2></div></div></div><p>You can set the<a id="id291" class="indexterm"/> priority to search resources for Cocos2d-x as follows:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;std::string&gt; searchPaths; 
searchPaths.push_back("ipad"); 
FileUtils::setSearchPaths(searchPaths); 
Sprite *sprite = Sprite::create("HelloWorld.png");
Sprite *close  = Sprite::create("CloseNormal.png");</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec165"/>How it works...</h2></div></div></div><p>Cocos2d-x will find <code class="literal">HelloWorld.png</code> in <code class="literal">Resources/ipad</code>. Cocos2d-x will use <code class="literal">HelloWorld.png</code> in this path; that's why it can find this resource in <code class="literal">Resources/ipad</code>. However, Cocos2d-x cannot find <code class="literal">CloseNormal.png</code> in <code class="literal">Resources/ipad</code>. It will find the <code class="literal">Resources</code> folder that is the next order path. The system can find it in the <code class="literal">Resources</code> folder and use it.</p><p>You should add this code in the <code class="literal">AppDelegate::applicationDidFinishLaunching</code> method before creating the first scene. Then, the first scene can use this search path setting.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec166"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The search path mechanism in the next recipe called <span class="emphasis"><em>Managing resource files</em></span>.</li></ul></div></div></div></div>
<div class="section" title="Managing resource files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Managing resource files</h1></div></div></div><p>Cocos2d-x has an <a id="id292" class="indexterm"/>extension that manages resources. It is called <code class="literal">AssetsManagerExtension</code>. This extension is designed for a hot update of resources such as images and audio files. You can update a new version of resources on your games by using this extension without updating your applications.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec167"/>Getting ready</h2></div></div></div><p>Before using <code class="literal">AssetsManagerExtension</code>, you should learn about it. This extension has many useful features to help you make the hot update. Some of these features are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Multithread downloading support</li><li class="listitem" style="list-style-type: disc">Two-level progression support—File-level and byte-level progression</li><li class="listitem" style="list-style-type: disc">Compressed ZIP file support</li><li class="listitem" style="list-style-type: disc">Resuming download</li><li class="listitem" style="list-style-type: disc">Detailed progression information and error information</li><li class="listitem" style="list-style-type: disc">Possibility to retry failed assets</li></ul></div><p>You have to prepare a web server, and hence, your application will download resources.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec168"/>How to do it...</h2></div></div></div><p>You need to upload resources and manifest files. In this case, we will update <code class="literal">HelloWorld.png</code> and a <code class="literal">.zip</code> file called <code class="literal">test.zip</code>. This <code class="literal">.zip</code> file includes some new images. <code class="literal">AssetsManagerExtension</code> will download resources according to the manifest files. The manifest files are <code class="literal">version.manifest</code> and <code class="literal">project.manifest</code>.</p><p>The <code class="literal">version.manifest</code> file contains the following code:</p><div class="informalexample"><pre class="programlisting">{
    "packageUrl" : "http://example.com/assets_manager/", 
    "remoteVersionUrl" : 
    "http://example.com/assets_manager/version.manifest", 
    "remoteManifestUrl" : 
    "http://example.com/assets_manager/project.manifest", 
    "version" : "1.0.1",}</pre></div><p>The <code class="literal">project.manifest</code> file contains the following code:</p><div class="informalexample"><pre class="programlisting">{
    "packageUrl" : "http://example.com/assets_manager/", 
    "remoteVersionUrl" : "http://example.com/assets_manager/version.manifest", 
    "remoteManifestUrl" : "http://example.com/assets_manager/project.manifest", 
    "version" : "1.0.1",
    "assets" : {
        "HelloWorld.png" : {
            "md5" : "b7892dc221c840550847eaffa1c0b0aa" 
        }, 
        "test.zip" : {
            "md5" : "c7615739e7a9bcd1b66e0018aff07517", 
            "compressed" : true
        }
    }
}</pre></div><p>Then, you have to<a id="id293" class="indexterm"/> upload these manifest files and new resources.</p><p>Next, you have to prepare your application for a hot update. You have to create the <code class="literal">local.manifest</code> file in your project. The local manifest file should contain the following code:</p><div class="informalexample"><pre class="programlisting">{
    "packageUrl" : "http://example.com/assets_manager/", 
    "remoteVersionUrl" : 
"http://example.com/assets_manager/version.manifest", 
    "remoteManifestUrl" : 
"http://example.com/assets_manager/project.manifest", 
    "version" : "1.0.0", 
}</pre></div><p>You should make a class that manages <code class="literal">AssetsManagerExtension</code> in your project. Here, we create a class called <code class="literal">ResourceManager</code>. Firstly, you will create a header file of <code class="literal">ResourceManager</code>. It is called <code class="literal">ResourceManager.h</code>. This file contains the following code:</p><div class="informalexample"><pre class="programlisting">#include "cocos2d.h"
#include "extensions/cocos-ext.h"

class ResourceManager {
private:
    ResourceManager();
    static ResourceManager* instance;

    cocos2d::extension::AssetsManagerEx* _am; 
    cocos2d::extension::EventListenerAssetsManagerEx* _amListener; 

public: 
    // custom event name 
    static const char* EVENT_PROGRESS; 
    static const char* EVENT_FINISHED; 

    virtual ~ResourceManager(); 
    static ResourceManager* getInstance(); 
    
    void updateAssets(std::string manifestPath); 
};</pre></div><p>The next step is <a id="id294" class="indexterm"/>to create a <code class="literal">ResourceManager.cpp</code> file. This file contains the following code:</p><div class="informalexample"><pre class="programlisting">#include "ResourceManager.h"

USING_NS_CC;
USING_NS_CC_EXT;

// custom event name
const char* ResourceManager::EVENT_PROGRESS = "__cc_Resource_Event_Progress"; 
const char* ResourceManager::EVENT_FINISHED = "__cc_Resource_Event_Finished"; 

ResourceManager* ResourceManager::instance = nullptr; 

ResourceManager::~ResourceManager() {
    CC_SAFE_RELEASE_NULL(_am);
}

ResourceManager::ResourceManager()
:_am(nullptr)
,_amListener(nullptr)
{

}

ResourceManager* ResourceManager::getInstance() { 
    if (instance==nullptr) { 
        instance = new ResourceManager(); 
    } 
     return instance; 
}

void ResourceManager::updateAssets(std::string manifestPath) 
{
    std::string storagePath = FileUtils::getInstance()- 
    &gt;getWritablePath(); 
    CCLOG("storage path = %s", storagePath.c_str()); 

    if (_am!=nullptr) { 
        CC_SAFE_RELEASE_NULL(_am); 
    } 
    _am = AssetsManagerEx::create(manifestPath, storagePath); 
    _am-&gt;retain(); 

    if (!_am-&gt;getLocalManifest()-&gt;isLoaded()) { 
        CCLOG("Fail to update assets, step skipped."); 
    } else { 
        _amListener = EventListenerAssetsManagerEx::create(_am, 
[this](EventAssetsManagerEx* event){ 
            static int failCount = 0; 
            switch (event-&gt;getEventCode()) 
            {
                case 
EventAssetsManagerEx::EventCode::ERROR_NO_LOCAL_MANIFEST: 
                { 
                    CCLOG("No local manifest file found, skip 
                    assets update.");
                    break; 
                } 
                case 
EventAssetsManagerEx::EventCode::UPDATE_PROGRESSION: 
                { 
                    std::string assetId = event-&gt;getAssetId(); 
                    float percent = event-&gt;getPercent(); 
                    std::string str; 
                    if (assetId == AssetsManagerEx::VERSION_ID) { 
                        // progress for version file
                    } else if (assetId == 
AssetsManagerEx::MANIFEST_ID) {
                        // progress for manifest file 
                    } else { 
                        // dispatch progress event 
                        CCLOG("%.2f Percent", percent); 
                        auto event = 
EventCustom(ResourceManager::EVENT_PROGRESS); 
                        auto data = Value(percent); 
                        event.setUserData(&amp;data); 
                        Director::getInstance()-&gt;getEventDispatcher()-&gt;dispatchEvent(&amp;event); 
                    } 

                    break; 
                } 
                case 
EventAssetsManagerEx::EventCode::ERROR_DOWNLOAD_MANIFEST: 
                case 
EventAssetsManagerEx::EventCode::ERROR_PARSE_MANIFEST: 

                { 
                    CCLOG("Fail to download manifest file, update 
skipped."); 
                    break; 
                } 
                case 
EventAssetsManagerEx::EventCode::ALREADY_UP_TO_DATE: 
                case 
EventAssetsManagerEx::EventCode::UPDATE_FINISHED: 
                { 
                    CCLOG("Update finished. %s", 
                    event-&gt;getMessage().c_str()); 
                    CC_SAFE_RELEASE_NULL(_am); 
                    // dispatch finished updating event 
                    Director::getInstance()-&gt;getEventDispatcher()- 
&gt;dispatchCustomEvent(ResourceManager::EVENT_FINISHED); 
                    break; 
                } 
                case 
EventAssetsManagerEx::EventCode::UPDATE_FAILED: 
                { 
                    CCLOG("Update failed. %s", event- 
&gt;getMessage().c_str()); 

                    // retry 5 times, if error occurred 
                    failCount ++; 
                    if (failCount &lt; 5) { 
                        _am-&gt;downloadFailedAssets(); 
                    } else { 
                        CCLOG("Reach maximum fail count, exit 
update process"); 
                        failCount = 0; 
                    } 
                    break; 
                } 
                case 
EventAssetsManagerEx::EventCode::ERROR_UPDATING: 
                { 
                    CCLOG("Asset %s : %s", event- 
&gt;getAssetId().c_str(), event-&gt;getMessage().c_str()); 
                    break; 
                } 
                case 
EventAssetsManagerEx::EventCode::ERROR_DECOMPRESS: 
                { 
                    CCLOG("%s", event-&gt;getMessage().c_str()); 
                    break;
                } 
                default: 
                    break;
            } 
        }); 

        // execute updating resources 
        Director::getInstance()-&gt;getEventDispatcher()- 
&gt;addEventListenerWithFixedPriority(_amListener, 1); 
        _am-&gt;update(); 
    } 
}</pre></div><p>Finally, to start<a id="id295" class="indexterm"/> updating the resource, use the following code:</p><div class="informalexample"><pre class="programlisting">// label for progress 
auto size = Director::getInstance()-&gt;getWinSize(); 
TTFConfig config("fonts/arial.ttf", 30); 
_progress = Label::createWithTTF(config, "0%", 
TextHAlignment::CENTER); 
_progress-&gt;setPosition( Vec2(size.width/2, 50) ); 
this-&gt;addChild(_progress); 

// progress event 
getEventDispatcher()- 
&gt;addCustomEventListener(ResourceManager::EVENT_PROGRESS, 
[this](EventCustom* event){ 
    auto data = (Value*)event-&gt;getUserData(); 
    float percent = data-&gt;asFloat(); 
    std::string str = StringUtils::format("%.2f", percent) + "%"; 
    CCLOG("%.2f Percent", percent); 
    if (this-&gt;_progress != nullptr) { 
        this-&gt;_progress-&gt;setString(str); 
    }
}); 

// fnished updating event 
getEventDispatcher()- 
&gt;addCustomEventListener(ResourceManager::EVENT_FINISHED, 
[this](EventCustom* event){ 
    // clear cache 
    Director::getInstance()-&gt;getTextureCache()- 
&gt;removeAllTextures(); 
    // reload scene 
    auto scene = HelloWorld::createScene(); 
    Director::getInstance()-&gt;replaceScene(scene); 
});

// update resources 
ResourceManager::getInstance()- 
&gt;updateAssets("res/local.manifest");</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec169"/>How it works...</h2></div></div></div><p>Firstly, we will <a id="id296" class="indexterm"/>explain the manifest file and the mechanism of <code class="literal">AssetsManagerExtension</code>. The manifest files are in the JSON format. Local manifest and version manifest have the following data:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Keys</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">packageUrl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The URL where the assets manager will try to request and download all the assets.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">remoteVersionUrl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The remote version manifest file URL that permits one to check the remote version to determine whether a new version has been uploaded to the server.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">remoteManifestUrl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The remote manifest file URL that contains all the asset information.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">version</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The version of this manifest file.</p>
</td></tr></tbody></table></div><p>In addition, the remote manifest has the following data in the key <a id="id297" class="indexterm"/>called assets.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Keys</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">key</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Each key represents the relative path of the asset.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Md5</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">md5</code> field represents the version information of the asset.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">compressed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When the compressed field is <code class="literal">true</code>, the downloaded file will be decompressed automatically; this key is optional.</p>
</td></tr></tbody></table></div><p>
<code class="literal">AssetsManagerExtension</code> will execute<a id="id298" class="indexterm"/> the hot update in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Read the local manifest in the application.</li><li class="listitem">Download the version manifest according to the remote version URL in the local manifest.</li><li class="listitem">Compare the version in the local manifest to the version in the version manifest.</li><li class="listitem">If both versions do not match, <code class="literal">AssetsManagerExtension</code> downloads the project manifest according to the remote manifest URL in the local manifest.</li><li class="listitem">Compare the <code class="literal">md5</code> value in the remote manifest to the <code class="literal">md5</code> of the asset in the application.</li><li class="listitem">If both <code class="literal">md5</code> values do not match, <code class="literal">AssetsManagerExtension</code> downloads this asset.</li><li class="listitem">Next time, <code class="literal">AssetsManagerExtension</code> will use the version manifest that was downloaded instead of the local manifest.</li></ol></div><p>Next, we will explain the <code class="literal">ResourceManager</code> class. You can execute the hot update as follows:</p><div class="informalexample"><pre class="programlisting">ResourceManager::getInstance()-&gt;updateAssets("res/local.manifest");</pre></div><p>You should<a id="id299" class="indexterm"/> call the <code class="literal">ResourceManager::updateAssets</code> method by specifying the path of the local manifest. <code class="literal">ResourceManager::updateAssets</code> will create an instance of <code class="literal">AssetsManagerEx</code>, which is the class name of <code class="literal">AssetsManagerExtension</code>, by specifying the path of the local manifest and the path of the storage in the application.</p><p>It will create an instance of <code class="literal">EventListenerAssetsManagerEx</code> for listening to the progress of the hot update.</p><p>If the compressed value is true, <code class="literal">AssetsManagerExtension</code> will unzip it after downloading it.</p><p>You can update assets by calling the <code class="literal">AssetsManagerEx::update</code> method. During the update, you can get the following events:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Event</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ERROR_NO_LOCAL_MANIFEST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Cannot find the local manifest. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UPDATE_PROGRESSION</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Get the progression of the update.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ERROR_DOWNLOAD_MANIFEST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Fail to download the manifest file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ERROR_PARSE_MANIFEST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Parse error for the manifest file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ALREADY_UP_TO_DATE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Already updating assets (The version in the local manifest and the version in the version manifest are equal.).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UPDATE_FINISHED</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Finished updating assets.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UPDATE_FAILED</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Error occurred during updating assets. In this case, the cause of error may be the connection. You should try to update again.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ERROR_UPDATING</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Failed to update.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ERROR_DECOMPRESS</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Error occurred during unzipping.</p>
</td></tr></tbody></table></div><p>
<code class="literal">ResourceManager</code> dispatches the event called <code class="literal">EVENT_PROGRESS</code> if it catches the event called <code class="literal">UPDATE_PROGRESSION</code>. If you catch <code class="literal">EVENT_PROGRESS</code>, you should update the progress label.</p><p>Further, it dispatches the event called <code class="literal">EVENT_FINISHED</code> if it catches the event called <code class="literal">UPDATE_FINISHED</code>. If you catch <code class="literal">EVENT_FINISHED</code>, you should refresh all textures. That's why we remove all texture caches and reload the scene.</p><div class="informalexample"><pre class="programlisting">// clear cache Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures();
// reload sceneauto scene = HelloWorld::createScene(); 
Director::getInstance()-&gt;replaceScene(scene);</pre></div></div></div>
<div class="section" title="Using SQLite"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Using SQLite</h1></div></div></div><p>You can save and load game<a id="id300" class="indexterm"/> data easily by using the database in your game. In a smartphone application, the database called SQLite is usually used. SQLite is easy to use. However, you have to set a few things before using it. In this recipe, we will explain how to set up and use SQLite in Cocos2d-x.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec170"/>Getting ready</h2></div></div></div><p>Cocos2d-x doesn't have an SQLite library. You have to add SQLite's source code to Cocos2d-x.</p><p>You need to download<a id="id301" class="indexterm"/> the source code from the site <a class="ulink" href="http://sqlite.org/download.html">http://sqlite.org/download.html</a>. The latest version at the time of writing this book is version 3.8.10. You can download this version's <code class="literal">.zip</code> file and expand it. Then, you can add the resulting files to your project as shown in the following image:</p><div class="mediaobject"><img src="graphics/B00561_07_02.jpg" alt="Getting ready"/></div><p>In this recipe, we will create an original class called <code class="literal">SQLiteManager</code>. So, you have to add the <code class="literal">SQLiteManager.h</code> and <code class="literal">SQLiteManager.cpp</code> files to your project.</p><p>Then, if you build for Android, you have to edit <code class="literal">proj.android/jni/Android.mk</code> as follows:</p><div class="informalexample"><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \ 
                   ../../Classes/AppDelegate.cpp \ 
                   ../../Classes/HelloWorldScene.cpp \ 
                   ../../Classes/SQLiteManager.cpp \ 
                   ../../Classes/sqlite/sqlite3.c</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec171"/>How to do it...</h2></div></div></div><p>First, you have to <a id="id302" class="indexterm"/>edit the <code class="literal">SQLiteManager.h</code> file as follows:</p><div class="informalexample"><pre class="programlisting">#include "cocos2d.h" #include "sqlite/sqlite3.h"

class SQLiteManager {
private:
    SQLiteManager();
    static SQLiteManager* instance;
    sqlite3 *_db;
    bool open();
    void close();
public:
    virtual ~SQLiteManager();
    static SQLiteManager* getInstance();
    void insert(std::string key, std::string value);
    std::string select(std::string key);
};</pre></div><p>Next, you have to edit the <code class="literal">SQLiteManager.cpp</code> file. This code is a little long. So, we will explain it step by step.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following code for the singleton class:<div class="informalexample"><pre class="programlisting">SQLiteManager* SQLiteManager::instance = nullptr; 
SQLiteManager::~SQLiteManager() { 
}

SQLiteManager::SQLiteManager()
{
    if (this-&gt;open()) {
        sqlite3_stmt* stmt;
        // create table 
        std::string sql = "CREATE TABLE IF NOT EXISTS 
data(key TEXT PRIMARY KEY,value TEXT);"; 
        if (sqlite3_prepare_v2(_db, sql.c_str(), -1, &amp;stmt, 
nullptr) == SQLITE_OK) { 
            if (sqlite3_step(stmt)!=SQLITE_DONE) { 
                CCLOG("Error in CREATE TABLE"); 
            }
  } 
        sqlite3_reset(stmt); 
        sqlite3_finalize(stmt); 
        this-&gt;close(); 
   } 
}

SQLiteManager* SQLiteManager::getInstance() { 
    if (instance==nullptr) { 
        instance = new SQLiteManager(); 
    }
    return instance;
}</pre></div></li><li class="listitem">Add the method that opens and closes the database:<div class="informalexample"><pre class="programlisting">bool SQLiteManager::open() 
{
    std::string path = FileUtils::getInstance()- 
&gt;getWritablePath()+"test.sqlite"; 
    return sqlite3_open(path.c_str(), &amp;_db)==SQLITE_OK; 
}

void SQLiteManager::close() 
{ 
    sqlite3_close(_db); 
}</pre></div></li><li class="listitem">Add the <a id="id303" class="indexterm"/>method that inserts data to the database:<div class="informalexample"><pre class="programlisting">void SQLiteManager::insert(std::string key, std::string value)
{
    this-&gt;open();
    // insert data
    sqlite3_stmt* stmt;
    std::string sql = "INSERT INTO data (key, value) VALUES(?, ?)";
    if (sqlite3_prepare_v2(_db, sql.c_str(), -1, &amp;stmt, nullptr) == SQLITE_OK) {
        sqlite3_bind_text(stmt, 1, key.c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 2, value.c_str(), -1, SQLITE_TRANSIENT);
        if (sqlite3_step(stmt)!=SQLITE_DONE) { 
            CCLOG("Error in INSERT 1, %s", 
            sqlite3_errmsg(_db)); 
        }
    }
    sqlite3_reset(stmt);
    sqlite3_finalize(stmt);
    this-&gt;close();
}</pre></div></li><li class="listitem">Add the <a id="id304" class="indexterm"/>method that selects data from the database:<div class="informalexample"><pre class="programlisting">std::string SQLiteManager::select(std::string key){
    this-&gt;open(); 

    // select data 
    std::string value; 
    sqlite3_stmt* stmt; 
    std::string sql = "SELECT VALUE from data where key=?"; 
    if (sqlite3_prepare_v2(_db, sql.c_str(), -1, &amp;stmt, 
    NULL) == SQLITE_OK) { 
        sqlite3_bind_text(stmt, 1, key.c_str(), -1, 
        SQLITE_TRANSIENT); 
        if (sqlite3_step(stmt) == SQLITE_ROW) { 
            const unsigned char* val = 
            sqlite3_column_text(stmt, 0); 
            value = std::string((char*)val); 
            CCLOG("key=%s, value=%s", key.c_str(), val); 
        } else {
            CCLOG("Error in SELECT, %s", 
            sqlite3_errmsg(_db));
        }
    } else {
        CCLOG("Error in SELECT, %s", sqlite3_errmsg(_db)); 
    } 
    sqlite3_reset(stmt); 
    sqlite3_finalize(stmt); 
    this-&gt;close(); 
    return value; 
}</pre></div></li><li class="listitem">Finally, here's how to use this class. To insert data, use the following code:<div class="informalexample"><pre class="programlisting">SQLiteManager::getInstance()-&gt;insert("foo", "value1");</pre></div><p>To select data, use the following code:</p><div class="informalexample"><pre class="programlisting">std::string value = SQLiteManager::getInstance()- 
&gt;select("foo");</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec172"/>How it works...</h2></div></div></div><p>Firstly, in the constructor method of the <code class="literal">SQLiteManager</code> class, this class creates a table called data if it does not already exist. The data table is created in SQL as follows:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE IF NOT EXISTS data(key TEXT PRIMARY KEY,value TEXT);</pre></div><p>In order to use SQLite, you have to include <code class="literal">sqlite3.h</code> and use the sqlite3 API. This API is in the C language. If you would like to learn it, you should check the website <a class="ulink" href="http://sqlite.org/cintro.html">http://sqlite.org/cintro.html</a>.</p><p>We created our database called <code class="literal">test.sqlite</code> in the sandbox area of the application. If you want to change the location or the name, you should edit the <code class="literal">open</code> method.</p><div class="informalexample"><pre class="programlisting">std::string path = FileUtils::getInstance()-&gt;getWritablePath()+"test.sqlite";</pre></div><p>You can insert <a id="id305" class="indexterm"/>data by using the <code class="literal">insert</code> method to specify the key and the value.</p><div class="informalexample"><pre class="programlisting">SQLiteManager::getInstance()-&gt;insert("foo", "value1");</pre></div><p>Further, you can select the value by using the <code class="literal">select</code> method to specify the key.</p><div class="informalexample"><pre class="programlisting">std::string value = SQLiteManager::getInstance()-&gt;select("foo");</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec173"/>There's more...</h2></div></div></div><p>In this recipe, we created the <code class="literal">insert</code> method and the <code class="literal">select</code> method. However, you can execute other SQL methods such as <code class="literal">delete</code> and <code class="literal">replace</code>. Further, you can make the database match your game. So, you will need to edit this class for your game.</p></div></div>
<div class="section" title="Using .xml files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Using .xml files</h1></div></div></div><p>XML is often<a id="id306" class="indexterm"/> used as an API's return value. Cocos2d-x has the TinyXML2 library that can parse an XML file. In this recipe, we will explain how to parse XML files by using this library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec174"/>Getting ready</h2></div></div></div><p>Firstly, you need to create an XML file and save it as <code class="literal">test.xml</code> in the <code class="literal">Resources/res</code> folder in your project. In this case, we will use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;key&gt;key text&lt;/key&gt;
    &lt;array&gt;
        &lt;name&gt;foo&lt;/name&gt;
        &lt;name&gt;bar&lt;/name&gt;
        &lt;name&gt;hoge&lt;/name&gt;
    &lt;/array&gt;
&lt;/root&gt;</pre></div><p>To use the TinyXML-2 library, you have to include it and use namespace as follows:</p><div class="informalexample"><pre class="programlisting">#include "tinyxml2/tinyxml2.h" 
using namespace tinyxml2;</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec175"/>How to do it...</h2></div></div></div><p>You can parse an<a id="id307" class="indexterm"/> XML file by using the TinyXML2 library. In the following code, we parse <code class="literal">test.xml</code> and log each element in it.</p><div class="informalexample"><pre class="programlisting">std::string path = util-&gt;fullPathForFilename("res/test.xml"); 
XMLDocument *doc = new XMLDocument();
XMLError error = doc-&gt;LoadFile(path.c_str());
if (error == 0) { 
    XMLElement *root = doc-&gt;RootElement(); 
    XMLElement *key = root-&gt;FirstChildElement("key"); 
    if (key) { 
        CCLOG("key element = %s", key-&gt;GetText()); 
    }
    XMLElement *array = key-&gt;NextSiblingElement();
    XMLElement *child = array-&gt;FirstChildElement();
    while ( child ) {
        CCLOG("child element= %s", child-&gt;GetText());
        child = child-&gt;NextSiblingElement();
    }
    delete doc;
}</pre></div><p>This result is the following log:</p><div class="informalexample"><pre class="programlisting">key element = key text
child element= foo
child element= bar
child element= hoge</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec176"/>How it works...</h2></div></div></div><p>First, you will have to create an instance of <code class="literal">XMLDocument</code> and then, parse the <code class="literal">.xml</code> file by using the <code class="literal">XMLDocument::LoadFile</code> method. To get the root element, you will have to use the <code class="literal">XMLDocument::RootElement</code> method. Basically, you can get the element by using the <code class="literal">FirstChildElement</code> method. If it is a continuous element, you can get the next element by using the <code class="literal">NextSiblingElement</code> method. If there are no more elements, the return value of <code class="literal">NextSiblingElement</code> will be null.</p><p>Finally, you shouldn't forget to delete the instance of <code class="literal">XMLDocment</code>. That's why you created it using a new operation.</p></div></div>
<div class="section" title="Using .plist files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Using .plist files</h1></div></div></div><p>PLIST used in OS X <a id="id308" class="indexterm"/>and iOS is a property list. The file extension is <code class="literal">.plist</code>, but in fact, the PLIST format is an XML format. We often use <code class="literal">.plist</code> files to store game settings and so on. Cocos2d-x has a class through which you can easily use <code class="literal">.plist</code> files.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec177"/>Getting ready</h2></div></div></div><p>Firstly, you need to create a <code class="literal">.plist</code> file and save it as <code class="literal">test.plist</code> to the <code class="literal">Resources/res</code> folder in your project. In this case, it has two keys, namely <code class="literal">foo</code> and <code class="literal">bar</code>. The <code class="literal">foo</code> key has an integer value of <code class="literal">1</code>. The <code class="literal">bar</code> key has a string value of <code class="literal">This is string</code>. Refer to the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;foo&lt;/key&gt;
  &lt;integer&gt;1&lt;/integer&gt;
  &lt;key&gt;bar&lt;/key&gt;
  &lt;string&gt;This is string&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec178"/>How to do it...</h2></div></div></div><p>You can parse a <code class="literal">.plist</code> file by using the <code class="literal">FileUtils::getValueMapFromFile</code> method. In the following code, we parse <code class="literal">test.plist</code> and log a key value in it.</p><div class="informalexample"><pre class="programlisting">FileUtils* util = FileUtils::getInstance();
std::string path = util-&gt;fullPathForFilename("res/test.plist");
ValueMap map = util-&gt;getValueMapFromFile(path); 
for (auto element : map) { 
    std::string key = element.first; 
    Value value = element.second; 
    switch (value.getType()) { 
        case Value::Type::BOOLEAN: 
            CCLOG("%s, %s", key.c_str(), 
            value.asBool()?"true":"false");
            break; 
        case Value::Type::INTEGER: 
            CCLOG("%s, %d", key.c_str(), value.asInt()); 
            break; 
        case Value::Type::FLOAT: 
            CCLOG("%s, %f", key.c_str(), value.asFloat()); 
            break; 
        case Value::Type::DOUBLE: 
            CCLOG("%s, %f", key.c_str(), value.asDouble()); 
            break; 
        case Value::Type::STRING: 
            CCLOG("%s, %s", key.c_str(), 
            value.asString().c_str()); 
            break;        default: 
            break; 
    }
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec179"/>How it works...</h2></div></div></div><p>You can<a id="id309" class="indexterm"/> parse a <code class="literal">.plist</code> file by specifying the <code class="literal">.plist</code> file's path to the <code class="literal">FileUtils::getValueMapFromFile</code> method. After doing so, you get the data from the <code class="literal">.plist</code> file as a <code class="literal">ValueMap</code> value. The <code class="literal">ValueMap</code> class is a wrapper class-based <code class="literal">std::unordered_map</code>. PLIST's data containers are <code class="literal">Array</code> and <code class="literal">Dictionary</code>. After parsing the <code class="literal">.plist</code> file, <code class="literal">Array</code> is <code class="literal">std::vector&lt;Value&gt;</code> and <code class="literal">Dictionary</code> is <code class="literal">std::unordered_map&lt;std::string, Value&gt;</code>. Further, you can distinguish the type of value by using the <code class="literal">Value::getType</code> method. Then, you can get the value by using the <code class="literal">Value::asInt</code>, <code class="literal">asFloat</code>, <code class="literal">asDouble</code>, <code class="literal">asBool</code>, and <code class="literal">asString</code> methods.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec180"/>There's more...</h2></div></div></div><p>You can save the <code class="literal">.plist</code> file from <code class="literal">ValueMap</code>. By doing so, you can save your game data in the <code class="literal">.plist</code> file. To save the <code class="literal">.plist</code> file, use the following code:</p><div class="informalexample"><pre class="programlisting">ValueMap map; for (int i=0; i&lt;10; i++) { 
    std::string key = StringUtils::format("key_%d", i); 
    Value val = Value(i); 
    map.insert(std::make_pair(key, val));
}
std::string fullpath = util-&gt;getWritablePath() + "/test.xml"; 
FileUtils::getInstance()-&gt;writeToFile(map, fullpath);</pre></div><p>First, you need to set the key value in <code class="literal">ValueMap</code>. In this case, the values are all of the integer type, but you can set mixed-type values as well. Finally, you need to save the file as a <code class="literal">.plist</code> file by using the <code class="literal">FileUtils::writeToFile</code> method.</p></div></div>
<div class="section" title="Using .json files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Using .json files</h1></div></div></div><p>We can use the <a id="id310" class="indexterm"/>JSON format like the XML format for saving/loading game-related data. JSON is a simpler format than XML. It takes less space to represent the same data than the XML file format. Further, today, it is used as the value of Web API. Cocos2d-x has a JSON parse library called <span class="strong"><strong>RapidJSON</strong></span>. In this recipe, we will explain how to use <a id="id311" class="indexterm"/>RapidJSON.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec181"/>Getting ready</h2></div></div></div><p>RapidJSON is usually included in Cocos2d-x. However, you need to include the header files as follows:</p><div class="informalexample"><pre class="programlisting">#include "json/rapidjson.h"
#include "json/document.h"</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec182"/>How to do it...</h2></div></div></div><p>Firstly, we will parse a JSON string as follows:</p><div class="informalexample"><pre class="programlisting">std::string str = "{\"hello\" : \"word\"}";</pre></div><p>You can parse JSON by using <code class="literal">rapidjson::Document</code> as follows:</p><div class="informalexample"><pre class="programlisting">rapidjson::Document d;
d.Parse&lt;0&gt;(str.c_str());
if (d.HasParseError()) { 
    CCLOG("GetParseError %s\n",d.GetParseError()); 
} else if (d.IsObject() &amp;&amp; d.HasMember("hello")) { 
    CCLOG("%s\n", d["hello"].GetString()); 
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec183"/>How it works...</h2></div></div></div><p>You can parse JSON by using the <code class="literal">Document::Parse</code> method and specifying the JSON string. You may get a parse error when you use the <code class="literal">Document::HasParseError</code> method; you can get a description of this error by using the <code class="literal">Document::GetParseError</code> method for a string. Further, you can get an element by specifying the hash key and using the <code class="literal">Document::GetString</code> method.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec184"/>There's more...</h2></div></div></div><p>In a real application, you can get a JSON string from a file. We will now explain how to get this string from a file. First, you need to add a file called <code class="literal">test.json</code> to the <code class="literal">Resources/res</code> folder in your project and save it as follows:</p><div class="informalexample"><pre class="programlisting">[{"name":"Tanaka","age":25}, {"name":"Ichiro","age":40}]</pre></div><p>Next, you can get a JSON string from a file as follows:</p><div class="informalexample"><pre class="programlisting">std::string jsonData = FileUtils::getInstance()- 
&gt;getStringFromFile("res/test.json"); 
CCLOG("%s\n", jsonData.c_str()); 
rapidjson::Document d; 
d.Parse&lt;0&gt;(jsonData.c_str()); 
if (d.HasParseError()) { 
    CCLOG("GetParseError %s\n",d.GetParseError()); 
} else { 
    if (d.IsArray()) { 
        for (rapidjson::SizeType i = 0; i &lt; d.Size(); ++i) { 
            auto name = d[i]["name"].GetString(); 
            auto age = d[i]["age"].GetInt(); 
            CCLOG("name-%s, age=%d", name, age); 
        }
    }
}</pre></div><p>You can get the<a id="id312" class="indexterm"/> string from the file by using the <code class="literal">FileUtils::getStringFromFile</code> method. Thereafter, you can parse in the same way. In addition, this JSON string may be an array. You can check whether the format is an array by using the <code class="literal">Document::IsArray</code> method. Then, you can use a for loop to go through the JSON object in the array.</p></div></div></body></html>