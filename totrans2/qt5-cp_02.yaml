- en: Chapter 2. Building a Beautiful Cross-platform Clock
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 构建一个美观的跨平台时钟
- en: 'In this chapter, you will learn that Qt is a great tool to build cross-platform
    applications. A Qt/C++ clock example is used as a demonstration here. The topics
    covered in this chapter, which are listed here, are essential for any real-world
    applications. These are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解到 Qt 是构建跨平台应用程序的伟大工具。这里使用 Qt/C++ 时钟示例作为演示。本章涵盖的主题，如以下列出，对于任何实际应用都是必不可少的。以下是具体内容：
- en: Creating a basic digital clock
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本数字时钟
- en: Tweaking the digital clock
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整数字时钟
- en: Saving and restoring settings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和恢复设置
- en: Building on Unix platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unix 平台上构建
- en: Creating a basic digital clock
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本数字时钟
- en: It's time to create a new project, so we will create a Qt Widgets application
    named `Fancy_Clock`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个新项目了，因此我们将创建一个名为 `Fancy_Clock` 的 Qt Widgets 应用程序。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We won't utilize any Qt Quick knowledge in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会使用任何 Qt Quick 知识。
- en: 'Now, change the window title to `Fancy Clock` or any other name that you like.
    Then, the main window UI needs to be tailored because the clock is displayed at
    the top of the desktop. The menu bar, status bar, and toolbar are all removed.
    After that, we need to drag an **LCD Number** widget into `centralWidget`. Next,
    change the layout of `MainWindow` to **LayOut Horizontally** in order to autoresize
    the subwidget. The last thing that needs to be done to the UI file is to change
    **frameShape** to **NoFrame** under the **QFrame** column in the property of `lcdNumber`.
    If you''ve done this right, you''ll get a prototype of a digital clock, as shown
    here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将窗口标题更改为 `Fancy Clock` 或你喜欢的任何其他名称。然后，需要调整主窗口 UI，因为时钟显示在桌面顶部。菜单栏、状态栏和工具栏都被移除。之后，我们需要将一个
    **LCD Number** 小部件拖入 `centralWidget`。接下来，将 `MainWindow` 的布局更改为 **水平布局** 以自动调整子小部件的大小。对
    UI 文件进行的最后修改是在 `QFrame` 列的属性下将 **frameShape** 更改为 **NoFrame**。如果你做得正确，你将得到一个数字时钟的原型，如图所示：
- en: '![Creating a basic digital clock](img/4615OS_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本数字时钟](img/4615OS_02_01.jpg)'
- en: 'In order to update the LCD number display repeatedly, we have to make use of
    the `QTimer` class to set up a timer that emits a signal repetitively. In addition
    to this, we need to create a slot to receive the signal and to update the LCD
    number display to the current time. Thus, the `QTime` class is also needed. This
    is how the header file of `MainWindowmainwindow.h` will look now:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重复更新 LCD 数字显示，我们必须使用 `QTimer` 类设置一个重复发出信号的计时器。除此之外，我们还需要创建一个槽来接收信号并更新 LCD
    数字显示到当前时间。因此，也需要 `QTime` 类。这就是 `MainWindowmainwindow.h` 的头文件现在看起来是这样的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the only modification made here is the declaration of a private
    `updateTime` slot. As usual, we're supposed to define this slot in `mainwindow.cpp`,
    whose content is pasted here. Note that we need to include `QTimer` and `QTime`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里所做的唯一修改是声明了一个私有的 `updateTime` 槽。像往常一样，我们应在 `mainwindow.cpp` 中定义此槽，其内容如下。请注意，我们需要包含
    `QTimer` 和 `QTime`。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the `updateTime` slot, the `QTime` class is used to deal with the time,
    that is, the clock. This class can provide accuracy of up to 1 millisecond, if
    the underlying operating system supports it. However, `QTime` has nothing to do
    with the time zone or daylight saving time. It is, at least, sufficient for our
    little clock. The `currentTime()` function is a static public function, which
    is used to create a `QTime` object that contains the system's local time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `updateTime` 槽内部，使用 `QTime` 类来处理时间，即时钟。如果底层操作系统支持，此类可以提供高达 1 毫秒的精度。然而，`QTime`
    与时区或夏令时无关。至少，这对我们的小时钟来说是足够的。`currentTime()` 函数是一个静态公共函数，用于创建一个包含系统本地时间的 `QTime`
    对象。
- en: As for the second line of the `updateTime` function, we used the `toString`
    function provided by `QTime` to convert the time to a string, and then saved it
    in `currentTimeText`. The arguments that are passed to `toString` are in the format
    of the time string. The full list of expressions can be obtained from **Qt Reference
    Documentation**. The colon in the middle of the clock should be flashing, just
    as in the case of a real digital clock. Hence, we used an `if` statement to control
    this. The colon will vanish when the second's value is even, and it will reappear
    when the second's value is odd. Here, inside the `if` block, we used the `[2]`
    operator to get a modifiable reference of the third character because this is
    the only way to do direct modifications to a character inside a string. Here,
    the counting of the `currentTimeText` string starts from `0`. Meanwhile, the `at()`
    function of `QString` returns a constant character, which you have no right to
    change. At last, this function will let `lcdNumber` display the time string. Now,
    let's get back to the constructor of `MainWindow`. After the initialization of
    the UI, the first thing it does is to create a `QTimer` object. Why can't we use
    a local variable? The answer to that question is because the local variables will
    be destroyed after the construction of `MainWindow`. If the timer has gone, there's
    no way to trigger `updateTime` repetitively. We don't use a member variable because
    there is no need to perform the declaration work in the header file, since we
    won't use this timer elsewhere.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `updateTime` 函数的第二行，我们使用了 `QTime` 提供的 `toString` 函数将时间转换为字符串，并将其保存在 `currentTimeText`
    中。传递给 `toString` 的参数是时间字符串的格式。完整的表达式列表可以从**Qt 参考文档**中获取。时钟中间的冒号应该闪烁，就像真实数字时钟一样。因此，我们使用了一个
    `if` 语句来控制这一点。当秒的值是偶数时，冒号将消失，当秒的值是奇数时，它将重新出现。在这里，在 `if` 块内部，我们使用了 `[2]` 操作符来获取第三个字符的可修改引用，因为这是在字符串内部直接修改字符的唯一方法。在这里，`currentTimeText`
    字符串的计数从 `0` 开始。同时，`QString` 的 `at()` 函数返回一个常量字符，你无权更改它。最后，这个函数将让 `lcdNumber` 显示时间字符串。现在，让我们回到
    `MainWindow` 的构造函数。在初始化 UI 之后，它首先做的事情是创建一个 `QTimer` 对象。为什么我们不能使用局部变量？这个问题的答案是，因为局部变量将在
    `MainWindow` 构造之后被销毁。如果定时器已经消失，就没有办法重复触发 `updateTime`。我们不使用成员变量，因为没有必要在头文件中进行声明工作，因为我们不会在其他地方使用这个定时器。
- en: The `QTimer` class is used to create a repetitive and single-shot timer. It
    will emit the `timeout` signal at constant intervals after `start` is called.
    Here, we create one timer and connect the `timeout` signal to the `updateTime`
    slot so that `updateTime` is called every second.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer` 类用于创建重复和单次定时器。在调用 `start` 后，它将在恒定的时间间隔后发出 `timeout` 信号。在这里，我们创建了一个定时器，并将
    `timeout` 信号连接到 `updateTime` 插槽，以便每秒钟调用 `updateTime`。'
- en: There is another important aspect in Qt called **parent-child mechanism**. Although
    it's not as well-known as signals and slots, it plays a crucial role in the development
    of the Qt applications. Basically speaking, when we create an `QObject` child
    with a parent or explicitly set a parent by calling `setParent`, the parent will
    add this `QObject` child to its list of children. Then, when the parent is deleted,
    it'll go through its list of children and delete each child. In most cases, especially
    in the design of a UI, the parent-child relationship is set up implicitly. The
    parent widget or layout automatically becomes the parent object to its children
    widgets or layouts. In other cases, we have to explicitly set the parent for a
    `QObject` child so that the parent can take over its ownership and manage the
    release of its memory. Hence, we pass the `QObject` parent, which is this, a `MainWindow`
    class to the constructor of `QTimer`. This ensures that `QTimer` will be deleted
    after `MainWindow` is deleted. That's why we don't have to explicitly write the
    `delete` statements in the destructor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中还有一个重要的方面，称为**父子机制**。尽管它不如信号和槽那么知名，但在 Qt 应用程序的开发中起着至关重要的作用。基本上说，当我们创建一个带有父对象或通过调用
    `setParent` 显式设置父对象的 `QObject` 子对象时，父对象会将这个 `QObject` 子对象添加到其子对象列表中。然后，当父对象被删除时，它会遍历其子对象列表并删除每个子对象。在大多数情况下，尤其是在
    UI 设计中，父子关系是隐式设置的。父小部件或布局自动成为其子小部件或布局的父对象。在其他情况下，我们必须显式设置 `QObject` 子对象的父对象，以便父对象可以接管其所有权并管理其内存释放。因此，我们将
    `QObject` 父对象，即这个 `MainWindow` 类，传递给 `QTimer` 构造函数。这确保了在 `MainWindow` 被删除后，`QTimer`
    也会被删除。这就是为什么我们不需要在析构函数中显式编写 `delete` 语句的原因。
- en: 'At the end of the constructor, we need to call `updateTime` explicitly, which
    will allow the clock to display the current time. If we don''t do this, the application
    will display a zero for a second until the `timeout` signal is emitted by `timer`.
    Now, run your application; it will be similar to the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的末尾，我们需要显式调用`updateTime`，这将允许时钟显示当前时间。如果我们不这样做，应用程序将显示一个零秒，直到`timer`发出`timeout`信号。现在，运行你的应用程序；它将类似于以下截图：
- en: '![Creating a basic digital clock](img/4615OS_02_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本的数字时钟](img/4615OS_02_02.jpg)'
- en: Tweaking the digital clock
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整数字时钟
- en: It's time to make this basic digital clock look more beautiful. Let's add something
    like a transparent background, which sits on top of the frameless window. Using
    a transparent background can deliver a fantastic visual effect. While the frameless
    window hides window decorations, including a border and the title bar, a desktop
    widget, such as a clock, should be frameless and displayed on top of the desktop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让这个基本的数字时钟看起来更漂亮了。让我们添加一些像透明背景这样的东西，它位于无框窗口的顶部。使用透明背景可以产生惊人的视觉效果。当无框窗口隐藏窗口装饰，包括边框和标题栏时，桌面小部件，如时钟，应该是无边框的，并显示在桌面顶部。
- en: 'To make our clock translucent, simply add the following line to the constructor
    of `MainWindow`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的时钟透明，只需将以下行添加到`MainWindow`的构造函数中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The effect of the `WA_TranslucentBackground` attribute depends on the composition
    managers on the X11 platforms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`WA_TranslucentBackground`属性的效果取决于X11平台上的合成管理器。'
- en: A widget may have lots of attributes, and this function is used to switch on
    or switch off a specified attribute. It's turned on by default. You need to pass
    a false Boolean as the second argument to disable an attribute. The full list
    of `Qt::WidgetAttribute` can be found in the Qt Reference Documentation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件可能有大量的属性，这个函数用于打开或关闭指定的属性。默认情况下是开启的。你需要传递一个假的布尔值作为第二个参数来禁用属性。`Qt::WidgetAttribute`的完整列表可以在Qt参考文档中找到。
- en: 'Now, add the following line to the constructor as well, which will make the
    clock look frameless and make it stay on top of the desktop:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下行添加到构造函数中，这将使时钟看起来无边框，并使其保持在桌面顶部：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, `Qt::WindowFlags` is used to define the type of widget. It controls
    the behavior of the widget, rather than of its properties. Thus, two hints are
    given: one is to stay on top and the other is to be frameless. If you want to
    preserve old flags while setting new ones, you need to add them to the combination.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Qt::WindowFlags`用于定义小部件的类型。它控制小部件的行为，而不是其属性。因此，给出了两个提示：一个是保持在顶部，另一个是无边框。如果你想保留旧标志同时设置新标志，你需要将它们添加到组合中。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `windowFlags` function is used to retrieve the window flags. One thing
    you may be interested to know is that `setWindowFlags` will result in the invisibility
    of the widget after the `show` function. So, you can either call `setWindowFlags`
    before the `show` function of the window or widget or call `show` again after
    `setWindowFlags`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`windowFlags`函数用于检索窗口标志。你可能感兴趣的一件事是，`setWindowFlags`将在`show`函数之后导致小部件不可见。所以，你可以在窗口或小部件的`show`函数之前调用`setWindowFlags`，或者调用`show`后再调用`setWindowFlags`。
- en: 'After the modification to the constructor, this is how the clock is expected
    to look:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改构造函数后，时钟应该看起来是这样的：
- en: '![Tweaking the digital clock](img/4615OS_02_03_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![调整数字时钟](img/4615OS_02_03_03.jpg)'
- en: 'There is a useful trick that you can use to hide the clock from the taskbar.
    Of course, a clock doesn''t need to be displayed among the applications in a taskbar.
    You should never set a flag such as `Qt::Tool` or `Qt::ToolTip` alone to achieve
    this because this will cause the exit behavior of the application to be abnormal.
    This trick is even simpler; here is the code of `main.cpp`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有用的技巧，你可以用它来隐藏时钟从任务栏中。当然，时钟不需要在任务栏中的应用程序中显示。你不应该单独设置一个像`Qt::Tool`或`Qt::ToolTip`这样的标志来达到这个目的，因为这会导致应用程序的退出行为异常。这个技巧甚至更简单；下面是`main.cpp`的代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code makes our `MainWindow w` object a child of `QWidget wid`.
    The child widgets won't display on the taskbar because there should be only one
    top parent widget. Meanwhile, our parent widget, `wid`, doesn't even show. It's
    tricky, but it's the only one that does the trick without breaking any other logic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使我们的`MainWindow w`对象成为`QWidget wid`的子对象。子小部件不会显示在任务栏上，因为应该只有一个顶级父小部件。同时，我们的父小部件`wid`甚至不会显示。这很棘手，但这是唯一一个在不破坏任何其他逻辑的情况下做到这一点的方法。
- en: Well, a new problem has just surfaced. The clock is unable to move and the only
    way to close it is by stopping it through the Qt Creator's panel or through a
    keyboard shortcut. This is because we declared it as a frameless window, which
    led to an inability to control it via a window manager. Since there is no way
    to interact with it, it's impossible to close it by itself. Hence, the solution
    to this problem is to write our own functions to move and close the clock.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，一个新的问题刚刚出现。时钟无法移动，唯一的关闭方式是通过 Qt Creator 的面板或通过键盘快捷键停止它。这是因为我们将其声明为无边框窗口，导致无法通过窗口管理器控制它。由于无法与之交互，因此无法自行关闭。因此，解决这个问题的方法是编写我们自己的函数来移动和关闭时钟。
- en: 'Closing this application may be more urgent. Let''s see how to reimplement
    some functions to achieve this goal. First, we need to declare a new `showContextMenu`
    slot to display a context menu and reimplement `mouseReleaseEvent`. The following
    code shows the content of `mainwindow.h`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭此应用程序可能更为紧急。让我们看看如何重新实现一些功能以达到这个目标。首先，我们需要声明一个新的 `showContextMenu` 槽来显示上下文菜单，并重新实现
    `mouseReleaseEvent`。以下代码展示了 `mainwindow.h` 的内容：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are two new classes defined in the preceding code: `QPoint` and `QMouseEvent`.
    The `QPoint` class defines a point in the plane by using integer precision. Relatively,
    there is another class named `QPointF`, which provides float precision. Well,
    the `QMouseEvent` class inherits `QEvent` and `QInputEvent`. It contains some
    parameters that describe a mouse event. Let''s see why we need them in `mainwindow.cpp`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义了两个新的类：`QPoint` 和 `QMouseEvent`。`QPoint` 类通过使用整数精度定义平面上的一个点。相对地，还有一个名为
    `QPointF` 的类，它提供浮点精度。嗯，`QMouseEvent` 类继承自 `QEvent` 和 `QInputEvent`。它包含一些描述鼠标事件的参数。让我们看看为什么在
    `mainwindow.cpp` 中需要它们：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that you should include `QMouseEvent`, `QMenu`, and `QAction` in order
    to utilize these classes. There is a predefined `customContextMenuRequested` signal,
    which is coupled with the newly created `showContextMenu` slot. For the sake of
    consistency, we will follow the rule that Qt defined, which means that the `QPoint`
    argument in `customContextMenuRequested` should be a local position instead of
    a global position. That's why we need a `mapToGlobal` function to translate `pos`
    to a global position. As for the `QMenu` class, it provides a `menu` widget for
    a menu bar, context menu, or other pop-up menus. So, we create the `contextMenu`
    object, and then add a new action with the `Exit` text. This is coupled with a
    `close` slot of `MainWindow`. The last statement is used to execute the `contextMenu`
    object at the specified global position. In other words, this slot will display
    a pop-up menu at the given position.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该包含 `QMouseEvent`、`QMenu` 和 `QAction` 以利用这些类。有一个预定义的 `customContextMenuRequested`
    信号，它与新创建的 `showContextMenu` 槽相关联。为了保持一致性，我们将遵循 Qt 定义的规则，这意味着 `customContextMenuRequested`
    中的 `QPoint` 参数应该是一个局部位置而不是全局位置。这就是为什么我们需要一个 `mapToGlobal` 函数将 `pos` 转换为全局位置。至于
    `QMenu` 类，它提供了一个菜单栏、上下文菜单或其他弹出菜单的 `menu` 小部件。因此，我们创建了 `contextMenu` 对象，然后添加一个带有
    `Exit` 文本的新的操作。这与 `MainWindow` 的 `close` 槽相关联。最后的语句用于在指定的全局位置执行 `contextMenu`
    对象。换句话说，这个槽将在给定位置显示一个弹出菜单。
- en: The reimplementation of `mouseReleaseEvent` is done to check the triggered button
    of the event. If it's the right button, emit the `customContextMenuRequested`
    signal with the local position of the mouse. Otherwise, simply call the default
    `mouseReleaseEvent` function of `QMainWindow`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重新实现 `mouseReleaseEvent` 的目的是检查事件触发按钮。如果是右键，则使用鼠标的局部位置发出 `customContextMenuRequested`
    信号。否则，简单地调用 `QMainWindow` 的默认 `mouseReleaseEvent` 函数。
- en: Make use of the default member functions of the base class when you reimplement
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新实现它时，利用基类的默认成员函数。
- en: 'Run the application again; you can quit by right-clicking on it and then selecting
    **Exit**. Now, we should continue the reimplementation to make the clock movable.
    This time, we need to rewrite two protected functions: `mousePressEvent` and `mouseMoveEvent`.
    Therefore, this is how the header file looks:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序；你可以通过右键单击它并选择**退出**来退出。现在，我们应该继续重新实现，使时钟可移动。这次，我们需要重写两个受保护的函数：`mousePressEvent`
    和 `mouseMoveEvent`。因此，这是头文件的外观：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is also a declaration of a new private member variable in the preceding
    code, `m_mousePos`, which is a `QPoint` object used to store the local position
    of the mouse. The following code defines `mousePressEvent` and `mouseMoveEvent`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，还声明了一个新的私有成员变量 `m_mousePos`，它是一个用于存储鼠标局部位置的 `QPoint` 对象。下面的代码定义了 `mousePressEvent`
    和 `mouseMoveEvent`：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's easier than you thought. When a mouse button is pressed, the local position
    of the mouse is stored as `m_mousePos`. When the mouse is moving, we call the
    `move` function to move `MainWindow` to a new position. Because the position passed
    to `move` is a global position, we need to use `globalPos` of the event minus
    the local position of the mouse. Confused? The `m_mousePos` variable is the mouse's
    relative position to the top-left point of the parent widget, which is `MainWindow`
    in our case. The `move` function will move the top-left point of `MainWindow`
    to the given global position. While the `e->globalPos()` function is the global
    position of the mouse and not `MainWindow`, we need to subtract the relative position
    of `m_mousePos` to translate the mouse's global position to the top-left point
    position of `MainWindow`. After all this effort, the clock should look much more
    satisfying.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这比你想象的要简单。当鼠标按钮被按下时，鼠标的局部位置被存储为 `m_mousePos`。当鼠标移动时，我们调用 `move` 函数将 `MainWindow`
    移动到新的位置。因为传递给 `move` 的位置是一个全局位置，我们需要使用事件的 `globalPos` 减去鼠标的局部位置。困惑吗？`m_mousePos`
    变量是鼠标相对于父小部件（在我们的例子中是 `MainWindow`）的相对位置。`move` 函数将 `MainWindow` 的左上角移动到给定的全局位置。而
    `e->globalPos()` 函数是鼠标的全局位置，而不是 `MainWindow`，我们需要减去 `m_mousePos` 的相对位置，以将鼠标的全局位置转换为
    `MainWindow` 的左上角位置。经过所有这些努力，时钟应该看起来更加令人满意。
- en: Saving and restoring settings
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和恢复设置
- en: 'Although the clock can be moved, it won''t restore its last position after
    restarting. In addition to this, we can give users some choices to adjust the
    clock''s appearance, such as the font color. To make it work, we need the `QSettings`
    class, which provides platform-independent persistent settings. It needs a company
    or organization name and the name of an application. A typical `QSettings` object
    can be constructed by using this line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时钟可以被移动，但它重启后不会恢复到最后的位置。此外，我们可以为用户提供一些选项来调整时钟的外观，例如字体颜色。为了使其工作，我们需要 `QSettings`
    类，它提供平台无关的持久设置。它需要一个公司或组织名称以及应用程序名称。一个典型的 `QSettings` 对象可以通过以下行构建：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `Qt5 Blueprints` is the organization's name and `Fancy Clock` is the application's
    name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Qt5 Blueprints` 是组织的名称，而 `Fancy Clock` 是应用程序的名称。
- en: The settings are stored in the system registry on Windows, while they are stored
    in the XML preferences files on Mac OS X and the INI text files on the other Unix
    operating systems, such as Linux. However, we do not usually need to be concerned
    with this, since `QSettings` provides high-level interfaces to manipulate the
    settings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，设置存储在系统注册表中，而在 Mac OS X 上存储在 XML 预设文件中，在其他 Unix 操作系统（如 Linux）上存储在
    INI 文本文件中。然而，我们通常不需要担心这一点，因为 `QSettings` 提供了高级接口来操作设置。
- en: 'If we''re going to read and/or write settings in multiple places, we''d better
    set the organization and application in `QCoreApplication`, which is inherited
    by `QApplication`. The `main.cpp` file''s content is shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算在多个地方读取和/或写入设置，我们最好在继承自 `QApplication` 的 `QCoreApplication` 中设置组织和应用程序。`main.cpp`
    文件的内容如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This enables us to use the default `QSettings` constructor to access the same
    settings. In order to save the geometry and state of `MainWindow`, we need to
    reimplement `closeEvent`. First, we need to declare `closeEvent` to be a protected
    member function, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以使用默认的 `QSettings` 构造函数来访问相同的设置。为了保存 `MainWindow` 的几何形状和状态，我们需要重新实现 `closeEvent`。首先，我们需要将
    `closeEvent` 声明为一个受保护的成员函数，如下所示：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, let''s define the `closeEvent` function in `mainwindow.cpp`, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在 `mainwindow.cpp` 中定义 `closeEvent` 函数，如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember to add `#include <QSettings>` in order to include the `QSettings` header
    files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加 `#include <QSettings>` 以包含 `QSettings` 头文件。
- en: Thanks to `setOrganizationName` and `setApplicationName`, we don't need to pass
    any arguments to the `QSettings` constructor now. Instead, we call a `setValue`
    function to save the settings. The `saveGeometry()` and `saveState()` functions
    return the `MainWindow` geometry and state respectively as the `QByteArray` objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`setOrganizationName`和`setApplicationName`，我们现在不需要向`QSettings`构造函数传递任何参数。相反，我们调用一个`setValue`函数来保存设置。`saveGeometry()`和`saveState()`函数分别返回`MainWindow`的几何形状和状态作为`QByteArray`对象。
- en: 'The next step is to read these settings and restore the geometry and state.
    This can be done inside the constructor of `MainWindow`. You just need to add
    two statements to it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是读取这些设置并恢复几何形状和状态。这可以在`MainWindow`的构造函数内部完成。您只需向其中添加两个语句即可：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, `toByteArray()` can translate the stored value to a `QByteArray` object.
    How do we test to see if this works? To do this, perform the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`toByteArray()`可以将存储的值转换为`QByteArray`对象。我们如何测试它是否工作？为此，请执行以下步骤：
- en: Rebuild this application.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建此应用程序。
- en: Run it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它。
- en: Move its position.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动其位置。
- en: Close it.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭它。
- en: Run it again.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行它。
- en: 'You''ll see that the clock will appear at exactly the same position as it was
    before it closed. Now that you''re pretty much familiar with widgets, layouts,
    settings, signals, and slots, it''s time to cook a preference dialog by performing
    the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到时钟将出现在与关闭前完全相同的位置。现在，您已经相当熟悉小部件、布局、设置、信号和槽，是时候通过以下步骤制作一个首选项对话框了：
- en: Right-click on the `Fancy_Clock` project in the **Projects** panel.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中右键单击`Fancy_Clock`项目。
- en: Select **Add New…**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加新…**。
- en: Select **Qt** in the **Files and Classes** panel.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件和类**面板中选择**Qt**。
- en: Click on **Qt Designer Form Class** in the middle panel.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间面板中点击**Qt Designer表单类**。
- en: Select **Dialog with Buttons Bottom**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**带有按钮底部的对话框**。
- en: Fill in `Preference` under **Class name**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类名**下填写`Preference`。
- en: Click on **Next**, and then select **Finish**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，然后选择**完成**。
- en: 'Qt Creator will redirect you to the **Design** mode. First, let''s change `windowTitle`
    to **Preference**, and then do some UI work. Perform the following steps to do
    this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator将您重定向到**设计模式**。首先，让我们将`windowTitle`更改为**Preference**，然后进行一些UI操作。执行以下步骤来完成此操作：
- en: Drag **Label** to `QDialog` and change its `objectName` property to `colourLabel`.
    Next, change its text to `Colour`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**拖到`QDialog`中，并将其`objectName`属性更改为`colourLabel`。接下来，将其文本更改为`颜色`。
- en: Add **QComboBox** and change its `objectName` property to `colourBox`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**QComboBox**并将其`objectName`属性更改为`colourBox`。
- en: Add the `Black`, `White`, `Green`, and `Red` items to `colourBox`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Black`、`White`、`Green`和`Red`项添加到`colourBox`中。
- en: Change the layout of `Preference` to **Lay Out in a Form Lay Out**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Preference`的布局更改为**表单布局**。
- en: 'Close this UI file. Go back to editing the `preference.h` add a private `onAccepted`
    slot. The following code shows the content of this file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭此UI文件。返回编辑`preference.h`，添加一个私有的`onAccepted`槽。以下代码显示了此文件的内容：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As usual, we define this slot in the source file. Besides, we have to set up
    some initializations in the constructor of `Preference`. Thus, `preference.cpp`
    becomes similar to the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们在源文件中定义此槽。此外，我们还需要在`Preference`的构造函数中设置一些初始化。因此，`preference.cpp`变成了以下代码：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, we load the settings and change the current item of `colourBox`.
    Then, it''s the signal and slot coupling that follow. Note that Qt Creator has
    automatically generated the accept and reject connections between `buttonBox`
    and `Preference` for us. The `accepted` signal of `buttonBox` is emitted when
    the **OK** button is clicked. Likewise, the `rejected` signal is emitted if the
    user clicks on **Cancel**. You may want to check **Signals & Slots Editor** in
    the **Design** mode to see which connections are defined there. This is shown
    in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们加载设置并更改`colourBox`的当前项。然后，接下来是信号和槽的耦合。请注意，Qt Creator已为我们自动生成了`buttonBox`和`Preference`之间的接受和拒绝连接。当点击**OK**按钮时，`buttonBox`的`accepted`信号被触发。同样，如果用户点击**取消**，则触发`rejected`信号。您可能想检查**设计模式**下的**信号与槽编辑器**，以查看那里定义了哪些连接。这在上面的屏幕截图中显示：
- en: '![Saving and restoring settings](img/4615OS_02_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![保存和恢复设置](img/4615OS_02_04.jpg)'
- en: As for the definition of the `onAccepted` slot, it saves `currentIndex` of `colourBox`
    to the settings so that we can read this setting elsewhere.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`onAccepted`槽的定义，它将`colourBox`的`currentIndex`保存到设置中，这样我们就可以在其他地方读取此设置。
- en: Now, what we're going to do next is add an entry for `Preference` in the pop-up
    menu and change the color of `lcdNumber` according to the `Colour` setting value.
    Therefore, you should define a private slot and a private member function in `mainwindow.h`
    first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们接下来要做的就是在弹出菜单中添加一个`Preference`的条目，并根据`Colour`设置值更改`lcdNumber`的颜色。因此，你首先需要在`mainwindow.h`中定义一个私有槽和一个私有成员函数。
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `setColour` function is used to change the color of `lcdNumber`, while
    the `showPreference` slot will execute a `Preference` object. The definitions
    of these two members are in the `mainwindow.cpp` file, which is displayed in the
    following manner:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`setColour`函数用于更改`lcdNumber`的颜色，而`showPreference`槽将执行一个`Preference`对象。这两个成员的定义在`mainwindow.cpp`文件中，如下所示：'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We call `setColour` in the constructor in order to set the color of `lcdNumber`
    correctly. Inside `setColour`, we first read the `Colour` value from the settings,
    and then use a `switch` statement to get the correct `QPalette` class before calling
    `setPalette` to change the color of `lcdNumber`. Since Qt doesn't provide a direct
    way to change the foreground color of the `QLCDNumber` objects, we need to use
    this tedious method to achieve this. At the end of this member function, we call
    `update()` to update the `MainWindow` user interface.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中调用`setColour`是为了正确设置`lcdNumber`的颜色。在`setColour`内部，我们首先从设置中读取`Colour`值，然后使用`switch`语句在调用`setPalette`更改`lcdNumber`的颜色之前获取正确的`QPalette`类。由于Qt没有提供直接更改`QLCDNumber`对象的前景色的方法，我们需要使用这种方法来实现。在这个成员函数的末尾，我们调用`update()`来更新`MainWindow`用户界面。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to add the `Preference` action to `contextMenu` inside `showContextMenu`.
    Otherwise, there will be no way to open the dialog.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`showContextMenu`内部将`Preference`动作添加到`contextMenu`中。否则，将无法打开对话框。
- en: In the relevant `showPreference` slot, we create a new `Preference` object,
    which is the child of `MainWindow`, and then call `exec()` to execute and show
    it. Lastly, we call `setColour()` to change the color of `lcdNumber`. As `Preference`
    is modal and `exec()` has its own event loop, it will block the application until
    `pre` is finished. After `pre` finishes executing, either by `accepted` or `rejected`,
    `setColour` will be called next. Of course, you can use the signal-slot way to
    implement it, but we have to apply some modifications to the previous code. Firstly,
    delete the `accepted-accept` signal-slot couple in `preference.ui` in the **Design**
    mode. Then, add `accept()` to the end of `onAccepted` in `preference.cpp`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关的`showPreference`槽中，我们创建一个新的`Preference`对象，它是`MainWindow`的子对象，然后调用`exec()`来执行并显示它。最后，我们调用`setColour()`来更改`lcdNumber`的颜色。由于`Preference`是模态的，且`exec()`有自己的事件循环，它将阻塞应用程序直到`pre`完成。`pre`执行完成后，无论是通过`accepted`还是`rejected`，接下来都会调用`setColour`。当然，你可以使用信号-槽的方式来实现它，但我们必须对之前的代码进行一些修改。首先，在**设计**模式下删除`preference.ui`中的`accepted-accept`信号-槽对。然后，将`accept()`添加到`preference.cpp`中的`onAccepted`的末尾。
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, `showPreference` in `mainwindow.cpp` can be rewritten as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`mainwindow.cpp`中的`showPreference`可以重写为以下内容：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `connect` statement shouldn't be placed after `exec()`, as it will cause
    the binding to fail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`语句不应该放在`exec()`之后，因为它会导致绑定失败。'
- en: 'No matter which way you prefer, the clock should have a **Preference** dialog
    now. Run it, select **Preference** from the pop-up menu, and change the color
    to whatever you please. You should expect a result similar to what is shown in
    the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你更喜欢哪种方式，现在时钟都应该有一个**Preference**对话框。运行它，从弹出菜单中选择**Preference**，并将颜色更改为你想要的任何颜色。你应该期待的结果类似于以下截图所示：
- en: '![Saving and restoring settings](img/4615OS_02_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![保存和恢复设置](img/4615OS_02_05.jpg)'
- en: Building on the Unix platforms
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unix平台上构建
- en: 'So far, we are still trapped with our applications on Windows. It''s time to
    test whether our code can be built on other platforms. In this chapter, the code
    involved with only desktop operating systems, while we''ll get a chance to build
    applications for mobile platforms later in this book. In terms of other desktop
    operating systems, there are plenty of them, and most of them are Unix-like. Qt
    officially supports Linux and Mac OS X, along with Windows. Hence, users of other
    systems, such as **FreeBSD**, may need to compile Qt from scratch or get prebuilt
    packages from their own communities. In this book, the Linux distribution **Fedora
    20** is used as a demonstration to introduce platform crossing. Please bear in
    mind that there are lots of desktop environments and theming tools on Linux, so
    don''t be surprised if the user interface differs. Well, since you''re curious,
    let me tell you that the desktop environment is **KDE 4** with `QtCurve`, unifying
    GTK+ / Qt 4 / Qt 5 in my case. Let''s get started as soon as you''re ready. You
    can perform the following steps to do this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仍然被困在Windows的应用程序中。是时候测试我们的代码是否可以在其他平台上构建了。在本章中，涉及的代码仅限于桌面操作系统，而在此书的后半部分，我们将有机会为移动平台构建应用程序。至于其他桌面操作系统，种类繁多，其中大多数是类Unix系统。Qt官方支持Linux和Mac
    OS X，以及Windows。因此，使用其他系统（如**FreeBSD**）的用户可能需要从头编译Qt或从他们自己的社区获取预构建的包。在本书中，使用**Fedora
    20** Linux发行版作为演示，介绍平台跨编译。请记住，Linux上有许多桌面环境和主题工具，所以如果用户界面有所不同，请不要感到惊讶。嗯，既然你很好奇，让我告诉你，桌面环境是带有`QtCurve`的**KDE
    4**，在我的情况下，它统一了GTK+ / Qt 4 / Qt 5。一旦你准备好了，我们就开始吧。你可以执行以下步骤来完成这个任务：
- en: Copy the source code of `Fancy Clock` to a directory under Linux.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Fancy Clock`的源代码复制到Linux下的一个目录中。
- en: Delete the `Fancy_Clock.pro.user` file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Fancy_Clock.pro.user`文件。
- en: Open this project in Qt Creator.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Creator中打开此项目。
- en: 'Now, build and run this application. Everything is good except that there''s
    a taskbar icon. Small issues such as this can''t be avoided without testing. Well,
    to fix this, just modify a single line in the constructor of `MainWindow`. Changing
    the window flags will amend this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建并运行这个应用程序。除了任务栏图标外，一切都很正常。这种小问题在测试中是无法避免的。嗯，为了解决这个问题，只需修改`MainWindow`构造函数中的一行。更改窗口标志将修正这个问题：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run the file again, `Fancy Clock` won't show up in the taskbar any more.
    Please keep the `MainWindow` object, `w`, as a child of `QWidget wid`; otherwise,
    the application won't terminate after you click on **Close**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行文件，`Fancy Clock`将不再出现在任务栏中。请确保将`MainWindow`对象`w`作为`QWidget wid`的子对象；否则，点击**关闭**后应用程序不会终止。
- en: Note that the **Preference** dialog uses native UI controls, rather than bringing
    the other platform's controls to this one. This is one of the most fascinating
    things that Qt has provided. All the Qt applications will look and behave like
    native applications across all platforms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**首选项**对话框使用原生UI控件，而不是将其他平台的控件带到这个平台上。这是Qt提供的最迷人的功能之一。所有Qt应用程序都将跨所有平台看起来和表现得像原生应用程序。
- en: '![Building on the Unix platforms](img/4615OS_02_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![在Unix平台上构建](img/4615OS_02_06.jpg)'
- en: It's not a hustle but the truth is that once you code the Qt application, you
    can run it everywhere. You don't need to write different GUIs for different platforms.
    That dark age has long gone. However, you may want to write some functions for
    specific platforms, either because of particular needs or workarounds. Firstly,
    I'd like to introduce you to some Qt Add-On modules dedicated for several platforms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是麻烦，但事实是，一旦你编写了Qt应用程序，你就可以在任何地方运行它。你不需要为不同的平台编写不同的GUI。那个黑暗的时代已经过去了。然而，你可能想为特定平台编写一些函数，无论是由于特定的需求还是解决方案。首先，我想向你介绍一些针对几个平台定制的Qt附加模块。
- en: Take Qt Windows Extras as an example. Some cool features that Windows provides,
    such as **Thumbnail Toolbar** and **Aero Peek**, are supported by Qt through this
    add-on module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以Qt Windows附加组件为例。Windows提供的一些酷炫功能，如**缩略图工具栏**和**Aero Peek**，通过这个附加模块得到了Qt的支持。
- en: 'Well, adding this module to the project file directly, which in this case is
    `Fancy_Clock.pro` file, will definitely upset other platforms. A better way to
    do this is to test whether it''s on Windows; if so, add this module to the project.
    Otherwise, skip this step. The following code shows you the `Fancy_Clock.pro`
    file, which will add the `winextras` module if it''s built on Windows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，直接将此模块添加到项目文件中，在这种情况下是 `Fancy_Clock.pro` 文件，肯定会惹恼其他平台。更好的方法是测试它是否在 Windows
    上；如果是，则将此模块添加到项目中。否则，跳过此步骤。以下代码显示了 `Fancy_Clock.pro` 文件，如果它在 Windows 上构建，则会添加
    `winextras` 模块：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, `win32` is a conditional statement, which is `true` only if
    the host machine is Windows. After a `qmake` rerun for this project, you'll be
    able to include and utilize those extra classes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`win32` 是一个条件语句，仅在主机机器是 Windows 时才为 `true`。在为该项目重新运行 `qmake` 之后，你将能够包含并使用那些额外的类。
- en: 'Similarly, if you want to do something on the Unix platforms, simply use the
    keyword `unix`, but `unix` will be `true` only on Linux/X11 or Mac OS X. To distinguish
    Mac OS X from Linux, here''s an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你想在 Unix 平台上做些什么，只需使用关键字 `unix`，但 `unix` 只在 Linux/X11 或 Mac OS X 上为 `true`。为了区分
    Mac OS X 和 Linux，这里有一个例子：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In fact, you can just use `unix: !macx` as the conditional statement to do
    some platform-specific work on Linux. It''s a common practice to have many platform-specific
    statements in the project file(s), especially when your project needs to be linked
    with other libraries. You have to specify different paths for these libraries
    on different platforms, otherwise the compiler will complain about missing libraries
    or unknown symbols.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，你可以使用 `unix: !macx` 作为条件语句在 Linux 上执行一些特定平台的工作。在项目文件（s）中包含许多特定平台语句是一种常见做法，特别是当你的项目需要与其他库链接时。你必须为这些库在不同的平台上指定不同的路径，否则编译器会抱怨缺少库或未知符号。'
- en: 'In addition to this, you may want to know how to write platform-specific code
    while keeping it from other platforms. Similar to C++, it''s a predefined macro
    that is handled by various compilers. However, these compiler macro lists may
    differ from one compiler to another. So, it is better to use `Global Qt Declarations`
    instead. I''ll use a the following short example to explain this further:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能还想知道如何在保持与其他平台兼容的同时编写特定平台的代码。类似于 C++，它是一个由各种编译器处理的预定义宏。然而，这些编译器宏列表可能因编译器而异。因此，最好使用
    `Global Qt Declarations`。我将使用以下简短示例进一步解释这一点：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code shows you the new version of `showContextMenu`. The `Preference`
    menu entry will use different texts on different platforms, namely Windows, Linux,
    and Mac OS X. Change your `showContextMenu` function and run it again. You'll
    see **Options** on Windows, **Profile** on Linux, and **Preference** on Mac OS
    X. Below is a list concerning the platform-specific macros. You can get a full
    description, including other macros, functions, and types on the `QtGlobal` document.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了 `showContextMenu` 的新版本。`Preference` 菜单项将在不同的平台上使用不同的文本，即 Windows、Linux
    和 Mac OS X。更改你的 `showContextMenu` 函数并再次运行它。你将在 Windows 上看到 **选项**，在 Linux 上看到
    **配置文件**，在 Mac OS X 上看到 **偏好设置**。以下是有关特定平台宏的列表。你可以在 `QtGlobal` 文档中找到完整的描述，包括其他宏、函数和类型。
- en: '| Macro | Correspond Platform |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 宏 | 对应平台 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Q_OS_ANDROID | Android |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_ANDROID | Android |'
- en: '| Q_OS_FREEBSD | FreeBSD |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_FREEBSD | FreeBSD |'
- en: '| Q_OS_LINUX | Linux |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_LINUX | Linux |'
- en: '| Q_OS_IOS | iOS |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_IOS | iOS |'
- en: '| Q_OS_MAC | Mac OS X and iOS (Darwin-based) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_MAC | Mac OS X 和 iOS (基于 Darwin) |'
- en: '| Q_OS_WIN | All Windows platforms, including Windows CE |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_WIN | 所有 Windows 平台，包括 Windows CE |'
- en: '| Q_OS_WINPHONE | Windows Phone 8 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_WINPHONE | Windows Phone 8 |'
- en: '| Q_OS_WINRT | Windows Runtime on Windows 8\. Windows RT and Windows Phone
    8 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Q_OS_WINRT | Windows 8 上的 Windows Runtime。Windows RT 和 Windows Phone 8 |'
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, information, including some tricks, about UI designing is included.
    Furthermore, there are basic yet useful cross-platform topics. Now, you're able
    to write an elegant Qt application in your favorite, and possibly already mastered,
    C++.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，包括一些技巧在内的 UI 设计信息。此外，还有一些基本但有用的跨平台主题。现在，你能够使用你最喜欢的，也许已经熟练掌握的 C++ 编写优雅的
    Qt 应用程序。
- en: In the next chapter, we are going to learn how to write an application in Qt
    Quick. However, fear not; Qt Quick is even easier and, of course, quicker to develop.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Qt Quick 编写应用程序。然而，无需担心；Qt Quick 甚至更容易，当然，开发起来也更快。
