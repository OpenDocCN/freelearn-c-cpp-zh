<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 10. A Chapter You Shouldnt Skip - Final Optimizations"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/><span class="koboSpan" id="kobo.1.1">Chapter 10. A Chapter You Shouldnt Skip - Final Optimizations</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">What's the most important aspect of any game? </span><span class="koboSpan" id="kobo.2.2">According to a very famous e-celebrity, it's being able to play it. </span><span class="koboSpan" id="kobo.2.3">Fancy graphics and advanced techniques definitely add a necessary touch of polish to a medium as visual and interactive as video games, but if that gets in the way of enjoying the most fundamental experience of smooth gameplay, the whole thing might as well just be a fancy screensaver. </span><span class="koboSpan" id="kobo.2.4">Optimizing code, even when the application runs fine on higher-end machines, is extremely important, since every iteration excludes potential machines that are older but could still be used to expand the fan base of a game.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we will be covering the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">The basics of profiling and reading code metrics</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Analyzing and repairing inefficiencies in our code</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">The basics of light culling</span></li></ul></div><p><span class="koboSpan" id="kobo.7.1">Let's not waste any more clock cycles and get to cleaning up some of those inefficiencies!</span></p><div class="section" title="Use of third-party software"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec89"/><span class="koboSpan" id="kobo.8.1">Use of third-party software</span></h1></div></div></div><p><span class="koboSpan" id="kobo.9.1">As expected, we can't do all of this work with no additional tools. </span><span class="koboSpan" id="kobo.9.2">Profiling applications is a subject that requires a backend of established software, used to neatly organize and present us with the data of performance subtleties. </span><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">CodeXL</span></em></span><span class="koboSpan" id="kobo.11.1"> is an application we have already covered in </span><a class="link" href="ch09.html" title="Chapter 9.  The Speed of Dark - Lighting and Shadows"><span class="koboSpan" id="kobo.12.1">Chapter 9
</span></a><span class="koboSpan" id="kobo.13.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">The Speed of Dark - Lighting and Shadows</span></em></span><span class="koboSpan" id="kobo.15.1"> and although we used it to view runtime OpenGL states, it also has quite a suite of options used to profile both CPU and GPU code. </span><span class="koboSpan" id="kobo.15.2">It can be found and downloaded here: </span><a class="ulink" href="http://gpuopen.com/compute-product/codexl/"><span class="koboSpan" id="kobo.16.1">http://gpuopen.com/compute-product/codexl/</span></a><span class="koboSpan" id="kobo.17.1">.</span></p><p><span class="koboSpan" id="kobo.18.1">Of course, if we don't have AMD hardware, only a very limited set of tools for profiling are available. </span><span class="koboSpan" id="kobo.18.2">Although we can get by with the limited CPU profiling options, GPU profiling on an Nvidia card, for example, would require a different tool. </span><span class="koboSpan" id="kobo.18.3">There are some choices out there, but one notable option is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Nvidia Nsight</span></em></span><span class="koboSpan" id="kobo.20.1">: </span><a class="ulink" href="http://www.nvidia.com/object/nsight.html"><span class="koboSpan" id="kobo.21.1">http://www.nvidia.com/object/nsight.html</span></a><span class="koboSpan" id="kobo.22.1">.</span></p><p><span class="koboSpan" id="kobo.23.1">It's worth mentioning, however, that the newest versions of Nsight don't support some of the legacy functions SFML invokes, so the functionalities are, once again, rather limited.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The devil's in the details"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec90"/><span class="koboSpan" id="kobo.1.1">The devil's in the details</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">They say that a master craftsman knows not only how, but also when to use their tools. </span><span class="koboSpan" id="kobo.2.2">Many programmers often enough arrive at the false conclusion that they must constantly write beautiful, efficient, and overall perfect code that will never fail. </span><span class="koboSpan" id="kobo.2.3">In practice, this couldn't be farther from the truth. </span><span class="koboSpan" id="kobo.2.4">Many find this out the hard way. </span><span class="koboSpan" id="kobo.2.5">As </span><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">Donald Knuth</span></em></span><span class="koboSpan" id="kobo.4.1"> said:</span></p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">"Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. </span><span class="koboSpan" id="kobo.5.2">We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil."</span></em></span></p></blockquote></div><p><span class="koboSpan" id="kobo.6.1">This doesn't mean that one shouldn't take performance into consideration. </span><span class="koboSpan" id="kobo.6.2">Things such as designing a class with later features in mind, or even picking the right algorithm for the job both fall under that remaining 3%. </span><span class="koboSpan" id="kobo.6.3">Rather, it simply means that, unless the application is noticeably slow, tackling performance issues in code should be one of the final tasks at all times.</span></p><p><span class="koboSpan" id="kobo.7.1">Another common mistake programmers often make is relying on intuition when it comes to evaluating performance. </span><span class="koboSpan" id="kobo.7.2">It's easy to forget that a program has tons of underlying complexity and moving parts, which is why it's incredibly hard to always know exactly how a specific chunk of code is going to behave unless properly tested. </span><span class="koboSpan" id="kobo.7.3">That's the key here always profile! </span><span class="koboSpan" id="kobo.7.4">Is the game running slow? </span><span class="koboSpan" id="kobo.7.5">Break out the profiler and take it for a spin. </span><span class="koboSpan" id="kobo.7.6">Feeling like enemy path-finding code is really weighing down on performance? </span><span class="koboSpan" id="kobo.7.7">Don't feel, just profile! </span><span class="koboSpan" id="kobo.7.8">The same thing can be said about the state of your code after optimizations have been made. </span><span class="koboSpan" id="kobo.7.9">Don't just replace a ton of code and assume it runs faster. </span><span class="koboSpan" id="kobo.7.10">Take a base measurement, make the appropriate changes, and profile the final result to make sure the new code runs faster. </span><span class="koboSpan" id="kobo.7.11">Starting to see the picture? </span><span class="koboSpan" id="kobo.7.12">Good. </span><span class="koboSpan" id="kobo.7.13">With that out of the way, let's jump straight into the basics of profiling!</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Profiling basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec91"/><span class="koboSpan" id="kobo.1.1">Profiling basics</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There's a variety of different ways an application can be profiled. </span><span class="koboSpan" id="kobo.2.2">Anything from branching and individual instructions, to usage of caches and patterns of data access can be tracked in a project. </span><span class="koboSpan" id="kobo.2.3">Since our game isn't exactly overflowing with complexity, however, we really only need to worry about time-based profiling.</span></p><p><span class="koboSpan" id="kobo.3.1">There are three basic ways a profiler can gather information about an application:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.4.1">Sampling</span></strong></span><span class="koboSpan" id="kobo.5.1">: This is a periodic application stack capture that yields relatively inaccurate results, yet has very little overhead.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.6.1">Event collection</span></strong></span><span class="koboSpan" id="kobo.7.1">: This involves tapping into the compilation process and configuring it in such a way that allows certain information to be sent to the profiling DLLs. </span><span class="koboSpan" id="kobo.7.2">A higher amount of overhead with a higher precision.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">Instrumentation</span></strong></span><span class="koboSpan" id="kobo.9.1">: This involves direct code injection into the application during run time that allows for the most precise results and has the highest level of overhead.</span></li></ul></div><p><span class="koboSpan" id="kobo.10.1">Any of these techniques can be utilized, depending on what software is being used and the data it needs to collect. </span><span class="koboSpan" id="kobo.10.2">Because we don't really need incredibly precise results to locate the hotspots of our code, it's best to go with a sampling approach.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/><span class="koboSpan" id="kobo.11.1">Tip</span></h3><p><span class="koboSpan" id="kobo.12.1">As we have already established, profiling is not a free task. </span><span class="koboSpan" id="kobo.12.2">In some instances, it can slow down an application to a crawl, which, depending on the task, can be absolutely normal.</span></p></div></div><div class="section" title="Time-based sampling"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec108"/><span class="koboSpan" id="kobo.13.1">Time-based sampling</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">Using the time-based sampling technique will create a rough estimate of all of the application's function/method calls, initializations/destructions, virtually anything that can be created or invoked, and assign a sample value to them. </span><span class="koboSpan" id="kobo.14.2">This even includes underlying libraries, such as STL, SFML, OpenGL, and so on. </span><span class="koboSpan" id="kobo.14.3">If your code uses it, it will be on the list.</span></p><p><span class="koboSpan" id="kobo.15.1">This sample value represents how much time is spent executing a certain line of code. </span><span class="koboSpan" id="kobo.15.2">There are two types of time samples:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">Inclusive</span></strong></span><span class="koboSpan" id="kobo.17.1">: This involves all of the time spent inside a specific line/chunk of code, including all of the time it took to execute other functions that may have been called.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">Exclusive</span></strong></span><span class="koboSpan" id="kobo.19.1">: This involves only the amount of time that a specific line/chunk of code took to execute on its own.</span></li></ul></div><p><span class="koboSpan" id="kobo.20.1">We are not necessarily going to be dealing with exclusive sample counts, but it's important to understand these terms nonetheless.</span></p><p><span class="koboSpan" id="kobo.21.1">Lastly, it's important to understand that samples are relative. </span><span class="koboSpan" id="kobo.21.2">If a program is running slowly, fewer samples will be captured across the board. </span><span class="koboSpan" id="kobo.21.3">This particular benchmark shouldn't be interpreted based on quantity, but rather in comparison to the rest of the code.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/><span class="koboSpan" id="kobo.22.1">Note</span></h3><p><span class="koboSpan" id="kobo.23.1">Sampling should always be done with all of the relevant project's optimizations enabled, because it strips away unnecessary code that's used for debugging, which would interfere with the results. </span><span class="koboSpan" id="kobo.23.2">In the case of Visual Studio, the release mode should be used when sampling.</span></p></div></div></div><div class="section" title="Sampling our application"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec109"/><span class="koboSpan" id="kobo.24.1">Sampling our application</span></h2></div></div></div><p><span class="koboSpan" id="kobo.25.1">Now that we have the fundamentals covered, let's actually fire up a profile and get started! </span><span class="koboSpan" id="kobo.25.2">The first important aspect of this process is actually spending enough time sampling the state of the desired application. </span><span class="koboSpan" id="kobo.25.3">In our case, sampling should be done in the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">Game</span></code><span class="koboSpan" id="kobo.27.1"> state, and for at least 20 seconds, to capture enough information. </span><span class="koboSpan" id="kobo.27.2">It isn't going to help us understand the time complexities of the entity component system, for example, if the majority of the application sampling time is spent inside the menu state.</span></p><p><span class="koboSpan" id="kobo.28.1">Secondly, we should probably test our application in a stressful state, just to make sure it holds up well under nonideal conditions. </span><span class="koboSpan" id="kobo.28.2">For our purposes, we will simply add a bunch more entities, particle emitters, and lights to the scene until a </span><span class="strong"><strong><span class="koboSpan" id="kobo.29.1">stress test</span></strong></span><span class="koboSpan" id="kobo.30.1"> that looks like the following is constructed:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.31.1"><img src="graphics/image_10_001.jpg" alt="Sampling our application"/></span></div><p><span class="koboSpan" id="kobo.32.1">It isn't pretty, but then again, neither are performance issues.</span></p><p><span class="koboSpan" id="kobo.33.1">Once the application has been sampled enough and is terminated, most profilers will show a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.34.1">profile overview</span></em></span><span class="koboSpan" id="kobo.35.1"> of all the processes that have been running during the sampling process. </span><span class="koboSpan" id="kobo.35.2">It's important to select only our game by clicking on it, because that's what we're interested in.</span></p><p><span class="koboSpan" id="kobo.36.1">After navigating to the </span><span class="strong"><strong><span class="koboSpan" id="kobo.37.1">Function</span></strong></span><span class="koboSpan" id="kobo.38.1"> tab, we should be left with something similar to this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.39.1"><img src="graphics/image_10_002.jpg" alt="Sampling our application"/></span></div><p><span class="koboSpan" id="kobo.40.1">By clicking on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.41.1">Timer</span></strong></span><span class="koboSpan" id="kobo.42.1"> tab and sorting entries in a descending order, we can view the functions that have the highest amount of samples, thus taking the most time to run. </span><span class="koboSpan" id="kobo.42.2">This is where you will find the trade-off between using a general purpose library such as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.43.1">SFML</span></em></span><span class="koboSpan" id="kobo.44.1"> and sacrificing some performance. </span><span class="koboSpan" id="kobo.44.2">While it's true that writing case-specific code would probably be more optimal in terms of performance, it's still a worthy price to pay when considering how versatile SFML is for small to medium-sized projects.</span></p><p><span class="koboSpan" id="kobo.45.1">While it's obvious our own SFML rendering code could probably use some work and utilize vertex arrays when rendering sprites and tiles to reduce this bottleneck, we're not going to concern ourselves with SFML-specific optimizations this time. </span><span class="koboSpan" id="kobo.45.2">Instead, let's analyze the highlighted entries on the list first. </span><span class="koboSpan" id="kobo.45.3">As the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">glm::</span></code><span class="koboSpan" id="kobo.47.1"> namespace seems to suggest, the OpenGL math library we're using for various calculations is the culprit. </span><span class="koboSpan" id="kobo.47.2">Upon closer inspection, it seems that all three of these hotspots have to do with matrix operations; the most expensive of which is the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">glm::operator*</span></code><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">By right-clicking on the entry, we can view it in a call graph.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/><span class="koboSpan" id="kobo.50.1">Note</span></h3><p><span class="koboSpan" id="kobo.51.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">call graph</span></strong></span><span class="koboSpan" id="kobo.53.1"> is a tool that helps locate all points in our code that use a specific function.</span></p></div></div><p><span class="koboSpan" id="kobo.54.1">By simply analyzing the information onscreen, we're now able to see what code uses the GLM matrices in such a way that causes performance problems:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.55.1"><img src="graphics/image_10_003.jpg" alt="Sampling our application"/></span></div><p><span class="koboSpan" id="kobo.56.1">As the </span><span class="strong"><strong><span class="koboSpan" id="kobo.57.1">Parents</span></strong></span><span class="koboSpan" id="kobo.58.1"> section indicates, the majority of time samples regarding this particular bottleneck are located inside the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">GL_Transform::GetModelMatrix()</span></code><span class="koboSpan" id="kobo.60.1"> method. </span><span class="koboSpan" id="kobo.60.2">Double-clicking on the function allows us to also view the code and specific hotspots of each individual line:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.61.1"><img src="graphics/image_10_004.jpg" alt="Sampling our application"/></span></div><p><span class="koboSpan" id="kobo.62.1">This should all start to add up by now. </span><span class="koboSpan" id="kobo.62.2">The two most sampled lines in relation to matrices were </span><code class="literal"><span class="koboSpan" id="kobo.63.1">glm::tmat4x4&lt;float,0&gt;::tmat4x4&lt;float,0&gt;(float const&amp;)</span></code><span class="koboSpan" id="kobo.64.1">, which is the matrix constructor, and </span><code class="literal"><span class="koboSpan" id="kobo.65.1">glm::rotate</span></code><span class="koboSpan" id="kobo.66.1">, which we're calling three times. </span><span class="koboSpan" id="kobo.66.2">Every time we want to obtain a model matrix from this class (which is once for each shadow caster every frame), a bunch of new matrices are constructed and filled out using quite expensive GLM function calls, not to mention being multiplied later as well.</span></p></div><div class="section" title="Finding GPU bottlenecks"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec110"/><span class="koboSpan" id="kobo.67.1">Finding GPU bottlenecks</span></h2></div></div></div><p><span class="koboSpan" id="kobo.68.1">Finding GPU bottlenecks is fairly similar to what we did with the CPU. </span><span class="koboSpan" id="kobo.68.2">It also utilizes time sampling and will generate similar looking reports that list OpenGL code based on how long it took to execute, as follows:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.69.1"><img src="graphics/image_10_005.jpg" alt="Finding GPU bottlenecks"/></span></div><p><span class="koboSpan" id="kobo.70.1">We're not going to be covering GPU optimizations heavily here, but the idea is exactly the same: finding bottlenecks, re-implementing code in a more efficient manner, and testing again.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/><span class="koboSpan" id="kobo.71.1">Note</span></h3><p><span class="koboSpan" id="kobo.72.1">Some GPU profiling tools, such as Nvidia Nsight, don't support legacy OpenGL API calls made by SFML.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Improving CPU code performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec92"/><span class="koboSpan" id="kobo.1.1">Improving CPU code performance</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">After establishing a baseline reading, we can begin making changes to our code. </span><span class="koboSpan" id="kobo.2.2">Some of these changes involve simply understanding the libraries we're using and being more cautious about the way they're deployed, while others revolve around making better design choices, applying faster and more appropriate algorithms, designing data structures better, and using the newest features of the C++ standard. </span><span class="koboSpan" id="kobo.2.3">Let's begin by taking a look at some easy changes that can be made to our code.</span></p><div class="section" title="Optimizing the three most obvious bottlenecks"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec111"/><span class="koboSpan" id="kobo.3.1">Optimizing the three most obvious bottlenecks</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Judging by the profiler's results, there is quite a bit of room for improvement of the code we've written so far. </span><span class="koboSpan" id="kobo.4.2">In this section, we're going to be addressing three of the most inefficient implementations and how they can be fixed.</span></p><div class="section" title="GL_Transform optimizations"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec25"/><span class="koboSpan" id="kobo.5.1">GL_Transform optimizations</span></h3></div></div></div><p><span class="koboSpan" id="kobo.6.1">The very first example we used to illustrate how time sampling works is a perfect candidate for improvement. </span><span class="koboSpan" id="kobo.6.2">There really is nothing subtle about it. </span><span class="koboSpan" id="kobo.6.3">First, the recalculation of all matrices involved in obtaining a model matrix every time one is requested is incredibly inefficient. </span><span class="koboSpan" id="kobo.6.4">To add insult to injury, all </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">7</span></em></span><span class="koboSpan" id="kobo.8.1"> of those matrices has to be created all over again. </span><span class="koboSpan" id="kobo.8.2">That's a lot of clock cycles wasted for no reason. </span><span class="koboSpan" id="kobo.8.3">Let's see how that can be quickly improved:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">class GL_Transform { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.9.2">const glm::mat4&amp; GetModelMatrix(); 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.9.3">bool m_needsUpdate; 
  glm::mat4 m_matPos; 
  glm::mat4 m_matScale; 
  glm::mat4 m_matRotX; 
  glm::mat4 m_matRotY; 
  glm::mat4 m_matRotZ; 
  glm::mat4 m_matRotCombined; 
  glm::mat4 m_modelMatrix; // Final matrix. 
</span><span class="koboSpan" id="kobo.9.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Firstly, notice the change of the return parameter of </span><code class="literal"><span class="koboSpan" id="kobo.11.1">GetModelMatrix</span></code><span class="koboSpan" id="kobo.12.1"> to a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">const</span></em></span>
<span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">reference</span></em></span><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">This ensures that we're not returning a newly constructed matrix each time. </span><span class="koboSpan" id="kobo.15.3">Additionally, we have added a Boolean flag that will help us keep track of whether the position, scale, or rotation of the object has changed and whether the model matrix needs to be updated to reflect that. </span><span class="koboSpan" id="kobo.15.4">Lastly, we're storing all 7 matrices inside the transform object now, so that they are created only once. </span><span class="koboSpan" id="kobo.15.5">This is important, because we don't want to recalculate three rotational matrices along with its combined matrix, for example, just because the position of the object was changed.</span></p><p><span class="koboSpan" id="kobo.16.1">Next, let's actually implement these changes, starting with the setters of this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">void GL_Transform::SetPosition(const glm::vec3&amp; l_pos) { 
  if (l_pos == m_position) { return; } 
  m_position = l_pos; 
  m_matPos = glm::translate(m_position); 
  m_needsUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.18.1">The general idea here is to first check whether the argument provided to the setter method isn't already the current value of whatever parameter it's supposed to override. </span><span class="koboSpan" id="kobo.18.2">If it isn't, the position is changed and the position matrix is updated, along with the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">m_needsUpdate</span></code><span class="koboSpan" id="kobo.20.1"> flag being set to </span><code class="literal"><span class="koboSpan" id="kobo.21.1">true</span></code><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">This will ensure that the model matrix is updated later on.</span></p><p><span class="koboSpan" id="kobo.23.1">Rotation follows the exact same principle:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">void GL_Transform::SetRotation(const glm::vec3&amp; l_rot) { 
  if (l_rot == m_rotation) { return; } 
  if (l_rot.x != m_rotation.x) { 
    m_matRotX = glm::rotate(m_rotation.x, glm::vec3(1, 0, 0)); 
  } 
  if (l_rot.y != m_rotation.y) { 
    m_matRotY = glm::rotate(m_rotation.y, glm::vec3(0, 1, 0)); 
  } 
  if (l_rot.z != m_rotation.z) { 
    m_matRotZ = glm::rotate(m_rotation.z, glm::vec3(0, 0, 1)); 
  } 
  m_matRotCombined = m_matRotZ * m_matRotY * m_matRotX; 
  m_rotation = l_rot; 
  m_needsUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.25.1">Before the assignment is committed to, however, we must check each individual member of the vector class, because each one of them has their own matrix. </span><span class="koboSpan" id="kobo.25.2">The point, as it's becoming clearer and clearer now, is to only calculate what we absolutely have to.</span></p><p><span class="koboSpan" id="kobo.26.1">Scale, once again, follows this idea exactly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">void GL_Transform::SetScale(const glm::vec3&amp; l_scale) { 
  if (l_scale == m_scale) { return; } 
  m_scale = l_scale; 
  m_matScale = glm::scale(m_scale); 
  m_needsUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">The </span><code class="literal"><span class="koboSpan" id="kobo.29.1">GetModelMatrix</span></code><span class="koboSpan" id="kobo.30.1"> method should now be implemented this way:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">const glm::mat4&amp; GL_Transform::GetModelMatrix() { 
  if (m_needsUpdate) { 
    m_modelMatrix = m_matPos * m_matRotCombined * m_matScale; 
    m_needsUpdate = false; 
  } 
  return m_modelMatrix; 
} 
</span></pre><p><span class="koboSpan" id="kobo.32.1">First, the update flag is checked to determine whether the matrix needs to be updated. </span><span class="koboSpan" id="kobo.32.2">If it does, all three relevant matrices are multiplied and the flag is reset back to </span><code class="literal"><span class="koboSpan" id="kobo.33.1">false</span></code><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">We then return the const reference to the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">m_modelMatrix </span></code><span class="koboSpan" id="kobo.36.1">data member, ensuring one isn't created just to be thrown away later.</span></p><p><span class="koboSpan" id="kobo.37.1">Let's follow our own advice and profile the application again to make sure our changes worked:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.38.1"><img src="graphics/image_10_006.jpg" alt="GL_Transform optimizations"/></span></div><p><span class="koboSpan" id="kobo.39.1">All three of the previously highlighted lines to do with </span><code class="literal"><span class="koboSpan" id="kobo.40.1">glm::</span></code><span class="koboSpan" id="kobo.41.1"> have now completely disappeared from the top of the list! </span><span class="koboSpan" id="kobo.41.2">The highlighted exception in this illustration was taken during the sampling of </span><code class="literal"><span class="koboSpan" id="kobo.42.1">GL_Transform::GetModelMatrix()</span></code><span class="koboSpan" id="kobo.43.1"> that </span><span class="strong"><strong><span class="koboSpan" id="kobo.44.1">did not</span></strong></span><span class="koboSpan" id="kobo.45.1"> return by const reference, just to show that our approach does indeed work. </span><span class="koboSpan" id="kobo.45.2">When the method does return a const reference, even the highlighted function completely vanishes. </span><span class="koboSpan" id="kobo.45.3">This perfectly illustrates how avoiding useless copies of data can vastly improve overall performance.</span></p></div><div class="section" title="Particle system optimizations"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec26"/><span class="koboSpan" id="kobo.46.1">Particle system optimizations</span></h3></div></div></div><p><span class="koboSpan" id="kobo.47.1">Another massive bottleneck that's right at the top of the sample list is the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">ParticleSystem::Draw</span></code><span class="koboSpan" id="kobo.49.1"> method. </span><span class="koboSpan" id="kobo.49.2">In fact, it's the highest sampled piece of code that we have actually written. </span><span class="koboSpan" id="kobo.49.3">It's understandable that rendering so many particles would be taxing, but in this case, the unoptimized version of this method knocks the frame rate of our game down to 10 FPS:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.50.1"><img src="graphics/image_10_007.jpg" alt="Particle system optimizations"/></span></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip52"/><span class="koboSpan" id="kobo.51.1">Tip</span></h3><p><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">Fraps</span></strong></span><span class="koboSpan" id="kobo.53.1"> is a free piece of screen capture software that can record video, take screenshots, and most importantly for our purposes, show the frame rate! </span><span class="koboSpan" id="kobo.53.2">Although it's Windows specific, there are other tools like it for Linux and OSX. </span><span class="koboSpan" id="kobo.53.3">The frame rate counter can also be easily implemented by simply counting the frames in our code and displaying the result using SFML.</span></p></div></div><p><span class="koboSpan" id="kobo.54.1">That is absolutely unforgivable, so let's break out the profiler and dissect the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Draw</span></code><span class="koboSpan" id="kobo.56.1"> method:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.57.1"><img src="graphics/image_10_008.jpg" alt="Particle system optimizations"/></span></div><p><span class="koboSpan" id="kobo.58.1">Judging by the sample count, the main inefficiency lies somewhere inside the material value shader pass, where each particle is rendered for the normal and specular passes. </span><span class="koboSpan" id="kobo.58.2">There is something slightly weird going on, though, and that's the fact that the normal pass samples seem to be really low, but when the time comes to render for the specular pass, they suddenly jump much higher. </span><span class="koboSpan" id="kobo.58.3">This may look especially weird considering all we're doing is setting a </span><code class="literal"><span class="koboSpan" id="kobo.59.1">vec3</span></code><span class="koboSpan" id="kobo.60.1"> uniform and drawing to a render texture. </span><span class="koboSpan" id="kobo.60.2">This is where further digging through the function stack and understanding of how SFML needs to handle things behind the scenes comes in:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.61.1"><img src="graphics/image_10_009.jpg" alt="Particle system optimizations"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.62.1">Because of context switching and the way render textures work behind the scenes, it's extremely inefficient to render two different types of material maps as we did. </span><span class="koboSpan" id="kobo.62.2">Switching textures too many times during runtime can cause serious performance bottlenecks, which is why sprite and tile sheets are used by games, rather than individual images.</span></p><p><span class="koboSpan" id="kobo.63.1">Let's try and split up these two different types into two separate loops, making sure only one texture is being rendered two at a time:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.64.1">void ParticleSystem::Draw(MaterialMapContainer&amp; l_materials, ...) { 
  ... 
  </span><span class="koboSpan" id="kobo.64.2">if (renderer-&gt;UseShader("MaterialValuePass")) { 
    auto shader = renderer-&gt;GetCurrentShader(); 
    // Normal pass. 
    </span><span class="koboSpan" id="kobo.64.3">auto texture = l_materials[MaterialMapType::Normal].get(); 
    shader-&gt;setUniform("material", 
      sf::Glsl::Vec3(0.5f, 0.5f, 1.f)); 
    for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
      ... 
      </span><span class="koboSpan" id="kobo.64.4">renderer-&gt;Draw(drawables[i], texture); 
    } 
 
    // Specular pass. 
    </span><span class="koboSpan" id="kobo.64.5">texture = l_materials[MaterialMapType::Specular].get(); 
    shader-&gt;setUniform("material", sf::Glsl::Vec3(0.f, 0.f, 0.f)); 
    for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
      ... 
      </span><span class="koboSpan" id="kobo.64.6">renderer-&gt;Draw(drawables[i], texture); 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.64.7">} 
</span></pre><p><span class="koboSpan" id="kobo.65.1">Note that the material uniform is also moved outside of the loop to prevent unnecessary copies from being constructed and sent to the shader every time. </span><span class="koboSpan" id="kobo.65.2">By just running the application now, a very obvious jump in performance will quickly become apparent. </span><span class="koboSpan" id="kobo.65.3">Let's see how much faster it got by simply splitting up the little bit of code we had into two pieces:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.66.1"><img src="graphics/image_10_010.jpg" alt="Particle system optimizations"/></span></div><p><span class="koboSpan" id="kobo.67.1">We just jumped from 10 FPS to 65 FPS by simply separating the normal and specular material passes! </span><span class="koboSpan" id="kobo.67.2">That's more like it! </span><span class="koboSpan" id="kobo.67.3">You will notice that this sudden jump in performance will increase the sample count drastically:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.68.1"><img src="graphics/image_10_011.jpg" alt="Particle system optimizations"/></span></div><p><span class="koboSpan" id="kobo.69.1">This is because the game is running much faster now and doesn't indicate that the function is taking more time to execute. </span><span class="koboSpan" id="kobo.69.2">Remember, the samples are relative. </span><span class="koboSpan" id="kobo.69.3">Upon looking through the list, the two previously highlighted bits of code are found much lower now, with sample counts in the 20s. </span><span class="koboSpan" id="kobo.69.4">That's only slightly lower than before, but because the samples are relative and they all jumped up to about 6 times higher, it indicates a huge performance gain.</span></p></div><div class="section" title="Light culling"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec27"/><span class="koboSpan" id="kobo.70.1">Light culling</span></h3></div></div></div><p><span class="koboSpan" id="kobo.71.1">The last main inefficiency we have to fix has to do with the lighting system implemented in </span><a class="link" href="ch08.html" title="Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting"><span class="koboSpan" id="kobo.72.1">Chapter 8
</span></a><span class="koboSpan" id="kobo.73.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.74.1">Let There Be Light! </span><span class="koboSpan" id="kobo.74.2">- An Introduction to Advanced Lighting</span></em></span><span class="koboSpan" id="kobo.75.1">, and </span><a class="link" href="ch09.html" title="Chapter 9.  The Speed of Dark - Lighting and Shadows"><span class="koboSpan" id="kobo.76.1">Chapter 9
</span></a><span class="koboSpan" id="kobo.77.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.78.1">The Speed of Dark - Lighting and Shadows</span></em></span><span class="koboSpan" id="kobo.79.1">.</span></p><p><span class="koboSpan" id="kobo.80.1">Dealing with multiple lights in a scene by using multipass shading/rendering is a great technique, but it can quickly become inefficient when those passes start to add up. </span><span class="koboSpan" id="kobo.80.2">The first obvious step to fixing that issue is not rendering lights that will not affect anything in the final image. </span><span class="koboSpan" id="kobo.80.3">The technique of reducing the number of objects being rendered by eliminating those that cannot be directly observed by the scene's view frustum, also known as </span><span class="strong"><strong><span class="koboSpan" id="kobo.81.1">culling</span></strong></span><span class="koboSpan" id="kobo.82.1">, is going to help out with that.</span></p><p><span class="koboSpan" id="kobo.83.1">Since we're only dealing with omni-directional point lights at this moment, culling lights can be achieved by simply checking for circle on rectangle collisions.</span></p><p><span class="koboSpan" id="kobo.84.1">Let's set up some helper functions to help us do that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.85.1">inline float GetDistance(const sf::Vector2f&amp; l_1, 
  const sf::Vector2f&amp; l_2) 
{ 
  return std::sqrt(std::pow(l_1.x - l_2.x, 2) + 
    std::pow(l_1.y - l_2.y, 2)); 
} 
 
inline bool CircleInView(const sf::View&amp; l_view, 
  const sf::Vector2f&amp; l_circleCenter, float l_circleRad) 
{ 
  auto HalfSize = l_view.getSize() / 2.f; 
  float OuterRadius = std::sqrt((HalfSize.x * HalfSize.x) + 
    (HalfSize.y * HalfSize.y)); 
  float AbsoluteDistance = GetDistance(l_view.getCenter(), 
    l_circleCenter); 
  if (AbsoluteDistance &gt; OuterRadius + l_circleRad) { 
    return false; 
  } 
  float InnerRadius = std::min(l_view.getSize().x, 
    l_view.getSize().y) / 2.f; 
  if (AbsoluteDistance &lt; InnerRadius + l_circleRad){return true;} 
  glm::vec2 dir = { 
    l_circleCenter.x - l_view.getCenter().x, 
    l_circleCenter.y - l_view.getCenter().y 
  }; 
  dir = glm::normalize(dir); 
  sf::Vector2f point = l_circleCenter + 
    sf::Vector2f(l_circleRad * dir.x, l_circleRad * dir.y); 
  auto rect = sf::FloatRect( 
    l_view.getCenter() - HalfSize, 
    l_view.getSize()); 
  return rect.contains(point); 
} 
</span></pre><p><span class="koboSpan" id="kobo.86.1">The function works by first creating an outer radius around the view's rectangle, so that we can default to a circle-on-circle collision checking for the majority of cases where the light is nowhere near the view frustum. </span><span class="koboSpan" id="kobo.86.2">The distance between the view's centre and circle's centre is obtained and checked for exceeding the sum of the view's outer bounding circle's radius summed with the circle's radius. </span><span class="koboSpan" id="kobo.86.3">This is the easiest way to check whether the light circle is anywhere close to the view's rectangle.</span></p><p><span class="koboSpan" id="kobo.87.1">If the light is closer to the view, another circle radius for the view's rectangle is constructed. </span><span class="koboSpan" id="kobo.87.2">This time, the circle is inside the view and only has the radius of the smaller dimension of the rectangle's size. </span><span class="koboSpan" id="kobo.87.3">If the distance between the light and the view's center is lower than the sum of the inner radius and the circle's radius, we know for sure that we have a collision. </span><span class="koboSpan" id="kobo.87.4">That's another common case that we can scratch off the list, before defaulting to a more complicated algorithm.</span></p><p><span class="koboSpan" id="kobo.88.1">Finally, if we know the light may be intersecting with one of the corners, its direction towards the view is normalized and used to obtain the closest point that is then checked for intersecting a constructed </span><code class="literal"><span class="koboSpan" id="kobo.89.1">sf::FloatRect</span></code><span class="koboSpan" id="kobo.90.1"> that represents our view.</span></p><p><span class="koboSpan" id="kobo.91.1">Actual changes to the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">RenderScene()</span></code><span class="koboSpan" id="kobo.93.1"> method of the light manager class simply involve storing a new list of lights that are definitely affecting something on screen, so that they can be passed to the shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.94.1">void LightManager::RenderScene() { 
  ... 
  </span><span class="koboSpan" id="kobo.94.2">std::vector&lt;LightBase*&gt; unculled; 
  for (auto&amp; light : m_lights) { 
    if (!Utils::CircleInView(currentView, 
      { light.m_lightPos.x, light.m_lightPos.y }, 
      light.m_radius)) 
    { continue; } 
    unculled.emplace_back(&amp;light); 
  } 
  auto&amp; beginning = unculled.begin(); 
  auto passes = static_cast&lt;int&gt;(std::ceil( 
    static_cast&lt;float&gt;(unculled.size()) / LightsPerPass)); 
  if (passes == 0) { passes = 1; } 
   
  for (int pass = 0; pass &lt; passes; ++pass) { 
    ... 
    </span><span class="koboSpan" id="kobo.94.3">for (int lightID = 0; lightID &lt; LightsPerPass; ++lightID) { 
      ... 
      </span><span class="koboSpan" id="kobo.94.4">DrawShadowMap(ShadowPassShaderHandle, **light, lightID); 
      ... 
    </span><span class="koboSpan" id="kobo.94.5">} 
    ... 
    </span><span class="koboSpan" id="kobo.94.6">for (int lightID = 0; lightID &lt; LightCount; ++lightID) { 
      ... 
      </span><span class="koboSpan" id="kobo.94.7">SubmitLightUniforms(LightPassShaderHandle,lightID, **light); 
      ... 
    </span><span class="koboSpan" id="kobo.94.8">} 
    ... 
    </span><span class="koboSpan" id="kobo.94.9">renderer-&gt;SwapTextures(); 
  } 
  ... 
</span><span class="koboSpan" id="kobo.94.10">} 
</span></pre><p><span class="koboSpan" id="kobo.95.1">Note that we're not taking into account the light's falloff or how it's attenuated in the shader to determine whether it should be culled or not.</span></p><p><span class="koboSpan" id="kobo.96.1">After all the unnecessary lights have been culled, only the very busy areas will experience some performance loss. </span><span class="koboSpan" id="kobo.96.2">At this point, it's the area of level design that should show concern and improve the architecture of the map.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec93"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Congratulations on making it all the way to the end! </span><span class="koboSpan" id="kobo.2.2">It has been quite a journey, and we can certainly say that a lot of things have been covered here that should inspire confidence in advanced game development in anyone. </span><span class="koboSpan" id="kobo.2.3">Even so, as always, there's still a ton of features, optimizations, techniques, and topics that we either just briefly touched upon, or haven't even acknowledged yet. </span><span class="koboSpan" id="kobo.2.4">Use that as inspiration to seek greatness, because, as we have already established, master craftsmen know not only how, but when to use their tools. </span><span class="koboSpan" id="kobo.2.5">While we have covered the basics, there are still many more tools to add to your tool belt. </span><span class="koboSpan" id="kobo.2.6">Use them, abuse them, break them and replace them. </span><span class="koboSpan" id="kobo.2.7">Do whatever it takes, but always remember to take something out of it and make it better next time.</span></p><p><span class="koboSpan" id="kobo.3.1">With that, may your next project exhibit that extra level of polish, and run just a little bit faster! </span><span class="koboSpan" id="kobo.3.2">Thanks for reading!</span></p></div></div></div></body></html>