<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Building a Spreadsheet Application</h1></div></div></div><p>In this chapter, we will start developing the last application of this book–a spreadsheet program capable of calculating numerical expressions as well as cutting and pasting cells with relative references. Similar to the word processor in the previous chapters, the spreadsheet program cuts and pastes ASCII and Unicode text as well as application-specific information. Moreover, it is possible to change the font and color of the cells and their horizontal and vertical alignment.</p><p>In this chapter, we will look at the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mouse and keyboard input</li><li class="listitem" style="list-style-type: disc">Drawing a spreadsheet</li><li class="listitem" style="list-style-type: disc">Saving and loading the spreadsheet</li><li class="listitem" style="list-style-type: disc">Cutting, copying, and pasting cell blocks</li><li class="listitem" style="list-style-type: disc">Fonts, colors, and alignments of cell blocks</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec34"/>The MainWindow class</h1></div></div></div><p>The <code class="literal">MainWindow</code> definition in this chapter looks very much like the previous definitions.</p><p>
<strong>MainWindow.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Token.h" &#13;
#include "Error.h" &#13;
#include "Scanner.h" &#13;
#include "TreeNode.h" &#13;
#include "Parser.h" &#13;
#include "Cell.h" &#13;
#include "CalcDocument.h" &#13;
 &#13;
void MainWindow(vector&lt;String&gt; /* argumentList */, &#13;
                WindowShow windowShow) { &#13;
  Application::ApplicationName() = TEXT("Calc"); &#13;
  Application::MainWindowPtr() = new CalcDocument(windowShow); &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec35"/>The CalcDocument class</h1></div></div></div><p>The <code class="literal">CalcDocument</code> class is the main class of the application. It catches mouse and keyboard events, handles scrolling and painting, and processes menu actions. However, the cell-level operations are handled by the <code class="literal">Cell</code> class, which we will cover in <a class="link" href="ch09.html" title="Chapter 9. Formula Interpretation">Chapter 9</a>, <em>Formula Interpretation</em>.</p><p>The user can mark one or several cells, in which case, the private field <code class="literal">calcMode</code> is set to <code class="literal">Mark</code>. The user can also edit the text in one cell, in which case the <code class="literal">calcMode</code> field is set to <code class="literal">Edit</code>. Similar to the word processor in the previous chapters, we refer to the current value of the <code class="literal">calcMode</code> field in expressions such as <strong>in mark mode</strong> and <strong>in edit mode</strong>.</p><pre class="programlisting">class CalcDocument : public StandardDocument { &#13;
  public: &#13;
    CalcDocument(WindowShow windowShow);       &#13;
</pre><p>The <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseMove</code>, and <code class="literal">OnDoubleClick</code> methods catch the mouse actions in the same way as in the previous applications. Note that we do not override the <code class="literal">OnMouseUp</code> method. Contrary to the word processor of <a class="link" href="ch07.html" title="Chapter 7. Keyboard Input and Character Calculation">Chapter 7</a>, <em>Keyboard Input and Character Calaculation</em>, this application remains in the <code class="literal">mark</code> mode until the user actually inputs a character, even if they mark only one cell. The user can also mark several cells by dragging the mouse.</p><pre class="programlisting">    void OnMouseDown(MouseButton mouseButtons, Point mousePoint,&#13;
                     bool shiftPressed, bool controlPressed);&#13;
    void OnMouseMove(MouseButton mouseButtons, Point mousePoint,&#13;
                     bool shiftPressed, bool controlPressed);&#13;
    void OnDoubleClick(MouseButton mouseButtons, Point mousePoint,&#13;
                     bool shiftPressed, bool controlPressed);&#13;
    void OnMouseUp(MouseButton mouseButtons, Point mousePoint,&#13;
                     bool shiftPressed, bool controlPressed);&#13;
</pre><p>The <code class="literal">OnHorizontalScroll</code> and <code class="literal">OnVerticalScroll</code> methods are called when the user changes the scroll bars. In the previous applications, we did not override these functions, but in this application, we want each scroll movement to result in a movement of an exact number of cells. Besides, in the <code class="literal">StandardDocument</code> constructor call, we use the <code class="literal">LogicalWithoutScroll</code> coordinate system in order to be able to handle the row and column headers of the spreadsheet, which are always located at the top and to the left of the client area regardless of the scroll bar settings. This implies that we have to handle scroll bar movements manually.</p><pre class="programlisting">    virtual void OnHorizontalScroll(WORD flags, WORD x); &#13;
    virtual void OnVerticalScroll(WORD flags, WORD y); &#13;
</pre><p>The user can mark all cells by clicking on the <strong>all </strong>box in the top-left corner (<code class="literal">ClickAll</code>), all cells in a column by clicking on the column header (<code class="literal">ClickCol</code>), all cells in a row by clicking on the row header (<code class="literal">ClickRow</code>), or just one of the cells (<code class="literal">ClickCell</code>) by clicking on the cell.</p><pre class="programlisting">    enum ClickArea {ClickAll, ClickRow, ClickColumn, ClickCell}; &#13;
</pre><p>The <code class="literal">GetMouseLocation</code> method analyzes a mouse click and returns one of the <code class="literal">ClickArea</code> values. If the user clicks on the right of the spreadsheet, the rightmost cell on the row is selected, and if they click below the spreadsheet, the cell at the bottom of the column is selected. The <code class="literal">Reference</code> class is defined in <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <em>The Auxiliary Classes</em>.</p><pre class="programlisting">    ClickArea GetMouseLocation(Point mousePoint, &#13;
                               Reference&amp; cellRef) const; &#13;
</pre><p>The <code class="literal">MarkBlock</code> method marks the blocks in the click area depending on the marks.</p><pre class="programlisting">    void MarkBlock(ClickArea clickArea, Reference newFirstMarkRef,&#13;
                   Reference newLastMarkRef);&#13;
</pre><p>The <code class="literal">OnDraw</code> method draws the row and column header as well as the cells themselves. In the <code class="literal">edit</code> mode, the <code class="literal">UpdateCaret</code> method sets the caret in the cell being edited.</p><pre class="programlisting">    void OnDraw(Graphics&amp; graphics, DrawMode drawMode) const; &#13;
    void UpdateCaret(); &#13;
</pre><p>When the user marks cells with the keyboard, the latest marked cell will always be visible. The <code class="literal">IsCellVisible</code> method returns <code class="literal">true</code> if it is visible, while the <code class="literal">MakeCellVisible</code> method makes sure it is visible by scrolling, if necessary.</p><p>The <code class="literal">MakeCellVisible</code> method without parameters calls the <code class="literal">MakeCellVisible</code> method with the parameter with the edited cell, or the last marked cell, depending on whether the application holds the <code class="literal">edit</code> or <code class="literal">mark</code> mode.</p><pre class="programlisting">    bool IsCellVisible(Reference cellRef) const; &#13;
    void MakeCellVisible(); &#13;
    void MakeCellVisible(Reference cellRect); &#13;
</pre><p>When the user finishes input text in a cell, the <code class="literal">ToMarkMode</code> method is called, which tries to change the application mode from <code class="literal">edit</code> to <code class="literal">mark</code>. It returns <code class="literal">false</code> if the input fails (if a formula with syntax error has been input):</p><pre class="programlisting">    bool ToMarkMode(); &#13;
</pre><p>The <code class="literal">Remark</code> method is called when the user has marked one or several cells. In order to avoid dazzle, it does not mark already marked cells:</p><pre class="programlisting">    void Remark(Reference newFirstRef, Reference newLastRef); &#13;
</pre><p>The <code class="literal">OnChar</code> method is called when the user inputs a character in <code class="literal">mark</code> mode; the application is changed to <code class="literal">edit</code> mode:</p><pre class="programlisting">    void OnChar(TCHAR tChar); &#13;
</pre><p>The <code class="literal">OnKeyDown</code> method calls one of the specific key handling methods, which changes the caret position in the <code class="literal">edit</code> mode and changes the cell markings in the <code class="literal">mark</code> mode:</p><pre class="programlisting">    bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                   bool controlPressed); &#13;
    void OnLeftArrowKey(bool shiftPressed); &#13;
    void OnRightArrowKey(bool shiftPressed); &#13;
    void OnUpArrowKey(bool shiftPressed); &#13;
    void OnDownArrowKey(bool shiftPressed); &#13;
    void OnHomeKey(bool shiftPressed, bool controlPressed); &#13;
    void OnEndKey(bool shiftPressed, bool controlPressed); &#13;
</pre><p>The <code class="literal">OnReturnKey</code> and <code class="literal">OnTabulatorKey</code> methods finish the input in the <code class="literal">edit</code> mode (unless a syntax error occurs) and moves the mark position one step down (<em>Return</em>), to the left (<em>Shift</em> + <em>Tab</em>) or to the right (<em>Tab</em>). However, in case of an error, an error message box is displayed and the <code class="literal">edit</code> mode remains. The only way for the user to finish the input of a formula with a syntax error is to press the <em>Esc</em> key, in which case the <code class="literal">OnEscapeKey</code> method is called and the cell's value is reset to the value which it held at the beginning of the input:</p><pre class="programlisting">    void OnReturnKey(); &#13;
    void OnTabulatorKey(bool shiftPressed); &#13;
    void OnEscapeKey(); &#13;
</pre><p>The <code class="literal">OnDeleteKey</code> and <code class="literal">OnBackspaceKey</code> methods remove the current character from the <code class="literal">edit</code> mode and clear the marked cells in the <code class="literal">mark</code> mode:</p><pre class="programlisting">    void OnDeleteKey(); &#13;
    void OnBackspaceKey(); &#13;
</pre><p>Similar to the previous applications, the <code class="literal">ClearDocument</code> method is called when the user selects the <strong>New</strong> menu item, the <code class="literal">ReadDocumentFromStream</code> method is called when they select the <strong>Open</strong> menu item, and the <code class="literal">WriteDocumentToStream</code> method is called when they select the <strong>Save</strong> or S<strong>ave As</strong> menu items:</p><pre class="programlisting">    void ClearDocument(); &#13;
    bool ReadDocumentFromStream(String name, istream&amp; inStream); &#13;
    bool WriteDocumentToStream(String name, ostream&amp; outStream) &#13;
                               const; &#13;
</pre><p>A text that begins with an equal sign (<strong>=</strong>) followed by a numerical expression with cell references is regarded as a <strong>formula</strong>. Technically, an equal sign followed by something other than a numerical expression is also considered a formula. However, in that case, it is a formula with a syntax error. When the user inputs a formula, the cells referred to in the formula constitute the cell's <strong>source set</strong>. The <strong>target set</strong> of a cell is made up by the cells that have it at a source (the sets are more exactly defined at the end of this chapter). The <code class="literal">WriteSetMapToStream</code> and <code class="literal">ReadSetMapFromStream</code> methods write and read the source and target set maps:</p><pre class="programlisting">    static bool WriteSetMapToStream(const map&lt;Reference, &#13;
                     set&lt;Reference&gt;&gt;&amp; setMap, ostream&amp; outStream); &#13;
    static bool ReadSetMapFromStream(map&lt;Reference,set&lt;Reference&gt;&gt; &#13;
                                     &amp;setMap, istream&amp; inStream); &#13;
</pre><p>In this application, we overwrite the methods <code class="literal">IsCopyAsciiReady</code>, <code class="literal">IsCopyUnicodeReady</code>, and <code class="literal">IsCopyGenericReady</code> from the <code class="literal">StandardDocument</code> class. They are called by the <code class="literal">OnCopy</code>  method in the <code class="literal">StandardDocument</code> class:</p><pre class="programlisting">    bool CopyEnable() const; &#13;
    bool IsCopyAsciiReady() const {return true;} &#13;
    bool IsCopyUnicodeReady() const {return true;} &#13;
    bool IsCopyGenericReady(int format) const {return true;} &#13;
</pre><p>It may seem strange that both the <code class="literal">CopyEnable</code> method and the three more specific enable methods are overridden. However, the <code class="literal">CopyEnable</code> method returns <code class="literal">true</code> if the application is ready for copying (which it is in the <code class="literal">mark</code> mode), while the other methods are called by the <code class="literal">OnCopy</code> method in the <code class="literal">StandardDocument</code> class to decide whether the application is ready to copy in the given format.</p><p>Their default implementation is to return <code class="literal">false</code>, but we need to override them, as it is always possible to copy the marked cells in <code class="literal">mark</code> mode:</p><pre class="programlisting">    void CopyAscii(vector&lt;String&gt;&amp; textList) const; &#13;
    void CopyUnicode(vector&lt;String&gt;&amp; textList) const; &#13;
    void CopyGeneric(int format, InfoList&amp; infoList) const; &#13;
</pre><p>We could override the <code class="literal">PasteEnable</code> method from the <code class="literal">StandardDocument</code> class in the same way we override the <code class="literal">CopyEnable</code> method. However, in this application, we need some finer testing. Therefore, we override the <code class="literal">IsPasteAsciiReady</code>, <code class="literal">IsPasteUnicodeReady</code>, and <code class="literal">IsPasteGenericReady</code> methods instead. In the word processor of the previous chapters, we could always paste text, irrespective of the number of characters or paragraphs. In this application, however, we need to check whether the block to be pasted fits in the spreadsheet:</p><pre class="programlisting">    bool IsPasteAsciiReady(const vector&lt;String&gt;&amp; textList) const; &#13;
    bool IsPasteUnicodeReady(const vector&lt;String&gt;&amp; textList)const; &#13;
    bool IsPasteGenericReady(int format, InfoList&amp; infoList)const; &#13;
</pre><p>Similar to the word processor, we override the <code class="literal">PasteAscii</code>, <code class="literal">PasteUnicode</code>, and <code class="literal">PasteGeneric</code> methods. Remember that these methods are called in the order in which the formats are given in the list in the <code class="literal">CalcDocument</code> constructor call. When the corresponding enable method <code class="literal">IsPasteAsciiReady</code>, <code class="literal">IsPasteUnicodeReady</code>, or <code class="literal">IsPasteGenericReady</code> returns <code class="literal">true</code>, the <code class="literal">PasteAscii</code>, <code class="literal">PasteUnicode</code>, or <code class="literal">PasteGeneric</code> method is called. Only the first paste method is called. If none of the enable methods returns <code class="literal">true</code>, none of the paste methods is called:</p><pre class="programlisting">    void PasteAscii(const vector&lt;String&gt;&amp; textList); &#13;
    void PasteUnicode(const vector&lt;String&gt;&amp; textList); &#13;
    void PasteGeneric(int format, InfoList&amp; infoList); &#13;
</pre><p>The <code class="literal">DeleteEnable</code> method always returns <code class="literal">true</code> in the <code class="literal">mark</code> mode, since there is always at least one cell marked and ready to be deleted. It returns <code class="literal">true</code> in the <code class="literal">edit</code> mode if the caret is not located at the end of the text of the edited cell.  The <code class="literal">OnDelete</code> method simply calls the <code class="literal">OnDeleteKey</code> method, because the <strong>Delete</strong> menu item has the same effect as that of a user pressing the <em>Delete</em> key:</p><pre class="programlisting">    bool DeleteEnable() const; &#13;
    void OnDelete(); &#13;
</pre><p>The <code class="literal">OnFont</code> and <code class="literal">OnBackgroundColor</code> methods are called when the user selects the <strong>Font</strong> or <strong>Background Color</strong> menu item. They display the standard <strong>Font</strong> or <strong>Color</strong> dialog:</p><pre class="programlisting">    DEFINE_VOID_LISTENER(CalcDocument, OnFont); &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnBackgroundColor); &#13;
</pre><p>Horizontally, the text of a cell can be aligned to left, center, right, or justified. Vertically, it can be aligned to top, center, or bottom. All the radio methods call the <code class="literal">IsHorizontalAlignment</code> or <code class="literal">IsVerticalAlignment</code> methods, and all the selection methods call the <code class="literal">SetHorizontalAlignment</code> or <code class="literal">SetVerticalAlignment</code> methods:</p><pre class="programlisting">    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalLeftRadio); &#13;
    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalCenterRadio); &#13;
    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalRightRadio); &#13;
    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalJustifiedRadio); &#13;
 &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalLeft); &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalCenter); &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalRight); &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalJustified); &#13;
 &#13;
    bool IsHorizontalAlignment(Alignment alignment) const; &#13;
    void SetHorizontalAlignment(Alignment alignment); &#13;
 &#13;
    DEFINE_BOOL_LISTENER(CalcDocument, VerticalTopRadio); &#13;
    DEFINE_BOOL_LISTENER(CalcDocument, VerticalCenterRadio); &#13;
    DEFINE_BOOL_LISTENER(CalcDocument, VerticalBottomRadio); &#13;
 &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnVerticalTop); &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnVerticalCenter); &#13;
    DEFINE_VOID_LISTENER(CalcDocument, OnVerticalBottom);     &#13;
 &#13;
    bool IsVerticalAlignment(Alignment alignment) const; &#13;
    void SetVerticalAlignment(Alignment alignment); &#13;
</pre><p>The <code class="literal">InterpretEditCell</code> method interprets the cell after the user has finished the input and creates a <strong>syntax tree</strong> (described in <a class="link" href="ch09.html" title="Chapter 9. Formula Interpretation">Chapter 9</a>, <em>Formula Interpretation</em>) in the case of a formula (or throws an exception in the case of syntax error). The <code class="literal">IsCircular</code> method returns <code class="literal">true</code> if the cell is part of a circular reference (the cell formula refers to itself, directly or indirectly). The <code class="literal">RemoveTargetSetMap</code> method removes the targets of the cell, and the <code class="literal">AddTargetSetMap</code> method adds targets to the cell. The <code class="literal">EvaluateCell</code> method evaluates the value of one cell, while the <code class="literal">EvaluateRecursive</code> method recursively evaluates the values of all its target cells. Finally, the <code class="literal">InvalidateCell</code> method invalidates the cell so that it can be redrawn later:</p><pre class="programlisting">    bool InterpretEditCell(); &#13;
    bool IsCircular(Reference cellRef, set&lt;Reference&gt;&amp; targetSet); &#13;
    void RemoveTargetSetMap(Reference cellRef); &#13;
    void AddTargetSetMap(Reference cellRef, &#13;
                         set&lt;Reference&gt;&amp; newSourceSet); &#13;
    void InvalidateCell(Reference cellRef); &#13;
&#13;
    void EvaluateRecursive(Reference cellRef, &#13;
                           set&lt;Reference&gt;&amp; invalidateSet); &#13;
    void EvaluateCell(Reference cellRef); &#13;
</pre><p>As mentioned at the beginning of this section, the <code class="literal">calcMode</code> method is set to <code class="literal">Mark</code> or <code class="literal">Edit</code>, and we refer to its current value as <strong>in mark mode</strong> and <strong>in edit mode</strong>:</p><pre class="programlisting">  private: &#13;
    enum CalcMode {Edit, Mark} calcMode = Mark; &#13;
</pre><p>The <code class="literal">markOk</code> field is set by the <code class="literal">OnMouseDown</code> method to signal the <code class="literal">OnMouseMove</code> method that it is clear to mark cells:</p><pre class="programlisting">    bool markOk; &#13;
</pre><p>The <code class="literal">firstMarkRef</code> and <code class="literal">lastMarkRef</code> fields refer to the first and last marked cell in the spreadsheet in the <code class="literal">mark</code> mode. Note that they refer to their chronological order rather than their physical order, which means that the first marked reference can be larger than the last marked reference. When necessary, in some methods, the minimum and maximum references are calculated:</p><pre class="programlisting">    Reference firstMarkRef, lastMarkRef, editRef; &#13;
</pre><p>In the <code class="literal">edit</code> mode, <code class="literal">editRef</code> refers to the cell currently edited and <code class="literal">editIndex</code> to the index of the next input position in the cell text (and the caret position):</p><pre class="programlisting">    int editIndex; &#13;
</pre><p>The <code class="literal">cellMatrix</code> field holds the spreadsheet of the application. <code class="literal">Rows</code> and <code class="literal">Cols</code> are constant values and <code class="literal">Cell</code> is the class holding the information of each cell. <code class="literal">Matrix</code> is defined in <a class="link" href="ch09.html" title="Chapter 9. Formula Interpretation">Chapter 9</a>, <em>Formula Interpretation</em>.</p><pre class="programlisting">    Matrix&lt;Rows,Cols,Cell&gt; cellMatrix; &#13;
</pre><p>When the user inputs a formula in a cell, each reference in the formula becomes a source. In the same way, each of the source cells is given a cell as a target. The source and target sets of the cells are stored in the <code class="literal">sourceSetMap</code> and <code class="literal">targetSetMap</code> methods:</p><pre class="programlisting">    map&lt;Reference,set&lt;Reference&gt;&gt; sourceSetMap, targetSetMap; &#13;
</pre><p>The value of the <code class="literal">CalcFormat</code> method used when identifying cut, copy, and paste format is arbitrarily chosen to be 1003:</p><pre class="programlisting">    static const unsigned int CalcFormat = 1003; &#13;
</pre><p>When the user finishes the input of a cell with the <em>Esc</em> key, the previous content of the cell (what was stored in the cell before the input began) gets stored in the <code class="literal">prevCell</code> variable and is copied back to the cell:</p><pre class="programlisting">    Cell prevCell; &#13;
}; &#13;
</pre><p>
<strong>CalcDocument.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Token.h" &#13;
#include "Error.h" &#13;
#include "Scanner.h" &#13;
#include "TreeNode.h" &#13;
#include "Parser.h" &#13;
#include "Cell.h" &#13;
#include "CalcDocument.h" &#13;
</pre><p>The constructor calls the <code class="literal">StandardDocument</code> constructor in the same way as in the word processor of the previous chapters. However, note that we choose the <code class="literal">LogicalWithoutScroll</code> coordinate system (in the word processor, we chose <code class="literal">LogicalWithScroll</code>). This implies that the coordinates of the client area are not updated when the user changes the scroll bar settings. Instead, we have to catch the scroll bar movements with the <code class="literal">OnHorizontalScroll</code> and <code class="literal">OnVerticalScroll</code> methods. This is because the row and column headers are always placed at the top and to the left of the client area, regardless of the current scroll bar settings. Besides, we also want the scrolling to result in exact row and column movements. We also give <code class="literal">false</code> as the seventh parameter, indicating that we omit the <strong>Print</strong> and <strong>Print Preview</strong> file items in the <strong>File</strong> menu in this application:</p><pre class="programlisting">CalcDocument::CalcDocument(WindowShow windowShow) &#13;
 :StandardDocument(LogicalWithoutScroll, USLetterPortrait, &#13;
                   TEXT("Calc Files, clc; Text Files, txt"), &#13;
                   nullptr, OverlappedWindow, windowShow, &#13;
                   {CalcFormat, UnicodeFormat, AsciiFormat}, &#13;
                   {CalcFormat, UnicodeFormat, AsciiFormat}) { &#13;
</pre><p>In this application, we only add the <strong>Format</strong> menu besides the <strong>File</strong>, <strong>Edit</strong>, and <strong>Help</strong> standard menus to the standard menu bar. The <strong>Format</strong> menu holds the <strong>Font</strong> and <strong>Background Color</strong> items as well as the sub menus <strong>Horizontal Alignment</strong> and <strong>Vertical Alignment</strong>.</p><pre class="programlisting">  Menu menuBar(this); &#13;
  menuBar.AddMenu(StandardFileMenu(false)); &#13;
  menuBar.AddMenu(StandardEditMenu()); &#13;
&#13;
 &#13;
  Menu formatMenu(this, TEXT("F&amp;ormat")); &#13;
  formatMenu.AddItem(TEXT("&amp;Font ...\tCtrl+F"), OnFont); &#13;
  formatMenu.AddItem(TEXT("&amp;Background Color ...\tCtrl+B"), &#13;
                     OnBackgroundColor); &#13;
 &#13;
  Menu horizontalMenu(this, TEXT("&amp;Horizontal Alignment")); &#13;
  horizontalMenu.AddItem(TEXT("&amp;Left"), OnHorizontalLeft, &#13;
                         nullptr, nullptr, HorizontalLeftRadio); &#13;
  horizontalMenu.AddItem(TEXT("&amp;Center"), OnHorizontalCenter, &#13;
                         nullptr, nullptr, HorizontalCenterRadio); &#13;
  horizontalMenu.AddItem(TEXT("&amp;Right"), OnHorizontalRight, &#13;
                         nullptr, nullptr, HorizontalRightRadio); &#13;
  horizontalMenu.AddItem(TEXT("&amp;Justified"),OnHorizontalJustified,                              &#13;
                    nullptr, nullptr, HorizontalJustifiedRadio); &#13;
  Menu verticalMenu(this, TEXT("&amp;Vertical Alignment")); &#13;
  verticalMenu.AddItem(TEXT("&amp;Top"), OnVerticalTop, &#13;
                       nullptr, nullptr, VerticalTopRadio); &#13;
  verticalMenu.AddItem(TEXT("&amp;Center"), OnVerticalCenter, &#13;
                       nullptr, nullptr, VerticalCenterRadio); &#13;
 &#13;
  verticalMenu.AddItem(TEXT("&amp;Bottom"), OnVerticalBottom, &#13;
                       nullptr, nullptr, VerticalBottomRadio); &#13;
 &#13;
  formatMenu.AddMenu(horizontalMenu); &#13;
  formatMenu.AddMenu(verticalMenu); &#13;
  menuBar.AddMenu(formatMenu); &#13;
 &#13;
  menuBar.AddMenu(StandardHelpMenu()); &#13;
  SetMenuBar(menuBar); &#13;
</pre><p>The <code class="literal">GenerateCaretList</code> method is called for each cell in the spreadsheet, even though every cell is empty to start with. However, there is an extra caret rectangle generated for the position to the right of the text, which we need in case the user double-clicks on an empty cell. If they do, we use the caret list to find the index of the character clicked on (which naturally is zero for an empty cell):</p><pre class="programlisting">  for (int row = 0; row &lt; Rows; ++row) { &#13;
    for (int col = 0; col &lt; Cols; ++col) { &#13;
      cellMatrix[Reference(row, col)].GenerateCaretList(this); &#13;
    } &#13;
  } &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Mouse input</h2></div></div></div><p>The <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseMove</code> methods look up the part of the spreadsheet with the mouse position and mark the appropriate set of cells. If the user inputs a formula with a syntax error, it is not possible to change the mode from <code class="literal">edit</code> to <code class="literal">mark</code>, so an error message is displayed in a message box, and the <code class="literal">edit</code> mode remains as it is. In that case, the <code class="literal">markOk</code> method is set to <code class="literal">false</code>, indicating that the <code class="literal">OnMouseMove</code> and <code class="literal">OnDoubleClick</code> methods will take no actions:</p><pre class="programlisting">void CalcDocument::OnMouseDown(MouseButton mouseButtons, &#13;
                   Point mousePoint, bool shiftPressed /*=false*/, &#13;
                   bool controlPressed /* = false */) { &#13;
  if ((calcMode == Mark) || ToMarkMode()) { &#13;
    markOk = true; &#13;
    Reference newFirstMarkRef; &#13;
    ClickArea clickArea = &#13;
      GetMouseLocation(mousePoint, newFirstMarkRef); &#13;
    MarkBlock(clickArea, newFirstMarkRef, newFirstMarkRef); &#13;
    UpdateCaret(); &#13;
  } &#13;
  else { &#13;
    markOk = false; &#13;
  } &#13;
} &#13;
</pre><p>Note that the <code class="literal">OnMouseMove</code> method only takes action if the <code class="literal">markOk</code> method is set to <code class="literal">true</code> in the <code class="literal">OnMouseDown</code> method. Since the <code class="literal">OnMouseDown</code> method is always called before the <code class="literal">OnMouseMove</code> method, the <code class="literal">markOk</code> method is always properly set. One difference between the <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseMove</code> methods is that the <code class="literal">OnMouseDown</code> method sets the first and last marked cell reference, while the <code class="literal">OnMouseMove</code> method only sets the last marked cell reference:</p><pre class="programlisting">void CalcDocument::OnMouseMove(MouseButton mouseButtons, &#13;
                   Point mousePoint, bool shiftPressed /*=false*/, &#13;
                   bool controlPressed /* = false */) { &#13;
  if ((mouseButtons == LeftButton) &amp;&amp; markOk) { &#13;
    Reference newLastMarkRef; &#13;
    ClickArea clickArea = &#13;
      GetMouseLocation(mousePoint, newLastMarkRef); &#13;
    MarkBlock(clickArea, firstMarkRef, newLastMarkRef); &#13;
  } &#13;
} &#13;
</pre><p>When the user double-clicks, the input position (and caret) is set to the character clicked on. We look up the clicked area in the same way as in the <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseMove</code> methods. However, the double-click only takes effect if the user clicks on a cell, not the all-box or one of the row or column headers. We mark the clicked cell, set the application to the <code class="literal">edit</code> mode, and extract the edit index from the cell by calling the <code class="literal">MouseToIndex</code> method:</p><pre class="programlisting">void CalcDocument::OnDoubleClick(MouseButton mouseButtons, &#13;
                   Point mousePoint, bool shiftPressed /*=false*/, &#13;
                   bool controlPressed /* = false */) { &#13;
  if ((mouseButtons == LeftButton) &amp;&amp; markOk) { &#13;
    ClickArea clickArea = GetMouseLocation(mousePoint, editRef); &#13;
 &#13;
    if (clickArea == ClickCell) { &#13;
      calcMode = Edit; &#13;
      Cell&amp; editCell = cellMatrix[editRef]; &#13;
      prevCell = editCell; &#13;
      editCell.DisplayFormula(); &#13;
      editIndex = editCell.MouseDown(mousePoint.X() % ColWidth); &#13;
      InvalidateCell(editRef); &#13;
      UpdateWindow(); &#13;
      UpdateCaret(); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Scrolling and marking</h2></div></div></div><p>The <code class="literal">OnHorizontalScroll</code> and <code class="literal">OnVerticalScroll</code> methods are called when the user changes the scroll bar settings. We adjust the position to the nearest column or row and set the scroll position. These methods (together with <code class="literal">GetMouseLocation</code>) are the reason we chose the <code class="literal">LogicalWithoutScroll</code> coordinate system in the <code class="literal">CalcDocument</code> constructor call:</p><pre class="programlisting">void CalcDocument::OnHorizontalScroll(WORD flags, WORD x) { &#13;
  int col = x / ColWidth; &#13;
  SetHorizontalScrollPosition(col * ColWidth); &#13;
} &#13;
 &#13;
void CalcDocument::OnVerticalScroll(WORD flags, WORD y) { &#13;
  int row = y / RowHeight; &#13;
  SetVerticalScrollPosition(row * RowHeight); &#13;
} &#13;
</pre><p>The <code class="literal">GetMouseLocation</code> method takes the position of a mouse click and returns one of the four areas of the client window: the all-box in the top-left corner (<code class="literal">ClickAll</code>), one of the column headers (<code class="literal">ClickCol</code>), one of the row headers (<code class="literal">ClickRow</code>), or one of the cells in the spreadsheet (<code class="literal">ClickCell</code>). In order for these methods to work properly, we have to choose the <code class="literal">LogicalWithoutScroll</code> coordinate system in the <code class="literal">CalcDocument</code> constructor call. We must be able to find the mouse position without any regard to the current scroll settings.</p><p>If the user clicks on the all-box (where both the horizontal and vertical positions are within the header dimension), we return the <code class="literal">ClickAll</code> method:</p><pre class="programlisting">CalcDocument::ClickArea CalcDocument::GetMouseLocation &#13;
                        (Point mousePoint, Reference&amp; cellRef) const { &#13;
  if ((mousePoint.X() &lt;= HeaderWidth) &amp;&amp; &#13;
      (mousePoint.Y() &lt;= HeaderHeight)) { &#13;
    return ClickAll; &#13;
  } &#13;
</pre><p>If the mouse click is not located within the all-box but within the header width, we return the <code class="literal">ClickRow</code> method and set the cell reference to the row clicked on. If the mouse click is below the bottom row, the bottom row is selected:</p><pre class="programlisting">  else if (mousePoint.X() &lt;= HeaderWidth) { &#13;
    mousePoint.Y() += GetVerticalScrollPosition() - HeaderHeight; &#13;
    cellRef = Reference(min(Rows-1, mousePoint.Y()/RowHeight), 0); &#13;
    return ClickRow; &#13;
  } &#13;
</pre><p>If the mouse click is not located within the all-box or in a row header but within the header height, we return the <code class="literal">ClickCol</code> method and set the cell reference to the column clicked on. If the mouse click is to the right of the rightmost column, the rightmost column is selected:</p><pre class="programlisting">  else if (mousePoint.Y() &lt;= HeaderHeight) { &#13;
    mousePoint.X() += GetHorizontalScrollPosition() - HeaderWidth; &#13;
    cellRef = Reference(0, min(Cols - 1, &#13;
                               mousePoint.X() / ColWidth)); &#13;
    return ClickColumn; &#13;
  } &#13;
</pre><p>If the mouse click is not located within the all-box or at a row or column header, we return the <code class="literal">ClickCell</code> method and set the cell reference to the cell clicked on. If the mouse click is below the bottom row, the bottom row is selected, and if the mouse click is to the right of the rightmost column, the rightmost column selected:</p><pre class="programlisting">  else { &#13;
    mousePoint.X() += GetHorizontalScrollPosition() - HeaderWidth; &#13;
    mousePoint.Y() += GetVerticalScrollPosition() - HeaderHeight; &#13;
    cellRef = Reference(min(Rows - 1, mousePoint.Y() / RowHeight), &#13;
                        min(Cols - 1, mousePoint.X() / ColWidth)); &#13;
    return ClickCell; &#13;
  } &#13;
} &#13;
</pre><p>Here is an outline of the different parts of the spreadsheet:</p><p>
</p><div><img src="img/B05475_08_01.jpg" alt="Scrolling and marking"/></div><p>
</p><p>The <code class="literal">MarkBlock</code> method marks a part of the spreadsheet due to the <code class="literal">clickArea</code> parameter:</p><pre class="programlisting">void CalcDocument::MarkBlock(ClickArea clickArea, &#13;
         Reference newFirstMarkRef, Reference newLastMarkRef) { &#13;
  switch (clickArea) { &#13;
</pre><p>If the user clicks on the all-box, all cells in the spreadsheet are marked:</p><pre class="programlisting">    case ClickAll: &#13;
      Remark(ZeroReference, Reference(Rows - 1, Cols - 1)); &#13;
      break; &#13;
</pre><p>If they click on a row, all cells in that row are marked:</p><pre class="programlisting">    case ClickRow: &#13;
      Remark(Reference(newFirstMarkRef.Row(), 0), &#13;
             Reference(newLastMarkRef.Row(), Cols - 1)); &#13;
      break; &#13;
</pre><p>If they click on a column, all cells in that column are marked:</p><pre class="programlisting">    case ClickColumn: &#13;
      Remark(Reference(0, newFirstMarkRef.Col()), &#13;
             Reference(Rows - 1, newLastMarkRef.Col())); &#13;
      break; &#13;
</pre><p>If they click on a cell, only that cell gets marked:</p><pre class="programlisting">    case ClickCell: &#13;
      Remark(newFirstMarkRef, newLastMarkRef); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec66"/>Painting</h2></div></div></div><p>The <code class="literal">OnDraw</code> method is called when the window client area needs to be repainted partly or completely. The client area can be divided into five parts as outlined earlier: the top-left corner, the row header, the column header, the cell space, and the area outside the spreadsheet:</p><pre class="programlisting">void CalcDocument::OnDraw(Graphics&amp; graphics,&#13;
                          DrawMode /* drawMode */) const {&#13;
  int horizontalScroll = GetHorizontalScrollPosition(), &#13;
      verticalScroll = GetVerticalScrollPosition(); &#13;
</pre><p>We use the scroll bar settings to find the top and leftmost row and column. We cannot simply draw all cells (unless the scroll bar settings are zero) since it would  overwrite the row or column headers:</p><pre class="programlisting">  int startRow = horizontalScroll / RowHeight, &#13;
      startCol = verticalScroll / ColWidth; &#13;
</pre><p>The all-box is simply a rectangle:</p><pre class="programlisting">  graphics.DrawRectangle(Rect(0, 0, HeaderWidth, HeaderHeight), &#13;
                         Black); &#13;
</pre><p>When drawing the column headers, we calculate the horizontal position of the cell's left border by multiplying the column index by the column width. We also need to subtract the current setting of the horizontal scroll bar and add the width of the header. The first column has index zero and will be named <code class="literal">A</code>, so we add the column index to the character <code class="literal">A</code> in order to find its name:</p><pre class="programlisting">  for (int col = startCol; col &lt; Cols; ++col) { &#13;
    int x = (col * ColWidth) - horizontalScroll + HeaderWidth; &#13;
    Rect headerRect(x, 0, x + ColWidth, HeaderHeight); &#13;
    graphics.DrawRectangle(Rect(x, 0, x + ColWidth, HeaderHeight), &#13;
                           Black); &#13;
    TCHAR buffer[] = {(TCHAR) (TEXT('A') + col), TEXT('\0')}; &#13;
    graphics.DrawText(headerRect, buffer, &#13;
                      SystemFont, Black, White); &#13;
  } &#13;
</pre><p>In the same way, when drawing the row headers, we calculate the vertical position of the cell's top border by multiplying the row index by the row height. We also need to subtract the current setting of the vertical scroll bar and add the height of the header:</p><pre class="programlisting">  for (int row = startRow; row &lt; Rows; ++row) { &#13;
    int y = (row * RowHeight) - verticalScroll + HeaderHeight; &#13;
    Rect headerRect(0, y, HeaderWidth, y + RowHeight); &#13;
    graphics.DrawRectangle(Rect(0, y, HeaderWidth, y + RowHeight), &#13;
                           Black); &#13;
    String buffer = to_String(row + 1); &#13;
    graphics.DrawText(headerRect, buffer, &#13;
                      SystemFont, Black, White); &#13;
  } &#13;
</pre><p>Since the marked cells will be inverted and the <code class="literal">firstMarkRef</code> and <code class="literal">lastMarkRef</code> methods refer to the chronological order of the marking, we calculate the minimal and maximal markings:</p><pre class="programlisting">  int minMarkRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      minMarkCol = min(firstMarkRef.Col(), lastMarkRef.Col()), &#13;
      maxMarkRow = max(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      maxMarkCol = max(firstMarkRef.Col(), lastMarkRef.Col()); &#13;
</pre><p>Finally, we draw the cells. For the cells marked or being edited, the third <code class="literal">DrawCell</code> parameter is <code class="literal">true</code> and the cell is inversed:</p><pre class="programlisting">  for (int row = startRow; row &lt; Rows; ++row) { &#13;
    for (int col = startCol; col &lt; Cols; ++col) { &#13;
      bool edit = (calcMode == Edit) &amp;&amp; &#13;
                  (row == editRef.Row())&amp;&amp;(col == editRef.Col()); &#13;
 &#13;
      bool mark = (calcMode == Mark) &amp;&amp; &#13;
                  (row &gt;= minMarkRow) &amp;&amp; (row &lt;= maxMarkRow) &amp;&amp; &#13;
                  (col &gt;= minMarkCol) &amp;&amp; (col &lt;= maxMarkCol); &#13;
 &#13;
      Reference cellRef(row, col); &#13;
      Cell cell = cellMatrix[cellRef]; &#13;
      cell.DrawCell(graphics, cellRef, edit || mark); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec67"/>Visibility</h2></div></div></div><p>The <code class="literal">IsCellVisible</code> method returns <code class="literal">true</code> if the cell is visible in the window's client area. The index of the first and last visible row and column is calculated from the current scroll bar settings. The given cell reference is then compared to the references of the visible cells:</p><pre class="programlisting">bool CalcDocument::IsCellVisible(Reference cellRef) const{ &#13;
  int horizontalScrollPos = GetHorizontalScrollPosition(), &#13;
      horizontalScrollPage = GetHorizontalScrollPageWidth(); &#13;
  int firstVisibleRow = horizontalScrollPos / RowHeight; &#13;
  int lastVisibleRow = firstVisibleRow + &#13;
                       (horizontalScrollPage / RowHeight); &#13;
 &#13;
  int verticalScrollPos = GetVerticalScrollPosition(), &#13;
      verticalScrollPage = GetVerticalScrollPageHeight(); &#13;
  int firstVisibleCol = verticalScrollPos / ColWidth; &#13;
  int lastVisibleCol = firstVisibleCol + &#13;
                       (verticalScrollPage / ColWidth); &#13;
 &#13;
  int row = cellRef.Row(), col = cellRef.Col(); &#13;
  return (row &gt;= firstVisibleRow) &amp;&amp; (row &lt;= lastVisibleRow) &amp;&amp; &#13;
         (col &gt;= firstVisibleCol) &amp;&amp; (col &lt;= lastVisibleCol); &#13;
} &#13;
</pre><p>The <code class="literal">MakeCellVisible</code> method makes the cell being edited visible in <code class="literal">edit</code> mode and the last marked cell visible in the <code class="literal">mark</code> mode:</p><pre class="programlisting">void CalcDocument::MakeCellVisible() { &#13;
  switch (calcMode) { &#13;
    case Edit: &#13;
      MakeCellVisible(editRef); &#13;
      break; &#13;
 &#13;
&#13;
&#13;
    case Mark: &#13;
      MakeCellVisible(lastMarkRef); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">MakeCellVisible</code> method makes the cell visible by comparing it to the current scroll bar settings. If necessary, it changes the scroll bar settings:</p><pre class="programlisting">void CalcDocument::MakeCellVisible(Reference cellRef) { &#13;
  Point topLeft(cellRef.Col() * ColWidth, &#13;
                cellRef.Row() * RowHeight); &#13;
  Rect cellRect(topLeft, Size(ColWidth, RowHeight)); &#13;
  Size clientSize = GetClientSize(); &#13;
</pre><p>First, we check whether the width of the spreadsheet is larger than the width of the client area, in which case it may be necessary to change the setting of the horizontal scroll bar:</p><pre class="programlisting">  if (clientSize.Width() &lt; (HeaderWidth + Cols * ColWidth)) { &#13;
    int left = GetHorizontalScrollPosition(), &#13;
        xPage = GetHorizontalScrollPageWidth(); &#13;
    int right = left + xPage - 1; &#13;
</pre><p>If the cell's left border is located to the left of the client area's left border or if the cell's right border is located to the right of the client area's right border, we change the scroll bar setting, as follows:</p><pre class="programlisting">    if (cellRect.Left() &lt; left) { &#13;
      SetHorizontalScrollPosition(cellRect.Left()); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    }  &#13;
    if (cellRect.Right() &gt; right) { &#13;
      int distance = cellRect.Right() - right; &#13;
      distance += ColWidth - distance % ColWidth; &#13;
      SetHorizontalScrollPosition(left + distance); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
  } &#13;
</pre><p>If the height of the spreadsheet is more than the height of the client area, it may be necessary to change the setting of the horizontal scroll bar:</p><pre class="programlisting">  if (clientSize.Height() &lt; (HeaderHeight + Rows * RowHeight)) { &#13;
    int top = GetHorizontalScrollPosition(), &#13;
        yPage = GetHorizontalScrollPageWidth(); &#13;
    int bottom = top + yPage - 1; &#13;
</pre><p>If the cell's top border is located above the client area's top border or if the cell's bottom border is located below the client area's bottom border, we change the scroll bar settings:</p><pre class="programlisting">    if (cellRect.Top() &lt; top) { &#13;
      SetVerticalScrollPosition(cellRect.Top()); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
 &#13;
    if (cellRect.Bottom() &gt; bottom) { &#13;
      int distance = cellRect.Bottom() - bottom; &#13;
      distance += RowHeight - distance % RowHeight; &#13;
      SetVerticalScrollPosition(top + distance); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec68"/>Marking and updating</h2></div></div></div><p>The <code class="literal">UpdateCaret</code> method sets the caret in <code class="literal">edit</code> mode if the edited cell is visible. Otherwise, it clears the caret. We have to check whether the cell is visible. Otherwise, the caret may be shown in one of the header areas. In the keyboard <code class="literal">insert</code> mode, the caret is a vertical bar, and in the <code class="literal">overwrite</code> mode, it is a rectangle the size of the current character.</p><pre class="programlisting">void CalcDocument::UpdateCaret() { &#13;
  if ((calcMode == Edit) &amp;&amp; IsCellVisible(editRef)) { &#13;
    Point topLeft(HeaderWidth + (editRef.Col() * ColWidth) + &#13;
                  CellMargin, HeaderHeight + (editRef.Row() * &#13;
                  RowHeight) + CellMargin); &#13;
    Cell&amp; editCell = cellMatrix[editRef]; &#13;
    Rect caretRect = editCell.CaretList()[editIndex]; &#13;
 &#13;
    if (GetKeyboardMode() == InsertKeyboard) { &#13;
      caretRect.Right() = caretRect.Left() + 1; &#13;
    } &#13;
 &#13;
    SetCaret(topLeft + caretRect); &#13;
  } &#13;
  else { &#13;
    ClearCaret(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">ToMarkMode</code> method is called when the user ends the input of the text in the cell by pressing the <em>Return</em> or <em>Tab</em> key or by clicking the mouse. Its first task is to check whether the input is valid by calling the <code class="literal">InterpretEditCell</code> method, which returns <code class="literal">false</code> if the text contains a formula with a syntax error. In that case, the <code class="literal">edit</code> mode remains unchanged and <code class="literal">false</code> is returned. However, if the cell interpretation goes well, the application is set to the <code class="literal">mark</code> mode and we get <code class="literal">true</code> in return:</p><pre class="programlisting">bool CalcDocument::ToMarkMode() { &#13;
  if (calcMode == Edit) { &#13;
    if (InterpretEditCell()) { &#13;
      calcMode = Mark; &#13;
      firstMarkRef = editRef; &#13;
      lastMarkRef = editRef; &#13;
      return true; &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
 &#13;
  return true; &#13;
} &#13;
</pre><p>The <code class="literal">Remark</code> method unmarks the marked cells and marks the new block given by the parameters without any unnecessary updating. That is, cells already marked shall not be invalidated. Note that the first and last marked cells refer to their chronological order rather than their locations on the spreadsheet. The last row or column may be less reflective than the first one. Therefore, we introduce the minimal and maximal variables to reflect their actual locations in the spreadsheet:</p><pre class="programlisting">void CalcDocument::Remark(Reference newFirstRef, &#13;
                          Reference newLastRef) { &#13;
  Reference &#13;
    minOldMarked(min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
                 min(firstMarkRef.Col(), lastMarkRef.Col())), &#13;
    maxOldMarked(max(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
                 max(firstMarkRef.Col(), lastMarkRef.Col())), &#13;
    minNewMarked(min(newFirstRef.Row(), newLastRef.Row()), &#13;
                 min(newFirstRef.Col(), newLastRef.Col())), &#13;
    maxNewMarked(max(newFirstRef.Row(), newLastRef.Row()), &#13;
                 max(newFirstRef.Col(), newLastRef.Col())); &#13;
</pre><p>In the previous marked block, all cells that are not located in the new marked block are invalidated in order for them to be redrawn as unmarked cells. No old cells within the new marked blocks become invalidated:</p><pre class="programlisting">  for (int row = minOldMarked.Row(); &#13;
       row &lt;= maxOldMarked.Row(); ++row) { &#13;
    for (int col = minOldMarked.Col(); &#13;
         col &lt;= maxOldMarked.Col(); ++col) { &#13;
      Reference cellRef(row, col); &#13;
      if (!cellRef.Inside(minNewMarked, maxNewMarked)) { &#13;
        InvalidateCell(cellRef); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>In the new marked block, all cells that are not located in the old marked block are invalidated in order for them to be redrawn as unmarked cells. No already marked cells become invalidated:</p><pre class="programlisting">  for (int row = minNewMarked.Row(); &#13;
       row &lt;= maxNewMarked.Row(); ++row) { &#13;
    for (int col = minNewMarked.Col(); &#13;
         col &lt;= maxNewMarked.Col(); ++col) { &#13;
      Reference cellRef(row, col); &#13;
      if (!cellRef.Inside(minOldMarked, maxOldMarked)) { &#13;
        InvalidateCell(Reference(row, col)); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>The first and last marked reference is set and the invalidated cells are updated:</p><pre class="programlisting">  firstMarkRef = newFirstRef; &#13;
  lastMarkRef = newLastRef; &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec69"/>Keyboard input</h2></div></div></div><p>The <code class="literal">OnCharDown</code> method is called every time the user presses a graphical key on the keyboard. In the <code class="literal">mark</code> mode, the application is changed to the <code class="literal">edit</code> mode, where the edit reference is set to the first marked reference, the edit index is set to zero since the start of the input resets the cell, and the <code class="literal">prevCell</code> variable is set as backup in case the user finishes the input by pressing the <em>Esc</em> key:</p><pre class="programlisting">void CalcDocument::OnChar(TCHAR tChar) { &#13;
  if (calcMode == Mark) { &#13;
    calcMode = Edit; &#13;
    editRef = firstMarkRef; &#13;
    Remark(editRef, editRef); &#13;
    editIndex = 0; &#13;
    Cell&amp; editCell = cellMatrix[editRef]; &#13;
    prevCell = *editCell; &#13;
    editCell.Reset(); &#13;
  } &#13;
</pre><p>The cell to be edited is made visible, the character is added to the text, and the caret rectangle is regenerated. Finally, the caret and window are updated, since the cell has been altered and the edit index has been updated:</p><pre class="programlisting">  MakeCellVisible(editRef); &#13;
  Cell&amp; cell = cellMatrix[editRef]; &#13;
  cell.CharDown(editIndex++, tChar, GetKeyboardMode()); &#13;
  cell.GenerateCaretList(this); &#13;
  InvalidateCell(editRef); &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre><p>The <code class="literal">OnKeyDown</code> method is called every time the user presses a key. The appropriate method is called in the case of the arrow keys, <em>Page Up</em>, <em>Page Down</em>, <em>Home</em>, <em>End</em>, <em>Return</em>, <em>Tab</em>, <em>Insert</em>, <em>Delete</em>, or <em>Backspace</em>:</p><pre class="programlisting">bool CalcDocument::OnKeyDown(WORD key, bool shiftPressed, &#13;
                             bool controlPressed) { &#13;
  switch (key) { &#13;
    case KeyLeft: &#13;
      OnLeftArrowKey(shiftPressed); &#13;
      break; &#13;
 &#13;
    case KeyRight: &#13;
      OnRightArrowKey(shiftPressed); &#13;
      break; &#13;
 &#13;
    case KeyUp: &#13;
      OnUpArrowKey(shiftPressed); &#13;
      break; &#13;
 &#13;
    case KeyDown: &#13;
      OnDownArrowKey(shiftPressed); &#13;
      break; &#13;
 &#13;
    case KeyHome: &#13;
      OnHomeKey(shiftPressed, controlPressed); &#13;
      break; &#13;
 &#13;
&#13;
&#13;
    case KeyEnd: &#13;
      OnEndKey(shiftPressed, controlPressed); &#13;
      break; &#13;
 &#13;
    case KeyReturn: &#13;
      OnReturnKey(); &#13;
      break; &#13;
 &#13;
    case KeyTabulator: &#13;
      OnTabulatorKey(shiftPressed); &#13;
      break; &#13;
 &#13;
    case KeyEscape: &#13;
      OnEscapeKey(); &#13;
      break; &#13;
 &#13;
    case KeyDelete: &#13;
      OnDeleteKey(); &#13;
      break; &#13;
 &#13;
    case KeyBackspace: &#13;
      OnBackspaceKey(); &#13;
      break; &#13;
  } &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
  return true; &#13;
} &#13;
</pre><p>The <code class="literal">OnLeftArrowKey</code> method is called when the user presses the left arrow key. We have three different cases to consider depending on the <code class="literal">edit</code> or <code class="literal">mark</code> mode and on whether the user presses the <em>Shift</em> key. In the <code class="literal">edit</code> mode, we make the edit cell visible, move the edit index one step to the left if it is not already at the leftmost position, and update the caret:</p><pre class="programlisting">void CalcDocument::OnLeftArrowKey(bool shiftPressed) { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        MakeCellVisible(editRef); &#13;
        if (editIndex &gt; 0) { &#13;
          --editIndex; &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>In the <code class="literal">mark</code> mode, we have to take into consideration whether the <em>Shift</em> key is pressed. If it is not, we place the marked block (both the first and last marked cells) one step to the left of the last marked cell unless it is already at the leftmost column:</p><pre class="programlisting">    case Mark: &#13;
      if (lastMarkRef.Col() &gt; 0) { &#13;
        if (!shiftPressed) { &#13;
          Reference newLastMarkRef(lastMarkRef.Row(), &#13;
                                   lastMarkRef.Col() - 1); &#13;
          MakeCellVisible(newLastMarkRef); &#13;
          Remark(newLastMarkRef, newLastMarkRef); &#13;
        } &#13;
</pre><p>If the <em>Shift</em> key is pressed, we move the last marked cell one step to the left unless it is already at the leftmost position. The first marked cell is not affected:</p><pre class="programlisting">        else { &#13;
          Reference newLastRefMark(lastMarkRef.Row(), &#13;
                                   lastMarkRef.Col() - 1); &#13;
          MakeCellVisible(newLastRefMark); &#13;
          Remark(firstMarkRef, newLastRefMark); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnRightArrowKey</code> method is called when the user presses the right arrow key. It works similarly to the <code class="literal">OnLeftArrowKey</code> method. In the <code class="literal">edit</code> mode, we make the edit cell visible, move the edit index one step to the right if it is not already at the rightmost position, and update the caret:</p><pre class="programlisting">void CalcDocument::OnRightArrowKey(bool shiftPressed) { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        MakeCellVisible(editRef); &#13;
 &#13;
        if (editIndex &lt; &#13;
            ((int) cellMatrix[editRef].GetText().length())) { &#13;
          ++editIndex; &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>In the <code class="literal">mark</code> mode, we have to take into consideration whether the <em>Shift</em> key is pressed. If it is not pressed, we place the marked block one step to the right of the first marked cell, unless it already is at the rightmost column:</p><pre class="programlisting">    case Mark: &#13;
      if (lastMarkRef.Col() &lt; (Cols - 1)) { &#13;
        if (!shiftPressed) { &#13;
          Reference newLastMarkRef(lastMarkRef.Row(), &#13;
                                   lastMarkRef.Col() + 1); &#13;
          MakeCellVisible(newLastMarkRef); &#13;
          Remark(newLastMarkRef, newLastMarkRef); &#13;
        } &#13;
</pre><p>If the <em>Shift</em> key is pressed, we move the last marked cell one step to the right unless it is already at the rightmost position. The first marked cell is not affected:</p><pre class="programlisting">        else { &#13;
          Reference newLastRefMark(lastMarkRef.Row(), &#13;
                                   lastMarkRef.Col() + 1); &#13;
          MakeCellVisible(newLastRefMark); &#13;
          Remark(firstMarkRef, newLastRefMark); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnUpArrowKey</code> method is called when the user presses the up arrow key. In the <code class="literal">edit</code> mode, no action is taken:</p><pre class="programlisting">void CalcDocument::OnUpArrowKey(bool shiftPressed) { &#13;
  switch (calcMode) { &#13;
    case Edit: &#13;
      break; &#13;
</pre><p>If the <em>Shift</em> key is not pressed in the <code class="literal">mark</code> mode, we place the marked cell one step up relative to the first marked cell if it is not already in the top row. In that case, we place the marked block in the first marked cell:</p><pre class="programlisting">    case Mark: &#13;
      if (lastMarkRef.Row() &gt; 0) { &#13;
        if (!shiftPressed) { &#13;
          Reference newLastMarkRef(lastMarkRef.Row() - 1, &#13;
                                   lastMarkRef.Col()); &#13;
          MakeCellVisible(newLastMarkRef); &#13;
          Remark(newLastMarkRef, newLastMarkRef); &#13;
        } &#13;
</pre><p>If the <em>Shift</em> key is pressed, we move the last marked cell one step up unless it is already in the top row. The first marked cell is not affected:</p><pre class="programlisting">        else { &#13;
          Reference newLastRefMark(lastMarkRef.Row() - 1, &#13;
                                   lastMarkRef.Col()); &#13;
          MakeCellVisible(newLastRefMark); &#13;
          Remark(firstMarkRef, newLastRefMark); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnDownArrowKey</code> method is called when the user presses the down arrow key. It works in a way similar to the <code class="literal">OnUpArrowKey</code> method. In the <code class="literal">edit</code> mode, no action is taken:</p><pre class="programlisting">void CalcDocument::OnDownArrowKey(bool shiftPressed) { &#13;
  switch (calcMode) { &#13;
    case Edit: &#13;
      break; &#13;
</pre><p>If the <em>Shift</em> key is not pressed in the <code class="literal">mark</code> mode, we place the marked block one step relatively under the first marked cell, unless it already is in the bottom row:</p><pre class="programlisting">    case Mark: &#13;
      if (lastMarkRef.Row() &lt; (Rows - 1)) { &#13;
        if (!shiftPressed) { &#13;
          Reference newMarkRef(lastMarkRef.Row() + 1, &#13;
                               lastMarkRef.Col()); &#13;
          MakeCellVisible(newMarkRef); &#13;
          Remark(newMarkRef, newMarkRef); &#13;
        } &#13;
</pre><p>If the <em>Shift</em> key is pressed, we move the last marked cell one step down unless it is already in the bottom row. The first marked cell is not affected:</p><pre class="programlisting">        else { &#13;
          Reference newLastRefMark(lastMarkRef.Row() + 1, &#13;
                                   lastMarkRef.Col()); &#13;
          MakeCellVisible(newLastRefMark); &#13;
          Remark(firstMarkRef, newLastRefMark); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnHomeKey</code> method is called when the user presses the <em>Home</em> key. In the <code class="literal">edit</code> mode, we make the edit cell visible, move the edit index to the leftmost index, and update the caret:</p><pre class="programlisting">void CalcDocument::OnHomeKey(bool shiftPressed, &#13;
                             bool controlPressed) { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        MakeCellVisible(editRef); &#13;
        editIndex = 0; &#13;
        UpdateCaret(); &#13;
      } &#13;
      break; &#13;
</pre><p>If neither the <em>Shift</em> or <em>Ctrl</em> keys is pressed in the <code class="literal">mark</code> mode, we move the marked block to the leftmost column of the first marked row. If the <em>Shift</em> key is pressed, we move the last marked cell to the leftmost column of the last marked row. The first marked cell is not affected:</p><pre class="programlisting">    case Mark: &#13;
      if (!shiftPressed &amp;&amp; !controlPressed) { &#13;
        Remark(Reference(firstMarkRef.Row(), 0), &#13;
               Reference(firstMarkRef.Row(), 0)); &#13;
        MakeCellVisible(firstMarkRef); &#13;
      } &#13;
      else if (shiftPressed &amp;&amp; !controlPressed) { &#13;
        Remark(firstMarkRef, Reference(firstMarkRef.Row(), 0)); &#13;
        MakeCellVisible(lastMarkRef); &#13;
      } &#13;
</pre><p>If the <em>Ctrl</em> key is pressed, but not the <em>Shift</em> key, we move the marked block to the top-left cell. If the <em>Ctrl</em> key is not pressed, we move the last marked cell to the leftmost position in the row:</p><pre class="programlisting">      else if (!shiftPressed &amp;&amp; controlPressed) { &#13;
        Remark(ZeroReference, ZeroReference); &#13;
        MakeCellVisible(lastMarkRef); &#13;
      } &#13;
      else if (shiftPressed &amp;&amp; controlPressed) { &#13;
        Remark(firstMarkRef, ZeroReference); &#13;
        MakeCellVisible(lastMarkRef); &#13;
      } &#13;
    break; &#13;
    } &#13;
} &#13;
</pre><p>The <code class="literal">OnEndKey</code> method is called when the user presses the <em>End</em> key, and it works in a way similar to the <code class="literal">OnHomeKey</code> method. In the <code class="literal">edit</code> mode, we make the edit cell visible, move the edit index to the rightmost index, and update the caret:</p><pre class="programlisting">void CalcDocument::OnEndKey(bool shiftPressed, bool controlPressed) { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        MakeCellVisible(editRef); &#13;
        editIndex = cellMatrix[editRef].GetText().length(); &#13;
        UpdateCaret(); &#13;
      } &#13;
      break; &#13;
</pre><p>If neither the <em>Shift</em> nor the <em>Ctrl</em> key is pressed in the <code class="literal">mark</code> mode, we move the marked block to the rightmost column of the first marked row. If the <em>Shift</em> key is pressed, we move the last marked cell to the rightmost column of the last marked row. The first marked cell is not affected:</p><pre class="programlisting">    case Mark: &#13;
      if (!shiftPressed &amp;&amp; !controlPressed) { &#13;
        Remark(Reference(firstMarkRef.Row(), Cols - 1), &#13;
               Reference(firstMarkRef.Row(), Cols - 1)); &#13;
        MakeCellVisible(firstMarkRef); &#13;
      } &#13;
      else if (shiftPressed &amp;&amp; !controlPressed) { &#13;
        Remark(firstMarkRef, &#13;
               Reference(firstMarkRef.Row(), Cols - 1)); &#13;
        MakeCellVisible(lastMarkRef); &#13;
      } &#13;
</pre><p>If the <em>Ctrl</em> key is pressed, but not the <em>Shift</em> key, we move the marked block to the bottom-right cell. If the <em>Ctrl</em> key is not pressed, we move the last marked cell to the rightmost position in the row:</p><pre class="programlisting">      else if (!shiftPressed &amp;&amp; controlPressed) { &#13;
        Remark(Reference(Rows - 1, Cols - 1), &#13;
               Reference(Rows - 1, Cols - 1)); &#13;
        MakeCellVisible(lastMarkRef); &#13;
      } &#13;
      else if (shiftPressed &amp;&amp; controlPressed) { &#13;
        Remark(firstMarkRef, Reference(Rows - 1, Cols - 1)); &#13;
        MakeCellVisible(lastMarkRef); &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <em>Return</em> key finishes the editing session unless the user has input a formula with a syntax error, in which case an error message box is displayed. The user can also finish by pressing the <em>Tab</em> key or by clicking the mouse; in either case, the <code class="literal">Remark</code> method takes care of finishing the editing process. When the editing is finished, we try to mark the cell:</p><pre class="programlisting">void CalcDocument::OnReturnKey() { &#13;
  if ((calcMode == Mark) || ToMarkMode()) { &#13;
    Reference newMarkedRef(min(firstMarkRef.Row() + 1, Rows - 1), &#13;
                           firstMarkRef.Col()); &#13;
    Remark(newMarkedRef, newMarkedRef); &#13;
    MakeCellVisible(newMarkedRef); &#13;
  } &#13;
} &#13;
</pre><p>The <em>Tab</em> key does almost the same thing as the <em>Return</em> key. The only difference is that the next marked cell is, if possible, the cell to right or the cell to the left (if the user pressed the <em>Shift</em> key):</p><pre class="programlisting">void CalcDocument::OnTabulatorKey(bool shiftPressed) { &#13;
  if ((calcMode == Mark) || ToMarkMode()) { &#13;
    if (shiftPressed &amp;&amp; (lastMarkRef.Col() &gt; 0)) { &#13;
      Reference firstMarkRef(lastMarkRef.Row(), &#13;
                             firstMarkRef.Col() - 1); &#13;
      Remark(firstMarkRef, firstMarkRef); &#13;
      MakeCellVisible(firstMarkRef); &#13;
    } &#13;
     &#13;
    if (!shiftPressed &amp;&amp; (lastMarkRef.Col() &lt; (Cols - 1))) { &#13;
      Reference firstMarkRef(firstMarkRef.Row(), &#13;
                             firstMarkRef.Col() + 1); &#13;
      Remark(firstMarkRef, firstMarkRef); &#13;
      MakeCellVisible(firstMarkRef); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnEscapeKey</code> method is called when the user presses the <em>Esc</em> key and resets the cell to the value of the <code class="literal">prevCell</code> variable:</p><pre class="programlisting">void CalcDocument::OnEscapeKey() { &#13;
  if (calcMode == Edit) { &#13;
    Cell&amp; editCell = cellMatrix[editRef]; &#13;
    editCell = prevCell; &#13;
    InvalidateCell(editRef); &#13;
    calcMode = Mark; &#13;
    firstMarkRef = lastMarkRef = editRef; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnDeleteKey</code> method is called when the user presses the <em>Delete</em> key or selects the <strong>Delete</strong> menu item to delete a character in the <code class="literal">edit</code> mode or the contents of the marked block in the <code class="literal">mark</code> mode. In the <code class="literal">edit</code> mode, we delete the character of the edit index unless it is at the end of the text. In the <code class="literal">mark</code> mode, we just reset the marked cell. When the cells are reset, we need to re-evaluate their target cells recursively:</p><pre class="programlisting">void CalcDocument::OnDeleteKey() { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
      Cell&amp; editCell = cellMatrix[editRef]; &#13;
      String&amp; cellText = editCell.GetText(); &#13;
 &#13;
      if (editIndex &lt; ((int) cellText.length())) { &#13;
        String leftPart = cellText.substr(0, editIndex), &#13;
               rightPart = cellText.substr(editIndex + 1); &#13;
        editCell.SetText(leftPart + rightPart); &#13;
        editCell.GenerateCaretList(this); &#13;
        InvalidateCell(editRef); &#13;
        UpdateWindow(); &#13;
        SetDirty(true); &#13;
      } &#13;
    } &#13;
    break; &#13;
 &#13;
  case Mark: { &#13;
      int minMarkRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
          minMarkCol = min(firstMarkRef.Col(), lastMarkRef.Col()), &#13;
          maxMarkRow = max(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
          maxMarkCol = max(firstMarkRef.Col(), lastMarkRef.Col()); &#13;
 &#13;
      set&lt;Reference&gt; invalidateSet; &#13;
      for (int row = minMarkRow; row &lt;= minMarkRow; ++row) { &#13;
        for (int col = minMarkCol; col &lt;= minMarkCol; ++col) { &#13;
          Reference cellRef = Reference(row, col); &#13;
          cellMatrix[cellRef].Reset(); &#13;
          EvaluateRecursive(editRef, invalidateSet); &#13;
        } &#13;
      }  &#13;
      for (Reference cellRef : invalidateSet) { &#13;
        InvalidateCell(cellRef); &#13;
      }  &#13;
      UpdateWindow(); &#13;
      SetDirty(true); &#13;
    } &#13;
    break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnBackspaceKey</code> method is called when the user presses the <em>Backspace</em> key to delete a character in a cell in the <code class="literal">edit</code> mode or the contents of the marked block in the <code class="literal">mark</code> mode. In the <code class="literal">edit</code> mode, we decrement the edit index and remove the character by calling the <code class="literal">OnDeleteKey</code> method at the new index, unless the edit position is already at the beginning of text. In the <code class="literal">mark</code> mode, we just call the <code class="literal">OnDeleteKey</code> method:</p><pre class="programlisting">void CalcDocument::OnBackspaceKey() { &#13;
  switch (calcMode) { &#13;
    case Edit: &#13;
      if (editIndex &gt; 0) { &#13;
        --editIndex; &#13;
        OnDeleteKey(); &#13;
      } &#13;
      break; &#13;
 &#13;
    case Mark: &#13;
      OnDeleteKey(); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec70"/>File management</h2></div></div></div><p>Similar to the previous applications, the <code class="literal">ClearDocument</code> method is called by the <code class="literal">StandardDocument</code> class when the user selects the <strong>New</strong> menu item, the <code class="literal">WriteDocumentToStream</code> method is called when the user selects <strong>Save</strong> or <strong>Save As</strong>, and the <code class="literal">ReadDocumentFromStream</code> method is called when the user selects <strong>Open</strong> menu item.</p><p>In the <code class="literal">ClearDocument</code> method, every cell is cleared along with their source and target sets. When a cell is reset, its text is cleared. When it is cleared, its font and color are also cleared. Finally, the application is set to the <code class="literal">mark</code> mode, where the top-left cell is marked:</p><pre class="programlisting">void CalcDocument::ClearDocument() { &#13;
  for (int row = 0; row &lt; Rows; ++row) { &#13;
    for (int col = 0; col &lt; Cols; ++col) { &#13;
      cellMatrix[Reference(row, col)].Clear(); &#13;
    } &#13;
  } &#13;
 &#13;
  sourceSetMap.clear(); &#13;
  targetSetMap.clear(); &#13;
 &#13;
&#13;
&#13;
  calcMode = Mark; &#13;
  firstMarkRef.Clear(); &#13;
  lastMarkRef.Clear(); &#13;
} &#13;
</pre><p>The <code class="literal">WriteCellToStream</code> method is a callback function that, given a cell and an output stream, writes the cell to the stream. In the same way, the <code class="literal">ReadCellFromStream</code> method reads a cell from an input stream:</p><pre class="programlisting">void WriteCellToStream(Cell cell, ostream&amp; outStream) { &#13;
  cell.WriteCellToStream(outStream); &#13;
} &#13;
 &#13;
void ReadCellFromStream(Cell&amp; cell, istream&amp; inStream) { &#13;
  cell.ReadCellFromStream(inStream); &#13;
} &#13;
</pre><p>The <code class="literal">WriteDocumentToStream</code> and <code class="literal">ReadDocumentFromStream</code> methods write and read the spreadsheet. More specifically, they read and write the <code class="literal">application</code> mode, the edit index and reference, the mark references, the source and target sets, and the cells in the cell matrix:</p><pre class="programlisting">bool CalcDocument::WriteDocumentToStream(String name, &#13;
                                         ostream&amp; outStream)const{ &#13;
  if (EndsWith(name, TEXT(".clc"))) { &#13;
    outStream.write((char*) &amp;calcMode, sizeof calcMode); &#13;
    outStream.write((char*) &amp;editIndex, sizeof editIndex); &#13;
    editRef.WriteReferenceToStream(outStream); &#13;
    firstMarkRef.WriteReferenceToStream(outStream); &#13;
    lastMarkRef.WriteReferenceToStream(outStream); &#13;
    prevCell.WriteCellToStream(outStream); &#13;
    WriteSetMapToStream(sourceSetMap, outStream); &#13;
    WriteSetMapToStream(targetSetMap, outStream); &#13;
 &#13;
    for (int row = 0; row &lt; Rows; ++row) { &#13;
      for (int col = 0; col &lt; Cols; ++col) { &#13;
        cellMatrix[row][col].WriteCellToStream(outStream); &#13;
      } &#13;
    } &#13;
  } &#13;
  else if (EndsWith(name, TEXT(".txt"))) { &#13;
    for (int row = 0; row &lt; Rows; ++row) { &#13;
      if (row &gt; 0) { &#13;
        outStream &lt;&lt; "\n"; &#13;
      } &#13;
 &#13;
&#13;
      for (int col = 0; col &lt; Cols; ++col) { &#13;
        if (col &gt; 0) { &#13;
          outStream &lt;&lt; "\t"; &#13;
        } &#13;
 &#13;
        const Cell&amp; cell = cellMatrix[row][col]; &#13;
        String text = cell.IsFormula() &#13;
                      ? (TEXT("=") + cell.TreeToString()) &#13;
                      : cell.GetText(); &#13;
 &#13;
        for (TCHAR c : text) { &#13;
          outStream &lt;&lt; ((char) c); &#13;
        } &#13;
      } &#13;
    } &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
</pre><p>Note that we call the <code class="literal">MakeCellVisible</code> method at the end of the <code class="literal">ReadDocumentFromStream</code> method. The idea is that the user should be able to pick up the spreadsheet where they left it:</p><pre class="programlisting">bool CalcDocument::ReadDocumentFromStream(String name, &#13;
                                          istream&amp; inStream) { &#13;
  if (EndsWith(name, TEXT(".clc")) &amp;&amp; &#13;
      ReadPrintSetupInfoFromStream(inStream)){ &#13;
    inStream.read((char*)&amp;calcMode, sizeof calcMode); &#13;
    inStream.read((char*) &amp;editIndex, sizeof editIndex); &#13;
    editRef.ReadReferenceFromStream(inStream); &#13;
    firstMarkRef.ReadReferenceFromStream(inStream); &#13;
    lastMarkRef.ReadReferenceFromStream(inStream); &#13;
    prevCell.ReadCellFromStream(inStream); &#13;
    ReadSetMapFromStream(sourceSetMap, inStream); &#13;
    ReadSetMapFromStream(targetSetMap, inStream); &#13;
    MakeCellVisible(); &#13;
 &#13;
    for (int row = 0; row &lt; Rows; ++row) { &#13;
      for (int col = 0; col &lt; Cols; ++col) { &#13;
        cellMatrix[Reference(row, col)]. &#13;
            ReadCellFromStream(inStream); &#13;
      } &#13;
    } &#13;
  }   &#13;
&#13;
&#13;
&#13;
  else if (EndsWith(name, TEXT(".txt"))) { &#13;
    String text; &#13;
    int row = 0, col = 0; &#13;
 &#13;
    while (inStream) { &#13;
      char c; &#13;
      inStream.read(&amp;c, sizeof c); &#13;
 &#13;
      if (inStream) { &#13;
        switch (c) { &#13;
          case ';': &#13;
            cellMatrix[Reference(row, col++)].SetText(text); &#13;
            text.clear(); &#13;
            break; &#13;
 &#13;
          case '\n': &#13;
            cellMatrix[Reference(row++, col)].SetText(text); &#13;
            text.clear(); &#13;
            col = 0; &#13;
            break; &#13;
 &#13;
          default: &#13;
            text.push_back((TCHAR) c); &#13;
            break; &#13;
        } &#13;
      } &#13;
    } &#13;
  } &#13;
 &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre><p>The <code class="literal">WriteSetMapToStream</code> and <code class="literal">ReadSetMapFromStream</code> methods write and read the source and target sets. They are static, since they are called for both <code class="literal">sourceSetMap</code> and <code class="literal">targetSetMap</code>. For each cell in the spreadsheet, the size of the set as well as the references of the sets are written and read:</p><pre class="programlisting">bool CalcDocument::WriteSetMapToStream(const &#13;
                   map&lt;Reference,set&lt;Reference&gt;&gt;&amp; setMap, &#13;
                   ostream&amp; outStream) { &#13;
  int mapSize = setMap.size(); &#13;
  outStream.write((char*) &amp;mapSize, sizeof mapSize); &#13;
 &#13;
  for (pair&lt;Reference,set&lt;Reference&gt;&gt; entry : setMap) { &#13;
    Reference cellRef = entry.first; &#13;
    cellRef.WriteReferenceToStream(outStream); &#13;
 &#13;
&#13;
    set&lt;Reference&gt; set = entry.second; &#13;
    int setSize = set.size(); &#13;
    outStream.write((char*) &amp;setSize, sizeof setSize); &#13;
 &#13;
    for (Reference ref : set) { &#13;
      ref.WriteReferenceToStream(outStream); &#13;
    } &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool CalcDocument::ReadSetMapFromStream &#13;
                   (map&lt;Reference,set&lt;Reference&gt;&gt;&amp; setMap, &#13;
                    istream&amp; inStream) { &#13;
  int mapSize; &#13;
  inStream.read((char*) &amp;mapSize, sizeof mapSize); &#13;
 &#13;
  for (int mapIndex = 0; mapIndex &lt; mapSize; ++mapIndex) { &#13;
    Reference cellRef; &#13;
    cellRef.ReadReferenceFromStream(inStream); &#13;
 &#13;
    int setSize; &#13;
    inStream.read((char*) &amp;setSize, sizeof setSize); &#13;
 &#13;
    set&lt;Reference&gt; set; &#13;
    for (int setIndex = 0; setIndex &lt; setSize; ++setIndex) { &#13;
      Reference ref; &#13;
      ref.ReadReferenceFromStream(inStream); &#13;
      set.insert(ref); &#13;
    } &#13;
 &#13;
    setMap[cellRef] = set; &#13;
  } &#13;
 &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec71"/>Cut, copy, and paste</h2></div></div></div><p>The <strong>Copy</strong> menu item is enabled in the <code class="literal">mark</code> mode. Note that we do not override the <code class="literal">PasteEnable</code> method, since the <code class="literal">StandardDocument</code> class enables the <strong>Paste</strong> menu item if there is a clipboard buffer with one of the application formats–the <code class="literal">AsciiFormat</code>, <code class="literal">UnicodeFormat</code>, or <code class="literal">CalcFormat</code> format:</p><pre class="programlisting">bool CalcDocument::CopyEnable() const { &#13;
  return (calcMode == Mark); &#13;
} &#13;
</pre><p>The <code class="literal">CopyAscii</code> method simply calls <code class="literal">CopyUnicode</code>, which in turn fills the <code class="literal">textList</code> list with the copied text. Each text in the <code class="literal">textList</code> list holds one row, and the columns are divided by semicolons (';'):</p><pre class="programlisting">void CalcDocument::CopyAscii(vector&lt;String&gt;&amp; textList) const { &#13;
  CopyUnicode(textList); &#13;
} &#13;
 &#13;
void CalcDocument::CopyUnicode(vector&lt;String&gt;&amp; textList) const { &#13;
  int minMarkRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      maxMarkRow = max(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      minMarkCol = min(firstMarkRef.Col(), lastMarkRef.Col()), &#13;
      maxMarkCol = max(firstMarkRef.Col(), lastMarkRef.Col()); &#13;
 &#13;
  for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
    String text; &#13;
 &#13;
    for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
      Reference markRef = Reference(row, col); &#13;
      const Cell&amp; markCell = cellMatrix[markRef]; &#13;
      text.append(((col &gt; 0) ? TEXT(";") : TEXT("")) + &#13;
                  markCell.TreeToString()); &#13;
    } &#13;
 &#13;
    textList.push_back(text); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">CopyGeneric</code> method stores the top-left position and size of the marked block and calls the <code class="literal">WriteCellToClipboard</code> method for each marked cell:</p><pre class="programlisting">void CalcDocument::CopyGeneric(int /* format */, &#13;
                               InfoList&amp; infoList) const { &#13;
  int minRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      minCol = min(firstMarkRef.Col(), lastMarkRef.Col()), &#13;
      copyRows = abs(firstMarkRef.Row() - lastMarkRef.Row()) + 1, &#13;
      copyCols = abs(firstMarkRef.Col() - lastMarkRef.Col()) + 1; &#13;
 &#13;
  infoList.AddValue&lt;int&gt;(copyRows); &#13;
  infoList.AddValue&lt;int&gt;(copyCols); &#13;
  infoList.AddValue&lt;int&gt;(minRow); &#13;
  infoList.AddValue&lt;int&gt;(minCol); &#13;
 &#13;
&#13;
  for (int row = 0; row &lt; copyRows; ++row) { &#13;
    for (int col = 0; col &lt; copyCols; ++col) { &#13;
      Reference sourceRef(minRow + row, minCol + col); &#13;
      const Cell&amp; cell = cellMatrix[sourceRef]; &#13;
      cell.WriteCellToClipboard(infoList); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">IsPasteAsciiReady</code> method simply calls the <code class="literal">IsPasteUnicodeReady</code> method, which returns <code class="literal">true</code> if there is only one cell currently marked and the block to be pasted fits in the spreadsheet, or if the currently marked block has the same size as the block to be pasted. Note that in the first case, if only one cell is marked, the block to be pasted does not have to have an equal number of columns for each row, as long as they fit in the spreadsheet:</p><pre class="programlisting">bool CalcDocument::IsPasteAsciiReady &#13;
                   (const vector&lt;String&gt;&amp; textList) const { &#13;
  return IsPasteUnicodeReady(textList); &#13;
}  &#13;
bool CalcDocument::IsPasteUnicodeReady &#13;
                   (const vector&lt;String&gt;&amp; textList) const { &#13;
  int markedRows = abs(firstMarkRef.Row() - lastMarkRef.Row()) +1, &#13;
      markedCols = abs(firstMarkRef.Col() - lastMarkRef.Col()) +1, &#13;
      minMarkedRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      minMarkedCol = min(firstMarkRef.Col(), lastMarkRef.Col());  &#13;
  if ((markedRows == 1) &amp;&amp; (markedCols == 1)) { &#13;
    int copyRows = textList.size(); &#13;
    int maxCopyCols = 0;  &#13;
    for (String text : textList) { &#13;
      maxCopyCols = max(maxCopyCols, &#13;
                        ((int) Split(text, ';').size())); &#13;
    }  &#13;
    return ((minMarkedRow + copyRows) &lt; Rows) &amp;&amp; &#13;
           ((minMarkedCol + maxCopyCols) &lt; Cols); &#13;
  } &#13;
  else { &#13;
    if (textList.size() != markedRows) { &#13;
      return false; &#13;
    }  &#13;
    for (String text : textList) { &#13;
      if (((int) Split(text, ';').size()) != markedCols) { &#13;
        return false; &#13;
      } &#13;
    }  &#13;
    return true; &#13;
  } &#13;
} &#13;
</pre><p>Similar to the <code class="literal">IsPasteUnicodeReady</code> method, the <code class="literal">IsPasteGenericReady</code> method returns <code class="literal">true</code> if there is only cell marked at the moment and the block to be pasted fits in the spreadsheet or if the currently marked block and the block to be pasted have the same size. However, unlike the Unicode case we saw earlier, the rows of the generic block to be pasted all have the same size:</p><pre class="programlisting">bool CalcDocument::IsPasteGenericReady(int /* format */, &#13;
                                     InfoList&amp; infoList) const { &#13;
  int markedRows = abs(firstMarkRef.Row() - lastMarkRef.Row()) +1, &#13;
      markedCols = abs(firstMarkRef.Col() - lastMarkRef.Col()) +1, &#13;
      minMarkedRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      minMarkedCol = min(firstMarkRef.Col(), lastMarkRef.Col()), &#13;
      copyRows, copyCols; &#13;
 &#13;
  infoList.PeekValue&lt;int&gt;(copyRows, 0); &#13;
  infoList.PeekValue&lt;int&gt;(copyCols, sizeof(int)); &#13;
 &#13;
  return (((markedRows == copyRows)&amp;&amp;(markedCols == copyCols)) || &#13;
          ((markedRows == 1) &amp;&amp; (markedCols == 1))) &amp;&amp; &#13;
         ((minMarkedRow + copyRows) &lt;= Rows) &amp;&amp; &#13;
         ((minMarkedCol + copyCols) &lt;= Cols); &#13;
} &#13;
</pre><p>The <code class="literal">PasteAscii</code> method simply calls the <code class="literal">PasteUnicode</code> method that first takes a backup of the cell matrix as well as the source and target set maps, since the cells to be pasted may contain a formula with syntax errors, in which case the pasting process will be aborted. Then, it iterates through the text to be pasted and splits each row in to columns. The text of each column is copied to the pasted cell:</p><pre class="programlisting">void CalcDocument::PasteAscii(const vector&lt;String&gt;&amp; textList) { &#13;
  PasteUnicode(textList); &#13;
} &#13;
 &#13;
void CalcDocument::PasteUnicode(const vector&lt;String&gt;&amp; textList) { &#13;
  Matrix&lt;Rows,Cols,Cell&gt; backupMatrix = &#13;
    Matrix&lt;Rows,Cols,Cell&gt;(cellMatrix); &#13;
  map&lt;Reference,set&lt;Reference&gt;&gt; backupSourceSetMap = sourceSetMap, &#13;
                                backupTargetSetMap = targetSetMap; &#13;
 &#13;
  try { &#13;
    set&lt;Reference&gt; invalidateSet; &#13;
    int row = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
        minCol = min(firstMarkRef.Col(), lastMarkRef.Col()); &#13;
    Reference diffRef(row, minCol); &#13;
&#13;
&#13;
 &#13;
    for (String rowText : textList) { &#13;
      int col = minCol; &#13;
      vector&lt;String&gt; columnList = Split(rowText, ';'); &#13;
</pre><p>The text of the column is interpreted, and if it holds a formula with a syntax error, an exception is thrown, stopping the iteration and restoring the backup matrix together with the source and target set maps. This is actually the reason why the <code class="literal">EvaluateRecursive</code> method fills the set of references to be invalidated instead of just invalidating them. If the pasting process fails due to a formula with a syntax error, we would not want any cells to become invalidated and updated:</p><pre class="programlisting">      for (String colText : columnList) { &#13;
        Reference targetRef(row, col++); &#13;
        RemoveTargetSetMap(targetRef); &#13;
        Cell&amp; targetCell = cellMatrix[targetRef]; &#13;
        targetCell.Reset(); &#13;
        targetCell.SetText(colText) &#13;
        set&lt;Reference&gt; sourceSet; &#13;
        targetCell.InterpretCell(sourceSet); &#13;
        targetCell.GenerateCaretList(this); &#13;
</pre><p>When the text has been interpreted, we need to update the references, in case it holds a formula, by comparing the location of the marked block with the original location (from where it was copied) of the pasted block in order for the reference to be relative:</p><pre class="programlisting">        if (!diffRef.IsEmpty()) { &#13;
          sourceSet.clear(); &#13;
          targetCell.UpdateTree(diffRef, sourceSet); &#13;
        } &#13;
</pre><p>Finally, we set the source and target sets of the cell, evaluate its value, and generate its caret rectangle list. The evaluation may result in an error (missing value, reference out of range, circular reference, or division by zero), in which case an error message is stored in the cell text:</p><pre class="programlisting">        AddTargetSetMap(targetRef, sourceSet); &#13;
        sourceSetMap[targetRef] = sourceSet; &#13;
        EvaluateRecursive(targetRef, invalidateSet); &#13;
        targetCell.GenerateCaretList(this); &#13;
      } &#13;
     &#13;
      ++row; &#13;
    } &#13;
</pre><p>The pasted cells are not invalidated until we have iterated through them and none of them has been found to hold a formula with a syntax error. Note that there may be more than just the pasted cells to be invalidated, the other cells outside the pasted block that are targets of the pasted cells, and thereby evaluated, need to be invalidated:</p><pre class="programlisting">    for (Reference cellRef : invalidateSet) { &#13;
      InvalidateCell(cellRef); &#13;
    } &#13;
  } &#13;
</pre><p>If one of the pasted cells holds a formula with a syntax error, we simply restore the backup and display a message box:</p><pre class="programlisting">  catch (Error error) { &#13;
    cellMatrix = backupMatrix; &#13;
    sourceSetMap = backupSourceSetMap; &#13;
    targetSetMap = backupTargetSetMap; &#13;
    MessageBox(error.ErrorText(), TEXT("Syntax Error"), Ok, Stop); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">PasteGeneric</code> method is simpler than the <code class="literal">PasteUnicode</code> method: since there is no need for cell interpretation (as the cell has been copied from the spreadsheet and thereby holds valid formulas), there in no need for backup and no exception is thrown:</p><pre class="programlisting">void CalcDocument::PasteGeneric(int /* format */, &#13;
                                InfoList&amp; infoList) { &#13;
  int minMarkedRow = min(firstMarkRef.Row(), lastMarkRef.Row()), &#13;
      minMarkedCol = min(firstMarkRef.Col(), lastMarkRef.Col()), &#13;
      copyRows, copyCols, minCopyRow, minCopyCol; &#13;
 &#13;
  infoList.GetValue&lt;int&gt;(copyRows); &#13;
  infoList.GetValue&lt;int&gt;(copyCols); &#13;
  infoList.GetValue&lt;int&gt;(minCopyRow); &#13;
  infoList.GetValue&lt;int&gt;(minCopyCol); &#13;
 &#13;
  Reference diffRef(minMarkedRow - minCopyRow, &#13;
                    minMarkedCol - minCopyCol); &#13;
  int maxCopyRow = minCopyRow + copyRows - 1, &#13;
      maxCopyCol = minCopyCol + copyCols - 1; &#13;
</pre><p>Each pasted cell is read from the buffer and then the source cell is assigned to it. The target set is removed and then added by the pasted cell:</p><pre class="programlisting">  for (int row = minCopyRow; row &lt;= maxCopyRow; ++row) { &#13;
    for (int col = minCopyCol; col &lt;= maxCopyCol; ++col) { &#13;
      Cell pastedCell; &#13;
      pastedCell.ReadCellFromClipboard(infoList); &#13;
 &#13;
      Reference pastedRef(row, col); &#13;
      Reference targetRef = pastedRef + diffRef; &#13;
 &#13;
      RemoveTargetSetMap(targetRef); &#13;
      Cell&amp; targetCell = cellMatrix[targetRef]; &#13;
      targetCell = pastedCell; &#13;
 &#13;
      set&lt;Reference&gt; sourceSet; &#13;
      if (diffRef.IsEmpty()) { &#13;
        targetCell.GenerateSourceSet(sourceSet); &#13;
      } &#13;
      else { &#13;
        targetCell.UpdateTree(diffRef, sourceSet); &#13;
      } &#13;
 &#13;
      AddTargetSetMap(targetRef, sourceSet); &#13;
      sourceSetMap[targetRef] = sourceSet; &#13;
 &#13;
      set&lt;Reference&gt; invalidateSet; &#13;
      EvaluateRecursive(targetRef, invalidateSet); &#13;
 &#13;
      for (Reference cellRef : invalidateSet) { &#13;
        InvalidateCell(cellRef); &#13;
      } &#13;
    } &#13;
  } &#13;
 &#13;
  UpdateWindow(); &#13;
  SetDirty(true); &#13;
} &#13;
</pre><p>The <strong>Delete</strong> menu item is enabled in the <code class="literal">edit</code> mode unless the edit index is at the end of the cell's text. The item is always enabled in the <code class="literal">mark</code> mode, since there is always at least one marked cell marked to be deleted:</p><pre class="programlisting">bool CalcDocument::DeleteEnable() const { &#13;
  if (calcMode == Edit) { &#13;
    const Cell&amp; editCell = cellMatrix[editRef]; &#13;
    return (editIndex &lt; ((int)editCell.GetText().length())); &#13;
  } &#13;
  else { &#13;
    return true; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnDelete</code> method (the menu item) just calls <code class="literal">OnDeleteKey</code> (the key pressed), since they perform the same action:</p><pre class="programlisting">void CalcDocument::OnDelete() { &#13;
  OnDeleteKey(); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec72"/>Font and color</h2></div></div></div><p>The <code class="literal">OnFont</code> and <code class="literal">OnBackgroundColor</code> methods work in the same manner–they are called when the user selects the <strong>Font</strong> or <strong>Background Color</strong> items in the <strong>Format</strong> menu. They apply the change on the edited or marked cells, and the window and (in the edit case) the caret is updated. If at least one cell has been modified, the dirty flag is set:</p><pre class="programlisting">void CalcDocument::OnFont() { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        Cell&amp; editCell = cellMatrix[editRef]; &#13;
        Font font = editCell.CellFont(); &#13;
        Font previousFont = font; &#13;
</pre><p>In the <code class="literal">edit</code> mode, the font of the edited cell is changed if the <code class="literal">FontDialog</code> method returns <code class="literal">true</code> (the user has pressed the <strong>Ok</strong> button) and has chosen a different font. Note that the <code class="literal">FontDialog</code> method also sets the color of the font:</p><pre class="programlisting">        if (StandardDialog::FontDialog(this, font) &amp;&amp; &#13;
            (font != previousFont)) { &#13;
          editCell.CellFont() = font; &#13;
          editCell.GenerateCaretList(this); &#13;
          InvalidateCell(editRef); &#13;
          SetDirty(true); &#13;
          UpdateCaret(); &#13;
          UpdateWindow(); &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>In the <code class="literal">mark</code> mode, the font of each marked cell is set to the new font if the <code class="literal">FontDialog</code> method returns <code class="literal">true</code>. If the font of at least one cell is set (which we do not know from the start), the dirty flag is set:</p><pre class="programlisting">    case Mark: { &#13;
        Font font = cellMatrix[lastMarkRef].CellFont(); &#13;
&#13;
 &#13;
        if (StandardDialog::FontDialog(this, font)) { &#13;
          int minMarkRow = min(firstMarkRef.Row(), &#13;
                               lastMarkRef.Row()), &#13;
              maxMarkRow = max(firstMarkRef.Row(), &#13;
                               lastMarkRef.Row()), &#13;
              minMarkCol = min(firstMarkRef.Col(), &#13;
                               lastMarkRef.Col()), &#13;
              maxMarkCol = max(firstMarkRef.Col(), &#13;
                               lastMarkRef.Col()); &#13;
 &#13;
          for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
            for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
              Reference markRef = Reference(row, col); &#13;
              Cell&amp; markCell = cellMatrix[markRef]; &#13;
 &#13;
              if (markCell.CellFont() != font) { &#13;
                markCell.CellFont() = font; &#13;
                markCell.GenerateCaretList(this); &#13;
                InvalidateCell(markRef); &#13;
                SetDirty(true); &#13;
              } &#13;
            } &#13;
          } &#13;
 &#13;
          UpdateWindow(); &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnBackgroundColor</code> method is similar to the <code class="literal">OnFont</code> method. The only difference is that the <code class="literal">OnBackgroundColor</code> method calls the <code class="literal">ColorDialog</code> method instead of the <code class="literal">FontDialog</code> method, and that <code class="literal">BackgroundColor</code> is called for each cell instead of <code class="literal">Font</code>:</p><pre class="programlisting">void CalcDocument::OnBackgroundColor() { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        Cell&amp; editCell = cellMatrix[editRef]; &#13;
        Color color = editCell.BackgroundColor(); &#13;
        Color previousColor = color; &#13;
&#13;
        if (StandardDialog::ColorDialog(this, color) &amp;&amp; &#13;
            (color != previousColor)){ &#13;
          editCell.BackgroundColor() = color; &#13;
          InvalidateCell(editRef); &#13;
          SetDirty(true); &#13;
        } &#13;
      } &#13;
      break; &#13;
 &#13;
    case Mark: { &#13;
        Color color = cellMatrix[lastMarkRef].BackgroundColor(); &#13;
 &#13;
        if (StandardDialog::ColorDialog(this, color)) { &#13;
          int minMarkRow = min(firstMarkRef.Row(), &#13;
                               lastMarkRef.Row()), &#13;
              maxMarkRow = max(firstMarkRef.Row(), &#13;
                               lastMarkRef.Row()), &#13;
              minMarkCol = min(firstMarkRef.Col(), &#13;
                               lastMarkRef.Col()), &#13;
              maxMarkCol = max(firstMarkRef.Col(), &#13;
                               lastMarkRef.Col()); &#13;
 &#13;
          for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
            for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
              Reference markRef = Reference(row, col); &#13;
              Cell&amp; markCell = cellMatrix[markRef]; &#13;
 &#13;
              if (markCell.BackgroundColor() != color) { &#13;
                markCell.BackgroundColor() = color; &#13;
                InvalidateCell(markRef); &#13;
                SetDirty(true); &#13;
              } &#13;
            } &#13;
          } &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
 &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec73"/>Alignment</h2></div></div></div><p>The horizontal and vertical alignments follow the same pattern. The radio methods call the <code class="literal">IsHorizontalAlignment</code> or <code class="literal">IsVerticalAlignment</code> method, which return <code class="literal">true</code> if the edited cells or all the marked cells hold the alignment in question. The selection methods call the <code class="literal">SetHorizontalAlignment</code> or <code class="literal">SetVerticalAlignment</code> method, which set the alignment of the edited cell or every marked cell. If at least one cell has been modified, the dirty flag is set. Finally, the window and (in the edit case) caret are updated.</p><p>The <code class="literal">HorizontalLeftRadio</code>, <code class="literal">HorizontalCenterRadio</code>, <code class="literal">HorizontalRightRadio</code>, and <code class="literal">HorizontalJustifiedRadio</code> methods call the <code class="literal">IsHorizontalAlignment</code> method, as you'll see next:</p><pre class="programlisting">bool CalcDocument::HorizontalLeftRadio() const { &#13;
  return (IsHorizontalAlignment(Left)); &#13;
} &#13;
 &#13;
bool CalcDocument::HorizontalCenterRadio() const { &#13;
  return (IsHorizontalAlignment(Center)); &#13;
} &#13;
 &#13;
bool CalcDocument::HorizontalRightRadio() const { &#13;
  return (IsHorizontalAlignment(Right)); &#13;
} &#13;
 &#13;
bool CalcDocument::HorizontalJustifiedRadio() const { &#13;
  return (IsHorizontalAlignment(Justified)); &#13;
} &#13;
</pre><p>The <code class="literal">IsHorizontalAlignment</code> method returns <code class="literal">true</code> if the alignment of the edited cell or at least one of the marked cells holds the alignment in question:</p><pre class="programlisting">bool CalcDocument::IsHorizontalAlignment(Alignment alignment) &#13;
                                         const { &#13;
  switch (calcMode) { &#13;
    case Edit: &#13;
      return cellMatrix[editRef].HorizontalAlignment() == &#13;
             alignment; &#13;
 &#13;
    case Mark: { &#13;
        int minMarkRow = min(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            maxMarkRow = max(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            minMarkCol = min(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()), &#13;
            maxMarkCol = max(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()); &#13;
 &#13;
        for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
          for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
            Reference markRef = Reference(row, col); &#13;
            if (cellMatrix[markRef].VerticalAlignment()!= &#13;
                alignment) { &#13;
              return true; &#13;
            } &#13;
          } &#13;
        } &#13;
       &#13;
        return false; &#13;
      } &#13;
  } &#13;
 &#13;
  return true; &#13;
} &#13;
</pre><p>The <code class="literal">OnHorizontalLeft</code>,  <code class="literal">OnHorizontalCenter</code>,  <code class="literal">OnHorizontalRight</code>, and <code class="literal">OnHorizontalJustified</code> methods call the <code class="literal">SetHorizontalAlignment</code> method, as follows:</p><pre class="programlisting">void CalcDocument::OnHorizontalLeft() { &#13;
  SetHorizontalAlignment(Left); &#13;
} &#13;
 &#13;
void CalcDocument::OnHorizontalCenter() { &#13;
  SetHorizontalAlignment(Center); &#13;
} &#13;
 &#13;
void CalcDocument::OnHorizontalRight() { &#13;
  SetHorizontalAlignment(Right); &#13;
} &#13;
 &#13;
void CalcDocument::OnHorizontalJustified() { &#13;
  SetHorizontalAlignment(Justified); &#13;
} &#13;
</pre><p>The <code class="literal">SetHorizontalAlignment</code> method sets the alignment of the edited cell or all marked cells:</p><pre class="programlisting">void CalcDocument::SetHorizontalAlignment(Alignment alignment) { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        Cell&amp; editCell = cellMatrix[editRef]; &#13;
        editCell.HorizontalAlignment() = alignment; &#13;
        editCell.GenerateCaretList(this); &#13;
        InvalidateCell(editRef); &#13;
        UpdateCaret(); &#13;
      } &#13;
      break; &#13;
    case Mark: { &#13;
        int minMarkRow = min(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            maxMarkRow = max(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            minMarkCol = min(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()), &#13;
            maxMarkCol = max(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()); &#13;
 &#13;
        for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
          for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
            Reference markRef = Reference(row, col); &#13;
            Cell&amp; markCell = cellMatrix[markRef]; &#13;
</pre><p>For each cell whose alignment is changed, its caret rectangle list is regenerated and the cell becomes invalidated:</p><pre class="programlisting">            if (markCell.HorizontalAlignment() != alignment) { &#13;
              markCell.HorizontalAlignment() = alignment; &#13;
              markCell.GenerateCaretList(this); &#13;
              InvalidateCell(markRef); &#13;
            } &#13;
          } &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
</pre><p>The dirty flag is set, since at least one cell has been modified. Otherwise, the alignment menu item would not be enabled:</p><pre class="programlisting">  UpdateWindow(); &#13;
  SetDirty(true); &#13;
} &#13;
</pre><p>The vertical alignment methods are similar to the horizontal alignment methods, as we can see here:</p><pre class="programlisting">bool CalcDocument::VerticalTopRadio() const { &#13;
  return (IsVerticalAlignment(Top)); &#13;
} &#13;
 &#13;
bool CalcDocument::VerticalCenterRadio() const { &#13;
  return (IsVerticalAlignment(Center)); &#13;
} &#13;
 &#13;
bool CalcDocument::VerticalBottomRadio() const { &#13;
  return (IsVerticalAlignment(Bottom)); &#13;
} &#13;
 &#13;
bool CalcDocument::IsVerticalAlignment(Alignment alignment) const { &#13;
  switch (calcMode) { &#13;
    case Edit: &#13;
      return cellMatrix[editRef].VerticalAlignment() == alignment; &#13;
 &#13;
    case Mark: { &#13;
        int minMarkRow = min(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            maxMarkRow = max(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            minMarkCol = min(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()), &#13;
            maxMarkCol = max(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()); &#13;
 &#13;
        for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
          for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
            Reference markRef = Reference(row, col); &#13;
            if (cellMatrix[markRef].VerticalAlignment() != &#13;
                alignment){ &#13;
              return true; &#13;
            } &#13;
          } &#13;
        } &#13;
     &#13;
        return false; &#13;
      } &#13;
  } &#13;
 &#13;
  return true; &#13;
} &#13;
 &#13;
void CalcDocument::OnVerticalTop() { &#13;
  SetVerticalAlignment(Top); &#13;
} &#13;
 &#13;
void CalcDocument::OnVerticalCenter() { &#13;
  SetVerticalAlignment(Center); &#13;
} &#13;
 &#13;
void CalcDocument::OnVerticalBottom() { &#13;
  SetVerticalAlignment(Bottom); &#13;
} &#13;
 &#13;
void CalcDocument::SetVerticalAlignment(Alignment alignment) { &#13;
  switch (calcMode) { &#13;
    case Edit: { &#13;
        Cell&amp; editCell = cellMatrix[editRef]; &#13;
        editCell.VerticalAlignment() = alignment; &#13;
        editCell.GenerateCaretList(this); &#13;
        InvalidateCell(editRef); &#13;
        UpdateCaret(); &#13;
      } &#13;
      break; &#13;
 &#13;
    case Mark: { &#13;
        int minMarkRow = min(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            maxMarkRow = max(firstMarkRef.Row(), &#13;
                             lastMarkRef.Row()), &#13;
            minMarkCol = min(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()), &#13;
            maxMarkCol = max(firstMarkRef.Col(), &#13;
                             lastMarkRef.Col()); &#13;
 &#13;
        for (int row = minMarkRow; row &lt;= maxMarkRow; ++row) { &#13;
          for (int col = minMarkCol; col &lt;= maxMarkCol; ++col) { &#13;
            Reference markRef = Reference(row, col); &#13;
            Cell&amp; markCell = cellMatrix[markRef]; &#13;
 &#13;
            if (markCell.VerticalAlignment() != alignment) { &#13;
              markCell.VerticalAlignment() = alignment; &#13;
              markCell.GenerateCaretList(this); &#13;
              InvalidateCell(markRef); &#13;
            } &#13;
          } &#13;
        } &#13;
      } &#13;
      break; &#13;
  } &#13;
 &#13;
  UpdateWindow(); &#13;
  SetDirty(true); &#13;
}  &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec36"/>Source and target sets</h1></div></div></div><p>Each cell in the spreadsheet holds a numerical value, a formula, or a (possibly empty) plain text. As mentioned at the beginning of the chapter, a formula is a text beginning with the equal sign (=) followed by a numerical expression with cell references. If the cell holds a value, it may affect the values in other cells (if it does not hold a value, it might cause evaluation errors in target cells). If the cell contains a formula, its value may depend on the values in other cells. This implies that each cell needs a set of cells that it depends on, that is, its source set, and a set of cells that depend on it, that is, its target set.</p><p>Only a formula has a non-empty source set, which is the set of all references of the formula. The target set, on the other hand, is more complicated–a cell does not decide its own target set; it is decided indirectly by the formulas that have it as its source cell.</p><p>In mathematical terms, the cells with its source and target sets constitute a <strong>directed graph</strong>. Technically, they constitute two different directed graphs, one each for the source and target sets. However, the graphs are just inverses of each other, so in all practical ways, they can be regarded as the same graph.</p><p>For instance, in the screenshot that follows the source set of <code class="literal">a3</code> holds <code class="literal">a1</code> and <code class="literal">c1</code> because its formula includes <code class="literal">a1</code> and <code class="literal">c1</code>. In the same way, the source set of <code class="literal">c3</code> holds <code class="literal">c1</code> because its formula includes <code class="literal">c1</code>. The source set of <code class="literal">a1</code> and <code class="literal">c1</code> are empty, because they do not hold formulas.</p><p>As <code class="literal">c1</code> is included in both the formulas of <code class="literal">a3</code> and <code class="literal">c3</code>, the value of <code class="literal">c1</code> affects the values of <code class="literal">a3</code> and <code class="literal">c3</code>. This implies that the target set of <code class="literal">c1</code> holds <code class="literal">a3</code> and <code class="literal">c3</code>. In the same way, as <code class="literal">a1</code> is included in the formula of <code class="literal">a3</code>, the target set of <code class="literal">a1</code> holds <code class="literal">a3</code>. As the values of <code class="literal">a3</code> and <code class="literal">c3</code> do not affect the values of any other cells, their target sets are empty.</p><p>
</p><div><img src="img/B05475_08_02.jpg" alt="Source and target sets"/></div><p>
</p><p>The following is a screenshot of the same spreadsheet with the <code class="literal">c3</code> cell being edited instead of the <code class="literal">a3</code> cell:</p><p>
</p><div><img src="img/B05475_08_03.jpg" alt="Source and target sets"/></div><p>
</p><p>The first of the following diagrams shows the acyclic graph of the source sets of the preceding spreadsheet, the second diagram shows the acyclic graph of the target sets. As mentioned previously (and shown by the graphs), the source and targets sets are the inverse of each other. Technically, we can manage with only one of the sets. However, as the sets are needed on different occasions, the code is clearer with both of them.</p><p>
</p><div><img src="img/B05475_07_04.jpg" alt="Source and target sets"/></div><p>
</p><p>When the value of a cell is changed, its target set is traversed and the values of those cells are updated. Then the target sets of these cells are traversed, and so on. The search terminates when there are no more cells to evaluate or when we detect a circular reference. The circular reference is detected by a deep-search algorithm, which is described in the next section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec37"/>Graph searching</h1></div></div></div><p>When the user changes the value of a cell, we need to find the cells that need to be re-evaluated. Again, note the difference between source and target sets. While only formula cells can have non-empty source sets, all kinds of cells (also empty cells) can have non-empty target sets. Another difference between the two sets is that the target sets are defined indirectly by formulas in other cells. If a formula of another cell holds a reference to a particular cell, the reference to the formula cell is added to the target set of the particular cell. In the same way, when a formula is altered or cleared, the reference to that cell is removed from the target sets of all its source cells. When a cell is updated, all its targets are evaluated recursively–the targets cells are re-evaluated, then their target cells are re-evaluated, and so on. The evaluation always terminates when there are no more targets left, or when a circular reference is encountered. We always run out of targets or encounter a circular reference, since there is a finite number of cells in the spreadsheet.</p><p>The <code class="literal">InterpretEditCell</code> method is called when the user finishes the input of a cell. It interprets the cell by calling the <code class="literal">InterpretCell</code> method, which fills the <code class="literal">sourceSet</code> method but throws an exception in the case of a formula with a syntax error:</p><pre class="programlisting">bool CalcDocument::InterpretEditCell() { &#13;
  try { &#13;
    Cell&amp; editCell = cellMatrix[editRef]; &#13;
    set&lt;Reference&gt; sourceSet; &#13;
    editCell.InterpretCell(sourceSet); &#13;
</pre><p>However, if the parsing goes well, the previous source set is removed and the new source set is added:</p><pre class="programlisting">    RemoveTargetSetMap(editRef); &#13;
    AddTargetSetMap(editRef, sourceSet); &#13;
    sourceSetMap[editRef] = sourceSet; &#13;
</pre><p>Then the cell is recursively evaluated and all its direct or indirect target cells are updated:</p><pre class="programlisting">    set&lt;Reference&gt; invalidateSet; &#13;
    EvaluateRecursive(editRef, invalidateSet); &#13;
    editCell.GenerateCaretList(this); &#13;
</pre><p>Finally, all evaluated cells are invalidated, the dirty flag is set, and <code class="literal">true</code> is returned:</p><pre class="programlisting">    for (Reference cellRef : invalidateSet) { &#13;
      InvalidateCell(cellRef); &#13;
    } &#13;
 &#13;
    SetDirty(true); &#13;
    return true; &#13;
  } &#13;
</pre><p>If a syntax error is detected and an exception is thrown, an error message is displayed and <code class="literal">false</code> is returned. In that case, the application remains in <code class="literal">edit</code> mode if the user has finished the input. If the <code class="literal">InterpretEditCell</code> method has been called due to pasting, the pasting process is aborted:</p><pre class="programlisting">  catch (Error error) { &#13;
    MessageBox(error.ErrorText(), TEXT("Syntax Error"), Ok, Stop); &#13;
    return false; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">InvalidateCell</code> method invalidates the area occupied by the cell with the given reference:</p><pre class="programlisting">void CalcDocument::InvalidateCell(Reference cellRef) { &#13;
  Point topLeft(HeaderWidth + (cellRef.Col() * ColWidth), &#13;
                HeaderHeight + (cellRef.Row() * RowHeight)); &#13;
  Size cellSize(ColWidth, RowHeight); &#13;
  Rect cellRect(topLeft, cellSize); &#13;
  Invalidate(cellRect); &#13;
} &#13;
</pre><p>The sources and targets sets can be searched and evaluated in two ways: <strong>depth-first</strong> and <strong>breadth-first</strong>. As the names implies, depth-first tries to search as deep as possible. When it reaches a dead end, it backtracks and tries another way, if there is one. Breadth-first, on the other hand, evaluates all cells at the same distance from the start cell. Not until every cell at a distance has been evaluated, are the cells at the next distance examined.</p><p>When the user adds or alters a formula, it is essential that we detect potential circular references in the graph. The <code class="literal">IsCircular</code> method decides whether the cell is part of a circular reference, that is, a direct reference to its own cell or a chain of references leading to its own cell. We perform a depth-first search, which is easier than the breadth-first search, since we can take advantage of recursive calls. The breadth-first method is, on the other hand, necessary in order to evaluate the targets of a modified cell in the <code class="literal">EvaluateRecursive</code> method, as shown here:</p><pre class="programlisting">bool CalcDocument::IsCircular(Reference cellRef, &#13;
                              set&lt;Reference&gt;&amp; targetSet){ &#13;
  for (Reference targetRef : targetSet) { &#13;
    if ((cellRef == targetRef) || &#13;
        IsCircular(cellRef, targetSetMap[targetRef])) { &#13;
      return true; &#13;
    } &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>When the value of a cell is modified, it is essential that the formulas having references to the cell are notified and that their values are re-evaluated. The <code class="literal">EvaluateRecursive</code> method performs a breadth-first search by following the target sets forward.</p><p>Unlike the check for circular references, which we saw earlier, we cannot perform a depth-first search, since it would introduce the risk of the cells being evaluated in the wrong order:</p><pre class="programlisting">void CalcDocument::EvaluateCell(Reference cellRef) { &#13;
  Cell&amp; cell = cellMatrix[cellRef]; &#13;
 &#13;
  if (IsCircular(cellRef, targetSetMap[cellRef])) { &#13;
    cell.SetText(Error(CircularReference).ErrorText()); &#13;
  } &#13;
  else { &#13;
    set&lt;Reference&gt; sourceSet = sourceSetMap[cellRef]; &#13;
    map&lt;Reference, double&gt; valueMap; &#13;
 &#13;
    for (Reference sourceRef : sourceSet) {   &#13;
      Cell&amp; sourceCell = cellMatrix[sourceRef]; &#13;
 &#13;
      if (sourceCell.HasValue()) { &#13;
        valueMap[sourceRef] = sourceCell.GetValue(); &#13;
      } &#13;
    } &#13;
 &#13;
    cell.Evaluate(valueMap); &#13;
  } &#13;
 &#13;
  cell.GenerateCaretList(this); &#13;
} &#13;
</pre><p>When a cell is being evaluated, it needs the values of the cells in its source set; the <code class="literal">valueMap</code> parameter holds the values of the source cells that holds some value. Every source cell not holding a value is omitted from the map:</p><pre class="programlisting">void CalcDocument::EvaluateRecursive(Reference cellRef, &#13;
                           set&lt;Reference&gt;&amp; invalidateSet) { &#13;
</pre><p>If this cell is not a part of a circular reference, we add the values of the referred cells with values to the <code class="literal">valueMap</code> parameter. Refereed cells without values are simply omitted from the <code class="literal">valueMap</code> parameter:</p><pre class="programlisting">  set&lt;Reference&gt; targetSet, evaluatedSet; &#13;
  targetSet.insert(cellRef); &#13;
 &#13;
  while (!targetSet.empty()) { &#13;
    Reference targetRef = *targetSet.begin(); &#13;
    targetSet.erase(targetRef); &#13;
 &#13;
&#13;
&#13;
    if (evaluatedSet.count(targetRef) == 0) { &#13;
      EvaluateCell(targetRef); &#13;
      evaluatedSet.insert(targetRef); &#13;
      invalidateSet.insert(targetRef); &#13;
      set&lt;Reference&gt; nextTargetSet = targetSetMap[targetRef]; &#13;
      targetSet.insert(nextTargetSet.begin(), &#13;
                       nextTargetSet.end()); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>Regardless of whether the cell was properly evaluated or was found to be part of a circular reference, we need to regenerate its caret rectangle list. It is either given a proper value or an error message, and in both cases, the text is changed:</p><pre class="programlisting">  cell.GenerateCaretList(this); &#13;
} &#13;
</pre><p>The <code class="literal">RemoveTargetSetMap</code> method traverses the source set of the cell in the cell matrix and, for each source cell, removes the cell as a target. In the same way, the <code class="literal">AddTargetSetMap</code> method traverses the source set of the cell in the cell matrix and, for each source cell, adds the cell as a target:</p><pre class="programlisting">void CalcDocument::RemoveTargetSetMap(Reference cellRef) { &#13;
  for (Reference sourceRef : sourceSetMap[cellRef]) { &#13;
    int row = sourceRef.Row(), col = sourceRef.Col(); &#13;
    if ((row &gt;= 0) &amp;&amp; (row &lt; Rows) &amp;&amp; (col &gt;= 0) &amp;&amp; (col &lt; Cols)){ &#13;
      targetSetMap[sourceRef].erase(cellRef); &#13;
    } &#13;
  } &#13;
} &#13;
 &#13;
void CalcDocument::AddTargetSetMap(Reference cellRef, &#13;
                                   set&lt;Reference&gt;&amp; sourceSet) { &#13;
  for (Reference sourceRef : sourceSet) { &#13;
    int row = sourceRef.Row(), col = sourceRef.Col(); &#13;
    if ((row &gt;= 0) &amp;&amp; (row &lt; Rows) &amp;&amp; (col &gt;= 0) &amp;&amp; (col &lt; Cols)){ &#13;
      targetSetMap[sourceRef].insert(cellRef); &#13;
    } &#13;
  } &#13;
 &#13;
  sourceSetMap[cellRef] = sourceSet; &#13;
} &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec38"/>Error handling</h1></div></div></div><p>The evaluation errors are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Missing value</strong>: This error occurs when the cell referred in a formula does not hold a value</li><li class="listitem" style="list-style-type: disc"><strong>Reference out of range</strong>: This error occurs when a reference is outside the scope of the spreadsheet</li><li class="listitem" style="list-style-type: disc"><strong>Circular reference</strong>: This error occurs when a cell is referring to itself, directly or indirectly</li><li class="listitem" style="list-style-type: disc"><strong>Division by zero</strong>: This error occurs when the denominator in a division expression is zero</li></ul></div><p>There is also the syntax error that occurs when the user inputs a syntactically incorrect formula.</p><p>
<strong>Error.h</strong>
</p><pre class="programlisting">enum ErrorId {SyntaxError, CircularReference, ReferenceOutOfRange, &#13;
              DivisionByZero, MissingValue}; &#13;
 &#13;
class Error : public exception { &#13;
  public: &#13;
    Error(ErrorId errorId); &#13;
    String ErrorText() const; &#13;
 &#13;
  private: &#13;
    ErrorId errorId; &#13;
}; &#13;
</pre><p>
<strong>Error.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Error.h" &#13;
 &#13;
Error::Error(ErrorId errorId) &#13;
 :errorId(errorId) { &#13;
  // Empty. &#13;
} &#13;
 &#13;
String Error::ErrorText() const{ &#13;
  switch (errorId) { &#13;
    case SyntaxError: &#13;
      return TEXT("Syntax Error."); &#13;
 &#13;
&#13;
    case CircularReference: &#13;
      return TEXT("#Circular reference#"); &#13;
 &#13;
    case DivisionByZero: &#13;
      return TEXT("#Division by Zero#"); &#13;
 &#13;
    case MissingValue: &#13;
      return TEXT("#Missing Value#"); &#13;
 &#13;
    case ReferenceOutOfRange: &#13;
      return TEXT("#Reference out of Range.#"); &#13;
  } &#13;
 &#13;
  return TEXT(""); &#13;
} &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we looked into how a spreadsheet program is implemented: the mouse and keyboard input; cut, copy, and paste; file management; and font, color, and alignment. <a class="link" href="ch09.html" title="Chapter 9. Formula Interpretation">Chapter 9</a>, <em>Formula Interpretation</em>, will introduce cell handling and formula interpretation, including parsing, scanning, and caret rectangle list generation.</p></div></body></html>