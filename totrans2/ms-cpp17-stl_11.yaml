- en: Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about regular expressions, a feature that
    has been part of the C++ standard library since C++11, but which is still little-known
    by many programmers. You saw that regular expressions are useful in two situations
    at the opposite ends of the C++ spectrum--in complex programs requiring bulletproof
    parsing of complicated input formats, and in trivial scripts where the important
    things are readability and speed of development.
  prefs: []
  type: TYPE_NORMAL
- en: Another library feature that lands squarely in both of these categories is *random
    number generation*. Many scripting programs require a little bit of randomness
    here and there, but C++ programmers have been taught for decades that the classic
    libc `rand()` function is pass√©. At the other end of the spectrum, `rand()` is
    spectacularly inappropriate, both for cryptography and for complicated numerical
    simulations. The C++11 `<random>` library, however, manages to hit all three of
    these targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between truly random and pseudo-random number sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a *generator* of random bits and a *distribution* that
    produces data values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three strategies to seed a random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several standard library generators and distributions, and their use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to shuffle a deck of cards in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random numbers versus pseudo-random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about random numbers in the context of computer programming, we
    must be careful to distinguish between truly random numbers, which come from a
    physically non-deterministic source, and *pseudo-random* numbers, which come from
    an algorithm that deterministically produces a stream of "random-looking" numbers.
    Such an algorithm is called a **pseudo-random number generator** (**PRNG**). Every
    PRNG conceptually works the same way--it has some internal *state*, and it has
    some way for the user to ask for the *next output*. Every time we ask for the
    next output, the PRNG scrambles its internal state according to some deterministic
    algorithm and returns some piece of that state. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This `SimplePRNG` class implements a *linear congruential generator*, which
    is likely very similar to your standard library's implementation of `rand()`.
    Notice that `SimplePRNG::operator()` produces integers in the `[0, 32767]` 15-bit
    range, but its internal `state` has a 32-bit range. This pattern is true in real-world
    PRNGs as well.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the standard Mersenne Twister algorithm keeps almost 20 kilobytes
    of state! Keeping so much internal state means that there are lots of bits to
    scramble, and only a small fraction of the PRNG's internal state leaks out at
    each generation. This makes it difficult for a human (or a computer) to predict
    the PRNG's next output, given only a few of the preceding outputs. The difficulty
    of predicting its outputs leads us to call this thing a *pseudo-random* number
    generator. If its output was full of obvious patterns and easy to predict, we'd
    probably call it a *non-random* number generator!
  prefs: []
  type: TYPE_NORMAL
- en: Despite its pseudo-random qualities, a PRNG's behavior is always perfectly *deterministic*;
    it follows exactly the algorithm it was coded to follow. If we take a program
    that uses a PRNG and run it several times in a row, we expect to get the exact
    same sequence of pseudo-random numbers each time. Its strict determinism leads
    us to call this thing a *pseudo*-random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of *pseudo-random* number generators is that two generators running
    the exact same algorithm, but with tiny variations in their initial states, will
    rapidly magnify these variations, *diverge* from each other, and produce completely
    different-looking output sequences--just as two drops of water placed in slightly
    different spots on the back of your hand will run off in completely divergent
    directions. This means that if we want a different sequence of pseudo-random numbers
    each time we run our program, all we have to do is make sure that we use a different
    *initial state* for our PRNG. Setting a PRNG's initial state is called *seeding*
    the PRNG.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have at least three strategies for seeding our PRNG:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a seed supplied *from outside--*from the caller or end user. This is the
    most appropriate for anything that needs reproducibility, such as Monte Carlo
    simulations or anything that you'll unit test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a predictable but variable seed, such as the current timestamp. Prior
    to C++11, this was the most common strategy, because the C standard library provides
    a portable and convenient `time` function, but does not provide any portable source
    of truly random bits. Seeding based on something as predictable as `time` is not
    suitable for anything security-related. As of C++11, you shouldn't ever use this
    strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a *truly random* seed obtained directly from some platform-specific source
    of "truly random" bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Truly random* bits are collected by the operating system based on all sorts
    of random events; a classic approach is for every system call to collect the low-order
    bits of the hardware cycle counter and XOR them into the operating system''s *entropy
    pool*. A PRNG deep inside the kernel is periodically reseeded with bits from the
    entropy pool; the output sequence of that PRNG is exposed to application programmers.
    On Linux, the raw entropy pool is exposed as `/dev/random` and the PRNG''s output
    sequence is exposed as `/dev/urandom`. Fortunately, you''ll never need to deal
    with either of those devices directly; the C++ standard library has you covered.
    Read on.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem with rand()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The old school C way of generating *random* numbers is to call `rand()`. The
    `rand()` function, which is still part of C++, takes no arguments and produces
    a single, uniformly distributed integer in the `[0, RAND_MAX]` range. The internal
    state can be *seeded* by calling the library function, `srand(seed_value)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic code to generate a *random* number in the `[0, x)` range hasn''t
    changed since the 1980s, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, this code has several problems. The first and most obvious problem
    is that it doesn't generate all `x` outputs with equal likelihood. Suppose, for
    the sake of argument, `rand()` returns a uniformly distributed value in the `[0,
    32767]` range, then `randint0(10)` will return each value in the `[0, 7]` range
    one-3276th more often than it returns either `8` or `9`.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that `rand()` accesses global state; the same random number
    generator is shared by every thread in your C++ program. This isn't a thread-safety
    concern--`rand()` has been guaranteed to be thread-safe since C++11\. However,
    it is a problem for performance (because each call to `rand()` must take a global
    mutex lock), and it is a problem for reproducibility (because if you use `rand()`
    from multiple threads concurrently, different runs of the program may yield different
    answers).
  prefs: []
  type: TYPE_NORMAL
- en: 'A third and related problem with the global-statefulness of `rand()` is that
    any function anywhere in the program can modify that state just by calling `rand()`.
    This makes it effectively impossible to use `rand()` in a unit-test-driven environment.
    Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the unit test, `test_heads`, will break as soon as we start parallelizing
    our unit tests (because a call to `rand()` from some other thread will interfere
    with the delicate workings of this test). However, more subtly, it can also break
    simply because someone changed the implementation of `DEBUG_LOG` to add or remove
    a call to `rand()`! This kind of *spooky action at a distance* is a problem any
    time your architecture depends on global variables. We saw a similar danger with
    `std::pmr::get_default_resource()` in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*. In every case, my strongly recommended remedy is the same--*Don't
    use global variables. Don't use global state.*
  prefs: []
  type: TYPE_NORMAL
- en: So, the C library has two problems--it provides no way to generate a truly uniform
    distribution of pseudo-random numbers, and it fundamentally depends on global
    variables. Let's see how the C++ standard library's `<random>` header fixed both
    of these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems with <random>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two core concepts provided by the `<random>` header--the *generator*
    and the *distribution*. A *generator* (a class modeling the `UniformRandomBitGenerator`
    concept) encapsulates the internal state of a PRNG into a C++ object, and provides
    a next output member function in the form of the function-call operator, `operator()(void)`.
    A *distribution* (a class modeling `RandomNumberDistribution`) is a kind of filter
    you can place over the output of a generator so that instead of getting uniformly
    distributed random bits, as you do from `rand()`, you get actual data values distributed
    according to a specified mathematical distribution and constrained to a specific
    range, such as `rand() % n`, but more mathematically appropriate and vastly more
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The `<random>` header contains a total of seven *generator* types and twenty
    *distribution* types. Most of them are templates taking lots of parameters. The
    majority of these generators are more historically interesting than practically
    useful, and the vast majority of these distributions are of interest only to mathematicians.
    So, in this chapter, we'll concentrate on just a few standard generators and distributions,
    each of which illustrates something interesting about the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given any *generator* object `g`, you can perform the following operations
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g()`: This scrambles the internal state of the generator and yields its next
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g.min()`: This tells you the smallest possible output of `g()` (typically
    `0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g.max()`: This tells you the largest possible output of `g()`. That is, the
    range of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: possible outputs of `g()` is `g.min()` to `g.max()` inclusive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`g.discard(n)`: This effectively makes `n` calls to `g()` and discards the'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: results. In a good library implementation, you'll pay for scrambling the generator's
    internal state `n` times, but save any cost associated with computing the next
    outputs from the state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Truly random bits with std::random_device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::random_device` is a *generator*. Its interface is incredibly simple;
    it's not even a class template, just a plain old class. Once you've constructed
    an instance of `std::random_device` using its default constructor, you can use
    its overloaded call operator to fetch values of type `unsigned int` that are uniformly
    distributed in the closed `[rd.min(), rd.max()]` range.
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat--`std::random_device` doesn''t fully model the `UniformRandomBitGenerator`
    concept. Most importantly, it is neither copyable nor moveable. This isn''t much
    of a problem in practice, because you generally don''t keep a *truly* random generator
    around for very long. Instead, you''ll use a very short-lived instance of `std::random_device`
    to generate a *seed* for a long-lived pseudo-random generator of some other type,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at the only pseudo-random generator you'll ever need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random bits with std::mt19937
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only pseudo-random generator you'll ever need to know is called the *Mersenne
    Twister* algorithm. This algorithm has been known since 1997, and high-quality
    implementations in any programming language are easy to find. Technically speaking,
    the Mersenne Twister algorithm defines a whole family of related PRNGs--it's the
    algorithmic equivalent of a C++ template--but the most commonly used member of
    the family is known as **MT19937**. That string of digits might look like a timestamp,
    but it's not; it's the size in bits of the Twister's internal state. Because the
    Mersenne Twister's next output function scrambles its state so perfectly that
    it will eventually reach every possible state (but one) before looping back around
    to the beginning--the *period* of the MT19937 generator is 2^(19937)-1\. Compare
    this to our `SimplePRNG` from the beginning of this chapter, which has an internal
    state of only 32 bits and a period of 2^(31). (Our `SimplePRNG` generator has
    2^(32) possible internal states, but only half of them are reached before it loops
    around again. For example, `state=3` is not reachable from the initial `state=1`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough theory. Let''s see the Mersenne Twister in action! The C++ class template
    corresponding to the Mersenne Twister *algorithm template* is `std::mersenne_twister_engine<...>`,
    but you won''t use it directly; you''ll use the convenience typedef `std::mt19937`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor for `std::mt19937` sets its internal state to a well-known
    standard value. This ensures that the output sequence you get from a default-constructed
    `mt19937` object will be identical across all platforms--as opposed to `rand()`,
    which tends to give different output sequences on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a different output sequence, you need to provide a *seed* to the constructor
    of `std::mt19937`. There are two ways to do this in C++17--the tedious way and
    the simple way. The tedious way is to construct a truly random 19937-bit seed
    and copy it into the `std::mt19937` object via a *seed sequence*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `SeedSeq` type can be either `std::seed_seq` (a glorified `std::vector`;
    it uses heap allocation) or a properly handwritten "seed sequence" class, such
    as the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is quite a bit of code to write just to construct a single
    PRNG object! (I told you, this was the *tedious* way.) The simple way, and the
    way you''ll see being used in practice, is to seed MT19937 with a single, truly
    random *32-bit integer*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Beware! 32 is a much, much smaller number than 19937! This simple method of
    seeding is capable of producing only four billion different output sequences,
    *ever*; this means that if you run your program over and over with random seeds,
    you can expect to see some repetitions after only a few hundred thousand runs.
    (This is an application of the famous *Birthday Paradox*.) However, if this level
    of predictability is important to you, you should probably also be aware that
    the Mersenne Twister is *not cryptographically secure*. This means that even if
    you initialize it with a truly random 19937-bit seed sequence, a malicious attacker
    can reverse-engineer all 19937 bits of your original seed and predict every subsequent
    output with perfect accuracy after seeing only a few hundred terms of the output
    sequence. If you need a **cryptographically secure pseudo-random number generator**
    (**CSPRNG**), you should be using something like AES-CTR or ISAAC, neither of
    which is provided by the C++ standard library. You should still wrap your CSPRNG
    implementation in a class modeling `UniformRandomBitGenerator` so that it can
    be used with standard algorithms, which we'll get to at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering generator outputs with adaptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've mentioned that the raw output of a *generator* is usually filtered through
    a single *distribution* in order to convert the generator's raw bits into usable
    data values. Interestingly, it is also possible to send a generator's output through
    a *generator adaptor*, which can reformat the raw bits in various, perhaps useful
    ways. The standard library provides three adaptors--`std::discard_block_engine`,
    `std::shuffle_order_engine`, and `std::independent_bits_engine`. These adaptor
    types work just like the *container adaptors* (such as `std::stack`) we discussed
    in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container
    Zoo--*they provide a certain interface but delegate most of their implementation
    details to some other class.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of `std::discard_block_engine<Gen, p, r>` keeps an *underlying
    generator* of type `Gen`, and delegates all its operations to that underlying
    generator, except that `discard_block_engine::operator()` will return only the
    first `r` of every `p` outputs from the underlying generator. For example, consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that a reference to the underlying generator can be retrieved via `g2.base()`.
    In the preceding example, `g1` is initialized as a copy of `g2.base()`; this explains
    how calling `g1()` doesn't affect the state of `g2`, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `std::shuffle_order_engine<Gen, k>` keeps a buffer of the last
    *k* outputs from its underlying generator, and an additional integer `Y`. Each
    call to
  prefs: []
  type: TYPE_NORMAL
- en: '`shuffle_order_engine::operator()` sets `Y = buffer[Y % k]`, then sets `buffer[Y]
    = base()()`. (The formula to compute the buffer index from `Y` is actually more
    complicated than a simple modulus, but it basically has the same effect.) Notably,
    `std::shuffle_order_engine` does *not* use `std::uniform_int_distribution` to
    map `Y` onto the `[0, k)` range. This doesn''t affect the *randomness* of the
    generator''s output--if the underlying generator is already pseudo-random, shuffling
    its outputs a little bit won''t make them any more or less random, no matter what
    algorithm we use to do the shuffling. Therefore, the algorithm used by `shuffle_order_engine`
    was picked specifically for its historical interest--it is a building block for
    a classic algorithm described in Donald Knuth''s *The Art of Computer Programming*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An instance of `std::independent_bits_engine<Gen, w, T>` keeps no state other
    than its underlying generator of type `Gen`. The `independent_bits_engine::operator()`
    function calls `base()()` just enough times to compute at least `w` random bits;
    then, it pastes together exactly `w` of those bits (via an algorithm of more historical
    than practical interest) and serves them up as an unsigned integer of type `T`.
    (It is an error if `T` is not an unsigned integer type, or if `T` has fewer than
    `w` bits.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `independent_bits_engine` pasting together bits from
    multiple calls to `base()()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example of using `independent_bits_engine` to chop off all but
    the least significant digit from the output of `mt19937` (creating a *coin flipper*
    generator), and then, pasting together 32 of this generator''s outputs to build
    back up to a 32-bit generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `independent_bits_engine` does *not* perform any complicated operation
    on the bits of its underlying generator; in particular, it assumes that its underlying
    generator has no bias. If the `WeightedCoin` generator has a bias toward even
    numbers. You'll see that bias show up in the output of `independent_bits_engine<WeightedCoin,
    w, T>` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Despite our spending several pages talking about these generators, remember
    that there is no reason to use any of these obscure classes in your own code!
    If you need a PRNG, use `std::mt19937`; if you need a cryptographically secure
    PRNG, use something like AES-CTR, or ISAAC; and, if you need a relatively small
    number of true random bits, to seed your PRNG; use `std::random_device`. These
    are the only generators that you will ever use in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen how to generate random bits on demand, let's look at how
    to convert those random bits to numeric values matching a particular *distribution*.
    This two-step process--generate raw bits, and then format them into data values--is
    very similar to the two-step process of buffering and parsing we covered in [Chapter
    9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d), *Iostreams*. First,
    get the raw bits and bytes, then perform some kind of operation to convert those
    bits and bytes into typed data values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given any distribution object `dist`, you can perform the following operations
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dist(g)`: This yields the next output according to the appropriate mathematical
    distribution. It may require several calls to `g()`, or none at all, depending
    on the internal state of the `dist` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dist.reset()`: This clears the internal state of the `dist` object, if any.
    You''ll never need to use this member function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dist.min()` and `dist.max()`: These tell you the smallest and largest possible
    outputs of `dist(g)` for any random bit generator `g`. Generally, these values
    are either self-evident or meaningless; for example, `std::normal_distribution<float>().max()`
    is `INFINITY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see a few distribution types in action.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling dice with uniform_int_distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::uniform_int_distribution` method is the simplest distribution type
    in the standard library. It performs the same operation we tried to perform with
    `randint0` earlier in this chapter--map a random unsigned integer into a given
    range--, but it does it without any bias. The simplest implementation of `uniform_int_distribution`
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The actual standard library implementation has to do something to get rid of
    that `assert`. Typically, they'll use something like `independent_bits_engine`
    to generate exactly `ceil(log2(range))` random bits at a time, minimizing the
    number of times the `while` loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'As implied in the preceding example, `uniform_int_distribution` is stateless
    (although this is not *technically* guaranteed), and so the most common way to
    use it is to create a new distribution object every time you generate a number.
    So, we can implement our `randint0` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now will probably be a good time to remark on an oddity of the `<random>` facilities.
    As a general rule, any time you supply an *integral numeric range* to one of these
    functions or constructors, it is treated as a *closed* range. This is in stark
    contrast to how ranges usually work in C and C++; we even saw in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, how deviating from the *half-open range* rule
    was usually the sign of buggy code. However, in the case of C++'s random-number
    facilities, there is a new rule--*the closed range* rule. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the key advantage of the half-open range is that it can easily represent
    an *empty range*. On the other hand, half-open ranges cannot represent a *completely
    full range*, that is, a range that covers the entire domain. (We saw this difficulty
    pop up in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, in the implementation of `std::list<T>::end()`.) Suppose
    we want to express the idea of a uniform distribution over the entire range of
    `long long`. We can't express that as the half-open range `[LLONG_MIN, LLONG_MAX+1)`
    because `LLONG_MAX+1` will overflow. However, we *can* express it as the closed
    range `[LLONG_MIN, LLONG_MAX]`--and so, that's what the `<random>` library's functions
    and classes (such as `uniform_int_distribution`) do. The `uniform_int_distribution<int>(0,6)`
    method is a distribution over the seven-number range `[0,6]`, and `uniform_int_distribution<int>(42,42)`
    is a perfectly valid distribution that invariably returns `42`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `std::uniform_real_distribution<double>(a, b)` *does* operate
    on a half-open range! The `std::uniform_real_distribution<double>(0, 1)` method
    yields values of type `double`, uniformly distributed in the `[0, 1)` range. In
    the floating-point domain, there's no problem with overflow--a half-open range
    of `[0, INFINITY)` is actually expressible, although, of course, there's no such
    thing as a *uniform distribution* over an infinite range. Floating-point also
    makes it difficult to say the difference between a half-open range and a closed
    range; for example, `std::uniform_real_distribution<float>(0, 1)(g)` can legitimately
    return `float(1.0)` any time it generates a random real number close enough to
    1 that it rounds up about one in every 2^(25) results. (At press time, libc++
    behaves as described here. GNU's libstdc++ applies a patch that makes close-to-1
    real numbers round down instead of up so that the floating-point number just below
    1.0 appears marginally more often than chance would predict.)
  prefs: []
  type: TYPE_NORMAL
- en: Generating populations with normal_distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most useful example of a real-valued distribution is probably the *normal
    distribution*, also known as the **bell curve**. In the real world, normal distributions
    show up all over the place, particularly in the distribution of physical traits
    in a population. For example, a histogram of adult human heights will tend to
    look like a normal distribution--lots of individuals clustered around the average
    height, and others tailing off to each side. Flip this around, and it means that
    you might want to use a normal distribution to assign heights, weights, and so
    on, to the simulated individuals in a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::normal_distribution<double>(m, sd)` method constructs an instance
    of `normal_distribution<double>` with mean (`m`) and standard deviation (`sd`).
    (These parameters default to `m=0` and `sd=1` if you don''t provide them, so watch
    out for typos!) Here''s an example of using `normal_distribution` to create a
    "population" of 10,000 normally distributed samples, and then verifying their
    distribution mathematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the other distributions we've seen in this chapter (or will see), `std::normal_distribution`
    is stateful. While it is okay to construct a new instance of `std::normal_distribution`
    for each value you generate, if you do that, you're effectively halving the efficiency
    of your program. This is because the most popular algorithm to generate normally
    distributed values produces two independent values per step; `std::normal_distribution`
    can't give you both values at once, so it hangs onto one of them in a member variable
    to give it to you the next time you ask. The `dist.reset()` member function can
    be used to clear out this saved state, not that you'd ever want to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Making weighted choices with discrete_distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::discrete_distribution<int>(wbegin, wend)` method constructs a discrete,
    or weighted, distribution over the integers in the half-open `[0, wend - wbegin)`
    range. This is easiest to explain with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::discrete_distribution<int>` method makes its own internal copy of
    the weights you pass in, in a private member variable of type `std::vector<double>`
    (and as usual for `<random>`, it''s not allocator-aware). You can get a copy of
    this vector by calling `dist.probabilities()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You probably don''t want to use `discrete_distribution` directly in your own
    code; at best, you''ll want to encapsulate its use in something like the preceding
    `weighted_choice` function. However, if you need to avoid heap allocation or floating-point
    math, it might pay to use a simpler, non-allocating function, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there''s a reason the *default* library implementation of `discrete_distribution`
    does all its math as floating-point: it saves you from having to worry about integer
    overflow. The preceding code will have bad behavior if `sum` overflows the range
    of `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: Shuffling cards with std::shuffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's close this chapter by looking at `std::shuffle(a,b,g)`, the one standard
    algorithm that takes a random number generator as input. It's a *permutative algorithm*
    by the definitions of [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator Pair-Algorithms*--it takes a range of elements `[a,b)` and shuffles
    them around, preserving their values but not their positions.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::shuffle(a,b,g)` method was introduced in C++11 to replace the older
    `std::random_shuffle(a,b)` algorithm. That older algorithm "randomly" shuffled
    the `[a,b)` range, but without specifying the source of the randomness; in practice,
    this meant that it would use the global C library's `rand()` with all its attendant
    problems. As soon as C++11 introduced a standardized way of talking about random
    number generators with `<random>`, it was time to get rid of the old `rand()`
    based `random_shuffle`; and, as of C++17, `std::random_shuffle(a,b)` is no longer
    part of the C++ standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use C++11''s `std::shuffle` to shuffle a deck of playing
    cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Recall that every *generator* in `<random>` is completely specified so that,
    for example, an instance of `std::mt19937` seeded with a fixed value will produce
    exactly the same outputs on every platform. The same is *not* true of *distributions*
    such as `uniform_real_distribution`, nor is it true of the `shuffle` algorithm.
    Switching from libc++ to libstdc++, or even just upgrading your compiler, may
    cause changes in the behavior of your `std::shuffle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Whatever generator and seeding method you use, you'll be able to plug it right
    into `std::shuffle`. This is the benefit of the standard library's composable
    approach to random number generation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides two random-number-related concepts--*generator*
    and *distribution*. Generators are stateful, must be seeded, and produce unsigned
    integer outputs (raw bits) via `operator()(void)`. The two important generator
    types are `std::random_device`, which produces truly random bits, and `std::mt19937`,
    which produces pseudo-random bits.
  prefs: []
  type: TYPE_NORMAL
- en: Distributions are *usually* stateless, and produce numeric data values via `operator()(Gen&)`.
    The most important distribution type for most programmers will be `std::uniform_int_distribution<int>(a,b)`,
    which produces integers in the closed range `[a,b]`. The standard library provides
    other distributions, such as `std::uniform_real_distribution`, `std::normal_distribution`,
    and `std::discrete_distribution`, as well as many arcane distributions useful
    to mathematicians and statisticians.
  prefs: []
  type: TYPE_NORMAL
- en: The one standard algorithm that uses randomness is `std::shuffle`, which replaces
    the old-style `std::random_shuffle`. Don't use `random_shuffle` in the new code.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that `std::mt19937` has exactly the same behavior on every platform,
    but the same is not true of any *distribution* type, nor of `std::shuffle`.
  prefs: []
  type: TYPE_NORMAL
