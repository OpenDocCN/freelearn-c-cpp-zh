- en: Random Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数
- en: In the previous chapter, you learned about regular expressions, a feature that
    has been part of the C++ standard library since C++11, but which is still little-known
    by many programmers. You saw that regular expressions are useful in two situations
    at the opposite ends of the C++ spectrum--in complex programs requiring bulletproof
    parsing of complicated input formats, and in trivial scripts where the important
    things are readability and speed of development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了正则表达式，这是一个自C++11以来一直是C++标准库的一部分的功能，但许多程序员仍然不太了解。你看到正则表达式在C++光谱的两端都很有用——在需要对复杂输入格式进行坚如磐石解析的复杂程序中，以及在需要可读性和开发速度的简单脚本中。
- en: Another library feature that lands squarely in both of these categories is *random
    number generation*. Many scripting programs require a little bit of randomness
    here and there, but C++ programmers have been taught for decades that the classic
    libc `rand()` function is passé. At the other end of the spectrum, `rand()` is
    spectacularly inappropriate, both for cryptography and for complicated numerical
    simulations. The C++11 `<random>` library, however, manages to hit all three of
    these targets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个位于这两个类别中的库特性是*随机数生成*。许多脚本程序需要一点随机性，但几十年来，C++程序员一直被告知经典的libc `rand()` 函数已经过时。在光谱的另一端，`rand()`
    对于密码学和复杂的数值模拟来说都是极其不合适的。然而，C++11 `<random>` 库却成功地实现了这三个目标。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The difference between truly random and pseudo-random number sequences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正随机数序列与伪随机数序列之间的区别
- en: The difference between a *generator* of random bits and a *distribution* that
    produces data values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机比特生成器与产生数据值的分布之间的区别
- en: Three strategies to seed a random number generator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为随机数生成器设置种子的三种策略
- en: Several standard library generators and distributions, and their use cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种标准库生成器和分布，以及它们的用例
- en: How to shuffle a deck of cards in C++17
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C++17中洗牌一副牌
- en: Random numbers versus pseudo-random numbers
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数与伪随机数
- en: 'When talking about random numbers in the context of computer programming, we
    must be careful to distinguish between truly random numbers, which come from a
    physically non-deterministic source, and *pseudo-random* numbers, which come from
    an algorithm that deterministically produces a stream of "random-looking" numbers.
    Such an algorithm is called a **pseudo-random number generator** (**PRNG**). Every
    PRNG conceptually works the same way--it has some internal *state*, and it has
    some way for the user to ask for the *next output*. Every time we ask for the
    next output, the PRNG scrambles its internal state according to some deterministic
    algorithm and returns some piece of that state. Here''s an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程的语境中谈论随机数时，我们必须小心地区分真正随机的数，这些数来自物理上非确定性的来源，以及*伪随机*数，这些数来自一个算法，该算法以确定性的方式产生一系列“看起来随机”的数。这样的算法被称为**伪随机数生成器**（**PRNG**）。每个PRNG在概念上都以相同的方式工作——它有一些内部*状态*，并且有一些方式让用户请求*下一个输出*。每次我们请求下一个输出时，PRNG都会根据某种确定性的算法打乱其内部状态，并返回该状态的一部分。以下是一个例子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `SimplePRNG` class implements a *linear congruential generator*, which
    is likely very similar to your standard library's implementation of `rand()`.
    Notice that `SimplePRNG::operator()` produces integers in the `[0, 32767]` 15-bit
    range, but its internal `state` has a 32-bit range. This pattern is true in real-world
    PRNGs as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `SimplePRNG` 类实现了一个*线性同余生成器*，这可能与你的标准库中 `rand()` 的实现非常相似。请注意，`SimplePRNG::operator()`
    产生 `[0, 32767]` 15位范围内的整数，但其内部 `state` 有32位范围。这种模式在现实世界的PRNG中也是成立的。
- en: For example, the standard Mersenne Twister algorithm keeps almost 20 kilobytes
    of state! Keeping so much internal state means that there are lots of bits to
    scramble, and only a small fraction of the PRNG's internal state leaks out at
    each generation. This makes it difficult for a human (or a computer) to predict
    the PRNG's next output, given only a few of the preceding outputs. The difficulty
    of predicting its outputs leads us to call this thing a *pseudo-random* number
    generator. If its output was full of obvious patterns and easy to predict, we'd
    probably call it a *non-random* number generator!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，标准的梅森旋转算法几乎保持20千字节的状态！保持如此多的内部状态意味着有很多位可以混淆，并且每次生成时只有PRNG内部状态的一小部分泄露出来。这使得人类（或计算机）在只有少量先前输出的情况下难以预测PRNG的下一个输出。预测其输出的难度使我们称这个为*伪随机*数生成器。如果其输出充满了明显的模式和易于预测，我们可能会称其为*非随机*数生成器！
- en: Despite its pseudo-random qualities, a PRNG's behavior is always perfectly *deterministic*;
    it follows exactly the algorithm it was coded to follow. If we take a program
    that uses a PRNG and run it several times in a row, we expect to get the exact
    same sequence of pseudo-random numbers each time. Its strict determinism leads
    us to call this thing a *pseudo*-random number generator.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具有伪随机的特性，PRNG的行为始终是完美的*确定性*；它严格遵循其编码的算法。如果我们运行一个使用PRNG的程序并连续运行几次，我们期望每次都能得到完全相同的伪随机数序列。它的严格确定性使我们称这个为*伪*-随机数生成器。
- en: Another aspect of *pseudo-random* number generators is that two generators running
    the exact same algorithm, but with tiny variations in their initial states, will
    rapidly magnify these variations, *diverge* from each other, and produce completely
    different-looking output sequences--just as two drops of water placed in slightly
    different spots on the back of your hand will run off in completely divergent
    directions. This means that if we want a different sequence of pseudo-random numbers
    each time we run our program, all we have to do is make sure that we use a different
    *initial state* for our PRNG. Setting a PRNG's initial state is called *seeding*
    the PRNG.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假随机数生成器的一个方面是，两个运行相同算法但初始状态有微小差异的生成器会迅速放大这些差异，*发散*彼此，并产生看起来完全不同的输出序列——就像两滴水被放在你手背上的不同位置，会向完全不同的方向流去。这意味着如果我们想在每次运行程序时得到不同的伪随机数序列，我们只需确保我们为我们的PRNG使用不同的*初始状态*。设置PRNG的初始状态被称为*播种*PRNG。
- en: 'We have at least three strategies for seeding our PRNG:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少有三种为PRNG播种的策略：
- en: Using a seed supplied *from outside--*from the caller or end user. This is the
    most appropriate for anything that needs reproducibility, such as Monte Carlo
    simulations or anything that you'll unit test.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从外部提供的种子*——*来自调用者或最终用户。这对于需要可重复性的任何事物都最合适，例如蒙特卡洛模拟或任何需要进行单元测试的事物。
- en: Using a predictable but variable seed, such as the current timestamp. Prior
    to C++11, this was the most common strategy, because the C standard library provides
    a portable and convenient `time` function, but does not provide any portable source
    of truly random bits. Seeding based on something as predictable as `time` is not
    suitable for anything security-related. As of C++11, you shouldn't ever use this
    strategy.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可预测但可变的种子，例如当前时间戳。在C++11之前，这是最常见的策略，因为C标准库提供了一个便携且方便的`time`函数，但它不提供任何真正的随机位源。基于像`time`这样可预测的东西进行播种不适合任何与安全相关的事物。从C++11开始，你不应该再使用这种策略。
- en: Using a *truly random* seed obtained directly from some platform-specific source
    of "truly random" bits.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从某些特定平台来源直接获得的*真正随机*种子。
- en: '*Truly random* bits are collected by the operating system based on all sorts
    of random events; a classic approach is for every system call to collect the low-order
    bits of the hardware cycle counter and XOR them into the operating system''s *entropy
    pool*. A PRNG deep inside the kernel is periodically reseeded with bits from the
    entropy pool; the output sequence of that PRNG is exposed to application programmers.
    On Linux, the raw entropy pool is exposed as `/dev/random` and the PRNG''s output
    sequence is exposed as `/dev/urandom`. Fortunately, you''ll never need to deal
    with either of those devices directly; the C++ standard library has you covered.
    Read on.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正随机*的位是通过操作系统基于各种随机事件收集的；一个经典的方法是对于每个系统调用，收集硬件周期计数器的低阶位，并将它们通过XOR操作合并到操作系统的*熵池*中。内核内部的伪随机数生成器（PRNG）会定期用熵池中的位重新初始化；该PRNG的输出序列被暴露给应用程序开发者。在Linux上，原始的熵池作为`/dev/random`暴露，PRNG的输出序列作为`/dev/urandom`暴露。幸运的是，你永远不需要直接处理这些设备；C++标准库已经为你解决了这个问题。请继续阅读。'
- en: The problem with rand()
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`rand()`的问题'
- en: The old school C way of generating *random* numbers is to call `rand()`. The
    `rand()` function, which is still part of C++, takes no arguments and produces
    a single, uniformly distributed integer in the `[0, RAND_MAX]` range. The internal
    state can be *seeded* by calling the library function, `srand(seed_value)`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的C语言生成*随机*数的方法是调用`rand()`函数。这个`rand()`函数仍然是C++的一部分，它不接受任何参数，并在`[0, RAND_MAX]`范围内产生一个单一、均匀分布的整数。内部状态可以通过调用库函数`void
    srand(unsigned int seed_value)`来*初始化*。
- en: 'The classic code to generate a *random* number in the `[0, x)` range hasn''t
    changed since the 1980s, shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自1980年代以来，生成`[0, x)`范围内的*随机*数的经典代码没有变化，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, this code has several problems. The first and most obvious problem
    is that it doesn't generate all `x` outputs with equal likelihood. Suppose, for
    the sake of argument, `rand()` returns a uniformly distributed value in the `[0,
    32767]` range, then `randint0(10)` will return each value in the `[0, 7]` range
    one-3276th more often than it returns either `8` or `9`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码有几个问题。第一个也是最明显的问题是它没有以相等的可能性生成所有的`x`输出。假设为了论证，`rand()`返回一个在`[0, 32767]`范围内的均匀分布值，那么`randint0(10)`将比返回`8`或`9`更频繁地返回`[0,
    7]`范围内的每个值，频率是1/3276。
- en: The second problem is that `rand()` accesses global state; the same random number
    generator is shared by every thread in your C++ program. This isn't a thread-safety
    concern--`rand()` has been guaranteed to be thread-safe since C++11\. However,
    it is a problem for performance (because each call to `rand()` must take a global
    mutex lock), and it is a problem for reproducibility (because if you use `rand()`
    from multiple threads concurrently, different runs of the program may yield different
    answers).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是`rand()`访问全局状态；在C++程序中的每个线程都共享同一个随机数生成器。这不是线程安全的问题--`rand()`自C++11以来被保证是线程安全的。然而，这是一个性能问题（因为每次调用`rand()`都必须获取全局互斥锁），这也是一个可重复性问题（因为如果你从多个线程并发使用`rand()`，不同的程序运行可能会得到不同的结果）。
- en: 'A third and related problem with the global-statefulness of `rand()` is that
    any function anywhere in the program can modify that state just by calling `rand()`.
    This makes it effectively impossible to use `rand()` in a unit-test-driven environment.
    Consider the following code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand()`函数的第三个问题，也是与其全局状态相关的问题，是任何程序中的函数都可以通过调用`rand()`来修改该状态。这使得在单元测试驱动的环境中使用`rand()`变得实际上是不可能的。考虑以下代码片段：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Clearly, the unit test, `test_heads`, will break as soon as we start parallelizing
    our unit tests (because a call to `rand()` from some other thread will interfere
    with the delicate workings of this test). However, more subtly, it can also break
    simply because someone changed the implementation of `DEBUG_LOG` to add or remove
    a call to `rand()`! This kind of *spooky action at a distance* is a problem any
    time your architecture depends on global variables. We saw a similar danger with
    `std::pmr::get_default_resource()` in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*. In every case, my strongly recommended remedy is the same--*Don't
    use global variables. Don't use global state.*
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，单元测试 `test_heads` 将在开始并行化单元测试时立即中断（因为来自其他线程对 `rand()` 的调用将干扰这个测试的微妙工作）。然而，更微妙的是，它也可能因为有人更改了
    `DEBUG_LOG` 的实现，添加或删除对 `rand()` 的调用而中断！这种 *遥远的神秘作用* 是任何依赖于全局变量的架构的问题。我们在第 8 章
    [分配器](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d)中看到了类似的危险。在每种情况下，我强烈推荐的治疗方法都是相同的--*不要使用全局变量。不要使用全局状态*。
- en: So, the C library has two problems--it provides no way to generate a truly uniform
    distribution of pseudo-random numbers, and it fundamentally depends on global
    variables. Let's see how the C++ standard library's `<random>` header fixed both
    of these problems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C 库有两个问题--它没有提供生成真正均匀分布的伪随机数的方法，并且它从根本上依赖于全局变量。让我们看看 C++ 标准库的 `<random>`
    头文件是如何解决这两个问题的。
- en: Solving problems with <random>
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `<random>` 解决问题
- en: There are two core concepts provided by the `<random>` header--the *generator*
    and the *distribution*. A *generator* (a class modeling the `UniformRandomBitGenerator`
    concept) encapsulates the internal state of a PRNG into a C++ object, and provides
    a next output member function in the form of the function-call operator, `operator()(void)`.
    A *distribution* (a class modeling `RandomNumberDistribution`) is a kind of filter
    you can place over the output of a generator so that instead of getting uniformly
    distributed random bits, as you do from `rand()`, you get actual data values distributed
    according to a specified mathematical distribution and constrained to a specific
    range, such as `rand() % n`, but more mathematically appropriate and vastly more
    flexible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`<random>` 头文件提供了两个核心概念--*生成器* 和 *分布*。一个 *生成器*（一个模拟 `UniformRandomBitGenerator`
    概念的类）将 PRNG 的内部状态封装到一个 C++ 对象中，并提供了一个以函数调用操作符 `operator()(void)` 形式的下一个输出成员函数。一个
    *分布*（一个模拟 `RandomNumberDistribution` 的类）是你可以在生成器的输出上放置的一种过滤器，这样你得到的不是像从 `rand()`
    得到的均匀分布的随机位，而是根据指定的数学分布实际数据值分布，并限制在特定范围内，如 `rand() % n`，但更数学上合适且具有更大的灵活性。'
- en: The `<random>` header contains a total of seven *generator* types and twenty
    *distribution* types. Most of them are templates taking lots of parameters. The
    majority of these generators are more historically interesting than practically
    useful, and the vast majority of these distributions are of interest only to mathematicians.
    So, in this chapter, we'll concentrate on just a few standard generators and distributions,
    each of which illustrates something interesting about the standard library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`<random>` 头文件包含总共七种 *生成器* 类型以及二十种 *分布* 类型。其中大部分是模板，需要很多参数。这些生成器中大多数比实际应用更有历史意义，而大多数分布只对数学家感兴趣。因此，在本章中，我们将专注于几个标准的生成器和分布，每个都展示了标准库的一些有趣之处。'
- en: Dealing with generators
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理生成器
- en: 'Given any *generator* object `g`, you can perform the following operations
    on it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何 *生成器* 对象 `g`，你可以对其执行以下操作：
- en: '`g()`: This scrambles the internal state of the generator and yields its next
    output.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g()`: 这会打乱生成器的内部状态并产生下一个输出。'
- en: '`g.min()`: This tells you the smallest possible output of `g()` (typically
    `0`).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g.min()`: 这告诉你 `g()` 的最小可能输出（通常是 `0`）。'
- en: '`g.max()`: This tells you the largest possible output of `g()`. That is, the
    range of'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g.max()`: 这告诉你 `g()` 的最大可能输出。也就是说，`g()` 的可能输出范围是从 `g.min()` 到 `g.max()`，包括两端。'
- en: possible outputs of `g()` is `g.min()` to `g.max()` inclusive.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能的输出范围是 `g.min()` 到 `g.max()`，包括 `g.max()`。
- en: '`g.discard(n)`: This effectively makes `n` calls to `g()` and discards the'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g.discard(n)`: 这实际上是对 `g()` 进行 `n` 次调用并丢弃这些结果。'
- en: results. In a good library implementation, you'll pay for scrambling the generator's
    internal state `n` times, but save any cost associated with computing the next
    outputs from the state.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果。在一个好的库实现中，你将支付打乱生成器内部状态 `n` 次的费用，但节省与从状态计算下一个输出相关的任何成本。
- en: Truly random bits with std::random_device
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::random_device 的真正随机位
- en: The `std::random_device` is a *generator*. Its interface is incredibly simple;
    it's not even a class template, just a plain old class. Once you've constructed
    an instance of `std::random_device` using its default constructor, you can use
    its overloaded call operator to fetch values of type `unsigned int` that are uniformly
    distributed in the closed `[rd.min(), rd.max()]` range.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::random_device` 是一个 *生成器*。它的接口极其简单；它甚至不是一个类模板，而是一个普通的类。一旦你使用其默认构造函数构造了一个
    `std::random_device` 的实例，你就可以使用其重载的调用操作符来获取类型为 `unsigned int` 的值，这些值在闭区间 `[rd.min(),
    rd.max()]` 内均匀分布。'
- en: 'One caveat--`std::random_device` doesn''t fully model the `UniformRandomBitGenerator`
    concept. Most importantly, it is neither copyable nor moveable. This isn''t much
    of a problem in practice, because you generally don''t keep a *truly* random generator
    around for very long. Instead, you''ll use a very short-lived instance of `std::random_device`
    to generate a *seed* for a long-lived pseudo-random generator of some other type,
    like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的地方是，`std::random_device` 并不完全符合 `UniformRandomBitGenerator` 的概念。最重要的是，它既不可复制也不可移动。在实践中，这并不是一个大问题，因为你通常不会长时间保留一个
    *真正* 随机的生成器。相反，你会使用一个短暂的 `std::random_device` 实例来为某种类型的长期伪随机生成器生成一个 *种子*，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now let's look at the only pseudo-random generator you'll ever need to know.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看你唯一需要了解的伪随机生成器。
- en: Pseudo-random bits with std::mt19937
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::mt19937 的伪随机位
- en: The only pseudo-random generator you'll ever need to know is called the *Mersenne
    Twister* algorithm. This algorithm has been known since 1997, and high-quality
    implementations in any programming language are easy to find. Technically speaking,
    the Mersenne Twister algorithm defines a whole family of related PRNGs--it's the
    algorithmic equivalent of a C++ template--but the most commonly used member of
    the family is known as **MT19937**. That string of digits might look like a timestamp,
    but it's not; it's the size in bits of the Twister's internal state. Because the
    Mersenne Twister's next output function scrambles its state so perfectly that
    it will eventually reach every possible state (but one) before looping back around
    to the beginning--the *period* of the MT19937 generator is 2^(19937)-1\. Compare
    this to our `SimplePRNG` from the beginning of this chapter, which has an internal
    state of only 32 bits and a period of 2^(31). (Our `SimplePRNG` generator has
    2^(32) possible internal states, but only half of them are reached before it loops
    around again. For example, `state=3` is not reachable from the initial `state=1`.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要了解的伪随机生成器被称为 *梅森旋转器* 算法。这个算法自1997年以来就为人所知，在任何编程语言中的高质量实现都很容易找到。从技术上讲，梅森旋转器算法定义了一个相关PRNG的整个家族--它是C++模板的算法等价物--但这个家族中最常用的成员被称为
    **MT19937**。这一串数字可能看起来像时间戳，但并非如此；它是旋转器内部状态的大小（以位为单位）。因为梅森旋转器的下一个输出函数完美地打乱了其状态，它最终会达到（除了一个之外）所有可能的状态，然后再回到开始--MT19937生成器的
    *周期* 是 2^(19937)-1。与此相比，我们本章开头的 `SimplePRNG` 只有一个32位的内部状态和一个周期为 2^(31)。（我们的 `SimplePRNG`
    生成器有 2^(32) 种可能的内部状态，但在它再次循环之前，只有一半的状态被达到。例如，`state=3` 从初始的 `state=1` 是无法到达的。）
- en: 'Enough theory. Let''s see the Mersenne Twister in action! The C++ class template
    corresponding to the Mersenne Twister *algorithm template* is `std::mersenne_twister_engine<...>`,
    but you won''t use it directly; you''ll use the convenience typedef `std::mt19937`,
    as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够。让我们看看梅森旋转器在实际中的应用！对应于梅森旋转器 *算法模板* 的C++类模板是 `std::mersenne_twister_engine<...>`，但你不会直接使用它；你将使用便利的typedef
    `std::mt19937`，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The default constructor for `std::mt19937` sets its internal state to a well-known
    standard value. This ensures that the output sequence you get from a default-constructed
    `mt19937` object will be identical across all platforms--as opposed to `rand()`,
    which tends to give different output sequences on different platforms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mt19937` 的默认构造函数将其内部状态设置为众所周知的标准值。这确保了从默认构造的 `mt19937` 对象获得的输出序列在所有平台上都是相同的--与
    `rand()` 相比，`rand()` 在不同平台上往往给出不同的输出序列。'
- en: 'To get a different output sequence, you need to provide a *seed* to the constructor
    of `std::mt19937`. There are two ways to do this in C++17--the tedious way and
    the simple way. The tedious way is to construct a truly random 19937-bit seed
    and copy it into the `std::mt19937` object via a *seed sequence*, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得不同的输出序列，你需要向`std::mt19937`的构造函数提供一个**种子**。 在C++17中有两种方法--繁琐的方法和简单的方法。 繁琐的方法是构建一个真正的19937位种子，并将其通过一个**种子序列**复制到`std::mt19937`对象中，如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the `SeedSeq` type can be either `std::seed_seq` (a glorified `std::vector`;
    it uses heap allocation) or a properly handwritten "seed sequence" class, such
    as the following piece of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SeedSeq`类型可以是`std::seed_seq`（一个被美化的`std::vector`；它使用堆分配）或者一个正确编写的“种子序列”类，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course, this is quite a bit of code to write just to construct a single
    PRNG object! (I told you, this was the *tedious* way.) The simple way, and the
    way you''ll see being used in practice, is to seed MT19937 with a single, truly
    random *32-bit integer*, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅为了构建一个单一的PRNG对象就需要写这么多代码！ (我告诉过你，这是**繁琐**的方法。) 简单的方法，也是你将在实践中看到的方法，是将MT19937用单个真正的**32位整数**进行初始化，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Beware! 32 is a much, much smaller number than 19937! This simple method of
    seeding is capable of producing only four billion different output sequences,
    *ever*; this means that if you run your program over and over with random seeds,
    you can expect to see some repetitions after only a few hundred thousand runs.
    (This is an application of the famous *Birthday Paradox*.) However, if this level
    of predictability is important to you, you should probably also be aware that
    the Mersenne Twister is *not cryptographically secure*. This means that even if
    you initialize it with a truly random 19937-bit seed sequence, a malicious attacker
    can reverse-engineer all 19937 bits of your original seed and predict every subsequent
    output with perfect accuracy after seeing only a few hundred terms of the output
    sequence. If you need a **cryptographically secure pseudo-random number generator**
    (**CSPRNG**), you should be using something like AES-CTR or ISAAC, neither of
    which is provided by the C++ standard library. You should still wrap your CSPRNG
    implementation in a class modeling `UniformRandomBitGenerator` so that it can
    be used with standard algorithms, which we'll get to at the end of this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕！32比19937小得多！这种简单的初始化方法只能产生40亿种不同的输出序列，**永远**；这意味着如果你用随机种子反复运行你的程序，你可以在运行了几十万次之后看到一些重复。
    (这是著名的**生日悖论**的应用。) 然而，如果你认为这种可预测性很重要，你可能还应该知道，梅森旋转器**不是密码学安全的**。 这意味着即使你用真正的19937位种子序列初始化它，恶意攻击者也可以逆向工程你的原始种子中的所有19937位，并在只看到输出序列的几百项之后，完美准确地预测后续的每个输出。
    如果你需要一个**密码学安全的伪随机数生成器**（**CSPRNG**），你应该使用类似AES-CTR或ISAAC的东西，这两种东西都不是C++标准库提供的。
    你仍然应该将你的CSPRNG实现包装在一个模拟`UniformRandomBitGenerator`的类中，这样它就可以与标准算法一起使用，我们将在本章末尾讨论这一点。
- en: Filtering generator outputs with adaptors
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用适配器过滤生成器输出
- en: We've mentioned that the raw output of a *generator* is usually filtered through
    a single *distribution* in order to convert the generator's raw bits into usable
    data values. Interestingly, it is also possible to send a generator's output through
    a *generator adaptor*, which can reformat the raw bits in various, perhaps useful
    ways. The standard library provides three adaptors--`std::discard_block_engine`,
    `std::shuffle_order_engine`, and `std::independent_bits_engine`. These adaptor
    types work just like the *container adaptors* (such as `std::stack`) we discussed
    in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container
    Zoo--*they provide a certain interface but delegate most of their implementation
    details to some other class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，生成器的原始输出通常需要通过单个**分布**进行过滤，以便将生成器的原始比特转换为可用的数据值。有趣的是，也可以将生成器的输出通过一个**生成器适配器**发送，该适配器可以以各种可能有用的方式重新格式化原始比特。标准库提供了三种适配器--`std::discard_block_engine`、`std::shuffle_order_engine`和`std::independent_bits_engine`。这些适配器类型的工作方式与我们在[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)“容器动物园”中讨论的**容器适配器**（如`std::stack`）类似--它们提供一定的接口，但将大部分实现细节委托给其他某个类。
- en: 'An instance of `std::discard_block_engine<Gen, p, r>` keeps an *underlying
    generator* of type `Gen`, and delegates all its operations to that underlying
    generator, except that `discard_block_engine::operator()` will return only the
    first `r` of every `p` outputs from the underlying generator. For example, consider
    the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::discard_block_engine<Gen, p, r>`的一个实例保留了一个类型为`Gen`的*底层生成器*，并将所有操作委托给该底层生成器，除了`discard_block_engine::operator()`将只返回底层生成器每`p`个输出中的前`r`个。例如，考虑以下示例：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that a reference to the underlying generator can be retrieved via `g2.base()`.
    In the preceding example, `g1` is initialized as a copy of `g2.base()`; this explains
    how calling `g1()` doesn't affect the state of `g2`, and vice versa.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以通过`g2.base()`检索底层生成器的引用。在上面的示例中，`g1`被初始化为`g2.base()`的一个副本；这解释了为什么调用`g1()`不会影响`g2`的状态，反之亦然。
- en: An instance of `std::shuffle_order_engine<Gen, k>` keeps a buffer of the last
    *k* outputs from its underlying generator, and an additional integer `Y`. Each
    call to
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shuffle_order_engine<Gen, k>`的一个实例保留其底层生成器最后*k*个输出的缓冲区，以及一个额外的整数`Y`。每次调用'
- en: '`shuffle_order_engine::operator()` sets `Y = buffer[Y % k]`, then sets `buffer[Y]
    = base()()`. (The formula to compute the buffer index from `Y` is actually more
    complicated than a simple modulus, but it basically has the same effect.) Notably,
    `std::shuffle_order_engine` does *not* use `std::uniform_int_distribution` to
    map `Y` onto the `[0, k)` range. This doesn''t affect the *randomness* of the
    generator''s output--if the underlying generator is already pseudo-random, shuffling
    its outputs a little bit won''t make them any more or less random, no matter what
    algorithm we use to do the shuffling. Therefore, the algorithm used by `shuffle_order_engine`
    was picked specifically for its historical interest--it is a building block for
    a classic algorithm described in Donald Knuth''s *The Art of Computer Programming*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle_order_engine::operator()`将`Y = buffer[Y % k]`设置为`buffer[Y] = base()()`。（从`Y`计算缓冲区索引的公式实际上比简单的模运算更复杂，但它基本上有相同的效果。）值得注意的是，`std::shuffle_order_engine`并不使用`std::uniform_int_distribution`将`Y`映射到`[0,
    k)`范围。这不会影响生成器输出的*随机性*——如果底层生成器已经是伪随机的话，稍微打乱其输出并不会使它们变得更加或更少随机，无论我们使用什么算法来进行打乱。因此，`shuffle_order_engine`使用的算法是专门挑选的，因为它具有历史兴趣——它是唐纳德·克努特在《计算机程序设计艺术》中描述的经典算法的一个构建块：'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An instance of `std::independent_bits_engine<Gen, w, T>` keeps no state other
    than its underlying generator of type `Gen`. The `independent_bits_engine::operator()`
    function calls `base()()` just enough times to compute at least `w` random bits;
    then, it pastes together exactly `w` of those bits (via an algorithm of more historical
    than practical interest) and serves them up as an unsigned integer of type `T`.
    (It is an error if `T` is not an unsigned integer type, or if `T` has fewer than
    `w` bits.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::independent_bits_engine<Gen, w, T>`的一个实例除了其底层生成器类型为`Gen`之外，不保留任何状态。`independent_bits_engine::operator()`函数调用`base()()`足够多次以计算至少`w`个随机位；然后，它通过一个比实际应用更有历史意义的算法精确地拼接这些位，并将它们作为类型为`T`的无符号整数提供。
    （如果`T`不是无符号整数类型，或者`T`的位数少于`w`位，则是一个错误。）'
- en: 'Here is an example of `independent_bits_engine` pasting together bits from
    multiple calls to `base()()`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`independent_bits_engine`从多个`base()()`调用中拼接位的示例：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And here is an example of using `independent_bits_engine` to chop off all but
    the least significant digit from the output of `mt19937` (creating a *coin flipper*
    generator), and then, pasting together 32 of this generator''s outputs to build
    back up to a 32-bit generator:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`independent_bits_engine`从`mt19937`的输出中移除所有但最低有效位（创建一个*翻转生成器*）的示例，然后，将这个生成器的32个输出拼接起来，以重建一个32位生成器：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `independent_bits_engine` does *not* perform any complicated operation
    on the bits of its underlying generator; in particular, it assumes that its underlying
    generator has no bias. If the `WeightedCoin` generator has a bias toward even
    numbers. You'll see that bias show up in the output of `independent_bits_engine<WeightedCoin,
    w, T>` as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`independent_bits_engine`对其底层生成器的位不执行任何复杂的操作；特别是，它假设其底层生成器没有偏差。如果`WeightedCoin`生成器倾向于偶数。你将看到这种偏差也会在`independent_bits_engine<WeightedCoin,
    w, T>`的输出中体现出来。
- en: Despite our spending several pages talking about these generators, remember
    that there is no reason to use any of these obscure classes in your own code!
    If you need a PRNG, use `std::mt19937`; if you need a cryptographically secure
    PRNG, use something like AES-CTR, or ISAAC; and, if you need a relatively small
    number of true random bits, to seed your PRNG; use `std::random_device`. These
    are the only generators that you will ever use in practice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们花费了数页的篇幅来讨论这些生成器，但请记住，在你的代码中没有任何理由使用这些神秘的类！如果你需要一个伪随机数生成器，请使用 `std::mt19937`；如果你需要一个加密安全的伪随机数生成器，请使用类似
    AES-CTR 或 ISAAC 的东西；如果你需要相对较少的真正随机位来为你的伪随机数生成器设置种子，请使用 `std::random_device`。这些是你将在实践中唯一使用的生成器。
- en: Dealing with distributions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理分布
- en: Now that we've seen how to generate random bits on demand, let's look at how
    to convert those random bits to numeric values matching a particular *distribution*.
    This two-step process--generate raw bits, and then format them into data values--is
    very similar to the two-step process of buffering and parsing we covered in [Chapter
    9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d), *Iostreams*. First,
    get the raw bits and bytes, then perform some kind of operation to convert those
    bits and bytes into typed data values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何按需生成随机位，让我们看看如何将这些随机位转换为匹配特定 *分布* 的数值。这个两步过程--生成原始位，然后将它们格式化为数据值--与我们前面在
    [第 9 章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d) 中介绍的缓冲和解析的两步过程非常相似，即
    *Iostreams*。首先，获取原始位和字节，然后执行某种操作将这些位和字节转换为类型化的数据值。
- en: 'Given any distribution object `dist`, you can perform the following operations
    on it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何分布对象 `dist`，你可以对其执行以下操作：
- en: '`dist(g)`: This yields the next output according to the appropriate mathematical
    distribution. It may require several calls to `g()`, or none at all, depending
    on the internal state of the `dist` object.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist(g)`: 这将根据适当的数学分布产生下一个输出。这可能需要多次调用 `g()`，或者根本不需要，这取决于 `dist` 对象的内部状态。'
- en: '`dist.reset()`: This clears the internal state of the `dist` object, if any.
    You''ll never need to use this member function.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist.reset()`: 这将清除 `dist` 对象的内部状态（如果有的话）。你永远不会需要使用这个成员函数。'
- en: '`dist.min()` and `dist.max()`: These tell you the smallest and largest possible
    outputs of `dist(g)` for any random bit generator `g`. Generally, these values
    are either self-evident or meaningless; for example, `std::normal_distribution<float>().max()`
    is `INFINITY`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist.min()` 和 `dist.max()`: 这些告诉你 `dist(g)` 对于任何随机位生成器 `g` 的最小和最大可能输出。通常，这些值要么是显而易见的，要么是没有意义的；例如，`std::normal_distribution<float>().max()`
    是 `INFINITY`。'
- en: Let's see a few distribution types in action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个分布类型在实际中的应用。
- en: Rolling dice with uniform_int_distribution
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 uniform_int_distribution 投掷骰子
- en: 'The `std::uniform_int_distribution` method is the simplest distribution type
    in the standard library. It performs the same operation we tried to perform with
    `randint0` earlier in this chapter--map a random unsigned integer into a given
    range--, but it does it without any bias. The simplest implementation of `uniform_int_distribution`
    looks something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::uniform_int_distribution` 方法是标准库中最简单的分布类型。它执行的操作与我们本章前面尝试用 `randint0`
    执行的操作相同--将一个随机无符号整数映射到给定的范围中--但它没有任何偏差。`uniform_int_distribution` 的最简单实现看起来可能像这样：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The actual standard library implementation has to do something to get rid of
    that `assert`. Typically, they'll use something like `independent_bits_engine`
    to generate exactly `ceil(log2(range))` random bits at a time, minimizing the
    number of times the `while` loop needs to run.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的标准库实现必须做一些事情来消除那个 `assert`。通常，他们会使用类似 `independent_bits_engine` 的东西来一次生成正好
    `ceil(log2(range))` 个随机位，从而最小化 `while` 循环需要运行的次数。
- en: 'As implied in the preceding example, `uniform_int_distribution` is stateless
    (although this is not *technically* guaranteed), and so the most common way to
    use it is to create a new distribution object every time you generate a number.
    So, we can implement our `randint0` function like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`uniform_int_distribution` 是无状态的（尽管这并不是 *技术上* 保证的），因此最常见的使用方式是在每次生成数字时创建一个新的分布对象。因此，我们可以像这样实现我们的
    `randint0` 函数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now will probably be a good time to remark on an oddity of the `<random>` facilities.
    As a general rule, any time you supply an *integral numeric range* to one of these
    functions or constructors, it is treated as a *closed* range. This is in stark
    contrast to how ranges usually work in C and C++; we even saw in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, how deviating from the *half-open range* rule
    was usually the sign of buggy code. However, in the case of C++'s random-number
    facilities, there is a new rule--*the closed range* rule. Why?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是时候指出 `<random>` 库的一些奇怪之处了。一般来说，每次你向这些函数或构造函数提供一个 *整数数值范围* 时，它被视为一个 *闭区间*。这与
    C 和 C++ 中范围通常的工作方式形成鲜明对比；我们甚至在 [第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法*
    中看到，偏离 *半开区间* 规则通常是代码有问题的标志。然而，在 C++ 随机数库的情况下，有一条新的规则--*闭区间* 规则。为什么？
- en: Well, the key advantage of the half-open range is that it can easily represent
    an *empty range*. On the other hand, half-open ranges cannot represent a *completely
    full range*, that is, a range that covers the entire domain. (We saw this difficulty
    pop up in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, in the implementation of `std::list<T>::end()`.) Suppose
    we want to express the idea of a uniform distribution over the entire range of
    `long long`. We can't express that as the half-open range `[LLONG_MIN, LLONG_MAX+1)`
    because `LLONG_MAX+1` will overflow. However, we *can* express it as the closed
    range `[LLONG_MIN, LLONG_MAX]`--and so, that's what the `<random>` library's functions
    and classes (such as `uniform_int_distribution`) do. The `uniform_int_distribution<int>(0,6)`
    method is a distribution over the seven-number range `[0,6]`, and `uniform_int_distribution<int>(42,42)`
    is a perfectly valid distribution that invariably returns `42`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，半开区间的关键优势是它可以轻松地表示一个 *空区间*。另一方面，半开区间不能表示一个 *完全满的区间*，也就是说，一个覆盖整个域的区间。（我们在
    [第 4 章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，*容器动物园* 的实现中看到了这个问题。）假设我们想要表达在整个
    `long long` 范围上均匀分布的概念。我们不能将其表示为半开区间 `[LLONG_MIN, LLONG_MAX+1)`，因为 `LLONG_MAX+1`
    会溢出。然而，我们可以将其表示为闭区间 `[LLONG_MIN, LLONG_MAX]`--因此，这就是 `<random>` 库的函数和类（如 `uniform_int_distribution`）所做的事情。《uniform_int_distribution<int>(0,6)`
    方法是在 `[0,6]` 七个数范围内的分布，而 `uniform_int_distribution<int>(42,42)` 是一个完全有效的分布，总是返回
    `42`。
- en: On the other hand, `std::uniform_real_distribution<double>(a, b)` *does* operate
    on a half-open range! The `std::uniform_real_distribution<double>(0, 1)` method
    yields values of type `double`, uniformly distributed in the `[0, 1)` range. In
    the floating-point domain, there's no problem with overflow--a half-open range
    of `[0, INFINITY)` is actually expressible, although, of course, there's no such
    thing as a *uniform distribution* over an infinite range. Floating-point also
    makes it difficult to say the difference between a half-open range and a closed
    range; for example, `std::uniform_real_distribution<float>(0, 1)(g)` can legitimately
    return `float(1.0)` any time it generates a random real number close enough to
    1 that it rounds up about one in every 2^(25) results. (At press time, libc++
    behaves as described here. GNU's libstdc++ applies a patch that makes close-to-1
    real numbers round down instead of up so that the floating-point number just below
    1.0 appears marginally more often than chance would predict.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`std::uniform_real_distribution<double>(a, b)` *确实* 在一个半开区间上操作！`std::uniform_real_distribution<double>(0,
    1)` 方法产生类型为 `double` 的值，在 `[0, 1)` 范围内均匀分布。在浮点数域中，没有溢出问题--`[0, INFINITY)` 的半开区间实际上是可以表示的，尽管当然，在无限范围内不存在
    *均匀分布*。浮点数也使得很难区分半开区间和闭区间；例如，`std::uniform_real_distribution<float>(0, 1)(g)`
    可以合法地返回 `float(1.0)`，只要它生成的随机实数足够接近 1，以至于每 2^(25) 个结果中大约有一个会被四舍五入。 (在出版时，libc++
    的行为如上所述。GNU 的 libstdc++ 应用了一个补丁，使得接近 1 的实数向下而不是向上舍入，因此略低于 1.0 的浮点数出现的频率略高于随机预测。)
- en: Generating populations with normal_distribution
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 normal_distribution 生成种群
- en: The most useful example of a real-valued distribution is probably the *normal
    distribution*, also known as the **bell curve**. In the real world, normal distributions
    show up all over the place, particularly in the distribution of physical traits
    in a population. For example, a histogram of adult human heights will tend to
    look like a normal distribution--lots of individuals clustered around the average
    height, and others tailing off to each side. Flip this around, and it means that
    you might want to use a normal distribution to assign heights, weights, and so
    on, to the simulated individuals in a game.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实值分布最有用的例子可能是**正态分布**，也称为**钟形曲线**。在现实世界中，正态分布无处不在，尤其是在一个群体中物理特征的分布中。例如，成年人类身高的直方图往往会呈现出正态分布——许多个体围绕着平均身高聚集，其他人则向两边延伸。反过来，这意味着你可能想要使用正态分布来为游戏中的模拟个体分配身高、体重等。
- en: 'The `std::normal_distribution<double>(m, sd)` method constructs an instance
    of `normal_distribution<double>` with mean (`m`) and standard deviation (`sd`).
    (These parameters default to `m=0` and `sd=1` if you don''t provide them, so watch
    out for typos!) Here''s an example of using `normal_distribution` to create a
    "population" of 10,000 normally distributed samples, and then verifying their
    distribution mathematically:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::normal_distribution<double>(m, sd)` 方法构建了一个具有均值（`m`）和标准差（`sd`）的 `normal_distribution<double>`
    实例。（如果你没有提供这些参数，这些参数默认为 `m=0` 和 `sd=1`，所以要注意拼写错误！）以下是一个使用 `normal_distribution`
    创建 10,000 个正态分布样本的“人口”，然后通过数学方法验证其分布的示例：'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unlike the other distributions we've seen in this chapter (or will see), `std::normal_distribution`
    is stateful. While it is okay to construct a new instance of `std::normal_distribution`
    for each value you generate, if you do that, you're effectively halving the efficiency
    of your program. This is because the most popular algorithm to generate normally
    distributed values produces two independent values per step; `std::normal_distribution`
    can't give you both values at once, so it hangs onto one of them in a member variable
    to give it to you the next time you ask. The `dist.reset()` member function can
    be used to clear out this saved state, not that you'd ever want to do that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中（或将要看到的）的其他分布不同，`std::normal_distribution` 是有状态的。虽然为每个生成的值构造一个新的 `std::normal_distribution`
    实例是可以的，但如果你这样做，实际上会减半你程序的效率。这是因为生成正态分布值的最流行算法每次产生两个独立值；`std::normal_distribution`
    不能一次给你两个值，所以它会将其中一个值保留在成员变量中，以便下次请求时提供给你。可以使用 `dist.reset()` 成员函数清除这个保存的状态，尽管你永远不会想这样做。
- en: Making weighted choices with discrete_distribution
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `discrete_distribution` 进行加权选择
- en: 'The `std::discrete_distribution<int>(wbegin, wend)` method constructs a discrete,
    or weighted, distribution over the integers in the half-open `[0, wend - wbegin)`
    range. This is easiest to explain with the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::discrete_distribution<int>(wbegin, wend)` 方法在 `[0, wend - wbegin)` 的半开区间上构建一个离散的或加权的分布。以下示例可以最容易地解释这一点：'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `std::discrete_distribution<int>` method makes its own internal copy of
    the weights you pass in, in a private member variable of type `std::vector<double>`
    (and as usual for `<random>`, it''s not allocator-aware). You can get a copy of
    this vector by calling `dist.probabilities()` as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::discrete_distribution<int>` 方法会将其传入的权重在自己的私有成员变量 `std::vector<double>`
    中创建一个内部副本（并且，像 `<random>` 中的常规操作一样，它不是分配器感知的）。你可以通过调用 `dist.probabilities()` 来获取这个向量的副本，如下所示：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You probably don''t want to use `discrete_distribution` directly in your own
    code; at best, you''ll want to encapsulate its use in something like the preceding
    `weighted_choice` function. However, if you need to avoid heap allocation or floating-point
    math, it might pay to use a simpler, non-allocating function, such as the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想直接在自己的代码中使用 `discrete_distribution`；最好的办法是将它的使用封装在类似前面的 `weighted_choice`
    函数中。然而，如果你需要避免堆分配或浮点运算，使用一个更简单的不分配函数可能更有利，如下所示：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, there''s a reason the *default* library implementation of `discrete_distribution`
    does all its math as floating-point: it saves you from having to worry about integer
    overflow. The preceding code will have bad behavior if `sum` overflows the range
    of `int`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`discrete_distribution` 的默认库实现之所以将其所有数学运算作为浮点数进行，是因为它为你节省了担心整数溢出的麻烦。如果 `sum`
    超出了 `int` 的范围，前面的代码将会有不良行为。
- en: Shuffling cards with std::shuffle
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::shuffle` 洗牌
- en: Let's close this chapter by looking at `std::shuffle(a,b,g)`, the one standard
    algorithm that takes a random number generator as input. It's a *permutative algorithm*
    by the definitions of [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator Pair-Algorithms*--it takes a range of elements `[a,b)` and shuffles
    them around, preserving their values but not their positions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看`std::shuffle(a,b,g)`来结束这一章，这是唯一一个接受随机数生成器作为输入的标准算法。根据[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)的定义，它是一个*排列算法*--它接受一个元素范围
    `[a,b)` 并对其进行洗牌，保留其值但不保留其位置。
- en: The `std::shuffle(a,b,g)` method was introduced in C++11 to replace the older
    `std::random_shuffle(a,b)` algorithm. That older algorithm "randomly" shuffled
    the `[a,b)` range, but without specifying the source of the randomness; in practice,
    this meant that it would use the global C library's `rand()` with all its attendant
    problems. As soon as C++11 introduced a standardized way of talking about random
    number generators with `<random>`, it was time to get rid of the old `rand()`
    based `random_shuffle`; and, as of C++17, `std::random_shuffle(a,b)` is no longer
    part of the C++ standard library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shuffle(a,b,g)`方法是在C++11中引入的，用于取代旧的`std::random_shuffle(a,b)`算法。那个旧的算法“随机”地洗牌
    `[a,b)` 范围，但没有指定随机性的来源；在实践中，这意味着它将使用全局C库的`rand()`，并带来所有相关问题。一旦C++11通过`<random>`引入了关于随机数生成器的标准化方法，就到了摆脱基于旧`rand()`的`random_shuffle`的时候了；并且，截至C++17，`std::random_shuffle(a,b)`不再是C++标准库的一部分。'
- en: 'Here''s how we can use C++11''s `std::shuffle` to shuffle a deck of playing
    cards:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以如何使用C++11的`std::shuffle`来洗牌一副扑克牌的方法：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Recall that every *generator* in `<random>` is completely specified so that,
    for example, an instance of `std::mt19937` seeded with a fixed value will produce
    exactly the same outputs on every platform. The same is *not* true of *distributions*
    such as `uniform_real_distribution`, nor is it true of the `shuffle` algorithm.
    Switching from libc++ to libstdc++, or even just upgrading your compiler, may
    cause changes in the behavior of your `std::shuffle`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`<random>`中的每个*生成器*都是完全指定的，例如，使用固定值初始化的`std::mt19937`实例将在每个平台上产生完全相同的输出。对于像`uniform_real_distribution`这样的*分布*，以及`shuffle`算法，情况并非如此。从libc++切换到libstdc++，或者只是升级编译器，可能会导致你的`std::shuffle`行为发生变化。
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Whatever generator and seeding method you use, you'll be able to plug it right
    into `std::shuffle`. This is the benefit of the standard library's composable
    approach to random number generation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么生成器和初始化方法，你都可以直接将其插入到`std::shuffle`中。这是标准库对随机数生成可组合方法的好处。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The standard library provides two random-number-related concepts--*generator*
    and *distribution*. Generators are stateful, must be seeded, and produce unsigned
    integer outputs (raw bits) via `operator()(void)`. The two important generator
    types are `std::random_device`, which produces truly random bits, and `std::mt19937`,
    which produces pseudo-random bits.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了两个与随机数相关的概念--*生成器*和*分布*。生成器是有状态的，必须进行初始化，并通过`operator()(void)`产生无符号整数输出（原始比特）。两种重要的生成器类型是`std::random_device`，它产生真正的随机比特，以及`std::mt19937`，它产生伪随机比特。
- en: Distributions are *usually* stateless, and produce numeric data values via `operator()(Gen&)`.
    The most important distribution type for most programmers will be `std::uniform_int_distribution<int>(a,b)`,
    which produces integers in the closed range `[a,b]`. The standard library provides
    other distributions, such as `std::uniform_real_distribution`, `std::normal_distribution`,
    and `std::discrete_distribution`, as well as many arcane distributions useful
    to mathematicians and statisticians.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 分布通常是*无状态的*，并通过`operator()(Gen&)`产生数值数据。对于大多数程序员来说，最重要的分布类型将是`std::uniform_int_distribution<int>(a,b)`，它产生闭区间
    `[a,b]` 内的整数。标准库还提供了其他分布，例如`std::uniform_real_distribution`、`std::normal_distribution`和`std::discrete_distribution`，以及许多对数学家和统计学家有用的神秘分布。
- en: The one standard algorithm that uses randomness is `std::shuffle`, which replaces
    the old-style `std::random_shuffle`. Don't use `random_shuffle` in the new code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机性的唯一标准算法是`std::shuffle`，它取代了旧式的`std::random_shuffle`。不要在新代码中使用`random_shuffle`。
- en: Be aware that `std::mt19937` has exactly the same behavior on every platform,
    but the same is not true of any *distribution* type, nor of `std::shuffle`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::mt19937`在所有平台上具有完全相同的行为，但任何*分布*类型，以及`std::shuffle`，情况并非如此。
