<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. HTTP and SSL/TLS</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing the HTTP client application</li><li class="listitem" style="list-style-type: disc">Implementing the HTTP server application</li><li class="listitem" style="list-style-type: disc">Adding SSL/TLS support to client applications</li><li class="listitem" style="list-style-type: disc">Adding SSL/TLS support to server applications</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Introduction</h1></div></div></div><p>This chapter covers two major topics. The first one is HTTP protocol implementation. The second is the usage of SSL/TLS protocol. Let's briefly examine each of them.</p><p>The <strong>HTTP protocol</strong> is <a id="id254" class="indexterm"/>an application layer protocol operating on the top of TCP protocol. It is widely used on the Internet, allowing client applications to request particular resources from the servers, and servers to transmit the requested resources back to the clients. Besides, HTTP allows clients to upload data and send commands to the server.</p><p>The HTTP protocol assumes several models or <strong>methods</strong> of communication, each designed for a specific purpose. The simplest method called <code class="literal">GET</code> assumes the following flow of events:</p><div><ol class="orderedlist arabic"><li class="listitem">The <a id="id255" class="indexterm"/>HTTP client application (for example, a web browser) generates a request message containing information about a particular resource (residing on the server) to be requested and sends it to the HTTP server application (for example, a web server) using TCP as a transport level protocol.</li><li class="listitem">The <a id="id256" class="indexterm"/>HTTP server application, having received a request from the client, parses it, extracts the requested resource from the storage (for example, from a file system or a database), and sends it back to the client as a part of a HTTP response message.</li></ol></div><p>The format of both the request and response messages is defined by HTTP protocol.</p><p>Several other methods are defined by HTTP protocol, allowing client application to actively send data or upload resources to the server, delete resources located on the server, and perform other operations. In the recipes of this chapter, we will consider implementation of the <code class="literal">GET</code> method. Because HTTP protocol methods are similar in principle, implementation of one of them gives a good hint about how to implement others.</p><p>Another topic covered in this chapter is <strong>SSL and TLS protocols</strong>. <a id="id257" class="indexterm"/>
<strong>Secure Socket Layer</strong> (<strong>SSL</strong>)and <a id="id258" class="indexterm"/>
<strong>Transport Layer Security</strong> (<strong>TLS</strong>) protocols operate on the top of TCP protocol and are aimed at achieving two main goals as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Providing a way to authenticate each communication participant using digital certificate</li><li class="listitem" style="list-style-type: disc">Securing data being transmitted over the underlying TCP protocol</li></ul></div><p>The SSL and TLS protocols are widespread, especially in the Web. Most web servers to which its potential clients may send sensitive data (passwords, credit card numbers, personal data, and so on) support SSL/TLS-enabled communication. In this case, the so called HTTPS (HTTP over SSL) protocol is used to allow the client to authenticate the server (sometimes servers may want to authenticate the client, though this is rarely the case) and to secure transmitted data by encrypting it, making this data useless for the culprit even if intercepted.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Boost.Asio does not contain the implementation of SSL/TLS protocols. Instead, it relies on the OpenSSL library, Boost.Asio provides a set of classes, functions, and data structures that facilitate the usage of functionality provided by OpenSSL, making the code of the application more uniformed and object-oriented.</p></div></div><p>In this chapter, we will not consider the details of the OpenSSL library or SSL/TLS protocols. These topics are not in the scope of this book. Instead, we will touch upon specific tools provided by the Boost.Asio that rely on OpenSSL library and allow to implement support of SSL/TLS protocol in a network application.</p><p>The two recipes demonstrate how to build client and server applications that secure their communication using SSL/TLS protocols. To make SSL/TLS-related aspects of the applications more vivid and clear, all other aspects of considered applications were made as simple as possible. Both client and server applications are synchronous and based on recipes found in other chapters of this book. This allows us to compare a basic TCP client or server application with their advanced versions supporting SSL/TLS and to better understand what it takes to add SSL/TLS support to a distributed application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Implementing the HTTP client application</h1></div></div></div><p>HTTP clients<a id="id259" class="indexterm"/> constitute important class of distributed software and are represented by many applications. Web browsers are prominent representatives of this class. They use HTTP protocols to request web pages from web servers. However, today HTTP protocol is used not only in the web. Many distributed applications use this protocol to exchange custom data of any kind. Often, when designing a distributed application, choosing HTTP as a communication protocol is a much better idea than developing custom one.</p><p>In this recipe, we will consider an implementation of HTTP client using Boost.Asio that satisfies the following basic requirements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Supports the HTTP <code class="literal">GET</code> request method</li><li class="listitem" style="list-style-type: disc">Executes requests asynchronously</li><li class="listitem" style="list-style-type: disc">Supports request canceling</li></ul></div><p>Let's move on to the implementation.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec94"/>How to do it…</h2></div></div></div><p>Because one of the requirements of our client application is to support canceling requests that have been initiated but have not been completed yet, we need to make sure that canceling is enabled on all target platforms. Therefore, we begin our client application by configuring Boost.Asio library so that request canceling is enabled. More details on issues related to asynchronous operation canceling are provided in the <em>Cancelling asynchronous operations</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. I/O Operations">Chapter 2</a>, <em>I/O Operations</em>:</p><div><pre class="programlisting">#include &lt;boost/predef.h&gt; // Tools to identify the OS.

// We need this to enable cancelling of I/O operations on
// Windows XP, Windows Server 2003 and earlier.
// Refer to "http://www.boost.org/doc/libs/1_58_0/
// doc/html/boost_asio/reference/basic_stream_socket/
// cancel/overload1.html" for details.
#ifdef BOOST_OS_WINDOWS
#define _WIN32_WINNT 0x0501

#if _WIN32_WINNT &lt;= 0x0502 // Windows Server 2003 or earlier.
#define BOOST_ASIO_DISABLE_IOCP
#define BOOST_ASIO_ENABLE_CANCELIO  
#endif
#endif</pre></div><p>Next, we<a id="id260" class="indexterm"/> include Boost.Asio library headers and also headers of some components of standard C++ libraries that we will need to implement our application:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;

#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Now, before we can jump to implementing classes and functions constituting our client application, we have to make one more preparation related to error representation and handling.</p><p>When implementing the HTTP client application, we need to deal with three classes of errors. The first class is represented by numerous errors that may occur when executing Boost.Asio functions and classes' methods. For example, if we call the <code class="literal">write_some()</code> method on an object representing a socket that has not been opened, the method will return operating system dependent error code (either by throwing an exception or by the means of an out argument depending on the method overload used), designating the fact that an invalid operation has been executed on a non-opened socket.</p><p>The second class includes both erroneous and non-erroneous statuses defined by HTTP protocol. For example, the status code 200 returned by the server as a response to particular request made by the client, designates the fact that a client's request has been fulfilled successfully. On the other hand, the status code 500 designates that while performing the requested operation, an error occurred on the server that led to the request not being fulfilled.</p><p>The third class includes errors related to the HTTP protocol itself. In case a server sends a message, as a response to correct the request made by a client and this message is not a properly structured HTTP response, the client application should have means to represent this fact in terms of error code.</p><p>Error code for the first class of errors are defined in the sources of Boost.Asio libraries. Status codes of the second class are defined by HTTP protocol. The third class is not defined anywhere and we should define corresponding error codes by ourselves in our application.</p><p>We define a single error code that represents quite a general error designating the fact that the message received from the server is not a correct HTTP response message and therefore, the client cannot parse it. Let's name this error code as <code class="literal">invalid_response</code>:</p><div><pre class="programlisting">namespace http_errors {
  enum http_error_codes
  {
    invalid_response = 1
  };</pre></div><p>Then, we define <a id="id261" class="indexterm"/>a class representing an error category, which includes the <code class="literal">invalid_response</code> error code defined above. Let's name this category as <code class="literal">http_errors_category</code>:</p><div><pre class="programlisting">  class http_errors_category
    : public boost::system::error_category
  {
  public:
    const char* name() const BOOST_SYSTEM_NOEXCEPT 
    { return "http_errors"; }

    std::string message(int e) const {
      switch (e) {
      case invalid_response:
        return "Server response cannot be parsed.";
        break;
      default:
        return "Unknown error.";
        break;
      }
    }
  };</pre></div><p>Then, we define a static object of this class, a function returning an instance of the object, and the overload for the <code class="literal">make_error_code()</code> function accepting error codes of our custom type <code class="literal">http_error_codes</code>:</p><div><pre class="programlisting">const boost::system::error_category&amp;
get_http_errors_category()
{
    static http_errors_category cat;
    return cat;
  }

  boost::system::error_code
    make_error_code(http_error_codes e)
  {
    return boost::system::error_code(
      static_cast&lt;int&gt;(e), get_http_errors_category());
  }
} // namespace http_errors</pre></div><p>The last step we <a id="id262" class="indexterm"/>need to perform before we can use our new error code in our application is to allow Boost library to <em>know</em> that the members of the <code class="literal">http_error_codes</code> enumeration should be treated as error codes. To do this, we include the following structure definition into the <code class="literal">boost::system</code> namespace:</p><div><pre class="programlisting">namespace boost {
  namespace system {
    template&lt;&gt;
struct is_error_code_enum
&lt;http_errors::http_error_codes&gt;
{
      BOOST_STATIC_CONSTANT(bool, value = true);
    };
  } // namespace system
} // namespace boost</pre></div><p>Because our HTTP client application is going to be asynchronous, the user of the client when initiating a request, will need to provide a pointer to a callback function, which will be invoked when the request completes. We need to define a type representing a pointer to such a callback function.</p><p>A callback function when called, would need to be passed arguments that clearly designate three things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Which request has completed</li><li class="listitem" style="list-style-type: disc">What is the response</li><li class="listitem" style="list-style-type: disc">Whether the request completed successfully and if not, the error code designating the error that occurred</li></ul></div><p>Note that, later, we will define the <code class="literal">HTTPRequest</code> and <code class="literal">HTTPResponse</code> classes representing the HTTP request and HTTP response correspondingly, but now we use forward declarations. Here is how the callback function pointer type declaration looks:</p><div><pre class="programlisting">class HTTPClient;
class HTTPRequest;
class HTTPResponse;

typedef void(*Callback) (const HTTPRequest&amp; request,
  const HTTPResponse&amp; response,
  const system::error_code&amp; ec);</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec41"/>The HTTPResponse class</h3></div></div></div><p>Now, we can <a id="id263" class="indexterm"/>define a class representing a HTTP response message sent to the client as a response to the request:</p><div><pre class="programlisting">class HTTPResponse {
  friend class HTTPRequest;
  HTTPResponse() : 
    m_response_stream(&amp;m_response_buf)
  {}
public:

  unsigned int get_status_code() const {
    return m_status_code;
  }

  const std::string&amp; get_status_message() const {
    return m_status_message;
  }

  const std::map&lt;std::string, std::string&gt;&amp; get_headers() {
    return m_headers;
  }
  
  const std::istream&amp; get_response() const {
    return m_response_stream;
  }

private:
  asio::streambuf&amp; get_response_buf() {
    return m_response_buf;
  }

  void set_status_code(unsigned int status_code) {
    m_status_code = status_code;
  }

  void set_status_message(const std::string&amp; status_message) {
    m_status_message = status_message;
  }

  void add_header(const std::string&amp; name, 
  const std::string&amp; value) 
  {
    m_headers[name] = value;
  }

private:
  unsigned int m_status_code; // HTTP status code.
  std::string m_status_message; // HTTP status message.
  
  // Response headers.
  std::map&lt;std::string, std::string&gt; m_headers;
  asio::streambuf m_response_buf;
  std::istream m_response_stream;
};</pre></div><p>The <code class="literal">HTTPResponse</code> class<a id="id264" class="indexterm"/> is quite simple. Its private data members represent parts of HTTP response such as the response status code and status message, and response headers and body. Its public interface contains methods that return the values of corresponding data members, while private methods allow setting those values.</p><p>The <code class="literal">HTTPRequest</code> class representing a HTTP request, which will be defined next, is declared as a friend to <code class="literal">HTTPResponse</code>. We will see how the objects of the <code class="literal">HTTPRequest</code> class use the private methods of the <code class="literal">HTTPResponse</code> class to set values of its data members when a response message arrives.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec42"/>The HTTPRequest class</h3></div></div></div><p>Next, we <a id="id265" class="indexterm"/>define a class representing a HTTP request containing functionality that constructs the HTTP request message based on information provided by the class user, sends it to the server, and then receives and parses the HTTP response message.</p><p>This class is at the center of our application because it contains most of its functionalities.</p><p>Later, we will define the <code class="literal">HTTPClient</code> class representing an HTTP client, responsibilities of which will be limited to maintaining a single instance of the <code class="literal">asio::io_service</code> class common to all the <code class="literal">HTTPRequest</code> objects and acting as a factory of the <code class="literal">HTTPRequest</code> objects. Therefore, we declare the <code class="literal">HTTPClient</code> class as a friend to the <code class="literal">HTTPRequest</code> class and make the <code class="literal">HTTPRequest</code> class' constructor private:</p><div><pre class="programlisting">class HTTPRequest {
  friend class HTTPClient;

  static const unsigned int DEFAULT_PORT = 80;

  HTTPRequest(asio::io_service&amp; ios, unsigned int id) :
    m_port(DEFAULT_PORT),
    m_id(id),
    m_callback(nullptr),
    m_sock(ios),
    m_resolver(ios),
    m_was_cancelled(false),
    m_ios(ios)  
{}</pre></div><p>The constructor accepts two arguments: a reference to an object of the <code class="literal">asio::io_service</code> class and an <a id="id266" class="indexterm"/>unsigned integer named <code class="literal">id</code>. The latter contains a unique identifier of a request, which is assigned by the user of the class and allows distinguishing request objects one from another.</p><p>Then, we define methods constituting the public interface of the class:</p><div><pre class="programlisting">public:
  void set_host(const std::string&amp; host) {
    m_host = host;
  }

  void set_port(unsigned int port) {
    m_port = port;
  }

  void set_uri(const std::string&amp; uri) {
    m_uri = uri;
  }

  void set_callback(Callback callback) {
    m_callback = callback;
  }

  std::string get_host() const {
    return m_host;
  }

  unsigned int get_port() const {
    return m_port;
  }

  const std::string&amp; get_uri() const {
    return m_uri;
  }

  unsigned int get_id() const {
    return m_id;
  }

  void execute() {
    // Ensure that precorditions hold.
    assert(m_port &gt; 0);
    assert(m_host.length() &gt; 0);
    assert(m_uri.length() &gt; 0);
    assert(m_callback != nullptr);

    // Prepare the resolving query.
    asio::ip::tcp::resolver::query resolver_query(m_host,
      std::to_string(m_port), 
      asio::ip::tcp::resolver::query::numeric_service);

    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);

    if (m_was_cancelled) {
      cancel_lock.unlock();
      on_finish(boost::system::error_code(
      asio::error::operation_aborted));
      return;
    }
    
    // Resolve the host name.
    m_resolver.async_resolve(resolver_query,
      [this](const boost::system::error_code&amp; ec,
      asio::ip::tcp::resolver::iterator iterator)
    {
      on_host_name_resolved(ec, iterator);
    });
  }

  void cancel() {
    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);
    
    m_was_cancelled = true;
    
    m_resolver.cancel();
    
    if (m_sock.is_open()) {
      m_sock.cancel();
    }  
}</pre></div><p>The public interface<a id="id267" class="indexterm"/> includes methods that allow the class' user to set and get HTTP request parameters such as the DNS name of the host running the server, protocol port number, and URI of the requested resource. Besides, there is a method that allows setting a pointer to a callback function that will be called when the request completes.</p><p>The <code class="literal">execute()</code> method <a id="id268" class="indexterm"/>initiates the execution of the request. Also, the <code class="literal">cancel()</code> method allows canceling the initiated request before it completes. We will consider how these methods work in the next section of the recipe.</p><p>Now, we define a set of private methods that contain most of the implementation details. Firstly, we define a method that is used as a callback for an asynchronous DNS name resolution operation:</p><div><pre class="programlisting">private:
  void on_host_name_resolved(
    const boost::system::error_code&amp; ec,
    asio::ip::tcp::resolver::iterator iterator) 
{
    if (ec != 0) {
      on_finish(ec);
      return;
    }

    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);

    if (m_was_cancelled) {
      cancel_lock.unlock();
      on_finish(boost::system::error_code(
      asio::error::operation_aborted));
      return;
    }

    // Connect to the host.
    asio::async_connect(m_sock,
      iterator,
      [this](const boost::system::error_code&amp; ec,
      asio::ip::tcp::resolver::iterator iterator)
    {
      on_connection_established(ec, iterator);
    });

  }</pre></div><p>Then, we define a method used as a callback for an asynchronous connection operation, which is initiated <a id="id269" class="indexterm"/>in the <code class="literal">on_host_name_resolved()</code> method just defined:</p><div><pre class="programlisting">  void on_connection_established(
    const boost::system::error_code&amp; ec,
    asio::ip::tcp::resolver::iterator iterator) 
{
    if (ec != 0) {
      on_finish(ec);
      return;
    }

    // Compose the request message.
    m_request_buf += "GET " + m_uri + " HTTP/1.1\r\n";

    // Add mandatory header.
    m_request_buf += "Host: " + m_host + "\r\n";

    m_request_buf += "\r\n";

    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);

    if (m_was_cancelled) {
      cancel_lock.unlock();
      on_finish(boost::system::error_code(
      asio::error::operation_aborted));
      return;
    }

    // Send the request message.
    asio::async_write(m_sock,
      asio::buffer(m_request_buf),
      [this](const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_request_sent(ec, bytes_transferred);
    });
  }</pre></div><p>The next method we define—<code class="literal">on_request_sent()</code>—is a callback, which is called after the request message is sent to the server:</p><div><pre class="programlisting">  void on_request_sent(const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred) 
{
    if (ec != 0) {
      on_finish(ec);
      return;
    }

    m_sock.shutdown(asio::ip::tcp::socket::shutdown_send);

    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);

    if (m_was_cancelled) {
      cancel_lock.unlock();
      on_finish(boost::system::error_code(
      asio::error::operation_aborted));
      return;
    }

    // Read the status line.
    asio::async_read_until(m_sock,
      m_response.get_response_buf(),
      "\r\n",
      [this](const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_status_line_received(ec, bytes_transferred);
    });
  }</pre></div><p>Then, we need <a id="id270" class="indexterm"/>another callback method, which is called when the first portion <a id="id271" class="indexterm"/>of the response message, namely, <strong>status line</strong>, is received from the server:</p><div><pre class="programlisting">  void on_status_line_received(
    const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred)
  {
    if (ec != 0) {
      on_finish(ec);
      return;
    }

    // Parse the status line.
    std::string http_version;
    std::string str_status_code;
    std::string status_message;

    std::istream response_stream(
    &amp;m_response.get_response_buf());
    response_stream &gt;&gt; http_version;

    if (http_version != "HTTP/1.1"){
      // Response is incorrect.
      on_finish(http_errors::invalid_response);
      return;
    }

    response_stream &gt;&gt; str_status_code;

    // Convert status code to integer.
    unsigned int status_code = 200;

    try {
      status_code = std::stoul(str_status_code);
    }
    catch (std::logic_error&amp;) {
      // Response is incorrect.
      on_finish(http_errors::invalid_response);
      return;
    }

    std::getline(response_stream, status_message, '\r');
    // Remove symbol '\n' from the buffer.
    response_stream.get();

    m_response.set_status_code(status_code);
    m_response.set_status_message(status_message);

    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);

    if (m_was_cancelled) {
      cancel_lock.unlock();
      on_finish(boost::system::error_code(
      asio::error::operation_aborted));
      return;
    }

    // At this point the status line is successfully
    // received and parsed.
    // Now read the response headers.
    asio::async_read_until(m_sock,
      m_response.get_response_buf(),
      "\r\n\r\n",
      [this](
      const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_headers_received(ec,
        bytes_transferred);
    });
  }</pre></div><p>Now, we define <a id="id272" class="indexterm"/>a method that serves as a callback, which is called when the next portion of the response message—<strong>the </strong>
<a id="id273" class="indexterm"/>
<strong>response headers block</strong>—arrives from the server. We will name it as <code class="literal">on_headers_received()</code>:</p><div><pre class="programlisting">  void on_headers_received(const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred) 
{
    if (ec != 0) {
      on_finish(ec);
      return;
    }

    // Parse and store headers.
    std::string header, header_name, header_value;
    std::istream response_stream(
    &amp;m_response.get_response_buf());

    while (true) {
      std::getline(response_stream, header, '\r');

      // Remove \n symbol from the stream.
      response_stream.get();

      if (header == "")
        break;

      size_t separator_pos = header.find(':');
      if (separator_pos != std::string::npos) {
        header_name = header.substr(0,
        separator_pos);

        if (separator_pos &lt; header.length() - 1)
          header_value =
          header.substr(separator_pos + 1);
        else
          header_value = "";

        m_response.add_header(header_name,
        header_value);
      }
    }

    std::unique_lock&lt;std::mutex&gt;
      cancel_lock(m_cancel_mux);

    if (m_was_cancelled) {
      cancel_lock.unlock();
      on_finish(boost::system::error_code(
      asio::error::operation_aborted));
      return;
    }

    // Now we want to read the response body.
    asio::async_read(m_sock,
      m_response.get_response_buf(),
      [this](
      const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_response_body_received(ec,
        bytes_transferred);
    });

    return;
  }</pre></div><p>Besides, we <a id="id274" class="indexterm"/>need a method that will handle the last part of the response—<strong>the response body</strong>. The<a id="id275" class="indexterm"/> following method is used as a callback, which is called after the response body arrives from the server:</p><div><pre class="programlisting">void on_response_body_received(
const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred) 
{
    if (ec == asio::error::eof)
      on_finish(boost::system::error_code());
    else
      on_finish(ec);  
}</pre></div><p>Finally, we define the <code class="literal">on_finish()</code> method that serves as a final point of all execution paths (including erroneous) that start in the <code class="literal">execute()</code> method. This method is called when the <a id="id276" class="indexterm"/>request completes (either successfully or not) and its purpose is to call the callback provided by the <code class="literal">HTTPRequest</code> class' user to notify it about the completion of the request:</p><div><pre class="programlisting">  void on_finish(const boost::system::error_code&amp; ec) 
{
    if (ec != 0) {
      std::cout &lt;&lt; "Error occured! Error code = "
        &lt;&lt; ec.value()
        &lt;&lt; ". Message: " &lt;&lt; ec.message();
    }

    m_callback(*this, m_response, ec);

    return;
  }</pre></div><p>We will need some data fields associated with each instance of the <code class="literal">HTTPRequest</code> class. Here, we declare the class' corresponding data members:</p><div><pre class="programlisting">private:
  // Request parameters. 
  std::string m_host;
  unsigned int m_port;
  std::string m_uri;

  // Object unique identifier. 
  unsigned int m_id;

  // Callback to be called when request completes. 
  Callback m_callback;

  // Buffer containing the request line.
  std::string m_request_buf;

  asio::ip::tcp::socket m_sock;  
  asio::ip::tcp::resolver m_resolver;

  HTTPResponse m_response;

  bool m_was_cancelled;
  std::mutex m_cancel_mux;

  asio::io_service&amp; m_ios;</pre></div><p>The last thing to <a id="id277" class="indexterm"/>add is the closing bracket to designate the end of the <code class="literal">HTTPRequest</code> class definition:</p><div><pre class="programlisting">};</pre></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec43"/>The HTTPClient class</h3></div></div></div><p>The last class <a id="id278" class="indexterm"/>that we need in our application is the one that would be responsible for the following three functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To establish a threading policy</li><li class="listitem" style="list-style-type: disc">To spawn and destroy threads in a pool of threads running the Boost.Asio event loop and delivering asynchronous operations' completion events</li><li class="listitem" style="list-style-type: disc">To act as a factory of the <code class="literal">HTTPRequest</code> objects</li></ul></div><p>We will name this class as <code class="literal">HTTPClient</code>:</p><div><pre class="programlisting">class HTTPClient {
public:
  HTTPClient(){
    m_work.reset(new boost::asio::io_service::work(m_ios));

    m_thread.reset(new std::thread([this](){
      m_ios.run();
    }));
  }

  std::shared_ptr&lt;HTTPRequest&gt;
  create_request(unsigned int id) 
  {
    return std::shared_ptr&lt;HTTPRequest&gt;(
    new HTTPRequest(m_ios, id));
  }

  void close() {
    // Destroy the work object. 
    m_work.reset(NULL);

    // Waiting for the I/O thread to exit.
    m_thread-&gt;join();
  }

private:
  asio::io_service m_ios;
  std::unique_ptr&lt;boost::asio::io_service::work&gt; m_work;
  std::unique_ptr&lt;std::thread&gt; m_thread;
};</pre></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec44"/>The callback and the main() entry point function</h3></div></div></div><p>At this point, we <a id="id279" class="indexterm"/>have the basic HTTP client that comprises three classes and several supplementary data types. Now we will define two functions that are not parts of the client, but demonstrate how to use it to communicate with the server using the HTTP protocol. The first function will be used as a callback, which will be called when the request completes. Its signature must correspond to the function <a id="id280" class="indexterm"/>pointer type <code class="literal">Callback</code> defined earlier. Let's name our callback function as <code class="literal">handler()</code>:</p><div><pre class="programlisting">void handler(const HTTPRequest&amp; request,
  const HTTPResponse&amp; response,
  const system::error_code&amp; ec)
{
  if (ec == 0) {
    std::cout &lt;&lt; "Request #" &lt;&lt; request.get_id()
      &lt;&lt; " has completed. Response: "
      &lt;&lt; response.get_response().rdbuf();
  }
  else if (ec == asio::error::operation_aborted) {
    std::cout &lt;&lt; "Request #" &lt;&lt; request.get_id()
      &lt;&lt; " has been cancelled by the user." 
      &lt;&lt; std::endl;
  }
  else {
    std::cout &lt;&lt; "Request #" &lt;&lt; request.get_id()
      &lt;&lt; " failed! Error code = " &lt;&lt; ec.value()
      &lt;&lt; ". Error message = " &lt;&lt; ec.message() 
    &lt;&lt; std::endl;
  }

  return;
}</pre></div><p>The second and the last function we need to define is the <code class="literal">main()</code> application entry point function that uses the HTTP client to send HTTP requests to the server:</p><div><pre class="programlisting">int main()
{
  try {
    HTTPClient client;

    std::shared_ptr&lt;HTTPRequest&gt; request_one =
      client.create_request(1);

    request_one-&gt;set_host("localhost");
    request_one-&gt;set_uri("/index.html");
    request_one-&gt;set_port(3333);
    request_one-&gt;set_callback(handler);

    request_one-&gt;execute();

    std::shared_ptr&lt;HTTPRequest&gt; request_two =
      client.create_request(1);

    request_two-&gt;set_host("localhost");
    request_two-&gt;set_uri("/example.html");
    request_two-&gt;set_port(3333);
    request_two-&gt;set_callback(handler);

    request_two-&gt;execute();

    request_two-&gt;cancel();

    // Do nothing for 15 seconds, letting the
    // request complete.
    std::this_thread::sleep_for(std::chrono::seconds(15));

    // Closing the client and exiting the application.
    client.close();
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
};</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec95"/>How it works…</h2></div></div></div><p>Now let's consider <a id="id281" class="indexterm"/>how our HTTP client works. The application consists of five components, among which are the three classes such as <code class="literal">HTTPClient</code>, <code class="literal">HTTPRequest</code>, and <code class="literal">HTTPResponse</code>, and two functions such as the <code class="literal">handler()</code> callback function and the <code class="literal">main()</code> application entry point function. Let's consider how each component works separately.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec45"/>The HTTPClient class</h3></div></div></div><p>A class' constructor <a id="id282" class="indexterm"/>begins with creating an instance of the <code class="literal">asio::io_service::work</code> object in order to make sure that threads running the event loop do not exit this loop when there are no pending asynchronous operations. Then, a thread of control is spawned and added to the pool by calling the <code class="literal">run()</code> method on the <code class="literal">m_ios</code> object. This is where the <code class="literal">HTTPClient</code> class performs its first and part of the second functions, namely, establishing threading policy and adding threads to the pool.</p><p>The third function of the <code class="literal">HTTPClient</code> class—to act as a factory of the object representing HTTP requests—is performed in its <code class="literal">create_request()</code> public method. This method creates an instance of the <code class="literal">HTTPRequest</code> class in the free memory and returns a shared pointer object pointing to it. As its input argument, the method accepts an integer value that represents the unique identifier to be assigned to the newly created request object. This identifier is used to distinguish between different request objects.</p><p>The <code class="literal">close()</code> method from the class' public interface destroys the <code class="literal">asio::io_service::work</code> object, allowing threads to exit the event loop just as soon as all pending operations complete. The method blocks until all threads exit.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec46"/>The HTTPRequest class</h3></div></div></div><p>Let's begin <a id="id283" class="indexterm"/>considering the <code class="literal">HTTPRequest</code> class' behavior by inspecting its data members and their purpose. The <code class="literal">HTTPRequest</code> class contains 12 data members, among which are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Request parameters:<div><pre class="programlisting">  std::string m_host;
  unsigned int m_port;
  std::string m_uri;</pre></div></li><li class="listitem" style="list-style-type: disc">A unique identifier of the request:<div><pre class="programlisting">  unsigned int m_id;</pre></div></li><li class="listitem" style="list-style-type: disc">A pointer to the callback function provided by the class' user to be called when a request completes:<div><pre class="programlisting">  Callback m_callback;</pre></div></li><li class="listitem" style="list-style-type: disc">A string buffer used to store the HTTP request message:<div><pre class="programlisting">  std::string m_request_buf;</pre></div></li><li class="listitem" style="list-style-type: disc">A socket object used to communicate with the server:<div><pre class="programlisting">  asio::ip::tcp::socket m_sock;</pre></div></li><li class="listitem" style="list-style-type: disc">A resolver object used to resolve the DNS name of the server host provided by the user:<div><pre class="programlisting">  asio::ip::tcp::resolver m_resolver;</pre></div></li><li class="listitem" style="list-style-type: disc">An instance of the <code class="literal">HTTPResponse</code> class that represents the response received from the server:<div><pre class="programlisting">  HTTPResponse m_response;</pre></div></li><li class="listitem" style="list-style-type: disc">A boolean flag and a <code class="literal">mutex</code> object supporting the request canceling functionality (which will be explained later):<div><pre class="programlisting">  bool m_was_cancelled;
  std::mutex m_cancel_mux;</pre></div></li><li class="listitem" style="list-style-type: disc">Also, a reference to an instance of the <code class="literal">asio::io_service</code> class required by resolver and socket objects. The single instance of the <code class="literal">asio::io_service</code> class is maintained by an object of the <code class="literal">HTTPClient</code> class:<div><pre class="programlisting">  asio::io_service&amp; m_ios;</pre></div></li></ul></div><p>An instance of <a id="id284" class="indexterm"/>the <code class="literal">HTTPRequest</code> object represents a single HTTP <code class="literal">GET</code> request. The class is designed so that in order to send a request, two steps need to be performed. Firstly, the parameters of the request and the callback function to be called when the request completes are set by calling the corresponding setter methods on the object. Then, as a second step, the <a id="id285" class="indexterm"/>
<code class="literal">execute()</code> method is invoked to initiate the request execution. When the request completes, the callback function is called.</p><p>The <code class="literal">set_host()</code>, <code class="literal">set_port()</code>, <code class="literal">set_uri()</code>, and <code class="literal">set_callback()</code> setter methods allow setting a server host DNS name and port number, URI of the requested resource, and a callback function to be called when the request completes. Each of these methods accepts one argument and stores its value in the corresponding <code class="literal">HTTPRequest</code> object's data member.</p><p>The <code class="literal">get_host()</code>, <code class="literal">get_port()</code>, and<code class="literal"> get_uri()</code> getter methods return values set by corresponding setter methods. The <code class="literal">get_id()</code> getter method<a id="id286" class="indexterm"/> returns a request object's unique identifier, which is passed to the object's constructor on instantiation.</p><p>The <code class="literal">execute()</code> method begins the execution of a request by initiating a sequence of asynchronous operations. Each asynchronous operation performs one step of request execution procedure.</p><p>Because a server host in the request object is represented with a DNS name (rather than with an IP address), before sending the request message to the server, the specified DNS name must be resolved and transformed into an IP address. Therefore, the first step in the request execution is DNS name resolution. The <code class="literal">execute()</code> method<a id="id287" class="indexterm"/> begins with preparing the resolving query and then calls the resolver object's <code class="literal">async_resolve()</code> method, specifying the <code class="literal">HTTPRequest</code> class' <code class="literal">on_host_name_resolve()</code> private method as an operation completion callback.</p><p>When the server host DNS name is resolved, the <code class="literal">on_host_name_resolved()</code> method is called. This method is passed two arguments: the first of which is an error code, designating the status of the <a id="id288" class="indexterm"/>operation, and the second one is the iterator that can be used to iterate through a list of endpoints resulting from a resolution process.</p><p>The <code class="literal">on_host_name_resolved()</code> method<a id="id289" class="indexterm"/> initiates the next asynchronous operation in a sequence, namely socket connection, by calling <code class="literal">asio::async_connect()</code> free function passing socket object <code class="literal">m_sock</code> and iterator parameter to it so that it connects the socket to the first valid endpoint. The <code class="literal">on_connection_established()</code> method is <a id="id290" class="indexterm"/>specified as an asynchronous connection operation completion callback.</p><p>When an asynchronous connection operation completes, the <code class="literal">on_connection_established()</code> method is invoked. The first argument passed to it is named <code class="literal">ec</code> that designates the operation completion status. If its value is equal to zero, it means that the socket was successfully connected to one of the endpoints. The <code class="literal">on_connection_established()</code> method constructs the HTTP <code class="literal">GET</code> request message using request parameters stored in the corresponding data members of the <code class="literal">HTTPRequest</code> object. Then, the <code class="literal">asio::async_write()</code> free function is called to asynchronously send a constructed HTTP request message to the server. The class' private method <code class="literal">on_request_sent()</code> is specified as a callback to be called when the <code class="literal">asio::async_write()</code> operation completes.</p><p>After a request is sent, and if it is sent successfully, the client application has to let the server know that the full request is sent and the client is not going to send anything else by shutting down the send part of the socket. Then, the client has to wait for the response message from the server. And this is what the <code class="literal">on_request_sent()</code> method does. Firstly, it calls the socket object's <code class="literal">shutdown()</code> method, specifying that the send part should be closed by the passing value <code class="literal">asio::ip::tcp::socket::shutdown_send</code> to the method as an argument. Then, it calls the <code class="literal">asio::async_read_until()</code> free function to receive a response from the server.</p><p>Because the response may be potentially very big and we do not know its size beforehand, we do not want to read it all at once. We first want to read the <strong>HTTP response status line</strong>
<a id="id291" class="indexterm"/> only; then, having analyzed it, either continue reading the rest of the response (if we think we need it) or discard it. Therefore, we pass the <code class="literal">\r\n</code> symbols sequence, designating the end of the HTTP response status line as a delimiter argument to the <code class="literal">asio::async_read_until()</code> method. The <code class="literal">on_status_line_received()</code> method is specified as an operation completion callback.</p><p>When the status line is received, the <code class="literal">on_status_line_received()</code> method is invoked. This method performs parsing of the status line, extracting values designating the HTTP protocol version, response status code, and response status message from it. Each value is analyzed for correctness. We expect the HTTP version to be 1.1, otherwise the response is considered incorrect and the request execution is interrupted. The status code should be an integer value. If the string-to-integer conversion fails, the response is considered incorrect and its further processing is interrupted too. If the response status line is correct, the request <a id="id292" class="indexterm"/>execution continues. The extracted status code and status message are stored in the <code class="literal">m_response</code> member object, and the next asynchronous operation in the request execution operation sequence is initiated. Now, we want to read the response headers block.</p><p>According to the HTTP protocol, the response headers block ends with the <code class="literal">\r\n\r\n</code> symbols sequence. Therefore, in order to read it, we call the <code class="literal">asio::async_read_until()</code> free function one more time, specifying the string <code class="literal">\r\n\r\n</code> as a delimiter. The <code class="literal">on_headers_received()</code> method is specified as a callback.</p><p>When the response headers block is received, the <code class="literal">on_headers_received()</code> method is invoked. In this method, the response headers block is parsed and broken into separate name-value pairs and stored in the <code class="literal">m_response</code> member object as a part of the response.</p><p>Having received and parsed the headers, we want to read the last part of the response—the response body. To do this, an asynchronous reading operation is initiated by calling the <code class="literal">asio::async_read()</code> free function. The <code class="literal">on_response_body_received()</code> method is specified as a callback.</p><p>Eventually, the <code class="literal">on_response_body_received()</code> method is invoked notifying us of the fact that the whole response message has been received. Because the HTTP server may shutdown the send part of its socket just after it sends the last part of the response message, on the client side, the last reading operation may complete with an error code equal to the <code class="literal">asio::error::eof</code> value. This should not be treated as an actual error, but rather as a normal event. Therefore, if the <code class="literal">on_response_body_received()</code> method is called with the <code class="literal">ec</code> argument equal to <code class="literal">asio::error::eof</code>, we pass the default constructed object of the <code class="literal">boost::system::error_code</code> class to the <code class="literal">on_finish()</code> method in order to designate that the request execution is completed successfully. Otherwise, the <code class="literal">on_finish()</code> method is called with an argument representing the original error code. The <code class="literal">on_finish()</code> method in its turn calls the callback provided by the client of the <code class="literal">HTTPRequest</code> class object.</p><p>When the callback returns, request processing is considered finished.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec47"/>The HTTPResponse class</h3></div></div></div><p>The<a id="id293" class="indexterm"/> <code class="literal">HTTPResponse</code> class does not provide much functionality. It is more like a plain data structure containing data members representing different parts of a response, with getter and setter methods defined, allowing getting and setting corresponding data member values.</p><p>All setter methods are private and only the objects of the <code class="literal">HTTPRequest</code> class has access to them (recall that the <code class="literal">HTTPRequest</code> class is declared as the <code class="literal">HTTPResponse</code> class' friend). Each object of the <code class="literal">HTTPRequest</code> class has a data member that is an instance of the <code class="literal">HTTPResponse</code> class. The object of the <code class="literal">HTTPRequest</code> class sets values of its member object <a id="id294" class="indexterm"/>of <code class="literal">HTTPResponse</code> class as it receives and parses the response received from a HTTP server.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec48"/>Callback and the main() entry point functions</h3></div></div></div><p>These functions <a id="id295" class="indexterm"/>demonstrate how to use the <code class="literal">HTTPClient</code> and <code class="literal">HTTPRequest</code> classes in order to send the <code class="literal">GET</code> HTTP requests to the HTTP server and then how to use the <code class="literal">HTTPResponse</code> class to obtain the response.</p><p>The <code class="literal">main()</code> function <a id="id296" class="indexterm"/>first creates an instance of the <code class="literal">HTTPClient</code> class and then uses it to create two instances of the <code class="literal">HTTPRequest</code> class, each representing a separate <code class="literal">GET</code> HTTP request. Both request objects are provided with request parameters and then executed. However, just after the second request has been executed, the first one is canceled by invoking its <code class="literal">cancel()</code> method.</p><p>The <code class="literal">handler()</code> function, which<a id="id297" class="indexterm"/> is used as a completion callback for both request objects created in the <code class="literal">main()</code> function, is invoked when each request completes regardless of whether it succeeded, failed, or was canceled. The <code class="literal">handler()</code> function analyses the error code and the request and response objects passed to it as arguments and output corresponding messages to the standard output stream.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec96"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Implementing asynchronous TCP client</em> recipe from <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, provides more information on how to implement an asynchronous TCP client.</li><li class="listitem" style="list-style-type: disc">The <em>Using timers</em> recipe from <a class="link" href="ch06.html" title="Chapter 6. Other Topics">Chapter 6</a>, <em>Other Topics</em>, demonstrates how to use timers provided by Boost.Asio. Timers can be used to implement an asynchronous operation timeout mechanism.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Implementing the HTTP server application</h1></div></div></div><p>Nowadays, there <a id="id298" class="indexterm"/>are plenty of HTTP server applications available in the market. However, sometimes there is a need to implement a custom one. This could be a small and simple server, supporting a specific subset of HTTP protocol possibly with custom extensions, or maybe not an HTTP server but a server supporting a communication protocol, which is similar to HTTP or is based on it.</p><p>In this recipe, we <a id="id299" class="indexterm"/>will consider the implementation of basic HTTP server application using Boost.Asio. Here is the set of requirements that our application must satisfy:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It should support the HTTP 1.1 protocol</li><li class="listitem" style="list-style-type: disc">It should support the <code class="literal">GET</code> method</li><li class="listitem" style="list-style-type: disc">It should be able to process multiple requests in parallel, that is, it should be an asynchronous parallel server</li></ul></div><p>In fact, we have already considered the implementation of the server application that partially fulfils specified requirements. In <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, the recipe named <em>Implementing an asynchronous TCP server</em> demonstrates how to implement an asynchronous parallel TCP server, which communicates with clients according to a dummy application layer protocol. All the communication functionality and protocol details are encapsulated in a single class named <code class="literal">Service</code>. All other classes and functions defined in that recipe are infrastructural in their purpose and isolated from the protocol details. Therefore, the current recipe will be based on the one from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, and here we will only consider the implementation of the <code class="literal">Service</code> class as all other components stay the same.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Note that, in this recipe, we do not consider the security aspect of the application. Make sure the server is protected before making it available to the public, where though operating correctly and in accordance with HTTP protocol, it could be compromised by the culprits due to security breaches.</p></div></div><p>Now let's move on to the implementation of the HTTP server application.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec97"/>Getting ready…</h2></div></div></div><p>Because the application demonstrated in this recipe is based on other applications demonstrated in the recipe named <em>Implementing asynchronous TCP server</em> from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, it is necessary to get acquainted with that recipe before proceeding with this one.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec98"/>How to do it…</h2></div></div></div><p>We begin our application by including header files containing declarations and definitions of data types and functions that we will use:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;boost/filesystem.hpp&gt;

#include &lt;fstream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Next, we start <a id="id300" class="indexterm"/>defining the <code class="literal">Service</code> class that provides the implementation of the HTTP protocol. Firstly, we declare a static constant table containing HTTP status codes and status messages. The definition of the table will be given after the <code class="literal">Service</code> class' definition:</p><div><pre class="programlisting">class Service {
  static const std::map&lt;unsigned int, std::string&gt;
http_status_table;</pre></div><p>The class' constructor accepts a single parameter—shared pointer pointing to an instance of a socket connected to a client. Here's the definition of the constructor:</p><div><pre class="programlisting">public:
  Service(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock) :
    m_sock(sock),
    m_request(4096),
    m_response_status_code(200), // Assume success.
    m_resource_size_bytes(0)
  {};</pre></div><p>Next, we define a single method constituting the <code class="literal">Service</code> class' public interface. This method initiates an asynchronous communication session with the client connected to the socket, pointer to which was passed to the <code class="literal">Service</code> class' constructor:</p><div><pre class="programlisting">  void start_handling() {
    asio::async_read_until(*m_sock.get(),
      m_request,
      "\r\n",
      [this](
      const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_request_line_received(ec,
        bytes_transferred);
    });
  }</pre></div><p>Then, we define a set of private methods that perform receiving and processing of the request sent by the client, parse and execute the request, and send the response back. Firstly, we define a method that processes the <a id="id301" class="indexterm"/>
<strong>HTTP request line</strong>:</p><div><pre class="programlisting">private:
  void on_request_line_received(
    const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred) 
{
    if (ec != 0) {
      std::cout &lt;&lt; "Error occured! Error code = "
        &lt;&lt; ec.value()
        &lt;&lt; ". Message: " &lt;&lt; ec.message();

      if (ec == asio::error::not_found) {
        // No delimiter has been found in the
        // request message.

        m_response_status_code = 413;
        send_response();

        return;
      }
      else {
        // In case of any other error –
        // close the socket and clean up.
        on_finish();
        return;
      }
    }

    // Parse the request line.
    std::string request_line;
    std::istream request_stream(&amp;m_request);
    std::getline(request_stream, request_line, '\r');
    // Remove symbol '\n' from the buffer.
    request_stream.get();

    // Parse the request line.
    std::string request_method;
    std::istringstream request_line_stream(request_line);
    request_line_stream &gt;&gt; request_method;

    // We only support GET method.
    if (request_method.compare("GET") != 0) {
      // Unsupported method.
      m_response_status_code = 501;
      send_response();

      return;
    }

    request_line_stream &gt;&gt; m_requested_resource;

    std::string request_http_version;
    request_line_stream &gt;&gt; request_http_version;

    if (request_http_version.compare("HTTP/1.1") != 0) {
      // Unsupported HTTP version or bad request.
      m_response_status_code = 505;
      send_response();

      return;
    }

    // At this point the request line is successfully
    // received and parsed. Now read the request headers.
    asio::async_read_until(*m_sock.get(),
      m_request,
      "\r\n\r\n",
      [this](
      const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_headers_received(ec,
        bytes_transferred);
    });

    return;
  }</pre></div><p>Next, we define a <a id="id302" class="indexterm"/>method intended to process and store the <a id="id303" class="indexterm"/>
<strong>request headers block</strong>, containing the request headers:</p><div><pre class="programlisting">  void on_headers_received(const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred)  
  {
    if (ec != 0) {
      std::cout &lt;&lt; "Error occured! Error code = "
        &lt;&lt; ec.value()
        &lt;&lt; ". Message: " &lt;&lt; ec.message();

      if (ec == asio::error::not_found) {
        // No delimiter has been fonud in the
        // request message.

        m_response_status_code = 413;
        send_response();
        return;
      }
      else {
        // In case of any other error - close the
        // socket and clean up.
        on_finish();
        return;
      }
    }

    // Parse and store headers.
    std::istream request_stream(&amp;m_request);
    std::string header_name, header_value;

    while (!request_stream.eof()) {
      std::getline(request_stream, header_name, ':');
      if (!request_stream.eof()) {
        std::getline(request_stream, 
        header_value, 
      '\r');

        // Remove symbol \n from the stream.
        request_stream.get();
        m_request_headers[header_name] =
        header_value;
      }
    }

    // Now we have all we need to process the request.
    process_request();
    send_response();

    return;
  }</pre></div><p>Besides, we need a method that can perform the actions needed to fulfill the request sent by the client. We define <a id="id304" class="indexterm"/>the <code class="literal">process_request()</code> method, whose purpose is to read the contents of the requested resource from the file system <a id="id305" class="indexterm"/>and store it in the buffer, ready to be sent back to the client:</p><div><pre class="programlisting">  void process_request() {
    // Read file.
    std::string resource_file_path =
    std::string("D:\\http_root") +
    m_requested_resource;

    if (!boost::filesystem::exists(resource_file_path)) {
      // Resource not found.
      m_response_status_code = 404;

      return;
    }

    std::ifstream resource_fstream(
    resource_file_path, 
    std::ifstream::binary);

    if (!resource_fstream.is_open()) {
      // Could not open file. 
      // Something bad has happened.
      m_response_status_code = 500;

      return;
    }

    // Find out file size.
    resource_fstream.seekg(0, std::ifstream::end);
    m_resource_size_bytes =
    static_cast&lt;std::size_t&gt;(
    resource_fstream.tellg());

    m_resource_buffer.reset(
    new char[m_resource_size_bytes]);

    resource_fstream.seekg(std::ifstream::beg);
    resource_fstream.read(m_resource_buffer.get(),
    m_resource_size_bytes);

    m_response_headers += std::string("content-length") +
      ": " +
      std::to_string(m_resource_size_bytes) +
      "\r\n";
  }</pre></div><p>Finally, we define a <a id="id306" class="indexterm"/>method that composes a response message and send it to the client:</p><div><pre class="programlisting">  void send_response()  {
    m_sock-&gt;shutdown(
    asio::ip::tcp::socket::shutdown_receive);

    auto status_line =
      http_status_table.at(m_response_status_code);

    m_response_status_line = std::string("HTTP/1.1 ") +
      status_line +
      "\r\n";

    m_response_headers += "\r\n";

    std::vector&lt;asio::const_buffer&gt; response_buffers;
    response_buffers.push_back(
    asio::buffer(m_response_status_line));
    
    if (m_response_headers.length() &gt; 0) {
      response_buffers.push_back(
      asio::buffer(m_response_headers));
    }

    if (m_resource_size_bytes &gt; 0) {
      response_buffers.push_back(
      asio::buffer(m_resource_buffer.get(),
      m_resource_size_bytes));
    }

    // Initiate asynchronous write operation.
    asio::async_write(*m_sock.get(),
      response_buffers,
      [this](
      const boost::system::error_code&amp; ec,
      std::size_t bytes_transferred)
    {
      on_response_sent(ec,
        bytes_transferred);
    });
  }</pre></div><p>When the response sending is complete, we need to shut down the socket to let the client know that a full response has been sent and no more data will be sent by the server. We define the <code class="literal">on_response_sent()</code> method for this purpose:</p><div><pre class="programlisting">  void on_response_sent(const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred) 
{
    if (ec != 0) {
      std::cout &lt;&lt; "Error occured! Error code = "
        &lt;&lt; ec.value()
        &lt;&lt; ". Message: " &lt;&lt; ec.message();
    }

    m_sock-&gt;shutdown(asio::ip::tcp::socket::shutdown_both);

    on_finish();
  }</pre></div><p>The last <a id="id307" class="indexterm"/>method we need to define is the one that performs cleanup and deletes an instance of the <code class="literal">Service</code> object, when the communication session is finished and the object is not needed anymore is not needed anymore:</p><div><pre class="programlisting">  // Here we perform the cleanup.
  void on_finish() {
    delete this;
  }</pre></div><p>Of course, we will need some data members in our class. We declare the following data members:</p><div><pre class="programlisting">private:
  std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; m_sock;
  boost::asio::streambuf m_request;
  std::map&lt;std::string, std::string&gt; m_request_headers;
  std::string m_requested_resource;

  std::unique_ptr&lt;char[]&gt; m_resource_buffer;  
  unsigned int m_response_status_code;
  std::size_t m_resource_size_bytes;
  std::string m_response_headers;
  std::string m_response_status_line;
};</pre></div><p>The last thing we need to do to complete the definition of the class representing a service is to define the <code class="literal">http_status_table</code> static member declared before and fill it with data—HTTP status code and corresponding status messages:</p><div><pre class="programlisting">const std::map&lt;unsigned int, std::string&gt;
  Service::http_status_table = 
{
  { 200, "200 OK" },
  { 404, "404 Not Found" },
  { 413, "413 Request Entity Too Large" },
  { 500, "500 Server Error" },
  { 501, "501 Not Implemented" },
  { 505, "505 HTTP Version Not Supported" }
};</pre></div><p>Our <code class="literal">Service</code> class is <a id="id308" class="indexterm"/>now ready.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec99"/>How it works…</h2></div></div></div><p>Let's begin with considering the <code class="literal">Service</code> class' data members and then switch to its functionality. The <code class="literal">Service</code> class contains the following non-static data members:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; m_sock</code>: This is a shared pointer to a TCP socket object connected to the client</li><li class="listitem" style="list-style-type: disc"><code class="literal">boost::asio::streambuf m_request</code>: This is a buffer into which the request message is read</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::map&lt;std::string, std::string&gt; m_request_headers</code>: This is a map where request headers are put when the HTTP request headers block is parsed</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::string m_requested_resource</code>: This is the URI of the resource requested by the client</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::unique_ptr&lt;char[]&gt; m_resource_buffer</code>: This is a buffer where the contents of a requested resource is stored before being sent to the client as a part of the response message</li><li class="listitem" style="list-style-type: disc"><code class="literal">unsigned int m_response_status_code</code>: This is the HTTP response status code</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::size_t m_resource_size_bytes</code>: This is the size of the contents of the requested resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::string m_response_headers</code>: This is a string containing a properly formatted response headers block</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::string m_response_status_line</code>: This contains a response status line</li></ul></div><p>Now that we know the purpose of the <code class="literal">Service</code> class' data members, let's trace how it works. Here, we will only consider how the <code class="literal">Service</code> class works. The description of all other components of the server application and how they work is given in the recipe named <em>Implementing an asynchronous TCP server</em> in <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>.</p><p>When a client sends a TCP connection request and this request is accepted on the server (this happens in the <code class="literal">Acceptor</code> class, which is not considered in this recipe), an instance of the <code class="literal">Service</code> class is created and its constructor is passed a shared pointer pointing to the TCP socket object, connected to that client. The pointer to the socket is stored in the <code class="literal">Service</code> object's data member <code class="literal">m_sock</code>.</p><p>Besides, during the construction of the <code class="literal">Service</code> object, the <code class="literal">m_request</code> stream buffer member is initialized with the value of 4096, which sets the maximum size of the buffer in bytes. Limiting the size of the request buffer is a security measure, which helps to protect the server from malicious clients that may try to send very long dummy request messages exhausting all memory at the disposal of the server application. For the correct request, a buffer of 4096 bytes in size is more than enough.</p><p>After an <a id="id309" class="indexterm"/>instance of the <code class="literal">Service</code> class has been constructed, its <code class="literal">start_handling()</code> method is called by the <code class="literal">Acceptor</code> class. From this method, the sequence of asynchronous method invocations begins, which performs request receiving, processing, and response sending. The <code class="literal">start_handling()</code> method immediately initiates an asynchronous reading operation calling the <code class="literal">asio::async_read_until()</code> function in order to receive the HTTP request line sent by the client. The <code class="literal">on_request_line_received()</code> method is specified as a callback.</p><p>When the <code class="literal">on_request_line_received()</code> method is invoked, we first check the error code specifying the operation completion status. If the status code is not equal to zero, we consider two options. The first option—when the error code is equal to the <code class="literal">asio::error::not_found</code> value—means that more bytes have been received from the client than the size of the buffer and the delimiter of the HTTP request line (the <code class="literal">\r\n</code> symbol sequence) has not been encountered. This case is described by the HTTP status code 413. We set the value of the <code class="literal">m_response_status_code</code> member variable to 413 and call the <code class="literal">send_response()</code> method that initiates the operation that sends a response designating the error back to the client. We will consider the <code class="literal">send_response()</code> method later in this section. At this point, the request processing is finished.</p><p>If the error code neither designates success nor is equal to <code class="literal">asio::error::not_found</code>, it means that some other error has occurred from which we cannot recover, therefore, we just output the information about the error and do not reply to the client at all. The <code class="literal">on_finish()</code> method is called to perform the cleanup, and the communication with the client is interrupted.</p><p>Finally, if receiving of the HTTP request line succeeds, it is parsed to extract the HTTP request method, the URI identifying the requested resource and the HTTP protocol version. Because our sample server only supports the <code class="literal">GET</code> method, if the method specified in the request line is different from <code class="literal">GET</code>, further request processing is interrupted and the response containing the error code 501 is sent to the client to inform it that the method specified in the request is not supported by the server.</p><p>Likewise, the HTTP protocol version specified by the client in the HTTP request line is checked to be the one supported by the server. Because our server application supports only version 1.1, if the version specified by the client is different, the response with the HTTP status code 505 is sent to the client and the request processing is interrupted.</p><p>A URI string extracted from the HTTP request line is stored in the <code class="literal">m_requested_resource</code> data member and will be used later.</p><p>When the HTTP request <a id="id310" class="indexterm"/>line is received and parsed, we continue reading the request message in order to read the request headers block. To do this, the <code class="literal">asio::async_read_until()</code> function is called. Because the request headers block ends with the <code class="literal">\r\n\r\n</code> symbol sequence, this symbol sequence is passed to the function as a delimiter argument. The <code class="literal">on_headers_received()</code> method is specified as an operation completion callback.</p><p>The <code class="literal">on_headers_received()</code> method performs error checking similar to the one that is performed in the <code class="literal">on_request_line_received()</code> method. In case of an error, request processing interrupts. In the case of success, the HTTP request headers block is parsed and broken into separate name-value pairs, which are then stored in the <code class="literal">m_request_headers</code> member map. After the headers block has been parsed, the <code class="literal">process_request()</code> and <code class="literal">send_response()</code> methods are called consequently.</p><p>The purpose of the <code class="literal">process_request()</code> method is to read the file specified in the request as the URI and put its content to the buffer, from which the contents will be sent to the client as a part of the response message. If the specified file is not found in the server root directory, the HTTP status code 404 (page not found) code is sent to the client as a part of the response message and the request processing interrupts.</p><p>However, if the requested file is found, its size is first calculated and then the buffer of the corresponding size is allocated in the free memory and the file contents are read in that buffer.</p><p>After this, an HTTP header named <em>content-length</em> specifying the size of the response body is added to the <code class="literal">m_response_headers</code> string data member. This data member represents the response headers block and its value will later be used as a part of the response message.</p><p>At this point, all ingredients required to construct the HTTP response message are available and we can move on to preparing and sending the response to the client. This is done in the <code class="literal">send_response()</code> method.</p><p>The <code class="literal">send_response()</code> method starts with shutting down the receive side of the socket letting the client know that the server will not read any data from it anymore. Then, it extracts the response status message corresponding to the status code stored in the <code class="literal">m_response_status_code</code> member variable from the <code class="literal">http_status_table</code> static table.</p><p>Next, the HTTP response status line is constructed and the headers block is appended with the delimiting symbol sequence <code class="literal">\r\n</code> according to the HTTP protocol. At this point, all the components of the response message—the response status line, response headers block, and response body—are ready to be sent to the client. The components are combined in the form of a vector of buffers, each represented with an instance of the <code class="literal">asio::const_buffer</code> class and <a id="id311" class="indexterm"/>containing one component of the response message. A vector of buffers embodies a composite buffer consisting of three parts. When this composite buffer is constructed, it is passed to the <code class="literal">asio::async_write()</code> function to be sent to the client. The <code class="literal">Service</code> class' <code class="literal">on_response_sent()</code> method is specified as a callback.</p><p>When the response message is sent and the <code class="literal">on_response_sent()</code> callback method is invoked, it first checks the error code and outputs the log message if the operation fails; then, it shuts down the socket and calls the <code class="literal">on_finish()</code> method. The <code class="literal">on_finish()</code> method in its turn deletes the instance of the <code class="literal">Service</code> object in the context of which it is called.</p><p>At this point, client handling is finished.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec100"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Implementing an asynchronous TCP server</em> recipe from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, provides more information on how to implement the asynchronous TCP server used as a base for this recipe.</li><li class="listitem" style="list-style-type: disc">The <em>Using timers</em> recipe from <a class="link" href="ch06.html" title="Chapter 6. Other Topics">Chapter 6</a>, <em>Other Topics</em>, demonstrates how to use timers provided by Boost.Asio. Timers can be used to implement an asynchronous operation timeout mechanism.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Adding SSL/TLS support to client applications</h1></div></div></div><p>Client applications <a id="id312" class="indexterm"/>usually use SSL/TLS protocol to send sensitive data such as passwords, credit card numbers, personal data. SSL/TLS protocol allows clients to authenticate the server and encrypt the data. The authentication of the server allows the client to make sure that the data will be sent to the expected addressee (and not to a malicious one). Data encryption guarantees that even if the transmitted data is intercepted somewhere on its way to the server, the interceptor will not be able to use it.</p><p>This recipe demonstrates how to implement a synchronous TCP client application supporting SSL/TLS protocol using the Boost.Asio and OpenSSL libraries. The TCP client application demonstrated in the recipe named <em>Implementing synchronous TCP client</em> from <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, is taken as a base for this recipe, and some code changes and additions are made to it in order to add support for SSL/TLS protocol. The code that <a id="id313" class="indexterm"/>differs from that of the base implementation of the synchronous TCP client is <em>highlighted</em> so that the code directly related to SSL/TLS support is better distinguished from the rest of the code.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec101"/>Getting ready…</h2></div></div></div><p>Before setting out to this recipe, OpenSSL library must be installed and the project must be linked against it. Procedures related to the installation of the library or linking the project against it are beyond the scope of this book. Refer to the OpenSSL library documentation for more information.</p><p>Besides, because this recipe is based on another recipe named <em>Implementing a synchronous TCP Client</em> from <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, it is highly advised to get acquainted with it before proceeding to this one.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec102"/>How to do it…</h2></div></div></div><p>The following code sample demonstrates the possible implementation of a synchronous TCP client application supporting SSL/TLS protocol to authenticate the server and encrypt the data being transmitted.</p><p>We begin our application by adding the <code class="literal">include</code> and <code class="literal">using</code> directives:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
<strong>#include &lt;boost/asio/ssl.hpp&gt;</strong>
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>The <code class="literal">&lt;boost/asio/ssl.hpp&gt;</code> header contains types and functions providing integration with OpenSSL library.</p><p>Next, we define a class that plays the role of the synchronous SSL/TLS-enabled TCP client:</p><div><pre class="programlisting">class <strong>SyncSSLClient</strong> {
public:
  SyncSSLClient(const std::string&amp; raw_ip_address,
    unsigned short port_num) :
    m_ep(asio::ip::address::from_string(raw_ip_address),
    port_num),
    <strong>m_ssl_context(asio::ssl::context::sslv3_client),</strong>    
    <strong>m_ssl_stream</strong>(m_ios, <strong>m_ssl_context</strong>)
  {
<strong>    // Set verification mode and designate that </strong>
<strong>    // we want to perform verification.</strong>
<strong>    m_ssl_stream.set_verify_mode(asio::ssl::verify_peer);</strong>

<strong>    // Set verification callback. </strong>
<strong>    m_ssl_stream.set_verify_callback([this](</strong>
<strong>      bool preverified,</strong>
<strong>      asio::ssl::verify_context&amp; context)-&gt;bool{</strong>
<strong>      return on_peer_verify(preverified, context);</strong>
<strong>    });</strong>  
  }

  void connect() {
<strong>    // Connect the TCP socket.</strong>
<strong>    m_ssl_stream.lowest_layer().connect(m_ep);</strong>

<strong>    // Perform the SSL handshake.</strong>
<strong>    m_ssl_stream.handshake(asio::ssl::stream_base::client);</strong>
  }

  void close() {
    <strong>// We ignore any errors that might occur</strong>
<strong>    // during shutdown as we anyway can't</strong>
<strong>    // do anything about them.</strong>
<strong>    boost::system::error_code ec;</strong>

<strong>    m_ssl_stream.shutdown(ec); // Shutdown SSL.</strong>

<strong>    // Shut down the socket.</strong>
<strong>    m_ssl_stream.lowest_layer().shutdown(</strong>
<strong>      boost::asio::ip::tcp::socket::shutdown_both, ec);</strong>

<strong>    m_ssl_stream.lowest_layer().close(ec);</strong>
  }

  std::string emulate_long_computation_op(
    unsigned int duration_sec) {

    std::string request = "EMULATE_LONG_COMP_OP "
      + std::to_string(duration_sec)
      + "\n";

    send_request(request);
    return receive_response();
  };

private:
  <strong>bool on_peer_verify(bool preverified,</strong>
<strong>    asio::ssl::verify_context&amp; context) </strong>
<strong>  {</strong>
<strong>    // Here the certificate should be verified and the</strong>
<strong>    // verification result should be returned.</strong>
<strong>    return true;</strong>
<strong>  }</strong>

  void send_request(const std::string&amp; request) {
    asio::write(<strong>m_ssl_stream</strong>, asio::buffer(request));
  }

  std::string receive_response() {
    asio::streambuf buf;
    asio::read_until(<strong>m_ssl_stream</strong>, buf, '\n');

    std::string response;
    std::istream input(&amp;buf);
    std::getline(input, response);

    return response;
  }

private:
  asio::io_service m_ios;
  asio::ip::tcp::endpoint m_ep;

  <strong>asio::ssl::context m_ssl_context;</strong>
<strong>  asio::ssl::stream&lt;asio::ip::tcp::socket&gt;m_ssl_stream;</strong>
};</pre></div><p>Now we implement<a id="id314" class="indexterm"/> the <code class="literal">main()</code> application entry point function that uses the <code class="literal">SyncSSLClient</code> class to authenticate the server and securely communicate with it using SSL/TLS protocol:</p><div><pre class="programlisting">int main()
{
  const std::string raw_ip_address = "127.0.0.1";
  const unsigned short port_num = 3333;

  try {
    <strong>SyncSSLClient</strong> client(raw_ip_address, port_num);

    // Sync connect.
    client.connect();

    std::cout &lt;&lt; "Sending request to the server... "
      &lt;&lt; std::endl;

    std::string response =
      client.emulate_long_computation_op(10);

    std::cout &lt;&lt; "Response received: " &lt;&lt; response
      &lt;&lt; std::endl;

    // Close the connection and free resources.
    client.close();
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec103"/>How it works…</h2></div></div></div><p>The sample client application <a id="id315" class="indexterm"/>consists of two main components: the <code class="literal">SyncSSLClient</code> class and a <code class="literal">main()</code> application entry point function that uses the <code class="literal">SyncSSLClient</code> class to communicate with the server application over SSL/TLS protocol. Let's consider how each component works separately.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec49"/>The SyncSSLClient class</h3></div></div></div><p>The <a id="id316" class="indexterm"/>
<code class="literal">SyncSSLClient</code> class is the key component in our application. It implements the communication functionality.</p><p>The class has four private data members as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">asio::io_service m_ios</code>: This is an object providing access to the operating system's communication services that are used by the socket object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">asio::ip::tcp::endpoint m_ep</code>: This is an endpoint designating the server application.</li><li class="listitem" style="list-style-type: disc"><code class="literal">asio::ssl::context m_ssl_context</code>: This is an object representing SSL context; basically, this is a wrapper around the <code class="literal">SSL_CTX</code> data structure defined by OpenSSL library. This object contains global settings and parameters used by other objects and functions involved in the process of communication using SSL/TLS protocol.</li><li class="listitem" style="list-style-type: disc"><code class="literal">asio::ssl::stream&lt;asio::ip::tcp::socket&gt; m_ssl_stream</code>: This represents a stream that wraps a TCP socket object and implements all SSL/TLS communication operations.</li></ul></div><p>Each object <a id="id317" class="indexterm"/>of the class is intended to communicate with a single server. Therefore, the class' constructor accepts an IP address and a protocol port number designating the server application as its input arguments. These values are used to instantiate the <code class="literal">m_ep</code> data member in the constructor's initialization list.</p><p>Next, the <code class="literal">m_ssl_context</code> and <code class="literal">m_ssl_stream</code> members of the <code class="literal">SyncSSLClient</code> class are instantiated. We pass the <code class="literal">asio::ssl::context::sslv23_client</code> value to the <code class="literal">m_ssl_context</code> object's constructor to designate that the context will be used by the application playing a role of a <em>client</em> only and that we want to support multiple secure protocols including multiple versions of SSL and TLS. This value defined by Boost.Asio corresponds to a value representing a connection method returned by the <code class="literal">SSLv23_client_method()</code> function defined by OpenSSL library.</p><p>The SSL stream object <code class="literal">m_ssl_stream</code> is set up in the <code class="literal">SyncSSLClient</code> class' constructor. Firstly, the peer verification mode is set to <code class="literal">asio::ssl::verify_peer</code>, which means that we want to perform peer verification during a handshake. Then, we set a verification callback method that will be called when certificates arrive from the server. The callback is invoked once for each certificate in the certificates chain sent by the server.</p><p>The class' <code class="literal">on_peer_verify()</code> method that is set as a peer verification callback is a dummy in our application. The certificate verification process lies beyond the scope of this book. Therefore, the function simply always returns the <code class="literal">true</code> constant, meaning that the certificate verification succeeded without performing the actual verification.</p><p>The three public methods comprise the interface of the <code class="literal">SyncSSLClient</code> class. The method named <code class="literal">connect()</code> performs two operations. Firstly, the TCP socket is connected to the server. The socket underlying the SSL stream is returned by the method of the SSL stream object <code class="literal">lowest_layer()</code>. Then, the <code class="literal">connect()</code> method is called on the socket with <code class="literal">m_ep</code> being passed as an argument designating the endpoint to be connected to:</p><div><pre class="programlisting">
<strong>// Connect the TCP socket.</strong>
<strong>m_ssl_stream.lowest_layer().connect(m_ep);</strong>
</pre></div><p>After the TCP connection is established, the <code class="literal">handshake()</code> method is called on the SSL stream object, which leads to the initiation of the handshake process. This method is synchronous and does not return until the handshake completes or an error occurs:</p><div><pre class="programlisting">
<strong>// Perform the SSL handshake.</strong>
<strong>m_ssl_stream.handshake(asio::ssl::stream_base::client);</strong>
</pre></div><p>After the <code class="literal">handshake()</code> method returns, both TCP and SSL (or TLS, depending on which protocol was agreed upon during the handshake process) connections are established and the effective communication can be performed.</p><p>The <code class="literal">close()</code> method shuts down the SSL connection by calling the <code class="literal">shutdown()</code> method on the SSL stream object. The <code class="literal">shutdown()</code> method is synchronous and blocks until the SSL connection is shut down or an error occurs. After this method returns, the corresponding SSL stream object cannot be used to transmit the data anymore.</p><p>The third interface <a id="id318" class="indexterm"/>method is <code class="literal">emulate_long_computation_op(unsigned int duration_sec)</code>. This method is where the I/O operations are performed. It begins with preparing the request string according to the application layer protocol. Then, the request is passed to the class' <code class="literal">send_request(const std::string&amp; request)</code> private method, which sends it to the server. When the request is sent and the <code class="literal">send_request()</code> method returns, the <code class="literal">receive_response()</code> method is called to receive the response from the server. When the response is received, the <code class="literal">receive_response()</code> method returns the string containing the response. After this, the <code class="literal">emulate_long_computation_op()</code> method returns the response message to its caller.</p><p>Note that the <code class="literal">emulate_long_computation_op()</code>, <code class="literal">send_request()</code>, and <code class="literal">receive_response()</code> methods are almost identical to the corresponding methods defined in the <code class="literal">SyncTCPClient</code> class, which is a part of the synchronous TCP client application demonstrated in <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, which we used as a base for <code class="literal">SyncSSLClient</code> class. The only difference is that in <code class="literal">SyncSSLClient</code>, an <em>SSL stream object</em> is passed to the corresponding Boost.Asio I/O functions, while in the <code class="literal">SyncTCPClient</code> class, a <em>socket object</em> is passed to those functions. Other aspects of the mentioned methods are identical.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec50"/>The main() entry point function</h3></div></div></div><p>This<a id="id319" class="indexterm"/> function acts as a user of the <code class="literal">SyncSSLClient</code> class. Having obtained the server IP address and protocol port number, it instantiates and uses the object of the <code class="literal">SyncSSLClient</code> class to authenticate and securely communicate with the server in order to consume its service, namely, to emulate an operation on the server by performing dummy calculations for 10 seconds. The code of this function is simple and self-explanatory; thus, requires no additional comments.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec104"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Implementing a synchronous TCP client</em> recipe from <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, provides more information on how to implement a synchronous TCP client used as a base for this recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Adding SSL/TLS support to server applications</h1></div></div></div><p>SSL/TLS protocol <a id="id320" class="indexterm"/>support is usually added to the server application when the services it provides assumes transmission of sensitive data such as passwords, credit card <a id="id321" class="indexterm"/>numbers, personal data, and so on, by the client to the server. In this case, adding SSL/TLS protocol support to the server allows clients to authenticate the server and establish a secure channel to make sure that the sensitive data is protected while being transmitted.</p><p>Sometimes, a server application may want to use SSL/TLS protocol to authenticate the client; however, this is rarely the case and usually other methods are used to ensure the authenticity of the client (for example, username and password are specified when logging into a mail server).</p><p>This recipe demonstrates how to implement a synchronous iterative TCP server application supporting SSL/TLS protocol using the Boost.Asio and OpenSSL libraries. The synchronous iterative TCP server application demonstrated in the recipe named <em>Implementing a synchronous iterative TCP server</em> from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, is taken as a base for this recipe and some code changes and additions are made to it in order to add support for SSL/TLS protocol. The code that differs from that of the base implementation of the synchronous iterative TCP server is <em>highlighted</em> so that the code directly related to SSL/TLS support is better distinguished from the rest of the code.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec105"/>Getting ready…</h2></div></div></div><p>Before setting out to this recipe, OpenSSL library must be installed and the project must be linked against it. Procedures related to the installation of the library or linking the project against it are beyond the scope of this book. Refer to the official OpenSSL documentation for more information.</p><p>Besides, because this recipe is based on another recipe named <em>Implementing a synchronous iterative TCP server</em>, from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, it is highly advised to get acquainted with it before proceeding to this one.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec106"/>How to do it…</h2></div></div></div><p>The following code sample demonstrates the possible implementation of a synchronous TCP server application supporting SSL/TLS protocol to allow client applications to authenticate the server and protect the data being transmitted.</p><p>We begin our application by including Boost.Asio library headers and headers of some components of standard C++ libraries that we will need to implement in our application:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
<strong>#include &lt;boost/asio/ssl.hpp&gt;</strong>

#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>The <code class="literal">&lt;boost/asio/ssl.hpp&gt;</code> header contains types and functions providing integration with OpenSSL library.</p><p>Next, we <a id="id322" class="indexterm"/>define a class responsible for handling a single client by reading the request message, processing it, and then sending back the response message. This class represents a single service provided by the server application and is named correspondingly—<code class="literal">Service</code>:</p><div><pre class="programlisting">class Service {
public:
  Service(){}

  void handle_client(
  <strong>asio::ssl::stream&lt;asio::ip::tcp::socket&gt;&amp; ssl_stream</strong>) 
  {
    try {
      <strong>// Blocks until the handshake completes.</strong>
<strong>      ssl_stream.handshake(</strong>
<strong>        asio::ssl::stream_base::server);</strong>

      asio::streambuf request;
      asio::read_until(<strong>ssl_stream</strong>, request, '\n');

      // Emulate request processing.
      int i = 0;
      while (i != 1000000)
        i++;
      std::this_thread::sleep_for(
        std::chrono::milliseconds(500));

      // Sending response.
      std::string response = "Response\n";
      asio::write(<strong>ssl_stream</strong>, asio::buffer(response));
    }
    catch (system::system_error &amp;e) {
      std::cout &lt;&lt; "Error occured! Error code = "
        &lt;&lt; e.code() &lt;&lt; ". Message: "
        &lt;&lt; e.what();
    }
  }
};</pre></div><p>Next, we define another class that represents a high-level <em>acceptor </em>concept (as compared to the low-level acceptor represented by the <code class="literal">asio::ip::tcp::acceptor</code> class). This class is responsible <a id="id323" class="indexterm"/>for accepting connection requests arriving from clients and instantiating objects of the <code class="literal">Service</code> class, which will provide the service to connected clients. This class is called <code class="literal">Acceptor</code>:</p><div><pre class="programlisting">class Acceptor {
public:
  Acceptor(asio::io_service&amp; ios, unsigned short port_num) :
    m_ios(ios),
    m_acceptor(m_ios,
    asio::ip::tcp::endpoint(
    asio::ip::address_v4::any(),
    port_num)),
    <strong>m_ssl_context(asio::ssl::context::sslv23_server)</strong>
  {
    <strong>// Setting up the context.</strong>
<strong>    m_ssl_context.set_options(</strong>
<strong>      boost::asio::ssl::context::default_workarounds</strong>
<strong>      | boost::asio::ssl::context::no_sslv2</strong>
<strong>      | boost::asio::ssl::context::single_dh_use);</strong>

<strong>    m_ssl_context.set_password_callback(</strong>
<strong>      [this](std::size_t max_length,</strong>
<strong>      asio::ssl::context::password_purpose purpose)</strong>
<strong>      -&gt; std::string </strong>
<strong>        {return get_password(max_length, purpose);}</strong>
<strong>    );</strong>

<strong>    m_ssl_context.use_certificate_chain_file("server.crt");</strong>
<strong>    m_ssl_context.use_private_key_file("server.key",</strong>
<strong>      boost::asio::ssl::context::pem);</strong>
<strong>    m_ssl_context.use_tmp_dh_file("dhparams.pem");</strong>

    // Start listening for incoming connection requests.
    m_acceptor.listen();
  }

  void accept() {
    <strong>asio::ssl::stream&lt;asio::ip::tcp::socket&gt;</strong>
<strong>    ssl_stream(m_ios, m_ssl_context);</strong>

    m_acceptor.accept(<strong>ssl_stream.lowest_layer()</strong>);

    Service svc;
    svc.handle_client(<strong>ssl_stream</strong>);
  }

private:
  <strong>std::string get_password(std::size_t max_length,</strong>
<strong>    asio::ssl::context::password_purpose purpose) const</strong>
<strong>  {</strong>
<strong>    return "pass";</strong>
<strong>  }</strong>

private:
  asio::io_service&amp; m_ios;
  asio::ip::tcp::acceptor m_acceptor;

  <strong>asio::ssl::context m_ssl_context;</strong>
};</pre></div><p>Now we define <a id="id324" class="indexterm"/>a class that represents the server itself. The class is named correspondingly—<code class="literal">Server</code>:</p><div><pre class="programlisting">class Server {
public:
  Server() : m_stop(false) {}

  void start(unsigned short port_num) {
    m_thread.reset(new std::thread([this, port_num]() {
      run(port_num);
    }));
  }

  void stop() {
    m_stop.store(true);
    m_thread-&gt;join();
  }

private:
  void run(unsigned short port_num) {
    Acceptor acc(m_ios, port_num);

    while (!m_stop.load()) {
      acc.accept();
    }
  }

  std::unique_ptr&lt;std::thread&gt; m_thread;
  std::atomic&lt;bool&gt; m_stop;
  asio::io_service m_ios;
};</pre></div><p>Eventually, we <a id="id325" class="indexterm"/>implement the<code class="literal"> main()</code> application entry point function that demonstrates how to use the <code class="literal">Server</code> class. This function is identical to the one defined in the recipe from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, that we took as a base for this recipe:</p><div><pre class="programlisting">int main()
{
  unsigned short port_num = 3333;

  try {
    Server srv;
    srv.start(port_num);

    std::this_thread::sleep_for(std::chrono::seconds(60));

    srv.stop();
  }
  catch (system::system_error &amp;e) {
    std::cout   &lt;&lt; "Error occured! Error code = " 
    &lt;&lt; e.code() &lt;&lt; ". Message: "
        &lt;&lt; e.what();
  }

  return 0;
}</pre></div><p>Note that the last two components of the server application, namely, the <code class="literal">Server</code> class and the<code class="literal"> main()</code> application entry point function are identical to the corresponding components defined in the recipe from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, that we took as a base for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec107"/>How it works…</h2></div></div></div><p>The sample server application consists of four components: the <code class="literal">Service</code>, <code class="literal">Acceptor</code>, and <code class="literal">Server</code> classes and the <code class="literal">main()</code>, application entry point function, which demonstrates how to use the <code class="literal">Server</code> class. Because the source code and the purpose of the <code class="literal">Server</code> class and the<code class="literal"> main()</code> entry point function are identical to those of the corresponding components defined in the recipe from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, that we took as a base for this recipe, we will not discuss them here. We will only consider the <code class="literal">Service</code> and <code class="literal">Acceptor</code> classes that were updated to provide support for SSL/TLS protocol.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec51"/>The Service class</h3></div></div></div><p>The <code class="literal">Service</code> class <a id="id326" class="indexterm"/>is the key functional component in the application. While other components are infrastructural in their purpose, this class implements the actual function (or service) required by the clients.</p><p>The <code class="literal">Service</code> class is quite simple and consists of a single method <code class="literal">handle_client()</code>. As its input argument, this method accepts a reference to an object representing an SSL stream that wraps a TCP socket connected to a particular client.</p><p>The method begins with performing an <a id="id327" class="indexterm"/>SSL/TLS <strong>handshake</strong> by invoking the <code class="literal">handshake()</code> method on the <code class="literal">ssl_stream</code> object. This method is synchronous and does not return until the handshake completes or an error occurs.</p><p>After the handshake has completed, a request message is synchronously read from the SSL stream until a new line ASCII symbol <code class="literal">\n</code> is encountered. Then, the request is processed. In our sample application, request processing is trivial and dummy and consists in running a loop performing one million increment operations and then putting the thread to sleep for half a second. After this, the response message is prepared and sent back to the client.</p><p>Exceptions that may be thrown by the Boost.Asio functions and methods are caught and handled in the <code class="literal">handle_client()</code> method and are not propagated to the method's caller so that, if handling of one client fails, the server continues working.</p><p>Note that the <code class="literal">handle_client()</code> method is very similar to the corresponding method defined in the recipe <em>Implementing a synchronous iterative TCP server</em>, from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, that we took as a base for this recipe. The difference consists in the fact that in this recipe, the <code class="literal">handle_client()</code> method operates on an object representing an SSL stream as opposed to an object representing a TCP socket being operated on in the base implementation of the method. Besides, an additional operation—an SSL/TLS handshake—is performed in the method defined in this recipe.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec52"/>The Acceptor class</h3></div></div></div><p>The <a id="id328" class="indexterm"/>
<code class="literal">Acceptor</code> class is a part of the server application infrastructure. Each object of this class owns an instance of the <code class="literal">asio::ssl::context</code> class named <code class="literal">m_ssl_context</code>. This member represents an <a id="id329" class="indexterm"/>
<strong>SSL context</strong>. Basically, the <code class="literal">asio::ssl::contex</code> class is a wrapper around the <code class="literal">SSL_CTX</code> data structure defined by OpenSSL library. Objects of this class contain global settings and parameters used by other objects and functions involved in the process of communication using SSL/TLS protocol.</p><p>The <code class="literal">m_ssl_context</code> object, when instantiated, is passed a <code class="literal">asio::ssl::context::sslv23_server</code> value to its constructor to designate that the SSL context will be used by the application playing a role of a <em>server</em> only and that multiple secure protocols should be supported, including multiple versions of SSL and TLS. This value defined by Boost.Asio corresponds to a value representing a connection method returned by the <code class="literal">SSLv23_server_method()</code> function defined by OpenSSL library.</p><p>The SSL context is configured in the <code class="literal">Acceptor</code> class' constructor. The context options, password callback and files containing digital certificates, and private keys and Diffie-Hellman protocol parameters, are specified there.</p><p>After SSL context <a id="id330" class="indexterm"/>has been configured, the <code class="literal">listen()</code> method is called on the acceptor object in the <code class="literal">Acceptor</code> class' constructor to start listening for connection requests from the clients.</p><p>The <code class="literal">Acceptor</code> class exposes a single <code class="literal">accept()</code> public method. This method, when called, first instantiates an object of the <code class="literal">asio::ssl::stream&lt;asio::ip::tcp::socket&gt;</code> class named <code class="literal">ssl_stream</code>, representing an SSL/TLS communication channel with the underlying TCP socket. Then, the <code class="literal">accept()</code> method is called on the <code class="literal">m_acceptor</code> acceptor object to accept a connection. The TCP socket object owned by <code class="literal">ssl_stream</code>, returned by its <code class="literal">lowest_layer()</code> method, is passed to the <code class="literal">accept()</code> method as an input argument. When a new connection is established, an instance of the <code class="literal">Service</code> class is created and its <code class="literal">handle_client()</code> method is called, which performs communication with the client and request handling.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec108"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Implementing synchronous iterative TCP server</em> recipe from <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, provides more information on how to implement a synchronous TCP server used as a base for this recipe.</li></ul></div></div></div></body></html>