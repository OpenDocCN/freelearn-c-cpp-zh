<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 5. Filling the Tool Belt - a few More Gadgets"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/><span class="koboSpan" id="kobo.1.1">Chapter 5. Filling the Tool Belt - a few More Gadgets</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The last chapter established a firm ground for us to build on. </span><span class="koboSpan" id="kobo.2.2">It is time to take full advantage of it and finish what we started, by building a robust set of tools, ready to take on a wide variety of design problems.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to be covering these topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Implementation of selection options</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Design and programming of a tile selection window</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Management of entities</span></li></ul></div><p><span class="koboSpan" id="kobo.7.1">There is quite a lot of code to cover, so let us just jump into it!</span></p><div class="section" title="Planning the selection options"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/><span class="koboSpan" id="kobo.8.1">Planning the selection options</span></h1></div></div></div><p><span class="koboSpan" id="kobo.9.1">Versatile selection options are important when creating a responsive and useful application. </span><span class="koboSpan" id="kobo.9.2">Without them, any sort of software can feel unintuitive, clunky, or unresponsive at best. </span><span class="koboSpan" id="kobo.9.3">In this particular case, we are going to be dealing with selecting, copying, and placing tiles, entities, and particle emitters.</span></p><p><span class="koboSpan" id="kobo.10.1">Let us see what such an interface might look like:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_05_001.jpg" alt="Planning the selection options"/></span></div><p><span class="koboSpan" id="kobo.12.1">In order to get there, we need to create a flexible class, designed to be able to handle any possible combination of options and controls. </span><span class="koboSpan" id="kobo.12.2">Let us start by going over the most basic data types that are going to come in handy when developing this system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">enum class SelectMode{ Tiles, Entities, Emitters }; 
using NameList = std::vector&lt;std::pair&lt;std::string, bool&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.14.1">First, the selection mode needs to be enumerated. </span><span class="koboSpan" id="kobo.14.2">As shown in the preceding snippet, there are three modes we are going to be working with at the moment, although this list can easily be expanded in the future. </span><span class="koboSpan" id="kobo.14.3">The </span><code class="literal"><span class="koboSpan" id="kobo.15.1">NameList</span></code><span class="koboSpan" id="kobo.16.1"> data type is going to be used to store the contents of entity and particle directories. </span><span class="koboSpan" id="kobo.16.2">This is simply the return format for the utility function we are going to be relying on.</span></p><p><span class="koboSpan" id="kobo.17.1">With the data types out of the way, let us take a stab at creating the blueprint of our </span><code class="literal"><span class="koboSpan" id="kobo.18.1">SelectionOptions</span></code><span class="koboSpan" id="kobo.19.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.20.1">class GUI_SelectionOptions { 
public: 
  GUI_SelectionOptions(EventManager* l_eventManager, 
    GUI_Manager* l_guiManager, MapControls* l_controls, 
    GUI_MapTileSelector* l_selector, Map* l_map, TileMap* l_brush, 
    EntityManager* l_entityMgr, ParticleSystem* l_particles); 
  ~GUI_SelectionOptions(); 
 
  void Show(); 
  void Hide(); 
  void SetControlMode(ControlMode l_mode); 
  void SetSelectMode(SelectMode l_mode); 
  SelectMode GetSelectMode()const; 
  void SelectEntity(int l_id); 
  void SelectEmitter(Emitter* l_emitter); 
  sf::Vector2i GetSelectXRange() const; 
  sf::Vector2i GetSelectYRange() const; 
  unsigned int GetLowestLayer() const; 
  unsigned int GetHighestLayer() const; 
 
  void Update(); 
  void Draw(sf::RenderWindow* l_window); 
  bool MouseClick(const sf::Vector2f&amp; l_pos); 
  void MouseRelease(); 
  void Reset(); 
 
  void SelectModeSwitch(EventDetails* l_details); 
  void OpenTileSelection(EventDetails* l_details); 
  void SolidToggle(EventDetails* l_details); 
  void CopySelection(EventDetails* l_details); 
  void PlaceSelection(EventDetails* l_details); 
  void RemoveSelection(EventDetails* l_details); 
  void ToggleLayers(EventDetails* l_details); 
  void SelectionOptionsElevation(EventDetails* l_details); 
  void SaveOptions(EventDetails* l_details); 
private: 
  void SelectionElevationUpdate(); 
  void UpdateSelectDrawable(); 
  void UpdateTileSelection(); 
  void UpdateEntitySelection(); 
  void UpdateEmitterSelection(); 
  void DeleteSelection(bool l_deleteAll); 
  ... 
</span><span class="koboSpan" id="kobo.20.2">}; 
</span></pre><p><span class="koboSpan" id="kobo.21.1">In order to keep things simple, let us focus on talking about the methods we need first, before covering data members. </span><span class="koboSpan" id="kobo.21.2">As far as public methods go, we have pretty much the assortment anyone would expect. </span><span class="koboSpan" id="kobo.21.3">Alongside the </span><code class="literal"><span class="koboSpan" id="kobo.22.1">Show()</span></code><span class="koboSpan" id="kobo.23.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Hide()</span></code><span class="koboSpan" id="kobo.25.1"> methods, which are going to be used to manipulate the interface this class encapsulates, we pretty much only have a few setters and getters, used to manipulate the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">ControlMode</span></code><span class="koboSpan" id="kobo.27.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.28.1">SelectMode</span></code><span class="koboSpan" id="kobo.29.1">, select specific entities or particle emitters, and obtain tile selection ranges, as well as the range of layer visibility/selection. </span><span class="koboSpan" id="kobo.29.2">Additionally, this class also needs to provide plenty of callback methods for numerous controls of the interface we are working with.</span></p><p><span class="koboSpan" id="kobo.30.1">The private methods mainly consist of code used to update the interface and the visual representation of its selection onscreen, as well as methods for updating each possible mode the selection interface can be in. </span><span class="koboSpan" id="kobo.30.2">It's topped off by a private method </span><code class="literal"><span class="koboSpan" id="kobo.31.1">DeleteSelection()</span></code><span class="koboSpan" id="kobo.32.1">, which is going to be useful when removing tiles, entities, or particle emitters.</span></p><p><span class="koboSpan" id="kobo.33.1">Finally, let us take a gander at all of the data members that are going to be used to preserve the state of this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">class GUI_SelectionOptions { 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.34.2">// Selection data. 
  </span><span class="koboSpan" id="kobo.34.3">SelectMode m_selectMode; 
  sf::RectangleShape m_selectDrawable; 
  sf::Color m_selectStartColor; 
  sf::Color m_selectEndColor; 
  sf::Color m_entityColor; 
  sf::Color m_emitterColor; 
  sf::Vector2i m_selectRangeX; 
  sf::Vector2i m_selectRangeY; 
  bool m_selectUpdate; 
  // Entity and emitter select info. 
  </span><span class="koboSpan" id="kobo.34.4">int m_entityId; 
  C_Position* m_entity; 
  Emitter* m_emitter; 
  NameList m_entityNames; 
  NameList m_emitterNames; 
  // Selection range. 
  </span><span class="koboSpan" id="kobo.34.5">unsigned int m_layerSelectLow; 
  unsigned int m_layerSelectHigh; 
  // Interfaces. 
  </span><span class="koboSpan" id="kobo.34.6">GUI_Interface* m_selectionOptions; 
  MapControls* m_mapControls; 
  GUI_MapTileSelector* m_tileSelector; 
  // Class ties. 
  </span><span class="koboSpan" id="kobo.34.7">EventManager* m_eventManager; 
  GUI_Manager* m_guiManager; 
  Map* m_map; 
  TileMap* m_brush; 
  EntityManager* m_entityManager; 
  ParticleSystem* m_particleSystem; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.35.1">We start by storing the current selection mode, alongside the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">RectangleShape</span></code><span class="koboSpan" id="kobo.37.1"> object, used to visually represent the selection being made. </span><span class="koboSpan" id="kobo.37.2">In order to make our tools feel more responsive and lively, we are going to be providing a number of different colors, used to represent different states of selection. </span><span class="koboSpan" id="kobo.37.3">For example, the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">m_selectStartColor</span></code><span class="koboSpan" id="kobo.39.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.40.1">m_selectEndColor</span></code><span class="koboSpan" id="kobo.41.1"> data members are used to differentiate the tile selection that's still being made, and its final state, when the mouse button is released. </span><span class="koboSpan" id="kobo.41.2">In addition to colors, we also have two vector types that store the tile selection range for both axes, and a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.42.1">boolean</span></em></span><span class="koboSpan" id="kobo.43.1"> flag, used to determine when the rectangle shape should be updated.</span></p><p><span class="koboSpan" id="kobo.44.1">For the other two states, we need to store the entity identifier and its position component, given we are in an entity selection mode, and a pointer to the particle emitter, provided we are currently working with particles. </span><span class="koboSpan" id="kobo.44.2">This is also where the contents of particle and entity directories are going to be stored, in order to populate the drop-down list with the appropriate values.</span></p><p><span class="koboSpan" id="kobo.45.1">Additionally, we need to keep track of the layer selection range, as well as pointers to the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">selectionOptions</span></code><span class="koboSpan" id="kobo.47.1"> interface, the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">MapControl</span></code><span class="koboSpan" id="kobo.49.1"> class that was covered in the previous chapter, and a map tile selector class, which will be covered shortly. </span><span class="koboSpan" id="kobo.49.2">Keep in mind that only the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">m_selectionOptions</span></code><span class="koboSpan" id="kobo.51.1"> interface is technically owned by this class. </span><span class="koboSpan" id="kobo.51.2">The other two classes encapsulate their own interfaces, thus managing their destruction.</span></p><p><span class="koboSpan" id="kobo.52.1">Lastly, we need to have access to the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">eventManager</span></code><span class="koboSpan" id="kobo.54.1">, </span><code class="literal"><span class="koboSpan" id="kobo.55.1">guimanager</span></code><span class="koboSpan" id="kobo.56.1">, the game </span><code class="literal"><span class="koboSpan" id="kobo.57.1">map</span></code><span class="koboSpan" id="kobo.58.1"> instance, the tile </span><code class="literal"><span class="koboSpan" id="kobo.59.1">brush</span></code><span class="koboSpan" id="kobo.60.1">, entityManager, and the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">particleSystem</span></code><span class="koboSpan" id="kobo.62.1">.</span></p><div class="section" title="Implementing selection options"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/><span class="koboSpan" id="kobo.63.1">Implementing selection options</span></h2></div></div></div><p><span class="koboSpan" id="kobo.64.1">With all of this data to properly initialize, we have quite a lot of work to do in the constructor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.65.1">GUI_SelectionOptions::GUI_SelectionOptions( 
  EventManager* l_eventManager, GUI_Manager* l_guiManager, 
  MapControls* l_controls, GUI_MapTileSelector* l_selector, 
  Map* l_map, TileMap* l_brush, EntityManager* l_entityMgr, 
  ParticleSystem* l_particles) : 
  /* Processing arguments. </span><span class="koboSpan" id="kobo.65.2">*/ 
  m_eventManager(l_eventManager), m_guiManager(l_guiManager), 
  m_mapControls(l_controls), m_tileSelector(l_selector), 
  m_map(l_map), m_brush(l_brush), m_entityManager(l_entityMgr), 
  m_particleSystem(l_particles), 
  /* Initializing default values of data members. </span><span class="koboSpan" id="kobo.65.3">*/ 
  m_selectRangeX(-1, -1), m_selectRangeY(-1, -1), 
  m_layerSelectLow(0), m_layerSelectHigh(0), 
  m_selectMode(SelectMode::Tiles), m_entityId(-1), 
  m_entity(nullptr), m_emitter(nullptr), m_selectUpdate(true) 
{...} 
</span></pre><p><span class="koboSpan" id="kobo.66.1">After all of the arguments are properly stored away, the default values of all data members are set up. </span><span class="koboSpan" id="kobo.66.2">This ensures that the initial state of the selection is defined. </span><span class="koboSpan" id="kobo.66.3">The body of the constructor is used to appropriately deal with other tasks:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.67.1">GUI_SelectionOptions::GUI_SelectionOptions(...) 
{ 
  ... </span><span class="koboSpan" id="kobo.67.2">// Setting up callbacks. 
  </span><span class="koboSpan" id="kobo.67.3">m_guiManager-&gt;LoadInterface( 
    "MapEditorSelectionOptions.interface", 
    "MapEditorSelectionOptions"); 
  m_selectionOptions =  
    m_guiManager-&gt;GetInterface("MapEditorSelectionOptions"); 
  m_selectionOptions-&gt;SetPosition({ 0.f, 164.f }); 
  m_selectionOptions-&gt;SetActive(false); 
  m_selectStartColor = sf::Color(0, 0, 150, 120); 
  m_selectEndColor = sf::Color(0, 0, 255, 150); 
  m_entityColor = sf::Color(255, 0, 0, 150); 
  m_emitterColor = sf::Color(0, 255, 0, 150); 
 
  m_entityNames = Utils::GetFileList(Utils::GetWorkingDirectory() 
    + "media/Entities/", "*.entity"); 
  m_emitterNames = Utils::GetFileList(Utils::GetWorkingDirectory() 
    + "media/Particles/", "*.particle"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.68.1">Here, all of the proper callbacks are set up, the interface the class owns is loaded, positioned and hidden, and the color values are initialized. </span><span class="koboSpan" id="kobo.68.2">Finally, the contents of the entity and particle emitter directories are obtained and stored.</span></p><p><span class="koboSpan" id="kobo.69.1">We're not going to be covering the destructor here, because it simply deals with removing all callbacks and the interface that is set up.</span></p><p><span class="koboSpan" id="kobo.70.1">Speaking of interfaces, the outside code needs to be able to easily show and hide the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">selectionOptions</span></code><span class="koboSpan" id="kobo.72.1"> window:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">void GUI_SelectionOptions::Show() { 
  m_selectionOptions-&gt;SetActive(true); 
  m_guiManager-&gt;BringToFront(m_selectionOptions); 
} 
void GUI_SelectionOptions::Hide() { 
  m_selectionOptions-&gt;SetActive(false); 
} 
</span></pre><p><span class="koboSpan" id="kobo.74.1">The desired effect is achieved by either setting the interface as active or inactive. </span><span class="koboSpan" id="kobo.74.2">In the former case, the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">guiManager</span></code><span class="koboSpan" id="kobo.76.1"> is also used in order to position the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">selectionOptions</span></code><span class="koboSpan" id="kobo.78.1"> interface above everything else, by bringing it to the front.</span></p><p><span class="koboSpan" id="kobo.79.1">Because this interface/class is a sort of helper, it depends on the control mode of our editor. </span><span class="koboSpan" id="kobo.79.2">This relationship requires the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">selectionOptions</span></code><span class="koboSpan" id="kobo.81.1"> class to be notified of </span><code class="literal"><span class="koboSpan" id="kobo.82.1">controlMode</span></code><span class="koboSpan" id="kobo.83.1"> changes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.84.1">void GUI_SelectionOptions::SetControlMode(ControlMode l_mode) { 
  if (l_mode != ControlMode::Brush &amp;&amp; l_mode 
    != ControlMode::Select) 
  { return; } 
  SetSelectMode(SelectMode::Tiles); 
  if (l_mode == ControlMode::Brush) { 
    m_selectionOptions-&gt;SetActive(true); 
    m_selectionOptions-&gt;Focus(); 
    m_selectionOptions-&gt;GetElement("TileSelect")-&gt;SetActive(true); 
  } else if (l_mode == ControlMode::Select) { 
    m_selectionOptions-&gt;SetActive(true); 
    m_selectionOptions-&gt;Focus(); 
    m_selectionOptions-&gt;GetElement("SolidToggle")-&gt; 
      SetActive(true); 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(true); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.85.1">It's only necessary to worry about the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">Brush</span></code><span class="koboSpan" id="kobo.87.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.88.1">Select</span></code><span class="koboSpan" id="kobo.89.1"> modes, as this interface is not even needed for anything else. </span><span class="koboSpan" id="kobo.89.2">In case a </span><code class="literal"><span class="koboSpan" id="kobo.90.1">Brush</span></code><span class="koboSpan" id="kobo.91.1"> is selected, the interface is enabled and focused, while its </span><code class="literal"><span class="koboSpan" id="kobo.92.1">TileSelect</span></code><span class="koboSpan" id="kobo.93.1"> element is also enabled. </span><span class="koboSpan" id="kobo.93.2">This ensures we can select tiles we want to paint with. </span><span class="koboSpan" id="kobo.93.3">If the selection tool is picked, we want the buttons for solidity toggling and selection copying to be enabled instead.</span></p><p><span class="koboSpan" id="kobo.94.1">The actual selection mode switching needs to be handled too, and can be done like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.95.1">void GUI_SelectionOptions::SetSelectMode(SelectMode l_mode) { 
  Reset(); 
  m_selectMode = l_mode; 
  m_selectionOptions-&gt;SetActive(true); 
  m_selectionOptions-&gt;Focus(); 
 
  if (l_mode == SelectMode::Tiles) { 
    ... </span><span class="koboSpan" id="kobo.95.2">// GUI Element manipulation. 
  </span><span class="koboSpan" id="kobo.95.3">} else if(l_mode == SelectMode::Entities) { 
    ... </span><span class="koboSpan" id="kobo.95.4">// GUI Element manipulation. 
    </span><span class="koboSpan" id="kobo.95.5">auto dropdown = static_cast&lt;GUI_DropDownMenu*&gt;( 
      m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
      GetMenu(); 
    dropdown-&gt;PurgeEntries(); 
    for (auto&amp; entity : m_entityNames) { 
      dropdown-&gt;AddEntry( 
        entity.first.substr(0, entity.first.find(".entity"))); 
    } 
    dropdown-&gt;Redraw(); 
  } else if (l_mode == SelectMode::Emitters) { 
    ... </span><span class="koboSpan" id="kobo.95.6">// GUI Element manipulation. 
    </span><span class="koboSpan" id="kobo.95.7">auto dropdown = static_cast&lt;GUI_DropDownMenu*&gt;( 
      m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
      GetMenu(); 
    dropdown-&gt;PurgeEntries(); 
    for (auto&amp; emitter : m_emitterNames) { 
      dropdown-&gt;AddEntry( 
        emitter.first.substr(0, emitter.first.find(".particle"))); 
    } 
    dropdown-&gt;Redraw(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.96.1">First, the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Reset()</span></code><span class="koboSpan" id="kobo.98.1"> method is invoked. </span><span class="koboSpan" id="kobo.98.2">It is used to disable all unnecessary interface elements and zero out the selection data members to their default values. </span><span class="koboSpan" id="kobo.98.3">After the actual selection mode is stored and the interface is set to active, we begin dealing with the actual mode-specific logic.</span></p><p><span class="koboSpan" id="kobo.99.1">If we are in the tile selection mode, it simply involves enabling a number of interface elements, as well as setting their text to match the context. </span><span class="koboSpan" id="kobo.99.2">For the sake of simplicity, all of the element manipulation in this method is omitted.</span></p><p><span class="koboSpan" id="kobo.100.1">Dealing with entity and emitter modes is similar, yet includes an additional step, which is populating the drop-down menu with appropriate values. </span><span class="koboSpan" id="kobo.100.2">In both cases, the drop-down element is obtained and purged of its current entries. </span><span class="koboSpan" id="kobo.100.3">The appropriate directory list is then iterated over; adding each entry to the drop-down, making sure the file type is removed. </span><span class="koboSpan" id="kobo.100.4">Once this is done, the drop-down menu is instructed to be re-drawn.</span></p><p><span class="koboSpan" id="kobo.101.1">Let us take a look at what needs to happen when our selection options class is instructed to select a particular entity:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.102.1">void GUI_SelectionOptions::SelectEntity(int l_id) { 
  if (l_id == -1) { 
    m_entityId = -1; 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(false); 
    m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
      SetText("Place"); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(false); 
    m_entity = nullptr; 
    return; 
  } 
  auto pos = m_entityManager-&gt; 
    GetComponent&lt;C_Position&gt;(l_id, Component::Position); 
  if (!pos) { 
    m_entityId = -1; 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(false); 
    m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
      SetText("Place"); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(false); 
    m_entity = nullptr; 
    return; 
  } 
  m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
    SetActive(true); 
  m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
    SetText("Edit"); 
  m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
    SetActive(true); 
  m_entityId = l_id; 
  m_entity = pos; 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt; 
    SetText(std::to_string(m_entityId)); 
  m_selectUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.103.1">First, the argument could be used to de-select an entity, as well as select it. </span><span class="koboSpan" id="kobo.103.2">If the appropriate de-select value is passed, or an entity position component with the provided identifier has not been found, the related interface elements are adjusted to match the situation.</span></p><p><span class="koboSpan" id="kobo.104.1">If an entity with the provided ID does exist, the proper elements are enabled and adjusted. </span><span class="koboSpan" id="kobo.104.2">The entity position component as well as its identifier is stored for later use, and the information text element of the selection options interface is changed to reflect the ID of the entity selected. </span><span class="koboSpan" id="kobo.104.3">It is also marked to be updated, by manipulating the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.105.1">boolean</span></em></span><span class="koboSpan" id="kobo.106.1"> flag </span><code class="literal"><span class="koboSpan" id="kobo.107.1">m_selectUpdate</span></code><span class="koboSpan" id="kobo.108.1">.</span></p><p><span class="koboSpan" id="kobo.109.1">A very similar process takes place when selecting an emitter:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.110.1">void GUI_SelectionOptions::SelectEmitter(Emitter* l_emitter) { 
  m_emitter = l_emitter; 
  if (!l_emitter) { 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(false); 
    m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
      SetText("Place"); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(false); 
    return; 
  } 
  m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
    SetActive(true); 
  m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
    SetText("Edit"); 
  m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
    SetActive(true); 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt;SetText(m_emitter-&gt; 
    GetGenerators()); 
  m_selectionOptions-&gt;GetElement("EmitRate")-&gt; 
    SetText(std::to_string(m_emitter-&gt;GetEmitRate())); 
  m_selectUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.111.1">It is simpler in a sense that we are only working with a pointer to a particle emitter. </span><span class="koboSpan" id="kobo.111.2">If </span><code class="literal"><span class="koboSpan" id="kobo.112.1">nullptr</span></code><span class="koboSpan" id="kobo.113.1"> is passed in, proper elements are disabled and adjusted. </span><span class="koboSpan" id="kobo.113.2">Otherwise, the interface is updated to reflect the information of the emitter that is selected, while also marking the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">selectionOptions</span></code><span class="koboSpan" id="kobo.115.1"> interface is properly updated afterwards.</span></p><p><span class="koboSpan" id="kobo.116.1">We obviously also need a way to switch between the different selection modes, hence this callback:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.117.1">void GUI_SelectionOptions::SelectModeSwitch( 
  EventDetails* l_details) 
{ 
  if (m_selectMode == SelectMode::Tiles) { 
    if (m_mapControls-&gt;GetMode() != ControlMode::Select) { 
      m_mapControls-&gt;SelectMode(ControlMode::Select); 
    } 
    SetSelectMode(SelectMode::Entities); 
  } else if (m_selectMode == SelectMode::Entities) { 
    SetSelectMode(SelectMode::Emitters); 
  } else { SetSelectMode(SelectMode::Tiles); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.118.1">It simply cycles through all of the options for selection. </span><span class="koboSpan" id="kobo.118.2">One thing worthy of pointing out here is that if the interface before cycling is in tile mode, we want to make sure that the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">ControlMode</span></code><span class="koboSpan" id="kobo.120.1"> is switched to </span><code class="literal"><span class="koboSpan" id="kobo.121.1">Select</span></code><span class="koboSpan" id="kobo.122.1">.</span></p><p><span class="koboSpan" id="kobo.123.1">Another feature we want to work on is opening up and dealing with tiles being selected from the tile-sheet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.124.1">void GUI_SelectionOptions::OpenTileSelection( 
  EventDetails* l_details) 
{ 
  if (!m_tileSelector-&gt;IsActive()) { 
    m_tileSelector-&gt;Show(); 
    return; 
  } 
  m_mapControls-&gt;SelectMode(ControlMode::Brush); 
  if (m_tileSelector-&gt;CopySelection(*m_brush)) { 
    m_selectionOptions-&gt;GetElement("Solidity")-&gt;SetText("False"); 
    m_mapControls-&gt;RedrawBrush(); 
  } 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt;SetText( 
    std::to_string(m_brush-&gt;GetTileCount())); 
} 
</span></pre><p><span class="koboSpan" id="kobo.125.1">First, we deal with just opening the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">tileSelector</span></code><span class="koboSpan" id="kobo.127.1"> interface, provided it is not set to active yet. </span><span class="koboSpan" id="kobo.127.2">On the other hand, if the interface is open, the select button being pressed indicates the user attempting to copy their selection to the brush. </span><span class="koboSpan" id="kobo.127.3">The </span><code class="literal"><span class="koboSpan" id="kobo.128.1">mapControls</span></code><span class="koboSpan" id="kobo.129.1"> class is instructed to switch its mode to </span><code class="literal"><span class="koboSpan" id="kobo.130.1">Brush</span></code><span class="koboSpan" id="kobo.131.1">, which is then passed into the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">tileSelector</span></code><span class="koboSpan" id="kobo.133.1"> class's </span><code class="literal"><span class="koboSpan" id="kobo.134.1">CopySelection()</span></code><span class="koboSpan" id="kobo.135.1"> method, responsible for copying actual tile data. </span><span class="koboSpan" id="kobo.135.2">Since it returns a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.136.1">boolean</span></em></span><span class="koboSpan" id="kobo.137.1"> value that indicates its success, the method is invoked inside an </span><code class="literal"><span class="koboSpan" id="kobo.138.1">if</span></code><span class="koboSpan" id="kobo.139.1"> statement, which allows us to update the solidity element of the interface and request a brush re-draw, provided the copying procedure was successful. </span><span class="koboSpan" id="kobo.139.2">At any rate, the information text element of the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">selectionOptions</span></code><span class="koboSpan" id="kobo.141.1"> interface is then updated to hold the total count of tiles that have been selected and copied to the brush.</span></p><p><span class="koboSpan" id="kobo.142.1">Toggling the solidity of the current portion of the map being selected or the brush itself is also possible in our tile editor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.143.1">void GUI_SelectionOptions::SolidToggle(EventDetails* l_details) { 
  auto mode = m_mapControls-&gt;GetMode(); 
  if (m_mapControls-&gt;GetMode() != ControlMode::Brush 
    &amp;&amp; mode != ControlMode::Select) 
  { return; } 
  auto element = m_selectionOptions-&gt;GetElement("Solidity"); 
  auto state = element-&gt;GetText(); 
  bool solid = false; 
  std::string newText; 
  if (state == "True") { newText = "False"; } 
  else { solid = true; newText = "True"; } 
  element-&gt;SetText(newText); 
  sf::Vector2u start; 
  sf::Vector2u finish; 
  TileMap* map = nullptr; 
  if (mode == ControlMode::Brush) { 
    map = m_brush; 
    start = sf::Vector2u(0, 0); 
    finish = map-&gt;GetMapSize() - sf::Vector2u(1, 1); 
  } else if (mode == ControlMode::Select) { 
    map = m_map-&gt;GetTileMap(); 
    start = sf::Vector2u(m_selectRangeX.x, m_selectRangeY.x); 
    finish = sf::Vector2u(m_selectRangeX.y, m_selectRangeY.y); 
  } 
 
  for (auto x = start.x; x &lt;= finish.x; ++x) { 
    for (auto y = start.y; y &lt;= finish.y; ++y) { 
      for (auto layer = m_layerSelectLow; 
        layer &lt; m_layerSelectHigh; ++layer) 
      { 
        auto tile = map-&gt;GetTile(x, y, layer); 
        if (!tile) { continue; } 
        tile-&gt;m_solid = solid; 
      } 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.144.1">First, we obviously can not toggle the solidity of a selection, if the control mode is not set to either the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">Brush</span></code><span class="koboSpan" id="kobo.146.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.147.1">Select</span></code><span class="koboSpan" id="kobo.148.1"> mode. </span><span class="koboSpan" id="kobo.148.2">With that being covered, the solidity state label is obtained, as well as its text. </span><span class="koboSpan" id="kobo.148.3">After flipping its value to its opposite and updating the element's text, we establish a range of tiles that will be modified. </span><span class="koboSpan" id="kobo.148.4">In the case of a brush having its solidity toggled, the range encapsulates the entire structure. </span><span class="koboSpan" id="kobo.148.5">On the other hand, the map selection range is used when dealing with the select mode.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/><span class="koboSpan" id="kobo.149.1">Note</span></h3><p><span class="koboSpan" id="kobo.150.1">The </span><code class="literal"><span class="koboSpan" id="kobo.151.1">m_selectRangeX</span></code><span class="koboSpan" id="kobo.152.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.153.1">m_selectRangeY</span></code><span class="koboSpan" id="kobo.154.1"> data members represent the selection range of the map tiles. </span><span class="koboSpan" id="kobo.154.2">Each range is responsible for its own axis. </span><span class="koboSpan" id="kobo.154.3">For example,</span><code class="literal"><span class="koboSpan" id="kobo.155.1"> m_selectRangeX.x</span></code><span class="koboSpan" id="kobo.156.1"> is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.157.1">starting </span></strong></span>
<span class="emphasis"><em><span class="koboSpan" id="kobo.158.1">X</span></em></span><span class="koboSpan" id="kobo.159.1"> coordinate, and </span><code class="literal"><span class="koboSpan" id="kobo.160.1">m_selectRangeX.y</span></code><span class="koboSpan" id="kobo.161.1"> is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.162.1">ending</span></strong></span>
<span class="emphasis"><em><span class="koboSpan" id="kobo.163.1">X</span></em></span><span class="koboSpan" id="kobo.164.1"> coordinate.</span></p></div></div><p><span class="koboSpan" id="kobo.165.1">After the range is properly established, we simply need to iterate over it and obtain tiles from the appropriate </span><code class="literal"><span class="koboSpan" id="kobo.166.1">TileMap</span></code><span class="koboSpan" id="kobo.167.1">, setting their solidity to the appropriate value.</span></p><p><span class="koboSpan" id="kobo.168.1">Copying a certain portion of the map to the brush could also prove to be a useful feature:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.169.1">void GUI_SelectionOptions::CopySelection(EventDetails* l_details) 
{ 
  if (m_selectRangeX.x == -1) { return; } 
  auto size = sf::Vector2u( 
    m_selectRangeX.y - m_selectRangeX.x, 
    m_selectRangeY.y - m_selectRangeY.x); 
  size.x += 1; 
  size.y += 1; 
  m_brush-&gt;Purge(); 
  m_brush-&gt;SetMapSize(size); 
  unsigned int b_x = 0, b_y = 0, b_l = 0; 
  bool solid = false, mixed = false; 
  unsigned short changes = 0; 
  for (auto x = m_selectRangeX.x; x &lt;= m_selectRangeX.y; ++x) { 
    for (auto y = m_selectRangeY.x; y &lt;= m_selectRangeY.y; ++y) { 
      for (auto layer = m_layerSelectLow; 
        layer &lt;= m_layerSelectHigh; ++layer) 
      { 
        auto tile = m_map-&gt;GetTile(x, y, layer); 
        if (!tile) { ++b_l; continue; } 
        auto newTile = m_brush-&gt;SetTile( 
          b_x, b_y, b_l, tile-&gt;m_properties-&gt;m_id); 
        if (!newTile) { continue; } 
        if (!mixed) { 
          if (tile-&gt;m_solid &amp;&amp; !solid) { 
            solid = true; ++changes; 
          } else if (solid) { 
            solid = false; ++changes; 
          } 
          if (changes &gt;= 2) { mixed = true; } 
        } 
        *newTile = *tile; 
        ++b_l; 
      } 
      b_l = 0; 
      ++b_y; 
    } 
    b_y = 0; 
    ++b_x; 
  } 
  m_layerSelectHigh = m_layerSelectLow + 
    m_brush-&gt;GetHighestElevation(); 
  if (m_layerSelectHigh &gt;= Sheet::Num_Layers) { 
    auto difference = (m_layerSelectHigh - Sheet::Num_Layers) + 1; 
    m_layerSelectHigh = Sheet::Num_Layers - 1; 
    m_layerSelectLow -= difference; 
  } 
  SelectionElevationUpdate(); 
  m_mapControls-&gt;SelectMode(ControlMode::Brush); 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt; 
    SetText(std::to_string(m_brush-&gt;GetTileCount())); 
  m_selectionOptions-&gt;GetElement("Solidity")-&gt; 
    SetText((mixed ? </span><span class="koboSpan" id="kobo.169.2">"Mixed" : (solid ? </span><span class="koboSpan" id="kobo.169.3">"True" : "False"))); 
} 
</span></pre><p><span class="koboSpan" id="kobo.170.1">We begin by checking if a selection actually was made, which can be done by checking any of the select range data members. </span><span class="koboSpan" id="kobo.170.2">Afterwards, the size of the selection is calculated by subtracting the start-points of the selection from the end-points, and increasing the size by one unit on both axes. </span><span class="koboSpan" id="kobo.170.3">This is done in order to compensate for inclusive ranges that start and end on the same exact tile number.</span></p><p><span class="koboSpan" id="kobo.171.1">Once the brush tile map is purged and resized, some local variables are set up in order to aid the rest of the code. </span><span class="koboSpan" id="kobo.171.2">The three </span><span class="emphasis"><em><span class="koboSpan" id="kobo.172.1">unsigned integers</span></em></span><span class="koboSpan" id="kobo.173.1"> are going to be used as index coordinates for the brush tile map, in order to map the copied tiles correctly. </span><span class="koboSpan" id="kobo.173.2">The two </span><span class="emphasis"><em><span class="koboSpan" id="kobo.174.1">boolean</span></em></span><span class="koboSpan" id="kobo.175.1"> flags and the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.176.1">unsigned short </span></em></span><span class="koboSpan" id="kobo.177.1">changes are going to keep track of solidity changes, in order to update the GUI element that denotes what solidity state the selection is in.</span></p><p><span class="koboSpan" id="kobo.178.1">Next, the tile loops are entered. </span><span class="koboSpan" id="kobo.178.2">After the map tile at the specific coordinates is obtained and passes the validity check, the brush tile at the current coordinates denoted by </span><code class="literal"><span class="koboSpan" id="kobo.179.1">b_x</span></code><span class="koboSpan" id="kobo.180.1">, </span><code class="literal"><span class="koboSpan" id="kobo.181.1">b_y</span></code><span class="koboSpan" id="kobo.182.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.183.1">b_l</span></code><span class="koboSpan" id="kobo.184.1"> is set to hold the same tile ID. </span><span class="koboSpan" id="kobo.184.2">The solidity changes of the tile are then detected and noted, in order to determine if we have a mixed selection of solidities. </span><span class="koboSpan" id="kobo.184.3">Finally, all other tile properties are transferred to the brush, by utilizing the overloaded </span><code class="literal"><span class="koboSpan" id="kobo.185.1">=</span></code><span class="koboSpan" id="kobo.186.1"> operator.</span></p><p><span class="koboSpan" id="kobo.187.1">In order to keep the interface up–to–date with our actions, the current layer selection range is checked for exceeding the actual range of total layers supported by the application. </span><span class="koboSpan" id="kobo.187.2">If, for example, we support four total layers and the current selected layer is two while the brush has all of its layers filled, we want to adjust the current layer selection to honour that by calculating the layer difference, adjusting the highest layer selected to match the maximum layer supported by the application, and subtract the difference from the lowest layer, hence preserving the proper range of the brush.</span></p><p><span class="koboSpan" id="kobo.188.1">Lastly, a method for updating the selection options elevation selection text is invoked, the map controls class is instructed to switch to the </span><code class="literal"><span class="koboSpan" id="kobo.189.1">Brush</span></code><span class="koboSpan" id="kobo.190.1"> mode, and the selection options interface is updated with the information of the brush tile count and solidity.</span></p><p><span class="koboSpan" id="kobo.191.1">Let us drift away from the topic of placing, editing, or copying tiles for a second, and talk about actually placing entities or emitters when the </span><span class="strong"><strong><span class="koboSpan" id="kobo.192.1">Place</span></strong></span><span class="koboSpan" id="kobo.193.1"> button is pressed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.194.1">void GUI_SelectionOptions::PlaceSelection(EventDetails* l_details) 
{ 
  if (m_selectMode == SelectMode::Tiles) { return; } 
  auto dropdownValue = static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
    GetMenu()-&gt;GetSelected(); 
  if (dropdownValue.empty()) { return; } 
  if (m_selectMode == SelectMode::Entities) { 
    if (!m_entity || m_entityId == -1) { 
      // New entity. 
      </span><span class="koboSpan" id="kobo.194.2">auto id = m_entityManager-&gt;AddEntity(dropdownValue); 
      if (id == -1) { return; } 
      SelectEntity(id); 
    } 
    SaveOptions(nullptr); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { 
      // New emitter. 
      </span><span class="koboSpan" id="kobo.194.3">auto text = m_selectionOptions-&gt; 
        GetElement("EmitRate")-&gt;GetText(); 
      auto rate = std::stoi(text); 
      auto emitter = m_particleSystem-&gt;AddEmitter( 
        sf::Vector3f(0.f, 0.f, 0.f), dropdownValue, rate, 
        StateType::MapEditor); 
      SelectEmitter(emitter); 
    } 
    SaveOptions(nullptr); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.195.1">We are not going to be using this functionality to do anything with tiles, because that is what the mouse is designated for. </span><span class="koboSpan" id="kobo.195.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">selectionOptions</span></code><span class="koboSpan" id="kobo.197.1"> interface is in the proper </span><code class="literal"><span class="koboSpan" id="kobo.198.1">Select</span></code><span class="koboSpan" id="kobo.199.1"> mode, the value of the drop-down menu is obtained and checked for not being empty. </span><span class="koboSpan" id="kobo.199.2">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.200.1">Place</span></strong></span><span class="koboSpan" id="kobo.201.1"> button can also act as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.202.1">Edit</span></strong></span><span class="koboSpan" id="kobo.203.1"> button under appropriate circumstances, such as when an entity or particle emitter is selected, so in both cases, the appropriate values are checked for representing a selection, or lack thereof. </span><span class="koboSpan" id="kobo.203.2">If nothing is selected, the drop-down value is used to add a new entity or emitter of the selected type. </span><span class="koboSpan" id="kobo.203.3">The </span><code class="literal"><span class="koboSpan" id="kobo.204.1">SaveOptions()</span></code><span class="koboSpan" id="kobo.205.1"> method is then invoked, so in either case, the information currently stored in the </span><code class="literal"><span class="koboSpan" id="kobo.206.1">selectionOptions</span></code><span class="koboSpan" id="kobo.207.1"> interface is saved to either the newly created object, or one that was already selected.</span></p><p><span class="koboSpan" id="kobo.208.1">Pressing the </span><span class="strong"><strong><span class="koboSpan" id="kobo.209.1">Remove</span></strong></span><span class="koboSpan" id="kobo.210.1"> button can be handled like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.211.1">void GUI_SelectionOptions::RemoveSelection( 
  EventDetails* l_details) 
{ 
  DeleteSelection(l_details-&gt;m_shiftPressed); 
} 
</span></pre><p><span class="koboSpan" id="kobo.212.1">As you can see, a different method is invoked here, with a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.213.1">boolean</span></em></span><span class="koboSpan" id="kobo.214.1"> flag being passed to it, denoting whether the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.215.1">Shift</span></em></span><span class="koboSpan" id="kobo.216.1"> key is being held down, controlling how much of the current selection is removed. </span><span class="koboSpan" id="kobo.216.2">Let us take a look at the actual delete method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.217.1">void GUI_SelectionOptions::DeleteSelection(bool l_deleteAll) { 
  if (m_selectMode == SelectMode::Tiles) { 
    if (m_selectRangeX.x == -1) { return; } 
    auto layerRange = (l_deleteAll ? 
      </span><span class="koboSpan" id="kobo.217.2">sf::Vector2u(0, Sheet::Num_Layers - 1) : 
      sf::Vector2u(m_layerSelectLow, m_layerSelectHigh)); 
 
    m_map-&gt;GetTileMap()-&gt;RemoveTiles( 
      sf::Vector2u(m_selectRangeX), 
      sf::Vector2u(m_selectRangeY), 
      layerRange); 
    m_map-&gt;ClearMapTexture( 
      sf::Vector3i(m_selectRangeX.x, 
        m_selectRangeY.x, layerRange.x), 
      sf::Vector3i(m_selectRangeX.y, 
        m_selectRangeY.y, layerRange.y)); 
  } else if (m_selectMode == SelectMode::Entities) { 
    if (!m_entity || m_entityId == -1) { return; } 
    m_entityManager-&gt;RemoveEntity(m_entityId); 
    SelectEntity(-1); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { return; } 
    m_particleSystem-&gt;RemoveEmitter(m_emitter); 
    SelectEmitter(nullptr); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.218.1">Once again, we deal with all three different selection types: tile, entity, and particle emitters. </span><span class="koboSpan" id="kobo.218.2">If we are working with tiles, the selection range is checked. </span><span class="koboSpan" id="kobo.218.3">Provided something actually is selected, the layer range is defined, based on whether the argument says everything should be deleted. </span><span class="koboSpan" id="kobo.218.4">The map is then instructed to remove the tiles and cleat its render texture within the calculated ranges.</span></p><p><span class="koboSpan" id="kobo.219.1">In the cases of entities and particle emitters, it's much less complicated. </span><span class="koboSpan" id="kobo.219.2">The selected entity/emitter is simply removed, and the appropriate </span><code class="literal"><span class="koboSpan" id="kobo.220.1">SelectX</span></code><span class="koboSpan" id="kobo.221.1"> method is invoked shortly after, passing in a value for nothing being selected.</span></p><p><span class="koboSpan" id="kobo.222.1">Next, let us handle the </span><span class="emphasis"><em>
<span class="strong"><strong><span class="koboSpan" id="kobo.223.1">+</span></strong></span>
</em></span><span class="koboSpan" id="kobo.224.1"> and </span><span class="emphasis"><em>
<span class="strong"><strong><span class="koboSpan" id="kobo.225.1">-</span></strong></span>
</em></span><span class="koboSpan" id="kobo.226.1"> buttons that control the elevation selection being pressed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.227.1">void GUI_SelectionOptions::SelectionOptionsElevation( 
  EventDetails* l_details) 
{ 
  int low = 0, high = 0; 
  bool shift = sf::Keyboard::isKeyPressed(sf::Keyboard::LShift); 
  if (l_details-&gt;m_name == "MapEditor_SelectOptionsPlus") { 
    if (shift) { high = 1; } else { low = 1; } 
  } else if(l_details-&gt;m_name == "MapEditor_SelectOptionsMinus") { 
    if (shift) { high = -1; } else { low = -1; } 
  } 
 
  auto mode = m_mapControls-&gt;GetMode(); 
 
  if (mode == ControlMode::Brush) { 
    if (high != 0) { return; } // only working with low values. 
    </span><span class="koboSpan" id="kobo.227.2">int l = m_layerSelectLow + low; 
    if (l &lt; 0 || l &gt;= Sheet::Num_Layers) { return; } 
    if (l + m_brush-&gt;GetHighestElevation() &gt;= 
      Sheet::Num_Layers) 
    { return; } 
    m_layerSelectLow = l; 
    m_layerSelectHigh = l + m_brush-&gt;GetHighestElevation(); 
    SelectionElevationUpdate(); 
  } else if (mode == ControlMode::Select) { 
    int l = m_layerSelectLow + low; 
    int h = m_layerSelectHigh + high; 
    if (l &lt; 0 || l &gt;= Sheet::Num_Layers) { return; } 
    if (h &lt; 0 || h &gt;= Sheet::Num_Layers) { return; } 
    if (m_layerSelectLow == m_layerSelectHigh &amp;&amp; !shift) { 
      m_layerSelectLow += low; 
      m_layerSelectLow += high; 
      m_layerSelectHigh = m_layerSelectLow; 
    } else { 
      m_layerSelectLow = l; 
      m_layerSelectHigh = h; 
    } 
    if (m_layerSelectLow &gt; m_layerSelectHigh) { 
      std::swap(m_layerSelectLow, m_layerSelectHigh); 
    } 
    SelectionElevationUpdate(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.228.1">Here, we want to handle the button clicks in a specific way. </span><span class="koboSpan" id="kobo.228.2">Keep in mind that support for selecting ranges of layers is also something of great importance. </span><span class="koboSpan" id="kobo.228.3">Consider the following illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.229.1"><img src="graphics/image_05_002.jpg" alt="Implementing selection options"/></span></div><p><span class="koboSpan" id="kobo.230.1">Simply clicking either a plus or a minus would affect the low number, which represents the lowest elevation selected. </span><span class="koboSpan" id="kobo.230.2">Holding a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.231.1">Shift</span></em></span><span class="koboSpan" id="kobo.232.1"> key would increase the high number, controlling the highest elevation. </span><span class="koboSpan" id="kobo.232.2">For this, two integers, </span><code class="literal"><span class="koboSpan" id="kobo.233.1">low</span></code><span class="koboSpan" id="kobo.234.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.235.1">high</span></code><span class="koboSpan" id="kobo.236.1">, are set up, alongside a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.237.1">boolean</span></em></span><span class="koboSpan" id="kobo.238.1"> flag that determines if a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.239.1">Shift</span></em></span><span class="koboSpan" id="kobo.240.1"> key is being held or not. </span><span class="koboSpan" id="kobo.240.2">Based on that and the event name, the numbers are adjusted to represent the changes in elevation.</span></p><p><span class="koboSpan" id="kobo.241.1">Next, we branch out the logic once again. </span><span class="koboSpan" id="kobo.241.2">If a </span><code class="literal"><span class="koboSpan" id="kobo.242.1">Brush</span></code><span class="koboSpan" id="kobo.243.1"> mode is selected, we do not want to deal with any changes of the high elevation at all. </span><span class="koboSpan" id="kobo.243.2">Instead, only the low layer selection is used here. </span><span class="koboSpan" id="kobo.243.3">After a new value for it is established by adding the layer delta to the already selected low elevation, the range is checked for exceeding the boundaries of [0;</span><code class="literal"><span class="koboSpan" id="kobo.244.1">Sheet::NumLayers</span></code><span class="koboSpan" id="kobo.245.1">). </span><span class="koboSpan" id="kobo.245.2">Provided that passes, the low elevation selection is updated with the new value, as is the high value, which simply takes the low elevation and adds the thickness of the brush to it, represented by the brush's highest elevation.</span></p><p><span class="koboSpan" id="kobo.246.1">The </span><code class="literal"><span class="koboSpan" id="kobo.247.1">Select</span></code><span class="koboSpan" id="kobo.248.1"> mode follows the same basic principle, with one exception: it also handles the high elevation. </span><span class="koboSpan" id="kobo.248.2">With the deltas properly added to the current values, the range is checked for exceeding the allowed limits. </span><span class="koboSpan" id="kobo.248.3">The next check deals with how we control shift-clicks depending on whether both the low and high values are the same. </span><span class="koboSpan" id="kobo.248.4">If they are, the deltas are simply added to the low value, which is copied over to the high elevation, preserving the equality. </span><span class="koboSpan" id="kobo.248.5">Otherwise, both low and high values are simply overwritten with the preceding newly calculated range.</span></p><p><span class="koboSpan" id="kobo.249.1">In both cases, it is also important to invoke the </span><code class="literal"><span class="koboSpan" id="kobo.250.1">SelectionElevationUpdate()</span></code><span class="koboSpan" id="kobo.251.1"> method, which makes sure the interface elements are kept up-to-date, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.252.1">void GUI_SelectionOptions::SelectionElevationUpdate() { 
  if (!m_selectionOptions-&gt;IsActive()) { return; } 
  m_selectionOptions-&gt;GetElement("Elevation")-&gt;SetText( 
    std::to_string(m_layerSelectLow) + 
    (m_layerSelectLow != m_layerSelectHigh ? 
    </span><span class="koboSpan" id="kobo.252.2">" - " + std::to_string(m_layerSelectHigh) : "") 
  ); 
  SaveOptions(nullptr); 
} 
</span></pre><p><span class="koboSpan" id="kobo.253.1">After making sure the selection options interface is actually active, the elevation label is updated with the proper layer range. </span><span class="koboSpan" id="kobo.253.2">The </span><code class="literal"><span class="koboSpan" id="kobo.254.1">SaveOptions()</span></code><span class="koboSpan" id="kobo.255.1"> callback is then invoked with </span><code class="literal"><span class="koboSpan" id="kobo.256.1">nullptr</span></code><span class="koboSpan" id="kobo.257.1"> for its argument. </span><span class="koboSpan" id="kobo.257.2">It is responsible for actually saving the interface's information to whatever object happens to be selected. </span><span class="koboSpan" id="kobo.257.3">Let us take a look at this method now:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.258.1">void GUI_SelectionOptions::SaveOptions(EventDetails* l_details) { 
  if (m_selectMode == SelectMode::Tiles) { return; } 
 
  auto x = m_selectionOptions-&gt;GetElement("Pos_X")-&gt;GetText(); 
  auto y = m_selectionOptions-&gt;GetElement("Pos_Y")-&gt;GetText(); 
  auto z = m_selectionOptions-&gt;GetElement("Pos_Z")-&gt;GetText(); 
 
  auto c_x = std::stoi(x); 
  auto c_y = std::stoi(y); 
  auto c_z = std::stoi(z); 
 
  if (m_selectMode == SelectMode::Entities) { 
    if (!m_entity || m_entityId == -1) { return; } 
    m_entity-&gt;SetPosition(sf::Vector2f(c_x, c_y)); 
    m_entity-&gt;SetElevation(m_layerSelectLow); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { return; } 
    auto emitRate = m_selectionOptions-&gt; 
      GetElement("EmitRate")-&gt;GetText(); 
    auto c_rate = std::stoi(emitRate); 
    m_emitter-&gt;SetPosition(sf::Vector3f(c_x, c_y, c_z)); 
    m_emitter-&gt;SetEmitRate(c_rate); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.259.1">The most obvious first check is to make sure we are not in tile mode, because there is nothing to save there. </span><span class="koboSpan" id="kobo.259.2">Afterwards, the values from the text-fields representing </span><span class="emphasis"><em><span class="koboSpan" id="kobo.260.1">X</span></em></span><span class="koboSpan" id="kobo.261.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.262.1">Y</span></em></span><span class="koboSpan" id="kobo.263.1">, and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.264.1">Z</span></em></span><span class="koboSpan" id="kobo.265.1"> coordinates are obtained and converted to numbers. </span><span class="koboSpan" id="kobo.265.2">This is where our logic branches out once again.</span></p><p><span class="koboSpan" id="kobo.266.1">In the case of dealing with an entity, we must first make sure one is selected. </span><span class="koboSpan" id="kobo.266.2">If it is, its position is changed to that of the values just obtained from the interface. </span><span class="koboSpan" id="kobo.266.3">We do not need to use the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.267.1">Z</span></em></span><span class="koboSpan" id="kobo.268.1"> coordinate here, because that is replaced by the elevation.</span></p><p><span class="koboSpan" id="kobo.269.1">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.270.1">Z</span></em></span><span class="koboSpan" id="kobo.271.1"> coordinate is, however, used when dealing with particle emitters. </span><span class="koboSpan" id="kobo.271.2">After obtaining the additional value of the emit rate from the interface and converting it to a proper number, all of these values are applied to the current particle emitter selected.</span></p><p><span class="koboSpan" id="kobo.272.1">Now, the piece of code that makes everything else tick:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.273.1">void GUI_SelectionOptions::Update() { 
  if (m_selectUpdate) { UpdateSelectDrawable(); } 
  if (!m_mapControls-&gt;IsInAction()) { return; } 
  if (m_selectMode == SelectMode::Tiles) {UpdateTileSelection();} 
  else if (m_selectMode == SelectMode::Entities) { 
    UpdateEntitySelection(); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    UpdateEmitterSelection(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.274.1">At this point, we want to make sure the selection drawable is updated, provided the </span><code class="literal"><span class="koboSpan" id="kobo.275.1">m_selectUpdate</span></code><span class="koboSpan" id="kobo.276.1"> flag is enabled. </span><span class="koboSpan" id="kobo.276.2">The rest of the code can be skipped if the </span><code class="literal"><span class="koboSpan" id="kobo.277.1">mapControls</span></code><span class="koboSpan" id="kobo.278.1"> class is not letting us know that the left mouse button is pressed. </span><span class="koboSpan" id="kobo.278.2">However, if it is, an appropriate update method is invoked, depending on what </span><code class="literal"><span class="koboSpan" id="kobo.279.1">selectMode</span></code><span class="koboSpan" id="kobo.280.1"> the interface is in.</span></p><p><span class="koboSpan" id="kobo.281.1">A good way to keep an application looking neat and responsive is having neat indicators of certain selections being made, like so:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.282.1"><img src="graphics/image_05_003.jpg" alt="Implementing selection options"/></span></div><p><span class="koboSpan" id="kobo.283.1">Let us take a look at how the selection rectangle can be updated for entities and emitters:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.284.1">void GUI_SelectionOptions::UpdateSelectDrawable() { 
  if (m_selectMode == SelectMode::Entities) { 
    if (m_entityId == -1) { return; } 
    if (!m_entity) { return; } 
    if (m_entityManager-&gt;HasComponent(m_entityId, 
      Component::Collidable)) 
    { 
      auto col = m_entityManager-&gt; 
        GetComponent&lt;C_Collidable&gt;(m_entityId, 
        Component::Collidable); 
      auto primitive = col-&gt;GetCollidable(); 
      m_selectDrawable.setPosition(primitive.left, primitive.top); 
      m_selectDrawable.setSize( 
        sf::Vector2f(primitive.width, primitive.height)); 
    } else if (m_entityManager-&gt;HasComponent(m_entityId, 
      Component::SpriteSheet)) 
    { 
      auto drawable = m_entityManager-&gt; 
        GetComponent&lt;C_SpriteSheet&gt;(m_entityId, 
        Component::SpriteSheet); 
      auto pos = drawable-&gt;GetSpriteSheet()-&gt;GetSpritePosition(); 
      auto size = drawable-&gt;GetSpriteSheet()-&gt;GetSpriteSize(); 
      m_selectDrawable.setPosition(pos); 
      m_selectDrawable.setSize(sf::Vector2f(size)); 
    } else { 
      m_selectDrawable.setPosition( 
        m_entity-&gt;GetPosition() - sf::Vector2f(16.f, 16.f)); 
      m_selectDrawable.setSize(sf::Vector2f(32.f, 32.f)); 
    } 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { return; } 
    auto pos = sf::Vector2f( 
      m_emitter-&gt;GetPosition().x, m_emitter-&gt;GetPosition().y); 
    m_selectDrawable.setPosition(pos - sf::Vector2f(16.f, 16.f)); 
    m_selectDrawable.setSize(sf::Vector2f(32.f, 32.f)); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.285.1">As always, our logic branches out, depending on the selection mode we are in. </span><span class="koboSpan" id="kobo.285.2">Provided we are working with entities, a few checks are necessary in order to make sure one is selected. </span><span class="koboSpan" id="kobo.285.3">If it is, the next problem at hand is giving the rectangle a proper size, origin, and position. </span><span class="koboSpan" id="kobo.285.4">The easiest way to do that is by obtaining the colloidal component of an entity and manipulating it based on the collision primitive. </span><span class="koboSpan" id="kobo.285.5">If the entity doesn't have that type of component, we attempt to use the next best thing - its sprite sheet. </span><span class="koboSpan" id="kobo.285.6">Finally, if there's only a position component to work with, the rectangle is centered at the entity's position and given a fixed size of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.286.1">32x32</span></em></span><span class="koboSpan" id="kobo.287.1">.</span></p><p><span class="koboSpan" id="kobo.288.1">Dealing with emitters is quite similar, minus the entire component headache. </span><span class="koboSpan" id="kobo.288.2">Provided one is selected, its 2D position is obtained and used to centre the rectangle, while giving it a static size of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.289.1">32x32</span></em></span><span class="koboSpan" id="kobo.290.1">.</span></p><p><span class="koboSpan" id="kobo.291.1">Let us move on to updating the tile selection next:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.292.1">void GUI_SelectionOptions::UpdateTileSelection() { 
  auto&amp; tileStart = m_mapControls-&gt;GetMouseTileStart(); 
  auto&amp; mouseTile = m_mapControls-&gt;GetMouseTile(); 
 
  auto start = sf::Vector2f( 
    (tileStart.x + (tileStart.x &gt; mouseTile.x ? </span><span class="koboSpan" id="kobo.292.2">1 : 0)) 
      * Sheet::Tile_Size, 
    (tileStart.y + (tileStart.y &gt; mouseTile.y ? </span><span class="koboSpan" id="kobo.292.3">1 : 0)) 
      * Sheet::Tile_Size 
  ); 
 
  auto end = sf::Vector2f( 
    (mouseTile.x + (tileStart.x &lt;= mouseTile.x ? </span><span class="koboSpan" id="kobo.292.4">1 : 0)) 
      * Sheet::Tile_Size, 
    (mouseTile.y + (tileStart.y &lt;= mouseTile.y ? </span><span class="koboSpan" id="kobo.292.5">1 : 0)) 
      * Sheet::Tile_Size 
  ); 
 
  m_selectDrawable.setPosition( 
    (start.x &lt;= end.x ? </span><span class="koboSpan" id="kobo.292.6">start.x : end.x), 
    (start.y &lt;= end.y ? </span><span class="koboSpan" id="kobo.292.7">start.y : end.y) 
  ); 
 
  m_selectDrawable.setFillColor(m_selectStartColor); 
  m_selectDrawable.setSize({ 
    std::abs(end.x - start.x), 
    std::abs(end.y - start.y) 
  }); 
  m_selectRangeX = sf::Vector2i( 
    std::min(tileStart.x, mouseTile.x), 
    std::max(tileStart.x, mouseTile.x) 
  ); 
  m_selectRangeY = sf::Vector2i( 
    std::min(tileStart.y, mouseTile.y), 
    std::max(tileStart.y, mouseTile.y) 
  ); 
} 
</span></pre><p><span class="koboSpan" id="kobo.293.1">This is the actual method that handles tile selection logic. </span><span class="koboSpan" id="kobo.293.2">First, the coordinates of the starting tile that got clicked are obtained along with the current mouse position in tile coordinates. </span><span class="koboSpan" id="kobo.293.3">This information is used to calculate absolute global coordinates for the rectangle that will be used to represent the selection. </span><span class="koboSpan" id="kobo.293.4">The actual rectangle is then updated with this information, as well as set to have the </span><code class="literal"><span class="koboSpan" id="kobo.294.1">m_selectStartColor</span></code><span class="koboSpan" id="kobo.295.1"> color. </span><span class="koboSpan" id="kobo.295.2">Finally, all that is left to do is save this information as the current selection range, making sure it is in ascending order.</span></p><p><span class="koboSpan" id="kobo.296.1">Next, updating entity selection deserves a peek:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.297.1">void GUI_SelectionOptions::UpdateEntitySelection() { 
  if (!m_mapControls-&gt;IsInAction()) { return; } 
  if (!m_entity) { return; } 
  m_entity-&gt;MoveBy(m_mapControls-&gt;GetMouseDifference()); 
  auto elevation = m_entity-&gt;GetElevation(); 
  m_selectionOptions-&gt;GetElement("Pos_X")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;( 
      m_entity-&gt;GetPosition().x))); 
  m_selectionOptions-&gt;GetElement("Pos_Y")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;( 
      m_entity-&gt;GetPosition().y))); 
  m_selectionOptions-&gt;GetElement("Elevation")-&gt; 
    SetText(std::to_string(elevation)); 
  m_layerSelectLow = elevation; 
  m_layerSelectHigh = elevation; 
  m_selectUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.298.1">A check is needed to make sure the </span><code class="literal"><span class="koboSpan" id="kobo.299.1">mapControls</span></code><span class="koboSpan" id="kobo.300.1"> are in action in the same fashion as tile updating. </span><span class="koboSpan" id="kobo.300.2">Also, we obviously cannot update an entity that is not even selected, so a check is needed for that as well. </span><span class="koboSpan" id="kobo.300.3">The final bit of logic simply deals with moving the entity by the mouse position difference and updating our </span><code class="literal"><span class="koboSpan" id="kobo.301.1">selectionOptions</span></code><span class="koboSpan" id="kobo.302.1"> interface to hold its current position and elevation. </span><span class="koboSpan" id="kobo.302.2">The layer selection range is also updated to hold the elevation information. </span><span class="koboSpan" id="kobo.302.3">Finally, the select update flag is set to </span><code class="literal"><span class="koboSpan" id="kobo.303.1">true</span></code><span class="koboSpan" id="kobo.304.1">, which requests the selection rectangle to be updated.</span></p><p><span class="koboSpan" id="kobo.305.1">It's time to wrap up the updating logic. </span><span class="koboSpan" id="kobo.305.2">The only remaining mode left to update is the particle emitter selection:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.306.1">void GUI_SelectionOptions::UpdateEmitterSelection() { 
  if (!m_mapControls-&gt;IsInAction()) { return; } 
  if (!m_emitter) { return; } 
  auto emitPos = m_emitter-&gt;GetPosition(); 
  auto position = sf::Vector2f(emitPos.x, emitPos.y); 
  position += m_mapControls-&gt;GetMouseDifference(); 
  m_emitter-&gt;SetPosition( 
    { position.x, position.y, m_emitter-&gt;GetPosition().z }); 
  m_selectionOptions-&gt;GetElement("Pos_X")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;(emitPos.x))); 
  m_selectionOptions-&gt;GetElement("Pos_Y")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;(emitPos.y))); 
  m_selectionOptions-&gt;GetElement("Pos_Z")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;(emitPos.z))); 
  m_selectUpdate = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.307.1">Just as before, the map control primary action flag is checked before proceeding, as well as the actual selection being made. </span><span class="koboSpan" id="kobo.307.2">The </span><code class="literal"><span class="koboSpan" id="kobo.308.1">X</span></code><span class="koboSpan" id="kobo.309.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.310.1">Y</span></code><span class="koboSpan" id="kobo.311.1"> attributes of the particle emitter position are pushed by the mouse delta, while the </span><code class="literal"><span class="koboSpan" id="kobo.312.1">Z</span></code><span class="koboSpan" id="kobo.313.1"> coordinate is preserved as is. </span><span class="koboSpan" id="kobo.313.2">Afterwards, it is only a matter of updating the interface with the most recent position of the particle emitter, and marking the selection drawable for updating.</span></p><p><span class="koboSpan" id="kobo.314.1">The last few pieces of the puzzle involve us dealing with mouse input correctly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.315.1">bool GUI_SelectionOptions::MouseClick(const sf::Vector2f&amp; l_pos) { 
  if (m_selectMode == SelectMode::Tiles) { return true; } 
  bool madeSelection = false; 
  if (m_selectMode == SelectMode::Entities) { 
    int entity = -1; 
    if (m_mapControls-&gt;DrawSelectedLayers()) { 
      entity = m_entityManager-&gt;FindEntityAtPoint(l_pos, 
        m_layerSelectLow, m_layerSelectHigh); 
    } else { 
      entity = m_entityManager-&gt;FindEntityAtPoint(l_pos); 
    } 
    SelectEntity(entity); 
    madeSelection = entity != -1; 
  } else if (m_selectMode == SelectMode::Emitters) { 
    Emitter* emitter = nullptr; 
    if (m_mapControls-&gt;DrawSelectedLayers()) { 
      emitter = m_particleSystem-&gt;FindEmitter(l_pos, 
        sf::Vector2f(32.f, 32.f), m_layerSelectLow, 
          m_layerSelectHigh); 
    } else { 
      emitter = m_particleSystem-&gt;FindEmitter( 
        l_pos, sf::Vector2f(32.f, 32.f)); 
    } 
    SelectEmitter(emitter); 
    madeSelection = emitter != nullptr; 
  } 
  if (!madeSelection) { 
    m_selectionOptions-&gt;GetElement("Pos_X")-&gt; 
      SetText(std::to_string(static_cast&lt;int&gt;(l_pos.x))); 
    m_selectionOptions-&gt;GetElement("Pos_Y")-&gt; 
      SetText(std::to_string(static_cast&lt;int&gt;(l_pos.y))); 
  } 
  return madeSelection; 
} 
</span></pre><p><span class="koboSpan" id="kobo.316.1">As you recall from the previous chapter, this method is invoked by the </span><code class="literal"><span class="koboSpan" id="kobo.317.1">mapControls</span></code><span class="koboSpan" id="kobo.318.1"> class. </span><span class="koboSpan" id="kobo.318.2">It is required to return a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.319.1">boolean</span></em></span><span class="koboSpan" id="kobo.320.1"> value that denotes whether a selection has been made or not, so that the </span><code class="literal"><span class="koboSpan" id="kobo.321.1">mapControls</span></code><span class="koboSpan" id="kobo.322.1"> class can deal with its own logic if the set of tools can give the artist a boost they have been looking for
latter is true. </span><span class="koboSpan" id="kobo.322.2">When dealing with tiles, this method always needs to return </span><code class="literal"><span class="koboSpan" id="kobo.323.1">true</span></code><span class="koboSpan" id="kobo.324.1">, allowing the control class to know that an action is taking place regardless.</span></p><p><span class="koboSpan" id="kobo.325.1">While in entity mode, the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">FindEntityAtPoint</span></code><span class="koboSpan" id="kobo.327.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.328.1">entityManager</span></code><span class="koboSpan" id="kobo.329.1"> class is invoked, with the global position, as well as the layer selection range being passed in as arguments. </span><span class="koboSpan" id="kobo.329.2">The latter is only true if the user of the tile editor has decided to only make selected layers visible. </span><span class="koboSpan" id="kobo.329.3">It will return an entity ID if an entity has been found at a specific point in space, which is then used to call </span><code class="literal"><span class="koboSpan" id="kobo.330.1">SelectEntity</span></code><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">To determine whether an entity has been selected, the ID is checked for not being equal to a known value for </span><span class="emphasis"><em><span class="koboSpan" id="kobo.332.1">not found</span></em></span><span class="koboSpan" id="kobo.333.1">.</span></p><p><span class="koboSpan" id="kobo.334.1">A very similar procedure is used to select a particle emitter. </span><span class="koboSpan" id="kobo.334.2">Because most emitters are single points in space, a </span><code class="literal"><span class="koboSpan" id="kobo.335.1">sf::Vector2f</span></code><span class="koboSpan" id="kobo.336.1"> needs to be used here simply to define the area around the position that can be clicked in order to select it.</span></p><p><span class="koboSpan" id="kobo.337.1">Lastly, if a selection hasn't been made, the position text-fields of the selection options interface are filled in with the global coordinates of the click. </span><span class="koboSpan" id="kobo.337.2">This allows easier positioning of objects in the world before placement.</span></p><p><span class="koboSpan" id="kobo.338.1">Surprisingly, quite a lot needs to happen when a mouse button is released. </span><span class="koboSpan" id="kobo.338.2">Let's take a look:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.339.1">void GUI_SelectionOptions::MouseRelease() { 
  if (m_selectMode == SelectMode::Tiles) { 
    m_selectDrawable.setFillColor(m_selectEndColor); 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(true); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(true); 
 
    bool solid = false, mixed = false; 
    unsigned short changes = 0; 
    for (auto x = m_selectRangeX.x; x &lt;= m_selectRangeX.y 
      &amp;&amp; !mixed; ++x) 
    { 
      for (auto y = m_selectRangeY.x; y &lt;= m_selectRangeY.y 
        &amp;&amp; !mixed; ++y) 
      { 
        for (auto layer = m_layerSelectLow; 
          layer &lt;= m_layerSelectHigh &amp;&amp; !mixed; ++layer) 
        { 
          auto tile = m_map-&gt;GetTile(x, y, layer); 
          if (!tile) { continue; } 
          if (tile-&gt;m_solid &amp;&amp; !solid) { 
            solid = true; 
            ++changes; 
          } else if (tile-&gt;m_solid &amp;&amp; !solid) { 
            solid = false; 
            ++changes; 
          } 
          if (changes &gt;= 2) { mixed = true; } 
        } 
      } 
    } 
    m_selectionOptions-&gt;GetElement("Solidity")-&gt; 
      SetText((mixed ? </span><span class="koboSpan" id="kobo.339.2">"Mixed" : (solid ? </span><span class="koboSpan" id="kobo.339.3">"True" : "False"))); 
  } else if (m_selectMode == SelectMode::Entities) { 
    m_selectDrawable.setFillColor(m_entityColor); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    m_selectDrawable.setFillColor(m_emitterColor); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.340.1">Most of this logic is concerned with dealing with tile selection. </span><span class="koboSpan" id="kobo.340.2">The first thing we need to worry about is setting the selection rectangle to its final color, indicating the selection is made. </span><span class="koboSpan" id="kobo.340.3">After that, the interface buttons for copying and removing the selection are made visible, and a loop is used to check the selection in order to determine the solidity situation of the entire chunk, which is then saved to the appropriate interface element.</span></p><p><span class="koboSpan" id="kobo.341.1">The entity and emitter modes do not need quite as much maintenance for such a simple task. </span><span class="koboSpan" id="kobo.341.2">All we need to worry about here is setting the selection rectangle colors appropriately.</span></p><p><span class="koboSpan" id="kobo.342.1">As modes are being switched, all of the important data needs to be reset in order to avoid strange bugs:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.343.1">void GUI_SelectionOptions::Reset() { 
  auto defaultVector = sf::Vector2i(-1, -1); 
  m_selectRangeX = defaultVector; 
  m_selectRangeY = defaultVector; 
  m_entityId = -1; 
  m_entity = nullptr; 
  m_emitter = nullptr; 
  static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
    GetMenu()-&gt;ResetSelected(); 
  ... </span><span class="koboSpan" id="kobo.343.2">// GUI Element manipulation. 
</span><span class="koboSpan" id="kobo.343.3">} 
</span></pre><p><span class="koboSpan" id="kobo.344.1">In addition to ranges and IDs being reset, the actual selection of the </span><code class="literal"><span class="koboSpan" id="kobo.345.1">DropDownMenu</span></code><span class="koboSpan" id="kobo.346.1"> of entities/emitters needs zeroing-out. </span><span class="koboSpan" id="kobo.346.2">Finally, all of the mode-specific GUI elements we have been working with need to be disabled and/or set to their neutral values.</span></p><p><span class="koboSpan" id="kobo.347.1">Finally, we are left with only one essential chunk of code left to cover - the </span><code class="literal"><span class="koboSpan" id="kobo.348.1">Draw()</span></code><span class="koboSpan" id="kobo.349.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.350.1">void GUI_SelectionOptions::Draw(sf::RenderWindow* l_window) { 
  auto mode = m_mapControls-&gt;GetMode(); 
  if (mode == ControlMode::Select) { 
    if (m_selectMode == SelectMode::Tiles &amp;&amp; 
      m_selectRangeX.x == -1) 
    { return; } 
    if (m_selectMode == SelectMode::Entities &amp;&amp; !m_entity) 
    { return; } 
    if (m_selectMode == SelectMode::Emitters &amp;&amp; !m_emitter) 
    { return; } 
    l_window-&gt;draw(m_selectDrawable); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.351.1">The only thing that we really need to draw is the selection rectangle. </span><span class="koboSpan" id="kobo.351.2">As it is quite evident here, it does not need to be drawn if no selection of any kind has been made. </span><span class="koboSpan" id="kobo.351.3">This includes checking all three select modes.</span></p><p><span class="koboSpan" id="kobo.352.1">For the sake of completion, we only have a couple of getter methods left to look over:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.353.1">unsigned int GUI_SelectionOptions::GetLowestLayer() const{ 
  return m_layerSelectLow; 
} 
unsigned int GUI_SelectionOptions::GetHighestLayer() const{  
  return m_layerSelectHigh; 
} 
SelectMode GUI_SelectionOptions::GetSelectMode() const{ 
  return m_selectMode; 
} 
sf::Vector2i GUI_SelectionOptions::GetSelectXRange() const{ 
  return sf::Vector2i( 
    std::min(m_selectRangeX.x, m_selectRangeX.y), 
    std::max(m_selectRangeX.x, m_selectRangeX.y)); 
} 
sf::Vector2i GUI_SelectionOptions::GetSelectYRange() const{ 
  return sf::Vector2i( 
    std::min(m_selectRangeY.x, m_selectRangeY.y), 
    std::max(m_selectRangeY.x, m_selectRangeY.y)); 
} 
</span></pre><p><span class="koboSpan" id="kobo.354.1">This concludes the </span><code class="literal"><span class="koboSpan" id="kobo.355.1">selectionOptions</span></code><span class="koboSpan" id="kobo.356.1"> class.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building the tile selector"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/><span class="koboSpan" id="kobo.1.1">Building the tile selector</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">When working with tile maps, it is important to have a fast and intuitive way of accessing the tile-sheet, selecting its contents and painting them directly onto the game map. </span><span class="koboSpan" id="kobo.2.2">A good set of tools can give the artist the boost they have been looking for, while an unmanageable application is only a hindrance. </span><span class="koboSpan" id="kobo.2.3">Let us take a peek at what we are going to be building:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.3.1"><img src="graphics/image_05_004.jpg" alt="Building the tile selector"/></span></div><p><span class="koboSpan" id="kobo.4.1">This interface, just like most others we have been working with, is going to be much easier to manage when wrapped in a class of its own:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class GUI_MapTileSelector { 
public: 
  GUI_MapTileSelector(EventManager* l_eventManager, 
    GUI_Manager* l_guiManager, TextureManager* l_textureManager); 
  ~GUI_MapTileSelector(); 
  void Show(); 
  void Hide(); 
  bool IsActive() const; 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.6.1">void SetSheetTexture(const std::string&amp; l_texture);</span></strong></span><span class="koboSpan" id="kobo.7.1"> 
  void UpdateInterface(); 
  bool CopySelection(TileMap&amp; l_tileMap) const; 
  void TileSelect(EventDetails* l_details); 
  void Close(EventDetails* l_details); 
private: 
  EventManager* m_eventManager; 
  GUI_Manager* m_guiManager; 
  TextureManager* m_textureManager; 
   
  GUI_Interface* m_interface; 
  sf::RenderTexture m_selectorTexture; 
  sf::Sprite m_tileMapSprite; 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">sf::RectangleShape m_shape;</span></strong></span><span class="koboSpan" id="kobo.9.1"> 
  std::string m_sheetTexture; 
 
  sf::Vector2u m_startCoords; 
  sf::Vector2u m_endCoords; 
  bool m_selected; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Just like before, we have </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Show()</span></code><span class="koboSpan" id="kobo.12.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Hide()</span></code><span class="koboSpan" id="kobo.14.1"> methods to manage its visibility, as well as a couple of callbacks. </span><span class="koboSpan" id="kobo.14.2">Note the highlighted method. </span><span class="koboSpan" id="kobo.14.3">It is going to be used for setting the texture of the tile-sheet the map is using.</span></p><p><span class="koboSpan" id="kobo.15.1">The data members are quite predictable for a class like this. </span><span class="koboSpan" id="kobo.15.2">Alongside the classes that this object relies on, we keep track of a pointer to the actual interface it is going to be manipulating, an instance of a </span><code class="literal"><span class="koboSpan" id="kobo.16.1">sf::RenderTexture</span></code><span class="koboSpan" id="kobo.17.1"> that we are going to be drawing to, the sprite that will be used to display the render texture, a rectangle shape, start and end coordinates, and a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">boolean</span></em></span><span class="koboSpan" id="kobo.19.1"> flag for the actual selection drawable. </span><span class="koboSpan" id="kobo.19.2">Lastly, </span><code class="literal"><span class="koboSpan" id="kobo.20.1">m_sheetTexture</span></code><span class="koboSpan" id="kobo.21.1"> is going to simply keep track of the texture identifier until it is time to release it.</span></p><div class="section" title="Implementing the tile selector"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/><span class="koboSpan" id="kobo.22.1">Implementing the tile selector</span></h2></div></div></div><p><span class="koboSpan" id="kobo.23.1">Let us begin by setting all of this data up inside the constructor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">GUI_MapTileSelector::GUI_MapTileSelector( 
  EventManager* l_eventManager, GUI_Manager* l_guiManager, 
  TextureManager* l_textureManager) : 
  m_eventManager(l_eventManager), m_guiManager(l_guiManager), 
  m_textureManager(l_textureManager), m_selected(false) 
{ 
  m_eventManager-&gt;AddCallback(StateType::MapEditor, 
    "MapEditor_TileSelectClick", 
    &amp;GUI_MapTileSelector::TileSelect, this); 
  m_eventManager-&gt;AddCallback(StateType::MapEditor, 
    "MapEditor_TileSelectRelease", 
    &amp;GUI_MapTileSelector::TileSelect, this); 
  m_eventManager-&gt;AddCallback(StateType::MapEditor,  
    "MapEditor_TileSelectClose", 
    &amp;GUI_MapTileSelector::Close, this); 
 
  m_guiManager-&gt;LoadInterface("MapEditorTileSelect.interface", 
    "MapEditorTileSelect"); 
  m_interface = m_guiManager-&gt;GetInterface("MapEditorTileSelect"); 
  m_interface-&gt;SetContentRectSize( 
    sf::Vector2i(m_interface-&gt;GetSize()-sf::Vector2f(32.f,32.f))); 
  m_interface-&gt;SetContentOffset({ 16.f, 16.f }); 
  m_interface-&gt;PositionCenterScreen(); 
  m_interface-&gt;SetActive(false); 
 
  m_shape.setFillColor({ 0, 0, 150, 150 }); 
  m_shape.setSize({ Sheet::Tile_Size, Sheet::Tile_Size }); 
  m_shape.setPosition(0.f, 0.f); 
} 
</span></pre><p><span class="koboSpan" id="kobo.25.1">After the arguments are taken care of, the three callback methods we need are set up. </span><span class="koboSpan" id="kobo.25.2">The interface is then loaded and stored as one of the data members, just before its content rectangle size and offset are changed in order to allow space for control elements, such as the close button to be positioned comfortably. </span><span class="koboSpan" id="kobo.25.3">The interface is then centered on–screen and set to inactive. </span><span class="koboSpan" id="kobo.25.4">Finally, the rectangle shape used to represent tile selection is initialized to its default state as well.</span></p><p><span class="koboSpan" id="kobo.26.1">Let us take a look at the destructor of this class next, in order to make sure we are not forgetting to release certain resources:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">GUI_MapTileSelector::~GUI_MapTileSelector() { 
  ... </span><span class="koboSpan" id="kobo.27.2">// Callbacks and interface removal. 
  </span><span class="koboSpan" id="kobo.27.3">if (!m_sheetTexture.empty()) { 
    m_textureManager-&gt;ReleaseResource(m_sheetTexture); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">After all three callbacks are released, it is imperative to make sure the tile-sheet texture is removed as well, provided its identifier is not empty.</span></p><p><span class="koboSpan" id="kobo.29.1">Speaking of the tile-sheet texture, let us see how one can be assigned to this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">void GUI_MapTileSelector::SetSheetTexture( 
  const std::string&amp; l_texture) 
{ 
  if (!m_sheetTexture.empty()) { 
    m_textureManager-&gt;ReleaseResource(m_sheetTexture); 
  } 
  m_sheetTexture = l_texture; 
  m_textureManager-&gt;RequireResource(m_sheetTexture);  
  m_tileMapSprite.setTexture( 
    *m_textureManager-&gt;GetResource(m_sheetTexture)); 
  m_tileMapSprite.setPosition({ 0.f, 0.f }); 
  auto size = m_tileMapSprite.getTexture()-&gt;getSize(); 
  m_selectorTexture.create(size.x, size.y); 
  m_selectorTexture.clear({ 0,0,0,0 }); 
  m_selectorTexture.draw(m_tileMapSprite); 
  m_selectorTexture.display(); 
 
  auto element = static_cast&lt;GUI_Sprite*&gt;( 
    m_interface-&gt;GetElement("TileSprite")); 
  element-&gt;SetTexture(m_selectorTexture); 
} 
</span></pre><p><span class="koboSpan" id="kobo.31.1">After the current tile-sheet texture is properly released, the new one is assigned and retrieved. </span><span class="koboSpan" id="kobo.31.2">Because of this, the actual selector texture that will be passed to the main GUI element of our interface needs to be re-drawn and passed into said element.</span></p><p><span class="koboSpan" id="kobo.32.1">A similar procedure takes place when the interface needs to be updated:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">void GUI_MapTileSelector::UpdateInterface() { 
  m_selectorTexture.clear({ 0,0,0,0 }); 
  m_selectorTexture.draw(m_tileMapSprite); 
  m_selectorTexture.draw(m_shape); 
  m_selectorTexture.display(); 
 
  m_interface-&gt;RequestContentRedraw(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">It simply consists of the tile-sheet, as well as the selector rectangle being drawn to the render texture. </span><span class="koboSpan" id="kobo.34.2">The interface is then instructed to re-draw its content, as it was changed.</span></p><p><span class="koboSpan" id="kobo.35.1">Next, let us provide a way for outside classes to copy the current tile-sheet selection to a </span><code class="literal"><span class="koboSpan" id="kobo.36.1">TileMap</span></code><span class="koboSpan" id="kobo.37.1"> structure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">bool GUI_MapTileSelector::CopySelection(TileMap&amp; l_tileMap) const{ 
  if (!m_selected) { return false; } 
  l_tileMap.Purge(); 
  auto TileCoordsStart = m_startCoords / 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  auto TileCoordsEnd = m_endCoords / 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  auto size = TileCoordsEnd - TileCoordsStart; 
  l_tileMap.SetMapSize(size + sf::Vector2u(1,1)); 
 
  auto sheetSize = m_textureManager-&gt;GetResource( 
    l_tileMap.GetTileSet().GetTextureName())-&gt;getSize(); 
  auto nPerRow = sheetSize.x / Sheet::Tile_Size; 
 
  auto t_x = 0, t_y = 0; 
  for (auto x = TileCoordsStart.x; x &lt;= TileCoordsEnd.x; ++x) { 
    for (auto y = TileCoordsStart.y; y &lt;= TileCoordsEnd.y; ++y) { 
      auto coordinate = (y * nPerRow) + x; 
      auto tile = l_tileMap.SetTile(t_x, t_y, 0, coordinate); 
      // Always layer 0. 
      </span><span class="koboSpan" id="kobo.38.2">if (!tile) { ++t_y; continue; } 
      tile-&gt;m_solid = false; 
      ++t_y; 
    } 
    t_y = 0; 
    ++t_x; 
  } 
  return true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">Obviously, we cannot copy anything if nothing has been selected. </span><span class="koboSpan" id="kobo.39.2">The first check takes care of that. </span><span class="koboSpan" id="kobo.39.3">The </span><code class="literal"><span class="koboSpan" id="kobo.40.1">TileMap</span></code><span class="koboSpan" id="kobo.41.1"> passed in as the argument is then purged in preparation for being overwritten. </span><span class="koboSpan" id="kobo.41.2">The tile coordinate range is then calculated, and the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">TileMap</span></code><span class="koboSpan" id="kobo.43.1"> argument is re-sized to match the size of the selection. </span><span class="koboSpan" id="kobo.43.2">After a couple of local variables are established to help us calculate the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.44.1">1D</span></em></span><span class="koboSpan" id="kobo.45.1"> coordinate index, we begin iterating over the calculated range of tiles one by one, adding them to the tile map. </span><span class="koboSpan" id="kobo.45.2">Because we're not working with any sort of depth when dealing with a tile-sheet, the layer is always going to be set to the value </span><code class="literal"><span class="koboSpan" id="kobo.46.1">0</span></code><span class="koboSpan" id="kobo.47.1">.</span></p><p><span class="koboSpan" id="kobo.48.1">The following code deals with the mouse-click and mouse-release events, which are vital when making a selection:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">void GUI_MapTileSelector::TileSelect(EventDetails* l_details) { 
  if (l_details-&gt;m_name == "MapEditor_TileSelectClick") { 
    m_startCoords = sf::Vector2u(l_details-&gt;m_mouse); 
    m_endCoords = sf::Vector2u(l_details-&gt;m_mouse); 
    m_selected = false; 
  } else { 
    if (l_details-&gt;m_mouse.x &lt; 0 || l_details-&gt;m_mouse.y &lt; 0) { 
      m_endCoords = sf::Vector2u(0, 0); 
      return; 
    } 
    m_endCoords = sf::Vector2u(l_details-&gt;m_mouse); 
    m_selected = true; 
  } 
 
  if (m_startCoords.x &gt; m_endCoords.x) { 
    std::swap(m_startCoords.x, m_endCoords.x); 
  } 
  if (m_startCoords.y &gt; m_endCoords.y) { 
    std::swap(m_startCoords.y, m_endCoords.y); 
  } 
 
  auto start = sf::Vector2i(m_startCoords.x / Sheet::Tile_Size, 
    m_startCoords.y / Sheet::Tile_Size); 
  start *= static_cast&lt;int&gt;(Sheet::Tile_Size); 
  auto end = sf::Vector2i(m_endCoords.x / Sheet::Tile_Size, 
    m_endCoords.y / Sheet::Tile_Size); 
  end *= static_cast&lt;int&gt;(Sheet::Tile_Size); 
 
  m_shape.setPosition(sf::Vector2f(start)); 
  m_shape.setSize(sf::Vector2f(end - start) + 
    sf::Vector2f(Sheet::Tile_Size, Sheet::Tile_Size)); 
  UpdateInterface(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">If we are dealing with a mouse-left click, we simply need to make note of the mouse coordinates at this point in time, as well as reset the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">m_selected</span></code><span class="koboSpan" id="kobo.52.1"> flag to </span><code class="literal"><span class="koboSpan" id="kobo.53.1">false</span></code><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">On the other hand, if the left mouse button has been released, the final mouse position is first checked for not going into negative values on both axes. </span><span class="koboSpan" id="kobo.54.3">The end coordinates are then stored, and the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">m_selected</span></code><span class="koboSpan" id="kobo.56.1"> flag is set to </span><code class="literal"><span class="koboSpan" id="kobo.57.1">true</span></code><span class="koboSpan" id="kobo.58.1">.</span></p><p><span class="koboSpan" id="kobo.59.1">The remaining chunk of code simply deals with making sure the start and end coordinates are stored in an ascending order, and calculating the proper position and size of the selector rectangle. </span><span class="koboSpan" id="kobo.59.2">The </span><code class="literal"><span class="koboSpan" id="kobo.60.1">UpdateInterface()</span></code><span class="koboSpan" id="kobo.61.1"> method is then invoked, which makes sure everything is re-drawn.</span></p><p><span class="koboSpan" id="kobo.62.1">Let us wrap this up by quickly looking over some of the helper methods of this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.63.1">void GUI_MapTileSelector::Close(EventDetails* l_details){ Hide();} 
void GUI_MapTileSelector::Show() { 
  m_interface-&gt;SetActive(true); 
  m_interface-&gt;Focus(); 
} 
void GUI_MapTileSelector::Hide() {m_interface-&gt;SetActive(false);} 
bool GUI_MapTileSelector::IsActive() const{ 
  return m_interface-&gt;IsActive(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.64.1">The </span><code class="literal"><span class="koboSpan" id="kobo.65.1">Show()</span></code><span class="koboSpan" id="kobo.66.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.67.1">Hide()</span></code><span class="koboSpan" id="kobo.68.1"> methods simply manipulate the interfaces activity, while the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">Close</span></code><span class="koboSpan" id="kobo.70.1"> callback just invokes </span><code class="literal"><span class="koboSpan" id="kobo.71.1">Hide</span></code><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">Just like that, all of the pieces fit together and we are left with a fully functional map editor!</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Building tools for a game may not be the easiest or the most pleasant task in the world, but in the end, it always pays off. </span><span class="koboSpan" id="kobo.2.2">Dealing with text files, endless copy-pasting, or other botch-like solutions may work fine in the short term, but nothing beats a fully equipped set of tools, ready to take on any project with the click of a button! </span><span class="koboSpan" id="kobo.2.3">Although the editor we have built is geared towards a very specific task, the idea behind it can, with enough time and energy, be applied to any set of production problems.</span></p><p><span class="koboSpan" id="kobo.3.1">In the next chapter, we are going to be covering the basics and general uses of shaders in SFML. </span><span class="koboSpan" id="kobo.3.2">The OpenGL shading language, along with SFML's built in support for shaders, is going to allow us to create a very basic day and night cycle. </span><span class="koboSpan" id="kobo.3.3">See you there!</span></p></div></div></div></body></html>