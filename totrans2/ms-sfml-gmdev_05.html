<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Filling the Tool Belt - a few More Gadgets</h1></div></div></div><p>The last chapter established a firm ground for us to build on. It is time to take full advantage of it and finish what we started, by building a robust set of tools, ready to take on a wide variety of design problems.</p><p>In this chapter, we are going to be covering these topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementation of selection options</li><li class="listitem" style="list-style-type: disc">Design and programming of a tile selection window</li><li class="listitem" style="list-style-type: disc">Management of entities</li></ul></div><p>There is quite a lot of code to cover, so let us just jump into it!</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Planning the selection options</h1></div></div></div><p>Versatile selection options are important when creating a responsive and useful application. Without them, any sort of software can feel unintuitive, clunky, or unresponsive at best. In this particular case, we are going to be dealing with selecting, copying, and placing tiles, entities, and particle emitters.</p><p>Let us see what such an interface might look like:</p><div><img src="img/image_05_001.jpg" alt="Planning the selection options"/></div><p>In order to get there, we need to create a flexible class, designed to be able to handle any possible combination of options and controls. Let us start by going over the most basic data types that are going to come in handy when developing this system:</p><pre class="programlisting">enum class SelectMode{ Tiles, Entities, Emitters }; 
using NameList = std::vector&lt;std::pair&lt;std::string, bool&gt;&gt;; 
</pre><p>First, the selection mode needs to be enumerated. As shown in the preceding snippet, there are three modes we are going to be working with at the moment, although this list can easily be expanded in the future. The <code class="literal">NameList</code> data type is going to be used to store the contents of entity and particle directories. This is simply the return format for the utility function we are going to be relying on.</p><p>With the data types out of the way, let us take a stab at creating the blueprint of our <code class="literal">SelectionOptions</code> class:</p><pre class="programlisting">class GUI_SelectionOptions { 
public: 
  GUI_SelectionOptions(EventManager* l_eventManager, 
    GUI_Manager* l_guiManager, MapControls* l_controls, 
    GUI_MapTileSelector* l_selector, Map* l_map, TileMap* l_brush, 
    EntityManager* l_entityMgr, ParticleSystem* l_particles); 
  ~GUI_SelectionOptions(); 
 
  void Show(); 
  void Hide(); 
  void SetControlMode(ControlMode l_mode); 
  void SetSelectMode(SelectMode l_mode); 
  SelectMode GetSelectMode()const; 
  void SelectEntity(int l_id); 
  void SelectEmitter(Emitter* l_emitter); 
  sf::Vector2i GetSelectXRange() const; 
  sf::Vector2i GetSelectYRange() const; 
  unsigned int GetLowestLayer() const; 
  unsigned int GetHighestLayer() const; 
 
  void Update(); 
  void Draw(sf::RenderWindow* l_window); 
  bool MouseClick(const sf::Vector2f&amp; l_pos); 
  void MouseRelease(); 
  void Reset(); 
 
  void SelectModeSwitch(EventDetails* l_details); 
  void OpenTileSelection(EventDetails* l_details); 
  void SolidToggle(EventDetails* l_details); 
  void CopySelection(EventDetails* l_details); 
  void PlaceSelection(EventDetails* l_details); 
  void RemoveSelection(EventDetails* l_details); 
  void ToggleLayers(EventDetails* l_details); 
  void SelectionOptionsElevation(EventDetails* l_details); 
  void SaveOptions(EventDetails* l_details); 
private: 
  void SelectionElevationUpdate(); 
  void UpdateSelectDrawable(); 
  void UpdateTileSelection(); 
  void UpdateEntitySelection(); 
  void UpdateEmitterSelection(); 
  void DeleteSelection(bool l_deleteAll); 
  ... 
}; 
</pre><p>In order to keep things simple, let us focus on talking about the methods we need first, before covering data members. As far as public methods go, we have pretty much the assortment anyone would expect. Alongside the <code class="literal">Show()</code> and <code class="literal">Hide()</code> methods, which are going to be used to manipulate the interface this class encapsulates, we pretty much only have a few setters and getters, used to manipulate the <code class="literal">ControlMode</code> and <code class="literal">SelectMode</code>, select specific entities or particle emitters, and obtain tile selection ranges, as well as the range of layer visibility/selection. Additionally, this class also needs to provide plenty of callback methods for numerous controls of the interface we are working with.</p><p>The private methods mainly consist of code used to update the interface and the visual representation of its selection onscreen, as well as methods for updating each possible mode the selection interface can be in. It's topped off by a private method <code class="literal">DeleteSelection()</code>, which is going to be useful when removing tiles, entities, or particle emitters.</p><p>Finally, let us take a gander at all of the data members that are going to be used to preserve the state of this class:</p><pre class="programlisting">class GUI_SelectionOptions { 
private: 
  ... 
  // Selection data. 
  SelectMode m_selectMode; 
  sf::RectangleShape m_selectDrawable; 
  sf::Color m_selectStartColor; 
  sf::Color m_selectEndColor; 
  sf::Color m_entityColor; 
  sf::Color m_emitterColor; 
  sf::Vector2i m_selectRangeX; 
  sf::Vector2i m_selectRangeY; 
  bool m_selectUpdate; 
  // Entity and emitter select info. 
  int m_entityId; 
  C_Position* m_entity; 
  Emitter* m_emitter; 
  NameList m_entityNames; 
  NameList m_emitterNames; 
  // Selection range. 
  unsigned int m_layerSelectLow; 
  unsigned int m_layerSelectHigh; 
  // Interfaces. 
  GUI_Interface* m_selectionOptions; 
  MapControls* m_mapControls; 
  GUI_MapTileSelector* m_tileSelector; 
  // Class ties. 
  EventManager* m_eventManager; 
  GUI_Manager* m_guiManager; 
  Map* m_map; 
  TileMap* m_brush; 
  EntityManager* m_entityManager; 
  ParticleSystem* m_particleSystem; 
}; 
</pre><p>We start by storing the current selection mode, alongside the <code class="literal">RectangleShape</code> object, used to visually represent the selection being made. In order to make our tools feel more responsive and lively, we are going to be providing a number of different colors, used to represent different states of selection. For example, the <code class="literal">m_selectStartColor</code> and <code class="literal">m_selectEndColor</code> data members are used to differentiate the tile selection that's still being made, and its final state, when the mouse button is released. In addition to colors, we also have two vector types that store the tile selection range for both axes, and a <em>boolean</em> flag, used to determine when the rectangle shape should be updated.</p><p>For the other two states, we need to store the entity identifier and its position component, given we are in an entity selection mode, and a pointer to the particle emitter, provided we are currently working with particles. This is also where the contents of particle and entity directories are going to be stored, in order to populate the drop-down list with the appropriate values.</p><p>Additionally, we need to keep track of the layer selection range, as well as pointers to the <code class="literal">selectionOptions</code> interface, the <code class="literal">MapControl</code> class that was covered in the previous chapter, and a map tile selector class, which will be covered shortly. Keep in mind that only the <code class="literal">m_selectionOptions</code> interface is technically owned by this class. The other two classes encapsulate their own interfaces, thus managing their destruction.</p><p>Lastly, we need to have access to the <code class="literal">eventManager</code>, <code class="literal">guimanager</code>, the game <code class="literal">map</code> instance, the tile <code class="literal">brush</code>, entityManager, and the <code class="literal">particleSystem</code>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Implementing selection options</h2></div></div></div><p>With all of this data to properly initialize, we have quite a lot of work to do in the constructor:</p><pre class="programlisting">GUI_SelectionOptions::GUI_SelectionOptions( 
  EventManager* l_eventManager, GUI_Manager* l_guiManager, 
  MapControls* l_controls, GUI_MapTileSelector* l_selector, 
  Map* l_map, TileMap* l_brush, EntityManager* l_entityMgr, 
  ParticleSystem* l_particles) : 
  /* Processing arguments. */ 
  m_eventManager(l_eventManager), m_guiManager(l_guiManager), 
  m_mapControls(l_controls), m_tileSelector(l_selector), 
  m_map(l_map), m_brush(l_brush), m_entityManager(l_entityMgr), 
  m_particleSystem(l_particles), 
  /* Initializing default values of data members. */ 
  m_selectRangeX(-1, -1), m_selectRangeY(-1, -1), 
  m_layerSelectLow(0), m_layerSelectHigh(0), 
  m_selectMode(SelectMode::Tiles), m_entityId(-1), 
  m_entity(nullptr), m_emitter(nullptr), m_selectUpdate(true) 
{...} 
</pre><p>After all of the arguments are properly stored away, the default values of all data members are set up. This ensures that the initial state of the selection is defined. The body of the constructor is used to appropriately deal with other tasks:</p><pre class="programlisting">GUI_SelectionOptions::GUI_SelectionOptions(...) 
{ 
  ... // Setting up callbacks. 
  m_guiManager-&gt;LoadInterface( 
    "MapEditorSelectionOptions.interface", 
    "MapEditorSelectionOptions"); 
  m_selectionOptions =  
    m_guiManager-&gt;GetInterface("MapEditorSelectionOptions"); 
  m_selectionOptions-&gt;SetPosition({ 0.f, 164.f }); 
  m_selectionOptions-&gt;SetActive(false); 
  m_selectStartColor = sf::Color(0, 0, 150, 120); 
  m_selectEndColor = sf::Color(0, 0, 255, 150); 
  m_entityColor = sf::Color(255, 0, 0, 150); 
  m_emitterColor = sf::Color(0, 255, 0, 150); 
 
  m_entityNames = Utils::GetFileList(Utils::GetWorkingDirectory() 
    + "media/Entities/", "*.entity"); 
  m_emitterNames = Utils::GetFileList(Utils::GetWorkingDirectory() 
    + "media/Particles/", "*.particle"); 
} 
</pre><p>Here, all of the proper callbacks are set up, the interface the class owns is loaded, positioned and hidden, and the color values are initialized. Finally, the contents of the entity and particle emitter directories are obtained and stored.</p><p>We're not going to be covering the destructor here, because it simply deals with removing all callbacks and the interface that is set up.</p><p>Speaking of interfaces, the outside code needs to be able to easily show and hide the <code class="literal">selectionOptions</code> window:</p><pre class="programlisting">void GUI_SelectionOptions::Show() { 
  m_selectionOptions-&gt;SetActive(true); 
  m_guiManager-&gt;BringToFront(m_selectionOptions); 
} 
void GUI_SelectionOptions::Hide() { 
  m_selectionOptions-&gt;SetActive(false); 
} 
</pre><p>The desired effect is achieved by either setting the interface as active or inactive. In the former case, the <code class="literal">guiManager</code> is also used in order to position the <code class="literal">selectionOptions</code> interface above everything else, by bringing it to the front.</p><p>Because this interface/class is a sort of helper, it depends on the control mode of our editor. This relationship requires the <code class="literal">selectionOptions</code> class to be notified of <code class="literal">controlMode</code> changes:</p><pre class="programlisting">void GUI_SelectionOptions::SetControlMode(ControlMode l_mode) { 
  if (l_mode != ControlMode::Brush &amp;&amp; l_mode 
    != ControlMode::Select) 
  { return; } 
  SetSelectMode(SelectMode::Tiles); 
  if (l_mode == ControlMode::Brush) { 
    m_selectionOptions-&gt;SetActive(true); 
    m_selectionOptions-&gt;Focus(); 
    m_selectionOptions-&gt;GetElement("TileSelect")-&gt;SetActive(true); 
  } else if (l_mode == ControlMode::Select) { 
    m_selectionOptions-&gt;SetActive(true); 
    m_selectionOptions-&gt;Focus(); 
    m_selectionOptions-&gt;GetElement("SolidToggle")-&gt; 
      SetActive(true); 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(true); 
  } 
} 
</pre><p>It's only necessary to worry about the <code class="literal">Brush</code> and <code class="literal">Select</code> modes, as this interface is not even needed for anything else. In case a <code class="literal">Brush</code> is selected, the interface is enabled and focused, while its <code class="literal">TileSelect</code> element is also enabled. This ensures we can select tiles we want to paint with. If the selection tool is picked, we want the buttons for solidity toggling and selection copying to be enabled instead.</p><p>The actual selection mode switching needs to be handled too, and can be done like so:</p><pre class="programlisting">void GUI_SelectionOptions::SetSelectMode(SelectMode l_mode) { 
  Reset(); 
  m_selectMode = l_mode; 
  m_selectionOptions-&gt;SetActive(true); 
  m_selectionOptions-&gt;Focus(); 
 
  if (l_mode == SelectMode::Tiles) { 
    ... // GUI Element manipulation. 
  } else if(l_mode == SelectMode::Entities) { 
    ... // GUI Element manipulation. 
    auto dropdown = static_cast&lt;GUI_DropDownMenu*&gt;( 
      m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
      GetMenu(); 
    dropdown-&gt;PurgeEntries(); 
    for (auto&amp; entity : m_entityNames) { 
      dropdown-&gt;AddEntry( 
        entity.first.substr(0, entity.first.find(".entity"))); 
    } 
    dropdown-&gt;Redraw(); 
  } else if (l_mode == SelectMode::Emitters) { 
    ... // GUI Element manipulation. 
    auto dropdown = static_cast&lt;GUI_DropDownMenu*&gt;( 
      m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
      GetMenu(); 
    dropdown-&gt;PurgeEntries(); 
    for (auto&amp; emitter : m_emitterNames) { 
      dropdown-&gt;AddEntry( 
        emitter.first.substr(0, emitter.first.find(".particle"))); 
    } 
    dropdown-&gt;Redraw(); 
  } 
} 
</pre><p>First, the <code class="literal">Reset()</code> method is invoked. It is used to disable all unnecessary interface elements and zero out the selection data members to their default values. After the actual selection mode is stored and the interface is set to active, we begin dealing with the actual mode-specific logic.</p><p>If we are in the tile selection mode, it simply involves enabling a number of interface elements, as well as setting their text to match the context. For the sake of simplicity, all of the element manipulation in this method is omitted.</p><p>Dealing with entity and emitter modes is similar, yet includes an additional step, which is populating the drop-down menu with appropriate values. In both cases, the drop-down element is obtained and purged of its current entries. The appropriate directory list is then iterated over; adding each entry to the drop-down, making sure the file type is removed. Once this is done, the drop-down menu is instructed to be re-drawn.</p><p>Let us take a look at what needs to happen when our selection options class is instructed to select a particular entity:</p><pre class="programlisting">void GUI_SelectionOptions::SelectEntity(int l_id) { 
  if (l_id == -1) { 
    m_entityId = -1; 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(false); 
    m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
      SetText("Place"); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(false); 
    m_entity = nullptr; 
    return; 
  } 
  auto pos = m_entityManager-&gt; 
    GetComponent&lt;C_Position&gt;(l_id, Component::Position); 
  if (!pos) { 
    m_entityId = -1; 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(false); 
    m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
      SetText("Place"); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(false); 
    m_entity = nullptr; 
    return; 
  } 
  m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
    SetActive(true); 
  m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
    SetText("Edit"); 
  m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
    SetActive(true); 
  m_entityId = l_id; 
  m_entity = pos; 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt; 
    SetText(std::to_string(m_entityId)); 
  m_selectUpdate = true; 
} 
</pre><p>First, the argument could be used to de-select an entity, as well as select it. If the appropriate de-select value is passed, or an entity position component with the provided identifier has not been found, the related interface elements are adjusted to match the situation.</p><p>If an entity with the provided ID does exist, the proper elements are enabled and adjusted. The entity position component as well as its identifier is stored for later use, and the information text element of the selection options interface is changed to reflect the ID of the entity selected. It is also marked to be updated, by manipulating the <em>boolean</em> flag <code class="literal">m_selectUpdate</code>.</p><p>A very similar process takes place when selecting an emitter:</p><pre class="programlisting">void GUI_SelectionOptions::SelectEmitter(Emitter* l_emitter) { 
  m_emitter = l_emitter; 
  if (!l_emitter) { 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(false); 
    m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
      SetText("Place"); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(false); 
    return; 
  } 
  m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
    SetActive(true); 
  m_selectionOptions-&gt;GetElement("PlaceSelection")-&gt; 
    SetText("Edit"); 
  m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
    SetActive(true); 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt;SetText(m_emitter-&gt; 
    GetGenerators()); 
  m_selectionOptions-&gt;GetElement("EmitRate")-&gt; 
    SetText(std::to_string(m_emitter-&gt;GetEmitRate())); 
  m_selectUpdate = true; 
} 
</pre><p>It is simpler in a sense that we are only working with a pointer to a particle emitter. If <code class="literal">nullptr</code> is passed in, proper elements are disabled and adjusted. Otherwise, the interface is updated to reflect the information of the emitter that is selected, while also marking the <code class="literal">selectionOptions</code> interface is properly updated afterwards.</p><p>We obviously also need a way to switch between the different selection modes, hence this callback:</p><pre class="programlisting">void GUI_SelectionOptions::SelectModeSwitch( 
  EventDetails* l_details) 
{ 
  if (m_selectMode == SelectMode::Tiles) { 
    if (m_mapControls-&gt;GetMode() != ControlMode::Select) { 
      m_mapControls-&gt;SelectMode(ControlMode::Select); 
    } 
    SetSelectMode(SelectMode::Entities); 
  } else if (m_selectMode == SelectMode::Entities) { 
    SetSelectMode(SelectMode::Emitters); 
  } else { SetSelectMode(SelectMode::Tiles); } 
} 
</pre><p>It simply cycles through all of the options for selection. One thing worthy of pointing out here is that if the interface before cycling is in tile mode, we want to make sure that the <code class="literal">ControlMode</code> is switched to <code class="literal">Select</code>.</p><p>Another feature we want to work on is opening up and dealing with tiles being selected from the tile-sheet:</p><pre class="programlisting">void GUI_SelectionOptions::OpenTileSelection( 
  EventDetails* l_details) 
{ 
  if (!m_tileSelector-&gt;IsActive()) { 
    m_tileSelector-&gt;Show(); 
    return; 
  } 
  m_mapControls-&gt;SelectMode(ControlMode::Brush); 
  if (m_tileSelector-&gt;CopySelection(*m_brush)) { 
    m_selectionOptions-&gt;GetElement("Solidity")-&gt;SetText("False"); 
    m_mapControls-&gt;RedrawBrush(); 
  } 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt;SetText( 
    std::to_string(m_brush-&gt;GetTileCount())); 
} 
</pre><p>First, we deal with just opening the <code class="literal">tileSelector</code> interface, provided it is not set to active yet. On the other hand, if the interface is open, the select button being pressed indicates the user attempting to copy their selection to the brush. The <code class="literal">mapControls</code> class is instructed to switch its mode to <code class="literal">Brush</code>, which is then passed into the <code class="literal">tileSelector</code> class's <code class="literal">CopySelection()</code> method, responsible for copying actual tile data. Since it returns a <em>boolean</em> value that indicates its success, the method is invoked inside an <code class="literal">if</code> statement, which allows us to update the solidity element of the interface and request a brush re-draw, provided the copying procedure was successful. At any rate, the information text element of the <code class="literal">selectionOptions</code> interface is then updated to hold the total count of tiles that have been selected and copied to the brush.</p><p>Toggling the solidity of the current portion of the map being selected or the brush itself is also possible in our tile editor:</p><pre class="programlisting">void GUI_SelectionOptions::SolidToggle(EventDetails* l_details) { 
  auto mode = m_mapControls-&gt;GetMode(); 
  if (m_mapControls-&gt;GetMode() != ControlMode::Brush 
    &amp;&amp; mode != ControlMode::Select) 
  { return; } 
  auto element = m_selectionOptions-&gt;GetElement("Solidity"); 
  auto state = element-&gt;GetText(); 
  bool solid = false; 
  std::string newText; 
  if (state == "True") { newText = "False"; } 
  else { solid = true; newText = "True"; } 
  element-&gt;SetText(newText); 
  sf::Vector2u start; 
  sf::Vector2u finish; 
  TileMap* map = nullptr; 
  if (mode == ControlMode::Brush) { 
    map = m_brush; 
    start = sf::Vector2u(0, 0); 
    finish = map-&gt;GetMapSize() - sf::Vector2u(1, 1); 
  } else if (mode == ControlMode::Select) { 
    map = m_map-&gt;GetTileMap(); 
    start = sf::Vector2u(m_selectRangeX.x, m_selectRangeY.x); 
    finish = sf::Vector2u(m_selectRangeX.y, m_selectRangeY.y); 
  } 
 
  for (auto x = start.x; x &lt;= finish.x; ++x) { 
    for (auto y = start.y; y &lt;= finish.y; ++y) { 
      for (auto layer = m_layerSelectLow; 
        layer &lt; m_layerSelectHigh; ++layer) 
      { 
        auto tile = map-&gt;GetTile(x, y, layer); 
        if (!tile) { continue; } 
        tile-&gt;m_solid = solid; 
      } 
    } 
  } 
} 
</pre><p>First, we obviously can not toggle the solidity of a selection, if the control mode is not set to either the <code class="literal">Brush</code> or <code class="literal">Select</code> mode. With that being covered, the solidity state label is obtained, as well as its text. After flipping its value to its opposite and updating the element's text, we establish a range of tiles that will be modified. In the case of a brush having its solidity toggled, the range encapsulates the entire structure. On the other hand, the map selection range is used when dealing with the select mode.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">m_selectRangeX</code> and <code class="literal">m_selectRangeY</code> data members represent the selection range of the map tiles. Each range is responsible for its own axis. For example,<code class="literal"> m_selectRangeX.x</code> is the <strong>starting </strong>
<em>X</em> coordinate, and <code class="literal">m_selectRangeX.y</code> is the <strong>ending</strong>
<em>X</em> coordinate.</p></div></div><p>After the range is properly established, we simply need to iterate over it and obtain tiles from the appropriate <code class="literal">TileMap</code>, setting their solidity to the appropriate value.</p><p>Copying a certain portion of the map to the brush could also prove to be a useful feature:</p><pre class="programlisting">void GUI_SelectionOptions::CopySelection(EventDetails* l_details) 
{ 
  if (m_selectRangeX.x == -1) { return; } 
  auto size = sf::Vector2u( 
    m_selectRangeX.y - m_selectRangeX.x, 
    m_selectRangeY.y - m_selectRangeY.x); 
  size.x += 1; 
  size.y += 1; 
  m_brush-&gt;Purge(); 
  m_brush-&gt;SetMapSize(size); 
  unsigned int b_x = 0, b_y = 0, b_l = 0; 
  bool solid = false, mixed = false; 
  unsigned short changes = 0; 
  for (auto x = m_selectRangeX.x; x &lt;= m_selectRangeX.y; ++x) { 
    for (auto y = m_selectRangeY.x; y &lt;= m_selectRangeY.y; ++y) { 
      for (auto layer = m_layerSelectLow; 
        layer &lt;= m_layerSelectHigh; ++layer) 
      { 
        auto tile = m_map-&gt;GetTile(x, y, layer); 
        if (!tile) { ++b_l; continue; } 
        auto newTile = m_brush-&gt;SetTile( 
          b_x, b_y, b_l, tile-&gt;m_properties-&gt;m_id); 
        if (!newTile) { continue; } 
        if (!mixed) { 
          if (tile-&gt;m_solid &amp;&amp; !solid) { 
            solid = true; ++changes; 
          } else if (solid) { 
            solid = false; ++changes; 
          } 
          if (changes &gt;= 2) { mixed = true; } 
        } 
        *newTile = *tile; 
        ++b_l; 
      } 
      b_l = 0; 
      ++b_y; 
    } 
    b_y = 0; 
    ++b_x; 
  } 
  m_layerSelectHigh = m_layerSelectLow + 
    m_brush-&gt;GetHighestElevation(); 
  if (m_layerSelectHigh &gt;= Sheet::Num_Layers) { 
    auto difference = (m_layerSelectHigh - Sheet::Num_Layers) + 1; 
    m_layerSelectHigh = Sheet::Num_Layers - 1; 
    m_layerSelectLow -= difference; 
  } 
  SelectionElevationUpdate(); 
  m_mapControls-&gt;SelectMode(ControlMode::Brush); 
  m_selectionOptions-&gt;GetElement("InfoText")-&gt; 
    SetText(std::to_string(m_brush-&gt;GetTileCount())); 
  m_selectionOptions-&gt;GetElement("Solidity")-&gt; 
    SetText((mixed ? "Mixed" : (solid ? "True" : "False"))); 
} 
</pre><p>We begin by checking if a selection actually was made, which can be done by checking any of the select range data members. Afterwards, the size of the selection is calculated by subtracting the start-points of the selection from the end-points, and increasing the size by one unit on both axes. This is done in order to compensate for inclusive ranges that start and end on the same exact tile number.</p><p>Once the brush tile map is purged and resized, some local variables are set up in order to aid the rest of the code. The three <em>unsigned integers</em> are going to be used as index coordinates for the brush tile map, in order to map the copied tiles correctly. The two <em>boolean</em> flags and the <em>unsigned short </em>changes are going to keep track of solidity changes, in order to update the GUI element that denotes what solidity state the selection is in.</p><p>Next, the tile loops are entered. After the map tile at the specific coordinates is obtained and passes the validity check, the brush tile at the current coordinates denoted by <code class="literal">b_x</code>, <code class="literal">b_y</code>, and <code class="literal">b_l</code> is set to hold the same tile ID. The solidity changes of the tile are then detected and noted, in order to determine if we have a mixed selection of solidities. Finally, all other tile properties are transferred to the brush, by utilizing the overloaded <code class="literal">=</code> operator.</p><p>In order to keep the interface up–to–date with our actions, the current layer selection range is checked for exceeding the actual range of total layers supported by the application. If, for example, we support four total layers and the current selected layer is two while the brush has all of its layers filled, we want to adjust the current layer selection to honour that by calculating the layer difference, adjusting the highest layer selected to match the maximum layer supported by the application, and subtract the difference from the lowest layer, hence preserving the proper range of the brush.</p><p>Lastly, a method for updating the selection options elevation selection text is invoked, the map controls class is instructed to switch to the <code class="literal">Brush</code> mode, and the selection options interface is updated with the information of the brush tile count and solidity.</p><p>Let us drift away from the topic of placing, editing, or copying tiles for a second, and talk about actually placing entities or emitters when the <strong>Place</strong> button is pressed:</p><pre class="programlisting">void GUI_SelectionOptions::PlaceSelection(EventDetails* l_details) 
{ 
  if (m_selectMode == SelectMode::Tiles) { return; } 
  auto dropdownValue = static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
    GetMenu()-&gt;GetSelected(); 
  if (dropdownValue.empty()) { return; } 
  if (m_selectMode == SelectMode::Entities) { 
    if (!m_entity || m_entityId == -1) { 
      // New entity. 
      auto id = m_entityManager-&gt;AddEntity(dropdownValue); 
      if (id == -1) { return; } 
      SelectEntity(id); 
    } 
    SaveOptions(nullptr); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { 
      // New emitter. 
      auto text = m_selectionOptions-&gt; 
        GetElement("EmitRate")-&gt;GetText(); 
      auto rate = std::stoi(text); 
      auto emitter = m_particleSystem-&gt;AddEmitter( 
        sf::Vector3f(0.f, 0.f, 0.f), dropdownValue, rate, 
        StateType::MapEditor); 
      SelectEmitter(emitter); 
    } 
    SaveOptions(nullptr); 
  } 
} 
</pre><p>We are not going to be using this functionality to do anything with tiles, because that is what the mouse is designated for. If the <code class="literal">selectionOptions</code> interface is in the proper <code class="literal">Select</code> mode, the value of the drop-down menu is obtained and checked for not being empty. The <strong>Place</strong> button can also act as the <strong>Edit</strong> button under appropriate circumstances, such as when an entity or particle emitter is selected, so in both cases, the appropriate values are checked for representing a selection, or lack thereof. If nothing is selected, the drop-down value is used to add a new entity or emitter of the selected type. The <code class="literal">SaveOptions()</code> method is then invoked, so in either case, the information currently stored in the <code class="literal">selectionOptions</code> interface is saved to either the newly created object, or one that was already selected.</p><p>Pressing the <strong>Remove</strong> button can be handled like so:</p><pre class="programlisting">void GUI_SelectionOptions::RemoveSelection( 
  EventDetails* l_details) 
{ 
  DeleteSelection(l_details-&gt;m_shiftPressed); 
} 
</pre><p>As you can see, a different method is invoked here, with a <em>boolean</em> flag being passed to it, denoting whether the <em>Shift</em> key is being held down, controlling how much of the current selection is removed. Let us take a look at the actual delete method:</p><pre class="programlisting">void GUI_SelectionOptions::DeleteSelection(bool l_deleteAll) { 
  if (m_selectMode == SelectMode::Tiles) { 
    if (m_selectRangeX.x == -1) { return; } 
    auto layerRange = (l_deleteAll ? 
      sf::Vector2u(0, Sheet::Num_Layers - 1) : 
      sf::Vector2u(m_layerSelectLow, m_layerSelectHigh)); 
 
    m_map-&gt;GetTileMap()-&gt;RemoveTiles( 
      sf::Vector2u(m_selectRangeX), 
      sf::Vector2u(m_selectRangeY), 
      layerRange); 
    m_map-&gt;ClearMapTexture( 
      sf::Vector3i(m_selectRangeX.x, 
        m_selectRangeY.x, layerRange.x), 
      sf::Vector3i(m_selectRangeX.y, 
        m_selectRangeY.y, layerRange.y)); 
  } else if (m_selectMode == SelectMode::Entities) { 
    if (!m_entity || m_entityId == -1) { return; } 
    m_entityManager-&gt;RemoveEntity(m_entityId); 
    SelectEntity(-1); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { return; } 
    m_particleSystem-&gt;RemoveEmitter(m_emitter); 
    SelectEmitter(nullptr); 
  } 
} 
</pre><p>Once again, we deal with all three different selection types: tile, entity, and particle emitters. If we are working with tiles, the selection range is checked. Provided something actually is selected, the layer range is defined, based on whether the argument says everything should be deleted. The map is then instructed to remove the tiles and cleat its render texture within the calculated ranges.</p><p>In the cases of entities and particle emitters, it's much less complicated. The selected entity/emitter is simply removed, and the appropriate <code class="literal">SelectX</code> method is invoked shortly after, passing in a value for nothing being selected.</p><p>Next, let us handle the <em>
<strong>+</strong>
</em> and <em>
<strong>-</strong>
</em> buttons that control the elevation selection being pressed:</p><pre class="programlisting">void GUI_SelectionOptions::SelectionOptionsElevation( 
  EventDetails* l_details) 
{ 
  int low = 0, high = 0; 
  bool shift = sf::Keyboard::isKeyPressed(sf::Keyboard::LShift); 
  if (l_details-&gt;m_name == "MapEditor_SelectOptionsPlus") { 
    if (shift) { high = 1; } else { low = 1; } 
  } else if(l_details-&gt;m_name == "MapEditor_SelectOptionsMinus") { 
    if (shift) { high = -1; } else { low = -1; } 
  } 
 
  auto mode = m_mapControls-&gt;GetMode(); 
 
  if (mode == ControlMode::Brush) { 
    if (high != 0) { return; } // only working with low values. 
    int l = m_layerSelectLow + low; 
    if (l &lt; 0 || l &gt;= Sheet::Num_Layers) { return; } 
    if (l + m_brush-&gt;GetHighestElevation() &gt;= 
      Sheet::Num_Layers) 
    { return; } 
    m_layerSelectLow = l; 
    m_layerSelectHigh = l + m_brush-&gt;GetHighestElevation(); 
    SelectionElevationUpdate(); 
  } else if (mode == ControlMode::Select) { 
    int l = m_layerSelectLow + low; 
    int h = m_layerSelectHigh + high; 
    if (l &lt; 0 || l &gt;= Sheet::Num_Layers) { return; } 
    if (h &lt; 0 || h &gt;= Sheet::Num_Layers) { return; } 
    if (m_layerSelectLow == m_layerSelectHigh &amp;&amp; !shift) { 
      m_layerSelectLow += low; 
      m_layerSelectLow += high; 
      m_layerSelectHigh = m_layerSelectLow; 
    } else { 
      m_layerSelectLow = l; 
      m_layerSelectHigh = h; 
    } 
    if (m_layerSelectLow &gt; m_layerSelectHigh) { 
      std::swap(m_layerSelectLow, m_layerSelectHigh); 
    } 
    SelectionElevationUpdate(); 
  } 
} 
</pre><p>Here, we want to handle the button clicks in a specific way. Keep in mind that support for selecting ranges of layers is also something of great importance. Consider the following illustration:</p><div><img src="img/image_05_002.jpg" alt="Implementing selection options"/></div><p>Simply clicking either a plus or a minus would affect the low number, which represents the lowest elevation selected. Holding a <em>Shift</em> key would increase the high number, controlling the highest elevation. For this, two integers, <code class="literal">low</code> and <code class="literal">high</code>, are set up, alongside a <em>boolean</em> flag that determines if a <em>Shift</em> key is being held or not. Based on that and the event name, the numbers are adjusted to represent the changes in elevation.</p><p>Next, we branch out the logic once again. If a <code class="literal">Brush</code> mode is selected, we do not want to deal with any changes of the high elevation at all. Instead, only the low layer selection is used here. After a new value for it is established by adding the layer delta to the already selected low elevation, the range is checked for exceeding the boundaries of [0;<code class="literal">Sheet::NumLayers</code>). Provided that passes, the low elevation selection is updated with the new value, as is the high value, which simply takes the low elevation and adds the thickness of the brush to it, represented by the brush's highest elevation.</p><p>The <code class="literal">Select</code> mode follows the same basic principle, with one exception: it also handles the high elevation. With the deltas properly added to the current values, the range is checked for exceeding the allowed limits. The next check deals with how we control shift-clicks depending on whether both the low and high values are the same. If they are, the deltas are simply added to the low value, which is copied over to the high elevation, preserving the equality. Otherwise, both low and high values are simply overwritten with the preceding newly calculated range.</p><p>In both cases, it is also important to invoke the <code class="literal">SelectionElevationUpdate()</code> method, which makes sure the interface elements are kept up-to-date, like so:</p><pre class="programlisting">void GUI_SelectionOptions::SelectionElevationUpdate() { 
  if (!m_selectionOptions-&gt;IsActive()) { return; } 
  m_selectionOptions-&gt;GetElement("Elevation")-&gt;SetText( 
    std::to_string(m_layerSelectLow) + 
    (m_layerSelectLow != m_layerSelectHigh ? 
    " - " + std::to_string(m_layerSelectHigh) : "") 
  ); 
  SaveOptions(nullptr); 
} 
</pre><p>After making sure the selection options interface is actually active, the elevation label is updated with the proper layer range. The <code class="literal">SaveOptions()</code> callback is then invoked with <code class="literal">nullptr</code> for its argument. It is responsible for actually saving the interface's information to whatever object happens to be selected. Let us take a look at this method now:</p><pre class="programlisting">void GUI_SelectionOptions::SaveOptions(EventDetails* l_details) { 
  if (m_selectMode == SelectMode::Tiles) { return; } 
 
  auto x = m_selectionOptions-&gt;GetElement("Pos_X")-&gt;GetText(); 
  auto y = m_selectionOptions-&gt;GetElement("Pos_Y")-&gt;GetText(); 
  auto z = m_selectionOptions-&gt;GetElement("Pos_Z")-&gt;GetText(); 
 
  auto c_x = std::stoi(x); 
  auto c_y = std::stoi(y); 
  auto c_z = std::stoi(z); 
 
  if (m_selectMode == SelectMode::Entities) { 
    if (!m_entity || m_entityId == -1) { return; } 
    m_entity-&gt;SetPosition(sf::Vector2f(c_x, c_y)); 
    m_entity-&gt;SetElevation(m_layerSelectLow); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { return; } 
    auto emitRate = m_selectionOptions-&gt; 
      GetElement("EmitRate")-&gt;GetText(); 
    auto c_rate = std::stoi(emitRate); 
    m_emitter-&gt;SetPosition(sf::Vector3f(c_x, c_y, c_z)); 
    m_emitter-&gt;SetEmitRate(c_rate); 
  } 
} 
</pre><p>The most obvious first check is to make sure we are not in tile mode, because there is nothing to save there. Afterwards, the values from the text-fields representing <em>X</em>, <em>Y</em>, and <em>Z</em> coordinates are obtained and converted to numbers. This is where our logic branches out once again.</p><p>In the case of dealing with an entity, we must first make sure one is selected. If it is, its position is changed to that of the values just obtained from the interface. We do not need to use the <em>Z</em> coordinate here, because that is replaced by the elevation.</p><p>The <em>Z</em> coordinate is, however, used when dealing with particle emitters. After obtaining the additional value of the emit rate from the interface and converting it to a proper number, all of these values are applied to the current particle emitter selected.</p><p>Now, the piece of code that makes everything else tick:</p><pre class="programlisting">void GUI_SelectionOptions::Update() { 
  if (m_selectUpdate) { UpdateSelectDrawable(); } 
  if (!m_mapControls-&gt;IsInAction()) { return; } 
  if (m_selectMode == SelectMode::Tiles) {UpdateTileSelection();} 
  else if (m_selectMode == SelectMode::Entities) { 
    UpdateEntitySelection(); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    UpdateEmitterSelection(); 
  } 
} 
</pre><p>At this point, we want to make sure the selection drawable is updated, provided the <code class="literal">m_selectUpdate</code> flag is enabled. The rest of the code can be skipped if the <code class="literal">mapControls</code> class is not letting us know that the left mouse button is pressed. However, if it is, an appropriate update method is invoked, depending on what <code class="literal">selectMode</code> the interface is in.</p><p>A good way to keep an application looking neat and responsive is having neat indicators of certain selections being made, like so:</p><div><img src="img/image_05_003.jpg" alt="Implementing selection options"/></div><p>Let us take a look at how the selection rectangle can be updated for entities and emitters:</p><pre class="programlisting">void GUI_SelectionOptions::UpdateSelectDrawable() { 
  if (m_selectMode == SelectMode::Entities) { 
    if (m_entityId == -1) { return; } 
    if (!m_entity) { return; } 
    if (m_entityManager-&gt;HasComponent(m_entityId, 
      Component::Collidable)) 
    { 
      auto col = m_entityManager-&gt; 
        GetComponent&lt;C_Collidable&gt;(m_entityId, 
        Component::Collidable); 
      auto primitive = col-&gt;GetCollidable(); 
      m_selectDrawable.setPosition(primitive.left, primitive.top); 
      m_selectDrawable.setSize( 
        sf::Vector2f(primitive.width, primitive.height)); 
    } else if (m_entityManager-&gt;HasComponent(m_entityId, 
      Component::SpriteSheet)) 
    { 
      auto drawable = m_entityManager-&gt; 
        GetComponent&lt;C_SpriteSheet&gt;(m_entityId, 
        Component::SpriteSheet); 
      auto pos = drawable-&gt;GetSpriteSheet()-&gt;GetSpritePosition(); 
      auto size = drawable-&gt;GetSpriteSheet()-&gt;GetSpriteSize(); 
      m_selectDrawable.setPosition(pos); 
      m_selectDrawable.setSize(sf::Vector2f(size)); 
    } else { 
      m_selectDrawable.setPosition( 
        m_entity-&gt;GetPosition() - sf::Vector2f(16.f, 16.f)); 
      m_selectDrawable.setSize(sf::Vector2f(32.f, 32.f)); 
    } 
  } else if (m_selectMode == SelectMode::Emitters) { 
    if (!m_emitter) { return; } 
    auto pos = sf::Vector2f( 
      m_emitter-&gt;GetPosition().x, m_emitter-&gt;GetPosition().y); 
    m_selectDrawable.setPosition(pos - sf::Vector2f(16.f, 16.f)); 
    m_selectDrawable.setSize(sf::Vector2f(32.f, 32.f)); 
  } 
} 
</pre><p>As always, our logic branches out, depending on the selection mode we are in. Provided we are working with entities, a few checks are necessary in order to make sure one is selected. If it is, the next problem at hand is giving the rectangle a proper size, origin, and position. The easiest way to do that is by obtaining the colloidal component of an entity and manipulating it based on the collision primitive. If the entity doesn't have that type of component, we attempt to use the next best thing - its sprite sheet. Finally, if there's only a position component to work with, the rectangle is centered at the entity's position and given a fixed size of <em>32x32</em>.</p><p>Dealing with emitters is quite similar, minus the entire component headache. Provided one is selected, its 2D position is obtained and used to centre the rectangle, while giving it a static size of <em>32x32</em>.</p><p>Let us move on to updating the tile selection next:</p><pre class="programlisting">void GUI_SelectionOptions::UpdateTileSelection() { 
  auto&amp; tileStart = m_mapControls-&gt;GetMouseTileStart(); 
  auto&amp; mouseTile = m_mapControls-&gt;GetMouseTile(); 
 
  auto start = sf::Vector2f( 
    (tileStart.x + (tileStart.x &gt; mouseTile.x ? 1 : 0)) 
      * Sheet::Tile_Size, 
    (tileStart.y + (tileStart.y &gt; mouseTile.y ? 1 : 0)) 
      * Sheet::Tile_Size 
  ); 
 
  auto end = sf::Vector2f( 
    (mouseTile.x + (tileStart.x &lt;= mouseTile.x ? 1 : 0)) 
      * Sheet::Tile_Size, 
    (mouseTile.y + (tileStart.y &lt;= mouseTile.y ? 1 : 0)) 
      * Sheet::Tile_Size 
  ); 
 
  m_selectDrawable.setPosition( 
    (start.x &lt;= end.x ? start.x : end.x), 
    (start.y &lt;= end.y ? start.y : end.y) 
  ); 
 
  m_selectDrawable.setFillColor(m_selectStartColor); 
  m_selectDrawable.setSize({ 
    std::abs(end.x - start.x), 
    std::abs(end.y - start.y) 
  }); 
  m_selectRangeX = sf::Vector2i( 
    std::min(tileStart.x, mouseTile.x), 
    std::max(tileStart.x, mouseTile.x) 
  ); 
  m_selectRangeY = sf::Vector2i( 
    std::min(tileStart.y, mouseTile.y), 
    std::max(tileStart.y, mouseTile.y) 
  ); 
} 
</pre><p>This is the actual method that handles tile selection logic. First, the coordinates of the starting tile that got clicked are obtained along with the current mouse position in tile coordinates. This information is used to calculate absolute global coordinates for the rectangle that will be used to represent the selection. The actual rectangle is then updated with this information, as well as set to have the <code class="literal">m_selectStartColor</code> color. Finally, all that is left to do is save this information as the current selection range, making sure it is in ascending order.</p><p>Next, updating entity selection deserves a peek:</p><pre class="programlisting">void GUI_SelectionOptions::UpdateEntitySelection() { 
  if (!m_mapControls-&gt;IsInAction()) { return; } 
  if (!m_entity) { return; } 
  m_entity-&gt;MoveBy(m_mapControls-&gt;GetMouseDifference()); 
  auto elevation = m_entity-&gt;GetElevation(); 
  m_selectionOptions-&gt;GetElement("Pos_X")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;( 
      m_entity-&gt;GetPosition().x))); 
  m_selectionOptions-&gt;GetElement("Pos_Y")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;( 
      m_entity-&gt;GetPosition().y))); 
  m_selectionOptions-&gt;GetElement("Elevation")-&gt; 
    SetText(std::to_string(elevation)); 
  m_layerSelectLow = elevation; 
  m_layerSelectHigh = elevation; 
  m_selectUpdate = true; 
} 
</pre><p>A check is needed to make sure the <code class="literal">mapControls</code> are in action in the same fashion as tile updating. Also, we obviously cannot update an entity that is not even selected, so a check is needed for that as well. The final bit of logic simply deals with moving the entity by the mouse position difference and updating our <code class="literal">selectionOptions</code> interface to hold its current position and elevation. The layer selection range is also updated to hold the elevation information. Finally, the select update flag is set to <code class="literal">true</code>, which requests the selection rectangle to be updated.</p><p>It's time to wrap up the updating logic. The only remaining mode left to update is the particle emitter selection:</p><pre class="programlisting">void GUI_SelectionOptions::UpdateEmitterSelection() { 
  if (!m_mapControls-&gt;IsInAction()) { return; } 
  if (!m_emitter) { return; } 
  auto emitPos = m_emitter-&gt;GetPosition(); 
  auto position = sf::Vector2f(emitPos.x, emitPos.y); 
  position += m_mapControls-&gt;GetMouseDifference(); 
  m_emitter-&gt;SetPosition( 
    { position.x, position.y, m_emitter-&gt;GetPosition().z }); 
  m_selectionOptions-&gt;GetElement("Pos_X")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;(emitPos.x))); 
  m_selectionOptions-&gt;GetElement("Pos_Y")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;(emitPos.y))); 
  m_selectionOptions-&gt;GetElement("Pos_Z")-&gt; 
    SetText(std::to_string(static_cast&lt;int&gt;(emitPos.z))); 
  m_selectUpdate = true; 
} 
</pre><p>Just as before, the map control primary action flag is checked before proceeding, as well as the actual selection being made. The <code class="literal">X</code> and <code class="literal">Y</code> attributes of the particle emitter position are pushed by the mouse delta, while the <code class="literal">Z</code> coordinate is preserved as is. Afterwards, it is only a matter of updating the interface with the most recent position of the particle emitter, and marking the selection drawable for updating.</p><p>The last few pieces of the puzzle involve us dealing with mouse input correctly:</p><pre class="programlisting">bool GUI_SelectionOptions::MouseClick(const sf::Vector2f&amp; l_pos) { 
  if (m_selectMode == SelectMode::Tiles) { return true; } 
  bool madeSelection = false; 
  if (m_selectMode == SelectMode::Entities) { 
    int entity = -1; 
    if (m_mapControls-&gt;DrawSelectedLayers()) { 
      entity = m_entityManager-&gt;FindEntityAtPoint(l_pos, 
        m_layerSelectLow, m_layerSelectHigh); 
    } else { 
      entity = m_entityManager-&gt;FindEntityAtPoint(l_pos); 
    } 
    SelectEntity(entity); 
    madeSelection = entity != -1; 
  } else if (m_selectMode == SelectMode::Emitters) { 
    Emitter* emitter = nullptr; 
    if (m_mapControls-&gt;DrawSelectedLayers()) { 
      emitter = m_particleSystem-&gt;FindEmitter(l_pos, 
        sf::Vector2f(32.f, 32.f), m_layerSelectLow, 
          m_layerSelectHigh); 
    } else { 
      emitter = m_particleSystem-&gt;FindEmitter( 
        l_pos, sf::Vector2f(32.f, 32.f)); 
    } 
    SelectEmitter(emitter); 
    madeSelection = emitter != nullptr; 
  } 
  if (!madeSelection) { 
    m_selectionOptions-&gt;GetElement("Pos_X")-&gt; 
      SetText(std::to_string(static_cast&lt;int&gt;(l_pos.x))); 
    m_selectionOptions-&gt;GetElement("Pos_Y")-&gt; 
      SetText(std::to_string(static_cast&lt;int&gt;(l_pos.y))); 
  } 
  return madeSelection; 
} 
</pre><p>As you recall from the previous chapter, this method is invoked by the <code class="literal">mapControls</code> class. It is required to return a <em>boolean</em> value that denotes whether a selection has been made or not, so that the <code class="literal">mapControls</code> class can deal with its own logic if the set of tools can give the artist a boost they have been looking for
latter is true. When dealing with tiles, this method always needs to return <code class="literal">true</code>, allowing the control class to know that an action is taking place regardless.</p><p>While in entity mode, the <code class="literal">FindEntityAtPoint</code> method of the <code class="literal">entityManager</code> class is invoked, with the global position, as well as the layer selection range being passed in as arguments. The latter is only true if the user of the tile editor has decided to only make selected layers visible. It will return an entity ID if an entity has been found at a specific point in space, which is then used to call <code class="literal">SelectEntity</code>. To determine whether an entity has been selected, the ID is checked for not being equal to a known value for <em>not found</em>.</p><p>A very similar procedure is used to select a particle emitter. Because most emitters are single points in space, a <code class="literal">sf::Vector2f</code> needs to be used here simply to define the area around the position that can be clicked in order to select it.</p><p>Lastly, if a selection hasn't been made, the position text-fields of the selection options interface are filled in with the global coordinates of the click. This allows easier positioning of objects in the world before placement.</p><p>Surprisingly, quite a lot needs to happen when a mouse button is released. Let's take a look:</p><pre class="programlisting">void GUI_SelectionOptions::MouseRelease() { 
  if (m_selectMode == SelectMode::Tiles) { 
    m_selectDrawable.setFillColor(m_selectEndColor); 
    m_selectionOptions-&gt;GetElement("CopySelection")-&gt; 
      SetActive(true); 
    m_selectionOptions-&gt;GetElement("RemoveSelection")-&gt; 
      SetActive(true); 
 
    bool solid = false, mixed = false; 
    unsigned short changes = 0; 
    for (auto x = m_selectRangeX.x; x &lt;= m_selectRangeX.y 
      &amp;&amp; !mixed; ++x) 
    { 
      for (auto y = m_selectRangeY.x; y &lt;= m_selectRangeY.y 
        &amp;&amp; !mixed; ++y) 
      { 
        for (auto layer = m_layerSelectLow; 
          layer &lt;= m_layerSelectHigh &amp;&amp; !mixed; ++layer) 
        { 
          auto tile = m_map-&gt;GetTile(x, y, layer); 
          if (!tile) { continue; } 
          if (tile-&gt;m_solid &amp;&amp; !solid) { 
            solid = true; 
            ++changes; 
          } else if (tile-&gt;m_solid &amp;&amp; !solid) { 
            solid = false; 
            ++changes; 
          } 
          if (changes &gt;= 2) { mixed = true; } 
        } 
      } 
    } 
    m_selectionOptions-&gt;GetElement("Solidity")-&gt; 
      SetText((mixed ? "Mixed" : (solid ? "True" : "False"))); 
  } else if (m_selectMode == SelectMode::Entities) { 
    m_selectDrawable.setFillColor(m_entityColor); 
  } else if (m_selectMode == SelectMode::Emitters) { 
    m_selectDrawable.setFillColor(m_emitterColor); 
  } 
} 
</pre><p>Most of this logic is concerned with dealing with tile selection. The first thing we need to worry about is setting the selection rectangle to its final color, indicating the selection is made. After that, the interface buttons for copying and removing the selection are made visible, and a loop is used to check the selection in order to determine the solidity situation of the entire chunk, which is then saved to the appropriate interface element.</p><p>The entity and emitter modes do not need quite as much maintenance for such a simple task. All we need to worry about here is setting the selection rectangle colors appropriately.</p><p>As modes are being switched, all of the important data needs to be reset in order to avoid strange bugs:</p><pre class="programlisting">void GUI_SelectionOptions::Reset() { 
  auto defaultVector = sf::Vector2i(-1, -1); 
  m_selectRangeX = defaultVector; 
  m_selectRangeY = defaultVector; 
  m_entityId = -1; 
  m_entity = nullptr; 
  m_emitter = nullptr; 
  static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_selectionOptions-&gt;GetElement("SelectDropdown"))-&gt; 
    GetMenu()-&gt;ResetSelected(); 
  ... // GUI Element manipulation. 
} 
</pre><p>In addition to ranges and IDs being reset, the actual selection of the <code class="literal">DropDownMenu</code> of entities/emitters needs zeroing-out. Finally, all of the mode-specific GUI elements we have been working with need to be disabled and/or set to their neutral values.</p><p>Finally, we are left with only one essential chunk of code left to cover - the <code class="literal">Draw()</code> method:</p><pre class="programlisting">void GUI_SelectionOptions::Draw(sf::RenderWindow* l_window) { 
  auto mode = m_mapControls-&gt;GetMode(); 
  if (mode == ControlMode::Select) { 
    if (m_selectMode == SelectMode::Tiles &amp;&amp; 
      m_selectRangeX.x == -1) 
    { return; } 
    if (m_selectMode == SelectMode::Entities &amp;&amp; !m_entity) 
    { return; } 
    if (m_selectMode == SelectMode::Emitters &amp;&amp; !m_emitter) 
    { return; } 
    l_window-&gt;draw(m_selectDrawable); 
  } 
} 
</pre><p>The only thing that we really need to draw is the selection rectangle. As it is quite evident here, it does not need to be drawn if no selection of any kind has been made. This includes checking all three select modes.</p><p>For the sake of completion, we only have a couple of getter methods left to look over:</p><pre class="programlisting">unsigned int GUI_SelectionOptions::GetLowestLayer() const{ 
  return m_layerSelectLow; 
} 
unsigned int GUI_SelectionOptions::GetHighestLayer() const{  
  return m_layerSelectHigh; 
} 
SelectMode GUI_SelectionOptions::GetSelectMode() const{ 
  return m_selectMode; 
} 
sf::Vector2i GUI_SelectionOptions::GetSelectXRange() const{ 
  return sf::Vector2i( 
    std::min(m_selectRangeX.x, m_selectRangeX.y), 
    std::max(m_selectRangeX.x, m_selectRangeX.y)); 
} 
sf::Vector2i GUI_SelectionOptions::GetSelectYRange() const{ 
  return sf::Vector2i( 
    std::min(m_selectRangeY.x, m_selectRangeY.y), 
    std::max(m_selectRangeY.x, m_selectRangeY.y)); 
} 
</pre><p>This concludes the <code class="literal">selectionOptions</code> class.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Building the tile selector</h1></div></div></div><p>When working with tile maps, it is important to have a fast and intuitive way of accessing the tile-sheet, selecting its contents and painting them directly onto the game map. A good set of tools can give the artist the boost they have been looking for, while an unmanageable application is only a hindrance. Let us take a peek at what we are going to be building:</p><div><img src="img/image_05_004.jpg" alt="Building the tile selector"/></div><p>This interface, just like most others we have been working with, is going to be much easier to manage when wrapped in a class of its own:</p><pre class="programlisting">class GUI_MapTileSelector { 
public: 
  GUI_MapTileSelector(EventManager* l_eventManager, 
    GUI_Manager* l_guiManager, TextureManager* l_textureManager); 
  ~GUI_MapTileSelector(); 
  void Show(); 
  void Hide(); 
  bool IsActive() const; 
  <strong>void SetSheetTexture(const std::string&amp; l_texture);</strong> 
  void UpdateInterface(); 
  bool CopySelection(TileMap&amp; l_tileMap) const; 
  void TileSelect(EventDetails* l_details); 
  void Close(EventDetails* l_details); 
private: 
  EventManager* m_eventManager; 
  GUI_Manager* m_guiManager; 
  TextureManager* m_textureManager; 
   
  GUI_Interface* m_interface; 
  sf::RenderTexture m_selectorTexture; 
  sf::Sprite m_tileMapSprite; 
  <strong>sf::RectangleShape m_shape;</strong> 
  std::string m_sheetTexture; 
 
  sf::Vector2u m_startCoords; 
  sf::Vector2u m_endCoords; 
  bool m_selected; 
}; 
</pre><p>Just like before, we have <code class="literal">Show()</code> and <code class="literal">Hide()</code> methods to manage its visibility, as well as a couple of callbacks. Note the highlighted method. It is going to be used for setting the texture of the tile-sheet the map is using.</p><p>The data members are quite predictable for a class like this. Alongside the classes that this object relies on, we keep track of a pointer to the actual interface it is going to be manipulating, an instance of a <code class="literal">sf::RenderTexture</code> that we are going to be drawing to, the sprite that will be used to display the render texture, a rectangle shape, start and end coordinates, and a <em>boolean</em> flag for the actual selection drawable. Lastly, <code class="literal">m_sheetTexture</code> is going to simply keep track of the texture identifier until it is time to release it.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Implementing the tile selector</h2></div></div></div><p>Let us begin by setting all of this data up inside the constructor:</p><pre class="programlisting">GUI_MapTileSelector::GUI_MapTileSelector( 
  EventManager* l_eventManager, GUI_Manager* l_guiManager, 
  TextureManager* l_textureManager) : 
  m_eventManager(l_eventManager), m_guiManager(l_guiManager), 
  m_textureManager(l_textureManager), m_selected(false) 
{ 
  m_eventManager-&gt;AddCallback(StateType::MapEditor, 
    "MapEditor_TileSelectClick", 
    &amp;GUI_MapTileSelector::TileSelect, this); 
  m_eventManager-&gt;AddCallback(StateType::MapEditor, 
    "MapEditor_TileSelectRelease", 
    &amp;GUI_MapTileSelector::TileSelect, this); 
  m_eventManager-&gt;AddCallback(StateType::MapEditor,  
    "MapEditor_TileSelectClose", 
    &amp;GUI_MapTileSelector::Close, this); 
 
  m_guiManager-&gt;LoadInterface("MapEditorTileSelect.interface", 
    "MapEditorTileSelect"); 
  m_interface = m_guiManager-&gt;GetInterface("MapEditorTileSelect"); 
  m_interface-&gt;SetContentRectSize( 
    sf::Vector2i(m_interface-&gt;GetSize()-sf::Vector2f(32.f,32.f))); 
  m_interface-&gt;SetContentOffset({ 16.f, 16.f }); 
  m_interface-&gt;PositionCenterScreen(); 
  m_interface-&gt;SetActive(false); 
 
  m_shape.setFillColor({ 0, 0, 150, 150 }); 
  m_shape.setSize({ Sheet::Tile_Size, Sheet::Tile_Size }); 
  m_shape.setPosition(0.f, 0.f); 
} 
</pre><p>After the arguments are taken care of, the three callback methods we need are set up. The interface is then loaded and stored as one of the data members, just before its content rectangle size and offset are changed in order to allow space for control elements, such as the close button to be positioned comfortably. The interface is then centered on–screen and set to inactive. Finally, the rectangle shape used to represent tile selection is initialized to its default state as well.</p><p>Let us take a look at the destructor of this class next, in order to make sure we are not forgetting to release certain resources:</p><pre class="programlisting">GUI_MapTileSelector::~GUI_MapTileSelector() { 
  ... // Callbacks and interface removal. 
  if (!m_sheetTexture.empty()) { 
    m_textureManager-&gt;ReleaseResource(m_sheetTexture); 
  } 
} 
</pre><p>After all three callbacks are released, it is imperative to make sure the tile-sheet texture is removed as well, provided its identifier is not empty.</p><p>Speaking of the tile-sheet texture, let us see how one can be assigned to this class:</p><pre class="programlisting">void GUI_MapTileSelector::SetSheetTexture( 
  const std::string&amp; l_texture) 
{ 
  if (!m_sheetTexture.empty()) { 
    m_textureManager-&gt;ReleaseResource(m_sheetTexture); 
  } 
  m_sheetTexture = l_texture; 
  m_textureManager-&gt;RequireResource(m_sheetTexture);  
  m_tileMapSprite.setTexture( 
    *m_textureManager-&gt;GetResource(m_sheetTexture)); 
  m_tileMapSprite.setPosition({ 0.f, 0.f }); 
  auto size = m_tileMapSprite.getTexture()-&gt;getSize(); 
  m_selectorTexture.create(size.x, size.y); 
  m_selectorTexture.clear({ 0,0,0,0 }); 
  m_selectorTexture.draw(m_tileMapSprite); 
  m_selectorTexture.display(); 
 
  auto element = static_cast&lt;GUI_Sprite*&gt;( 
    m_interface-&gt;GetElement("TileSprite")); 
  element-&gt;SetTexture(m_selectorTexture); 
} 
</pre><p>After the current tile-sheet texture is properly released, the new one is assigned and retrieved. Because of this, the actual selector texture that will be passed to the main GUI element of our interface needs to be re-drawn and passed into said element.</p><p>A similar procedure takes place when the interface needs to be updated:</p><pre class="programlisting">void GUI_MapTileSelector::UpdateInterface() { 
  m_selectorTexture.clear({ 0,0,0,0 }); 
  m_selectorTexture.draw(m_tileMapSprite); 
  m_selectorTexture.draw(m_shape); 
  m_selectorTexture.display(); 
 
  m_interface-&gt;RequestContentRedraw(); 
} 
</pre><p>It simply consists of the tile-sheet, as well as the selector rectangle being drawn to the render texture. The interface is then instructed to re-draw its content, as it was changed.</p><p>Next, let us provide a way for outside classes to copy the current tile-sheet selection to a <code class="literal">TileMap</code> structure:</p><pre class="programlisting">bool GUI_MapTileSelector::CopySelection(TileMap&amp; l_tileMap) const{ 
  if (!m_selected) { return false; } 
  l_tileMap.Purge(); 
  auto TileCoordsStart = m_startCoords / 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  auto TileCoordsEnd = m_endCoords / 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  auto size = TileCoordsEnd - TileCoordsStart; 
  l_tileMap.SetMapSize(size + sf::Vector2u(1,1)); 
 
  auto sheetSize = m_textureManager-&gt;GetResource( 
    l_tileMap.GetTileSet().GetTextureName())-&gt;getSize(); 
  auto nPerRow = sheetSize.x / Sheet::Tile_Size; 
 
  auto t_x = 0, t_y = 0; 
  for (auto x = TileCoordsStart.x; x &lt;= TileCoordsEnd.x; ++x) { 
    for (auto y = TileCoordsStart.y; y &lt;= TileCoordsEnd.y; ++y) { 
      auto coordinate = (y * nPerRow) + x; 
      auto tile = l_tileMap.SetTile(t_x, t_y, 0, coordinate); 
      // Always layer 0. 
      if (!tile) { ++t_y; continue; } 
      tile-&gt;m_solid = false; 
      ++t_y; 
    } 
    t_y = 0; 
    ++t_x; 
  } 
  return true; 
} 
</pre><p>Obviously, we cannot copy anything if nothing has been selected. The first check takes care of that. The <code class="literal">TileMap</code> passed in as the argument is then purged in preparation for being overwritten. The tile coordinate range is then calculated, and the <code class="literal">TileMap</code> argument is re-sized to match the size of the selection. After a couple of local variables are established to help us calculate the <em>1D</em> coordinate index, we begin iterating over the calculated range of tiles one by one, adding them to the tile map. Because we're not working with any sort of depth when dealing with a tile-sheet, the layer is always going to be set to the value <code class="literal">0</code>.</p><p>The following code deals with the mouse-click and mouse-release events, which are vital when making a selection:</p><pre class="programlisting">void GUI_MapTileSelector::TileSelect(EventDetails* l_details) { 
  if (l_details-&gt;m_name == "MapEditor_TileSelectClick") { 
    m_startCoords = sf::Vector2u(l_details-&gt;m_mouse); 
    m_endCoords = sf::Vector2u(l_details-&gt;m_mouse); 
    m_selected = false; 
  } else { 
    if (l_details-&gt;m_mouse.x &lt; 0 || l_details-&gt;m_mouse.y &lt; 0) { 
      m_endCoords = sf::Vector2u(0, 0); 
      return; 
    } 
    m_endCoords = sf::Vector2u(l_details-&gt;m_mouse); 
    m_selected = true; 
  } 
 
  if (m_startCoords.x &gt; m_endCoords.x) { 
    std::swap(m_startCoords.x, m_endCoords.x); 
  } 
  if (m_startCoords.y &gt; m_endCoords.y) { 
    std::swap(m_startCoords.y, m_endCoords.y); 
  } 
 
  auto start = sf::Vector2i(m_startCoords.x / Sheet::Tile_Size, 
    m_startCoords.y / Sheet::Tile_Size); 
  start *= static_cast&lt;int&gt;(Sheet::Tile_Size); 
  auto end = sf::Vector2i(m_endCoords.x / Sheet::Tile_Size, 
    m_endCoords.y / Sheet::Tile_Size); 
  end *= static_cast&lt;int&gt;(Sheet::Tile_Size); 
 
  m_shape.setPosition(sf::Vector2f(start)); 
  m_shape.setSize(sf::Vector2f(end - start) + 
    sf::Vector2f(Sheet::Tile_Size, Sheet::Tile_Size)); 
  UpdateInterface(); 
} 
</pre><p>If we are dealing with a mouse-left click, we simply need to make note of the mouse coordinates at this point in time, as well as reset the <code class="literal">m_selected</code> flag to <code class="literal">false</code>. On the other hand, if the left mouse button has been released, the final mouse position is first checked for not going into negative values on both axes. The end coordinates are then stored, and the <code class="literal">m_selected</code> flag is set to <code class="literal">true</code>.</p><p>The remaining chunk of code simply deals with making sure the start and end coordinates are stored in an ascending order, and calculating the proper position and size of the selector rectangle. The <code class="literal">UpdateInterface()</code> method is then invoked, which makes sure everything is re-drawn.</p><p>Let us wrap this up by quickly looking over some of the helper methods of this class:</p><pre class="programlisting">void GUI_MapTileSelector::Close(EventDetails* l_details){ Hide();} 
void GUI_MapTileSelector::Show() { 
  m_interface-&gt;SetActive(true); 
  m_interface-&gt;Focus(); 
} 
void GUI_MapTileSelector::Hide() {m_interface-&gt;SetActive(false);} 
bool GUI_MapTileSelector::IsActive() const{ 
  return m_interface-&gt;IsActive(); 
} 
</pre><p>The <code class="literal">Show()</code> and <code class="literal">Hide()</code> methods simply manipulate the interfaces activity, while the <code class="literal">Close</code> callback just invokes <code class="literal">Hide</code>. Just like that, all of the pieces fit together and we are left with a fully functional map editor!</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Summary</h1></div></div></div><p>Building tools for a game may not be the easiest or the most pleasant task in the world, but in the end, it always pays off. Dealing with text files, endless copy-pasting, or other botch-like solutions may work fine in the short term, but nothing beats a fully equipped set of tools, ready to take on any project with the click of a button! Although the editor we have built is geared towards a very specific task, the idea behind it can, with enough time and energy, be applied to any set of production problems.</p><p>In the next chapter, we are going to be covering the basics and general uses of shaders in SFML. The OpenGL shading language, along with SFML's built in support for shaders, is going to allow us to create a very basic day and night cycle. See you there!</p></div></div></div></body></html>