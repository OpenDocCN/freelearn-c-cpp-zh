- en: Chapter 5. On the Line – Rocket Through
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 在线上 – 火箭穿越
- en: '*In our third game, Rocket Through, we''ll use particle effects to spice things
    up a bit, and we''ll use DrawNode to make our own OpenGL drawings on screen. And
    be advised, this game uses quite a bit of vector math, but luckily for us, Cocos2d-x
    comes bundled with a sweet pack of helper methods to deal with that as well.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们的第三个游戏，火箭穿越中，我们将使用粒子效果来增加一些趣味性，并且我们将使用DrawNode在屏幕上绘制自己的OpenGL图形。并且请注意，这个游戏使用了相当多的向量数学，但幸运的是，Cocos2d-x附带了一套甜美的辅助方法来处理这些问题。*'
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习：
- en: How to load and set up a particle system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载和设置粒子系统
- en: How to draw primitives (lines, circles, and more) with `DrawNode`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`DrawNode`绘制原语（线条、圆圈等）
- en: How to use vector math helper methods included in Cocos2d-x
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Cocos2d-x中包含的向量数学辅助方法
- en: The game – Rocket Through
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏 – 火箭穿越
- en: 'In this sci-fi version of the classic Snake game engine, you control a rocket
    ship that must move around seven planets, collecting tiny supernovas. But here''s
    the catch: you can only steer the rocket by rotating it around pivot points put
    in place through `touch` events. So the vector of movement we set for the rocket
    ship is at times linear and at times circular.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个经典蛇形游戏引擎的科幻版本中，你控制一艘火箭船，必须在七个行星之间移动，收集微小的超新星。但这里有个问题：你只能通过通过`touch`事件放置的支点旋转来控制火箭。所以，我们为火箭船设定的运动矢量有时是线性的，有时是圆形的。
- en: The game settings
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设置
- en: This is a universal game designed for the regular iPad and then scaled up and
    down to match the screen resolution of other devices. It is set to play in portrait
    mode and it does not support multitouches.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用游戏，专为普通iPad设计，然后放大和缩小以匹配其他设备的屏幕分辨率。它设置为在纵向模式下播放，并且不支持多点触控。
- en: Play first, work later
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先玩，后工作
- en: Download the `4198_05_START_PROJECT.zip` and `4198_05_FINAL_PROJECT.zip` files
    from this book's **Support** page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的**支持**页面下载`4198_05_START_PROJECT.zip`和`4198_05_FINAL_PROJECT.zip`文件。
- en: You will, once again, use the **Start Project** option to work on; this way,
    you won't need to type logic or syntax already covered in previous chapters. The
    **Start Project** option contains all the resource files and all the class declarations
    as well as placeholders for all the methods inside the classes' implementation
    files. We'll go over these in a moment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次使用**开始项目**选项来工作；这样，你就不需要输入已经在之前章节中覆盖的逻辑或语法。**开始项目**选项包含所有资源文件和所有类声明，以及类实现文件中的所有方法的占位符。我们稍后会介绍这些内容。
- en: You should run the final project version to acquaint yourself with the game.
    By pressing and dragging your finger on the rocket ship, you draw a line. Release
    the touch and you create a pivot point. The ship will rotate around this pivot
    point until you press on the ship again to release it. Your aim is to collect
    the bright supernovas and avoid the planets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该运行最终项目版本，以便熟悉游戏。通过按住并拖动你的手指在火箭船上，你可以画一条线。释放触摸，你创建一个支点。船将围绕这个支点旋转，直到你再次按下船来释放它。你的目标是收集明亮的超新星并避开行星。
- en: '![Play first, work later](img/00016.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![先玩，后工作](img/00016.jpeg)'
- en: The start project
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始项目
- en: If you run the **Start Project** option, you should see the basic game screen
    already in place. There is no need to repeat the steps we've taken in our previous
    tutorial to create a batch node and place all the screen sprites. We once again
    have a `_gameBatchNode` object and a `createGameScreen` method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行**开始项目**选项，你应该能看到基本的游戏屏幕已经就位。没有必要重复我们在之前的教程中创建批节点和放置所有屏幕精灵的步骤。我们再次有一个`_gameBatchNode`对象和一个`createGameScreen`方法。
- en: But by all means, read through the code inside the `createGameScreen` method.
    What is of key importance here is that each planet we create is stored inside
    the `_planets` vector. And we also create our `_rocket` object (the `Rocket` class)
    and our `_lineContainer` object (the `LineContainer` class) here. More on these
    soon.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是无论如何，请阅读`createGameScreen`方法内部的代码。这里的关键重要性在于，我们创建的每个行星都存储在`_planets`向量中。我们还在这里创建了我们的`_rocket`对象（`Rocket`类）和我们的`_lineContainer`对象（`LineContainer`类）。关于这些内容，我们稍后会详细介绍。
- en: In the **Start Project** option, we also have our old friend `GameSprite`, which
    extends `Sprite` here with an extra method to get the `radius()` method of our
    sprites. The `Rocket` object and all the planets are `GameSprite` objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在**开始项目**选项中，我们还有我们的老朋友`GameSprite`，在这里它扩展了`Sprite`，并增加了一个获取精灵的`radius()`方法。`Rocket`对象和所有行星都是`GameSprite`对象。
- en: Screen settings
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕设置
- en: 'So if you have the **Start Project** option opened in Xcode, let''s review
    the screen settings for this game in `AppDelegate.cpp`. Inside the `applicationDidFinishLaunching`
    method, you should see this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你在 Xcode 中打开了 **Start Project** 选项，让我们回顾一下 `AppDelegate.cpp` 中这个游戏的屏幕设置。在
    `applicationDidFinishLaunching` 方法内部，你应该看到以下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So we basically start the same way we did in the previous game. The majority
    of sprites in this game are circle-shaped and you may notice some distortion in
    different screens; you should test the same configuration but using different
    `ResolutionPolicies`, such as `SHOW_ALL`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们基本上是以与上一款游戏相同的方式开始的。这款游戏中的大多数精灵都是圆形的，你可能会在不同的屏幕上注意到一些扭曲；你应该测试相同的配置，但使用不同的
    `ResolutionPolicies`，例如 `SHOW_ALL`。
- en: So what are particles?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，粒子是什么？
- en: Particles or particle systems are a way to add special effects to your applications.
    In general terms this is achieved by the use of a large number of tiny textured
    sprites (particles), which are animated and run through a series of transformations.
    You can use these systems to create smoke, explosions, sparks, lightening, rain,
    snow, and other such effects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子或粒子系统是向你的应用程序添加特殊效果的一种方式。一般来说，这是通过使用大量的小纹理精灵（粒子）来实现的，这些粒子被动画化并通过一系列变换运行。你可以使用这些系统来创建烟雾、爆炸、火花、闪电、雨、雪以及其他类似效果。
- en: As I mentioned in [Chapter 1](part0016_split_000.html#page "Chapter 1. Installing
    Cocos2d-x"), *Installing Cocos2d-x*, you should seriously consider getting yourself
    a program to help you design your particle systems. In this game, the particles
    were created in ParticleDesigner.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 [第 1 章](part0016_split_000.html#page "第 1 章。安装 Cocos2d-x") 中提到的，*安装 Cocos2d-x*，你应该认真考虑为自己获取一个程序来帮助你设计粒子系统。在这款游戏中，粒子是在
    ParticleDesigner 中创建的。
- en: It's time to add them to our game!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将它们添加到我们的游戏中了！
- en: Time for action – creating particle systems
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建粒子系统
- en: For particles, all we need is the XML file describing the particle system's
    properties.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于粒子，我们只需要描述粒子系统属性的 XML 文件。
- en: So let's go to `GameLayer.cpp`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以让我们去 `GameLayer.cpp`。
- en: The game initializes by calling `createGameScreen`, which is already in place,
    then `createParticles` and `createStarGrid`, which is also implemented. So let's
    go over the `createParticles` method now.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏通过调用 `createGameScreen` 初始化，这已经就位，然后是 `createParticles` 和 `createStarGrid`，这也是已实现的。所以现在让我们来看看
    `createParticles` 方法。
- en: 'Go to that method in `GameLayer.cpp` and add the following code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `GameLayer.cpp` 中的那个方法，并添加以下代码：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*What just happened?*'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created our first particles. ParticleDesigner exports the particle system
    data as a `.plist` file, which we used to create our `ParticleSystemQuad` objects.
    You should open one of these files in Xcode to review the number of settings used
    in a particle system. From Cocos2d-x you can modify any of these settings through
    setters inside `ParticleSystem`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了第一个粒子。ParticleDesigner 将粒子系统数据导出为 `.plist` 文件，我们使用它来创建我们的 `ParticleSystemQuad`
    对象。你应该在 Xcode 中打开其中一个文件来查看粒子系统中使用的设置数量。从 Cocos2d-x 中，你可以通过 `ParticleSystem` 中的设置器修改这些设置中的任何一个。
- en: 'The particles we''ll use in this game are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中使用的粒子如下：
- en: '`_jet`: This is attached to the `_rocket` object and it will trail behind the
    `_rocket` object. We set the system''s angle and source position parameters to
    match the `_rocket` sprite.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_jet`: 这与 `_rocket` 对象相关联，并且它将在 `_rocket` 对象的后面拖尾。我们将系统的角度和源位置参数设置为与 `_rocket`
    精灵匹配。'
- en: '`_boom`: This is the particle system used when `_rocket` explodes.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_boom`: 这是在 `_rocket` 爆炸时使用的粒子系统。'
- en: '`_comet`: This is a particle system that moves across the screen at set intervals
    and can collide with `_rocket`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_comet`: 这是一个在设定间隔内移动穿过屏幕的粒子系统，并且可以与 `_rocket` 发生碰撞。'
- en: '`_pickup`: This is used when a star is collected.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_pickup`: 这用于收集星星时。'
- en: '`_warp`: This marks the initial position of the rocket.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_warp`: 这标记了火箭的初始位置。'
- en: '`_star`: This is the particle system used for the star that the rocket must
    collect.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_star`: 这是火箭必须收集的星星所使用的粒子系统。'
- en: 'The following screenshot shows these various particles:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这些各种粒子：
- en: '![What just happened?](img/00017.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/00017.jpeg)'
- en: All particle systems are added as children to `GameLayer`; they cannot be added
    to our `SpriteBatchNode` class. And you must call `stopSystem()` on each system
    as they're created otherwise they will start playing as soon as they are added
    to a node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有粒子系统都作为 `GameLayer` 的子对象添加；它们不能添加到我们的 `SpriteBatchNode` 类中。并且，在创建每个系统时，你必须调用
    `stopSystem()`，否则它们一旦被添加到节点中就会立即开始播放。
- en: In order to run the system, you make a call to `resetSystem()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行系统，你需要调用`resetSystem()`。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Cocos2d-x comes bundled with some common particle systems you can modify for
    your own needs. If you go to the `test` folder at: `tests/cpp-tests/Classes/ParticleTest`,
    you will see examples of these systems being used. The actual particle data files
    are found at: `tests/cpp-tests/Resources/Particles`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x附带了一些常见的粒子系统，你可以根据需要修改。如果你去`test`文件夹中的`tests/cpp-tests/Classes/ParticleTest`，你会看到这些系统被使用的示例。实际的粒子数据文件位于：`tests/cpp-tests/Resources/Particles`。
- en: Creating the grid
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网格
- en: Let's take some time now to review the grid logic in the game. This grid is
    created inside the `createStarGrid` method in `GameLayer.cpp`. What the method
    does is determine all possible spots on the screen where we can place the `_star`
    particle system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们花些时间来回顾一下游戏中的网格逻辑。这个网格是在`GameLayer.cpp`中的`createStarGrid`方法中创建的。这个方法所做的就是确定屏幕上所有可以放置`_star`粒子系统的可能位置。
- en: 'We use a C++ vector list called `_grid` to store the available spots:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`_grid`的C++向量列表来存储可用的位置：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `createStarGrid` method divides the screen into multiple cells of 32 x 32
    pixels, ignoring the areas too close to the screen borders (`gridFrame`). Then
    we check the distance between each cell and the planet sprites stored inside the
    vector `_planets`. If the cell is far enough from the planets, we store it inside
    the `_grid` vector as `Point`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`createStarGrid`方法将屏幕划分为多个32 x 32像素的单元格，忽略离屏幕边缘太近的区域（`gridFrame`）。然后我们检查每个单元格与存储在向量`_planets`中的星球精灵之间的距离。如果单元格离星球足够远，我们就将其作为`Point`存储在`_grid`向量中。'
- en: In the following figure, you can get an idea of the result we're after. We want
    all the white cells not overlapping any of the planets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以了解我们想要达到的结果。我们想要所有不与任何星球重叠的白色单元格。
- en: '![Creating the grid](img/00018.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![创建网格](img/00018.jpeg)'
- en: 'We output a message to the console with `Log` stating how many cells we end
    up with:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Log`向控制台输出一条消息，说明我们最终有多少个单元格：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `vector` list will be shuffled at each new game, so we end up with a random
    sequence of possible positions for our star:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`vector`列表将在每次新游戏中进行洗牌，所以我们最终得到一个可能的星星位置随机序列：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way we never place a star on top of a planet or so close to it that the
    rocket could not reach it without colliding with the planet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就不会在星球上方或离它如此近的地方放置星星，以至于火箭无法到达它而不与星球相撞。
- en: Drawing primitives in Cocos2d-x
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Cocos2d-x中绘制原语
- en: One of the main elements in the game is the `LineContainer.cpp` class. It is
    a `DrawNode` derived class that allows us to draw lines and circles on the screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的主要元素之一是`LineContainer.cpp`类。它是一个从`DrawNode`派生出来的类，允许我们在屏幕上绘制线条和圆圈。
- en: '`DrawNode` comes bundled with a list of drawing methods you can use to draw
    lines, points, circles, polygons, and so on.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawNode`附带了一系列你可以用来绘制线条、点、圆圈、多边形等的绘制方法。'
- en: The methods we'll use are `drawLine` and `drawDot`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的方法是`drawLine`和`drawDot`。
- en: Time for action – let's do some drawing!
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手画一些东西了！
- en: 'Time to implement the drawing inside `LineContainer.cpp`. You will notice that
    this class already has most of its methods implemented, so you can save a little
    typing. I''ll go over what these methods represent once we add the game''s main
    update method. But basically `LineContainer` will be used to display the lines
    the player draws on screen to manipulate `_rocket` sprite, as well as display
    an energy bar that acts as a sort of timer in our game:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在`LineContainer.cpp`中实现绘制功能了。你会注意到这个类已经实现了大部分方法，所以你可以节省一些输入。一旦我们添加了游戏的主要更新方法，我会解释这些方法代表什么。但基本上`LineContainer`将用于显示玩家在屏幕上绘制的线条，以操纵`_rocket`精灵，以及显示一个充当游戏计时器的能量条：
- en: 'What we need to change here is the `update` method. So this is what you need
    to type inside that method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在这里更改的是`update`方法。所以这就是你需要在那个方法中输入的内容：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We end our drawing calls by drawing the energy bar in the same `LineContainer`
    node:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在同一个`LineContainer`节点上绘制能量条来结束我们的绘制调用：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*What just happened?*'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You just learned how to draw inside `DrawNode`. One important line in that code
    is the `clear()` call. It clears all the drawings in that node before we update
    them with their new state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何在`DrawNode`中绘制。代码中的一条重要行是`clear()`调用。在我们用新状态更新它们之前，它会清除该节点中的所有绘制。
- en: In `LineContainer`, we use a `switch` statement to determine how to draw the
    player's line. If the `_lineType` property is set to `LINE_NONE`, we don't draw
    anything (this will, in effect, clear the screen of any drawings done by the player).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LineContainer`中，我们使用`switch`语句来确定如何绘制玩家的线。如果`_lineType`属性设置为`LINE_NONE`，则不绘制任何内容（这实际上会清除玩家所做的任何绘图）。
- en: If `_lineType` is `LINE_TEMP`, this means the player is currently dragging a
    finger away from the `_rocket` object, and we want to show a white line from the
    `_rocket` current position to the player's current touch position. These points
    are called `tip` and `pivot`, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`_lineType`是`LINE_TEMP`，这意味着玩家正在将手指从`_rocket`对象上拖开，我们想显示从`_rocket`当前位置到玩家当前触摸位置的白线。这些点分别称为`tip`和`pivot`。
- en: We also draw a dot right on the `pivot` point.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`pivot`点上画了一个点。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If `_lineType` is `LINE_DASHED`, it means the player has removed his or her
    finger from the screen and set a new pivot point for the `_rocket` to rotate around.
    We draw a white dotted line, using what is known as the Bezier linear formula
    to draw a series of tiny circles from the `_rocket` current position and the `pivot`
    point:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`_lineType`是`LINE_DASHED`，这意味着玩家已经从屏幕上移除了手指，并为`_rocket`设置了一个新的旋转支点。我们用所谓的贝塞尔线性公式画一条白点线，从`_rocket`当前位置和`pivot`点画一系列小圆：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And finally, for the energy bar, we draw a black line underneath an orange one.
    The orange one resizes as the value for `_energy` in `LineContainer` is reduced.
    The black one stays the same and it's here to show contrast. You layer your drawings
    through the order of your `draw` calls; so the first things drawn appear underneath
    the latter ones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于能量条，我们在橙色条下方画一条黑色线。当`LineContainer`中的`_energy`值减少时，橙色条会调整大小。黑色线保持不变，它在这里是为了显示对比。你通过`draw`调用的顺序来叠加你的绘图；所以先画的东西会出现在后画的东西下面。
- en: The rocket sprite
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火箭精灵
- en: 'Time to tackle the second object in the game: the rocket.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是处理游戏中的第二个对象：火箭。
- en: 'Once again, I already put in place the part of the logic that''s old news to
    you. But please review the code already inside `Rocket.cpp`. We have a method
    to reset the rocket every time a new game starts (`reset`), and a method to show
    the selected state of the rocket (`select(bool flag)`) by changing its displayed
    texture:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我已经放好了对你来说已经是老生常谈的逻辑部分。但请审查已经放在`Rocket.cpp`中的代码。我们有一个方法，每次新游戏开始时重置火箭（`reset`），还有一个方法通过改变其显示纹理来显示火箭的选中状态（`select(bool
    flag)`）：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will either show the rocket with a glow around it, or not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示火箭周围有光晕，或者不显示。
- en: And finally a method to check collision with the sides of the screen (`collidedWithSides`).
    If there is a collision, we adjust the rocket so it moves away from the screen
    side it collided with, and we release it from any pivot point.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个检查与屏幕边缘碰撞的方法（`collidedWithSides`）。如果有碰撞，我们将调整火箭使其远离碰撞的屏幕边缘，并从任何支点位置释放它。
- en: What we really need to worry about here is the rocket's `update` method. And
    that's what we'll add next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要担心的是火箭的`update`方法。这就是我们接下来要添加的。
- en: Time for action – updating our rocket sprite
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的火箭精灵的行动时间
- en: The game's main loop will call the rocket's `update` method in every iteration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的主循环会在每次迭代中调用火箭的`update`方法。
- en: 'Inside the empty `update` method in `Rocket.cpp`, add the following lines:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rocket.cpp`中的空`update`方法内，添加以下行：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we are saying, if the rocket is not rotating `(_rotationOrientation ==
    ROTATE_NONE`), just move it according to its current `_vector`. If it is rotating,
    then use the Cocos2d-x helper `rotateByAngle` method to find its next position
    around its pivot point:![Time for action – updating our rocket sprite](img/00019.jpeg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里我们说的是，如果火箭没有旋转（`_rotationOrientation == ROTATE_NONE`），就根据其当前`_vector`移动它。如果它在旋转，则使用Cocos2d-x辅助函数`rotateByAngle`方法找到其绕支点旋转的下一个位置：![更新我们的火箭精灵的行动时间
    – 更新我们的火箭精灵](img/00019.jpeg)
- en: The method will rotate any point around a pivot by a certain angle. So we rotate
    the rocket's updated position around its pivot (determined by the player) using
    a property of `Rocket` class called _`angularSpeed`; we'll see in a moment how
    it gets calculated.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法将围绕一个支点旋转任意点一定角度。因此，我们使用`Rocket`类的一个属性`_angularSpeed`来旋转火箭的更新位置（由玩家确定），我们稍后会看到它是如何计算的。
- en: Based on whether the rocket is rotating clockwise or counterclockwise, we adjust
    its rotation so the rocket will be at a 90 degree angle with the line drawn between
    the rocket and its pivot point. Then we change the rocket's movement vector based
    on this rotated angle, and we wrap the value of that angle between 0 and 360.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据火箭是顺时针旋转还是逆时针旋转，我们调整其旋转，使火箭与火箭和其支点之间绘制的线条成90度角。然后我们根据这个旋转角度改变火箭的运动矢量，并将该角度的值包裹在0到360度之间。
- en: 'Finish up the `update` method with these lines:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行完成 `update` 方法的编写：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With these lines we determine the new target rotation of our sprite and we run
    an animation to rotate the rocket to its target rotation (with a bit of a spring
    to it).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些行我们确定精灵的新目标旋转，并运行一个动画将火箭旋转到目标旋转（带有一点弹性）。
- en: '*What just happened?*'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just wrote the logic that will move the rocket around the screen, whether
    the rocket is rotating or not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了将火箭在屏幕上移动的逻辑，无论火箭是否旋转。
- en: So when the player picks a pivot point for the `_rocket` sprite, this pivot
    point is passed to both `Rocket` and `LineContainer`. The former will use it to
    rotate its vector around it and the latter will use it to draw a dotted line between
    `_rocket` and the `pivot` point.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当玩家为 `_rocket` 精灵选择一个支点时，这个支点被传递给 `Rocket` 和 `LineContainer`。前者将使用它在其周围旋转矢量，后者将使用它来在
    `_rocket` 和 `pivot` 点之间绘制虚线。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can't use `Action` to rotate the sprite because the target rotation is updated
    too many times in our logic, and `Action` needs time to initialize and run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用 `Action` 来旋转精灵，因为我们的逻辑中目标旋转更新得太频繁，而 `Action` 需要时间来初始化和运行。
- en: So it's time to code the touch events to make all that logic fall into place.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候编写触摸事件代码，让所有这些逻辑都落到实处。
- en: Time for action – handling touches
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 处理触摸
- en: We need to implement `onTouchBegan`, `onTouchMoved`, and `onTouchEnded`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现 `onTouchBegan`、`onTouchMoved` 和 `onTouchEnded`。
- en: 'Now in `GameLayer.cpp`, inside `onTouchBegan`, add the following lines:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `GameLayer.cpp` 中，在 `onTouchBegan` 中添加以下行：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When a touch begins, we only need to determine whether it's touching the ship.
    If it is, we set our `_drawing` property to `true`. This will indicate we have
    a valid point (one that began by touching the `_rocket` sprite).
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当触摸开始时，我们只需要确定它是否触摸了飞船。如果是，我们将我们的 `_drawing` 属性设置为 `true`。这将表明我们有一个有效的点（一个从触摸
    `_rocket` 精灵开始的点）。
- en: We clear any lines we may be currently drawing in `_lineContainer` by calling
    `setLineType( LINE_NONE )`, and we make sure `_rocket` will not rotate until we
    have a pivot point by releasing `_rocket (setRotationOrientation ( ROTATE_NONE
    ))`, so it will continue to move on its current linear trajectory `(_vector`).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用 `setLineType( LINE_NONE )` 清除 `_lineContainer` 中可能正在绘制的任何线条，并确保通过释放 `_rocket
    (setRotationOrientation ( ROTATE_NONE ))`，我们不会旋转 `_rocket`，直到我们有一个支点，这样它将继续沿着当前的线性轨迹
    `(_vector)` 移动。
- en: 'From here, we begin drawing a new line with the next `onTouchMoved` method.
    Inside that method, we add the following lines:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里开始，我们使用下一个 `onTouchMoved` 方法绘制新的线条。在该方法内部，我们添加以下行：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll handle touch moved only if we are using `_drawing`, which means the player
    has pressed on the ship and is now dragging his or her finger across the screen.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只处理触摸移动，如果我们正在使用 `_drawing`，这意味着玩家已经按下了飞船，现在正在将手指拖过屏幕。
- en: Once the distance between the finger and `_rocket` is greater than the _`minLineLength`
    distance we stipulate in game `init`, then we give a visual cue to the player
    by adding a glow around `_rocket (_rocket->select(true))`, and we draw the new
    line in `_lineContainer` by passing it the touch's current position and setting
    the line type to `LINE_TEMP`. If the minimum length is not reached, we don't show
    a line and nor do we show the player selected.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦手指与 `_rocket` 之间的距离大于我们在游戏 `init` 中规定的 `_` `minLineLength` 距离，我们就通过在 `_rocket`
    周围添加发光效果（_rocket->select(true)）向玩家提供一个视觉提示，并在 `_lineContainer` 中通过传递触摸的当前位置并设置线型为
    `LINE_TEMP` 来绘制新的线条。如果未达到最小长度，则不显示线条，也不显示玩家已选择。
- en: 'Next comes `onTouchEnded`. There is logic in place already inside our `onTouchEnded`
    method which deals with game states. You should uncomment the calls to `resetGame`
    and add a new `else if` statement inside the method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `onTouchEnded`。在我们的 `onTouchEnded` 方法中已经存在处理游戏状态的逻辑。你应该取消注释对 `resetGame`
    的调用，并在方法内添加一个新的 `else if` 语句：
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the game is paused, we change the texture in the `_pauseBtn` sprite through
    `Sprite->setDisplayFrame`, and we start running the game again.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏处于暂停状态，我们通过 `Sprite->setDisplayFrame` 在 `_pauseBtn` 精灵中更改纹理，并重新开始运行游戏。
- en: 'Now we begin handling the touch. First, we determine whether it''s landing
    on the `Pause` button:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们开始处理触摸。首先，我们确定它是否落在 `Pause` 按钮上：
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If so, we change the game state to `kGamePaused`, change the texture on the
    `_pauseBtn` sprite (by retrieving another sprite frame from `SpriteFrameCache`),
    stop running the game (pausing it), and return from the function.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们将游戏状态更改为 `kGamePaused`，在 `_pauseBtn` 精灵上更改纹理（通过从 `SpriteFrameCache`
    中检索另一个精灵帧），停止运行游戏（暂停游戏），并从函数中返回。
- en: 'We can finally do something about the rocket ship. So, continuing inside the
    same `if(touch != nullptr) {` conditional seen previously, add these lines:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们终于可以对火箭飞船做些事情了。所以，继续在之前看到的 `if(touch != nullptr) {` 条件语句中，添加以下行：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by deselecting the `_rocket` sprite, and then we check whether we are
    currently showing a temporary line in `_lineContainer`. If we are, this means
    we can go ahead and create our new pivot point with the player's released touch.
    We pass this information to `_lineContainer` with our `setPivot` method, along
    with the line length. The `_rocket` sprite also receives the pivot point information.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先取消选择 `_rocket` 精灵，然后检查我们是否正在 `_lineContainer` 中显示临时线条。如果我们正在显示，这意味着我们可以继续使用玩家的释放触摸来创建新的支点。我们通过
    `setPivot` 方法将此信息传递给 `_lineContainer`，同时传递线条长度。`_rocket` 精灵也会接收到支点信息。
- en: 'Then, things get hairy! The `_rocket` sprite is moving at a pixel-based speed.
    Once `_rocket` starts rotating, it will move at an angular-based speed through
    `Point.rotateByAngle`. So the following lines are added to translate the `_rocket`
    current pixel-based speed into angular speed:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，事情变得复杂！`_rocket` 精灵以像素为基础的速度移动。一旦 `_rocket` 开始旋转，它将通过 `Point.rotateByAngle`
    以基于角的速度移动。因此，以下行被添加以将 `_rocket` 当前像素速度转换为角速度：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It grabs the length of the circumference about to be described by `_rocket
    (line length * 2 * PI)` and divides it by the rocket''s speed, getting in return
    the number of iterations needed for the rocket to complete that length. Then the
    360 degrees of the circle is divided by the same number of iterations (but we
    do it in radians) to arrive at the fraction of the circle that the rocket must
    rotate at each iteration: its angular speed.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它获取将要被 `_rocket` 描述的圆周长度（`_rocket (line length * 2 * PI)`），然后除以火箭的速度，得到火箭完成该长度所需的迭代次数。然后，将圆的360度除以相同的迭代次数（但我们用弧度来计算）以得到火箭在每次迭代中必须旋转的圆周分数：它的角速度。
- en: 'What follows next is even more math, using the amazingly helpful methods from
    Cocos2d-x related to vector math (`Point.getRPerp`, `Point.dot`, `Point.subtract`,
    to name a few) some of which we''ve seen already in the `Rocket` class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的是更多的数学计算，使用 Cocos2d-x 中与向量数学相关的非常有帮助的方法（例如 `Point.getRPerp`、`Point.dot`、`Point.subtract`
    等），其中一些我们在 `Rocket` 类中已经见过：
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What they do here is determine which direction the rocket should rotate to:
    clockwise or counterclockwise, based on its current vector of movement.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们在这里做的是确定火箭应该旋转的方向：顺时针还是逆时针，基于其当前的运动向量。
- en: 'The line the player just drew between `_rocket` and pivot point, which we get
    by subtracting (`Point.subtract`) those two points, has two perpendicular vectors:
    one to the right (clockwise) that you get through `Point.getRPerp` and one to
    the left (counterclockwise) that you get through `Point.getPerp`. We use the angle
    of one of these vectors as the `_rocket` target rotation so the rocket will rotate
    to be at 90 degrees with the line drawn in `LineContainer`. And we find the correct
    perpendicular through the dot product of the `_rocket` current vector and one
    of the perpendiculars (`Point.dot`).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家刚刚在 `_rocket` 和支点之间绘制的线条，通过减去这两个点（`Point.subtract`）得到，有两个垂直向量：一个向右（顺时针）的向量，通过
    `Point.getRPerp` 获取；一个向左（逆时针）的向量，通过 `Point.getPerp` 获取。我们使用其中一个向量的角度作为 `_rocket`
    目标旋转，使火箭旋转到与 `LineContainer` 中绘制的线条成90度，并通过 `_rocket` 当前向量与其中一个垂直向量的点积（`Point.dot`）找到正确的垂直向量。
- en: '*What just happened?*'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: I know. A lot of math and all at once! Thankfully, Cocos2d-x made it all much
    easier to handle.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道。有很多数学计算，而且都是一次性完成的！幸运的是，Cocos2d-x 使这一切处理起来容易得多。
- en: We just added the logic that allows the player to draw lines and set new pivot
    points for the `_rocket` sprite.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了允许玩家绘制线条并设置 `_rocket` 精灵的新支点的逻辑。
- en: The player will steer the `_rocket` sprite through the planets by giving the
    rocket a pivot point to rotate around. And by releasing the `_rocket` from pivot
    points, the player will make it move in a straight line again. All that logic
    gets managed here in the game's touch events.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家将通过给火箭一个旋转的支点来控制`_rocket`精灵穿越行星。通过释放`_rocket`从支点，玩家将使其再次沿直线移动。所有这些逻辑都由游戏中的触摸事件管理。
- en: And don't worry about the math. Though understanding how to deal with vectors
    is a very useful tool in any game developer's toolbox, and you should definitely
    research the topic, there are countless games you can still build with little
    or no math; so cheer up!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并且不用担心数学问题。虽然理解如何处理向量是任何游戏开发者工具箱中非常有用的工具，你应该绝对研究这个话题，但你可以用很少或没有数学知识来构建无数的游戏；所以加油！
- en: The game loop
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: It's time to create our good old ticker! The main loop will be in charge of
    collision detection, updating the points inside `_lineContainer`, adjusting our
    `_jet` particle system to our `_rocket` sprite, and a few other things.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们熟悉的老式计时器了！主循环将负责碰撞检测，更新`_lineContainer`内的分数，调整`_jet`粒子系统以匹配`_rocket`精灵，以及一些其他事情。
- en: Time for action – adding the main loop
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加主循环
- en: Let's implement our main `update` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的主要`update`方法。
- en: 'In `GameLayer.cpp`, inside the `update` method, add the following lines:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameLayer.cpp`中，在`update`方法内部，添加以下行：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We check to see if we are not currently on pause. Then, if there is a line for
    our ship that we need to show in `_lineContainer`, we update the line's `tip`
    point with the `_rocket` current position.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们检查我们是否不在暂停状态。然后，如果有我们需要在`_lineContainer`中显示的船的线，我们使用`_rocket`的当前位置更新线的`tip`点。
- en: We run collision checks between `_rocket` and the screen sides, update the `_rocket`
    sprite, and position and rotate our `_jet` particle system to align it with the
    `_rocket` sprite.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`_rocket`和屏幕边缘之间运行碰撞检测，更新`_rocket`精灵，并定位和旋转我们的`_jet`粒子系统以与`_rocket`精灵对齐。
- en: 'Next we update `_comet` (its countdown, initial position, movement, and collision
    with `_rocket` if `_comet` is visible):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们更新`_comet`（它的倒计时、初始位置、移动和如果`_comet`可见则与`_rocket`的碰撞）：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we update `_lineContainer`, and slowly reduce the opacity of the `_rocket`
    sprite based on the `_energy` level in `_lineContainer`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们更新`_lineContainer`，并逐渐降低`_rocket`精灵的透明度，基于`_lineContainer`中的`_energy`等级：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will add a visual cue for the player that time is running out as the `_rocket`
    sprite will slowly turn invisible.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为玩家添加一个视觉提示，表明时间正在流逝，因为`_rocket`精灵将逐渐变得不可见。
- en: 'Run collision with planets:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行星球的碰撞：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And collision with the star:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且与星星的碰撞：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we collect `_star`, we activate the `_pickup` particle system on the spot
    where `_star` was, we fill up the player's energy level, we make the game slightly
    harder, and we immediately reset `_star` to its next position to be collected
    again.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们收集到`_star`时，我们在`_star`所在的位置激活`_pickup`粒子系统，填充玩家的能量等级，使游戏稍微困难一些，并立即将`_star`重置到下一个位置以便再次收集。
- en: The score is based on the time it took the player to collect `_star`.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分数基于玩家收集`_star`所需的时间。
- en: 'And we keep track of this time on the last lines of `update` where we also
    check the energy level:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`update`函数的最后几行记录这个时间，同时检查能量等级：
- en: '[PRE24]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*What just happened?*'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added the main loop to our game and finally have all the pieces talking to
    each other. But you probably noticed quite a few calls to methods we have not
    implemented yet, such as `killPlayer` and `resetStar`. We'll finish our game logic
    with these methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将主循环添加到游戏中，并且所有的部件都开始相互通信。但你可能已经注意到，我们调用了一些尚未实现的方法，比如`killPlayer`和`resetStar`。我们将使用这些方法完成游戏逻辑。
- en: Kill and reset
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁和重置
- en: It's that time again! Time to kill our player and reset the game! We also need
    to move the `_star` sprite to a new position whenever it's picked up by the player.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 又是时候了！是时候杀死我们的玩家并重置游戏了！我们还需要在玩家拾取`_star`时将其精灵移动到新的位置。
- en: Time for action – adding our resets and kills
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加重置和销毁
- en: We need to add logic to restart our game and to move our pickup star to a new
    position. But first, let's kill the player!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加逻辑来重新开始游戏，并将我们的拾取星移动到新的位置。但首先，让我们销毁玩家！
- en: 'Inside the `killPlayer` method, add the following lines:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`killPlayer`方法内部，添加以下行：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside `resetStar`, add the following lines:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resetStar`内部，添加以下行：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And finally, our `resetGame` method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`resetGame`方法：
- en: '[PRE27]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*What just happened?*'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: That's it. We're done. It took more math than most people are comfortable with.
    But what can I tell you, I just love messing around with vectors!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们完成了。这比大多数人舒服的数学要多。但你能告诉我什么呢，我就是喜欢玩弄向量！
- en: Now, let's move on to Android!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习Android！
- en: Time for action – running the game in Android
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——在Android上运行游戏
- en: 'Follow these steps to deploy the game to Android:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将游戏部署到Android：
- en: Open the manifest file and set the `app` orientation to `portrait`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开清单文件，并将`app`方向设置为`portrait`。
- en: Next, open the `Android.mk` file in a text editor.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在文本编辑器中打开`Android.mk`文件。
- en: 'Edit the lines in `LOCAL_SRC_FILES` to read:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`LOCAL_SRC_FILES`中的行，使其读取：
- en: '[PRE28]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Import the game into Eclipse and build it.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏导入Eclipse并构建它。
- en: Save and run your application. This time, you can try out different size screens
    if you have the devices.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行你的应用程序。这次，如果你有设备，你可以尝试不同的屏幕尺寸。
- en: '*What just happened?*'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You now have Rocket Through running in Android.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的Rocket Through已经在Android上运行了。
- en: Have a go hero
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大胆尝试
- en: Add logic to the `resetStar` method so that the new position picked is not too
    close to the `_rocket` sprite. So, make the function a recurrent one until a proper
    position is picked.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 给`resetStar`方法添加逻辑，以确保新选择的位置不要离`_rocket`精灵太近。所以，让这个函数成为一个循环的函数，直到选择了一个合适的位置。
- en: And take the `warp` particle system, which right now does not do a whole lot,
    and use it as a random teleport field so that the rocket may get sucked in by
    a randomly placed warp and moved farther away from the target star.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用`warp`粒子系统，目前它并没有做什么，将其用作随机传送场，这样火箭可能会被随机放置的传送门吸入，并远离目标恒星。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You now have enough information about Cocos2d-x to produce
    awesome 2D games. First sprites, then actions, and now particles.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在对Cocos2d-x有了足够的信息来制作出色的2D游戏。首先是精灵，然后是动作，现在是粒子。
- en: Particles make everything look shiny! They are easy to implement and are a very
    good way to add an extra bit of animation to your game. But it's very easy to
    overdo it, so be careful. You don't want to give your players epileptic fits.
    Also, running too many particles at once could stop your game in its tracks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子让一切看起来都很闪亮！它们很容易实现，并且是给游戏添加额外动画的好方法。但是很容易过度使用，所以请小心。你不想让你的玩家出现癫痫发作。此外，一次性运行太多粒子可能会让你的游戏停止运行。
- en: In the next chapter, we'll see how to use Cocos2d-x to quickly test and develop
    game ideas.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用Cocos2d-x快速测试和开发游戏想法。
