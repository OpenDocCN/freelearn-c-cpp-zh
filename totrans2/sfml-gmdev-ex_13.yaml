- en: Chapter 13. We Have Contact! – Networking Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章. 我们有联系！ – 网络基础
- en: In today's world where everyone and everything is interconnected, playing games
    with your friends is not a new thing anymore. It has become a standard amongst
    many groups. Expressions such as "frag" or "camping" became buzzwords amongst
    gamers. Whether it's a 2-4 player LAN party or a massive multiplayer online game,
    networking obviously plays a huge role in the gaming circles. Introducing the
    element of other human players amplifies the content added, on top of making the
    game's universe seem much more alive and flourishing. In many instances, this
    sort of phenomenon actually brings people together and provides a very enjoyable
    experience, as long as it's not lagging. It's about time we harness the essence
    of multiplayer, and perhaps even propagate the six degrees of separation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今这个人人互联、事事相连的世界里，和朋友一起玩游戏已经不再是什么新鲜事了。它已经成为许多群体中的标准。像“击杀”或“露营”这样的表达已经成为游戏玩家的流行语。无论是2-4人的局域网聚会还是大型多人在线游戏，网络显然在游戏圈中扮演着巨大的角色。引入其他玩家的元素增加了游戏内容，同时也让游戏的宇宙看起来更加生动和繁荣。在许多情况下，这种现象实际上将人们聚集在一起，并提供了一种非常愉快的体验，只要它不卡顿。现在是时候利用多人游戏的核心，也许甚至传播六度分隔理论了。
- en: 'In this chapter, we''re going to be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Fundamentals of networking applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序的基本原理
- en: Utilizing threads and ensuring data safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用线程并确保数据安全
- en: Implementing our own basic communication protocol
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们自己的基本通信协议
- en: Building a simple chat client and server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的聊天客户端和服务器
- en: Let's break the isolation of your system and open it up to the outside world!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打破系统的孤立状态，将其对外开放！
- en: Basics of networking
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络基础
- en: 'First things first, let''s cover a term that is pretty much synonymous with
    networking at this point: sockets. What is a socket? In its simplest terms, a
    socket is just an interface that is used for network communications. When two
    applications are communicating, at least two sockets are involved and data is
    exchanged between them. When data is sent from application A to application B,
    it first leaves from the socket of application A, travels throughout the internet,
    and hopefully reaches the socket of application B:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来解释一个在此时与网络几乎同义的术语：套接字。什么是套接字？最简单的说法，套接字就是一个用于网络通信的接口。当两个应用程序进行通信时，至少涉及两个套接字，并且它们之间交换数据。当数据从应用程序A发送到应用程序B时，它首先从应用程序A的套接字出发，穿越整个互联网，并希望最终到达应用程序B的套接字：
- en: '![Basics of networking](img/B04284_13_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![网络基础](img/B04284_13_01.jpg)'
- en: Each socket has to be bound to something referred to as a port, which can be
    imagined as a gateway to a system. Each gateway is used for different purposes
    and can only be used by one socket at a time. In the simplest terms, a port is
    just a 16-bit numerical value, which means a port number can be as high as 65535\.
    While a service is using a specific port, another socket cannot bind to it until
    it's freed. The most commonly used ports are in a range of 20-1024\. For example,
    port 80 is always used for HTTP traffic, which is what most website hosting servers
    operate on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个套接字都必须绑定到一个称为端口的实体上，这可以想象成通向系统的门户。每个门户用于不同的目的，并且一次只能由一个套接字使用。最简单的说法，端口就是一个16位的数值，这意味着端口号可以高达65535。当某个服务正在使用特定的端口时，另一个套接字无法绑定到它，直到它被释放。最常用的端口范围在20-1024之间。例如，端口80始终用于HTTP流量，这是大多数网站托管服务器运行的基础。
- en: SFML networking
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML网络
- en: 'In order to access network constructs in SFML, we must first include the network
    header:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在SFML中访问网络结构，我们首先需要包含网络头文件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Building a project that has networking capabilities also requires more library
    files in order to link properly, specifically `sfml-network.lib`, `ws2_32.lib`,
    and `winmm.lib`. Having these libraries included will ensure that the project
    compiles properly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 构建具有网络功能的项目还需要更多的库文件来正确链接，具体为`sfml-network.lib`、`ws2_32.lib`和`winmm.lib`。包含这些库将确保项目能够正确编译。
- en: 'There are several types of sockets available out there, each with specific
    features, advantages, and disadvantages. SFML provides us with two basic types:
    TCP and UDP. **TCP** stands for **Transmission Control Protocol**, while **UDP**
    stands for **User Datagram Protocol**. Both of these protocols are capable of
    sending and receiving data, but they are fundamentally different from each other
    under the hood. It''s fair to mention that while two sockets of the same type
    cannot bind to the same port, it can still be bound to by two different protocols.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有几种类型的套接字可供选择，每种都有特定的功能、优点和缺点。SFML 为我们提供了两种基本类型：TCP 和 UDP。**TCP** 代表 **传输控制协议**，而
    **UDP** 代表 **用户数据报协议**。这两个协议都能够发送和接收数据，但在底层它们是根本不同的。公平地说，虽然同一类型的两个套接字不能绑定到同一个端口，但它们仍然可以被两种不同的协议绑定。
- en: TCP sockets
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 套接字
- en: 'TCP is a connection-based protocol, which means that before data can be exchanged,
    a connection has to be established by having an application that attempts to initiate
    it (a client) connect to another application that is actively waiting for connections
    (a server). Let''s take a look at a basic client application connection attempt:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是一种基于连接的协议，这意味着在交换数据之前，必须通过一个尝试发起连接的应用程序（客户端）连接到另一个积极等待连接的应用程序（服务器）来建立连接。让我们看看一个基本的客户端应用程序连接尝试：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we create a TCP socket instance. Its `connect` method is called next,
    with three arguments:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 TCP 套接字实例。接下来，会调用其 `connect` 方法，并传递三个参数：
- en: 'The first argument is of the type `sf::IpAddress` and is exactly what it sounds
    like: the IP address we are trying to connect to, which has to be open and have
    a server accepting connections.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是 `sf::IpAddress` 类型，正如其名称所示：我们试图连接到的 IP 地址，它必须是开放的并且有一个服务器正在接受连接。
- en: The second argument is the port number.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是端口号。
- en: Lastly, we have the third argument, which is completely optional. It's the timeout
    value after which the socket should give up and throw an error. If this argument
    isn't provided, the default operating system time-out value is used.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有第三个参数，它是完全可选的。这是套接字在超时后放弃并抛出错误的超时值。如果没有提供此参数，则使用默认的操作系统超时值。
- en: The return value of the connect method is captured and stored in a `sf::Socket::Status`
    type, which is just an enumeration table that has a few useful values, such as
    `Done`, `NotReady`, `Partial`, `Disconnected`, and `Error`. Every method of both
    socket types that has to do with sending or receiving data, connecting or disconnecting,
    returns a status that we can use for error checking.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 方法的返回值被捕获并存储在 `sf::Socket::Status` 类型中，它只是一个包含一些有用值的枚举表，例如 `Done`、`NotReady`、`Partial`、`Disconnected`
    和 `Error`。与发送或接收数据、连接或断开连接相关的两种套接字类型的每个方法都会返回一个我们可以用于错误检查的状态。'
- en: 'In order to accept a connection on the server side when using TCP, a special
    class is used: `sf::TcpListener`. It has to be bound to a specific port and cannot
    send or receive any data:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 TCP 在服务器端接受连接时，会使用一个特殊的类：`sf::TcpListener`。它必须绑定到特定的端口，并且不能发送或接收任何数据：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the socket is set up, the listener's `accept` method is called. Along
    with `connect` and a few other methods we'll be covering down the line, it actually
    stops the application from continuing until a connection comes through. This is
    what's referred to as `blocking`. A good example of a blocking function from an
    STL library is `std::cin`. Why is this important? Well, to put it simply, networking
    operations are rather unpredictable. There is no way of knowing exactly how long
    a connection attempt may take, as the host on the other end could be unreachable.
    During that time, your application will stand still and do absolutely nothing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字设置完成后，会调用监听器的 `accept` 方法。与 `connect` 以及我们稍后将要讨论的几个其他方法一样，它实际上会阻止应用程序继续执行，直到建立连接。这被称为
    `阻塞`。一个来自 STL 库的阻塞函数的好例子是 `std::cin`。为什么这很重要呢？简单来说，网络操作相当不可预测。我们无法确切知道连接尝试可能需要多长时间，因为另一端的宿主可能无法到达。在这段时间里，你的应用程序将停滞不前，什么也不做。
- en: 'After a connection finally comes through, the incoming socket can be used to
    communicate with the client:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当连接建立后，传入的套接字可以用来与客户端通信：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The send method has two variations: a low-level one that allows the user to
    send a raw array of bytes and a higher level one that uses a specialized class
    we''re going to be covering shortly. The low-level version takes in a `void` pointer
    and the number of bytes it should send.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方法有两种变体：一种是低级版本，允许用户发送原始字节数组，另一种是高级版本，它使用我们将很快介绍的专业化类。低级版本接受一个`void`指针和它应该发送的字节数量。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that sending data could also fail for a number of reasons. Make
    sure to always check the returned status for errors!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于多种原因，发送数据也可能失败。务必始终检查返回的状态以检查错误！
- en: 'In order to receive data on the other end, a socket needs to listen:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在另一端接收数据，套接字需要监听：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When raw data is sent, a large-enough buffer must be provided along with the
    maximum size it can contain, which is the second argument of the receive method.
    The third argument is the number of bytes received, which is written over when
    data comes in. The receive method is also blocking by default. This means that
    it will halt the entire program until some data comes through.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送原始数据时，必须提供一个足够大的缓冲区以及它可以包含的最大大小，这是接收方法中的第二个参数。第三个参数是接收到的字节数，当数据到来时会被写入。默认情况下，接收方法也是阻塞的。这意味着它将使整个程序停止，直到有数据通过。
- en: Handling multiple connections
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个连接
- en: 'You might have noticed by now that all of the examples above focus on just
    one client connecting and sending data. In today''s hyper-connected world that
    is almost never the case, so let''s take a look at a way we can handle multiple
    TCP sockets at the same time:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，上述所有示例都只关注一个客户端连接并发送数据。在当今高度互联的世界里，这种情况几乎从未发生过，所以让我们看看我们如何同时处理多个TCP套接字：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `sf::SocketSelector` class provides a way for us to block on multiple sockets,
    instead of just one. It monitors every single socket that is added to it for incoming
    data, unlike the previous examples that only dealt with a single socket.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::SocketSelector`类提供了一种让我们能够阻塞在多个套接字上的方法，而不是仅仅一个。它监视添加到其中的每个套接字，以寻找传入的数据，与之前的示例不同，之前的示例只处理了一个套接字。'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A very important thing to keep in mind is that the socket selector does not
    actually store the sockets added to it, but merely points to them. This means
    that although a socket has been added to a selector, it still must be stored in
    a data container of your choosing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的一个重要事情是，套接字选择器实际上并不存储添加到其中的套接字，它只是指向它们。这意味着尽管套接字已被添加到选择器中，但它仍然必须存储在你选择的数据容器中。
- en: 'To handle incoming data from multiple sockets, the `wait` method of a socket
    selector class is used:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理来自多个套接字的数据，可以使用套接字选择器的`wait`方法：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The argument provided in the `wait` method is, once again, optional. If one
    of the socket inside the selector receives something, *true* is returned and we
    can iterate over our data container to find the socket that received data, by
    using the `isRead` `y` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait`方法提供的参数再次是可选的。如果选择器内的某个套接字接收到了数据，则返回`true`，我们可以通过使用`isRead`方法遍历我们的数据容器来找到接收数据的套接字。'
- en: TCP protocol specifics
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP协议细节
- en: 'One major difference between TCP and UDP is transmission reliability. The TCP
    protocol uses something called a three-way-handshake when establishing a connection.
    It looks a little something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP之间一个主要的不同点在于传输可靠性。TCP协议在建立连接时使用了一种称为三次握手的机制。它看起来有点像这样：
- en: '![TCP protocol specifics](img/B04284_13_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![TCP协议细节](img/B04284_13_02.jpg)'
- en: A **SYN** (**synchronize**) packet is first sent by the party attempting to
    establish a connection. The server responds with a **SYN/ACK** (**synchronize-acknowledgement**)
    packet, to which the client responds with an **ACK** (**acknowledgement**) packet.
    These three exchanges of data happen at the beginning of every connection. Afterwards,
    when actual data is being sent, it travels in a form of a SYN packet, to which
    the receiving party always replies with an ACK packet. If the party sending some
    data does not receive an ACK response, the same data is sent again after a specific
    time interval. All of this data being sent back and forth is also tagged with
    a sequence number, which enables the TCP protocol to also ensure that data arrives
    in order. This provides reliability, but at a price. Because of additional checks,
    waiting if some data got lost somewhere and additional data overhead, TCP ends
    up being slower and bulkier. If a packet gets lost somewhere, the receiving party
    has to wait until the same data is retransmitted in order to continue. For most
    applications and even certain types of games this difference is speed is negligible.
    However, some really fast-paced games that require highest possible efficiency
    and don't care about packet loss end up using UDP.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试建立连接的一方首先发送一个**SYN**（**同步**）数据包。服务器响应一个**SYN/ACK**（**同步确认**）数据包，客户端随后响应一个**ACK**（**确认**）数据包。这三个数据交换发生在每个连接的开始阶段。之后，当实际数据发送时，它以SYN数据包的形式发送，接收方总是回复一个ACK数据包。如果发送数据的方没有收到ACK响应，那么在特定的时间间隔后，会再次发送相同的数据。所有这些来回发送的数据都会被标记上序列号，这使得TCP协议也能确保数据按顺序到达。这提供了可靠性，但代价是速度较慢且体积较大。如果某个数据包丢失，接收方必须等待直到相同的数据被重传才能继续。对于大多数应用程序甚至某些类型的游戏，这种速度差异是可以忽略不计的。然而，一些需要最高效率且不关心数据包丢失的快节奏游戏最终会使用UDP。
- en: User datagram protocol
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户数据报协议
- en: Both TCP and UDP sockets in SFML actually inherit from the same base class,
    which means a lot of the functionality that we saw with TCP carries over. One
    major difference, however, is that UDP is connectionless. This means that there
    is no such thing as a three-way-handshake for UDP and for that matter, no acknowledgement
    packets either. UDP is centered on data being sent. There are no order checks,
    no sequence numbers, no bloated packets, and no guarantee that what was sent out
    is going to reach its destination. This total elimination of error checking reduces
    the packet overhead from 20 bytes when using TCP all the way down to 8 bytes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在SFML中，TCP和UDP套接字实际上都继承自同一个基类，这意味着我们之前看到的TCP的大部分功能都得到了继承。然而，一个主要的区别是UDP是无连接的。这意味着UDP没有三次握手这样的东西，也没有确认包。UDP专注于数据的发送。没有顺序检查，没有序列号，没有膨胀的包，也没有保证发送出去的数据会到达目的地。这种完全消除错误检查将数据包开销从使用TCP时的20字节降低到8字节。
- en: With all of that said, there are some limitations that UDP has, such as the
    maximum size of the data being sent out. Data in UDP is being sent out in datagrams
    instead of streams, which is how TCP handles it. The maximum imposed datagram
    size, which is a little less than 65536 bytes, cannot be exceeded.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，UDP也有一些限制，比如发送数据的最大大小。UDP中的数据是以数据报的形式发送的，而不是像TCP那样以流的形式，这是TCP处理数据的方式。规定的最大数据报大小略小于65536字节，不能超过。
- en: 'Because UDP is connectionless, there is no equivalent of `sf::TcpListener`
    that can be used to accept incoming traffic. The socket must be bound to a specific
    port before it can be used though:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为UDP是无连接的，所以没有可以用来接收传入流量的`sf::TcpListener`等价物。不过，在可以使用之前，套接字必须绑定到特定的端口：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Binding to a random port is also possible, thanks to `sf::Socket::AnyPort`,
    which can be passed into the bind method instead of a numerical constant. It can
    be retrieved later like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`sf::Socket::AnyPort`，可以将随机端口绑定到套接字，而不是使用数值常量。稍后可以像这样检索它：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sending and receiving carries the same gist, except for having to provide additional
    arguments for an IP address and port that the data is being sent to or received
    from, on the count of UDP being connectionless:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 发送和接收的基本原理相同，只是由于UDP是无连接的，所以需要提供额外的参数，即数据发送到或接收自的IP地址和端口：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, UDP sockets do work with a `sf::SocketSelector` class, but given the
    nature of UDP, there are fewer instances where that actually come in handy, because
    all data can simply be sent and received by using one or two sockets at most.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，UDP套接字确实与`sf::SocketSelector`类一起工作，但鉴于UDP的特性，真正有用的情况并不多，因为所有数据最多可以通过一个或两个套接字发送和接收。
- en: Alternative to sending raw data
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送原始数据的替代方案
- en: Simply sending raw bytes across a network can get quite tricky, not to mention
    problematic. The first and perhaps the biggest issue is the **endianness** of
    a machine. Some processors interpret data in a different order than others. In
    a big-endian family, the most significant byte is stored first, while a little-endian
    family machine would do the opposite. Raw data being sent from a big-endian machine
    to a little-endian machine would be interpreted differently and result in funky
    results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上简单地发送原始字节可能会变得相当复杂，更不用说有问题了。第一个也许是最大的问题是机器的**字节序**。一些处理器以不同于其他处理器的顺序解释数据。在大端字节序的家族中，最重要的字节首先存储，而在小端字节序的机器中则会相反。从大端机器发送到小端机器的原始数据会被不同地解释，并导致奇怪的结果。
- en: On top of data being stored differently amongst all types of machines, the sizes
    of basic variables in C++ may vary between different machines and compilers. If
    that is not enough, the TCP protocol introduces additional headaches due to it
    not preserving message boundaries. Chunks of data being sent out can be split
    and combined, which can cause problems if they are not properly re-constructed
    by the receivers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有类型的机器存储数据的方式不同之外，C++中基本变量的大小可能在不同的机器和编译器之间有所不同。如果这还不够，TCP协议由于不保留消息边界而引入了额外的麻烦。发送出去的数据块可能会被分割和组合，如果接收者没有正确地重新构造它们，这可能会引起问题。
- en: While all of this sounds fairly horrific, there are solutions to all of these
    problems. Data type size variations can be addressed by using SFML's fixed-size
    types, such as `sf::Int8`, `sf::Uint16`, and so on. They are simple type definitions,
    mapped to data types that are sure to have the expected size depending on the
    platform. Exchanging these types over the network instead re-assures data safety.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些都听起来相当可怕，但所有这些问题都有解决方案。可以通过使用SFML的固定大小类型来解决数据类型大小变化的问题，例如`sf::Int8`、`sf::Uint16`等。它们是简单的类型定义，映射到平台上的预期大小确定的数据类型。通过网络交换这些类型可以再次确保数据安全。
- en: SFML packets
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SFML数据包
- en: 'The endianness and message boundary problems require slightly more effort to
    resolve. Enter `sf::Packet`! It is a specialized, lightweight class that can be
    used to pack/extract data. SFML packets use the exact same interface as standard
    streams by using the `<<` and `>>` operators for data insertion and extraction,
    as seen here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序和消息边界问题需要稍微更多的努力来解决。这时就出现了`sf::Packet`！它是一个专门且轻量级的类，可以用来打包/提取数据。SFML数据包使用与标准流完全相同的接口，通过使用`<<`和`>>`操作符进行数据插入和提取，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While packing data is always guaranteed to work, extracting it can in fact
    fail. If it does, the packet error flag is set. Checking whether the flag is set
    or not is similar to testing a Boolean value, which is again similar to standard
    streams:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然打包数据始终可以保证工作，但提取数据实际上可能会失败。如果发生这种情况，数据包错误标志会被设置。检查标志是否设置与测试布尔值类似，这又与标准流类似：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Both TCP and UDP packets do provide overloaded send and receive methods that
    work with instances of `sf::Packet`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP数据包都提供了与`sf::Packet`实例一起工作的重载发送和接收方法：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Custom data types can also be fed into or extracted from the `sf::Packet` structure,
    if overloads of `<<` and `>>` operators are provided, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`<<`和`>>`操作符的重载，自定义数据类型也可以被输入到或从`sf::Packet`结构中提取，如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This enables easy insertion and extraction of a custom data type:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得插入和提取自定义数据类型变得容易：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using SFML packets with TCP sockets poses a small restriction. Due to the message
    boundaries having to be preserved, some extra data is sent in the packet. This
    means that data sent in a form of a SFML packet has to be received by using a
    SFML packet. UDP does not pose this restriction, as the protocol itself preserves
    message boundaries.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SFML数据包与TCP套接字存在一个小限制。由于必须保留消息边界，数据包中会发送一些额外的数据。这意味着以SFML数据包形式发送的数据必须使用SFML数据包接收。UDP不对此有限制，因为该协议本身保留了消息边界。
- en: Non-blocking sockets
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非阻塞套接字
- en: 'Both TCP and UDP sockets, as well as the TCP listener, are blocking by default.
    Their blocking mode can be changed to return immediately:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TCP和UDP套接字以及TCP监听器都是阻塞的。它们的阻塞模式可以更改为立即返回：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Receiving on a non-blocking socket that has no data incoming would return `sf::Socket::NotReady`,
    as well as trying to accept a TCP connection if there are none pending. Putting
    your sockets in a non-blocking mode is the easiest way to not halt your program's
    execution by instead checking the availability of data or connections each time
    it is updated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个没有数据传入的非阻塞套接字上接收数据会返回 `sf::Socket::NotReady`，同样，如果没有挂起的TCP连接，尝试接受TCP连接也会返回
    `sf::Socket::NotReady`。将你的套接字置于非阻塞模式是避免程序执行因检查数据或连接的可用性而中断的最简单方法。
- en: 'Non-blocking TCP sockets are not guaranteed to send all of the data you pass
    to it, even when using instances of `sf::Packet`. If a `sf::Socket::Partial` status
    is returned, the data must be sent again at the exact byte offset of where the
    last call to `send` stopped. If raw data is sent, make sure to use this `send`
    overload:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞TCP套接字不能保证发送你传递给它的所有数据，即使使用 `sf::Packet` 实例。如果返回 `sf::Socket::Partial` 状态，必须在
    `send` 上一次调用停止的确切字节偏移量处再次发送数据。如果发送原始数据，请确保使用此 `send` 重载：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It overwrites the third provided argument with the exact number of bytes sent
    out.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它会覆盖第三个提供的参数，以发送的字节数的准确值。
- en: Sending `sf::Packet` instances does not require you to keep track of the byte
    offset, as it is stored in the packet itself. This means that you cannot destroy
    the packet instance until it has been successfully sent. Creating a new packet
    and filling it with the exact same data will not work, as the data offset that
    was stored internally inside the packet is lost.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 `sf::Packet` 实例不需要你跟踪字节数偏移量，因为它存储在数据包本身中。这意味着你必须在数据包成功发送之前不能销毁数据包实例。创建一个新的数据包并用完全相同的数据填充它将不起作用，因为数据包内部存储的数据偏移量丢失了。
- en: Letting the traffic flow
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让流量流动
- en: There are a lot more subtleties to communicating over the internet than using
    the right code. As we discussed previously, the port number an application uses
    to send or receive data can be imagined as a gateway to your system, of which
    there are thousands. That gateway can either be open or closed. By default, it's
    more likely than not that whichever port you choose to use for your program is
    going to be closed on your system, which doesn't matter for local connections,
    but anything coming from the outside world through that particular port is not
    going to get through. Managing your ports can be done by visiting your router's
    settings page. The steps required to do so are different for each router out there.
    Luckily, [http://portforward.com](http://portforward.com) is there to help you!
    By visiting it and looking up the make and model of your router on this website,
    you can find detailed instructions on how any port can be opened or closed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上进行通信比使用正确的代码有更多细微之处。正如我们之前讨论的，应用程序用于发送或接收数据的端口号可以想象成是通向你的系统的门户，其中有成千上万个。这个门户可以是开启的，也可以是关闭的。默认情况下，你选择的程序使用的端口在你的系统上更有可能被关闭，这对于本地连接来说无关紧要，但任何通过该特定端口从外部世界传入的数据都无法通过。你可以通过访问你的路由器设置页面来管理你的端口。所需的步骤因每个路由器而异。幸运的是，[http://portforward.com](http://portforward.com)
    提供了帮助！通过访问它并在该网站上查找你的路由器的制造商和型号，你可以找到有关如何打开或关闭任何端口的详细说明。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Sockets bound to `sf::Socket::AnyPort` will most likely end up binding to a
    port in a range of 49152 and 65535\. Port forwarding works for ranges, as well
    as individual ports. Opening this particular range of ports will ensure that your
    SFML networking application works as intended when communicating over the World
    Wide Web.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到 `sf::Socket::AnyPort` 的套接字很可能会绑定到49152和65535之间的某个端口。端口转发适用于范围，以及单个端口。打开这个特定的端口范围将确保你的SFML网络应用程序在通过万维网进行通信时按预期工作。
- en: Firewalls also tend to block this type of traffic by default. For example, the
    Windows firewall prompts users about allowing traffic to come through for an application
    that's being launched for the first time. Depending on your application, however,
    that prompt may never manifest due to the Windows firewall not being the most
    reliable piece of software ever written. If all of your key ports are open and
    a particular program still doesn't seem to be sending or receiving anything, make
    sure to add your client or server program to the "allowed list" of the Windows
    firewall, by going to **Control Panel**, clicking on **Windows Firewall**, selecting
    **Allow a program or feature through Windows Firewall** on the left side, clicking
    **Change settings**, and finally hitting the **Allow another program** button.
    This will bring up another window that can be used to add your client/server application
    by browsing for it and clicking on **Add** afterwards.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙也通常会默认阻止此类流量。例如，Windows 防火墙会提示用户允许流量通过首次启动的应用程序。然而，根据您的应用程序，由于 Windows 防火墙并非最可靠的应用软件，该提示可能永远不会出现。如果您的所有关键端口都开放，而某个特定程序似乎仍然没有发送或接收任何内容，请确保将您的客户端或服务器程序添加到
    Windows 防火墙的“允许列表”中，方法是转到**控制面板**，点击**Windows 防火墙**，在左侧选择**通过 Windows 防火墙允许程序或功能**，点击**更改设置**，最后点击**允许另一个程序**按钮。这将打开另一个窗口，您可以通过浏览并点击**添加**来添加您的客户端/服务器应用程序。
- en: Multi-threading
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: 'Having blocking functions in your code can be a real nuisance. Listening for
    incoming network connections or data, asking users to input something into the
    console, or even loading game data, like textures, maps, or sounds, can block
    a program from executing until it''s done. Have you ever wondered how certain
    games have a loading bar that actually moves while the data is being loaded? How
    can that be done with code that is executed sequentially? The answer to that is
    multi-threading. Your application runs all its code sequentially from top to bottom
    in something referred to as the main thread. It is not a program, as it can''t
    exist by itself. Instead, a thread only runs within your application. The beauty
    of this is that multiple threads can exist and run all at once, which enables
    parallel code execution. Consider the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中包含阻塞函数可能会带来真正的麻烦。监听传入的网络连接或数据、要求用户在控制台中输入某些内容，或者甚至加载游戏数据，如纹理、地图或声音，都可能阻塞程序执行直到完成。您是否曾想过某些游戏在加载数据时加载条会实际移动？如何用顺序执行的代码实现这一点？答案是多线程。您的应用程序从上到下按顺序在主线程中运行所有代码。它不是一个程序，因为它不能独立存在。相反，线程只在您的应用程序中运行。这种美妙的特性是，可以同时存在并运行多个线程，这实现了并行代码执行。考虑以下图示：
- en: '![Multi-threading](img/B04284_13_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![多线程](img/B04284_13_03.jpg)'
- en: 'Let''s say that the entire application space is the main thread, and all we
    do here is update and render the game. The example above is running three threads
    in addition to that. The first thread could be used to listen for incoming network
    connections. **Thread #2** is responsible for loading/unloading data when a new
    level is opened or closed. Lastly, thread three could be waiting for console input.
    Even if all three threads are blocked, the application still keeps rendering!
    Neat!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '假设整个应用程序空间是主线程，我们在这里所做的一切就是更新和渲染游戏。上面的例子中除了主线程外还运行了三个线程。第一个线程可以用来监听传入的网络连接。**线程
    #2** 负责在新关卡打开或关闭时加载数据或卸载数据。最后，第三个线程可能正在等待控制台输入。即使这三个线程都阻塞了，应用程序仍然会继续渲染！真酷！'
- en: 'SFML provides us with a few fundamental types that can be used to create and
    control threads. Let''s start by first giving a thread something to do:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 为我们提供了一些基本类型，可以用来创建和控制线程。让我们首先给线程分配一些工作：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is just a basic function that we want to be executed in parallel to the
    main thread. How can that be done? By using the `sf::Thread`!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个我们希望与主线程并行执行的基本函数。如何实现这一点？通过使用 `sf::Thread`！
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: C++ also provides its own thread class, `std::thread`, as well its own locks
    and mutexes. It also provides a `std::future` class template, which is useful
    when accessing results of asynchronous operations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 也提供了它自己的线程类 `std::thread`，以及它自己的锁和互斥量。它还提供了一个 `std::future` 类模板，这在访问异步操作的结果时非常有用。
- en: 'First, it must be set up properly by providing a function or a member function
    pointer to its constructor:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须通过向其构造函数提供函数或成员函数指针来正确设置它：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The thread constructor actually provides four overloads and even takes in the
    return value of `std::bind` and lambda expressions, which allows us to provide
    any number of arguments to these functions. Once the thread is set up, it must
    be launched in order to execute the code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 线程构造函数实际上提供了四个重载，甚至可以接受`std::bind`和lambda表达式的返回值，这使得我们可以向这些函数提供任意数量的参数。一旦线程设置好，就必须启动它才能执行代码：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once the function that is executed returns, its thread is automatically stopped.
    The `sf::Thread` class provides a terminate method, but it really shouldn't be
    used unless you know what you're doing. It can produce unwanted behavior, including
    local variables not being destroyed on some operating systems. Instead, your code
    should be designed in a way that allows a thread to stop on its own when it's
    no longer needed. Terminating it by hand is not safe! You have been warned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行函数返回，其线程将自动停止。`sf::Thread`类提供了一个终止方法，但除非您知道自己在做什么，否则不应使用它。它可能会产生不受欢迎的行为，包括在某些操作系统上局部变量不会被销毁。相反，您的代码应该设计成允许线程在不再需要时自行停止。手动终止它是不安全的！警告您了。
- en: 'One last method that threads provide is the `wait` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 线程提供的最后一个方法是`wait`方法：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The thread it is called on will halt until `thread1` is finished. This could
    be potentially dangerous. In the case of an infinite loop or a blocking function
    being called in `thread1` that never unblocks, the program will hang completely.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的线程将一直挂起，直到`thread1`完成。这可能会非常危险。如果`thread1`中存在无限循环或被调用的阻塞函数永远不会解除阻塞，程序将完全挂起。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never destroy an instance of `sf::Thread` before it's done! This will cause
    the main thread to halt, as the destructor of a thread invokes its `wait` method.
    Your application will be stuck.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sf::Thread`完成之前，永远不要销毁其实例！这将导致主线程挂起，因为线程的析构函数会调用其`wait`方法。您的应用程序将陷入停滞。
- en: Shared data protection
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享数据保护
- en: Incidentally, the reason why threads are used is also the cause for most problems
    a user could potentially experience. Having chunks of code that run in parallel
    is great, but what happens if two threads attempt to read or modify the same data?
    In a scenario like that, crashes and data corruption are a distinct possibility.
    Imagine a scenario where the main thread holds a list of entities that are to
    be updated and rendered. So far, so good! Next, let's introduce a new thread that
    is going to be running network-specific code and has access to all of our entities.
    If this thread decided to remove an entity for whatever reason, there's a very
    good chance that it might happen during either the update or render cycle of the
    main thread. At this point, we all know too well what happens when an iterator
    you're using suddenly becomes invalid. Luckily, there are ways to ensure all operations
    in your code are thread-safe, by synchronizing them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，使用线程的原因也是用户可能遇到的大多数问题的原因。并行运行代码块是很好的，但如果两个线程试图读取或修改相同的数据会发生什么呢？在这种场景下，崩溃和数据损坏是明确的可能性。想象一下这样一个场景：主线程持有要更新和渲染的实体列表。到目前为止，一切顺利！接下来，让我们引入一个新的线程，该线程将运行特定于网络的代码，并有权访问我们所有的实体。如果这个线程出于任何原因决定删除一个实体，那么它很可能发生在主线程的更新或渲染周期中。此时，我们都知道当您正在使用的迭代器突然变得无效时会发生什么。幸运的是，有方法可以确保您的代码中的所有操作都是线程安全的，通过同步它们来实现。
- en: 'SFML provides us with an interesting little class called `sf::Mutex`. It stands
    for mutual exclusion and operates on a very basic principle of allowing only a
    single thread to execute certain bits of code, while making other threads wait
    until it''s done. Let''s take a look at a basic code example to help you better
    understand this idea:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: SFML为我们提供了一个有趣的名为`sf::Mutex`的小类。它代表互斥，基于一个非常基本的原理：允许只有一个线程执行某些代码，同时使其他线程等待它完成。让我们通过一个基本的代码示例来帮助您更好地理解这个概念：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `mutex` class provides us with two methods: `lock` and `unlock`. When a
    mutex is locked for the first time, the thread that locked it is given priority
    and is allowed to continue executing the code. If another thread calls the `lock`
    method of the *same* mutex while it''s still locked, it''s not allowed to move
    any further until the mutex is unlocked. Once it is, the waiting is over and the
    second thread is allowed to continue.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex`类为我们提供了两个方法：`lock`和`unlock`。当一个互斥锁第一次被锁定时，锁定它的线程被赋予优先权，并允许继续执行代码。如果另一个线程在互斥锁仍然锁定的情况下调用`lock`方法，则不允许它进一步移动，直到互斥锁被解锁。一旦解锁，等待结束，第二个线程被允许继续。'
- en: 'Let''s analyze what happens in the code example above: `thread1` is bound to
    the `Test` function and launched immediately. The test function locks the mutex
    and because it hasn''t been locked yet, the loop for printing numbers begins iterating.
    In the meantime, our main thread reaches the `mutex.lock();` line. A few numbers
    may have been printed out already by this point. Because the mutex is already
    locked, the main thread *halts* immediately. Once the last number of the `Test`
    function is printed out, the `mutex.unlock();` line is reached. This enables the
    main thread to lock the mutex for itself and continue. If any other thread was
    to invoke the lock method of the shared mutex, it would have to wait until the
    main thread is through. Finally, the mutex is unlocked and any possible thread
    that was waiting in the background can now resume.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下上面代码示例中发生的情况：`thread1` 被绑定到 `Test` 函数并立即启动。测试函数锁定互斥锁，因为在此之前它还没有被锁定，所以打印数字的循环开始迭代。与此同时，我们的主线程到达了
    `mutex.lock();` 这一行。此时可能已经打印出了一些数字。由于互斥锁已经被锁定，主线程立即停止。一旦 `Test` 函数打印出最后一个数字，就会到达
    `mutex.unlock();` 这一行。这允许主线程为自己锁定互斥锁并继续执行。如果其他任何线程试图调用共享互斥锁的锁定方法，它必须等待主线程完成。最后，互斥锁被解锁，任何在后台等待的可能线程现在可以继续执行。
- en: 'There is a corner-case scenario where this could potentially be dangerous.
    The mutex has to be unlocked in order for the main thread to continue. What if
    the function that is bound to a thread suddenly throws an exception? What if it
    returns a value, or has a branch of if/else statements that return separate values?
    The `unlock` method could be called in each branch, but that just clutters the
    code, not to mention it doesn''t solve the exception problem. Luckily, there is
    a very elegant solution to that: the `sf::Lock` class. All it does is take in
    a reference to a mutex in its constructor, at which point it''s locked, and unlocks
    it in its destructor. Creating an object like that on the stack would solve all
    of these problems, as the mutex would just get unlocked as soon as the lock object
    is out of scope. Let''s take a look at how it can be used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个潜在的边缘情况，这可能会变得危险。互斥锁必须被解锁，主线程才能继续执行。如果绑定到线程的函数突然抛出异常怎么办？如果它返回一个值，或者有返回不同值的
    if/else 语句分支怎么办？`unlock` 方法可以在每个分支中调用，但这只会使代码变得混乱，更不用说它并没有解决异常问题。幸运的是，有一个非常优雅的解决方案：`sf::Lock`
    类。它所做的只是在其构造函数中接收一个互斥锁的引用，此时它被锁定，并在析构函数中解锁它。在栈上创建这样的对象可以解决所有这些问题，因为互斥锁会在锁对象超出作用域时自动解锁。让我们看看它是如何使用的：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a much safer piece of code. Even if there was a possibility of an exception
    being thrown, the shared mutex would be unlocked, allowing the rest of the program
    to continue.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段更安全的代码。即使有可能抛出异常，共享互斥锁也会被解锁，允许程序的其余部分继续执行。
- en: Creating a simple communication protocol
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的通信协议
- en: Having covered all of the basics, we're finally ready to get designing! The
    first choice we need to make is which protocol suits our needs better. Losing
    packets in a real-time application like this is not a tragedy. It's more important
    that data is sent and received as quickly as possible in order to update the player
    and all of the entities in the game. Since TCP is a slower protocol and we would
    not benefit from the extra measures it takes to deliver data in order, the choice
    is clear. User datagram protocol is the way to go.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了所有基础知识之后，我们终于准备好开始设计了！我们需要做的第一个选择是选择哪种协议更适合我们的需求。在像这样的实时应用程序中丢失数据包并不是悲剧。更重要的是，数据要尽可能快地发送和接收，以便更新玩家和游戏中的所有实体。由于
    TCP 是一个较慢的协议，我们不会从它采取的额外措施中受益，因此选择很明确。用户数据报协议是更好的选择。
- en: 'Let''s flesh out some details of the system we''re going to be building by
    first defining some packet types that are going to be exchanged between the server
    and client, as well as deciding on the type of the packet identifier. This information
    will be held inside the `PacketTypes.h` header:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先定义一些将在服务器和客户端之间交换的包类型，以及决定包标识符的类型，让我们详细说明一下我们将要构建的系统的一些细节。这些信息将保存在 `PacketTypes.h`
    头文件中：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note the very last element inside the `PacketType` enumeration. It isn''t an
    actual packet type that will be sent or received. Instead, it simply exists for
    convenience when checking whether a packet type is valid or not, which we''ll
    cover soon enough. In addition to the enumeration, we''re also providing a function
    for attaching a type to a packet. It''s implemented in the `PacketTypes.cpp` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`PacketType`枚举中的最后一个元素。它并不是一个实际要发送或接收的数据包类型。相反，它仅仅是为了方便检查数据包类型是否有效而存在，这一点我们很快就会讨论。除了枚举之外，我们还提供了一个将类型附加到数据包的函数。该函数在`PacketTypes.cpp`文件中实现：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function simply converts the provided type argument into a specific integer
    data type supplied by SFML prior to feeding it into the packet instance. Using
    a function to do it pays off in the long run, should we ever decide to change
    the communication protocol by adding additional data into the packet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是将提供的类型参数转换为SFML提供的特定整数数据类型，然后再将其输入到数据包实例中。使用函数来做这件事，从长远来看是有好处的，如果我们决定通过在数据包中添加额外的数据来更改通信协议。
- en: 'Next, let''s create a header file that contains the most common bits of information
    shared between both the client and server. We''ll simply call it `NetworkDefinitions.h`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个头文件，其中包含客户端和服务器之间共享的最常见信息位。我们可以简单地称它为`NetworkDefinitions.h`：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are simply all of the types and constants that both communicating sides
    are going to be using.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是通信双方将要使用到的所有类型和常量。
- en: Keeping a UDP connection alive
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持UDP连接活跃
- en: Due to UDP sockets being connectionless, we're going to need to have a way to
    check if either one of the clients on the server side, or the server on the client
    side, has stopped responding, and therefore is deemed to have timed out. A common
    term for this type of mechanism is **heartbeat**. How it's implemented may differ
    from application to application, as well as your own sensibilities. In this case,
    we're going to cover a fairly basic strategy of not only maintaining a live connection,
    but also measuring the network delay between both sides.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP套接字是无连接的，我们需要有一种方法来检查服务器端的任何一个客户端，或者客户端端的任何一个服务器，是否已经停止响应，因此被认为是超时了。这种机制的常见术语是**心跳**。它的实现可能因应用程序而异，以及你的个人感受。在这种情况下，我们将讨论一种相当基本的策略，不仅维护一个活跃的连接，而且还测量两边的网络延迟。
- en: 'For this purpose, it''s always best to have the server initiate the heartbeat.
    It has two major benefits: less data being exchanged and a reduced risk of cheating.
    Let''s take a look at the most conservative implementation of a server-client
    heartbeat:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，最好由服务器启动心跳。它有两个主要好处：交换的数据更少，作弊的风险降低。让我们看看服务器-客户端心跳的最保守实现：
- en: '![Keeping a UDP connection alive](img/B04284_13_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![保持UDP连接活跃](img/B04284_13_04.jpg)'
- en: The server is going to keep track of when the last heartbeat to a client was
    sent. That combined with a predefined heartbeat interval enables us to send them
    at a constant rate. When it is time to send one, a heartbeat packet is constructed
    and the local server time is attached to it. It is then sent out to the client.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将跟踪最后一次向客户端发送心跳的时间。结合预定义的心跳间隔，我们可以以恒定的速率发送它们。当需要发送时，构建一个心跳包并将其本地服务器时间附加到它上。然后将其发送到客户端。
- en: The client side of this operation is much simpler. It is always waiting for
    a heartbeat and when one is received, the local time of the client is updated
    and kept around for checking timeouts later. A response to the server is then
    sent back, acknowledging that a heartbeat was indeed received.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的客户端部分要简单得多。它总是等待心跳，当收到一个心跳时，更新客户端的本地时间并保留下来以供稍后检查超时。然后向服务器发送一个响应，确认确实收到了心跳。
- en: When our server receives a heartbeat response from the client, the delay between
    these two machines is measured by subtracting the time of when the last heartbeat
    packet was sent out from the current time. This delay, also known as latency,
    is the time it takes for data to make a round trip between two hosts.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的服务器从客户端收到心跳响应时，通过从当前时间减去最后一次心跳包发送的时间来测量这两台机器之间的延迟。这个延迟，也称为延迟，是数据在两个主机之间往返所需的时间。
- en: Having a heartbeat mechanism in place ensures that we are not keeping around
    any clients that could've potentially disconnected and thereby wasting bandwidth
    by sending data to unreachable hosts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上实现心跳机制确保我们不会保留任何可能已经断开连接的客户端，从而通过向不可达的主机发送数据而浪费带宽。
- en: Designing the client class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计客户端类
- en: 'With all of the things happening on the client side, be it rendering sprites
    or playing sounds or processing user input, it only makes sense to have all of
    the networking code localized inside a single class. This will allow us to communicate
    with the server quickly and easily. Let''s begin designing that class, by first
    taking a look at some necessary definitions inside the `Client.h` header:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端发生的一切，无论是渲染精灵、播放声音还是处理用户输入，都只意味着将所有网络代码本地化在单个类中。这将使我们能够快速轻松地与服务器通信。让我们首先查看`Client.h`头文件中的一些必要定义，开始设计这个类：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first definition is the amount of milliseconds that it takes for a client
    to realize that it's no longer connected to a server. This value can obviously
    be tweaked at any time. Following that is a definition of a function type that
    will be used to handle packets on the client side. We're going to be providing
    the client class with a pointer to a function that is responsible for handling
    most of the incoming information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个定义是客户端意识到它不再连接到服务器所需的时间（以毫秒为单位）。这个值显然可以在任何时候进行调整。接下来是一个函数类型的定义，它将用于处理客户端上的数据包。我们将为客户端类提供一个指向函数的指针，该函数负责处理大部分传入的信息。
- en: 'With that out of the way, we can begin shaping the client class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，我们可以开始塑造客户端类：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are a few things to note here. First, we're going to want to support both
    regular functions and member functions to serve as packet handlers, hence two
    `Setup` methods. The first one obviously has to be implemented in the header file
    due to having a template argument.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事情。首先，我们希望支持常规函数和成员函数作为数据包处理器，因此有两个`Setup`方法。显然，第一个方法由于有模板参数，必须在头文件中实现。
- en: Second, this class keeps and manages its own instances of `sf::Mutex` and `sf::Thread`.
    This way, we can provide a common interface of thread synchronization to the outside
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这个类保留并管理自己的`sf::Mutex`和`sf::Thread`实例。这样，我们可以向外部代码提供一个通用的线程同步接口。
- en: Implementing the client
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现客户端
- en: 'With the class definition covered, it''s time to actually make it do something,
    starting with the constructor and destructor:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完类定义后，现在是时候让它真正发挥作用了，从构造函数和析构函数开始：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the client constructor's initializer list, we bind the listening thread to
    the `Listen` method of this class. Threads do not have a default empty constructor,
    which is why this is necessary. The destructor is simply used to unbind the socket
    we're using.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端构造函数的初始化列表中，我们将监听线程绑定到这个类的`Listen`方法。线程没有默认的空构造函数，这就是为什么这是必要的。析构函数只是用来解绑我们使用的套接字。
- en: 'Now, let''s take a stab at implementing the connection protocol:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试实现连接协议：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first and most obvious step is checking whether we're already connected
    to the server by checking out the `m_connected` data member.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步也是最明显的一步是检查我们是否已经连接到服务器，通过检查`m_connected`数据成员。
- en: Next, the socket we're using must be bound to a port. A specific port number
    could be used here, but that would limit the number of connections a single computer
    can have at the same time. You cannot bind a socket to the same port on the same
    protocol twice. By using `sf::Socket::AnyPort`, we're letting SFML pick a random
    port that isn't being used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用的套接字必须绑定到一个端口。这里可以使用特定的端口号，但这将限制同一台计算机在同时可以拥有的连接数量。你不能在相同的协议上两次绑定同一个端口的套接字。通过使用`sf::Socket::AnyPort`，我们让SFML选择一个未被使用的随机端口。
- en: In order to establish a connection, the client must first send something to
    the server. Since SFML already provides an excellent helper class for easy data
    transfer, `sf::Packet`, we're going to be taking full advantage of it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，客户端必须首先向服务器发送一些信息。由于SFML已经提供了一个用于轻松数据传输的优秀辅助类`sf::Packet`，我们将充分利用它。
- en: After assigning the type `Connect` to our packet, we also write in the player
    name and send the packet to the server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在将类型`Connect`分配给我们的数据包后，我们也写入玩家名称并将数据包发送到服务器。
- en: The rest of the code is responsible for correctly handling timeouts. First,
    we set our socket to be in a non-blocking mode, because we're going to be handling
    this in a single thread. After clearing the packet we just sent out in order to
    use it again, a few local variables are set up in order to capture the IP address
    and port number of a response. Additionally, a clock is set up in order to help
    us determine whether we've been waiting too long for a response.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分负责正确处理超时。首先，我们将套接字设置为非阻塞模式，因为我们将在单个线程中处理它。在清除我们刚刚发送的数据包以便再次使用后，设置一些局部变量以捕获响应的IP地址和端口号。此外，设置一个时钟，以帮助我们确定我们是否等待响应时间过长。
- en: Next, the code loops as long as the timer stays underneath the predefined time-out
    value, `CONNECT_TIMEOUT`. In each iteration, we invoke the receive method of our
    socket and capture its status. If the returned status doesn't signify success
    or the IP address it was received from does not match that of our server, we simply
    skip the current iteration. Nobody wants to receive data from an unknown source!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码会在计时器保持在预定义的超时值`CONNECT_TIMEOUT`之下时循环。在每次迭代中，我们调用套接字的接收方法并捕获其状态。如果返回的状态不表示成功或接收到的IP地址不匹配我们服务器的IP地址，我们简单地跳过当前迭代。没有人想从未知来源接收数据！
- en: After verifying that the packet contains an ID and that it matches `Connect`,
    we pass the received information to the packet handler, set the `m_connected`
    flag to `true`, put the socket back into blocking mode, set the last heartbeat
    value to the current time, launch the listening thread, and return `true` to show
    success. However, if the time to successfully connect runs out, the loop is ended,
    an error message is printed, and the socket is unbound and set to blocking mode
    again.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证数据包包含ID并且它与`Connect`匹配后，我们将接收到的信息传递给数据包处理器，将`m_connected`标志设置为`true`，将套接字放回阻塞模式，将最后的心跳值设置为当前时间，启动监听线程，并返回`true`以表示成功。然而，如果成功连接的时间耗尽，循环结束，打印错误消息，并将套接字解绑并再次设置为阻塞模式。
- en: 'Once the client is connected to the server, the listening thread is launched.
    Let''s take a look at what makes it tick:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端连接到服务器，就会启动监听线程。让我们看看是什么让它运转：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After setting up some local variables to hold the packet, IP, and port information,
    the listening thread loop is entered. It runs as long as the client is connected
    to the server. Each time the loop iterates, the packet instance is cleared in
    order to receive new data. The status of the socket receive method is stored in
    a local variable, `status`, and checked for success. Because the socket is in
    blocking mode, the listening thread will halt at the `m_socket.receive(...)` line
    until some data comes in.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置一些局部变量以保存数据包、IP和端口号信息后，进入监听线程循环。只要客户端连接到服务器，它就会运行。每次循环迭代时，都会清除数据包实例以接收新数据。套接字接收方法的状态存储在局部变量`status`中，并检查是否成功。因为套接字处于阻塞模式，监听线程将在`m_socket.receive(...)`行处停止，直到有数据到来。
- en: If the returned status denotes some kind of failure, an appropriate error message
    is printed, presuming that the client is still connected to the server. If it's
    not, the socket was unbound and the loop is immediately stopped so the thread
    can safely terminate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的状态表示某种失败，打印适当的错误消息，假设客户端仍然连接到服务器。如果不是，套接字将被解绑，循环立即停止，以便线程可以安全地终止。
- en: Given that some data was properly received, the originating IP address is checked.
    If it does not match the IP of our server, the data is discarded by skipping the
    current loop iteration. Similarly enough, if we're unable to extract the packet
    ID, or if it does not fit within our predetermined boundaries, the same outcome
    takes place. We don't want any malformed or unwelcome packets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已经正确接收了一些数据，检查原始IP地址。如果它不匹配我们服务器的IP地址，数据将通过跳过当前循环迭代被丢弃。同样，如果我们无法提取数据包ID，或者它不在我们预定的边界内，结果相同。我们不希望有任何格式不正确或不欢迎的数据包。
- en: 'Next, we check the ID of the packet that was just received. In this particular
    class, we only want to worry about a single type of packets: `PACKET_HEARTBEAT`.
    These are little messages that the server sends to all clients for two reasons:
    time synchronization and maintaining a valid connection. Due to unforeseen circumstances,
    time on the server side and the client side can start going out of sync, which
    eventually can cause serious problems. Overwriting the client time with a timestamp
    coming from the server every so often eliminates this problem. In addition to
    that, this is how both the client and server keep track of whether the connection
    is still alive or not. In the case of our client, `m_lastHeartbeat` holds the
    latest timestamp received from the server, which can be checked for timeouts later.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查刚刚接收到的数据包的ID。在这个特定的类中，我们只关心一种类型的数据包：`PACKET_HEARTBEAT`。这些是小消息，服务器为了两个原因发送给所有客户端：时间同步和保持有效的连接。由于不可预见的情况，服务器端和客户端的时间可能会开始不同步，这最终可能导致严重的问题。每隔一段时间用来自服务器的时间戳覆盖客户端的时间可以消除这个问题。除此之外，这也是客户端和服务器跟踪连接是否仍然存活的方法。在我们的客户端中，`m_lastHeartbeat`保存了从服务器接收到的最新时间戳，稍后可以用来检查超时。
- en: If the packet ID is something else, it simply gets passed into the packet handler
    function to be processed by a different class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据包ID是其他东西，它就直接传递给数据包处理函数，由不同的类进行处理。
- en: 'Now that we have all these ways of opening and maintaining a connection to
    the server, let''s take a look at how it can be terminated:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些打开和维护服务器连接的方法，让我们看看它是如何被终止的：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, the state of the client is checked. We don't need to disconnect if there
    is no connection to begin with. A packet instance is then constructed with a type
    of `Disconnect` and sent to the server. After the `m_connected` flag is set to
    `false`, we unbind our socket and return `true` or `false`, based on whether sending
    the packet was successful or not.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查客户端的状态。如果没有连接，我们不需要断开连接。然后，使用类型为`Disconnect`的数据包实例发送到服务器。在将`m_connected`标志设置为`false`之后，我们解绑我们的套接字，并根据发送数据包是否成功返回`true`或`false`。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a socket is in blocking mode, its `receive` method waits until some data
    arrives before continuing. Having something like that happen in a separate thread
    would leave it running, and therefore stop our program from quitting. One way
    to prevent that is by unbinding a socket that is being used. It makes the `receive`
    method return an error, which we have handled in the `Listen` method of our client
    class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字处于阻塞模式时，其`receive`方法会在有数据到达之前等待，然后继续。如果在单独的线程中发生类似的事情，它就会继续运行，因此会阻止我们的程序退出。防止这种情况的一种方法是通过解绑正在使用的套接字。这会使`receive`方法返回一个错误，我们在客户端类的`Listen`方法中已经处理了这个错误。
- en: 'Sending data to the server is quite simple, as this next method shows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 向服务器发送数据非常简单，就像下一个方法所展示的那样：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We take in a reference to an existing packet that needs to be sent out. The
    method immediately returns `false` if we're not connected to the server or if
    the `send` method of our socket returns anything else than `sf::Socket::Done`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接收一个需要发送出去的现有数据包的引用。如果我们没有连接到服务器，或者我们的套接字的`send`方法返回的不是`sf::Socket::Done`，该方法立即返回`false`。
- en: 'We also need a way to provide a custom packet handler function that is to be
    used by this class. The member function version of this method was already implemented
    in the header file, and all that''s left is handling a function pointer version:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来提供自定义的数据包处理函数，该函数将由这个类使用。这个方法的成员函数版本已经在头文件中实现，剩下要处理的是函数指针版本：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For balance, every positive needs a negative. Let''s provide a way to remove
    any ties to functions that may no longer exist once the code starts wrapping up:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平衡，每个正面都需要一个反面。让我们提供一种方法来移除对可能不再存在的函数的任何关联，一旦代码开始封装：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Last but not least, the update method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，更新方法：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The main purpose of this method is keeping track of passing time by adding the
    time between updates to the server time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的主要目的是通过将更新之间的时间添加到服务器时间来跟踪流逝的时间。
- en: Now, you might notice something strange in the next few lines. Why are we checking
    for the server time being below zero? Well, the amount of milliseconds that have
    passed since the beginning is represented by a signed 32-bit integer. Its maximum
    positive value is 2,147,483,647, after which it goes right to the negatives, -2,147,483,648
    to be precise. Granted, this doesn't happen very often. In fact, the server would
    have to be running continuously for almost 25 whole days for the timestamp to
    reach the values we're talking about. Still, a corner-case scenario is not worthy
    of ignoring simply because it's unlikely to happen. Subtracting the highest possible
    value of a 32-bit integer from the server timestamp "wraps" the time around back
    into the positive realm and allows it to continue like nothing happened.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会在接下来的几行中注意到一些奇怪的地方。为什么我们要检查服务器时间是否低于零？嗯，自开始以来经过的毫秒数由一个有符号的32位整数表示。它的最大正值是2,147,483,647，之后它直接进入负数，确切地说是-2,147,483,648。诚然，这种情况并不常见。事实上，服务器需要连续运行近25天才能使时间戳达到我们讨论的值。尽管如此，一个边缘情况场景不应该因为不太可能发生而被忽视。从32位整数的最大可能值中减去服务器时间戳“将时间绕回”到正数领域，并允许它继续像什么都没发生一样。
- en: The update method is also where we check for our connection timing out. If the
    difference between current time and the last heartbeat received from the server
    is greater or equal to the timeout value in milliseconds, the `Disconnect` method
    is invoked.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 更新方法也是我们检查连接是否超时的地方。如果当前时间和从服务器接收到的最后心跳之间的差异大于或等于超时值（以毫秒为单位），则调用`Disconnect`方法。
- en: The server class
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器类
- en: 'Now, it''s time to take a look at the way things are handled on the other side
    of the wire. Let''s begin by defining some constants:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看另一端是如何处理这些事情的了。让我们先定义一些常量：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our server application is going to send out heartbeats every second and retry
    five times before it times out a client. Speaking of clients, there''s additional
    information that we need to keep track of, which calls for a good data structure
    that holds it all:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器应用程序将每秒发送一次心跳，并在超时前重试五次，然后才会将客户端标记为超时。说到客户端，我们还需要跟踪一些额外的信息，这需要一个好的数据结构来存储所有这些信息：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Besides simply keeping track of the IP and port of a client, we also need to
    know when the last heartbeat was sent to them, whether the server is waiting for
    a heartbeat response, the number of heartbeat retries made, and the current latency
    the client has.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地跟踪客户端的IP和端口号外，我们还需要知道上次向他们发送心跳的时间，服务器是否正在等待心跳响应，已进行的心跳重试次数，以及客户端当前的延迟。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keeping track of latency provides tons of potential benefits, ranging from assessing
    quality of service and accurate matchmaking to maximizing the accuracy of a network
    simulation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪延迟提供了大量的潜在好处，从评估服务质量、精确匹配到最大化网络模拟的准确性。
- en: 'Next, the data types we''re going to be using throughout the `Server` class
    deserve a look:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要使用的数据类型在整个`Server`类中值得一看：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, this class also uses a custom function that is going to be handling
    incoming packets. In addition to that, we're going to need to be able to process
    client timeouts outside of this class as well, which can also be done through
    means of using a function pointer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类还使用了一个自定义函数，该函数将处理传入的数据包。除此之外，我们还需要能够在类外处理客户端超时，这也可以通过使用函数指针来完成。
- en: 'We have everything we need, so let''s write the `Server` class header:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有需要的东西，所以让我们编写`Server`类的头文件：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Just like the `Client` class, we want to support both member functions and
    regular functions being bound as packet and timeout handlers. Additionally, we
    also need an instance of a mutex and two sockets: one for listening and one for
    sending data. Having two sockets on the server side provides separation between
    different operations, which sometimes may result in runtime errors and data corruption.
    For an added bonus, we''re also keeping track of all data sent and received.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Client`类一样，我们希望支持将成员函数和常规函数绑定作为数据包和超时处理程序。此外，我们还需要一个互斥锁的实例和两个套接字：一个用于监听，一个用于发送数据。在服务器端有两个套接字提供了不同操作之间的分离，这有时可能会导致运行时错误和数据损坏。作为额外的奖励，我们还在跟踪所有发送和接收的数据。
- en: Implementing server
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务器
- en: 'Let''s start by taking a look at the second constructor and the destructor
    of this class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个类的第二个构造函数和析构函数：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Nothing too interesting is happening here. The constructor simply binds the
    provided packet handler function, while the destructor just invokes the `Stop`
    method, which we are going to cover shortly. Speaking of binding, we also need
    a function to handle client timeouts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生什么有趣的事情。构造函数只是绑定提供的包处理函数，而析构函数只是调用我们即将介绍的`Stop`方法。说到绑定，我们还需要一个处理客户端超时的函数：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Simply having the client get disconnected is not always enough, depending on
    your application. One of the main ways we're going to be taking advantage of this
    feature is de-spawning entities in the game world.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 仅让客户端断开连接并不总是足够的，这取决于你的应用程序。我们将利用这个功能的主要方式之一是在游戏世界中销毁实体。
- en: 'Now, let''s take a peek at how we start our server:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们是如何启动服务器的：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the server is already running, or if we failed to bind the incoming socket
    to the predesignated port number, `false` is returned. Otherwise, the outgoing
    socket is bound to a random port, a `Setup` method is invoked to set up some data
    members, the listening thread is launched, and the `m_running` flag is set to
    true. You can stop the server like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器已经运行，或者如果我们未能将传入的套接字绑定到预指定的端口号，则返回`false`。否则，传出套接字绑定到一个随机端口，调用`Setup`方法来设置一些数据成员，启动监听线程，并将`m_running`标志设置为`true`。你可以这样停止服务器：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the server is actually running, a `DisconnectAll` method is invoked to drop
    all the clients. The running flag is then set to `false` and the incoming socket
    is unbound, which in turn stops the listening thread from running, as the socket
    is in blocking mode.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器实际上正在运行，则会调用`DisconnectAll`方法来断开所有客户端。然后运行标志设置为`false`，并将传入的套接字解绑，这反过来又停止了监听线程的运行，因为套接字处于阻塞模式。
- en: 'Here''s a little helper method that initializes some data members to their
    default states:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小助手方法，它将一些数据成员初始化为它们的默认状态：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is invoked every time a server is started, as demonstrated previously.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这在之前演示的每次启动服务器时都会被调用。
- en: 'Sending data to clients is fairly straightforward, as you can see here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 向客户端发送数据相当直接，正如你所看到的：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With a little bit of STL find magic, we retrieve the client's information from
    the container it's stored in and send the packet out.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点STL查找魔法，我们从存储它的容器中检索客户端信息，并发送数据包。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the mutex lock in the very first line. This is done to ensure that the
    client isn't removed from the container right in the middle of a send operation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一行中的互斥锁。这样做是为了确保在发送操作过程中不会从容器中移除客户端。
- en: As a side bonus, it's also nice to keep track of how much data was sent and
    received. Here, we make use of the `getDataSize` method that `sf::Packet` provides
    to do just that.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项额外的好处，跟踪发送和接收的数据量也是一件好事。在这里，我们利用`sf::Packet`提供的`getDataSize`方法来完成这项工作。
- en: 'For convenience, we could also write an overloaded version of the `Send` method
    that doesn''t require a client:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们还可以编写一个重载的`Send`方法，它不需要客户端：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In plenty of occasions, sending data out to only one client isn''t enough.
    Broadcasting it to all of the clients currently connected can be useful for sending
    out anything from chat messages to entity states. Let''s write it:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，仅向单个客户端发送数据是不够的。将数据广播给所有当前连接的客户端可以用于发送从聊天消息到实体状态的各种内容。让我们来写一下：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once again, it's quite basic. The client container is iterated over and each
    client's ID is checked for matching the `l_ignore` argument, which can be used
    to specify a client ID that shouldn't receive the packet being broadcasted. If
    data is successfully sent out, its size is added to the sent data counter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这相当基础。遍历客户端容器，并检查每个客户端的ID是否与`l_ignore`参数匹配，该参数可以用来指定不应接收广播数据包的客户端ID。如果数据成功发送出去，其大小会被添加到已发送数据计数器中。
- en: 'Much like the client, our server is going to need a separate thread for processing
    incoming data. Let''s take a look at the `Listen` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就像客户端一样，我们的服务器也需要一个单独的线程来处理传入的数据。让我们看看`Listen`方法：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, it's quite similar to the way a client listener is implemented.
    After some local variables are set up for capturing incoming data, we enter a
    `while` loop, during which the packet is cleared and the blocking receive method
    of our incoming socket is invoked, capturing the status as well. Just as before,
    we break from the loop if the server is no longer running and the return status
    from the `receive` method was anything but `sf::Socket::Done`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与客户端监听器实现的方式非常相似。在设置了一些用于捕获传入数据的局部变量之后，我们进入一个`while`循环，在这个循环中，数据包被清除，并调用我们传入套接字的阻塞接收方法，同时捕获状态。就像之前一样，如果服务器不再运行，并且`receive`方法的返回状态不是`sf::Socket::Done`，我们就从循环中跳出。
- en: After all of the packet ID checks, we get to the heartbeat part of the code.
    A flag is set up to indicate whether a client that sent the heartbeat was located
    or not.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有数据包ID检查之后，我们到达代码的心跳部分。设置了一个标志来指示是否找到了发送心跳的客户端。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we lock our mutex here, because we're about to start iterating over
    the list of clients in order to find the one that sent in the heartbeat response.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里锁定互斥锁，因为我们即将开始遍历客户端列表以找到发送心跳响应的那个客户端。
- en: If the client with matching information has been found, we also check if the
    server is currently waiting for a heartbeat response from them. We only want clients
    to be able to send in heartbeat responses in order to both accurately measure
    latency and prevent potential cheating attempts.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了匹配信息的客户端，我们还会检查服务器是否正在等待从他们那里收到心跳响应。我们只希望客户端能够发送心跳响应，以便准确测量延迟并防止潜在的作弊尝试。
- en: Given that this is a valid heartbeat response, latency is calculated by subtracting
    the time a heartbeat was sent to this particular client from the current server
    time. The current timestamp is also stored in `m_lastHeartbeat`, which we'll be
    using to determine when to dispatch the next one. Afterwards, the heartbeat waiting
    flag is set to `false` and the retry counter is set back to 0.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个有效的心跳响应，通过从当前服务器时间减去发送到特定客户端的心跳时间来计算延迟。当前的时间戳也存储在`m_lastHeartbeat`中，我们将使用它来确定何时发送下一个心跳。之后，将心跳等待标志设置为`false`，并将重试计数器重置为0。
- en: 'Next, let''s implement adding clients:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现添加客户端：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once again, since we're modifying client data, we want to lock our mutex to
    ensure no other piece of code running in another thread will attempt to read or
    modify the data as well. Following that, we do a quick search through the client
    container and return -1 if a specified IP and port combination already exists.
    Otherwise, a new client ID is assigned and the client information is inserted
    into the container, followed by an increment operation of `m_lastID`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于我们正在修改客户端数据，我们想要锁定互斥锁以确保没有其他在另一个线程中运行的代码尝试读取或修改数据。随后，我们在客户端容器中进行快速搜索，如果指定的IP和端口号组合已经存在，则返回-1。否则，分配一个新的客户端ID，并将客户端信息插入到容器中，然后对`m_lastID`进行增量操作。
- en: 'Sometimes, we may need to obtain the client ID of a client by providing their
    IP address and port number. Let''s write a way to do just that:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要通过提供IP地址和端口号来获取客户端的ID。让我们编写一种方法来实现这一点：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As always, it simply iterates over each client and checks if their information
    matches the provided arguments. This is another instance where we need to lock
    the mutex in order to safely access this data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，它只是遍历每个客户端并检查它们的信息是否与提供的参数匹配。这又是一个需要锁定互斥锁以安全访问这些数据的例子。
- en: 'Next up, we need some setters and getters:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些设置器和获取器：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A way of obtaining client information from a client ID is also necessary:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端ID获取客户信息的方法也是必要的：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this case, the provided reference to a `ClientInfo` structure is simply overwritten
    with the located information. It can be done in a single line of code, thanks
    to the overloaded assignment operator that `ClientInfo` provides. Once again,
    the mutex is locked because we're accessing data that can be removed or overwritten
    in the middle of the search otherwise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，提供的`ClientInfo`结构引用被简单地覆盖为找到的信息。这可以通过`ClientInfo`提供的重载赋值运算符在单行代码中完成。再次强调，我们锁定互斥锁，因为我们正在访问可能在搜索过程中被删除或覆盖的数据。
- en: 'When a client is no longer needed, it must be removed. For convenience, we
    provide two variations of the same method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要客户端时，它必须被移除。为了方便，我们提供了两种相同方法的变体：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first one simply locates client information by using the `find` method
    of a container it''s stored in. If one was found, a disconnect packet is created
    and sent to the client before it gets erased. The second variation varies in its
    search method, but carries out the same basic idea:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法简单地通过使用存储它的容器中的`find`方法来定位客户端信息。如果找到了一个，则在它被删除之前，会创建一个断开连接的数据包并发送给客户端。第二种变化在于其搜索方法，但执行的是相同的基本想法：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once again, the mutex is locked in both of them as data is being read and modified.
    Speaking of removing clients, how about having a method that kicks all of them
    out at the same time?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于数据正在读取和修改，所以在这两个地方都锁定了互斥锁。说到移除客户端，我们是否可以有一个一次性将所有客户端踢出的方法？
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It's quite a simple little bit of code. If the server is running, a disconnect
    packet is created, just like before, except it's broadcasted to all clients instead
    of just one. The mutex is then locked, right before the client container is cleared
    completely.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单。如果服务器正在运行，就会创建一个断开连接的数据包，就像之前一样，只不过它是广播给所有客户端而不是一个。然后锁定互斥锁，在客户端容器被完全清除之前。
- en: 'Last but definitely not least, here''s the update method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但绝对不是最不重要的，这里是有更新方法：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Similar to the client, the server also has to worry about the timestamp running
    out of bounds. Unlike the client, however, we need to reset the heartbeats of
    every client the server has, hence the mutex lock. Speaking of which, we also
    need to lock the mutex right before all of the update code, as it can potentially
    modify any of the clients, just like any other piece of code that runs in a different
    thread.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端类似，服务器也必须担心时间戳超出范围的问题。然而，与客户端不同的是，我们需要重置服务器拥有的每个客户端的心跳，因此需要互斥锁。说到这里，我们还需要在所有更新代码之前锁定互斥锁，因为它可以像任何其他在不同线程中运行的代码片段一样修改任何客户端。
- en: After the mutex lock, we begin iterating over clients and measuring the time
    elapsed between now and the last heartbeat. If this time exceeds or is equal to
    the interval we want heartbeats to be sent out at, we first check if it either
    also exceeds the timeout interval or if the number of heartbeat retries has exceeded
    the designated value. If so, the timeout handler is invoked and the client is
    erased from the container.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在互斥锁之后，我们开始遍历客户端并测量现在和上次心跳之间经过的时间。如果这个时间超过了我们想要发送心跳的间隔，我们首先检查它是否也超过了超时间隔，或者心跳重试次数是否超过了指定的值。如果是这样，就会调用超时处理程序，并将客户端从容器中删除。
- en: The heartbeat code itself is quite simple. If the server isn't waiting for a
    reply from the client, or if it's time to retry sending another heartbeat, a packet
    is constructed, the server time is attached to it, and it is sent out. If this
    is a first try sending it, the server time also gets stored inside the `m_heartbeatSent`
    data member of a client entry.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 心跳代码本身相当简单。如果服务器没有等待来自客户端的回复，或者如果到了重试发送另一个心跳的时间，就会构建一个数据包，将服务器时间附加到它上面，然后发送出去。如果是第一次尝试发送它，服务器时间也会存储在客户端条目的`m_heartbeatSent`数据成员中。
- en: A simple chat application
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的聊天应用程序
- en: 'We have the basic framework in place to handle connections, so let''s build
    something with it! How about a neat little console-based chat program? Let''s
    start with the server by creating a separate project and a new file called `Server_Main.cpp`.
    The first thing we''re going to need is a packet handler:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了处理连接的基本框架，所以让我们用它来构建一些东西！比如一个整洁的基于控制台的聊天程序？让我们从创建一个名为`Server_Main.cpp`的新文件开始，并创建一个单独的项目。我们首先需要的是一个数据包处理器：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As we''re going to be providing a pointer to this function to our `Server`
    class, the fingerprint has to match exactly. The function itself starts by first
    establishing whether the client ID for the provided IP address and port number
    exists. If it is indeed above or equal to zero, we''re only interested in two
    types of packets: `Disconnect` and `Message`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算向`Server`类提供这个函数的指针，因此指纹必须完全匹配。函数本身首先确定提供的IP地址和端口号的客户端ID是否存在。如果它确实大于或等于零，我们只对两种类型的数据包感兴趣：`Disconnect`和`Message`。
- en: In a case of client disconnect, we create a message packet that is broadcasted
    to all clients except the one disconnecting. On the other hand, if there is an
    incoming message from one of the clients, it is first extracted and attached to
    a string that contains the client's IP address and port. We're not going to be
    using nicknames this time. The full message string is then attached to a message
    packet and broadcasted to every client, except the one that sent the message to
    begin with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端断开连接的情况下，我们创建一个广播给所有客户端（不包括断开连接的那个）的消息数据包。另一方面，如果收到来自某个客户端的消息，它首先被提取并附加到一个包含客户端IP地址和端口号的字符串上。这次我们不会使用昵称。然后将完整的消息字符串附加到消息数据包上，并广播给每个客户端，除了最初发送消息的那个客户端。
- en: If a client wasn't found, however, all we care about is receiving connect packets.
    When one is received, the IP address and port are added and a connect packet is
    sent back to the client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果找不到客户端，我们唯一关心的是接收连接数据包。当收到一个时，IP地址和端口号被添加，并发送一个连接数据包回客户端。
- en: 'What kind of a server would it be if it didn''t have the ability to process
    commands? Let''s write a function that will be running in a separate thread and
    process user input:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器没有处理命令的能力，那会是什么样的服务器？让我们编写一个将在单独的线程中运行的函数，用于处理用户输入：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that `std::getline` is a blocking function. If the program stops running,
    the thread that this function is running on will still be blocking until some
    user input comes through. One way to get it to terminate is to implement a command
    that stops the server, which is what `"!quit"` does. Once the server `Stop` method
    is invoked, it also breaks the loop just to be safe.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::getline` 是一个阻塞函数。如果程序停止运行，运行此函数的线程将仍然阻塞，直到有用户输入。让它终止的一种方法是实现一个停止服务器的命令，这就是
    `"!quit"` 所做的。一旦调用服务器的 `Stop` 方法，它也会打破循环以确保安全。
- en: The other two commands are pretty standard. One simply disconnects all users,
    while the other prints out a list of all connected clients. We haven't covered
    `GetClientCount` or `GetClientList`, since they're fairly basic and are not required
    for the server to run. You can find the implementation of these two methods in
    the source code of this book.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个命令相当标准。一个简单地断开所有用户，而另一个打印出所有已连接客户端的列表。我们没有涵盖 `GetClientCount` 或 `GetClientList`，因为它们相当基础，并且对于服务器运行不是必需的。您可以在本书的源代码中找到这两个方法的实现。
- en: 'Now it''s time to assemble and run our code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是组装和运行我们代码的时候了：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is quite a basic setup for the entry point of an application like this.
    First, we create an instance of the `Server` class and provide a function pointer
    that is going to be handling packets in its constructor. We then attempt to start
    the server and catch the return value of that in an `if` statement. If a successful
    start took place, a command thread is set up and launched. An instance of `sf::Clock`
    is created and restarted before entering our main loop, which simply executes
    as long as the server is running and updates it with the elapsed time value between
    iterations. That's all we need to have in a chat server!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对此类应用程序的入口点的相当基本的设置。首先，我们创建 `Server` 类的一个实例，并在其构造函数中提供一个将处理数据包的函数指针。然后我们尝试启动服务器，并在
    `if` 语句中捕获其返回值。如果成功启动，就设置并启动一个命令线程。在进入主循环之前，创建并重新启动 `sf::Clock` 实例，主循环简单地执行，只要服务器在运行，就更新它之间的迭代时间值。这就是我们需要的所有内容，一个聊天服务器！
- en: The chat client
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天客户端
- en: 'Our server is quite useless if we don''t have the means of connecting to it
    and sending messages back and forth. In a separate project, let''s create a file
    named `Client_Main.cpp` and begin writing the client portion of the code, starting
    with a packet handler:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有连接到服务器并来回发送消息的手段，我们的服务器就毫无用处。在另一个项目中，让我们创建一个名为 `Client_Main.cpp` 的文件，并开始编写客户端部分的代码，从数据包处理器开始：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see, it''s really quite a simple design when we have a proper support
    class to fall back on. The client responds to two types of packets: messages and
    disconnects. In case a message pops in, it''s extracted and simply printed in
    the console window. If a disconnect packet arrives from the server, the client''s
    `Disconnect` method is invoked.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们有一个合适的支持类可以依赖时，这实际上是一个非常简单的设计。客户端响应两种类型的数据包：消息和断开连接。如果消息突然出现，它会被提取并在控制台窗口中简单地打印出来。如果从服务器收到断开连接的数据包，客户端的
    `Disconnect` 方法将被调用。
- en: 'Next, the function that will be running in a command thread:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将在命令线程中运行的函数：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We're using the same basic principle of capturing console input with the `std::getline`
    function, except we're only going to be processing the quit command in this case.
    Anything else that gets entered is treated as a message and sent out to the server.
    Keep in mind that because the `std::getline` function is a blocking one, a user
    will have to press enter once if the client gets disconnected by the server, just
    to provide some input and get things moving again in order for the thread to be
    closed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用与`std::getline`函数捕获控制台输入相同的基本原理，但在这个案例中，我们只处理退出命令。输入的其他任何内容都被视为消息并发送到服务器。请注意，由于`std::getline`函数是一个阻塞函数，如果客户端被服务器断开连接，用户将需要按一次回车键，以便提供一些输入并使线程关闭，从而使事情再次运转起来。 '
- en: 'Lastly, let''s put all of this code to work and implement the main loop of
    our chat client:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将所有这些代码付诸实践，并实现聊天客户端的主循环：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We begin by setting up a few variables to hold the IP address and port of the
    server. For extra credit, let's add support for command line arguments. If none
    are provided, the user is simply prompted to enter the server information inside
    the console window. Otherwise, the command-line arguments are read in and used
    for the same purpose.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置几个变量来保存服务器的IP地址和端口号。作为额外加分项，让我们添加对命令行参数的支持。如果没有提供任何参数，用户将被提示在控制台窗口中输入服务器信息。否则，将读取命令行参数并用于相同的目的。
- en: Moving further, we see that an instance of `Client` is created and set up with
    the server information that was provided, in addition to the packet handler function
    getting registered and a command thread being prepared. The client then attempts
    to connect to the server, and if the connection is successful, the command thread
    is launched, an instance of `sf::Clock` is created, and the main loop of the program
    is entered, where the client gets updated.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们看到创建了一个`Client`实例，并使用提供的服务器信息进行了设置，同时注册了数据包处理函数，并准备了一个命令线程。然后客户端尝试连接到服务器，如果连接成功，将启动命令线程，创建一个`sf::Clock`实例，并进入程序的主循环，其中客户端会得到更新。
- en: 'With this, we have a fairly simple yet functional chat application:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就拥有了一个相当简单但功能齐全的聊天应用程序：
- en: '![The chat client](img/B04284_13_05.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![聊天客户端](img/B04284_13_05.jpg)'
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on making it this far! Having covered the most important fundamentals,
    which includes the basics of socket programming, utilization of threads, and building
    the underlying layer of client-server communications, we're finally ready to tackle
    actual game networking! In the final chapter of this book, we're going to integrate
    this network code into our existing code base, turning a lonely single player
    RPG into an exciting arena of player versus player combat! See you there!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到了这一步！在涵盖了最重要的基础知识之后，包括套接字编程的基础、线程的使用以及构建客户端-服务器通信的底层层，我们终于准备好处理实际的网络游戏了！在本书的最后一章中，我们将把这段网络代码集成到现有的代码库中，将孤独的单人RPG游戏转变为激动人心的玩家对战竞技场！那里见！
