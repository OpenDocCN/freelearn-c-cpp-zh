- en: Chapter 3. Collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze collision in Unreal Engine 4, what it is,
    the different types of collision that exist in the engine, how to use it, and
    how to apply it to both static meshes and blueprints. To start with, we will first
    take an overview look of the different collisions that exist in Unreal Engine
    4, but we will also cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple versus complex collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating simple collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating complex and custom collision hulls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom object and trace channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-depth collision presets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will continue to work with Unreal Engine
    4 using the **Unreal_PhyProject** that we created in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Collision and Trace Responses – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world and in Unreal Engine 4, we define collision as an overlap
    of two or more objects. In the context of Unreal Engine 4, **Collision** and **Trace
    Responses** lay the groundwork for how Unreal Engine 4 handles collision and ray
    casting during the game. Every object that is given collision gets an **Object
    Type** and a series of responses that describe how it interacts with the other
    object types. In the event of either a collision or an overlap of two or more
    objects, all objects involved can be set to affect or to be affected by blocking,
    overlapping, or ignoring one another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace Responses** describe how an object should react when you interact with
    a trace, which is done with a ray cast. An object can choose to block, overlap,
    or even ignore a trace from a particular source. By default, there are two different
    **Trace Responses**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visibility**: This specifies a trace from one position to another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera**: This is exactly similar to the **Visibility** trace response, but
    it should be used when you use a ray cast from the camera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Responses** describe how an object should respond when you interact
    with other objects in our game world. Similar to **Trace Responses**, **Object
    Responses** offer the ability to choose whether or not an object will block, overlap,
    or ignore other objects when a collision occurs. By default, there are six different
    types of **Object Responses**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WorldStatic**: This object response is for objects in our game world that
    are static, meaning that they do not and cannot be moved by any means. Objects
    such as volumes, world geometry, or any other meshes in the game world are associated
    to this object response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WorldDynamic**: This object response is for objects in our game world that
    are moving actors, outside of player pawns, physics bodies, vehicles, and destructible
    actors. Examples of **WorldDynamic** objects would be an elevator, a door that
    can open and close, or a wheel that a player can turn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn**: This object response is for player characters in our game or any
    other character that can be possessed by the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PhysicsBody**: This object response is for any physics body or object that
    can be simulated with physics in our game world. An example of a **PhysicsBody**
    object would be a basketball that the player can pick up and throw; *Half-Life
    2* is a great example of how physics body object collisions are used in games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vehicle**: Although this object response is labeled as **Vehicle**, what
    this response is useful for is to have player pawns jump into them, such as a
    vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destructible**: This object response is for any actors that are destructible,
    meaning that they can break apart using the destructible mesh editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you work on setting up collisions on an object or a component in Unreal
    Engine 4 blueprints, you will see the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision and Trace Responses – an overview](img/image00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to note that we want to make sure that our static mesh or blueprint
    component has collision generated before setting any collision presets to that
    object; otherwise, we will not receive any responses once a collision occurs.
    Later in this chapter, we will go into more detail on how to generate simple and
    complex collisions for our objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to setting up **Collisions** to an object, there are numerous
    collision presets that default to Unreal Engine 4 that either ignores, overlaps,
    or blocks a combination of trace and object responses. In addition to these presets,
    we do have the option to create a custom collision preset for certain circumstances
    in our blueprint. Feel free to explore some of the collision presets and how they
    differentiate from one another, but for the sake of this text, let''s take a look
    at some of the more common presets. We will take an in-depth look at the following
    presets later on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Collision**: As the name suggests, this collision preset eliminates any
    collision responses by setting the **Visibility** trace response and the **Camera**
    trace response to ignore and sets **Collision Enabled** to **No Collision**. Typically,
    we would use this for blueprint components that we don''t want to react to any
    collisions that may occur.![Collision and Trace Responses – an overview](img/image00236.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block All**: This collision preset causes all the collisions with the associated
    component to result in a block. Alternatively, it causes all the objects involved
    in this collision to hit and bounce off one another if physics are applied. This
    is done by setting all the responses, including the trace and object responses,
    to **Block** under their **Collision Responses**, as shown in the following screenshot:![Collision
    and Trace Responses – an overview](img/image00237.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overlap All**: This collision preset results in all the collisions to generate
    an overlap between all the objects involved in the collision. As long as the **Generate
    Overlap Events** property is checked, we can use the blueprint collision events
    to enable behaviors or events to occur once this type is involved in a collision.![Collision
    and Trace Responses – an overview](img/image00238.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn**: This collision preset is useful if it is used for a player pawn or
    character in our game. By default, it is set to block **Object Responses**, block
    the **Camera** trace response, and ignore the **Visibility** trace response:![Collision
    and Trace Responses – an overview](img/image00239.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Actor**: This collision preset is used for any actor or component
    that is a physics-based actor, meaning that the object has in-game physics (such
    as gravity) applied to it. In order for this preset to work properly, we want
    to make sure that the **Simulate Physics** property in the **Physics Tab** is
    checked. By default, all the **Trace Responses** and **Object Responses** are
    set to **Block**:![Collision and Trace Responses – an overview](img/image00240.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are just a few of the different options that Unreal Engine 4 offers by
    default for collision, and we will cover the other options in more detail later
    on in this chapter. Although there are a handful of options when it comes to collision
    presets offered in Unreal Engine 4 by default, a really nice feature that is in
    place is the ability to create your own trace, object channels, and collision
    presets. To do this, we need to navigate to the **Edit** window and select **Project
    Settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision and Trace Responses – an overview](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, we need to navigate to the **Collision** option in the **Engine**
    category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision and Trace Responses – an overview](img/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this menu, we can create custom collision presets, specify which object and
    trace channels to either ignore, overlap, or block, give it a specific name, and
    save it to the project file. For advanced needs, we can also create custom object
    and trace channels in this window. Later in this chapter, we will create our own
    custom collision preset and apply it to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Collision and Trace Responses – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we briefly looked at the different **Collision** and **Trace
    Responses** that exist in Unreal Engine 4 and defined a handful of these responses.
    We analyzed the different **Trace Responses** and **Object Responses** that default
    to Unreal Engine 4, and we also defined a limited number of collision presets
    that are provided. Now that we have a basic understanding of **Collision** and
    **Trace Responses**, we can move forward and learn more about simple and complex
    collision in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Simple versus complex collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Unreal Engine 4, we will be able to autogenerate collisions for our meshes
    that can be used in our game. There are two different types of collision that
    exist in Unreal Engine 4: simple and complex collision. Each type of collision
    serves its own unique purpose, and in this section, we will simply define each
    collision type and provide examples of each. Later on in this chapter, we will
    work on how to apply these collisions to our objects. We will also test these
    collisions in our game. Let''s begin with simple collision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple collision is a collision mesh that uses basic shapes, such as boxes,
    spheres, capsules, and convex shapes, to define the bounds of our object. Convex
    shapes are ones that have one or more interior angles that are less than 180 degrees,
    whereas concave shapes are ones that possess one or more interior angles that
    are more than 180 degrees, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple versus complex collision](img/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to these basic shapes, we can generate a form of simple collision
    called **KDOP** or **K Discrete Oriented Polytope** (where K is the number of
    axis-aligned planes). What this option essentially does is that it takes the *K*
    axis-aligned planes and moves them as close as possible to the selected mesh.
    We will go into more detail on how to generate these different types of simple
    collision later on. Now, let''s define the different types of simple collision
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sphere**: This creates a spherical bound mesh around the selected object.
    It can be used in physics objects and to apply collision to objects that are round.![Simple
    versus complex collision](img/image00244.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capsule**: This creates a capsule bound mesh around the selected object and
    is typically used for character or pawn meshes:![Simple versus complex collision](img/image00245.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Box**: This creates a box bound mesh around the selected object. This type
    of simple collision is most commonly used for environment meshes:![Simple versus
    complex collision](img/image00246.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10DOP X**: This creates a box with four edges beveled in the *X*-aligned
    edges:![Simple versus complex collision](img/image00247.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10DOP Y**: This creates a box with four edges beveled in the *Y*-aligned
    edges:![Simple versus complex collision](img/image00248.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10DOP Z**: This creates a box with four edges beveled in the *Z*-aligned
    edges:![Simple versus complex collision](img/image00249.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**18DOP**: This creates a box with all of its edges beveled:![Simple versus
    complex collision](img/image00250.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**26DOP**: This creates a box with all of its edges and corners beveled:![Simple
    versus complex collision](img/image00251.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main advantage of simple collision is that it almost eliminates the possibility
    of an object getting stuck to a player or vice versa. An additional advantage
    is that the collision mesh is of a basic shape, which is less expensive to use
    in the game at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex collision is done for each polygon and is very expensive in Unreal
    Engine 4 as compared to simple collision. Moreover, complex collision is never
    used for an actor that is simulating physics, and it will just fall through the
    game world. In order to enable complex collision in the **Static Mesh** editor,
    we need to navigate to **Details Panel** and then to the **Static Mesh Settings**
    section. It is here that we can change the **Collision Complexity** parameter
    to **Use Simple Collision As Complex** or **Use Complex Collision As Simple**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple versus complex collision](img/image00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Simple versus complex collision – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we looked at the different simple collisions offered by default
    in the **Static Mesh** editor in Unreal Engine 4\. We also discussed the advantages
    and disadvantages of the simple and complex collision when it comes to game development
    and engine performance. Lastly, we briefly looked at how to create both these
    types of collision. With a basic understanding of simple and complex collision
    under our belts, we can now discuss how to create simple collision, and how to
    create collision hulls in Unreal Engine 4 later on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to creating collisions, there are many options that we can take
    advantage of to properly utilize collision and optimize game performance. As we
    discussed in the previous section, we have the option to create simple and complex
    collisions in the **Static Mesh** editor in Unreal Engine 4, but we can also use
    third-party art programs to create custom collision hulls. Let's first discuss
    how to create simple collisions in Unreal Engine 4, and in the next section, we
    will discuss how to create complex and custom collisions for our assets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by opening `StarterContent` and navigating to **Content Browser**.
    From here, let's go to the `StarterContent` folder and select the `Shapes` folder
    that contains multiple simple-shaped static meshes to select from. For this set
    of examples, we will choose the `Shape_Trim` mesh because it is a more complicated
    shape as compared to a sphere or box; this way, we can see the effects of different
    collision options. Double-click on the `Shape_Trim` asset to open the **Static
    Mesh** editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navigating to the **Static Mesh** editor is very similar to moving around in
    the **Perspective** view mode in the main game editor of Unreal Engine 4\. At
    the top of the **Static Mesh** editor is the main toolbar that provides a handful
    of useful options when you view your mesh and its collision.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The toolbar provides us the options to save our mesh and its properties, to
    view the mesh in real time, which is useful if the mesh has an animated material
    applied to it, to view any applied **Sockets**, to toggle the **Wireframe** of
    the mesh, to view any **Vertex Colors** applied to the mesh, to toggle a background
    **Grid**, to toggle the **Bounds** of the mesh, and (most importantly) to toggle
    the **Collision** applied to the mesh. Additionally, we can view the mesh's **Pivot
    Point**, its **Normals**, **Tangents**, **Bi-Normals**, and **UV** sheet.
  prefs: []
  type: TYPE_NORMAL
- en: As we will work primarily with collisions, we will want to make sure that the
    **Collision** option is toggled on so that we can see the bounds of the bounding
    collision mesh. To do this, we can left-click on the **Collision** button to make
    sure that it's highlighted in orange, and if the mesh has any collision applied
    to it, we will see it in a light blue-colored wireframe around our object. By
    default, `Shape_Trim` does have a collision applied to it, so we first want to
    remove this collision so that we are able to apply only one collision mesh to
    the object at once for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to the **Collision** drop-down window at the very top of the
    **Static Mesh** editor located alongside the **File**, **Edit**, **Asset** window
    options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select **Remove Collision**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the light blue-colored wireframe outline mesh will disappear from our mesh,
    meaning that this asset no longer has any collision applied to it. It is also
    very important to keep in mind that we do not want more than one collision-bounding
    mesh applied to an object at once in order to keep our assets as optimized as
    possible, unless the shape of the mesh demands more than one collision mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to generating simple collision in the **Static Mesh** editor,
    it is as easy as clicking on a few buttons in its interface. Let''s start by creating
    a **Sphere** collision in our `Shape_Trim` mesh by clicking on the **Collision**
    drop-down menu and selecting **Add Sphere Simplified Collision**. Once complete,
    we should see a collision-bounding mesh that looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Sphere Simplified Collision** option sets the radius of the sphere that
    best matches the size and shape of the mesh that it is applied to. We should also
    note that the collision wireframe changed from light blue to green; this means
    that the collision will use a simple shape. Once a collision is generated, the
    shape can be moved, rotated, and scaled to the desired size and shape. For this
    shape, a sphere collision does not seem to work as we would like it to work, so
    let's select the **Remove Collision** option from the **Collision** drop-down
    list and then the **Add Capsule Simplified Collision** option.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the **Capsule Simplified Collision** option does a much better
    job of matching the size and shape of our mesh than the **Sphere Simplified Collision**
    option because it sets the capsule's height and radius as opposed to just setting
    the radius. We can still see that the collision-bounding mesh does not fit this
    shape as closely as we would like, so let's continue to add differently shaped
    collision meshes in order to find the best one.
  prefs: []
  type: TYPE_NORMAL
- en: Let's remove the capsule collision-bounding mesh and instead select the **Add
    Box Simplified Collision** option to `Shape_Trim`. Here, we can see that the box
    shape does a really good job of matching the size and shape of the mesh, and in
    most situations, we would use this option for this asset for use in our game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purposes of this chapter, we will continue to apply the **KDOP Collision**
    options to this mesh so that we have a better understanding of their purposes
    and the results that we can get from these options. Now, let''s remove the **Box
    Simplified Collision** option and use the **Add 10DOP-X Simplified Collision**
    option. If you remember from the previous section, the **10DOP-X Simplified Collision**
    creates a box with four edges beveled in the *X*-aligned edges. Then, we get the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the **10DOP-X Simplified Collision** option generates a collision-bounding
    mesh identical to the **Box Simplified Collision** option. Now, let''s try applying
    the **10DOP-Y Simplified Collision** option, which creates a box with four edges
    beveled in the *Y*-aligned edges by first removing the **10DOP-X Simplified Collision**
    option and then selecting the **Add 10DOP-Y Simplified Collision** option to obtain
    the following collision mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see here, the **10DOP-Y Simplified Collision** option does an excellent
    job of almost exactly matching the size and shape of our `Shape_Trim` static mesh.
    This is definitely a viable option to select when you generate a collision for
    this asset. Lastly, let''s apply the **10DOP-Z Simplified Collision** option to
    view how it generates a collision mesh around our asset. First, let''s remove
    the **10DOP-Y Simplified Collision** option and then navigate to the **Collision**
    drop-down menu and select **Add 10DOP-Z Simplified Collision**, which creates
    a box with four edges beveled in the *Z*-aligned axis to obtain the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00260.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The result is identical to what we obtained when we applied the **Box Simplified
    Collision** and **10DOP-X Simplified Collision** options. Based on the results
    we received from these options, the best choices for this asset would either be
    **Box Simplified Collision** or **10DOP-Y Simplified Collision**. Due to the simplicity
    of this asset, the **18DOP** and **26DOP Simplified Collision** options won't
    produce unique options, so to properly demonstrate these choices, we need to choose
    a different asset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s close **Static Mesh** editor for the `Shape_Trim`
    asset and navigate to **Content Browser**. Here, under the `Starter Content` folder
    in the `Props` folder, we will double-click on the `SM_Chair` asset to open this
    mesh in **Static Mesh** editor. The `SM_Chair` asset does have the default collision
    applied to it, so before we apply our own, let''s first remove its collision.
    Then, let''s go ahead and select the **18DOP** **Simplified Collision** option
    and view how it generates a collision-bounding mesh for our chair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00261.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you remember, the **18DOP Simplified Collision** option creates a collision-bounding
    box with all of its edges beveled, creating a nice collision around our chair.
    Here, let''s apply the **26DOP Simplified Collision** option by first removing
    our collision and then selecting the **Add 26DOP Simplified Collision** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating simple collisions](img/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the **26DOP Simplified Collision** option creates a box that
    has all of its edges and corners beveled, creating a smoother and more rounded
    collision mesh around our asset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple collisions – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we took a more in-depth look at the different types of simple
    collision that can be generated in the **Static Mesh** editor in Unreal Engine
    4 and the pros and cons of each type. Using starter content assets as examples,
    we applied each type of simple collision to view how they are generated based
    on the size and shape of our asset to better understand how they work. Now that
    we have taken a deeper look at how to generate simple collisions in Unreal Engine
    4, let's now move on and take a look at how to generate complex and custom collision
    hulls using Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex and custom collision hulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to creating complex collision in the **Static Mesh** editor, we
    can use the **Auto Convex Collision** tool to customize the number of hulls and
    hull vertices that the collision mesh will have. For the purposes of this section,
    we will need to continue using `Unreal_PhyProject` that we created, and we will
    use the `SM_Lamp_Wall` asset as an example of how to generate custom and complex
    collision hulls. To navigate to this asset, we need to go to **Content Browser**
    and then to the `Starter Content` folder. Now, under props, we will find the `SM_Lamp_Wall`
    asset. Double-click on this asset to open the **Static Mesh** editor. If this
    static mesh has any default collisions applied to it, make sure to remove the
    said collision by navigating to the **Collision** drop-down menu and selecting
    remove collision. Make sure that the **Collision Toggle** option is set to on
    so that we can view the collision mesh in the **Static Mesh** editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this asset, we will use the **Auto Convex Collision** tool that provides
    us with a set of parameters to generate **Complex Collision**. To use this tool,
    we need to navigate to the **Collision** drop-down menu and select the **Auto
    Convex Collision** option. Once done, we will be provided with a submenu on the
    right-hand side under **Details Panel** labeled as **Convex Decomposition** with
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex and custom collision hulls](img/image00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Max Hulls**: This parameter determines the number of hulls that are created
    to best match the size and shape of the mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Hull Verts**: This parameter sets the maximum number of collision hull
    vertices. By increasing this value, we can see how complex the collision hulls
    can be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply**: This parameter generates a collision mesh based on the **Max Hulls**
    and **Max Hull Verts** parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defaults**: This parameter resets the **Max Hulls** and **Max Hull Verts**
    parameters back to their default values of `4` and `12` respectively (as seen
    in the previous image).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of providing examples, let''s apply **Auto Convex Collision**
    to our `SM_Lamp_Wall` mesh and set the **Max Hulls** and **Max Hull Verts** parameters
    to their default values of `4` and `12` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex and custom collision hulls](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To really view the power of this tool, let''s try applying **Auto Convex Collision**
    to the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Hulls**: Set this parameter to `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max** **Hull Verts**: Set this parameter to `6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex and custom collision hulls](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, setting these parameters to the lowest values possible will
    result in a collision mesh that does the bare minimum and does not fit the size
    and shape of our lamp. Now, let''s try applying **Auto Convex Collision** to the
    following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Hulls**: Set this paramerter to 24'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Hull Verts**: Set this paramerter to 32'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Creating complex and custom collision hulls](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With the maximum settings applied to the convex collision mesh, we can see that
    it does a much better job of covering the lamp in terms of its size and shape.
    In the end, we would want to choose a setting somewhere between the lowest and
    highest values for the **Max Hulls** and **Max Hull Verts** parameters in order
    to create the most optimized collision possible for our assets.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the methods of how to create collisions with the tools
    offered in the **Static Mesh** editor of Unreal Engine 4, we will now briefly
    discuss how to create and import collisions created in third-party art programs
    (such as 3ds Max or Maya).
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind creating customized collision geometry is to make it as simple
    as possible in order to optimize collision detection when you play the game. The
    more complicated the collision geometry for an object, the more calculations are
    required by the engine to ensure that the collision is done correctly on that
    object. When you import the `.FBX` file to Unreal Engine 4, the collision meshes
    included in this file are identified by the importer based on their name. Here
    is the collision-naming syntax required to ensure proper collision when you import
    your assets to Unreal Engine 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UBX_[Mesh Name]**: This naming syntax is required when you import collision
    meshes that are box shaped, using either the box object type in 3ds Max or the
    cube primitive in Maya. Keep in mind that if you move any of the vertices of the
    box collision in the third-party art program or deform the shape in any way to
    make it anything other than a rectangular prism, the import will not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USP_[Mesh Name]**: This naming syntax is required when you import collision
    meshes that are sphere shaped, using the sphere object type in 3ds Max and Maya.
    The sphere itself in the third-party art program does not need to have a specific
    number of segments because it is converted to a true sphere for collision once
    it is imported to Unreal Engine 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UCX_[Mesh Name]**: This naming syntax is required when you import collision
    meshes that are convex shaped or a shape that is completely closed and does not
    have an interior angle of more than 180 degrees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you import the `.FBX` files that contain collision meshes, there are a
    few concepts that we have to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, spheres are only used for rigid-body collisions
    and Unreal's zero-extent traces, such as weapons, and not for instances (such
    as player movements).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the naming syntax mentioned earlier, the **Mesh Name** component must be
    identical to the name of the mesh that the collision is associated with in the
    third- party art program. An example would be a box collision mesh for an object
    named `Chair_01` would be labeled as `UBX_Chair_01`, or if there are multiple
    collision meshes for this object, an additional collision mesh could be named
    `UBX_Chair_01_02`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the collision meshes are created and named properly, we can export both
    the collision and the mesh that the collision is associated with in the `.FBX`
    file. Once imported, Unreal Engine 4 will find the collision, separate it from
    the actual mesh, and transform it into a collision model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the instance that an object has a collision composed of multiple shapes,
    the best results are found when the collision hulls do not intersect with one
    another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating complex and custom collision hulls – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we took an in-depth look at how to create more complex collisions.
    We also looked at how to create custom collision hulls in third-party art programs
    (such as 3ds Max and Maya). Moreover, we analyzed the **Auto Convex Collision**
    tool in the **Static Mesh** editor of Unreal Engine 4\. We also discussed how
    the **Max Hulls** and **Max Hull Verts** parameters affect the collision that
    is generated around our asset. Lastly, we looked at all the necessary naming conventions
    required in our art applications that ensure proper exporting and importing of
    our meshes and collisions to Unreal Engine 4\. Now that we have a very strong
    understanding of how to generate collisions in Unreal Engine 4 and third-party
    art applications, we can now talk about about the different collision interactions
    that exist in Unreal Engine 4 in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Collision interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After discussing a lot about what collision is and how to generate different
    types of collision, let's now talk about how the different collision responses
    function when you interact with the player and other objects in our game world.
    For the purposes of this section, we will want to have `Unreal_PhyProject` open,
    and we will work with the `FirstPersonExampleMap` level and use the default starter
    content to analyze these interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `FirstPersonExampleMap`, we will find numerous cube physics actors spread
    across the surface of the level (each starting awake and active at game time).
    If we select any of these cube actors in the editor by left-clicking on it, we
    will see the following **Collision** settings in its **Details Panel**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, these actors will use **Physics Actor** collision preset and
    have an **Object Type** of **PhysicsBody**. If we were to jump to the level with
    the first person project example (which we have in place) by pressing *Alt* +
    *P*, we can shoot these cubes with the **First-Person Projectile** blueprint by
    left-clicking on it. We can see that on colliding, there is an impulse created
    that causes the boxes to be pushed, and the collision itself causes the projectile
    to bounce off because it is also a physics object that has **Physics Body Object
    Response** set to **Block**. To get a better idea of what is happening, let''s
    open the **First Person Projectile** blueprint by navigating to **Content Browser**
    and then to the `First Person BP` folder. In the `Blueprints` folder, we will
    find the **First Person Projectile** blueprint. Double-click on this asset to
    open its blueprint. It will bring us to the main **Event Graph**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we are viewing the blueprint graph for the first time, this may be a little
    confusing, but we can easily break down the logic flow and understand exactly
    what the projectile will do once it's spawned and collides with an actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the main event of this graph: the **Event Hit** event
    node. What this event node checks for is whether or not the main root component
    of the blueprint is hit in a collision. In this case, the main root of this blueprint
    is the **Sphere Collision Component** option, labeled as **Collision Component**.
    Let''s select this component by left-clicking on **Collision Component** in the
    **Components** tab in the top-left corner of the blueprint screen and then view
    its collision in **Details Panel**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you view its collision, you will see that it is set exactly similar to
    the physics cube actors in the level, possessing a **Physics Actor** collision
    preset and an **Object Type** set to **Physics Body**. What this means in terms
    of collision is that this projectile will act similar to a normal physics ball,
    such as a baseball or a basketball, when spawned into our game world. A ball in
    both the real world and our game world will more than likely end up hitting something,
    and when it does, our **Event Hit** node will be called.
  prefs: []
  type: TYPE_NORMAL
- en: What happens next in the **First Person Projectile** blueprint is that it checks
    whether or not the other component that hits our projectile is a box, a wall,
    a player, or the floor. In particular, this blueprint will check whether the other
    hit component of any collision to this projectile is **Simulating Physics** or
    a physics actor. The **Is Simulating Physics** function node returns a **Boolean**
    value (**True** or **False**), irrespective of whether or not the other hit component
    is a physics actor. We then use a **Branch** node that uses this **True** or **False**
    condition from the **Is Simulating Physics** function to perform actions based
    on whether or not the hit component is a physics actor. We can see that from the
    **True** execution pin, we can add an impulse at the location of the projectile
    and use the **Other Component** of the **Hit** collision as our target to apply
    this impulse to. To determine the force of this impulse, we can perform a simple
    multiplication between the velocity vector of the projectile. We multiply it by
    a constant **Float** value. In addition to **Add Impulse at Location**, this math
    is what causes the physics cube to bounce or react to the projectile on collision,
    and **Is Simulating Physics** checks to ensure that no impulses are created when
    hitting the walls, the floor, or even the player. To have some fun with this blueprint,
    let's change the constant Float value from `100` to `1000` and see how it drastically
    changes the results when the projectile hits a physics object.
  prefs: []
  type: TYPE_NORMAL
- en: To change the way this projectile behaves in the game, we can change its collision
    preset from **Physics Actor** to **Custom** so that we can individually set how
    the collision interacts with the different object responses. For example, let's
    set the **Physics Body** object response from **Block** to **Overlap** and then
    compile the blueprint so that we can see the changes in the game. The result is
    that the projectile goes straight through the physics cube. However, it still
    reacts normally to the **World Static** object type (such as the floor and the
    walls). This is because we changed the object response to **Physics Body** from
    **Block** to **Overlap**. This causes the **Event Hit** event node to never get
    called.
  prefs: []
  type: TYPE_NORMAL
- en: In the blueprints of Unreal Engine 4, there are event nodes we can use when
    objects overlap. This is called the **On Component Begin** overlap. As we made
    our projectile use the **Custom Collision** preset that overlaps the physics bodies
    in the game, we can use the **On Component Begin Overlap** event node to have
    any number of actions to take place during this collision. To set up a basic example
    in our projectile blueprint, select the **Collision Component** option in the
    **Components** tab so that it is highlighted. Next, right-click on an empty space
    of **Event Graph** and navigate to **Add Event** for **Collision Component** and
    then to **Collision**. Finally, select the **Add On Component Begin Overlap**
    event node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To have a similar behavior to what we had in the **Event Hit** node checking
    for objects that are physics actors, let''s copy and paste the **Is Simulating
    Physics** function node and **Branch** that was used in the original blueprint
    logic and connect the nodes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we had our projectile check for objects in our world that are physics
    actors once the collision is overlapped, but we have no actions taking place if
    this check is **True** or **False**. Instead of performing any kind of complicated
    actions, we will simply use the **Print String** function to print the dialogue
    to our console so that we know that the check is working. Let''s right-click on
    the empty space of **Event Graph** and search for the **Print String** function
    node. In the **In String** parameter, enter `Overlapped Physics Body`, and connect
    it to the **True** executional output pin, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we click on the **Compile** button at the top of the blueprint and play the
    game, we can see that the projectile goes right through our physics objects, but
    we do not see our **Print String** outputted to the console. This is because both
    the physics cubes in the level and our projectile collision don't have the **Generate
    Overlap Events** parameter set to **True** by default, so let's select one or
    more of the cubes and navigate to their **Collision Settings** in **Details Panel**
    and make sure that **Generate Overlap Events** is set to **True**. Let's perform
    the same function to **Collision Component** in our projectile blueprint. Now,
    if we play again and shoot the physics cubes that we customized, we will now see
    our **Print String** outputted to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision interactions](img/image00273.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From here, feel free to experiment and customize the collision presets that
    the projectile has, see how it changes and reacts in our game world, and add more
    blueprint functionalities to see what else is possible.
  prefs: []
  type: TYPE_NORMAL
- en: The last collision interaction that can exist between objects, apart from **Block**
    and **Overlap**, is the **Ignore** option. There is not much to this type of **Collision
    Response** because it will ignore the different **Object Responses** completely
    if it is set to **Ignore**. For the purpose of our example, in our **First Person
    Projectile** blueprint, let's change the **Physics Body** object response from
    **Overlap** to **Ignore**. If we play now, we can shoot at the physics cubes,
    but it will go completely through the object, and neither the **On Component Begin
    Overlap** nor the **Event Hit** event nodes will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Collision interactions – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we got our hands dirty by applying the different combinations
    of collision presets to the **First Person Projectile** blueprint to see how it
    interacts with the physics actors in our game world. By setting the **Physics
    Body** object response to **Block**, the **Event Hit** event node will be called.
    Also, an impulse will be created at the projectiles' location, resulting in a
    small push force applied to the physics actor the projectile collides with. By
    setting the **Physics Body** object response to **Overlap**, we can use the **On
    Component Begin Overlap Event** node to call different actions once the projectile
    overlaps with a physics actor. We just need to make sure that the physics actors
    in our level and our projectile have the **Generate Overlap Events** set to **True**.
    Lastly, we briefly discussed the results of when our projectile has the **Physics
    Body** object response set to **Ignore**. Like the name suggests, it ignores the
    object response, and no events are fired. Now that we talked more about collision
    interactions, let's move on and discuss how to create and use custom object and
    trace channel responses in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Custom object and trace channel responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the default object and trace channel responses are not enough for
    what we want to do in our games. So, it may be necessary to create customized
    object and trace channel responses for certain assets and scenarios. To accomplish
    this, we can navigate to the **Edit** drop-down window at the top of the Unreal
    Engine 4 editor and select **Project Settings**. From here, select the **Collision**
    option under the **Engine** section. Here, we can create custom **Objects**, **Trace
    Channels**, and **Presets** that we can use when we apply collisions to our assets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with creating a new **Object Channel** by selecting this option
    and clicking on the **New Object Channel** button. Here, a dialogue window pops
    up. Then, we can customize how **Object Channel** responds by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom object and trace channel responses](img/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Name the **Object Channel** `Projectile`, and set its **Default Response**
    to **Block**. Now, let''s create a custom **Collision Preset** by selecting this
    option and selecting the **New** button so that a dialogue window appears. Here,
    we can set the presets default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom object and trace channel responses](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can also name this new **Collision Preset Profile**, `Projectile`, set the
    **Collision Enabled** property to **Collision Enabled**, **Object Type** to `Projectile`,
    (the one that we have just created), and the **Description** property to anything
    that will remind us of what this **Collision Preset** is used for. Lastly, we
    can set all the **Trace** and **Object Channels** for this preset to **Block**.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this section's demonstration, we won't create a custom **Trace
    Channel**, but if we ever needed to, it works exactly similar to creating a custom
    **Object Channel**; select the **Trace Channels** option, left-click on the **New
    Trace Channel** button, name the channel, and set the **Default Response** to
    either **Block**, **Overlap**, or **Ignore**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created a custom **Object Channel** and a custom **Collision
    Preset**, let''s apply these to the **Collision Component** of the **First Person
    Projectile** blueprint. Once you are in the **First Person Projectile** blueprint,
    select the **Collision** component from the **Components** tab in the top-left
    corner and navigate to the **Collision** section of the **Details Panel** in the
    bottom-right corner of the blueprint window. If we look at the **Collision Presets**
    drop-down menu, we will see our `Projectile` **Collision Preset** available, and
    when we select this option, we will see the default values that we set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom object and trace channel responses](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can also see our `Projectile` **Object Channel Response** that we created
    earlier in the **Object Responses** section of the **Collision Component**. Now,
    if we ever need to, we can set all of our projectile assets to have the **Projectile
    Collision Preset** so that all of our projectiles behave the same during collisions.
    In addition to this, we can have other assets collide in a specific way to projectiles
    by setting the **Projectile** object response to **Block**, **Overlap**, or **Ignore**
    projectiles on colliding. Now, when we play the game, we can see that the **First
    Person Projectile** blueprint behaves exactly as intended when you fire the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: Just as a reminder, we can only have up to 18 custom **Object Channels** and
    **Trace Channels**, and if we ever delete an **Object Type** that has been used
    in our game, it will revert back to **WorldStatic**, and if we delete a trace
    channel that has been used in our game, the behavior of the trace is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Custom object and trace channel responses – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we took a deeper look at how to create and implement custom
    objects, trace channels, and custom collision presets. We then applied these customized
    channels and presets to the **First Person Projectile** blueprint and found that
    we can have the same collision behavior exist for the projectile when we use custom
    collision presets and **Object** channels. Now that we have created our very own
    custom object and trace channels and created our own collision preset, we can
    now move on and take an in-depth look at the additional default collision presets
    that exist in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: In-depth collision presets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To conclude this chapter, let''s briefly discuss the remaining collision presets
    available in Unreal Engine 4 that we have not gone through at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom**: This collision preset allows you to fully customize how you want
    the collision to behave by selecting the **Collision Enabled** property, setting
    the **Object Type** property, and fully customizing how the **Trace** and **Object
    Responses** react to different types of collisions. This type of collision preset
    is useful when we need to customize an assets collision, and where the default
    collision presets does not fit the type of collision we need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block All Dynamic**: This collision preset blocks all the actors by default
    and makes the collision itself a **WorldDynamic** object. This type of collision
    preset is useful for dynamic objects or objects that can move in your game world
    that you want to block when you collide with other objects. Lastly, the **Collision
    Enabled** property is set to **Collision Enabled**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overlap All Dynamic**: This collision preset overlaps all the actors by default
    and makes the collision itself a **WorldDynamic** object. This type of collision
    preset is useful for dynamic objects that you want to overlap when you collide
    with other objects. Lastly, the **Collision Enabled** property is set to **No
    Physics Collision**, meaning that the assets'' collision won''t use game physics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ignore Only Pawn**: This collision preset blocks all the actors by default,
    but it ignores the **Pawn** and **Vehicle** object responses. This preset also
    sets the **Object Type** of the collision to **WorldDynamic** and is useful for
    assets that you want to ignore for **Pawns** and **Vehicles** in your game world.
    Lastly, the **Collision Enabled** property is set to **No Physics Collision**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overlap Only Pawn**: This collision preset blocks all the actors by default,
    but it overlaps the **Pawn** and **Vehicle** object responses. It also overlaps
    the **Camera** trace channel. This preset also sets the **Object Type** of the
    collision to **WorldDynamic** and is useful for assets that need overlap events
    to fire when it is overlapped during a collision with **Pawns**, **Vehicles**,
    and **Camera Traces**. Lastly, the **Collision Enabled** property is set to **No
    Physics Collision**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spectator**: This collision preset ignores all the actors by default, except
    the **WorldStatic** object responses. This preset also sets the **Object Type**
    of the collision to **Pawn** and is useful when you want players to see a game
    in multiplayer situations. Lastly, the **Collision Enabled** property is set to
    **No Physics Collision**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character Mesh**: This collision preset is a **Pawn Object Type** that is
    used for a **Character** **Mesh** when you create a player character. By default,
    this preset ignores the **Visibility** trace response and the **Pawn** and **Vehicle**
    object responses, although it blocks the remaining values. Lastly, the **Collision
    Enabled** property is set to **No Physics Collision**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destructible**: This collision preset is a **Destructible Object Type** that
    is used for assets that can be destructible in the game. By default, this preset
    blocks all the **Trace** and **Object Channels**. Its **Collision Enabled** property
    is set to **Collision Enabled**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invisible Wall**: This collision preset is a **World Static Object Type**
    that is used as an invisible wall that blocks all the **Trace** and **Object Responses**,
    except the **Visibility Trace Response**, which this preset ignores. This preset
    works exactly similar to a blocking volume. Lastly, its **Collision Enabled**
    property is set to **Collision Enabled**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invisible Wall Dynamic**: This collision preset is a **World Dynamic Object
    Type** that is used as an invisible wall that functions exactly similar to the
    **Invisible Wall** collision preset, in which it blocks all the **Trace** and
    **Object Responses**, except the **Visibility Trace Response**, which this preset
    also ignores. Lastly, its **Collision Enabled** property is set to **Collision
    Enabled**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger**: This collision preset is a **World Dynamic Object Type** that
    is used as a **Trigger**, meaning that it functions similar to a **Trigger Volume**
    so that we can use it to call all the events and functions in our game. By default,
    the **Trigger Collision Preset** overlaps all the **Trace** and **Object Channel
    Responses**, except the **Visibility Trace Channel**, which this preset ignores.
    Lastly, its **Collision Enabled** property is set to **No Physics Collision**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ragdoll**: This collision preset is used to simulate skeletal mesh components.
    Its **Object Type** is set to **Physics Body**. We can use this preset for character
    meshes that would turn rag doll when players are killed or lose control and would
    want the player character to be taken over by physics. By default, this collision
    preset blocks all the **Trace** and **Object Responses**, except the **Pawn Object
    Response**, which it ignores. Lastly, the **Collision Enabled** property is set
    to **Collision Enabled**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vehicle**: This collision preset is a **Vehicle Object Type** that is used
    for any moving vehicle assets in our game world. By default, this preset blocks
    all the **Trace** and **Object Responses**. Its **Collision Enabled** property
    is set to **Collision Enabled**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI**: This collision preset is a **World Dynamic Object Type** that is used
    for any **UI** assets (such as **UMG HUD** elements). By default, this preset
    overlaps all the **Trace** and **Object Responses**, except the **Visibility Trace**
    **Response**, which this preset blocks. Lastly, the **Collision Enabled** property
    is set to **No Physics Collision**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-depth collision presets – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we took an in-depth look at all the collision presets that
    Unreal Engine 4 provides users by default, and by doing so, we analyzed the purpose
    and functionalities of each. Now that we have covered collision presets, we can
    now conclude this chapter and move on to discussing constraints in Unreal Engine
    4.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how collision works and how it is implemented
    in Unreal Engine 4 by first analyzing the topics of trace and collision responses.
    We also discussed how these responses work, their parameter values, and how to
    implement these responses to our blueprint assets in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned about simple and complex collisions by defining what each
    type is and how they are used. We also looked at its pros and cons and how to
    generate the different types of simple collision.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you learned more about complex collisions and how to generate
    these types of collisions in Unreal Engine 4\. You also looked at how to create
    custom collision hulls in third-party art programs.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you learned about collision interactions. We used the **First Person
    Projectile** blueprint as an example of how these interactions are used when it
    comes to scripting different behaviors for our assets.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we went through the purposes of custom objects and trace channels.
    We discussed how to create custom collision presets, including how to implement
    these customized parameters in blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we discussed the different collision presets that exist in Unreal Engine
    4, their purposes, and how they function in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a stronger understanding of how collision works and how to
    implement the different collisions for our assets, we can now dive deep into creating
    constraints in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
