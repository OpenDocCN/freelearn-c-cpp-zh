<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Building User Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building User Interfaces</h1></div></div></div><p>This chapter covers the JUCE <code class="literal">Component</code> class, which is the main building block for creating a <a id="id61" class="indexterm"/>
<span class="strong"><strong>Graphical User Interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) in JUCE. In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating buttons, sliders, and other components</li><li class="listitem" style="list-style-type: disc">Responding to user interaction and changes: broadcasters and listeners</li><li class="listitem" style="list-style-type: disc">Using other component types</li><li class="listitem" style="list-style-type: disc">Specifying colors and using drawing operations</li></ul></div><p>By the end of this chapter, you will be able to create a basic GUI and perform fundamental drawing operations within a component. You will also have the skills required to design and build more complex interfaces.</p><div class="section" title="Creating buttons, sliders, and other components"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Creating buttons, sliders, and other components</h1></div></div></div><p>The <a id="id62" class="indexterm"/>JUCE <code class="literal">Component</code> class is the base class that provides<a id="id63" class="indexterm"/> the<a id="id64" class="indexterm"/> facility to draw on the screen and intercept user interaction from pointing devices, <a id="id65" class="indexterm"/>touch-screen interaction, and keyboard input. The<a id="id66" class="indexterm"/> JUCE distribution includes a wide range of <code class="literal">Component</code> subclasses, many of which you may have encountered by exploring the JUCE Demo application in <a class="link" href="ch01.html" title="Chapter 1. Installing JUCE and the Introjucer Application">Chapter 1</a>, <span class="emphasis"><em>Installing JUCE and the Introjucer Application</em></span>. The JUCE coordinate system<a id="id67" class="indexterm"/> is hierarchical, starting at the computer's screen (or screens) level. This is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/3316_02_01.jpg" alt="Creating buttons, sliders, and other components"/></div><p>Each on-screen window contains a single <span class="strong"><strong>parent</strong></span> component<a id="id68" class="indexterm"/> within which other <span class="strong"><strong>child</strong></span> components<a id="id69" class="indexterm"/> (or <span class="strong"><strong>subcomponents</strong></span>) are placed (each of which may contain further child components). The top-left of the computer screen is coordinate (0, 0) with each top-left of the content of JUCE windows being at an offset from this. Each component then has its own local coordinates where its top-left starts at (0, 0) too.</p><p>In most cases you will deal with the components' coordinates relative to their parent components, but JUCE provides simple mechanisms to convert these values to be relative to other components or the main screen (that is, global coordinates). Notice in the preceding diagram that a window's top-left position does not include the title bar area.</p><p>You will now create a simple JUCE application that includes some fundamental component types. As the code for this project is going to be quite simple, we will write all our code into the header file (<code class="literal">.h</code>). This is not recommended for real-world projects except for quite small classes (or where there are other good reasons), but this will keep all the code in one place as we go through it. Also, we will split up the code into the <code class="literal">.h</code> and <code class="literal">.cpp</code> files later in the chapter.</p><p>Create a new JUCE project using the Introjucer application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Choose menu item <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project…</strong></span></li><li class="listitem">Select <span class="strong"><strong>Create a Main.cpp file and a basic window</strong></span> from the <span class="strong"><strong>Files to Auto-Generate</strong></span> menu.</li><li class="listitem">Choose where to save the project and name it <code class="literal">Chapter02_01</code>.</li><li class="listitem">Click on the <span class="strong"><strong>Create…</strong></span> button</li><li class="listitem">Navigate to the <span class="strong"><strong>Files</strong></span> panel.</li><li class="listitem">Right-click on the file <code class="literal">MainComponent.cpp</code>, choose <span class="strong"><strong>Delete</strong></span> from the contextual menu, and confirm.</li><li class="listitem">Choose menu item <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Save Project</strong></span>.</li><li class="listitem">Open the project in your <span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>), either Xcode or Visual Studio.</li></ol></div><p>Navigate to the <code class="literal">MainComponent.h</code> file in your IDE. The most important part of this file should look similar to this:</p><div class="informalexample"><pre class="programlisting">#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent  : public Component
{
public:
  //==============================================================
  MainContentComponent();
  ~MainContentComponent();

  void paint (Graphics&amp;);
  void resized();

  private:
  //==============================================================
  JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR
    (MainContentComponent)
};</pre></div><p>Of course, we have removed the actual code from the autogenerated project by removing the <code class="literal">.cpp</code> file.</p><p>First let's make an empty window. We will remove some of the elements to simplify the code and add a function body for the constructor. Change the declaration of the <code class="literal">MainContentComponent</code> class shown as follows:</p><div class="informalexample"><pre class="programlisting">class MainContentComponent : public Component
{
public:
  MainContentComponent()
  {
    setSize (200, 100);
  }
};</pre></div><p>Build and run the application, there should be an empty window named <span class="strong"><strong>MainWindow</strong></span> in the center of the screen. Our JUCE application will create a window and place an instance of our <code class="literal">MainContentComponent</code> class as its content (that is, excluding the title bar). Notice our <code class="literal">MainContentComponent</code> class inherits from the <code class="literal">Component</code> class and therefore has access to a range of functions implemented by the <code class="literal">Component</code> class. The first of these is the <code class="literal">setSize()</code> function<a id="id70" class="indexterm"/>, which sets the width and height of our component.</p><div class="section" title="Adding child components"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Adding child components</h2></div></div></div><p>Building<a id="id71" class="indexterm"/> user interfaces using components <a id="id72" class="indexterm"/>generally involves combining other components to produce composite user interfaces. The easiest way to do this is to include member variables in which to store the <span class="strong"><strong>child</strong></span> components in the <span class="strong"><strong>parent</strong></span> component class. For each child component that we wish to add, there are five basic steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Creating a member variable in which to store the new component.</li><li class="listitem">Allocating a new component (either using static or dynamic memory allocation).</li><li class="listitem">Adding the component as a child of the parent component.</li><li class="listitem">Making the child component visible.</li><li class="listitem">Setting the child component's size and position within the parent component.</li></ol></div><p>First, we will create a button; change the code shown as follows. The preceding numbered steps are illustrated in the code comments:</p><div class="informalexample"><pre class="programlisting">class MainContentComponent : public Component
{
public:
  MainContentComponent()
  : button1 ("Click") // Step [2]
  {
    addAndMakeVisible (&amp;button); // Step [3] and [4]
    setSize (200, 100);
  }
  
  void resized()
  {
    // Step [5]
    button1.setBounds (10, 10, getWidth()-20, getHeight()-20);
  }
  
private:
  TextButton button1; // Step [1]
};</pre></div><p>The important parts of the preceding code are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An instance of the JUCE <code class="literal">TextButton</code> class was added to the <code class="literal">private</code> section of our class. This button will be statically allocated.</li><li class="listitem" style="list-style-type: disc">The button is initialized in the constructor's initializer list using a string that sets the text that will appear on the button.</li><li class="listitem" style="list-style-type: disc">A call to the component function <code class="literal">addAndMakeVisible()</code><a id="id73" class="indexterm"/> is passed as a pointer to our button instance. This adds the child component to the parent component hierarchy and makes the component visible on screen.</li><li class="listitem" style="list-style-type: disc">The component function <code class="literal">resized()</code><a id="id74" class="indexterm"/> is overridden to position our button with an inset of 10 pixels within the parent component (this is achieved by using component functions <code class="literal">getWidth()</code><a id="id75" class="indexterm"/> and <code class="literal">getHeight()</code><a id="id76" class="indexterm"/> to discover the size of the parent component). This call to the <code class="literal">resized()</code> function is triggered when the parent component is resized, which in this case happens when we call the <code class="literal">setSize()</code> function in the constructor. The arguments to the <code class="literal">setSize()</code> function<a id="id77" class="indexterm"/> are in the order: width and height. The arguments to the <code class="literal">setBounds()</code> function<a id="id78" class="indexterm"/> are in the order: left, top, width, and height.</li></ul></div><p>Build <a id="id79" class="indexterm"/>and<a id="id80" class="indexterm"/> run the application. Notice that the button responds as the mouse pointer hovers over the button and when the button is clicked, although the button doesn't yet do anything.</p><p>Generally, this is the most convenient method of positioning and resizing child components, even though in this example we could have easily set all the sizes in the constructor. The real power of this technique is illustrated when the parent component becomes resizable. The easiest way to do that here is to enable the resizing of the window itself. To do this, navigate to the <code class="literal">Main.cpp</code> file (which contains the boilerplate code to set up the basic application) and add the following highlighted line to the <code class="literal">MainWindow</code> constructor:</p><div class="informalexample"><pre class="programlisting">...
{
  setContentOwned (new MainContentComponent(), true);

  centreWithSize (getWidth(), getHeight());
  setVisible (true);
  <span class="strong"><strong>setResizable (true, true);</strong></span>
}
...</pre></div><p>Build and run the application and notice that the window now has a corner resizer in the bottom-right. The important thing here is that the button automatically resizes as the window size changes due to the way we implemented this above. In the call to the <code class="literal">setResizable()</code> function<a id="id81" class="indexterm"/>, the first argument sets whether the window is resizable and the second argument sets whether this is via a corner resizer (<code class="literal">true</code>) or allowing the border of the window to be dragged to resize the window (<code class="literal">false</code>).</p><p>Child components may be positioned proportionally rather than with absolute or offset values. One way of achieving this is through the <code class="literal">setBoundsRelative()</code> function<a id="id82" class="indexterm"/>. In the following example you will add a slider control and a label to the component.</p><div class="informalexample"><pre class="programlisting">class MainContentComponent : public Component
{
public:
  MainContentComponent()
  : button1 ("Click")<span class="strong"><strong>,</strong></span>
<span class="strong"><strong>    label1 ("label1", "Info")</strong></span>
  {
<span class="strong"><strong>    slider1.setRange (0.0, 100.0);</strong></span>
    addAndMakeVisible (&amp;button1);
<span class="strong"><strong>    addAndMakeVisible (&amp;slider1);</strong></span>
<span class="strong"><strong>    addAndMakeVisible (&amp;label1);</strong></span>
    setSize (200, 100);
  }
  
  void resized()
  {
<span class="strong"><strong>    button1.setBoundsRelative (0.05, 0.05, 0.90, 0.25);</strong></span>
<span class="strong"><strong>    slider1.setBoundsRelative (0.05, 0.35, 0.90, 0.25);</strong></span>
<span class="strong"><strong>    label1.setBoundsRelative (0.05, 0.65, 0.90, 0.25);</strong></span>
  }
  
private:
  TextButton button1;
<span class="strong"><strong>  Slider slider1;</strong></span>
<span class="strong"><strong>  Label label1;</strong></span>
};</pre></div><p>In this case<a id="id83" class="indexterm"/>, each child component is 90 percent of the width of the parent component and positioned five percent of the parent's width from the left. Each child component is 25 percent of the height of the parent, and the three components are distributed top to bottom with the button five percent of the parent's height from the top. Build and run the application, and notice that resizing the window automatically and smoothly, updates the sizes and position of the child components. The window should look similar to the following screenshot. In the next section you will intercept and respond to user interaction:</p><div class="mediaobject"><img src="graphics/3316_02_02.jpg" alt="Adding child components"/></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div></div>
<div class="section" title="Responding to user interaction and changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Responding to user interaction and changes</h1></div></div></div><p>Create a <a id="id84" class="indexterm"/>new Introjucer project named <code class="literal">Chapter02_02</code> with a basic window; this time retain all of the<a id="id85" class="indexterm"/> auto-generated files. We will now split the code from the previous section into the <code class="literal">MainComponent.h</code> and <code class="literal">MainComponent.cpp</code> files. The <code class="literal">MainComponent.h</code> file should look as follows:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component
{
public:
  MainContentComponent();
  void resized();
  
private:
  TextButton button1;
  Slider slider1;
  Label label1;
};
#endif </pre></div><p>The <code class="literal">MainComponent.cpp</code> file should look as follows:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: button1 ("Click")
{
  slider1.setRange (0.0, 100.0);
  addAndMakeVisible (&amp;button1);
  addAndMakeVisible (&amp;slider1);
  addAndMakeVisible (&amp;label1);
  setSize (200, 100);
}

void MainContentComponent::resized()
{
  button1.setBoundsRelative (0.05, 0.05, 0.90, 0.25);
  slider1.setBoundsRelative (0.05, 0.35, 0.90, 0.25);
  label1.setBoundsRelative (0.05, 0.65, 0.90, 0.25);
}</pre></div><div class="section" title="Broadcasters and listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Broadcasters and listeners</h2></div></div></div><p>Although the <code class="literal">Slider</code> class already contains a text box that displays the slider's value, it will be useful to examine how this communication works within JUCE. In the next example we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Remove the<a id="id86" class="indexterm"/> text box from the slider</li><li class="listitem" style="list-style-type: disc">Make the slider's value appear in the label</li><li class="listitem" style="list-style-type: disc">Enable the slider to be zeroed by clicking on the button</li></ul></div><p>To achieve<a id="id87" class="indexterm"/> this, JUCE uses the <span class="strong"><strong>observer</strong></span> pattern<a id="id88" class="indexterm"/> widely throughout the library to enable objects to communicate. In particular, the <code class="literal">Component</code> class and the <code class="literal">Component</code> subclasses use this to notify your code when a user interface item has been clicked, their content has been changed, and so on. In JUCE, these are generally known as <span class="strong"><strong>listeners</strong></span>
<a id="id89" class="indexterm"/> (the observers) and <span class="strong"><strong>broadcasters</strong></span>
<a id="id90" class="indexterm"/> (the subjects of the observers). JUCE also makes extensive use of multiple inheritance. One area in JUCE where multiple inheritance is particularly useful is through the use of the broadcaster and listener systems. Generally, a JUCE class that supports broadcasting its state changes has a nested class called <code class="literal">Listener</code>. Thus, the <code class="literal">Slider</code> class has the <code class="literal">Slider::Listener</code> class and the <code class="literal">Label</code> class has the <code class="literal">Label::Listener</code> class. (These are often represented by classes with similar names to help support older IDEs, for example, <code class="literal">SliderListener</code> and <code class="literal">LabelListener</code> are equivalent.) The <code class="literal">TextButton</code> class is in fact a subclass of the more generic <code class="literal">Button</code> class; therefore, its listener class is <code class="literal">Button::Listener</code>. Each of these listener classes will contain a declaration of at least one <span class="strong"><strong>pure virtual function</strong></span>
<a id="id91" class="indexterm"/>. This will require our derived class to implement these functions. Listener classes may contain other regular virtual functions, meaning they may be implemented optionally. To implement these functions, first add listener classes for the button and slider as public base classes of our <code class="literal">MainContentComponent</code> class in the <code class="literal">MainComponent.h</code> file shown as follows:</p><div class="informalexample"><pre class="programlisting">class MainContentComponent :  public Component<span class="strong"><strong>,</strong></span>
<span class="strong"><strong>          public Button::Listener,</strong></span>
<span class="strong"><strong>          public Slider::Listener</strong></span>
{
...</pre></div><p>Each of our user interface listeners here requires us to implement one function to respond to its changes. These are the<a id="id92" class="indexterm"/>
<code class="literal">buttonClicked()</code> and <code class="literal">sliderValueChanged()</code> functions.<a id="id93" class="indexterm"/> Add these to the <code class="literal">public</code> section of our class declaration:</p><div class="informalexample"><pre class="programlisting">  ...
<span class="strong"><strong>  void buttonClicked (Button* button);</strong></span>
<span class="strong"><strong>  void sliderValueChanged (Slider* slider);</strong></span>
  ...
</pre></div><p>The full listing to use for the <code class="literal">MainComponent.cpp</code> file is shown as follows:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: <span class="strong"><strong>button1 ("Zero Slider"),</strong></span>
<span class="strong"><strong>  slider1 (Slider::LinearHorizontal, Slider::NoTextBox)</strong></span>
{
  slider1.setRange (0.0, 100.0);

<span class="strong"><strong>  slider1.addListener (this);</strong></span>
<span class="strong"><strong>  button1.addListener (this);</strong></span>
<span class="strong"><strong>  slider1.setValue (100.0, sendNotification);</strong></span>

  addAndMakeVisible (&amp;button1);
  addAndMakeVisible (&amp;slider1);
  addAndMakeVisible (&amp;label1);

  setSize (200, 100);
}

void MainContentComponent::resized()
{
  button1.setBoundsRelative (0.05, 0.05, 0.90, 0.25);
  slider1.setBoundsRelative (0.05, 0.35, 0.90, 0.25);
  label1.setBoundsRelative (0.05, 0.65, 0.90, 0.25);
}

<span class="strong"><strong>void MainContentComponent::buttonClicked (Button* button)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  if (&amp;button1 == button)</strong></span>
<span class="strong"><strong>    slider1.setValue (0.0, sendNotification);</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>void MainContentComponent::sliderValueChanged(Slider* slider)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  if (&amp;slider1 == slider) {</strong></span>
<span class="strong"><strong>    label1.setText (String (slider1.getValue()), </strong></span>
<span class="strong"><strong>                    sendNotification);</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>The two calls to add the listeners using the <code class="literal">addListener()</code> function<a id="id94" class="indexterm"/>, pass the <code class="literal">this</code> pointer (a pointer to our <code class="literal">MainContentComponent</code> instance). This adds our <code class="literal">MainContentComponent</code> instance as a listener to both the slider and the button respectively.</p><p>Although there is only one instance of each type of component, the preceding example shows the recommend way to check which component broadcasted a change, in cases where there may be many similar components (such as banks of buttons or sliders). This technique is to check the value of the pointer received by the listener function and whether this matches the address of one of the member variables. There is one thing to note on the coding style here. You may prefer to write the <code class="literal">if()</code> statement with the arguments swapped over as follows:</p><div class="informalexample"><pre class="programlisting">
if 
(button == &amp;button1)
...</pre></div><p>However, the style used throughout this book is employed to cause a deliberate compiler error if you mistype the "<code class="literal">==</code>" operator as a single "<code class="literal">=</code>" character. This should help avoid bugs that might be introduced by this mistake.</p><p>Components that store some kind of value such as sliders and labels may, of course, have their state set programmatically. In this case, you can control whether its listeners are notified of the change or not (you can also customize whether this is transmitted <span class="strong"><strong>synchronously</strong></span> or <span class="strong"><strong>asynchronously</strong></span>). This is the purpose of the <code class="literal">sendNotification</code> value (which is an enumerated constant) in the calls to the <code class="literal">Slider::setValue()</code> and <code class="literal">Label::setText()</code> functions as in the preceding code snippet. Also, you should notice that the call to the <code class="literal">Slider::setValue()</code> function in the constructor is made <span class="emphasis"><em>after</em></span> the class has been registered as a listener. This ensures that all the components are configured correctly from the start while minimizing the duplication of code. This code  makes use of the <code class="literal">String</code> class to pass text to the label, to convert text to numerical values, and vice versa. The <code class="literal">String</code> class will be explored in more detail in the next chapter, but for now, we will limit the usage of the <code class="literal">String</code> class to these basic operations. The text box is removed from the slider by initializing the slider in the initializer list with a slider style and text box style. In this case, the initializer <code class="literal">slider1 (Slider::LinearHorizontal</code>,<code class="literal"> Slider::NoTextBox)</code> specifies a horizontal slider and that no text box should be attached.</p><p>Finally, should we want to set the value of the slider to something specific; we can make the label editable and transmit any changes typed into the label to the slider. Make another new Introjucer project and name it <code class="literal">Chapter02_03</code>. Add the <code class="literal">Label::Listener</code> class to the base classes of our <code class="literal">MainContentComponent</code> class in the header file:</p><div class="informalexample"><pre class="programlisting">class MainContentComponent :  public Component,
                              public Button::Listener,
                              public Slider::Listener<span class="strong"><strong>,</strong></span>
<span class="strong"><strong>                              public Label::Listener</strong></span>
{
...</pre></div><p>Add the <code class="literal">Label::Listener</code> function that responds to the label changes, also in the header file:</p><div class="informalexample"><pre class="programlisting">... 
<span class="strong"><strong>  void labelTextChanged (Label* label);</strong></span>
...</pre></div><p>Update the constructor in the <code class="literal">MainComponent.cpp</code> file to further configure the label:</p><div class="informalexample"><pre class="programlisting">MainContentComponent::MainContentComponent()
: button1 ("Zero Slider"),
  slider1 (Slider::LinearHorizontal, Slider::NoTextBox)
{
  slider1.setRange (0.0, 100.0);
<span class="strong"><strong>  label1.setEditable (true);</strong></span>

  slider1.addListener (this);
  button1.addListener (this);
<span class="strong"><strong>  label1.addListener (this);</strong></span>

  slider1.setValue (100.0, sendNotification);

  addAndMakeVisible (&amp;button1);
  addAndMakeVisible (&amp;slider1);
  addAndMakeVisible (&amp;label1);

  setSize (200, 100);
}</pre></div><p>Here, the label is set to be editable with a single click and our class registers itself as a listener for the label. Lastly, add the implementation for the <code class="literal">labelTextChanged()</code> function to the <code class="literal">MainComponent.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void MainContentComponent::labelTextChanged (Label* label)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  if (&amp;label1 == label) {</strong></span>
<span class="strong"><strong>    slider1.setValue (label1.getText().getDoubleValue(), </strong></span>
<span class="strong"><strong>                      sendNotification);</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Build and run the application to test this functionality. There are some problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The slider correctly clips values typed into the label that are outside the range of the slider, but the text in the label still remains if these values are outside the range</li><li class="listitem" style="list-style-type: disc">The label allows non-numerical characters to be typed in (although these are usefully resolved to zero)</li></ul></div></div><div class="section" title="Filtering data entry"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Filtering data entry</h2></div></div></div><p>The <a id="id95" class="indexterm"/>first issue mentioned above is straightforward, and this is to convert the slider's value back to text and use this to set the label content.  This time we use the <code class="literal">dontSendNotification</code> value, because we want to avoid an infinite loop whereby each component would broadcast a message that causes a change that would in turn cause a message to be broadcasted and so on:</p><div class="informalexample"><pre class="programlisting">  if (&amp;label1 == label)
  {
    slider1.setValue (label1.getText().getDoubleValue(),
                      sendNotification);
    <span class="strong"><strong>label1.setText (String (slider1.getValue()), </strong></span>
<span class="strong"><strong>                    dontSendNotification);</strong></span>
  }</pre></div><p>The second issue requires a filter to allow only certain characters. Here, you need access to the label's internal <code class="literal">TextEditor</code> object. To do this, you could create a custom label class by inheriting from the <code class="literal">Label</code> class and implementing the <code class="literal">editorShown()</code> virtual function. Add this small class to the <code class="literal">MainComponent.h</code> file above the <code class="literal">MainContentComponent</code> class declaration (although to reuse this class across a number of components in your application, it may be better to place this code in a separate file):</p><div class="informalexample"><pre class="programlisting">class NumericalLabel : public Label
{
public:
  void editorShown (TextEditor* editor)
  {
    editor-&gt;setInputRestrictions (0, "-0123456789.");
  }
};</pre></div><p>Because the text editor is just about to be shown, this function is called by the label, and at that point you can set the text editor's input restrictions using its <code class="literal">setInputRestrictions()</code> function. The two arguments are: length and allowable characters. The zero length means there is no restriction on length and the allowable characters in this case include all the digits, the<a id="id96" class="indexterm"/> minus sign and the period. (In fact you could omit the minus sign to disallow negative numbers and omit the period if you wanted to allow integer values only.) To use this class in place of the built-in <code class="literal">Label</code> class simply replace this class name in the member variable list for our <code class="literal">MainContentComponent</code> class as shown highlighted:</p><div class="informalexample"><pre class="programlisting">...
private:
  TextButton button1;
  Slider slider1;
<span class="strong"><strong>  NumericalLabel label1;</strong></span>
...</pre></div><p>Hopefully, by this point you can see that JUCE classes provide a useful range of core functionality while allowing customizations with relative ease.</p></div></div>
<div class="section" title="Using other component types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Using other component types</h1></div></div></div><p>There are many other <a id="id97" class="indexterm"/>built-in component types and variations on the sliders and buttons already seen. In the previous section we used the default horizontal slider, but the <code class="literal">Slider</code> class is very flexible, as illustrated by the Widget demo page of the JUCE Demo application. The sliders can adopt a rotary-type control, have minimum and maximum ranges, and warp the numerical track to adopt non-linear behavior. Similarly, buttons can adopt different styles such as toggle buttons, buttons that use images, and so on. The following example illustrates a toggle-type button<a id="id98" class="indexterm"/> that changes the style of two sliders. <a id="id99" class="indexterm"/>Create a new Introjucer project named <code class="literal">Chapter02_04</code>, and use the following code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MainComponent.h</strong></span>:<div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent :  public Component,
                              public Button::Listener
{
public:
  MainContentComponent();
  void resized();
  
  void buttonClicked (Button* button);
  
private:
  Slider slider1;
  Slider slider2;
  ToggleButton toggle1;
};
#endif</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MainComponent.cpp</strong></span><a id="id100" class="indexterm"/>:<div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: slider1 (Slider::LinearHorizontal, Slider::TextBoxLeft),
  slider2 (Slider::LinearHorizontal, Slider::TextBoxLeft),
  toggle1 ("Slider style: Linear Bar")
{
  slider1.setColour (Slider::thumbColourId, Colours::red);
  toggle1.addListener (this);
    
  addAndMakeVisible (&amp;slider1);
  addAndMakeVisible (&amp;slider2);
  addAndMakeVisible (&amp;toggle1);
  
  setSize (400, 200);
}

void MainContentComponent::resized()
{
  slider1.setBounds (10, 10, getWidth() - 20, 20);
  slider2.setBounds (10, 40, getWidth() - 20, 20);
  toggle1.setBounds (10, 70, getWidth() - 20, 20);
}

void MainContentComponent::buttonClicked (Button* button)
{
  if (&amp;toggle1 == button)
  {
    if (toggle1.getToggleState()) {
      slider1.setSliderStyle (Slider::LinearBar);
      slider2.setSliderStyle (Slider::LinearBar);
    } else {
      slider1.setSliderStyle (Slider::LinearHorizontal);
      slider2.setSliderStyle (Slider::LinearHorizontal);
    }
  }
}</pre></div></li></ul></div><p>This example uses a <code class="literal">ToggleButton</code> object<a id="id101" class="indexterm"/> and checks its toggle state in the <code class="literal">buttonClicked()</code> function<a id="id102" class="indexterm"/> using the <code class="literal">getToggleState()</code> function<a id="id103" class="indexterm"/>. One obvious customization yet to be discussed is changing the colors of the various elements within the built-in components. This will be covered in the next section.</p></div>
<div class="section" title="Specifying colors"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Specifying colors</h1></div></div></div><p>Colors in <a id="id104" class="indexterm"/>JUCE are handled by the <code class="literal">Colour</code> and <code class="literal">Colours</code> classes (<span class="emphasis"><em>note the British spelling of these two class names</em></span>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Colour</code> class stores a 32-bit color with 8-bit alpha, red, green, and blue values (<span class="strong"><strong>ARGB</strong></span>). A <code class="literal">Colour</code> object may be initialized from other formats (for example, using floating point values, or values in the <span class="strong"><strong>HSV</strong></span> format).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Colour</code> class includes a number of utilities for creating new colors from existing ones, for example, by modifying the alpha channel, changing only the brightness or finding a suitable contrasting color.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Colours</code> class is a collection of static <code class="literal">Colour</code> instances (for example, <code class="literal">Colour::red</code>, <code class="literal">Colour::cyan</code>). These are based broadly on the naming scheme of colors in the <span class="strong"><strong>HyperText Markup Language</strong></span> (<span class="strong"><strong>HTML</strong></span>) standard.</li></ul></div><p>For example, the following code snippet illustrates several different ways of creating the same "red" color:</p><div class="informalexample"><pre class="programlisting">Colour red1 = Colours::red;        // using Colours
Colour red2 = Colour (0xffff0000); // using hexadecimal ARGB
Colour red3 = Colour (255, 0, 0);  // using 8-bit RGB values
Colour red4 = Colour::fromFloatRGBA (1.f, 0.f, 0.f, 1.f); // float
Colour red5 = Colour::fromHSV (0.f, 1.f, 1.f, 1.f);       // HSV</pre></div><p>Component classes employ an ID system to refer to the various colors they use for different purposes (background, border, text, and so on). To use these colors to change the appearance of a component, the <code class="literal">Component::setColour()</code> function is used:</p><div class="informalexample"><pre class="programlisting">void setColour (int colourId, Colour newColour);</pre></div><p>For example, to change the color of a slider's thumb (which is the draggable part), the ID is the <code class="literal">Slider::thumbColourId</code> constant (this too changes the fill color that represents the slider's value when the slider style is set to the <code class="literal">Slider::LinearBar</code> constant). You can test this in the <code class="literal">Chapter02_04</code> project by adding the following highlighted lines to the constructor:</p><div class="informalexample"><pre class="programlisting">MainContentComponent::MainContentComponent()
: slider1 (Slider::LinearHorizontal, Slider::TextBoxLeft),
  slider2 (Slider::LinearHorizontal, Slider::TextBoxLeft),
  toggle1 ("Slider style: Linear Bar")
{
  <span class="strong"><strong>slider1.setColour (Slider::thumbColourId, Colours::red);</strong></span>
  <span class="strong"><strong>slider2.setColour (Slider::thumbColourId, Colours::red);</strong></span>
  toggle1.addListener (this);
    
  addAndMakeVisible (&amp;slider1);
  addAndMakeVisible (&amp;slider2);
  addAndMakeVisible (&amp;toggle1);
  
  setSize (400, 200);
}</pre></div><p>The final look <a id="id105" class="indexterm"/>of this application showing both types of slider is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3316_02_03.jpg" alt="Specifying colors"/></div><div class="section" title="Component color IDs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Component color IDs</h2></div></div></div><p>Many built-in components define their <a id="id106" class="indexterm"/>own color ID constants; the most useful are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::backgroundColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::thumbColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::trackColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::rotarySliderFillColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::rotarySliderOutlineColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::textBoxTextColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::textBoxBackgroundColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::textBoxHighlightColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider::textBoxOutlineColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Label::backgroundColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Label::textColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Label::outlineColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ToggleButton::textColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextButton::buttonColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextButton::buttonOnColourId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextButton::textColourOffId</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextButton::textColourOnId</code></li></ul></div><p>Each of these<a id="id107" class="indexterm"/> enumerated constants is defined in the class in which they are used. There are many others for each of the component types.</p></div><div class="section" title="Setting colors using the LookAndFeel class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Setting colors using the LookAndFeel class</h2></div></div></div><p>If you <a id="id108" class="indexterm"/>have many controls and want to set unified colors for all of them, then it is likely to be more convenient to set the color at some other point in the component hierarchy. This is one purpose of the JUCE <code class="literal">LookAndFeel</code> class. This was seen briefly in <a class="link" href="ch01.html" title="Chapter 1. Installing JUCE and the Introjucer Application">Chapter 1</a>, <span class="emphasis"><em>Installing JUCE and the Introjucer Application</em></span> where the different styles of the various widgets can be selected by using a different look and feel. If this is to be a global change across the whole application then the best place to put this change is likely to be in the initialization code. To try this, remove the following two lines of code from your project, which were added in the previous step:</p><div class="informalexample"><pre class="programlisting">  slider1.setColour (Slider::thumbColourId, Colours::red);
  slider2.setColour (Slider::thumbColourId, Colours::red);</pre></div><p>Navigate to the <code class="literal">Main.cpp</code> file. Now add the following lines to the <a id="id109" class="indexterm"/>
<code class="literal">initialise()</code> function (<span class="emphasis"><em>again notice the British spelling</em></span>).</p><div class="informalexample"><pre class="programlisting">void initialise (const String&amp; commandLine)
{
  <span class="strong"><strong>LookAndFeel&amp; lnf = LookAndFeel::getDefaultLookAndFeel();</strong></span>
<span class="strong"><strong>lnf.setColour (Slider::thumbColourId, Colours::red);</strong></span>
  mainWindow = new MainWindow();
}</pre></div><p>It should be clear that an extended list of colors could be configured at this point to customize the application's appearance. Another technique, that again uses the <code class="literal">LookAndFeel</code> class, is to inherit from the default <code class="literal">LookAndFeel</code> class and update colors in this derived class. Setting a particular look and feel for a component affects all child components in its hierarchy. Therefore, this method would allow you to set colors selectively in different parts of an application. A solution that uses this method is shown as follows, with the important parts highlighted:</p><p>
<span class="strong"><strong>The MainComponent.h file</strong></span>:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent :  public Component,
                              public Button::Listener
{
public:
  MainContentComponent();
  void resized();
  
  void buttonClicked (Button* button);
  
<span class="strong"><strong>  class AltLookAndFeel : public LookAndFeel</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>  public:</strong></span>
<span class="strong"><strong>    AltLookAndFeel()</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      setColour (Slider::thumbColourId, Colours::red);</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  };</strong></span>
private:
  Slider slider1;
  Slider slider2;
  ToggleButton toggle1;
  <span class="strong"><strong>AltLookAndFeel altLookAndFeel;</strong></span>
};
#endif</pre></div><p>In the <code class="literal">MainComponent.cpp</code> file only the constructor needs updating:</p><div class="informalexample"><pre class="programlisting">MainContentComponent::MainContentComponent()
: slider1 (Slider::LinearHorizontal, Slider::TextBoxLeft),
  slider2 (Slider::LinearHorizontal, Slider::TextBoxLeft),
  toggle1 ("Slider style: Linear Bar")
{
  <span class="strong"><strong>setLookAndFeel (&amp;altLookAndFeel);</strong></span>
  toggle1.addListener (this);

  addAndMakeVisible (&amp;slider1);
  addAndMakeVisible (&amp;slider2);
  addAndMakeVisible (&amp;toggle1);
  
  setSize (400, 200);
}</pre></div><p>Here, we create a nested class <code class="literal">AltLookAndFeel</code> that is based on the default <code class="literal">LookAndFeel</code> class. This is defined as a nested class, because we need to only refer to it from within a <code class="literal">MainContentComponent</code> instance. It might be more appropriate to define this class <a id="id110" class="indexterm"/>outside the <code class="literal">MainContentComponent</code> class if the <code class="literal">AltLookAndFeel</code> becomes a more extended class or needs to be reused by other component classes that we write.</p><p>In the <code class="literal">AltLookAndFeel</code> constructor, we set the color of the slider thumb. Finally, we set the look and feel for the <code class="literal">MainContentComponent</code> class in its constructor. There are clearly many other possible techniques using this handful of tools, and the exact approach is heavily dependent on the specific application features being developed. It is important to note that the <code class="literal">LookAndFeel</code> class not only deals with colors, but also more broadly enables you to configure the exact way in which certain user interface elements are drawn. Not only can you change the color of the slider thumb, you can change its radius (by overriding the <code class="literal">LookAndFeel::getSliderThumbRadius()</code> function) or even change its shape altogether (by overriding the <code class="literal">LookAndFeel::drawLinearSliderThumb()</code> function).</p></div></div>
<div class="section" title="Using drawing operations"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Using drawing operations</h1></div></div></div><p>Although it<a id="id111" class="indexterm"/> is advisable to use the built-in components if possible, there are occasions where you may need or wish to create a completely new custom component. This may be to perform some specific drawing tasks or a unique user interface item. JUCE also handles this elegantly.</p><p>First, create a new Introjucer project and name it <code class="literal">Chapter02_05</code>. To perform drawing tasks in a component, you should override the <code class="literal">Component::paint()</code> function. Change the contents of the <code class="literal">MainComponent.h</code> file to:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent :  public Component
{
public:
  MainContentComponent();
  void paint (Graphics&amp; g);
};
#endif</pre></div><p>Change the contents of the <code class="literal">MainComponent.cpp</code> file to:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  setSize (200, 200);
}

void MainContentComponent::paint (Graphics&amp; g)
{
  g.fillAll (Colours::cornflowerblue);
}</pre></div><p>Build <a id="id112" class="indexterm"/>and run the application to see the resulting empty window filled with a blue color.</p><p>The <code class="literal">paint()</code> function<a id="id113" class="indexterm"/> is called when the component needs to redraw itself. This might be due to the component having been resized (which of course you can try out using the corner resizer), or specific calls to invalidate the display (for example, the component displays visual representation of a value and this is no longer the currently stored value). The <code class="literal">paint()</code> function is passed a reference to a <code class="literal">Graphics</code> object. It is this <code class="literal">Graphics</code> object that you instruct to perform your drawing tasks. The <code class="literal">Graphics::fillAll()</code> function used in the code above should be self-explanatory: it fills the entire component with the specified color. The <code class="literal">Graphics</code> object can draw rectangles, ellipses, rounded rectangles, lines (in various styles), curves, text (with numerous shortcuts for fitting or truncating text within particular areas) and images.</p><p>The next example illustrates drawing a collection of random rectangles using random colors. Change the <code class="literal">paint()</code> function in the <code class="literal">MainComponent.cpp</code> file to:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::paint (Graphics&amp; g)
{
  Random&amp; r (Random::getSystemRandom());
  g.fillAll (Colours::cornflowerblue);
  
  for (int i = 0; i &lt; 20; ++i) {
    g.setColour (Colour (r.nextFloat(),
                         r.nextFloat(),
                         r.nextFloat(),
                         r.nextFloat()));
    
    const int width = r.nextInt (getWidth() / 4);
    const int height = r.nextInt (getHeight() / 4);
    const int left = r.nextInt (getWidth() - width);
    const int top = r.nextInt (getHeight() - height);
    
    g.fillRect (left, top, width, height);
  }
}</pre></div><p>This makes use of multiple calls to the JUCE random number generator class <code class="literal">Random</code>. This is a convenient class that allows the generation of pseudo-random integers and floating-point numbers. You can make your own instance of a <code class="literal">Random</code> object (which is recommend if your application uses random numbers in multiple threads), but here we simply take a copy of a reference to a global "system" <code class="literal">Random</code> object (using the <code class="literal">Random::getSystemRandom()</code> function) and use it multiple times. Here, we fill the component with a blue background and generate 20 rectangles. The color is generated from randomly generated floating point ARGB values. The call to the <code class="literal">Graphics::setColour()</code> function sets the current drawing color that will be employed by subsequent drawing commands. A randomly generated rectangle is also created by first choosing width and<a id="id114" class="indexterm"/> height (each being a maximum value of one-quarter of the parent component's width and height respectively). Then the position of the rectangle is randomly selected; again this is done using the parent component's width and height but this time subtracting the width and height of our random rectangle to ensure its right and bottom edges are not off-screen. As mentioned previously, the <code class="literal">paint()</code> function is called each time the component needs to be redrawn. This means we will get a completely new set of random rectangles as the component is resized.</p><p>Changing the drawing command to <code class="literal">fillEllipse()</code> rather than <code class="literal">fillRect()</code> draws a collection of ellipses instead. Lines can be drawn in various ways. Change the <a id="id115" class="indexterm"/>
<code class="literal">paint()</code> function as follows:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::paint (Graphics&amp; g)
{
  Random&amp; r (Random::getSystemRandom());
  g.fillAll (Colours::cornflowerblue);

<span class="strong"><strong>  const float lineThickness = r.nextFloat() * 5.f + 1.f;</strong></span>
  for (int i = 0; i &lt; 20; ++i) {
    g.setColour (Colour (r.nextFloat(),
                         r.nextFloat(),
                         r.nextFloat(),
                         r.nextFloat()));
    
<span class="strong"><strong>    const float startX = r.nextFloat() * getWidth();</strong></span>
<span class="strong"><strong>    const float startY = r.nextFloat() * getHeight();</strong></span>
<span class="strong"><strong>    const float endX = r.nextFloat() * getWidth();</strong></span>
<span class="strong"><strong>    const float endY = r.nextFloat() * getHeight();</strong></span>
<span class="strong"><strong/></span>
<span class="strong"><strong>    g.drawLine (startX, startY,</strong></span>
<span class="strong"><strong>                endX, endY,</strong></span>
<span class="strong"><strong>                lineThickness);</strong></span>
  }
}</pre></div><p>Here, we choose a random line thickness (between one and six pixels wide) before the <code class="literal">for()</code> loop and use <a id="id116" class="indexterm"/>it for each line. The start and end positions of the lines are also randomly generated. To draw a continuous line there are a number of options, you could:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">store the last end point of the line and use this as the start point of the next line; or</li><li class="listitem" style="list-style-type: disc">use a JUCE <code class="literal">Path</code> object to build a series of line drawing commands and draw the path in one pass.</li></ul></div><p>The first solution would be something like this:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::paint (Graphics&amp; g)
{
  Random&amp; r (Random::getSystemRandom());
  g.fillAll (Colours::cornflowerblue);

  const float lineThickness = r.nextFloat() * 5.f + 1.f;
  
<span class="strong"><strong>  float x1 = r.nextFloat() * getWidth();</strong></span>
<span class="strong"><strong>  float y1 = r.nextFloat() * getHeight();</strong></span>
  for (int i = 0; i &lt; 20; ++i) {
    g.setColour (Colour (r.nextFloat(),
                         r.nextFloat(),
                         r.nextFloat(),
                         r.nextFloat()));
    
<span class="strong"><strong>    const float x2 = r.nextFloat() * getWidth();</strong></span>
<span class="strong"><strong>    const float y2 = r.nextFloat() * getHeight();</strong></span>
<span class="strong"><strong>    g.drawLine (x1, y1, x2, y2, lineThickness);</strong></span>
<span class="strong"><strong>    x1 = x2;</strong></span>
<span class="strong"><strong>    y1 = y2;</strong></span>
  }
}</pre></div><p>The second option is slightly different; in particular, each of the lines that make up the path must be same color:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::paint (Graphics&amp; g)
{
  Random&amp; r (Random::getSystemRandom());
  g.fillAll (Colours::cornflowerblue);
  
<span class="strong"><strong>  Path path;</strong></span>
<span class="strong"><strong>  path.startNewSubPath (r.nextFloat() * getWidth(),</strong></span>
<span class="strong"><strong>                        r.nextFloat() * getHeight());</strong></span>
  for (int i = 0; i &lt; 20; ++i) {
<span class="strong"><strong>    path.lineTo (r.nextFloat() * getWidth(),</strong></span>
<span class="strong"><strong>                 r.nextFloat() * getHeight());</strong></span>
  }
  
  <span class="strong"><strong>g.setColour (Colour (r.nextFloat(),</strong></span>
<span class="strong"><strong>                       r.nextFloat(),</strong></span>
<span class="strong"><strong>                       r.nextFloat(),</strong></span>
<span class="strong"><strong>                       r.nextFloat()));</strong></span>
<span class="strong"><strong/></span>
<span class="strong"><strong>  const float lineThickness = r.nextFloat() * 5.f + 1.f;</strong></span>
<span class="strong"><strong>  g.strokePath (path, PathStrokeType (lineThickness));</strong></span>
}</pre></div><p>Here the path<a id="id117" class="indexterm"/> is created before the <code class="literal">for()</code> loop and each iteration of the loop adds a line segment to the path. These two approaches to line drawing clearly suit different applications. The path drawing technique is heavily customizable, in particular:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The joints at the corners of the line segments can be customized with the <code class="literal">PathStrokeType</code> class (for example, to make the corners slightly rounded).</li><li class="listitem" style="list-style-type: disc">The lines need not be straight: they can be Bezier curves.</li><li class="listitem" style="list-style-type: disc">The path may include other fundamental shapes such as rectangles, ellipses, stars, arrows and so on.</li></ul></div><p>In addition to these line drawing commands, there are accelerated functions specifically for drawing horizontal and vertical lines (that is, non-diagonal). These are the <code class="literal">Graphics::drawVerticalLine()</code> and <code class="literal">Graphics::drawHorizontalLine()</code> functions.</p><div class="section" title="Intercepting mouse activity"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Intercepting mouse activity</h2></div></div></div><p>To help <a id="id118" class="indexterm"/>your component respond to mouse interaction, the <code class="literal">Component</code> class has six important callback functions that you can override:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mouseEnter()</code>: Called when<a id="id119" class="indexterm"/> the mouse pointer enters the bounds of this component and the mouse buttons are <span class="emphasis"><em>up</em></span>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseMove()</code>: Called when <a id="id120" class="indexterm"/>the mouse pointer moves within the bounds of this component and the mouse buttons are <span class="emphasis"><em>up</em></span>. A <code class="literal">mouseEnter()</code> callback will always have been received first.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseDown()</code>: Called when <a id="id121" class="indexterm"/>one or more mouse buttons are pressed while the mouse pointer is over this component. A <code class="literal">mouseEnter()</code> callback will always have been received first and it is highly likely one or more <code class="literal">mouseMove()</code> callbacks will have been received too.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseDrag()</code>: <a id="id122" class="indexterm"/>Called when the mouse pointer is moved following a <code class="literal">mouseDown()</code> callback on this component. The position of the mouse pointer may be outside the bounds of the component.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseUp()</code>: Called when <a id="id123" class="indexterm"/>the mouse button is released following a <code class="literal">mouseDown()</code> callback on this component (the mouse pointer will not necessarily be over this component at this time).</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseExit()</code>: Called when<a id="id124" class="indexterm"/> the mouse pointer leaves the bounds of this component when the mouse buttons are <span class="emphasis"><em>up</em></span> and after a <code class="literal">mouseUp()</code> callback if the user has clicked on this component (even if the mouse pointer exited the bounds of this component some time ago).</li></ul></div><p>In each <a id="id125" class="indexterm"/>of these cases, the callbacks are passed a reference to a <code class="literal">MouseEvent</code> object that can provide information about the current state of the mouse (where it was at the time of the event, when the event occurred, which modifier keys on the keyboard were down, which mouse buttons were down, and so on). In fact, although these classes and function names refer to the "mouse" this system can handle multi-touch events and the <code class="literal">MouseEvent</code> object can be ask which "finger" was involved in such cases (for example, on the iOS platform).</p><p>To experiment with these callbacks, create a new Introjucer project and name it <code class="literal">Chapter02_06</code>. Use the following code for this project.</p><p>The<code class="literal"> MainComponent.h</code> file declares the class with its various member functions and data:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component
{
public:
  MainContentComponent();
  void paint (Graphics&amp; g);

  void mouseEnter (const MouseEvent&amp; event);
  void mouseMove (const MouseEvent&amp; event);
  void mouseDown (const MouseEvent&amp; event);
  void mouseDrag (const MouseEvent&amp; event);
  void mouseUp (const MouseEvent&amp; event);
  void mouseExit (const MouseEvent&amp; event);
  
  void handleMouse (const MouseEvent&amp; event);
  
private:
  String text;
  int x, y;
};
#endif</pre></div><p>The<code class="literal"> MainComponent.cpp</code> file should contain the following code. First, add the constructor<a id="id126" class="indexterm"/> and the <code class="literal">paint()</code> function. The <code class="literal">paint()</code> function draws a yellow circle at the mouse position and some text showing the current phase of the mouse interaction:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: x (0), y (0)
{
  setSize (200, 200);
}

void MainContentComponent::paint (Graphics&amp; g)
{  
  g.fillAll (Colours::cornflowerblue);
  g.setColour (Colours::yellowgreen);
  g.setFont (Font (24));
  g.drawText (text, 0, 0, getWidth(), getHeight(),
              Justification::centred, false);
  g.setColour (Colours::yellow);
  const float radius = 10.f;
  g.fillEllipse (x - radius, y - radius,
                 radius * 2.f, radius * 2.f);
}</pre></div><p>Then add the mouse event callbacks and our <code class="literal">handleMouse()</code> function described as follows. We store the coordinates of the mouse callbacks with reference to our component and store a <code class="literal">String</code> object based on the type of callback (mouse down, up, move, and so on). Because the storage of the coordinates is the same in each case, we use the <code class="literal">handleMouse()</code> function, which stores the coordinates from the <code class="literal">MouseEvent</code> object in our class member variables <code class="literal">x</code> and <code class="literal">y</code>, and pass this <code class="literal">MouseEvent</code> object from the callbacks. To ensure that the component redraws itself, we must call the <code class="literal">Component::repaint()</code> function.</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::mouseEnter (const MouseEvent&amp; event)
{
  text = "mouse enter";
  handleMouse (event);
}

void MainContentComponent::mouseMove (const MouseEvent&amp; event)
{
  text = "mouse move";
  handleMouse (event);
}

void MainContentComponent::mouseDown (const MouseEvent&amp; event)
{
  text = "mouse down";
  handleMouse (event);
}

void MainContentComponent::mouseDrag (const MouseEvent&amp; event)
{
  text = "mouse drag";
  handleMouse (event);
}

void MainContentComponent::mouseUp (const MouseEvent&amp; event)
{
  text = "mouse up";
  handleMouse (event);
}

void MainContentComponent::mouseExit (const MouseEvent&amp; event)
{
  text = "mouse exit";
  handleMouse (event);
}

void MainContentComponent::handleMouse (const MouseEvent&amp; event)
{
  x = event.x;
  y = event.y;
  repaint();
}</pre></div><p>As shown in <a id="id127" class="indexterm"/>the following screenshot, the result is a yellow circle that sits under our mouse pointer and a text message in the center of the window that gives feedback as to the type of mouse event most recently received:</p><div class="mediaobject"><img src="graphics/3316_02_04.jpg" alt="Intercepting mouse activity"/></div></div></div>
<div class="section" title="Configuring complex component arrangements"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Configuring complex component arrangements</h1></div></div></div><p>JUCE makes <a id="id128" class="indexterm"/>it straightforward to create custom components either by combining several built-in components or through providing an effective means of interacting with pointing devices combined with a range of fundamental drawing commands. In addition to this, the Introjucer application provides a graphical editor for laying out custom components. This will then autogenerate the code required to rebuild this interface in your application. Create a new Introjucer project as earlier, with a basic window, and name it <code class="literal">Chapter02_07</code>.</p><p>Switch to <a id="id129" class="indexterm"/>the <span class="strong"><strong>Files</strong></span> panel, right-click (on the Mac, press <span class="emphasis"><em>control</em></span> and click) on the <span class="strong"><strong>Source</strong></span> folder in the hierarchy, and select <span class="strong"><strong>Add New GUI Component…</strong></span> from the contextual menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3316_02_05.jpg" alt="Configuring complex component arrangements"/></div><p>You will be asked to name the header file, which also names the corresponding <code class="literal">.cpp</code> file. Name the header file <code class="literal">CustomComponent.h</code>. When you select a <code class="literal">.cpp</code> file created in this way, you are offered several ways of editing the file. In particular you can add child components, add <a id="id130" class="indexterm"/>drawing commands, or you can edit the code directly. Select the <code class="literal">CustomComponent.cpp</code> file, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3316_02_06.jpg" alt="Configuring complex component arrangements"/></div><p>In the <span class="strong"><strong>Subcomponents</strong></span> panel, you can right-click on the grid to add one of the several built-in component types. Add in a few buttons and sliders. Each of these can be edited when selected using the properties on the right-hand side of the window. What is particularly useful here is the ability to set complex rules about the positioning of the components relative to each other and the parent component. Some of the options for this are visible in the following screenshot:</p><div class="mediaobject"><img src="graphics/3316_02_07.jpg" alt="Configuring complex component arrangements"/></div><p>Because the Introjucer application generates C++ code, it should be clear that these options are clearly available programmatically. For some tasks, especially complex GUIs, using the GUI editor <a id="id131" class="indexterm"/>may be more convenient. It is also a useful way of discovering features available in the various component classes and the corresponding code to enable and control these features.</p><p>Before opening the project in your IDE, select the <span class="strong"><strong>Class</strong></span> panel (using the tab to the left of the <span class="strong"><strong>Subcomponents</strong></span> tab) and change the <span class="strong"><strong>class name</strong></span> from <code class="literal">NewComponent</code> to <code class="literal">CustomComponent</code> (to match the filenames of the code). Save the Introjucer project and open its IDE project for your platform. You <a id="id132" class="indexterm"/>need make only a few minor modifications to load this auto-generated code into your <code class="literal">MainContentComponent</code> class. Change the <code class="literal">MainComponent.h</code> file as follows:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"
#include "CustomComponent.h"

class MainContentComponent   : public Component
{
public:
  MainContentComponent();

private:
  CustomComponent custom;
};
#endif</pre></div><p>Then, change the <code class="literal">MainComponent.cpp</code> file to:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  addAndMakeVisible (&amp;custom);
  setSize (custom.getWidth(), custom.getHeight());
}</pre></div><p>This allocates a <code class="literal">CustomComponent</code> object and makes it fill the bounds of the <code class="literal">MainContentComponent</code> object. Build and run the application, and you should see whatever user interface you designed in the Introjucer application's GUI editor. The Introjucer application <a id="id133" class="indexterm"/>takes special control of the source files for these autogenerated GUI controls. Take a look in the <code class="literal">CustomComponent.h</code> and <code class="literal">CustomComponent.cpp</code> files. There will be some code you recognize from earlier in this chapter (one major difference is that the Introjucer application generates code to allocate the subcomponent classes dynamically, rather than using static allocation as we have done here). You must be very careful when editing code in these autogenerated GUI files, because loading the project back into the Introjucer application may overwrite some of your changes (which doesn't happen with regular code files). The Introjucer application identifies areas where you <span class="emphasis"><em>may</em></span> make changes using specially tagged opening and closing comments. For example, this is the end of a typical autogenerated component constructor:</p><div class="informalexample"><pre class="programlisting">... 
    //[UserPreSize]
    //[/UserPreSize]

    setSize (600, 400);

    //[Constructor] You can add your own custom stuff here..
    //[/Constructor]
}</pre></div><p>You <span class="emphasis"><em>may</em></span> make <a id="id134" class="indexterm"/>changes and add code in between the opening <code class="literal">[UserPreSize]</code> tag and closing <code class="literal">[/UserPreSize]</code> tag and between the opening <code class="literal">[Constructor]</code> tag and closing <code class="literal">[/Constructor]</code> tag. In fact you can make edits between any of these opening and closing tags <span class="emphasis"><em>but not anywhere else</em></span>. Doing so risks your changes being deleted if and when the Introjucer project is next saved to disk. This applies if you add another build target, add another GUI component, add other files to the Introjucer project, and where you explicitly save the project in the Introjucer application.</p><div class="section" title="Other component types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Other component types</h2></div></div></div><p>JUCE comprises a <a id="id135" class="indexterm"/>wide range of other component types for particular tasks. Many of these will be familiar, as similar controls are available within many operating systems and other GUI frameworks. In particular:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Buttons</strong></span>: There are several button types, including buttons that can be created using image files and other shapes (for example, <code class="literal">ImageButton</code>, and <code class="literal">ShapeButton</code> classes); there is a <code class="literal">ToolbarButton</code> class<a id="id136" class="indexterm"/> that can be used to create toolbars.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Menus</strong></span>: There is a <code class="literal">PopupMenu</code> class<a id="id137" class="indexterm"/> (for issuing commands) and a <code class="literal">ComboBox</code> class (for selecting items).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layout</strong></span>: There are various classes for organizing other components including a <code class="literal">TabbedComponent</code> class<a id="id138" class="indexterm"/> (for creating tabbed pages), a <code class="literal">ViewPort</code> class (for creating scrollable content), a <code class="literal">TableListBox</code> class<a id="id139" class="indexterm"/> (for creating tables), and a <code class="literal">TreeView</code> class<a id="id140" class="indexterm"/> (for organizing content in to a hierarchical structure).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>File browsers</strong></span>: There are various ways of displaying and accessing file directory structures including the <code class="literal">FileChooser</code><a id="id141" class="indexterm"/>, <code class="literal">FileNameComponent</code><a id="id142" class="indexterm"/>, and <code class="literal">FileTreeComponent</code><a id="id143" class="indexterm"/> classes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Text editors</strong></span>: There is a general-purpose <code class="literal">TextEditor</code> class,<a id="id144" class="indexterm"/> and a <code class="literal">CodeEditorComponent</code> for displaying and editing code.</li></ul></div><p>Most of source code for these components can be found in <code class="literal">juce/modules/juce_gui_basics</code> with some additional classes being found in <code class="literal">juce/modules/juce_gui_extra</code>. All classes are documented in the online documentation. An alphabetical list of all classes can be found here:</p><p>
<a class="ulink" href="http://www.juce.com/api/annotated.html">http://www.juce.com/api/annotated.html</a>
</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>By the end of this chapter you should be familiar with the principles of building user interfaces in JUCE both programmatically and via the Introjucer application. This chapter has shown you how to create and use JUCE's built-in components, how to construct custom components, and how to perform fundamental drawing operations on-screen. You should read the online documentation for each class introduced during this chapter. You should also examine the code bundle for this book that contains each of the examples developed in this chapter. The code in this bundle also includes more inline comments for each of the examples. The next chapter covers a range of non-GUI classes although many of these will be useful for managing some elements of user interface functionality.</p></div></body></html>