<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Rendering 2D Graphics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Rendering 2D Graphics</h1></div></div></div><p>One of the biggest aspects in a video game is the graphics. It's why we call them video games after all! So how do we create images on the screen? As we did with user input in the previous chapter, we <a id="id153" class="indexterm"/>have a couple of options here. They are <span class="strong"><strong>Direct2D</strong></span> and <span class="strong"><strong>Direct3D</strong></span>
<a id="id154" class="indexterm"/>. We will focus on Direct2D in this chapter and save Direct3D for a later chapter.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a Direct2D game window class</li><li class="listitem" style="list-style-type: disc">Drawing a rectangle on the screen</li><li class="listitem" style="list-style-type: disc">Creating a 2D tile-based game world and entities</li></ul></div><div class="section" title="Creating a Direct2D game window class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Creating a Direct2D game window class</h1></div></div></div><p>We are finally <a id="id155" class="indexterm"/>ready to put some graphics on the screen! The first step for us is to create a new game window class that will use Direct2D. This new game window class will derive from our original game window class, while adding the Direct2D functionality.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>You'll need to download the code for this chapter as some code is omitted to save space.</p></div></div><p>Open Visual Studio and we will get started with our <code class="literal">Ch03</code> project. Add a new class to the <code class="literal">Ch03</code> project called <code class="literal">GameWindow2D</code>. We need to change its declaration to:</p><div class="informalexample"><pre class="programlisting">public class GameWindow2D : GameWindow, IDispoable</pre></div><p>As you can see, it inherits from the <code class="literal">GameWindow</code> class meaning that it has all of the public and protected members of the <code class="literal">GameWindow</code> class, as though we had implemented them again in this class. It also implements the <code class="literal">IDisposable</code> interface, just as the <code class="literal">GameWindow</code> class does. Also, don't forget to add a reference to SlimDX to this project if you haven't already.</p><p>We need to <a id="id156" class="indexterm"/>add some <code class="literal">using</code> statements to the top of this class file as well. They are all the same <code class="literal">using</code> statements that the <code class="literal">GameWindow</code> class has, plus one more. The new one is <code class="literal">SlimDX.Direct2D</code>. They are as follows:</p><div class="informalexample"><pre class="programlisting">using System.Windows.Forms;
using System.Diagnostics;
using System.Drawing;
using System;
using SlimDX;
using SlimDX.Direct2D;
using SlimDX.Windows;</pre></div><p>Next, we need to create a handful of member variables:</p><div class="informalexample"><pre class="programlisting">WindowRenderTarget m_RenderTarget;
Factory m_Factory;
PathGeometry m_Geometry;
SolidColorBrush m_BrushRed;
SolidColorBrush m_BrushGreen;
SolidColorBrush m_BrushBlue;</pre></div><p>The first variable is a <code class="literal">WindowRenderTarget</code> object. The term <span class="strong"><strong>render target</strong></span> is used to refer to the <a id="id157" class="indexterm"/>surface we are going to draw on. In this case, it is our game window. However, this is not always the case. Games can render to other places as well. For example, rendering into a texture object is used to create various effects. One example would be a simple security camera effect. Say, we have a security camera in one room and a monitor in another room. We want the monitor to display what our security camera sees. To do this, we can render the camera's view into a texture, which can then be used to texture the screen of the monitor. Of course, this has to be re-done in every frame so that the monitor screen shows what the camera is currently seeing. This idea is useful in 2D too.</p><p>Back to our member variables, the second one is a <code class="literal">Factory</code> object that we will be using to set up our Direct2D stuff. It is used to create Direct2D resources such as <code class="literal">RenderTargets</code>. The third variable is a <code class="literal">PathGeometry</code> object that will hold the geometry for the first thing we will draw, which will be a rectangle. The last three variables are all <code class="literal">SolidColorBrush</code> objects. We use these to specify the color we want to draw something with. There is a little more to them than that, but that's all we need right now.</p><div class="section" title="The constructor"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>The constructor</h2></div></div></div><p>Let's turn our <a id="id158" class="indexterm"/>attention now to the constructor of<a id="id159" class="indexterm"/> our Direct2D game window class. It will do two things. Firstly, it will call the base class constructor (remember the base class is the original <code class="literal">GameWindow</code> class), and it will then get our Direct2D stuff initialized. The following is the initial code for our constructor:</p><div class="informalexample"><pre class="programlisting">public GameWindow2D(string title, int width, int height,bool fullscreen)
    : base(title, width, height, fullscreen)
{
    m_Factory = new Factory();

    WindowRenderTargetProperties properties = new WindowRenderTargetProperties();
    properties.Handle = FormObject.Handle;
    properties.PixelSize = new Size(width, height);

    m_RenderTarget = new WindowRenderTarget(m_Factory, properties);
}</pre></div><p>In the preceding code, the line starting with a colon is calling the constructor of the base class for us. This ensures that everything inherited from the base class is initialized. In the body of the constructor, the first line creates a new <code class="literal">Factory</code> object and stores it in our <code class="literal">m_Factory</code> member variable. Next, we create a <code class="literal">WindowRenderTargetProperties</code> object and store the handle of our <code class="literal">RenderForm</code> object in it. Note that <code class="literal">FormObject</code> is one of the properties defined in our <code class="literal">GameWindow</code> base class in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, but it is one of those properties that we haven't discussed in detail in the book. You can see it in the downloadable code for this book. Remember that the <code class="literal">RenderForm</code> object is a SlimDX object that represents a window for us to draw on. The next line saves the size of our game window in the <code class="literal">PixelSize</code> property. The <code class="literal">WindowRenderTargetProperties</code> object is basically how we specify the initial configuration for a <code class="literal">WindowRenderTarget</code> object when we create it. The last line in our constructor creates our <code class="literal">WindowRenderTarget</code> object, storing it in our <code class="literal">m_RenderTarget</code> member variable. The two parameters we pass in are our <code class="literal">Factory</code> object and the <code class="literal">WindowRenderTargetProperties</code> object we just created. A <code class="literal">WindowRenderTarget</code> object is a render target that refers to the client area of a window. We use the <code class="literal">WindowRenderTarget</code> object to draw in a window.</p></div><div class="section" title="Creating our rectangle"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Creating our rectangle</h2></div></div></div><p>Now that <a id="id160" class="indexterm"/>our render target is set up, we <a id="id161" class="indexterm"/>are ready to draw stuff, but first we need to create something to draw! So, we will add a bit more code at the bottom of our constructor. First, we need to initialize our three <code class="literal">SolidColorBrush</code> objects. Add these three lines of code at the bottom of the constructor:</p><div class="informalexample"><pre class="programlisting">m_BrushRed = new SolidColorBrush(m_RenderTarget, new Color4(1.0f, 1.0f, 0.0f, 0.0f));
m_BrushGreen = new SolidColorBrush(m_RenderTarget, new Color4(1.0f, 0.0f, 1.0f, 0.0f));
m_BrushBlue = new SolidColorBrush(m_RenderTarget, new Color4(1.0f, 0.0f, 0.0f, 1.0f));</pre></div><p>This code is fairly simple. For each brush, we pass in two parameters. The first parameter is the render target we will use this brush on. The second parameter is the color of the brush, which is an <span class="strong"><strong>ARGB</strong></span> (<span class="strong"><strong>Alpha Red Green Blue</strong></span>) value. The first parameter we give for the <a id="id162" class="indexterm"/>color is <code class="literal">1.0f</code>. The <code class="literal">f</code> character on <a id="id163" class="indexterm"/>the end indicates that this number is of the <code class="literal">float</code> data <a id="id164" class="indexterm"/>type. We set alpha to <code class="literal">1.0</code> because we want the brush to be completely opaque. A value of <code class="literal">0.0</code> will make it completely transparent, and a value of <code class="literal">0.5</code> will be 50 percent transparent. Next, we have the red, green, and blue parameters. These are all <code class="literal">float</code> values in the range of <code class="literal">0.0</code> to <code class="literal">1.0</code> as well. As you can see for the red brush, we set the red channel to <code class="literal">1.0f</code> and the green and blue channels are both set to <code class="literal">0.0f</code>. This means we have maximum red, but no green or blue in our color.</p><p>With our <code class="literal">SolidColorBrush</code> objects set up, we now have three brushes we can draw with, but we still lack something to draw! So, let's fix that by adding some code to make our rectangle. Add this code to the end of the constructor:</p><div class="informalexample"><pre class="programlisting">m_Geometry = new PathGeometry(m_RenderTarget.Factory);

using (GeometrySink sink = m_Geometry.Open())
{
    int top = (int) (0.25f * FormObject.Height);
    int left = (int) (0.25f * FormObject.Width);
    int right = (int) (0.75f * FormObject.Width);
    int bottom = (int) (0.75f * FormObject.Height);

    PointF p0 = new Point(left, top);
    PointF p1 = new Point(right, top);
    PointF p2 = new Point(right, bottom);
    PointF p3 = new Point(left, bottom);

    sink.BeginFigure(p0, FigureBegin.Filled);
    sink.AddLine(p1);
    sink.AddLine(p2);
    sink.AddLine(p3);
    sink.EndFigure(FigureEnd.Closed);
    sink.Close();
}</pre></div><p>This code is a bit longer, but it's still fairly simple. The first line creates a new <code class="literal">PathGeometry</code> object and stores it in our <code class="literal">m_Geometry</code> member variable. The next line starts the <code class="literal">using</code> block and creates a new <code class="literal">GeometrySink</code> object that we will use to build the geometry of our rectangle. The <code class="literal">using</code> block will automatically dispose of the <code class="literal">GeometrySink</code> object for us when program execution reaches the end of the <code class="literal">using</code> block.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">using</code> blocks only work with objects that implement the <code class="literal">IDisposable</code> interface.</p></div></div><p>The next four lines calculate where each edge of our rectangle will be. For example, the first line calculates the vertical position of the top edge of the rectangle. In this case, we are making the rectangle's top edge be 25 percent of the way down from the top of the screen. Then, we do the same thing for the other three sides of our rectangle. The second group of four lines of code creates four <code class="literal">Point</code> objects and initializes them using the values we just calculated. These four <code class="literal">Point</code> objects represent the corners of our rectangle. A <a id="id165" class="indexterm"/>point is also often referred to<a id="id166" class="indexterm"/> as a <a id="id167" class="indexterm"/>
<span class="strong"><strong>vertex</strong></span>. When we have more than one vertex, we call them <span class="strong"><strong>vertices</strong></span> (pronounced as <span class="emphasis"><em>vert-is-ces</em></span>).</p><p>The final group of code has six lines. They use the <code class="literal">GeometrySink</code> and the <code class="literal">Point</code> objects we just created to set up the geometry of our rectangle inside the <code class="literal">PathGeometry</code> object. The first line uses the <code class="literal">BeginFigure()</code> method to begin the creation of a new geometric figure. The <a id="id168" class="indexterm"/>next three lines each add one more line segment to the figure by adding another point or vertex to it. With all four vertices added, we then call the <code class="literal">EndFigure()</code> method to specify that we are done adding vertices. The last line calls the <code class="literal">Close()</code> method<a id="id169" class="indexterm"/> to specify that we are finished adding geometric figures, since we<a id="id170" class="indexterm"/> can have more than one if we want. In this case, we are only adding one geometric figure, our rectangle.</p></div><div class="section" title="Drawing our rectangle"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Drawing our rectangle</h2></div></div></div><p>Since our <a id="id171" class="indexterm"/>rectangle never changes, we don't need to add any code to our <a id="id172" class="indexterm"/>
<code class="literal">UpdateScene()</code> method. We will override the base <a id="id173" class="indexterm"/>class's <code class="literal">UpdateScene()</code> method anyway, in case we need to add some code in here later, which is given as follows:</p><div class="informalexample"><pre class="programlisting">public override void UpdateScene(double frameTime)
{
    base.UpdateScene(frameTime);
}</pre></div><p>As you can see, we only have one line of code in this <code class="literal">override</code> modifier of the base class's <code class="literal">UpdateScene()</code> method. It simply calls the base class version of this method. This is important because the base class's <code class="literal">UpdateScene()</code> method contains our code that gets the latest user input data each frame, as you may recall from the previous chapter.</p><p>Now, we <a id="id174" class="indexterm"/>are finally ready to write the code that will draw our rectangle<a id="id175" class="indexterm"/> on the screen! We will override the <a id="id176" class="indexterm"/>
<code class="literal">RenderScene()</code> method so we can add our custom code:</p><div class="informalexample"><pre class="programlisting">public override void RenderScene()

{
    if ((!this.IsInitialized) || this.IsDisposed)
    {
        return;
    }

    m_RenderTarget.BeginDraw();
    m_RenderTarget.Clear(ClearColor);
    m_RenderTarget.FillGeometry(m_Geometry, m_BrushBlue);
    m_RenderTarget.DrawGeometry(m_Geometry, m_BrushRed, 1.0f);
    m_RenderTarget.EndDraw();
}</pre></div><p>First, we have an <code class="literal">if</code> statement, which happens to be identical to the one we put in the base class's <code class="literal">RenderScene()</code> method. This is because we are not calling the base class's <code class="literal">RenderScene()</code> method, since the only code in it is this <code class="literal">if</code> statement. Not calling the base class version of this method will give us a slight performance boost, since we don't have the overhead of that function call. We could do the same thing with the <code class="literal">UpdateScene()</code> method as well. In this case we didn't though, because the base class version of that method has a lot more code in it. In your own projects you may want to copy and paste that code into your override of the <code class="literal">UpdateScene()</code> method.</p><p>The next line of code calls the render target's <code class="literal">BeginDraw()</code> method to tell it that we are ready to<a id="id177" class="indexterm"/> begin drawing. Then, we clear the screen on the next line by filling it with the color stored in the <code class="literal">ClearColor</code> property that is defined by our <code class="literal">GameWindow</code> base class. The last three lines draw our geometry twice. First, we draw it using the <code class="literal">FillGeometry()</code> method<a id="id178" class="indexterm"/> of our render target. This will draw our rectangle filled in with the specified brush (in this case, solid blue). Then, we draw the rectangle a second time, but this time with the <code class="literal">DrawGeometry()</code> method<a id="id179" class="indexterm"/>. This draws only the lines of our shape but doesn't fill it in, so this draws a border on our rectangle. The extra parameter on the <code class="literal">DrawGeometry()</code> method is optional and specifies the width of the lines we are drawing. We set it to <code class="literal">1.0f</code>, which means the lines will be one-pixel wide. And the last line calls the <a id="id180" class="indexterm"/>
<code class="literal">EndDraw()</code> method <a id="id181" class="indexterm"/>to tell the render target<a id="id182" class="indexterm"/> that we are finished drawing.</p></div><div class="section" title="Cleanup"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Cleanup</h2></div></div></div><p>As usual, we need to clean things up after ourselves when the program closes. So, we need to add <code class="literal">override</code>
<a id="id183" class="indexterm"/> of the base class's <code class="literal">Dispose(bool)</code> method, just <a id="id184" class="indexterm"/>as we did in the last chapter. We've already done this a few times, so<a id="id185" class="indexterm"/> it should be somewhat familiar and is not shown here. Check out the downloadable code for this chapter to see this code.</p><div class="mediaobject"><img src="graphics/7389OS_03_01.jpg" alt="Cleanup"/><div class="caption"><p>Our blue rectangle with a red border</p></div></div><p>As you might guess, there is a lot more you can do with drawing geometry. You can draw curved line segments and draw shapes with gradient brushes too for example. You can also draw <a id="id186" class="indexterm"/>text on the screen using the render target's <code class="literal">DrawText()</code> method<a id="id187" class="indexterm"/>. But since we have limited space on these pages, we're going<a id="id188" class="indexterm"/> to look at how to draw bitmap images on the screen. These images are something that makes up the graphics of most 2D games.</p></div></div></div>
<div class="section" title="Rendering bitmaps"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Rendering bitmaps</h1></div></div></div><p>Instead of <a id="id189" class="indexterm"/>doing a simple demo of drawing a single bitmap on the screen, we will make a small 2D tile-based world. In 2D graphics, the term tile refers to a small<a id="id190" class="indexterm"/> bitmap image that represents one square of space in the 2D world. A <span class="strong"><strong>tile set</strong></span> or <span class="strong"><strong>tile sheet</strong></span>
<a id="id191" class="indexterm"/> is a single bitmap file that contains numerous tiles. A single 2D graphic tile is also referred to as a <span class="strong"><strong>sprite</strong></span>
<a id="id192" class="indexterm"/>. To get started, add a new project named <code class="literal">TileWorld</code> to the <code class="literal">SlimFramework</code> solution. So far, we've directly used the game window classes we made. This time, we will see how we will do this in a real-world game project.</p><p>Add a new class file to the <code class="literal">TileWorld</code> project and name it <code class="literal">TileGameWindow.cs</code>. As you may have guessed, we will make this new class inherit from the <code class="literal">GameWindow</code> class in our <code class="literal">SlimFramework</code> project. But first, we need to add a reference to the <code class="literal">SlimFramework</code> project. We've already covered this, so go ahead and add the reference. Don't forget to add a reference to SlimDX as well. You will also need to add a reference to <code class="literal">System.Drawing</code> if there isn't one already. Also, don't forget to set <code class="literal">TileWorld</code> as the startup project.</p><p>Next, we need to add our <code class="literal">using</code> statements to the top of the <code class="literal">TileGameWindow.cs</code> file. We will need to add the following <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using System.Windows.Forms;
using System.Collections,Generic;
using System.Diagnostics;
using System.Drawing;
using System;

using SlimDX;
using SlimDX.Direct2D;
using SlimDX.DirectInput;
using SlimDX.Windows;</pre></div><p>Next, we need to create a couple of structs and member variables. First, let's define the following <span class="strong"><strong>constant</strong></span> at the top of this class:</p><div class="informalexample"><pre class="programlisting">const float PLAYER_MOVE_SPEED = 0.05f;</pre></div><p>This constant defines the movement speed of the player. A constant is just a variable whose value can never be changed after it is initialized, so its value is always the same. Now, we need a place to store the information about our player character. We will create a structure named <code class="literal">Player</code>. Just add it right below the constant we just made with the following code:</p><div class="informalexample"><pre class="programlisting">public struct Player
{
    public float PositionX;
    public float PositionY;
    public int AnimFrame;
    public double LastFrameChange;
}</pre></div><p>The first two member variables in this struct store the player's current location within the 2D world. The <code class="literal">AnimFrame</code> variable<a id="id193" class="indexterm"/> keeps track of the current animation frame that the player<a id="id194" class="indexterm"/> character is on, and the last variable keeps track of how long the player character has been on the current animation frame. This is used to ensure that the animation runs at about the same speed regardless of how fast your PC is.</p><p>We need to add a second struct below this one now. We will name this struct <code class="literal">Tile</code>. It stores information on a single tile. As you might guess, we will be creating a list of these structures containing one for each tile type in our game world. The following is the <code class="literal">Tile</code> struct:</p><div class="informalexample"><pre class="programlisting">public struct Tile
{
    public bool IsSolid;
    public int SheetPosX;
    public int SheetPosY;
}</pre></div><p>The first variable indicates whether this tile is solid or not. If a tile is solid, it means that the player cannot walk on it or through it. So, for example, a brick wall tile would have this set to <code class="literal">true</code>, since we don't want our players to be walking through brick walls! The last two member variables of this struct hold the coordinates of the tile's image within the tile sheet.</p><p>Next, let's turn our attention to creating the member variables for the <code class="literal">TileGameWindow</code> class. You can add these just below the structs we just created as follows:</p><div class="informalexample"><pre class="programlisting">WindowRenderTarget m_RenderTarget;
Factory m_Factory;

Player m_Player;
SlimDX.Direct2D.Bitmap m_PlayerSprites;
SlimDX.Direct2D.Bitmap m_TileSheet;

List&lt;Tile&gt; m_TileList;
int[ , ] m_Map;
SolidColorBrush m_DebugBrush;</pre></div><p>The first two member variables should be familiar from the rectangle program that we wrote at the beginning of this chapter. The <code class="literal">m_Player</code> variable holds a <code class="literal">Player</code> object. This is the<a id="id195" class="indexterm"/> first struct we created earlier. The next two variables will hold the bitmap images we will use for this program. One holds the sprites that make up the animation for our player character, and the other one will hold the tile sheet that we will use to draw the game world. The next variable is a list named <code class="literal">m_TileList</code>. We will fill this with one entry for each tile type that we have. The <code class="literal">m_Map</code> variable, as you might guess, will contain a map of our game world. And lastly, we have a <code class="literal">SolidColorBrush</code> member variable named <code class="literal">m_DebugBrush</code>.</p><div class="section" title="Initialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Initialization</h2></div></div></div><p>Now, it's time to <a id="id196" class="indexterm"/>create the constructor and start initializing everything. First, we <a id="id197" class="indexterm"/>need to set up the render target. This is very similar to how we did it in the program for creating a rectangle, but slightly different. The following is the code:</p><div class="informalexample"><pre class="programlisting">m_Factory = new Factory();

RenderTargetProperties rtProperties = new RenderTargetProperties();
rtProperties.PixelFormat = new PixelFormat(SlimDX.DXGI.Format.B8G8R8A8_UNorm, AlphaMode.Premultiplied);

WindowRenderTargetProperties properties = new WindowRenderTargetProperties();
properties.Handle = FormObject.Handle;
properties.PixelSize = new Size(width, height);

m_RenderTarget = new WindowRenderTarget(m_Factory, rtProperties, properties);

m_DebugBrush = new SolidColorBrush(m_RenderTarget, new Color4(1.0f, 1.0f, 1.0f, 0.0f));</pre></div><p>As we did in the program for creating a rectangle, we first create the factory object. After that, things differ slightly. This time we need to create two properties objects instead of one. The new one is a <code class="literal">RenderTargetProperties</code> object. We use it to set the pixel format for our render target. As you can see, we are using a 32-bit format with 8 bits for each of the four channels (blue, green, red, and alpha). Yes, this is backwards from the ARGB format we've already discussed earlier. That's OK though because our <code class="literal">LoadBitmap()</code> method<a id="id198" class="indexterm"/> will flip the ARGB format to BGRA for us. The next line of code creates a <code class="literal">WindowRenderTargetProperties</code> object, just as we did in the <span class="emphasis"><em>Rectangle</em></span> program earlier in this chapter. We use this to specify the handle of the window we want to draw on as well as the size of the window. And lastly, we create the render target object and initialize our debug brush to be an opaque yellow brush.</p><p>So, we're done<a id="id199" class="indexterm"/> initializing stuff now, right? Well, no; not yet. We still<a id="id200" class="indexterm"/> have a few things that need to be initialized. But first, we need to<a id="id201" class="indexterm"/> create our <code class="literal">LoadBitmap()</code> method so that we can load in our graphics! The following is the code:</p><div class="informalexample"><pre class="programlisting">public SlimDX.Direct2D.Bitmap LoadBitmap(string filename)
{
    // This will hold the Direct2D Bitmap that we will return at the end of this function.SlimDX.Direct2D.Bitmap d2dBitmap = null;

    // Load the bitmap using the System.Drawing.Bitmap class.
      System.Drawing.Bitmap originalImage = new System.Drawing.Bitmap(filename);
    // Create a rectangle holding the size of the bitmap image.
    Rectangle bounds = new Rectangle(0, 0, originalImage.Width, originalImage.Height);

    // Lock the memory holding this bitmap so that only we are allowed to mess with it.
    System.Drawing.Imaging.BitmapData imageData = originalImage.LockBits(bounds, System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);

    // Create a DataStream attached to the bitmap.
    SlimDX.DataStream dataStream = new DataStream(imageData.Scan0,  imageData.Stride * imageData.Height, true, false);

    // Set the pixel format and properties.
    PixelFormat pFormat = new PixelFormat(SlimDX.DXGI.Format.B8G8R8A8_UNorm, AlphaMode.Premultiplied);
    BitmapProperties bmpProperties = new BitmapProperties();
    bmpProperties.PixelFormat = pFormat;

    // Copy the image data into a new SlimDX.Direct2D.Bitmap object.
    d2dBitmap = new SlimDX.Direct2D.Bitmap(m_RenderTarget, new Size(bounds.Width, bounds.Height), dataStream, imageData.Stride, bmpProperties);

    // Unlock the memory that is holding the original bitmap object.
    originalImage.UnlockBits(imageData);

    // Get rid of the original bitmap object since we no longer need it.
    originalImage.Dispose();
    // Return the Direct2D bitmap.
    return d2dBitmap;
}</pre></div><p>This method is a<a id="id202" class="indexterm"/> little confusing, so I've kept the comments present in this <a id="id203" class="indexterm"/>code listing. You may have noticed that in the line with the call to the <a id="id204" class="indexterm"/>
<code class="literal">LockBits()</code> method, there is a pixel format parameter, but it is different from what we saw a bit earlier in the chapter; it is <code class="literal">System.Drawing.Imaging.PixelFormat.Format32bppPArgb</code>. This is the same format we are using, but what is that <code class="literal">P</code> in there for? The <code class="literal">P</code> is short for <span class="strong"><strong>precalculated alpha</strong></span>
<a id="id205" class="indexterm"/>. This basically means that the red, green, and blue channels are automatically adjusted based on the alpha value before rendering. So, if you have the red channel at maximum and the alpha channel at 50 percent, the intensity of the red channel will be reduced by half.</p><p>There is also <span class="strong"><strong>straight alpha</strong></span>
<a id="id206" class="indexterm"/> which is less efficient than precalculated alpha. The values of the red, green, and blue channels are left alone. Their intensity is adjusted based on the value of the alpha channel during rendering. Precalculated alpha is a bit faster since it adjusts the color channels once before any rendering happens, whereas straight alpha has to adjust the color channels each time we render a new frame. And lastly, there is also an <span class="strong"><strong>ignore alpha</strong></span> mode. In this mode, the alpha channel is <a id="id207" class="indexterm"/>completely ignored, and thus you cannot use transparent bitmaps.</p><p>We are using the precalculated alpha mode in this case and this is important. If you don't do this, the player character will have white in all of the transparent areas of the robot image, which looks rather silly. We used the <code class="literal">LockBits()</code> method to lock the memory holding the bitmap because if any other code on another thread accesses that memory while we are messing with it, this can cause crashes and other odd behavior.</p><p>Now, let's return to the constructor and initialize the player character, which will be a rather silly robot. Add the following code at the bottom of the constructor:</p><div class="informalexample"><pre class="programlisting">m_PlayerSprites = LoadBitmap(Application.StartupPath + "\\Robot.png");

m_Player = new Player();
m_Player.PositionX = 4;
m_Player.PositionY = 8;</pre></div><p>The first line of code uses our <a id="id208" class="indexterm"/>
<code class="literal">LoadBitmap()</code> method to load the robot sprite sheet and store it in the <code class="literal">m_PlayerSprites</code> member variable. The second line creates the player object to hold information about the player character. Finally, the last two lines set the starting position for the player. Note that the coordinates (0, 0) represent the upper-left corner of the screen. The robot sprite sheet is just a series of animation frames for our robot that we will display one after another in quick succession to animate the robot.</p><p>Now that the <a id="id209" class="indexterm"/>player object is initialized, we need to initialize the <a id="id210" class="indexterm"/>game world! The following is the first part of the code:</p><div class="informalexample"><pre class="programlisting">m_TileSheet = LoadBitmap(Application.StartupPath + "\\TileSheet.png");

m_TileList = new List&lt;Tile&gt;();

// First row of sprites in the sprite sheet.
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 0, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 1, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 2, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 3, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 4, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 5, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = false, SheetPosX = 6, SheetPosY = 0 });
m_TileList.Add(new Tile() { IsSolid = true, SheetPosX = 7, SheetPosY = 0 });</pre></div><p>The first line calls our <code class="literal">LoadBitmap()</code> method again to load in the tile sheet and store it in the <code class="literal">m_TileSheet</code> member variable. The second line creates our tile list object. This will store information for each tile type. The eight lines of code at the bottom create entries in the tile list for all of the tiles in the first row of the tile sheet. Of course, the tile sheet has more than one row of tiles in it, but I will not show the code for the other rows here, since it is very similar and would take up several pages.</p><p>We have one more thing to do to finish initializing the game world. It consists of initializing the map. The map is simply a two-dimensional array. Each element in the array represents a tile position in the game world. As such, the array is of type <code class="literal">int</code>; it is of type <code class="literal">int</code> because each element stores a numeric index in the tile list. So basically, each element in the array holds a number that tells us which type of tile is at this position in the game world. As the code that fills in this array is much too wide to fit on the page, I will show a brief example of how it is initialized here:</p><div class="informalexample"><pre class="programlisting">m_Map = new int[,] { {14, 14, 14 },
                     {14, 0, 14 },
                     {14, 14, 14 } };</pre></div><p>As you can see, we are creating a new two-dimensional <code class="literal">int</code> array. In this sample code, we have a 3 x 3 world. We are using tile type <code class="literal">14</code> (a brick wall tile) to make a wall around the outer <a id="id211" class="indexterm"/>border of this small world. In the center, we have tile type <code class="literal">0</code>, which in our game demo is a grass tile. Each row of values gets its own pair of <a id="id212" class="indexterm"/>enclosing brackets (<code class="literal">{}</code>), followed by a comma. This is basically how you set up a 2D tile map. Of course you can get a lot fancier with this. For example, you can implement animated tile types in your game. These would be animated very similarly to how we will animate our robot character. Check out the downloadable code for this chapter to see the complete array initialization code, which is much larger than the earlier example.</p></div><div class="section" title="Rendering the game world"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Rendering the game world</h2></div></div></div><p>For clarity, we will create a couple of different render methods that will each be called from our <code class="literal">RenderScene()</code> method<a id="id213" class="indexterm"/>. Since the first thing we need to <a id="id214" class="indexterm"/>draw is the game world itself, let's create that method <a id="id215" class="indexterm"/>first. We will name this method <code class="literal">RenderWorld</code>:</p><div class="informalexample"><pre class="programlisting">public void RenderWorld()
{
    Tile s;
    // Loop through the y axis.
    for (int y = 0; y &lt; m_Map.GetLength(0); y++)
    {
        // Loop through the x axis.
        for (int x = 0; x &lt; m_Map.GetLength(1); x++)
        {
            // Get the tile at the current coordinates.
            s = m_TileList[ m_Map[y, x] ];

            // Render the tile.
            m_RenderTarget.DrawBitmap(m_TileSheet,
                new Rectangle(x * 32, y * 32, 32, 32),
                1.0f,
                InterpolationMode.Linear,
                new Rectangle(s.SheetPosX * 32,
                              s.SheetPosY * 32,
                               32, 32));
        }
    }
}</pre></div><p>This code is fairly straightforward. The first line creates a <code class="literal">Tile</code> object variable. Next, we have two nested <code class="literal">for</code> loops that loop through every tile position in the game world. Inside the inner <code class="literal">for</code> loop, we get the tile type for this position on the map and look it up in the tile list. We store the result in the variable <code class="literal">s</code> so that we can use it easily afterwards. The last line<a id="id216" class="indexterm"/> renders the tile. The first parameter here is the bitmap <a id="id217" class="indexterm"/>containing the tiles. The second parameter is a rectangle specifying where we want to draw the tile on the screen. The third parameter is the opacity. We have it set to <code class="literal">1.0f</code> so that the tile is completely opaque. The third parameter is the interpolation mode. And the last parameter is another rectangle, which specifies what portion of the tile sheet we want to draw on the screen. For this, we specify the part of the tile sheet containing the tile we want to draw. For the x and y coordinates of both rectangle parameters, you may have noticed that we are multiplying by 32. This is because each tile is 32 x 32 pixels in size. So, we have to multiply by 32 to get the position of the tile within the tile sheet correctly. The fact that our tiles are 32 x 32 pixels in size is also why both rectangles we created here specify the value <code class="literal">32</code> for their <code class="literal">width</code> and <code class="literal">height</code> parameters.</p></div><div class="section" title="Rendering the player character"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Rendering the player character</h2></div></div></div><p>Now that we have code to draw the world, we need to draw the player character! For this, we will <a id="id218" class="indexterm"/>create a method called <code class="literal">RenderPlayer()</code>. It's pretty <a id="id219" class="indexterm"/>short compared to the <code class="literal">RenderWorld()</code> method. The following <a id="id220" class="indexterm"/>is the code:</p><div class="informalexample"><pre class="programlisting">public void RenderPlayer()
{
    // Render the player character.
    m_RenderTarget.DrawBitmap(m_PlayerSprites,
          new Rectangle((int) (m_Player.PositionX * 32),
                        (int) (m_Player.PositionY * 32),
                        32, 32),
                       1.0f,
                       InterpolationMode.Linear,new Rectangle(m_Player.AnimFrame * 32,
                                      0, 32, 32));
}</pre></div><p>This <a id="id221" class="indexterm"/>method contains only one line. It is very similar to the code we used to draw each tile in the <code class="literal">RenderWorld()</code> method. But this time we are using the player sprites sheet rather than the tile sheet. You may also notice that we determine<a id="id222" class="indexterm"/> which sprite to draw based on the player<a id="id223" class="indexterm"/> object's <code class="literal">AnimFrame</code> variable, which we use to keep track of which animation frame the robot is currently on.</p></div><div class="section" title="Rendering debug information"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Rendering debug information</h2></div></div></div><p>This is not <a id="id224" class="indexterm"/>strictly necessary, but it's a good thing to know <a id="id225" class="indexterm"/>how to do. We will create a new method <a id="id226" class="indexterm"/>called <code class="literal">RenderDebug()</code>. It will draw a yellow border on every solid tile in the game world. The following is the code:</p><div class="informalexample"><pre class="programlisting">public void RenderDebug()
{
    Tile s;

     // Loop through the y axis.
     for (int y = 0; y &lt; m_Map.GetLength(0); y++)
     {
         // Loop through the x axis.
         for (int x = 0; x &lt; m_Map.GetLength(1); x++)
         {
             // Get the tile at the current coordinates.
             s = m_TileList[m_Map[y, x]];

             // Check if the tile is solid. If so, draw a yellow border on it.
             if (s.IsSolid)
                 m_RenderTarget.DrawRectangle(m_DebugBrush,
                     new Rectangle(x * 32, y * 32, 32, 32));
        }
    }
}</pre></div><p>As you can see, this method looks very similar to the <code class="literal">RenderWorld()</code> method; it loops through every position in the game world just as that method does. The one major difference is that we use the <code class="literal">DrawRectangle()</code> method here rather than the <code class="literal">DrawBitmap()</code> method. Using our <a id="id227" class="indexterm"/>yellow debug brush, it draws a yellow border on any tile in<a id="id228" class="indexterm"/> the game world that is solid.</p></div><div class="section" title="Finishing the rendering code"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Finishing the rendering code</h2></div></div></div><p>Now we <a id="id229" class="indexterm"/>need to add code into the <code class="literal">RenderScene()</code> method to call these methods we just made. The following is the <code class="literal">RenderScene()</code> code:</p><div class="informalexample"><pre class="programlisting">public override void RenderScene()
{
    if ((!this.IsInitialized) || this.IsDisposed)
    {
        return;
    }

    m_RenderTarget.BeginDraw();
    m_RenderTarget.Clear(ClearColor);

    RenderWorld();

#if DEBUG
    RenderDebug();
#endif

    RenderPlayer();

    // Tell the render target that we are done drawing.
    m_RenderTarget.EndDraw();
}</pre></div><p>With that, our rendering code is now complete. The <code class="literal">if</code> statement at the top prevents the program from crashing when it is first starting up or shutting down. The next two lines tell the render<a id="id230" class="indexterm"/> target we are ready to begin drawing by calling the <code class="literal">BeginDraw()</code> method, and then clear the screen by calling the <code class="literal">Clear()</code> method. The next line calls our <code class="literal">RenderWorld()</code> method to draw the game world. But then, the call to the <code class="literal">RenderDebug()</code> method is preceded by <code class="literal">#if DEBUG</code> and followed by <code class="literal">#endif</code>. These are known as <span class="strong"><strong>preprocessor directives</strong></span>. This one checks if a symbol named <code class="literal">DEBUG</code> is defined, and if so, the code inside this <code class="literal">if</code> directive will be compiled into<a id="id231" class="indexterm"/> the program. Preprocessor directives are processed by the <span class="strong"><strong>preprocessor,</strong></span> which runs before the compiler when you compile your code. After the preprocessor <a id="id232" class="indexterm"/>has finished its job, the compiler will run. There are a bunch<a id="id233" class="indexterm"/> of other preprocessor directives besides <code class="literal">#if</code>, but they are beyond the scope of this text. When you compile your code under the <code class="literal">Debug</code> configuration, the <code class="literal">DEBUG</code> symbol is automatically defined for us, meaning our call to <code class="literal">RenderDebug()</code> will be compiled into the game. In Visual Studio, you can change the compile configuration using the drop-down list box that is just to the right of the <span class="strong"><strong>Start</strong></span> button, which you click on to compile and run your program. Visual Studio provides <code class="literal">Debug</code> and <code class="literal">Release</code> configurations. You can also run a program by pressing the <span class="emphasis"><em>F5</em></span> key.</p><p>The next line calls our <code class="literal">RenderPlayer()</code> method to draw the player character using the appropriate animation frame from the robot's sprite sheet. And lastly, we call the <code class="literal">EndDraw()</code> method to<a id="id234" class="indexterm"/> tell the render target that we are done rendering this frame.</p></div><div class="section" title="Handling user input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Handling user input</h2></div></div></div><p>Now, we <a id="id235" class="indexterm"/>need to add some code into our <code class="literal">UpdateScene()</code> method to <a id="id236" class="indexterm"/>handle player input:</p><div class="informalexample"><pre class="programlisting">base.UpdateScene(frameTime);

// Figure out which grid square each corner of the player sprite is currently in.
PointF TL = new PointF(m_Player.PositionX + 0.25f, m_Player.PositionY + 0.25f); // Top left corner
PointF BL = new PointF(m_Player.PositionX + 0.25f, m_Player.PositionY + 0.75f); // Bottom left corner
PointF TR = new PointF(m_Player.PositionX + 0.75f, m_Player.PositionY + 0.25f); // Top right corner
PointF BR = new PointF(m_Player.PositionX + 0.75f, m_Player.PositionY + 0.75f); // Bottom right corner</pre></div><p>The first line calls the base class's <a id="id237" class="indexterm"/>
<code class="literal">UpdateScene()</code> method, so it can perform its stuff. The next four lines may look a bit odd though. Why do we need to find out which grid square each corner of the player sprite is in? It has to do with how our player's movement will work. Specifically, this is used by our collision detection code.</p><p>You may also notice that the first four lines of code are skewing all four corners inward by 25 percent. You can think of these four corners as our bounding box for collision detection. Shrinking the bounding box like this makes it easier for the player to enter narrow spaces that are only one block wide. Note that <code class="literal">TL</code> is short for top-left, <code class="literal">TR</code> is top-right, <code class="literal">BL</code> is bottom-left, and <code class="literal">BR</code> is bottom-right. The following is the first part of our collision detection code:</p><div class="informalexample"><pre class="programlisting">// Check if the user is pressing left.
if (m_UserInput.KeyboardState_Current.IsPressed(Key.A) ||
   (m_UserInput.KeyboardState_Current.IsPressed(Key.LeftArrow)))
{
    if ((!m_TileList[m_Map[(int) TL.Y, (int) (TL.X - PLAYER_MOVE_SPEED)]].IsSolid) &amp;&amp; (!m_TileList[m_Map[(int) BL.Y, (int) (BL.X – PLAYER_MOVE_SPEED)]].IsSolid)){
         m_Player.PositionX -= PLAYER_MOVE_SPEED;
     }
}</pre></div><p>This code starts with a compound <code class="literal">if</code> statement, checking whether the user is pressing the <span class="emphasis"><em>A</em></span> key or the left arrow key. Yes, you can control our game character using either of the <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, or <span class="emphasis"><em>D</em></span> keys or the arrow keys if you wish to move the character using the keyboard. Next, we have another <code class="literal">if</code> statement. This <code class="literal">if</code> statement checks to see if moving the player to the left will <a id="id238" class="indexterm"/>cause a collision. If not, we move the player to the left. As you <a id="id239" class="indexterm"/>can see, we use the <code class="literal">PLAYER_MOVE_SPEED</code> constant that we created earlier in this chapter to control how much the robot moves. Obviously, we need three more of these <code class="literal">if</code> statements to handle the right, up, and down directions. As the code is very similar, I will not describe it here.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The downloadable code for this chapter also supports controlling the robot using joysticks/gamepads. It adds a member variable named <code class="literal">m_UseDirectInput</code> to the <code class="literal">TileGameWindow</code> class. Set this variable to <code class="literal">true</code> to use DirectInput for joystick/gamepad controls, or set this variable to <code class="literal">false</code> to have the program use XInput for joystick/gamepad controls. We need the <code class="literal">m_UseDirectInput</code> member variable because if we used both DirectInput and XInput at the same time for the same game controller device, this will cause the player to get moved twice per frame. </p></div></div></div><div class="section" title="Animating the player character"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Animating the player character</h2></div></div></div><p>With the<a id="id240" class="indexterm"/> user input and collision detection code done, there is<a id="id241" class="indexterm"/> now only one thing left to do in <code class="literal">UpdateScene()</code>. We need to add a bit of code to animate the player character:</p><div class="informalexample"><pre class="programlisting">m_Player.LastFrameChange += frameTime;
if (m_Player.LastFrameChange &gt; 0.1)
{
    m_Player.LastFrameChange = 0;
    m_Player.AnimFrame++;
    if (m_Player.AnimFrame &gt; 7)
       m_Player.AnimFrame = 0;
}</pre></div><p>This code is fairly simple. The first line adds <code class="literal">frameTime</code> to the player object's <code class="literal">LastFrameChange</code> variable. Remember that <code class="literal">frameTime</code> is the parameter of the <code class="literal">UpdateScene()</code> method<a id="id242" class="indexterm"/>, and it contains the amount of time that has elapsed since the previous frame. Next, we have an <code class="literal">if</code> statement that checks if the player object's <code class="literal">LastFrameChange</code> variable has a value greater than <code class="literal">0.1</code>. If this is the case, it means that it has been 1/10th of a second or more since the last time we changed the animation frame, so we will change it again. Inside the <code class="literal">if</code> statement, we reset the <code class="literal">LastFrameChange</code> variable to <code class="literal">0</code>, so we will know when to change the animation frame again. The next line increments the value of the player object's <code class="literal">AnimFrame</code> variable. And lastly, we have another <code class="literal">if</code> statement that checks if the new value of <a id="id243" class="indexterm"/>the <code class="literal">AnimFrame</code> variable is too large. If it is, we reset<a id="id244" class="indexterm"/> it to a value of <code class="literal">0</code> and the animation starts all over again.</p></div><div class="section" title="Running the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Running the game</h2></div></div></div><p>We are almost ready to run the game, but don't forget that you need to add the <code class="literal">Dispose(bool)</code> method<a id="id245" class="indexterm"/>. In this program, there are only four objects it needs to dispose off. They are <code class="literal">m_RenderTarget</code>, <code class="literal">m_Factory</code>, <code class="literal">m_TileSheet</code>, and <code class="literal">m_DebugBrush</code>. They should be disposed of in the managed section of the <code class="literal">Dispose(bool)</code> method. You can see this in the downloadable code for this chapter.</p><p>With the <a id="id246" class="indexterm"/>cleanup code in place, we are ready to run the game. As <a id="id247" class="indexterm"/>you can see, you control a rather goofy robot. Note that the player sprites are in the <code class="literal">Robot.png</code> file and the tile sheet is saved in the <code class="literal">TileSheet.png</code> file. Both of these files are, of course, included with the downloadable code for this chapter. The screenshot following the explanation shows what the game window looks like with the debug overlay off.</p><p>You may have noticed that we didn't implement the fullscreen mode. This is because Direct2D unfortunately does not natively support the fullscreen mode. It is, however, possible to have the fullscreen mode in a Direct2D application. To do this, you will create a Direct3D render target and share it with Direct2D. This would then allow you to draw on it with Direct2D and also be able to use the fullscreen mode.</p><div class="mediaobject"><img src="graphics/7389OS_03_02.jpg" alt="Running the game"/><div class="caption"><p>Our 2D game in action</p></div></div><p>The <a id="id248" class="indexterm"/>following screenshot shows our game with the debug overlay<a id="id249" class="indexterm"/> turned on.</p><div class="mediaobject"><img src="graphics/7389OS_03_03.jpg" alt="Running the game"/><div class="caption"><p>Our 2D game in action with the debug overlay turned on</p></div></div></div></div>
<div class="section" title="Entities"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Entities</h1></div></div></div><p>This 2D game demo we created only has one <span class="strong"><strong>entity</strong></span> in it (the player character). In game development, the<a id="id250" class="indexterm"/> term entity refers to an object that can interact with the game <a id="id251" class="indexterm"/>world or other objects in the game world. An entity would typically be implemented as a class. So, we would create a class to represent our player object. In this demo, our player object was very simple and had no methods in it, so we just made it a struct instead. In a real-game engine, you might have an <code class="literal">Entity</code> base class that all other entity classes would inherit from. This base class would define methods such as <code class="literal">Update()</code>
<a id="id252" class="indexterm"/> and <code class="literal">Draw()</code> so that every entity has them. Each <a id="id253" class="indexterm"/>entity class would then override them to provide its own custom update and draw code.</p><p>A single level or game world can have hundreds of entities in it, so how do we manage them? One way is to create an <code class="literal">EntityManager</code> class that simply holds the collection of entities that are in the currently loaded level or world. The <code class="literal">EntityManager</code> class will have an <code class="literal">Update()</code> method and a <code class="literal">Draw()</code> method. The <code class="literal">Update()</code> method would, of course, get called once per frame by the <code class="literal">UpdateScene()</code> method of our game window class. Likewise, the <code class="literal">Draw()</code> method would be called once per frame by the <code class="literal">RenderScene()</code> method. The entity manager's <code class="literal">Update()</code> method would iterate through all of the entities and call each one's <code class="literal">Update()</code> method so that the entity can update itself. And of<a id="id254" class="indexterm"/>  course, the entity manager's <code class="literal">Draw()</code> method would do the <a id="id255" class="indexterm"/>same thing, but instead it would call each entity's <code class="literal">Draw()</code> method so that the entity can draw itself.</p><p>In some games, entities are able to communicate with each other via a messaging system of sorts. A good <a id="id256" class="indexterm"/>example of this is the inputs and outputs system used in <code class="literal">Half-Life 2</code>. For example, there is a button on a wall next to a door. We will set up an <a id="id257" class="indexterm"/>output on the button that fires when the button is pressed. We will connect it to the input on the door that makes the door open. So, basically, when the output of the button fires, it activates the specified input on the door. In short, the button sends a message to the door telling it to open. The output of one object can potentially send parameters to its target input as well. The big benefit here is that many interactions between objects can be handled like this and don't need to be specifically coded as a result, but instead can simply be set up in the game's level editor.</p><div class="section" title="Component-based entities"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Component-based entities</h2></div></div></div><p>There is <a id="id258" class="indexterm"/>another way to implement our entities as well. It <a id="id259" class="indexterm"/>implements an <code class="literal">Entity</code> class that is used to represent any possible entity. The difference is that this <code class="literal">Entity</code> class contains a collection of <code class="literal">Components</code>. A <span class="strong"><strong>component</strong></span>
<a id="id260" class="indexterm"/> is a class that represents a certain action or feature that an object in the game world can have. So, for example, you might have an <span class="strong"><strong>Armor</strong></span> component<a id="id261" class="indexterm"/> that allows an entity to have an armor value, or a <span class="strong"><strong>Health</strong></span> component<a id="id262" class="indexterm"/> that allows the entity to<a id="id263" class="indexterm"/> have health and the ability to take damage. This <a id="id264" class="indexterm"/>Health component would probably have a property to set the maximum health for the entity and another one that is used to get the current health value for the entity.</p><p>This is a very powerful approach because you can give any entity health (and the ability to take damage) just by adding the Health component into that entity. So, as you can see, each entity is represented by the basic <code class="literal">Entity</code> class and gets all of its features and properties from the components that are added into it. This is what makes this approach so powerful. You write the Health code once and then you can re-use it on any number of entities without having to rewrite it for each one. The component-based entities are a bit trickier to program than regular entities though. For example, we would need to add a method on the <code class="literal">Entity</code> class that lets you pass in a component type to specify which component you would like to access. It would then find the component of the specified type and <a id="id265" class="indexterm"/>return it for you to use. You would usually <a id="id266" class="indexterm"/>make your entity system such that it will not allow an entity to have more than one component of any given type as this generally wouldn't make much sense anyway. For example, giving one entity two Health components doesn't make much sense.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Summary</h1></div></div></div><p>In this chapter we first made a simple demo application that drew a rectangle on the screen. Then we got a bit more ambitious and built a 2D tile-based game world. In the process, we covered how to render bitmaps on the screen, basic collision detection, and reviewed some basic user input handling. We also looked at how to create a handy debug overlay. Of course, this debug overlay is pretty simple, but they can show all sorts of useful information. They are a very powerful tool when it comes to solving bugs. In the next chapter, we will look at playing music and sound effects to add more life to our 2D game world that we built in this chapter!</p></div></body></html>