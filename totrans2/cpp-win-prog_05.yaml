- en: Chapter 5. The Figure Hierarchy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 图形层次结构
- en: This chapter introduces the figure classes of the drawing program. Each figure
    is responsible for deciding whether it is hit by a mouse click or if it is enclosed
    by a rectangle. It is also responsible for moving or modifying, as well as drawing
    and communicating with a file stream and the clipboard.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了绘图程序的图形类。每个图形负责决定它是否被鼠标点击击中，或者它是否被矩形包围。它还负责移动或修改，以及绘制以及与文件流和剪贴板进行通信。
- en: 'The drawing figure hierarchy is made up of the `Draw`, `LineFigure`, `ArrowFigure`,
    `RectangleFigure`, and `EllipseFigure` classes, as shown in the following image:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图图形层次结构由`Draw`、`LineFigure`、`ArrowFigure`、`RectangleFigure`和`EllipseFigure`类组成，如下图所示：
- en: '![The Figure Hierarchy](img/image_05_001.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图形层次结构](img/image_05_001.jpg)'
- en: The DrawFigure class
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DrawFigure类
- en: The `Draw` class is the root class of the hierarchy and is mostly made up of
    virtual and pure virtual methods intended to be overridden by the subclasses.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw`类是层次结构的根类，主要由虚拟方法和纯虚拟方法组成，旨在由子类重写。'
- en: The difference between a virtual method and a pure virtual method is that the
    virtual method has a body and it may be overridden by a subclass. If the subclass
    overrides the method, its version of the method is called.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟方法和纯虚拟方法之间的区别是，虚拟方法有一个主体，并且可以被子类重写。如果子类重写了该方法，则调用其版本的方法。
- en: 'If the subclass does not override the method, the method of the base class
    is called instead. A pure virtual method does not usually have a body, and a class
    holding at least one pure virtual method becomes abstract. The subclass can either
    override all the pure virtual methods of its base class or become abstract itself:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类没有重写方法，则调用基类的方法。纯虚拟方法通常没有主体，包含至少一个纯虚拟方法的类成为抽象类。子类可以选择重写其基类的所有纯虚拟方法或自己成为抽象类：
- en: '**Draw.h**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Draw.h**'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each figure has its own identity number, returned by the `GetId` method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形都有自己的唯一编号，由`GetId`方法返回：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `IsClick` method returns `True` if the mouse point hits the figure, and
    the `IsInside` method returns `True` if the figure is completely enclosed by the
    area. The `DoubleClick` method gives the figure a possibility to perform a figure-specific
    action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsClick`方法如果鼠标点击图形则返回`True`，如果图形完全被区域包围则`IsInside`方法返回`True`。`DoubleClick`方法给图形一个执行特定于图形的操作的机会：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Modify` and `Move` methods simply move the figure. However, the `Modify`
    method performs figure-specific actions defined by the `IsClick` method. If the
    user clicked on one of the figure endpoints, it will be modified, and if they
    clicked on any other part of the figure, it will be moved:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modify`和`Move`方法只是简单地移动图形。然而，`Modify`方法执行由`IsClick`方法定义的特定于图形的操作。如果用户点击了图形的一个端点，它将被修改；如果他们点击了图形的任何其他部分，它将被移动：'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Invalidate` method invalidates the figure by calling the `Area` method,
    which returns the area occupied by the figure. The `Draw` method draws the figure
    with the given `Graphics` class''s reference:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invalidate`方法通过调用返回图形占据区域的`Area`方法来使图形无效。`Draw`方法使用给定的`Graphics`类引用绘制图形：'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `IsFillable`, `IsFilled`, and `Fill` methods are only overridden by the
    `Rectangle` and `Ellipse` methods:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFillable`、`IsFilled`和`Fill`方法仅由`Rectangle`和`Ellipse`方法重写：'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `WriteFigureToStream` and `ReadFigureFromStream` methods are called when
    the user opens or saves a document. They write or read the information of the
    figure to and from the streams:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开或保存文档时调用`WriteFigureToStream`和`ReadFigureFromStream`方法。它们将图形的信息写入和从流中读取：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `WriteFigureToClipboard` and `ReadFigureFromClipboard` methods are called
    when the user copies or pastes figures. They write information to a character
    list and read information to a character buffer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户复制或粘贴图形时调用`WriteFigureToClipboard`和`ReadFigureFromClipboard`方法。它们将信息写入字符列表并从字符缓冲区读取信息：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `color` and `marked` fields have their own get and set methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`color`和`marked`字段有自己的获取和设置方法：'
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `GetCursor` method returns the correct cursor for the figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCursor`方法返回图形的正确光标：'
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `MarkRadius` method is the size of the small squares showing that the figure
    is marked:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkRadius`方法表示显示图形被标记的小正方形的大小：'
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `windowPtr` pointer is used when invalidating the figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当无效化图形时使用`windowPtr`指针：
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each figure, regardless of its type, has a color and is marked or unmarked:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形，无论其类型如何，都有一个颜色，并且被标记或未标记：
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Draw.cpp**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Draw.cpp**'
- en: '[PRE13]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `MarkRadius` parameter is set to 100 * 100 units, which is 1 * 1 millimeters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkRadius`参数设置为100 * 100单位，即1 * 1毫米：'
- en: '[PRE14]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a figure is created, it is always unmarked.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建图形时，它总是未标记的。
- en: '[PRE15]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We redraw when the user toggles the figure's marked state. You may notice the
    different order in the `if...else` statements. The reason is that when we mark
    a figure, it becomes larger; that is why we first set the `marked` parameter to
    `True` and then invalidate the figure to catch its area including its markings.
    On the other hand, when we unmark a figure it becomes smaller; that is why we
    first invalidate it to catch its area, including the markings, and then set the
    `marked` parameter to `False`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户切换图形的标记状态时，我们会重新绘制。你可能注意到了`if...else`语句中的不同顺序。原因是当我们标记一个图形时，它会变得更大；这就是为什么我们首先将`marked`参数设置为`True`，然后使图形无效以捕获包括标记在内的区域。另一方面，当我们取消标记图形时，它会变得更小；这就是为什么我们首先使图形无效以捕获包括标记在内的区域，然后设置`marked`参数为`False`。
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The color is the only field written or read in file handling and in communication
    with the clipboard. The subclasses of the `DrawFigure` class call these methods
    and then write and read figure-specific information. The `WriteFigureToStream`
    and `ReadFigureFromStream` methods return the Boolean value of the stream to indicate
    whether the file operation succeeded.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是文件处理和与剪贴板通信中唯一写入或读取的字段。`DrawFigure`类的子类调用这些方法，然后写入和读取特定于图形的信息。`WriteFigureToStream`和`ReadFigureFromStream`方法返回流的布尔值，以指示文件操作是否成功。
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The LineFigure class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LineFigure类
- en: 'A line is drawn between two points, represented by the `firstPoint` field to
    the `lastPoint` field in the `LineFigure` class, as shown in the following image:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点之间绘制线条，这些点由`LineFigure`类中的`firstPoint`字段到`lastPoint`字段表示，如下面的图像所示：
- en: '![The LineFigure class](img/image_05_002.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![LineFigure类](img/image_05_002.jpg)'
- en: The `header` file overrides some of the methods of its `DrawFigure` base class.
    The `DoubleClick` method does nothing. As I see it, there is no really meaningful
    response to a double-click on a line. However, we still need to override the `DoubleClick`
    method, since it is a pure virtual method in the `DrawFigure` base class. If we
    do not override it, the `LineFigure` class will be abstract.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`header`文件覆盖了其`DrawFigure`基类的一些方法。`DoubleClick`方法不做任何事情。在我看来，对于线条的双击并没有真正有意义的响应。然而，我们仍然需要覆盖`DoubleClick`方法，因为它是`DrawFigure`基类中的一个纯虚方法。如果我们不覆盖它，`LineFigure`类将变成抽象的。'
- en: '**LineFigure.h**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**LineFigure.h**'
- en: '[PRE18]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**LineFigure.cpp**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**LineFigure.cpp**'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `SetFirstPoint` method is called when the line is created and sets both
    the first and last points.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建线条时，会调用`SetFirstPoint`方法，并设置第一个和最后一个点。
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `IsClick` method has two cases: the user has to hit either one of the endpoints
    or the line itself. We define two squares (`firstSquare` and `lastSquare`) covering
    the endpoints, and test whether the mouse hits one of them. If not, we test whether
    the mouse hits the line itself by calling the `IsPointInLine` method.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsClick`方法有两个情况：用户必须击中端点之一或线条本身。我们定义了两个覆盖端点的正方形（`firstSquare`和`lastSquare`），并测试鼠标是否击中其中之一。如果没有，我们通过调用`IsPointInLine`方法测试鼠标是否击中线条本身。'
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `IsPointInLine` method checks whether the point is located on the line,
    with some tolerance. We use trigonometric functions to calculate the position
    of the point relative to the line. However, if the line is completely vertical
    and the points have the same x coordinate, we have a special case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPointInLine`方法检查点是否位于线上，并有一定的容差。我们使用三角函数来计算点相对于线的位置。然而，如果线完全垂直且点的x坐标相同，我们有一个特殊情况。'
- en: 'Applying the trigonometric functions would result in division by zero. Instead,
    we create a small rectangle surrounding the line and check if the point is located
    in the rectangle, as shown in the following image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应用三角函数会导致除以零。相反，我们创建一个围绕线的矩形，并检查点是否位于矩形内，如下面的图像所示：
- en: '![The LineFigure class](img/image_05_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![LineFigure类](img/image_05_003.jpg)'
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the line is not vertical, we start by creating an enclosing rectangle and
    test if the mouse point is in it. If it is, we let the leftmost point of the `firstPoint`
    and `lastPoint` fields equal to the `minPoint` field and the rightmost point equal
    to the `maxPoint` field. Then we calculate the width (`lineWidth`) and height
    (`lineHeight`) of the enclosing rectangle, as well as the distance between the
    `minPoint` and `mousePoint` fields in x and y directions (`diffWidth` and `diffHeight`),
    as shown in the following image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线条不是垂直的，我们首先创建一个包围矩形并测试鼠标点是否在其中。如果是，我们将 `firstPoint` 和 `lastPoint` 字段的左端点等于
    `minPoint` 字段，右端点等于 `maxPoint` 字段。然后我们计算包围矩形的宽度（`lineWidth`）和高度（`lineHeight`），以及
    `minPoint` 和 `mousePoint` 字段在 x 和 y 方向上的距离（`diffWidth` 和 `diffHeight`），如下面的图像所示：
- en: '![The LineFigure class](img/image_05_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![The LineFigure class](img/image_05_004.jpg)'
- en: 'Due to uniformity, the following equation is true if the mouse point hits the
    line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一致性，如果鼠标点击中线条，以下方程是正确的：
- en: '![The LineFigure class](img/image_05_005.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![The LineFigure class](img/image_05_005.jpg)'
- en: 'This implies that:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: '![The LineFigure class](img/image_05_006.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![The LineFigure class](img/image_05_006.jpg)'
- en: 'And this also implies that:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着：
- en: '![The LineFigure class](img/image_05_007.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![The LineFigure class](img/image_05_007.jpg)'
- en: 'Let us allow for a small tolerance; let us say that the user is allowed to
    miss the line by a millimeter (100 units). This changes the last equation to the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们允许有一点容差；让我们说用户被允许错过线条 1 毫米（100 单位）。这改变了最后一个方程到以下方程：
- en: '![The LineFigure class](img/image_05_008.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![The LineFigure class](img/image_05_008.jpg)'
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `IsInside` method is easier than the `IsClick` method. We just check whether
    both endpoints are enclosed by the given rectangle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsInside` 方法比 `IsClick` 方法简单。我们只需检查两个端点是否都被给定的矩形包围。'
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the `Modify` mode, we move one of the endpoints or the line depending on
    the value of the `lineMode` parameter set by the `IsClick` method. If the user
    has hit the first point, we move it. If they have hit the last point, or if the
    line is in the process of being created, we move the last point. If they have
    hit the line, we move the line. That is, we move both the first and last points.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Modify` 模式下，我们根据 `IsClick` 方法设置的 `lineMode` 参数的值移动一个端点或线条。如果用户击中了第一个点，我们就移动它。如果他们击中了最后一个点，或者如果线条正在创建过程中，我们就移动最后一个点。如果他们击中了线条，我们就移动线条。也就是说，我们移动第一个和最后一个点。
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Move` method is also easy; we just move the two endpoints.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move` 方法也很简单；我们只需移动两个端点。'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `Draw` method, we draw the line and, if the line is marked, its two endpoints
    are always black.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Draw` 方法中，我们绘制线条，如果线条被标记，则其两个端点始终是黑色。
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The area occupied by the line is a rectangle with the endpoints as corners.
    If the line is marked, the mark radius is added.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 线条占据的区域是一个以端点为顶点的矩形。如果线条被标记，则标记半径被添加。
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the line is being modified, the `Crosshair` cursor is returned. If it is
    being moved, the size-all cursor (four arrows in the compass directions) is returned.
    If none of these cases apply, then we just return the normal arrow cursor.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在修改线条，则返回 `Crosshair` 光标。如果正在移动，则返回全选光标（四个指向方位的箭头）。如果没有这些情况，则我们只返回正常的箭头光标。
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `WriteFigureToStream`, `ReadFigureFromStream`, `WriteFigureToClipboard`,
    and `ReadFigureFromClipboard` methods write and read the first and last endpoints
    of the line after calling the corresponding methods in the `DrawFigure` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteFigureToStream`、`ReadFigureFromStream`、`WriteFigureToClipboard` 和 `ReadFigureFromClipboard`
    方法在调用 `DrawFigure` 类中的相应方法后，写入和读取线的第一个和最后一个端点。'
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The ArrowFigure class
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrowFigure 类
- en: The `ArrowFigure` is a subclass of the `LineFigure` class and reuses the `firstPoint`
    and `lastPoint` fields and some of its functionality. The endpoints of the arrowhead
    are stored in the `leftPoint` and `rightPoint` fields, as shown in the following
    image. The lengths of the sides are defined by the `ArrowLength` constant to 500
    units, which is 5 millimeters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrowFigure` 是 `LineFigure` 类的子类，并重用了 `firstPoint` 和 `lastPoint` 字段以及一些功能。箭头端点存储在
    `leftPoint` 和 `rightPoint` 字段中，如下面的图像所示。边的长度由 `ArrowLength` 常量定义为 500 单位，即 5 毫米。'
- en: '![The ArrowFigure class](img/image_05_010.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![The ArrowFigure class](img/image_05_010.jpg)'
- en: The `ArrowFigure` class overrides some of the methods of the `LineFigure` class.
    Mostly, it calls the methods of the `LineFigure` class and then adds functionality
    of its own.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrowFigure` 类覆盖了 `LineFigure` 类的一些方法。主要的是，它调用 `LineFigure` 类的方法，然后添加自己的功能。'
- en: '**ArrowFigure.h**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**ArrowFigure.h**'
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The constructors let the `LineFigure` constructors initialize the arrow's endpoints,
    and then call the `CalculateArrowHead` method to calculate the endpoints of the
    arrowhead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数允许 `LineFigure` 构造函数初始化箭头的端点，然后调用 `CalculateArrowHead` 方法来计算箭头端点。
- en: '**ArrowFigure.cpp**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**ArrowFigure.cpp**'
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `IsClick` method returns `True` if the user clicks on the line or any part
    of the arrowhead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsClick` 方法如果用户点击线或箭头的任何部分，则返回 `True`。'
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `IsInside` method returns `True` if all the endpoints of the line and arrowhead
    are inside the area.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsInside` 方法如果线的所有端点和箭头都在区域内，则返回 `True`。'
- en: '[PRE34]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Modify` method modifies the line and recalculates the arrowhead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modify` 方法修改线并重新计算箭头。'
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Move` method moves the line and the arrowhead.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move` 方法移动线和箭头。'
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the user double-clicks on the arrow, its head and tail are swapped.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击箭头时，其头部和尾部会交换。
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Area` method calculates the minimum and maximum of the line's and arrowhead's
    endpoints and returns an area with its top-left and bottom-right corners. If the
    arrow is marked, the mark radius is added to the area.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Area` 方法计算线和箭头端点的最小和最大值，并返回一个包含其左上角和右下角的区域。如果箭头被标记，则将标记半径添加到区域中。'
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Draw` method draws the line and the arrowhead. If the arrow is marked,
    the arrow's endpoints are also marked with squares.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw` 方法绘制线和箭头。如果箭头被标记，箭头的端点也会用方块标记。'
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `WriteFigureToStream`, `ReadFigureFromStream`, `WriteFigureToClipboard`,
    and `ReadFigureFromClipboard` methods let the `LineFigure` class write and read
    the line's endpoints. Then it writes and reads the arrowhead's endpoints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteFigureToStream`、`ReadFigureFromStream`、`WriteFigureToClipboard` 和 `ReadFigureFromClipboard`
    方法允许 `LineFigure` 类写入和读取线的端点。然后它写入和读取箭头端点。'
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `CalculateArrowHead` method is a private auxiliary method that calculates
    the endpoints of the arrowhead. We will use the following relations to calculate
    the `leftPoint` and `rightPoint` fields.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculateArrowHead` 方法是一个私有辅助方法，用于计算箭头端点。我们将使用以下关系来计算 `leftPoint` 和 `rightPoint`
    字段。'
- en: '![The ArrowFigure class](img/image_05_011.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![The ArrowFigure class](img/image_05_011.jpg)'
- en: 'The calculation is performed in three steps; first we calculate `alpha` and
    `beta`. See the following illustration for the definition of the angles:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 计算分为三个步骤；首先我们计算 `alpha` 和 `beta`。请参见以下插图以了解角度的定义：
- en: '![The ArrowFigure class](img/image_05_012.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![The ArrowFigure class](img/image_05_012.jpg)'
- en: 'Then we calculate `leftAngle` and `rightAngle` and use their values to calculate
    the value of `leftPoint` and `rightPoint`. The angle between the line and the
    arrowhead parts is 45 degrees, which is equivialent to Π/4 radians. So, in order
    to determine the angles for the arrowhead parts, we simply subtract Π/4 from `beta`
    and add Π/4 to `beta`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们计算 `leftAngle` 和 `rightAngle`，并使用它们的值来计算 `leftPoint` 和 `rightPoint` 的值。线和箭头部分的夹角是
    45 度，相当于 Π/4 弧度。因此，为了确定箭头部分的角，我们只需从 `beta` 中减去 Π/4 并将 Π/4 加到 `beta` 上：
- en: '![The ArrowFigure class](img/image_05_013.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![The ArrowFigure class](img/image_05_013.jpg)'
- en: 'Then we use the following formulas to finally determine `leftPoint` and `rightPoint`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下公式最终确定 `leftPoint` 和 `rightPoint`：
- en: '![The ArrowFigure class](img/image_05_014.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![The ArrowFigure class](img/image_05_014.jpg)'
- en: The trigonometric functions are available in the C standard library. However,
    we need to define our value for Π. The `atan2` function calculates the tangent
    value for the quota of `height` and `width` and takes into consideration the possibility
    that `width` might be zero.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数在 C 标准库中可用。然而，我们需要定义我们的 Π 值。`atan2` 函数计算 `height` 和 `width` 的比例的切线值，并考虑
    `width` 可能为零的可能性。
- en: '![The ArrowFigure class](img/image_05_018.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![The ArrowFigure class](img/image_05_018.jpg)'
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The RectangleFigure class
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RectangleFigure 类
- en: The `RectangleFigure` class holds a rectangle, which can be filled or unfilled.
    The user can modify it by grabbing one of its four corners. The `DrawRectangle`
    class overrides most of the methods of the `DrawFigure` class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`RectangleFigure` 类包含一个矩形，可以是填充的或不填充的。用户可以通过抓住其四个角之一来修改它。`DrawRectangle` 类覆盖了
    `DrawFigure` 类的大部分方法。'
- en: One difference compared to the line and arrow cases is that a rectangle is two-dimensional
    and can be filled or unfilled. The `Fillable` method returns `True` and the `IsFilled`
    and `Fill` methods are overridden. When the user double-clicks on a rectangle
    it will be toggled between the filled and unfilled states.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与线和箭头的情况相比，一个区别是矩形是二维的，可以是填充的或未填充的。`Fillable` 方法返回 `True`，`IsFilled` 和 `Fill`
    方法被覆盖。当用户双击矩形时，它将在填充和未填充状态之间切换。
- en: '**RectangleFigure.h**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**RectangleFigure.h**'
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**RectangleFigure.cpp**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**RectangleFigure.cpp**'
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the user clicks on the rectangle, they may hit one of its four corners,
    the borders of the rectangle, or (if it is filled) its interior. First, we check
    the corners and then the rectangle itself. If it is filled, we just test whether
    the mouse point is enclosed in the rectangle. If the rectangle is unfilled, we
    test whether any of its four borders has been hit by constructing a slightly smaller
    rectangle and a slightly larger one. If the mouse position is included in the
    larger rectangle, but not in the smaller one, the user has hit one of the rectangle
    borders.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击矩形时，他们可能会点击其四个角落之一、矩形的边缘，或者（如果它被填充）其内部。首先，我们检查角落，然后是矩形本身。如果它被填充，我们只需测试鼠标点是否在矩形内。如果矩形未被填充，我们通过构建一个稍微小一点的矩形和一个稍微大一点的矩形来测试是否点击了其任何四个边缘。如果鼠标位置包含在较大的矩形内，但不包含在较小的矩形内，则用户点击了矩形的边缘。
- en: '![The RectangleFigure class](img/image_05_019.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![The RectangleFigure class](img/image_05_019.jpg)'
- en: '[PRE44]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `IsInside` method returns `true` if the top-left and bottom-right corners
    are enclosed by the rectangle area.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsInside` 方法如果矩形的左上角和右下角被矩形区域包围，则返回 `true`。'
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `DoubleClick` method fills the rectangle if it is unfilled and vice versa.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoubleClick` 方法如果矩形未被填充则填充它，反之亦然。'
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Modify` method modifies or moves the rectangle in accordance with the setting
    of the `rectangleMode` parameter in the `IsClick` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modify` 方法根据 `IsClick` 方法中 `rectangleMode` 参数的设置修改或移动矩形。'
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `Move` method moves the rectangle's corners.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move` 方法移动矩形的角落。'
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The area of the rectangle is simply that of the rectangle. However, if it is
    marked, we increase it in order to include the corner squares.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的面积简单地说就是矩形的面积。然而，如果它被标记，我们会增加它以包括角落的正方形。
- en: '![The RectangleFigure class](img/image_05_020.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![The RectangleFigure class](img/image_05_020.jpg)'
- en: '[PRE49]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Draw` method draws or fills the rectangle. It also fills the squares if
    it is marked.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw` 方法绘制或填充矩形。如果它被标记，它还会填充正方形。'
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The cursor of the rectangle is the size-all cursor (arrows in the four compass
    directions) when the figure is being moved. It is a cursor with arrows in accordance
    with the grabbed corner while being modified: north-west and south-east arrows
    in the case of the top-left or bottom-right corner, and north-east and south-west
    arrows in the case of the top-right or bottom-left corner.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当图形被移动时，矩形的指针是大小全指针（四个方向上的箭头）。它是一个根据抓取的角落而修改时带有箭头的指针：如果是最左上角或最右下角，则使用西北和东南箭头；如果是右上角或左下角，则使用东北和西南箭头。
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `WriteFigureToStream`, `ReadFigureFromStream`, `WriteFigureToClipboard`,
    and `ReadFigureFromClipboard` methods call the corresponding methods in the `DrawFigure`
    class. Then they write and read the four corners of the rectangle, and whether
    it is filled or not.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteFigureToStream`、`ReadFigureFromStream`、`WriteFigureToClipboard` 和 `ReadFigureFromClipboard`
    方法调用 `DrawFigure` 类中的相应方法。然后它们写入和读取矩形的四个角，以及它是否被填充。'
- en: '[PRE52]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The EllipseFigure class
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The EllipseFigure 类
- en: The `EllipseFigure` class is a subclass of the `RectangleFigure` class. The
    ellipse can be moved or reshaped by the horizontal or vertical corners. Most of
    the methods from the `RectangleFigure` class are not overridden by the `Ellipse`
    class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`EllipseFigure` 类是 `RectangleFigure` 类的子类。椭圆可以通过水平或垂直角落移动或重塑。`RectangleFigure`
    类的大多数方法都没有被 `Ellipse` 类覆盖。'
- en: '**Ellipse.h**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ellipse.h**'
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Ellipse.cpp**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ellipse.cpp**'
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Just as in the rectangle case, the `IsClick` method first decides if the user
    has clicked on one of the four endpoints; however, the positions are different
    compared to the rectangle corners.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如矩形的情况一样，`IsClick` 方法首先决定用户是否点击了四个端点之一；然而，与矩形角落的位置相比，这些位置是不同的。
- en: '![The EllipseFigure class](img/image_05_021.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![The EllipseFigure class](img/image_05_021.jpg)'
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the user has not clicked on one of the modifying positions, we have to decide
    if the user has clicked on the ellipse itself. It is rather easy if the ellipse
    is not filled. We create an elliptic region by using the Win32 API function `CreateEllipticRgn`
    and test if the mouse position is in it. If the ellipse is not filled, we create
    two regions, one slightly smaller and one slightly larger. If the mouse position
    is included in the larger region, but not in the smaller one, we have a hit.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有点击任何一个修改位置，我们必须决定用户是否点击了椭圆本身。如果椭圆没有填充，这相当简单。我们使用Win32 API函数`CreateEllipticRgn`创建一个椭圆区域，并测试鼠标位置是否在其中。如果椭圆没有填充，我们创建两个区域，一个稍微小一些，一个稍微大一些。如果鼠标位置包含在较大的区域中，但不包含在较小的区域中，则表示发生了点击。
- en: '![The EllipseFigure class](img/image_05_022.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![EllipseFigure类](img/image_05_022.jpg)'
- en: '[PRE56]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Modify` method moves the corner in accordance with the setting of the `ellipseMode`
    parameter in the `IsClick` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modify`方法根据`IsClick`方法中`ellipseMode`参数的设置移动角落。'
- en: '[PRE57]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Draw` method fills or draws the ellipse, and the four squares if the ellipse
    is marked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw`方法填充或绘制椭圆，如果椭圆被标记，则绘制四个方块。'
- en: '[PRE58]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, when it comes to the cursor, we have the following five different
    cases:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于光标，我们有以下五种不同的情况：
- en: When the ellipse is being created, the crosshair is returned
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当椭圆正在创建时，会返回十字光标
- en: When the user grabs the left or right endpoint of the ellipse, the west-east
    (left-right) arrow is returned
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户抓住椭圆的左端点或右端点时，会返回东西（左右）箭头
- en: When the user grabs the top or bottom endpoint, the top-bottom (up-down) arrow
    is returned
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户抓住椭圆的顶部或底部端点时，会返回上下（上下）箭头
- en: When the user moves the ellipse, the size-all arrow (four arrows that point
    left, right, up, and down) is returned
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户移动椭圆时，会返回大小箭头（指向左、右、上、下的四个箭头）
- en: Finally, when the user neither moves nor modifies the ellipse, the normal arrow
    cursor is returned
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当用户既不移动也不修改椭圆时，会返回正常的箭头光标
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you studied the figure class hierarchy for the drawing program
    of [Chapter 4](ch04.html "Chapter 4. Working with Shapes and Figures"), *Working
    with Shapes and Figures*. You covered the following topics:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了[第4章](ch04.html "第4章。处理形状和图形")中绘图程序的图形类层次结构，*处理形状和图形*。你涵盖了以下主题：
- en: Testing whether the figure has been hit by a mouse click or if it is enclosed
    by a rectangle
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试图形是否被鼠标点击击中或是否被矩形包围
- en: Modification and movement of the figure
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形的修改和移动
- en: Drawing the figure and calculating the area of the figure
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制图形和计算图形的面积
- en: Writing and reading the figure to and from a file stream or the clipboard
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图形写入和读取到文件流或剪贴板
- en: Cursor handling with different cursors depending on the current state of figure
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据图形的当前状态使用不同光标的游标处理
- en: In [Chapter 6](ch06.html "Chapter 6. Building a Word Processor"), *Building
    a Word Processor*, you will start developing a word processor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。构建字处理器")中，*构建字处理器*，你将开始开发字处理器。
