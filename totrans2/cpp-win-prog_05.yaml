- en: Chapter 5. The Figure Hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the figure classes of the drawing program. Each figure
    is responsible for deciding whether it is hit by a mouse click or if it is enclosed
    by a rectangle. It is also responsible for moving or modifying, as well as drawing
    and communicating with a file stream and the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawing figure hierarchy is made up of the `Draw`, `LineFigure`, `ArrowFigure`,
    `RectangleFigure`, and `EllipseFigure` classes, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Figure Hierarchy](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The DrawFigure class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Draw` class is the root class of the hierarchy and is mostly made up of
    virtual and pure virtual methods intended to be overridden by the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a virtual method and a pure virtual method is that the
    virtual method has a body and it may be overridden by a subclass. If the subclass
    overrides the method, its version of the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the subclass does not override the method, the method of the base class
    is called instead. A pure virtual method does not usually have a body, and a class
    holding at least one pure virtual method becomes abstract. The subclass can either
    override all the pure virtual methods of its base class or become abstract itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Draw.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each figure has its own identity number, returned by the `GetId` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsClick` method returns `True` if the mouse point hits the figure, and
    the `IsInside` method returns `True` if the figure is completely enclosed by the
    area. The `DoubleClick` method gives the figure a possibility to perform a figure-specific
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Modify` and `Move` methods simply move the figure. However, the `Modify`
    method performs figure-specific actions defined by the `IsClick` method. If the
    user clicked on one of the figure endpoints, it will be modified, and if they
    clicked on any other part of the figure, it will be moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Invalidate` method invalidates the figure by calling the `Area` method,
    which returns the area occupied by the figure. The `Draw` method draws the figure
    with the given `Graphics` class''s reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsFillable`, `IsFilled`, and `Fill` methods are only overridden by the
    `Rectangle` and `Ellipse` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteFigureToStream` and `ReadFigureFromStream` methods are called when
    the user opens or saves a document. They write or read the information of the
    figure to and from the streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteFigureToClipboard` and `ReadFigureFromClipboard` methods are called
    when the user copies or pastes figures. They write information to a character
    list and read information to a character buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `color` and `marked` fields have their own get and set methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetCursor` method returns the correct cursor for the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MarkRadius` method is the size of the small squares showing that the figure
    is marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `windowPtr` pointer is used when invalidating the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each figure, regardless of its type, has a color and is marked or unmarked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Draw.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MarkRadius` parameter is set to 100 * 100 units, which is 1 * 1 millimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When a figure is created, it is always unmarked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We redraw when the user toggles the figure's marked state. You may notice the
    different order in the `if...else` statements. The reason is that when we mark
    a figure, it becomes larger; that is why we first set the `marked` parameter to
    `True` and then invalidate the figure to catch its area including its markings.
    On the other hand, when we unmark a figure it becomes smaller; that is why we
    first invalidate it to catch its area, including the markings, and then set the
    `marked` parameter to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The color is the only field written or read in file handling and in communication
    with the clipboard. The subclasses of the `DrawFigure` class call these methods
    and then write and read figure-specific information. The `WriteFigureToStream`
    and `ReadFigureFromStream` methods return the Boolean value of the stream to indicate
    whether the file operation succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The LineFigure class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A line is drawn between two points, represented by the `firstPoint` field to
    the `lastPoint` field in the `LineFigure` class, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `header` file overrides some of the methods of its `DrawFigure` base class.
    The `DoubleClick` method does nothing. As I see it, there is no really meaningful
    response to a double-click on a line. However, we still need to override the `DoubleClick`
    method, since it is a pure virtual method in the `DrawFigure` base class. If we
    do not override it, the `LineFigure` class will be abstract.
  prefs: []
  type: TYPE_NORMAL
- en: '**LineFigure.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**LineFigure.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `SetFirstPoint` method is called when the line is created and sets both
    the first and last points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsClick` method has two cases: the user has to hit either one of the endpoints
    or the line itself. We define two squares (`firstSquare` and `lastSquare`) covering
    the endpoints, and test whether the mouse hits one of them. If not, we test whether
    the mouse hits the line itself by calling the `IsPointInLine` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `IsPointInLine` method checks whether the point is located on the line,
    with some tolerance. We use trigonometric functions to calculate the position
    of the point relative to the line. However, if the line is completely vertical
    and the points have the same x coordinate, we have a special case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the trigonometric functions would result in division by zero. Instead,
    we create a small rectangle surrounding the line and check if the point is located
    in the rectangle, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the line is not vertical, we start by creating an enclosing rectangle and
    test if the mouse point is in it. If it is, we let the leftmost point of the `firstPoint`
    and `lastPoint` fields equal to the `minPoint` field and the rightmost point equal
    to the `maxPoint` field. Then we calculate the width (`lineWidth`) and height
    (`lineHeight`) of the enclosing rectangle, as well as the distance between the
    `minPoint` and `mousePoint` fields in x and y directions (`diffWidth` and `diffHeight`),
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Due to uniformity, the following equation is true if the mouse point hits the
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This implies that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And this also implies that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us allow for a small tolerance; let us say that the user is allowed to
    miss the line by a millimeter (100 units). This changes the last equation to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LineFigure class](img/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `IsInside` method is easier than the `IsClick` method. We just check whether
    both endpoints are enclosed by the given rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the `Modify` mode, we move one of the endpoints or the line depending on
    the value of the `lineMode` parameter set by the `IsClick` method. If the user
    has hit the first point, we move it. If they have hit the last point, or if the
    line is in the process of being created, we move the last point. If they have
    hit the line, we move the line. That is, we move both the first and last points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `Move` method is also easy; we just move the two endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the `Draw` method, we draw the line and, if the line is marked, its two endpoints
    are always black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The area occupied by the line is a rectangle with the endpoints as corners.
    If the line is marked, the mark radius is added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the line is being modified, the `Crosshair` cursor is returned. If it is
    being moved, the size-all cursor (four arrows in the compass directions) is returned.
    If none of these cases apply, then we just return the normal arrow cursor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `WriteFigureToStream`, `ReadFigureFromStream`, `WriteFigureToClipboard`,
    and `ReadFigureFromClipboard` methods write and read the first and last endpoints
    of the line after calling the corresponding methods in the `DrawFigure` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The ArrowFigure class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ArrowFigure` is a subclass of the `LineFigure` class and reuses the `firstPoint`
    and `lastPoint` fields and some of its functionality. The endpoints of the arrowhead
    are stored in the `leftPoint` and `rightPoint` fields, as shown in the following
    image. The lengths of the sides are defined by the `ArrowLength` constant to 500
    units, which is 5 millimeters.
  prefs: []
  type: TYPE_NORMAL
- en: '![The ArrowFigure class](img/image_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ArrowFigure` class overrides some of the methods of the `LineFigure` class.
    Mostly, it calls the methods of the `LineFigure` class and then adds functionality
    of its own.
  prefs: []
  type: TYPE_NORMAL
- en: '**ArrowFigure.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The constructors let the `LineFigure` constructors initialize the arrow's endpoints,
    and then call the `CalculateArrowHead` method to calculate the endpoints of the
    arrowhead.
  prefs: []
  type: TYPE_NORMAL
- en: '**ArrowFigure.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `IsClick` method returns `True` if the user clicks on the line or any part
    of the arrowhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `IsInside` method returns `True` if all the endpoints of the line and arrowhead
    are inside the area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `Modify` method modifies the line and recalculates the arrowhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Move` method moves the line and the arrowhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When the user double-clicks on the arrow, its head and tail are swapped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `Area` method calculates the minimum and maximum of the line's and arrowhead's
    endpoints and returns an area with its top-left and bottom-right corners. If the
    arrow is marked, the mark radius is added to the area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Draw` method draws the line and the arrowhead. If the arrow is marked,
    the arrow's endpoints are also marked with squares.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `WriteFigureToStream`, `ReadFigureFromStream`, `WriteFigureToClipboard`,
    and `ReadFigureFromClipboard` methods let the `LineFigure` class write and read
    the line's endpoints. Then it writes and reads the arrowhead's endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `CalculateArrowHead` method is a private auxiliary method that calculates
    the endpoints of the arrowhead. We will use the following relations to calculate
    the `leftPoint` and `rightPoint` fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![The ArrowFigure class](img/image_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The calculation is performed in three steps; first we calculate `alpha` and
    `beta`. See the following illustration for the definition of the angles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ArrowFigure class](img/image_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we calculate `leftAngle` and `rightAngle` and use their values to calculate
    the value of `leftPoint` and `rightPoint`. The angle between the line and the
    arrowhead parts is 45 degrees, which is equivialent to Π/4 radians. So, in order
    to determine the angles for the arrowhead parts, we simply subtract Π/4 from `beta`
    and add Π/4 to `beta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ArrowFigure class](img/image_05_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we use the following formulas to finally determine `leftPoint` and `rightPoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ArrowFigure class](img/image_05_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The trigonometric functions are available in the C standard library. However,
    we need to define our value for Π. The `atan2` function calculates the tangent
    value for the quota of `height` and `width` and takes into consideration the possibility
    that `width` might be zero.
  prefs: []
  type: TYPE_NORMAL
- en: '![The ArrowFigure class](img/image_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The RectangleFigure class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RectangleFigure` class holds a rectangle, which can be filled or unfilled.
    The user can modify it by grabbing one of its four corners. The `DrawRectangle`
    class overrides most of the methods of the `DrawFigure` class.
  prefs: []
  type: TYPE_NORMAL
- en: One difference compared to the line and arrow cases is that a rectangle is two-dimensional
    and can be filled or unfilled. The `Fillable` method returns `True` and the `IsFilled`
    and `Fill` methods are overridden. When the user double-clicks on a rectangle
    it will be toggled between the filled and unfilled states.
  prefs: []
  type: TYPE_NORMAL
- en: '**RectangleFigure.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**RectangleFigure.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks on the rectangle, they may hit one of its four corners,
    the borders of the rectangle, or (if it is filled) its interior. First, we check
    the corners and then the rectangle itself. If it is filled, we just test whether
    the mouse point is enclosed in the rectangle. If the rectangle is unfilled, we
    test whether any of its four borders has been hit by constructing a slightly smaller
    rectangle and a slightly larger one. If the mouse position is included in the
    larger rectangle, but not in the smaller one, the user has hit one of the rectangle
    borders.
  prefs: []
  type: TYPE_NORMAL
- en: '![The RectangleFigure class](img/image_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `IsInside` method returns `true` if the top-left and bottom-right corners
    are enclosed by the rectangle area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `DoubleClick` method fills the rectangle if it is unfilled and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `Modify` method modifies or moves the rectangle in accordance with the setting
    of the `rectangleMode` parameter in the `IsClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `Move` method moves the rectangle's corners.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The area of the rectangle is simply that of the rectangle. However, if it is
    marked, we increase it in order to include the corner squares.
  prefs: []
  type: TYPE_NORMAL
- en: '![The RectangleFigure class](img/image_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `Draw` method draws or fills the rectangle. It also fills the squares if
    it is marked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The cursor of the rectangle is the size-all cursor (arrows in the four compass
    directions) when the figure is being moved. It is a cursor with arrows in accordance
    with the grabbed corner while being modified: north-west and south-east arrows
    in the case of the top-left or bottom-right corner, and north-east and south-west
    arrows in the case of the top-right or bottom-left corner.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `WriteFigureToStream`, `ReadFigureFromStream`, `WriteFigureToClipboard`,
    and `ReadFigureFromClipboard` methods call the corresponding methods in the `DrawFigure`
    class. Then they write and read the four corners of the rectangle, and whether
    it is filled or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The EllipseFigure class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EllipseFigure` class is a subclass of the `RectangleFigure` class. The
    ellipse can be moved or reshaped by the horizontal or vertical corners. Most of
    the methods from the `RectangleFigure` class are not overridden by the `Ellipse`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ellipse.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Ellipse.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Just as in the rectangle case, the `IsClick` method first decides if the user
    has clicked on one of the four endpoints; however, the positions are different
    compared to the rectangle corners.
  prefs: []
  type: TYPE_NORMAL
- en: '![The EllipseFigure class](img/image_05_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the user has not clicked on one of the modifying positions, we have to decide
    if the user has clicked on the ellipse itself. It is rather easy if the ellipse
    is not filled. We create an elliptic region by using the Win32 API function `CreateEllipticRgn`
    and test if the mouse position is in it. If the ellipse is not filled, we create
    two regions, one slightly smaller and one slightly larger. If the mouse position
    is included in the larger region, but not in the smaller one, we have a hit.
  prefs: []
  type: TYPE_NORMAL
- en: '![The EllipseFigure class](img/image_05_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `Modify` method moves the corner in accordance with the setting of the `ellipseMode`
    parameter in the `IsClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `Draw` method fills or draws the ellipse, and the four squares if the ellipse
    is marked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when it comes to the cursor, we have the following five different
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When the ellipse is being created, the crosshair is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user grabs the left or right endpoint of the ellipse, the west-east
    (left-right) arrow is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user grabs the top or bottom endpoint, the top-bottom (up-down) arrow
    is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user moves the ellipse, the size-all arrow (four arrows that point
    left, right, up, and down) is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when the user neither moves nor modifies the ellipse, the normal arrow
    cursor is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you studied the figure class hierarchy for the drawing program
    of [Chapter 4](ch04.html "Chapter 4. Working with Shapes and Figures"), *Working
    with Shapes and Figures*. You covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing whether the figure has been hit by a mouse click or if it is enclosed
    by a rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modification and movement of the figure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing the figure and calculating the area of the figure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and reading the figure to and from a file stream or the clipboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cursor handling with different cursors depending on the current state of figure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Building a Word Processor"), *Building
    a Word Processor*, you will start developing a word processor.
  prefs: []
  type: TYPE_NORMAL
