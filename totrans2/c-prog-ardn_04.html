<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Improve Programming with Functions, Math, and Timing</h1></div></div></div><p>As a digital artist, I need special conditions to be able to work. We all need our own environment and ambience to be productive. Even if each one of us has his/her own way, there are many things in common.</p><p>In this chapter, I want to give you elements that will make you more comfortable to write source code that is easily readable, reusable and, as much as possible, beautiful. Like Yin and Yang, for me there has always been a Zen-like quality to the artistic and coding sides of me. Here is where I can deliver some programming pearls of wisdom to bring peace of mind to your creative side.</p><p>We are going to learn something we have already used a bit before: functions. They contribute to improve both readability and efficiency at the same time. As we do that, we'll touch on some mathematics and trigonometry often used in many projects. We'll also talk about some approaches to calculation optimization, and we'll finish this chapter with timing-related events or actions within the Arduino's firmware. </p><p>It is going to be a very interesting chapter before the real dive into pure Arduino's projects!</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Introducing functions</h1></div></div></div><p>A function<a id="id369" class="indexterm"/> is a piece of code defined by a name and that can be reused/executed from many different points in a <a id="id370" class="indexterm"/>C program. The name of a function has to be <em>unique</em> in a C program. It is also <code class="literal">global</code>, which means, as you already read for variables, it can be used everywhere in the C program containing the function declaration/definition in its scope (see the The scope concept section in <a class="link" href="ch03.html" title="Chapter 3. C Basics – Making You Stronger">Chapter 3</a>, <em>C Basics – Making You Stronger</em>).</p><p>A function can require special elements to be passed to it; these are called <a id="id371" class="indexterm"/>
<strong>arguments</strong>. A function can also produce and return<a id="id372" class="indexterm"/> <strong>results</strong>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Structure of a function</h2></div></div></div><p>A function is a block <a id="id373" class="indexterm"/> of code that has a header and a body. In standard C, a function's declaration and definition are made separately. The declaration of the function is specifically called the declaration of the prototype of the function and has to be done in the<a id="id374" class="indexterm"/> <strong>header file</strong> (see <a class="link" href="ch02.html" title="Chapter 2. First Contact with C">Chapter 2</a>, <em>First Contact with C</em>).</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec30"/>Creating function prototypes using the Arduino IDE</h3></div></div></div><p>The <a id="id375" class="indexterm"/>Arduino IDE makes our life easier; it creates <a id="id376" class="indexterm"/>function prototypes for us. But in special cases, if you need to declare a function prototype, you can do that in the same code file at the beginning of the code. This provides a nice way of source code centralization.</p><p>Let's take an easy example, we want to create a function that sums two integers and produces/returns the result. There are two arguments that are integer type variables. In this case, the result of the addition of these two <code class="literal">int</code> (integer) values is also an <code class="literal">int</code> value. It doesn't have to be, but for this example it is. The prototype in that case would be:</p><div><pre class="programlisting">int mySum(int m, int n);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec31"/>Header and name of functions</h3></div></div></div><p>Knowing what <a id="id377" class="indexterm"/>
<a id="id378" class="indexterm"/>
<a id="id379" class="indexterm"/>
<a id="id380" class="indexterm"/>prototype looks like is interesting because it is similar to what we call the header. The header of a function is its first statement definition. Let's move further by writing the global structure of our function <code class="literal">mySum</code>:</p><div><pre class="programlisting">int mySum(int m, int n) // this row is the header
{
  // between curly brackets sits the body
}</pre></div><p>The header has the global form:</p><div><pre class="programlisting">returnType functionName(arguments)</pre></div><p>
<code class="literal">returnType</code> is a variable type. By now, I guess you understand the <code class="literal">void</code> type better. In the case where our function doesn't return anything, we have to specify it by choosing <code class="literal">returnType</code> equals to <code class="literal">void</code>.</p><p>
<code class="literal">functionName</code> has to be chosen to be easy to remember and should be as self-descriptive as possible. Imagine supporting code written by someone else. Finding <code class="literal">myNiceAndCoolMathFunction</code> requires research. On the other hand, <code class="literal">mySum</code> is self-explanatory. Which code example would you rather support?</p><p>The Arduino core (and even C) follows a naming convention called camel case. The difference between two words, because we <em>cannot</em> use the blank/space character in a function name, is made by putting the first letter of words as uppercase characters. It isn't necessary, but it is recommended especially if you want to save time later. It's easier to read and makes the function self-explanatory.</p><p>
<code class="literal">mysum</code> is less <a id="id381" class="indexterm"/>
<a id="id382" class="indexterm"/>
<a id="id383" class="indexterm"/>
<a id="id384" class="indexterm"/>readable than <code class="literal">mySum</code>, isn't it? Arguments are a series of variable declarations. In our <code class="literal">mySum</code> example, we created two function arguments. But we could also have a function without arguments. Imagine a function that you need to call to produce an action that would always be the same, not depending on variables. You'd make it like this:</p><div><pre class="programlisting">int myAction()
{
  // between curly brackets sits the body
}</pre></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Variables<a id="id385" class="indexterm"/> declared within a function are known only to the function containing them. This is what's known <a id="id386" class="indexterm"/>as "scope". Such variables declared within a function cannot be accessed anywhere else, but they can be "passed". Variables which can be passed are known as <a id="id387" class="indexterm"/> <strong>arguments</strong>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec32"/>Body and statements of functions</h3></div></div></div><p>As you probably<a id="id388" class="indexterm"/>
<a id="id389" class="indexterm"/>
<a id="id390" class="indexterm"/>
<a id="id391" class="indexterm"/> intuitively understood, the body is the place where everything happens; it's where all of a function's instruction steps are constructed.</p><p>Imagine the body as a real, pure, and new block of source code. You can declare and define variables, add conditions, and play with loops. Imagine the body (of instructions) as where the sculptor's clay is shaped and molded and comes out in the end with the desired effect; perhaps in one piece or many, perhaps in identical copies, and so on. It's the manipulation of what there is, but remember: Garbage in, garbage out!</p><p>You can also, as we just introduced, return a variable's value. Let's create the body of our <code class="literal">mySum</code> example:</p><div><pre class="programlisting">int mySum(int m, int n) // this row is the header
{
  int result;		// this is the variable to store the result
  result = m + n; 	// it makes the sum and store it in result
  return result;	// it returns the value of result variable
}</pre></div><p>
<code class="literal">int result;</code> declares the variable, and names it <code class="literal">result</code>. Its scope is the same as the scope of arguments. <code class="literal">result = m + n;</code> contains two operators, and you already know that <code class="literal">+</code> has a higher precedence than <code class="literal">=</code> which is pretty good, as the mathematical operation is made first and then the result is stored in the <code class="literal">result</code> variable. This is where the magic happens; take two operators, and make one out of them. Remember that, in a combination of multiple mathematical operations, do not forget the order of precedence; it's critical so that we don't get unexpected results.</p><p>At last, <code class="literal">return result;</code> is the statement that makes the function call resulting into a value. Let's <a id="id392" class="indexterm"/>
<a id="id393" class="indexterm"/>
<a id="id394" class="indexterm"/>
<a id="id395" class="indexterm"/>check an actual example of the Arduino code to understand this better:</p><div><pre class="programlisting">void setup() {
Serial.begin(9600); Let's check an actual example of Arduino code to understand this better.
}	

Void loop() {
// let's sum all integers from 0 to 99, 2 by 2 and display
int currentResult;		
for (int i = 0 ; i &lt; 100 ; i++)
{
  currentResult = mySum(i,i+1);	// sum and store
  Serial.println(currentResult);	// display to serial monitor
}
delay(2000); make a 2 second pause
}
int mySum(int m, int n) // this row is the header
{
  int result;		// this is the variable to store the result
  result = m + n; 	// it makes the sum and store it in result
  return result;	// it returns the value of result variable
}</pre></div><p>As you have just seen, the <code class="literal">mySum</code> function has been defined and called in the example. The most important statement is <code class="literal">currentResult = mySum(i,i+1);</code>. Of course, the <code class="literal">i</code> and <code class="literal">i+1</code> trick is interesting, but the most important thing to recognize here is the usage of the variable <code class="literal">currentResult</code> that was declared at the beginning of the<a id="id396" class="indexterm"/><code class="literal">loop()</code> function.</p><p>In programming, it's important to recognize that everything at the right (contents) goes into the left (the new container). According to the precedence rules, a function call has a precedence of 2 against 16 for the <code class="literal">=</code> assignment operator. It means the call is made first and the function returns the result of the <code class="literal">+</code> operation, as we designed it. From this point of view, you just learned something very important: <em>The call statement of a function returning a result is a value</em>.</p><p>You can <a id="id397" class="indexterm"/>
<a id="id398" class="indexterm"/>
<a id="id399" class="indexterm"/>
<a id="id400" class="indexterm"/>check <em>Appendix B, Operator Precedence in C and C++</em> for the entire precedencies list. As with all values within a variable, we can store it into another, here inside the integer variable <code class="literal">result</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Benefits of using functions</h2></div></div></div><p>Programming is about <a id="id401" class="indexterm"/>
<a id="id402" class="indexterm"/>writing pieces of code for general and specific purposes. Using functions is one of the best ways of segmenting your code.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec33"/>Easier coding and debugging</h3></div></div></div><p>Functions can really help us to be better organized. While designing the program, we often use pseudo-codes and this is also the step when we notice that there are a lot of common statements. These common statements may often be put inside functions.</p><p>The function/call pattern is also easier to debug. We have only one part of code where the function sits. If there is a problem, we can debug the function itself just once, and all the calls will then be fixed instead of modifying the whole part of the code.</p><div><img src="img/7584_04_001.jpg" alt="Easier coding and debugging"/><div><p>Functions make your code easier to debug</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec34"/>Better modularity helps reusability</h3></div></div></div><p>Some part of <a id="id403" class="indexterm"/>
<a id="id404" class="indexterm"/>your code will be high level and general. For instance, at some point, you may need a series of statements that can cut an array into pieces, then regroup all values following a basic rule. This series could be the body of a function. In another way, coding a function that converts Fahrenheit units into Celsius could interest you. These two examples are general-purpose functions.</p><p>In contrast, you can also have a specific function whose sole purpose is to convert U.S. Dollars to French Francs. You may not call it very often, but if occasionally necessary, it is always ready to handle that task.</p><p>In both cases, the function can be used and of course, re-used. The idea behind this is to save time. It also means that you can grab some already existing functions and re-use them. Of course, it has to be done following some principles, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Code licensing </li><li class="listitem" style="list-style-type: disc">Respect the API of the function that can be a part of a library</li><li class="listitem" style="list-style-type: disc">Good match for your purpose</li></ul></div><p>
<strong>Code licensing</strong> issue<a id="id405" class="indexterm"/> is an important point. We are used to grabbing, testing, and copy/pasting things, but the code you find isn't always in the public domain. You have to take care of the license file that is often included in a code release archive, and in the first line of the code too, where comments can help you understand the conditions to respect the re-use of it. </p><p>
<strong>Application Programming Interface</strong> (<strong>API</strong>)<a id="id406" class="indexterm"/> means you have to conform yourself to some documentation before using the material related to that API. I understand that purists would consider this a small abuse, but it is a pretty pragmatic definition.</p><p>Basically, an API defines specifications for routines, data structures, and other code entities that can be re-used inside other programs. An API specification can be documentation of a library. In that case, it would precisely define what you can and cannot do.</p><p>The good-match principle can seem obvious, but sometimes out of convenience we find an existing library and choose to use it rather than coding our own solution. Unfortunately, sometimes in the end we only add more complication than originally intended. Doing it ourselves may fulfil the simple need, and will certainly avoid the complexities and idiosyncrasies of a more comprehensive solution. There's also the avoidance of a potential performance hit; you don't buy a limo when all you really need is to walk to the supermarket just down the street.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec35"/>Better readability</h3></div></div></div><p>It is a <a id="id407" class="indexterm"/>
<a id="id408" class="indexterm"/>consequence of the other benefits, but I want to make you understand that this is more vital than commenting your code. Better readability means saving time to focus on something else. It also means easier code upgrade and improvement steps.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>C standard mathematical functions and Arduino</h1></div></div></div><p>As we have <a id="id409" class="indexterm"/>already seen, almost all standard C <a id="id410" class="indexterm"/>and C++ entities supported by the compiler <a id="id411" class="indexterm"/>
<strong>avr-g++</strong> should work with Arduino. This is also true for C mathematical functions.</p><p>This group of functions is a part of the (famous) C standard library. A lot of functions of this group are inherited in C++. There are some differences between C and C++ in the use of complex numbers. C++ doesn't provide complex numbers handling from that library but from its own C++ standard library by using the class <a id="id412" class="indexterm"/>template <code class="literal">std::complex</code>.</p><p>Almost all these functions are designed to work with and manipulate floating-point numbers. In standard C, this library is known as<a id="id413" class="indexterm"/> <code class="literal">math.h</code> (a filename), which we mention in the header of a C program, so that we can use its functions.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Trigonometric C functions in the Arduino core</h2></div></div></div><p>We often need to <a id="id414" class="indexterm"/>
<a id="id415" class="indexterm"/>make some trigonometric calculations, from determining distances an object has moved, to angular speed, and many other real-world properties. Sometimes, you'll need to do that inside Arduino itself because you'll use it as an autonomous smart unit without any computers in the neighborhood. </p><p>The Arduino core provides the classic trigonometric functions that can be summarized by writing their prototypes. A major part of these return results in radians. Let's begin by reviewing our trigonometry just a bit!</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec36"/>Some prerequisites</h3></div></div></div><p>I promise, I'll be quick and light. But the following lines of text will save you time looking for your old and torn school book. When I learn knowledge from specific fields, I personally like to have all I need close at hand.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec14"/>Difference between radians and degrees</h4></div></div></div><p>
<strong>Radian</strong>
<a id="id416" class="indexterm"/> is the unit used by many trigonometric functions. Then, we have to be clear about radians and <a id="id417" class="indexterm"/>
<a id="id418" class="indexterm"/>degrees, and especially how to convert one into the other. Here is the official radian definition: <strong>Alpha</strong> <a id="id419" class="indexterm"/>is a ratio between two distances and is in radian units.</p><div><img src="img/7584_04_002.jpg" alt="Difference between radians and degrees"/><div><p>Radian definition</p></div></div><p>
<strong>Degree</strong>
<a id="id420" class="indexterm"/> is the 1/360 of<a id="id421" class="indexterm"/>
<a id="id422" class="indexterm"/> a full rotation (complete circle). Considering these two definitions and the fact that a complete rotation equals 2π, we can convert one into the other: </p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>angleradian = angledegree x π/180</p><p>angledegree = angleradian x 180/π</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec15"/>Cosine, sine, and tangent</h4></div></div></div><p>Let's see the<a id="id423" class="indexterm"/> trigonometric triangle example:</p><div><img src="img/7584_04_003.jpg" alt="Cosine, sine, and tangent"/></div><p>Considering the angle A in radians, we can define cosine, sine, and tangent<a id="id424" class="indexterm"/> as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">cos(A) = b/h</li><li class="listitem" style="list-style-type: disc">sin(A) = a/h</li><li class="listitem" style="list-style-type: disc">tan(A) = sin(A)/cos(A) = a/b</li></ul></div><p>Cosine<a id="id425" class="indexterm"/> and sine<a id="id426" class="indexterm"/> evolve from -1 to 1 for value of <a id="id427" class="indexterm"/>angles in radians, while tangent has some special points where it isn't defined and then evolves cyclically from -∞ to +∞. We can represent them on the same graph as follows:</p><div><img src="img/7584_04_004.jpg" alt="Cosine, sine, and tangent"/><div><p>Graphical cosine, sine, and tangent representation</p></div></div><p>Yes, of course, those<a id="id428" class="indexterm"/> functions oscillate, infinitely reproducing the same evolutions. It is good to keep in mind that they can be used for pure calculations but also to avoid overly linear value evolution in the time by replacing linearity by smoother oscillations. We'll see that a bit later.</p><p>We know how to calculate a cosine/sine/tangent when we have an angle, but how to calculate an angle when we already have the cosine/sine/tangent?</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec16"/>Arccosine, arcsine, and arctangent</h4></div></div></div><p>Arccosine<a id="id429" class="indexterm"/>, <a id="id430" class="indexterm"/>arcsine, and arctangent<a id="id431" class="indexterm"/> are called inverse trigonometric functions<a id="id432" class="indexterm"/>. These functions are used to calculate an angle when you already have the distance ratios that I mentioned before.</p><p>They are called inverse because this is the inverse/reciprocal process of the previously seen trigonometric function. Basically, these functions provide you an angle, but considering the periodicity, they provide a lot of angles. If k is an integer, we can write:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">sin (A) = x ó A = arcsin(x) + 2kπ or y = π – arcsin(x) + 2kπ</li><li class="listitem" style="list-style-type: disc">cos (A) = x ó A = arccos(x) + 2kπ or y = 2π – arccos (x) + 2kπ</li><li class="listitem" style="list-style-type: disc">tan (A) = x ó A = arctan(x) + kπ</li></ul></div><p>These are the right mathematical relationships. Practically, in usual cases, we can drop the full rotation cases and forget about the 2kπ of the cosine and sine cases and kπ of the tangent case.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec37"/>Trigonometry functions</h3></div></div></div><p>
<code class="literal">Math.h</code> <a id="id433" class="indexterm"/>contains the <a id="id434" class="indexterm"/>trigonometry function's prototype, so does the Arduino core:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">double cos (double x);</code> returns the cosine of <code class="literal">x</code> radians</li><li class="listitem" style="list-style-type: disc"><code class="literal">double sin (double x);</code> returns the sine of <code class="literal">x</code> radians</li><li class="listitem" style="list-style-type: disc"><code class="literal">double tan (double x);</code> returns the tangent of <code class="literal">x</code> radians</li><li class="listitem" style="list-style-type: disc"><code class="literal">double acos (double x);</code> returns A, the angle corresponding to cos (A) = <code class="literal">x</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double asin (double x);</code> returns A, the angle corresponding to sin (A) = <code class="literal">x</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double atan (double x);</code> returns A, the angle corresponding to tan (A) = <code class="literal">x</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double atan2 (double y, double x);</code> returns arctan (<code class="literal">y</code>/<code class="literal">x</code>)</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Exponential functions and some others</h2></div></div></div><p>Making calculations, <a id="id435" class="indexterm"/>
<a id="id436" class="indexterm"/>even basic ones, involves other types of mathematical functions, namely power, absolute value, and so on. The Arduino core then implements those. Some mathematical functions are given as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">double pow (double x, double y);</code> returns <code class="literal">x</code> to power <code class="literal">y</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double exp (double x);</code> returns the exponential value of <code class="literal">x</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double log (double x);</code> returns the natural logarithm of <code class="literal">x</code> with <code class="literal">x</code> &gt; 0</li><li class="listitem" style="list-style-type: disc"><code class="literal">double log10 (double x);</code> returns the logarithm of <code class="literal">x</code> to base 10 with <code class="literal">x</code> &gt; 0</li><li class="listitem" style="list-style-type: disc"><code class="literal">double square (double x);</code> returns the square of <code class="literal">x</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double sqrt (double x);</code> returns the square root of <code class="literal">x</code> with <code class="literal">x</code> &gt;= 0</li><li class="listitem" style="list-style-type: disc"><code class="literal">double fabs (double x);</code> returns the absolute value of <code class="literal">x</code></li></ul></div><p>Of course, mathematical rules, especially considering range of values, have to be respected. This is why I added some conditions of <code class="literal">x</code> to the list.</p><p>All these functions are very useful, even for solving small problems. One day, I was teaching someone at a workshop and had to explain about measuring temperature with a sensor. This student was quite motivated but didn't know about these functions because she only played with inputs and outputs without converting anything (because she basically didn't need that). We then learned these functions, and she ended by even optimizing her firmware, which made me so proud of her!</p><p>Now, let's <a id="id437" class="indexterm"/>
<a id="id438" class="indexterm"/>approach some methods of optimization.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Approaching calculation optimization</h1></div></div></div><p>This section is an <a id="id439" class="indexterm"/>approach. It means it doesn't contain all the advanced tips and tricks for programming optimizations, but contains the optimizations on pure calculation.</p><p>Generally, we design an idea, code a program, and then optimize it. It works fine for huge programs. For smaller ones, we can optimize while coding. </p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Normally, our firmware is small and so I'd suggest that you consider this as a new rule: Write each statement keeping optimization in mind.</p></div></div><p>I could add something else right now: Don't kill the readability of your code with too many cryptic optimization solutions; I thought of <em>pointers</em> while writing that. I'll add a few lines about them in order to make you familiar with, at least, the concept.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>The power of the bit shift operation</h2></div></div></div><p>If I consider an array to store <a id="id440" class="indexterm"/>things, I almost always choose the size as a power of two. Why? Because the compiler, instead of performing the array indexing by using a CPU-intensive multiply operation, can use the more efficient bit shift operation.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>What are bit operations?</h3></div></div></div><p>Some of you must<a id="id441" class="indexterm"/> have already understood the way I work; I'm using a lot of pretexts to teach you new things. Bitwise operators are specific operators for bits. Some cases require this kind of calculation. I can quote two cases that we'll learn about in the next part of this book:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using shift registers for multiplexing</li><li class="listitem" style="list-style-type: disc">Performing arithmetic operations, for powers of 2, involving the multiply and divide operator</li></ul></div><p>There are four operators and two bit shift operators. Before we dive into it, let's learn a bit more about the binary numeral system.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>Binary numeral system</h3></div></div></div><p>We are used to counting using <a id="id442" class="indexterm"/>the decimal system, also called decimal numeral system or base-10 number system. In this system, we can count as:</p><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...</p><p>Binary numeral system is the system used under the hood in computers and digital electronic devices. It is also named base-2 system. In this system we count as follows:</p><p>0, 1, 10, 11, 100, 101, 110, 111...</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec17"/>Easily converting a binary number to a decimal number</h4></div></div></div><p>A nice trick to convert <a id="id443" class="indexterm"/>
<a id="id444" class="indexterm"/>from binary to decimal, start by counting the position of 0 and 1, starting from the index 0.</p><p>Let's take 110101. It can be represented as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Positions</p>
</th><th style="text-align: left" valign="bottom">
<p>0</p>
</th><th style="text-align: left" valign="bottom">
<p>1</p>
</th><th style="text-align: left" valign="bottom">
<p>2</p>
</th><th style="text-align: left" valign="bottom">
<p>3</p>
</th><th style="text-align: left" valign="bottom">
<p>4</p>
</th><th style="text-align: left" valign="bottom">
<p>5</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr></tbody></table></div><p>Then, I can write this sum of multiplications and it equals the decimal version of my 110101 number:</p><p>1 x 20 + 0 x 21 + 1 x 22 + 0 x 23 + 1 x 24 + 1 x 25 = 1 + 4 + 16 + 32 = 53</p><p>Each bit <em>decides</em> if we have to consider the power of 2, considering its position.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>AND, OR, XOR, and NOT operators</h3></div></div></div><p>Let's have a look at these four operators.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec18"/>AND</h4></div></div></div><p>The bitwise <a id="id445" class="indexterm"/>AND operator<a id="id446" class="indexterm"/> is written with a single ampersand: <code class="literal">&amp;</code>. This operator operates on each bit position independently according to the following rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0 <code class="literal">&amp;</code> 0 == 0</li><li class="listitem" style="list-style-type: disc">0 <code class="literal">&amp;</code> 1 == 0</li><li class="listitem" style="list-style-type: disc">1 <code class="literal">&amp;</code> 0 == 0</li><li class="listitem" style="list-style-type: disc">1 <code class="literal">&amp;</code> 1 == 1</li></ul></div><p>Let's take a real example with integers, which are a 16-bit value:</p><div><pre class="programlisting">int a = 35;    // in binary: 00000000 00100011
int b = 49;    // in binary: 00000000 00110001
int c = a &amp; b; // in binary: 00000000 00100001 and in decimal 33</pre></div><p>To find the<a id="id447" class="indexterm"/> result<a id="id448" class="indexterm"/> easily, we have to compare each bit one by one for each position while following the preceding rules.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec19"/>OR</h4></div></div></div><p>The bitwise <a id="id449" class="indexterm"/>OR operator<a id="id450" class="indexterm"/> is written with a single vertical bar: <code class="literal">|</code>. It can be done by pressing <em>Alt</em> + <em>Shift</em> + <em>l</em> (letter L) on OSX and <em>Shift</em> + <em>\</em> on other PC keyboards. This operator operates on each bit position independently according to the following rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0 <code class="literal">|</code> 0 == 0</li><li class="listitem" style="list-style-type: disc">0 <code class="literal">|</code> 1 == 1</li><li class="listitem" style="list-style-type: disc">1 <code class="literal">|</code> 0 == 1</li><li class="listitem" style="list-style-type: disc">1 <code class="literal">|</code> 1 == 1</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec20"/>XOR</h4></div></div></div><p>The bitwise <a id="id451" class="indexterm"/>XOR operator<a id="id452" class="indexterm"/> is written with a single caret symbol: <code class="literal">^</code>. This operator operates on each bit position independently according to the following rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0 <code class="literal">^</code> 0 == 0</li><li class="listitem" style="list-style-type: disc">0 <code class="literal">^</code> 1 == 1</li><li class="listitem" style="list-style-type: disc">1 <code class="literal">^</code> 0 == 1</li><li class="listitem" style="list-style-type: disc">1 <code class="literal">^</code> 1 == 0</li></ul></div><p>It is the exclusive version of OR, thus the name XOR.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec21"/>NOT</h4></div></div></div><p>The bitwise <a id="id453" class="indexterm"/>XOR operator is<a id="id454" class="indexterm"/> written with a tilde symbol: <code class="literal">~</code>. It is a unary operator, which means, if you remember this term correctly, it can apply to one number only. I call it the <em>bit changer</em> in my workshops. It changes each bit to its opposite:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">~</code>0 == 1</li><li class="listitem" style="list-style-type: disc"><code class="literal">~</code>1 == 0</li></ul></div><p>Let's take a real example with integers, which are 16-bit values as you know:</p><div><pre class="programlisting">int a = 35;   // in binary: 00000000 00100011
int b = ~a ;  // in binary: 11111111 11011100 and in decimal -36</pre></div><p>As you already know, the <code class="literal">int</code> type in C is a signed type (<a class="link" href="ch03.html" title="Chapter 3. C Basics – Making You Stronger">Chapter 3</a>, <em>C Basics – Making You Stronger</em>) that <a id="id455" class="indexterm"/>is able to encode numbers from -32,768 to 32,767—negative <a id="id456" class="indexterm"/>numbers too.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Bit shift operations</h3></div></div></div><p>Coming from C++, the left<a id="id457" class="indexterm"/> shift and the right shift operators are respectively symbolized by <code class="literal">&lt;&lt;</code> and <code class="literal">&gt;&gt;</code>. It is easy to remember, the double &lt;&lt; goes to the left, and the other one &gt;&gt; to the right. Basically, it works like this:</p><div><pre class="programlisting">int a = 36; 		// in binary 00000000 00100100
int b = a &lt;&lt; 2;	// in binary 00000000 10010000, decimal 144
int c = a &gt;&gt; 1;	// in binary 00000000 00010010, decimal 18</pre></div><p>It is quite easy to see how it works. You shift all bits from a particular number of positions to the left or to the right. Some of you would have noticed that this is the same as multiplying or dividing by 2. Doing <code class="literal">&lt;&lt; 1</code> means multiply by 2, <code class="literal">&gt;&gt; 1</code> means divide by 2. <code class="literal">&lt;&lt; 3</code> means multiply by 8 (23), <code class="literal">&gt;&gt; 5</code> means divide by 32 (25), and so on.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>It is all about performance</h3></div></div></div><p>Bitwise operations are primitive actions directly supported by the processor. Especially with embedded systems, which are still not as powerful as normal computers, using bitwise operations can dramatically improve performance. I can write two new rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using power of 2 as the array size drives the use of bit shift operators internally/implicitly while the CPU performs index calculations. As we just learned, multiplying/dividing by 2 can be done very efficiently and quickly with bit shift.</li><li class="listitem" style="list-style-type: disc">All your multiplications and divisions by a power of 2 should be replaced by bit shifting.</li></ul></div><p>This is the nicest compromise between cryptic code and an efficient code. I used to do that quite often. Of course, we'll learn real cases using it. We are still in the most theoretical part of this book, but everything here will become clear quite soon.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>The switch case labels optimization techniques</h2></div></div></div><p>The <code class="literal">switch</code>…<code class="literal">case</code> conditional <a id="id458" class="indexterm"/>structure can also be optimized while you are writing it.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Optimizing the range of cases</h3></div></div></div><p>The first rule is to place all cases of the considered switch in the narrowest range possible.</p><p>In such a case, the compiler produces what we call a <em>jump table of case labels</em>, instead of generating a huge <code class="literal">if</code>-<code class="literal">else</code>-<code class="literal">if</code> cascade. The jump table based <code class="literal">switch</code>…<code class="literal">case</code> statement 's performance is independent of the number of case entries in the <code class="literal">switch</code> statement.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>So, place all cases of the switch in the narrowest range possible.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Optimizing cases according to their frequency</h3></div></div></div><p>The second <a id="id459" class="indexterm"/>rule is to place all cases sorted from the most frequently occurring to the least frequently occurring when you know the frequency.</p><p>As mentioned before, in cases where your <code class="literal">switch</code> statement contains cases placed far apart, because you cannot handle that in another way, the compiler replaces the <code class="literal">switch</code> statement and generates <code class="literal">if</code>-<code class="literal">else</code>-<code class="literal">if</code> cascades. It means it will always be better to reduce the potential number of comparisons; this also means that if the cases that are most probable are placed at the beginning, you maximize your chances to do that.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>So, place all cases sorted from the most frequently occurring to the least frequently occurring.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Smaller the scope, the better the board</h2></div></div></div><p>As I already mentioned when we talked about a variables' scope, always use the smallest scope possible for any variables. Let's check this example with a function named <code class="literal">myFunction</code>:</p><div><pre class="programlisting">int myFunction( int valueToTest )
{
  if (valueToTest == 1)
  {
    int temporaryVariable;
    // some calculations with temporaryVariable
    return temporaryVariable;
  }
  else {
  return -1;
  }
}</pre></div><p>
<code class="literal">temporaryVariable</code> is only required in one case, when <code class="literal">valueToTest</code> equals <code class="literal">1</code>. If I declare <code class="literal">temporaryVariable</code> outside of the <code class="literal">if</code> statement, whatever the value of <code class="literal">valueToTest</code>, <code class="literal">temporaryVariable</code> will be created.</p><p>In the example I cite, we save memory and processing; in all cases where <code class="literal">valueToTest</code> is not equal to <code class="literal">1</code>, the variable <code class="literal">temporaryVariable</code> is not even created.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>Use the smallest scope possible for all your variables.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>The Tao of returns</h2></div></div></div><p>Functions are usually designed with a particular idea in mind, they are modules of code able to perform specific operations through the statements that they include and are also able to return a result. This concept provides a nice way to forget about all those specific operations performed inside the function when we are outside of the function. We know the function has been designed to provide you a result when you give arguments to it.</p><p>Again, this is a nice way to focus on the core of your program.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>Direct returns concept</h3></div></div></div><p>As you may have already <a id="id460" class="indexterm"/>understood, declaring a variable creates a place in memory. That place cannot be used by something else, of course. The process that creates the variable consumes processor time. Let's take the same previous example detailed a bit more:</p><div><pre class="programlisting">int myFunction( int valueToTest )
{
  if (valueToTest == 1)
  {
    int temporaryVariable;
    temporaryVariable += globalVariable;
    temporaryVariable *= 7;
    return temporaryVariable;
  }
  else {
  return -1;
  }
}</pre></div><p>What could I improve to try to avoid the use of <code class="literal">temporaryVariable</code>? I could make a <em>direct return</em> as follows: </p><div><pre class="programlisting">int myFunction( int valueToTest )
{
  if (valueToTest == 1)
  {
    return ( (globalVariable + 1)*7 );
  }
  else {
  return -1;
  }
}</pre></div><p>In the longer version:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We were inside the <code class="literal">valueToTest == 1</code> case thus <code class="literal">valueToTest</code> equals <code class="literal">1</code></li><li class="listitem" style="list-style-type: disc">I directly put the calculation in the <code class="literal">return</code> statement</li></ul></div><p>In that case, there is <a id="id461" class="indexterm"/>no more temporary variable creation. There are some cases where it can be more readable to write a lot of temporary variables. But now, you are aware that it is worth finding compromises between readability and efficiency.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>Use a direct return instead of a lot of temporary variables.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>Use void if you don't need return</h3></div></div></div><p>I often read code <a id="id462" class="indexterm"/>including functions with a return type that didn't return anything. The compiler may warn you about that. But in case it didn't, you have to take care of it. A call to a function that provides a return type will always pass the return value even if nothing inside the function's body is really returned. This has a CPU cost.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>Use <code class="literal">void</code> as a return type for your functions if they don't return anything.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Secrets of lookup tables</h2></div></div></div><p>
<strong>Lookup tables</strong> <a id="id463" class="indexterm"/>are one of the most powerful tricks in the programming universe. They are arrays containing precalculated values and thus replace heavy runtime calculations by a simpler array index operation. For instance, imagine you want to track positions of something by reading distances coming from a bunch of distance sensors. You'll have <em>trigonometric</em> and probably <em>power</em> calculations to perform. Because they can be time consuming for your processor, it would be smarter and cheaper to use array content reading instead of those calculations. This is the usual illustration for the use of lookup tables.</p><p>These lookup tables can be precalculated and stored in a static program's storage memory, or calculated at the program's initialization phase (in that case, we call them <em>prefetched lookup tables</em>).</p><p>Some functions are particularly expensive, considering the CPU work. Trigonometric functions are one such function that can have bad consequences as the storage space and memory are limited in embedded systems. They are typically prefetched in code. Let's check how we can do that.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Table initialization</h3></div></div></div><p>We have to precalculate the cosine <a id="id464" class="indexterm"/>
<strong>Look Up Table</strong> (<strong>LUT</strong>). We need to create a small <a id="id465" class="indexterm"/>precision system. While calling cos(x) we can have all values of x that we want. But if we want to prefetch values inside an array, which has by design a finite size, we have to calculate a finite number of values. Then, we cannot have our cos(x) result for all float values but only for those calculated.</p><p>I consider precision as an angle of 0.5 degrees. It means, for instance, that the result of cosine of 45 degrees will be equal to the cosine of 45 degrees 4 minutes in our system. Fair enough.</p><p>Let's consider the Arduino code. You can find this code in the <code class="literal">Chapter04</code>/<code class="literal">CosLUT</code>/ folder:</p><div><pre class="programlisting">float cosLUT[(int) (360.0 * 1 / 0.5)] ;
const float DEG2RAD = 180 / PI ;


const float cosinePrecision = 0.5;
const int cosinePeriod = (int) (360.0 * 1 / cosinePrecision);


void setup()
{
  initCosineLUT();
}

void loop()
{
  // nothing for now!
}


void initCosineLUT(){  
  for (int i = 0 ; i &lt; cosinePeriod ; i++)
  {
    cosLUT[i] = (float) cos(i * DEG2RAD * cosinePrecision);
  }
}</pre></div><p>
<code class="literal">cosLUT</code> is declared as an array of the type <code class="literal">float</code> with a special size. 360 * 1/(precision in degrees) is just the number of elements we need in our array considering the precision. Here, precision is 0.5 degrees and of course, the declaration could be simplified as follows:</p><div><pre class="programlisting">float cosLUT[720];</pre></div><p>We also declared and defined a <code class="literal">DEG2RAD</code> constant that is useful to convert degrees to radians. We declared <code class="literal">cosinePrecision</code> and <code class="literal">cosinePeriod</code> in order to perform those calculations once.</p><p>Then, we <a id="id466" class="indexterm"/>defined an <code class="literal">initCosineLUT()</code>function<a id="id467" class="indexterm"/> that performs the precalculation inside the <code class="literal">setup()</code> function. Inside its body, we can see a loop over index <code class="literal">i</code>, from <code class="literal">i=0</code> to the size of the array minus one. This loop precalculates values of cosine(x) for all values of x from 0 to 2π. I explicitly wrote the x as <code class="literal">i * DEG2RAD * precision</code> in order to keep the precision visible.</p><p>At the board initialization, it calculates all the lookup table values once and provides these for further calculation by a simple array index operation.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Replacing pure calculation with array index operations</h3></div></div></div><p>Now, let's retrieve our <a id="id468" class="indexterm"/>
<a id="id469" class="indexterm"/>cosine values. We can easily retrieve our values by accessing our LUT through another function, shown as follows:</p><div><pre class="programlisting">float myFastCosine(float angle){
  
   return cosLUT[(int) (angle * 1 / cosinePrecision) % cosinePeriod];
}</pre></div><p>
<code class="literal">angle * 1 / cosinePrecision</code> gives us the angle considering the given precision of our LUT. We apply a modulo operation considering the <code class="literal">cosinePeriod</code> value to wrap values of higher angles to the limit of our LUT, and we have our index. We directly return the array value corresponding to our index.</p><p>We could also use this technique for root square prefetching. This is the way I used it in another language when I coded my first iOS application named <strong>digital collisions</strong>
<a id="id470" class="indexterm"/> <strong>(</strong>
<a class="ulink" href="http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features">http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features</a>). If you didn't test it, this is an application about generative music and visuals based on physical collision algorithms. I needed a lot of distance and rotation calculations. Trust me, this technique turned the first sluggish prototype into a fast application.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Taylor series expansion trick</h2></div></div></div><p>There is another nice <a id="id471" class="indexterm"/>way to save CPU work that requires some math. I mean, a bit more advanced math. Following words are very simplified. But yes, we need to focus on the C side of things, and not totally on mathematics.</p><p>Taylor series expansions are a way to approximate almost every mathematical expression at a particular point (and around it) by using polynomial expressions. </p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>A polynomial expression is similar to the following expression:</p><p>P(x) = a + bx + cx2 + dx3</p></div></div><p>P(x) is a <a id="id472" class="indexterm"/>polynomial function with a degree 3. a, b, c, and d are float numbers.</p><p>The idea behind a Taylor series is that we can approximate an expression by using the first term of the theoretical infinite sums that represent this expression. Let's take some examples.</p><p>For instance, considering x evolving from -π and π; we can write the function sine as follows:</p><p>sin(x) ≈ x - x3/6 + x5/120 - x7/5040</p><p>The sign ≈ means "approximately equals". Inside a reasonable range, we can replace sin(x) by x - x3/6 + x5/120 - x7/5040. There is no magic, just mathematical theorems. We can also write x evolving from -2 to 3 as follows:</p><p>ex ≈ 1 + x + x2/2 + x3/6 + x4/24</p><p>I could add some other examples here, but you'll be able to find this in the <em>Appendix D, Some Useful Taylor Series for Calculation Optimization</em>. These techniques are some powerful tricks to save CPU time.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>The Arduino core even provides pointers</h2></div></div></div><p>Pointers<a id="id473" class="indexterm"/> are more complicated techniques for beginners in C programming but I want you to understand the concept. They are not data, but they point to the starting point of a piece of data. There are at least two ways to pass data to a function or something else:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Copy it and pass it</li><li class="listitem" style="list-style-type: disc">Pass a pointer to it</li></ul></div><p>In the first case, if the amount of data is too large our memory stack would explode because the whole data would be copied in the stack. We wouldn't have a choice other than a pointer pass.</p><p>In this case, we have the reference of the place where the data is stored in memory. We can operate exactly as we want but only by using pointers. Pointers are a smart way to deal with any type of data, especially arrays.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Time measure</h1></div></div></div><p>Time<a id="id474" class="indexterm"/> is always something interesting to measure and to deal with, especially in embedded software that is, obviously, our main purpose here. The Arduino core includes several time functions that I'm going to talk about right now.</p><p>There is also a nice library that is smartly named <strong>SimpleTimer Library</strong>
<a id="id475" class="indexterm"/> and designed as a <a id="id476" class="indexterm"/>GNU LGPL 2.1 + library by <em>Marcello Romani</em>. This is a good library based on the <code class="literal">millis()</code> core function which means the maximum resolution is 1 ms. This will be more than enough for 99 percent of your future projects. <em>Marcello</em> even made a special version of the library for this book, based on <code class="literal">micros()</code>. </p><p>The Arduino core library now also includes a native function that is able to have a resolution of 8 microseconds, which means you can measure time delta of 1/8,000,000 of a second; quite precise, isn't it? </p><p>I'll also describe a higher resolution library <a id="id477" class="indexterm"/>
<strong>FlexiTimer2</strong> in the last chapter of the book. It will provide a high-resolution, customizable timer.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/>Does the Arduino board own a watch?</h2></div></div></div><p>The Arduino board chip provides its <em>uptime</em>. The <em>uptime</em> is the time since the board has started. It means you cannot natively store absolute time and date without keeping the board up and powered. Moreover, it will require you to set up the absolute time once and then keep the Arduino board powered. It is possible to keep the board autonomously powered. I also talk about that later in this book.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>The millis() function</h3></div></div></div><p>The core function <code class="literal">millis()</code> returns <a id="id478" class="indexterm"/>the number of milliseconds since the board has been started the last time. For your information, 1 millisecond equals 1/1000 of a second.</p><p>The Arduino core documentation also provides that this number will go back to zero after approximately 50 days (this is called the timer overflow). You can smile now, but imagine your latest installation artistically illustrating the concept of time in the MoMA in NYC which, after 50 days, would get totally messed up. You would be interested to know this information, wouldn't you? The return format of <code class="literal">millis()</code> is <em>unsigned long</em>.</p><p>Here is an example you'll have to upload to your board in the next few minutes. You can also find this code in the <code class="literal">Chapter04</code>/ <code class="literal">measuringUptime</code>/ folder:</p><div><pre class="programlisting">/*
  measuringTime is a small program measuring the uptime and printing it
  to the serial monitor each 250ms in order not to be too verbose.
 
  Written by Julien Bayle, this example code is under Creative Commons CC-BY-SA
 
  This code is related to the book "C programming for Arduino" written by Julien Bayle
  and published by Packt Publishing.
 
  http://cprogrammingforarduino.com
 */

unsigned long measuredTime;      // store the uptime

void setup(){
  Serial.begin(9600);
}

void loop(){
  Serial.print("Time: ");
  measuredTime = millis();
  
  Serial.println(measuredTime);  // prints the current uptime

  delay(250);         // pausing the program 250ms
}</pre></div><p>Can you optimize<a id="id479" class="indexterm"/> this (only for pedagogical reasons as this is a very small program)? Yes, indeed, we can avoid the use of the <code class="literal">measuredTime</code> variable. It would look more like this:</p><div><pre class="programlisting">/*
  measuringTime is a small program measuring the uptime and printing it
  to the serial monitor each 250ms in order not to be too verbose.
 
  Written by Julien Bayle, this example code is under Creative Commons CC-BY-SA
  This code is related to the book "C programming for Arduino" written by Julien Bayle
  and published by Packt Publishing.
 
  http://cprogrammingforarduino.com
 */

void setup(){
  Serial.begin(9600);
}

void loop(){
  Serial.print("Time: ");
  Serial.println(millis());  // prints the current uptime
  delay(250);         // pausing the program 250ms
}</pre></div><p>It is also beautiful in<a id="id480" class="indexterm"/> its simplicity, isn't it? I'm sure you'll agree. So upload this code on your board, start the Serial Monitor, and look at it.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>The micros() function</h3></div></div></div><p>If you needed more precision, you could use the<a id="id481" class="indexterm"/> <code class="literal">micros()</code> function. It provides uptime with a precision of 8 microseconds as written before but with an overflow of approximately 70 minutes (significantly less than 50 days, right?). We gain precision but loose overflow time range. You can also find the following code in the <code class="literal">Chapter04</code>/<code class="literal">measuringUptimeMicros</code>/ folder:</p><div><pre class="programlisting">/*
  measuringTimeMicros is a small program measuring the uptime in ms and
  µs and printing it to the serial monitor each 250ms in order not to be too verbose.
 
  Written by Julien Bayle, this example code is under Creative Commons CC-BY-SA
 
  This code is related to the book «C programming for Arduino» written by Julien Bayle
  and published by Packt Publishing.
 
  http://cprogrammingforarduino.com
 */

void setup(){
  Serial.begin(9600);
}

void loop(){
  Serial.print(«Time in ms: «);
  Serial.println(millis());  // prints the current uptime in ms
  Serial.print(«Time in µs: «);
  Serial.println(micros());  // prints the current uptime in µs

  delay(250); 		      // pausing the program 250ms
}</pre></div><p>Upload it and check the Serial Monitor.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>Delay concept and the program flow</h2></div></div></div><p>Like Le Bourgeois Gentilhomme who spoke <a id="id482" class="indexterm"/>prose without even realizing it, you've already used the <code class="literal">delay()</code> core function and haven't realized it. Delaying an Arduino program can be done using the <code class="literal">delay()</code> <a id="id483" class="indexterm"/>and<a id="id484" class="indexterm"/> <code class="literal">delayMicroseconds()</code> functions directly in the <code class="literal">loop()</code> function.</p><p>Both functions drive the program to make a pause. The only difference is that you have to provide a time in millisecond to <code class="literal">delay()</code> and a time in microseconds to <code class="literal">delayMicroseconds()</code>.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec51"/>What does the program do during the delay?</h3></div></div></div><p>Nothing. It waits. This <a id="id485" class="indexterm"/>sub-subsection isn't a joke. I want you to focus on this particular point because later it will be quite important.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>When you call <code class="literal">delay</code> or <code class="literal">delayMicroseconds</code> in a program, it stops its execution for a certain amount of time.</p></div></div><p>Here is a small diagram illustrating what happens when we power on our Arduino:</p><div><img src="img/7584_04_012.jpg" alt="What does the program do during the delay?"/><div><p>One lifecycle of a Arduino's firmware</p></div></div><p>Now here is a diagram of the firmware execution itself, which is the part that we will work with, in the next rows:</p><div><img src="img/7584_04_005.jpg" alt="What does the program do during the delay?"/><div><p>The firmware life cycle with the main part looping</p></div></div><p>Accepting the fact that when <code class="literal">setup()</code> <a id="id486" class="indexterm"/>stops, the <code class="literal">loop()</code> function<a id="id487" class="indexterm"/> begins to loop, everything in <code class="literal">loop()</code> is continuous. Now look at the same things when delays happen:</p><div><img src="img/7584_04_006.jpg" alt="What does the program do during the delay?"/><div><p>The firmware life cycle with the main part looping and breaking when delay() is called</p></div></div><p>The whole <a id="id488" class="indexterm"/>program breaks when <code class="literal">delay()</code> is called. The length of the break depends on the parameter passed to<a id="id489" class="indexterm"/> <code class="literal">delay()</code>.</p><p>We can notice that everything is done sequentially and in time. If a statement execution takes a lot of time, Arduino's chip executes it, and then continues with the next task.</p><p>In that very usual and common case, if one particular task (statements, function calls, or whatever) takes a lot of time, the whole program could be hung and produce a hiccup; consider the user experience.</p><p>Imagine that concrete case in which you have to read sensors, flip-flop some switches, and write information to a display <em>at the same time</em>. If you do that sequentially and you have a lot of sensors, which is quite usual, you can have some lag and slowdown in the display of information because that task is executed after the other one in <code class="literal">loop()</code>.</p><div><img src="img/7584_04_007.jpg" alt="What does the program do during the delay?"/><div><p>An Arduino board busy with many inputs and outputs</p></div></div><p>I usually teach my students at least two concepts in dealing with that only-one-task property that can feel like a limitation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Thread</li><li class="listitem" style="list-style-type: disc">Interrupt handler (and subsequent interrupt service routine concept)</li></ul></div><p>I obviously <a id="id490" class="indexterm"/>teach another one: <em>The polling</em>.<strong> The polling is a special interrupt case from where we will begin.</strong>
</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec52"/>The polling concept – a special interrupt case</h3></div></div></div><p>You know the <a id="id491" class="indexterm"/>poll term. I can summarize it as "ask, wait for an answer, and keep it somewhere".</p><p>If I wanted to create a code that reads inputs, and performs something when a particular condition would be verified with the value of these inputs, I would write this pseudo-code:</p><div><pre class="programlisting">setup()
- initialize things

loop()
- ask an input value and wait for it until it is available
- test this input according to something else
- if the test is true perform something else, loop to the beginning</pre></div><p>What could be annoying here? I cyclically poll new information and have to wait for it.</p><p>During this step, nothing more is done, but imagine that the input value remains the same for a long time. I'd request this value cyclically in the loop, constraining the other tasks to wait for nothing.</p><p>It sounds like a waste of time. Normally, polling is completely sufficient. It has to be written here instead of what other raw programmers could say to you.</p><p>We are creators, we need to make things communicate and work, and we can and like to test, don't we? Then, you just learned something important here.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Don't design complex program workarounds before having tested basic ones.</p></div></div><p>One day, <a id="id492" class="indexterm"/>I asked some people to design basic code. Of course, as usual, they were connected to the Internet and I just agreed because we are almost all working like that today, right? Some people finished before others.</p><p>Why? A lot of the people who finished later tried to build a nice multithreaded workaround using a messaging system and an external library. The intention was good, but in the time we had, they didn't finish and only had a nice Arduino board, some wired components, and a code that wasn't working on the table.</p><p>Do you want to know what the others had on their desktop? A polling-based routine that was driving their circuits perfectly! Time wasted by this polling-based firmware was just totally unimportant considering the circuit.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Think about hardcore optimizations, but first test your basic code.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec53"/>The interrupt handler concept</h3></div></div></div><p>Polling is nice but a<a id="id493" class="indexterm"/> bit time consuming, as we just figured out. The best way would be to be able to control when the processor would have to deal with inputs or outputs in a smarter way.</p><p>Imagine our previously drawn example with many inputs and outputs. Maybe, this is a system that has to react according to a user action. Usually, we can consider the user inputs as much slower than the system's ability to answer.</p><p>This means we could create a system that would interrupt the display as soon as a particular event would occur, such as a user input. This concept is called an <em>event-based interrupt system</em>.</p><p>The <em>interrupt</em> is a signal. When a particular event occurs, an interrupt message is sent to the processor. Sometimes it is sent externally to the processor (hardware interrupt) and sometimes internally (software interrupt).</p><p>This is how the disk controller or any external peripheral informs the processor of the main unit that it has to provide this or that at the right moment.</p><p>The interrupt<a id="id494" class="indexterm"/> handler is a routine that handles the interrupt by doing something. For instance, on the move of the mouse, the computer operating system (commonly called the OS) has to redraw the cursor in another place. It would be crazy to let the processor itself test each millisecond whether the mouse has moved, because the CPU would be running at 100 percent utilization. It seems smarter to have a part of the hardware for that purpose. When the mouse movement occurs, it sends an interrupt to the processor, and this later redraws the mouse.</p><p>In the case of our installation with a huge number of inputs and outputs, we can consider handling the user inputs with an interrupt. We would have to implement what is called an <a id="id495" class="indexterm"/>
<strong>Interrupt Service Routine</strong> (<strong>ISR</strong>), which is a routine called only when a physical world event occurs, that is, when a sensor value changes or something like that.</p><p>Arduino now provides a nice way to attach an interrupt to a function and it is now easy to design an ISR (even if we'll learn to do that a bit later). For instance, we can now react to the change of the value of an analog thermal sensor using ISR. In this case, we won't permanently poll the analog input, but we'll let our low-level Arduino part do that. Only when a value changes (rises or falls) depending on how we have attached the interrupt, would this act as a trigger and a special function would execute (for instance, the LCD display gets updated with the new value).</p><p>Polling, ISR, and now, we'll evoke threads. Hang on!</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>What is a thread?</h3></div></div></div><p>A thread<a id="id496" class="indexterm"/> is a running program flow in which the processor executes a series of tasks, generally looping, but not necessarily.</p><p>With only one processor, it is usually done by <em>time-division multiplexing</em>, which means the processor switches between the different threads according to time, that is, context switching.</p><div><img src="img/7584_04_008.jpg" alt="What is a thread?"/><div><p>Time-division multiplexing provides multitasking</p></div></div><p>More advanced processors provide the <em>multithread</em> feature. These behave as if they would be more than just one, each part dealing with a task at the same time.</p><div><img src="img/7584_04_009.jpg" alt="What is a thread?"/><div><p>Real multithreading provides tasks happening at the same time</p></div></div><p>Without <a id="id497" class="indexterm"/>going deeper into computer processors, as we aren't dealing with them right now, I can say threads are nice techniques to use in programming to make tasks run simultaneously.</p><p>Unfortunately, the Arduino core doesn't provide multithreading, nor does any other microcontroller. Because Arduino is an open source hardware project, some hackers have designed a variant of the Arduino board and created some Freeduino variant providing <em>concurrency</em>, an open source programming language, and an environment designed especially with multithreading in mind. This is out of topic here, but at least, you now have some leads if you are interested.</p><p>Let's move to the second solution to go beyond the one-task-at-a-time constraint, if we need it.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec55"/>A real-life polling library example</h3></div></div></div><p>As introduced in the<a id="id498" class="indexterm"/> first line of this section, Marcello's library is a very nice one. It provides a polling-based way to launch timed actions.</p><p>Those actions are generally function calls. Functions that behave like that are sometimes known as callback functions. These functions are generally called as an argument to another piece of code.</p><p>Imagine that I want to make our precious LED on the Arduino board blink every 120 milliseconds. I could use a delay but it would totally stop the program. Not smart enough.</p><p>I could hack a hardware timer on the board, but that would be overkill. A more practical solution that I would use is a callback function with Marcello's <code class="literal">SimpleTimer</code> library. Polling provides a simple and inexpensive way (computationally speaking) to deal with applications that are not timer dependent while avoiding the use of interrupts that raise more complex problems like hardware timer overconsumption (hijacking), which leads to other complicated factors.</p><p>However, if you want to call a function every 5 milliseconds and that function needs 9 milliseconds to complete, it will be called every 9 milliseconds. In our case here, with 120 milliseconds required to produce a nice and eye-friendly, visible blink, we are very safe.</p><p>For your information, you don't need to wire anything more than the USB cable between the board and your computer. The board-soldered LED on Arduino is wired to digital pin 13. Let's use it.</p><p>But first, let's download the <code class="literal">SimpleTimer</code> library for your first use of an external library.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec22"/>Installing an external library</h4></div></div></div><p>Download<a id="id499" class="indexterm"/>
<a id="id500" class="indexterm"/> it from <a class="ulink" href="http://playground.arduino.cc/Code/SimpleTimer">http://playground.arduino.cc/Code/SimpleTimer</a>, and extract it somewhere on your computer. You will typically see a folder with at least two files inside:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A header file (<code class="literal">.h</code> extension)</li><li class="listitem" style="list-style-type: disc">A source code file (<code class="literal">.cpp</code> extension)</li></ul></div><p>Now, you can see for yourself what they are. Within these files, you have the source code. Open your sketchbook folder (see <a class="link" href="ch01.html" title="Chapter 1. Let's Plug Things">Chapter 1</a>, <em>Let's Plug Things</em>), and move the library folder into the <code class="literal">libraries</code> folder if it exists, else create this special folder:</p><div><img src="img/7584_04_010.jpg" alt="Installing an external library"/><div><p>The header and the source code of SimpleTimer by Marcello Romani</p></div></div><p>The next time you'll<a id="id501" class="indexterm"/>
<a id="id502" class="indexterm"/> start your Arduino IDE, if you go to <strong>Sketch</strong> | <strong>Import Library</strong>, you'll see a new library at the bottom.</p><div><img src="img/7584_04_011.jpg" alt="Installing an external library"/></div><p>In order to include a library, you can click on it in this menu and it will write <code class="literal">#include &lt;libname.h&gt;</code> in<a id="id503" class="indexterm"/>
<a id="id504" class="indexterm"/> your code. You can also type this by yourself.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec23"/>Let's test the code</h4></div></div></div><p>Upload this next code and reboot Arduino; I'm going to explain how it works. You can also find this code in the <code class="literal">Chapter04</code>/<code class="literal">simpleTimerBlinker</code>/ folder:</p><div><pre class="programlisting">#include &lt;SimpleTimer.h&gt;	// include the Marcello's library

SimpleTimer timer ;		// the timer object construction
boolean currentLEDState ;
int ledPin = 13 ;


void setup() {
currentLEDState = false ;
pinMode(ledPin, OUTPUT) ;
timer.setInterval(120, blink) ;

}

void loop() {
timer.run() ;
}
// a function to be executed periodically
void blink() {
  if (!currentLEDState)	digitalWrite(ledPin, HIGH);
else digitalWrite(ledPin, LOW);
currentLEDState = !currentLEDState ; // invert the boolean
}</pre></div><p>This library is easy to use in our case. You have to include it first, of course. Then you have to declare an instance of <code class="literal">SimpleTimer</code>, which is an object construct, by declaring it.</p><p>Then I'm using a <code class="literal">currentLEDState</code> Boolean value to store the current state of the LED explicitly. At last, I declare/define <code class="literal">ledPin</code> with the number of the pin I need (in this case, 13) to make the LED blink. <code class="literal">setup()</code> is basically done with some initialization. The most important one here is the <code class="literal">timer.setInterval()</code> function.</p><p>Maybe, this is your first method call. The object timer has and embeds some methods that we can use. One of them is <code class="literal">setInterval</code>, which takes two variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A time interval</li><li class="listitem" style="list-style-type: disc">A callback function</li></ul></div><p>We are passing a function name here (a piece of code) to another piece of code. This is the structure of a typical callback system.</p><p>
<code class="literal">loop()</code> is then designed by calling the <code class="literal">run()</code> method of the timer object at each run. This is required to use it. At least, the callback function<a id="id505" class="indexterm"/> <code class="literal">blink()</code> is defined with a small trick at the end.</p><p>The comparison is obvious. I test the current state of the LED, if it is already switched on, I switch it off, else I switch it on. Then, I invert the state, which is the trick. I'm using the <code class="literal">!</code> (not) unary operator on this Boolean variable in order to flip its value, and I assign the inverted value to the Boolean itself. I could have made this too:</p><div><pre class="programlisting">void blink() {
  if (!currentLEDState) {
digitalWrite(ledPin, HIGH);
currentLEDState  = true ;
}

else {
digitalWrite(ledPin, LOW);
currentLEDState  = false;
}
}</pre></div><p>There's really no performance gain, one way or the other. It's simply a personal decision; use whichever you prefer.</p><p>I'm personally considering the flip as a general action that has to be done every time, independent of the state. This is the reason why I proposed that you put it outside of the test structure.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Summary</h1></div></div></div><p>This completes the first part of this book. I hope you have been able to absorb and enjoy these first (huge) steps. If not, you may want to take the time to review something you may not have clarity on; it's always worth it to better understand what you're doing.</p><p>We know a bit more about C and C++ programming, at least enough to lead us safely through the next two parts. We can now understand the basic tasks of Arduino, we can upload our firmware, and we can test them with the basic wiring.</p><p>Now, we'll move a step further into a territory where things are more practical, and less theoretical. Prepare yourself to explore new physical worlds, where you can make things talk, and communicate with each other, where your computer will be able to respond to how you feel and react, and without wires sometimes! Again, you may want to take a little time to review something you might still be a little hazy on; knowledge is power.</p><p>The future is now!</p></div></body></html>