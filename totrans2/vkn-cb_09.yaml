- en: Command Recording and Drawing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Clearing a color image
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing a depth-stencil image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing render pass attachments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding vertex buffers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding an index buffer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing data to shaders through push constants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting viewport state dynamically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting scissor state dynamically
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting line width state dynamically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting depth bias state dynamically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting blend constants state dynamically
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a geometry
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing an indexed geometry
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatching compute work
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a secondary command buffer inside a primary command buffer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording a command buffer that draws a geometry with a dynamic viewport and
    scissor states
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording command buffers on multiple threads
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a single frame of animation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing performance through increasing the number of separately rendered
    frames
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulkan was designed as a graphics and compute API. Its main purpose is to allow
    us to generate dynamic images using a graphics hardware produced by various vendors.
    We already know how to create and manage resources and use them as a source of
    data for shaders. We learned about different shader stages and pipeline objects
    controlling the state of rendering or dispatching computational work. We also
    know how to record command buffers and order operations into render passes. One
    last step we must learn about is how to utilize this knowledge to render images.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see what additional commands we can record and what
    commands need to be recorded so we can properly render a geometry or issue computational
    operations. We will also learn about the drawing commands and organizing them
    in our source code in such a way so that it maximizes the performance of our application.
    Finally, we will utilize one of the greatest strengths of the Vulkan API--the
    ability to record command buffers in multiple threads.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Clearing a color image
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional graphics APIs, we start rendering a frame by clearing a render
    target or a back buffer. In Vulkan, we should perform the clearing by specifying
    a `VK_ATTACHMENT_LOAD_OP_CLEAR` value for a `loadOp` member of the render pass's
    attachment description (refer to the *Specifying attachment descriptions* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*). But sometimes, we can't clear an image inside a render pass and
    we need to do it implicitly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer stored in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state
    and no render pass has started.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of an image that should be cleared. Provide it through a variable
    of type `VkImage` named `image`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the layout, in which the `image` will have during clearing, in a variable
    of type `VkImageLayout` named `image_layout`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepare a list of all mipmap levels of the `image` and array layers that should
    be cleared in a variable of type `std::vector<VkImageSubresourceRange>` named
    `image_subresource_ranges`. For each range of sub-resources of the `image`, add
    a new element to the `image_subresource_ranges` vector and use the following values
    to initialize its members:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image's aspect (color, depth, and/or stencil aspect cannot be provided)
    for `aspectMask`
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first mipmap level to be cleared in a given range for `baseMipLevel`
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of continuous mipmap levels that should be cleared in a given range
    for `levelCount`
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of a first array layer that should be cleared in a given range for
    `baseArrayLayer`
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of continuous array layers to be cleared for `layerCount`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide a color to which the image should be cleared using the following members
    of a variable type `VkClearColorValue` named `clear_color`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int32`: When the image has a signed integer format'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32`: When the image has an unsigned integer format'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float32`: For the rest of the formats'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `vkCmdClearColorImage( command_buffer, image, image_layout, &clear_color,
    static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data()
    )` command for which it provides the `command_buffer`, `image`, `image_layout`
    variables, a pointer to the `clear_color` variable, the number of elements in
    the `image_subresource_ranges` vector, and a pointer to the first element of the
    `image_subresource_ranges` vector.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clearing color images is performed by recording the `vkCmdClearColorImage()`
    function in a command buffer. The `vkCmdClearColorImage()` command cannot be recorded
    inside a render pass.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'It requires us to provide the image''s handle, its layout, and an array of
    its sub-resources (mipmap levels and/or array layers) that should be cleared.
    We must also specify the color to which the image should be cleared. These parameters
    can be used like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that by using this function, we can clear only color images (with a
    color aspect and one of the color formats).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The `vkCmdClearColorImage()` function can be used only for images created with
    **transfer dst** usage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image*'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying attachment descriptions*'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clearing render pass attachments*'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clearing a depth-stencil image*'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing a depth-stencil image
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to color images, we sometimes need to manually clear a depth-stencil
    image outside of a render pass.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the command buffer that is in a recording state and has no render pass
    currently started in it. Using its handle, initialize a variable of type `VkCommandBuffer`
    named `command_buffer`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a depth-stencil image and store it in a variable of type
    `VkImage` named `image`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value representing the layout, in which the `image` will have during
    clearing, in a variable of type `VkImageLayout` named `image_layout`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkImageSubresourceRange>` named `image_subresource_ranges`,
    which will contain a list of mipmap levels of all the `image`''s and array layers,
    which should be cleared. For each such range, add a new element to the `image_subresource_ranges`
    vector and use the following values to initialize its members:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The depth and/or stencil aspect for `aspectMask`
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first mipmap level to be cleared in a given range for `baseMipLevel`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of continuous mipmap levels in a given range for `levelCount`
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of a first array layer that should be cleared for `baseArrayLayer`
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of continuous array layers to be cleared in a range for `layerCount`
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide a value which should be used to clear (fill) the image using the following
    members of a variable of type `VkClearDepthStencilValue` named `clear_value`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`depth` when a depth aspect should be cleared'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stencil` for a value used to clear the stencil aspect'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkCmdClearDepthStencilImage( command_buffer, image, image_layout, &clear_value,
    static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data()
    )` and provide the `command_buffer`, `image`, and `image_layout` variables, a
    pointer to the `clear_value` variable, the number of elements in the `image_subresource_ranges`
    vector, and a pointer to the first element of the `image_subresource_ranges` vector.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clearing the depth-stencil image outside of a render pass is performed like
    this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use this function only for images created with a transfer dst usage (clearing
    is considered as a transfer operation).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image*'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying attachment descriptions*'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clearing render pass attachments*'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Clearing a color image* recipe, in this chapter
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing render pass attachments
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations in which we cannot rely only on implicit attachment clearings
    performed as initial render pass operations, and we need to clear attachments
    explicitly in one of the sub-passes. We can do this by calling a `vkCmdClearAttachments()`
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a command buffer that is in a recording state and store its handle in a
    variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a vector variable of type `std::vector<VkClearAttachment>` named `attachments`.
    For each `framebuffer` attachment that should be cleared inside a current sub-pass
    of a render pass, add an element to the vector and initialize it with the following
    values:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attachment's aspect (color, depth, or stencil) for `aspectMask`
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `aspectMask` is set to `VK_IMAGE_ASPECT_COLOR_BIT`, specify an index of a
    color attachment in the current sub-pass for `colorAttachment`; otherwise, this
    parameter is ignored
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A desired clear value for a color, depth, or stencil aspect for `clearValue`
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkClearRect>` named `rects`. For each
    area that should be cleared in all the specified attachments, add an element to
    the vector and initialize it with the following values:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rectangle to be cleared (top-left corner and a width and height) for `rect`
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of a first layer to be cleared for `baseArrayLayer`
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of layers to be cleared for `layerCount`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkCmdClearAttachments( command_buffer, static_cast<uint32_t>(attachments.size()),
    attachments.data(), static_cast<uint32_t>(rects.size()), rects.data() )`. For
    the function call, provide the handle of the command buffer, the number of elements
    in the `attachments` vector, a pointer to its first element, the number of elements
    in the `rects` vector, and a pointer to its first element.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to explicitly clear an image that is used as a framebuffer''s
    attachment inside a started render pass, we cannot use the usual image clearing
    functions. We can do this only by selecting which attachments should be cleared.
    This is done through the `vkCmdClearAttachments()` function like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using this function, we can clear multiple regions of all the indicated attachments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We can call the `vkCmdClearAttachments()` function only inside a render pass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the recipes:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying attachment descriptions*'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying sub-pass descriptions*'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a render pass*'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes from this chapter:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clearing a color image*'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clearing a depth-stencil image*'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding vertex buffers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we draw a geometry, we need to specify data for vertices. At the very least,
    vertex positions are required, but we can specify other attributes such as normal,
    tangent or bitangent vectors, colors, or texture coordinates. This data comes
    from buffers created with a **vertex buffer** usage. We need to bind these buffers
    to specified bindings before we can issue drawing commands.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, a custom `VertexBufferParameters` type is introduced. It has
    the following definition:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This type is used to specify the buffer''s parameters: its handle (in the `Buffer`
    member) and an offset from the start of the buffer''s memory from which data should
    be taken (in the `MemoryOffset` member).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer that is in a recording state and use it
    to initialize a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `std::vector<VkBuffer>` named `buffers`. For each
    buffer that should be bound to a specific binding in the command buffer, add the
    buffer's handle to the `buffers` vector.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `std::vector<VkDeviceSize>` named `offsets`. For each
    buffer in the `buffers` vector, add a new member to the `offsets` vector with
    an offset value from the start of the corresponding buffer's memory (the buffer
    at the same index in the `buffers` vector).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdBindVertexBuffers( command_buffer, first_binding, static_cast<uint32_t>(buffers_parameters.size()),
    buffers.data(), offsets.data() )`, providing the handle of the command buffer,
    the number of the first binding to which the first buffer from the list should
    be bound, the number of elements in the `buffers` (and `offsets`) vector, and
    a pointer to the first element of the `buffers` vector and to the first element
    of the `offsets` vector.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the graphics pipeline creation, we specify the vertex attributes that
    will be used (provided to shaders) during drawing. This is done through vertex
    binding and attributes descriptions (refer to the *Specifying a pipeline vertex
    binding description, attribute description, and input state* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
    Through them, we define the number of attributes, their formats, the location
    through which the shader will be able to access them, and the memory properties,
    such as offset and stride. We also provide the binding index from which a given
    attribute should be read. With this binding, we need to associate a selected buffer,
    in which data for a given attribute (or attributes) is stored. The association
    is made by binding a buffer to the selected binding index in a given command buffer,
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the handles of all the buffers that should be bound and
    their memory offsets are provided through a variable of type `std::vector<VertexBufferParameters>`
    named `buffers_parameters`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we can only bind buffers created with a vertex buffer usage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline vertex binding description*'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attribute description and input state*'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing a geometry*'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing an indexed geometry*'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding an index buffer
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To draw a geometry, we can provide the list of vertices (and their attributes)
    in two ways. The first way is a typical list, in which vertices are read one after
    another. The second method requires us to provide additional indices that indicate
    which vertices should be read to form polygons. This feature is known as indexed
    drawing. It allows us to reduce the memory consumption as we don't need to specify
    the same vertices multiple times. It is especially important when we have multiple
    attributes associated with each vertex, and when each such vertex is used across
    many polygons.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Indices are stored in a buffer called an **index buffer**, which must be bound
    before we can draw an indexed geometry.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store the command buffer's handle in a variable of type `VkCommandBuffer` named
    `command_buffer`. Make sure it is in a recording state.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of the buffer in which the indices are stored. Use its handle
    to initialize a variable of type `VkBuffer` named `buffer`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take an offset value (from the start of the buffer's memory) that indicates
    the beginning of the indice's data. Store the offset in a variable of type `VkDeviceSize`
    named `memory_offset`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the type of data used for the indices. Use a `VK_INDEX_TYPE_UINT16`
    value for 16-bit unsigned integers or a `VK_INDEX_TYPE_UINT32` value for 32-bit
    unsigned integers. Store the value in a variable of type `VkIndexType` named `index_type`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdBindIndexBuffer( command_buffer, buffer, memory_offset, index_type
    )`, and provide the handles of the command buffer and the buffer, the memory offset
    value, and the type of data used for the indices (the `index_type` variable as
    the last argument).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a buffer as a source of vertex indices, we need to create it with an
    *index buffer* usage and fill it with proper data--indices indicating what vertices
    should be used for drawing. Indices must be tightly packed (one after another)
    and they should just point to a given index in an array of vertex data, hence
    the name. This is shown in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_01-1.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'Before we can record an indexed drawing command, we need to bind an index buffer,
    like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the call, we need to provide a command buffer, to which we record the function
    and the buffer that should act as an index buffer. Also, the memory offset from
    the start of the buffer's memory is required. It shows from which parts of the
    buffer's memory the driver should start reading the indices. The last parameter,
    the `index_type` variable in the preceding example, specifies the data type of
    the indices stored in the buffer--if they are specified as unsigned integers with
    16 or 32 bits.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding vertex buffers*'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing an indexed geometry*'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing data to shaders through push constants
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During drawing or dispatching computational work, specific shader stages are
    executed--the ones defined during the pipeline creation. So the shaders can perform
    their job, we need to provide data to them. Most of the time we use descriptor
    sets, as they allow us to provide kilobytes or even megabytes of data through
    buffers or images. But using them is quite complicated. And, what's more important,
    frequent changes of descriptor sets may impact the performance of our application.
    But sometimes, we need to provide a small amount of data in a fast and easy way.
    We can do this using push constants.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store the handle of a command buffer in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure it is in a recording state.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the layout of a pipeline that uses a range of push constants. Store the
    handle of the layout in a variable of type `VkPipelineLayout` named `pipeline_layout`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through a variable of type `VkShaderStageFlags` named `pipeline_stages`, define
    the shader stages that will access a given range of push constant data.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a variable of type `uint32_t` named `offset`, specify an offset (in bytes)
    from which the push constant memory should be updated. The `offset` must be a
    multiple of 4.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the size (in bytes) of the part of the updated memory in a variable of
    type `uint32_t` named `size`. The `size` must be a multiple of 4.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a variable of type `void *` named `data`, provide a pointer to a memory
    from which the data should be copied to push the constant memory.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following call:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the call, provide (in the same order) the variables described in bullets
    from 1 to 6.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Push constants allow us to quickly provide a small amount of data to shaders
    (refer to the *Using push constants in shaders* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders*). Drivers are required to offer at least 128 bytes of memory for push
    constant data. This is not much, but it is expected that push constants are much
    faster than updating data in a descriptor resource. This is the reason we should
    use them to provide data that changes very frequently, even with each drawing
    or dispatching of compute shaders.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Data to push constants is copied from the provided memory address. Remember
    that we can update only data whose size is a multiple of 4\. The offset within
    a push constant memory (to which we copy the data) must also be a multiple of
    4\. As an example, to copy four floating-point values, we can use the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`ProvideDataToShadersThroughPushConstants()` is a function that implements
    this recipe in the following way:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the recipe:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using push constants in shaders*'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the recipe:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a pipeline layout*'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting viewport states dynamically
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The graphics pipeline defines parameters of lots of different states used during
    rendering. Creating separate pipeline objects every time we need to use slightly
    different values of some of these parameters would be cumbersome and very impractical.
    That's why dynamic states are available in Vulkan. We can define a viewport transformation
    to be one of them. In such a situation, we specify its parameters through a function
    call recorded in command buffers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer that is in a recording state. Using its
    handle, initialize a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the number of the first viewport whose parameters should be set. Store
    the number in a variable of type `uint32_t` named `first_viewport`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkViewport>` named `viewports`. For
    each viewport that was defined during the pipeline creation, add a new element
    to the `viewports` vector. Through it, specify the parameters of a corresponding
    viewport using the following values:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The left side (in pixels) of the upper left corner for `x`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The top side (in pixels) of the upper left corner for `y`
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The width of the viewport for `width`
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of the viewport for `height`
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimal depth value used during a fragment's depth calculations for `minDepth`
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximal value of a fragment's calculated depth for `maxDepth`
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkCmdSetViewport( command_buffer, first_viewport, static_cast<uint32_t>(viewports.size()),
    viewports.data() )` and provide the handle of the `command buffer`, the `first_viewport`
    variable, the number of elements in the viewports vector, and a pointer to the
    first element of the `viewports` vector.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The viewport state can be specified to be one of the dynamic pipeline states.
    We do this during the pipeline creation (refer to the *Specifying pipeline dynamic
    states* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*). Here, dimensions of the viewport are specified with a
    function call like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Parameters defining the dimensions of each viewport used during rendering (refer
    to the *Specifying a pipeline viewport and scissor test state* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*)
    are specified through an array, where each element of the array corresponds to
    a given viewport (offset by the value specified in the `firstViewport` function
    parameter--`first_viewport` variable in the preceding code).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We just need to remember that the number of viewports used during rendering
    is always specified statically in a pipeline, no matter if the viewport state
    is specified as dynamic or not.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline viewport and scissor test state*'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline dynamic states*'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting scissor states dynamically
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The viewport defines a part of an attachment (image) to which the clip's space
    will be mapped. The scissor test allows us to additionally confine a drawing to
    the specified rectangle within the specified viewport dimensions. The scissor
    test is always enabled; we can only set up various values for its parameters.
    This can be done statically during the pipeline creation, or dynamically. The
    latter is done with a function call recorded in a command buffer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store the handle of a command buffer that is in a recording state in a variable
    of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the number of the first scissor rectangle in a variable of type `uint32_t`
    named `first_scissor`. Remember that the number of scissor rectangles corresponds
    to the number of viewports.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkRect2D>` named `scissors`. For each
    scissor rectangle we want to specify, add an element to the `scissors` variable.
    Use the following values to specify its members:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The horizontal offset (in pixels) from the upper left corner of the viewport
    for the `x` member of the `offset`
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The vertical offset (in pixels) from the upper left corner of the viewport for
    the `y` member of the `offset`
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The width (in pixels) of the scissor rectangle for the `width` member of the
    `extent`
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The height (in pixels) of the scissor rectangle for the `height` member of the
    `extent`
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkCmdSetScissor( command_buffer, first_scissor, static_cast<uint32_t>(scissors.size()),
    scissors.data() )` and provide the `command_buffer` and `first_scissor` variables,
    the number of elements in the `scissors` vector, and a pointer to the first element
    of the `scissors` vector.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scissor test allows us to restrict rendering to a rectangle area specified
    anywhere inside the viewport. This test is always enabled and must be specified
    for all viewports defined during the pipeline creation. In other words, the number
    of specified scissor rectangles must be the same as the number of viewports. If
    we are providing parameters for a scissor test dynamically, we don't need to do
    it in a single function call. But before the drawing command is recorded, scissor
    rectangles for all the viewports must be defined.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a set of rectangles for the scissor test, we need to use the following
    code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `vkCmdSetScissor()` function allows us to define scissor rectangles for
    only a subset of viewports. Parameters specified at index `i` in the `scissors`
    array (vector) correspond to a viewport at index `first_scissor + i`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline viewport and scissor test state*'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline dynamic states*'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting viewport states dynamically*, in this chapter'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting line width states dynamically
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the parameters defined during the graphics pipeline creation is the width
    of drawn lines. We can define it statically. But if we intend to draw multiple
    lines with different widths, we should specify line width as one of the dynamic
    states. This way, we can use the same pipeline object and specify the width of
    the drawn lines with a function call.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer that is being recorded and use it to initialize
    a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `float` named `line_width` through which the width
    of drawn lines will be provided.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdSetLineWidth( command_buffer, line_width )` providing the `command_buffer`
    and `line_width` variables.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting the width of lines dynamically for a given graphics pipeline is performed
    with the `vkCmdSetLineWidth()` function call. We just need to remember that to
    use various widths, we must enable the `wideLines` feature during the logical
    device creation. Otherwise, we can only specify a value of `1.0f`. In such a case,
    we shouldn''t create a pipeline with a dynamic line width state. But, if we have
    enabled the mentioned feature and we want to specify various values for line widths,
    we can do it like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline input assembly state*'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline rasterization state*'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline dynamic states*'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting depth bias states dynamically
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When rasterization is enabled, each fragment that is generated during this process
    has its own coordinates (position on screen) and a depth value (distance from
    the camera). Depth value is used for the depth test, allowing for some opaque
    objects to cover other objects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Enabling depth bias allows us to modify the fragment's calculated depth value.
    We can provide parameters for biasing a fragment's depth during the pipeline creation.
    But when depth bias is specified as one of the dynamic states, we do it through
    a function call.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer that is being recorded. Use the handle to
    initialize a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value for the constant offset added to the fragment's depth in a variable
    of type `float` named `constant_factor`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `float` named `clamp`. Use it to provide the maximal
    (or minimal) depth bias that can be applied to an unmodified depth.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a variable of type `float` named `slope_factor`, in which store a value
    applied to the fragment's slope used during depth bias calculations.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `vkCmdSetDepthBias( command_buffer, constant_factor, clamp, slope_factor
    )` function providing the prepared `command_buffer`, `constant_factor`, `clamp`
    and `slope_factor` variables, which are mentioned in the previous steps.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depth bias is used to offset a depth value of a given fragment (or rather, all
    fragments generated from a given polygon). Commonly, it is used when we want to
    draw objects that are very near other objects; for example, pictures or posters
    on walls. Due to the nature of depth calculations, such objects may be incorrectly
    drawn (partially hidden) when viewed from a distance. This issue is known as depth-fighting
    or Z-fighting.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Depth bias modifies the calculated depth value--the value used during the depth
    test and stored in a depth attachment--but does not affect the rendered image
    in any way (that is, it does not increase the visible distance between the poster
    and the wall it is attached to). Modifications are performed based on a constant
    factor and fragment''s slope. We also specify the maximal or minimal value of
    the depth bias (`clamp`) which can be applied. These parameters are provided like
    this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline rasterization states*'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline depth and stencil states*'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline dynamic states*'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting blend constants states dynamically
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blending is a process that mixes a color stored in a given attachment with a
    color of a processed fragment. It is often used to simulate transparent objects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways in which a fragment's color and a color stored in an
    attachment can be combined--for the blending, we specify factors (weights) and
    operations, which generate the final color. It is also possible that an additional,
    constant color is used by these calculations. During the pipeline creation, we
    can specify that components of the constant color are provided dynamically. In
    such a case, we set them with a function recorded in a command buffer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer and use it to initialize a variable of type
    `VkCommandBuffer` named `command_buffer`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `std::array<float, 4>` named `blend_constants`. In
    the array's four elements, store the red, green, blue, and alpha components of
    the constant color used during the blending calculations.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdSetBlendConstants( command_buffer, blend_constants.data() )` and
    provide the `command_buffer` variable and a pointer to the first element of the
    `blend_constants` array.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blending is enabled (statically) during graphics pipeline creation. When we
    enable it, we must provide multiple parameters that define the behavior of this
    process (refer to the *Specifying pipeline blend state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). Among these parameters are blend constants--four
    components of a constant color used during blending calculations. Normally, they
    are defined statically during the pipeline creation. But, if we enable blending
    and intend to use multiple different values for the blend constants, we should
    specify that we will provide them dynamically (refer to the *Specifying pipeline
    dynamic states* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). This will allow us to avoid creating multiple
    similar graphics pipeline objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Values for the blend constants are provided with a single function call, like
    this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline blend states*'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline dynamic states*'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a geometry
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing is the operation we usually want to perform using graphics APIs such
    as OpenGL or Vulkan. It sends the geometry (vertices) provided by the application
    through a vertex buffer down the graphics pipeline, where it is processed step
    by step by programmable shaders and fixed-function stages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Drawing requires us to provide the number of vertices we would like to process
    (display). It also allows us to display multiple instances of the same geometry
    at once.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store the handle of a command buffer in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is currently being recorded
    and that the parameters of all the states used during rendering are already set
    in it (bound to it). Also, make sure that the render pass is started in the command
    buffer.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a variable of type `uint32_t` named `vertex_count` to hold the number of
    vertices we would like to draw.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `uint32_t` named `instance_count` and initialize it
    with the number of geometry instances that should be displayed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a variable of type `uint32_t` named `first_vertex`. Store the number
    of the first vertex from which the drawing should be performed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `uint32_t` named `first_instance` in which the number
    of the first instance (instance offset) should be stored.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the following function: `vkCmdDraw( command_buffer, vertex_count, instance_count,
    first_vertex, first_instance )`. For the call, provide all of the preceding variables
    in the same order.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drawing is performed with a call of the `vkCmdDraw()` function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It allows us to draw any number of vertices, where vertices (and their attributes)
    are stored one after another in a vertex buffer (no index buffer is used). During
    the call we need to provide an offset--the number of the first vertex from which
    drawing should be started. This can be used when we have multiple models stored
    in one vertex buffer (for example, compounds of a model) and we want to draw only
    one of them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The preceding function allows us to draw a single mesh (model), and also multiple
    instances of the same mesh. This is particularly useful when we have specified
    that some of the attributes change per instance, not per vertex (refer to the
    *Specifying pipeline vertex binding description, attribute description, and input
    state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*). This way, each drawn instance of the same model may be
    a little bit different.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_002.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Almost everything we do in Vulkan is used during drawing. So before we record
    a drawing command in a command buffer, we must be sure all the required data and
    parameters are properly set. Remember that each time we record a command buffer,
    it doesn't have any state. So before we can draw anything, we must set up the
    state accordingly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: There is no such thing as default state in Vulkan.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: An example can be descriptor sets or dynamic pipeline states. Each time we start
    recording a command buffer, before we can draw anything, all the required descriptor
    sets (those used by shaders) must be bound to the command buffer. Similarly, every
    pipeline state that is specified as dynamic must have its parameters provided
    through corresponding functions. Another thing to remember is the render pass,
    which must be started in a command buffer for the drawing to be properly executed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Drawing can be performed only inside the render pass.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding descriptor sets*'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a render pass*'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a framebuffer*'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a render pass*'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a graphics pipeline*'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding a pipeline object*'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding vertex buffers*'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting viewport states dynamically*'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting scissor states dynamically*'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing an indexed geometry
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often it is more convenient to reuse vertices stored in a vertex buffer.
    Like the corners of a cube which belong to multiple sides, vertices in arbitrary
    geometry may belong to many parts of the whole model.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the object one vertex after another would require us to store the same
    vertex (along with all its attributes) multiple times. A better solution is to
    indicate which vertices should be used for drawing, no matter how they are ordered
    in the vertex buffer. For this purpose, indexed drawing was introduced in the
    Vulkan API. To draw geometry using indices stored in an index buffer, we need
    to call the `vkCmdDrawIndexed()` function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a variable of type `VkCommandBuffer` named `command_buffer`, in which
    store the handle of a command buffer. Make sure the command buffer is in the recording
    state.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a variable of type `uint32_t` named `index_count` with the number
    of indices (and vertices) that should be drawn.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the number of instances (of the same geometry) to be drawn to initialize
    a variable of type `uint32_t` named `instance_count`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the offset (in the number of indices) from the beginning of an index buffer
    in a variable of type `uint32_t` named `first_index`. From this index, drawing
    will be started.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a variable of type `uint32_t` named `vertex_offset`, in which the vertex
    offset (the value added to each index) should be stored.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `uint32_t` named `first_instance` that should hold
    the number of the first geometry instance to be drawn.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following call: `vkCmdDrawIndexed( command_buffer, index_count, instance_count,
    first_index, vertex_offset, first_instance )`. For the call, provide all of the
    preceding variables, in the same order.'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexed drawing is the way to reduce the memory consumption. It allows us to
    remove duplicate vertices from vertex buffers, so we can allocate smaller vertex
    buffers. An additional index buffer is required, but usually vertex data requires
    much more memory space. This is especially the case in situations when each vertex
    has more attributes than just one position, such as normal, tangent, and bitangent
    vectors and two texture coordinates, which are used very often.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Indexed drawing also allows graphics hardware to reuse data from the already
    processed vertices through a form of vertex caching. With normal (non-indexed)
    drawing, hardware needs to process each vertex. When indices are used, hardware
    has additional information about processed vertices and knows if a given vertex
    was recently processed or not. If the same vertex was recently used (the last
    several dozens of processed vertices), in many situations the hardware may reuse
    the results of this vertex's previous processing.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a geometry using vertex indices, we need to bind an index buffer before
    we record an indexed drawing command (refer to the *Binding an index buffer* recipe).
    We must also start a render pass, as indexed drawing (similarly to normal drawing)
    can be recorded only inside render passes. We also need to bind a graphics pipeline
    and all other required states (depending on the resources used by the graphics
    pipeline), and we are then good to call the following function:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Indexed drawing, similarly to normal drawing, can only be performed inside a
    render pass.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding descriptor sets*'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a render pass*'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a framebuffer*'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a render pass*'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a graphics pipeline*'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding a pipeline object*'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding vertex buffers*'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding an index buffer*'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting viewport states dynamically*'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting scissor states dynamically*'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatching compute work
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from drawing, Vulkan can be used to perform general computations. For
    this purpose, we need to write compute shaders and execute them--this is called
    dispatching.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: When we want to issue computational work to be performed, we need to specify
    how many separate compute shader instances should be executed and how they are
    divided into workgroups.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state
    and no render pass is currently started.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the number of local workgroups along the *x* dimension in a variable of
    type `uint32_t` named `x_size`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of local workgroups in the *y* dimensions should be stored in a variable
    of type `uint32_t` named `y_size`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the number of local workgroups along the *z* dimension to initialize a variable
    of type `uint32_t` named `z_size`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record the `vkCmdDispatch( command_buffer, x_size, y_size, z_size )` function
    using the preceding variables as its arguments.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we dispatch compute work, we use compute shaders from the bound compute
    pipeline to perform the task they are programmed to do. Compute shaders use resources
    provided through descriptor sets. Results of their computations can also be stored
    only in resources provided through descriptor sets.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Compute shaders don't have a specific goal or use case scenario which they must
    fulfil. They can be used to perform any computations that operate on data read
    from descriptor resources. We can use them to perform image post-processing, such
    as color correction or blur. We can perform physical calculations and store transformation
    matrices in buffers or calculate new positions of a morphing geometry. The possibilities
    are limited only by the desired performance and hardware capabilities.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute shaders are dispatched in groups. The number of local invocations in
    `x`, `y`, and `z` dimensions are specified inside the shader source code (refer
    to the *Writing compute shaders* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders*). The collection of these invocations is called a workgroup. During
    dispatching the compute shaders, we specify how many such workgroups should be
    executed in each *x*, *y*, and *z* dimension. This is done through the parameters
    of the `vkCmdDispatch()` function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We just need to remember that the number of workgroups in a given dimension
    cannot be larger than the value in the corresponding index of the `maxComputeWorkGroupCount[3]`
    physical device's limit. Currently, the hardware must allow to dispatch at least
    65,535 workgroups in a given dimension.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching compute workgroups cannot be done inside render passes. In Vulkan,
    render passes can be used only for drawing. If we want to bind compute pipelines
    and perform some computations inside compute shaders, we must end a render pass.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Compute shaders cannot be dispatched inside render passes.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding descriptor sets*'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the recipe:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ending a render pass*'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing compute shaders*'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a compute pipeline*'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding a pipeline object*'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a secondary command buffer inside a primary command buffer
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan we can record two types of command buffers--primary and secondary.
    Primary command buffers can be submitted to queues directly. Secondary command
    buffers can be executed only from within primary command buffers.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a command buffer's handle. Store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a variable of type `std::vector<VkCommandBuffer>` named `secondary_command_buffers`
    containing secondary command buffers that should be executed from within the `command_buffer`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Record the following command: `vkCmdExecuteCommands( command_buffer, static_cast<uint32_t>(secondary_command_buffers.size()),
    secondary_command_buffers.data() )`. Provide the handle of the primary command
    buffer, the number of elements in the `secondary_command_buffers` vector, and
    a pointer to its first element.'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Secondary command buffers are recorded in a similar way to primary command
    buffers. In most cases, primary command buffers should be enough to perform rendering
    or computing work. But there may be situations in which we need to divide work
    into two command buffer types. When we have recorded secondary command buffers
    and we want the graphics hardware to process them, we can execute them from within
    a primary command buffer like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording a command buffer that draws a geometry with dynamic viewport and scissor
    states
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have all the knowledge required to draw images using the Vulkan API.
    In this sample recipe, we will aggregate some of the previous recipes and see
    how to use them to record a command buffer that displays a geometry.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To draw a geometry, we will use a custom structure type that has the following
    definition:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Data` member contains values for all the attributes of a given vertex,
    one vertex after another. For example, there are three components of position
    attribute, three components of a normal vector and two texture coordinates of
    a first vertex. After that, there is data for the position, normal, and **TexCoords**
    of a second vertex, and so on.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The `VertexOffset` member is used to store vertex offsets of separate parts
    of a geometry. The `VertexCount` vector contains a number of vertices in each
    such part.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Before we can draw a model whose data is stored in a variable of the preceding
    type, we need to copy the contents of a `Data` member to a buffer that will be
    bound to a command buffer as a vertex buffer.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a primary command buffer and store it in a variable of type
    `VkCommandBuffer` named `command_buffer`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start recording the `command_buffer` (refer to the *Beginning a command buffer
    recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of an acquired swapchain image and use it to initialize a variable
    of type `VkImage` named `swapchain_image` (refer to the *Getting handles of swapchain
    images* and *Acquiring a swapchain image* recipes from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*).
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the index of a queue family that is used for swapchain image presentation
    in a variable of type `uint32_t` named `present_queue_family_index`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the index of a queue family used for performing graphics operations in
    a variable of type `uint32_t` named `graphics_queue_family_index`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If values stored in the `present_queue_family_index` and `graphics_queue_family_index`
    variables are different, set up an image memory barrier in the `command_buffer`
    (refer to the *Setting an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*). Use a `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` value for the
    `generating_stages` parameter and a `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`
    value for the `consuming_stages` parameters. For the barrier, provide a single
    variable of type `ImageTransition` and use the following values to initialize
    its members:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `swapchain_image` variable for `Image`
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_ACCESS_MEMORY_READ_BIT` value for `CurrentAccess`
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `NewAccess`
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `CurrentLayout`
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `NewLayout`
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `present_queue_family_index` variable for `CurrentQueueFamily`
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `graphics_queue_family_index` variable for `NewQueueFamily`
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_ASPECT_COLOR_BIT` value for `Aspect`
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the handle of a `render pass` and store it in a variable of type `VkRenderPass`
    named `render_pass`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the handle of a framebuffer compatible with the `render_pass` in a variable
    of type `VkFramebuffer` named `framebuffer`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the size of the `framebuffer` in a variable of type `VkExtent2D` named
    `framebuffer_size`.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `std::vector<VkClearValue>` named `clear_values`.
    For each attachment used in the `render_pass` (and the `framebuffer`), add an
    element to the `clear_values` variable with values, to which corresponding attachments
    should be cleared.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record a `render pass` beginning operation in the `command_buffer`. Use the
    `render_pass`, `framebuffer`, `framebuffer_size`, and `clear_values` variables
    and a `VK_SUBPASS_CONTENTS_INLINE` value (refer to *Beginning a render pass* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*).
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a graphics pipeline and use it to initialize a variable of
    type `VkPipeline` named `graphics_pipeline`. Make sure the pipeline was created
    with dynamic viewport and scissor states.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the pipeline to the `command_buffer`. Provide a `VK_PIPELINE_BIND_POINT_GRAPHICS`
    value and the `graphics_pipeline` variable (refer to the *Binding a pipeline object*
    recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*).
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkViewport` named `viewport`. Use the following
    values to initialize its members:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `0.0f` value for `x`
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `0.0f` value for `y`
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `width` member of the `framebuffer_size` variable for `width`
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `height` member of the `framebuffer_size` variable for `height`
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `0.0f` value for `minDepth`
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `1.0f` value for `maxDepth`
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the viewport state dynamically in the `command_buffer`. Use a `0` value
    for the `first_viewport` parameter and a vector of type `std::vector<VkViewport>`
    with a single element containing the `viewport` variable for the `viewports` parameter
    (refer to the *Setting viewport state dynamically* recipe).
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkRect2D` named `scissor`. Use the following values
    to initialize its members:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `0` value for the `x` member of the `offset`
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `0` value for the `y` member of the `offset`
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `framebuffer_size.width` member variable for the `width` member of the `extent`
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `framebuffer_size.height` member variable for the `height` member of the
    `extent`
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the scissor state dynamically in the `command_buffer`. Use a `0` value for
    the `first_scissor` parameter and a vector of type `std::vector<VkRect2D>` with
    a single element containing the `scissor` variable as the `scissors` parameter
    (refer to the *Setting scissor states dynamically* recipe in this chapter).
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VertexBufferParameters>` named `vertex_buffers_parameters`.
    For each buffer that should be bound to the `command_buffer` as a vertex buffer,
    add an element to the `vertex_buffers_parameters` vector. Use the following values
    to initialize the members of the new element:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The handle of a buffer that should be used as the vertex buffer for `Buffer`
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The offset in bytes from the beginning of the buffer's memory (the memory part
    that should be bound for the vertex buffer) for `memoryoffset`
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the value of the first binding, to which the first vertex buffer should
    be bound, in a variable of type `uint32_t` named `first_vertex_buffer_binding`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind vertex buffers to the `command_buffer` using the `first_vertex_buffer_binding`
    and `vertex_buffers_parameters` variables (refer to the *Binding vertex buffers*
    recipe).
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform the following operations if any descriptor resources should be used
    during drawing:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a pipeline's layout and store it in a variable of type `VkPipelineLayout`
    named `pipeline_layout` (refer to *Creating a pipeline layout* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each descriptor set to be used during drawing to a vector variable of type
    `std::vector<VkDescriptorSet>` named `descriptor_sets`.
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Store an index, to which the first descriptor set should be bound, in a variable
    of type `uint32_t` named `index_for_first_descriptor_set`.
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind descriptor sets to the `command_buffer` using a `VK_PIPELINE_BIND_POINT_GRAPHICS`
    value and the `pipeline_layout`, `index_for_first_descriptor_set` and `descriptor_sets`
    variables.
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a geometry in the `command_buffer` specifying the desired values for the
    `vertex_count`, `instance_count`, `first_vertex`, and `first_instance` parameters
    (refer to the *Drawing a geometry* recipe).
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End a render pass in the `command_buffer` (refer to the *Ending a render pass*
    recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*).
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If values stored in the `present_queue_family_index` and `graphics_queue_family_index`
    variables are different, set up another image memory barrier in the `command_buffer`
    (refer to the *Setting an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*). Use the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`
    value for the `generating_stages` parameter and the `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT`
    value for the `consuming_stages` parameter. For the barrier, provide a single
    variable of type `ImageTransition` initialized with the following values:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `swapchain_image` variable for `Image`
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `CurrentAccess`
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_ACCESS_MEMORY_READ_BIT` value for `NewAccess`
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `CurrentLayout`
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `NewLayout`
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `graphics_queue_family_index` variable for `CurrentQueueFamily` and the
    `present_queue_family_index` variable for `NewQueueFamily`
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_ASPECT_COLOR_BIT` value for `Aspect`
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop recording the `command_buffer` (refer to the *Ending a command buffer recording
    operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assume we want to draw a single object. We want the object to appear directly
    on screen so, before we begin, we must acquire a swapchain image (refer to the
    *Acquiring a swapchain image* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*). Next, we start recording the command buffer (refer to the
    *Beginning a command buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first thing we need to record is to change the swapchain image''s layout
    to a `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` layout. This operation should
    be performed implicitly using appropriate render pass parameters (initial and
    sub-pass layouts). But if queues used for the presentation and graphics operations
    come from two different families, we must perform ownership transfer. This cannot
    be done implicitly--for this we need to set up an image memory barrier (refer
    to the *Setting an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next thing to do is to start a render pass (refer to the *Beginning a render
    pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render
    Passes and Framebuffers*). We also need to bind a pipeline object (refer to the
    *Binding a pipeline object* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). We must do this before we can set up any pipeline
    related state:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When a pipeline is bound, we must set up any state that was marked as dynamic
    during the pipeline creation. Here, we set up viewport and scissor test states
    respectively (refer to the *Setting viewport states dynamically* and *Setting
    scissor states dynamically* recipes). We also bind a buffer that should be a source
    of vertex data (refer to the *Binding vertex buffers* recipe). This buffer must
    contain data copied from a variable of type `Mesh`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One last thing to do in this example is to bind the descriptor sets, which
    can be accessed inside shaders (refer to the *Binding descriptor sets* recipe
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we are ready to draw a geometry. Of course, in more advanced scenarios,
    we would need to set up parameters of other states and bind other resources. For
    example, we may need to use an index buffer and provide values for push constants.
    But, the preceding setup is also enough for many cases:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To draw a geometry, we must provide the number of geometry instances we want
    to draw and an index of a first instance. Vertex offsets and the number of vertices
    to draw are taken from the members of variables of type `Mesh`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can stop recording a command buffer, we need to end a render pass
    (refer to the *Ending a render pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*). After that, another transition on a swapchain
    image is required. When we are done rendering a single frame of animation, we
    want to present (display) a swapchain image. For this, we need to change its layout
    to a `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout, because this layout is required
    for the presentation engine to correctly display an image. This transition should
    also be performed implicitly through render pass parameters (the final layout).
    But again, if the queues used for graphics operations and presentations are different,
    a queue ownership transfer is necessary. This is done with another image memory
    barrier. After that, we stop recording a command buffer (refer to the *Ending
    a command buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This concludes the command buffer recording operation. We can use this command
    buffer and submit it to a (graphics) queue. It can be submitted only once, because
    it was recorded with a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` flag. But,
    of course, we can record a command buffer without this flag and submit it multiple
    times.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: After submitting the command buffer, we can present a swapchain image, so it
    is displayed on screen. But, we must remember that submission and presentation
    operations should be synchronized (refer to the *Preparing a single frame of animation*
    recipe).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Acquiring a swapchain image*'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Presenting an image*'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ending a command buffer recording operation*'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding descriptor sets*'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a render pass*'
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ending a render pass*'
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the recipe:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding a pipeline object*'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding vertex buffers*'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting viewport states dynamically*'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting scissor states dynamically*'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing a geometry*'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Preparing a single frame of animation*'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording command buffers on multiple threads
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High level graphics APIs such as OpenGL are much easier to use, but they are
    also limited in many aspects. One such aspect is the lack of ability to render
    scenes on multiple threads. Vulkan fills this gap. It allows us to record command
    buffers on multiple threads, utilizing as much processing power of not only the
    graphics hardware, but also of the main processor.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe, a new type is introduced. It has the following
    definition:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding structure is used to store parameters specific for each thread
    used to record command buffers. The handle of a command buffer that will be recorded
    on a given thread is stored in the `CommandBuffer` member. The `RecordingFunction`
    member is used to define a function, inside which we will record the command buffer
    on a separate thread.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<CommandBufferRecordingThreadParameters>`
    named `threads_parameters`. For each thread used to record a command buffer, add
    a new element to the preceding vector. Initialize the element with the following
    values:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The handle of a command buffer to be recorded on a separate thread for `CommandBuffer`
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The function (accepting a command buffer handle) used to record a given command
    buffer for `RecordingFunction`
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a variable of type `std::vector<std::thread>` named `threads`. Resize
    it to be able to hold the same number of elements as the `threads_parameters`
    vector.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each element in the `threads_parameters` vector, start a new thread that
    will use the `RecordingFunction` and provide the `CommandBuffer` as the function's
    argument. Store the handle of a created thread at the corresponding position in
    the `threads` vector.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until all created threads finish their execution by joining with all elements
    in the `threads` vector.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gather all recorded command buffers in a variable of type `std::vector<VkCommandBuffer>`
    named `command_buffers`.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to use Vulkan in a multithreaded application, we must keep in mind
    several rules. First, we shouldn't modify the same object on multiple threads.
    For example, we cannot allocate command buffers from a single pool or we cannot
    update a descriptor set from multiple threads.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: We can access resources from multiple threads only if the access is read only
    or if we reference separate resources. But, as it may be hard to track which resources
    were created on which thread, in general, resource creation and modification should
    be performed only on a single *main* thread (which we can also call *the rendering
    thread*).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: The most common scenario of utilizing multithreading in Vulkan is to concurrently
    record command buffers. This operation takes most of the processor time. It is
    also the most important operation performance-wise, so dividing it into multiple
    threads is very reasonable.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: When we want to record multiple command buffers in parallel, we need to use
    not only a separate command buffer for each thread, but also a separate command
    pool.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: We need to use a separate command pool for each thread, on which command buffers
    will be recorded. In other words--a command buffer recorded on each thread must
    be allocated from a separate command pool.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Command buffer recording doesn't affect other resources (apart from the pool).
    We only prepare commands that will be submitted to a queue, so we can record any
    operations that use any resources. For example, we can record operations that
    access the same images or the same descriptor sets. The same pipelines can be
    bound to different command buffers at the same time during recording. We can also
    record operations that draw into the same attachments. We only record (prepare)
    operations.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'Recording command buffers on multiple threads may be performed like this:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, each thread takes a separate `RecordingFunction` member, in which a corresponding
    command buffer is recorded. When all threads finish recording their command buffers,
    we need to gather the command buffers and submit them to a queue, when they are
    executed.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: In real-life applications, we will probably want to avoid creating and destroying
    threads in this way. Instead, we should take an existing job/task system and use
    it to also record the necessary command buffers. But the presented example is
    easy to use and understand. And, it is also good at illustrating the steps that
    need to be performed to use Vulkan in multithreaded applications.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'Submission can also be performed only from a single thread (queues, similarly
    to other resources, cannot be accessed concurrently), so we need to wait until
    all threads finish their jobs:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Submitting command buffers to a queue can be performed only from a single thread
    at a time.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding situation is presented in the following diagram:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_003.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
- en: A similar situation occurs with a swapchain object. We can acquire and present
    swapchain images only from a single thread at a given moment. We cannot do this
    concurrently.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: A swapchain object cannot be accessed (modified) concurrently on multiple threads.
    Acquiring an image and presenting it should be done on a single thread.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: But, it is a valid operation to acquire a swapchain image on a single thread
    and then concurrently record multiple command buffers that render into this swapchain
    image. We just need to make sure that the first submitted command buffer performs
    a layout transition away from the `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` (or the `VK_IMAGE_LAYOUT_UNDEFINED`)
    layout. Transition back to the `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout must be
    performed inside the command buffer that was submitted to the queue at the end.
    The order in which these command buffers were recorded doesn't matter; only the
    submission order is crucial.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when we want to record operations that modify resources (for example,
    store values in buffers), we must also record proper synchronization operations
    (such as pipeline barriers). This is necessary for the proper execution, but it doesn't
    matter from the recording perspective.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Acquiring a swapchain image*'
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Presenting an image*'
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to a queue*'
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a single frame of animation
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, when we create 3D applications that render images, we would like images
    to be displayed on screen. For this purpose, a swapchain object is created in
    Vulkan. We know how to acquire images from a swapchain. We have also learned how
    to present them. Here, we will see how to connect image acquiring and presentation,
    how to record a command buffer in between, and how we should synchronize all of
    these operations to render a single frame of animation.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a handle of a created swapchain to initialize a variable of type `VkSwapchainKHR`
    named `swapchain`.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a semaphore handle in a variable of type `VkSemaphore` named `image_acquired_semaphore`.
    Make sure the semaphore is unsignaled or isn't being used in any previous submissions
    that haven't completed yet.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `uint32_t` named `image_index`.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire an image from the `swapchain` using the `logical_device`, `swapchain`,
    and `image_acquired_semaphore` variables and store its index in the `image_index`
    variable (refer to the *Acquiring a swapchain image* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*).
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a handle of a render pass that will be used during recording drawing
    operations. Store it in a variable of type `VkRenderPass` named `render_pass`.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare image views for all swapchain images. Store them in a variable of type
    `std::vector<VkImageView>` named `swapchain_image_views`.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the size of the swapchain images in a variable of type `VkExtent2D` named
    `swapchain_size`.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkFramebuffer` named `framebuffer`.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a framebuffer for the `render_pass` (with at least an image view corresponding
    to the swapchain's image at the position `image_index`) using the `logical_device`,
    `swapchain_image_views[image_index]` and `swapchain_size` variables. Store the
    created handle in the framebuffer variable (refer to the *Creating a framebuffer*
    recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*).
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record a command buffer using the acquired swapchain image at the `image_index`
    position and the `framebuffer` variable. Store the handle of the recorded command
    buffer in a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a queue that will process commands recorded in the `command_buffer`.
    Store the queue's handle in a variable of type `VkQueue` named `graphics_queue`.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of an unsignaled semaphore and store it in a variable of type
    `VkSemaphore` named `ready_to_present_semaphore`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare an unsignaled fence and store its handle in a variable of type `VkFence`
    named `finished_drawing_fence`.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `WaitSemaphoreInfo` named `wait_semaphore_info` (refer
    to the *Submitting command buffers to a queue* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command
    Buffers and Synchronization*). Initialize members of this variable using the following
    values:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `image_acquired_semaphore` variable for semaphore
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `WaitingStage`
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit the `command_buffer` to the `graphics_queue`, specifying one element
    vector with the `wait_semaphore_info` variable for the `wait_semaphore_infos`
    parameter, the `ready_to_present_semaphore` variable for the semaphore to be signaled,
    and the `finished_drawing_fence` variable for the fence to be signaled (refer
    to the *Submitting command buffers to the queue* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the handle of a queue used for presentation. Store it in a variable
    of type `VkQueue` named `present_queue`.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `PresentInfo` named `present_info` (refer to the
    *Presenting an image* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*). Initialize members of this variable with the following
    values:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `swapchain` variable for `Swapchain`
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `image_index` variable for `ImageIndex`
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Present the acquired swapchain image to the `present_queue` queue. Provide one
    element vector with the `ready_to_present_semaphore` variable as the `rendering_semaphores`
    parameter, and one element vector with the `present_info` variable as the `images_to_present`
    parameter (refer to the *Presenting an image* recipe from [Chapter 2](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=605&action=edit#post_29),
    *Image Presentation*).
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Preparing a single frame of animation can be divided into five steps:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring a swapchain image.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a framebuffer.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recording a command buffer.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submitting the command buffer to the queue.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Presenting an image.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we must acquire a swapchain image into which we can render. Rendering
    is performed inside a render pass that defines the parameters of attachments.
    Specific resources used for these attachments are defined in a framebuffer.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: As we want to render into a swapchain image (to display the image on screen),
    this image must be specified as one of the attachments defined in a framebuffer.
    It may seem that creating a framebuffer earlier and reusing it during the rendering
    is a good idea. Of course, it is a valid approach but it has its drawbacks. The
    most important drawback is that it may be hard to maintain it during the lifetime
    of our application. We can render only into the image that was acquired from a
    swapchain. But as we don't know which image will be acquired, we need to prepare
    separate framebuffers for all swapchain images. What's more, we will need to recreate
    them each time a swapchain object is recreated. If our rendering algorithm requires
    more attachments to render into, we will start creating multiple variations of
    framebuffers for all combinations of swapchain images and images created by us.
    This becomes very cumbersome.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要渲染到swapchain图像中（以在屏幕上显示图像），因此必须将此图像指定为帧缓冲区中定义的附件之一。看起来，在早期创建帧缓冲区并在渲染期间重用它是好主意。当然，这是一个有效的方法，但它有其缺点。最重要的缺点是，在应用程序的生命周期内可能很难维护它。我们只能渲染从swapchain获取的图像。但由于我们不知道哪个图像将被获取，我们需要为所有swapchain图像准备单独的帧缓冲区。更重要的是，每次创建swapchain对象时，我们都需要重新创建它们。如果我们的渲染算法需要更多的附件来渲染，我们将开始为swapchain图像和由我们创建的图像的所有组合创建多个帧缓冲区变体。这变得非常繁琐。
- en: That's why it is much easier to create a framebuffer just before we start recording
    a command buffer. We create the framebuffer with only those resources that are
    needed to render this single frame. We just need to remember that we can destroy
    such a framebuffer only when the execution of a submitted command buffer is finished.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在开始记录命令缓冲区之前创建帧缓冲区要容易得多。我们只使用渲染这一帧所需的资源来创建帧缓冲区。我们只需记住，我们只能在提交的命令缓冲区执行完成后销毁这样的帧缓冲区。
- en: A framebuffer cannot be destroyed until the queue stops processing a command
    buffer in which the framebuffer was used.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 直到队列停止处理使用帧缓冲区的命令缓冲区之前，帧缓冲区不能被销毁。
- en: 'When an image is acquired and a framebuffer is created, we can record a command
    buffer. These operations may be performed like this:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取图像并创建帧缓冲区时，我们可以记录一个命令缓冲区。这些操作可以按如下方式进行：
- en: '[PRE29]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, we are ready to submit the command buffer to the queue. Operations
    recorded in the command buffer must wait until the presentation engine allows
    us to use the acquired image. For this purpose, we specify a semaphore when the
    image is acquired. This semaphore must also be provided as one of the wait semaphores
    during command buffer submission:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就准备好将命令缓冲区提交到队列中。记录在命令缓冲区中的操作必须等待直到显示引擎允许我们使用获取到的图像。为此，我们在获取图像时指定一个信号量。这个信号量也必须在提交命令缓冲区时作为等待信号量之一提供：
- en: '[PRE30]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A rendered image can be presented (displayed on screen) when the queue stops
    processing the command buffer, but we don't want to wait and check when this happens.
    That's why we use an additional semaphore (the `ready_to_present_semaphore` variable
    in the preceding code) that will be signaled when the command buffer's execution
    is finished. The same semaphore is then provided when we present a swapchain image.
    This way, we synchronize operations internally on the GPU as this is much faster
    than synchronizing them on the CPU. If we weren't using the semaphore, we would
    need to wait until the fence is signaled and only then could we present an image.
    This would stall our application and hurt the performance considerably.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列停止处理命令缓冲区时，渲染的图像可以被呈现（显示在屏幕上），但我们不希望等待并检查何时发生这种情况。这就是为什么我们使用一个额外的信号量（前述代码中的`ready_to_present_semaphore`变量），当命令缓冲区的执行完成时，该信号量将被触发。然后，当呈现swapchain图像时，提供相同的信号量。这样，我们可以在GPU上内部同步操作，这比在CPU上同步要快得多。如果我们没有使用信号量，我们就需要等待直到栅栏被触发，然后才能呈现图像。这将使我们的应用程序停滞，并大大降低性能。
- en: You may wonder why we need the fence (`finished_drawing_fence` in the preceding
    code), as it also gets signaled when the command buffer processing is finished.
    Isn't the semaphore enough? No, there are situations in which the application
    also needs to know when the execution of a given command buffer has ended. One
    such situation is when destroying the created framebuffer. We can't destroy it
    until the preceding fence is signaled. Only the application can destroy the resources
    it created, so it must know when it can safely destroy them (when they are not
    used anymore). Another example is re-recording of the command buffer. We can't
    record it again until its execution on a queue is finished. So we need to know
    when this happens. And, as the application cannot check the state of a semaphore,
    the fence must be used.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Using both a semaphore and a fence allows us to submit command buffers and present
    images immediately one after another, without unnecessary waits. And we can do
    these operations for multiple frames independently, increasing the performance
    even further.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=605&action=edit#post_29),
    *Image Presentation*, see the following recipes:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting handles of swapchain images*'
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Acquiring a swapchain image*'
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Presenting an image*'
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a semaphore*'
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a fence*'
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to a queue*'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Checking if processing of a submitted command buffer has finished*'
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a render pass*'
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a framebuffer*'
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the performance through increasing the number of separately rendered
    frames
  id: totrans-602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering a single frame of animation and submitting it to a queue is the goal
    of 3D graphics applications, such as games and benchmarks. But a single frame
    isn't enough. We want to render and display multiple frames or we won't achieve
    the effect of animation.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we can't re-record the same command buffer immediately after
    we submit it; we must wait until the queue stops processing it. But, waiting until
    the command buffer processing is finished is a waste of time and it hurts the
    performance of our application. That's why we should render multiple frames of
    animation independently.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe, we will use variables of a custom `FrameResources`
    type. It has the following definition:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding type is used to define resources that manage the lifetime of a
    single frame of animation.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: The `CommandBuffer` member stores a handle of a command buffer used to record
    operations of a single, independent frame of animation. In a real-life application,
    a single frame will be probably composed of multiple command buffers recorded
    in multiple threads. But for the purpose of a basic code sample, one command buffer
    is enough.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: The `ImageAcquiredSemaphore` member is used to store a semaphore handle passed
    to the presentation engine when we acquire an image from a swapchain. This semaphore
    must then be provided as one of the wait semaphores when we submit the command
    buffer to a queue.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: The `ReadyToPresentSemaphore` member indicates a semaphore that gets signaled
    when a queue stops processing our command buffer. We should use it during image
    presentation, so the presentation engine knows when the image is ready.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: The `DrawingFinishedFence` member contains a fence handle. We provide it during
    the command buffer submission. Similarly to the `ReadyToPresentSemaphore` member,
    this fence gets signaled when the command buffer is no longer executed on a queue.
    But the fence is necessary to synchronize operations on the CPU side (the operations
    our application performs), not the GPU (and the presentation engine). When this
    fence is signaled, we know that we can both re-record the command buffer and destroy
    a framebuffer.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: The `DepthAttachment` member is used to store an image view for an image serving
    as a depth attachment inside a sub-pass.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: The `Framebuffer` member is used to store a temporary framebuffer handle created
    for the lifetime of a single frame of animation.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Most of the preceding members are wrapped into objects of a `VkDestroyer` type.
    This type is responsible for the implicit destruction of an owned object, when
    the object is no longer necessary.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<FrameResources>` named `frame_resources`.
    Resize it to hold the resources for the desired number of independently rendered
    frames (the recommended size is three), and initialize each element using the
    following values (the values stored in each element must be unique):'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The handle of a created command buffer for `commandbuffer`
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two handles of created semaphores for `ImageAcquiredSemaphore` and `ReadyToPresentSemaphore`
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handle of a fence created in an already signaled state for `DrawingFinishedFence`
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handle of an image view for an image serving as a depth attachment for `DepthAttachment`
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_NULL_HANDLE` value for `Framebuffer`
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a (potentially static) variable of type `uint32_t` named `frame_index`.
    Initialize it with a `0` value.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `FrameResources` named `current_frame` that references
    an element of the `frame_resources` vector pointed to by the `frame_index` variable.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the `current_frame.DrawingFinishedFence` gets signaled. Provide the
    `logical_device` variable and a timeout value equal to `2000000000` (refer to
    the *Waiting for fences* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the state of the `current_frame.DrawingFinishedFence` fence (refer to
    the *Resetting fences* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `current_frame.Framebuffer` member contains a handle of a created `framebuffer`,
    destroy it and assign a `VK_NULL_HANDLE` value to the member (refer to the *Destroying
    a framebuffer* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepare a single frame of animation using all the members of the `current_frame`
    variable (refer to the *Preparing a single frame of animation* recipe):'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire a swapchain image providing the `current_frame.ImageAcquiredSemaphore`
    variable during this operation.
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a framebuffer and store its handle in the `current_frame.Framebuffer`
    member.
  id: totrans-631
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Record a command buffer stored in the `current_frame.CommandBuffer` member.
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Submit the `current_frame.CommandBuffer` member to a selected queue, providing
    the `current_frame.ImageaAquiredSemaphore` semaphore as one of the waiting semaphores,
    the `current_frame.ReadyToPresentSemaphore` semaphore as the semaphore to be signaled,
    and the `current_frame.DrawingFinishedFence` fence as the fence to be signaled
    when the command buffer's execution is finished.
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Present a swapchain image to a selected queue, providing the one element vector
    with the `current_frame.ReadyToPresentSemaphore` variable as the `rendering_semaphores`
    parameter.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment a value stored in the `frame_index` variable. If it is equal to the
    number of elements in the `frame_resources` vector, reset the variable to `0`.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering animation is performed in a loop. One frame is rendered and an image
    is presented, then usually the operating system messages are processed. Next,
    another frame is rendered and presented, and so on.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: When we have only one command buffer and other resources required to prepare,
    render, and display a frame, we can't reuse them immediately. Semaphores cannot
    be used for another submission until the previous submission, in which they were
    used, has been finished. This situation requires us to wait for the end of the
    command buffer processing. But such waits are highly undesirable. The more we
    wait on the CPU, the more stalls we introduce to the graphics hardware and the
    worse performance we achieve.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 'To shorten the time we wait in our application (until a command buffer recorded
    for the previous frame is executed), we need to prepare several sets of resources
    required to render and present a frame. When we record and submit a command buffer
    for one frame and we want to prepare another frame, we just take another set of
    resources. For the next frame, we use yet another set of resources until we have
    used all of them. Then we just take the least recently used set--of course, we
    need to check if we can reuse it but, at this time, there is a high probability
    that it has already been processed by the hardware. The process of rendering animation
    using multiple sets of **Frame Resources** is presented in the following diagram:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_004.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
- en: How many sets should we prepare? We may think that the more sets we have the
    better, because we won't need to wait at all. But unfortunately, the situation
    isn't that simple. First, we increase the memory footprint of our application.
    But, more importantly, we increase an input lag. Usually, we render animation
    based on the input from the user, who wants to rotate a virtual camera, view a
    model, or move a character. We want our application to respond to a user's input
    as quickly as possible. When we increase the number of independently rendered
    frames, we also increase the time between a user's input and the effect it has
    on the rendered image.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: We need to balance the number of separately rendered frames, the performance
    of our application, its memory usage, and the input lag.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: So, how many frame resources should we have? This of course depends on the complexity
    of the rendered scenes, the performance of the hardware on which the application
    is executed, and the type of rendering scenario it realizes (that is, the type
    of game we are creating--whether it is a fast **first-person perspective** (**FPP**)
    shooter or a racing game, or a more slow-paced tour based **role-playing** **game**
    (**RPG**)). So there is not one exact value that will fit all possible scenarios.
    Tests have shown that increasing the number of frame resources from one to two
    may increase the performance by 50%. Adding a third set increases the performance
    further, but the growth isn't as big this time. So, the performance gain is smaller
    with each additional set of frame resources. Three sets of rendering resources
    seems like a good choice, but we should perform our own tests and see what is
    best for our specific needs.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see three examples of recording and submitting command buffers with
    one, two, and three independent sets of resources needed to render frames of animations,
    as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_005.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
- en: Now that we know why we should use several independent numbers of frame resources,
    we can see how to render a frame using them.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start by checking if we can use a given set of resources to prepare
    a frame. We do this by checking the status of a fence. If it is signaled, we are
    good to go. You may wonder, what should we do when we render the very first frame--we
    didn''t submit anything to a queue yet, so the fence didn''t have an opportunity
    to be signaled. It''s true, and that''s why, for the purpose of preparing frame
    resources, we should create fences in an already signaled state:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We should also check if a framebuffer used for the frame was created. If it
    was, we should destroy it because it will be created later. For an acquired swapchain
    image, an `InitVkDestroyer()` function initializes the provided variable with
    a new, empty object handle and, if necessary, destroys the previously owned object.
    After that, we render the frame and present an image. To do this, we need a command
    buffer and two semaphores (refer to the *Preparing a single frame of animation*
    recipe):'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One last thing is to increase the index of the currently used set of frame
    resources. For the next frame of animation we will use another set, until we have
    used all of them, and we start from the beginning:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Waiting for fences*'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resetting fences*'
  id: totrans-656
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipe:'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a framebuffer*'
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Preparing a single frame of animation *recipe in this chapter'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
