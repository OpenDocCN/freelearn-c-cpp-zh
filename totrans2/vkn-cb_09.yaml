- en: Command Recording and Drawing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令记录和绘制
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Clearing a color image
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除颜色图像
- en: Clearing a depth-stencil image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除深度-模板图像
- en: Clearing render pass attachments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除渲染通道附件
- en: Binding vertex buffers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定顶点缓冲区
- en: Binding an index buffer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定索引缓冲区
- en: Providing data to shaders through push constants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过推送常数向着色器提供数据
- en: Setting viewport state dynamically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态设置视口状态
- en: Setting scissor state dynamically
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态设置裁剪状态
- en: Setting line width state dynamically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态设置线宽状态
- en: Setting depth bias state dynamically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态设置深度偏差状态
- en: Setting blend constants state dynamically
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态设置混合常数状态
- en: Drawing a geometry
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制几何图形
- en: Drawing an indexed geometry
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制索引几何图形
- en: Dispatching compute work
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度计算工作
- en: Executing a secondary command buffer inside a primary command buffer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主命令缓冲区内部执行次级命令缓冲区
- en: Recording a command buffer that draws a geometry with a dynamic viewport and
    scissor states
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录一个具有动态视口和裁剪状态的几何图形的命令缓冲区
- en: Recording command buffers on multiple threads
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个线程上记录命令缓冲区
- en: Preparing a single frame of animation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备动画的单帧
- en: Increasing performance through increasing the number of separately rendered
    frames
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加单独渲染的帧数来提高性能
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Vulkan was designed as a graphics and compute API. Its main purpose is to allow
    us to generate dynamic images using a graphics hardware produced by various vendors.
    We already know how to create and manage resources and use them as a source of
    data for shaders. We learned about different shader stages and pipeline objects
    controlling the state of rendering or dispatching computational work. We also
    know how to record command buffers and order operations into render passes. One
    last step we must learn about is how to utilize this knowledge to render images.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan被设计为一个图形和计算API。其主要目的是允许我们使用由不同厂商生产的图形硬件生成动态图像。我们已经知道如何创建和管理资源，并将它们用作着色器的数据源。我们学习了不同的着色器阶段和管道对象，它们控制着渲染状态或调度计算工作。我们还知道如何记录命令缓冲区并将操作顺序放入渲染通道中。我们必须学习的最后一个步骤是如何利用这些知识来渲染图像。
- en: In this chapter, we will see what additional commands we can record and what
    commands need to be recorded so we can properly render a geometry or issue computational
    operations. We will also learn about the drawing commands and organizing them
    in our source code in such a way so that it maximizes the performance of our application.
    Finally, we will utilize one of the greatest strengths of the Vulkan API--the
    ability to record command buffers in multiple threads.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解我们可以记录哪些附加命令以及需要记录哪些命令，以便我们可以正确地渲染几何图形或执行计算操作。我们还将学习绘制命令，并在源代码中以这种方式组织它们，以最大化应用程序的性能。最后，我们将利用Vulkan
    API最伟大的优势之一——能够在多个线程中记录命令缓冲区。
- en: Clearing a color image
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除颜色图像
- en: In traditional graphics APIs, we start rendering a frame by clearing a render
    target or a back buffer. In Vulkan, we should perform the clearing by specifying
    a `VK_ATTACHMENT_LOAD_OP_CLEAR` value for a `loadOp` member of the render pass's
    attachment description (refer to the *Specifying attachment descriptions* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*). But sometimes, we can't clear an image inside a render pass and
    we need to do it implicitly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的图形API中，我们通过清除渲染目标或后缓冲区来开始渲染一个帧。在Vulkan中，我们应该通过指定渲染通道附件描述中的 `loadOp` 成员的
    `VK_ATTACHMENT_LOAD_OP_CLEAR` 值来执行清除操作（参考第6章中的 *指定附件描述* 菜谱 [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*)。但有时，我们无法在渲染通道内清除图像，我们需要隐式地执行此操作。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a command buffer stored in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state
    and no render pass has started.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为 `command_buffer` 的 `VkCommandBuffer` 类型变量中的命令缓冲区句柄。确保命令缓冲区处于记录状态且没有渲染通道已开始。
- en: Take the handle of an image that should be cleared. Provide it through a variable
    of type `VkImage` named `image`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应清除的图像句柄。通过名为 `image` 的 `VkImage` 类型变量提供它。
- en: Store the layout, in which the `image` will have during clearing, in a variable
    of type `VkImageLayout` named `image_layout`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在清除时 `image` 将具有的布局存储在名为 `image_layout` 的 `VkImageLayout` 类型变量中。
- en: 'Prepare a list of all mipmap levels of the `image` and array layers that should
    be cleared in a variable of type `std::vector<VkImageSubresourceRange>` named
    `image_subresource_ranges`. For each range of sub-resources of the `image`, add
    a new element to the `image_subresource_ranges` vector and use the following values
    to initialize its members:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个包含`image`和应清除的数组层的所有米普级别的列表，并将其存储在名为`image_subresource_ranges`的`std::vector<VkImageSubresourceRange>`类型变量中。对于`image`的每个子资源范围，向`image_subresource_ranges`向量添加一个新元素，并使用以下值初始化其成员：
- en: The image's aspect (color, depth, and/or stencil aspect cannot be provided)
    for `aspectMask`
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`aspectMask`，图像的方面（颜色、深度和/或模板方面不能提供）
- en: The first mipmap level to be cleared in a given range for `baseMipLevel`
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`baseMipLevel`，在给定范围内需要清除的第一个米普级别
- en: The number of continuous mipmap levels that should be cleared in a given range
    for `levelCount`
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定范围内需要清除的连续米普级别数量，对于`levelCount`
- en: The number of a first array layer that should be cleared in a given range for
    `baseArrayLayer`
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定范围内应清除的第一个数组层编号，对于`baseArrayLayer`
- en: The number of continuous array layers to be cleared for `layerCount`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要清除的连续数组层数量，对于`layerCount`
- en: 'Provide a color to which the image should be cleared using the following members
    of a variable type `VkClearColorValue` named `clear_color`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为`VkClearColorValue`的变量`clear_color`的以下成员提供图像应清除的颜色：
- en: '`int32`: When the image has a signed integer format'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32`: 当图像具有有符号整数格式时'
- en: '`uint32`: When the image has an unsigned integer format'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32`: 当图像具有无符号整数格式时'
- en: '`float32`: For the rest of the formats'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float32`: 对于其余的格式'
- en: Call the `vkCmdClearColorImage( command_buffer, image, image_layout, &clear_color,
    static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data()
    )` command for which it provides the `command_buffer`, `image`, `image_layout`
    variables, a pointer to the `clear_color` variable, the number of elements in
    the `image_subresource_ranges` vector, and a pointer to the first element of the
    `image_subresource_ranges` vector.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdClearColorImage( command_buffer, image, image_layout, &clear_color,
    static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data()
    )`命令，它提供了`command_buffer`、`image`、`image_layout`变量，`clear_color`变量的指针，`image_subresource_ranges`向量的元素数量，以及`image_subresource_ranges`向量第一个元素的指针。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Clearing color images is performed by recording the `vkCmdClearColorImage()`
    function in a command buffer. The `vkCmdClearColorImage()` command cannot be recorded
    inside a render pass.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令缓冲区中记录`vkCmdClearColorImage()`函数来执行清除颜色图像。`vkCmdClearColorImage()`命令不能在渲染通道内部记录。
- en: 'It requires us to provide the image''s handle, its layout, and an array of
    its sub-resources (mipmap levels and/or array layers) that should be cleared.
    We must also specify the color to which the image should be cleared. These parameters
    can be used like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它要求我们提供图像的句柄、其布局以及应清除的子资源（米普级别和/或数组层）的数组。我们还必须指定图像应清除的颜色。这些参数可以使用以下方式使用：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that by using this function, we can clear only color images (with a
    color aspect and one of the color formats).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，通过使用此函数，我们只能清除颜色图像（具有颜色方面和颜色格式之一）。
- en: The `vkCmdClearColorImage()` function can be used only for images created with
    **transfer dst** usage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`vkCmdClearColorImage()`函数只能用于使用**传输目标**用途创建的图像。'
- en: See also
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看以下配方：
- en: '*Creating an image*'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下配方：
- en: '*Specifying attachment descriptions*'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Clearing render pass attachments*'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清除渲染通道附件*'
- en: '*Clearing a depth-stencil image*'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清除深度-模板图像*'
- en: Clearing a depth-stencil image
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除深度-模板图像
- en: Similarly to color images, we sometimes need to manually clear a depth-stencil
    image outside of a render pass.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于颜色图像，我们有时需要在渲染通道之外手动清除深度-模板图像。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the command buffer that is in a recording state and has no render pass
    currently started in it. Using its handle, initialize a variable of type `VkCommandBuffer`
    named `command_buffer`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个处于记录状态且当前没有在其中启动渲染通道的命令缓冲区。使用其句柄，初始化一个名为`command_buffer`的`VkCommandBuffer`类型的变量。
- en: Take the handle of a depth-stencil image and store it in a variable of type
    `VkImage` named `image`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取深度-模板图像的句柄并将其存储在名为`image`的`VkImage`类型的变量中。
- en: Store the value representing the layout, in which the `image` will have during
    clearing, in a variable of type `VkImageLayout` named `image_layout`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表示清除期间`image`将具有的布局的值存储在名为`image_layout`的`VkImageLayout`类型的变量中。
- en: 'Create a variable of type `std::vector<VkImageSubresourceRange>` named `image_subresource_ranges`,
    which will contain a list of mipmap levels of all the `image`''s and array layers,
    which should be cleared. For each such range, add a new element to the `image_subresource_ranges`
    vector and use the following values to initialize its members:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_subresource_ranges`的`std::vector<VkImageSubresourceRange>`类型的变量，它将包含所有`image`的米普级别和数组层的列表，这些层应该被清除。对于这样的范围，向`image_subresource_ranges`向量添加一个新元素，并使用以下值来初始化其成员：
- en: The depth and/or stencil aspect for `aspectMask`
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`aspectMask`，深度和/或模板方面
- en: The first mipmap level to be cleared in a given range for `baseMipLevel`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`baseMipLevel`，给定范围内要清除的第一个米普级别
- en: The number of continuous mipmap levels in a given range for `levelCount`
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`levelCount`，给定范围内连续的米普级别数
- en: The number of a first array layer that should be cleared for `baseArrayLayer`
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`baseArrayLayer`，应该清除的第一个数组层的编号
- en: The number of continuous array layers to be cleared in a range for `layerCount`
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`layerCount`的范围中要清除的连续数组层数
- en: 'Provide a value which should be used to clear (fill) the image using the following
    members of a variable of type `VkClearDepthStencilValue` named `clear_value`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个值，该值应用于使用名为`clear_value`的`VkClearDepthStencilValue`类型变量的以下成员来清除（填充）图像：
- en: '`depth` when a depth aspect should be cleared'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depth`当需要清除深度方面时'
- en: '`stencil` for a value used to clear the stencil aspect'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencil`用于清除模板方面的值'
- en: Call `vkCmdClearDepthStencilImage( command_buffer, image, image_layout, &clear_value,
    static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data()
    )` and provide the `command_buffer`, `image`, and `image_layout` variables, a
    pointer to the `clear_value` variable, the number of elements in the `image_subresource_ranges`
    vector, and a pointer to the first element of the `image_subresource_ranges` vector.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdClearDepthStencilImage(command_buffer, image, image_layout, &clear_value,
    static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data())`并提供`command_buffer`、`image`和`image_layout`变量，`clear_value`变量的指针，`image_subresource_ranges`向量的元素数量，以及`image_subresource_ranges`向量第一个元素的指针。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Clearing the depth-stencil image outside of a render pass is performed like
    this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染通道之外清除深度-模板图像的操作如下：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use this function only for images created with a transfer dst usage (clearing
    is considered as a transfer operation).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能使用此函数来创建具有传输目标使用情况（清除被视为传输操作）的图像。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看食谱：
- en: '*Creating an image*'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下食谱：
- en: '*Specifying attachment descriptions*'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附加项描述*'
- en: '*Clearing render pass attachments*'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清除渲染通道附加项*'
- en: The *Clearing a color image* recipe, in this chapter
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*清除颜色图像*食谱
- en: Clearing render pass attachments
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除渲染通道附加项
- en: There are situations in which we cannot rely only on implicit attachment clearings
    performed as initial render pass operations, and we need to clear attachments
    explicitly in one of the sub-passes. We can do this by calling a `vkCmdClearAttachments()`
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况，我们不能仅仅依赖于作为初始渲染通道操作执行的隐式附加清除，我们需要在子通道之一中显式清除附加项。我们可以通过调用一个`vkCmdClearAttachments()`函数来实现。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take a command buffer that is in a recording state and store its handle in a
    variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个处于记录状态的命令缓冲区，并将其句柄存储在名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量中。
- en: 'Create a vector variable of type `std::vector<VkClearAttachment>` named `attachments`.
    For each `framebuffer` attachment that should be cleared inside a current sub-pass
    of a render pass, add an element to the vector and initialize it with the following
    values:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `attachments` 的 `std::vector<VkClearAttachment>` 类型的变量。对于渲染通道当前子通道中应清除的每个
    `framebuffer` 附件，向向量中添加一个元素，并用以下值初始化它：
- en: The attachment's aspect (color, depth, or stencil) for `aspectMask`
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspectMask` 的附件的方面（颜色、深度或模板）'
- en: If `aspectMask` is set to `VK_IMAGE_ASPECT_COLOR_BIT`, specify an index of a
    color attachment in the current sub-pass for `colorAttachment`; otherwise, this
    parameter is ignored
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `aspectMask` 设置为 `VK_IMAGE_ASPECT_COLOR_BIT`，则指定当前子通道中的颜色附件的索引 `colorAttachment`；否则，此参数被忽略
- en: A desired clear value for a color, depth, or stencil aspect for `clearValue`
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色、深度或模板方面的期望清除值 `clearValue`
- en: 'Create a variable of type `std::vector<VkClearRect>` named `rects`. For each
    area that should be cleared in all the specified attachments, add an element to
    the vector and initialize it with the following values:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `rects` 的 `std::vector<VkClearRect>` 类型的变量。对于所有指定附件中应清除的每个区域，向向量中添加一个元素，并用以下值初始化它：
- en: The rectangle to be cleared (top-left corner and a width and height) for `rect`
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要清除的矩形（左上角和宽高）`rect`
- en: The index of a first layer to be cleared for `baseArrayLayer`
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要清除的第一个层的索引 `baseArrayLayer`
- en: The number of layers to be cleared for `layerCount`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要清除的层数 `layerCount`
- en: Call `vkCmdClearAttachments( command_buffer, static_cast<uint32_t>(attachments.size()),
    attachments.data(), static_cast<uint32_t>(rects.size()), rects.data() )`. For
    the function call, provide the handle of the command buffer, the number of elements
    in the `attachments` vector, a pointer to its first element, the number of elements
    in the `rects` vector, and a pointer to its first element.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdClearAttachments(command_buffer, static_cast<uint32_t>(attachments.size()),
    attachments.data(), static_cast<uint32_t>(rects.size()), rects.data())`。对于函数调用，提供命令缓冲区的句柄、`attachments`
    向量中的元素数量、其第一个元素的指针、`rects` 向量中的元素数量以及其第一个元素的指针。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we want to explicitly clear an image that is used as a framebuffer''s
    attachment inside a started render pass, we cannot use the usual image clearing
    functions. We can do this only by selecting which attachments should be cleared.
    This is done through the `vkCmdClearAttachments()` function like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在已开始的渲染通道内显式清除用作帧缓冲区附件的图像时，我们不能使用通常的图像清除函数。我们只能通过选择哪些附件应该被清除来实现这一点。这通过 `vkCmdClearAttachments()`
    函数来完成，如下所示：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using this function, we can clear multiple regions of all the indicated attachments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，我们可以清除所有指示附件的多个区域。
- en: We can call the `vkCmdClearAttachments()` function only inside a render pass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在渲染通道内调用 `vkCmdClearAttachments()` 函数。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml) 中，*命令缓冲区和同步*，查看以下内容：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the recipes:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml) 中，*渲染通道和帧缓冲区*，查看以下内容：
- en: '*Specifying attachment descriptions*'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Specifying sub-pass descriptions*'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Beginning a render pass*'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: 'The following recipes from this chapter:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章以下内容：
- en: '*Clearing a color image*'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清除颜色图像*'
- en: '*Clearing a depth-stencil image*'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清除深度-模板图像*'
- en: Binding vertex buffers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定顶点缓冲区
- en: When we draw a geometry, we need to specify data for vertices. At the very least,
    vertex positions are required, but we can specify other attributes such as normal,
    tangent or bitangent vectors, colors, or texture coordinates. This data comes
    from buffers created with a **vertex buffer** usage. We need to bind these buffers
    to specified bindings before we can issue drawing commands.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制几何体时，我们需要指定顶点的数据。至少，需要顶点位置，但我们还可以指定其他属性，如法线、切线或双切线向量、颜色或纹理坐标。这些数据来自使用 **顶点缓冲区**
    用法创建的缓冲区。在我们可以发出绘制命令之前，我们需要将这些缓冲区绑定到指定的绑定上。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, a custom `VertexBufferParameters` type is introduced. It has
    the following definition:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，引入了一个自定义的 `VertexBufferParameters` 类型。它具有以下定义：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This type is used to specify the buffer''s parameters: its handle (in the `Buffer`
    member) and an offset from the start of the buffer''s memory from which data should
    be taken (in the `MemoryOffset` member).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型用于指定缓冲区的参数：其句柄（在 `Buffer` 成员中）和从缓冲区内存起始位置开始的数据偏移（在 `MemoryOffset` 成员中）。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take the handle of a command buffer that is in a recording state and use it
    to initialize a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取处于记录状态的命令缓冲区的句柄，并使用它初始化一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量。
- en: Create a variable of type `std::vector<VkBuffer>` named `buffers`. For each
    buffer that should be bound to a specific binding in the command buffer, add the
    buffer's handle to the `buffers` vector.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `buffers` 的 `std::vector<VkBuffer>` 类型的变量。对于应绑定到命令缓冲区中特定绑定的每个缓冲区，将缓冲区的句柄添加到
    `buffers` 向量中。
- en: Create a variable of type `std::vector<VkDeviceSize>` named `offsets`. For each
    buffer in the `buffers` vector, add a new member to the `offsets` vector with
    an offset value from the start of the corresponding buffer's memory (the buffer
    at the same index in the `buffers` vector).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `offsets` 的 `std::vector<VkDeviceSize>` 类型的变量。对于 `buffers` 向量中的每个缓冲区，在
    `offsets` 向量中添加一个新的成员，其偏移值从对应缓冲区内存的起始位置（`buffers` 向量中相同索引的缓冲区）计算得出。
- en: Call `vkCmdBindVertexBuffers( command_buffer, first_binding, static_cast<uint32_t>(buffers_parameters.size()),
    buffers.data(), offsets.data() )`, providing the handle of the command buffer,
    the number of the first binding to which the first buffer from the list should
    be bound, the number of elements in the `buffers` (and `offsets`) vector, and
    a pointer to the first element of the `buffers` vector and to the first element
    of the `offsets` vector.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdBindVertexBuffers( command_buffer, first_binding, static_cast<uint32_t>(buffers_parameters.size()),
    buffers.data(), offsets.data() )`，提供命令缓冲区的句柄、第一个应绑定到其上的绑定编号、`buffers`（和 `offsets`）向量中的元素数量，以及
    `buffers` 向量第一个元素和 `offsets` 向量第一个元素的指针。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'During the graphics pipeline creation, we specify the vertex attributes that
    will be used (provided to shaders) during drawing. This is done through vertex
    binding and attributes descriptions (refer to the *Specifying a pipeline vertex
    binding description, attribute description, and input state* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
    Through them, we define the number of attributes, their formats, the location
    through which the shader will be able to access them, and the memory properties,
    such as offset and stride. We also provide the binding index from which a given
    attribute should be read. With this binding, we need to associate a selected buffer,
    in which data for a given attribute (or attributes) is stored. The association
    is made by binding a buffer to the selected binding index in a given command buffer,
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形管线创建过程中，我们指定在绘制期间将使用（提供给着色器）的顶点属性。这是通过顶点绑定和属性描述来完成的（参考 [第 8 章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线顶点绑定描述、属性描述和输入状态*食谱）。通过它们，我们定义了属性的数量、它们的格式、着色器可以通过哪个位置访问它们，以及内存属性，如偏移和步进。我们还提供了从该绑定中读取给定属性的绑定索引。使用此绑定，我们需要将选定的缓冲区与给定属性（或属性集）的数据存储关联起来。关联是通过在给定命令缓冲区中将缓冲区绑定到选定的绑定索引来完成的，如下所示：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the handles of all the buffers that should be bound and
    their memory offsets are provided through a variable of type `std::vector<VertexBufferParameters>`
    named `buffers_parameters`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，通过一个名为 `buffers_parameters` 的 `std::vector<VertexBufferParameters>`
    类型的变量提供了所有应绑定及其内存偏移的缓冲区句柄。
- en: Remember that we can only bind buffers created with a vertex buffer usage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们只能绑定使用顶点缓冲区用途创建的缓冲区。
- en: See also
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，参见以下食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 4 章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，参见以下食谱：
- en: '*Creating a buffer*'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 8 章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，查看以下食谱：
- en: '*Specifying a pipeline vertex binding description*'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线顶点绑定描述*'
- en: '*Attribute description and input state*'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性描述和输入状态*'
- en: 'The following recipes in this chapter:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Drawing a geometry*'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制几何体*'
- en: '*Drawing an indexed geometry*'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制索引几何体*'
- en: Binding an index buffer
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定索引缓冲区
- en: To draw a geometry, we can provide the list of vertices (and their attributes)
    in two ways. The first way is a typical list, in which vertices are read one after
    another. The second method requires us to provide additional indices that indicate
    which vertices should be read to form polygons. This feature is known as indexed
    drawing. It allows us to reduce the memory consumption as we don't need to specify
    the same vertices multiple times. It is especially important when we have multiple
    attributes associated with each vertex, and when each such vertex is used across
    many polygons.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制几何体，我们可以以两种方式提供顶点列表（及其属性）。第一种方式是一个典型的列表，其中顶点一个接一个地读取。第二种方法需要我们提供额外的索引，指示应读取哪些顶点以形成多边形。这个特性被称为索引绘制。它允许我们减少内存消耗，因为我们不需要多次指定相同的顶点。当每个顶点与多个属性相关联，并且每个这样的顶点被多个多边形使用时，这一点尤为重要。
- en: Indices are stored in a buffer called an **index buffer**, which must be bound
    before we can draw an indexed geometry.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 索引存储在一个名为 **索引缓冲区** 的缓冲区中，在我们可以绘制索引几何体之前必须绑定它。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Store the command buffer's handle in a variable of type `VkCommandBuffer` named
    `command_buffer`. Make sure it is in a recording state.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令缓冲区的句柄存储在名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量中。确保它处于记录状态。
- en: Take the handle of the buffer in which the indices are stored. Use its handle
    to initialize a variable of type `VkBuffer` named `buffer`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取存储索引的缓冲区的句柄。使用其句柄初始化一个名为 `buffer` 的 `VkBuffer` 类型的变量。
- en: Take an offset value (from the start of the buffer's memory) that indicates
    the beginning of the indice's data. Store the offset in a variable of type `VkDeviceSize`
    named `memory_offset`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个偏移值（从缓冲区内存的起始位置），表示索引数据的开始。将偏移量存储在名为 `memory_offset` 的 `VkDeviceSize` 类型的变量中。
- en: Provide the type of data used for the indices. Use a `VK_INDEX_TYPE_UINT16`
    value for 16-bit unsigned integers or a `VK_INDEX_TYPE_UINT32` value for 32-bit
    unsigned integers. Store the value in a variable of type `VkIndexType` named `index_type`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供用于索引的数据类型。使用 `VK_INDEX_TYPE_UINT16` 值表示 16 位无符号整数或使用 `VK_INDEX_TYPE_UINT32`
    值表示 32 位无符号整数。将值存储在名为 `index_type` 的 `VkIndexType` 类型的变量中。
- en: Call `vkCmdBindIndexBuffer( command_buffer, buffer, memory_offset, index_type
    )`, and provide the handles of the command buffer and the buffer, the memory offset
    value, and the type of data used for the indices (the `index_type` variable as
    the last argument).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdBindIndexBuffer( command_buffer, buffer, memory_offset, index_type
    )`，并提供命令缓冲区和缓冲区的句柄、内存偏移量值以及用于索引的数据类型（作为最后一个参数的 `index_type` 变量）。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To use a buffer as a source of vertex indices, we need to create it with an
    *index buffer* usage and fill it with proper data--indices indicating what vertices
    should be used for drawing. Indices must be tightly packed (one after another)
    and they should just point to a given index in an array of vertex data, hence
    the name. This is shown in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓冲区用作顶点索引的来源，我们需要使用 *索引缓冲区* 用法创建它，并用适当的数据填充它--索引指示应使用哪些顶点进行绘制。索引必须紧密打包（一个接一个），它们应该仅指向顶点数据数组中的一个给定索引，因此得名。这在下图中显示：
- en: '![](img/image_09_01-1.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_01-1.png)'
- en: 'Before we can record an indexed drawing command, we need to bind an index buffer,
    like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够记录索引绘制命令之前，我们需要绑定一个索引缓冲区，如下所示：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the call, we need to provide a command buffer, to which we record the function
    and the buffer that should act as an index buffer. Also, the memory offset from
    the start of the buffer's memory is required. It shows from which parts of the
    buffer's memory the driver should start reading the indices. The last parameter,
    the `index_type` variable in the preceding example, specifies the data type of
    the indices stored in the buffer--if they are specified as unsigned integers with
    16 or 32 bits.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用，我们需要提供一个命令缓冲区，我们将记录函数和应作为索引缓冲区的缓冲区。还需要提供从缓冲区内存开始处的内存偏移量。它显示了驱动程序应该从缓冲区内存的哪些部分开始读取索引。上一个示例中的最后一个参数，`index_type`变量，指定了存储在缓冲区中的索引的数据类型--如果它们被指定为16位或32位的无符号整数。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看食谱：
- en: '*Creating a buffer*'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: 'The following recipes in this chapter:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章以下食谱：
- en: '*Binding vertex buffers*'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Drawing an indexed geometry*'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制索引几何体*'
- en: Providing data to shaders through push constants
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过推送常量提供数据给着色器
- en: During drawing or dispatching computational work, specific shader stages are
    executed--the ones defined during the pipeline creation. So the shaders can perform
    their job, we need to provide data to them. Most of the time we use descriptor
    sets, as they allow us to provide kilobytes or even megabytes of data through
    buffers or images. But using them is quite complicated. And, what's more important,
    frequent changes of descriptor sets may impact the performance of our application.
    But sometimes, we need to provide a small amount of data in a fast and easy way.
    We can do this using push constants.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制或调度计算工作期间，执行特定的着色器阶段--在管道创建期间定义的。因此，着色器可以完成其工作，我们需要向它们提供数据。大多数时候我们使用描述符集，因为它们允许我们通过缓冲区或图像提供千字节甚至兆字节的数据。但是使用它们相当复杂。更重要的是，描述符集的频繁更改可能会影响我们应用程序的性能。但是有时，我们需要以快速简单的方式提供少量数据。我们可以使用推送常量来完成此操作。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Store the handle of a command buffer in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure it is in a recording state.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令缓冲区的句柄存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。确保它处于记录状态。
- en: Take the layout of a pipeline that uses a range of push constants. Store the
    handle of the layout in a variable of type `VkPipelineLayout` named `pipeline_layout`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个使用推送常量范围的管道布局。将布局的句柄存储在名为`pipeline_layout`的`VkPipelineLayout`类型变量中。
- en: Through a variable of type `VkShaderStageFlags` named `pipeline_stages`, define
    the shader stages that will access a given range of push constant data.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名为`pipeline_stages`的`VkShaderStageFlags`类型变量定义将访问给定推送常量数据范围的着色器阶段。
- en: In a variable of type `uint32_t` named `offset`, specify an offset (in bytes)
    from which the push constant memory should be updated. The `offset` must be a
    multiple of 4.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`offset`的`uint32_t`类型变量中指定一个偏移量（以字节为单位），从该偏移量更新推送常量内存。`offset`必须是4的倍数。
- en: Define the size (in bytes) of the part of the updated memory in a variable of
    type `uint32_t` named `size`. The `size` must be a multiple of 4.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`size`的`uint32_t`类型变量中定义更新内存部分的字节大小。`size`必须是4的倍数。
- en: Using a variable of type `void *` named `data`, provide a pointer to a memory
    from which the data should be copied to push the constant memory.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为`data`的`void *`类型变量，提供一个指向内存的指针，从该内存中复制数据以推送常量内存。
- en: 'Make the following call:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下调用：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the call, provide (in the same order) the variables described in bullets
    from 1 to 6.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于调用，提供（按相同顺序）从1到6的子弹描述的变量。
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Push constants allow us to quickly provide a small amount of data to shaders
    (refer to the *Using push constants in shaders* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders*). Drivers are required to offer at least 128 bytes of memory for push
    constant data. This is not much, but it is expected that push constants are much
    faster than updating data in a descriptor resource. This is the reason we should
    use them to provide data that changes very frequently, even with each drawing
    or dispatching of compute shaders.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量允许我们快速向着色器提供一小块数据（参考[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)中的*在着色器中使用推送常量*配方，*着色器*）。驱动程序需要提供至少
    128 字节用于推送常量数据的内存。这并不多，但预计推送常量比在描述符资源中更新数据要快得多。这就是我们应该使用它们来提供非常频繁变化的数据的原因，即使是在每次绘制或计算着色器的分发中。
- en: 'Data to push constants is copied from the provided memory address. Remember
    that we can update only data whose size is a multiple of 4\. The offset within
    a push constant memory (to which we copy the data) must also be a multiple of
    4\. As an example, to copy four floating-point values, we can use the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送常量数据的数据从提供的内存地址复制。记住，我们只能更新大小为4的倍数的数据。推送常量内存（我们复制数据的内存）中的偏移量也必须是4的倍数。例如，要复制四个浮点值，我们可以使用以下代码：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`ProvideDataToShadersThroughPushConstants()` is a function that implements
    this recipe in the following way:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProvideDataToShadersThroughPushConstants()` 是一个函数，它以下列方式实现此配方：'
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the recipe:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Using push constants in shaders*'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the recipe:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下配方：
- en: '*Creating a pipeline layout*'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*'
- en: Setting viewport states dynamically
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置视口状态
- en: The graphics pipeline defines parameters of lots of different states used during
    rendering. Creating separate pipeline objects every time we need to use slightly
    different values of some of these parameters would be cumbersome and very impractical.
    That's why dynamic states are available in Vulkan. We can define a viewport transformation
    to be one of them. In such a situation, we specify its parameters through a function
    call recorded in command buffers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线定义了在渲染过程中使用的许多不同状态参数。每次我们需要使用这些参数中的一些略微不同的值时，都创建单独的管线对象将会很繁琐且非常不实用。这就是为什么在
    Vulkan 中有动态状态。我们可以定义一个视口变换作为其中之一。在这种情况下，我们通过记录在命令缓冲区中的函数调用来指定其参数。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a command buffer that is in a recording state. Using its
    handle, initialize a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个处于记录状态的命令缓冲区的句柄。使用其句柄，初始化一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量。
- en: Specify the number of the first viewport whose parameters should be set. Store
    the number in a variable of type `uint32_t` named `first_viewport`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定应设置参数的第一个视口的编号。将数字存储在名为 `first_viewport` 的 `uint32_t` 类型的变量中。
- en: 'Create a variable of type `std::vector<VkViewport>` named `viewports`. For
    each viewport that was defined during the pipeline creation, add a new element
    to the `viewports` vector. Through it, specify the parameters of a corresponding
    viewport using the following values:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `viewports` 的 `std::vector<VkViewport>` 类型的变量。对于在管线创建过程中定义的每个视口，向 `viewports`
    向量中添加一个新元素。通过它，使用以下值指定相应视口的参数：
- en: The left side (in pixels) of the upper left corner for `x`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上左角（以像素为单位）的左侧对于 `x`
- en: The top side (in pixels) of the upper left corner for `y`
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上左角（以像素为单位）的顶部对于 `y`
- en: The width of the viewport for `width`
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视口的宽度对于 `width`
- en: The height of the viewport for `height`
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视口的宽度对于 `height`
- en: The minimal depth value used during a fragment's depth calculations for `minDepth`
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在片段深度计算过程中使用的最小深度值 `minDepth`
- en: The maximal value of a fragment's calculated depth for `maxDepth`
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `maxDepth`，片段计算的最大深度值
- en: Call `vkCmdSetViewport( command_buffer, first_viewport, static_cast<uint32_t>(viewports.size()),
    viewports.data() )` and provide the handle of the `command buffer`, the `first_viewport`
    variable, the number of elements in the viewports vector, and a pointer to the
    first element of the `viewports` vector.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdSetViewport(command_buffer, first_viewport, static_cast<uint32_t>(viewports.size()),
    viewports.data())` 并提供 `command buffer` 的句柄、`first_viewport` 变量、`viewports` 向量中的元素数量以及指向
    `viewports` 向量第一个元素的指针。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The viewport state can be specified to be one of the dynamic pipeline states.
    We do this during the pipeline creation (refer to the *Specifying pipeline dynamic
    states* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*). Here, dimensions of the viewport are specified with a
    function call like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 视口状态可以指定为动态管线状态之一。我们在创建管线时这样做（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线动态状态*配方）。在这里，视口的尺寸通过如下函数调用指定：
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Parameters defining the dimensions of each viewport used during rendering (refer
    to the *Specifying a pipeline viewport and scissor test state* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*)
    are specified through an array, where each element of the array corresponds to
    a given viewport (offset by the value specified in the `firstViewport` function
    parameter--`first_viewport` variable in the preceding code).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在渲染过程中使用的每个视口维度的参数（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*指定管线视口和剪裁测试状态*配方，来自*图形和计算管线*）通过一个数组指定，其中数组的每个元素对应一个给定的视口（通过`firstViewport`函数参数指定的值偏移，即前述代码中的`first_viewport`变量）。
- en: We just need to remember that the number of viewports used during rendering
    is always specified statically in a pipeline, no matter if the viewport state
    is specified as dynamic or not.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要记住，在渲染过程中使用的视口数量始终在管线中静态指定，无论视口状态是否指定为动态。
- en: See also
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下配方：
- en: '*Specifying a pipeline viewport and scissor test state*'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线视口和剪裁测试状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线动态状态*'
- en: Setting scissor states dynamically
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置剪裁状态
- en: The viewport defines a part of an attachment (image) to which the clip's space
    will be mapped. The scissor test allows us to additionally confine a drawing to
    the specified rectangle within the specified viewport dimensions. The scissor
    test is always enabled; we can only set up various values for its parameters.
    This can be done statically during the pipeline creation, or dynamically. The
    latter is done with a function call recorded in a command buffer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 视口定义了附件（图像）的一部分，其中剪辑空间将被映射。剪裁测试允许我们在指定的视口尺寸内进一步限制绘图到指定的矩形。剪裁测试始终启用；我们只能设置其参数的各种值。这可以在管线创建期间静态完成，也可以动态完成。后者是通过在命令缓冲区中记录的函数调用完成的。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Store the handle of a command buffer that is in a recording state in a variable
    of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处于记录状态的命令缓冲区的句柄存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。
- en: Specify the number of the first scissor rectangle in a variable of type `uint32_t`
    named `first_scissor`. Remember that the number of scissor rectangles corresponds
    to the number of viewports.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`first_scissor`的`uint32_t`类型变量中指定第一个剪裁矩形的编号。请记住，剪裁矩形的数量对应于视口的数量。
- en: 'Create a variable of type `std::vector<VkRect2D>` named `scissors`. For each
    scissor rectangle we want to specify, add an element to the `scissors` variable.
    Use the following values to specify its members:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`scissors`的`std::vector<VkRect2D>`类型变量。对于我们要指定的每个剪裁矩形，向`scissors`变量添加一个元素。使用以下值来指定其成员：
- en: The horizontal offset (in pixels) from the upper left corner of the viewport
    for the `x` member of the `offset`
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`offset`的`x`成员，从视口左上角开始的水平偏移（以像素为单位）
- en: The vertical offset (in pixels) from the upper left corner of the viewport for
    the `y` member of the `offset`
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`offset`的`y`成员，从视口左上角开始的垂直偏移（以像素为单位）
- en: The width (in pixels) of the scissor rectangle for the `width` member of the
    `extent`
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`extent`的`width`成员的剪裁矩形的宽度（以像素为单位）
- en: The height (in pixels) of the scissor rectangle for the `height` member of the
    `extent`
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`extent`的`height`成员的剪裁矩形的宽度（以像素为单位）
- en: Call `vkCmdSetScissor( command_buffer, first_scissor, static_cast<uint32_t>(scissors.size()),
    scissors.data() )` and provide the `command_buffer` and `first_scissor` variables,
    the number of elements in the `scissors` vector, and a pointer to the first element
    of the `scissors` vector.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdSetScissor(command_buffer, first_scissor, static_cast<uint32_t>(scissors.size()),
    scissors.data())`，并提供`command_buffer`和`first_scissor`变量、`scissors`向量的元素数量以及指向`scissors`向量第一个元素的指针。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The scissor test allows us to restrict rendering to a rectangle area specified
    anywhere inside the viewport. This test is always enabled and must be specified
    for all viewports defined during the pipeline creation. In other words, the number
    of specified scissor rectangles must be the same as the number of viewports. If
    we are providing parameters for a scissor test dynamically, we don't need to do
    it in a single function call. But before the drawing command is recorded, scissor
    rectangles for all the viewports must be defined.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 剪裁测试允许我们将渲染限制为视图端口内部指定的矩形区域。此测试始终启用，并且在创建管道期间必须为所有定义的视图端口指定。换句话说，指定的剪裁矩形数量必须与视图端口数量相同。如果我们动态地提供剪裁测试的参数，我们不需要在单个函数调用中完成。但在记录绘图命令之前，必须定义所有视图端口的剪裁矩形。
- en: 'To define a set of rectangles for the scissor test, we need to use the following
    code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义用于剪裁测试的一组矩形，我们需要使用以下代码：
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `vkCmdSetScissor()` function allows us to define scissor rectangles for
    only a subset of viewports. Parameters specified at index `i` in the `scissors`
    array (vector) correspond to a viewport at index `first_scissor + i`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`vkCmdSetScissor()`函数允许我们仅定义视图端口子集的剪裁矩形。在`scissors`数组（向量）中指定索引`i`的参数对应于索引`first_scissor
    + i`的视图端口。'
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中，查看以下配方：
- en: '*Specifying a pipeline viewport and scissor test state*'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道视口和剪裁测试状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道动态状态*'
- en: '*Setting viewport states dynamically*, in this chapter'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置视口状态*，在本章中'
- en: Setting line width states dynamically
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置线宽状态
- en: One of the parameters defined during the graphics pipeline creation is the width
    of drawn lines. We can define it statically. But if we intend to draw multiple
    lines with different widths, we should specify line width as one of the dynamic
    states. This way, we can use the same pipeline object and specify the width of
    the drawn lines with a function call.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图形管道期间定义的参数之一是绘制线的宽度。我们可以静态地定义它。但如果我们打算绘制具有不同宽度的多条线，我们应该将线宽指定为动态状态之一。这样，我们可以使用相同的管道对象，并通过函数调用指定绘制线的宽度。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a command buffer that is being recorded and use it to initialize
    a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取正在记录的命令缓冲区的句柄，并使用它来初始化一个名为`command_buffer`的`VkCommandBuffer`类型的变量。
- en: Create a variable of type `float` named `line_width` through which the width
    of drawn lines will be provided.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`line_width`的`float`类型的变量，通过该变量提供绘制线的宽度。
- en: Call `vkCmdSetLineWidth( command_buffer, line_width )` providing the `command_buffer`
    and `line_width` variables.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdSetLineWidth(command_buffer, line_width)`，提供`command_buffer`和`line_width`变量。
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Setting the width of lines dynamically for a given graphics pipeline is performed
    with the `vkCmdSetLineWidth()` function call. We just need to remember that to
    use various widths, we must enable the `wideLines` feature during the logical
    device creation. Otherwise, we can only specify a value of `1.0f`. In such a case,
    we shouldn''t create a pipeline with a dynamic line width state. But, if we have
    enabled the mentioned feature and we want to specify various values for line widths,
    we can do it like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vkCmdSetLineWidth()`函数调用动态设置给定图形管道的线宽。我们只需记住，为了使用不同的宽度，我们必须在创建逻辑设备时启用`wideLines`功能。否则，我们只能指定`1.0f`的值。在这种情况下，我们不应创建具有动态线宽状态的管道。但是，如果我们已启用所述功能并且想要指定不同的线宽值，我们可以这样做：
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下配方：
- en: '*Specifying a pipeline input assembly state*'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线输入装配状态*'
- en: '*Specifying a pipeline rasterization state*'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线动态状态*'
- en: Setting depth bias states dynamically
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置深度偏移状态
- en: When rasterization is enabled, each fragment that is generated during this process
    has its own coordinates (position on screen) and a depth value (distance from
    the camera). Depth value is used for the depth test, allowing for some opaque
    objects to cover other objects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用光栅化时，在此过程中生成的每个片段都有自己的坐标（屏幕上的位置）和深度值（距离摄像机的距离）。深度值用于深度测试，允许某些不透明物体覆盖其他物体。
- en: Enabling depth bias allows us to modify the fragment's calculated depth value.
    We can provide parameters for biasing a fragment's depth during the pipeline creation.
    But when depth bias is specified as one of the dynamic states, we do it through
    a function call.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 启用深度偏移允许我们修改片段的计算深度值。我们可以在创建管线时提供对片段深度进行偏移的参数。但是，当深度偏移被指定为动态状态之一时，我们通过函数调用来实现。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a command buffer that is being recorded. Use the handle to
    initialize a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取正在记录的命令缓冲区的句柄。使用句柄初始化一个名为`command_buffer`的`VkCommandBuffer`类型变量。
- en: Store the value for the constant offset added to the fragment's depth in a variable
    of type `float` named `constant_factor`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将添加到片段深度中的常量偏移值存储在名为`constant_factor`的`float`类型变量中。
- en: Create a variable of type `float` named `clamp`. Use it to provide the maximal
    (or minimal) depth bias that can be applied to an unmodified depth.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`clamp`的`float`类型变量。使用它来提供可以应用于未修改深度的最大（或最小）深度偏移。
- en: Prepare a variable of type `float` named `slope_factor`, in which store a value
    applied to the fragment's slope used during depth bias calculations.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`slope_factor`的`float`类型变量，在其中存储应用于深度偏移计算期间使用的片段斜率的值。
- en: Call the `vkCmdSetDepthBias( command_buffer, constant_factor, clamp, slope_factor
    )` function providing the prepared `command_buffer`, `constant_factor`, `clamp`
    and `slope_factor` variables, which are mentioned in the previous steps.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdSetDepthBias( command_buffer, constant_factor, clamp, slope_factor )`函数，提供已准备的`command_buffer`、`constant_factor`、`clamp`和`slope_factor`变量，这些变量在之前的步骤中已提及。
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Depth bias is used to offset a depth value of a given fragment (or rather, all
    fragments generated from a given polygon). Commonly, it is used when we want to
    draw objects that are very near other objects; for example, pictures or posters
    on walls. Due to the nature of depth calculations, such objects may be incorrectly
    drawn (partially hidden) when viewed from a distance. This issue is known as depth-fighting
    or Z-fighting.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 深度偏移用于偏移给定片段的深度值（或者更确切地说，从给定多边形生成的所有片段）。通常，当我们要绘制非常靠近其他物体的对象时使用它；例如，墙上的图片或海报。由于深度计算的性质，这些物体在从远处观看时可能会被错误地绘制（部分隐藏）。这个问题被称为深度冲突或Z冲突。
- en: 'Depth bias modifies the calculated depth value--the value used during the depth
    test and stored in a depth attachment--but does not affect the rendered image
    in any way (that is, it does not increase the visible distance between the poster
    and the wall it is attached to). Modifications are performed based on a constant
    factor and fragment''s slope. We also specify the maximal or minimal value of
    the depth bias (`clamp`) which can be applied. These parameters are provided like
    this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 深度偏移修改了计算出的深度值——深度测试期间使用的值和存储在深度附加中的值，但以任何方式都不会影响渲染的图像（即，它不会增加海报与它所附着的墙壁之间的可见距离）。修改基于一个常量因子和片段的斜率。我们还指定了可以应用的深度偏移的最大或最小值（`clamp`）。这些参数提供如下：
- en: '[PRE12]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Specifying pipeline rasterization states*'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Specifying pipeline depth and stencil states*'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线深度和模板状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线动态状态*'
- en: Setting blend constants states dynamically
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置混合常数状态
- en: Blending is a process that mixes a color stored in a given attachment with a
    color of a processed fragment. It is often used to simulate transparent objects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 混合是将存储在给定附件中的颜色与处理片段的颜色混合的过程。它通常用于模拟透明物体。
- en: There are multiple ways in which a fragment's color and a color stored in an
    attachment can be combined--for the blending, we specify factors (weights) and
    operations, which generate the final color. It is also possible that an additional,
    constant color is used by these calculations. During the pipeline creation, we
    can specify that components of the constant color are provided dynamically. In
    such a case, we set them with a function recorded in a command buffer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以将片段的颜色和存储在附件中的颜色组合在一起——对于混合，我们指定因子（权重）和操作，这些操作生成最终颜色。在这些计算中，也可能使用一个额外的、恒定的颜色。在管线创建过程中，我们可以指定动态提供恒定颜色的组件。在这种情况下，我们使用记录在命令缓冲区中的函数来设置它们。
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a command buffer and use it to initialize a variable of type
    `VkCommandBuffer` named `command_buffer`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区的句柄，并使用它来初始化一个名为`command_buffer`的`VkCommandBuffer`类型的变量。
- en: Create a variable of type `std::array<float, 4>` named `blend_constants`. In
    the array's four elements, store the red, green, blue, and alpha components of
    the constant color used during the blending calculations.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`blend_constants`的`std::array<float, 4>`类型的变量。在数组的四个元素中，存储混合计算过程中使用的恒定颜色的红色、绿色、蓝色和alpha分量。
- en: Call `vkCmdSetBlendConstants( command_buffer, blend_constants.data() )` and
    provide the `command_buffer` variable and a pointer to the first element of the
    `blend_constants` array.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdSetBlendConstants(command_buffer, blend_constants.data())`并提供`command_buffer`变量以及`blend_constants`数组第一个元素的指针。
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Blending is enabled (statically) during graphics pipeline creation. When we
    enable it, we must provide multiple parameters that define the behavior of this
    process (refer to the *Specifying pipeline blend state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). Among these parameters are blend constants--four
    components of a constant color used during blending calculations. Normally, they
    are defined statically during the pipeline creation. But, if we enable blending
    and intend to use multiple different values for the blend constants, we should
    specify that we will provide them dynamically (refer to the *Specifying pipeline
    dynamic states* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). This will allow us to avoid creating multiple
    similar graphics pipeline objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图形管线时，混合被启用（静态）。当我们启用它时，我们必须提供多个参数来定义此过程的行为（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线混合状态*食谱）。这些参数中包括混合常数——在混合计算过程中使用的恒定颜色的四个分量。通常，它们在管线创建过程中静态定义。但是，如果我们启用混合并打算为混合常数使用多个不同的值，我们应该指定我们将动态提供它们（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线动态状态*食谱）。这将使我们能够避免创建多个类似的图形管线对象。
- en: 'Values for the blend constants are provided with a single function call, like
    this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 混合常数的值通过单个函数调用提供，如下所示：
- en: '[PRE13]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Specifying pipeline blend states*'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线混合状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线动态状态*'
- en: Drawing a geometry
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制几何图形
- en: Drawing is the operation we usually want to perform using graphics APIs such
    as OpenGL or Vulkan. It sends the geometry (vertices) provided by the application
    through a vertex buffer down the graphics pipeline, where it is processed step
    by step by programmable shaders and fixed-function stages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是我们通常想要使用图形API（如OpenGL或Vulkan）执行的操作。它将应用程序提供的几何形状（顶点）通过顶点缓冲区发送到图形管线，在那里它通过可编程着色器和固定功能阶段逐步处理。
- en: Drawing requires us to provide the number of vertices we would like to process
    (display). It also allows us to display multiple instances of the same geometry
    at once.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图需要我们提供我们想要处理的顶点数量（显示）。它还允许我们一次性显示同一几何形状的多个实例。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Store the handle of a command buffer in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is currently being recorded
    and that the parameters of all the states used during rendering are already set
    in it (bound to it). Also, make sure that the render pass is started in the command
    buffer.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令缓冲区的句柄存储在类型为`VkCommandBuffer`的变量`command_buffer`中。确保命令缓冲区目前正在被记录，并且渲染期间使用的所有状态的参数已经设置在其中（绑定到它）。还要确保渲染传递已在命令缓冲区中启动。
- en: Use a variable of type `uint32_t` named `vertex_count` to hold the number of
    vertices we would like to draw.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个类型为`uint32_t`的变量，命名为`vertex_count`，来保存我们想要绘制的顶点数量。
- en: Create a variable of type `uint32_t` named `instance_count` and initialize it
    with the number of geometry instances that should be displayed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`uint32_t`的变量，命名为`instance_count`，并将其初始化为应显示的几何实例数量。
- en: Prepare a variable of type `uint32_t` named `first_vertex`. Store the number
    of the first vertex from which the drawing should be performed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个类型为`uint32_t`的变量，命名为`first_vertex`。存储从该顶点开始绘图的第一个顶点的编号。
- en: Create a variable of type `uint32_t` named `first_instance` in which the number
    of the first instance (instance offset) should be stored.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在变量`first_instance`中创建一个类型为`uint32_t`的变量，用于存储第一个实例（实例偏移量）的编号。
- en: 'Call the following function: `vkCmdDraw( command_buffer, vertex_count, instance_count,
    first_vertex, first_instance )`. For the call, provide all of the preceding variables
    in the same order.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用以下函数：`vkCmdDraw(command_buffer, vertex_count, instance_count, first_vertex,
    first_instance)`。对于调用，以相同的顺序提供所有前面的变量。
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Drawing is performed with a call of the `vkCmdDraw()` function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是通过调用`vkCmdDraw()`函数来执行的：
- en: '[PRE14]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It allows us to draw any number of vertices, where vertices (and their attributes)
    are stored one after another in a vertex buffer (no index buffer is used). During
    the call we need to provide an offset--the number of the first vertex from which
    drawing should be started. This can be used when we have multiple models stored
    in one vertex buffer (for example, compounds of a model) and we want to draw only
    one of them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们绘制任意数量的顶点，其中顶点（及其属性）依次存储在顶点缓冲区中（不使用索引缓冲区）。在调用过程中，我们需要提供一个偏移量--从哪个顶点开始绘制。这可以在我们有一个顶点缓冲区中存储多个模型（例如，模型的化合物）并且我们只想绘制其中一个时使用。
- en: The preceding function allows us to draw a single mesh (model), and also multiple
    instances of the same mesh. This is particularly useful when we have specified
    that some of the attributes change per instance, not per vertex (refer to the
    *Specifying pipeline vertex binding description, attribute description, and input
    state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*). This way, each drawn instance of the same model may be
    a little bit different.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使我们能够绘制单个网格（模型），以及同一网格的多个实例。这在指定某些属性按实例而不是按顶点变化时特别有用（请参阅[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线顶点绑定描述、属性描述和输入状态*配方）。这样，同一模型的每个绘制实例可能略有不同。
- en: '![](img/image_09_002.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_002.png)'
- en: Almost everything we do in Vulkan is used during drawing. So before we record
    a drawing command in a command buffer, we must be sure all the required data and
    parameters are properly set. Remember that each time we record a command buffer,
    it doesn't have any state. So before we can draw anything, we must set up the
    state accordingly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，我们做的几乎所有事情都是在绘图时使用的。因此，在我们将绘图命令记录到命令缓冲区之前，我们必须确保所有所需的数据和参数都已正确设置。记住，每次我们记录命令缓冲区时，它没有任何状态。因此，在我们能够绘制任何内容之前，我们必须相应地设置状态。
- en: There is no such thing as default state in Vulkan.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，没有默认状态这一说法。
- en: An example can be descriptor sets or dynamic pipeline states. Each time we start
    recording a command buffer, before we can draw anything, all the required descriptor
    sets (those used by shaders) must be bound to the command buffer. Similarly, every
    pipeline state that is specified as dynamic must have its parameters provided
    through corresponding functions. Another thing to remember is the render pass,
    which must be started in a command buffer for the drawing to be properly executed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以是描述符集或动态管线状态。每次我们开始记录命令缓冲区时，在我们能够绘制任何内容之前，所有必需的描述符集（那些由着色器使用的）都必须绑定到命令缓冲区。同样，所有指定为动态的管线状态都必须通过相应的函数提供其参数。另一件需要记住的事情是渲染通道，它必须在命令缓冲区中启动，以便正确执行绘制。
- en: Drawing can be performed only inside the render pass.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制只能在渲染通道内执行。
- en: See also
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看以下食谱：
- en: '*Creating a buffer*'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个缓冲区*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，查看以下食谱：
- en: '*Binding descriptor sets*'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中，查看以下食谱：
- en: '*Creating a render pass*'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: '*Beginning a render pass*'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a graphics pipeline*'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Binding a pipeline object*'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管线对象*'
- en: 'The following recipes in this chapter:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Binding vertex buffers*'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Setting viewport states dynamically*'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置视口状态*'
- en: '*Setting scissor states dynamically*'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置裁剪状态*'
- en: Drawing an indexed geometry
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制索引几何图形
- en: Quite often it is more convenient to reuse vertices stored in a vertex buffer.
    Like the corners of a cube which belong to multiple sides, vertices in arbitrary
    geometry may belong to many parts of the whole model.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是，更方便地重用存储在顶点缓冲区中的顶点。就像立方体的角属于多个面一样，任意几何形状的顶点可能属于整个模型的多个部分。
- en: Drawing the object one vertex after another would require us to store the same
    vertex (along with all its attributes) multiple times. A better solution is to
    indicate which vertices should be used for drawing, no matter how they are ordered
    in the vertex buffer. For this purpose, indexed drawing was introduced in the
    Vulkan API. To draw geometry using indices stored in an index buffer, we need
    to call the `vkCmdDrawIndexed()` function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个绘制对象顶点将需要我们多次存储相同的顶点（及其所有属性）。一个更好的解决方案是指出哪些顶点应该用于绘制，无论它们在顶点缓冲区中的顺序如何。为此，Vulkan
    API 中引入了索引绘制。要使用存储在索引缓冲区中的索引绘制几何图形，我们需要调用 `vkCmdDrawIndexed()` 函数。
- en: How to do it...
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a variable of type `VkCommandBuffer` named `command_buffer`, in which
    store the handle of a command buffer. Make sure the command buffer is in the recording
    state.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量，在其中存储命令缓冲区的句柄。确保命令缓冲区处于记录状态。
- en: Initialize a variable of type `uint32_t` named `index_count` with the number
    of indices (and vertices) that should be drawn.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用要绘制的索引（和顶点）的数量初始化一个名为 `index_count` 的 `uint32_t` 类型的变量。
- en: Use the number of instances (of the same geometry) to be drawn to initialize
    a variable of type `uint32_t` named `instance_count`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用要绘制的（相同几何形状的）实例数量初始化一个名为 `instance_count` 的 `uint32_t` 类型的变量。
- en: Store the offset (in the number of indices) from the beginning of an index buffer
    in a variable of type `uint32_t` named `first_index`. From this index, drawing
    will be started.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将索引缓冲区开头的偏移量（以索引数量计）存储在一个名为 `first_index` 的 `uint32_t` 类型的变量中。从这个索引开始，将开始绘制。
- en: Prepare a variable of type `uint32_t` named `vertex_offset`, in which the vertex
    offset (the value added to each index) should be stored.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `vertex_offset` 的 `uint32_t` 类型的变量，在其中存储顶点偏移量（添加到每个索引的值）。
- en: Create a variable of type `uint32_t` named `first_instance` that should hold
    the number of the first geometry instance to be drawn.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`first_instance`的`uint32_t`类型的变量，该变量应包含要绘制的第一个几何实例的编号。
- en: 'Make the following call: `vkCmdDrawIndexed( command_buffer, index_count, instance_count,
    first_index, vertex_offset, first_instance )`. For the call, provide all of the
    preceding variables, in the same order.'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用以下函数：`vkCmdDrawIndexed( command_buffer, index_count, instance_count, first_index,
    vertex_offset, first_instance )`。对于调用，提供所有前面的变量，顺序相同。
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Indexed drawing is the way to reduce the memory consumption. It allows us to
    remove duplicate vertices from vertex buffers, so we can allocate smaller vertex
    buffers. An additional index buffer is required, but usually vertex data requires
    much more memory space. This is especially the case in situations when each vertex
    has more attributes than just one position, such as normal, tangent, and bitangent
    vectors and two texture coordinates, which are used very often.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 索引绘制是减少内存消耗的方法。它允许我们从顶点缓冲区中删除重复的顶点，因此我们可以分配更小的顶点缓冲区。需要一个额外的索引缓冲区，但通常顶点数据需要更多的内存空间。这在每个顶点除了位置属性外还有更多属性（如法线、切线、双切线向量和两个纹理坐标）的情况下尤其如此，这些属性被非常频繁地使用。
- en: Indexed drawing also allows graphics hardware to reuse data from the already
    processed vertices through a form of vertex caching. With normal (non-indexed)
    drawing, hardware needs to process each vertex. When indices are used, hardware
    has additional information about processed vertices and knows if a given vertex
    was recently processed or not. If the same vertex was recently used (the last
    several dozens of processed vertices), in many situations the hardware may reuse
    the results of this vertex's previous processing.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 索引绘制还允许图形硬件通过顶点缓存的形式重用已处理顶点的数据。在常规（非索引）绘制中，硬件需要处理每个顶点。当使用索引时，硬件有关于处理顶点的额外信息，并知道给定的顶点是否最近被处理过。如果相同的顶点最近被使用过（最后几十个处理的顶点），在许多情况下，硬件可能会重用该顶点之前处理的结果。
- en: 'To draw a geometry using vertex indices, we need to bind an index buffer before
    we record an indexed drawing command (refer to the *Binding an index buffer* recipe).
    We must also start a render pass, as indexed drawing (similarly to normal drawing)
    can be recorded only inside render passes. We also need to bind a graphics pipeline
    and all other required states (depending on the resources used by the graphics
    pipeline), and we are then good to call the following function:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用顶点索引绘制几何体，我们需要在记录索引绘制命令之前绑定一个索引缓冲区（参考*绑定索引缓冲区*配方）。我们还需要启动一个渲染通道，因为索引绘制（类似于常规绘制）只能在渲染通道内记录。我们还需要绑定图形管线和所有其他所需状态（取决于图形管线使用的资源），然后我们可以调用以下函数：
- en: '[PRE15]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Indexed drawing, similarly to normal drawing, can only be performed inside a
    render pass.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 索引绘制，类似于常规绘制，只能在渲染通道内执行。
- en: See also
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看配方：
- en: '*Creating a buffer*'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，查看配方：
- en: '*Binding descriptor sets*'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下配方：
- en: '*Creating a render pass*'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: '*Beginning a render pass*'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，查看以下配方：
- en: '*Creating a graphics pipeline*'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Binding a pipeline object*'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管线对象*'
- en: 'The following recipes in this chapter:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Binding vertex buffers*'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Binding an index buffer*'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定索引缓冲区*'
- en: '*Setting viewport states dynamically*'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置视口状态*'
- en: '*Setting scissor states dynamically*'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置剪裁状态*'
- en: Dispatching compute work
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分派计算工作
- en: Apart from drawing, Vulkan can be used to perform general computations. For
    this purpose, we need to write compute shaders and execute them--this is called
    dispatching.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绘图之外，Vulkan还可以用于执行通用计算。为此，我们需要编写计算着色器并执行它们——这被称为分发。
- en: When we want to issue computational work to be performed, we need to specify
    how many separate compute shader instances should be executed and how they are
    divided into workgroups.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要发出要执行的计算工作负载时，我们需要指定应该执行多少个单独的计算着色器实例以及它们如何被划分为工作组。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state
    and no render pass is currently started.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区的句柄并将其存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。确保命令缓冲区处于录制状态且当前没有启动渲染通道。
- en: Store the number of local workgroups along the *x* dimension in a variable of
    type `uint32_t` named `x_size`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将沿`x`维度的本地工作组数量存储在名为`x_size`的`uint32_t`类型变量中。
- en: The number of local workgroups in the *y* dimensions should be stored in a variable
    of type `uint32_t` named `y_size`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应将`y`维度的本地工作组数量存储在名为`y_size`的`uint32_t`类型变量中。
- en: Use the number of local workgroups along the *z* dimension to initialize a variable
    of type `uint32_t` named `z_size`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用沿`z`维度的本地工作组数量来初始化一个名为`z_size`的`uint32_t`类型变量。
- en: Record the `vkCmdDispatch( command_buffer, x_size, y_size, z_size )` function
    using the preceding variables as its arguments.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面定义的变量作为参数记录`vkCmdDispatch(command_buffer, x_size, y_size, z_size)`函数。
- en: How it works...
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we dispatch compute work, we use compute shaders from the bound compute
    pipeline to perform the task they are programmed to do. Compute shaders use resources
    provided through descriptor sets. Results of their computations can also be stored
    only in resources provided through descriptor sets.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分发计算工作负载时，我们使用已绑定的计算管道中的计算着色器来执行它们被编程要完成的任务。计算着色器使用通过描述符集提供的资源。它们的计算结果也可以仅存储在通过描述符集提供的资源中。
- en: Compute shaders don't have a specific goal or use case scenario which they must
    fulfil. They can be used to perform any computations that operate on data read
    from descriptor resources. We can use them to perform image post-processing, such
    as color correction or blur. We can perform physical calculations and store transformation
    matrices in buffers or calculate new positions of a morphing geometry. The possibilities
    are limited only by the desired performance and hardware capabilities.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器没有特定的目标或用例场景，它们必须满足。它们可以用于执行对从描述符资源读取的数据进行操作的计算。我们可以使用它们来执行图像后处理，例如色彩校正或模糊。我们可以执行物理计算并在缓冲区中存储变换矩阵或计算变形几何的新位置。可能性的限制仅限于所需的性能和硬件能力。
- en: 'Compute shaders are dispatched in groups. The number of local invocations in
    `x`, `y`, and `z` dimensions are specified inside the shader source code (refer
    to the *Writing compute shaders* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders*). The collection of these invocations is called a workgroup. During
    dispatching the compute shaders, we specify how many such workgroups should be
    executed in each *x*, *y*, and *z* dimension. This is done through the parameters
    of the `vkCmdDispatch()` function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器以组的形式分发。在着色器源代码中指定了`x`、`y`和`z`维度中的局部调用次数（请参阅[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)中的*编写计算着色器*配方，*着色器*）。这些调用的集合称为工作组。在分发计算着色器时，我们指定每个`x`、`y`和`z`维度中应执行多少个工作组。这是通过`vkCmdDispatch()`函数的参数来完成的：
- en: '[PRE16]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We just need to remember that the number of workgroups in a given dimension
    cannot be larger than the value in the corresponding index of the `maxComputeWorkGroupCount[3]`
    physical device's limit. Currently, the hardware must allow to dispatch at least
    65,535 workgroups in a given dimension.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要记住，给定维度中的工作组数量不能大于物理设备`maxComputeWorkGroupCount[3]`限制中相应索引的值。目前，硬件必须允许在给定维度中至少分发65,535个工作组。
- en: Dispatching compute workgroups cannot be done inside render passes. In Vulkan,
    render passes can be used only for drawing. If we want to bind compute pipelines
    and perform some computations inside compute shaders, we must end a render pass.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染通道内不能执行计算工作组的分发。在Vulkan中，渲染通道只能用于绘图。如果我们想在计算着色器内绑定计算管道并执行一些计算，我们必须结束渲染通道。
- en: Compute shaders cannot be dispatched inside render passes.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器不能在渲染通道内分发。
- en: See also
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看菜谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，查看菜谱：
- en: '*Binding descriptor sets*'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the recipe:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看菜谱：
- en: '*Ending a render pass*'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束渲染通道*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*，查看以下菜谱：
- en: '*Writing compute shaders*'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写计算着色器*'
- en: '*Creating a compute pipeline*'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管道*'
- en: '*Binding a pipeline object*'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管道对象*'
- en: Executing a secondary command buffer inside a primary command buffer
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主命令缓冲区内部执行次级命令缓冲区
- en: In Vulkan we can record two types of command buffers--primary and secondary.
    Primary command buffers can be submitted to queues directly. Secondary command
    buffers can be executed only from within primary command buffers.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，我们可以记录两种类型的命令缓冲区——主命令缓冲区和次级命令缓冲区。主命令缓冲区可以直接提交到队列中。次级命令缓冲区只能在主命令缓冲区内部执行。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take a command buffer's handle. Store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区的句柄。将其存储在名为`command_buffer`的`VkCommandBuffer`类型的变量中。确保命令缓冲区处于记录状态。
- en: Prepare a variable of type `std::vector<VkCommandBuffer>` named `secondary_command_buffers`
    containing secondary command buffers that should be executed from within the `command_buffer`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`secondary_command_buffers`的`std::vector<VkCommandBuffer>`类型的变量，包含应在`command_buffer`内部执行的次级命令缓冲区。
- en: 'Record the following command: `vkCmdExecuteCommands( command_buffer, static_cast<uint32_t>(secondary_command_buffers.size()),
    secondary_command_buffers.data() )`. Provide the handle of the primary command
    buffer, the number of elements in the `secondary_command_buffers` vector, and
    a pointer to its first element.'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录以下命令：`vkCmdExecuteCommands(command_buffer, static_cast<uint32_t>(secondary_command_buffers.size()),
    secondary_command_buffers.data())`。提供主命令缓冲区的句柄，`secondary_command_buffers`向量的元素数量，以及指向其第一个元素的指针。
- en: How it works...
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Secondary command buffers are recorded in a similar way to primary command
    buffers. In most cases, primary command buffers should be enough to perform rendering
    or computing work. But there may be situations in which we need to divide work
    into two command buffer types. When we have recorded secondary command buffers
    and we want the graphics hardware to process them, we can execute them from within
    a primary command buffer like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 次级命令缓冲区的记录方式与主命令缓冲区类似。在大多数情况下，主命令缓冲区足以执行渲染或计算工作。但可能存在需要将工作分为两种命令缓冲区类型的情况。当我们记录了次级命令缓冲区，并希望图形硬件处理它们时，我们可以像这样在主命令缓冲区内部执行它们：
- en: '[PRE17]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看菜谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: Recording a command buffer that draws a geometry with dynamic viewport and scissor
    states
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录一个带有动态视口和裁剪状态的几何图形绘制命令缓冲区
- en: Now we have all the knowledge required to draw images using the Vulkan API.
    In this sample recipe, we will aggregate some of the previous recipes and see
    how to use them to record a command buffer that displays a geometry.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了使用Vulkan API绘制图像所需的所有知识。在这个示例菜谱中，我们将汇总一些之前的菜谱，并看看如何使用它们来记录一个显示几何图形的命令缓冲区。
- en: Getting ready
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To draw a geometry, we will use a custom structure type that has the following
    definition:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制几何图形，我们将使用一个自定义结构类型，其定义如下：
- en: '[PRE18]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Data` member contains values for all the attributes of a given vertex,
    one vertex after another. For example, there are three components of position
    attribute, three components of a normal vector and two texture coordinates of
    a first vertex. After that, there is data for the position, normal, and **TexCoords**
    of a second vertex, and so on.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data`成员包含给定顶点的所有属性值，一个顶点接一个顶点。例如，位置属性有三个分量，法向量有三个分量，第一个顶点有两个纹理坐标。之后，是第二个顶点的位置、法向量和**TexCoords**的数据，依此类推。'
- en: The `VertexOffset` member is used to store vertex offsets of separate parts
    of a geometry. The `VertexCount` vector contains a number of vertices in each
    such part.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexOffset` 成员用于存储几何形状各个部分的顶点偏移。`VertexCount` 向量包含每个此类部分中的顶点数量。'
- en: Before we can draw a model whose data is stored in a variable of the preceding
    type, we need to copy the contents of a `Data` member to a buffer that will be
    bound to a command buffer as a vertex buffer.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以绘制存储在前述类型变量中的模型之前，我们需要将 `Data` 成员的内容复制到一个将绑定到命令缓冲区的缓冲区中作为顶点缓冲区。
- en: How to do it...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a primary command buffer and store it in a variable of type
    `VkCommandBuffer` named `command_buffer`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取主命令缓冲区的句柄并将其存储在一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量中。
- en: Start recording the `command_buffer` (refer to the *Beginning a command buffer
    recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始记录 `command_buffer`（参考第 3 章 *开始命令缓冲区记录操作* 的配方，*命令缓冲区和同步*）。
- en: Take the handle of an acquired swapchain image and use it to initialize a variable
    of type `VkImage` named `swapchain_image` (refer to the *Getting handles of swapchain
    images* and *Acquiring a swapchain image* recipes from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*).
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取已获取的交换链图像的句柄，并使用它初始化一个名为 `swapchain_image` 的 `VkImage` 类型的变量（参考第 2 章 *获取交换链图像句柄*
    和 *获取交换链图像* 的配方，*图像呈现*）。
- en: Store the index of a queue family that is used for swapchain image presentation
    in a variable of type `uint32_t` named `present_queue_family_index`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用于交换链图像呈现的队列家族的索引存储在一个名为 `present_queue_family_index` 的 `uint32_t` 类型的变量中。
- en: Store the index of a queue family used for performing graphics operations in
    a variable of type `uint32_t` named `graphics_queue_family_index`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用于执行图形操作的队列家族的索引存储在一个名为 `graphics_queue_family_index` 的 `uint32_t` 类型的变量中。
- en: 'If values stored in the `present_queue_family_index` and `graphics_queue_family_index`
    variables are different, set up an image memory barrier in the `command_buffer`
    (refer to the *Setting an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*). Use a `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` value for the
    `generating_stages` parameter and a `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`
    value for the `consuming_stages` parameters. For the barrier, provide a single
    variable of type `ImageTransition` and use the following values to initialize
    its members:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存储在 `present_queue_family_index` 和 `graphics_queue_family_index` 变量中的值不同，在
    `command_buffer` 中设置一个图像内存屏障（参考第 4 章 *设置图像内存屏障* 的配方，*资源和内存*）。为 `generating_stages`
    参数使用 `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` 值，为 `consuming_stages` 参数使用 `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`
    值。对于屏障，提供一个类型为 `ImageTransition` 的单个变量，并使用以下值初始化其成员：
- en: The `swapchain_image` variable for `Image`
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image` 的 `swapchain_image` 变量'
- en: The `VK_ACCESS_MEMORY_READ_BIT` value for `CurrentAccess`
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentAccess` 的 `VK_ACCESS_MEMORY_READ_BIT` 值'
- en: The `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `NewAccess`
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewAccess` 的 `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` 值'
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `CurrentLayout`
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentLayout` 的 `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` 值'
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `NewLayout`
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewLayout` 的 `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` 值'
- en: The `present_queue_family_index` variable for `CurrentQueueFamily`
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentQueueFamily` 的 `present_queue_family_index` 变量'
- en: The `graphics_queue_family_index` variable for `NewQueueFamily`
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewQueueFamily` 的 `graphics_queue_family_index` 变量'
- en: The `VK_IMAGE_ASPECT_COLOR_BIT` value for `Aspect`
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aspect` 的 `VK_IMAGE_ASPECT_COLOR_BIT` 值'
- en: Take the handle of a `render pass` and store it in a variable of type `VkRenderPass`
    named `render_pass`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `render pass` 的句柄并将其存储在一个名为 `render_pass` 的 `VkRenderPass` 类型的变量中。
- en: Store the handle of a framebuffer compatible with the `render_pass` in a variable
    of type `VkFramebuffer` named `framebuffer`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与 `render_pass` 兼容的 `framebuffer` 的句柄存储在一个名为 `framebuffer` 的 `VkFramebuffer`
    类型的变量中。
- en: Store the size of the `framebuffer` in a variable of type `VkExtent2D` named
    `framebuffer_size`.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `framebuffer` 的大小存储在一个名为 `framebuffer_size` 的 `VkExtent2D` 类型的变量中。
- en: Create a variable of type `std::vector<VkClearValue>` named `clear_values`.
    For each attachment used in the `render_pass` (and the `framebuffer`), add an
    element to the `clear_values` variable with values, to which corresponding attachments
    should be cleared.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `clear_values` 的 `std::vector<VkClearValue>` 类型的变量。对于在 `render_pass`（和
    `framebuffer`）中使用的每个附件，向 `clear_values` 变量添加一个元素，并指定相应的附件应该清除的值。
- en: Record a `render pass` beginning operation in the `command_buffer`. Use the
    `render_pass`, `framebuffer`, `framebuffer_size`, and `clear_values` variables
    and a `VK_SUBPASS_CONTENTS_INLINE` value (refer to *Beginning a render pass* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*).
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中记录一个`render pass`开始操作。使用`render_pass`、`framebuffer`、`framebuffer_size`和`clear_values`变量以及一个`VK_SUBPASS_CONTENTS_INLINE`值（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的*开始一个渲染通道*配方）。
- en: Take the handle of a graphics pipeline and use it to initialize a variable of
    type `VkPipeline` named `graphics_pipeline`. Make sure the pipeline was created
    with dynamic viewport and scissor states.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取图形管道的句柄并使用它来初始化一个名为`graphics_pipeline`的`VkPipeline`类型变量。确保管道是用动态视口和剪刀状态创建的。
- en: Bind the pipeline to the `command_buffer`. Provide a `VK_PIPELINE_BIND_POINT_GRAPHICS`
    value and the `graphics_pipeline` variable (refer to the *Binding a pipeline object*
    recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*).
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将管道绑定到`command_buffer`。提供一个`VK_PIPELINE_BIND_POINT_GRAPHICS`值和`graphics_pipeline`变量（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中的*绑定管道对象*配方）。
- en: 'Create a variable of type `VkViewport` named `viewport`. Use the following
    values to initialize its members:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`viewport`的`VkViewport`类型变量。使用以下值初始化其成员：
- en: The `0.0f` value for `x`
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`的`0.0f`值'
- en: The `0.0f` value for `y`
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`的`0.0f`值'
- en: The `width` member of the `framebuffer_size` variable for `width`
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`framebuffer_size`变量的`width`成员用于`width`'
- en: The `height` member of the `framebuffer_size` variable for `height`
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`framebuffer_size`变量的`height`成员用于`height`'
- en: The `0.0f` value for `minDepth`
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minDepth`的`0.0f`值'
- en: The `1.0f` value for `maxDepth`
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxDepth`的`1.0f`值'
- en: Set the viewport state dynamically in the `command_buffer`. Use a `0` value
    for the `first_viewport` parameter and a vector of type `std::vector<VkViewport>`
    with a single element containing the `viewport` variable for the `viewports` parameter
    (refer to the *Setting viewport state dynamically* recipe).
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中动态设置视口状态。将`first_viewport`参数设置为`0`值，并将一个包含`viewport`变量的`std::vector<VkViewport>`类型的向量作为`viewports`参数（参考*动态设置视口状态*配方）。
- en: 'Create a variable of type `VkRect2D` named `scissor`. Use the following values
    to initialize its members:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`scissor`的`VkRect2D`类型变量。使用以下值初始化其成员：
- en: The `0` value for the `x` member of the `offset`
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`成员的`x`值为`0`'
- en: The `0` value for the `y` member of the `offset`
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`成员的`y`值为`0`'
- en: The `framebuffer_size.width` member variable for the `width` member of the `extent`
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extent`的`width`成员变量用于`width`'
- en: The `framebuffer_size.height` member variable for the `height` member of the
    `extent`
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extent`的`height`成员变量用于`height`'
- en: Set the scissor state dynamically in the `command_buffer`. Use a `0` value for
    the `first_scissor` parameter and a vector of type `std::vector<VkRect2D>` with
    a single element containing the `scissor` variable as the `scissors` parameter
    (refer to the *Setting scissor states dynamically* recipe in this chapter).
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中动态设置剪刀状态。将`first_scissor`参数设置为`0`值，并将一个包含`scissor`变量的`std::vector<VkRect2D>`类型的向量作为`scissors`参数（参考本章中的*动态设置剪刀状态*配方）。
- en: 'Create a variable of type `std::vector<VertexBufferParameters>` named `vertex_buffers_parameters`.
    For each buffer that should be bound to the `command_buffer` as a vertex buffer,
    add an element to the `vertex_buffers_parameters` vector. Use the following values
    to initialize the members of the new element:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`vertex_buffers_parameters`的`std::vector<VertexBufferParameters>`类型变量。对于每个应绑定到`command_buffer`作为顶点缓冲区的缓冲区，向`vertex_buffers_parameters`向量中添加一个元素。使用以下值初始化新元素的成员：
- en: The handle of a buffer that should be used as the vertex buffer for `Buffer`
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于`Buffer`的顶点缓冲区的缓冲区句柄
- en: The offset in bytes from the beginning of the buffer's memory (the memory part
    that should be bound for the vertex buffer) for `memoryoffset`
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区内存开始（应绑定到顶点缓冲区的内存部分）的字节偏移量用于`memoryoffset`
- en: Store the value of the first binding, to which the first vertex buffer should
    be bound, in a variable of type `uint32_t` named `first_vertex_buffer_binding`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个绑定（第一个顶点缓冲区应绑定的绑定）的值存储在一个名为`first_vertex_buffer_binding`的`uint32_t`类型变量中。
- en: Bind vertex buffers to the `command_buffer` using the `first_vertex_buffer_binding`
    and `vertex_buffers_parameters` variables (refer to the *Binding vertex buffers*
    recipe).
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`first_vertex_buffer_binding`和`vertex_buffers_parameters`变量将顶点缓冲区绑定到`command_buffer`（参考*绑定顶点缓冲区*配方）。
- en: 'Perform the following operations if any descriptor resources should be used
    during drawing:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在绘图过程中需要使用任何描述符资源，请执行以下操作：
- en: Take the handle of a pipeline's layout and store it in a variable of type `VkPipelineLayout`
    named `pipeline_layout` (refer to *Creating a pipeline layout* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个管道布局的句柄并将其存储在名为`pipeline_layout`的类型为`VkPipelineLayout`的变量中（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中的*创建管道布局*配方）。
- en: Add each descriptor set to be used during drawing to a vector variable of type
    `std::vector<VkDescriptorSet>` named `descriptor_sets`.
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要用于绘图的每个描述符集添加到名为`descriptor_sets`的类型为`std::vector<VkDescriptorSet>`的向量变量中。
- en: Store an index, to which the first descriptor set should be bound, in a variable
    of type `uint32_t` named `index_for_first_descriptor_set`.
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`index_for_first_descriptor_set`的类型为`uint32_t`的变量中存储第一个描述符集应绑定的索引。
- en: Bind descriptor sets to the `command_buffer` using a `VK_PIPELINE_BIND_POINT_GRAPHICS`
    value and the `pipeline_layout`, `index_for_first_descriptor_set` and `descriptor_sets`
    variables.
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`VK_PIPELINE_BIND_POINT_GRAPHICS`值和`pipeline_layout`、`index_for_first_descriptor_set`和`descriptor_sets`变量将描述符集绑定到`command_buffer`。
- en: Draw a geometry in the `command_buffer` specifying the desired values for the
    `vertex_count`, `instance_count`, `first_vertex`, and `first_instance` parameters
    (refer to the *Drawing a geometry* recipe).
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中绘制几何形状，指定`vertex_count`、`instance_count`、`first_vertex`和`first_instance`参数的期望值（参考*绘制几何形状*配方）。
- en: End a render pass in the `command_buffer` (refer to the *Ending a render pass*
    recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*).
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中结束一个渲染通道（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的*结束渲染通道*配方）。
- en: 'If values stored in the `present_queue_family_index` and `graphics_queue_family_index`
    variables are different, set up another image memory barrier in the `command_buffer`
    (refer to the *Setting an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*). Use the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`
    value for the `generating_stages` parameter and the `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT`
    value for the `consuming_stages` parameter. For the barrier, provide a single
    variable of type `ImageTransition` initialized with the following values:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存储在`present_queue_family_index`和`graphics_queue_family_index`变量中的值不同，在`command_buffer`中设置另一个图像内存屏障（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*设置图像内存屏障*配方）。对于屏障，提供一个类型为`ImageTransition`的单个变量，并使用以下值初始化：
- en: The `swapchain_image` variable for `Image`
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`的`swapchain_image`变量'
- en: The `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `CurrentAccess`
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentAccess`的`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`值'
- en: The `VK_ACCESS_MEMORY_READ_BIT` value for `NewAccess`
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewAccess`的`VK_ACCESS_MEMORY_READ_BIT`值'
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `CurrentLayout`
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentLayout`的`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`值'
- en: The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `NewLayout`
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewLayout`的`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`值'
- en: The `graphics_queue_family_index` variable for `CurrentQueueFamily` and the
    `present_queue_family_index` variable for `NewQueueFamily`
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentQueueFamily`的`graphics_queue_family_index`变量和`NewQueueFamily`的`present_queue_family_index`变量'
- en: The `VK_IMAGE_ASPECT_COLOR_BIT` value for `Aspect`
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aspect`的`VK_IMAGE_ASPECT_COLOR_BIT`值'
- en: Stop recording the `command_buffer` (refer to the *Ending a command buffer recording
    operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止记录`command_buffer`（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*结束命令缓冲区记录操作*配方）。
- en: How it works...
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Assume we want to draw a single object. We want the object to appear directly
    on screen so, before we begin, we must acquire a swapchain image (refer to the
    *Acquiring a swapchain image* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*). Next, we start recording the command buffer (refer to the
    *Beginning a command buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要绘制单个对象。我们希望该对象直接显示在屏幕上，因此在我们开始之前，我们必须获取一个swapchain图像（参考第2章的*获取swapchain图像*配方，*图像展示*）。接下来，我们开始记录命令缓冲区（参考第3章的*开始命令缓冲区记录操作*配方，*命令缓冲区和同步*）：
- en: '[PRE19]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first thing we need to record is to change the swapchain image''s layout
    to a `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` layout. This operation should
    be performed implicitly using appropriate render pass parameters (initial and
    sub-pass layouts). But if queues used for the presentation and graphics operations
    come from two different families, we must perform ownership transfer. This cannot
    be done implicitly--for this we need to set up an image memory barrier (refer
    to the *Setting an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要记录的是将swapchain图像的布局更改为`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`布局。此操作应通过适当的渲染传递参数（初始和子传递布局）隐式执行。但是，如果用于展示和图形操作的队列来自两个不同的家族，我们必须执行所有权转移。这不能隐式完成--为此，我们需要设置一个图像内存屏障（参考第4章的*设置图像内存屏障*配方，*资源和内存*）：
- en: '[PRE20]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next thing to do is to start a render pass (refer to the *Beginning a render
    pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render
    Passes and Framebuffers*). We also need to bind a pipeline object (refer to the
    *Binding a pipeline object* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). We must do this before we can set up any pipeline
    related state:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开始一个渲染传递（参考第6章的*开始渲染传递*配方，*渲染传递和帧缓冲区*）。我们还需要绑定一个管道对象（参考第8章的*绑定管道对象*配方，*图形和计算管道*）。我们必须在设置任何与管道相关的状态之前完成此操作：
- en: '[PRE21]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When a pipeline is bound, we must set up any state that was marked as dynamic
    during the pipeline creation. Here, we set up viewport and scissor test states
    respectively (refer to the *Setting viewport states dynamically* and *Setting
    scissor states dynamically* recipes). We also bind a buffer that should be a source
    of vertex data (refer to the *Binding vertex buffers* recipe). This buffer must
    contain data copied from a variable of type `Mesh`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道绑定时，我们必须设置在管道创建期间标记为动态的任何状态。在这里，我们分别设置视口和剪裁测试状态（参考*动态设置视口状态*和*动态设置剪裁状态*配方）。我们还绑定了一个应该作为顶点数据源的缓冲区（参考*绑定顶点缓冲区*配方）。此缓冲区必须包含从类型为`Mesh`的变量中复制的数据：
- en: '[PRE22]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One last thing to do in this example is to bind the descriptor sets, which
    can be accessed inside shaders (refer to the *Binding descriptor sets* recipe
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中最后要做的另一件事是绑定描述符集，这些集可以在着色器内部访问（参考第5章的*绑定描述符集*配方，*描述符集*）：
- en: '[PRE23]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we are ready to draw a geometry. Of course, in more advanced scenarios,
    we would need to set up parameters of other states and bind other resources. For
    example, we may need to use an index buffer and provide values for push constants.
    But, the preceding setup is also enough for many cases:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好绘制几何图形。当然，在更高级的场景中，我们可能需要设置其他状态参数并绑定其他资源。例如，我们可能需要使用索引缓冲区并提供推送常数的值。但是，前面的设置对于许多情况也足够了：
- en: '[PRE24]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To draw a geometry, we must provide the number of geometry instances we want
    to draw and an index of a first instance. Vertex offsets and the number of vertices
    to draw are taken from the members of variables of type `Mesh`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制几何图形，我们必须提供我们想要绘制的几何实例数量以及第一个实例的索引。顶点偏移量和要绘制的顶点数量来自类型为`Mesh`的变量的成员。
- en: 'Before we can stop recording a command buffer, we need to end a render pass
    (refer to the *Ending a render pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*). After that, another transition on a swapchain
    image is required. When we are done rendering a single frame of animation, we
    want to present (display) a swapchain image. For this, we need to change its layout
    to a `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout, because this layout is required
    for the presentation engine to correctly display an image. This transition should
    also be performed implicitly through render pass parameters (the final layout).
    But again, if the queues used for graphics operations and presentations are different,
    a queue ownership transfer is necessary. This is done with another image memory
    barrier. After that, we stop recording a command buffer (refer to the *Ending
    a command buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够停止记录命令缓冲区之前，我们需要结束一个渲染通道（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的*结束渲染通道*配方）。之后，还需要在交换链图像上进行另一个转换。当我们完成单个动画帧的渲染后，我们希望展示（显示）一个交换链图像。为此，我们需要将其布局更改为`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`布局，因为这个布局是展示引擎正确显示图像所必需的。这个转换也应该通过渲染通道参数（最终布局）隐式执行。但是，如果用于图形操作和展示的队列不同，则需要进行队列所有权转移。这是通过另一个图像内存屏障来完成的。之后，我们停止记录命令缓冲区（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*结束命令缓冲区记录操作*配方）：
- en: '[PRE25]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This concludes the command buffer recording operation. We can use this command
    buffer and submit it to a (graphics) queue. It can be submitted only once, because
    it was recorded with a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` flag. But,
    of course, we can record a command buffer without this flag and submit it multiple
    times.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着命令缓冲区记录操作的结束。我们可以使用这个命令缓冲区并将其提交到一个（图形）队列中。它只能提交一次，因为它是以`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`标志记录的。但是，当然，我们也可以不使用这个标志来记录命令缓冲区，并多次提交。
- en: After submitting the command buffer, we can present a swapchain image, so it
    is displayed on screen. But, we must remember that submission and presentation
    operations should be synchronized (refer to the *Preparing a single frame of animation*
    recipe).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交命令缓冲区后，我们可以展示一个交换链图像，因此它会在屏幕上显示。但是，我们必须记住，提交和展示操作应该是同步的（参考*准备单个动画帧*配方）。
- en: See also
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*图像展示*，查看以下配方：
- en: '*Acquiring a swapchain image*'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取交换链图像*'
- en: '*Presenting an image*'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*展示图像*'
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Ending a command buffer recording operation*'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束命令缓冲区记录操作*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the recipe:'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看以下配方：
- en: '*Setting an image memory barrier*'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，查看以下配方：
- en: '*Binding descriptor sets*'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下配方：
- en: '*Beginning a render pass*'
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: '*Ending a render pass*'
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束渲染通道*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the recipe:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，查看以下配方：
- en: '*Binding a pipeline object*'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管线对象*'
- en: 'The following recipes in this chapter:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Binding vertex buffers*'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Setting viewport states dynamically*'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置视口状态*'
- en: '*Setting scissor states dynamically*'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置裁剪状态*'
- en: '*Drawing a geometry*'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制几何体*'
- en: '*Preparing a single frame of animation*'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备单个动画帧*'
- en: Recording command buffers on multiple threads
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个线程上记录命令缓冲区
- en: High level graphics APIs such as OpenGL are much easier to use, but they are
    also limited in many aspects. One such aspect is the lack of ability to render
    scenes on multiple threads. Vulkan fills this gap. It allows us to record command
    buffers on multiple threads, utilizing as much processing power of not only the
    graphics hardware, but also of the main processor.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 高级图形 API，如 OpenGL，使用起来更容易，但它们在许多方面也受到限制。其中一个方面是缺乏在多个线程上渲染场景的能力。Vulkan 填补了这个空白。它允许我们在多个线程上记录命令缓冲区，利用图形硬件以及主处理器的处理能力。
- en: Getting ready
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purpose of this recipe, a new type is introduced. It has the following
    definition:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，引入了一个新的类型。它具有以下定义：
- en: '[PRE26]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding structure is used to store parameters specific for each thread
    used to record command buffers. The handle of a command buffer that will be recorded
    on a given thread is stored in the `CommandBuffer` member. The `RecordingFunction`
    member is used to define a function, inside which we will record the command buffer
    on a separate thread.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构用于存储用于记录命令缓冲区的每个线程的特定参数。将在给定线程上记录的命令缓冲区的句柄存储在 `CommandBuffer` 成员中。`RecordingFunction`
    成员用于定义一个函数，在其中我们将记录命令缓冲区在单独的线程上。
- en: How to do it...
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a variable of type `std::vector<CommandBufferRecordingThreadParameters>`
    named `threads_parameters`. For each thread used to record a command buffer, add
    a new element to the preceding vector. Initialize the element with the following
    values:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `threads_parameters` 的 `std::vector<CommandBufferRecordingThreadParameters>`
    类型的变量。对于每个用于记录命令缓冲区的线程，向前面的向量中添加一个新元素。使用以下值初始化该元素：
- en: The handle of a command buffer to be recorded on a separate thread for `CommandBuffer`
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要在单独的线程上记录的命令缓冲区的句柄用于 `CommandBuffer`
- en: The function (accepting a command buffer handle) used to record a given command
    buffer for `RecordingFunction`
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于记录给定命令缓冲区的函数（接受命令缓冲区句柄）用于 `RecordingFunction`
- en: Create a variable of type `std::vector<std::thread>` named `threads`. Resize
    it to be able to hold the same number of elements as the `threads_parameters`
    vector.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `threads` 的 `std::vector<std::thread>` 类型的变量。将其大小调整为能够容纳与 `threads_parameters`
    向量相同数量的元素。
- en: For each element in the `threads_parameters` vector, start a new thread that
    will use the `RecordingFunction` and provide the `CommandBuffer` as the function's
    argument. Store the handle of a created thread at the corresponding position in
    the `threads` vector.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `threads_parameters` 向量中的每个元素，启动一个新的线程，该线程将使用 `RecordingFunction` 并将 `CommandBuffer`
    作为函数的参数提供。将创建的线程的句柄存储在 `threads` 向量中的相应位置。
- en: Wait until all created threads finish their execution by joining with all elements
    in the `threads` vector.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有创建的线程通过连接 `threads` 向量中的所有元素来完成它们的执行。
- en: Gather all recorded command buffers in a variable of type `std::vector<VkCommandBuffer>`
    named `command_buffers`.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有记录的命令缓冲区收集到一个名为 `command_buffers` 的 `std::vector<VkCommandBuffer>` 类型的变量中。
- en: How it works...
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we want to use Vulkan in a multithreaded application, we must keep in mind
    several rules. First, we shouldn't modify the same object on multiple threads.
    For example, we cannot allocate command buffers from a single pool or we cannot
    update a descriptor set from multiple threads.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在多线程应用程序中使用 Vulkan 时，我们必须记住几个规则。首先，我们不应该在多个线程上修改同一个对象。例如，我们不能从一个单一的池中分配命令缓冲区，或者我们不能从多个线程更新描述符集。
- en: We can access resources from multiple threads only if the access is read only
    or if we reference separate resources. But, as it may be hard to track which resources
    were created on which thread, in general, resource creation and modification should
    be performed only on a single *main* thread (which we can also call *the rendering
    thread*).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能从多个线程访问只读资源或引用不同的资源。但是，由于可能难以追踪哪些资源是在哪个线程上创建的，通常，资源创建和修改应该只在单个 *主* 线程（我们也可以称之为
    *渲染线程*）上执行。
- en: The most common scenario of utilizing multithreading in Vulkan is to concurrently
    record command buffers. This operation takes most of the processor time. It is
    also the most important operation performance-wise, so dividing it into multiple
    threads is very reasonable.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中使用多线程最常见的情况是同时记录命令缓冲区。这个操作消耗了大部分处理器时间。从性能角度来看，这也是最重要的操作，因此将其分成多个线程是非常合理的。
- en: When we want to record multiple command buffers in parallel, we need to use
    not only a separate command buffer for each thread, but also a separate command
    pool.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要并行记录多个命令缓冲区时，我们不仅需要为每个线程使用独立的命令缓冲区，还需要使用独立的命令池。
- en: We need to use a separate command pool for each thread, on which command buffers
    will be recorded. In other words--a command buffer recorded on each thread must
    be allocated from a separate command pool.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个线程使用一个独立的命令池，命令缓冲区将记录在这个池中。换句话说——每个线程上记录的命令缓冲区必须从独立的命令池中分配。
- en: Command buffer recording doesn't affect other resources (apart from the pool).
    We only prepare commands that will be submitted to a queue, so we can record any
    operations that use any resources. For example, we can record operations that
    access the same images or the same descriptor sets. The same pipelines can be
    bound to different command buffers at the same time during recording. We can also
    record operations that draw into the same attachments. We only record (prepare)
    operations.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区记录不会影响其他资源（除了池）。我们只准备将被提交到队列的命令，因此我们可以记录使用任何资源的任何操作。例如，我们可以记录访问相同图像或相同描述符集的操作。相同的管道可以在记录期间同时绑定到不同的命令缓冲区。我们还可以记录绘制到相同附件的操作。我们只记录（准备）操作。
- en: 'Recording command buffers on multiple threads may be performed like this:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程上记录命令缓冲区可以这样做：
- en: '[PRE27]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, each thread takes a separate `RecordingFunction` member, in which a corresponding
    command buffer is recorded. When all threads finish recording their command buffers,
    we need to gather the command buffers and submit them to a queue, when they are
    executed.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个线程都拥有一个独立的`RecordingFunction`成员，其中记录了相应的命令缓冲区。当所有线程完成它们的命令缓冲区记录后，我们需要收集这些命令缓冲区并将它们提交到队列，以便执行。
- en: In real-life applications, we will probably want to avoid creating and destroying
    threads in this way. Instead, we should take an existing job/task system and use
    it to also record the necessary command buffers. But the presented example is
    easy to use and understand. And, it is also good at illustrating the steps that
    need to be performed to use Vulkan in multithreaded applications.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们可能希望避免以这种方式创建和销毁线程。相反，我们应该使用现有的作业/任务系统，并利用它来记录必要的命令缓冲区。但是，所展示的示例易于使用和理解。此外，它还擅长说明在使用多线程应用程序中的Vulkan时需要执行的操作步骤。
- en: 'Submission can also be performed only from a single thread (queues, similarly
    to other resources, cannot be accessed concurrently), so we need to wait until
    all threads finish their jobs:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 提交也必须只能从单个线程执行（队列，与其他资源类似，不能并发访问），因此我们需要等待所有线程完成它们的工作：
- en: '[PRE28]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Submitting command buffers to a queue can be performed only from a single thread
    at a time.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 只能从单个线程提交命令缓冲区到队列。
- en: 'The preceding situation is presented in the following diagram:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况在以下图中展示：
- en: '![](img/image_09_003.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_003.png)'
- en: A similar situation occurs with a swapchain object. We can acquire and present
    swapchain images only from a single thread at a given moment. We cannot do this
    concurrently.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 与swapchain对象类似，我们只能在给定时刻从单个线程获取和展示swapchain图像。我们不能并发执行此操作。
- en: A swapchain object cannot be accessed (modified) concurrently on multiple threads.
    Acquiring an image and presenting it should be done on a single thread.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: swapchain对象不能在多个线程上并发访问（修改）。获取图像和展示它应该在单个线程上完成。
- en: But, it is a valid operation to acquire a swapchain image on a single thread
    and then concurrently record multiple command buffers that render into this swapchain
    image. We just need to make sure that the first submitted command buffer performs
    a layout transition away from the `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` (or the `VK_IMAGE_LAYOUT_UNDEFINED`)
    layout. Transition back to the `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout must be
    performed inside the command buffer that was submitted to the queue at the end.
    The order in which these command buffers were recorded doesn't matter; only the
    submission order is crucial.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在单个线程上获取swapchain图像，然后并发记录多个渲染到该swapchain图像的命令缓冲区是有效的操作。我们只需确保第一个提交的命令缓冲区执行一个从`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`（或`VK_IMAGE_LAYOUT_UNDEFINED`）布局的转换。转换回`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`布局必须在提交到队列的最后一个命令缓冲区内部执行。这些命令缓冲区记录的顺序并不重要；只有提交顺序是关键的。
- en: Of course, when we want to record operations that modify resources (for example,
    store values in buffers), we must also record proper synchronization operations
    (such as pipeline barriers). This is necessary for the proper execution, but it doesn't
    matter from the recording perspective.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们想要记录修改资源（例如，在缓冲区中存储值）的操作时，我们还必须记录适当的同步操作（例如，管道屏障）。这对于正确的执行是必要的，但从记录的角度来看并不重要。
- en: See also
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*图像展示*中，查看以下配方：
- en: '*Acquiring a swapchain image*'
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取swapchain图像*'
- en: '*Presenting an image*'
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*展示图像*'
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下配方：
- en: '*Submitting command buffers to a queue*'
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向队列提交命令缓冲区*'
- en: Preparing a single frame of animation
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备动画的单帧
- en: Usually, when we create 3D applications that render images, we would like images
    to be displayed on screen. For this purpose, a swapchain object is created in
    Vulkan. We know how to acquire images from a swapchain. We have also learned how
    to present them. Here, we will see how to connect image acquiring and presentation,
    how to record a command buffer in between, and how we should synchronize all of
    these operations to render a single frame of animation.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们创建渲染图像的3D应用程序时，我们希望图像显示在屏幕上。为此，在Vulkan中创建了一个swapchain对象。我们知道如何从swapchain获取图像。我们也学习了如何展示它们。在这里，我们将看到如何连接图像获取和展示，如何在其中记录命令缓冲区，以及我们应该如何同步所有这些操作以渲染动画的单帧。
- en: How to do it...
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在一个名为`logical_device`的`VkDevice`类型的变量中。
- en: Use a handle of a created swapchain to initialize a variable of type `VkSwapchainKHR`
    named `swapchain`.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的swapchain的句柄初始化一个名为`swapchain`的`VkSwapchainKHR`类型的变量。
- en: Prepare a semaphore handle in a variable of type `VkSemaphore` named `image_acquired_semaphore`.
    Make sure the semaphore is unsignaled or isn't being used in any previous submissions
    that haven't completed yet.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`image_acquired_semaphore`的`VkSemaphore`类型的变量中准备一个信号量句柄。确保信号量未被触发或未被用于任何尚未完成的先前提交。
- en: Create a variable of type `uint32_t` named `image_index`.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_index`的`uint32_t`类型的变量。
- en: Acquire an image from the `swapchain` using the `logical_device`, `swapchain`,
    and `image_acquired_semaphore` variables and store its index in the `image_index`
    variable (refer to the *Acquiring a swapchain image* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*).
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`、`swapchain`和`image_acquired_semaphore`变量从`swapchain`获取一个图像，并将它的索引存储在`image_index`变量中（参考[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)中的*获取swapchain图像*配方，*图像展示*）。
- en: Prepare a handle of a render pass that will be used during recording drawing
    operations. Store it in a variable of type `VkRenderPass` named `render_pass`.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个将在记录绘图操作期间使用的渲染通道句柄。将其存储在一个名为`render_pass`的`VkRenderPass`类型的变量中。
- en: Prepare image views for all swapchain images. Store them in a variable of type
    `std::vector<VkImageView>` named `swapchain_image_views`.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有swapchain图像准备图像视图。将它们存储在一个名为`swapchain_image_views`的`std::vector<VkImageView>`类型的变量中。
- en: Store the size of the swapchain images in a variable of type `VkExtent2D` named
    `swapchain_size`.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将swapchain图像的大小存储在一个名为`swapchain_size`的`VkExtent2D`类型的变量中。
- en: Create a variable of type `VkFramebuffer` named `framebuffer`.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`framebuffer`的`VkFramebuffer`类型的变量。
- en: Create a framebuffer for the `render_pass` (with at least an image view corresponding
    to the swapchain's image at the position `image_index`) using the `logical_device`,
    `swapchain_image_views[image_index]` and `swapchain_size` variables. Store the
    created handle in the framebuffer variable (refer to the *Creating a framebuffer*
    recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*).
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`、`swapchain_image_views[image_index]`和`swapchain_size`变量为`render_pass`创建一个帧缓冲区（至少包含一个对应于swapchain图像在`image_index`位置的图像视图）。将创建的句柄存储在帧缓冲区变量中（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)中的*创建帧缓冲区*配方，*渲染通道和帧缓冲区*）。
- en: Record a command buffer using the acquired swapchain image at the `image_index`
    position and the `framebuffer` variable. Store the handle of the recorded command
    buffer in a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用获取到的交换链图像在 `image_index` 位置和 `framebuffer` 变量中记录一个命令缓冲区。将记录的命令缓冲区的句柄存储在名为
    `command_buffer` 的 `VkCommandBuffer` 类型的变量中。
- en: Prepare a queue that will process commands recorded in the `command_buffer`.
    Store the queue's handle in a variable of type `VkQueue` named `graphics_queue`.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个将处理 `command_buffer` 中记录的命令的队列。将队列的句柄存储在名为 `graphics_queue` 的 `VkQueue`
    类型的变量中。
- en: Take the handle of an unsignaled semaphore and store it in a variable of type
    `VkSemaphore` named `ready_to_present_semaphore`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个未标记的信号量句柄并将其存储在名为 `VkSemaphore` 类型的变量 `ready_to_present_semaphore` 中。
- en: Prepare an unsignaled fence and store its handle in a variable of type `VkFence`
    named `finished_drawing_fence`.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个未标记的栅栏并将其手柄存储在名为 `finished_drawing_fence` 的 `VkFence` 类型的变量中。
- en: 'Create a variable of type `WaitSemaphoreInfo` named `wait_semaphore_info` (refer
    to the *Submitting command buffers to a queue* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command
    Buffers and Synchronization*). Initialize members of this variable using the following
    values:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `wait_semaphore_info` 的 `WaitSemaphoreInfo` 类型的变量（参考第 3 章 *将命令缓冲区提交到队列*
    的配方，*命令缓冲区和同步*）。使用以下值初始化此变量的成员：
- en: The `image_acquired_semaphore` variable for semaphore
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_acquired_semaphore` 变量用于信号量'
- en: The `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `WaitingStage`
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` 值用于 `WaitingStage`'
- en: Submit the `command_buffer` to the `graphics_queue`, specifying one element
    vector with the `wait_semaphore_info` variable for the `wait_semaphore_infos`
    parameter, the `ready_to_present_semaphore` variable for the semaphore to be signaled,
    and the `finished_drawing_fence` variable for the fence to be signaled (refer
    to the *Submitting command buffers to the queue* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `command_buffer` 提交到 `graphics_queue`，指定一个包含 `wait_semaphore_info` 变量的 `wait_semaphore_infos`
    参数的单元素向量，`ready_to_present_semaphore` 变量作为要发出信号的信号量，以及 `finished_drawing_fence`
    变量作为要发出信号的栅栏（参考第 3 章 *将命令缓冲区提交到队列* 的配方，*命令缓冲区和同步*）。
- en: Prepare the handle of a queue used for presentation. Store it in a variable
    of type `VkQueue` named `present_queue`.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备用于展示的队列的句柄。将其存储在名为 `present_queue` 的 `VkQueue` 类型的变量中。
- en: 'Create a variable of type `PresentInfo` named `present_info` (refer to the
    *Presenting an image* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*). Initialize members of this variable with the following
    values:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `present_info` 的 `PresentInfo` 类型的变量（参考第 2 章 *展示图像* 的配方，*图像展示*）。使用以下值初始化此变量的成员：
- en: The `swapchain` variable for `Swapchain`
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swapchain` 变量用于 `Swapchain`'
- en: The `image_index` variable for `ImageIndex`
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_index` 变量用于 `ImageIndex`'
- en: Present the acquired swapchain image to the `present_queue` queue. Provide one
    element vector with the `ready_to_present_semaphore` variable as the `rendering_semaphores`
    parameter, and one element vector with the `present_info` variable as the `images_to_present`
    parameter (refer to the *Presenting an image* recipe from [Chapter 2](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=605&action=edit#post_29),
    *Image Presentation*).
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取到的交换链图像展示给 `present_queue` 队列。提供一个包含 `ready_to_present_semaphore` 变量的 `rendering_semaphores`
    参数的单元素向量，以及一个包含 `present_info` 变量的 `images_to_present` 参数的单元素向量（参考第 2 章 *展示图像*
    的配方，*图像展示*）。
- en: How it works...
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Preparing a single frame of animation can be divided into five steps:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个动画的单帧可以分为五个步骤：
- en: Acquiring a swapchain image.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个交换链图像。
- en: Creating a framebuffer.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个帧缓冲区。
- en: Recording a command buffer.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录命令缓冲区。
- en: Submitting the command buffer to the queue.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令缓冲区提交到队列。
- en: Presenting an image.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示一个图像。
- en: First, we must acquire a swapchain image into which we can render. Rendering
    is performed inside a render pass that defines the parameters of attachments.
    Specific resources used for these attachments are defined in a framebuffer.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获取一个可以渲染的交换链图像。渲染是在一个定义了附件参数的渲染通道内进行的。用于这些附件的特定资源在帧缓冲区中定义。
- en: As we want to render into a swapchain image (to display the image on screen),
    this image must be specified as one of the attachments defined in a framebuffer.
    It may seem that creating a framebuffer earlier and reusing it during the rendering
    is a good idea. Of course, it is a valid approach but it has its drawbacks. The
    most important drawback is that it may be hard to maintain it during the lifetime
    of our application. We can render only into the image that was acquired from a
    swapchain. But as we don't know which image will be acquired, we need to prepare
    separate framebuffers for all swapchain images. What's more, we will need to recreate
    them each time a swapchain object is recreated. If our rendering algorithm requires
    more attachments to render into, we will start creating multiple variations of
    framebuffers for all combinations of swapchain images and images created by us.
    This becomes very cumbersome.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要渲染到swapchain图像中（以在屏幕上显示图像），因此必须将此图像指定为帧缓冲区中定义的附件之一。看起来，在早期创建帧缓冲区并在渲染期间重用它是好主意。当然，这是一个有效的方法，但它有其缺点。最重要的缺点是，在应用程序的生命周期内可能很难维护它。我们只能渲染从swapchain获取的图像。但由于我们不知道哪个图像将被获取，我们需要为所有swapchain图像准备单独的帧缓冲区。更重要的是，每次创建swapchain对象时，我们都需要重新创建它们。如果我们的渲染算法需要更多的附件来渲染，我们将开始为swapchain图像和由我们创建的图像的所有组合创建多个帧缓冲区变体。这变得非常繁琐。
- en: That's why it is much easier to create a framebuffer just before we start recording
    a command buffer. We create the framebuffer with only those resources that are
    needed to render this single frame. We just need to remember that we can destroy
    such a framebuffer only when the execution of a submitted command buffer is finished.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在开始记录命令缓冲区之前创建帧缓冲区要容易得多。我们只使用渲染这一帧所需的资源来创建帧缓冲区。我们只需记住，我们只能在提交的命令缓冲区执行完成后销毁这样的帧缓冲区。
- en: A framebuffer cannot be destroyed until the queue stops processing a command
    buffer in which the framebuffer was used.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 直到队列停止处理使用帧缓冲区的命令缓冲区之前，帧缓冲区不能被销毁。
- en: 'When an image is acquired and a framebuffer is created, we can record a command
    buffer. These operations may be performed like this:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取图像并创建帧缓冲区时，我们可以记录一个命令缓冲区。这些操作可以按如下方式进行：
- en: '[PRE29]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, we are ready to submit the command buffer to the queue. Operations
    recorded in the command buffer must wait until the presentation engine allows
    us to use the acquired image. For this purpose, we specify a semaphore when the
    image is acquired. This semaphore must also be provided as one of the wait semaphores
    during command buffer submission:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就准备好将命令缓冲区提交到队列中。记录在命令缓冲区中的操作必须等待直到显示引擎允许我们使用获取到的图像。为此，我们在获取图像时指定一个信号量。这个信号量也必须在提交命令缓冲区时作为等待信号量之一提供：
- en: '[PRE30]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A rendered image can be presented (displayed on screen) when the queue stops
    processing the command buffer, but we don't want to wait and check when this happens.
    That's why we use an additional semaphore (the `ready_to_present_semaphore` variable
    in the preceding code) that will be signaled when the command buffer's execution
    is finished. The same semaphore is then provided when we present a swapchain image.
    This way, we synchronize operations internally on the GPU as this is much faster
    than synchronizing them on the CPU. If we weren't using the semaphore, we would
    need to wait until the fence is signaled and only then could we present an image.
    This would stall our application and hurt the performance considerably.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列停止处理命令缓冲区时，渲染的图像可以被呈现（显示在屏幕上），但我们不希望等待并检查何时发生这种情况。这就是为什么我们使用一个额外的信号量（前述代码中的`ready_to_present_semaphore`变量），当命令缓冲区的执行完成时，该信号量将被触发。然后，当呈现swapchain图像时，提供相同的信号量。这样，我们可以在GPU上内部同步操作，这比在CPU上同步要快得多。如果我们没有使用信号量，我们就需要等待直到栅栏被触发，然后才能呈现图像。这将使我们的应用程序停滞，并大大降低性能。
- en: You may wonder why we need the fence (`finished_drawing_fence` in the preceding
    code), as it also gets signaled when the command buffer processing is finished.
    Isn't the semaphore enough? No, there are situations in which the application
    also needs to know when the execution of a given command buffer has ended. One
    such situation is when destroying the created framebuffer. We can't destroy it
    until the preceding fence is signaled. Only the application can destroy the resources
    it created, so it must know when it can safely destroy them (when they are not
    used anymore). Another example is re-recording of the command buffer. We can't
    record it again until its execution on a queue is finished. So we need to know
    when this happens. And, as the application cannot check the state of a semaphore,
    the fence must be used.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会 wonder 为什么我们需要栅栏（`finished_drawing_fence` 在前面的代码中），因为当命令缓冲区处理完成时它也会被信号。信号量不是足够吗？不，存在一些情况下应用程序也需要知道给定命令缓冲区的执行何时结束。这种情况之一就是在销毁创建的帧缓冲区时。我们无法在先前的栅栏被信号之前销毁它。只有应用程序可以销毁它创建的资源，因此它必须知道何时可以安全地销毁它们（当它们不再被使用时）。另一个例子是命令缓冲区的重新记录。我们无法在队列上完成其执行之前再次记录它。所以我们需要知道何时发生这种情况。而且，由于应用程序无法检查信号量的状态，所以必须使用栅栏。
- en: Using both a semaphore and a fence allows us to submit command buffers and present
    images immediately one after another, without unnecessary waits. And we can do
    these operations for multiple frames independently, increasing the performance
    even further.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号量和栅栏可以让我们立即提交命令缓冲区和呈现图像，而不需要不必要的等待。并且我们可以独立地对多个帧执行这些操作，从而进一步提高性能。
- en: See also
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 2](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=605&action=edit#post_29),
    *Image Presentation*, see the following recipes:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 2 章](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=605&action=edit#post_29)，*图像呈现*，查看以下菜谱：
- en: '*Getting handles of swapchain images*'
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取交换链图像的句柄*'
- en: '*Acquiring a swapchain image*'
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取交换链图像*'
- en: '*Presenting an image*'
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*呈现一个图像*'
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看以下菜谱：
- en: '*Creating a semaphore*'
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个信号量*'
- en: '*Creating a fence*'
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个栅栏*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: '*Checking if processing of a submitted command buffer has finished*'
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查提交的命令缓冲区的处理是否完成*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下菜谱：
- en: '*Creating a render pass*'
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个帧缓冲区*'
- en: Increasing the performance through increasing the number of separately rendered
    frames
  id: totrans-602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过增加独立渲染帧的数量来提高性能
- en: Rendering a single frame of animation and submitting it to a queue is the goal
    of 3D graphics applications, such as games and benchmarks. But a single frame
    isn't enough. We want to render and display multiple frames or we won't achieve
    the effect of animation.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染单个动画帧并将其提交到队列是 3D 图形应用程序（如游戏和基准测试）的目标。但一个帧是不够的。我们希望渲染和显示多个帧，否则我们无法达到动画的效果。
- en: Unfortunately, we can't re-record the same command buffer immediately after
    we submit it; we must wait until the queue stops processing it. But, waiting until
    the command buffer processing is finished is a waste of time and it hurts the
    performance of our application. That's why we should render multiple frames of
    animation independently.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法在提交它后立即重新记录相同的命令缓冲区；我们必须等待直到队列停止处理它。但是，等待直到命令缓冲区处理完成是浪费时间，并且会损害我们应用程序的性能。这就是为什么我们应该独立渲染多个动画帧的原因。
- en: Getting ready
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purpose of this recipe, we will use variables of a custom `FrameResources`
    type. It has the following definition:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，我们将使用自定义 `FrameResources` 类型的变量。它具有以下定义：
- en: '[PRE31]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding type is used to define resources that manage the lifetime of a
    single frame of animation.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型用于定义管理单个动画帧生命周期的资源。
- en: The `CommandBuffer` member stores a handle of a command buffer used to record
    operations of a single, independent frame of animation. In a real-life application,
    a single frame will be probably composed of multiple command buffers recorded
    in multiple threads. But for the purpose of a basic code sample, one command buffer
    is enough.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandBuffer` 成员存储用于记录单个、独立动画帧操作的命令缓冲区的句柄。在实际应用中，单个帧可能由多个线程中记录的多个命令缓冲区组成。但在基本代码示例中，一个命令缓冲区就足够了。'
- en: The `ImageAcquiredSemaphore` member is used to store a semaphore handle passed
    to the presentation engine when we acquire an image from a swapchain. This semaphore
    must then be provided as one of the wait semaphores when we submit the command
    buffer to a queue.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageAcquiredSemaphore` 成员用于存储在从交换链获取图像时传递给呈现引擎的信号量句柄。然后，这个信号量必须作为提交命令缓冲区到队列时的一个等待信号量提供。'
- en: The `ReadyToPresentSemaphore` member indicates a semaphore that gets signaled
    when a queue stops processing our command buffer. We should use it during image
    presentation, so the presentation engine knows when the image is ready.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadyToPresentSemaphore` 成员指示一个当队列停止处理我们的命令缓冲区时被信号量的信号量。我们应在图像呈现时使用它，以便呈现引擎知道图像何时准备好。'
- en: The `DrawingFinishedFence` member contains a fence handle. We provide it during
    the command buffer submission. Similarly to the `ReadyToPresentSemaphore` member,
    this fence gets signaled when the command buffer is no longer executed on a queue.
    But the fence is necessary to synchronize operations on the CPU side (the operations
    our application performs), not the GPU (and the presentation engine). When this
    fence is signaled, we know that we can both re-record the command buffer and destroy
    a framebuffer.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingFinishedFence` 成员包含一个围栏句柄。我们在提交命令缓冲区时提供它。类似于 `ReadyToPresentSemaphore`
    成员，当命令缓冲区不再在队列上执行时，这个围栏会被信号。但围栏是必要的，用于在 CPU 端（我们应用程序执行的操作）而不是 GPU（以及呈现引擎）上同步操作。当这个围栏被信号时，我们知道我们可以重新记录命令缓冲区并销毁帧缓冲区。'
- en: The `DepthAttachment` member is used to store an image view for an image serving
    as a depth attachment inside a sub-pass.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`DepthAttachment` 成员用于存储作为子通道内部深度附加的图像视图。'
- en: The `Framebuffer` member is used to store a temporary framebuffer handle created
    for the lifetime of a single frame of animation.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`Framebuffer` 成员用于存储为单个动画帧的生命周期创建的临时帧缓冲区句柄。'
- en: Most of the preceding members are wrapped into objects of a `VkDestroyer` type.
    This type is responsible for the implicit destruction of an owned object, when
    the object is no longer necessary.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面的成员都被包装成 `VkDestroyer` 类型的对象。这个类型负责在对象不再必要时隐式销毁所拥有的对象。
- en: How to do it...
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: 'Create a variable of type `std::vector<FrameResources>` named `frame_resources`.
    Resize it to hold the resources for the desired number of independently rendered
    frames (the recommended size is three), and initialize each element using the
    following values (the values stored in each element must be unique):'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `frame_resources` 的 `std::vector<FrameResources>` 类型的变量。将其大小调整为可以容纳所需数量的独立渲染帧的资源（推荐大小为三个），并使用以下值初始化每个元素（每个元素中存储的值必须是唯一的）：
- en: The handle of a created command buffer for `commandbuffer`
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `commandbuffer` 创建的命令缓冲区的句柄
- en: Two handles of created semaphores for `ImageAcquiredSemaphore` and `ReadyToPresentSemaphore`
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `ImageAcquiredSemaphore` 和 `ReadyToPresentSemaphore` 创建的两个句柄
- en: The handle of a fence created in an already signaled state for `DrawingFinishedFence`
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `DrawingFinishedFence` 创建的处于已信号状态的围栏的句柄
- en: The handle of an image view for an image serving as a depth attachment for `DepthAttachment`
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `DepthAttachment` 深度附加的图像视图的句柄
- en: The `VK_NULL_HANDLE` value for `Framebuffer`
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Framebuffer` 的 `VK_NULL_HANDLE` 值'
- en: Create a (potentially static) variable of type `uint32_t` named `frame_index`.
    Initialize it with a `0` value.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `frame_index` 的 `uint32_t` 类型的（可能静态的）变量。用 `0` 值初始化它。
- en: Create a variable of type `FrameResources` named `current_frame` that references
    an element of the `frame_resources` vector pointed to by the `frame_index` variable.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `current_frame` 的 `FrameResources` 类型的变量，该变量引用由 `frame_index` 变量指向的 `frame_resources`
    向量中的一个元素。
- en: Wait until the `current_frame.DrawingFinishedFence` gets signaled. Provide the
    `logical_device` variable and a timeout value equal to `2000000000` (refer to
    the *Waiting for fences* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到`current_frame.DrawingFinishedFence`被触发。提供`logical_device`变量和一个等于`2000000000`的超时值（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)中的*等待围栏*配方，*命令缓冲区和同步*）。
- en: Reset the state of the `current_frame.DrawingFinishedFence` fence (refer to
    the *Resetting fences* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置`current_frame.DrawingFinishedFence`围栏的状态（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)中的*重置围栏*配方，*命令缓冲区和同步*）。
- en: If the `current_frame.Framebuffer` member contains a handle of a created `framebuffer`,
    destroy it and assign a `VK_NULL_HANDLE` value to the member (refer to the *Destroying
    a framebuffer* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`current_frame.Framebuffer`成员包含创建的`framebuffer`的句柄，销毁它并将`VK_NULL_HANDLE`值分配给该成员（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)中的*销毁帧缓冲区*配方，*渲染通道和帧缓冲区*）。
- en: 'Prepare a single frame of animation using all the members of the `current_frame`
    variable (refer to the *Preparing a single frame of animation* recipe):'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`current_frame`变量的所有成员准备单个动画帧（参考*准备单个动画帧*配方）：
- en: Acquire a swapchain image providing the `current_frame.ImageAcquiredSemaphore`
    variable during this operation.
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此操作期间获取swapchain图像，提供`current_frame.ImageAcquiredSemaphore`变量。
- en: Create a framebuffer and store its handle in the `current_frame.Framebuffer`
    member.
  id: totrans-631
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个帧缓冲区并将它的句柄存储在`current_frame.Framebuffer`成员中。
- en: Record a command buffer stored in the `current_frame.CommandBuffer` member.
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录存储在`current_frame.CommandBuffer`成员中的命令缓冲区。
- en: Submit the `current_frame.CommandBuffer` member to a selected queue, providing
    the `current_frame.ImageaAquiredSemaphore` semaphore as one of the waiting semaphores,
    the `current_frame.ReadyToPresentSemaphore` semaphore as the semaphore to be signaled,
    and the `current_frame.DrawingFinishedFence` fence as the fence to be signaled
    when the command buffer's execution is finished.
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`current_frame.CommandBuffer`成员提交给一个选定的队列，提供`current_frame.ImageAcquiredSemaphore`信号量作为等待的信号量之一，将`current_frame.ReadyToPresentSemaphore`信号量作为要触发的信号量，将`current_frame.DrawingFinishedFence`围栏作为在命令缓冲区执行完成后要触发的围栏。
- en: Present a swapchain image to a selected queue, providing the one element vector
    with the `current_frame.ReadyToPresentSemaphore` variable as the `rendering_semaphores`
    parameter.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将swapchain图像展示给一个选定的队列，提供包含`current_frame.ReadyToPresentSemaphore`变量的一个元素向量作为`rendering_semaphores`参数。
- en: Increment a value stored in the `frame_index` variable. If it is equal to the
    number of elements in the `frame_resources` vector, reset the variable to `0`.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加存储在`frame_index`变量中的值。如果它等于`frame_resources`向量的元素数量，将变量重置为`0`。
- en: How it works...
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rendering animation is performed in a loop. One frame is rendered and an image
    is presented, then usually the operating system messages are processed. Next,
    another frame is rendered and presented, and so on.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染动画在一个循环中执行。渲染一帧并展示一个图像，然后通常处理操作系统消息。接下来，渲染并展示另一帧，依此类推。
- en: When we have only one command buffer and other resources required to prepare,
    render, and display a frame, we can't reuse them immediately. Semaphores cannot
    be used for another submission until the previous submission, in which they were
    used, has been finished. This situation requires us to wait for the end of the
    command buffer processing. But such waits are highly undesirable. The more we
    wait on the CPU, the more stalls we introduce to the graphics hardware and the
    worse performance we achieve.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有一个命令缓冲区以及准备、渲染和显示帧所需的其他资源时，我们无法立即重用它们。在之前的提交中使用过的信号量不能用于另一个提交，直到之前的提交完成。这种情况要求我们等待命令缓冲区处理的结束。但这样的等待是非常不希望的。我们在CPU上等待的时间越长，我们引入的图形硬件停滞就越多，我们达到的性能就越差。
- en: 'To shorten the time we wait in our application (until a command buffer recorded
    for the previous frame is executed), we need to prepare several sets of resources
    required to render and present a frame. When we record and submit a command buffer
    for one frame and we want to prepare another frame, we just take another set of
    resources. For the next frame, we use yet another set of resources until we have
    used all of them. Then we just take the least recently used set--of course, we
    need to check if we can reuse it but, at this time, there is a high probability
    that it has already been processed by the hardware. The process of rendering animation
    using multiple sets of **Frame Resources** is presented in the following diagram:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缩短我们在应用程序中等待的时间（直到为前一帧记录的命令缓冲区执行），我们需要准备几组渲染和呈现一帧所需的资源。当我们为某一帧记录和提交命令缓冲区，并希望准备另一帧时，我们只需获取另一组资源。对于下一帧，我们使用另一组资源，直到用完所有资源。然后我们只需取最不常用的那一组——当然，我们需要检查是否可以重用它，但在这个时候，它已经被硬件处理过的可能性很高。使用多组**帧资源**渲染动画的过程在以下图中展示：
- en: '![](img/image_09_004.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_004.png)'
- en: How many sets should we prepare? We may think that the more sets we have the
    better, because we won't need to wait at all. But unfortunately, the situation
    isn't that simple. First, we increase the memory footprint of our application.
    But, more importantly, we increase an input lag. Usually, we render animation
    based on the input from the user, who wants to rotate a virtual camera, view a
    model, or move a character. We want our application to respond to a user's input
    as quickly as possible. When we increase the number of independently rendered
    frames, we also increase the time between a user's input and the effect it has
    on the rendered image.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该准备多少组资源呢？我们可能会认为资源越多越好，因为我们根本不需要等待。但不幸的是，情况并不那么简单。首先，我们增加了应用程序的内存占用。但更重要的是，我们增加了输入延迟。通常，我们根据用户的输入渲染动画，用户可能想要旋转虚拟相机、查看模型或移动角色。我们希望应用程序能够尽可能快地响应用户的输入。当我们增加独立渲染的帧数时，我们也增加了用户输入和渲染图像上的效果之间的时间。
- en: We need to balance the number of separately rendered frames, the performance
    of our application, its memory usage, and the input lag.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要平衡单独渲染的帧数、应用程序的性能、内存使用和输入延迟。
- en: So, how many frame resources should we have? This of course depends on the complexity
    of the rendered scenes, the performance of the hardware on which the application
    is executed, and the type of rendering scenario it realizes (that is, the type
    of game we are creating--whether it is a fast **first-person perspective** (**FPP**)
    shooter or a racing game, or a more slow-paced tour based **role-playing** **game**
    (**RPG**)). So there is not one exact value that will fit all possible scenarios.
    Tests have shown that increasing the number of frame resources from one to two
    may increase the performance by 50%. Adding a third set increases the performance
    further, but the growth isn't as big this time. So, the performance gain is smaller
    with each additional set of frame resources. Three sets of rendering resources
    seems like a good choice, but we should perform our own tests and see what is
    best for our specific needs.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该有多少帧资源呢？这当然取决于渲染场景的复杂性、应用程序执行硬件的性能以及它实现的渲染场景类型（即我们正在创建的游戏类型——是快速的第一人称视角（**FPP**）射击游戏、赛车游戏，还是节奏较慢的基于**角色扮演**的**游戏**（**RPG**））。因此，没有一个确切的值可以适用于所有可能的场景。测试表明，将帧资源的数量从一组增加到两组可能会将性能提高50%。增加第三组可以进一步提高性能，但这次增长并不像之前那么大。因此，每增加一组帧资源，性能提升的幅度就较小。三组渲染资源看起来是一个不错的选择，但我们应该进行自己的测试，看看什么最适合我们的特定需求。
- en: 'We can see three examples of recording and submitting command buffers with
    one, two, and three independent sets of resources needed to render frames of animations,
    as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到使用一组、两组和三组独立资源记录和提交命令缓冲区的三个示例，如下所示：
- en: '![](img/image_09_005.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_005.png)'
- en: Now that we know why we should use several independent numbers of frame resources,
    we can see how to render a frame using them.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了为什么我们应该使用多个独立的帧资源，我们可以看看如何使用它们来渲染一帧。
- en: 'First, we start by checking if we can use a given set of resources to prepare
    a frame. We do this by checking the status of a fence. If it is signaled, we are
    good to go. You may wonder, what should we do when we render the very first frame--we
    didn''t submit anything to a queue yet, so the fence didn''t have an opportunity
    to be signaled. It''s true, and that''s why, for the purpose of preparing frame
    resources, we should create fences in an already signaled state:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始检查是否可以使用给定的一组资源来准备一个帧。我们通过检查栅栏的状态来完成此操作。如果它已信号，我们就准备好了。你可能想知道，当我们渲染第一个帧时我们应该做什么——我们还没有向队列提交任何内容，所以栅栏没有机会被信号。这是真的，这就是为什么，为了准备帧资源，我们应该在已信号的状态下创建栅栏：
- en: '[PRE32]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We should also check if a framebuffer used for the frame was created. If it
    was, we should destroy it because it will be created later. For an acquired swapchain
    image, an `InitVkDestroyer()` function initializes the provided variable with
    a new, empty object handle and, if necessary, destroys the previously owned object.
    After that, we render the frame and present an image. To do this, we need a command
    buffer and two semaphores (refer to the *Preparing a single frame of animation*
    recipe):'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该检查用于该帧的帧缓冲区是否已创建。如果是，我们应该销毁它，因为它将在稍后创建。对于已获取的swapchain图像，`InitVkDestroyer()`函数使用一个新的空对象句柄初始化提供的变量，并在必要时销毁之前拥有的对象。之后，我们渲染帧并呈现图像。为此，我们需要一个命令缓冲区和两个信号量（参考*准备单个动画帧*食谱）：
- en: '[PRE33]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One last thing is to increase the index of the currently used set of frame
    resources. For the next frame of animation we will use another set, until we have
    used all of them, and we start from the beginning:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是增加当前使用的帧资源集的索引。对于下一个动画帧，我们将使用另一组，直到我们使用完所有这些，然后我们从开始：
- en: '[PRE34]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见也
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看以下食谱：
- en: '*Waiting for fences*'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Resetting fences*'
  id: totrans-656
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置栅栏*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipe:'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下食谱：
- en: '*Destroying a framebuffer*'
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁帧缓冲区*'
- en: '*Preparing a single frame of animation *recipe in this chapter'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*准备单个动画帧*食谱
