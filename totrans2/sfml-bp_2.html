<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;General Game Architecture, User Inputs, and Resource Management"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. General Game Architecture, User Inputs, and Resource Management</h1></div></div></div><p>Now that the boring part is over, let's start working with SFML. In this chapter, we are not yet going to build a complete game, but instead we'll learn some basic skills that are required to build a game. These are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding a basic game architecture</li><li class="listitem" style="list-style-type: disc">Managing user inputs</li><li class="listitem" style="list-style-type: disc">Keeping a track of external resources</li></ul></div><p>All of these points are really important for any kind of game. But what do these points exactly mean? This is what I will explain to you in this chapter.</p><div class="section" title="General structure of a game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>General structure of a game</h1></div></div></div><p>Before starting to build randomly and without any specific planning, we need to have some information: what kind<a id="id60" class="indexterm"/> of game you want to build (RPG, FPS, or action-adventure), what elements will be used, and so on. The aim of this chapter is to understand the general game structure, which can be used in any kind of game. Through this part, we will study:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The game class</li><li class="listitem" style="list-style-type: disc">The frame rate</li><li class="listitem" style="list-style-type: disc">The player class</li><li class="listitem" style="list-style-type: disc">Event management </li></ul></div><div class="section" title="The game class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>The game class</h2></div></div></div><p>In the previous<a id="id61" class="indexterm"/> chapter, we have seen the minimal code required for a game, which contains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Window creation</li><li class="listitem" style="list-style-type: disc">Creation of graphic display</li><li class="listitem" style="list-style-type: disc">Handle user inputs</li><li class="listitem" style="list-style-type: disc">Deal with the user inputs</li><li class="listitem" style="list-style-type: disc">Display game objects on the screen</li></ul></div><p>Instead of having one function do all the work, we will make use of object-oriented practices and define various states in different functions. Moreover, we will encapsulate the methods in a new class named <code class="literal">Game</code>, and we will minimize the <code class="literal">main</code> function. This <code class="literal">Game</code> class will be the starting point for all our future games:</p><div class="informalexample"><pre class="programlisting">class Game
{
    public:
        Game(const Game&amp;) = delete;
        Game&amp; operator=(const Game&amp;) = delete;
        Game();
        void run();

    private:
        void processEvents();
        void update();
        void render();

        sf::RenderWindow _window;
        sf::CircleShape  _player;
};


int main(int argc,char* argv[])
{
    Game game;
    game.run();

    return 0;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>
<code class="literal">= delete</code> is a C++11 feature that allows us to explicitly delete a special member function such as constructor, move constructor, copy constructor, copy-assignment operator, move copy-assignment operator, and destructor. It tells to the compiler to not build the default function. In this particular case, it makes the class noncopyable. Another solution would be to extend the class from <code class="literal">sf::NonCopyable</code>.</p><p>
<code class="literal">= default</code> is also possible to explicitly tell the compiler to build the default version of this member function. It could, for example, be used to define a custom constructor and a default constructor.</p></div></div><p>Now we have the basic <code class="literal">Game</code> class <a id="id62" class="indexterm"/>structured, in which the functions are separated based on their features. Moreover, there is no loop anymore in the main function because we will be present in the <code class="literal">Game::run()</code> function. Now, we simply have to call the <code class="literal">Game::run()</code> function.</p><p>We can now move all the codes from the main function into the functions—<code class="literal">processEvents()</code>, <code class="literal">update()</code>, or <code class="literal">render()</code>—depending on what we are trying to achieve:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">processEvents()</code>: This will<a id="id63" class="indexterm"/> manage all events from the user</li><li class="listitem" style="list-style-type: disc"><code class="literal">update()</code>: This will update<a id="id64" class="indexterm"/> the entire game</li><li class="listitem" style="list-style-type: disc"><code class="literal">render()</code>: This will<a id="id65" class="indexterm"/> manage all the rendering of the game</li></ul></div><p>All the future features will also be put into one of these private functions.</p><p>Now, let's have a look at the implementation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The constructor initializes the window and the player:<div class="informalexample"><pre class="programlisting">Game::Game() : _window(sf::VideoMode(800, 600),"02_Game_Archi"), _player(150)
{
        _player.setFillColor(sf::Color::Blue);
        _player.setPosition(10, 20);
}</pre></div></li><li class="listitem">The <code class="literal">Game::run()</code> method hides the main <code class="literal">game</code> loop:<div class="informalexample"><pre class="programlisting">void Game::run()
{
    while (_window.isOpen())
    {
        processEvents();
        update();
        render();
    }
}</pre></div></li><li class="listitem">The <code class="literal">Game::processEvents()</code> method handles user inputs. It simply polls all the events received from the window since the last frame, such as a button in the window title bar or a keyboard key being pressed. In the following code, we check for the user pressing the window's close button and the keyboard's Esc key. In response, we close the window:<div class="informalexample"><pre class="programlisting">void Game::processEvents() {
  sf::Event event;
  while(_window.pollEvent(event)) {
    if ((event.type == sf::Event::Closed)
    or ((event.type == sf::Event::KeyPressed) and (event.key.code == sf::Keyboard::Escape))) {
      _window.close();
    }
  }
}</pre></div></li><li class="listitem">The <code class="literal">update()</code> method updates our game logic. For the moment, we don't have any logic, but in the near future we will see how to modify the logic of our game:<div class="informalexample"><pre class="programlisting">void Game::update(){}</pre></div></li><li class="listitem">The <code class="literal">Game::render()</code> method renders<a id="id66" class="indexterm"/> the game to the screen. First, we clear the window with a color, usually <code class="literal">sf::Color::Black</code>, which is the default, then we render our object for the frame, and finally, we display it on the screen:<div class="informalexample"><pre class="programlisting">void Game::render() {
  _window.clear();
  _window.draw(_player);
  _window.display();
}</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>
<span class="strong"><strong>Downloading the color images of this book</strong></span>
</p><p>We also provide you with a PDF file that has color images of the screenshots/diagrams used in this book. The color images will help you better understand the changes in the output. You can download this file from <a class="ulink" href="https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf">https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf</a>.</p></div></div><p>There is no change on the final render of the scene, compared to the minimal example of the previous chapter, except the title and the size. Even if there is more code, the application is easier to maintain with the new architecture because the functions have been reduced to the minimal, and it's easier for you to find what you want:</p><div class="mediaobject"><img src="graphics/8477OS_02_01.jpg" alt="The game class"/></div></div><div class="section" title="Game loops"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Game loops</h2></div></div></div><p>Now that the <code class="literal">Game</code> class<a id="id67" class="indexterm"/> has been introduced, let's talk about the loop inside the <code class="literal">Game::run()</code> function. This loop is <a id="id68" class="indexterm"/>called the <code class="literal">game</code> loop or <code class="literal">main</code> loop. It runs continuously during game play and performs several actions at each turn of the loop. Each iteration of this loop is called a frame. The term <span class="strong"><strong>frames per second</strong></span> (<span class="strong"><strong>FPS</strong></span>) is a <a id="id69" class="indexterm"/>measure that determines the number of iterations made by the game in 1 second. I will come back to this point later.</p><p>What you do inside this loop is quite simple. Firstly, we process the events. Then we update the games states. Finally, we render the game to the screen.</p><p>As you might have noticed, this sounds a lot like the <code class="literal">run</code> method of the <code class="literal">Game</code> class. To explain more visually, this loop is a flowchart representing the logic:</p><div class="mediaobject"><img src="graphics/8477OS_02_02.jpg" alt="Game loops"/></div><p>For the moment, the loop is reduced to the minimum. For example, we don't detail the <code class="literal">Game::processEvents()</code> method in depth here. For the moment, the game loop has been kept simple, so you can learn the basics first. Later, we will be getting back to each of<a id="id70" class="indexterm"/> the methods in the <code class="literal">Game::run()</code> method, such as the <code class="literal">Game::processEvents()</code> method, and adding<a id="id71" class="indexterm"/> more complexity.</p><div class="section" title="The frame rate"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>The frame rate</h3></div></div></div><p>We are now coming back to<a id="id72" class="indexterm"/> the frames. As I have already said, a frame is a complete iteration of the <code class="literal">game</code> loop. The final result is the new <code class="literal">game</code> states that can be displayed on the screen.</p><p>Humans are unable to see<a id="id73" class="indexterm"/> unlimited number of images per second. There is some interpolation between each image that we perceive with our brain. The result is that we don't need to display a great amount of images each second. But the more images displayed, the greater will the quality of the final result be. For example, at the cinema, only 24 images are displayed per second.</p><p>In video games, most of the time, we try to make a loop as quick as we can. The number of images displayed reaches 30 to 60 per second. Below 30 FPS, there can be a lag effect which can be due to the game, and we need to handle it to avoid problems.</p><p>One of the most common problems caused by the lag effect is the displacement of the entities. Most of the time, each entity has its own speed and direction. The speed is often measured in pixels per second. Now imagine your game, for any reason, has some lag and the FPS dropped to a small number like 5, then the graphical effect is that all your entities will teleport themselves. But this is not the main issue. The big issue is with the collisions. Take an example of an entity that was walking in the direction of a wall when the lag happens, the entity will literally cross over the wall. Here is a figure that represents the problem:</p><div class="mediaobject"><img src="graphics/8477OS_02_03.jpg" alt="The frame rate"/></div><p>To fix this problem, there are three different approaches. The first is called variable time steps, second is fixed time steps, and third that mix them together.</p><div class="section" title="Fixed time steps"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>Fixed time steps</h4></div></div></div><p>The fixed time steps approach, as<a id="id74" class="indexterm"/> its name suggests, is an approach where each call to the<a id="id75" class="indexterm"/> <code class="literal">Game::update()</code> function is made with the same time interval. The units used, for example, for the movement are relative to the frame. Because each frame is separate from the others of the same time, we don't need more complexity. The only thing we need to pay attention to is to choose the basic values to be sure that there are no problems.</p><p>Here is the new flowchart of the <code class="literal">game</code> loop:</p><div class="mediaobject"><img src="graphics/8477OS_02_04.jpg" alt="Fixed time steps"/></div><p>Now we will implement the new <code class="literal">Game</code> class in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Game::run(int frame_per_seconds)
{
    sf::Clock clock;
    sf::Time timeSinceLastUpdate = sf::Time::Zero;
    sf::Time TimePerFrame = sf::seconds(1.f/frame_per_seconds);

    while (_window.isOpen())
    {
        processEvents();
        bool repaint = false;

        timeSinceLastUpdate += clock.restart();
        while (timeSinceLastUpdate &gt; TimePerFrame)
        {
            timeSinceLastUpdate -= TimePerFrame;
            repaint = true;
            update(TimePerFrame);
        }
        if(repaint)
            render();
    }
}</pre></div><p>This code ensures that each call to the <code class="literal">Game::update()</code> function will always take the same time as the parameter value. There no big difference with the previous version of the code. Here we just keep track of the time since the last call of the <code class="literal">Game::update()</code> function, and then we only call it again, when the time exceeds the frame rate. The code could be improved by sleeping with <code class="literal">sf::sleep</code> the remainder of the free time in the loop. It's a bit more difficult (because needs to measure the time spent in the previous update+render), but won't waste CPU time.</p><p>A little change has <a id="id76" class="indexterm"/>been made on the <code class="literal">Game::update()</code> function by adding a parameter to it. Its new signature is now:</p><div class="informalexample"><pre class="programlisting">void update(sf::Time deltaTime);</pre></div><p>This parameter allows us to know the time elapsed since the last call of <code class="literal">Game::update()</code>. Currently, there is no great interest in it, but later there will be.</p><p>Because the state of the game is changed only when <code class="literal">Game::update()</code> is called, the call to <code class="literal">Game::render()</code> is made when at least an update is made.</p></div><div class="section" title="Variable time steps"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec04"/>Variable time steps</h4></div></div></div><p>The variable time steps <a id="id77" class="indexterm"/>approach is different from fixed time steps, as the name suggests. The main idea here is to execute the <code class="literal">game</code> loop as quickly as we can, without any delay. This allows the game to be more reactive. The units here have to be like units per time (mostly, time refers to one second here). Because we cannot predict how many times the loop will run, we will make it a parameter in the <code class="literal">Game::update()</code> function, and multiply it with the base unit.</p><p>Our actual implementation of the <code class="literal">game</code> loop corresponds to the variable time steps approach; we just need to add a system to keep a track of the elapsed time since the last loop:</p><div class="informalexample"><pre class="programlisting">void Game::run()
{
    sf::Clock clock;
                                      
    while (_window.isOpen())
    {
        processEvents();
        update(clock.restart());
        render();
    }
}</pre></div><p>The only thing new here is <code class="literal">sf::Clock</code> and the parameter to the <code class="literal">Game::update()</code> method. But there is <a id="id78" class="indexterm"/>still a problem with this approach: when the game is too slow (the time between two steps is important).</p></div><div class="section" title="Minimum time steps"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>Minimum time steps</h4></div></div></div><p>There is another solution, wherein<a id="id79" class="indexterm"/> the last two approaches are merged. The idea is to run the game as quickly as possible by ensuring the time parameter passed in the <code class="literal">Game::update()</code> method is not too high. The consequence is that we ensure to have a minimal frame rate, but no maximal. To sum up, we want two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To allow the game to run as quickly as possible</li><li class="listitem" style="list-style-type: disc">If, for any reason, the time between the two loops becomes higher than, let's say, 30 FPS, we split this time as much as needed to ensure that the delta time pass to the <code class="literal">Game::update()</code> function is not higher than 30 FPS.</li></ul></div><p>Here is the flowchart representing this solution:</p><div class="mediaobject"><img src="graphics/8477OS_02_05.jpg" alt="Minimum time steps"/></div><p>Now we will implement the new <code class="literal">run</code> function in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Game::run(int minimum_frame_per_seconds)) { 
    sf::Clock clock; 
   sf::Time timeSinceLastUpdate; 
    sf::Time TimePerFrame = sf::seconds(1.f/minimum_frame_per_seconds); 

   while (_window.isOpen()) { 
       processEvents(); 
      timeSinceLastUpdate = clock.restart(); 

      while (timeSinceLastUpdate &gt; TimePerFrame) { 
           timeSinceLastUpdate -= TimePerFrame; 
           update(TimePerFrame); 
      } 
     update(timeSinceLastUpdate); 
     render(); 
   } 
} </pre></div><p>On each frame, the <code class="literal">Game::update()</code> and <code class="literal">Game::render()</code> methods are called, but when the delta time<a id="id80" class="indexterm"/> between two frames is more important than what we want, the <code class="literal">Game::update()</code> method is called with the maximum value allowed, as many times as necessary.</p><p>All these approaches have their strong points and their weak points. Depending on circumstances, one approach will be better than another. But from now on, we will use the minimum time steps approach.</p><p>All these solutions are not well adapted to use a physics engine. We will return to this particular point in <a class="link" href="ch04.html" title="Chapter 4. Playing with Physics">Chapter 4</a>, <span class="emphasis"><em>Playing with Physics</em></span>. But knowing that it will take two loops: one for the physics and another one for the game logic. Each of these loops can have a frame rate different from each other.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>There are other approaches to manage the frame rate of an application. One of the most common is the<a id="id81" class="indexterm"/> <code class="literal">sleep()</code> function, which interrupts the application during a specified time and gives the processor the opportunity to work on other tasks. But this is not a good solution in games and all kinds of applications that <a id="id82" class="indexterm"/>need exact timing. SFML provides us with a <code class="literal">sf::RenderWindow::setFramerateLimit()</code> function that tries to fix the frame rate of the running application by calling <code class="literal">sf::sleep()</code> internally. This is a good solution, but for testing only.</p><p>Another solution is to use the vertical synchronization by calling <code class="literal">void sf::Window::setVerticalSyncEnabled(bool)</code>. It will limit the number of frames displayed to the refresh rate of the monitor (most of the time 60 Hz, but there is no guarantee). It helps in <a id="id83" class="indexterm"/>avoiding some visual artefacts, and limits the frame rate to a good value (but not constant across different computers). V-Sync can occasionally lock too low on some systems. This is why in full production games it can be turned on and off.</p></div></div></div></div></div><div class="section" title="Move our player"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Move our player</h2></div></div></div><p>Now that we have a clean <code class="literal">game</code> loop, let's move our <code class="literal">Player</code> object. For now, let's move it forward and make it turn<a id="id84" class="indexterm"/> right and left. We will make it in a way<a id="id85" class="indexterm"/> that will not depend on the frame rate. First, let's consider the player.</p><div class="section" title="The player class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>The player class</h3></div></div></div><p>
<code class="literal">Player</code> is a really important <a id="id86" class="indexterm"/>class in any kind of game, and changes a lot with the type of game. Here our goal is just to be able to move and rotate it. So the information required is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Its shape, size, and color</li><li class="listitem" style="list-style-type: disc">Its direction</li><li class="listitem" style="list-style-type: disc">Its speed</li></ul></div><p>Let's change the <code class="literal">Player</code> shape to a square using the SFML class <code class="literal">sf::RectangleShape</code>. The direction and the speed can be merged into a single object: a mathematical vector (we will speak about this in the next section). SFML provides a nice class for this: <code class="literal">sf::Vector2f</code>. We will also need to add speed and rotation and set the position of the player, but we will also update it and finally display it on the screen.</p><p>Finally, we obtain this class:</p><div class="informalexample"><pre class="programlisting">class Player : public sf::Drawable {
  public:
    Player(const Player&amp;) = delete;
    Player&amp; operator=(const Player&amp;) = delete;
    Player();

    template&lt;typename ... Args&gt;
    void setPosition(Args&amp;&amp; ... args) {
      _shape.setPosition(std::forward&lt;Args&gt;(args)...);
    }
                                                
    void update(sf::Time deltaTime);
    bool isMoving;
    int rotation;
                                                                                              
  private:
     virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
     sf::RectangleShape  _shape;
     sf::Vector2f        _velocity;
}</pre></div><p>As mentioned, the<a id="id87" class="indexterm"/> player needs to be displayed on the screen, so we extend it from <code class="literal">sf::Drawable</code>. This class simply adds the <code class="literal">draw()</code> virtual method to the class that we need to override. To be sure that we override it, we use the new keyword of C++11: <code class="literal">override</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Using override, we are sure that we make an override and not an overload. This is a new keyword from C++11.</p></div></div><p>Moreover, as in the <code class="literal">Game</code> class, we make the player non-copyable by explicitly deleting the default implementation of methods.</p><p>Now, let's speak about the <code class="literal">Player::setPosition()</code> method. As you can see, its signature is really strange. Here, I use another C++11 feature: the <code class="literal">variadic</code> template. As you know, <code class="literal">sf::Transformable</code> has two versions of the <code class="literal">setPosition()</code> method. The first one takes two float numbers, and the second takes <code class="literal">sf::Vector2f</code> as the parameter. Because I don't want to build the two versions, I use a new possibility of C++. I simply forward the arguments to <code class="literal">sf::Transformable::setPosition()</code> without knowing them. By using this, we can use both of the <code class="literal">sf::Transformable::setPosition()</code> functions.</p><p>First, we declare the parameter type of the function as the following template:</p><div class="informalexample"><pre class="programlisting">template&lt;typename Arg&gt; void setPosition(Arg arg);</pre></div><p>However, we also want to have a variable number of parameters, so we use the ellipse operator. The result is as follows:</p><div class="informalexample"><pre class="programlisting">template&lt;typename … Args&gt; void setPosition(Args ... args);</pre></div><p>Since we don't want to fix the type of parameter (constant, left-reference, or right-reference), we use another feature of C++11: the right value reference or, in this context, the forwarding/universal reference. This allows us to catch any kind of type by simply adding <code class="literal">&amp;&amp;</code>. The final signature of the function now is as follows:</p><div class="informalexample"><pre class="programlisting">template&lt;typename … Args&gt; void setPosition(Args&amp;&amp; ... args);</pre></div><p>Now, to perfectly forward the parameters to <code class="literal">sf::Transformable::setPosition()</code>, we simply need to unpack the arguments pack using the ellipse operator and call <code class="literal">std::forward</code> on each of them:</p><div class="informalexample"><pre class="programlisting">_shape.setPosition(std::forward&lt;Args&gt;(args)...);</pre></div><p>That's it! We can now use any of the <code class="literal">sf::Transformable::setPosition()</code> methods. This approach is really powerful to make some generic code, so try to understand it.</p><p>The <code class="literal">Player</code> class also<a id="id88" class="indexterm"/> has two public attributes: <code class="literal">isMoving</code> and <code class="literal">rotation</code>. These attributes will simply store the inputs' states.</p><p>Now take a look to the implementation of the functions:</p><div class="informalexample"><pre class="programlisting">Player::Player() : _shape(sf::Vector2f(32,32))
 {
     _shape.setFillColor(sf::Color::Blue);
     _shape.setOrigin(16,16);
 }</pre></div><p>Here, we just change the <code class="literal">_shape</code> constructor to fit with the <code class="literal">sf::RectangeShape</code> constructor, and center the origin of the shape to its gravity center:</p><div class="informalexample"><pre class="programlisting">void Player::update(sf::Time deltaTime)
{
    float seconds = deltaTime.asSeconds();
    if(rotation != 0)
    {
        float angle = (rotation&gt;0?1:-1)*180*seconds;
        _shape.rotate(angle);
    }
    if(isMoving)
    {
        float angle = _shape.getRotation() / 180 * M_PI - M_PI / 2;
        _velocity += sf::Vector2f(std::cos(angle),std::sin(angle)) * 60.f * seconds;
    }
    _shape.move(seconds * _velocity);
}</pre></div><p>Here is the important part. This function updates our player in the following manner:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First we rotate it if necessary.</li><li class="listitem" style="list-style-type: disc">Then, if the player is moving, we simply get the angle of rotation of the shape to know its direction, and then to its existing velocity, we add some speed depending on its direction. Notice that for the moment we don't clamp the maximal speed.</li><li class="listitem" style="list-style-type: disc">To finish, we<a id="id89" class="indexterm"/> just have to move it; this is incredibly easy. We simply need to call the <code class="literal">move</code> method on <code class="literal">shape</code> with <code class="literal">velocity</code> as the parameter.</li></ul></div><p>Because each frame is not executed in the same time, we need to multiply all the values (rotation speed, acceleration, and velocity) by the time since the last call. Here I choose to use pixels per second as the unit, so we need to multiply the value with the number of seconds since the last call; <code class="literal">sf::Time</code> provides this ability:</p><div class="informalexample"><pre class="programlisting">void Player::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
    target.draw(_shape,states);
}</pre></div><p>This function is not difficult and should not surprise you.</p><p>Now, we need to update the <code class="literal">Game::processEvents()</code> function to set the values of <code class="literal">isMoving</code> and <code class="literal">rotation</code>:</p><div class="informalexample"><pre class="programlisting">void Game::processEvents()
{
    sf::Event event;

    while(_window.pollEvent(event))
    {
        if (event.type == sf::Event::Closed)
            _window.close();
        else if (event.type == sf::Event::KeyPressed)
        {
            if (event.key.code == sf::Keyboard::Escape)
                _window.close();
            else if(event.key.code == sf::Keyboard::Up)
                _player.isMoving = true;
            else if (event.key.code == sf::Keyboard::Left)
                _player.rotation = -1;
            else if (event.key.code == sf::Keyboard::Right)
                _player.rotation = 1;
        }
        else if (event.type == sf::Event::KeyReleased)
        {
            if(event.key.code == sf::Keyboard::Up)
                _player.isMoving = false;
            else if (event.key.code == sf::Keyboard::Left)
                _player.rotation = 0;
            else if (event.key.code == sf::Keyboard::Right)
                _player.rotation = 0;
        }
    }
}</pre></div><p>With this code, we set the value of <code class="literal">isMoving</code> to <code class="literal">true</code> when the up arrow key is pressed and to <code class="literal">false</code> when it is<a id="id90" class="indexterm"/> released. The same trick is used to set the rotation depending on the left and right arrows, but here we set the rotation direction, <code class="literal">1</code> for clockwise, <code class="literal">-1</code> for counterclockwise, and <code class="literal">0</code> to none. All the computations have already been made in <code class="literal">Player::update()</code>.</p></div></div></div></div>
<div class="section" title="Managing user inputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Managing user inputs</h1></div></div></div><p>Managing the events<a id="id91" class="indexterm"/> received from the user is a really important topic. SFML provides us with two different approaches. The first is by polling the events received from a <code class="literal">sf::Window</code> instance, and the other is by checking the state in real time of an entry.</p><p>First of all, what is an event?</p><p>Generally, an event is an object that is triggered when something changes/happens. They are OS-dependent, but SFML provides us with a nice object to handle them in an OS-independent way. This is the <code class="literal">sf::Event</code> class. This class deals with a vast number of events, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Windows contains four different kinds of events. They are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Close</li><li class="listitem" style="list-style-type: disc">Resize</li><li class="listitem" style="list-style-type: disc">Gain/lose focus</li><li class="listitem" style="list-style-type: disc">The mouse pointer goes in/out of the window</li></ul></div></li><li class="listitem" style="list-style-type: disc">There are three events for the mouse. They are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move</li><li class="listitem" style="list-style-type: disc">Key press/release</li><li class="listitem" style="list-style-type: disc">Wheel press, release, or move</li></ul></div></li><li class="listitem" style="list-style-type: disc">The keyboard contains two events. They are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keys press/release</li><li class="listitem" style="list-style-type: disc">Text entered</li></ul></div></li><li class="listitem" style="list-style-type: disc">The joystick is also managed with four events. They are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connected/disconnected</li><li class="listitem" style="list-style-type: disc">Move</li><li class="listitem" style="list-style-type: disc">Press/release the key</li><li class="listitem" style="list-style-type: disc">Enter text</li></ul></div></li></ul></div><p>I suggest you take a<a id="id92" class="indexterm"/> look at the SFML documentation for this class at <a class="ulink" href="http://www.sfml-dev.org/tutorials/2.2/window-events.php">http://www.sfml-dev.org/tutorials/2.2/window-events.php</a>. An important thing to have in mind<a id="id93" class="indexterm"/> is that <code class="literal">sf::Event</code> is nothing but a big union, so you have to pay attention to access the right attributes of an event depending on its type.</p><div class="section" title="Polling events"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Polling events</h2></div></div></div><p>These kinds of events <a id="id94" class="indexterm"/>are stored in a queue by a <code class="literal">sf::Window</code> instance. To deal with them, we simply need to extract them one by one using the <code class="literal">sf::Window::pollEvent()</code> method. Its signature is as follows:</p><div class="informalexample"><pre class="programlisting">bool sf::Window::pollEvent(sf::Event&amp; event);</pre></div><p>This signature is a bit interesting. The return value is set to <code class="literal">true</code> if an event has been extracted from the queue and <code class="literal">false</code> in other cases. When an event is extracted, the event parameter is set to correspond to the correct value. In other words, the event parameter is the event that we get when the function returns <code class="literal">true</code>. The typical use of this is as follows:</p><div class="informalexample"><pre class="programlisting">sf::Event event;
while(_window.pollEvent(event))
{
    // do something with the event
}</pre></div><p>This is exactly what we've done in our actual application. For the moment, we use the event polling to deal with the user inputs.</p><p>These event types are used for specific cases (such as closing the window, using the escape key to exit, pausing the game, and so on), and not to move a player because events are perceived so jerky in a non-real-time. The resulting movement will also be jerky.</p></div><div class="section" title="Real-time events"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Real-time events</h2></div></div></div><p>SFML provides us with the <a id="id95" class="indexterm"/>possibility to check the state of an entity at any time. This entity can be the mouse, keyboard, or a joystick. Here, we don't use events, but we simply check the position of the mouse, and whether a specific button or key is pressed. This is really different from the events, and is particularly well adapted for the player's actions such as movement, shooting, and so on.</p><p>As you have probably noticed, our actual use of event in the <code class="literal">Player</code> class is wrong. So we need to change it to use real-time events without changing the controls keys. To do this, we will add a <code class="literal">processEvents()</code> method in the <code class="literal">Player</code> class that will set the value of <code class="literal">isMoving</code> and <code class="literal">rotation</code>. We will also change our <code class="literal">Game::processEvents()</code> function to call the<a id="id96" class="indexterm"/> newly created <code class="literal">Player::processEvents()</code> method. Also, because <code class="literal">isMoving</code> and <code class="literal">rotation</code> will be set inside the <code class="literal">Player</code> class, we will move them as private attributes.</p><p>Here is the signature of the new method:</p><div class="informalexample"><pre class="programlisting">void processEvents();</pre></div><p>As you can see, this is the exact same signature as <code class="literal">Game::processEvents()</code>. Its implementation is as follows:</p><div class="informalexample"><pre class="programlisting">void Player::processEvents()
{
    isMoving = sf::Keyboard::isKeyPressed(sf::Keyboard::Up);
    rotation = 0;
    rotation-= sf::Keyboard::isKeyPressed(sf::Keyboard::Left);
    rotation+= sf::Keyboard::isKeyPressed(sf::Keyboard::Right);
}</pre></div><p>First, we set the <code class="literal">isMoving</code> value, depending on the up arrow state. To do this, we use the <code class="literal">sf::Keyboard::isKeyPressed()</code> function. Because this function is a static one, we can directly use it without any object. Take a look at its signature:</p><div class="informalexample"><pre class="programlisting">static bool sf::Keyboard::isKeyPressed(sf::Keyboard::Key);</pre></div><p>This function returns <code class="literal">true</code> if the key is pressed, and <code class="literal">false</code> if not. Really simple, isn't it?</p><p>Now, let's talk about the rotation. The rotation depends on two different inputs. So, we need to think "What will happen if the user presses both at the same time?". It might sound a bit weird, but yes, some players will do this, so we need to consider it. Here, I use a really simple solution:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, I reset the value of <code class="literal">rotation</code></li><li class="listitem" style="list-style-type: disc">Then, I add <code class="literal">rotation</code> depending on the input state for both the keys</li></ul></div><p>By doing this, if no key is pressed, <code class="literal">rotation</code> stays to its initial value, that is, <code class="literal">0</code>. If one of the inputs is pressed, then <code class="literal">rotation</code> takes the value of <code class="literal">1</code> or <code class="literal">-1</code>, and if both are pressed, the two inputs will cancel each other out, so everything is fine and we get the result we expected.</p><p>Now, let's focus on the <code class="literal">Player::update()</code> method. This one is not really different. The only line we have to change is the following:</p><div class="informalexample"><pre class="programlisting">float angle = (rotation&gt;0?1:-1)*180*seconds;</pre></div><p>Because we now set <code class="literal">rotation</code> inside the <code class="literal">Player</code> class, we are sure that its value is always accurate, so that we don't need to verify it anymore and can remove it. The new line is reduced to<a id="id97" class="indexterm"/> the following:</p><div class="informalexample"><pre class="programlisting">float angle = rotation*180*seconds;</pre></div><p>Now, let's take a look at the updated <code class="literal">Game::processEvents()</code> method:</p><div class="informalexample"><pre class="programlisting">void Game::processEvents()
{
    sf::Event event;
    while(_window.pollEvent(event))
    {
        if (event.type == sf::Event::Closed)//Close window
            _window.close();
        else if (event.type == sf::Event::KeyPressed) //keyboard input
        {
            if (event.key.code == sf::Keyboard::Escape)
                _window.close();
        }
    }                      
    _player.processEvents();
}</pre></div><p>Here, we drastically reduce the code size by removing any event dedicated to the player. The only thing to do is to call the <code class="literal">Player::processEvents()</code> method instead of managing the player controls.</p></div><div class="section" title="Handling user inputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Handling user inputs</h2></div></div></div><p>Now that the events are known<a id="id98" class="indexterm"/> better, it could be interesting to be able to bind them to some callback when they occur. The main idea behind this is to allow us to dynamically add functionalities. In a game, you sometimes have the possibility to upgrade some weapons, or to use new ones; one option is to make sure that the usage is allowed before executing it, and another is to add it to the player when he is able to use it. By doing this, we remove a lot of if statements in our code and increase the readability of the latter.</p><p>To do this, we need a system that allows us to add functionalities to an entity, and that can be triggered by an event. This event can be in real time or generated by polling a <code class="literal">sf::Window</code> instance.</p></div><div class="section" title="Using the Action class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Using the Action class</h2></div></div></div><p>We will create a new class containing an <code class="literal">sf::Event</code> instance that needs to be executed. This class will<a id="id99" class="indexterm"/> implement functionality to check if the internal <code class="literal">sf::Event</code> instance is executed. The comparison operators are a good way to do this, but it will not work for real-time events because we have nothing to compare with, as we don't pool them. So<a id="id100" class="indexterm"/> we will also need <code class="literal">Action::test()</code> to check if a real-time event is satisfied. We will also need to know whether the event has to be triggered by pressing or releasing the input, or both.</p><p>The code for the <code class="literal">Action</code> class is as follows:</p><div class="informalexample"><pre class="programlisting">class Action
{
    public:

        enum Type
        {
            RealTime=1,
            Pressed=1&lt;&lt;1,
            Released=1&lt;&lt;2
        };

        Action(const sf::Keyboard::Key&amp; key,int type=Type::RealTime|Type::Pressed);
        Action(const sf::Mouse::Button&amp; button,int type=Type::RealTime|Type::Pressed);                                                          

        bool test()const;                                                                                        
 
        bool operator==(const sf::Event&amp; event)const;
        bool operator==(const Action&amp; other)const;
                                                                                            
    private:
        friend class ActionTarget;
        sf::Event _event;
        int _type;
};</pre></div><p>Let us follow this code step-by-step:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we define enum that will be used as flags in and by the constructors.</li><li class="listitem" style="list-style-type: disc">Then, we make the copy constructor and the copy operator.</li><li class="listitem" style="list-style-type: disc">Next are the constructors. For the moment, we need to manage inputs from the mouse and the keyboard. So we make two constructors, one for each type of event.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">test()</code> function will allow us to test whether the event is satisfied in real time, and the<a id="id101" class="indexterm"/> comparison operators will allow us to compare the event with others.</li></ul></div><p>We shall now take a<a id="id102" class="indexterm"/> look at the implementation:</p><div class="informalexample"><pre class="programlisting">Action::Action(const Action&amp; other) : _type(other._type)
{
    std::memcpy(&amp;_event,&amp;other._event,sizeof(sf::Event));
}
Action&amp; Action::operator=(const Action&amp; other)
{
    std::memcpy(&amp;_event,&amp;other._event,sizeof(sf::Event));
    _type = other._type;
    return *this;
}</pre></div><p>These two functions simply copy the content of <code class="literal">Action</code> to another <code class="literal">Action</code> instance. Because the <code class="literal">sf::Event</code> class doesn't implement the copy operator/constructor, we use the <code class="literal">std::memcpy()</code> function from the C string module. This allows us to copy the entire content of <code class="literal">sf::Event</code> simply by knowing its size, which can be known using the <code class="literal">sizeof()</code> operator. Notice that this is technically correct in this case only because <code class="literal">sf::Event</code> doesn't contain any pointers:</p><div class="informalexample"><pre class="programlisting">Action::Action(const sf::Keyboard::Key&amp; key,int type) : _type(type)
{
    _event.type = sf::Event::EventType::KeyPressed;
    _event.key.code = key;
}</pre></div><p>Here is the constructor for the keyboard events. The <code class="literal">key</code> parameter defines the key to bind, and the <code class="literal">type</code> parameter defines the state of the input: real-time, pressed, released, or a combination of them. Because the <code class="literal">type</code> value is a flag, it can take the value of <code class="literal">Pressed</code> and <code class="literal">Released</code> at the same time; this creates a problem because the type of an event can't be <code class="literal">sf::Event::EventType::KeyPressed</code> and <code class="literal">sf::Event::EventType::KeyReleased</code> at the same time. We need to bypass this limitation.</p><p>To do this, set the event type to <code class="literal">sf::Event::EventType::KeyPressed</code> no matter what the value of type is, and we will have some special cases to deal with later (in <code class="literal">test()</code> and comparison operator):</p><div class="informalexample"><pre class="programlisting">Action::Action(const sf::Mouse::Button&amp; button,int type) : _type(type)
{
    _event.type = sf::Event::EventType::MouseButtonPressed;
    _event.mouseButton.button = button;
}</pre></div><p>This is the same idea as<a id="id103" class="indexterm"/> the previous constructor. The only difference<a id="id104" class="indexterm"/> is that <code class="literal">event.mouseButton</code> cannot be copied. So here we need to use <code class="literal">std::memcpy()</code> again:</p><div class="informalexample"><pre class="programlisting">bool Action::operator==(const sf::Event&amp; event)const
{
    bool res = false;                                                                                                       
    switch(event.type)
    {
        case sf::Event::EventType::KeyPressed:
        {
            if(_type &amp; Type::Pressed and _event.type == sf::Event::EventType::KeyPressed)
                res = event.key.code == _event.key.code;
        }break;
        case sf::Event::EventType::KeyReleased:
        {
            if(_type &amp; Type::Released and _event.type == sf::Event::EventType::KeyPressed)
                res = event.key.code == _event.key.code;
        }break;
        case sf::Event::EventType::MouseButtonPressed:
        {
            if(_type &amp; Type::Pressed and _event.type == sf::Event::EventType::MouseButtonPressed)
                res = event.mouseButton.button == _event.mouseButton.button;
        }break;
        case sf::Event::EventType::MouseButtonReleased:
        {
            if(_type &amp; Type::Released and _event.type == sf::Event::EventType::MouseButtonPressed)
                res = event.mouseButton.button == _event.mouseButton.button;
        }break;
        default: break;
    }
    return res;
}</pre></div><p>
<code class="literal">Action::operator==()</code> is an interesting function. This function will test if two events are equivalent. But, because we have previously fixed the value for the keyboard and the mouse to <code class="literal">sf::Event::EventType::[Key/Button]Pressed</code>, we need to check these special cases. These <a id="id105" class="indexterm"/>cases are represented by the <code class="literal">if</code> statements:</p><div class="informalexample"><pre class="programlisting">bool Action::operator==(const Action&amp; other)const
{
    return _type == other._type and other == _event;
}</pre></div><p>This function is pretty<a id="id106" class="indexterm"/> simple, first we check the type, and then, we forward the comparison to the comparison operator previously defined:</p><div class="informalexample"><pre class="programlisting">bool Action::test()const
{
    bool res = false;
    if(_event.type == sf::Event::EventType::KeyPressed)
    {
        if(_type &amp; Type::Pressed)
            res = sf::Keyboard::isKeyPressed(_event.key.code);
    }
    else if (_event.type == sf::Event::EventType::MouseButtonPressed)
    {
        if(_type &amp; Type::Pressed)
            res = sf::Mouse::isButtonPressed(_event.mouseButton.button);
    }
    return res;
}</pre></div><p>This function is made for checking real-time events. As I have already mentioned, we only need the mouse and keyboard events. To check them, we use the static functions <code class="literal">sf::Keyboard::isKeyPressed()</code> and <code class="literal">sf::Mouse::isButtonPressed()</code>. Here we simply have to check the type of events and the state required, and that's it.</p><p>Now that the <code class="literal">Action</code> class was made, let's move on to the next step: binding them to a functionality.</p></div><div class="section" title="Action target"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Action target</h2></div></div></div><p>We will now need a <a id="id107" class="indexterm"/>system to bind a functionality to an event. So let's think about what a functionality is.</p><p>A functionality is a piece of code that has to be executed when a criterion is satisfied. Here the criterion is an action and thanks to our freshly defined class, we can now know whether the event is satisfied or not. But what about the piece of code? If we think a little bit about it, the functionality can be put in a function or method, so here we are: a functionality is nothing but a function. So to store the code, and be able to bind it at runtime, we will use the generic function wrapper from the C++11: the template class <code class="literal">std::function</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>
<code class="literal">std::function</code> is a <a id="id108" class="indexterm"/>generic wrapper for any type of function, method, and lambda. It's a very powerful object to store callbacks. To do this, we will use another new class from the C++11, the template class <code class="literal">std::pair</code>, and a container. Due to our needs, a <code class="literal">std::</code> list will be perfectly fine.</p></div></div><p>Now we have all the <a id="id109" class="indexterm"/>keys in hand to build what we need. We will build a container to store as many actions paired with <code class="literal">std::function</code> as we want:</p><div class="informalexample"><pre class="programlisting">class ActionTarget
{
    public:
        using FuncType = std::function&lt;void(const sf::Event&amp;)&gt;;

        ActionTarget();
                                                                        
        bool processEvent(const sf::Event&amp; event)const;
        void processEvents()const;

        void bind(const Action&amp; action,const FuncType&amp; callback);
        void unbind(const Action&amp; action);
                                                                        
    private:
        std::list&lt;std::pair&lt;Action,FuncType&gt;&gt; _eventsRealTime;
        std::list&lt;std::pair&lt;Action,FuncType&gt;&gt; _eventsPoll;
};</pre></div><p>Let's see what happens step by step:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, we define the type of the function that will be managed with the new C++11 use of the <code class="literal">using</code> keyword. This syntax is equivalent to <code class="literal">typedef</code> except that it is more explicit.</li><li class="listitem" style="list-style-type: disc">Secondly, we define a default constructor and the methods to verify the internal events. We create two of them. The first is for non-real-time events (polling), and the other is for real-time events.</li><li class="listitem" style="list-style-type: disc">Then we add a method to bind an event to a function, and another to remove any existing event.</li></ul></div><p>Internally, you can make the choice to separate the real-time and non-real-time events to avoid some <code class="literal">if</code> statements. The<a id="id110" class="indexterm"/> goal is to win some readability and computing power.</p><p>Now take a look at the implementation:</p><div class="informalexample"><pre class="programlisting">ActionTarget::ActionTarget()
{
}

bool ActionTarget::processEvent(const sf::Event&amp; event)const
{
    bool res = false;
    for(auto&amp; action : _eventsPoll)
    {
        if(action.first == event)
        {
            action.second(event);
            res = true;
            break;
        }
    }
    return res;
}
                                                                                     
void ActionTarget::processEvents()const
{
    for(auto&amp; action : _eventsRealTime)
    {
        if(action.first.test())
            action.second(action.first._event);
    }
}</pre></div><p>The two <code class="literal">ActionTarget::processEvent[s]()</code> methods are not difficult and simply check the validity of the events by using the functions that have been made in the <code class="literal">Action</code> class. If the event is satisfied, we call the associated function with the <code class="literal">sf::Event</code> as a parameter.</p><p>Here a new <code class="literal">for</code> loop, syntax is used. It's the <code class="literal">foreach</code> style of the C++11 <code class="literal">for</code> loop coupled with the <code class="literal">auto</code> keyword. This is both a very powerful and succinct syntax:</p><div class="informalexample"><pre class="programlisting">void ActionTarget::bind(const book::Action&amp; action,const FuncType&amp; callback)
{
    if(action._type &amp; Action::Type::RealTime)
        _eventsRealTime.emplace_back(action,callback);
    else
        _eventsPoll.emplace_back(action,callback)
}</pre></div><p>This method adds a new event and its callback to the internal container. To avoid some <code class="literal">if</code> statements in the <code class="literal">processEvent[s]()</code> methods, I make the choice to separate the real-time event from<a id="id111" class="indexterm"/> the others:</p><div class="informalexample"><pre class="programlisting">void ActionTarget::unbind(const book::Action&amp; action)
{
    auto remove_func = [&amp;action](const std::pair&lt;book::Action,FuncType&gt;&amp; pair) -&gt; bool
    {
        return pair.first == action;
    };
                                                                                       
    if(action._type &amp; Action::Type::RealTime)
        _eventsRealTime.remove_if(remove_func);
    else
        _eventsPoll.remove_if(remove_func);
}</pre></div><p>At runtime, it could be useful to be able to remove some actions. This is the idea of this function. I use the <code class="literal">std::list::remove_if()</code> method here to remove all the actions of the internal list that match the parameter. It takes a function such as the parameter, so we create a lambda. The lambda functions are a new feature from the C++11. Their syntax is a little special, as follows:</p><div class="informalexample"><pre class="programlisting">[captured, variables](parameters) -&gt; returnType { definition };</pre></div><p>Let's go through the preceding syntax in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A lambda is like any other function, except it doesn't have a name (also named anonymous functions). Because of this, a lambda doesn't know the context and sometimes, like here, you will need some variables from the calling context. These variables have to be specified in the <code class="literal">[]</code> part. You can prefix them with a <code class="literal">=</code> or <code class="literal">&amp;</code> symbol depending on whether you want to access them by copy or by reference.</li><li class="listitem" style="list-style-type: disc">Second is the parameters part. Nothing is new in this part. The parameter type is fixed by the <code class="literal">std::list::remove_if()</code> function to the same type of template parameter of the <code class="literal">std::list</code> used.</li><li class="listitem" style="list-style-type: disc">Then it's the return type. It's not an obligation, because this type can be deduced from the return statement, but here I've made the choice to explicitly write it, as a complete example. The return type is also fixed by the <code class="literal">std::list::remove_if()</code> method to <code class="literal">bool</code>.</li><li class="listitem" style="list-style-type: disc">And finally, between <code class="literal">{</code> and <code class="literal">}</code> is the implementation of the lambda. This implementation is really simple because all the work has already been done in the <code class="literal">Action</code> class.</li></ul></div><p>And here we are. We have our complete new <code class="literal">ActionTarget</code> class ready to be used. There are some new C++ features used in this part (<code class="literal">using</code>, <code class="literal">foreach</code>, <code class="literal">auto</code>, and <code class="literal">lambda</code>). If you don't understand them, I suggest you learn them by reading the C++11 that can be find on this website : <a class="ulink" href="http://en.cppreference.com/w/cpp/language">http://en.cppreference.com/w/cpp/language</a>. It's really<a id="id112" class="indexterm"/> essential you understand what is used here before you read on. So if need be, take as much time as required.</p><p>Now that we have built the system to manage the events, let's use it. We will change our player, and extend it from <code class="literal">ActionTarget</code>. We will need to change the code in the <code class="literal">.hpp</code> file a little bit. Since the C++ allows us to use the multiple inheritance, let's use it, and change the class from: </p><div class="informalexample"><pre class="programlisting">class Player : public sf::Drawable {…};</pre></div><p>to</p><div class="informalexample"><pre class="programlisting">class Player : public sf::Drawable , public ActionTarget {…};.</pre></div><p>By doing this, the functionalities of the <code class="literal">ActionTarget</code> class are added to the <code class="literal">Player</code> class. Now, we need to update two functions: <code class="literal">Player::Player()</code> and <code class="literal">Player::processEvents()</code>. Notice, that this change imply a modification on the <code class="literal">isMoving</code> and <code class="literal">rotation</code> attributes that are now private members of the <code class="literal">Player</code> class.</p><div class="informalexample"><pre class="programlisting">Player::Player() : _shape(sf::Vector2f(32,32))
                   ,_isMoving(false)
                   _rotation(0)
{
    _shape.setFillColor(sf::Color::Blue);
    _shape.setOrigin(16,16);
                                                               
    bind(Action(sf::Keyboard::Up),[this](const sf::Event&amp;){
         _isMoving = true;
    });

    bind(Action(sf::Keyboard::Left),[this](const sf::Event&amp;){
         _rotation-= 1;
     });

    bind(Action(sf::Keyboard::Right),[this](const sf::Event&amp;){
         _rotation+= 1;
     });
}</pre></div><p>Here, we bind the keyboard keys to some callbacks using lambda functions. As you can see, we don't need to check the state of the input in the function because this has already been done in the <code class="literal">ActionTarget::proccessEvents()</code> method. The callback is called only when the event is satisfied, in this case, when the key is pressed. So we can directly set the value because we know that the key is pressed.</p><p>The idea here is to be able to change the inputs without any change in the callbacks. This will be really<a id="id113" class="indexterm"/> interesting to build a custom input configuration in the future:</p><div class="informalexample"><pre class="programlisting">void Player::processEvents()
{
    _isMoving = false;
    _rotation = 0;
    ActionTarget::processEvents();
}</pre></div><p>In this method, we remove all of the codes that check the inputs states, and delegate this to the <code class="literal">ActionTaget::processEvents()</code> method. The only new thing to do is reset the variable that can be changed by the events.</p><p>There is no difference in the final result of our application, but now we have a good starting point to manage our events, and it simplifies our work.</p></div><div class="section" title="Event map"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Event map</h2></div></div></div><p>Now that we have defined a system to check our event, it would be great to change the inputs associated to a functionality at runtime. This will allow us to create a system where the user can choose which <a id="id114" class="indexterm"/>key/button he wants to associate with a specific action. For the moment, we have hardcoded the inputs.</p><p>To do this, we will need something that can associate a key with an action. This is what the <code class="literal">std::map</code> and <code class="literal">std::unordered_map</code> classes do. Because <code class="literal">std::unordered_map</code> is quicker than <code class="literal">std::map</code> at runtime, we prefer to use it. This class comes from the C++ 11.</p><p>As previously mentioned, we need to associate a key with an action, so we will create a new class named <code class="literal">ActionMap</code> that will contain the association map and offer the possibility to add actions at runtime or get one action, thanks to its key: </p><div class="informalexample"><pre class="programlisting">
<code class="literal">template&lt;typename T = int&gt;</code>
class ActionMap
{
    public:
        ActionMap(const ActionMap&lt;T&gt;&amp;) = delete;
        ActionMap&lt;T&gt;&amp; operator=(const ActionMap&lt;T&gt;&amp;) = delete;
                                                               
        ActionMap() = default;
                                                               
        void map(const T&amp; key,const Action&amp; action);
        const Action&amp; get(const T&amp; key)const;
                                                               
    private:
        std::unordered_map&lt;T,Action&gt; _map;
};</pre></div><p>Nothing complex here, we just make a wrapper around the container, and make the class in such a way that it cannot be copied with a default empty constructor. We also make the class as a template<a id="id115" class="indexterm"/> to be able to choose any kind of key type. In practice, we will often use an integer, but sometimes, it could be interesting to have a string as the key. This is the reason why the template type is <code class="literal">int</code> by default. Now, let's look at its implementation:</p><div class="informalexample"><pre class="programlisting">template&lt;typename T&gt;
void ActionMap&lt;T&gt;::map(const T&amp; key,const Action&amp; action)
{
    _map.emplace(key,action);
}

template&lt;typename T&gt;
const Action&amp; ActionMap&lt;T&gt;::get(const T&amp; key)const
{
    return _map.at(key);
}</pre></div><p>The implementation is really simple to understand. We simply forward what we want to do to the internal container. Because <code class="literal">std::unordered_map</code> throws exceptions when we try to make an invalid access, for example, we don't need any test.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Notice that, because the class is a template, the implementation has to be made in the header file. But, in order to not lose readability in the header, there is another way; put the code in a <code class="literal">.tpl</code> file (<code class="literal">tpl</code> is the short form for template word) and include it at the end of the header. By doing this, we separate the declaration from the implementation. This is a good practice, and I recommend you to apply it. The <code class="literal">.inl</code> file extension is also common (shortcut for inline word) instead of <code class="literal">.tpl</code>.</p></div></div><p>If you pay attention, the class is not a static one and can be instantiated. This is so that it will allow us to use multiple <code class="literal">ActionMap</code> class in our project, for example, one to store the player inputs, and another to store the system inputs. But this approach clashes with our actual <code class="literal">ActionTarget</code> class, so we need to modify it a little bit.</p></div><div class="section" title="Back to action target"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Back to action target</h2></div></div></div><p>Since I want to be most<a id="id116" class="indexterm"/> generic as possible in the event system, we need to modify our <code class="literal">ActionTarget</code> class a bit:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, the <code class="literal">ActionTaget</code> class needs to be linked to <code class="literal">ActionMap</code>. This will allow us to use multiple <code class="literal">ActionMap</code> in a single project, and this can be very interesting.</li><li class="listitem" style="list-style-type: disc">Moreover, because the action is now stored in <code class="literal">ActionMap</code>, <code class="literal">ActionTarget</code> doesn't need to store them anymore, but instead it needs to store the key to get them.</li><li class="listitem" style="list-style-type: disc">And finally, because <code class="literal">ActionMap</code> is a template class, we will need to turn <code class="literal">ActionTaget</code> into a template class too.</li></ul></div><p>The new header looks like this:</p><div class="informalexample"><pre class="programlisting">template&lt;typename T = int&gt;
class ActionTarget
{
    public:
        ActionTarget(const ActionTarget&lt;T&gt;&amp;) = delete;
        ActionTarget&lt;T&gt;&amp; operator=(const ActionTarget&lt;T&gt;&amp;) = delete;
    
        using FuncType = std::function&lt;void(const sf::Event&amp;)&gt;;
    
        ActionTarget(const ActionMap&lt;T&gt;&amp; map);
    
        bool processEvent(const sf::Event&amp; event)const;
        void processEvents()const;
    
        void bind(const T&amp; key,const FuncType&amp; callback);
        void unbind(const T&amp; key);
    
    private:
        std::list&lt;std::pair&lt;T,FuncType&gt;&gt; _eventsRealTime;
        std::list&lt;std::pair&lt;T,FuncType&gt;&gt; _eventsPoll;                                                                  

        const ActionMap&lt;T&gt;&amp; _actionMap;
};</pre></div><p>The major change is to turn all the references of the <code class="literal">Action</code> class to the template type. The action will now be identified by its key. Because we need to access the <code class="literal">Action</code> instances at runtime, we need to have a way to reach them.</p><p>Here, I use the SFML logic: one big object and a frontend class to use it. The big object is <code class="literal">ActionMap</code> and the frontend is <code class="literal">ActionTarget</code>. So, we internally store a reference to <code class="literal">ActionMap</code> used to store the events, and because we don't need to modify it, we make it as constant.</p><p>All these changes affect our class implementation. Instead of directly accessing an <code class="literal">Action</code> instance, we need to get it by calling <code class="literal">ActionMap::get()</code>, but nothing more difficult than this. The really important changes are made in the <code class="literal">Player</code> class, because now, we have the possibility to change the inputs at runtime, but we also need some default inputs, so we need to add a function to initialize the inputs.</p><p>Since a player<a id="id117" class="indexterm"/> doesn't have infinite possible control, we can create <code class="literal">enum</code> that will store all the keys that will be used in the code. For the moment, we have only one player, so we can present this function as static. The implication is that <code class="literal">ActionMap</code> internally used has to be static as well. This <code class="literal">ActionMap</code> will be added as a static attribute of the <code class="literal">Player</code> class. This is the new header of the class:</p><div class="informalexample"><pre class="programlisting">class Player : public sf::Drawable , public ActionTarget&lt;int&gt;
{
    public:
        Player(const Player&amp;) = delete;
        Player&amp; operator=(const Player&amp;) = delete;
        
        Player();
        
        template&lt;typename ... Args&gt;
        void setPosition(Args&amp;&amp; ... args);
        
        void processEvents();
        
        void update(sf::Time deltaTime);
        
        enum PlayerInputs {Up,Left,Right};
        static void setDefaultsInputs();
        
    private:
         virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
        
        sf::RectangleShape  _shape;
        sf::Vector2f        _velocity;
        
        bool _isMoving;
        int _rotation;
        
        static ActionMap&lt;int&gt; _playeInputs;
};</pre></div><p>As you can see, the <code class="literal">Player::PlayerInputs</code> enum, the <code class="literal">Player::setDefaultsInputs()</code> function, and the <code class="literal">Player::_playerInputs</code> attribute have been added. We also change the <code class="literal">ActionMap</code> type to <code class="literal">ActionMap&lt;int&gt;</code>, because we will use the newly created <code class="literal">enum</code> as a key; the default type of <code class="literal">enum</code> is <code class="literal">int</code>. The implementation of the player class does not change, except in the constructor. Instead of directly creating an action and <a id="id118" class="indexterm"/>binding it, we first initialize <code class="literal">ActionMap</code> (in <code class="literal">Player::setDefaultsInputs</code>) and then use the key store in <code class="literal">enum</code> to refer to the action.</p><p>So here is the new constructor:</p><div class="informalexample"><pre class="programlisting">Player::Player() : ActionTarget(_playerInputs)
                   ,_shape(sf::Vector2f(32,32))
                   ,_isMoving(false)
                   ,_rotation(0)
{
    _shape.setFillColor(sf::Color::Blue);
    _shape.setOrigin(16,16);
                                                       
    bind(PlayerInputs::Up,[this](const sf::Event&amp;){
         _isMoving = true;
    });
                                                       
    bind(PlayerInputs::Left,[this](const sf::Event&amp;){
         _rotation-= 1;
     });
                                                       
    bind(PlayerInputs::Right,[this](const sf::Event&amp;){
         _rotation+= 1;
     });
}</pre></div><p>As you can see, we also need to specify the <code class="literal">_playerInputs</code> parameter of the <code class="literal">ActionTarget</code> constructor, and we change all the <code class="literal">Action</code> constructions to their associated key:</p><div class="informalexample"><pre class="programlisting">void Player::setDefaultsInputs()
{
    _playerInputs.map(PlayerInputs::Up,Action(sf::Keyboard::Up));
    _playerInputs.map(PlayerInputs::Right,Action(sf::Keyboard::Right));
    _playerInputs.map(PlayerInputs::Left,Action(sf::Keyboard::Left));
}</pre></div><p>Here we simply initialize the <code class="literal">_playerInputs</code> with some default keys. These keys are similar to the previous ones, but because <code class="literal">_playerInputs</code> is a static member of the <code class="literal">Player</code> class it has to be created somewhere. A good practice is to define it in the <code class="literal">.cpp</code> file. So the last change in the <code class="literal">Player.cpp</code> file is this line:</p><div class="informalexample"><pre class="programlisting">ActionMap&lt;int&gt; Player::_playerInputs;</pre></div><p>This will create the object as expected.</p><p>We also need to initialize <code class="literal">ActionMap</code> by calling <code class="literal">Player::setDefaultsInputs()</code>. To do this, simply add this call to <code class="literal">main</code> before the game creation. The main should look like this by now:</p><div class="informalexample"><pre class="programlisting">int main(int argc,char* argv[])
{
    book::Player::setDefaultsInputs();

    book::Game game;
    game.run();

    return 0;
}</pre></div><p>The final result<a id="id119" class="indexterm"/> doesn't change, but I think that you can understand the power of the event system that has been created. It allows us to bind functionalities and change the key binding at runtime, this will be really useful in the future.</p><p>The result of the actual application should look like this:</p><div class="mediaobject"><img src="graphics/8477OS_02_06.jpg" alt="Back to action target"/></div><p>You should also be able to rotate the square using the right and left arrows of your keyboard, and make it move by pressing the up arrow. The next step will be to turn this stupid square into<a id="id120" class="indexterm"/> a nice spaceship.</p></div></div>
<div class="section" title="Keeping track of resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Keeping track of resources</h1></div></div></div><p>In general game development, the<a id="id121" class="indexterm"/> term <span class="strong"><strong>resource</strong></span> defines an external component that will be loaded at runtime within the application. Most of the time, a resource is a multimedia file such as music and image, but it can also be a script or a configuration file. Throughout this book, the term resource will mostly refer to a multimedia resource.</p><p>The resources require more memory, and one of the consequences of this is that all the operations on it run slowly, such as the copy. Another thing is that we don't want to have the same resource loaded multiple times in the memory. To avoid all this, we will use them in a particular way, with the help of a resource manager. Most of the time, a resource is loaded from a file to the hard disk, but there are other ways to load them, for example, from the <a id="id122" class="indexterm"/>memory or the network.</p><div class="section" title="Resources in SFML"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Resources in SFML</h2></div></div></div><p>The SFML library deals<a id="id123" class="indexterm"/> with a great numbers of different resources:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Graphics module</p>
</th><th style="text-align: left" valign="bottom">
<p>Audio module</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Texture</p>
</td><td style="text-align: left" valign="top">
<p>SoundBuffer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Image</p>
</td><td style="text-align: left" valign="top">
<p>Music</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Font</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Shader</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>All of these resources have some common points. Firstly, we can't use them directly as an output to the screen or the speakers. We have to use a frontend class that doesn't hold the data, but instead holds a reference to it. One of the implications is that the coping objects are quicker. Secondly, all these resource classes share the same SFML API (Application Programming Interface) with some deviations sometimes. A typical example is loading the resources from the hard disk, which has the following signature:</p><div class="informalexample"><pre class="programlisting">bool loadFomFile(const std::string &amp;filename);</pre></div><p>This function takes the complete path (relative or absolute) of the file to load, and returns <code class="literal">true</code> if the loading is successful and <code class="literal">false</code> if there is an error. It's very important to check the returned value to deal with the possible error, most of the time, an invalid path.</p><p>There are other versions of this type of member function that allows us to load the resource from different kinds of media. The function <code class="literal">bool loadFromMemory(const void *data, std::size_t size);</code> allows the user to load the resource from a RAM. A typical use of this function is to load the resource from hardcoded data. The other option with the SFML is to load the resource from a custom stream:</p><div class="informalexample"><pre class="programlisting">bool loadFromStream(sf::InputStream&amp; stream);</pre></div><p>This allows the user to fully define the load process. It can be used to load the data from a compressed or encrypted file, from the network, or from whatever device you want. But for now, we will focus on the file way (<code class="literal">loadFromFile()</code>) to design our future resources manager. Before <a id="id124" class="indexterm"/>starting to create it, take a look at each SFML resource class.</p><div class="section" title="The texture class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>The texture class</h3></div></div></div><p>The <code class="literal">sf::Texture</code> class represents<a id="id125" class="indexterm"/> an image as a pixel array. Each pixel is an<a id="id126" class="indexterm"/> <span class="strong"><strong>RGBA</strong></span> (<span class="strong"><strong>red, green, blue, alpha</strong></span>) value that defines the color at a specific position of the image. This pixel array is stored on the graphic card, in the video memory so it<a id="id127" class="indexterm"/> does not use any RAM. Because <code class="literal">sf::Texture</code> is stored in the video memory, the graphic card can access it quickly for each draw, but <code class="literal">sf::Texture</code> can't be manipulated (changed) as freely as <code class="literal">sf::Image</code> can. Every time we want to change it, we will need to reupload it on the video memory using the <code class="literal">sf::Texture::upload()</code> function. These operations are quite slow, so be careful when you use them. There are several common image formats sported by the SFML: <code class="literal">.bmp</code>, <code class="literal">.png</code>, <code class="literal">.tga</code>, <code class="literal">.jpg</code>, <code class="literal">.gif</code>, <code class="literal">.psd</code>, <code class="literal">.hdr</code>, and <code class="literal">.pic</code>. Notice that the <code class="literal">.png</code> images can be transparent, and can have an alpha channel to smooth edges again a transparent background.</p><p>The frontend class used to display <code class="literal">sf::Texture</code> is <code class="literal">sf::Sprite</code>. It's the texture representation with its own transformation, colors, and position. An important thing is that <code class="literal">sf::Texture</code> must be alive as long as <code class="literal">sf::Sprite</code> that used it is alive in order to avoid undefined behaviors. This is because <code class="literal">sf::Sprite</code> doesn't copy the texture data, but instead keeps a reference of it.</p></div><div class="section" title="The image class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>The image class</h3></div></div></div><p>The <code class="literal">sf::Image</code> class behaves<a id="id128" class="indexterm"/> as the <code class="literal">sf::Texture</code> class but with some important differences due to its storage. The<a id="id129" class="indexterm"/> pixel array is stored in the RAM instead of the graphic card. The implications are multiple. The first implication is that it's possible to modify each pixel of the image without any transfer. The second is that it's possible to save the image back to a file placed on the hard drive. The last is that it's not possible to directly display an image on the screen. We need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, convert it to <code class="literal">sf::Texture</code></li><li class="listitem">Then, create <code class="literal">sf::Sprite</code> referring to the texture</li><li class="listitem">Finally, display this sprite.</li></ol></div><p>Even if the entire image is not required for the display, it's possible to use only a part of it. So there is no waste of memory on the graphic card. The supported file formats are exactly the same for <code class="literal">sf::Texture</code> and <code class="literal">sf::Image</code>.</p><p>It's important to limit the use of <code class="literal">sf::Image</code> only when you really need it, for example, to modify a loaded image at runtime, to access any of its pixels, or to split it into multiple <code class="literal">sf::Texture</code> classes. In other cases, it's advisable to directly use <code class="literal">sf::Texture</code> for performance issues.</p></div><div class="section" title="The font class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec09"/>The font class</h3></div></div></div><p>The <code class="literal">sf::Font</code> class allows us to load and manipulate character fonts. Most of the common types of fonts are<a id="id130" class="indexterm"/> supported such as <code class="literal">TrueType</code>, <code class="literal">Type 1</code>, <code class="literal">CFF</code>, <code class="literal">OpenType</code>, <code class="literal">SFNT</code>, <code class="literal">X11 PCF</code>, <code class="literal">Windows FNT</code>, <code class="literal">BDF</code>, <code class="literal">PFR</code>, and <code class="literal">Type 42</code>. The <code class="literal">sf::Font</code> class holds the data, but it's not possible to use it directly. You will need to use the<a id="id131" class="indexterm"/> frontend class <code class="literal">sf::Text</code>, like <code class="literal">sf::Sprite</code> for <code class="literal">sf::Texture</code>. This class has some properties such as the font size, color, position, rotation, and so on. The <code class="literal">sf::Font</code> class must remain accessible as long as all of <code class="literal">sf::Text</code> that refer to it are alive.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>In SFML 2.1, there is no default font for <code class="literal">sf::Text</code>, so you need at least one font file to display them in your application. The default system font will not be used at all. Moreover, <code class="literal">sf:Text</code> is actually an object that inherits from <code class="literal">sf::Drawable</code>, and is physically represented by an OpenGL texture. You have to pay attention to the fact that updating the text every frame has a processing cost, and text needs to be updated only when it's changed.</p></div></div></div><div class="section" title="The shader class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>The shader class</h3></div></div></div><p>A shader is a <a id="id132" class="indexterm"/>program that will<a id="id133" class="indexterm"/> be executed directly on the graphic card, that is written in a specific language, GLSL, which is very similar to the C. There are two of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fragment shaders</strong></span>: This modifies the geometry of an object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pixel shaders</strong></span>: This modifies the pixel's value of the scene</li></ul></div><p>Shaders are really powerful, and allow us to apply some real-time manipulations on our scene, such as light. To use them, you only need to specify it on the <code class="literal">RenderTarget.draw(sf::drawable&amp;, sf::shader)</code> function.</p><p>I recommend you read the entire description of <code class="literal">sf::Shader</code> in the documentation before starting to use them.</p></div><div class="section" title="The sound buffer class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>The sound buffer class</h3></div></div></div><p>The <code class="literal">sf::SoundBuffer</code> class is used to<a id="id134" class="indexterm"/> store a sound effect. This class is especially <a id="id135" class="indexterm"/>designed to hold the entire audio sample in the memory as an array of 16 bits signed integers. Use it for short<a id="id136" class="indexterm"/> audio samples that require no latency and that can fit in the memory, for example, foot steps or gun shots.</p><p>Many audio formats are supported, such as <code class="literal">.ogg</code>, <code class="literal">.wav</code>, <code class="literal">.flac</code>, <code class="literal">.aiff</code>, <code class="literal">.au</code>, <code class="literal">.raw</code>, <code class="literal">.paf</code>, <code class="literal">.svx</code>, <code class="literal">.nist</code>, <code class="literal">.voc</code>, <code class="literal">.ircam</code>, <code class="literal">.w64</code>, <code class="literal">.mat4</code>, <code class="literal">.mat5 pvf</code>, <code class="literal">.htk</code>, <code class="literal">.sds</code>, <code class="literal">.avr</code>, <code class="literal">.sd2</code>, <code class="literal">.caf</code>, <code class="literal">.wve</code>, <code class="literal">.mpc2k</code>, and <code class="literal">.rf64</code>. Notice that the <code class="literal">.mp3</code> format is not supported because of its restrictive license.</p><p>Like <code class="literal">sf::Texture</code>, <code class="literal">sf::SoundBuffer</code> holds data, but does not allow us to play it directly. We need to use the <code class="literal">sf::Sound</code> class to do this. The <code class="literal">sf::Sound</code> class provides some common functionalities, such as play, stop, and pause but we can also change its volume, pitch, and position. A <code class="literal">sf::Sound</code> class refers to <code class="literal">ssf::SoundBuffer</code> that must stay valid as long as <code class="literal">sf::Sound</code> is <a id="id137" class="indexterm"/>played.</p></div><div class="section" title="The music class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>The music class</h3></div></div></div><p>The <code class="literal">sf::Music</code> class is the <a id="id138" class="indexterm"/>class used to play music. Unlike <code class="literal">sf::SoundBuffer</code> that is appropriate for short effects, <code class="literal">sf::Music</code> is designed to deal with long music themes. Themes are generally much<a id="id139" class="indexterm"/> longer than effects, and need a lot of memory to<a id="id140" class="indexterm"/> hold them completely. To overcome this, <code class="literal">sf::Music</code> does not load the entire resource at once, but, instead, streams it. This is really useful for large music files that take hundreds of MBs to avoid saturating the memory. Moreover, <code class="literal">sf::Music</code> has almost no loading delay.</p><p>Unlike other resources, <code class="literal">sf::Music</code> does not have any lightweight class. You can directly use it. It allows us to use the same features as <code class="literal">sf::SoundBuffer</code> and <code class="literal">sf::Sound</code> paired, such as play, pause, stop, request its parameters (channels and sample rate), and change the way it is played (pitch, volume, and 3D position).</p><p>As a sound stream, a music file is played in its own thread in order to not block the rest of the program. This means that you can leave the music file alone after calling <code class="literal">play()</code>, it will manage itself very well.</p></div></div><div class="section" title="Use case"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Use case</h2></div></div></div><p>Earlier in this chapter, I've<a id="id141" class="indexterm"/> explained that we will turn the blue square into a nice space ship. It's time to do that. Here is the result that will be obtained:</p><div class="mediaobject"><img src="graphics/8477OS_02_07.jpg" alt="Use case"/></div><p>It's not a big change, but<a id="id142" class="indexterm"/> it's a starting point for our future game.</p><p>To do this, we need to turn <code class="literal">sf::RectangleShape</code> that represents the <code class="literal">Player</code> class into <code class="literal">sf::Sprite</code>. We will also change the <code class="literal">_shape</code> attribute name into <code class="literal">_ship</code>; but there is an issue: where is the texture used to store the ship image? To make an attribute of the player of it can be a solution because there is only one player, but we will use another approach: a resources manager.</p><p>Before starting to<a id="id143" class="indexterm"/> create the manager, let's talk about the <span class="strong"><strong>Resource Acquisition Is Initialization</strong></span> (<span class="strong"><strong>RAII</strong></span>) idiom.</p></div><div class="section" title="RAII idiom"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>RAII idiom</h2></div></div></div><p>RAII is a principle in which a resource is acquired and released with a class construction and destruction, because<a id="id144" class="indexterm"/> these two functions are automatically called. It has<a id="id145" class="indexterm"/> the advantage over the manual management to be executed every time, even when some exceptions occur. It's <a id="id146" class="indexterm"/>used with the smart pointer classes in the C++11, and can be performed with every type of resource such as files, or in our case, SFML resources.</p></div><div class="section" title="Building a resources manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Building a resources manager</h2></div></div></div><p>The goal of a resources<a id="id147" class="indexterm"/> manager is to manage the resources and ensure that all the resources are loaded only once to avoid any more copies.</p><p>As previously mentioned, we focus on the resources loaded from the hard drive, so a good way to avoid any duplication is to use an identifier for the resource.</p><p>We will use <code class="literal">std::unordered_map</code> again, and build a wrapper around it, as the <code class="literal">ActionMap</code> class. Because SFML provides a lot of different types of resources, and I don't want to make one for each of them, I will build the resources manager as a template class again. But this time, the template type will be the resource and the key type. We will use the RAII idiom to automate the load and release the resources.</p><p>The class looks like this:</p><div class="informalexample"><pre class="programlisting">template&lt;typename RESOURCE,typename IDENTIFIER = int&gt;
class ResourceManager
{
    public:
        ResourceManager(const ResourceManager&amp;) = delete;
        ResourceManager&amp; operator=(const ResourceManager&amp;) = delete;
                                                                       
        ResourceManager() = default;
                                                                       
        template&lt;typename ... Args&gt;
        void load(const IDENTIFIER&amp; id,Args&amp;&amp; ... args);
                                                                       
        RESOURCE&amp; get(const IDENTIFIER&amp; id)const;
                                                                       
    private:
        std::unordered_map&lt;IDENTIFIER,std::unique_ptr&lt;RESOURCE&gt;&gt; _map;
};</pre></div><p>We make the class in such a manner that it cannot be copied, and create some functions to load a resource, and another one to get it. Because all the SFML resource classes don't have the exact same parameters for the <code class="literal">loadFromFile()</code> function (<code class="literal">sf::Shader</code>), I decided to use a template that will forward the arguments exactly as <code class="literal">Player::setPosition()</code>.</p><p>Moreover, some classes cannot be copied, so we need to use a pointer to store them in a container. Because of the RAII idiom, the choice has been made to use the <code class="literal">std::unique_ptr</code> template class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>A new class from the C++11 is <code class="literal">std::unique_ptr</code> and it is one of the smart pointers. Its internals use the RAII idiom, so we don't need to manage the memory deallocation.</p></div></div><p>Now the<a id="id148" class="indexterm"/> implementation is as follows:</p><div class="informalexample"><pre class="programlisting">template&lt;typename RESOURCE,typename IDENTIFIER&gt;
template&lt;typename ... Args&gt;
void ResourceManager&lt;RESOURCE,IDENTIFIER&gt;::load(const IDENTIFIER&amp; id,Args&amp;&amp; ... args)
{
    std::unique_ptr&lt;RESOURCE&gt; ptr(new RESOURCE);
    if(not ptr-&gt;loadFromFile(std::forward&lt;Args&gt;(args)...))
        throw std::runtime_error("Impossible to load file");
    _map.emplace(id,std::move(ptr));
}</pre></div><p>A feature from the C++11 is <code class="literal">std::move</code> and it allows us to use the <code class="literal">move</code> constructor instead of the <code class="literal">copy</code> constructor. The <code class="literal">std::unique_ptr</code> template class supports the type of constructor, so using it seems to be a good idea. The idea under the move semantic is to dump a temporary object by taking its content instead of copying it. The result is a gain in performance.</p><p>Here, we create a new resource using the template parameter <code class="literal">RESOURCE</code> as <code class="literal">std::unique_ptr</code>. Then we load the resource from the hard drive using the parameter pack <code class="literal">args</code>. Finally, we store it internally.</p><p>Notice that if the load fails, an exception is thrown rather than returning <code class="literal">false</code> as value:</p><div class="informalexample"><pre class="programlisting">template&lt;typename RESOURCE,typename IDENTIFIER&gt;
RESOURCE&amp; ResourceManager&lt;RESOURCE,IDENTIFIER&gt;::get(const IDENTIFIER&amp; id)const
{
    return *_map.at(id);
}</pre></div><p>This function simply delegates the job to the <code class="literal">std::unordered_map::at()</code> function by passing the <code class="literal">id</code> argument to it. The <code class="literal">::at()</code> method throws an exception when no object is found.</p><p>Because our actual <code class="literal">ResourceManager</code> class uses <code class="literal">loadFromFile()</code> in the <code class="literal">load()</code> method, we have a problem with the <code class="literal">sf::Music</code> class. <code class="literal">LoadFromFile()</code>, which doesn't exist in the <code class="literal">sf::Music</code> class and is replaced with <code class="literal">openFromFile()</code>. So we need to fix that.</p><p>To do this, we will use the <code class="literal">partial</code> specialization. The partial specialization is a technical used in template programming to make some special case, exactly like this one. We need to specialize the <code class="literal">load()</code> method when <code class="literal">RESOURCE</code> is set to <code class="literal">sf::Music</code>. The problem is that we can't do it directly because the <code class="literal">ResourceManager</code> class has two template parameters, and the other one doesn't need to<a id="id149" class="indexterm"/> be fixed. So instead, we have to specialize the entire class by creating a new one:</p><div class="informalexample"><pre class="programlisting">template&lt;typename IDENTIFIER&gt;
class ResourceManager&lt;sf::Music,IDENTIFIER&gt;
{
    public:
        ResourceManager(const ResourceManager&amp;) = delete;
        ResourceManager&amp; operator=(const ResourceManager&amp;) = delete;
    
        ResourceManager() = default;
    
        template&lt;typename ... Args&gt;
        void load(const IDENTIFIER&amp; id,Args&amp;&amp; ... args);
    
        sf::Music&amp; get(const IDENTIFIER&amp; id)const;
    
    private:
        std::unordered_map&lt;IDENTIFIER,std::unique_ptr&lt;sf::Music&gt;&gt; _map;
};</pre></div><p>This class is the replica of the previous one, except that we have removed one template parameter to fix it to <code class="literal">sf::Music</code>. Here is the implementation:</p><div class="informalexample"><pre class="programlisting">template&lt;typename IDENTIFIER&gt;
template&lt;typename ... Args&gt;
void ResourceManager&lt;sf::Music,IDENTIFIER&gt;::load(const IDENTIFIER&amp; id,Args&amp;&amp; ... args)
{
    std::unique_ptr&lt;sf::Music&gt; ptr(new sf::Music);
                                                                                       
    if(not ptr-&gt;openFromFile(std::forward&lt;Args&gt;(args)...))
        throw std::runtime_error("Impossible to load file");
    _map.emplace(id,std::move(ptr));
};
                    
template&lt;typename IDENTIFIER&gt;
sf::Music&amp; ResourceManager&lt;sf::Music,IDENTIFIER&gt;::get(const IDENTIFIER&amp; id) const
{
    return *_map.at(id);
}</pre></div><p>Here again, this is exactly the same, except that we have changed <code class="literal">loadFromFile()</code> to <code class="literal">openFromFile()</code>.</p><p>Finally, one class<a id="id150" class="indexterm"/> with a specialization has been constructed to deal with all the SFML resources types, and use the RAII idiom to free memory when required.</p><p>The next step is to use this class to change the appearance of the player.</p></div><div class="section" title="Changing the player's skin"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Changing the player's skin</h2></div></div></div><p>Now that we have built a nice<a id="id151" class="indexterm"/> system to manage any kind of resource, let's use them. As previously mentioned, to change the player's square into a ship, we need to change <code class="literal">sf::RectangleShapethat</code>, represent the <code class="literal">Player</code> class in <code class="literal">sf::Sprite</code>, and then set the texture source of <code class="literal">sf::Sprite</code> loaded by the texture manager. So we need a texture manager.</p><p>If we think about it, all the managers will be global to our application, so we will group them into a static class named <code class="literal">Configuration</code>. This class will hold all the game configurations and the managers. <code class="literal">ActionMap</code> can also be stored inside this class, so we will move <code class="literal">ActionMap</code> inside the player into this new class, and create an <code class="literal">initialize()</code> method to initialize all the inputs and textures.</p><p>This class is really simple, and can't be instantiated, so all the attributes and methods will be static:</p><div class="informalexample"><pre class="programlisting">class Configuration
{
    public:
        Configuration() = delete;
        Configuration(const Configuration&amp;) = delete;
        Configuration&amp; operator=(const Configuration&amp;) = delete;
    
        enum Textures : int {Player};
        static ResourceManager&lt;sf::Texture,int&gt; textures;
    
        enum PlayerInputs : int {Up,Left,Right};
        static ActionMap&lt;int&gt; player_inputs;
    
        static void initialize();
    
    private:
        
        static void initTextures();       
        static void initPlayerInputs();
};</pre></div><p>As you can see, the class is not really difficult. We only move the <code class="literal">_playerInputs</code> and <code class="literal">enum</code> from the <code class="literal">Player</code> class<a id="id152" class="indexterm"/> and add <code class="literal">ResourceManager</code> for textures. Here is the implementation:</p><div class="informalexample"><pre class="programlisting">ResourceManager&lt;sf::Texture,int&gt; Configuration::textures;
ActionMap&lt;int&gt; Configuration::player_inputs;
                                                                        
void Configuration::initialize()
{
    initTextures();
    initPlayerInputs();
}
           
void Configuration::initTextures()
{
    textures.load(Textures::Player,"media/Player/Ship.png");
}
           
void Configuration::initPlayerInputs()
{
    player_inputs.map(PlayerInputs::Up,Action(sf::Keyboard::Up));
    player_inputs.map(PlayerInputs::Right,Action(sf::Keyboard::Right));
    player_inputs.map(PlayerInputs::Left,Action(sf::Keyboard::Left));
}</pre></div><p>Here again, the code is simple. We now have just a few changes to make in the player class to draw it as a spaceship. We need to replace <code class="literal">sf::RectangleShape _shape</code> with <code class="literal">sf::Sprite _ship;</code>.</p><p>In the constructor, we need to set the texture and the origin of the sprite as follows:</p><div class="informalexample"><pre class="programlisting">_ship.setTexture(Configuration::textures.get(Configuration::Textures::Player));
_ship.setOrigin(49.5,37.5);</pre></div><p>Don't forget to call <code class="literal">Configuration::initialize()</code> from <code class="literal">main()</code> before anything else. We now have a nice spaceship as a player.</p><p>There is a lot of code and different classes to get this result, but if you think about it, this will really help us in the future, and reduce the number of code lines in our final applications.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we covered the general game architecture, the input management, and the resources. You also learned about the RAII idiom and some C++11 features such as lambda, variadic templates, smart pointers, move syntax, and perfect forwarding.</p><p>All the basic building blocks are now set up, so in the next chapter, we will make complete games by completing the current application to raise it to the asteroid game, and we will also build a Tetris game.</p></div></body></html>