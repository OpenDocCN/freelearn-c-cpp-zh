- en: Chapter 5. Physics Damping, Friction, and Physics Bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a deeper look at **Physics Bodies** in Unreal
    Engine 4 and analyze how the engine uses physics properties, such as **Angular
    Damping** and **Linear Friction** to simulate real-world physics in our game.
    To start with, we will examine what **Physics Bodies** are. We will also look
    at some of the detailed properties available to these assets. In addition, we
    will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular and linear friction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical materials – an overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics damping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will continue to work with Unreal Engine
    4 and the **Unreal_PhyProject** that we created in [Chapter 1](part0014.xhtml#aid-DB7S1
    "Chapter 1. Math and Physics Primer"), *Math and Physics Primer* in Unreal Engine.
    Let's begin by discussing **Physics Bodies** in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Physics Bodies – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to creating **Physics Bodies**, there are multiple ways to go
    about it (most of which we have covered up to this point), so we will not go into
    much detail about the creation of **Physics Bodies**. We can have **Static Meshes**
    react as **Physics Bodies** by checking the **Simulate Physics** property of the
    asset when it is placed in our level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics Bodies – an overview](img/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can also create **Physics Bodies** by creating **Physics Assets** and **Skeletal
    Meshes**, which automatically have the properties of physics by default. Lastly,
    **Shape Components** in blueprints, such as spheres, boxes, and capsules will
    automatically gain the properties of a Physics Body if they are set for any sort
    of collision, overlap, or other physics simulation events. As always, remember
    to ensure that our asset has a collision applied to it before attempting to simulate
    physics or establish **Physics Bodies**, otherwise the simulation will not work.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with the properties of **Physics** on **Static Meshes** or any
    other assets that we will attempt to simulate physics with, we will see a handful
    of different parameters that we can change in order to produce the desired effect
    under the **Details** panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics Bodies – an overview](img/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s break down these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simulate Physics**: This parameter allows you to enable or simulate physics
    with the asset you have selected. When this option is unchecked, the asset will
    remain static, and once enabled, we can edit the **Physics Body** properties for
    additional customization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Weld**: When this property is set to `True`, and when the asset is attached
    to a parent object, such as in a blueprint, the two bodies are merged into a single
    rigid body. **Physics** settings, such as collision profiles and body settings,
    are determined by **Root Component**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Awake**: This parameter determines whether the selected asset will
    **Simulate Physics** at the start once it is spawned or whether it will **Simulate
    Physics** at a later time. We can change this parameter with the level and actor
    blueprints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override Mass**: When this property is checked and set to `True`, we can
    then freely change the **Mass** of our asset using **kilograms** (**kg**). Otherwise,
    the **Mass in Kg** parameter will be set to a default value that is based on a
    computation between the physical material applied and the mass scale value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass in Kg**: This parameter determines the **Mass** of the selected asset
    using kilograms. This is important when you work with different sized physics
    objects and want them to react to forces appropriately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locked Axis**: This parameter allows you to lock the physical movement of
    our object along a specified axis. We have the choice to lock the default axes
    as specified in **Project Settings**. We also have the choice to lock physical
    movement along the individual *X*, *Y*, and *Z* axes. We can have none of the
    axes either locked in translation or rotation, or we can customize each axis individually
    with the **Custom** option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable Gravity**: This parameter determines whether the object should have
    the force of gravity applied to it. The force of gravity can be altered in the
    **World Settings** properties of the level or in the **Physics** section of the
    **Engine** properties in **Project Settings**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Async Scene**: This property allows you to enable the use of **Asynchronous
    Physics** for the specified object. By default, we cannot edit this property.
    In order to do so, we must navigate to **Project Settings** and then to the **Physics**
    section. Under the advanced **Simulation** tab, we will find the **Enable Async
    Scene** parameter. In an asynchronous scene, objects (such as **Destructible**
    actors) are simulated, and a **Synchronous** scene is where classic physics tasks,
    such as a falling crate, take place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override Walkable Slope on Instance**: This parameter determines whether
    or not we can customize an object''s walkable slope. In general, we would use
    this parameter for our player character, but this property enables the customization
    of how steep a slope is that an object can walk on. This can be controlled specifically
    by the **Walkable Slope Angle** parameter and the **Walkable Slope Behavior**
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override Max Depenetration Velocity**: This parameter allows you to customize
    **Max Depenetration Velocity** of the selected physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Center of Mass Offset**: This property allows you to specify a specific vector
    offset for the selected objects'' center of mass from the calculated location.
    Being able to know and even modify the center of the mass for our objects can
    be very useful when you work with sensitive physics simulations (such as flight).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sleep Family**: This parameter allows you to control the set of functions
    that the physics object uses when in a sleep mode or when the object is moving
    and slowly coming to a stop. The **SF Sensitive** option contains values with
    a lower sleep threshold. This is best used for objects that can move very slowly
    or for improved physics simulations (such as billiards). The **SF Normal** option
    contains values with a higher sleep threshold, and objects will come to a stop
    in a more abrupt manner once in motion as compared to the **SF Sensitive** option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass Scale**: This parameter allows you to scale the mass of our object by
    multiplying a scalar value. The lower the number, the lower the mass of the object
    will become, whereas the larger the number, the larger the mass of the object
    will become. This property can be used in conjunction with the **Mass in Kg**
    parameter to add more customization to the mass of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Damping**: This property is a modifier of the drag force that is
    applied to the object in order to reduce angular movement, which means to reduce
    the rotation of the object. We will go into more detail regarding **Angular Damping**
    later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Damping**: This property is used to simulate the different types of
    friction that can assist in the game world. This modifier adds a drag force to
    reduce linear movement, reducing the translation of the object. We will go into
    more detail regarding **Linear Damping** later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Angular Velocity**: This parameter limits **Max Angular Velocity** of
    the selected object in order to prevent the object from rotating at high rates.
    By increasing this value, the object will spin at very high speeds once it is
    impacted by an outside force that is strong enough to reach the **Max Angular
    Velocity** value. By decreasing this value, the object will not rotate as fast,
    and it will come to a halt much faster depending on the angular damping applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Position Solver Iteration Count**: This parameter reflects the physics body''s
    solver iteration count for its position; the solver iteration count is responsible
    for periodically checking the physics body''s position. Increasing this value
    will be more CPU intensive, but better stabilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Velocity Solver Iteration Count**: This parameter reflects the physics body''s
    solver iteration count for its velocity; the solver iteration count is responsible
    for periodically checking the physics body''s velocity. Increasing this value
    will be more CPU intensive, but better stabilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have discussed all the different parameters available to **Physics
    Bodies** in Unreal Engine 4, feel free to play around with these values in order
    to obtain a stronger grasp of what each property controls and how it affects the
    physical properties of the object. As there are a handful of properties, we will
    not go into detailed examples of each, but the best way to learn more is to experiment
    with these values. However, we will work with how to create various examples of
    physics bodies in order to explore **Physics Damping** and **Friction** later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Physics Bodies – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discussed what **Physics Bodies** are and how to create
    them by using static meshes, skeletal meshes, shape components in blueprints,
    and physics assets. Additionally, you learned about all the different parameters
    that exist for **Physics Bodies** in Unreal Engine 4\. We also looked at each
    property and how it affects the physics on the specified object. Now that we have
    a stronger grasp of what **Physics Bodies** are, let's move on and discuss **Angular**
    and **Linear Damping**.
  prefs: []
  type: TYPE_NORMAL
- en: Angular and Linear Damping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss **Angular** and **Linear Damping** in more
    detail, focusing on the friction properties of physics bodies. Further more, we
    will discuss physics damping and how this can be used when setting up the constraints
    for our blueprints. Let's begin by briefly discussing **Angular Damping** and
    **Angular Velocity/Momentum**.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of physics, **Angular Velocity** is defined as the rate of change
    of angular displacement, also known as a vector quantity, which specifies the
    angular speed or the rotational speed of an object and the axis in which the object
    is rotating.
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular and Linear Damping](img/image00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see that **w,** or the angular speed, is equal
    to the velocity divided by the radius of the object that is rotating.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear Angular Momentum** is proportional to **Moment of Inertia** (*I*)
    and **Angular Speed** (*w*), so the basic formula is *L = Iw*. We now know that
    *w* is equal to the velocity and radius of the object, so we can now write the
    expression as *L = I (v/r)*. Lastly, **Moment of Inertia** is equal to the radius
    of the object squared, multiplied by the object''s mass, or *I = r^2 * (m)*. With
    this in mind, we can now rewrite the **Linear Angular Momentum** expression as
    *L = (r^2 * m) * (v/r)*, or more simply, we can write the expression as *L = rmv*,
    so the **Linear Angular Momentum** of an object is equal to the radius of the
    object multiplied by its mass and the velocity that is applied to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a stronger understanding of **Angular Velocity** and **Angular
    Momentum**, let's apply this knowledge to the physics body with the **Unreal_PhyProject**
    game project that we created in the first chapter. By default, there are a bunch
    of physics body cubes placed throughout the **FirstPersonExampleMap** level that
    we can alter properties to in order to explore **Angular Damping** and **Angular
    Velocity**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by selecting a random cube from **FirstPersonExampleMap** and viewing
    its **Physics** properties in **Details** panel, on the left-hand side. For the
    sake of an example, let's left-click on the down directional arrow in the **Physics**
    section to expand the advanced properties. The first property we will see is **Enable
    Gravity**, and by default, it is set to `True`; let's set this property to `False`
    so that the selected physics body doesn't have the force of gravity applied to
    it. With this change in place, we can now move the physics body upwards in the
    *Z* direction so that it floats in the level in mid-air. Now, if we play the game,
    the physics body will not move unless it is shot at by the player with the **FirstPersonProjectile**
    blueprint. Once shot, the physics body will start spinning and moving in the appropriate
    direction based on where it's shot and the impulse that is applied to it by the
    projectile blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the **Details** panel of **Physics Body**, we can now explore the **Angular
    Damping** property, which is set to `0` by default, meaning that the object has
    no additional drag force applied to it to reduce angular velocity. By increasing
    this value, we can see that when we shoot the object in the game, the angular
    velocity slows down in a stronger exponential value compared to how it behaved
    when the **Angular Damping** value was set to `0`. We can also set the limit on
    how fast the physics object can rotate when a force is applied to it by altering
    the value of the **Max Angular Velocity** parameter; the higher the value, the
    faster the object is able to rotate if enough force is applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let''s set the **Angular Damping** value to `.01` and, the
    **Max Angular Velocity** parameter to `800`. We will override the **Mass in Kg**
    parameter and set a custom mass of `10.0`. We should now have the following properties
    in place for our physics body object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular and Linear Damping](img/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if we play the game and shoot at our **Physics Body** object, we will see
    that the object can rotate at a very quick rate when shot at by the player. To
    find out what else can affect the **Angular Velocity** and **Angular Damping**
    of an object, we can increase or decrease the values for the **Mass in Kg**, **Angular
    Damping**, and **Max Angular Velocity** parameters. With the knowledge of **Angular
    Damping** and **Angular Physics** under our belt, let's now discuss **Linear Damping**
    and **Linear Physics** in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: In physics, **Linear Velocity** is defined as the rate of the change of linear
    displacement of time, also known as a vector quantity, which specifies the linear
    speed of an object and the direction in which the object is moving in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular and Linear Damping](img/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The formula for basic **Linear Velocity** is *V = S/t*, or velocity equals the
    change in displacement of the object divided by the time the object takes to move
    this change in displacement. The concept of **Linear Damping** is the reduction
    of movement over time in order to have an object come to a complete stop once
    a force is applied to it that would cause displacement, also known as **Friction**.
    When it comes to **Linear Momentum**, the formula is *p = mv*, where *p* is the
    value of **Momentum**, *m* is the value of the object's mass, and *v* is the velocity
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine 4, we can damper the linear velocity of our physics body in
    two ways: by creating a **Physical Material** to apply to our physics body or
    by changing the **Linear Damping** property in the **Physics** section of the
    **Details** panel of our physics body. For the purposes of this section, we will
    only discuss how to change the **Linear Damping** property and we will go into
    more detail on how to create **Physical Material** later in this chapter. Working
    with **FirstPersonExampleMap** in **Unreal_PhyProject**, let''s go ahead and create
    a working example of how to properly utilize the **Linear Damping** property for
    our physics bodies in order to recreate **Friction**. For this example, we can
    use the same physics body that we used to demonstrate angular velocity and angular
    damping, but we do want to make sure that we check the **Enable Gravity** parameter
    and set the rest of the parameters to their default values so that we can start
    this example from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: By increasing the value of the **Linear Damping** property to a value such as
    `100` and playing the game, we will see that when we shoot the physics body, it
    does not translate as much as it would if the **Linear Damping** property was
    set to its default value of `.01`. With the value of `100`, the **Linear Damping**
    property causes the physics body to almost stay where it is, but the rotation
    of the object changes as normal because we did not change the properties involving
    angular damping. The use of **Linear Damping** is very straightforward, and there
    is not much customization passed (as discussed in the context of physics bodies
    in their **Physics** properties), but we can add additional properties using **Physics
    Materials**.
  prefs: []
  type: TYPE_NORMAL
- en: Angular and Linear Damping – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discussed the concepts of **Angular** and **Linear Damping**
    and **Angular** and **Linear Velocities** in the context of real-world physics
    in detail. Once we were able to grasp these concepts, we then applied what you
    learned about using physics bodies in Unreal Engine 4 and the **Physics** properties
    of these objects in order to explore how they affect the physics bodies in the
    game. Now that we have examined angular and linear damping, we can move on to
    briefly discuss what **Physics Materials** are and how to apply them to our physics
    bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Physical Materials – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Physical** **Materials** are assets that are used to define the response
    of a physics body when you dynamically interact with the game world. When you
    first create **Physical Material**, you are presented with a set of default values
    that are identical to the default **Physical Material** that is applied to all
    physics objects.'
  prefs: []
  type: TYPE_NORMAL
- en: To create **Physical Material**, let's navigate to **Content Browser** and select
    the **Content** folder so that it is highlighted. From here, we can right-click
    on the **Content** folder and select the **New Folder** option to create a new
    folder for our **Physical Material**; name this new folder `PhysicalMaterials`.
    Now, in the `PhysicalMaterials` folder, right-click on the empty area of **Content
    Browser** and navigate to the **Physics** section and select **Physical Material**.
    Make sure to name this new asset `PM_Test`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Physical Materials – an overview](img/image00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Double-click on the new **Physical Material** asset to open **Generic Asset
    Editor** and we should see the following values that we can edit in order to make
    our physics objects behave in certain ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physical Materials – an overview](img/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a few minutes to break down each of these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Friction**: This parameter controls how easily objects can slide on this
    surface. The lower the friction value, the more slippery the surface. The higher
    the friction value, the less slippery the surface. For example, ice would have
    a **Friction** surface value of `.05`, whereas a **Friction** surface value of
    `1` would cause the object not to slip as much once moved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction Combine Mode**: This parameter controls how friction is computed
    for multiple materials. This property is important when it comes to interactions
    between multiple physical materials and how we want these calculations to be made.
    Our choices are **Average**, **Minimum**, **Maximum**, and **Multiply**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override Friction Combine Mode**: This parameter allows you to set the **Friction**
    **Combine Mode** parameter instead of using **Friction Combine Mode**, found in
    the **Project Settings** | **Engine** | **Physics** section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restitution**: This parameter controls how bouncy the surface is. The higher
    the value, the more bouncy the surface will become.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Density**: This parameter is used in conjunction with the shape of the object
    to calculate its mass properties. The higher the number, the heavier the object
    becomes (in grams per cubic centimeter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raise Mass to Power**: This parameter is used to adjust the way in which
    the mass increases as the object gets larger. This is applied to the mass that
    is calculated based on a solid object. In actuality, larger objects do not tend
    to be solid and become more like shells (such as a vehicle). The values are clamped
    to `1` or less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destructible Damage Threshold Scale**: This parameter is used to scale the
    damage threshold for the destructible objects that this physical material is applied
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surface Type**: This parameter is used to describe what type of real-world
    surface we are trying to imitate for our project. We can edit these values by
    navigating to the **Project Settings** | **Physics** | **Physical Surface** section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tire Friction Scale**: This parameter is used as the overall tire friction
    scalar for every type of tire and is multiplied by the parent values of the tire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tire Friction Scales**: This parameter is almost identical to the **Tire
    Friction Scale** parameter, but it looks for a **Tire Type** data asset to associate
    it to. **Tire Types** can be created through the use of **Data Assets** by right-clicking
    on the **Content Browser** | **Miscellaneous** | **Data Asset** | **Tire Type**
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have briefly discussed how to create **Physical Materials** and
    what their properties are, let's take a look at how to apply **Physical Materials**
    to our physics bodies. In **FirstPersonExampleMap**, we can select any of the
    physics body cubes throughout the level and in the **Details** panel under **Collision**,
    we will find the **Phys Material Override** parameter. It is here that we can
    apply our **Physical Material** to the cube and view how it reacts to our game
    world.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of an example, let's return to the **Physical Material**, `PM_Test`,
    that we created earlier, change the **Friction** property from `0.7` to `0.2`,
    and save it. With this change in place, let's select a physics body cube in **FirstPersonExampleMap**
    and apply the **Physical Material**, `PM_Test`, to the **Phys Material Override**
    parameter of the object. Now, if we play the game, we will see that the cube we
    applied the **Physical Material**, `PM_Test`, to will start to slide more once
    shot by the player than it did when it had a **Friction** value of `0.7`. We can
    also apply this **Physical Material** to the floor mesh in **FirstPersonExampleMap**
    to see how it affects the other physics bodies in our game world. From here, feel
    free to play around with the **Physical Material** parameters to see how we can
    affect the physics bodies in our game world.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let's briefly discuss how to apply **Physical Materials** to normal
    **Materials**, **Material Instances**, and **Skeletal Meshes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply **Physical Material** to a normal material, we first need to either
    create or open an already created material in **Content Browser**. To create a
    material, just right-click on an empty area of **Content** **Browser** and select
    **Material** from the drop-down menu.Double-click on **Material** to open **Material
    Editor**, and we will see the parameter for **Phys Material** under the **Physical
    Material** section of **Details** panel in the bottom-left of **Material Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physical Materials – an overview](img/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To apply **Physical Material** to **Material Instance**, we first need to create
    **Material Instance** by navigating to **Content Browser** and right-clicking
    on an empty area to bring up the context drop-down menu. Under the **Materials
    & Textures** section, we will find an option for **Material Instance**. Double-click
    on this option to open **Material Instance Editor**. Under the **Details** panel
    in the top-left corner of this editor, we will find an option to apply **Phys
    Material** under the **General** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physical Materials – an overview](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, to apply **Physical Material** to **Skeletal Mesh**, we need to either
    create or open an already created **Physics Asset** that contains **Skeletal Mesh**.
    In the **First Person Shooter Project** template, we can find **TutorialTPP_PhysicsAsset**
    under the **Engine Content** folder. If the **Engine Content** folder is not visible
    by default in **Content Browser**, we need to simply navigate to **View Options**
    in the bottom-right corner of **Content Browser** and check the **Show Engine
    Content** parameter. Under the **Engine Content** folder, we can navigate to the
    **Tutorial** folder and then to the **TutorialAssets** folder to find the **TutorialTPP_PhysicsAsset**
    asset. Double-click on this asset to open **Physical Asset Tool**. Now, we can
    click on any of the body parts found on **Skeletal Mesh** to highlight it. Once
    this is highlighted, we can view the option for **Simple Collision Physical Material**
    in the **Details** panel under the **Physics** section. Here, we can apply any
    of our **Physical Materials** to this body part.
  prefs: []
  type: TYPE_NORMAL
- en: '![Physical Materials – an overview](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Physical Materials – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discussed in detail what **Physical Materials** are and
    what their parameters mean when applying them to a physics body. Additionally,
    we explored how to apply **Physical Materials** to physics bodies, **Materials**,
    **Material Instances**, and **Skeletal Meshes** in **Physical Asset Tool**. Now
    that we have a better understanding of **Physical Materials**, we can now conclude
    this chapter by working with **Constraints** in blueprints to better understand
    **Physics Damping**.
  prefs: []
  type: TYPE_NORMAL
- en: Physics Damping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to gain a stronger grasp of **Physics Damping** in Unreal Engine 4,
    we will create a simple working example of **Constraints** with blueprints. To
    start with, let's continue our work in the **Unreal_PhyProject** project, navigate
    to **Content Browser** and then to the **Blueprints** folder, and right-click
    on it to create a new **Actor** blueprint. Let's name this blueprint `BP_Constraint`
    and double-click on it to open **Blueprint Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: To begin this blueprint, let's navigate to the **Viewport** tab and then add
    **Scene Component** to the **Components** tab using the **Add Component** context
    sensitive drop-down menu. Name this component `ROOT`. Next, we will add two cube
    meshes from the **Basic Shapes** section to the **Add Components** menu. Name
    one `Stable Mesh` and the other `Constrained Mesh`. Lastly, let's add a **Physics
    Constraint** component from the **Physics** section and name it `Physics Constraint`.
    Now, we need to position these components in a manner that will better showcase
    how to use physics damping in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the position of our assets in the **Viewport** tab of our blueprint as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable Mesh**: `X – 0.0`, `Y – 0.0`, and `Z – 350.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constrained Mesh**: `X – 120.0`, `Y – 0.0`, `Z – 0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Constraint**: `X – 0.0`, `Y – 0.0`, `Z – 340.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will need to set the default parameters to our **Physics Constraint**
    asset so that it recognizes the mesh that is the anchor. The other mesh is the
    free-hanging pendulum attached to it. To accomplish this, let''s select the **Physics
    Constraint** component. Then, in its **Details** panel, we will find the parameters
    for **Component Name 1** and **Component Name 2** under the **Constraint** section.
    For these parameters, we will need to apply the names of the two meshes that we
    will use for our constraint: `Stable Mesh` and `Constrained Mesh`. Set these parameters
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component Name 1**: `Stable Mesh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component Name 2**: `Constrained Mesh`![Physics Damping](img/image00304.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these parameters in place, we can now place our **BP_Constraint** in **FirstPersonExampleMap**
    to see the constraint in action. First, make sure to compile and save the blueprint
    before placing this blueprint in our level. Once this is placed in our level,
    make sure to lift the blueprint well off the ground so that there won''t be any
    collision or clipping between the constrained assets and our game world, and when
    we can play the game to see how the constraint works, we will see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics Damping](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will see that the swinging cube will continue to swing back and forth for
    eternity without any sign of damping or friction to slow it down. Let''s change
    this. Then, navigate back to the **BP_Constraint** blueprint and select the **Physics
    Constraint** component. In the **Details** panel, we will see a handful of parameters
    that we can change to the constraint in order to affect its behavior. Let''s briefly
    define each parameter found in the **Details** panel of the **Physics Constraint
    component**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component Name 1**: This parameter requires the name of the first component
    property to constrain. If this is left empty, the name parameter will search in
    its **Owner** for a parameter name. If **Owner** returns null, this parameter
    will use the **Root Component** of **Actor 1**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component Name 2**: This parameter requires the name of the second component
    property to constrain. If this is left empty, the name parameter will search in
    its **Owner** for a parameter name. If **Owner** returns null, this parameter
    will use the **Root Component** of **Actor 2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Joint Name**: This parameter is used when you work with **Skeletal Meshes**
    and requires the name of **Bone** that **Joint** is attached to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constraint Bone 1**: This parameter requires the name of the first bone (body)
    that this constraint is connecting to and would be the child bone in **Physics
    Asset**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constraint Bone 2**: This parameter requires the name of the second bone
    (body) that this constraint is connecting to and would be the parent bone in **Physics
    Asset**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable Collision**: This parameter disables the collision between the bodies
    joined by this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable Projection**: This parameter ensures that all the bodies are projected
    so that both these bodies still appear attached to each other if a high enough
    linear or angular velocity is applied to each element. For example, a tether ball
    spinning too fast would cause the elements to look detached, but this parameter
    stops this from happening. If the distance error between the two bodies exceeds
    0.1 units, or if the rotation error exceeds 10 degrees, the projection will correct
    this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection Linear Tolerance**: This parameter represents **Linear Tolerance**
    in world units, and if the distance error exceeds this tolerance limit, the body
    will be projected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection Angular Tolerance**: This parameter represents **Angular Tolerance**
    in world units, and if the angular distance error exceeds this tolerance limit,
    the body will be projected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear X Motion**: This parameter indicates whether or not the linear motion
    along the **X** axis is allowed, blocked, or limited. If this is limited, the
    **Linear Limit** property will be used to determine whether a motion is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Y Motion**: This parameter indicates whether or not the linear motion
    along the **Y** axis is allowed, blocked, or limited. If this is limited, the
    **Linear Limit** property will be used to determine whether a motion is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Z Motion**: This parameter indicates whether or not the linear motion
    along the **Z** axis is allowed, blocked, or limited. If this is limited, the
    **Linear Limit** property will be used to determine whether a motion is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Breakable**: This parameter defines whether or not the joint in the
    constraint is breakable based on the **Linear Break Threshold** property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Break Threshold**: This parameter defines the force threshold required
    to break this joint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Swing 1 Motion**: This parameter indicates whether or not the rotation
    around the **Z** axis is allowed, blocked, or limited. If this is limited, the
    **Angular Limit** property will be used to determine the range of motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Twist Motion**: This parameter indicates whether or not the rotation
    around the **X** axis is allowed, blocked, or limited. If this is limited, the
    **Angular Limit** property will be used to determine the range of motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Swing 2 Motion**: This parameter indicates whether or not the rotation
    around the **Y** axis is allowed, blocked, or limited. If this is limited, the
    **Angular Limit** property will be used to determine the range of motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Breakable**: This parameter determines whether or not it is possible
    to break the joint with angular force.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Break Threshold**: This parameter dictates the angular force necessary
    to break the joint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Position Drive**: This parameter enables/disables the linear position
    drive. Here, we can set the **Linear X**, **Y**, and **Z** axes and **Linear Position
    Target**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Velocity Drive**: This parameter enables/disables the linear velocity
    drive, where we can set the **X**, **Y**, and **Z** linear velocity targets for
    the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear** **Position Strength**: This parameter dictates the spring force
    applied to the linear drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear** **Velocity Strength**: This parameter determines the damping force
    applied to the linear drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear** **Drive Force Limit**: This parameter limits the force that can
    be applied to the linear drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular** **Orientation Drive**: This parameter enables the angular drive
    towards a target orientation along the **X**, **Y**, or **Z** axes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular** **Velocity Drive**: This parameter enables the angular drive towards
    a target velocity along the **X**, **Y**, and **Z** axes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular** **Drive Force Limit**: This parameter limits the force that the
    angular drive can apply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Position Strength**: This parameter applies a spring force value
    to the angular drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular** **Velocity Strength**: This parameter applies a damping value to
    the angular drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drive Mode**: This parameter determines the way the angular paths
    are estimated; we can either select **SLERP (Spherical Linear Interpolation)**
    or decompose it into **Twist and Swing**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have briefly discussed the parameters available in the **Physics
    Constraint** component, let's apply angular damping to our constraint so that
    it can be slowed down and brought to a complete halt. In order to make this happen,
    we will need to apply **Angular Velocity Drive** and set **Angular Velocity Strength**
    to a value of `15.0`. Next, we will need to set **Angular Drive Mode** to **Twist
    and Swing**; the remaining parameters can be set to their default values. Once
    applied, let's compile, save, and jump back to **FirstPersonExampleMap**. We will
    see that over a short period of time, **Constrained Mesh** will slowly come to
    a halt. This is due to the high value of the **Angular Velocity Strength** parameter;
    the higher the value, the quicker **Constrained Mesh** will come to a halt. The
    lower the number, the longer it would take for **Constrained Mesh** to come to
    a halt all the way to the point where the mesh will not stop swinging.
  prefs: []
  type: TYPE_NORMAL
- en: What we can do now to conclude this chapter is set an angular force break so
    that if the constrained mesh moves with enough force, it will break from the constraint
    entirely and become its own unique physics body. To accomplish this, let's return
    to the **BP_Constraint** blueprint and select the **Physics Constraint** component
    from the **Components** tab. Now, in the **Details** panel under the **Angular
    Limits** section, we can set **Angular Swing 1 Motion**, **Angular Twist Motion**,
    and **Angular Swing 2 Motion** to **Limited** and leave their **Angle** values
    as their defaults. Lastly, make sure that the **Angular Breakable** parameter
    is checked and **Angular Break Threshold** is set to a value of `50`. If we compile
    and save the blueprint and jump back to the **FirstPersonExampleMap** level, we
    will see that when we shoot the constrained mesh enough times to cause its angular
    velocity to increase, once it reaches the threshold that we set, the mesh will
    separate entirely from the constraint. From here, we can interact with the separated
    mesh as its own physics body. This scenario is useful if you want to simulate
    physics for a tire swing, or for any type of a pendulum object that we wish to
    provide this behavior to. Feel free to experiment with the **Physics Constraint**
    values to see how else we can affect the behaviors of the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics Damping](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Physics Damping – a section review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we looked at how to explore **Physics Damping** using blueprints
    and the **Physics Constraint** component. By setting values in **Physics Constraint**,
    we are able to simulate a pendulum in our game world that would swing forever
    until we apply angular damping with the **Angular Velocity Strength** parameter.
    Lastly, we applied an angular threshold that would cause our constrained mesh
    to break from the joint and become its own separate physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what **Physics Bodies** are and how they function
    in Unreal Engine 4\. Moreover, we looked at the properties that are involved in
    **Physics Bodies** and how these properties can affect the behavior of these bodies
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored what **Angular** and **Linear Damping** are and how they can
    affect our **Physics Bodies**. We also discussed real-world physics when it comes
    to linear and angular momentum, apart from linear and angular velocities.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we briefly discussed **Physical Materials**, how to create them,
    and what their properties entail when it comes to affecting its behavior in the
    game. We then reviewed how to apply **Physical Materials** to static meshes, materials,
    material instances, and skeletal meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we applied **Physics Damping** to **Physics Constraint** by creating
    a working blueprint example, where we constrained two cube meshes together and
    created a pendulum. Moreover, we applied angular damping and angular threshold
    breaks to slowly bring the constrained cube mesh to a halt. We also implemented
    the ability for the constrained mesh to break from the joint to become its own
    physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a stronger understanding of how **Physics Bodies** work in
    the context of angular and linear velocities, momentum, and the application of
    damping, we can move on and explore in detail how **Physical Materials** work
    and how they are implemented.
  prefs: []
  type: TYPE_NORMAL
