<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. The Figure Hierarchy</h1></div></div></div><p>This chapter introduces the figure classes of the drawing program. Each figure is responsible for deciding whether it is hit by a mouse click or if it is enclosed by a rectangle. It is also responsible for moving or modifying, as well as drawing and communicating with a file stream and the clipboard.</p><p>The drawing figure hierarchy is made up of the <code class="literal">Draw</code>, <code class="literal">LineFigure</code>, <code class="literal">ArrowFigure</code>, <code class="literal">RectangleFigure</code>, and <code class="literal">EllipseFigure</code> classes, as shown in the following image:</p><p>
</p><div><img src="img/image_05_001.jpg" alt="The Figure Hierarchy"/></div><p>
</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec21"/>The DrawFigure class</h1></div></div></div><p>The <code class="literal">Draw</code> class is the root class of the hierarchy and is mostly made up of virtual and pure virtual methods intended to be overridden by the subclasses.</p><p>The difference between a virtual method and a pure virtual method is that the virtual method has a body and it may be overridden by a subclass. If the subclass overrides the method, its version of the method is called.</p><p>If the subclass does not override the method, the method of the base class is called instead. A pure virtual method does not usually have a body, and a class holding at least one pure virtual method becomes abstract. The subclass can either override all the pure virtual methods of its base class or become abstract itself:</p><p>
<strong>Draw.h</strong>
</p><pre class="programlisting">enum FigureId {LineId, ArrowId, RectangleId, EllipseId}; &#13;
class DrawDocument; &#13;
 &#13;
class Draw { &#13;
  public: &#13;
    Draw(const Window* windowPtr); &#13;
</pre><p>Each figure has its own identity number, returned by the <code class="literal">GetId</code> method:</p><pre class="programlisting">    virtual FigureId GetId() const = 0; &#13;
    virtual void SetFirstPoint(Point point) = 0; &#13;
</pre><p>The <code class="literal">IsClick</code> method returns <code class="literal">True</code> if the mouse point hits the figure, and the <code class="literal">IsInside</code> method returns <code class="literal">True</code> if the figure is completely enclosed by the area. The <code class="literal">DoubleClick</code> method gives the figure a possibility to perform a figure-specific action:</p><pre class="programlisting">    virtual bool IsClick(Point mousePoint) = 0; &#13;
    virtual bool IsInside(Rect area) = 0; &#13;
    virtual void DoubleClick(Point mousePoint) = 0; &#13;
</pre><p>The <code class="literal">Modify</code> and <code class="literal">Move</code> methods simply move the figure. However, the <code class="literal">Modify</code> method performs figure-specific actions defined by the <code class="literal">IsClick</code> method. If the user clicked on one of the figure endpoints, it will be modified, and if they clicked on any other part of the figure, it will be moved:</p><pre class="programlisting">    virtual void Modify(Size distanceSize) = 0; &#13;
    virtual void Move(Size distanceSize) = 0; &#13;
</pre><p>The <code class="literal">Invalidate</code> method invalidates the figure by calling the <code class="literal">Area</code> method, which returns the area occupied by the figure. The <code class="literal">Draw</code> method draws the figure with the given <code class="literal">Graphics</code> class's reference:</p><pre class="programlisting">    virtual Rect Area() const = 0; &#13;
    virtual void Draw(Graphics&amp; graphics) const = 0; &#13;
    void Invalidate() const {windowPtr-&gt;Invalidate(Area());} &#13;
</pre><p>The <code class="literal">IsFillable</code>, <code class="literal">IsFilled</code>, and <code class="literal">Fill</code> methods are only overridden by the <code class="literal">Rectangle</code> and <code class="literal">Ellipse</code> methods:</p><pre class="programlisting">    virtual bool IsFillable() const {return false;} &#13;
    virtual bool IsFilled() const {return false;} &#13;
    virtual void Fill(bool fill) {/* Empty. */} &#13;
</pre><p>The <code class="literal">WriteFigureToStream</code> and <code class="literal">ReadFigureFromStream</code> methods are called when the user opens or saves a document. They write or read the information of the figure to and from the streams:</p><pre class="programlisting">    virtual bool WriteFigureToStream(ostream&amp; outStream) const; &#13;
    virtual bool ReadFigureFromStream(istream&amp; inStream); &#13;
</pre><p>The <code class="literal">WriteFigureToClipboard</code> and <code class="literal">ReadFigureFromClipboard</code> methods are called when the user copies or pastes figures. They write information to a character list and read information to a character buffer:</p><pre class="programlisting">    virtual void WriteFigureToClipboard(InfoList&amp; infoList) const; &#13;
    virtual void ReadFigureFromClipboard(InfoList&amp; infoList); &#13;
</pre><p>The <code class="literal">color</code> and <code class="literal">marked</code> fields have their own get and set methods:</p><pre class="programlisting">    bool IsMarked() const {return marked;} &#13;
    void Mark(bool mark); &#13;
 &#13;
    Color GetColor() const {return color;} &#13;
    void SetColor(Color color); &#13;
</pre><p>The <code class="literal">GetCursor</code> method returns the correct cursor for the figure:</p><pre class="programlisting">    virtual CursoTyper GetCursor() const = 0; &#13;
</pre><p>The <code class="literal">MarkRadius</code> method is the size of the small squares showing that the figure is marked:</p><pre class="programlisting">    static const Size MarkRadius; &#13;
</pre><p>The <code class="literal">windowPtr</code> pointer is used when invalidating the figure:</p><pre class="programlisting">  private: &#13;
    const Window* windowPtr; &#13;
</pre><p>Each figure, regardless of its type, has a color and is marked or unmarked:</p><pre class="programlisting">    Color color; &#13;
    bool marked = false; &#13;
};</pre><p>
<strong>Draw.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "Draw.h"</pre><p>The <code class="literal">MarkRadius</code> parameter is set to 100 * 100 units, which is 1 * 1 millimeters:</p><pre class="programlisting">const Size DrawFigure::MarkRadius(100, 100); &#13;
</pre><p>When a figure is created, it is always unmarked.</p><pre class="programlisting">DrawFigure::Draw(const Window* windowPtr) &#13;
 :windowPtr(windowPtr) { &#13;
    // Empty. &#13;
} &#13;
</pre><p>We redraw when the user toggles the figure's marked state. You may notice the different order in the <code class="literal">if...else</code> statements. The reason is that when we mark a figure, it becomes larger; that is why we first set the <code class="literal">marked</code> parameter to <code class="literal">True</code> and then invalidate the figure to catch its area including its markings. On the other hand, when we unmark a figure it becomes smaller; that is why we first invalidate it to catch its area, including the markings, and then set the <code class="literal">marked</code> parameter to <code class="literal">False</code>.</p><pre class="programlisting">void DrawFigure::Mark(bool mark) { &#13;
  if (!marked &amp;&amp; mark) { &#13;
    marked = true; &#13;
    Invalidate(); &#13;
  } &#13;
  else if (marked &amp;&amp; !mark) { &#13;
    Invalidate(); &#13;
    marked = false; &#13;
  } &#13;
} &#13;
</pre><p>The color is the only field written or read in file handling and in communication with the clipboard. The subclasses of the <code class="literal">DrawFigure</code> class call these methods and then write and read figure-specific information. The <code class="literal">WriteFigureToStream</code> and <code class="literal">ReadFigureFromStream</code> methods return the Boolean value of the stream to indicate whether the file operation succeeded.</p><pre class="programlisting">bool DrawFigure::WriteFigureToStream(ostream&amp; outStream) const { &#13;
  color.WriteColorToStream(outStream); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool DrawFigure::ReadFigureFromStream(istream&amp; inStream) { &#13;
  color.ReadColorFromStream(inStream); &#13;
  return ((bool) inStream); &#13;
} &#13;
 &#13;
void DrawFigure::WriteFigureToClipboard(InfoList&amp; infoList) const{ &#13;
  color.WriteColorToClipboard(charList); &#13;
} &#13;
 &#13;
void DrawFigure::ReadFigureFromClipboard(InfoList&amp; infoList) { &#13;
  color.ReadColorFromClipboard(infoList); &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec22"/>The LineFigure class</h1></div></div></div><p>A line is drawn between two points, represented by the <code class="literal">firstPoint</code> field to the <code class="literal">lastPoint</code> field in the <code class="literal">LineFigure</code> class, as shown in the following image:</p><p>
</p><div><img src="img/image_05_002.jpg" alt="The LineFigure class"/></div><p>
</p><p>The <code class="literal">header</code> file overrides some of the methods of its <code class="literal">DrawFigure</code> base class. The <code class="literal">DoubleClick</code> method does nothing. As I see it, there is no really meaningful response to a double-click on a line. However, we still need to override the <code class="literal">DoubleClick</code> method, since it is a pure virtual method in the <code class="literal">DrawFigure</code> base class. If we do not override it, the <code class="literal">LineFigure</code> class will be abstract.</p><p>
<strong>LineFigure.h</strong>
</p><pre class="programlisting">class LineFigure : public DrawFigure { &#13;
  public: &#13;
    LineFigure(const Window* windowPtr); &#13;
    virtual FigureId GetId() const {return LineId;} &#13;
    virtual void SetFirstPoint(Point point); &#13;
 &#13;
    virtual bool IsClick(Point mousePoint); &#13;
    virtual bool IsInside(Rect rectangleArea); &#13;
    virtual void DoubleClick(Point mousePoint) {/* Empty. */} &#13;
 &#13;
    virtual void Modify(Size distanceSize); &#13;
    virtual void Move(Size distanceSize); &#13;
 &#13;
    virtual Rect Area() const; &#13;
    virtual void Draw(Graphics&amp; graphics) const; &#13;
    virtual CursorType GetCursor() const; &#13;
 &#13;
    virtual bool WriteFigureToStream(ostream&amp; outStream) const; &#13;
    virtual bool ReadFigureFromStream(istream&amp; inStream); &#13;
 &#13;
    virtual void WriteFigureToClipboard(InfoList&amp; infoList) const; &#13;
    virtual void ReadFigureFromClipboard(InfoList&amp; infoList); &#13;
 &#13;
  protected: &#13;
    enum {CreateLine, FirstPoint, LastPoint, MoveLine} lineMode; &#13;
    Point firstPoint, lastPoint; &#13;
    static bool IsPointInLine(Point firstPoint, Point lastPoint, &#13;
                              Point point); &#13;
};</pre><p>
<strong>LineFigure.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "Draw.h"&#13;
#include "LineFigure.h"&#13;
&#13;
LineFigure::LineFigure(const Window* windowPtr)&#13;
 :Draw(windowPtr), lineMode(CreateLine) {&#13;
 // Empty. &#13;
}</pre><p>The <code class="literal">SetFirstPoint</code> method is called when the line is created and sets both the first and last points.</p><pre class="programlisting">void LineFigure::SetFirstPoint(Point point) { &#13;
  firstPoint = point; &#13;
  lastPoint = point; &#13;
} &#13;
</pre><p>The <code class="literal">IsClick</code> method has two cases: the user has to hit either one of the endpoints or the line itself. We define two squares (<code class="literal">firstSquare</code> and <code class="literal">lastSquare</code>) covering the endpoints, and test whether the mouse hits one of them. If not, we test whether the mouse hits the line itself by calling the <code class="literal">IsPointInLine</code> method.</p><pre class="programlisting">bool LineFigure::IsClick(Point mousePoint) { &#13;
  Rect firstSquare(firstPoint - MarkRadius, &#13;
                   firstPoint + MarkRadius); &#13;
  firstSquare.Normalize(); &#13;
 &#13;
  if (firstSquare.PointInside(mousePoint)) { &#13;
    lineMode = FirstPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Rect lastSquare(lastPoint - MarkRadius, lastPoint + MarkRadius); &#13;
  lastSquare.Normalize(); &#13;
 &#13;
  if (lastSquare.PointInside(mousePoint)) { &#13;
    lineMode = LastPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  if (IsPointInLine(firstPoint, lastPoint, mousePoint)) { &#13;
    lineMode = MoveLine; &#13;
    return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">IsPointInLine</code> method checks whether the point is located on the line, with some tolerance. We use trigonometric functions to calculate the position of the point relative to the line. However, if the line is completely vertical and the points have the same x coordinate, we have a special case.</p><p>Applying the trigonometric functions would result in division by zero. Instead, we create a small rectangle surrounding the line and check if the point is located in the rectangle, as shown in the following image:</p><p>
</p><div><img src="img/image_05_003.jpg" alt="The LineFigure class"/></div><p>
</p><pre class="programlisting">bool LineFigure::IsPointInLine(Point firstPoint, Point lastPoint, &#13;
                               Point point) { &#13;
  if (firstPoint.X() == lastPoint.X()) { &#13;
    Rect lineRect(firstPoint - MarkRadius, &#13;
                  lastPoint + MarkRadius); &#13;
    lineRect.Normalize(); &#13;
    return lineRect.PointInside(point); &#13;
  } &#13;
</pre><p>If the line is not vertical, we start by creating an enclosing rectangle and test if the mouse point is in it. If it is, we let the leftmost point of the <code class="literal">firstPoint</code> and <code class="literal">lastPoint</code> fields equal to the <code class="literal">minPoint</code> field and the rightmost point equal to the <code class="literal">maxPoint</code> field. Then we calculate the width (<code class="literal">lineWidth</code>) and height (<code class="literal">lineHeight</code>) of the enclosing rectangle, as well as the distance between the <code class="literal">minPoint</code> and <code class="literal">mousePoint</code> fields in x and y directions (<code class="literal">diffWidth</code> and <code class="literal">diffHeight</code>), as shown in the following image:</p><p>
</p><div><img src="img/image_05_004.jpg" alt="The LineFigure class"/></div><p>
</p><p>Due to uniformity, the following equation is true if the mouse point hits the line:</p><p>
</p><div><img src="img/image_05_005.jpg" alt="The LineFigure class"/></div><p>
</p><p>This implies that:</p><p>
</p><div><img src="img/image_05_006.jpg" alt="The LineFigure class"/></div><p>
</p><p>And this also implies that:</p><p>
</p><div><img src="img/image_05_007.jpg" alt="The LineFigure class"/></div><p>
</p><p>Let us allow for a small tolerance; let us say that the user is allowed to miss the line by a millimeter (100 units). This changes the last equation to the following:</p><p>
</p><div><img src="img/image_05_008.jpg" alt="The LineFigure class"/></div><p>
</p><pre class="programlisting">  else { &#13;
    Point minPoint = Min(firstPoint, lastPoint), &#13;
          maxPoint = Max(firstPoint, lastPoint); &#13;
 &#13;
    if ((minPoint.X() &lt;= point.X()) &amp;&amp; &#13;
        (point.X() &lt;= maxPoint.X())) { &#13;
      int lineWidth = maxPoint.X() - minPoint.X(), &#13;
          lineHeight = maxPoint.Y() - minPoint.Y(); &#13;
 &#13;
      int diffWidth = point.X() - minPoint.X(), &#13;
          diffHeight = point.Y() - minPoint.Y(); &#13;
 &#13;
      double delta = fabs(diffHeight - (diffWidth * &#13;
                          ((double) lineHeight) / lineWidth)); &#13;
      return (delta &lt;= 100); &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">IsInside</code> method is easier than the <code class="literal">IsClick</code> method. We just check whether both endpoints are enclosed by the given rectangle.</p><pre class="programlisting">bool LineFigure::IsInside(Rect rect) { &#13;
  return (rect.PointInside(firstPoint) &amp;&amp; &#13;
          rect.PointInside(lastPoint)); &#13;
} &#13;
</pre><p>In the <code class="literal">Modify</code> mode, we move one of the endpoints or the line depending on the value of the <code class="literal">lineMode</code> parameter set by the <code class="literal">IsClick</code> method. If the user has hit the first point, we move it. If they have hit the last point, or if the line is in the process of being created, we move the last point. If they have hit the line, we move the line. That is, we move both the first and last points.</p><pre class="programlisting">void LineFigure::Modify(Size distanceSize) { &#13;
  Invalidate(); &#13;
  switch (lineMode) { &#13;
    case FirstPoint: &#13;
      firstPoint += distanceSize; &#13;
      break; &#13;
 &#13;
    case CreateLine: &#13;
    case LastPoint: &#13;
      lastPoint += distanceSize; &#13;
      break; &#13;
 &#13;
    case MoveLine: &#13;
      Move(distanceSize); &#13;
      break; &#13;
  } &#13;
 &#13;
  Invalidate(); &#13;
} &#13;
</pre><p>The <code class="literal">Move</code> method is also easy; we just move the two endpoints.</p><pre class="programlisting">void LineFigure::Move(Size distanceSize) { &#13;
  Invalidate(); &#13;
  firstPoint += distanceSize; &#13;
  lastPoint += distanceSize; &#13;
  Invalidate(); &#13;
} &#13;
</pre><p>In the <code class="literal">Draw</code> method, we draw the line and, if the line is marked, its two endpoints are always black.</p><pre class="programlisting">void LineFigure::Draw(Graphics&amp; graphics) const { &#13;
  graphics.DrawLine(firstPoint, lastPoint, GetColor()); &#13;
 &#13;
  if (IsMarked()) { &#13;
    graphics.FillRectangle(Rect(firstPoint - MarkRadius, &#13;
                           firstPoint + MarkRadius), Black,Black); &#13;
    graphics.FillRectangle(Rect(lastPoint - MarkRadius, &#13;
                           lastPoint + MarkRadius), Black, Black); &#13;
  } &#13;
} &#13;
</pre><p>The area occupied by the line is a rectangle with the endpoints as corners. If the line is marked, the mark radius is added.</p><pre class="programlisting">Rect LineFigure::Area() const { &#13;
  Rect lineArea(firstPoint.X(), firstPoint.Y(), &#13;
                lastPoint.X(), lastPoint.Y()); &#13;
  lineArea.Normalize(); &#13;
 &#13;
  if (IsMarked()) { &#13;
    lineArea -= MarkRadius; &#13;
    lineArea += MarkRadius; &#13;
  } &#13;
 &#13;
  return lineArea; &#13;
} &#13;
</pre><p>If the line is being modified, the <code class="literal">Crosshair</code> cursor is returned. If it is being moved, the size-all cursor (four arrows in the compass directions) is returned. If none of these cases apply, then we just return the normal arrow cursor.</p><pre class="programlisting">CursorType LineFigure::GetCursor() const { &#13;
  switch (lineMode) { &#13;
    case CreateLine: &#13;
    case FirstPoint: &#13;
    case LastPoint: &#13;
      return Cursor::Crosshair; &#13;
 &#13;
    case MoveLine: &#13;
      return Cursor::SizeAll; &#13;
 &#13;
    default: &#13;
      return Cursor::Normal; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">WriteFigureToStream</code>, <code class="literal">ReadFigureFromStream</code>, <code class="literal">WriteFigureToClipboard</code>, and <code class="literal">ReadFigureFromClipboard</code> methods write and read the first and last endpoints of the line after calling the corresponding methods in the <code class="literal">DrawFigure</code> class.</p><pre class="programlisting">bool LineFigure::WriteFigureToStream(ostream&amp; outStream) const { &#13;
  DrawFigure::WriteFigureToStream(outStream); &#13;
  firstPoint.WritePointToStream(outStream); &#13;
  lastPoint.WritePointToStream(outStream); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool LineFigure::ReadFigureFromStream (istream&amp; inStream) { &#13;
  DrawFigure::ReadFigureFromStream(inStream); &#13;
  firstPoint.ReadPointFromStream(inStream); &#13;
  lastPoint.ReadPointFromStream(inStream); &#13;
  return ((bool) inStream); &#13;
} &#13;
 &#13;
void LineFigure::WriteFigureToClipboard(InfoList&amp; infoList) const{ &#13;
  DrawFigure::WriteFigureToClipboard(charList); &#13;
  firstPoint.WritePointToClipboard(charList); &#13;
  lastPoint.WritePointToClipboard(charList); &#13;
} &#13;
 &#13;
&#13;
&#13;
&#13;
&#13;
void LineFigure::ReadFigureFromClipboard(InfoList&amp; infoList) { &#13;
  DrawFigure::ReadFigureFromClipboard(infoList); &#13;
  firstPoint.ReadPointFromClipboard(infoList); &#13;
  lastPoint.ReadPointFromClipboard(infoList); &#13;
} &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec23"/>The ArrowFigure class</h1></div></div></div><p>The <code class="literal">ArrowFigure</code> is a subclass of the <code class="literal">LineFigure</code> class and reuses the <code class="literal">firstPoint</code> and <code class="literal">lastPoint</code> fields and some of its functionality. The endpoints of the arrowhead are stored in the <code class="literal">leftPoint</code> and <code class="literal">rightPoint</code> fields, as shown in the following image. The lengths of the sides are defined by the <code class="literal">ArrowLength</code> constant to 500 units, which is 5 millimeters.</p><p>
</p><div><img src="img/image_05_010.jpg" alt="The ArrowFigure class"/></div><p>
</p><p>The <code class="literal">ArrowFigure</code> class overrides some of the methods of the <code class="literal">LineFigure</code> class. Mostly, it calls the methods of the <code class="literal">LineFigure</code> class and then adds functionality of its own.</p><p>
<strong>ArrowFigure.h</strong>
</p><pre class="programlisting">class ArrowFigure : public LineFigure { &#13;
  public: &#13;
    ArrowFigure(const Window* windowPtr); &#13;
    FigureId GetId() const {return ArrowId;}; &#13;
 &#13;
    bool IsClick(Point mousePoint); &#13;
    bool IsInside(Rect area); &#13;
    void DoubleClick(Point mousePoint); &#13;
&#13;
 &#13;
    void Modify(Size distanceSize); &#13;
    void Move(Size distanceSize); &#13;
    Rect Area() const; &#13;
    void Draw(Graphics&amp; graphics) const; &#13;
 &#13;
    bool WriteFigureToStream(ostream&amp; outStream) const; &#13;
    bool ReadFigureFromStream(istream&amp; inStream); &#13;
 &#13;
    void WriteFigureToClipboard(InfoList&amp; infoList) const; &#13;
    void ReadFigureFromClipboard(InfoList&amp; infoList); &#13;
 &#13;
  private: &#13;
    static const int ArrowLength = 500; &#13;
    Point leftPoint, rightPoint; &#13;
    void CalculateArrowHead(); &#13;
}; &#13;
</pre><p>The constructors let the <code class="literal">LineFigure</code> constructors initialize the arrow's endpoints, and then call the <code class="literal">CalculateArrowHead</code> method to calculate the endpoints of the arrowhead.</p><p>
<strong>ArrowFigure.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Draw.h" &#13;
#include "LineFigure.h" &#13;
#include "ArrowFigure.h" &#13;
 &#13;
ArrowFigure::ArrowFigure(const Window* windowPtr) &#13;
 :LineFigure(windowPtr) { &#13;
  CalculateArrowHead(); &#13;
} &#13;
</pre><p>The <code class="literal">IsClick</code> method returns <code class="literal">True</code> if the user clicks on the line or any part of the arrowhead.</p><pre class="programlisting">bool ArrowFigure::IsClick(Point mousePoint) { &#13;
  return LineFigure::IsClick(mousePoint) || &#13;
         IsPointInLine(firstPoint, leftPoint, mousePoint) || &#13;
         IsPointInLine(firstPoint, rightPoint, mousePoint) || &#13;
         IsPointInLine(leftPoint, rightPoint, mousePoint); &#13;
} &#13;
</pre><p>The <code class="literal">IsInside</code> method returns <code class="literal">True</code> if all the endpoints of the line and arrowhead are inside the area.</p><pre class="programlisting">bool ArrowFigure::IsInside(Rect area) { &#13;
  return area.PointInside(firstPoint) &amp;&amp; &#13;
         area.PointInside(lastPoint) &amp;&amp; &#13;
         area.PointInside(leftPoint) &amp;&amp; &#13;
         area.PointInside(rightPoint); &#13;
} &#13;
</pre><p>The <code class="literal">Modify</code> method modifies the line and recalculates the arrowhead.</p><pre class="programlisting">void ArrowFigure::Modify(Size distanceSize) { &#13;
  LineFigure::Modify(distanceSize); &#13;
  CalculateArrowHead(); &#13;
} &#13;
</pre><p>The <code class="literal">Move</code> method moves the line and the arrowhead.</p><pre class="programlisting">void ArrowFigure::Move(Size distanceSize) { &#13;
  LineFigure::Move(distanceSize); &#13;
  leftPoint += distanceSize; &#13;
  rightPoint += distanceSize; &#13;
} &#13;
</pre><p>When the user double-clicks on the arrow, its head and tail are swapped.</p><pre class="programlisting">void ArrowFigure::DoubleClick(Point mousePoint) { &#13;
  if (IsClick(mousePoint)) { &#13;
    Invalidate(); &#13;
    Point tempPoint = firstPoint; &#13;
    firstPoint = lastPoint; &#13;
    lastPoint = tempPoint; &#13;
    CalculateArrowHead(); &#13;
    Invalidate(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">Area</code> method calculates the minimum and maximum of the line's and arrowhead's endpoints and returns an area with its top-left and bottom-right corners. If the arrow is marked, the mark radius is added to the area.</p><pre class="programlisting">Rect ArrowFigure::Area() const { &#13;
  Point topLeft(min(firstPoint.X(), min(lastPoint.X(), &#13;
                    min(leftPoint.X(), rightPoint.X()))), &#13;
                min(firstPoint.Y(), min(lastPoint.Y(), &#13;
                    min(leftPoint.Y(), rightPoint.Y())))), &#13;
        bottomRight(max(firstPoint.X(), max(lastPoint.X(), &#13;
                        max(leftPoint.X(), rightPoint.X()))), &#13;
                    max(firstPoint.Y(), max(lastPoint.Y(), &#13;
                        max(leftPoint.Y(), rightPoint.Y())))); &#13;
 &#13;
  if (IsMarked()) { &#13;
    topLeft -= MarkRadius; &#13;
    bottomRight += MarkRadius; &#13;
  } &#13;
 &#13;
  return Rect(topLeft, bottomRight); &#13;
} &#13;
</pre><p>The <code class="literal">Draw</code> method draws the line and the arrowhead. If the arrow is marked, the arrow's endpoints are also marked with squares.</p><pre class="programlisting">void ArrowFigure::Draw(Graphics&amp; graphics) const { &#13;
  LineFigure::Draw(graphics); &#13;
 &#13;
  graphics.DrawLine(lastPoint, leftPoint, GetColor()); &#13;
  graphics.DrawLine(lastPoint, rightPoint, GetColor()); &#13;
  graphics.DrawLine(leftPoint, rightPoint, GetColor());  &#13;
  if (IsMarked()) { &#13;
    graphics.FillRectangle(Rect(leftPoint - MarkRadius, &#13;
                           leftPoint + MarkRadius), Black, Black); &#13;
    graphics.FillRectangle(Rect(rightPoint - MarkRadius, &#13;
                           rightPoint + MarkRadius), Black,Black); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">WriteFigureToStream</code>, <code class="literal">ReadFigureFromStream</code>, <code class="literal">WriteFigureToClipboard</code>, and <code class="literal">ReadFigureFromClipboard</code> methods let the <code class="literal">LineFigure</code> class write and read the line's endpoints. Then it writes and reads the arrowhead's endpoints.</p><pre class="programlisting">bool ArrowFigure::WriteFigureToStream(ostream&amp; outStream) const { &#13;
  LineFigure::WriteFigureToStream(outStream); &#13;
  leftPoint.WritePointToStream(outStream); &#13;
  rightPoint.WritePointToStream(outStream); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool ArrowFigure::ReadFigureFromStream(istream&amp; inStream) { &#13;
  LineFigure::ReadFigureFromStream(inStream); &#13;
  leftPoint.ReadPointFromStream(inStream); &#13;
  rightPoint.ReadPointFromStream(inStream); &#13;
  return ((bool) inStream); &#13;
} &#13;
 &#13;
void ArrowFigure::WriteFigureToClipboard(InfoList&amp; infoList)const{ &#13;
  LineFigure::WriteFigureToClipboard(charList); &#13;
  leftPoint.WritePointToClipboard(charList); &#13;
  rightPoint.WritePointToClipboard(charList); &#13;
} &#13;
 &#13;
void ArrowFigure::ReadFigureFromClipboard(InfoList&amp; infoList) { &#13;
  LineFigure::ReadFigureFromClipboard(infoList); &#13;
  leftPoint.ReadPointFromClipboard(infoList); &#13;
  rightPoint.ReadPointFromClipboard(infoList); &#13;
} &#13;
</pre><p>The <code class="literal">CalculateArrowHead</code> method is a private auxiliary method that calculates the endpoints of the arrowhead. We will use the following relations to calculate the <code class="literal">leftPoint</code> and <code class="literal">rightPoint</code> fields.</p><p>
</p><div><img src="img/image_05_011.jpg" alt="The ArrowFigure class"/></div><p>
</p><p>The calculation is performed in three steps; first we calculate <code class="literal">alpha</code> and <code class="literal">beta</code>. See the following illustration for the definition of the angles:</p><p>
</p><div><img src="img/image_05_012.jpg" alt="The ArrowFigure class"/></div><p>
</p><p>Then we calculate <code class="literal">leftAngle</code> and <code class="literal">rightAngle</code> and use their values to calculate the value of <code class="literal">leftPoint</code> and <code class="literal">rightPoint</code>. The angle between the line and the arrowhead parts is 45 degrees, which is equivialent to Π/4 radians. So, in order to determine the angles for the arrowhead parts, we simply subtract Π/4 from <code class="literal">beta</code> and add Π/4 to <code class="literal">beta</code>:</p><p>
</p><div><img src="img/image_05_013.jpg" alt="The ArrowFigure class"/></div><p>
</p><p>Then we use the following formulas to finally determine <code class="literal">leftPoint</code> and <code class="literal">rightPoint</code>:</p><p>
</p><div><img src="img/image_05_014.jpg" alt="The ArrowFigure class"/></div><p>
</p><p>The trigonometric functions are available in the C standard library. However, we need to define our value for Π. The <code class="literal">atan2</code> function calculates the tangent value for the quota of <code class="literal">height</code> and <code class="literal">width</code> and takes into consideration the possibility that <code class="literal">width</code> might be zero.</p><p>
</p><div><img src="img/image_05_018.jpg" alt="The ArrowFigure class"/></div><p>
</p><pre class="programlisting">void ArrowFigure::CalculateArrowHead() { &#13;
  int height = lastPoint.Y() - firstPoint.Y(); &#13;
  int width = lastPoint.X() - firstPoint.X(); &#13;
 &#13;
  const double Pi = 3.14159265; &#13;
  double alpha = atan2((double) height, (double) width); &#13;
  double beta = alpha + Pi; &#13;
 &#13;
  double leftAngle = beta - (Pi / 4); &#13;
  double rightAngle = beta + (Pi / 4); &#13;
 &#13;
  leftPoint.X() = lastPoint.X() + &#13;
                  (int) (ArrowLength * cos(leftAngle)); &#13;
  leftPoint.Y() = lastPoint.Y() + &#13;
                  (int) (ArrowLength * sin(leftAngle)); &#13;
 &#13;
  rightPoint.X() = lastPoint.X() + &#13;
                   (int) (ArrowLength * cos(rightAngle)); &#13;
  rightPoint.Y() = lastPoint.Y() + &#13;
                   (int) (ArrowLength * sin(rightAngle)); &#13;
} &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec24"/>The RectangleFigure class</h1></div></div></div><p>The <code class="literal">RectangleFigure</code> class holds a rectangle, which can be filled or unfilled. The user can modify it by grabbing one of its four corners. The <code class="literal">DrawRectangle</code> class overrides most of the methods of the <code class="literal">DrawFigure</code> class.</p><p>One difference compared to the line and arrow cases is that a rectangle is two-dimensional and can be filled or unfilled. The <code class="literal">Fillable</code> method returns <code class="literal">True</code> and the <code class="literal">IsFilled</code> and <code class="literal">Fill</code> methods are overridden. When the user double-clicks on a rectangle it will be toggled between the filled and unfilled states.</p><p>
<strong>RectangleFigure.h</strong>
</p><pre class="programlisting">class RectangleFigure : public DrawFigure { &#13;
  public: &#13;
    RectangleFigure(const Window* windowPtr); &#13;
 &#13;
    virtual void SetFirstPoint(Point point); &#13;
    virtual FigureId GetId() const {return RectangleId;} &#13;
 &#13;
    virtual bool IsClick(Point mousePoint); &#13;
    virtual bool IsInside(Rect rectangleArea); &#13;
    virtual void DoubleClick(Point mousePoint); &#13;
 &#13;
    virtual void Modify(Size distanceSize); &#13;
    virtual void Move(Size distanceSize); &#13;
 &#13;
    virtual Rect Area() const; &#13;
    virtual void Draw(Graphics&amp; graphics) const; &#13;
    virtual CursorType GetCursor() const; &#13;
 &#13;
    bool IsFillable() const {return true;} &#13;
    bool IsFilled() const {return filled;} &#13;
    void Fill(bool fill) {filled = fill; Invalidate();} &#13;
 &#13;
    virtual bool WriteFigureToStream(ostream&amp; outStream) const; &#13;
    virtual bool ReadFigureFromStream(istream&amp; inStream); &#13;
&#13;
 &#13;
    virtual void WriteFigureToClipboard(InfoList&amp; infoList) const; &#13;
    virtual void ReadFigureFromClipboard(InfoList&amp; infoList); &#13;
 &#13;
  private: &#13;
    enum {CreateRectangle, TopLeftPoint, TopRightPoint, &#13;
          BottomRightPoint, BottomLeftPoint, MoveRectangle} &#13;
         rectangleMode; &#13;
 &#13;
  protected: &#13;
    bool filled = false; &#13;
    Point topLeft, bottomRight; &#13;
};</pre><p>
<strong>RectangleFigure.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "Draw.h"&#13;
#include "RectangleFigure.h"&#13;
RectangleFigure::RectangleFigure(const Window* windowPtr)&#13;
:Draw(windowPtr), rectangleMode(CreateRectangle) { /* Empty. */ }&#13;
void RectangleFigure::SetFirstPoint(Point point) { topLeft = point; bottomRight = point; }</pre><p>When the user clicks on the rectangle, they may hit one of its four corners, the borders of the rectangle, or (if it is filled) its interior. First, we check the corners and then the rectangle itself. If it is filled, we just test whether the mouse point is enclosed in the rectangle. If the rectangle is unfilled, we test whether any of its four borders has been hit by constructing a slightly smaller rectangle and a slightly larger one. If the mouse position is included in the larger rectangle, but not in the smaller one, the user has hit one of the rectangle borders.</p><p>
</p><div><img src="img/image_05_019.jpg" alt="The RectangleFigure class"/></div><p>
</p><pre class="programlisting">bool RectangleFigure::IsClick(Point mousePoint) { &#13;
  Rect topLeftRect(topLeft - MarkRadius, topLeft + MarkRadius); &#13;
 &#13;
  if (topLeftRect.PointInside(mousePoint)) { &#13;
    rectangleMode = TopLeftPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Point topRightPoint(bottomRight.X(), topLeft.Y()); &#13;
  Rect topRectRight(topRightPoint - MarkRadius, &#13;
                    topRightPoint + MarkRadius); &#13;
 &#13;
  if (topRectRight.PointInside(mousePoint)) { &#13;
    rectangleMode = TopRightPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Rect bottomRightRect(bottomRight - MarkRadius, &#13;
                       bottomRight + MarkRadius); &#13;
 &#13;
  if (bottomRightRect.PointInside(mousePoint)) { &#13;
    rectangleMode = BottomRightPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Point bottomLeftPoint(topLeft.X(), bottomRight.Y()); &#13;
  Rect bottomLeftRect(bottomLeftPoint - MarkRadius, &#13;
                      bottomLeftPoint + MarkRadius); &#13;
 &#13;
  if (bottomLeftRect.PointInside(mousePoint)) { &#13;
    rectangleMode = BottomLeftPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Rect areaRect(topLeft, bottomRight); &#13;
  areaRect.Normalize(); &#13;
 &#13;
  if (IsFilled()) { &#13;
    areaRect.PointInside(mousePoint);    &#13;
 &#13;
    if (areaRect.PointInside(mousePoint)) { &#13;
      rectangleMode = MoveRectangle; &#13;
      return true; &#13;
    } &#13;
  } &#13;
&#13;
&#13;
&#13;
  else { &#13;
    Rect largeAreaRect(areaRect.TopLeft() - MarkRadius, &#13;
                       areaRect.BottomRight() + MarkRadius), &#13;
         smallAreaRect(areaRect.TopLeft() + MarkRadius, &#13;
                       areaRect.BottomRight() - MarkRadius); &#13;
         &#13;
    if (largeAreaRect.PointInside(mousePoint) &amp;&amp; &#13;
        !smallAreaRect.PointInside(mousePoint)) { &#13;
      rectangleMode = MoveRectangle; &#13;
      return true; &#13;
    } &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">IsInside</code> method returns <code class="literal">true</code> if the top-left and bottom-right corners are enclosed by the rectangle area.</p><pre class="programlisting">bool RectangleFigure::IsInside(Rect area) { &#13;
  return area.PointInside(topLeft) &amp;&amp; &#13;
         area.PointInside(bottomRight); &#13;
} &#13;
</pre><p>The <code class="literal">DoubleClick</code> method fills the rectangle if it is unfilled and vice versa.</p><pre class="programlisting">void RectangleFigure::DoubleClick(Point mousePoint) { &#13;
  if (IsClick(mousePoint)) { &#13;
    filled = !filled; &#13;
    Invalidate(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">Modify</code> method modifies or moves the rectangle in accordance with the setting of the <code class="literal">rectangleMode</code> parameter in the <code class="literal">IsClick</code> method.</p><pre class="programlisting">void RectangleFigure::Modify(Size distanceSize) { &#13;
  Invalidate(); &#13;
 &#13;
  switch (rectangleMode) { &#13;
    case TopLeftPoint: &#13;
      topLeft += distanceSize; &#13;
      break; &#13;
 &#13;
    case TopRightPoint: &#13;
      topLeft.Y() += distanceSize.Height(); &#13;
      bottomRight.X() += distanceSize.Width(); &#13;
      break; &#13;
 &#13;
    case CreateRectangle: &#13;
    case BottomRightPoint: &#13;
      bottomRight += distanceSize; &#13;
      break; &#13;
 &#13;
    case BottomLeftPoint: &#13;
      topLeft.X() += distanceSize.Width(); &#13;
      bottomRight.Y() += distanceSize.Height(); &#13;
      break; &#13;
 &#13;
    case MoveRectangle: &#13;
      Move(distanceSize); &#13;
      break; &#13;
  } &#13;
 &#13;
  Invalidate(); &#13;
} &#13;
</pre><p>The <code class="literal">Move</code> method moves the rectangle's corners.</p><pre class="programlisting">void RectangleFigure::Move(Size distanceSize) { &#13;
  Invalidate(); &#13;
  topLeft += distanceSize; &#13;
  bottomRight += distanceSize; &#13;
  Invalidate(); &#13;
} &#13;
</pre><p>The area of the rectangle is simply that of the rectangle. However, if it is marked, we increase it in order to include the corner squares.</p><p>
</p><div><img src="img/image_05_020.jpg" alt="The RectangleFigure class"/></div><p>
</p><pre class="programlisting">Rect RectangleFigure::Area() const {&#13;
  Rect areaRect(topLeft, bottomRight); &#13;
  areaRect.Normalize(); &#13;
 &#13;
  if (IsMarked()) { &#13;
    areaRect -= MarkRadius; &#13;
    areaRect += MarkRadius; &#13;
  }  &#13;
  return areaRect; &#13;
} &#13;
</pre><p>The <code class="literal">Draw</code> method draws or fills the rectangle. It also fills the squares if it is marked.</p><pre class="programlisting">void RectangleFigure::Draw(Graphics&amp; graphics) const { &#13;
  if (filled) { &#13;
    graphics.FillRectangle(Rect(topLeft, bottomRight), &#13;
                           GetColor(), GetColor()); &#13;
  } &#13;
  else { &#13;
    graphics.DrawRectangle(Rect(topLeft, bottomRight), &#13;
                           GetColor()); &#13;
  } &#13;
 &#13;
  if (IsMarked()) { &#13;
    graphics.FillRectangle(Rect(topLeft - MarkRadius, &#13;
                           topLeft + MarkRadius), Black, Black); &#13;
 &#13;
    Point topRight(bottomRight.X(), topLeft.Y()); &#13;
    graphics.FillRectangle(Rect(topRight - MarkRadius, &#13;
                           topRight + MarkRadius), Black, Black); &#13;
 &#13;
    graphics.FillRectangle(Rect(bottomRight - MarkRadius, &#13;
                           bottomRight + MarkRadius),Black,Black); &#13;
 &#13;
    Point bottomLeft(topLeft.X(), bottomRight.Y()); &#13;
    graphics.FillRectangle(Rect(bottomLeft - MarkRadius, &#13;
                 bottomLeft + MarkRadius.Height()), Black, Black); &#13;
  } &#13;
} &#13;
</pre><p>The cursor of the rectangle is the size-all cursor (arrows in the four compass directions) when the figure is being moved. It is a cursor with arrows in accordance with the grabbed corner while being modified: north-west and south-east arrows in the case of the top-left or bottom-right corner, and north-east and south-west arrows in the case of the top-right or bottom-left corner.</p><pre class="programlisting">CursorType RectangleFigure::GetCursor() const { &#13;
  switch (rectangleMode) { &#13;
    case TopLeftPoint: &#13;
    case BottomRightPoint: &#13;
      return Cursor::SizeNorthWestSouthEast; &#13;
 &#13;
    case TopRightPoint: &#13;
    case BottomLeftPoint: &#13;
      return Cursor::SizeNorthEastSouthWest; &#13;
 &#13;
    case MoveRectangle: &#13;
      return Cursor::SizeAll; &#13;
 &#13;
    default: &#13;
      return Cursor::Normal; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">WriteFigureToStream</code>, <code class="literal">ReadFigureFromStream</code>, <code class="literal">WriteFigureToClipboard</code>, and <code class="literal">ReadFigureFromClipboard</code> methods call the corresponding methods in the <code class="literal">DrawFigure</code> class. Then they write and read the four corners of the rectangle, and whether it is filled or not.</p><pre class="programlisting">bool RectangleFigure::WriteFigureToStream(ostream&amp; outStream) &#13;
                                          const { &#13;
  DrawFigure::WriteFigureToStream(outStream); &#13;
  topLeft.WritePointToStream(outStream); &#13;
  bottomRight.WritePointToStream(outStream); &#13;
  outStream.write((char*) &amp;filled, sizeof filled); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool RectangleFigure::ReadFigureFromStream (istream&amp; inStream) { &#13;
  DrawFigure::ReadFigureFromStream(inStream); &#13;
  topLeft.ReadPointFromStream(inStream); &#13;
  bottomRight.ReadPointFromStream(inStream); &#13;
  inStream.read((char*) &amp;filled, sizeof filled); &#13;
  return ((bool) inStream); &#13;
} &#13;
&#13;
void RectangleFigure::WriteFigureToClipboard(InfoList&amp; infoList) &#13;
                                             const { &#13;
  DrawFigure::WriteFigureToClipboard(infoList); &#13;
  topLeft.WritePointToClipboard(infoList); &#13;
  bottomRight.WritePointToClipboard(infoList); &#13;
  infoList.AddValue&lt;bool&gt;(filled); &#13;
} &#13;
 &#13;
void RectangleFigure::ReadFigureFromClipboard(InfoList&amp; infoList) { &#13;
  DrawFigure::ReadFigureFromClipboard(infoList); &#13;
  topLeft.ReadPointFromClipboard(infoList); &#13;
  bottomRight.ReadPointFromClipboard(infoList); &#13;
  infoList.GetValue&lt;bool&gt;(filled); &#13;
} &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>The EllipseFigure class</h1></div></div></div><p>The <code class="literal">EllipseFigure</code> class is a subclass of the <code class="literal">RectangleFigure</code> class. The ellipse can be moved or reshaped by the horizontal or vertical corners. Most of the methods from the <code class="literal">RectangleFigure</code> class are not overridden by the <code class="literal">Ellipse</code> class.</p><p>
<strong>Ellipse.h</strong>
</p><pre class="programlisting">class EllipseFigure : public RectangleFigure { &#13;
  public: &#13;
    EllipseFigure(const Window* windowPtr); &#13;
    FigureId GetId() const {return EllipseId;} &#13;
 &#13;
    bool IsClick(Point mousePoint); &#13;
    void Modify(Size distanceSize); &#13;
    void Draw(Graphics&amp; graphics) const; &#13;
    CursoTyper GetCursor() const; &#13;
 &#13;
  private: &#13;
    enum {CreateEllipse, LeftPoint, TopPoint, RightPoint, &#13;
          BottomPoint, MoveEllipse} ellipseMode; &#13;
};</pre><p>
<strong>Ellipse.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "Draw.h"&#13;
#include "RectangleFigure.h"&#13;
#include "EllipseFigure.h"&#13;
EllipseFigure::EllipseFigure(const Window* windowPtr) &#13;
 :RectangleFigure(windowPtr), &#13;
  ellipseMode(CreateEllipse) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>Just as in the rectangle case, the <code class="literal">IsClick</code> method first decides if the user has clicked on one of the four endpoints; however, the positions are different compared to the rectangle corners.</p><p>
</p><div><img src="img/image_05_021.jpg" alt="The EllipseFigure class"/></div><p>
</p><pre class="programlisting">bool EllipseFigure::IsClick(Point mousePoint) { &#13;
  Point leftPoint(topLeft.X(), (topLeft.Y() + bottomRight.Y())/2); &#13;
  Rect leftRect(leftPoint - MarkRadius, leftPoint + MarkRadius); &#13;
 &#13;
  if (leftRect.PointInside(mousePoint)) { &#13;
    ellipseMode = LeftPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Point topPoint((topLeft.X() + bottomRight.X()) / 2,topLeft.Y()); &#13;
  Rect topRect(topPoint - MarkRadius, topPoint + MarkRadius); &#13;
 &#13;
  if (topRect.PointInside(mousePoint)) { &#13;
    ellipseMode = TopPoint; &#13;
    return true; &#13;
  } &#13;
 &#13;
  Point rightPoint(bottomRight.X(), &#13;
                   (topLeft.Y() + bottomRight.Y()) / 2); &#13;
  Rect rightRect(rightPoint - MarkRadius, &#13;
                 rightPoint + MarkRadius); &#13;
 &#13;
  if (rightRect.PointInside(mousePoint)) { &#13;
    ellipseMode = RightPoint; &#13;
    return true; &#13;
  } &#13;
  Point bottomPoint((topLeft.X() + bottomRight.X()) / 2, &#13;
                    bottomRight.Y()); &#13;
  Rect bottomRect(bottomPoint - MarkRadius, &#13;
                  bottomPoint + MarkRadius); &#13;
 &#13;
  if (bottomRect.PointInside(mousePoint)) { &#13;
    ellipseMode = BottomPoint; &#13;
    return true; &#13;
  } &#13;
</pre><p>If the user has not clicked on one of the modifying positions, we have to decide if the user has clicked on the ellipse itself. It is rather easy if the ellipse is not filled. We create an elliptic region by using the Win32 API function <code class="literal">CreateEllipticRgn</code> and test if the mouse position is in it. If the ellipse is not filled, we create two regions, one slightly smaller and one slightly larger. If the mouse position is included in the larger region, but not in the smaller one, we have a hit.</p><p>
</p><div><img src="img/image_05_022.jpg" alt="The EllipseFigure class"/></div><p>
</p><pre class="programlisting">  ellipseMode = MoveEllipse; &#13;
  Point minPoint = Min(topLeft, bottomRight), &#13;
        maxPoint = Max(topLeft, bottomRight);  &#13;
  if (IsFilled()) { &#13;
    HRGN ellipseRegion = &#13;
      CreateEllipticRgn(minPoint.X(), minPoint.Y(), &#13;
                        maxPoint.X(), maxPoint.Y()); &#13;
    return (PtInRegion(ellipseRegion, mousePoint.X(), &#13;
                       mousePoint.Y()) != 0); &#13;
  } &#13;
  else { &#13;
    HRGN smallRegion = &#13;
      CreateEllipticRgn(minPoint.X() + MarkRadius.Width(), &#13;
                        minPoint.Y() + MarkRadius.Height(), &#13;
                        maxPoint.X() - MarkRadius.Width(), &#13;
                        maxPoint.Y() - MarkRadius.Height()); &#13;
    HRGN largeRegion = &#13;
      CreateEllipticRgn(minPoint.X() - MarkRadius.Width(), &#13;
                        minPoint.Y() - MarkRadius.Height(), &#13;
                        maxPoint.X() + MarkRadius.Width(), &#13;
                        maxPoint.Y() + MarkRadius.Height()); &#13;
    return ((PtInRegion(largeRegion, mousePoint.X(), &#13;
                        mousePoint.Y()) != 0) &amp;&amp; &#13;
            (PtInRegion(smallRegion, mousePoint.X(), &#13;
                        mousePoint.Y()) == 0)); &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">Modify</code> method moves the corner in accordance with the setting of the <code class="literal">ellipseMode</code> parameter in the <code class="literal">IsClick</code> method.</p><pre class="programlisting">void EllipseFigure::Modify(Size distanceSize) { &#13;
  Invalidate(); &#13;
 &#13;
  switch (ellipseMode) { &#13;
    case CreateEllipse: &#13;
      bottomRight += distanceSize; &#13;
      break; &#13;
 &#13;
    case LeftPoint: &#13;
      topLeft.X() += distanceSize.Width(); &#13;
      break; &#13;
 &#13;
    case RightPoint: &#13;
      bottomRight.X() += distanceSize.Width(); &#13;
      break; &#13;
 &#13;
    case TopPoint: &#13;
      topLeft.Y() += distanceSize.Height(); &#13;
      break; &#13;
 &#13;
    case BottomPoint: &#13;
      bottomRight.Y() += distanceSize.Height(); &#13;
      break; &#13;
 &#13;
    case MoveEllipse: &#13;
      Move(distanceSize); &#13;
      break; &#13;
  } &#13;
 &#13;
  Invalidate(); &#13;
} &#13;
</pre><p>The <code class="literal">Draw</code> method fills or draws the ellipse, and the four squares if the ellipse is marked.</p><pre class="programlisting">void EllipseFigure::Draw(Graphics&amp; graphics) const { &#13;
  if (filled) { &#13;
    graphics.FillEllipse(Rect(topLeft, bottomRight), &#13;
                         GetColor(), GetColor()); &#13;
  } &#13;
  else { &#13;
    graphics.DrawEllipse(Rect(topLeft, bottomRight), GetColor()); &#13;
  } &#13;
 &#13;
  if (IsMarked()) { &#13;
    Point leftPoint(topLeft.X(), (topLeft.Y()+bottomRight.Y())/2); &#13;
    graphics.FillRectangle(Rect(leftPoint - MarkRadius,  &#13;
                           leftPoint + MarkRadius), Black, Black); &#13;
 &#13;
    Point topPoint((topLeft.X() + bottomRight.X())/2,topLeft.Y()); &#13;
    graphics.FillRectangle(Rect(topPoint - MarkRadius, &#13;
                           topPoint + MarkRadius),Black, Black); &#13;
 &#13;
    Point rightPoint(bottomRight.X(), &#13;
                     (topLeft.Y() + bottomRight.Y()) / 2); &#13;
    graphics.FillRectangle(Rect(rightPoint - MarkRadius, &#13;
                           rightPoint + MarkRadius), Black,Black); &#13;
 &#13;
    Point bottomPoint((topLeft.X() + bottomRight.X()) / 2, &#13;
                      bottomRight.Y()); &#13;
    graphics.FillRectangle(Rect(bottomPoint - MarkRadius, &#13;
                           bottomPoint + MarkRadius),Black,Black); &#13;
  } &#13;
} &#13;
</pre><p>Finally, when it comes to the cursor, we have the following five different cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When the ellipse is being created, the crosshair is returned</li><li class="listitem" style="list-style-type: disc">When the user grabs the left or right endpoint of the ellipse, the west-east (left-right) arrow is returned</li><li class="listitem" style="list-style-type: disc">When the user grabs the top or bottom endpoint, the top-bottom (up-down) arrow is returned</li><li class="listitem" style="list-style-type: disc">When the user moves the ellipse, the size-all arrow (four arrows that point left, right, up, and down) is returned</li><li class="listitem" style="list-style-type: disc">Finally, when the user neither moves nor modifies the ellipse, the normal arrow cursor is returned</li></ul></div><pre class="programlisting">CursorType EllipseFigure::GetCursor() const { &#13;
  switch (ellipseMode) { &#13;
    case CreateEllipse: &#13;
      return Cursor::Crosshair; &#13;
 &#13;
    case LeftPoint: &#13;
    case RightPoint: &#13;
      return Cursor::SizeWestEast; &#13;
 &#13;
    case TopPoint: &#13;
    case BottomPoint: &#13;
      return Cursor::SizeNorthSouth; &#13;
 &#13;
    case MoveEllipse: &#13;
      return Cursor::SizeAll; &#13;
 &#13;
    default: &#13;
      return Cursor::Normal; &#13;
  } &#13;
} &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, you studied the figure class hierarchy for the drawing program of <a class="link" href="ch04.html" title="Chapter 4. Working with Shapes and Figures">Chapter 4</a>, <em>Working with Shapes and Figures</em>. You covered the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Testing whether the figure has been hit by a mouse click or if it is enclosed by a rectangle</li><li class="listitem" style="list-style-type: disc">Modification and movement of the figure</li><li class="listitem" style="list-style-type: disc">Drawing the figure and calculating the area of the figure</li><li class="listitem" style="list-style-type: disc">Writing and reading the figure to and from a file stream or the clipboard</li><li class="listitem" style="list-style-type: disc">Cursor handling with different cursors depending on the current state of figure</li></ul></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Building a Word Processor">Chapter 6</a>, <em>Building a Word Processor</em>, you will start developing a word processor.</p></div></body></html>