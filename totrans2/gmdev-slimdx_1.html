<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started</h1></div></div></div><p>So maybe you have played with XNA Game Studio and already know that it can help you get a small game going relatively quickly. As you get better with it, you start to uncover its limitations. You'd prefer to have the full power of DirectX available to you in C#, since C# is nicer to work in than C++. Is there an alternative to XNA that can give you this? The answer is yes. <strong>SlimDX</strong>
<a id="id0" class="indexterm"/> will give you that power in C#. It also gives you the power to work with different versions of DirectX as well. This means that you can make your games support multiple DirectX versions so that they can run on more computers, expanding your potential user base.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up Visual Studio 2013 Express and SlimDX</li><li class="listitem" style="list-style-type: disc">Creating our initial framework</li><li class="listitem" style="list-style-type: disc">The GameWindow class and the GameLoop method</li><li class="listitem" style="list-style-type: disc">Testing our game window</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Setting up Visual Studio 2013 Express</h1></div></div></div><p>We will be <a id="id1" class="indexterm"/>using Visual Studio 2013 Express since it is freely available from Microsoft.</p><p>Here are the steps to set up Visual Studio 2013 Express:</p><div><ol class="orderedlist arabic"><li class="listitem">To<a id="id2" class="indexterm"/> download Visual Studio 2013 Express, you can visit the Microsoft website at: <a class="ulink" href="http://www.visualstudio.com/downloads/download-visual-studio-vs">http://www.visualstudio.com/downloads/download-visual-studio-vs</a>.<p>This website will show you all of the Express versions of Visual Studio that are available.</p></li><li class="listitem">You will have to choose <strong>Visual Studio Express 2013 for Windows Desktop</strong> since we are focusing on PC development. Click on it to expand its section of the page, and then click on the <strong>Install now</strong> link to begin downloading the installer (<code class="literal">wdexpress_full.exe</code>).</li><li class="listitem">Now that you've downloaded the installer for Visual Studio 2013 Express, it's time to install it. Just double-click on the installer file to begin the installation process.</li><li class="listitem">When <a id="id3" class="indexterm"/>you start up Visual Studio 2013 Express, you will get a window asking you to log in with your Microsoft account. This is the account you will use to log in to your Hotmail account or your Xbox 360 (if you have one).</li><li class="listitem">Once you log in, Visual Studio 2013 Express will be registered to your Microsoft account. This is a smoother process than what it used to be.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up SlimDX</h1></div></div></div><p>Next, we need<a id="id4" class="indexterm"/> to download and install SlimDX. You can get SlimDX from <a id="id5" class="indexterm"/>its official website: <a class="ulink" href="http://www.slimdx.org.">http://www.slimdx.org.</a>
</p><p>Follow these steps to set up SlimDX:</p><div><ol class="orderedlist arabic"><li class="listitem">Once you go to the SlimDX website, click on the <strong>Download</strong> tab at the top of the page. This will take you to the downloads page.</li><li class="listitem">At the time of this writing, the January 2012 release of SlimDX is the latest version. In order <a id="id6" class="indexterm"/>to create SlimDX-based software, we need to get the <strong>SlimDX Developer SDK</strong>.</li><li class="listitem">So go to the section of the page with the heading <strong>Developer SDK</strong>. There is a short paragraph here and an orange button that says <strong>Install Developer SDK</strong>. As you can see from the short paragraph, this SDK contains all of the SlimDX binaries (the compiled SlimDX software), documentation, and samples. The SDK also supports both 32- and 64-bit systems. Click on the <strong>Install Developer SDK</strong> button.</li><li class="listitem">This opens a second web page with a link at the top to a file called <code class="literal">SlimDX SDK (January 2012).msi</code>. Click on this link to begin downloading the SlimDX Developer SDK.</li><li class="listitem">Once the download has completed, simply double-click on the installer file to begin the installation process. When the installer is finished, click on the <strong>Finish</strong> button to close it. We are now ready to write our first bits of code!</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating a framework</h1></div></div></div><p>To make things <a id="id7" class="indexterm"/>easier, we will make a framework project that will contain code that we will use in numerous demo projects. It will be a class library that will hold our <strong>engine code</strong>
<a id="id8" class="indexterm"/>. It is code that is not specific to a particular game, but rather is designed to be able to be re-used in multiple game development projects. If this sounds complicated, don't worry. It is really very easy to do. We will use the term <strong>game code</strong> to refer to<a id="id9" class="indexterm"/> code that is specific to a certain game.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>You should <em>always</em> keep your engine code separated from your game code as much as possible. This increases the reusability of your engine code so that you can use it in multiple game development projects much more easily. This can also potentially save you a lot of time on future projects since you won't have to start completely from scratch every time.</p></div></div><p>We are now<a id="id10" class="indexterm"/> ready to create a Visual Studio project that will store our framework code and resources:</p><div><ol class="orderedlist arabic"><li class="listitem">Open Visual Studio Express, if you haven't already.</li><li class="listitem">Click on the <strong>New Project...</strong> link on the left-hand side of the <strong>Start Page</strong>, or from the <strong>FILE</strong> menu, choose <strong>New</strong> <strong>Project...</strong>; either way you will end up in the <strong>New Project</strong> window.</li><li class="listitem">We need to choose the type of project we wish to create. In this case, we first need to click on the <strong>Visual C#</strong> category in the left-hand side column. The screen changes to show C# project types in the center portion of the window.</li><li class="listitem">Now select <strong>Class Library</strong> shown in the middle of the window. A class library is just that, a library of classes. It cannot be executed by itself though.</li><li class="listitem">Enter a name for the project in the <strong>Name</strong> textbox at the bottom of the window. We'll call this project <code class="literal">SlimFramework</code>.</li><li class="listitem">If you don't have one ready, you will need to create a folder somewhere on your computer to store your work. Then specify that folder in the <strong>Location</strong> textbox at the bottom of the window shown in the following screenshot:<div><img src="img/7389OS_01_01.jpg" alt="Creating a framework"/><div><p>The New Project window</p></div></div></li><li class="listitem">You can click on the <strong>Browse</strong> button to open a folder browser window that you can use to specify the folder you want to save to.</li><li class="listitem">Leave the <strong>Create directory for solution</strong> checkbox checked so that Visual Studio will make a subfolder to put this project in. Your <strong>New Project</strong> window should look like the previous screenshot.</li><li class="listitem">Click on the <strong>OK</strong> button to create the <code class="literal">SlimFramework</code> project. Visual Studio will create the project and display the <code class="literal">Class1.cs</code> file. It is just an empty class for now.</li></ol></div><p>To make a game, we first need a window to display our game in. So we will start our framework by creating a simple game window class.</p><p>Follow these <a id="id11" class="indexterm"/>simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the <code class="literal">Class1.cs</code> file in the <strong>Solution Explorer</strong> pane. The <strong>Solution Explorer</strong> pane is on the upper-right portion of the Visual Studio window and allows us to see the files in our project.</li><li class="listitem">If it is not there, you can access it by opening the <strong>VIEW</strong> menu and choosing <strong>Solution Explorer</strong> to open it.</li><li class="listitem">Right-click on the <code class="literal">Class1.cs</code> file and rename it to <code class="literal">GameWindow.cs</code>.</li><li class="listitem">You may get a message box asking if you want to also rename all references to the code element <code class="literal">Class1</code>. If you click on <strong>Yes</strong>, it will replace any occurrences of <code class="literal">Class1</code> in your code with the new name so that your code won't be broken since you renamed the class. You will usually need to click on <strong>Yes</strong> for this.</li><li class="listitem">Before we can start creating this class though, we need to add some references to our project. To accomplish this, right-click on the heading <strong>References</strong> in the <strong>Solution Explorer</strong> pane and choose <strong>Add Reference...</strong></li><li class="listitem">The <strong>Reference Manager</strong> window will appear. The <strong>Framework</strong> category is currently selected, which is fine, because two of the references we need are in this category.</li><li class="listitem">Scroll <a id="id12" class="indexterm"/>down the list until you find <strong>System.Windows.Forms</strong>. A checkbox appears for the highlighted extension. Check this checkbox since we want to add a reference to this extension. This is shown in the following screenshot:<div><img src="img/7389OS_01_03.jpg" alt="Creating a framework"/><div><p>Adding a reference to System.Windows.Forms</p></div></div></li><li class="listitem">Now, scroll up to find <strong>System.Drawing</strong> and put a check in its checkbox too.</li><li class="listitem">Now we need to select the <strong>Extensions</strong> category in the left-hand side column. This causes the list in the center of the window to display extensions.</li><li class="listitem">Scroll down until you find <strong>SlimDX</strong> in the list. You will find that there are two versions. You will have to select Version 4 as shown in the following screenshot:<div><img src="img/7389OS_01_04.jpg" alt="Creating a framework"/><div><p>Adding a reference to SlimDX</p></div></div></li><li class="listitem">Click on the <strong>OK</strong> button and Visual Studio will add all of the references we specified to the project for us.</li></ol></div><p>If you now expand the <strong>References</strong> heading in the <strong>Solution Explorer</strong> pane, you will see that <strong>SlimDX</strong> now appears in the list of references that our project is using, as do <strong>System.Windows.Forms</strong> and <strong>System.Drawing</strong>. Now that we have added our references, we will <a id="id13" class="indexterm"/>be able to use SlimDX in our project.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>The GameWindow class</h1></div></div></div><p>The <code class="literal">GameWindow</code> class<a id="id14" class="indexterm"/> will provide basic game window <a id="id15" class="indexterm"/>functionality. It will provide all of the basic properties we want to have in our game window, and it will be used as a base class. We will not be making many game window subclasses in this book, but the idea here is that you can make different subclasses for different types of game windows. For example, you can have a game window class for DirectX 10 as well as a game window class for DirectX 11.</p><p>The main things we need to implement for the <code class="literal">GameWindow</code> class are a constructor to initialize it, <strong>Game Loop</strong>
<a id="id16" class="indexterm"/>, <code class="literal">UpdateScene()</code> and <code class="literal">RenderScene()</code> methods, and<a id="id17" class="indexterm"/> a cleanup code for when the window is closed. A game loop is a method that is essentially the heart of a game engine. It is called repeatedly as long as the game is running. It is called once per frame in order to run the code that <a id="id18" class="indexterm"/>makes everything happen in our game world. It calls the <code class="literal">UpdateScene()</code> method, which updates objects in our game world. For example, this method will call on the physics system to simulate the physics for objects that are moving around in our game world.</p><p>Once <code class="literal">UpdateScene()</code> has finished updating the states of all of the objects in our game world, the game loop will then call the <code class="literal">RenderScene()</code> method to draw the current frame. So ultimately, the game loop simulates and draws the game world frame-by-frame. Each time it is called, it simulates another frame.</p><p>A video <a id="id19" class="indexterm"/>game is composed of frames, just like movies are, except that in a video game each frame is being generated on the fly by the <a id="id20" class="indexterm"/>computer. Ideally, we want a game to run at least at 30 FPS (frames per second) so that the video is smooth. If the frame rate is too low, the game's video will become choppy, or worse the game can become unplayable. Let's go ahead and get started with implementing our <code class="literal">GameWindow</code> class. First, we need to add some <code class="literal">using</code> statements at the beginning of the <code class="literal">GameWindow.cs</code> file so that we can use some classes defined by SlimDX and the .NET Framework:</p><div><pre class="programlisting">using System;
using System.Windows.Forms;
using System.Diagnostics;
using SlimDX;
using SlimDX.Windows;</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>In some places in this book, not all code is shown due to space constraints. I will make a note of it when this is the case, so you will need to download the code for this book to see the full code for some demos.</p></div></div><p>Next, we will create a member variables section at the beginning of the <code class="literal">GameWindow</code> class. Inside it, we will define all of the member variables for storing various information about the game window. Here is the the finished member variables section in the <code class="literal">GameWindow</code> class:</p><div><pre class="programlisting">private bool m_Isisposed = false;private bool m_IsInitialized = false;
private bool m_IsFullScreen = false;private bool m_IsPaused = false;
private RenderForm m_Form;private Color4 m_ClearColor;
private long m_CurrFrameTime;private long m_LastFrameTime;
private int m_FrameCount;private int m_FPS;</pre></div><p>Most of these are fairly self-explanatory, but I'll run through them just in case.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>The downloadable code for this book is fully commented. I've removed comments here to save space and make the page look clean.</p></div></div><p>Here is a <a id="id21" class="indexterm"/>list of our member variables and what each one is for:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Member variables</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_IsDisposed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Simply indicates whether or not our game window has been disposed of.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_IsInitialized</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates whether or not our game window has been initialized yet.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_IsFullScreen</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates whether or not the game window is running in full-screen mode.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_IsPaused</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This, of course, indicates whether or not the game window is paused.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_Form</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This holds the SlimDX <code class="literal">RenderForm</code> object that represents the game window itself.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_ClearColor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This simply specifies the color to use whenever the screen is cleared. This is essentially the background color that we start with when we draw our scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_CurrFrameTime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Holds the time in ticks when we start processing the current frame.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_LastFrameTime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Holds the time in ticks when we start processing the previous frame.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_FrameCount</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is only used by the debug code in the <code class="literal">GameLoop()</code> method.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">m_FPS</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Holds the current FPS (frames per second) that the game loop is running at.</p>
</td></tr></tbody></table></div><p>Now that <a id="id22" class="indexterm"/>we've created our member variables, we need to make some <strong>properties</strong> to provide access to the ones that need to be accessible from outside of this class. A property is just a pair of methods for getting and setting the value of the member variable it represents. These methods are often called <strong>accessor methods</strong>
<a id="id23" class="indexterm"/> or <strong>accessors</strong>. Most of the variables we just created will have accessors, but we don't have room to show them all here, so we will just look at the first one.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Check out the downloadable code to see the rest of the accessor methods.</p></div></div><p>Here is the code for the <a id="id24" class="indexterm"/>
<code class="literal">ClearColor</code> property:</p><div><pre class="programlisting">public Color4 ClearColor
{
  get
  {
    return m_ClearColor;
  }
  protected set
  {
    m_ClearColor = value;
  }
}</pre></div><p>As you can <a id="id25" class="indexterm"/>see, the <code class="literal">ClearColor</code> property defines both<a id="id26" class="indexterm"/> the <code class="literal">get</code> and <code class="literal">set</code> methods. The <code class="literal">set</code> method<a id="id27" class="indexterm"/> is declared <code class="literal">protected</code> so that <a id="id28" class="indexterm"/>this property can only be set by this class or subclasses.</p><div><div><div><div><h2 class="title"><a id="ch01lvl3sec01"/>The constructor</h2></div></div></div><p>Now we need to <a id="id29" class="indexterm"/>set up a constructor for our <code class="literal">GameWindow</code> class. Here is<a id="id30" class="indexterm"/> the code:</p><div><pre class="programlisting">public GameWindow(string title, int width, int height, bool fullscreen)
{
  // Store parameters in member variables.
  m_IsFullScreen = fullscreen;
  m_ClearColor = new Color4(1.0f, 0.0f, 0.0f, 0.0f);
  // Create the game window that will display the game.
  m_Form = new RenderForm(title);
  m_Form.ClientSize = new System.Drawing.Size(width, height);
  // Hook up event handlers so we can receive events from the form
  m_Form.FormClosed += FormClosed;
}</pre></div><p>The first two lines of code simply set the basic properties of the window to the values that have been passed into the constructor. The next line sets the default color, which is black. This means that each time we draw a new frame, we start with an empty black screen. The color is an <strong>ARGB</strong> (<strong>Alpha, Red, Green, and Blue</strong>) value. As you can see, this line sets all of the <a id="id31" class="indexterm"/>color channels to a value of <code class="literal">0.0f</code> (except for alpha)<code class="literal"> </code>which gives us the color black. A value of <code class="literal">1.0f</code> for alpha means the color is opaque, while a value of <code class="literal">0.0f</code> would make it completely transparent. A value of <code class="literal">0.5f</code> would make the color 50 percent transparent.</p><p>The next two lines create the <code class="literal">RenderForm</code> object, set its title text, and initialize it to the size that was passed into the constructor. <code class="literal">RenderForm</code> is a SlimDX class that represents a window for us to draw on. And finally, the last line simply subscribes the <code class="literal">GameWindow</code> class to the <code class="literal">Closed</code> event of the <code class="literal">RenderForm</code> object. This causes the <code class="literal">GameWindow</code> class to be notified when the window is closed.</p><p>Now that we <a id="id32" class="indexterm"/>have our constructor, we need to define an event handler for <a id="id33" class="indexterm"/>the event we just subscribed the <code class="literal">GameWindow</code> class to. As you might guess, this event is fired when the game window is closed (either by the user or programmatically). Here is the code, which is pretty short as you can see:</p><div><pre class="programlisting">public virtual void FormClosed(object o, FormClosedEventArgs e)
{
  if (!m_IsDisposed)
    Dispose();
}</pre></div><p>The <code class="literal">if</code> statement checks to see if the game window has already been disposed of. If not, then it calls the <code class="literal">Dispose()</code> method<a id="id34" class="indexterm"/> to dispose of it.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl3sec02"/>The IDisposable interface</h2></div></div></div><p>Currently, the declaration of our <code class="literal">GameWindow</code> class says that it does not inherit from any other<a id="id35" class="indexterm"/> class, nor does it implement an interface. We are going to <a id="id36" class="indexterm"/>change this because we are going to implement the <code class="literal">IDisposable</code> interface. It is a very small interface so implementing it will be quick. First, we need to edit the declaration of our class to say that it will be implementing this interface. To do this, simply go to the beginning of the <code class="literal">GameWindow</code> class and change <code class="literal">public class GameWindow</code> to <code class="literal">public class GameWindow : IDisposable</code>.</p><p>This tells the compiler that this class implements the <code class="literal">IDisposable</code> interface. Now we have to adhere to this interface. It has one method that we need to implement. This method will perform cleanup operations when the game window is closed. There isn't much in this function at the moment, but here it is:</p><div><pre class="programlisting">protected virtual void Dispose(bool disposing)
{
  if (!this.m_IsDisposed)
  {
    if (disposing)
    {
      // Unregister eventsm_Form.FormClosed -= this.FormClosed;
      // get rid of managed resources here
    }
  // get rid of unmanaged resources here
  }
  m_IsDisposed = true;
}</pre></div><p>The <code class="literal">Dispose(bool)</code> method<a id="id37" class="indexterm"/> is protected because we do not want it to be called from outside of the <code class="literal">GameWindow</code> class. Instead, we will create the second <code class="literal">Dispose()</code> method<a id="id38" class="indexterm"/> that is <code class="literal">public</code> and has no parameters. This way we can tell the object that we are done with it by calling this public method, and it will take care of cleaning up after itself. The <code class="literal">Dispose(bool)</code> method starts by checking to see if the game window has already been disposed of. If not, then it checks to see if the <code class="literal">disposing</code> parameter is set to <code class="literal">true</code>. This parameter simply indicates whether the game window is disposing of itself or whether it is being disposed of by the <strong>Garbage Collector</strong>.</p><p>The Garbage Collector<a id="id39" class="indexterm"/> is a part of managed languages such as C#. When your program is no longer using an object, the Garbage Collector will reclaim the<a id="id40" class="indexterm"/> memory that object was using so that it can be used for<a id="id41" class="indexterm"/> something else. This will only happen if the program no longer has any references to the object. However, the Garbage Collector is not guaranteed to reclaim that memory immediately.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>You should avoid creating large numbers of objects that you only use for a short time. This can keep the Garbage Collector much busier and you will pay the price in the form of lower FPS or lag spikes.</p></div></div><p>If the <code class="literal">disposing</code> parameter is set to <code class="literal">true</code>, then the code inside the <code class="literal">if</code> statement will unregister events and call the <code class="literal">Dispose()</code> method on any managed objects it is using. Currently, it only unregisters the <code class="literal">Closed</code> event that we previously subscribed to. Then, the code following the <code class="literal">if</code> statement cleans up any unmanaged objects that it may be using. We won't have any unmanaged objects since we are using only <strong>managed</strong> code. Managed means that<a id="id42" class="indexterm"/> memory management is handled automatically for us for the most part.</p><p>Lastly, at the end of this method, the <code class="literal">m_IsDisposed</code> member variable is set to <code class="literal">true</code>. This indicates that the window has been disposed of so the <code class="literal">RenderScene()</code> method will know that it should not try to render anything anymore, as doing so can cause the program to crash. We'll discuss the <code class="literal">RenderScene()</code> method in a moment, but first we need to <a id="id43" class="indexterm"/>finish with <code class="literal">IDisposable</code>.</p><p>Now we have to implement the public <code class="literal">Dispose()</code> method, which is a very short method as you can see in the following code snippet:</p><div><pre class="programlisting">public void Dispose()
{
  Dispose(true);

  // Since this Dispose() method already cleaned up the resources 
    used
  // by this object, there's no need for the Garbage Collector to
    call
  // this class's Finalizer, so we tell it not to
  GC.SuppressFinalize(this);
}</pre></div><p>This <a id="id44" class="indexterm"/>method calls the <code class="literal">Dispose(bool)</code> method to dispose of the <a id="id45" class="indexterm"/>game window. The value <code class="literal">true</code> is passed in because this method is part of the <code class="literal">GameWindow</code> class, and thus the <code class="literal">GameWindow</code> class is disposing of itself in this case. Then we call <code class="literal">GC.SuppressFinalize(this)</code> to tell the Garbage Collector that this object has already been disposed of. You may have noticed that we never implemented <code class="literal">Finalizer</code> in this class. This is because the <code class="literal">Finalize()</code> method is used to clean up unmanaged resources in the object. It is called automatically by the Garbage Collector before it destroys the object. This allows it to clean up its unmanaged resources before it is destroyed. As such, we do not need to implement this method since we are only using managed code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The GameLoop method</h1></div></div></div><p>Now we need to create our game loop. As mentioned earlier, the game loop is the main block of code that repeats endlessly until we close our game. It calls the code that will process and draw each frame, so it is essentially<a id="id46" class="indexterm"/> the heart of the game. We <a id="id47" class="indexterm"/>will create a new <code class="literal">GameLoop()</code> method that will be our game loop. Here is the code:</p><div><pre class="programlisting">public virtual void GameLoop()
{
  m_LastFrameTime = m_CurrFrameTime;
  m_CurrFrameTime = Stopwatch.GetTimestamp();

  UpdateScene((double) (m_CurrFrameTime - m_LastFrameTime) / Stopwatch.Frequency);

  RenderScene();

  // This code tracks our frame rate.
  m_nFPS = (int)(Stopwatch.Frequency / ( (float) (m_CurrFrameTime – m_LastFrameTime)));
}</pre></div><p>In this function, we first take the value of <code class="literal">m_CurrFrameTime</code> and copy it into <code class="literal">m_LastFrameTime</code>. Each time this function is called, we are processing a new frame. This means the value in <code class="literal">m_CurrFrameTime</code> now is the time for the previous frame. So we copy it into that variable. Next, we get the current time from the high performance timer and store it in <code class="literal">m_CurrFrameTime</code> via the <code class="literal">StopWatch</code> class. This class uses the high performance hardware timer, if it is available. Most PCs now have them, so this should not be a problem. Next, we go ahead and call the <code class="literal">UpdateScene()</code> and <code class="literal">RenderFrame()</code> methods. The <a id="id48" class="indexterm"/>
<code class="literal">UpdateScene()</code> method is just an empty method <a id="id49" class="indexterm"/>for now, as shown in the following code snippet:</p><div><pre class="programlisting">public virtual void UpdateScene(double frameTime)
{
}</pre></div><p>Lastly, we <a id="id50" class="indexterm"/>calculate our FPS based on the duration of the <a id="id51" class="indexterm"/>previous frame. We simply take <code class="literal">StopWatch.Frequency</code> and divide it by the duration of the previous frame.</p><p>The parameter of the <code class="literal">UpdateScene()</code> method is the amount of time that has elapsed since the last time <code class="literal">UpdateScene()</code> was called. So we calculate that by subtracting the previous frame's time from the current frame's time. We then divide by <code class="literal">StopWatch.Frequency</code> to convert the result into seconds. This is necessary because the <code class="literal">StopWatch.GetTimeStamp()</code> function returns the current time in ticks. Essentially, it is a count of how many ticks have elapsed on the system timer since Windows was last booted up. The <code class="literal">StopWatch.Frequency</code> property tells us how many ticks our system timer does in one second. This is important because the timer in one computer may be faster or slower than the timer in another. The <code class="literal">RenderScene()</code> method is mostly empty for now too, but it does have a simple <code class="literal">if</code> statement in it though. Here is its code:</p><div><pre class="programlisting">public virtual void RenderScene()
{
  if ((!this.IsInitialized) || this.IsDisposed)
  {
    return;
  }
}</pre></div><p>The <code class="literal">if</code> statement in the <code class="literal">RenderScene()</code> method checks to see if the game window is ready for rendering. If the game window has not been initialized yet, or if the game window has been disposed of, then we simply return out of this function. This is important because it prevents possible crashing when the game window first starts up and when it shuts down.</p><p>Note that <code class="literal">IsInitialized</code> and <code class="literal">IsDisposed</code> are two of the properties we talked about earlier for our member variables.</p><p>We almost have a functional <code class="literal">GameWindow</code> class now. But we need to add a <code class="literal">StartGameLoop()</code> method. This method is called to start up the game loop. It only contains the following few lines of code:</p><div><pre class="programlisting">public void StartGameLoop()
{
  // If initialization is already finished, then simply return.
  if (m_IsInitialized)
    return;

  m_IsInitialized = true;

  // Start the message pump.
  MessagePump.Run(m_Form, GameLoop);
}</pre></div><p>First, this <a id="id52" class="indexterm"/>function checks if the game window has already <a id="id53" class="indexterm"/>been initialized. If so, then we simply return out of this function. Otherwise, we set the <code class="literal">m_IsInitialized</code> member variable to <code class="literal">true</code> to indicate that it has been initialized. This function is essentially the initialization function for our game loop. And lastly, it calls <code class="literal">MessagePump.Run</code> passing in our <code class="literal">RenderForm</code> object (the game window itself) and our <code class="literal">GameLoop()</code> function. This will cause the <code class="literal">GameLoop()</code> function to be called repeatedly until we close the game window. (<code class="literal">RenderForm</code> and <code class="literal">MessagePump</code> are SlimDX classes.)</p><p>So why do we need <code class="literal">MessagePump</code>? In Windows, applications receive messages, which are just notifications that something has occurred. For example, a key press will generate a key pressed message. These messages are sent to whichever window is currently active. That program can then process and respond to the message.</p><p>In a game, we want a loop that runs continuously to simulate and draw each frame immediately after the previous one. We still have to handle messages from Windows though, or our game window will not work correctly anymore. For example, if we just had the program stuck in a loop, never checking Windows messages, then nothing will happen when you try to close the window since the program will never process the close message. So, we use this <code class="literal">MessagePump</code> class to handle Windows messages for us while running our game loop.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Testing our game window</h1></div></div></div><p>It is now time for us to test our game window! We will add a second project to our solution. With<a id="id54" class="indexterm"/> the <code class="literal">SlimFramework</code> solution still open, open the <strong>FILE</strong> menu, and select <strong>New Project...</strong>. Name the new project, for example, <code class="literal">Ch01</code>. Make sure you change the selected project type to <strong>Windows Forms Application</strong>. Also, it is very important that you make sure that the <strong>Solution</strong> drop-down list at the bottom of the window is set to <strong>Add to solution</strong> or Visual Studio will create a new solution instead of adding this project to our existing solution. If this option is not present, then it will add the new project to this solution.</p><p>Click on <strong>OK</strong> and the new project will be created and added to our solution. Right-click on it in the <strong>Solution Explorer</strong> pane and choose <strong>Set as StartUp Project</strong>. By doing this, we've told <a id="id55" class="indexterm"/>Visual Studio that this is the project we want to start up when we tell it to run our code.</p><p>The <code class="literal">SlimFramework</code> project can't be the startup project since it is just a class library, and therefore cannot execute on its own. This is because the <code class="literal">Class Library</code> project type does not have the <code class="literal">Main</code>
<strong> </strong>method, like a <code class="literal">Console Application</code> or <code class="literal">Windows Forms Application</code> does. A Main Method is the first method that is called when the program starts up. So it is essentially the starting point of the program. You should also delete the <code class="literal">Form1.cs</code> file from this new project since we don't need it.</p><p>Now we need to add a reference to our project. Right-click on the <strong>References</strong> heading for the <code class="literal">Ch01</code> project in the <strong>Solution Explorer</strong> pane. Then click on <strong>Add Reference...</strong>. In the <strong>Reference Manager</strong> window, select the <strong>Projects</strong> category. Now check the checkbox next to the <code class="literal">SlimFramework</code> project. Click on <strong>OK</strong> and Visual Studio will add a reference to the <code class="literal">SlimFramework</code> project into the <code class="literal">Ch01</code> project. We can now use classes defined in the <code class="literal">SlimFramework</code> project in <code class="literal">Ch01</code>.</p><p>Next, we need to add a couple of lines of code to the <code class="literal">Main</code> method in our new <code class="literal">Ch01</code> project. Here is the code:</p><div><pre class="programlisting">static void Main(string[] args)
{
  Application.EnableVisualStyles();
  Application.SetCompatibleTextRenderingDefault(false);

  SlimFramework.GameWindow gameWindow = new SlimFramework.GameWindow("Our First Game Window", 640, 480, false);

  gameWindow.StartGameLoop();
}</pre></div><p>This code is fairly simple. The first two lines were already there, created by Visual Studio. I removed the third line that Visual Studio added—which made a call to <code class="literal">Application.Run()</code>—since we don't need it. The next line simply creates a new <code class="literal">GameWindow</code> object and passes in parameters to specify the title of the window, the width and height of the window, and lastly whether or not we want to run it in fullscreen mode. In this case, we set the window title to <code class="literal">Our First Game Window</code>, and the window size to <code class="literal">640x480</code>. And lastly, we pass in the value <code class="literal">false</code> for the last parameter since we do not want to run in fullscreen mode, as we haven't implemented it yet anyway. The last line of code in this method calls the <code class="literal">GameWindow</code> class's <code class="literal">StartGameLoop()</code> method to start up the game loop. The parameter of the <code class="literal">Main()</code> method is simply a <code class="literal">String</code> array that contains any command-line arguments that were passed in when the application was started. You would simply add code somewhere that would process the passed in command-line arguments, if any. This is how you would add some command-line switches to your game.</p><p>We are <a id="id56" class="indexterm"/>now ready to compile and run our code. To do this, click on the <strong>Start</strong> button on Visual Studio's toolbar. This button has a green triangle icon beside it. The following screenshot shows what our game window looks like when you run the program. You may recall that we set black as our default background color, but the background of this window is not very black. This is not a bug, it is simply because we have no drawing code yet.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>If you get an error stating that <strong>A project with an Output Type of Class Library cannot be started directly</strong> when you try to run the program, it means that you forgot to set <code class="literal">Ch01</code> as the startup project as mentioned earlier.</p></div></div><p>The following screenshot shows our game window in action:</p><div><img src="img/7389OS_01_05.jpg" alt="Testing our game window"/><div><p>The game window in action</p></div></div><p>It's not that impressive now, but it won't be too much longer before we can start rendering some graphics on the screen, which makes things a lot more interesting.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we got Visual Studio and SlimDX set up and ready to go. We created a project to work in and built the beginnings of our little framework. It consists only of our <code class="literal">GameWindow</code> class for now, which creates a game window for us to draw our game on. We gave our <code class="literal">GameWindow</code> class a constructor and also covered the <code class="literal">GameLoop</code> function. We gave it <code class="literal">UpdateScene()</code> and <code class="literal">RenderScene()</code> methods for updating and drawing our game world at each frame. We also covered interfaces, specifically the <code class="literal">IDisposable</code> interface, and gave the game window a <code class="literal">ToggleFullscreen()</code> method. And finally, we tested our game window and saw it in action for the first time. In the next chapter, we will dive into user input and how to respond to the player's actions.</p></div></body></html>