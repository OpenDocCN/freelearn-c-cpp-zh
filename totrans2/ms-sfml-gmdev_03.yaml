- en: Chapter 3.  Make It Rain! - Building a Particle System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 让它下雨！——构建粒子系统
- en: Having the right amount of interactivity in any given game is incredibly important.
    Whether it amuses the player by having their consequences start chain reactions
    that eventually impact their state, or it simply means that the controls and input
    management feel just right, one cannot deny that this is one of the few things
    that can either make or break a game. While the latter is quite important, it's
    not the smooth navigation of menus that draw most gamers in, which is why in this
    chapter we are going to be focusing on environmental interactions, as well as
    stylization through the means of particle systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何游戏中拥有适当的交互性至关重要。无论是通过让玩家的后果引发连锁反应最终影响他们的状态来娱乐玩家，还是仅仅意味着控制感和输入管理感觉恰到好处，不可否认的是，这是为数不多的可以使游戏成功或失败的因素之一。虽然后者非常重要，但并不是菜单的流畅导航吸引了大多数玩家，这就是为什么在本章中我们将重点关注环境交互以及通过粒子系统实现的美化。
- en: 'In this chapter, we''re going to be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Benefits of the **Structure of Arrays** storage pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组结构**存储模式的优点'
- en: Architecture and implementation of a flexible particle system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活粒子系统的架构和实现
- en: Creation of different types of generator and updater objects that allow a wide
    variety of effects to be created
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不同类型的生成器和更新器对象，允许创建各种效果
- en: There is quite a bit to learn, so let us not waste any time and dive right in!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多东西需要学习，所以我们不要浪费时间，直接深入吧！
- en: Use of copyrighted resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的使用
- en: 'As always, let us begin by acknowledging all of the generous artists out there,
    who make all of this possible by providing assets under incredibly flexible licenses:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们首先感谢所有慷慨的艺术家，他们通过提供在极其灵活的许可下提供的资产，使这一切成为可能：
- en: '*misc png* by *dbszabo1* under the **CC0** license (public domain): [http://dbszabo1.deviantart.com/art/misc-png-316228902](http://dbszabo1.deviantart.com/art/misc-png-316228902)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*dbszabo1*创作的*misc png*，根据**CC0**许可（公有领域）：[http://dbszabo1.deviantart.com/art/misc-png-316228902](http://dbszabo1.deviantart.com/art/misc-png-316228902)
- en: '*Jillcreation-overlay-cloud* by *Juan Story* under the **CC0** license (public
    domain): [http://www.effecthub.com/item/5358](http://www.effecthub.com/item/5358)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Juan Story*创作的*Jillcreation-overlay-cloud*，根据**CC0**许可（公有领域）：[http://www.effecthub.com/item/5358](http://www.effecthub.com/item/5358)
- en: '*[LPC] Leaf Recolor* by *William.Thompsonj* under the **CC-BY-SA 3.0** and
    **GPL 3.0** licenses: [http://opengameart.org/content/lpc-leaf-recolor](http://opengameart.org/content/lpc-leaf-recolor)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*William.Thompsonj*创作的[LPC] Leaf Recolor，根据**CC-BY-SA 3.0**和**GPL 3.0**许可：[http://opengameart.org/content/lpc-leaf-recolor](http://opengameart.org/content/lpc-leaf-recolor)
- en: Particle system basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统基础
- en: There are quite a few things we first need to cover in order to get to the more
    meaty parts of implementing the particle system. Understanding certain concepts
    is key to making our system work as intended, starting with the way data is stored.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现粒子系统之前，我们需要先了解一些关键概念，以便使我们的系统按预期工作，首先是从数据存储的方式开始。
- en: Array of structs versus struct of arrays
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体数组与数组结构体
- en: 'It may be tempting at first to simply stick all of the data a particle has
    into a single class, give it some custom methods for handling certain situations,
    and store all of these objects in some generic container, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能会让人想将粒子拥有的所有数据都放入一个单独的类中，给它一些处理特定情况的自定义方法，并将所有这些对象存储在某个通用容器中，如下所示：
- en: '![Array of structs versus struct of arrays](img/image_03_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![结构体数组与数组结构体对比](img/image_03_001.jpg)'
- en: 'While it''s certainly easier this way, it doesn''t help with performance at
    all. Keep in mind that we''re probably going to be dealing with thousands, if
    not tens of thousands of instances of particles, all of which need to be updated
    in a variety of different ways. A simple update loop that works with particles
    may end up making the cache look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做确实更简单，但对性能的提升却微乎其微。请记住，我们可能需要处理成千上万的粒子实例，而且这些实例需要以各种不同的方式更新。一个简单的粒子更新循环可能会使缓存看起来像这样：
- en: '![Array of structs versus struct of arrays](img/image_03_002.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![结构体数组与数组结构体对比](img/image_03_002.jpg)'
- en: This is terrible as far as performance is concerned, because if we only need
    to work with positions, that means all of the additional space in the cache that
    could be used to store positions of other particles now holds useless data that
    will not be used at all, at least not now. In turn, when it's time to update another
    particle and its position is requested, it will most likely not be found inside
    the cache, resulting in a cache miss and time wasted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，这真是太糟糕了，因为如果我们只需要处理位置，这意味着缓存中所有额外的空间，本可以用来存储其他粒子的位置，现在却只存储了完全无用的数据，至少现在是这样。反过来，当需要更新另一个粒子的位置并请求它时，它很可能不会在缓存中找到，从而导致缓存未命中和时间的浪费。
- en: 'A much better scenario would look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的场景可能看起来像这样：
- en: '![Array of structs versus struct of arrays](img/image_03_003.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![结构体数组与数组结构体](img/image_03_003.jpg)'
- en: 'This is much better in terms of performance, as all of the data that exists
    in the cache is guaranteed to be used. How do we achieve such a result? By storing
    different particle properties in their own containers, where the memory is ensured
    to be contiguous, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，这要好得多，因为缓存中存在的所有数据都保证会被使用。我们如何实现这样的结果？通过将不同的粒子属性存储在自己的容器中，确保内存的连续性，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Storage, however, isn't everything. We must also make sure that whenever we
    are working with structures such as this, only the relevant and necessary data
    is being used. That part, however, will be addressed later down the line.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存储并不是一切。我们还必须确保，当我们处理此类结构时，只使用相关和必要的数据。然而，这部分内容将在稍后讨论。
- en: Storing particles
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子的存储
- en: 'With the key concept out of the way, let us take a look at how particles can
    be stored using the **SoA** pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了关键概念之后，让我们看看如何使用**SoA**模式存储粒子：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are a couple of ways particle properties can be stored and accounted for.
    Here, we're using C-style arrays along with a static constant that denotes their
    sizes. All of these properties, as well as their purposes, will be covered in
    later segments of the chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和计算粒子属性有几种方法。在这里，我们使用C风格的数组以及一个表示它们大小的静态常量。所有这些属性以及它们的目的将在本章的后续部分中介绍。
- en: 'A few extra things that are beneficial to keep track of here are the count
    of particles that are still alive and a pointer to the texture manager, since
    some of these suckers may be using textures that need to be grabbed and released.
    They are, of course, set up properly inside the constructor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里还有一些额外的好处是跟踪粒子的数量，以及指向纹理管理器的指针，因为其中一些可能正在使用需要抓取和释放的纹理。当然，它们在构造函数中设置得很好：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The destructor of this container class has a fairly simple job. All it needs
    to do, in order to not leave any loose ends, is loop through every particle stored
    and check if it is using a texture, which is just a string identifier. If it is,
    the texture is released.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器类的析构函数有一个相当简单的工作。为了不留下任何悬而未决的问题，它只需要遍历存储的每个粒子，并检查它是否正在使用纹理，这只是一个字符串标识符。如果是，则释放纹理。
- en: 'Another fairly important task that was left up to the constructor is resetting
    all of the allocated memory for the particles. This is left to the `Reset()` method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当重要的任务留给了构造函数，即重置粒子的所有分配内存。这留给`Reset()`方法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ResetParticle` private method is invoked for each single particle in the
    list. It is responsible for actually zeroing all of the data out to make sure
    the next particle that gets the same identifier will not possess certain properties
    carried over from the previous particle that owned it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResetParticle`私有方法为列表中的每个单独的粒子调用。它负责将所有数据归零，以确保下一个获得相同标识符的粒子不会携带前一个拥有它的粒子遗留的某些属性。'
- en: 'In order to actually manage the SoA structure efficiently, we''re going to
    be using these two key methods for enabling and disabling a particular ID:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地管理SoA结构，我们将使用这两个关键方法来启用和禁用特定的ID：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A sanity check is performed first in order to make sure we''re not enabling
    any particles if the maximum amount already exists, or disabling any if there
    are no active ones. Enabling a particle simply requires its *alive* flag to be
    set to *true*, while disabling calls for a complete reset. All of the data stored
    at `l_id` is then swapped with either the element after the last active particle
    when enabling in order to make it last, or with the very last particle when disabling.
    Consider the following illustration:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先进行一次合理性检查，以确保我们不会在已经存在最大数量粒子的情况下启用任何粒子，或者在没有活跃粒子的情况下禁用任何粒子。启用粒子只需将其*存活*标志设置为*true*，而禁用则需要完全重置。然后，所有存储在`l_id`的数据都会在启用时与最后一个活跃粒子的元素交换，以使其成为最后一个，或者在禁用时与最后一个粒子交换。请考虑以下说明：
- en: '![Storing particles](img/image_03_004.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![存储粒子](img/image_03_004.jpg)'
- en: Although it covers the scenario of disabling a particle, the same basic principle
    holds up for enabling as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它涵盖了禁用粒子的场景，但同样的基本原理也适用于启用。
- en: 'Actual data swapping isn''t a very complicated process:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的数据交换过程并不复杂：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It simply invokes `std::swap` on every single particle property at the `l_first`
    and `l_second` indices.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地在对每个单个粒子的属性在`l_first`和`l_second`索引上调用`std::swap`。
- en: 'Finally, we get to the actual reset code for a single particle:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了单个粒子的实际重置代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Predictably, every single particle parameter is reset to an appropriate default
    value at the provided index. If the texture identifier is not empty, the resource
    also gets released, since it is no longer needed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 预计，每个粒子的参数都会重置到提供的索引处的适当默认值。如果纹理标识符不为空，资源也会被释放，因为不再需要它。
- en: Particle system architecture
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子系统架构
- en: 'In order to cater for the way particles are stored and still provide a means
    of updating, interaction, and flexibility to the system, we must carefully address
    its architecture. Let''s begin by breaking it down into smaller parts that will
    be easier to manage on their own:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应粒子的存储方式，同时为系统提供更新、交互和灵活性的手段，我们必须仔细考虑其架构。让我们先将其分解成更小的部分，这样更容易单独管理：
- en: '**Emitter**:an object that exists in the world and acts as a particle spawner.
    It has access to a list of generators that each emitted particle is fed through
    before it gets spawned.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射器**：存在于世界中的一个对象，充当粒子生成器。它有权访问一个生成器列表，每个发射出的粒子在生成之前都会通过这些生成器。'
- en: '**Generator**:this belongs to a list of other similar objects that have direct
    access to particle properties and modify them according to their own, pre-defined
    rules in order to achieve a certain look.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器**：这属于其他具有直接访问粒子属性并根据它们自己的、预先定义的规则修改它们以实现某种外观的类似对象的列表。'
- en: '**Updater**:one of many objects owned by the particle system, and designed
    to only use the data it needs for a specific task, which is always related to
    updating particles in a specific way.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新器**：粒子系统拥有的许多对象之一，旨在仅使用特定任务所需的数据，该任务始终与以特定方式更新粒子相关。'
- en: '**Force applicator**:a small data structure, used by one of the updaters in
    order to create *forces* in the world, which physically interact with the particles.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力应用器**：一个小型数据结构，由一个更新器使用，以在世界上创建*力*，这些力与粒子进行物理交互。'
- en: Let us take some time and look at each individual piece in more depth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花些时间深入探讨每个单独的部分。
- en: The generator
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器
- en: 'A generator within this context is going to act as a stamp in a way. It will
    take in a range of particles, the properties of which are going to be adjusted
    according to the type of generator that received them. Consider this illustration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语境中，发生器将充当一种盖章的作用。它将接收一系列粒子，这些粒子的属性将根据接收它们的生成器的类型进行调整。请考虑以下说明：
- en: '![The generator](img/image_03_005.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![生成器](img/image_03_005.jpg)'
- en: A specific generator can be almost considered as a stamp of sorts. Some of the
    properties it imprints on a particle can be random, while others are constant.
    Either way, once a few particles are fed into it, they come out *stamped* with
    the properties that the generator is responsible for.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的生成器几乎可以被视为一种盖章。它印在粒子上的某些属性可能是随机的，而其他属性则是恒定的。无论如何，一旦将几个粒子输入其中，它们就会带有生成器负责的属性而被“盖章”。
- en: 'All the generators we''re going to be implementing need to be generalized,
    which is why they all must obey by the provided interface:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的所有生成器都需要是通用的，这就是为什么它们都必须遵守提供的接口：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, the `Generate()` method needs some explaining. It takes in a pointer
    to the `Emitter` instance that owns it. It also takes a pointer to the particle
    container it's going to be working with. The last two arguments are particle IDs
    that form a range, which represents particles that will be enabled inside the
    container. The range itself is going to be calculated inside the emitter that
    owns the generator.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要解释一下`Generate()`方法。它接受一个指向拥有它的`Emitter`实例的指针。它还接受一个指向它将要与之一起工作的粒子容器的指针。最后两个参数是构成范围的粒子ID，这代表容器内将启用的粒子。范围本身将在拥有生成器的发射器内部计算。
- en: This base class also allows derivative generators to implement how their properties
    are loaded from files. This will be important later, when we start actually creating
    different types of generators.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类还允许派生生成器实现如何从文件中加载它们的属性。这将在我们开始实际创建不同类型的生成器时变得很重要。
- en: The emitter
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发射器
- en: 'As mentioned previously, an emitter is simply a class that owns a list of generators
    in order to spawn a specific type of particle. It can be positioned within the
    world, and is responsible for calculating particle ID ranges for emission by keeping
    track of its emit rate. Let''s take a look at the header of the `Emitter` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，发射器只是一个拥有生成器列表的类，以便生成特定类型的粒子。它可以在世界中定位，并负责通过跟踪其发射速率来计算发射的粒子ID范围。让我们看看`Emitter`类的头文件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, this class doesn't actually store a list of generator instances.
    Instead, it stores a string identifier that will be used to obtain the list for
    a specific style of particles from the particle system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类实际上并不存储生成器实例的列表。相反，它存储一个字符串标识符，该标识符将用于从粒子系统获取特定风格的粒子列表。
- en: All of the setters and getters in this class are simple one-line methods that
    perform exactly as advertised, so we won't be covering them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的所有设置器和获取器都是简单的单行方法，它们正好按照广告宣传的那样执行，所以我们不会涉及它们。
- en: Aside all of the other obvious data members, it stores a floating point value
    named `m_accumulator`, which is going to be used in conjunction with the emit
    rate. We'll go over it more very shortly. It also stores an `m_maxParticles` data
    member in order to know if particles should be emitted indefinitely, or if the
    emitter needs to stop after a certain amount have been created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有其他明显的数据成员之外，它还存储一个名为`m_accumulator`的浮点值，它将与发射速率一起使用。我们很快就会详细介绍它。它还存储一个`m_maxParticles`数据成员，以便知道是否应该无限期地发射粒子，或者发射器在创建了一定数量的粒子后需要停止。
- en: Implementing emitter
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现发射器
- en: 'Let''s start with the basics of simply initializing all data members to their
    default values:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将所有数据成员初始化为其默认值的基本开始：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The only real method of importance in this class is obviously the `Update()`
    method. It''s responsible for actually doing all of the heavy lifting when it
    comes to particle emission:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中唯一真正重要的方法是`Update()`方法。它负责在粒子发射时进行所有实际的重负载工作：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Naturally, the updating is not going to happen if either the generator identifier
    is empty, or we were unable to obtain the list of generators from the particle
    system. Provided that isn't the case, the `m_accumulator` data member is added
    to based on the emit rate and **delta time**. It holds the total number of particles
    that have yet to be emitted. Since we obviously can't emit half of a particle,
    or any other fraction for that matter, the accumulator data member is checked
    to see whether it's less than one. If that's the case, there is nothing to emit/update.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果生成器标识符为空，或者我们无法从粒子系统中获取生成器列表，更新将不会发生。只要不是这种情况，`m_accumulator` 数据成员就会根据发射速率和**delta
    time**进行增加。它保存了尚未发射的粒子总数。由于显然我们不能发射半个粒子或任何其他分数，因此会检查累加器数据成员是否小于一。如果是这种情况，就没有东西可以发射/更新。
- en: The number of particles to be emitted is then calculated by simply converting
    the accumulator value to an integer. It is then subtracted from the accumulator,
    which retains whatever fraction of a particle is left for the next tick.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要发射的粒子数量通过将累加器值转换为整数来计算。然后从累加器中减去，保留剩余的粒子分数，以便在下一次滴答时使用。
- en: The way we know an emitter should keep on spitting particles out indefinitely
    is if its `m_maxParticles` data member is set to `-1`. If it isn't, the number
    of particles to be emitted this tick is checked for not having exceeded the limit.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道发射器应该无限期地喷射粒子的方式是，如果其`m_maxParticles`数据成员被设置为`-1`。如果不是这样，这一刻要发射的粒子数量将检查是否没有超过限制。
- en: Finally, we get to the interesting part. First, the range of IDs that will be
    brought back to life is calculated, making sure it doesn't go beyond the maximum
    number of particles allowed. The generator list for the type of particle the emitter
    is spitting out is then iterated over, with pointers to the current emitter, and
    the particle list being passed into their `Generate()` methods, alongside the
    calculated ranges. The range of particles is then iterated over and re-enabled
    to be displayed again, and the emitter is checked to see if it needs to be removed,
    should the `m_maxParticles` data member reach zero.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了有趣的部分。首先，计算将要复活的所有ID的范围，确保它不超过允许的最大粒子数。然后遍历发射器喷射出的粒子类型的生成器列表，将当前发射器的指针和粒子列表传递给它们的`Generate()`方法，同时传递计算出的范围。然后遍历粒子范围，重新启用以再次显示，并检查发射器是否需要被移除，如果`m_maxParticles`数据成员达到零。
- en: The updater
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新器
- en: 'In order to breathe life into our particle system, we must constantly keep
    it updated. Keeping performance in mind, we must stay true to the SoA pattern
    and only work with the data that is absolutely necessary for a particular scenario,
    as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的粒子系统充满活力，我们必须不断更新它。考虑到性能，我们必须坚持SoA模式，并且只处理特定场景绝对必要的数据，如下所示：
- en: '![The updater](img/image_03_006.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![更新器](img/image_03_006.jpg)'
- en: 'With that in mind, a very basic interface for all updaters can be put together,
    looking something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，可以为所有更新器创建一个非常基本的接口，看起来像这样：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All updaters should ever care about, as you can see, is the delta time and having
    a pointer to the particle container they are operating on. There is no need to
    provide it with ranges, as it will be operating on all *alive* particles.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有更新器应该关注的只是delta时间以及它们正在操作的粒子容器的指针。没有必要提供范围，因为它将操作所有*存活*粒子。
- en: Force applicators
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 力应用器
- en: 'Because we don''t want our character to be running around a static, dead environment,
    some interactivity between events and particles is required. This relationship
    is established via the means of forces, which impact the kinematic states of particles
    within reach, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望我们的角色在静态、死寂的环境中四处奔跑，所以需要事件和粒子之间的一些交互性。这种关系是通过力的方式建立的，它影响可达粒子动力学状态，如下所示：
- en: '![Force applicators](img/image_03_007.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![力应用器](img/image_03_007.jpg)'
- en: 'Force applicators are not fundamental to particle systems. All we need to do
    in order to generalize them is store some data, and let the appropriate updater(s)
    take care of the logic. Having said that, let us take a look at what we need to
    store:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 力应用器不是粒子系统的基本组成部分。我们为了使它们通用化所需做的只是存储一些数据，并让适当的更新器处理逻辑。话虽如此，让我们看看我们需要存储什么：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Forces can be positioned in the world, so their centers need to be stored. Additionally,
    a radius of the force is also necessary, in order to figure out the area of impact.
    Lastly, there can be no impact without first knowing how strong it is. This is
    where `m_force` comes in, by allowing force to be defined in all three axes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 力可以在世界中定位，因此需要存储其中心。此外，还需要知道力的半径，以便确定影响区域。最后，没有首先知道其强度，就无法产生影响。这就是`m_force`发挥作用的地方，它允许在所有三个轴向上定义力。
- en: Building the particle system class
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建粒子系统类
- en: 'With all of the building blocks in place, it''s time to actually build the
    particle system class. Let''s start with some type definitions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有构建块就绪之后，是时候实际构建粒子系统类了。让我们从一些类型定义开始：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to access any updater we want, we can map them to `string` identifiers.
    While the updaters aren't state-specific, emitters are. Their lists have to be
    associated with specific states in order to maintain particles across the entire
    application. Generators, just like updaters, aren't unique to any particular state,
    and we want to be able to access them via a string identifier from `Emitter` classes.
    Speaking of which, as evident from the code we've already covered, emitters can
    request removal of themselves in case they should stop emitting particles. Since
    that happens during the update cycle while the class is still in use, a separate
    list of emitter pointers must be kept for later removal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问我们想要的任何更新器，我们可以将它们映射到`string`标识符。虽然更新器不是状态特定的，但发射器是。它们的列表必须与特定的状态相关联，以在整个应用程序中维护粒子。生成器，就像更新器一样，也不是特定于任何特定状态的，我们希望能够通过`Emitter`类中的字符串标识符来访问它们。说到这里，正如我们从已经覆盖的代码中可以看出，发射器可以请求移除自身，以防它们应该停止发射粒子。由于这发生在更新周期中，而类仍在使用中，因此必须保留一个单独的发射器指针列表，以便稍后移除。
- en: Particles themselves are obviously stored within the designated `ParticleContainer`
    class, but these containers can, obviously, be possessed by different states.
    A similar idea applies as before, where we mapped state types to different particle
    containers in order to maintain application-wide particle support. The same exact
    principle also applies to force applicators.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子本身显然存储在指定的`ParticleContainer`类中，但这些容器显然可以被不同的状态拥有。这与之前类似的想法，我们将状态类型映射到不同的粒子容器，以维护应用程序范围内的粒子支持。相同的原理也适用于力应用器。
- en: The last data type we have should be a dead giveaway for the fact that we're
    going to be using the factory design pattern for producing different types of
    particle generator. These types will also be tied to string identifiers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的最后一种数据类型应该是一个明显的迹象，表明我们将使用工厂设计模式来生产不同类型的粒子生成器。这些类型也将与字符串标识符相关联。
- en: 'With all of that in mind, it''s time to discuss how the `ParticleSystem` class
    can be implemented, starting with its header:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，现在是时候讨论如何实现`ParticleSystem`类了，从其头文件开始：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, let us examine the inheritance subtleties of this class. Because we are
    going to have properties of particles saved inside text files, inheritance from
    `FileLoader` is useful, not to mention we get to offload the work to a separate
    thread. Also, recall that different states will need to be provided access to
    our particle system, which means the particle manager must implement methods for
    adding, changing, and removing states. Lastly, keep in mind that particle emitters
    and the different forces that impact them may be something game maps contain,
    so we're also inheriting from the `MapLoadee` class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来探讨这个类的继承细节。因为我们将在文本文件中保存粒子的属性，所以从`FileLoader`继承是有用的，更不用说我们可以将工作卸载到单独的线程上。此外，回想一下，不同的状态将需要访问我们的粒子系统，这意味着粒子管理器必须实现添加、更改和删除状态的方法。最后，请记住，粒子发射器和影响它们的力可能是游戏地图包含的内容，因此我们也在继承`MapLoadee`类。
- en: The class itself obviously needs access to the texture manager, a pointer to
    which is later passed down to the classes that need it. The same is true for the
    random number generator, as well as a pointer to the map instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类本身显然需要访问纹理管理器，稍后会将一个指向它的指针传递给需要它的类。对于随机数生成器也是如此，以及地图实例的指针。
- en: Lastly, note the two highlighted data members of this class, which are both
    iterators. These are kept around for easier access to data that is state-specific
    while updating/rendering particles.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意这个类的两个突出显示的数据成员，它们都是迭代器。这些被保留下来是为了在更新/渲染粒子时更容易地访问特定状态的数据。
- en: Implementing the particle system
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现粒子系统
- en: 'Let''s start by taking a look at the constructor of this class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个类的构造函数：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Outside the initializer list that performs all of the data member set-up duties,
    there is only one other purpose for the constructor here: setting up all of the
    updaters and generator types. The code we have above is heavily abridged, but
    the idea remains the same. All of the updaters we want to use are inserted into
    their container with the appropriate string identifier attached. On the generator
    side, we invoke a private template method that ties a specific type of a generator
    to a string identifier. Once again, we are using the factory pattern here.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行所有数据成员设置任务的初始化列表之外，构造函数在这里的另一个目的就是设置所有的更新器和生成器类型。我们上面的代码被大量缩减，但基本思想保持不变。我们想要使用的所有更新器都通过适当的字符串标识符插入到它们的容器中。在生成器方面，我们调用一个私有模板方法，将特定类型的生成器与字符串标识符关联起来。再次强调，这里我们使用了工厂模式。
- en: 'Adding emitter objects to our particle system is relatively straightforward:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将发射器对象添加到我们的粒子系统中相对简单：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, the emitter is provided with a pointer to the particle system for later
    access. We then check if the emitter's generator list name is valid. It's pointless
    to have an emitter that is going to be spawning *empty* particles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为发射器提供一个指向粒子系统的指针，以便稍后访问。然后我们检查发射器的生成器列表名称是否有效。拥有一个将要产生 *空* 粒子的发射器是没有意义的。
- en: As evident from the class header, a default value to the second argument of
    this method is provided. This gives us a nice way to differentiate whether a user
    of this class wants to add an emitter to a specific state, or just the current
    state that is selected. Both of these possibilities are then handled in the remaining
    chunk of the code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如类头所示，此方法第二个参数提供了一个默认值。这为我们提供了一个很好的方法来区分用户是否希望将发射器添加到特定状态，或者只是当前选定的状态。这两种可能性随后在代码的剩余部分得到处理。
- en: 'Force applicators are dealt with in a very similar fashion:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 强制应用器以非常相似的方式处理：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, the second argument has a default value, so we handle both the possibilities
    before attempting to insert the force applicator data inside the appropriate container.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，第二个参数有一个默认值，因此我们在尝试将强制应用器数据插入适当的容器之前处理了这两种可能性。
- en: 'Removal of emitters, as mentioned in the data type section, has two stages.
    The first stage is simply putting a pointer to the emitter in a designated list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如数据类型部分所述，移除发射器有两个阶段。第一阶段是将发射器的指针放入指定的列表中：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The actual removal is handled elsewhere. We will be covering that shortly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的移除操作在其他地方处理。我们很快就会介绍这一点。
- en: 'Obtaining the generator list is important for the emission process, so naturally,
    we must have a method for that as well:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 获取生成器列表对于发射过程非常重要，因此，我们自然也需要一个方法来获取它：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we stumble upon the state-dependent part of the particle system, starting
    with state creation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遇到了粒子系统的状态相关部分，从状态创建开始：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, a determination needs to be made whether the state being created doesn't
    already, for some reason, have its own particle container allocated. If it doesn't,
    one is created and inserted into the state's particle container, as well as an
    emitter list, and a force applicator list for that same state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要确定正在创建的状态是否已经因为某种原因分配了自己的粒子容器。如果没有，就创建一个并将其插入到状态粒子的容器中，以及发射器列表和相同状态的强制应用器列表。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `CreateState()` method of the `StateDependent` class is the only piece of
    code that needs to be invoked manually, in case certain states don't need to utilize
    that particular state dependent resource.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateDependent` 类的 `CreateState()` 方法是唯一需要手动调用的代码，以防某些状态不需要使用特定的状态相关资源。'
- en: 'Next, let''s discuss how a state can be changed inside a particle system:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何在粒子系统中改变状态：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After a private method for changing its own internal state is invoked, the data
    member that holds an iterator to the particles of the current state is updated.
    The same exact thing is done to the emitter iterator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用一个用于改变其自身内部状态的私有方法之后，持有当前状态粒子迭代器的数据成员被更新。对发射器迭代器执行相同的操作。
- en: The next few lines of code may not make much sense within this context, since
    we have not worked on any updaters yet, but let us cover them anyway. Further
    down the line, we are going to have updaters for particle collisions and forces.
    As far as collisions go, the updater only needs to have a pointer to the game
    map, presuming the current state is `Game`. `ForceUpdater`, on the other hand,
    needs to have access to a list of force applicators for the current state. Both
    of these types of updater are accommodated here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，接下来的几行代码可能没有太多意义，因为我们还没有处理任何更新器，但无论如何让我们来覆盖它们。在接下来的步骤中，我们将拥有粒子碰撞和力的更新器。就碰撞而言，更新器只需要指向游戏地图的指针，假设当前状态是`Game`。另一方面，`ForceUpdater`需要能够访问当前状态的力量应用者列表。这两种类型的更新器都包含在这里。
- en: 'Let''s wrap up the state modification subject by taking a look at what happens
    inside a particle system when a state is removed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看在从粒子系统中删除状态时内部发生的情况来总结状态修改的主题：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All we do here is erase data from state-bound containers. Since there are two
    iterator data members kept around, those too must be reset in case the state being
    removed matches the current state. Because of the way our state system works,
    and the order of `ChangeState` and `RemoveState`, we don't need to worry about
    iterators being invalidated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是从状态绑定容器中删除数据。由于保留了两个迭代器数据成员，因此如果被删除的状态与当前状态匹配，也必须重置它们。由于我们的状态系统的工作方式和`ChangeState`与`RemoveState`的顺序，我们不需要担心迭代器被无效化。
- en: 'Our particle system will definitely have plenty of data to load from text files,
    which is why it inherits from a file loader class. Let us take a look at the method
    that every single line stream will be fed into:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的粒子系统肯定会有很多从文本文件中加载的数据，这就是为什么它继承自文件加载类。让我们看看每行流将被喂入的方法：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first string of each line, later referred to as type, is extracted. If we
    have a name, another string is attempted to be extracted, and later checked for
    matches inside the generator list, in order to avoid duplicates. The name of the
    generator list is stored inside the `m_loadingGenerator` data member.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的第一个字符串，后来被称为类型，被提取出来。如果我们有一个名称，另一个字符串将被尝试提取，并在生成器列表中进行匹配检查，以避免重复。生成器列表的名称存储在`m_loadingGenerator`数据成员中。
- en: If any other type is encountered, it is safe to assume we are dealing with a
    specific type of generator. If that is the case, the generator list name is first
    checked that it isnt't being empty, which would indicate a file format problem.
    The generator factory is then searched for the generator with the type loaded
    from the file. If it is found, a new generator instance is created through it,
    the stream object is passed to it to do its own loading via the `>>` operator,
    and the final instance is inserted into the generator list for the current type
    of `m_loadingGenerator`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到其他类型，可以安全地假设我们正在处理特定类型的生成器。如果是这种情况，首先会检查生成器列表名称是否为空，这会表明存在文件格式问题。然后，在生成器工厂中搜索从文件中加载的类型对应的生成器。如果找到了，就会通过它创建一个新的生成器实例，将流对象传递给它，通过`>>`操作符进行自己的加载，并将最终的实例插入到当前类型`m_loadingGenerator`的生成器列表中。
- en: 'Because we''re using a data member to keep file information around, it must
    be reset before attempting to load another file. Our `FileLoader` interface provides
    such functionality, given this method is overloaded:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用数据成员来保留文件信息，因此在尝试加载另一个文件之前必须重置它。我们的`FileLoader`接口提供了这样的功能，因为此方法被重载：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final base class the particle system is inheriting from, `MapLoadee`, requires
    us to implement a single method that will handle map file entries with its own
    custom types:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统最终继承的最终基类`MapLoadee`要求我们实现一个方法，该方法将处理具有自定义类型的地图文件条目：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, two different types of map entry are supported by the particle
    system: `ParticleEmitter` and `ForceApplicator`. In both cases, all of the appropriate
    data is streamed in and applied to the newly constructed objects, which are then
    added to the `Game` state.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，粒子系统支持两种不同的地图条目类型：`ParticleEmitter`和`ForceApplicator`。在两种情况下，所有适当的数据都会流式传输并应用于新构造的对象，然后添加到`Game`状态中。
- en: 'Next, let''s focus on the method that *makes it all move*, so of speak. It''s
    time to take a look at the `Update()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于使一切移动的方法，即所谓的`Update()`方法：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It really only consists of three basic parts: updating emitters, updating all
    the different `BaseUpdater` instances, and processing removed emitters. None of
    this happens if the current state iterator is not valid. Having no particles to
    work with means we have no work at all.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上只由三个基本部分组成：更新发射器，更新所有不同的`BaseUpdater`实例，以及处理移除的发射器。如果当前状态迭代器无效，则这些都不会发生。没有粒子可供工作意味着我们没有任何工作要做。
- en: The updating of emitters and updaters is fairly straightforward. Removal of
    disposed emitters is not anything too complex either. The container of removed
    emitter pointers is iterated over, and for each entry, an emitter that is still
    within the world and has the same memory address is removed from the container.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更新发射器和更新器相对简单。移除已处理的发射器也不是什么复杂的事情。通过迭代移除的发射器指针容器，并对每个条目，如果发射器仍然在世界上并且具有相同的内存地址，则将其从容器中移除。
- en: 'Finally, we get to the code responsible for getting all of our beautiful particles
    out on the screen:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了负责将所有美丽的粒子显示在屏幕上的代码：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Naturally, if we're in a state that does not have a particle container, no drawing
    needs to be done. Otherwise, we obtain references to arrays of drawables, their
    positions and blend modes. Since we want particles to support layering in order
    to add depth, the second argument of this method takes in the current layer being
    drawn.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，如果我们处于没有粒子容器的状态，则不需要进行绘制。否则，我们获取可绘制数组的引用，它们的位子和混合模式。由于我们希望粒子支持分层以增加深度，因此此方法的第二个参数接受当前正在绘制的层。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the state checking and use of shaders in this portion of the code. We're
    essentially controlling which states the particles are shaded in here. The map
    editor state will be covered in the next two chapters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这段代码中的状态检查和着色器的使用。我们实际上在这里控制粒子着色的状态。地图编辑器状态将在下一章中介绍。
- en: If the layer/elevation tests pass, there's one more check we need to make in
    order to be able to render a particle, and that is whether the particle is currently
    within the view of the screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果层/高度测试通过，我们还需要进行一项额外的检查，以便能够渲染粒子，那就是粒子是否当前在屏幕的视图中。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This simple AABB collision check obviously does **not** account for particles
    being rotated. Although the bounds that are checked still contain the entire body
    of a particle, certain corner-case scenarios may result in it being rendered,
    while it is rotated in such a way that it should be invisible, yet where the bounding
    box is still within the view. This can be solved by applying a more sophisticated
    collision check algorithm, but it isn't going to be covered here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的AABB碰撞检测显然没有考虑到粒子可能被旋转的情况。虽然被检查的边界仍然包含粒子的整个身体，但某些特殊情况可能会导致粒子被渲染，而它以某种方式旋转，使得它应该是不可见的，但边界框仍然在视图中。这可以通过应用更复杂的碰撞检测算法来解决，但这里不会涉及。
- en: 'Finally, after all of the tests have passed, it is time to render the particle.
    Keep in mind that it is in our best interest here to support two blending modes
    when it comes to rendering: additive and alpha blending. Luckily, SFML makes it
    easy for us, and it''s only necessary to pass an additional argument to the draw
    method of a window instance to determine how something is drawn.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有测试都通过之后，是时候渲染粒子了。记住，对我们来说，在渲染时支持两种混合模式是最有益的：加法和alpha混合。幸运的是，SFML使这变得很容易，我们只需要向窗口实例的draw方法传递一个额外的参数来决定如何绘制某个对象。
- en: 'Having the ability to switch between blending modes can be useful when rendering
    some particle types, since they would look more realistic that way. For example,
    take a look at the same type of particles being rendered with additive blending,
    versus alpha blending, which is the default mode:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染某些粒子类型时，能够切换混合模式可能很有用，因为这样可以使它们看起来更真实。例如，看看使用加法混合渲染的相同类型的粒子，与默认模式alpha混合相比：
- en: '![Implementing the particle system](img/image_03_008.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![实现粒子系统](img/image_03_008.jpg)'
- en: While not all particles are going to take advantage of this blending mode, it's
    definitely a nice option to have for those that need that extra oomph.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有粒子都会利用这种混合模式，但对于需要额外动力的粒子来说，这确实是一个很好的选项。
- en: Creating updaters
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更新器
- en: 'With the core particle system all built up, it is time to focus on individual
    bits and pieces that will give our system its functionality and polish. By the
    time we are done, these are some of the effects that will be possible:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 核心粒子系统已经全部构建完毕，现在是时候关注那些将赋予我们系统功能性和润色的个别部分了。完成之后，以下是一些可能实现的效果：
- en: '![Creating updaters](img/image_03_009.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![创建更新器](img/image_03_009.jpg)'
- en: The only way to get there is to keep going, so let us get to it!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的方法是继续前进，让我们继续吧！
- en: Spatial updater
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间更新器
- en: 'First, and probably the most obvious task is adjusting particle positions based
    on their kinematic states. As small as they may be, they still operate based on
    changes in velocity, acceleration, and position:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可能是最明显的一项任务是根据粒子的运动状态调整粒子位置。尽管它们可能很小，但它们仍然基于速度、加速度和位置的变化来操作：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So far, so good! Some of these updaters will have rather small footprints since
    they perform incredibly simple tasks. All we do here is obtain references to velocity,
    acceleration and position containers. The data is then manipulated in two separate
    loops in order to minimize cache misses.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！其中一些更新器将具有相当小的足迹，因为它们执行的任务极其简单。我们在这里所做的一切只是获取速度、加速度和位置容器的引用。然后，通过两个独立的循环来操作数据，以最小化缓存未命中。
- en: Drawable updater
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可绘制更新器
- en: 'Next, let''s update the drawable bits of our particles. This is where the appropriately
    named `DrawableUpdater` comes in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新粒子的可绘制部分。这正是名为 `DrawableUpdater` 的合适之处：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is quite a bit of code, but its essence is incredibly simple. Separate
    loops are utilized in order to set all of the relevant drawable properties up.
    We do, however, have something more interesting going on. Note the highlighted
    portions of the code, all of which are related to scale. As you have probably
    figured out by now, SFML deals with only two dimensions when it comes to visuals.
    In order to fake 3D particles flying around, we can utilize drawable scaling.
    The scale factor itself is capped at *1.f*, so we don't go any smaller than the
    default particle size. The scale to elevation ratio here is set to *1.5f*, which
    is debatably the best value, but is obviously up for tweaking. All it is is a
    simple ratio that the supposed *elevation* of a particle gets multiplied by in
    order to obtain a scale value, which, when used, should create the illusion of
    a particle flying towards the camera.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当多，但其本质非常简单。使用独立的循环来设置所有相关的可绘制属性。然而，我们还有一些更有趣的事情在进行。注意代码中突出显示的部分，所有这些都与缩放相关。你可能已经猜到了，当涉及到视觉效果时，SFML
    只处理两个维度。为了模拟3D粒子在周围飞行的效果，我们可以利用可绘制缩放。缩放因子本身被限制在 *1.f*，所以我们不会小于默认粒子大小。这里的缩放与高度比设置为
    *1.5f*，这可能是最佳值，但显然可以调整。这只是简单的比例，粒子所谓的 *高度* 乘以以获得缩放值，当使用时，应该产生粒子向摄像机飞行的错觉。
- en: Lifespan updater
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期更新器
- en: 'Since computer resources, at least during the time of writing this book, are
    limited, we need to have a good way of disposing of particles when it''s time.
    One good idea is attaching a lifespan to particles, so that after it''s supposed
    to have expired, the particle is gracefully removed from the population:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机资源，至少在撰写本书的时候是有限的，我们需要有一种好的方法来处理粒子，当它们需要被处理的时候。一个不错的想法是为粒子附加一个生命周期，这样在它应该过期后，粒子就可以优雅地从群体中移除：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a quite simple little updater. The delta time is added to each live
    particle, which then is checked for having exceeded its lifespan. If it has, the
    particle is disabled. Keep in mind that disabling the particle will decrease the
    `m_countAlive` data member of a particle container. For this very reason, we must
    be careful when incrementing the `i` local variable, in order to not skip any
    data in the process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的更新器。将时间增量添加到每个活动粒子中，然后检查该粒子是否已经超过了其生命周期。如果超过了，粒子将被禁用。请注意，禁用粒子将减少粒子容器中的
    `m_countAlive` 数据成员。正因为如此，我们在递增局部变量 `i` 时必须小心，以免在过程中跳过任何数据。
- en: Interpolator
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值器
- en: 'Tons of particle properties are not going to be static throughout their lifetime.
    Take, for example, the particle color. We may want to fade a particle to complete
    transparency, or even cycle through a range of colors. All of this can be achieved
    by interpolating. This process is a good candidate for its own updater class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的大量属性在其生命周期内不会保持静态。以粒子颜色为例，我们可能想要将粒子淡化到完全透明，或者甚至循环一系列颜色。所有这些都可以通过插值来实现。这个过程是它自己的更新器类的良好候选者：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, we have lots of code, but the essence of it is basically the same
    all throughout. The `Interpolate` function, stored within our `Utilities.h` header,
    takes in a range of time values throughout which we need interpolation, the range
    of values that are supposed to be interpolated, and the current time value, which
    determines the output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们有很多代码，但它的本质基本上是一致的。存储在我们 `Utilities.h` 头文件中的 `Interpolate` 函数，接受一个时间范围，在这个范围内我们需要进行插值，以及应该进行插值的值范围，和当前的时间值，它决定了输出。
- en: The interpolated properties are particle colors, rotations, and sizes. For all
    three of them, we first check if the starting value is the same as the final value
    in order to avoid useless computations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 插值属性包括粒子颜色、旋转和大小。对于这三者，我们首先检查起始值是否与最终值相同，以避免无用的计算。
- en: Force updater
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 力更新器
- en: 'During the planning stages of this particle system, we have discussed having
    different forces in the world that would affect particles. Outside the possibility
    of having custom forces, we also want to have basic gravity, so that particles
    with any sort of elevation begin falling down, provided they have the property
    of being affected by gravity. Let us implement an updater that will allow us to
    do that:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个粒子系统的规划阶段，我们讨论了在世界上有不同类型的力会影响粒子。除了有自定义力的可能性之外，我们还希望有基本的重力，这样任何类型的粒子只要有被重力影响的属性，就会开始下落。让我们实现一个更新器，使我们能够做到这一点：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first, and arguably the most important, function of this particular updater
    is applying gravity to all of the particles that need it. We want to be able to
    give certain types of particles, such as smoke or fire, the ability to not be
    affected by the gravitational force, so it's all left up to a flag that can be
    set. The actual gravitational force is defined as a static `const` data member,
    and set up underneath the class definition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定更新器的第一个，也是最重要的功能，是将重力应用于所有需要重力的粒子。我们希望能够给某些类型的粒子，如烟雾或火焰，赋予不受重力影响的特性，所以这完全取决于一个可以设置的标志。实际的引力定义为静态
    `const` 数据成员，并在类定义下方设置。
- en: 'Next is the business we have with the force applicators within the world. If
    the force updater has no pointer to a force applicator list, there is obviously
    nothing left to do, so we return from the update method. Otherwise, a private
    `Force()` method is invoked with the force''s center, the amount of force adjusted
    for delta time, its radius, and references to the position and velocity of the
    particle passed in as arguments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们在世界中与力应用器打交道的事情。如果力更新器没有指向力应用器列表的指针，显然就没有什么可做的了，所以我们从更新方法中返回。否则，将调用一个私有的
    `Force()` 方法，该方法使用力的中心、调整后的力大小（考虑了时间增量）、其半径，以及作为参数传递的粒子的位置和速度引用：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After the distance ranges are calculated using the center and radius of the
    force, the position of the particle is tested to see whether it is within the
    force-affected area. Provided all of the tests pass, the distance is calculated
    between the center of the force and the particle. It's then used to calculate
    the absolute distance between them, determine the magnitude of the force, and
    normalize the vector. Force loss is calculated based on the radii and distances
    on all three axes, and subtracted from the actual applied force, which is then
    multiplied by the normal in order to yield the finished product. Depending on
    the distance sign, we can determine which direction the force should be applied
    to, which is what the next three lines are for. Finally, after all of that work,
    we're ready to add the applied force to the particle's velocity.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用力的中心和半径计算出距离范围后，测试粒子的位置，看它是否在力影响区域内。如果所有测试都通过，就计算力中心和粒子之间的距离。然后，它被用来计算它们之间的绝对距离，确定力的大小，并归一化向量。基于所有三个轴上的半径和距离，计算力损失，并从实际施加的力中减去，然后将结果乘以法线，以得到最终产品。根据距离的符号，我们可以确定力应该施加的方向，这就是下面三行的作用。最后，在完成所有这些工作之后，我们准备将施加的力添加到粒子的速度上。
- en: 'With the help of this updater, we can actually apply forces to particles even
    from outside classes, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新器的帮助下，我们实际上可以从类外对粒子应用力，如下所示：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While this isn't as useful as, say, having constant forces inside the world,
    it can still be used for testing purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不如在世界上有恒定力那么有用，但它仍然可以用于测试目的。
- en: Collision updater
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞更新器
- en: 'Another important aspect of particles interacting with the world is handling
    their collisions. So far, the only real collision we need to worry about is particles
    hitting the floor; however, actual map collisions could be implemented quite easily
    with the help of this class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子与世界交互的另一个重要方面是处理它们的碰撞。到目前为止，我们唯一真正需要担心的碰撞是粒子撞击地面；然而，借助这个类，实际地图碰撞可以很容易地实现：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All we have to worry about here is checking whether the position of a particle
    on the *z* axis is below zero. If it is, the position on that axis is reset back
    to zero, as well as its velocity. Additionally, if the updater has been provided
    with a pointer to a map instance, we want to handle particle friction against
    the map, provided they are touching the ground. Provided that''s the case, the
    delta time is passed into a private `ApplyFriction()` method, along with the position
    and velocity vectors of the particle:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要担心的是检查粒子在*z*轴上的位置是否低于零。如果是这样，该轴上的位置将被重置为零，以及它的速度。此外，如果更新器已经提供了一个指向地图实例的指针，我们希望处理粒子与地图的摩擦，前提是它们接触地面。如果情况如此，delta时间将被传递到一个私有的`ApplyFriction()`方法中，以及粒子的位置和速度向量：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After the tile coordinates a particle is touching are determined, the tile is
    checked to see whether it exists in the first place. If it does not, the default
    friction is used. Once all of that is sorted out, the velocity **lost to friction**
    is calculated, and then multiplied by delta time to get accurate results for the
    current frame. Everything else after this point is related to making sure the
    values being added have the right sign, and don't result in going past absolute
    zero into the opposite sign domain.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定粒子接触的瓦片坐标后，检查瓦片是否确实存在。如果不存在，则使用默认的摩擦系数。一旦所有这些都被整理好，就会计算由于摩擦而失去的速度，然后乘以delta时间以获得当前帧的准确结果。从这一点开始的所有其他内容都与确保添加的值具有正确的符号，并且不会导致越过绝对零进入相反符号域有关。
- en: Particle generators
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子生成器
- en: Having all of these updaters really does nothing unless certain base values
    are generated for the particles. Whether it is the initial position of a particle,
    the range of colors, or the name of a texture that gets attached to our flying
    little data structures, having that initial data set based on some pre-conceived
    notion is important. There are quite a few generators we support, not to mention
    tons of candidates for new generators, and thus new types of particles. Having
    said that, let us take a look at a couple of basics that we need to get some basic
    effects going.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些更新器，除非为粒子生成某些基本值，否则实际上什么也不会发生。无论是粒子的初始位置、颜色的范围，还是附着在我们飞行小数据结构上的纹理名称，基于某种预先设定的概念来拥有这个初始数据集是很重要的。我们支持相当多的生成器，更不用说还有大量新的生成器候选者，以及由此产生的新类型粒子。话虽如此，让我们来看看一些基本内容，这样我们就可以开始实现一些基本效果。
- en: Point position
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点位置
- en: 'The simplest generator we can possibly have in this entire system is a point
    position. Essentially, it just sets all positions of fed-in particles to a static
    point in space:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个系统中，我们可能拥有的最简单的生成器是一个点位置。本质上，它只是将输入粒子的所有位置设置到空间中的一个静态点上：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The center point all particles are positioned at is taken from the emitter.
    Its position will always be used to determine where a particle should be spawned.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有粒子定位的中心点是从发射器那里获取的。其位置将始终用于确定粒子应该在哪里生成。
- en: Area position
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区域位置
- en: 'Setting all particle positions to the same point can get rather boring, not
    to mention visually odd. If we''re dealing with particles such as smoke or fire,
    it may make more sense to scatter the particles within a specified area. This
    is where `AreaPosition` comes in:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有粒子的位置设置到同一个点可能会相当无聊，更不用说在视觉上也很奇怪。如果我们处理的是烟雾或火焰这样的粒子，那么在指定区域内分散粒子可能更有意义。这就是`AreaPosition`发挥作用的地方：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This particular position generator still uses the emitter position as the center
    point, but also applies a random deviation range to it. The deviation value can
    be read directly from the particle file, or simply set through the constructor
    of this generator.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的位置生成器仍然使用发射器位置作为中心点，但对其应用一个随机偏差范围。偏差值可以直接从粒子文件中读取，或者简单地通过这个生成器的构造函数设置。
- en: Line position
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行位置
- en: 'A slight variation on the area position is a line position. It works in the
    same basic way as the area position does, except only for one axis, which is either
    provided through the constructor or loaded in from the particle file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 面积位置的一个轻微变化是线位置。它的工作方式与面积位置相同，只是仅限于一个轴，这个轴可以通过构造函数提供或从粒子文件中加载：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The random deviation here is only applied to one of the axes. The same effect
    could arguably be achieved with an area position generator, but it doesn't hurt
    to have a little variety.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的随机偏差仅应用于一个轴。可以说，使用面积位置生成器可以达到相同的效果，但这并不妨碍有一些多样性。
- en: Particle properties
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子属性
- en: 'Certain properties particles possess would really not call for their own generators.
    For example, gravity and blending mode flags for particles could just be pooled
    to exist within a single type of generator:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子拥有的某些属性可能根本不需要自己的生成器。例如，粒子的重力和混合模式标志可以简单地汇总到单个类型的生成器中：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Both the gravity and blending mode flags can, as with all the previous generators,
    be loaded in from the file, or set through the constructor of the class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重力和混合模式标志，就像所有之前的生成器一样，可以从文件中加载，或者通过类的构造函数设置。
- en: Random color
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机颜色
- en: 'Randomizing the color of all emitted particles may be something one may want
    to do, whether the random variations are slight for something such as differently
    shaded water particles, or completely random for a fountain of skittles. All of
    that and more can be done by this class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化所有发射粒子的颜色可能是人们想要做的事情，无论是对于像不同阴影的水粒子这样的轻微随机变化，还是对于像彩虹糖喷泉这样的完全随机。所有这些以及更多都可以通过这个类来完成：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The generator stores ranges, which are going to be used to generate random results.
    They can either be loaded in from the particle file, or set through the constructor.
    Since the ranges can be different for each one of the three color channels, they
    are randomized separately.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器存储范围，这些范围将被用来生成随机结果。它们可以从粒子文件中加载，或者通过构造函数设置。由于三个颜色通道中的范围可能不同，它们被分别随机化。
- en: Color range
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色范围
- en: 'While the random color generator simply assigns the current color of the particle,
    a color range provides a range of colors that the particle will fade through during
    its lifespan, thanks to interpolation. This process is as simple as assigning
    those values:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当随机颜色生成器只是简单地分配粒子的当前颜色时，颜色范围提供了一系列颜色，粒子在其生命周期内会通过插值逐渐过渡到这些颜色。这整个过程就像分配这些值一样简单：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Just as before, the ranges can be read in from the particle file or set up by
    using the constructor. Both the initial and the current colors of a particle are
    set to match the starting color.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，范围可以从粒子文件中读取或通过构造函数设置。粒子的初始颜色和当前颜色都设置为起始颜色。
- en: Note the de-serialization method. Because we're reading integers from the text
    file, the variable type must reflect that at first. After all the values are read
    in, they're then converted to `sf::Uint8` and stored as ranges. This obviously
    includes the alpha channel, in order to give particles the means of fading out
    when they're about to de-spawn.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意反序列化方法。因为我们是从文本文件中读取整数，所以变量类型最初必须反映这一点。读取所有值之后，它们被转换为`sf::Uint8`并存储为范围。这显然包括alpha通道，以便在粒子即将消失时能够实现淡出效果。
- en: Random lifespan
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机生命周期
- en: 'Generating the lifespan for particles is fairly similar to everything else
    we''ve done so far, so let''s just jump straight into it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为粒子生成生命周期与到目前为止我们所做的一切相当相似，所以我们就直接进入正题吧：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Predictably, lifespans are also stored as ranges, which can be loaded from the
    particle file or set up by using the constructor. Afterwards, the life of a particle
    is randomized within the specified range. This can provide certain effects with
    visual variety by eliminating the *line of death* that tends to visually stick
    out.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 预计生命周期也会以范围的形式存储，可以从粒子文件中加载或通过构造函数设置。之后，粒子的生命周期将在指定的范围内随机化。这可以通过消除视觉上容易突出的“死亡线”，提供某些效果的视觉多样性。
- en: Random size
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机大小
- en: 'Randomizing the particle size is another useful tool to have in our visual
    arsenal. Let us take a look:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化粒子大小是我们视觉工具箱中另一个有用的工具。让我们来看看：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As always, ranges are stored as data members, and can be read in from a file,
    or set up via the constructor. The size itself is randomized once, and then applied
    as the same size for both axes. As of yet, we have no reason to generate rectangular
    particles with non-matching dimensions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，范围作为数据成员存储，可以从文件中读取，或通过构造函数设置。尺寸本身随机化一次，然后作为两个轴的相同尺寸应用。到目前为止，我们没有理由生成具有不匹配尺寸的矩形粒子。
- en: Random velocity
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机速度
- en: 'All of the effort we have put into the system so far would literally be at
    a standstill if we did not give these particles a push from their birth. Applying
    random velocity values can achieve just that:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不从这些粒子的出生开始推动它们，那么我们迄今为止投入系统的所有努力都将陷入停滞。应用随机速度值可以达到这个目的：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Velocities, as covered earlier, work in three dimensions, so that is precisely
    how we must store them. Their ranges are either loaded from particle files, or
    set up through the constructor of this generator. They are then individually randomized
    and applied.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 速度，如前面所述，在三维空间中工作，所以我们必须这样存储它们。它们的范围要么从粒子文件中加载，要么通过此生成器的构造函数设置。然后，它们将分别随机化并应用。
- en: Rotation range
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转范围
- en: 'Rotation of particles can be nice for a number of different effects we can
    think of. Rotating them slightly over their lifetimes can provide some nice variety,
    so let us reflect that in this next generator:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的旋转可以用于我们想到的许多不同效果。在它们的寿命期间略微旋转它们可以提供一些很好的多样性，所以让我们在下一个生成器中反映这一点：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since the rotation values are going to be interpolated over the particle's lifetime,
    we use beginning and ending values to reflect that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于旋转值将在粒子的寿命期间进行插值，我们使用起始和结束值来反映这一点。
- en: Size range
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尺寸范围
- en: 'Particle sizes are no different from any other data we have been dealing with
    so far, so let''s take a look:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子尺寸与我们迄今为止处理的所有其他数据没有不同，所以让我们来看看：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The ranges provided to this generator are first checked to see whether they're
    not equal. If that is the case, however, we can treat the size of a particle as
    constant and simply set its current size to it to save the interpolator some work.
    Otherwise, the beginning and ending values of the size are filled out.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给此生成器的范围首先会被检查，看它们是否不相等。然而，如果它们不相等，我们可以将粒子的尺寸视为常数，并将其当前尺寸简单地设置为该值，以节省插值器的工作量。否则，将填充尺寸的起始和结束值。
- en: Texture generator
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理生成器
- en: 'Last, but definitely not least, we can make our particles about a million times
    more appealing to the eye by texturing them. Luckily, our system makes it fairly
    easy to do at this point. Let''s take a look:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但绝对是最重要的，我们可以通过纹理化使我们的粒子看起来大约有一百万倍吸引人。幸运的是，我们的系统在这个阶段使这变得相当容易。让我们来看看：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The string identifier of the texture that needs to be used for the particle
    type is first either loaded in from a file, or passed in via the constructor.
    The string is then checked inside the `Generate` method in order to make sure
    it is not empty. After a pointer to the texture manager is obtained, the resource
    handle is checked for validity by an attempt to require it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 需要用于粒子类型的纹理的字符串标识符首先要么从文件中加载，要么通过构造函数传入。然后，在`Generate`方法内部检查该字符串，以确保它不为空。在获得纹理管理器的指针后，通过尝试获取资源句柄来检查资源句柄的有效性。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the `RequireResource` line actually claims the resource is being
    used, until it's released.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`RequireResource`行实际上声明资源正在被使用，直到它被释放。
- en: All particles that are being generated are then provided with the resource handle
    of the texture. For each particle, the resource is required one more time, and
    then finally passed into the drawable object of the particle, as well as properly
    cropped based on the particle size.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正在被生成的所有粒子都将提供纹理的资源句柄。对于每个粒子，资源需要一次，然后最终传递到粒子的可绘制对象中，并根据粒子大小进行适当的裁剪。
- en: Finally, note the last highlighted line of code inside the `Generate()` method.
    Because we have increased the internal resource counter once by requiring it at
    the very beginning for verification purposes, as well as to obtain a reference
    to the resource, it must now be released, leaving the internal resource counter
    with the same value as the number of particles that actually use this texture.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意`Generate()`方法中最后高亮显示的代码行。因为我们已经通过在验证目的和获取资源引用时在非常开始时要求它，增加了一次内部资源计数器，现在必须释放它，使内部资源计数器的值与实际使用此纹理的粒子数量相同。
- en: Using the particle system
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粒子系统
- en: 'Before we can start using our particle system, some basic setting up is in
    order. First, since the particle system is dependent on both states and map loading,
    their relationship must be set up inside the main `Game` class like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用粒子系统之前，需要进行一些基本的设置。首先，由于粒子系统依赖于状态和地图加载，它们之间的关系必须在主`Game`类内部设置，如下所示：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, let''s build an actual type of particle that will be used inside the
    main menu to make it look spectacular:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建一种实际类型的粒子，它将在主菜单中使用，使其看起来非常壮观：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: All of these generator parameters have already been covered, so if this format
    looks questionable, it may be prudent to review the generator section once again.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些生成器参数都已经介绍过了，所以如果这个格式看起来有问题，那么再次回顾生成器部分可能是明智的。
- en: 'Let us add all of these spectacular visuals to the menu state, in order to
    make it much more impressive than it currently is. We can start by first setting
    up a couple of emitters:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些壮观的视觉效果添加到菜单状态中，使其比目前看起来更加引人注目。我们可以先设置几个发射器：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note the highlighted line of the code. A state must be created inside the particle
    system in order for us to be able to use it. Next, two emitters are created. One
    is positioned at one third of the width of the screen, and the other, two thirds.
    Both of them are added to the system, as well as another emitter, positioned off
    to the left, which will be emitting smoke. Finally, a force applicator, positioned
    right in between the two flames, is added to the particle system as well. With
    this thoughtful positioning, we're going to be creating a really good-looking
    effect that will be showcased shortly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码中高亮的那一行。为了能够使用它，必须在粒子系统中创建一个状态。接下来，创建了两个发射器。一个位于屏幕宽度的三分之一处，另一个位于三分之二处。它们都被添加到系统中，还有一个位于左侧的发射器，它将产生烟雾。最后，在两个火焰之间添加了一个力应用器，也添加到粒子系统中。通过这种深思熟虑的定位，我们将创建一个即将展示的非常漂亮的效果。
- en: 'Our particles obviously need to be updated in order to function properly:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然需要更新粒子以使其正常工作：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, let''s draw them on screen:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在屏幕上绘制它们：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since the `Draw()` method takes in the layer we are currently drawing, and for
    this state layers are irrelevant, we simply iterate over the number of layers,
    invoking the `Draw()` method for each one. At the end, the `Draw()` method is
    invoked one last time with the argument `-1`, signifying that we want to draw
    all of the particles that are outside the maximum layer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Draw()`方法接受我们当前正在绘制的层，并且对于这个状态来说层是不相关的，所以我们只是遍历层的数量，对每一层调用`Draw()`方法。最后，使用参数`-1`再次调用`Draw()`方法，表示我们想要绘制所有超出最大层的粒子。
- en: 'The final result, along with the smoke effect, looks a little like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果，连同烟雾效果，看起来有点像这样：
- en: '![Using the particle system](img/image_03_010.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![使用粒子系统](img/image_03_010.jpg)'
- en: This is far from showcasing what the particle system can really do. The code
    in this chapter includes examples that exist within the game state, and can be
    easily found by compiling the project and simply taking a stroll through the scenery.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这远远不能展示出粒子系统真正能做什么。本章中的代码包含了存在于游戏状态中的示例，可以通过编译项目并在场景中漫步轻松找到。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There may have been quite a bit to take in, but if you are here, congratulations!
    With some careful architecting, calculated decisions, and a dash of taste, we
    have not only produced a particle system that makes the game look ten times better,
    but also formed the bedrock of knowledge that serves as a stepping stone towards
    better design, and increased performance.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有很多东西需要吸收，但如果你在这里，恭喜你！通过一些精心的设计、经过计算的决策和一点品味，我们不仅制作了一个使游戏看起来好十倍的粒子系统，而且还形成了知识的基础，这可以作为向更好设计和提高性能迈进的垫脚石。
- en: In the next few chapters, we are going to be covering the fundamentals of sculpting
    your own tools for actually designing the game we are working with, as well as
    its assets. See you there!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将介绍制作我们自己的工具的基础知识，这些工具将用于实际设计我们正在工作的游戏及其资产。那里见！
