- en: Chapter 3.  Make It Rain! - Building a Particle System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the right amount of interactivity in any given game is incredibly important.
    Whether it amuses the player by having their consequences start chain reactions
    that eventually impact their state, or it simply means that the controls and input
    management feel just right, one cannot deny that this is one of the few things
    that can either make or break a game. While the latter is quite important, it's
    not the smooth navigation of menus that draw most gamers in, which is why in this
    chapter we are going to be focusing on environmental interactions, as well as
    stylization through the means of particle systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the **Structure of Arrays** storage pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture and implementation of a flexible particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of different types of generator and updater objects that allow a wide
    variety of effects to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is quite a bit to learn, so let us not waste any time and dive right in!
  prefs: []
  type: TYPE_NORMAL
- en: Use of copyrighted resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, let us begin by acknowledging all of the generous artists out there,
    who make all of this possible by providing assets under incredibly flexible licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '*misc png* by *dbszabo1* under the **CC0** license (public domain): [http://dbszabo1.deviantart.com/art/misc-png-316228902](http://dbszabo1.deviantart.com/art/misc-png-316228902)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jillcreation-overlay-cloud* by *Juan Story* under the **CC0** license (public
    domain): [http://www.effecthub.com/item/5358](http://www.effecthub.com/item/5358)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[LPC] Leaf Recolor* by *William.Thompsonj* under the **CC-BY-SA 3.0** and
    **GPL 3.0** licenses: [http://opengameart.org/content/lpc-leaf-recolor](http://opengameart.org/content/lpc-leaf-recolor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle system basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are quite a few things we first need to cover in order to get to the more
    meaty parts of implementing the particle system. Understanding certain concepts
    is key to making our system work as intended, starting with the way data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Array of structs versus struct of arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It may be tempting at first to simply stick all of the data a particle has
    into a single class, give it some custom methods for handling certain situations,
    and store all of these objects in some generic container, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array of structs versus struct of arrays](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While it''s certainly easier this way, it doesn''t help with performance at
    all. Keep in mind that we''re probably going to be dealing with thousands, if
    not tens of thousands of instances of particles, all of which need to be updated
    in a variety of different ways. A simple update loop that works with particles
    may end up making the cache look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array of structs versus struct of arrays](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is terrible as far as performance is concerned, because if we only need
    to work with positions, that means all of the additional space in the cache that
    could be used to store positions of other particles now holds useless data that
    will not be used at all, at least not now. In turn, when it's time to update another
    particle and its position is requested, it will most likely not be found inside
    the cache, resulting in a cache miss and time wasted.
  prefs: []
  type: TYPE_NORMAL
- en: 'A much better scenario would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array of structs versus struct of arrays](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is much better in terms of performance, as all of the data that exists
    in the cache is guaranteed to be used. How do we achieve such a result? By storing
    different particle properties in their own containers, where the memory is ensured
    to be contiguous, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Storage, however, isn't everything. We must also make sure that whenever we
    are working with structures such as this, only the relevant and necessary data
    is being used. That part, however, will be addressed later down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Storing particles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the key concept out of the way, let us take a look at how particles can
    be stored using the **SoA** pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of ways particle properties can be stored and accounted for.
    Here, we're using C-style arrays along with a static constant that denotes their
    sizes. All of these properties, as well as their purposes, will be covered in
    later segments of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few extra things that are beneficial to keep track of here are the count
    of particles that are still alive and a pointer to the texture manager, since
    some of these suckers may be using textures that need to be grabbed and released.
    They are, of course, set up properly inside the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The destructor of this container class has a fairly simple job. All it needs
    to do, in order to not leave any loose ends, is loop through every particle stored
    and check if it is using a texture, which is just a string identifier. If it is,
    the texture is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another fairly important task that was left up to the constructor is resetting
    all of the allocated memory for the particles. This is left to the `Reset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ResetParticle` private method is invoked for each single particle in the
    list. It is responsible for actually zeroing all of the data out to make sure
    the next particle that gets the same identifier will not possess certain properties
    carried over from the previous particle that owned it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to actually manage the SoA structure efficiently, we''re going to
    be using these two key methods for enabling and disabling a particular ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A sanity check is performed first in order to make sure we''re not enabling
    any particles if the maximum amount already exists, or disabling any if there
    are no active ones. Enabling a particle simply requires its *alive* flag to be
    set to *true*, while disabling calls for a complete reset. All of the data stored
    at `l_id` is then swapped with either the element after the last active particle
    when enabling in order to make it last, or with the very last particle when disabling.
    Consider the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing particles](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although it covers the scenario of disabling a particle, the same basic principle
    holds up for enabling as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actual data swapping isn''t a very complicated process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It simply invokes `std::swap` on every single particle property at the `l_first`
    and `l_second` indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get to the actual reset code for a single particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Predictably, every single particle parameter is reset to an appropriate default
    value at the provided index. If the texture identifier is not empty, the resource
    also gets released, since it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Particle system architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to cater for the way particles are stored and still provide a means
    of updating, interaction, and flexibility to the system, we must carefully address
    its architecture. Let''s begin by breaking it down into smaller parts that will
    be easier to manage on their own:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Emitter**:an object that exists in the world and acts as a particle spawner.
    It has access to a list of generators that each emitted particle is fed through
    before it gets spawned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generator**:this belongs to a list of other similar objects that have direct
    access to particle properties and modify them according to their own, pre-defined
    rules in order to achieve a certain look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updater**:one of many objects owned by the particle system, and designed
    to only use the data it needs for a specific task, which is always related to
    updating particles in a specific way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force applicator**:a small data structure, used by one of the updaters in
    order to create *forces* in the world, which physically interact with the particles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us take some time and look at each individual piece in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: The generator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A generator within this context is going to act as a stamp in a way. It will
    take in a range of particles, the properties of which are going to be adjusted
    according to the type of generator that received them. Consider this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The generator](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A specific generator can be almost considered as a stamp of sorts. Some of the
    properties it imprints on a particle can be random, while others are constant.
    Either way, once a few particles are fed into it, they come out *stamped* with
    the properties that the generator is responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the generators we''re going to be implementing need to be generalized,
    which is why they all must obey by the provided interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, the `Generate()` method needs some explaining. It takes in a pointer
    to the `Emitter` instance that owns it. It also takes a pointer to the particle
    container it's going to be working with. The last two arguments are particle IDs
    that form a range, which represents particles that will be enabled inside the
    container. The range itself is going to be calculated inside the emitter that
    owns the generator.
  prefs: []
  type: TYPE_NORMAL
- en: This base class also allows derivative generators to implement how their properties
    are loaded from files. This will be important later, when we start actually creating
    different types of generators.
  prefs: []
  type: TYPE_NORMAL
- en: The emitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned previously, an emitter is simply a class that owns a list of generators
    in order to spawn a specific type of particle. It can be positioned within the
    world, and is responsible for calculating particle ID ranges for emission by keeping
    track of its emit rate. Let''s take a look at the header of the `Emitter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this class doesn't actually store a list of generator instances.
    Instead, it stores a string identifier that will be used to obtain the list for
    a specific style of particles from the particle system.
  prefs: []
  type: TYPE_NORMAL
- en: All of the setters and getters in this class are simple one-line methods that
    perform exactly as advertised, so we won't be covering them.
  prefs: []
  type: TYPE_NORMAL
- en: Aside all of the other obvious data members, it stores a floating point value
    named `m_accumulator`, which is going to be used in conjunction with the emit
    rate. We'll go over it more very shortly. It also stores an `m_maxParticles` data
    member in order to know if particles should be emitted indefinitely, or if the
    emitter needs to stop after a certain amount have been created.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing emitter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s start with the basics of simply initializing all data members to their
    default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The only real method of importance in this class is obviously the `Update()`
    method. It''s responsible for actually doing all of the heavy lifting when it
    comes to particle emission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, the updating is not going to happen if either the generator identifier
    is empty, or we were unable to obtain the list of generators from the particle
    system. Provided that isn't the case, the `m_accumulator` data member is added
    to based on the emit rate and **delta time**. It holds the total number of particles
    that have yet to be emitted. Since we obviously can't emit half of a particle,
    or any other fraction for that matter, the accumulator data member is checked
    to see whether it's less than one. If that's the case, there is nothing to emit/update.
  prefs: []
  type: TYPE_NORMAL
- en: The number of particles to be emitted is then calculated by simply converting
    the accumulator value to an integer. It is then subtracted from the accumulator,
    which retains whatever fraction of a particle is left for the next tick.
  prefs: []
  type: TYPE_NORMAL
- en: The way we know an emitter should keep on spitting particles out indefinitely
    is if its `m_maxParticles` data member is set to `-1`. If it isn't, the number
    of particles to be emitted this tick is checked for not having exceeded the limit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get to the interesting part. First, the range of IDs that will be
    brought back to life is calculated, making sure it doesn't go beyond the maximum
    number of particles allowed. The generator list for the type of particle the emitter
    is spitting out is then iterated over, with pointers to the current emitter, and
    the particle list being passed into their `Generate()` methods, alongside the
    calculated ranges. The range of particles is then iterated over and re-enabled
    to be displayed again, and the emitter is checked to see if it needs to be removed,
    should the `m_maxParticles` data member reach zero.
  prefs: []
  type: TYPE_NORMAL
- en: The updater
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to breathe life into our particle system, we must constantly keep
    it updated. Keeping performance in mind, we must stay true to the SoA pattern
    and only work with the data that is absolutely necessary for a particular scenario,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The updater](img/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With that in mind, a very basic interface for all updaters can be put together,
    looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All updaters should ever care about, as you can see, is the delta time and having
    a pointer to the particle container they are operating on. There is no need to
    provide it with ranges, as it will be operating on all *alive* particles.
  prefs: []
  type: TYPE_NORMAL
- en: Force applicators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we don''t want our character to be running around a static, dead environment,
    some interactivity between events and particles is required. This relationship
    is established via the means of forces, which impact the kinematic states of particles
    within reach, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Force applicators](img/image_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Force applicators are not fundamental to particle systems. All we need to do
    in order to generalize them is store some data, and let the appropriate updater(s)
    take care of the logic. Having said that, let us take a look at what we need to
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Forces can be positioned in the world, so their centers need to be stored. Additionally,
    a radius of the force is also necessary, in order to figure out the area of impact.
    Lastly, there can be no impact without first knowing how strong it is. This is
    where `m_force` comes in, by allowing force to be defined in all three axes.
  prefs: []
  type: TYPE_NORMAL
- en: Building the particle system class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the building blocks in place, it''s time to actually build the
    particle system class. Let''s start with some type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to access any updater we want, we can map them to `string` identifiers.
    While the updaters aren't state-specific, emitters are. Their lists have to be
    associated with specific states in order to maintain particles across the entire
    application. Generators, just like updaters, aren't unique to any particular state,
    and we want to be able to access them via a string identifier from `Emitter` classes.
    Speaking of which, as evident from the code we've already covered, emitters can
    request removal of themselves in case they should stop emitting particles. Since
    that happens during the update cycle while the class is still in use, a separate
    list of emitter pointers must be kept for later removal.
  prefs: []
  type: TYPE_NORMAL
- en: Particles themselves are obviously stored within the designated `ParticleContainer`
    class, but these containers can, obviously, be possessed by different states.
    A similar idea applies as before, where we mapped state types to different particle
    containers in order to maintain application-wide particle support. The same exact
    principle also applies to force applicators.
  prefs: []
  type: TYPE_NORMAL
- en: The last data type we have should be a dead giveaway for the fact that we're
    going to be using the factory design pattern for producing different types of
    particle generator. These types will also be tied to string identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of that in mind, it''s time to discuss how the `ParticleSystem` class
    can be implemented, starting with its header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, let us examine the inheritance subtleties of this class. Because we are
    going to have properties of particles saved inside text files, inheritance from
    `FileLoader` is useful, not to mention we get to offload the work to a separate
    thread. Also, recall that different states will need to be provided access to
    our particle system, which means the particle manager must implement methods for
    adding, changing, and removing states. Lastly, keep in mind that particle emitters
    and the different forces that impact them may be something game maps contain,
    so we're also inheriting from the `MapLoadee` class.
  prefs: []
  type: TYPE_NORMAL
- en: The class itself obviously needs access to the texture manager, a pointer to
    which is later passed down to the classes that need it. The same is true for the
    random number generator, as well as a pointer to the map instance.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note the two highlighted data members of this class, which are both
    iterators. These are kept around for easier access to data that is state-specific
    while updating/rendering particles.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the particle system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at the constructor of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside the initializer list that performs all of the data member set-up duties,
    there is only one other purpose for the constructor here: setting up all of the
    updaters and generator types. The code we have above is heavily abridged, but
    the idea remains the same. All of the updaters we want to use are inserted into
    their container with the appropriate string identifier attached. On the generator
    side, we invoke a private template method that ties a specific type of a generator
    to a string identifier. Once again, we are using the factory pattern here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding emitter objects to our particle system is relatively straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, the emitter is provided with a pointer to the particle system for later
    access. We then check if the emitter's generator list name is valid. It's pointless
    to have an emitter that is going to be spawning *empty* particles.
  prefs: []
  type: TYPE_NORMAL
- en: As evident from the class header, a default value to the second argument of
    this method is provided. This gives us a nice way to differentiate whether a user
    of this class wants to add an emitter to a specific state, or just the current
    state that is selected. Both of these possibilities are then handled in the remaining
    chunk of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Force applicators are dealt with in a very similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the second argument has a default value, so we handle both the possibilities
    before attempting to insert the force applicator data inside the appropriate container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removal of emitters, as mentioned in the data type section, has two stages.
    The first stage is simply putting a pointer to the emitter in a designated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The actual removal is handled elsewhere. We will be covering that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the generator list is important for the emission process, so naturally,
    we must have a method for that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we stumble upon the state-dependent part of the particle system, starting
    with state creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, a determination needs to be made whether the state being created doesn't
    already, for some reason, have its own particle container allocated. If it doesn't,
    one is created and inserted into the state's particle container, as well as an
    emitter list, and a force applicator list for that same state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CreateState()` method of the `StateDependent` class is the only piece of
    code that needs to be invoked manually, in case certain states don't need to utilize
    that particular state dependent resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s discuss how a state can be changed inside a particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After a private method for changing its own internal state is invoked, the data
    member that holds an iterator to the particles of the current state is updated.
    The same exact thing is done to the emitter iterator.
  prefs: []
  type: TYPE_NORMAL
- en: The next few lines of code may not make much sense within this context, since
    we have not worked on any updaters yet, but let us cover them anyway. Further
    down the line, we are going to have updaters for particle collisions and forces.
    As far as collisions go, the updater only needs to have a pointer to the game
    map, presuming the current state is `Game`. `ForceUpdater`, on the other hand,
    needs to have access to a list of force applicators for the current state. Both
    of these types of updater are accommodated here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wrap up the state modification subject by taking a look at what happens
    inside a particle system when a state is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: All we do here is erase data from state-bound containers. Since there are two
    iterator data members kept around, those too must be reset in case the state being
    removed matches the current state. Because of the way our state system works,
    and the order of `ChangeState` and `RemoveState`, we don't need to worry about
    iterators being invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our particle system will definitely have plenty of data to load from text files,
    which is why it inherits from a file loader class. Let us take a look at the method
    that every single line stream will be fed into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first string of each line, later referred to as type, is extracted. If we
    have a name, another string is attempted to be extracted, and later checked for
    matches inside the generator list, in order to avoid duplicates. The name of the
    generator list is stored inside the `m_loadingGenerator` data member.
  prefs: []
  type: TYPE_NORMAL
- en: If any other type is encountered, it is safe to assume we are dealing with a
    specific type of generator. If that is the case, the generator list name is first
    checked that it isnt't being empty, which would indicate a file format problem.
    The generator factory is then searched for the generator with the type loaded
    from the file. If it is found, a new generator instance is created through it,
    the stream object is passed to it to do its own loading via the `>>` operator,
    and the final instance is inserted into the generator list for the current type
    of `m_loadingGenerator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re using a data member to keep file information around, it must
    be reset before attempting to load another file. Our `FileLoader` interface provides
    such functionality, given this method is overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The final base class the particle system is inheriting from, `MapLoadee`, requires
    us to implement a single method that will handle map file entries with its own
    custom types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, two different types of map entry are supported by the particle
    system: `ParticleEmitter` and `ForceApplicator`. In both cases, all of the appropriate
    data is streamed in and applied to the newly constructed objects, which are then
    added to the `Game` state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s focus on the method that *makes it all move*, so of speak. It''s
    time to take a look at the `Update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It really only consists of three basic parts: updating emitters, updating all
    the different `BaseUpdater` instances, and processing removed emitters. None of
    this happens if the current state iterator is not valid. Having no particles to
    work with means we have no work at all.'
  prefs: []
  type: TYPE_NORMAL
- en: The updating of emitters and updaters is fairly straightforward. Removal of
    disposed emitters is not anything too complex either. The container of removed
    emitter pointers is iterated over, and for each entry, an emitter that is still
    within the world and has the same memory address is removed from the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get to the code responsible for getting all of our beautiful particles
    out on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, if we're in a state that does not have a particle container, no drawing
    needs to be done. Otherwise, we obtain references to arrays of drawables, their
    positions and blend modes. Since we want particles to support layering in order
    to add depth, the second argument of this method takes in the current layer being
    drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the state checking and use of shaders in this portion of the code. We're
    essentially controlling which states the particles are shaded in here. The map
    editor state will be covered in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If the layer/elevation tests pass, there's one more check we need to make in
    order to be able to render a particle, and that is whether the particle is currently
    within the view of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This simple AABB collision check obviously does **not** account for particles
    being rotated. Although the bounds that are checked still contain the entire body
    of a particle, certain corner-case scenarios may result in it being rendered,
    while it is rotated in such a way that it should be invisible, yet where the bounding
    box is still within the view. This can be solved by applying a more sophisticated
    collision check algorithm, but it isn't going to be covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after all of the tests have passed, it is time to render the particle.
    Keep in mind that it is in our best interest here to support two blending modes
    when it comes to rendering: additive and alpha blending. Luckily, SFML makes it
    easy for us, and it''s only necessary to pass an additional argument to the draw
    method of a window instance to determine how something is drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the ability to switch between blending modes can be useful when rendering
    some particle types, since they would look more realistic that way. For example,
    take a look at the same type of particles being rendered with additive blending,
    versus alpha blending, which is the default mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the particle system](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While not all particles are going to take advantage of this blending mode, it's
    definitely a nice option to have for those that need that extra oomph.
  prefs: []
  type: TYPE_NORMAL
- en: Creating updaters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the core particle system all built up, it is time to focus on individual
    bits and pieces that will give our system its functionality and polish. By the
    time we are done, these are some of the effects that will be possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating updaters](img/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The only way to get there is to keep going, so let us get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Spatial updater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, and probably the most obvious task is adjusting particle positions based
    on their kinematic states. As small as they may be, they still operate based on
    changes in velocity, acceleration, and position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good! Some of these updaters will have rather small footprints since
    they perform incredibly simple tasks. All we do here is obtain references to velocity,
    acceleration and position containers. The data is then manipulated in two separate
    loops in order to minimize cache misses.
  prefs: []
  type: TYPE_NORMAL
- en: Drawable updater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s update the drawable bits of our particles. This is where the appropriately
    named `DrawableUpdater` comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a bit of code, but its essence is incredibly simple. Separate
    loops are utilized in order to set all of the relevant drawable properties up.
    We do, however, have something more interesting going on. Note the highlighted
    portions of the code, all of which are related to scale. As you have probably
    figured out by now, SFML deals with only two dimensions when it comes to visuals.
    In order to fake 3D particles flying around, we can utilize drawable scaling.
    The scale factor itself is capped at *1.f*, so we don't go any smaller than the
    default particle size. The scale to elevation ratio here is set to *1.5f*, which
    is debatably the best value, but is obviously up for tweaking. All it is is a
    simple ratio that the supposed *elevation* of a particle gets multiplied by in
    order to obtain a scale value, which, when used, should create the illusion of
    a particle flying towards the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Lifespan updater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since computer resources, at least during the time of writing this book, are
    limited, we need to have a good way of disposing of particles when it''s time.
    One good idea is attaching a lifespan to particles, so that after it''s supposed
    to have expired, the particle is gracefully removed from the population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a quite simple little updater. The delta time is added to each live
    particle, which then is checked for having exceeded its lifespan. If it has, the
    particle is disabled. Keep in mind that disabling the particle will decrease the
    `m_countAlive` data member of a particle container. For this very reason, we must
    be careful when incrementing the `i` local variable, in order to not skip any
    data in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tons of particle properties are not going to be static throughout their lifetime.
    Take, for example, the particle color. We may want to fade a particle to complete
    transparency, or even cycle through a range of colors. All of this can be achieved
    by interpolating. This process is a good candidate for its own updater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have lots of code, but the essence of it is basically the same
    all throughout. The `Interpolate` function, stored within our `Utilities.h` header,
    takes in a range of time values throughout which we need interpolation, the range
    of values that are supposed to be interpolated, and the current time value, which
    determines the output.
  prefs: []
  type: TYPE_NORMAL
- en: The interpolated properties are particle colors, rotations, and sizes. For all
    three of them, we first check if the starting value is the same as the final value
    in order to avoid useless computations.
  prefs: []
  type: TYPE_NORMAL
- en: Force updater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the planning stages of this particle system, we have discussed having
    different forces in the world that would affect particles. Outside the possibility
    of having custom forces, we also want to have basic gravity, so that particles
    with any sort of elevation begin falling down, provided they have the property
    of being affected by gravity. Let us implement an updater that will allow us to
    do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first, and arguably the most important, function of this particular updater
    is applying gravity to all of the particles that need it. We want to be able to
    give certain types of particles, such as smoke or fire, the ability to not be
    affected by the gravitational force, so it's all left up to a flag that can be
    set. The actual gravitational force is defined as a static `const` data member,
    and set up underneath the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the business we have with the force applicators within the world. If
    the force updater has no pointer to a force applicator list, there is obviously
    nothing left to do, so we return from the update method. Otherwise, a private
    `Force()` method is invoked with the force''s center, the amount of force adjusted
    for delta time, its radius, and references to the position and velocity of the
    particle passed in as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After the distance ranges are calculated using the center and radius of the
    force, the position of the particle is tested to see whether it is within the
    force-affected area. Provided all of the tests pass, the distance is calculated
    between the center of the force and the particle. It's then used to calculate
    the absolute distance between them, determine the magnitude of the force, and
    normalize the vector. Force loss is calculated based on the radii and distances
    on all three axes, and subtracted from the actual applied force, which is then
    multiplied by the normal in order to yield the finished product. Depending on
    the distance sign, we can determine which direction the force should be applied
    to, which is what the next three lines are for. Finally, after all of that work,
    we're ready to add the applied force to the particle's velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of this updater, we can actually apply forces to particles even
    from outside classes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: While this isn't as useful as, say, having constant forces inside the world,
    it can still be used for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Collision updater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important aspect of particles interacting with the world is handling
    their collisions. So far, the only real collision we need to worry about is particles
    hitting the floor; however, actual map collisions could be implemented quite easily
    with the help of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'All we have to worry about here is checking whether the position of a particle
    on the *z* axis is below zero. If it is, the position on that axis is reset back
    to zero, as well as its velocity. Additionally, if the updater has been provided
    with a pointer to a map instance, we want to handle particle friction against
    the map, provided they are touching the ground. Provided that''s the case, the
    delta time is passed into a private `ApplyFriction()` method, along with the position
    and velocity vectors of the particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After the tile coordinates a particle is touching are determined, the tile is
    checked to see whether it exists in the first place. If it does not, the default
    friction is used. Once all of that is sorted out, the velocity **lost to friction**
    is calculated, and then multiplied by delta time to get accurate results for the
    current frame. Everything else after this point is related to making sure the
    values being added have the right sign, and don't result in going past absolute
    zero into the opposite sign domain.
  prefs: []
  type: TYPE_NORMAL
- en: Particle generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having all of these updaters really does nothing unless certain base values
    are generated for the particles. Whether it is the initial position of a particle,
    the range of colors, or the name of a texture that gets attached to our flying
    little data structures, having that initial data set based on some pre-conceived
    notion is important. There are quite a few generators we support, not to mention
    tons of candidates for new generators, and thus new types of particles. Having
    said that, let us take a look at a couple of basics that we need to get some basic
    effects going.
  prefs: []
  type: TYPE_NORMAL
- en: Point position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest generator we can possibly have in this entire system is a point
    position. Essentially, it just sets all positions of fed-in particles to a static
    point in space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The center point all particles are positioned at is taken from the emitter.
    Its position will always be used to determine where a particle should be spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Area position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting all particle positions to the same point can get rather boring, not
    to mention visually odd. If we''re dealing with particles such as smoke or fire,
    it may make more sense to scatter the particles within a specified area. This
    is where `AreaPosition` comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This particular position generator still uses the emitter position as the center
    point, but also applies a random deviation range to it. The deviation value can
    be read directly from the particle file, or simply set through the constructor
    of this generator.
  prefs: []
  type: TYPE_NORMAL
- en: Line position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A slight variation on the area position is a line position. It works in the
    same basic way as the area position does, except only for one axis, which is either
    provided through the constructor or loaded in from the particle file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The random deviation here is only applied to one of the axes. The same effect
    could arguably be achieved with an area position generator, but it doesn't hurt
    to have a little variety.
  prefs: []
  type: TYPE_NORMAL
- en: Particle properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certain properties particles possess would really not call for their own generators.
    For example, gravity and blending mode flags for particles could just be pooled
    to exist within a single type of generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Both the gravity and blending mode flags can, as with all the previous generators,
    be loaded in from the file, or set through the constructor of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Random color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Randomizing the color of all emitted particles may be something one may want
    to do, whether the random variations are slight for something such as differently
    shaded water particles, or completely random for a fountain of skittles. All of
    that and more can be done by this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The generator stores ranges, which are going to be used to generate random results.
    They can either be loaded in from the particle file, or set through the constructor.
    Since the ranges can be different for each one of the three color channels, they
    are randomized separately.
  prefs: []
  type: TYPE_NORMAL
- en: Color range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the random color generator simply assigns the current color of the particle,
    a color range provides a range of colors that the particle will fade through during
    its lifespan, thanks to interpolation. This process is as simple as assigning
    those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, the ranges can be read in from the particle file or set up by
    using the constructor. Both the initial and the current colors of a particle are
    set to match the starting color.
  prefs: []
  type: TYPE_NORMAL
- en: Note the de-serialization method. Because we're reading integers from the text
    file, the variable type must reflect that at first. After all the values are read
    in, they're then converted to `sf::Uint8` and stored as ranges. This obviously
    includes the alpha channel, in order to give particles the means of fading out
    when they're about to de-spawn.
  prefs: []
  type: TYPE_NORMAL
- en: Random lifespan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating the lifespan for particles is fairly similar to everything else
    we''ve done so far, so let''s just jump straight into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Predictably, lifespans are also stored as ranges, which can be loaded from the
    particle file or set up by using the constructor. Afterwards, the life of a particle
    is randomized within the specified range. This can provide certain effects with
    visual variety by eliminating the *line of death* that tends to visually stick
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Random size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Randomizing the particle size is another useful tool to have in our visual
    arsenal. Let us take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As always, ranges are stored as data members, and can be read in from a file,
    or set up via the constructor. The size itself is randomized once, and then applied
    as the same size for both axes. As of yet, we have no reason to generate rectangular
    particles with non-matching dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Random velocity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the effort we have put into the system so far would literally be at
    a standstill if we did not give these particles a push from their birth. Applying
    random velocity values can achieve just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Velocities, as covered earlier, work in three dimensions, so that is precisely
    how we must store them. Their ranges are either loaded from particle files, or
    set up through the constructor of this generator. They are then individually randomized
    and applied.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rotation of particles can be nice for a number of different effects we can
    think of. Rotating them slightly over their lifetimes can provide some nice variety,
    so let us reflect that in this next generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Since the rotation values are going to be interpolated over the particle's lifetime,
    we use beginning and ending values to reflect that.
  prefs: []
  type: TYPE_NORMAL
- en: Size range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Particle sizes are no different from any other data we have been dealing with
    so far, so let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The ranges provided to this generator are first checked to see whether they're
    not equal. If that is the case, however, we can treat the size of a particle as
    constant and simply set its current size to it to save the interpolator some work.
    Otherwise, the beginning and ending values of the size are filled out.
  prefs: []
  type: TYPE_NORMAL
- en: Texture generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last, but definitely not least, we can make our particles about a million times
    more appealing to the eye by texturing them. Luckily, our system makes it fairly
    easy to do at this point. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The string identifier of the texture that needs to be used for the particle
    type is first either loaded in from a file, or passed in via the constructor.
    The string is then checked inside the `Generate` method in order to make sure
    it is not empty. After a pointer to the texture manager is obtained, the resource
    handle is checked for validity by an attempt to require it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the `RequireResource` line actually claims the resource is being
    used, until it's released.
  prefs: []
  type: TYPE_NORMAL
- en: All particles that are being generated are then provided with the resource handle
    of the texture. For each particle, the resource is required one more time, and
    then finally passed into the drawable object of the particle, as well as properly
    cropped based on the particle size.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note the last highlighted line of code inside the `Generate()` method.
    Because we have increased the internal resource counter once by requiring it at
    the very beginning for verification purposes, as well as to obtain a reference
    to the resource, it must now be released, leaving the internal resource counter
    with the same value as the number of particles that actually use this texture.
  prefs: []
  type: TYPE_NORMAL
- en: Using the particle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start using our particle system, some basic setting up is in
    order. First, since the particle system is dependent on both states and map loading,
    their relationship must be set up inside the main `Game` class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s build an actual type of particle that will be used inside the
    main menu to make it look spectacular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: All of these generator parameters have already been covered, so if this format
    looks questionable, it may be prudent to review the generator section once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add all of these spectacular visuals to the menu state, in order to
    make it much more impressive than it currently is. We can start by first setting
    up a couple of emitters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note the highlighted line of the code. A state must be created inside the particle
    system in order for us to be able to use it. Next, two emitters are created. One
    is positioned at one third of the width of the screen, and the other, two thirds.
    Both of them are added to the system, as well as another emitter, positioned off
    to the left, which will be emitting smoke. Finally, a force applicator, positioned
    right in between the two flames, is added to the particle system as well. With
    this thoughtful positioning, we're going to be creating a really good-looking
    effect that will be showcased shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our particles obviously need to be updated in order to function properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s draw them on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Draw()` method takes in the layer we are currently drawing, and for
    this state layers are irrelevant, we simply iterate over the number of layers,
    invoking the `Draw()` method for each one. At the end, the `Draw()` method is
    invoked one last time with the argument `-1`, signifying that we want to draw
    all of the particles that are outside the maximum layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result, along with the smoke effect, looks a little like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the particle system](img/image_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is far from showcasing what the particle system can really do. The code
    in this chapter includes examples that exist within the game state, and can be
    easily found by compiling the project and simply taking a stroll through the scenery.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may have been quite a bit to take in, but if you are here, congratulations!
    With some careful architecting, calculated decisions, and a dash of taste, we
    have not only produced a particle system that makes the game look ten times better,
    but also formed the bedrock of knowledge that serves as a stepping stone towards
    better design, and increased performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we are going to be covering the fundamentals of sculpting
    your own tools for actually designing the game we are working with, as well as
    its assets. See you there!
  prefs: []
  type: TYPE_NORMAL
