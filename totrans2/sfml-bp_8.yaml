- en: Chapter 8. Build a Real-time Tower Defense Game from Scratch – Part 2, Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 从零开始构建实时塔防游戏 - 第2部分，网络
- en: 'In the previous chapter, we built a complete game from scratch. The only limitation
    we encountered was that we didn''t have real enemies to defeat. We will solve
    this limitation in the present chapter by adding networking to our game to allow
    it to interact with players other than you. At the end of this chapter, you will
    be able to play this game with some friends. This chapter will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从零开始构建了一个完整的游戏。我们遇到的唯一限制是没有真正的敌人可以击败。在本章中，我们将通过添加网络到我们的游戏中来解决这个问题，使其能够与除你之外的其他玩家交互。在本章结束时，你将能够与一些朋友一起玩这个游戏。本章将涵盖以下主题：
- en: Network architectures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络架构
- en: Network communication using sockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用套接字进行网络通信
- en: Creating a communication protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建通信协议
- en: Modifying our game by applying the client-server concept
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用客户端-服务器概念修改我们的游戏
- en: Saving and loading our game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载我们的游戏
- en: Now let's dive into this pretty complicated chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨这个相当复杂的章节。
- en: Network architectures
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络架构
- en: 'Before constructing our architecture, we need some information about what kind
    of network architectures are commonly used in a game, and their specificities.
    There are different types of architectures used in game programming. They greatly
    depend on the game and the needs of the developer. We will see two common architectures:
    peer-to-peer (P2P) and client-server. Both of them have their strengths and weaknesses.
    Let''s analyze them individually.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的架构之前，我们需要了解一些关于在游戏中常用哪些网络架构以及它们的具体特点的信息。在游戏编程中使用了不同类型的架构。它们在很大程度上取决于游戏和开发者的需求。我们将看到两种常见的架构：对等网络（P2P）和客户端-服务器。它们各自都有优势和劣势。让我们分别分析它们。
- en: Peer-to-peer architecture
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对等网络架构
- en: 'This architecture was widely used in the past, and is still used today. In
    this architecture, players know the addresses of each other and directly communicate
    with each other without any intermediary. For example, for a game with four different
    players, the network can be represented as the following chart:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构在过去被广泛使用，至今仍在使用。在这种架构中，玩家知道彼此的地址，并直接相互通信，无需任何中介。例如，对于一个有四个不同玩家的游戏，网络可以表示为以下图表：
- en: '![Peer-to-peer architecture](img/8477OS_08_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![对等网络架构](img/8477OS_08_02.jpg)'
- en: This organization allows a player to directly interact with any or all of the
    other players. When a client does something, it notifies the others of this action,
    and they update the simulation (game) consequently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式允许玩家直接与任何或所有其他玩家互动。当客户端执行某个动作时，它会通知其他玩家这个动作，然后他们相应地更新模拟（游戏）。
- en: This approach is efficient for communications, but comes with some limitations
    that can't be ignored. The main one is that there is no way to avoid cheating.
    A client can do whatever it wants by notifying the other of that action, even
    if it's impossible, such as teleporting itself by sending an arbitrary position.
    A possible result is that the fun of the game is completely destroyed for the
    other players.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在通信方面效率很高，但也有一些不能忽视的限制。主要的一个是，无法避免作弊。客户端可以通过通知其他玩家该动作来执行任何它想做的事情，即使这是不可能的，比如通过发送任意位置来传送自己。可能的结果是，其他玩家的游戏乐趣完全被破坏。
- en: To avoid this kind of cheating, we have to change the architecture to be able
    to have a kind of referee that can decide if an action is legal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种作弊行为，我们必须改变架构，以便能够有一个可以决定一个动作是否合法的裁判。
- en: Client-server architecture
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: In game programming, avoiding cheating is very important, because it can completely
    destroy the experience of the game for the player. To be able to reduce the possibility
    of cheating, the architecture used can help. With client-server architecture,
    a game can detect the major part of these exploits. This is one reason that justifies
    the importance of this part. One other point is that this is the architecture
    that will be used for our game. Instead of having the players communicating between
    each other, they will only communicate with a single host called the server. Because
    all other players will also do the same, we will be able to communicate with them,
    but with an intermediary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏编程中，避免作弊非常重要，因为它可以完全破坏玩家的游戏体验。为了能够减少作弊的可能性，所使用的架构可以提供帮助。使用客户端-服务器架构，游戏可以检测到这些漏洞的大部分。这是证明这一部分重要性的一个原因。另一个观点是，这是我们游戏将使用的架构。玩家之间不会相互通信，他们只会与一个称为服务器的单一主机通信。因为所有其他玩家也会这样做，我们将能够与他们通信，但有一个中介。
- en: 'Moreover, this intermediary will act as a judge that will decide if an action
    is legal. Instead of having a full simulation on all the different players'' computers,
    the real simulation is made by the server. It holds the real game states that
    have to be taken into account; the client is just a kind of display that we can
    interact with. The following chart represents the architecture:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个中介将充当法官，将决定一个动作是否合法。而不是在所有不同玩家的电脑上进行全面模拟，真正的模拟由服务器完成。它持有必须考虑的真实游戏状态；客户端只是我们可以与之交互的一种显示。以下图表表示了架构：
- en: '![Client-server architecture](img/8477OS_08_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![客户端-服务器架构](img/8477OS_08_03.jpg)'
- en: As you can see, we now need to pass through the server to propagate any kind
    of actions to the other players.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在需要通过服务器来传播任何类型的动作给其他玩家。
- en: Its main drawback is that the server has to be reactive for all the players
    (clients), and if your game has a great number of players, this can become hard.
    Splitting the tasks on different threads is very important to ensure the reactivity
    of the server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要缺点是服务器必须对所有玩家（客户端）做出反应，如果你的游戏有大量玩家，这可能会变得很困难。将任务分配到不同的线程对于确保服务器的反应性非常重要。
- en: Some games require so many resources that it can't handle only a limited amount
    of players, the result is that you have to manage multiple server for one game;
    for instance, one for logging, another for chatting, another one for a specific
    area of the map, and so on. We will now see how to use this architecture for our
    game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有些游戏需要的资源太多，以至于它只能处理有限数量的玩家，结果是，你必须为一场游戏管理多个服务器；例如，一个用于登录，另一个用于聊天，另一个用于地图的特定区域，等等。我们现在将看看如何使用这种架构来构建我们的游戏。
- en: 'When creating a multiplayer architecture, the first thing to have in mind is
    that we will have to split our game in two distinct programs: a client and a server.
    We will have one server hosting several game instances and any number of clients,
    possibly on different matches.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建多人架构时，首先要考虑的是，我们必须将我们的游戏分成两个不同的程序：一个客户端和一个服务器。我们将有一个服务器托管多个游戏实例和任意数量的客户端，可能在不同场比赛中。
- en: To be able to have this kind of result, let's first think about what is needed
    by each part.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够得到这种结果，我们首先考虑每个部分需要什么。
- en: Client
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Each player must start a client program to be able to start a match. This program
    will have to do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个玩家必须启动一个客户端程序才能开始一场比赛。这个程序必须执行以下操作：
- en: Display the game state
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示游戏状态
- en: Handle the different user inputs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同的用户输入
- en: Play effects (sounds, bloodshed, and so on)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放效果（声音、血腥场面等）
- en: Update its game status according to the information received from the server
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据从服务器接收到的信息更新其游戏状态
- en: Send requests to the server (build, destroy)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向服务器发送请求（构建、销毁）
- en: 'These different features are already present in our actual game, so we will
    need to adapt them; but there are also some new features:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的功能已经存在于我们的实际游戏中，因此我们需要适应它们；但也有一些新功能：
- en: Request the creation of a new match
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求创建一个新的比赛
- en: Request to join a match
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求加入比赛
- en: Here I use the word *request* because that's what it really is. As a player
    will not handle the game in totality, it can only send requests to the server
    to take action. The server will then judge them and react as a consequence. Now
    let's take a look at the server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用“请求”这个词，因为它确实如此。作为一个玩家不会完全处理游戏，它只能向服务器发送请求以采取行动。然后服务器将判断它们并做出反应。现在让我们来看看服务器。
- en: Server
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器
- en: 'On the other hand, the server will need to be launched only once, and will
    have to manage the following functionalities:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，服务器只需要启动一次，并需要管理以下功能：
- en: Store all the different matches
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储所有不同的比赛
- en: Process each game's steps
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理每个游戏的步骤
- en: Send updates of the game to players
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向玩家发送游戏更新
- en: Handle player requests
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家请求
- en: 'But a server also has to take care of the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但服务器还必须注意以下事项：
- en: Managing connection/disconnection
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理连接/断开
- en: Game creation
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏创建
- en: Adding a player as a controller for a team
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家添加为团队的控制者
- en: 'As you can see, there is no need for any kind of display, so the server output
    will be in console only. It will also have to judge all the different requests
    coming from the client. In a distributed environment, also true for web development,
    remember this rule: *don''t trust user inputs*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，不需要任何类型的显示，因此服务器输出将仅在控制台。它还必须判断来自客户端的所有不同请求。在分布式环境中，对于Web开发也是如此，请记住这个规则：*不要信任用户输入*。
- en: If you keep this in mind, it will save you a lot of trouble and a lot of time
    in debugging. Some users, even if it's a very small number of users, can send
    you random data such as cheats or anything else that you're not supposed to receive.
    So don't take the inputs at face value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记住这一点，它将为你节省很多麻烦和调试时间。一些用户，即使是非常少数的用户，也可能发送随机数据，如作弊或其他你不应该接收的内容。所以不要直接接受输入。
- en: Now that the functionalities have been exposed, we need a way to communicate
    between a client and the server. This is the topic that we will now speak about.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在功能已经暴露出来，我们需要一种在客户端和服务器之间进行通信的方式。这是我们接下来要讨论的主题。
- en: Network communication using sockets
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字进行网络通信
- en: 'To be able to interact with other players, we will need a way to communicate
    with them, regardless of the architecture used. To be able to communicate with
    any computer, we have to use sockets. In short, a socket enables communication
    with other processes/computers through the network as long as there is an existing
    way between both sides (LAN or Internet). There are two main kinds of sockets:
    non-connected (UDP) or connected (TCP). Both these need an IP address and a port
    number to communicate with their destination.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够与其他玩家互动，我们需要一种与他们通信的方法，无论使用的是哪种架构。为了能够与任何计算机通信，我们必须使用套接字。简而言之，套接字通过网络与其他进程/计算机进行通信，只要双方之间存在现有的连接方式（局域网或互联网）。套接字主要有两种类型：非连接（UDP）或连接（TCP）。这两种都需要IP地址和端口号才能与目的地通信。
- en: Notice that the number of available ports on a computer is contained between
    0 and 65535\. A piece of advice is to avoid the use of ports with a number lesser
    than 1024\. The reason is that most of them are reserved by the system or used
    by common applications, such as 80 for a web browser, 21 for FTP, and so on. You
    also have to ensure that both sides of the communication use the same port number
    to be able to exchange data. Let's now see in detail the two kinds of socket previously
    introduced.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计算机上可用的端口号范围在0到65535之间。一条建议是避免使用小于1024的端口号。原因是大多数端口号都被系统保留或被常用应用程序使用，例如80用于网页浏览器，21用于FTP等。你还要确保通信双方使用相同的端口号才能交换数据。现在让我们详细看看之前提到的两种套接字。
- en: UDP
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP
- en: 'As already said, **User Datagram Protocol** (**UDP**) is a way of sending data
    through the network without connections. We can visualize the communication achieved
    by this protocol, such as sending letters. Each time you want to send a message
    to someone, you have to specify the destination address (IP and port). The message
    can then be sent, but you don''t know if it really arrives at its destination.
    This kind of communication is really quick, but comes with some limitations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，**用户数据报协议**（**UDP**）是一种在网络中发送数据而不建立连接的方式。我们可以将这种协议实现的通信可视化，例如发送信件。每次你想向某人发送消息时，你必须指定目标地址（IP和端口）。然后可以发送消息，但你不知道它是否真的到达了目的地。这种通信非常快，但也有一些限制：
- en: You don't even know if the message has arrived at its destination
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你甚至不知道消息是否到达了目的地
- en: A message can be lost
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可能会丢失
- en: A big message will be split in smaller messages
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大消息将被分割成更小的消息
- en: Messages can be received in a different order than the original order
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息的接收顺序可能与原始顺序不同
- en: A message can be duplicated
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可能会重复
- en: Because of these limitations, the messages can't be exploited as soon as they
    are received. There is a need for verification. A simple way to resolve a majority
    of these troubles is to add to your data a small header containing a unique message
    identifier. This identifier will allow us to identify precisely a message, remove
    possible duplication, and treat each in the correct order. You can also ensure
    that your message is not too big to avoid splitting and losing a part of the data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，消息不能在收到后立即被利用。需要进行验证。解决这些麻烦的一个简单方法是在您的数据中添加一个包含唯一消息标识符的小型标题。这个标识符将允许我们精确地识别一个消息，删除可能的重复，并按正确的顺序处理每个消息。您还可以确保您的消息不是太大，以避免分割和丢失数据的一部分。
- en: SFML provides us the `sf::UdpSocket` class to communicate using the UDP protocol.
    This chapter will not cover this kind of socket, but if you are interested in
    it, take a look at the SFML tutorial on the official website ([www.sfml-dev.org](http://www.sfml-dev.org)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SFML为我们提供了用于通过UDP协议通信的 `sf::UdpSocket` 类。本章将不涉及这种套接字，但如果您对此感兴趣，请查看官方网站上的SFML教程（[www.sfml-dev.org](http://www.sfml-dev.org)）。
- en: TCP
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP
- en: '**Transmission Control Protocol** (**TCP**) is a connected protocol. This can
    be compared to a phone conversation. There are some steps to follow to understand
    this protocol:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）是一个连接协议。这可以比作电话对话。理解这个协议有一些步骤需要遵循：'
- en: Ask for a connection to an address (phone is ringing)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求连接到地址（电话铃声响起）
- en: Accept the connection (pick up the phone)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受连接（接起电话）
- en: Exchange data (talk)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换数据（交谈）
- en: Stop the conversation (hang up)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止对话（挂断电话）
- en: As the protocol is connected, it ensures that the data arrived at the destination
    is in the same ordering, structure, and consistency as at its source. By the way,
    we need to specify the destination address only once during the connection. Moreover,
    if the connection breaks (the problem is on the other side, for example), we can
    detect it as soon as it happens. The downside of this protocol is that the communication
    speed is reduced.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协议是连接的，它确保到达目的地的数据与源地的顺序、结构和一致性相同。顺便说一句，我们只需要在连接期间指定一次目标地址。此外，如果连接中断（问题在另一边，例如），我们可以在发生时立即检测到。这种协议的缺点是通信速度会降低。
- en: SFML provides us the `sf::TcpSocket` class to deal with the TCP protocol easily.
    This is the one that we will use in our project. I will discuss its usage in the
    next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SFML为我们提供了 `sf::TcpSocket` 类来轻松处理TCP协议。这是我们将在我们的项目中使用的类。我将在下一节讨论其用法。
- en: Selector
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择器
- en: 'SFML provides us with another utility class: `sf::SocketSelector`. This class
    works like an observer on any kind of socket and holds a pointer to managed sockets,
    as explained in the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SFML为我们提供了一个另一个实用工具类：`sf::SocketSelector`。这个类就像任何类型的套接字的观察者，并持有指向管理套接字的指针，如下面的步骤中解释的那样：
- en: Use the `sf::SocketSelector::add(sf::Socket)` method to add a socket to observe.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sf::SocketSelector::add(sf::Socket)` 方法将套接字添加到观察列表中。
- en: Then, when one or more of the observed sockets receive data, the `sf::SocketSelector::wait()function`
    return. Finally, using `sf::SocketSelector::isReady(sf::Socket)`, we can identify
    which one of the sockets received data. This allows us to avoid pooling and use
    real-time reaction.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当观察到的一个或多个套接字接收到数据时，`sf::SocketSelector::wait()函数` 返回。最后，使用 `sf::SocketSelector::isReady(sf::Socket)`，我们可以确定哪个套接字接收到了数据。这使我们能够避免池化并使用实时反应。
- en: We will use this class in this chapter paired with `sf::TcpSocket`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用这个类与 `sf::TcpSocket` 配对。
- en: The Connection class
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接类
- en: Now that all the basic network bricks have been introduced, it's time for us
    to think about our game. We need to decide the way in which our game will exchange
    data with another player. We will need to send and receive data. To achieve this,
    we will use the `sf::TcpSocket` class. As each action on the socket will block
    the execution of our game, we will need to create a system to disable the blocking.
    SFML provides a `sf::Socket::setBlocking()` function, but our solution will use
    a different method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了所有基本网络组件，是时候我们考虑我们的游戏了。我们需要决定我们的游戏将如何与其他玩家交换数据。我们需要发送和接收数据。为了实现这一点，我们将使用
    `sf::TcpSocket` 类。由于每个套接字上的操作都会阻塞我们游戏的执行，我们需要创建一个系统来禁用阻塞。SFML提供了 `sf::Socket::setBlocking()`
    函数，但我们的解决方案将使用不同的方法。
- en: The goal of the Connection class
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接类的目标
- en: If you remember, in [Chapter 6](ch06.html "Chapter 6. Boost Your Code Using
    Multithreading"), *Boost Your Code Using Multithreading*, I told you that networking
    is mostly managed in a dedicated thread. Our solution will follow this path; the
    idea is to have an object that internally manages a thread as transparently as
    possible to the user. Moreover, we will design the API to be similar to SFML event
    management from the `sf::Window` class. The result of these constraints is the
    construction of a `Connection` class. This class will then be specialized by the
    architecture that we will choose (described in the next section).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在[第6章](ch06.html "第6章。使用多线程提升代码")中，*使用多线程提升代码*，我告诉你网络主要是在一个专用线程中管理的。我们的解决方案将遵循这条路径；想法是尽可能透明地管理一个线程，对用户来说。此外，我们将设计API，使其类似于`sf::Window`类的SFML事件管理。这些约束的结果是构建一个`Connection`类。然后，这个类将由我们选择的架构（在下一节中描述）进行特殊化。
- en: 'Let''s now take a look at the header of this new class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个新类的头文件：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s explain this class step by step:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地解释这个类：
- en: We start by defining a constructor and a destructor. Notice that the destructor
    is set to virtual because the class will be specialized.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义了一个构造函数和一个析构函数。请注意，析构函数被设置为虚拟的，因为该类将被特殊化。
- en: Then we define some common functions to deal with the internal thread for synchronization
    issues.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了一些常见的函数来处理内部线程以解决同步问题。
- en: Some methods to deal with events are then defined. We build two methods to deal
    with incoming events and one to deal with outgoing messages. The overload on the
    `pollEvent()` function allows us to use raw or parsed data. The `packet::NetworkEvent`
    class will be described later in this chapter. For now, take it as a message similar
    to `sf::Event` with type and data, but coming from the network.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后定义了一些处理事件的方法。我们构建了两个方法来处理传入的事件，一个方法来处理发出的消息。`pollEvent()`函数的重载使我们能够使用原始数据或解析数据。`packet::NetworkEvent`类将在本章后面进行描述。现在，将其视为类似于`sf::Event`的消息，具有类型和数据，但来自网络。
- en: We define a function to close the communication properly.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个函数来正确地关闭通信。
- en: Finally, we define some functions to get information on the connection.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一些函数来获取有关连接的信息。
- en: 'To be able to work, all these functions require some objects. Moreover, to
    be as responsive as possible, we will use two sockets: one for incoming messages
    and the other for outgoing messages. This will allow us to send and receive data
    at the same time and accelerate the responsiveness of the game. Because of this
    choice, we will need to duplicate all the other requirements (thread, mutex, queue,
    and so on). Let''s discuss the goal of each one:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够工作，所有这些函数都需要一些对象。此外，为了尽可能响应，我们将使用两个套接字：一个用于传入消息，另一个用于传出消息。这将允许我们同时发送和接收数据，并加速游戏的响应速度。由于这个选择，我们需要复制所有其他要求（线程、互斥锁、队列等）。让我们讨论每个目标：
- en: '`sf::TcpSocket`: It handles the communication between the two sides.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sf::TcpSocket`：它处理两端的通信。'
- en: '`sf::Thread`: It allows us to be non-blocking as previously exposed. It will
    remain alive as long as the connection instance.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sf::Thread`：它允许我们像之前展示的那样非阻塞。它将保持与连接实例的生命周期一致。'
- en: '`sf::Mutex`: It protects the queue of data to avoid data race or use them afterwards
    for free.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sf::Mutex`：它保护数据队列，以避免数据竞争或之后免费使用。'
- en: '`std::queue<sf::Packet>`: This is the queue of events to processes. Each time
    it is accessed, the associated mutex is locked.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::queue<sf::Packet>`：这是要处理的事件队列。每次访问它时，都会锁定相关的互斥锁。'
- en: 'Now that the different objects have been explained, we can continue with the
    implementation of the class, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经解释了不同的对象，我们可以继续实现类的实现，如下所示：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The constructor doesn''t have any function in particular. It simply initializes
    with the correct value without launching a different thread. We have a function
    for that, which is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数没有特定的功能。它只是使用正确的值进行初始化，而不启动不同的线程。我们有一个函数来做这件事，如下所示：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These three functions manage the lifetime of the different threads by launching,
    stopping, or keeping them waiting. Notice that a mutex to protect `_isRunning`
    is not necessary because we don't write in it outside of those functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数通过启动、停止或保持它们等待来管理不同线程的生命周期。请注意，不需要互斥锁来保护`_isRunning`，因为我们不会在这些函数之外写入它。
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These two functions are important and copy the behavior of the `sf::Window::pollEvent()`
    function, so their usage will not surprise you. What we do here is that we pick
    up an event from the incoming queue if there is one enabled. The second function
    also parses the receiving message to a `NetworkEvent` function. Most often, we
    will prefer to use the second method in our code, because all the verifications
    are already made to be able to exploit the event. This function just adds a packet
    to the outgoing queue. The job is then done by the `_sendThread` object, as shown
    in the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数非常重要，并复制了`sf::Window::pollEvent()`函数的行为，所以它们的用法不会让您感到惊讶。我们在这里做的是，如果有一个启用的事件，就从输入队列中获取一个事件。第二个函数还将接收到的消息解析为`NetworkEvent`函数。通常，我们更倾向于在代码中使用第二种方法，因为所有验证都已经完成，以便能够利用事件。这个函数只是将数据包添加到输出队列。然后，由`_sendThread`对象完成工作，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function closes the different sockets used. Because we used a connected
    protocol, the other side of the communication will be able to detect it and manage
    this at its convenience.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数关闭了使用的不同套接字。因为我们使用了连接协议，通信的另一端将能够检测到这一点，并在方便的时候处理。
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function is one of the two most important ones. It is run into its own
    thread—this is the reason for the loop. Moreover, we use the `sf::SocketSelector`
    function to observe our socket. Using this, we avoid useless operations that consume
    CPU power. Instead, we lock the thread until a message is received on the incoming
    socket. We also add a timeout of one second to avoid a deadlock, as seen in the
    following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是两个最重要的函数之一。它在自己的线程中运行——这就是循环的原因。此外，我们使用`sf::SocketSelector`函数来观察我们的套接字。使用它，我们避免了消耗CPU功率的无用操作。相反，我们锁定线程，直到在输入套接字上收到消息。我们还添加了一秒钟的超时，以避免死锁，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A deadlock is a situation encountered in multithreaded programs where two threads
    wait indefinitely because they are both waiting for a resource that only the other
    thread can free up. The most common is a double lock on the same mutex in the
    same thread, with a recursive call, for example. In the present case, imagine
    that you use the `stop()` function. The thread is not aware of this change, and
    will still be waiting for data, maybe forever, because no new data will be received
    on the socket. An easy solution is to add a timeout to not wait forever, but only
    a small amount of time that allows us to recheck the loop condition and get out
    if necessary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是在多线程程序中遇到的一种情况，其中两个线程无限期地等待，因为它们都在等待只有另一个线程才能释放的资源。最常见的是同一线程中对同一个互斥锁的双重锁定，例如递归调用。在当前情况下，假设您使用了`stop()`函数。线程没有意识到这种变化，仍然会等待数据，可能永远如此，因为套接字上不会收到新的数据。一个简单的解决方案是添加超时，以避免无限期等待，而是等待一小段时间，这样我们就可以重新检查循环条件，并在必要时退出。
- en: 'Once a packet is received, or a disconnection is detected, we add the corresponding
    packet to the queue. The user will then be able to pool in from its own thread
    and treat it as he wants. The disconnection shows you a specific `NetworkEvent`
    : `Disconnected` function. Later in the chapter, I will explain in detail the
    logic behind this.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到数据包或检测到断开连接，我们就将相应的数据包添加到队列中。然后用户将能够从自己的线程中检索它，并按自己的意愿处理。断开连接会显示一个特定的`NetworkEvent`：`Disconnected`函数。在后面的章节中，我将详细解释其背后的逻辑。
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function complements the previous one. It picks up events from the outgoing
    queue and sends it through the network using its socket.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数补充了前面的一个函数。它从输出队列中获取事件，并通过其套接字通过网络发送。
- en: As you can see, with the use of classes, we can send and receive data very easily
    in a multi-threaded environment. Moreover, the disconnection is managed like any
    other event and doesn't require any special case for the user. Another strength
    of this class is that it's very generic and can be used in a lot of cases, including
    on client and server sides.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用类，我们可以在多线程环境中非常容易地发送和接收数据。此外，断开连接就像管理任何其他事件一样，不需要用户进行任何特殊处理。这个类的另一个优点是它非常通用，可以在很多情况下使用，包括客户端和服务器端。
- en: 'To sum it up, we can visualize the usage of this class as shown in the following
    chart:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们可以将这个类的使用可视化如下图表：
- en: '![The goal of the Connection class](img/8477OS_08_01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![连接类的目标](img/8477OS_08_01.jpg)'
- en: Now that we have designed a class to manage the different messages, let's build
    our custom protocol.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计了一个类来管理不同的消息，让我们构建我们的自定义协议。
- en: Creating a communication protocol
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通信协议
- en: It's now time for us to create our own custom protocol. We will use an SFML
    class `sf::Packet` to transport our data, but we have to define their shapes.
    Let's first focus on the `sf::Packet` class and then on the shapes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们创建自己的自定义协议的时候了。我们将使用 SFML 类 `sf::Packet` 来传输数据，但我们必须定义它们的形状。让我们首先关注 `sf::Packet`
    类，然后是形状。
- en: Using the sf::Packet class
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sf::Packet 类
- en: The `sf::Packet` class is like a buffer that contains our data. It comes with
    already-made functions that allow us to serialize primitive types. I don't know
    if you are familiar with the internal memory storage of computers, but keep in
    mind that the arrangement is not the same everywhere. This is called endianness.
    You can see it like reading from the right or from the left. When you send data
    over the network, you don't know the endianness of the destination. Because of
    this, the convention is to send data as a big-endian arrangement over the network.
    I suggest you to take a look at the Wikipedia page ([https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness))
    for more details.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Packet` 类就像一个包含我们数据的缓冲区。它自带了允许我们序列化原始类型的函数。我不知道你是否熟悉计算机的内部内存存储，但请记住，这种排列并非在所有地方都相同。这被称为字节序。你可以把它想象成从右到左或从左到右读取。当你通过网络发送数据时，你不知道目标端的字节序。正因为如此，网络上的数据发送通常采用大端字节序。我建议你查看维基百科页面（[https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness)）以获取更多详细信息。'
- en: 'Thanks to SFML, there are some pre-existing functions that make the job easy
    for us. The only inconvenience is that we have to use SFML types instead of the
    primitive types. Following is a table that shows you the primitive types, and
    the corresponding type to use with `sf::Packet`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 SFML，有一些预定义的函数让我们的工作变得简单。唯一的麻烦是我们必须使用 SFML 类型而不是原始类型。以下是一个表格，展示了原始类型以及与 `sf::Packet`
    一起使用的对应类型：
- en: '| Primitive | SFML overload |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 原始类型 | SFML 重载 |'
- en: '| --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char` | `sf::Int8` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `sf::Int8` |'
- en: '| `unsigned char` | `sf::Uint8` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned char` | `sf::Uint8` |'
- en: '| `short int` | `sf::Int16` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | `sf::Int16` |'
- en: '| `unsigned short int` | `sf::Uint16` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short int` | `sf::Uint16` |'
- en: '| `Int` | `sf::int32` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | `sf::int32` |'
- en: '| `unsigned int` | `sf::Uint32` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | `sf::Uint32` |'
- en: '| `float` | `float` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `float` |'
- en: '| `double` | `double` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `double` |'
- en: '| `char*` | `char*` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `char*` | `char*` |'
- en: '| `std::string` | `std:string` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `std::string` | `std:string` |'
- en: '| `bool` | `bool` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |'
- en: 'The `sf::Packet` class is used like the standard c++ I/O streams using the
    `>>` and `<<` operators to extract and insert data. Following is an example taken
    directly from the SFML documentation of the `sf::Packet` class that shows you
    how simple it is in terms of usage:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Packet` 类的使用方式类似于标准的 C++ I/O 流，使用 `>>` 和 `<<` 操作符来提取和插入数据。以下是一个直接从 SFML
    文档中摘取的 `sf::Packet` 类示例，展示了其在使用上的简单性：'
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Even if this use is pretty simple, there is another way to send data like structure/class
    more easily, using the operator overload. This is the technique that we will use
    to send/receive data, an example of which is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种用法很简单，还有另一种方法可以更轻松地发送结构/类数据，即使用操作符重载。这是我们用来发送/接收数据的技术，以下是一个示例：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this technique, there are two operators to overload, and the serialization/unserialization
    is then transparent for the user. Moreover, if the structure changes, there is
    only one place to update: the operators.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，有两个操作符需要重载，然后序列化和反序列化对用户来说是透明的。此外，如果结构发生变化，只需在一个地方更新：操作符。
- en: Now that we have seen the system to transport our data, let's think about a
    way to construct it so that it is as generic as possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了传输数据的系统，让我们思考一种尽可能通用的构建方式。
- en: RPC-like protocol
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类似RPC的协议
- en: We now need to think exactly about our needs concerning the data to send. We
    have already pretty much completed the job in the first part of this chapter by
    separating the tasks of the client and the server, but it's not sufficient. We
    now need a list of all the different possibilities, which have been enlisted here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要精确地考虑发送数据的需求。我们已经在本章的第一部分通过分离客户端和服务器任务而完成了大部分工作，但这还不够。我们现在需要一个包含所有不同可能性的列表，这些可能性已在此列出。
- en: 'Both sides:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 双方：
- en: Connection
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: Disconnection
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开连接
- en: Client event
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端事件
- en: Log out
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 登出
- en: Get game list
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取游戏列表
- en: Request for the creation of a game (match)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏的请求（比赛）
- en: Request to join the game
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入游戏的请求
- en: Request to create an entity
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建实体的请求
- en: Request to destroy an entity
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁实体的请求
- en: Server events
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器事件
- en: Entity update
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体更新
- en: Entity's events (onHit, onHitted, onSpawn)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体的事件（onHit，onHitted，onSpawn）
- en: Update team (gold, game over)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新团队（金牌，游戏结束）
- en: Respond to client events
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应客户端事件
- en: The good news is that there aren't too many kinds of events; the bad news is
    that these events don't require the same information, so we can't build only one
    event, but instead, as many events as the number of possible actions, with their
    own data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是事件种类并不多；坏消息是这些事件不需要相同的信息，所以我们不能只构建一个事件，而必须构建与可能动作数量一样多的多个事件，每个事件都有自己的数据。
- en: 'But there is now another trouble. How do we recognize which one to use? Well,
    we need an identifier that allows this. An `enum` function will do the job perfectly,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在又出现了另一个问题。我们如何识别使用哪一个？嗯，我们需要一个允许这样做的标识符。一个`enum`函数将完美地完成这项工作，如下所示：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have a way to differ the actions, we have to send a packet with
    a common part for all these actions. This part (header) will contain the identifier
    of the action. Then all actions will add their own data. This is exactly the way
    that `sf::Event` works with the `sf::Event::type` attribute.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了区分动作的方法，我们必须发送一个包含所有这些动作公共部分的包。这个部分（头部）将包含动作的标识符。然后所有动作都将添加它们自己的数据。这正是`sf::Event`与`sf::Event::type`属性一起工作的方式。
- en: We will copy this mechanism to our own system, by building a new class called
    `NetworkEvent`. This class works as `sf::Event` does, except that it also adds
    serialization/unserialization with the `sf::Packet` class, allowing us to send
    that data across the network easily. Let's now take a look at this new class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制这个机制到我们自己的系统中，通过构建一个新的类，称为`NetworkEvent`。这个类的工作方式与`sf::Event`类似，但它还增加了与`sf::Packet`类的序列化/反序列化，使我们能够轻松地将数据发送到网络上。现在让我们看看这个新类。
- en: The NetworkEvent class
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络事件类
- en: The `NetworkEvent` class is built inside the `book::packet` namespace. Now that
    we have an idea of the global shape of our data to send, it's time for us to build
    some classes that will help us to deal with them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkEvent`类是在`book::packet`命名空间内部构建的。现在我们已经对我们的发送数据的全局形状有了概念，是时候构建一些帮助我们处理它们的类了。'
- en: 'We will build one class for each event, with a common parent, the `NetworkEvent`
    class. This class will allow us to use polymorphism. Following is its header:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个事件构建一个类，它们有一个共同的父类，即`NetworkEvent`类。这个类将允许我们使用多态。以下是其头文件：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, this class is very short and only contains its type. The reason
    is that it''s the only common point with all the different events. It also contains
    some default operator and an important function: `makeFromPacket()`. This function,
    as you will see, constructs the correct events depending on the data stored inside
    the `sf::Packet` received as parameter. Now take a look at the implementation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类非常短，只包含其类型。原因是它是所有不同事件唯一的共同点。它还包含一些默认运算符和一个重要的函数：`makeFromPacket()`。这个函数，正如您将看到的，根据作为参数接收到的`sf::Packet`内部存储的数据构建正确的事件。现在让我们看看实现：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As usual, the constructor and the destructor are very simple and should be
    familiar:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，构造函数和析构函数非常简单，应该很熟悉：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding function is very important. This is the one that will parse data
    received from the network to an instance of `NetworkEvent` with respect to the
    type received. The programmer will then use this instance instead of `sf::Packet`.
    Notice that an allocation is made inside this function, so a delete has to be
    made on the returned object after use:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数非常重要。这个函数会将从网络接收到的数据解析为`NetworkEvent`实例，具体取决于接收到的类型。程序员将使用这个实例而不是`sf::Packet`。请注意，在这个函数内部进行了分配，因此在使用后必须对返回的对象进行删除：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous function return the type associated to the `NetworkEvent`. It allows
    the programmer to cast the instance into the correct class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数返回与`NetworkEvent`关联的类型。它允许程序员将实例转换为正确的类。
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These two functions are in charge of the serialization/unserialization functionality.
    Because the unserialization function (`>>` operator) is only called inside the
    `makeFromPacket()` function and the type has already been extracted, this one
    does nothing. On the other hand, the serialization function (`<<` operator) adds
    the type of the event to the packet, as there is no other data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数负责序列化/反序列化功能。因为反序列化函数（`>>`运算符）仅在`makeFromPacket()`函数内部调用，并且类型已经被提取，所以这个函数不做任何事情。另一方面，序列化函数（`<<`运算符）将事件的类型添加到包中，因为没有其他数据。
- en: I will now show you one of the event classes. All the others are built on the
    same logic, and I'm sure that you already understand how it is done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将向您展示一个事件类。所有其他类都是基于相同的逻辑构建的，我相信您已经理解了它是如何实现的。
- en: 'Let''s take the `RequestCreateEntity` class. This class contains the different
    data to request the creation of an entity on the battlefield:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`RequestCreateEntity`类。这个类包含了请求在战场上创建实体的不同数据：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First of all, we define an `enum` function that will contain all the identifiers
    for the entities, and then the class that requests their construction. The `RequestCreateEntity`
    class inherits from the previous `NetworkEvent` class and defines the same functions,
    plus those specific to the event. Notice that there are two constructors. The
    default is used in the `makeFromPacket()` function, and the other by the programmer
    to send an event. Take a look now at the following implementation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`enum`函数，它将包含所有实体的标识符，然后是请求它们构建的类。`RequestCreateEntity`类继承自之前的`NetworkEvent`类，并定义了相同的函数，以及特定于事件的函数。请注意，这里有两个构造函数。默认构造函数用于`makeFromPacket()`函数，另一个由程序员用来发送事件。现在让我们看看以下实现：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This function unpacks the different data specific to the event and stores them
    internally. That''s all:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数解包特定于事件的不同的数据，并将其存储在内部。就是这样：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function serializes the different data using the SFML object corresponding
    to the primitive types used.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用与用于原始类型的SFML对象序列化不同的数据。
- en: As you can see, creating an event is really simple with this system. It only
    requires an identifier for its class along with some parsing functions. All the
    other events are built on the same model as this one, so I will not explain them.
    To see the complete code, you can take a look at the `include/SFML-Book/common/Packet.hpp`
    file if you want.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用这个系统创建事件真的很简单。它只需要为其类提供一个标识符以及一些解析函数。所有其他事件都是基于这个模型构建的，所以我就不再解释它们了。如果您想查看完整的代码，可以查看`include/SFML-Book/common/Packet.hpp`文件。
- en: Now that we have all the keys in hand to build the multiplayer part, it's time
    for us to modify our game.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建多人游戏部分所需的所有键，是时候修改我们的游戏了。
- en: Modifying our game
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我们的游戏
- en: 'To add this functionality to our game, we will need to rethink the internal
    structure a bit. First of all, we need to split our code to build two different
    programs. All the common classes (such as those used for communication) will be
    put into a common directory. All the other functionalities will be put into the
    server or client folder with respect to their usage. Let''s start with the most
    complicated part: the server.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此功能添加到我们的游戏中，我们需要稍微重新思考一下内部结构。首先，我们需要将我们的代码分成两个不同的程序。所有通用类（例如用于通信的类）将放入一个通用目录中。所有其他功能将根据其用途放入服务器或客户端文件夹中。让我们从最复杂的部分开始：服务器。
- en: Server
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器
- en: The server will be in charge of all the simulation. In fact, all our game will
    reside in the server. Moreover, it will have to ensure the possibility of having
    multiple matches running at the same time. It will also have to deal with connections/disconnections
    and player events.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将负责所有模拟。实际上，我们的整个游戏都将驻留在服务器上。此外，它还必须确保能够同时运行多个比赛。它还必须处理连接/断开连接和玩家事件。
- en: Because the server will not render anything, we don't need any graphic class
    anymore on this side. So the `AnimatedSprite` function in the `CompSkin` component
    will have to be removed, as will the `sf::RectangleShape` component in the `CompHp`
    function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因为服务器不会渲染任何内容，所以我们在这边不再需要任何图形类。因此，`CompSkin`组件中的`AnimatedSprite`函数以及`CompHp`函数中的`sf::RectangleShape`组件都需要被移除。
- en: Because the positions of the entities were stored by the `CompSkin` component
    (more precisely `_sprite`), we have to add an `sf::Vector2f` function in each
    entity that will store its position.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为实体的位置是由`CompSkin`组件（更确切地说，是`_sprite`）存储的，所以我们必须在每个实体中添加一个`sf::Vector2f`函数来存储其位置。
- en: 'The main loop will also be changed a lot. Remember that we need to manage multiple
    clients and matches and listen for a new connection on a specific port. So to
    be able to do this, we will build a `Server` class, and each match will have its
    own game instance running in its own thread. So let''s do this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环也将有很大的变化。记住，我们需要管理多个客户端和比赛，并在特定端口上监听新的连接。因此，为了能够做到这一点，我们将构建一个`Server`类，每个比赛将有一个自己的游戏实例在其自己的线程中运行。所以让我们这样做：
- en: Building the Server entry point
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建服务器入口点
- en: 'The server class will be in charge to manage new clients, to create new matches
    and to add clients to existing matches. This class can be seen like the main menu
    of the game. By the way the corresponding display on the player screen will be
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器类将负责管理新客户端，创建新比赛并将客户端添加到现有比赛中。这个类可以看作是游戏的主菜单。顺便说一下，玩家屏幕上的相应显示如下：
- en: '![Building the Server entry point](img/8477OS_08_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![构建服务器入口点](img/8477OS_08_04.jpg)'
- en: 'So, we will need to:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做的是：
- en: Store the running match (games)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储正在进行的比赛（游戏）
- en: Store the new clients
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储新客户端
- en: Listen for new clients
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听新客户端
- en: Respond to some request (create a new match, joint a match, get the list of
    running match)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应一些请求（创建新比赛、加入比赛、获取正在进行的比赛列表）
- en: Let's now build the server class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建服务器类。
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This class handle all the information describe above, and some threads to run
    separated functionalities independently (logging and request). Now take a look
    to its implementation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类处理上述所有信息，以及一些线程来独立运行不同的功能（日志和请求）。现在让我们看看它的实现：
- en: 'First of all we need to declare some global variable and function as followed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明一些全局变量和函数，如下所示：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous function will be call when the user will ask to stop the server
    by pressing the *Ctrl* + *C* key. This mechanism is initialized in the `Server::run()`
    function as you will see in a moment..
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Ctrl* + *C*键请求停止服务器时，将调用之前的函数。这个机制在`Server::run()`函数中初始化，你很快就会看到。
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous function initialize the different threads, and the random function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的函数初始化了不同的线程和随机函数。
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we destroy all the running matches and clients to stop the server properly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们销毁所有正在进行的比赛和客户端，以正确地停止服务器。
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function start the server that is blocked until the `SIGINT` (*Ctrl* +
    *c*) signal is sent to it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数启动服务器，直到接收到`SIGINT`（*Ctrl* + *c*）信号：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This function is the server''s most important function. This is the one that
    handles all the events coming from players. For each client, we check if there
    is an event waiting to be processed, and then, depending on its type, we take
    different actions. Thanks to our `NetworkEvent` class, the parsing on the event
    is easy, and we can reduce the code to the functionalities only:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是服务器最重要的函数。这是处理来自玩家的所有事件的函数。对于每个客户端，我们检查是否有等待处理的事件，然后根据其类型，采取不同的行动。多亏了我们的`NetworkEvent`类，对事件的解析变得简单，我们可以将代码缩减到仅包含功能的部分：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function is the final function of the server. Its job is to wait for a
    new connection, initialize the client, and add it to the list managed by the previous
    function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是服务器的最终函数。它的任务是等待新的连接，初始化客户端，并将其添加到先前函数管理的列表中。
- en: Nothing else has to be done in this class since as soon as the client joins
    a match, it's the match and no more the `Server` class that will have to deal
    with it. Each match is managed by a `Game` instance. Let's now take a look at
    it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中不需要做其他任何事情，因为一旦客户端加入比赛，处理它的将不再是`Server`类，而是每个比赛都由一个`Game`实例管理。现在让我们来看看它。
- en: Reacting to players' actions during a match
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在比赛中对玩家动作做出反应
- en: The `Game` class hasn't changed a lot. The event processing has changed, but
    is still very similar to the original system. Instead of using `sf::Event`, we
    now use `NetworkEvent`. And because the API is very close, it should not disturb
    you too much.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类没有太大变化。事件处理已经改变，但仍然非常类似于原始系统。我们不再使用`sf::Event`，而是现在使用`NetworkEvent`。由于API非常接近，它不应该给你带来太多麻烦。'
- en: 'The first function that interacts with a player is the one that receives the
    match information. For example, we need to send it to the map file and all the
    different entities. This task is created by the `Game::addClient()` function,
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与玩家交互的第一个函数是接收比赛信息的那个。例如，我们需要将其发送到地图文件和所有不同的实体。这个任务是由`Game::addClient()`函数创建的，如下所示：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function is separated into four parts:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数分为四个部分：
- en: Checking if we can add a new player to the match.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否可以添加新玩家到比赛中。
- en: Sending map data.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送地图数据。
- en: Sending entity informations.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送实体信息。
- en: Adding the client to the team.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户端添加到团队中。
- en: 'Once a client has been added to the game, we have to manage its incoming events.
    This task is made by the new function `processNetworkEvents()`. It works exactly
    as the old `processEvents()` function, but with `NetworkEvent` instead of `sf::Events`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦客户端被添加到游戏中，我们必须管理其接收的事件。这个任务由新的函数`processNetworkEvents()`完成。它的工作方式与旧的`processEvents()`函数完全相同，但使用`NetworkEvent`而不是`sf::Events`：
- en: '[PRE27]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's no surprise here. We have to deal with the possible client disconnection/logout,
    and then with all the different events. I don't have to put the entire code of
    the different events, as there is nothing complicated there. But if you are interested,
    take a look at the `src/SFML-Book/server/Game.cpp` file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶。我们必须处理客户端断开连接/登出，以及所有不同的事件。我无需放置不同事件的全部代码，因为那里没有复杂的东西。但如果你感兴趣，可以查看`src/SFML-Book/server/Game.cpp`文件。
- en: Notice that we never send any confirmation to the client for any request. The
    synchronization of the game will ensure this.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从未向客户端发送任何请求的确认。游戏的同步将确保这一点。
- en: Synchronization between clients and the server
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端与服务器之间的同步
- en: A big change in the `Game` class is the way to manage the synchronization between
    the clients and the server. In the previous chapter, only one client received
    data. Now we have some of the clients, and the logic changes. To ensure synchronization,
    we have to send updates to clients.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类中的一个重大变化是管理客户端与服务器之间同步的方式。在前一章中，只有一个客户端接收数据。现在我们有一些客户端，逻辑发生了变化。为了确保同步，我们必须向客户端发送更新。'
- en: 'To be able to send the updates, we have to keep in memory each change during
    the game loop, and then send them to all the players. Because a request will change
    the game, it will be included in the updates. This is why in the previous points
    we don''t send any response to the player for the requests. In the game, we will
    need to keep track of the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够发送更新，我们必须在游戏循环中记住每个变化，然后将它们发送给所有玩家。因为请求将改变游戏，它将包含在更新中。这就是为什么在前面的点中我们不向玩家发送任何请求的响应。在游戏中，我们需要跟踪以下内容：
- en: Entity creation
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体创建
- en: Entity destruction
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体销毁
- en: Entity updates
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体更新
- en: Entity events (onHitted, onHit, onSpawn)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体事件（onHitted, onHit, onSpawn）
- en: Update of team status, gold amount, and so on
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新团队状态、金币数量等
- en: 'Most of these events only require the entity ID without any other information
    (destruction entity events). For other events, some extra data is required, but
    the logic is still the same: add the information to a container.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件中的大多数只需要实体ID，而不需要其他信息（销毁实体事件）。对于其他事件，需要一些额外的数据，但逻辑仍然是相同的：将信息添加到容器中。
- en: Then, in the `Game::update()` function, we have to send the updates to all the
    players. To do this, we add to a queue the outgoing events (exactly as in the
    `Connection` class). Another thread will be in charge of their propagation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Game::update()`函数中，我们必须向所有玩家发送更新。为此，我们将输出事件添加到队列中（与`Connection`类中的方式相同）。另一个线程将负责它们的传播。
- en: 'Here is a code snippet that makes the destruction event:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建销毁事件的代码片段：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, there is no complexity here, and all the magic is done by the
    `sendToAll()` function. As you can suppose, its aim is to broadcast the message
    to all the different players by adding the packet to the outgoing queue. Another
    thread will then enter that queue to broadcast the message.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里没有复杂性，所有的魔法都是由`sendToAll()`函数完成的。正如你所猜测的，它的目的是通过将数据包添加到输出队列来向所有不同的玩家广播消息。然后另一个线程将进入该队列以广播消息。
- en: In terms of the game's logic, nothing else has changed. We still use the entity
    system and the map to manage the level. Only the graphical elements have been
    deleted. It is the client's job to display on the screen the game state to the
    player, speaking of which, let's now look into this part in detail.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏逻辑方面，没有其他变化。我们仍然使用实体系统和地图来管理关卡。只是图形元素被删除了。这是客户端的任务，向玩家显示游戏状态，说到这里，让我们现在详细看看这一部分。
- en: The Client class
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端类
- en: This is the final part of this chapter. The client is even simpler than the
    server, since it only has one player to manage but is still a bit complex. The
    client will have a graphical rendering but no more game logic. The only job made
    by the client is handling player inputs and updating the game states with the
    incoming network events.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一部分。客户端比服务器简单得多，因为它只需要管理一个玩家，但仍然有点复杂。客户端将具有图形渲染，但没有更多的游戏逻辑。客户端的唯一任务是处理玩家输入和更新游戏状态，使用接收到的网络事件。
- en: 'Because starting a client is now not sufficient to start a match, we have to
    communicate with the server to initialize a game, or even create a new match.
    In fact, a client is composed of two main components: the connection menu and
    the game. The client game class has changed a lot to handle the new functionalities,
    which is why I will now show you the new `Game` header before continuing the explanation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在仅启动客户端不足以开始比赛，我们必须与服务器通信以初始化游戏，甚至创建一个新的比赛。实际上，客户端由两个主要组件组成：连接菜单和游戏。客户端游戏类为了处理新的功能而发生了很大变化，这就是为什么我现在在继续解释之前会先展示新的`Game`头文件：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, there are some new functions to manage the network, and the
    GUI has been separated in other classes (`MainMenu`, `GameMenu`). On the other
    hand, some classes such as `Level` haven't changed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有一些新的函数用于管理网络，GUI已经被分离到其他类中（`MainMenu`，`GameMenu`）。另一方面，一些类如`Level`并没有改变。
- en: Now let's take a look at the main menu.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看主菜单。
- en: Connection with the server
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器连接
- en: Before starting a match, a connection to the server is required, following which
    we have to choose which match we want to play. The connection is achieved exactly
    as in the server, but in the reverse order (changing received to send, and vice
    versa).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始比赛之前，需要连接到服务器，连接成功后，我们必须选择我们想要玩哪场比赛。连接方式与服务器上完全相同，但顺序相反（将接收改为发送，反之亦然）。
- en: 'The choice of the match is then made by the player. He has to be able to create
    a new match and join it as well. To simplify this, we will use our GUI by creating
    a `MainMenu` class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后由玩家选择比赛。他必须能够创建一个新的比赛并加入其中。为了简化这个过程，我们将通过创建一个`MainMenu`类来使用我们的GUI：
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This class is very small. It''s a frame with several buttons, as you can see
    in the following image:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常小。它是一个带有几个按钮的框架，正如你在以下图片中可以看到的：
- en: '![Connection with the server](img/8477OS_08_04.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![服务器连接](img/8477OS_08_04.jpg)'
- en: 'The implementation of this class is not too complicated; rather much more consequential:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实现并不太复杂；而是具有更大的影响：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All the logic of the class is coded within the `fill()` function. This function
    receives the list of running matches on the server and displays them as buttons
    to the player. The player can then press one of the buttons to join the match
    or request the creation of a game.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类的所有逻辑都编码在`fill()`函数中。这个函数接收服务器上正在运行的比赛列表，并将其显示为按钮给玩家。然后玩家可以按下其中一个按钮加入比赛或请求创建游戏。
- en: 'When the player requests to join the game, if all is good on the server side,
    the client receives a `JoinGameConfirmation` event with the data to initialize
    its level (remember the `addClient()` function in the server):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家请求加入游戏时，如果服务器端一切正常，客户端将接收到一个`JoinGameConfirmation`事件，其中包含初始化其级别的数据（记住服务器中的`addClient()`函数）：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function handles the events coming from the server and dispatches them
    depending on the internal states. As you can see, a `JoinGameConfirmation` event
    launches the creation of the level, and a change of the internal state, which
    shows by displaying the game to the player.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数处理来自服务器的各种事件，并根据内部状态进行分发。正如你所见，一个`JoinGameConfirmation`事件会启动级别的创建，并改变内部状态，这通过向玩家显示游戏来体现。
- en: The Level class
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别类
- en: Some additions have been made to the `Level` class to handle network events.
    We still have to deal with construction/destruction requests, but now we also
    have to manage events coming from the server, such as position update, entity
    creation/destruction, and entity events.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Level`类进行了一些添加，以处理网络事件。我们仍然需要处理构建/销毁请求，但现在我们还需要管理来自服务器的各种事件，例如位置更新、实体创建/销毁和实体事件。
- en: 'This management is very important because this is the place that adds dynamism
    to our game to synchronize it with the server. Take a look at the following function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种管理非常重要，因为这是添加游戏动态并使其与服务器同步的地方。请看以下函数：
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, this function is a bit long. This is because we have to manage
    six different types of events. The destruction and the creation of entities are
    easy to make because the major part of the job is done by the `EntityManager`
    function. The updates are another piece of cake. We have to change each value
    to the new one, one by one, or activate the callbacks for the entity events with
    all the necessary verifications; remember *don't trust user inputs*, even if they
    come from the server.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数有点长。这是因为我们必须管理六种不同类型的事件。实体的销毁和创建很容易实现，因为大部分工作都是由`EntityManager`函数完成的。更新也很简单。我们必须逐个更改每个值，或者激活实体事件的回调，并进行所有必要的验证；记住*不要相信用户输入*，即使它们来自服务器。
- en: Now that the major part of the game has been made, we just have to clean all
    the unnecessary components from the client to only have `CompTeam`, `CompHp`,
    and `CompSkin`. All the others are only used by the server for the entities' behavior.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏的主要部分已经完成，我们只需要从客户端清理掉所有不必要的组件，只保留`CompTeam`、`CompHp`和`CompSkin`。其他所有组件都只由服务器用于实体的行为。
- en: 'The final result of this chapter will not change a lot from the previous one,
    but you will now be able to play with friends, and the game will become interesting
    to play because the difficulties are now real:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终结果与上一章不会有太大变化，但现在你将能够和朋友一起玩游戏，因为难度现在是真实的：
- en: '![The Level class](img/8477OS_08_05.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![The Level class](img/8477OS_08_05.jpg)'
- en: Adding data persistence to the game
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据持久化添加到游戏中
- en: 'If, like me, you can''t imagine a game without a save option, this part couldn''t
    interest you more. In this final part of the book, I will introduce you to the
    persistence of data. Data persistence is the ability of a program to save its
    internal state for future restoration. This is exactly what a save option does
    in a game. In our particular case, because the client received data directly from
    the server, all the jobs have to be done on the server part. First of all, let''s
    think a bit about what we need to save:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，无法想象一个没有保存选项的游戏，这部分将对你更有吸引力。在这本书的最后一部分，我将向你介绍数据的持久化。数据持久化是程序保存其内部状态以供将来恢复的能力。这正是游戏中保存选项所做的事情。在我们的特定情况下，因为客户端直接从服务器接收数据，所有的工作都必须在服务器部分完成。首先，让我们稍微思考一下我们需要保存什么：
- en: The entities and their components
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体及其组件
- en: The teams
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队
- en: The games
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏
- en: We then need a way to store that data to be able to restore it later. The solution
    is to use files or something else that can grow with time, as easy to copy. For
    this functionality, I've made the choice of using `Sqlite`. This is a database
    engine available as library. More information can be found on the website at [https://sqlite.org/](https://sqlite.org/).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要一种方法来存储这些数据，以便以后能够恢复。解决方案是使用文件或其他可以随时间增长且易于复制的东西。为此功能，我选择了使用`Sqlite`。这是一个作为库提供的数据库引擎。更多信息可以在[https://sqlite.org/](https://sqlite.org/)网站上找到。
- en: The usage of a database engine is a bit of overkill for our project, but the
    goal here is to show you its usage in our actual game. Then you will be able to
    use it for more complex projects of your creation. The persistence data will be
    stored in a database that is a single file, which can easily be copied or modified
    using some GUI for `Sqlite`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库引擎对我们的项目来说有点过度，但在这里的目标是向你展示它在我们的实际游戏中的应用。然后你将能够将其用于你创建的更复杂的项目。持久化数据将存储在一个数据库文件中，这个文件可以很容易地使用一些GUI工具来复制或修改`Sqlite`。
- en: 'The only drawback of this solution is that some knowledge on the SQL language
    is required. Because this book doesn''t aim to cover that topic, I propose to
    you an alternative usage: **Object-relational Mapping** (**ORM**).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的唯一缺点是需要一些关于SQL语言的知识。因为这本书的目标不是涵盖这个主题，我建议你使用另一种用法：**对象关系映射**（**ORM**）。
- en: What is ORM?
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是ORM？
- en: To say as simply as possible, an ORM is between the database engine and the
    API of the program and automatically makes the SQL query when it's needed without
    the need to write it by hand. Moreover, most of them support multiple database
    engines, allowing you to change the engine with only one or two lines of code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，ORM位于数据库引擎和程序API之间，并在需要时自动生成SQL查询，而不需要手动编写。此外，大多数ORM支持多种数据库引擎，允许你通过一行或两行代码更改引擎。
- en: 'Following is an example that will help illustrate my words (in pseudo code).
    First, using a standard library:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，将有助于说明我的话（伪代码）。首先，使用标准库：
- en: '[PRE34]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And now using an ORM:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用ORM：
- en: '[PRE35]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, all is made by the ORM without the need to write anything. This
    remains exactly the same when it comes to saving data. Just use the `save()` method,
    and that's it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有这些都是由 ORM 完成的，无需编写任何代码。保存数据时也是如此。只需使用 `save()` 方法，就是这样。
- en: Using cpp-ORM
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cpp-ORM
- en: We will use the `cpp-ORM` library which was written by me, so there is no trouble
    to use it in our project. It can be found at [https://github.com/Krozark/cpp-ORM](https://github.com/Krozark/cpp-ORM).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我编写的 `cpp-ORM` 库，所以在我们的项目中使用它不会有任何问题。它可以在 [https://github.com/Krozark/cpp-ORM](https://github.com/Krozark/cpp-ORM)
    找到。
- en: To be able to work, the library needs some information on your class; this is
    why some custom types have to be used for the data that you want to save.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够工作，库需要一些关于你类的信息；这就是为什么必须使用一些自定义类型来保存你想要保存的数据。
- en: '| ORM types | C++ types |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| ORM 类型 | C++ 类型 |'
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| orm::BooleanField | bool |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| orm::BooleanField | bool |'
- en: '| orm::CharField<N> | std::string (of length N) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| orm::CharField<N> | std::string (of length N) |'
- en: '| orm::DateTimeField | struct tm |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| orm::DateTimeField | struct tm |'
- en: '| orm::AutoDateTimeField |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| orm::AutoDateTimeField |'
- en: '| orm::AutoNowDateTimeField |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| orm::AutoNowDateTimeField |'
- en: '| orm::IntegerField | int |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| orm::IntegerField | int |'
- en: '| orm::FloatField | float |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| orm::FloatField | float |'
- en: '| orm::DoubleField | double |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| orm::DoubleField | double |'
- en: '| orm::TextField | std::string |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| orm::TextField | std::string |'
- en: '| orm::UnsignedIntegerField | unsigned int |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| orm::UnsignedIntegerField | unsigned int |'
- en: '| orm::FK<T,NULLABLE=true> | std::shared_ptr<T> NULLABLE specify if T can be
    null |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| orm::FK<T,NULLABLE=true> | std::shared_ptr<T> NULLABLE 指定 T 是否可以为空 |'
- en: '| orm::ManyToMany<T,U> | std::vector<std::shared_ptr<U>> Use it when T need
    to keep an unknown number of reference of U class |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| orm::ManyToMany<T,U> | std::vector<std::shared_ptr<U>> 当 T 需要保留对 U 类的未知数量的引用时使用
    |'
- en: 'Moreover, your class will need to have a default constructor with no parameters,
    and extends from `orm::SqlObject<T>` where `T` is your class name. To understand
    well, let''s build a component as persistent, such as `CompHp`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的类将需要一个不带参数的默认构造函数，并扩展自 `orm::SqlObject<T>`，其中 `T` 是你的类名。为了更好地理解，让我们构建一个持久化的组件，例如
    `CompHp`：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There is not much to explain. We just add `orm::SqlObject<CompHp>` as the parent
    class and change `int` to `orm::IntegerField`. The `MAKE_STATIC_COLUMN` is used
    to create some additional fields that will contain the column name of each field
    in the database. With regards to the implementation, there is another macro to
    avoid repetitive work: `REGISTER_AND_CONSTRUCT`. Its usage is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 没有多少需要解释的。我们只需将 `orm::SqlObject<CompHp>` 作为父类添加，并将 `int` 改为 `orm::IntegerField`。`MAKE_STATIC_COLUMN`
    用于创建一些额外的字段，这些字段将包含数据库中每个字段的列名。关于实现，还有一个宏来避免重复工作：`REGISTER_AND_CONSTRUCT`。其用法如下：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This macro will construct the entire default constructor implementation. Then,
    in your code, use the field as usual. There is no need to change anything concerning
    your class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏将构建整个默认构造函数实现。然后，在你的代码中，像往常一样使用字段。不需要更改任何关于你类的内容。
- en: 'The last requirement is to reference the default database to use. In our case,
    we will use the `Sqlite3` engine, so we need to create it somewhere, for example,
    in the `main.cpp` file:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的要求是引用要使用的默认数据库。在我们的例子中，我们将使用 `Sqlite3` 引擎，因此我们需要在某个地方创建它，例如在 `main.cpp` 文件中：
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this short example, the database is created and the connection connected
    to it. It's important to keep in mind that all the access to the database will
    use the default connection by default.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的例子中，数据库已创建，连接已连接到它。重要的是要记住，默认情况下，所有对数据库的访问都将使用默认连接。
- en: Turning our object persistent
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的对象持久化
- en: Now that the database is created, we don't need to touch it anymore. Now let's
    interest ourselves with how to save our objects in the database or restore them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库已经创建，我们不再需要触碰它了。现在让我们关注如何将我们的对象保存到数据库中或恢复它们。
- en: Saving an object in a database
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数据库中保存对象
- en: 'This functionality is very simple thanks to the entity system. Let''s take
    our previous `CompHp` class. Create an instance of it and call the `.save()` method
    on it. If you want to update an object already stored in the database, use `save()`
    as well. Only the field that changes will be updated:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了实体系统，这个功能非常简单。让我们以我们之前的 `CompHp` 类为例。创建其实例，并在其上调用 `.save()` 方法。如果你想要更新数据库中已经存储的对象，也可以使用
    `save()`。只有更改的字段将被更新：
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now let's move on to the object loading.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到对象加载。
- en: Loading an object from the database
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据库中加载数据对象
- en: 'There are basically two ways to load an object. The first one is when you know
    its primary key (identifier), and the second one is to search all the objects
    corresponding to a specific criterion:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 加载对象基本上有两种方式。第一种是你知道它的主键（标识符），第二种是搜索符合特定标准的所有对象：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These two lines of code load an object from the database and then display its
    content to the console output. On the other hand, if you don''t know the identifier
    value but you have a specific criterion, you can also load objects in the following
    manner:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码从数据库中加载一个对象，并将其内容显示到控制台输出。另一方面，如果你不知道标识符值，但有一个特定的标准，你也可以以下这种方式加载对象：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we get the entire `CompHp` component through a complex query
    and then display the content to the console output.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过一个复杂的查询获取整个`CompHp`组件，并将其内容显示到控制台输出。
- en: Now you have all the keys in hand to add loading/saving into our actual game
    without too much pain, so I will not enter further into the implementation details.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了所有必要的键，可以在我们的实际游戏中轻松地添加加载/保存功能，所以我就不会进一步深入到实现细节中。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, you have learned how to add basic networking using sockets,
    selectors, and even creating a custom protocol. You have integrated this new knowledge
    to the previous game and turned it into a multiplayer game in real time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，你学习了如何使用套接字、选择器和甚至创建自定义协议来添加基本网络功能。你已经将新知识整合到之前的游戏中，并将其转变为实时多人游戏。
- en: You have also learned how to add persistence to your data using an ORM, and
    how to add a save/load option to the game. By now you have seen many aspects of
    game programming, and you now have all the keys in hand to build every kind of
    game you want in 2D.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何使用ORM给你的数据添加持久性，以及如何为游戏添加保存/加载选项。到目前为止，你已经看到了游戏编程的许多方面，现在你手头有所有必要的键，可以构建你想要的任何类型的2D游戏。
- en: I hope that this book gives you useful tools. If you want to reuse some part
    of the framework made across this book, the code is available on GitHub at [https://github.com/Krozark/SFML-utils](https://github.com/Krozark/SFML-utils).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能给你提供有用的工具。如果你想重用这本书中制作的框架的某些部分，代码可在GitHub上找到：[https://github.com/Krozark/SFML-utils](https://github.com/Krozark/SFML-utils)。
- en: I hope you have enjoyed reading this book, and developed the games well. I wish
    you good luck for your future games!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢阅读这本书，并且游戏开发得很好。祝你未来游戏好运！
