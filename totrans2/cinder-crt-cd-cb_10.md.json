["```cpp\n#include \"InteractiveObject.h\"\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    #pragma once\n\n    #include \"cinder/Rect.h\"\n    #include \"cinder/Color.h\"\n    #include \"cinder/app/MouseEvent.h\"\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/app/App.h\"\n    ```", "```cpp\n    class InteractiveObject{\n    public:\n    InteractiveObject( const ci::Rectf& rect );\n    virtual ~InteractiveObject();\n    virtual void draw();\n    virtual void pressed();\n    virtual void pressedOutside();\n    virtual void released();\n    virtual void releasedOutside();\n    virtual void rolledOver();\n    virtual void rolledOut();\n    virtual void dragged();\n    void mouseDown( ci::app::MouseEvent& event );\n    void mouseUp( ci::app::MouseEvent& event );\n    void mouseDrag( ci::app::MouseEvent& event );\n    void mouseMove( ci::app::MouseEvent& event );\n\n    ci::Rectf rect;\n    ci::Color pressedColor, idleColor, overColor, strokeColor;\n\n    protected:\n    bool mPressed, mOver;\n    };\n    ```", "```cpp\n    #include \"InteractiveObject.h\"\n\n    using namespace ci;\n    using namespace ci::app;\n    using namespace std;\n    ```", "```cpp\n    InteractiveObject::InteractiveObject( const Rectf& rect ){\n      this->rect = rect;\n      pressedColor = Color( 1.0f, 0.0f, 0.0f );\n      idleColor = Color( 0.7f, 0.7f, 0.7f );\n      overColor = Color( 1.0f, 1.0f, 1.0f );\n      strokeColor = Color( 0.0f, 0.0f, 0.0f );\n      mPressed = false;\n      mOver = false;\n    }\n\n    InteractiveObject::~InteractiveObject(){    \n    }\n    ```", "```cpp\n    void InteractiveObject::draw(){\n     if( mPressed ){\n      gl::color( pressedColor );\n     } else if( mOver ){\n      gl::color( overColor );\n     } else {\n      gl::color( idleColor );\n     }\n     gl::drawSolidRect( rect );\n     gl::color( strokeColor );\n     gl::drawStrokedRect( rect );\n    }\n    ```", "```cpp\n    void InteractiveObject::pressed(){\n      console() << \"pressed\" << endl;\n    }\n\n    void InteractiveObject::pressedOutside(){\n      console() << \"pressed outside\" << endl;\n    }\n\n    void InteractiveObject::released(){\n      console() << \"released\" << endl;\n    }\n\n    void InteractiveObject::releasedOutside(){\n      console() << \"released outside\" << endl;\n    }\n\n    void InteractiveObject::rolledOver(){\n      console() << \"rolled over\" << endl;\n    }\n\n    void InteractiveObject::rolledOut(){\n      console() << \"rolled out\" << endl;\n    }\n\n    void InteractiveObject::dragged(){\n      console() << \"dragged\" << endl;\n    }\n    ```", "```cpp\n    void InteractiveObject::mouseDown( MouseEvent& event ){\n      if( rect.contains( event.getPos() ) ){\n        mPressed = true;\n        mOver = false;\n        pressed();\n      }else{\n          pressedOutside();\n      }\n    }\n\n    void InteractiveObject::mouseUp( MouseEvent& event ){\n     if( rect.contains( event.getPos() ) ){\n      if( mPressed ){\n       mPressed = false;\n       mOver = true;\n       released();\n      }\n     } else {\n      mPressed = false;\n      mOver = false;\n      releasedOutside();\n     } \n    }\n\n    void InteractiveObject::mouseDrag( MouseEvent& event ){\n     if( mPressed && rect.contains( event.getPos() ) ){\n      mPressed = true;\n      mOver = false;\n      dragged();\n     } \n    }\n\n    void InteractiveObject::mouseMove( MouseEvent& event ){\n     if( rect.contains( event.getPos() ) ){\n      if( mOver == false ){\n       mPressed = false;\n       mOver = true;\n       rolledOver();\n      }\n     } else {\n      if( mOver ){\n       mPressed = false;\n       mOver = false;\n       rolledOut();\n      } \n     }\n    ```", "```cpp\n    shared_ptr<InteractiveObject> mObject;\n    ```", "```cpp\n    Rectf rect( 100.0f, 100.0f, 300.0f, 300.0f );\n    mObject = shared_ptr<InteractiveObject>( new InteractiveObject( rect ) );\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\t\n    void mouseUp( MouseEvent event );\n    void mouseDrag( MouseEvent event );\n    void mouseMove( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      mObject->mouseDown( event );\n    }\n\n    void MyApp::mouseUp( MouseEvent event ){\n      mObject->mouseUp( event );\n    }\n\n    void MyApp::mouseDrag( MouseEvent event ){\n      mObject->mouseDrag( event );\n    }\n\n    void MyApp::mouseMove( MouseEvent event ){\n      mObject->mouseMove( event );\n    }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    mObject->draw();\n    ```", "```cpp\n    class InteractiveObject;\n    class InteractiveObjectEvent: public ci::app::Event{\n    public:\n    enum EventType{ Pressed, PressedOutside, Released,\n     ReleasedOutside, RolledOut, RolledOver, Dragged };\n    InteractiveObjectEvent( InteractiveObject *sender, \n     EventType type ){\n     this->sender = sender;\n     this->type = type;\n    }\n\n    InteractiveObject *sender;\n    EventType type;\n    };\n    ```", "```cpp\n    ci::CallbackMgr< void(InteractiveObjectEvent) > mEvents;\n    ```", "```cpp\n    template< class T >\n    ci::CallbackId addListener( T* listener, \n     void (T::*callback)(InteractiveObjectEvent) ){\n     return mEvents.registerCb( std::bind1st( \n      std::mem_fun( callback ), listener ) );\n    }\n    ```", "```cpp\n    void removeListener( ci::CallbackId callId );\n    ```", "```cpp\n    void InteractiveObject::removeListener( CallbackId callbackId ){\n      mEvents.unregisterCb( callbackId );\n    }\n    ```", "```cpp\n    void InteractiveObject::mouseDown( MouseEvent& event ){\n     if( rect.contains( event.getPos() ) ){\n      mPressed = true;\n      mOver = false;\n      pressed();\n      mEvents.call( InteractiveObjectEvent( this,\n       InteractiveObjectEvent::Pressed ) );\n     } else {\n      pressedOutside();\n      mEvents.call( InteractiveObjectEvent( this, \n       InteractiveObjectEvent::PressedOutside ) );\n     } \n    }\n\n    void InteractiveObject::mouseUp( MouseEvent& event ){\n     if( rect.contains( event.getPos() ) ){\n      if( mPressed ){\n       mPressed = false;\n       mOver = true;\n       released();\n       mEvents.call( InteractiveObjectEvent( this, \n        InteractiveObjectEvent::Released ) );\n      }\n     } else {\n      mPressed = false;\n      mOver = false;\n      releasedOutside();\n      mEvents.call( InteractiveObjectEvent( this, \n       InteractiveObjectEvent::ReleasedOutside ) );\n     } \n    }\n\n    void InteractiveObject::mouseDrag( MouseEvent& event ){\n     if( mPressed && rect.contains( event.getPos() ) ){\n      mPressed = true;\n      mOver = false;\n\n      dragged();\n      mEvents.call( InteractiveObjectEvent( this,\n      InteractiveObjectEvent::Dragged ) );\n     }\n    }\n\n    void InteractiveObject::mouseMove( MouseEvent& event ){\n     if( rect.contains( event.getPos() ) ){\n      if( mOver == false ){\n       mPressed = false;\n       mOver = true;\n       rolledOver();\n       mEvents.call( InteractiveObjectEvent( this, \n        InteractiveObjectEvent::RolledOver ) );\n      }\n     } else {\n      if( mOver ){\n       mPressed = false;\n       mOver = false;\n       rolledOut();\n       mEvents.call( InteractiveObjectEvent( this, \n        InteractiveObjectEvent::RolledOut ) );\n      }\n     }\n    }\n    ```", "```cpp\n    void receivedEvent( InteractiveObjectEvent event );\n    ```", "```cpp\n    void MyApp::receivedEvent( InteractiveObjectEvent event ){\n    string text;\n    switch( event.type ){\n    case InteractiveObjectEvent::Pressed:\n    text = \"Pressed event\";\n    break;\n    case InteractiveObjectEvent::PressedOutside:\n    text = \"Pressed outside event\";\n    break;\n    case InteractiveObjectEvent::Released:\n    text = \"Released event\";\n    break;\n    case InteractiveObjectEvent::ReleasedOutside:\n    text = \"Released outside event\";\n    break;\n    case InteractiveObjectEvent::RolledOver:\n    text = \"RolledOver event\";\n    break;\n    case InteractiveObjectEvent::RolledOut:\n    text = \"RolledOut event\";\n    break;\n    case InteractiveObjectEvent::Dragged:\n    text = \"Dragged event\";\n    break;\n    default:\n    text = \"Unknown event\";      \n        }\n    console() << \"Received \" + text << endl;\n    }\n    ```", "```cpp\n    mObject->addListener( this, &InteractiveObjectApp::receivedEvent );\n    ```", "```cpp\n    #include \"InteractiveObject.h\"\n    #include \"cinder/gl/Texture.h\"\n    ```", "```cpp\n    class Button: public InteractiveObject{\n    public:\n    Button( const ci::Rectf& rect, ci::gl::Texture idleTex, \n     ci::gl::Texture overTex, ci::gl::Texture pressTex)\n    :InteractiveObject( rect )\n    {\n     mIdleTex = idleTex;\n     mOverTex = overTex;\n     mPressTex = pressTex;\n    }\n\n    virtual void draw(){\n     if( mPressed ){\n      ci::gl::draw( mPressTex, rect );\n     } else if( mOver ){\n      ci::gl::draw( mOverTex, rect );\n     } else {\n      ci::gl::draw( mPressTex, rect );\n     }\n    }\n\n    protected:\n    ci::gl::Texture mIdleTex, mOverTex, mPressTex;\n    };\n    ```", "```cpp\n    #pragma once\n\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/Color.h\"\n\n    #include \"InteractiveObject.h\"\n\n    using namespace std;\n    using namespace ci;\n    using namespace ci::app;\n\n    class Slider : publicInteractiveObject {\n    public:\n    Slider( ) : InteractiveObject( Rectf(0,0, 100,10) ) {\n     mValue = 0.f;\n    }\n    Vec2f   getPosition() { return rect.getUpperLeft(); }\n    void    setPosition(Vec2f position) { rect.offset(position); }\n    void    setPosition(float x, float y) { setPosition(Vec2f(x,y)); }\n    float   getWidth() { return getSize().x; }\n    float   getHeight() { return getSize().y; }\n    Vec2f   getSize() { return rect.getSize(); }\n    void    setSize(Vec2f size) { \n     rect.x2 = rect.x1+size.x; rect.y2 = rect.y1+size.y; \n    }\n    void    setSize(float width, float height) { \n     setSize(Vec2f(width,height)); \n    }\n    virtual float getValue() { return mValue; }\n    virtual void setValue(float value) {\n     mValue = ci::math<float>::clamp(value);\n    }\n\n    virtual void pressed() {\n     InteractiveObject::pressed();\n     dragged();\n    }\n\n    virtual void dragged() {\n     InteractiveObject::dragged();\n     Vec2i mousePos = AppNative::get()->getMousePos();\n     setValue( (mousePos.x - rect.x1) / rect.getWidth() );\n    }\n\n    virtual void draw() {\n     gl::color(Color::gray(0.7f));\n     gl::drawSolidRect(rect);\n     gl::color(Color::black());\n     Rectf fillRect = Rectf(rect);\n     fillRect.x2 = fillRect.x1 + fillRect.getWidth() * mValue;\n     gl::drawSolidRect( fillRect );\n    }\n\n    protected:\n    float mValue;\n    };\n    ```", "```cpp\n    #include \"Slider.h\"\n    ```", "```cpp\n    shared_ptr<Slider> mSlider1;\n    shared_ptr<Slider> mSlider2;\n    shared_ptr<Slider> mSlider3;\n    ```", "```cpp\n    mSlider1 = shared_ptr<Slider>( new Slider() );\n    mSlider1->setPosition(70.f, 20.f);\n    mSlider1->setSize(200.f, 10.f);\n    mSlider1->setValue(0.75f);\n\n    mSlider2 = shared_ptr<Slider>( new Slider() );\n    mSlider2->setPosition(70.f, 35.f);\n    mSlider2->setValue(0.25f);\n\n    mSlider3 = shared_ptr<Slider>( new Slider() );\n    mSlider3->setPosition(70.f, 50.f);\n    mSlider3->setValue(0.5f);\n    ```", "```cpp\n    gl::enableAlphaBlending();\n    gl::clear( Color::white() );\n    gl::setViewport(getWindowBounds());\n    gl::setMatricesWindow(getWindowSize());\n\n    mSlider1->draw();\n    gl::drawStringRight(\"Value 1:\", mSlider1->getPosition()+Vec2f(-5.f, 3.f), Color::black());\n    gl::drawString(toString(mSlider1->getValue()), mSlider1->getPosition()+Vec2f(mSlider1->getWidth()+5.f, 3.f), Color::black());\n\n    mSlider2->draw();\n    gl::drawStringRight(\"Value 2:\", mSlider2->getPosition()+Vec2f(-5.f, 3.f), Color::black());\n    gl::drawString(toString(mSlider2->getValue()), mSlider2->getPosition()+Vec2f(mSlider2->getWidth()+5.f, 3.f), Color::black());\n\n    mSlider3->draw();\n    gl::drawStringRight(\"Value 3:\", mSlider3->getPosition()+Vec2f(-5.f, 3.f), Color::black());\n    gl::drawString(toString(mSlider3->getValue()), mSlider3->getPosition()+Vec2f(mSlider3->getWidth()+5.f, 3.f), Color::black());\n    ```", "```cpp\n    #pragma once\n\n    #include \"InteractiveObject.h\"\n    #include \"cinder/Text.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/app/KeyEvent.h\"\n    #include \"cinder/app/AppBasic.h\"\n    ```", "```cpp\n    class InteractiveTextBox: public InteractiveObject{\n    public:\n        InteractiveTextBox( const ci::Rectf& rect );\n\n        virtual void draw();\n        virtual void pressed();\n        virtual void releasedOutside();\n\n        void keyDown( ci::app::KeyEvent& event );\n        protected:\n            ci::TextBox mTextBox;\n        std::string mText;\n        bool mActive;\n        bool mFirstText;\n    };\n    ```", "```cpp\n    #include \"InteractiveTextBox.h\"\n\n    using namespace std;\n    using namespace ci;\n    using namespace ci::app;\n    ```", "```cpp\n    InteractiveTextBox::InteractiveTextBox( const Rectf& rect ):\n    InteractiveObject( rect )\n    {\n      mActive = false;\n      mText = \"Write some text\";\n      mTextBox.setText( mText );\n      mTextBox.setFont( Font( \"Arial\", 24 ) );\n      mTextBox.setPremultiplied( true );\n      mTextBox.setSize( Vec2i( rect.getWidth(), rect.getHeight() ) );\n      mTextBox.setBackgroundColor( Color::white() );\n      mTextBox.setColor( Color::black() );\n      mFirstText = true;\n    }\n    ```", "```cpp\n    void InteractiveTextBox::draw(){\n     if( mActive ){\n      mTextBox.setBackgroundColor( Color( 0.7f, 0.7f, 1.0f ) );\n     } else {\n      mTextBox.setBackgroundColor( Color::white() );\n     }\n     gl::color( Color::white() );\n     gl::Texture texture = mTextBox.render();\n     gl::draw( texture, rect );\n    }\n    ```", "```cpp\n    void InteractiveTextBox::pressed(){\n      mActive = true;\n    }\n\n    void InteractiveTextBox::releasedOutside(){\n      mActive = false;\n    }\n    ```", "```cpp\n    void InteractiveTextBox::keyDown( KeyEvent& event ){\n     if( mActive == false ) return;\n     if( mFirstText ){\n      mText = \"\";\n      mFirstText = false;\n    ```", "```cpp\n     }\n     if( event.getCode() == KeyEvent::KEY_BACKSPACE ){\n      if( mText.size() > 0 ){\n       mText = mText.substr( 0, mText.size()-1 );\n      }\n     } else {\n      const char character = event.getChar();\n      mText += string( &character, 1 );\n     }\n     mTextBox.setText( mText );\n    }\n    ```", "```cpp\n    #include \"InteractiveTextBox.h\"\n\n    using namespace ci;\n    using namespace ci::app;\n    using namespace std;\n    ```", "```cpp\n    shared_ptr<InteractiveTextBox> mTextBox;\n    ```", "```cpp\n    Rectf rect( 100.0f, 100.0f, 300.0f, 200.0f );\n    mTextBox = shared_ptr<InteractiveTextBox>( new InteractiveTextBox( rect ) );\n    ```", "```cpp\n      gl::enableAlphaBlending();\n      gl::clear( Color( 0, 0, 0 ) );\n      mTextBox->draw();\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\n    void mouseUp( MouseEvent event );\n    void mouseDrag( MouseEvent event );\n    void mouseMove( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      mTextBox->mouseDown( event );\n    }\n\n    void MyApp::mouseUp( MouseEvent event ){\n      mTextBox->mouseUp( event );\n    }\n\n    void MyApp::mouseDrag( MouseEvent event ){\n      mTextBox->mouseDrag( event );\n    }\n\n    void MyApp::mouseMove( MouseEvent event ){\n      mTextBox->mouseMove( event );\n    }\n    ```", "```cpp\n    void keyDown( KeyEvent event );\n    ```", "```cpp\n    void InteractiveObjectApp::keyDown( KeyEvent event ){\n      mTextBox->keyDown( event );\n    }\n    ```", "```cpp\n    #pragma once\n\n    #include \"cinder/app/AppNative.h\"\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/Color.h\"\n\n    #include \"InteractiveObject.h\"\n\n    using namespace std;\n    using namespace ci;\n    using namespace ci::app;\n\n    class TouchInteractiveObject : public InteractiveObject {\n    public:\n    TouchInteractiveObject( const Vec2f& position, \n     const Vec2f& size );\n    bool    touchesBegan(TouchEvent event);\n    bool    touchesMoved(TouchEvent event);\n    bool    touchesEnded(TouchEvent event);\n    Vec2f   getPosition() { return position; }\n    void    setPosition(Vec2f position) { this->position = position; }\n    void    setPosition(float x, float y) { setPosition(Vec2f(x,y)); }\n    float   getWidth() { return getSize().x; }\n    float   getHeight() { return getSize().y; }\n    Vec2f   getSize() { return rect.getSize(); }\n    void    setSize(Vec2f size) { \n     size.x = max(30.f,size.x); \n     size.y = max(30.f,size.y); \n     rect = Rectf(getPosition()-size*0.5f,getPosition()+size*0.5f);\n    }\n    void    setSize(float width, float height) {\n     setSize(Vec2f(width,height)); \n    }\n    float   getRotation() { return rotation; }\n    void    setRotation( float rotation ) { \n     this->rotation = rotation;\n    }\n    virtual void draw();\n\n    protected:\n    Vec2f   position;\n    float   rotation;\n    bool    scaling;\n\n    unsigned int    dragTouchId;\n    unsigned int    scaleTouchId;\n    };\n    ```", "```cpp\n    #include \"TouchInteractiveObject.h\"\n    ```", "```cpp\n    TouchInteractiveObject::TouchInteractiveObject( \n     const Vec2f& position, const Vec2f& size )\n      : InteractiveObject( Rectf() )\n    {\n     scaling = false;\n     rotation = 0.f;\n     setPosition(position);\n     setSize(size);\n     AppNative::get()->registerTouchesBegan(this, \n      &TouchInteractiveObject::touchesBegan);\n     AppNative::get()->registerTouchesMoved(this, \n      &TouchInteractiveObject::touchesMoved);\n     AppNative::get()->registerTouchesEnded(this, \n      &TouchInteractiveObject::touchesEnded);\n    }\n    ```", "```cpp\n    bool TouchInteractiveObject::touchesBegan(TouchEvent event)\n    ```", "```cpp\n    {\n     Vec2f bVec1 = getSize()*0.5f;\n     Vec2f bVec2 = Vec2f(getWidth()*0.5f, -getHeight()*0.5f);\n     bVec1.rotate((rotation) * (M_PI/180.f));\n     bVec2.rotate((rotation) * (M_PI/180.f));\n     Vec2f bVec;\n     bVec.x = math<float>::max( abs(bVec1.x), abs(bVec2.x));\n     bVec.y = math<float>::max( abs(bVec1.y), abs(bVec2.y));\n     Area activeArea = Area(position-bVec, position+bVec);\n     for (vector<TouchEvent::Touch>::const_iterator it \n       = event.getTouches().begin(); \n       it != event.getTouches().end(); ++it) {\n      if(activeArea.contains( it->getPos() )) {\n       if(mPressed) {\n        scaling = true;\n        scaleTouchId = it->getId();\n       } else {\n        mPressed = true;\n        dragTouchId = it->getId();\n       }\n      } \n     }\n     return false;\n    }\n\n    bool TouchInteractiveObject::touchesMoved(TouchEvent event)\n    {\n     if(!mPressed) return false;\n     const TouchEvent::Touch* dragTouch;\n     const TouchEvent::Touch* scaleTouch;\n     for (vector<TouchEvent::Touch>::const_iterator it \n       = event.getTouches().begin(); \n       it != event.getTouches().end(); ++it) {\n      if (scaling && scaleTouchId == it->getId()) {\n       scaleTouch = &(*it);\n      }\n      if(dragTouchId == it->getId()) {\n       dragTouch = &(*it);\n      }\n     }\n     if(scaling) {\n      Vec2f prevPos = (dragTouch->getPrevPos() \n       + scaleTouch->getPrevPos()) * 0.5f;\n      Vec2f curPos = (dragTouch->getPos() \n       + scaleTouch->getPos())*0.5f;\n      setPosition(getPosition() + curPos - prevPos);\n      Vec2f prevVec = dragTouch->getPrevPos() \n       - scaleTouch->getPrevPos();\n      Vec2f curVec = dragTouch->getPos() - scaleTouch->getPos();\n\n      float scaleFactor = (curVec.length() - prevVec.length()) \n       / prevVec.length();\n      float sizeFactor = prevVec.length() / getSize().length();\n      setSize(getSize() + getSize() * sizeFactor * scaleFactor);\n\n      float angleDif = atan2(curVec.x, curVec.y) \n       - atan2(prevVec.x, prevVec.y);\n      rotation += -angleDif * (180.f/M_PI);\n     } else {\n      setPosition(getPosition() + dragTouch->getPos() \n       - dragTouch->getPrevPos() );\n     }\n     return false;\n    }\n\n    bool TouchInteractiveObject::touchesEnded(TouchEvent event)\n    {\n     if(!mPressed) return false;\n     for (vector<TouchEvent::Touch>::const_iterator it \n       = event.getTouches().begin(); \n       it != event.getTouches().end(); ++it) {\n      if(dragTouchId == it->getId()) {\n       mPressed = false;\n       scaling = false;\n      }\n      if(scaleTouchId == it->getId()) {\n       scaling = false;\n      } \n     }\n     return false;\n    }\n    ```", "```cpp\n    void TouchInteractiveObject::draw() {\n     Rectf locRect = Rectf(Vec2f::zero(), getSize());\n     gl::pushMatrices();\n     gl::translate(getPosition());\n     gl::rotate(getRotation());\n     gl::pushMatrices();\n     gl::translate(-getSize()*0.5f);\n     gl::color(Color::gray( mPressed ? 0.6f : 0.9f ));\n     gl::drawSolidRect(locRect);\n     gl::color(Color::black());\n     gl::drawStrokedRect(locRect);\n     gl::popMatrices();\n     gl::popMatrices();\n    }\n    ```", "```cpp\n    class Circle : publicTouchInteractiveObject {\n    public:\n     Circle(const Vec2f& position, const Vec2f& size)\n       : TouchInteractiv eObject(position, size) {}\n\n     virtual void draw() {\n      gl::color(Color::gray( mPressed ? 0.6f : 0.9f ));\n      gl::drawSolidEllipse(getPosition(), \n       getSize().x*0.5f, getSize().y*0.5f);\n      gl::color(Color::black());\n      gl::drawStrokedEllipse(getPosition(), \n       getSize().x*0.5f, getSize().y*0.5f);\n     } \n    };\n    ```", "```cpp\n    #include \"cinder/app/AppNative.h\"\n    #include \"cinder/Camera.h\"\n    #include \"cinder/Rand.h\"\n\n    #include \"TouchInteractiveObject.h\"\n    ```", "```cpp\n    typedef shared_ptr<TouchInteractiveObject> tio_ptr;\n    ```", "```cpp\n    tio_ptr mObj1;\n    tio_ptr mCircle;\n    ```", "```cpp\n    mObj1 = tio_ptr( new TouchInteractiveObject(getRandPos(), Vec2f(100.f,100.f)) );\n    mCircle = tio_ptr( new Circle(getRandPos(), Vec2f(100.f,100.f)) );\n    ```", "```cpp\n    gl::setMatricesWindow(getWindowSize());\n    gl::clear( Color::white() );\n    mObj1->draw();\n    mCircle->draw();\n    ```", "```cpp\n    Vec2f MainApp::getRandPos()\n    {\n      return Vec2f( randFloat(30.f, getWindowWidth()-30.f),  randFloat(30.f, getWindowHeight()-30.f));\n    }\n    ```", "```cpp\n    class ObjectsManager {\n    public:\n        ObjectsManager() { }\n\n        void addObject( tio_ptr obj) {\n            objects.push_front(obj);\n        }\n\n        void update() {\n            bool rel = false;\n            deque<tio_ptr>::const_iterator it;\n            for(it = objects.begin(); it != objects.end(); ++it) {\n                if( rel ) \n                    (*it)->release();\n                else if( (*it)->isActive() )\n                    rel = true;\n            }\n        }\n\n    protected:\n        deque<tio_ptr> objects;\n    };\n    ```", "```cpp\n    shared_ptr<ObjectsManager> mObjMgr;\n    ```", "```cpp\n    mObjMgr = shared_ptr<ObjectsManager>( new ObjectsManager() );\n    mObjMgr->addObject( mObj1 );\n    mObjMgr->addObject( mCircle );\n    ```", "```cpp\n    void MainApp::update()\n    {\n        mObjMgr->update();\n    }\n    ```", "```cpp\n    bool    isActive() { return mPressed; }\n    void    release() { mPressed = false; }\n    ```"]