- en: Chapter 6. Rendering and Texturing Particle Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Texturing particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a tail to our particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a cloth simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texturing a cloth simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texturing the particle system using point sprites and shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*, we will learn how to render and apply textures to
    our particles in order to make them more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Texturing particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will render particles introduced in the previous chapter using
    texture loaded from the PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe code base is an example of the recipe *Simulating particles flying
    on the wind* from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*. We also need a texture for a single particle. You
    can prepare one easily with probably any graphical program. For this example,
    we are going to use a PNG file with transparency stored inside the `assets` folder
    with a name, `particle.png`. In this case it is just a radial gradient with transparency.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/8703OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will render particles using the previously created texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a member to the application main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `setup` method load `particleTexture`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have to change the particle size for this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `draw` method we will draw our particles as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `draw` method inside the `Particle.cpp` source file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 5, we saw two important lines. One enables alpha blending and the other
    binds our texture stored in the `particleTexture` property. If you look at step
    6, you can see we drew each particle as a rectangle and each rectangle had texture
    applied. It is a simple way of texturing particles and not very performance effective,
    but in this case, it works quite well. It is possible to change the color of drawing
    particles by changing the color just before invoking the `draw` method on `ParticleSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look into the recipe *Texturing the particle system using Point sprites and
    shaders*
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tail to our particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to add a tail to the particle animation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to use the code base from the recipe *Applying repulsion
    and attraction forces* from [Chapter 5](ch05.html "Chapter 5. Building Particle
    Systems"), *Building Particle Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add a tail to the particles using different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simply replace the `draw` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tail as a line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will add a tail constructed from several lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add new properties to the `Particle` class inside the `Particle.h` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `Particle` constructor, inside the `Particle.cpp` source
    file, set the default value to the `tailLength` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `update` method of the `Particle` class add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace your `Particle::draw` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will explain how each technique works.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind this method is very simple, instead of clearing the drawing
    area, we are continuously drawing semi-transparent rectangles that cover old drawing
    states more and more. This very simple method can give you interesting effects
    with particles. You can also manipulate the opacity of each rectangle by changing
    the alpha channel of the rectangle color, which becomes a color of the background.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing history](img/8703OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tail as a line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw a tail with lines, we have to store several particle positions and draw
    a line through these locations with variable opacity. The rule for opacity is
    just to draw older locations with less opacity. You can see the drawing code and
    alpha channel calculation in step 4
  prefs: []
  type: TYPE_NORMAL
- en: '![Tail as a line](img/8703OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a cloth simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to simulate cloth by creating a grid of particles
    connected by springs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be using the particle system described in the recipe
    *Creating a particle system in 2D* from [Chapter 5](ch05.html "Chapter 5. Building
    Particle Systems"), *Building Particle Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be using the `Springs` class created in the recipe *Creating springs*
    from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"), *Building
    Particle Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you will need to add the following files to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Particle.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spring.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spring.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a grid of particles connected with springs to create a cloth
    simulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the particle system file in your project by adding the following code
    on top of your source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `using` statements before the application class declaration as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an instance of a `ParticleSystem` object and member variables to store
    the top corners of the grid. We will also create variables to store the number
    of rows and lines that make up our grid. Add the following code in your application
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we start creating our particle grid, let's update and draw our particle
    system in our application's `update` and `draw` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setup` method, let''s initialize the grid corner positions and number
    of rows and lines. Add the following code at the top of the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calculate the distance between each particle on the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a grid of evenly spaced particles and add them to `ParticleSystem`.
    We''ll do this by creating a nested loop where each loop index will be used to
    calculate the particle''s position. Add the following code in the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the particles are created, we need to connect them with springs. Let''s
    start by connecting each particle to the one directly below it. In a nested loop,
    we will calculate the index of the particle in `ParticleSystem` and the one below
    it. We then create a `Spring` class connecting both particles using their current
    distance as `rest` and a `strength` value of `1.0`. Add the following to the bottom
    of the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have a static grid made out of particles and springs. Let''s add some
    gravity by applying a constant vertical force to each particle. Add the following
    code at the bottom of the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To prevent the grid from falling down, we need to make the particles at the
    top edges static in their initial positions, defined by `mLeftCorner` and `mRightCorner`.
    Add the following code to the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application; you'll see a grid of particles falling down with
    gravity, locked by its top corners.![How to do it…](img/8703OS_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's add some interactivity by allowing the user to drag particles with the
    mouse. Declare a `Particle` pointer to store the particle being dragged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method initialize the particle to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the `mouseUp` and `mouseDown` methods in the application's class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the implementation of the `mouseDown` event, we iterate the overall particles
    and, if a particle is under the cursor, we set `mDragParticle` to point to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `mouseUp` event we simply set `mDragParticle` to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to check if `mDragParticle` is a valid pointer and set the particle''s
    position to the mouse cursor. Add the following code to the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application. Press and drag the mouse over any particle and
    drag it around to see how the cloth simulation reacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cloth simulation is achieved by creating a two dimensional grid of particles
    and connecting them with springs. Each particle will be connected with a spring
    to the ones next to it and to the ones above and below it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The density of the grid can be changed to accommodate the user's needs. Using
    a grid with more particles will generate a more precise simulation but will be
    slower.
  prefs: []
  type: TYPE_NORMAL
- en: Change `mNumLines` and `mNumRows` to change the number of particles that make
    up the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Texturing a cloth simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to apply a texture to the cloth simulation
    we created in the *Creating a cloth simulation* recipe of the current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the cloth simulation developed in the recipe *Creating a cloth
    Simulation* as the base for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need an image to use as texture; place it inside your `assets`
    folder. In this recipe we will name our image `texture.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will calculate the correspondent texture coordinate to each particle in the
    cloth simulation and apply a texture.
  prefs: []
  type: TYPE_NORMAL
- en: Include the necessary files to work with the texture and read images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare a `ci::gl::Texture` object in your application's class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method load the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will remake the `draw` method. So we''ll erase everything in it which was
    changed in the *Creating a cloth simulation* recipe and apply the `clear` method.
    Your `draw` method should be like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `clear` method call, enable the `VERTEX` and `TEXTURE COORD` arrays
    and bind the texture. Add the following to the `draw` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now iterate over all particles and springs that make up the cloth simulation
    grid and draw a textured triangle strip between each row and the row next to it.
    Start by creating a `for` loop with `mNumRows-1` iterations and create two `std::vector<Vec2f>`
    containers to store vertex and texture coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the loop we will create a nested loop that will iterate over all lines
    in the cloth grid. In this loop we will calculate the index of the particles whose
    vertices will be drawn, calculate their correspondent texture coordinates, and
    add them with the positions of `textureCoords` and `vertexCoords`. Type the following
    code into the loop that we created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the `vertex` and `texture` coordinates are calculated and placed inside
    `vertexCoords` and `textureCoords` we will draw them. Here is the complete nested
    loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally we need to unbind `mTexture` by adding the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We calculated the correspondent texture coordinate according to the particle's
    position on the grid. We then drew our texture as triangular strips formed by
    the particles on a row with the particles on the row next to it.
  prefs: []
  type: TYPE_NORMAL
- en: Texturing a particle system using point sprites and shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to apply a texture to all our particles using
    OpenGL point sprites and a GLSL Shader.
  prefs: []
  type: TYPE_NORMAL
- en: This method is optimized and allows for a large number of particles to be drawn
    at fast frame rates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using the particle system developed in the recipe *Creating a particle
    system in 2D* from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*. So we will need to add the following files to your
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Particle.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also be loading an image to use as texture. The image's size must be
    a power of two, such as 256 x 256 or 512 x 512\. Place the image inside the `assets`
    folder and name it `particle.png`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a GLSL shader and then enable OpenGL point sprites to draw textured
    particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating the GLSL Shader. Create the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shader.frag`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shader.vert`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add them to the `assets` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the file `shader.frag` in your IDE of choice and declare a `uniform sampler2D`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` function we use the texture to define the fragment color. Add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `shader.vert` file and create `float attribute` to store the particle''s
    radiuses. In the `main` method we define the position, color, and point size attributes.
    Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our shader is done! Let''s go to our application source file and include the
    necessary files. Add the following code to your application source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the member variables to create a particle system and arrays to store
    the particle's positions and radiuses. Also declare a variable to store the number
    of particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method, let's initialize `mNumParticles` to `1000` and allocate
    the arrays. We will also create the random particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `update` method, we will update `mParticleSystem` and the `mPositions`
    and `mRadiuses` arrays. Add the following code to the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the shaders and the particle's texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the shaders and texture by adding the following code in the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method, we will start by clearing the background with black, set
    the window's matrices, enable the additive blend, and bind the shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get the location for the `particleRadius` attribute in the `Vertex` shader.
    Enable vertex attribute arrays and set the pointer to `mRadiuses`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable point sprites and enable our shader to write to point sizes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable vertex arrays and set the vertex pointer to `mPositions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now enable and bind the texture, draw the vertex array as points, and unbind
    the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All we need to do now is disable the vertex arrays, disable the vertex attribute
    arrays, and unbind the shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application and you will see `1000` random particles with
    the applied texture.![How to do it...](img/8703OS_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Point sprites is a nice feature of OpenGL that allows for the application of
    an entire texture to a single point. It is extremely useful when drawing particle
    systems and is quite optimized, since it reduces the amount of information sent
    to the graphics card and performs most of the calculations on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe we also created a GLSL shader, a high-level programming language,
    that allows more control over the programming pipeline, to define individual point
    sizes for each particle.
  prefs: []
  type: TYPE_NORMAL
- en: In the `update` method we updated the `Positions` and `Radiuses` arrays, so
    that if the particles are animated the arrays will represent the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Point sprites allow us to texturize points in 3D space. To draw the particle
    system in 3D do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Particle` class described in the *There's more…* section of the recipe
    *Creating a Particle system in 2D* from [Chapter 5](ch05.html "Chapter 5. Building
    Particle Systems"), *Building Particle Systems*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare and initialize `mPositions` as a `ci::Vec3f` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `draw` method, indicate that the vertex pointer contains 3D information
    by applying the following change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the previous code line to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The vertex shader needs to adjust the point size according to the depth of
    the particle. The `shader.vert` file would need to read the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Connecting the dots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will show how to connect particles with lines and introduce
    another way of drawing particles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe's code base is an example from the recipe *Simulating particles
    flying on the wind* (from [Chapter 5](ch05.html "Chapter 5. Building Particle
    Systems"), *Building Particle Systems*), so please refer to this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will connect particles rendered as circles with lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the number of particles to create inside the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will calculate `radius` and `mass` of each particle as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `draw` method inside the `Particle.cpp` source file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `draw` method inside the `ParticleSystem.cpp` source file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most interesting part of this example is mentioned in step 4\. We are iterating
    through all the points, actually through all possible pairs of the points, to
    connect it with a line and apply the right opacity. The opacity of the line connecting
    two particles is calculated from the distance between these two particles; the
    longer distance makes the connection line more transparent.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a look at how the particles are been drawn in step 3\. They are solid circles
    with a slightly bigger outer circle. The nice detail is the connection line that
    we are drawing between particles that stick to the edge of the outer circle, but
    don't cross it. We have done it in step 4, where we calculated the normalized
    vector of the vectors connecting two particles, then used them to move the attachment
    point towards that vector, multiplied by the outer circle radius.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting particles with spline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we are going to learn how to connect particles with splines in
    3D.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to use the particle's code base from the recipe
    *Creating a particle system*, from [Chapter 5](ch05.html "Chapter 5. Building
    Particle Systems"), *Building Particle Systems*. We are going to use the 3D version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create splines connecting particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary header file inside `ParticleSystem.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new property to the `ParticleSystem` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `computeBSpline` method for the `ParticleSystem` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `ParticleSystem` update method, invoke the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `draw` method of `ParticleSystem` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add headers to your main Cinder application class files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add members for your `main` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `setup` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add members for camera navigation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `update` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `draw` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**B-spline** lets us draw a very smooth curved line through some given points,
    in our case, particle positions. We can still apply some attraction and repulsion
    forces so that the line behaves quite like a spring. In Cinder, you can use B-splines
    in 2D and 3D space and calculate them with the `BSpline` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More details about B-spline are available at [http://en.wikipedia.org/wiki/B-spline](http://en.wikipedia.org/wiki/B-spline).
  prefs: []
  type: TYPE_NORMAL
