- en: Chapter 5. Animation and AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。动画和AI
- en: This chapter is about animation and **artificial intelligence** (**AI**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于动画和**人工智能**（**AI**）的。
- en: Animation is what we need in order to see things move in a game. AI is what
    is required for characters (other than the player) to know how to behave and react
    while you are in the game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是我们为了让游戏中的事物移动所需要的东西。人工智能（AI）是角色（除了玩家）在游戏中知道如何行为和反应所必需的。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition of animation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画的定义
- en: 3D animation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D动画
- en: Tools required for animation in Unreal Engine 4
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unreal Engine 4中进行动画所需的工具
- en: Learning to add animation to your game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将动画添加到你的游戏中
- en: Using an Animation Blueprint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画蓝图
- en: Learning about Blend Animation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解混合动画
- en: AI in games
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的AI
- en: Designing a **Behavior Tree** (**BT**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个**行为树**（**BT**）
- en: Using a Blueprint to implement AI in your game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝图在你的游戏中实现AI
- en: What is animation?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是动画？
- en: Animation is the simulation of movement through a series of images or frames.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是通过一系列图像或帧来模拟运动。
- en: Before computers came into the picture, animation was created using traditional
    techniques such as hand-drawn animation and stop-motion animation (or model animation).
    Hand-drawn animation, as the name suggests, involves hand-drawn scenes on paper.
    Each scene is repeated on the next sheet of paper with a slight change in the
    scene. All the papers are put together in sequence and the pages are turned very
    quickly, like a flipbook. The slight changes on the sheets of paper create 2D
    animation, and this can be filmed into a motion film. This technique is used very
    often in Disney cartoons and movies. As you can imagine, this is a very time-consuming
    way to produce animation, as you would need thousands of drawings to create seconds
    of the film.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机出现之前，动画是通过传统的技术创造的，如手绘动画和定格动画（或模型动画）。正如其名所示，手绘动画涉及在纸上绘制场景。每个场景都在下一张纸上重复，场景略有变化。所有纸张按顺序排列，页面快速翻动，就像翻页书一样。纸张上的细微变化创造了2D动画，这可以被拍摄成运动电影。这种技术在迪士尼卡通和电影中经常使用。正如你可以想象的，这是一种非常耗时的方式来制作动画，因为你需要成千上万的绘画来创造几秒钟的电影。
- en: Stop-motion animation involves creating models, moving them a little in each
    frame to mimic movement, and filming this sequence to construct an entire scene.
    The tedious process of capturing countless snippets has limited the use of this
    method in favor of more mainstream animation techniques today.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 定格动画涉及创建模型，在每一帧中稍微移动它们以模拟运动，并拍摄这个序列来构建整个场景。捕捉无数片段的繁琐过程限制了这种方法的使用，如今更主流的动画技术得到了青睐。
- en: Computer animation is quite similar to stop-motion animation as computer graphics
    is moved a little in each frame; these frames are then rendered on screen. For
    computer games, we use computer animation by creating 3D models using tools, such
    as Maya and 3ds Max. Then, we animate these models to simulate life-like behavior
    and actions for the game. Animation is needed for all things in order to make
    them move. Characters need to be animated so that they can look real—they can
    be in an idle position, walk, run, or execute any other action that needs to be
    performed in the course of the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机动画与定格动画非常相似，因为计算机图形在每一帧中都会稍微移动；然后这些帧被渲染到屏幕上。对于计算机游戏，我们通过使用Maya和3ds Max等工具创建3D模型来进行计算机动画。然后，我们为这些模型添加动画以模拟游戏中的逼真行为和动作。为了使物体移动，动画是必需的。角色需要被动画化，这样它们看起来才真实——它们可以处于空闲状态、行走、奔跑或执行游戏中需要执行的其他任何动作。
- en: Motion capture is also another very popular way to animate characters these
    days. This technology basically uses recorded human actions to create the computer
    graphic character's behavior. If you have watched the movie *Avatar*, the blue
    avatar characters were, in fact, played by human actors and then enhanced to look
    the way they did using computer graphics. For the filming of the movie, they advanced
    the motion capture technology into what is now called **performance capture**.
    This advancement in technology has empowered film and game makers to capture the
    details in animation in such a way that can make a CG character stand out.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 动作捕捉也是目前非常流行的一种角色动画方式。这项技术基本上是利用记录的人类动作来创建计算机图形角色的行为。如果你看过电影《阿凡达》，那些蓝色的阿凡达角色实际上是由人类演员扮演的，然后通过计算机图形技术进行了增强，以呈现出那样的外观。为了拍摄这部电影，他们把动作捕捉技术推进到了现在所说的**表演捕捉**。这项技术的进步赋予了电影和游戏制作者捕捉动画细节的能力，使得CG角色能够脱颖而出。
- en: Understanding how to animate a 3D model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何动画化3D模型
- en: Although the objective of this book is not to teach you how to animate a model,
    it is important to understand how animation is done so that you can understand
    better how to get game characters in a game to move and behave according to design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书的目标不是教你如何动画化模型，但了解动画是如何制作的对于你更好地理解如何在游戏中让游戏角色根据设计移动和表现是非常重要的。
- en: As mentioned earlier, we can animate 3D models using tools, such as Maya or
    3ds Max. We can then record their changes and then render these animations on
    screen when needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用工具如Maya或3ds Max来动画化3D模型。然后我们可以记录它们的变化，并在需要时在屏幕上渲染这些动画。
- en: Preparing before animation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画前的准备工作
- en: In game development, the creation of animation falls under the responsibility
    of an animator. Before an animation can be first created, we need to first have
    a 3D model that's been created by a 3D modeler. The 3D modeler is responsible
    for giving the object its shape and texturing it. Depending on the type of object
    we're dealing with, the exact process to get an object properly rigged can be
    slightly different. Rigging needs to be done before handing over the object to
    the animator to create specific animations. Sometimes, animators also need to
    fine-tune the rigs for better control of the animation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，动画的制作责任属于动画师。在动画首先被创建之前，我们需要首先有一个由3D模型师创建的3D模型。3D模型师负责赋予物体形状并进行纹理处理。根据我们处理的对象类型，获取物体正确绑定的具体过程可能会有所不同。绑定需要在将物体交给动画师创建特定动画之前完成。有时，动画师还需要对绑定进行微调，以便更好地控制动画。
- en: Rigging is a process where a skeleton is placed in the mesh and joints that
    are created for the skeleton. The collection of bones/joints is known as the **rig**.
    The rig provides control points, which the animator can use to move the object
    in order to create the desired animation. I will use a human character model in
    my explanation here so that you can understand this concept easily.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 布料绑定是一个将骨骼放置在网格中并为骨骼创建关节的过程。这些骨骼/关节的集合被称为**绑定**。绑定提供了控制点，动画师可以使用这些控制点来移动对象，从而创建所需的动画。在这里，我将使用一个人类角色模型来解释，以便你能够轻松理解这个概念。
- en: The 3D or character modeler first shows how the face and body of a model are
    shaped. It then determines how tall the model is, creates all the required features
    by adding primitives to the model, and then textures it to give color to its eyes,
    hair, and so on. The model is now ready but still jelly on the inside because
    we have not given it any internal structure. Rigging is the process where we add
    bones to the body to hold it up. The arm can be rotated because we have given
    it a shoulder bone (scapula), arm bone (humerus), and a joint that can mimic the
    ball and socket joint. The joint we have in place for rigging is made up of a
    group of constraints that limit movement in various planes and angles. Hierarchies
    are also applied to the bone structure to help the bones link each other. The
    fingers are linked to the hand, which is linked to the arm. Such a relationship
    can be put in place so that movement looks real when one of parts moves and the
    rest of the parts naturally move together as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 3D或角色建模师首先展示模型的头部和身体是如何塑造的。然后确定模型的高度，通过向模型添加原语来创建所有必需的特征，并对其进行纹理处理，为其眼睛、头发等上色。现在模型已经准备好了，但内部仍然像果冻一样柔软，因为我们还没有给它任何内部结构。绑定是将骨骼添加到身体中的过程，以支撑它。手臂可以旋转，因为我们已经给它一个肩胛骨（肩胛骨）、上臂骨（肱骨）和一个可以模仿球窝关节的关节。我们用于绑定的关节由一组限制组成，这些限制限制了在不同平面和角度上的运动。还将层次结构应用于骨骼结构，以帮助骨骼相互连接。手指连接到手，手连接到手臂。可以建立这样的关系，以便当一个部分移动时，其余部分也会自然地一起移动，从而使动作看起来更真实。
- en: Tools, such as Maya and 3ds Max, provide some simplification to the rigging
    process, as you can use standard rigs as the base, and tweak this base according
    to the needs of the model. Some models are taller and require longer bones. A
    3D model must have a simple skeletal structure that adheres closely to the shape
    and size of a 3D model. Similar sized 3D models can share the same skeletal structure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Maya和3ds Max等工具为绑定过程提供了一些简化，因为您可以使用标准绑定作为基础，并根据模型的需求调整这个基础。一些模型更高，需要更长的骨骼。一个3D模型必须有一个简单的骨骼结构，紧密遵循3D模型的形状和大小。相似大小的3D模型可以共享相同的骨骼结构。
- en: To better understand how we can add animation to our game levels, let's learn
    how computer animation is created and how we can make these models move.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们如何将动画添加到游戏关卡中，让我们学习计算机动画是如何创建的，以及我们如何使这些模型移动。
- en: How is animation created?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画是如何创建的？
- en: Animation basically mimics how life moves in the real world. Many companies
    go to great lengths to make computer animation as accurate as possible through
    the use of motion capture. They film actual movements in real life and then recreate
    these movements using computer 3D models.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 动画基本上模仿了现实世界中生命活动的样子。许多公司为了使计算机动画尽可能准确，会不遗余力地使用动作捕捉技术。他们拍摄现实生活中的实际动作，然后使用计算机3D模型来重现这些动作。
- en: When creating animations, the animator makes use of the bones and joints created
    during the rigging process and adjusts them in place using as much detail as possible
    to mimic their natural movement. The joints and bones work together to affect
    the body posture. These movements are then recorded as short animation clips known
    as an animation sequence. Animation sequences form the most basic blocks of animation,
    and they can be played once or repeatedly to create an action. For example, a
    walking animation is only 1.8 seconds long but can be replayed over and over to
    simulate walking. When this sequence is repeated again, it is commonly known as
    an animation loop.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建动画时，动画师利用绑定过程中创建的骨骼和关节，并尽可能详细地调整它们的位置，以模仿它们的自然运动。骨骼和关节共同作用，影响身体姿势。这些动作随后被记录为简短的动画剪辑，称为动画序列。动画序列构成了动画的最基本块，可以播放一次或多次以创建动作。例如，一个行走动画只有1.8秒长，但可以反复播放来模拟行走。当这个序列再次重复时，通常被称为动画循环。
- en: Animation sequences can also be linked to form a chain of actions. While transitioning
    from one sequence to another, some blending might be needed in order for the movement
    to look natural.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 动画序列也可以相互链接，形成一个动作链。在从一个序列过渡到另一个序列时，可能需要一些混合，以便使动作看起来更自然。
- en: What Unreal Engine 4 offers for animation in games
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal Engine 4 为游戏动画提供的功能
- en: 'Animation in Unreal Engine 4 is mostly done in the Persona editor. This editor
    offers four different modes: **Skeleton**, **Mesh**, **Animation**, and **Graph**.
    These modes mainly exist so that you can jump straight into one of them to edit/create
    the animations more effectively. So, they are simply a loose group of functions
    that can be used to control the different aspects of animation. We will learn
    how to make use of the functions in Persona to add animation to our level.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine 4中，动画主要是在Persona编辑器中完成的。这个编辑器提供了四种不同的模式：**骨骼**、**网格**、**动画**和**图表**。这些模式主要存在是为了让您可以直接跳入其中之一，以更有效地编辑/创建动画。因此，它们只是一组松散的功能，可以用来控制动画的不同方面。我们将学习如何使用Persona中的功能为我们的关卡添加动画。
- en: To help improve team collaboration, Unreal Engine 4 also released a previously
    in-house-only toolset, which is a plugin for Maya (compatible for Maya 2013 and
    higher versions), known as **Animation and Rigging Toolset** (**ART**). This toolset
    provides a user interface to allow the creation of a skeleton, placement of the
    skeleton, and rig creation within Maya itself. We will not go into the details
    of this toolset, but you can find more information on this in Unreal's online
    documentation at [https://docs.unrealengine.com/latest/INT/Engine/Content/Tools/MayaRiggingTool/index.html](https://docs.unrealengine.com/latest/INT/Engine/Content/Tools/MayaRiggingTool/index.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助提高团队协作，Unreal Engine 4还发布了一个之前仅限内部使用的工具集，这是一个Maya（兼容Maya 2013及以上版本）的插件，称为**动画和绑定工具集**（**ART**）。此工具集提供了一个用户界面，允许在Maya本身内创建骨骼、放置骨骼和创建绑定。我们不会深入探讨这个工具集的细节，但您可以在Unreal的在线文档中找到更多关于此的信息，网址为[https://docs.unrealengine.com/latest/INT/Engine/Content/Tools/MayaRiggingTool/index.html](https://docs.unrealengine.com/latest/INT/Engine/Content/Tools/MayaRiggingTool/index.html)。
- en: Importing animation from Maya/3ds Max
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Maya/3ds Max导入动画
- en: As many artists use Maya and 3ds Max to create 3D models and animation, Unreal
    Engine 4 has a great FBX Import pipeline that allows you to successfully import
    skeletal models, animation sequences, and morph targets. This makes it easy to
    transfer assets to the Unreal Editor and put them into the game. Unreal also tries
    to stabilize the import of art assets from other software, such as Blender and
    MODO.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多艺术家使用Maya和3ds Max来创建3D模型和动画，Unreal Engine 4拥有一个出色的FBX导入管道，允许您成功导入骨骼模型、动画序列和变形目标。这使得将资产传输到Unreal编辑器并将其放入游戏变得容易。Unreal还试图稳定从其他软件（如Blender和MODO）导入艺术资产。
- en: Tutorial – importing the animation pack from Marketplace
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教程 – 从Marketplace导入动画包
- en: Since 3D models and animation are first created outside Unreal Engine, for the
    purpose of learning about how animation works, we will import an animation pack
    that contains a 3D model with a number of animation sequences first, and we'll
    then learn how to make use of the different tools in the Unreal Editor for animation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于3D模型和动画最初是在Unreal Engine之外创建的，为了了解动画的工作原理，我们首先导入一个包含3D模型和多个动画序列的动画包，然后我们将学习如何使用Unreal编辑器中的不同工具进行动画制作。
- en: Unreal Engine offers a number of downloadable packs in Marketplace. Marketplace
    is in the start menu screen, which is under the **Launch** button. The following
    screenshot shows the startup screen that has the **Marketplace** tab selected
    for the downloadable packs. Search for **Animation Starter Pack** in Marketplace
    under **Characters and Animations**. This particular pack is free to download.
    Click on **Animation Started Pack** to download it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine在Marketplace提供了许多可下载的包。Marketplace位于启动菜单屏幕下，位于**启动**按钮下方。以下截图显示了具有**Marketplace**标签选中的启动屏幕，该标签用于可下载的包。在**角色和动画**下Marketplace中搜索**动画入门包**。这个特定的包可以免费下载。点击**动画入门包**进行下载。
- en: '![Tutorial – importing the animation pack from Marketplace](img/B03679_05_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 从Marketplace导入动画包](img/B03679_05_01.jpg)'
- en: 'After the pack is downloaded, you will find the pack added to the **Library**.
    The following screenshot shows where **Animator Starter Pack** is found in **Library**
    under **Vault**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在包下载后，您会发现包已添加到**库**中。以下截图显示了**Animator Starter Pack**在**库**下的**保险库**中的位置：
- en: '![Tutorial – importing the animation pack from Marketplace](img/B03679_05_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 从Marketplace导入动画包](img/B03679_05_02.jpg)'
- en: Now that we have the **Animation Starter Pack** in our **Library**, we can add
    it to our current project and start playing with the animations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将**动画入门包**添加到我们的**库**中，我们可以将其添加到当前项目中并开始尝试动画。
- en: 'Click on **Add To Project** and a pop-up screen with all the current projects
    that are present in Unreal Engine will appear. Select the name of the project
    that you have been creating for all the various levels and all the tutorial examples.
    If you have followed the same project and level naming convention as me, it will
    be `MyProject`. I have also opened `Chapter4Level` from the previous chapter and
    renamed it `Chapter5Level`. The following screenshot shows `AnimStarterPack` loaded
    in the project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加到项目**，将出现一个弹出窗口，显示 Unreal Engine 中所有当前项目的名称。选择你为所有各种级别和教程示例创建的项目名称。如果你遵循与我相同的项目和级别命名约定，它将是`MyProject`。我已将上一章的`Chapter4Level`打开并重命名为`Chapter5Level`。以下屏幕截图显示了在项目中加载的`AnimStarterPack`：
- en: '![Tutorial – importing the animation pack from Marketplace](img/B03679_05_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 从Marketplace导入动画包](img/B03679_05_03.jpg)'
- en: What can you do with Persona?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你可以用Persona做什么？
- en: Persona gives game developers the ability to playback and preview animation
    sequences, combine animation sequences into a single animation by blending, creating
    montages, editing skeletons/sockets, and controlling animation with Blueprints.
    I hope you still remember what you have learned about Blueprints in [Chapter 3](ch03.html
    "Chapter 3. Game Objects – More and Move"), *Game Object – More and Move*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Persona为游戏开发者提供了播放和预览动画序列的能力，通过混合将动画序列合并成单个动画，创建蒙太奇，编辑骨骼/插座，以及使用蓝图控制动画。我希望你仍然记得在[第3章](ch03.html
    "第3章。游戏对象 – 更多和移动")“游戏对象 – 更多和移动”中关于蓝图所学的内容。
- en: Tutorial – assigning existing animation to a Pawn
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教程 – 将现有动画分配给Pawn
- en: After adding the free animation pack into your project in the previous exercise,
    it is time to add some animation to the level. First of all, open `Chapter4Level`,
    rename it `Chapter5Level`, and then navigate to the `AnimStarterPack` folder using
    **Content Browser**. Go to the `Character` subfolder and click and drag **HeroTPP**
    into the level.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中将免费动画包添加到你的项目中后，现在是时候向级别添加一些动画了。首先，打开`Chapter4Level`，将其重命名为`Chapter5Level`，然后使用**内容浏览器**导航到`AnimStarterPack`文件夹。转到`Character`子文件夹，点击并拖动**HeroTPP**到级别中。
- en: 'This screenshot shows how **HeroTPP** is added to the level:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕截图显示了如何将**HeroTPP**添加到级别中：
- en: '![Tutorial – assigning existing animation to a Pawn](img/B03679_05_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 将现有动画分配给Pawn](img/B03679_05_04.jpg)'
- en: The **HeroTPP** looks fake and frozen, right? Now, let's give him a better pose.
    Click on **HeroTPP** to display the details. Go to the **Animation** tab under
    **Details** and input the **Animation Mode** settings. Use **Animation Asset**,
    navigate and click on **Jog_Fwd_Rifle** in `AnimStarterPack` (in **Content Browser**),
    and then click on the arrow next to **Anim to Play**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeroTPP**看起来很假，对吧？现在，让我们给他一个更好的姿势。点击**HeroTPP**以显示详细信息。在**详细信息**下的**动画**选项卡中输入**动画模式**设置。使用**动画资产**，在**内容浏览器**中导航并点击**Jog_Fwd_Rifle**（在`AnimStarterPack`中），然后点击**Anim
    to Play**旁边的箭头。'
- en: '![Tutorial – assigning existing animation to a Pawn](img/B03679_05_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 将现有动画分配给Pawn](img/B03679_05_05.jpg)'
- en: 'Here is a zoomed-in view of the **Animation** settings:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是**动画**设置的放大视图：
- en: '![Tutorial – assigning existing animation to a Pawn](img/B03679_05_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 将现有动画分配给Pawn](img/B03679_05_06.jpg)'
- en: Now, build and play the level. You will see the character that you have just
    added to the level, is jogging.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建并播放级别。你会看到你刚刚添加到级别中的角色正在慢跑。
- en: This is the straightforward way to animate a character. However, the character
    continues to loop through this animation no matter what is happening around. We
    probably want the character to be able to react to the environment and conditions
    of the game. So, how can we do this?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是动画角色的直接方法。然而，无论周围发生什么，角色都会继续循环这个动画。我们可能希望角色能够对环境和游戏条件做出反应。那么，我们该如何做到这一点？
- en: Why do we need to blend animations?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要混合动画？
- en: In the previous exercise, we learned how to make a skeletal mesh take on a single
    animation. But can we make the skeletal mesh start running in a straight line?
    The next few sections of animation exercises will explain how we can do this and,
    subsequently, add more to this basic animation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们学习了如何使骨骼网格采用单个动画。但我们可以让骨骼网格开始沿直线奔跑吗？接下来的几个动画练习部分将解释我们如何做到这一点，并随后添加更多基本动画。
- en: First of all, you need to remember that animation sequences/poses are played
    when you tell them to. While animating character, you need to look into the details
    so that the character looks normal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要记住，当告诉它们播放时，动画序列/姿势才会播放。在为角色动画时，你需要关注细节，以便角色看起来正常。
- en: 'Now, let''s quickly recap what we did in the previous exercise: the skeletal
    mesh character was a zombie with no animation attached. When we linked the run
    animation and set it to play, the character immediately seemed like it was running.
    So, if we want the character to stop running, we can remove the run animation.
    The character goes back to looking like a zombie that hasn''t been animated. If
    we did this in a game, you would probably think that there is something very wrong
    with the animation. Zombie->Running->Zombie. Nothing realistic about it.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速回顾一下在之前的练习中我们做了什么：骨骼网格角色是一个没有附加动画的僵尸。当我们链接跑步动画并设置它播放时，角色立即看起来像是在跑步。所以，如果我们想让角色停止跑步，我们可以移除跑步动画。角色会回到看起来像是没有动画的僵尸。如果我们在一个游戏中这样做，你可能会认为动画有什么非常不正常的地方。僵尸->跑步->僵尸。这没有任何现实感。
- en: How can we improve this? We start with an idle pose for the character; an idle
    pose is one where the character stands at a fixed spot and breathes. Breathing
    is part of animation too. It makes the character look like it's alive. Next, we
    set it to play the run animation. To stop this animation, we allow the character
    to take the idle position again. Not a bad attempt for this iteration. The character
    doesn't look like a zombie now, but it looks and feels real.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进它？我们从为角色设置空闲姿势开始；空闲姿势是角色站在固定位置并呼吸的状态。呼吸也是动画的一部分。它使角色看起来像是有生命的。接下来，我们设置它播放跑步动画。要停止这个动画，我们允许角色再次回到空闲位置。对于这个迭代来说，这不是一个糟糕的尝试。角色现在看起来不再像僵尸，而是看起来和感觉都很真实。
- en: What else can we do to make this even better? Let's use an analogy of someone
    driving a car normally (not a race car driver). When moving from the start position,
    you accelerate from a speed of 0 up to a comfortable cruising speed. When you
    want to stop, you reduce the cruising speed by stepping on the brakes and then
    gradually go back to 0 (to avoid a stopping suddenly and giving your passengers
    the unpleasant experience of being thrown forward). Similarly, we can use this
    to help us design our character's transition from a stationary position. We will
    use a tool called **Blend Animation** to create this transition so that we can
    make the movement of the character a little more realistic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做些什么来让它更好？让我们用一个正常驾驶汽车的人（不是赛车手）的类比。当你从起始位置移动时，你会从0速度加速到舒适的巡航速度。当你想要停车时，你会通过踩刹车来降低巡航速度，然后逐渐回到0（以避免突然停车并给你的乘客带来向前抛的不好体验）。同样，我们可以用这个来帮助我们设计角色的从静止状态过渡。我们将使用一个名为**混合动画**的工具来创建这个过渡，这样我们就可以让角色的动作更加逼真。
- en: Blend Animation, as the name suggests, blends various types of animation using
    variables. It can be a simple one-dimensional relationship where we use speed
    as an axis to blend the animations or a two-dimensional relationship where we
    use both speed and direction to blend animations. Unreal Engine's Blend Animation
    tool is capable of setting up the blending of animations in different ways.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 混合动画，正如其名所示，通过变量混合各种类型的动画。它可以是一个简单的一维关系，其中我们使用速度作为一个轴来混合动画，或者是一个二维关系，其中我们使用速度和方向来混合动画。虚幻引擎的混合动画工具能够以不同的方式设置动画的混合。
- en: Tutorial – creating a Blend Animation
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教程 – 创建混合动画
- en: In this example, we will use speed as the parameter to blend the animation.
    Let's quickly cover the thought process here first before listing the steps to
    follow in the Unreal Editor to achieve this. This would help in your understanding
    of how this process works instead of simply following the process to make something
    happen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用速度作为参数来混合动画。在我们列出在虚幻编辑器中实现此目的的步骤之前，让我们先简要概述一下这里的思考过程。这将有助于你理解这个过程是如何工作的，而不仅仅是简单地遵循过程来让某件事情发生。
- en: 'At speed = 0, we assign the idle pose. As the speed increases, we should switch
    the animation from an idle to a walking animation. As the speed increases even
    more, the animation switches from walking to jogging, and then running. Here''s
    an illustration of how the blend would look:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当速度为0时，我们分配空闲姿势。随着速度的增加，我们应该将动画从空闲状态切换到行走动画。当速度进一步增加时，动画从行走切换到慢跑，然后是跑步。以下是混合动画效果的示意图：
- en: '![Tutorial – creating a Blend Animation](img/B03679_05_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建混合动画](img/B03679_05_07.jpg)'
- en: 'Next, let''s identify which animation sequences we have in the animation pack
    and would be suitable for each of the stages:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确定动画包中哪些动画序列适合每个阶段：
- en: '**Idle_Rifle_Hip**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Idle_Rifle_Hip**'
- en: '**Walk_Fwd_Rifle_Ironsights**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Walk_Fwd_Rifle_Ironsights**'
- en: '**Jog_Fwd_Rifle**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jog_Fwd_Rifle**'
- en: '**Sprint_Fwd_Rifle**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sprint_Fwd_Rifle**'
- en: To create a simple 1D Blend Space, we can right-click on the `Character` folder,
    and go to **Create Asset** | **Animation** | **Blend Space 1D**. Alternatively,
    you can select the `Character` folder in **Content Browser**, click on the **Create**
    button at the top, go to **Animation**, and then **Blend Space 1D**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的1D混合空间，我们可以右键单击`Character`文件夹，并转到**创建资产** | **动画** | **混合空间1D**。或者，您可以在**内容浏览器**中选择`Character`文件夹，点击顶部的**创建**按钮，转到**动画**，然后选择**混合空间1D**。
- en: '![Tutorial – creating a Blend Animation](img/B03679_05_08.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建混合动画](img/B03679_05_08.jpg)'
- en: Select **HeroTPP_Skeleton**; clicking on this creates a new Blend Space 1D.
    Rename **newblendspace1d** to `WalkJogRun`. Double-click on the newly created
    **WalkJogRun** to open the editor. This will propel you straight to the **Animation**
    tab of the editor. Notice that this part is highlighted in the following screenshot.
    In the **SkeletonMesh** field, we have **HeroTPP_Skeleton**, which was what we
    selected when creating the blend space earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**HeroTPP_Skeleton**；点击此选项将创建一个新的1D混合空间。将**newblendspace1d**重命名为`WalkJogRun`。双击新创建的**WalkJogRun**以打开编辑器。这将直接将您带到编辑器的**动画**选项卡。注意以下截图中的这部分被突出显示。在**骨骼网格**字段中，我们有**HeroTPP_Skeleton**，这是我们之前创建混合空间时选择的。
- en: '![Tutorial – creating a Blend Animation](img/B03679_05_09.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建混合动画](img/B03679_05_09.jpg)'
- en: In the **Animation** editor, you have access to **Asset Browser** (which is,
    by default, in the bottom right-hand side of the screen). Clicking on the animation
    assets will allow you to preview how the animation looks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在**动画**编辑器中，您可以使用**资产浏览器**（默认位于屏幕的右下角）。点击动画资产可以预览动画的外观。
- en: Let's first set the **X Axis Label** to `Speed`. **X Axis Range** is from `0`
    to `375`. Leave **X Axis Divisions** as **4**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置**X轴标签**为`速度`。**X轴范围**从`0`到`375`。将**X轴分区**保留为**4**。
- en: 'The number of divisions creates segments in the speed graph that we have. Based
    on what we selected earlier for the Idle, Walk, Jog, and Run states, find the
    animation using **Asset Browser**, click and drop the animation into the **WalkJogRun**
    tab into the appropriate sections, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在速度图中，分区的数量创建了我们所拥有的段。基于我们之前为空闲、步行、慢跑和跑步状态选择的设置，使用**资产浏览器**找到动画，点击并拖动动画到**WalkJogRun**标签页中的适当部分，如图所示：
- en: '**Idle_Rifle_Hip** is at speed = 0\. Set **Walk_Fwd_Rifle_Ironsights** in the
    first division line. When you drag an animation into the graph, it creates a node
    and snaps at one of the division lines. Set **Jog_Fwd_Rifle** in the second division
    line and set **Sprint_Fwd_Rifle** at speed = 375\. To preview how the animation
    blends, move the mouse over the graph along the vertical axis.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Idle_Rifle_Hip**在速度=0时。在第一分区行中设置**Walk_Fwd_Rifle_Ironsights**。当您将动画拖动到图中时，它会在分区线之一处创建一个节点并自动对齐。在第二分区行中设置**Jog_Fwd_Rifle**，并在速度=375时设置**Sprint_Fwd_Rifle**。要预览动画的混合效果，将鼠标沿垂直轴移动到图中。'
- en: '![Tutorial – creating a Blend Animation](img/B03679_05_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建混合动画](img/B03679_05_10.jpg)'
- en: Tutorial – setting up the Animation Blueprint to use a Blend Animation
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教程 – 设置动画蓝图以使用混合动画
- en: Now we have created a Blend Animation that uses speed as a parameter. How do
    we make an NPC change speed and then link this animation to it so that as the
    speed changes and the animation that is played also changes?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个使用速度作为参数的混合动画。我们如何让NPC改变速度，然后将此动画链接到它，以便随着速度的变化，播放的动画也发生变化？
- en: 'For a simple implementation of getting the speed and animation to change, we
    will set up the Animation Blueprint. Go to **Content Browser**. Navigate to **Animation**
    | **Character**; then, navigate and click on **Create Asset** | **Animation**
    | **Animation Blueprint**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的速度和动画变化实现，我们将设置动画蓝图。转到**内容浏览器**。导航到**动画** | **角色**；然后，导航并点击**创建资产** | **动画**
    | **动画蓝图**：
- en: '![Tutorial – setting up the Animation Blueprint to use a Blend Animation](img/B03679_05_11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 设置动画蓝图以使用混合动画](img/B03679_05_11.jpg)'
- en: 'Upon selecting **Animation Blueprint**, the editor will prompt you about the
    base class that you want the Animation Blueprint to be created in. This screenshot
    shows the options that are available for selection:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**动画蓝图**后，编辑器会提示你想要在哪个基类中创建动画蓝图。以下截图显示了可用的选择选项：
- en: '![Tutorial – setting up the Animation Blueprint to use a Blend Animation](img/B03679_05_12.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 设置动画蓝图以使用混合动画](img/B03679_05_12.jpg)'
- en: In this example, we will pick the most basic generic class, `AnimInstance`,
    to build our Animation Blueprint in. Select **HeroTPP_Skeleton** as the target
    skeletal mesh for this blueprint. Name this Animation Blueprint `MyNPC_Blueprint`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将选择最基础的通用类`AnimInstance`来构建我们的动画蓝图。将**HeroTPP_Skeleton**作为此蓝图的目标骨骼网格。将此动画蓝图命名为`MyNPC_Blueprint`。
- en: To check whether you have selected the correct target skeletal mesh, look in
    the **Skeleton** tab in the **Blueprint** window, as shown in the following screenshot.
    You should see **HeroTPP_Skeleton** in the box. The screenshot also shows the
    **Graph** tab that's been selected with the empty default AnimGraph showing. We
    will proceed through this exercise with the **Graph** tab selected, unless specified
    otherwise.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你是否选择了正确的目标骨骼网格，请查看**蓝图**窗口中的**骨骼**标签，如图下截图所示。你应该在框中看到**HeroTPP_Skeleton**。截图还显示了已选择的**图**标签，显示了一个空的默认AnimGraph。我们将使用**图**标签继续这个练习，除非另有说明。
- en: AnimGraph
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AnimGraph
- en: 'This screenshot shows the default blank AnimGraph. **Final Animation Pose**
    will receive the output of the skeletal mesh that''s been specified:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了默认的空白AnimGraph。**最终动画姿态**将接收已指定骨骼网格的输出：
- en: '![AnimGraph](img/B03679_05_13.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_13.jpg)'
- en: 'First, we want to add a state machine by right-clicking within the AnimGraph
    and navigating to **State Machines** | **Add New State Machine…**, as shown in
    the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要通过在AnimGraph内部右键点击并导航到**状态机** | **添加新状态机…**来添加一个状态机，如图下截图所示：
- en: '![AnimGraph](img/B03679_05_14.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_14.jpg)'
- en: 'Rename the newly created state machine **Movement**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名新创建的状态机**Movement**：
- en: '![AnimGraph](img/B03679_05_15.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_15.jpg)'
- en: 'Double-click on **Movement**. Create a new state named **WalkJogRun**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**Movement**。创建一个名为**WalkJogRun**的新状态：
- en: '![AnimGraph](img/B03679_05_16.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_16.jpg)'
- en: Double-click on the newly created **WalkJogRun** state to modify the state in
    a new tab. Go to the **Asset Browser** tab, look for **WalkJogRun** blendspace,
    which we created in the previous exercise, and click and drag it into the editor.
    Link **WalkJogRun** blendspace to the final animation, as shown in the following
    screenshot. Notice that speed = 0.00 is specified in the blendspace node; this
    was the variable that we defined to control the change of the animation when we
    created blendspace in the earlier exercise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 双击新创建的**WalkJogRun**状态，在新标签页中修改状态。转到**资产浏览器**标签页，查找我们在上一个练习中创建的**WalkJogRun**
    blendspace，将其拖动到编辑器中。将**WalkJogRun** blendspace链接到最终动画，如图下截图所示。注意，在blendspace节点中指定了速度=0.00；这是我们之前在早期练习中创建blendspace时定义的变量，用于控制动画变化。
- en: 'Next, we need to create a variable so that we can pass in a value to the **WalkJogRun**
    blendspace speed variable. To do so, we need to click and drag the green dot next
    to the **Speed** on the blendspace node to open up a contextual menu, look for
    **Promote to Variable**, and then click on it. This promotes speed in the blendspace
    node to a float variable, which we would set to control the speed and type of
    animation that will be played. Rename this new variable **Speed**. The following
    screenshot shows how we have created and connected a **Speed** variable to **WalkJogRun**
    blendspace, which is linked to **Final Animation Pose**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个变量，以便我们可以将值传递给**WalkJogRun** blendspace的速度变量。要做到这一点，我们需要点击并拖动blendspace节点旁边**Speed**旁边的绿色点以打开上下文菜单，查找**提升为变量**，然后点击它。这将在blendspace节点中将速度提升为浮点变量，我们将设置它来控制播放动画的速度和类型。将这个新变量重命名为**Speed**。以下截图显示了如何创建和连接一个**Speed**变量到**WalkJogRun**
    blendspace，它链接到**最终动画姿态**：
- en: '![AnimGraph](img/B03679_05_17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_17.jpg)'
- en: 'Now, go back to link **Movement** to **Final Animation Pose**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到将**Movement**链接到**最终动画姿态**：
- en: '![AnimGraph](img/B03679_05_18.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_18.jpg)'
- en: Now, the entire AnimGraph is linked up. Click on **Compile**, and you would
    see the preview of the character model updated, as shown in the following screenshot.
    The white moving dots show how data flows through the system. The speed is 0 here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个AnimGraph已经连接起来。点击**Compile**，你会看到角色模型的预览更新，如以下截图所示。白色移动的圆点显示了数据如何通过系统流动。这里的速度是0。
- en: '![AnimGraph](img/B03679_05_19.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_19.jpg)'
- en: We can also use this tab to see live preview as we change the value to **Speed**.
    The following screenshot shows you when speed is 50\. The character model assumes
    a walking pose.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用此选项卡来查看当我们更改**Speed**的值时的实时预览。以下截图显示了速度为50时的情况。角色模型采取了一个行走姿态。
- en: '![AnimGraph](img/B03679_05_20.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![AnimGraph](img/B03679_05_20.jpg)'
- en: Through AnimGraph, we were able to set up **Speed** as a variable and link this
    variable to **WalkJogRun** blendspace, which, in turn, controls what animation
    to play at which speed. We need to now think about how to provide some logic to
    determine how the speed of the NPC changes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过AnimGraph，我们能够将**Speed**设置为变量，并将其链接到**WalkJogRun**混合空间，这反过来控制以何种速度播放哪种动画。我们现在需要考虑如何提供一些逻辑来确定NPC的速度如何变化。
- en: EventGraph
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EventGraph
- en: EventGraph is used to program logic into the Blueprint.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: EventGraph用于将逻辑编程到蓝图之中。
- en: In this example, we will use EventGraph to create logic to change the speed
    values that will, in turn, affect the NPC's animation control.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用EventGraph创建逻辑来更改速度值，这将反过来影响NPC的动画控制。
- en: To create a more complex intelligent decision-making process, which is termed
    as AI, we will need to use a set of AI-related nodes in EventGraph. We will learn
    more about creating AI in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个更复杂的智能决策过程，这被称为AI，我们需要在EventGraph中使用一组与AI相关的节点。我们将在下一节中了解更多关于创建AI的内容。
- en: The following screenshot shows the default new **EventGraph** tab in the Animation
    Blueprint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了动画蓝图中的默认新**EventGraph**选项卡。
- en: The **Event Blueprint Update Animation** node can be thought of as the source
    that sends a pulse through the EventGraph network. As this pulse travels through
    the network, it goes through a series of questions that you design to determine
    which animation is played.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Event Blueprint Update Animation**节点可以被视为在EventGraph网络中发送脉冲的源。随着这个脉冲通过网络传播，它会经过你设计的多个问题，以确定播放哪种动画。'
- en: '![EventGraph](img/B03679_05_21.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![EventGraph](img/B03679_05_21.jpg)'
- en: '**Try Get Pawn Owner** is to get the owner that Animation Blueprint is assigned
    to. This is simply used in combination with another node, **IsValid**, to ensure
    that we have a valid owner before setting values to change the animation.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Try Get Pawn Owner**用于获取动画蓝图分配的所有者。这通常与另一个节点**IsValid**结合使用，以确保在设置值以更改动画之前有一个有效的所有者。'
- en: 'To make **MyNPC_Blueprint** work for the **Hero_TPP** mesh that we have in
    the level, we will need to first delete the **Try Get Pawn Owner** node and replace
    it with **Get Owning Component**. Right-click on the EventGraph and type `Get`.
    In the contextual menu that is opened, scroll down to find **Get Owning Component**.
    This screenshot shows where the **Get Owning Component** node is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使**MyNPC_Blueprint**在级别中为我们拥有的**Hero_TPP**网格上工作，我们首先需要删除**Try Get Pawn Owner**节点并将其替换为**Get
    Owning Component**。在EventGraph上右键点击并输入`Get`。在打开的上下文菜单中向下滚动以找到**Get Owning Component**。此截图显示了**Get
    Owning Component**节点所在的位置：
- en: '![EventGraph](img/B03679_05_22.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![EventGraph](img/B03679_05_22.jpg)'
- en: 'In the same way, right-click in the editor and type `IsValid` to look for the
    node. This screenshot shows where to get the **IsValid** node:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在编辑器中右键点击并输入`IsValid`以查找节点。此截图显示了获取**IsValid**节点的地方：
- en: '![EventGraph](img/B03679_05_23.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![EventGraph](img/B03679_05_23.jpg)'
- en: Now, link the triangular output from **Event Blueprint Update Animation** to
    the **Exec** input of the **IsValid** node (which is also a triangular input).
    Link **Return Value** (this has a blue circle next to it) output from **Get Owning
    Component** to **Input Object** (this has a blue circle next to it) of the **IsValid**
    node. The following screenshot shows the linkage of the three nodes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**Event Blueprint Update Animation**的三角形输出链接到**IsValid**节点的**Exec**输入（这也是一个三角形输入）。将**Get
    Owning Component**的**Return Value**输出（旁边有一个蓝色圆圈）链接到**IsValid**节点的**Input Object**（旁边也有一个蓝色圆圈）。以下截图显示了三个节点的连接。
- en: The explanation for this is that at every tick, we need to check whether the
    target skeleton mesh is valid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解释是这样的，在每一个tick时，我们需要检查目标骨骼网格是否有效。
- en: 'For now, let''s simply set the speed of the NPC to 100 if the target skeleton
    mesh is valid. So, right-click on the EventGraph area, and type `SetSpeed` to
    filter the options. Click and select **Set Speed**, as shown in this screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果目标骨骼网格有效，我们只需将NPC的速度设置为100。因此，在事件图区域右键单击，并输入`SetSpeed`以过滤选项。点击并选择**设置速度**，如图所示：
- en: '![EventGraph](img/B03679_05_24.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/B03679_05_24.jpg)'
- en: 'Link the **Is Valid** output of the **IsValid** node to the input (this has
    a triangular symbol) of the **SET Speed** node. Then, click on the box next to
    **Speed** and type `100` to set the speed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将**IsValid**节点的**Is Valid**输出链接到**SET Speed**节点的输入（这有一个三角形符号）。然后，点击**速度**旁边的框，并输入`100`以设置速度：
- en: '![EventGraph](img/B03679_05_25.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/B03679_05_25.jpg)'
- en: 'Save and recompile now to see how the preview model changes. The following
    screenshot shows the model playing the walk animation when speed is set to 100:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新编译现在，以查看预览模型如何变化。以下截图显示了当速度设置为100时，模型正在播放行走动画：
- en: '![EventGraph](img/B03679_05_26.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/B03679_05_26.jpg)'
- en: Now, Animation Blueprint is ready for use in the game level. We need to assign
    this Animation Blueprint to a character in the game. Save and close the Animation
    Blueprint editor to go back to the main editor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，动画蓝图已经准备好在游戏关卡中使用。我们需要将这个动画蓝图分配给游戏中的一个角色。保存并关闭动画蓝图编辑器以返回主编辑器。
- en: 'To assign the Blueprint to the skeleton mesh, we will click on the existing
    **HeroTPP** to display the details panel. Focus on the animation part of the panel;
    the following screenshot shows the original setting that I have when there is
    no animation sequence linked to the skeleton mesh and it does not use an Animation
    Blueprint. Set **Animation Mode** to **Use Animation Asset** and **Anim to Play**
    to **None**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要将蓝图分配给骨骼网格，我们将点击现有的**HeroTPP**以显示详细信息面板。关注面板的动画部分；以下截图显示了当没有动画序列链接到骨骼网格且不使用动画蓝图时的原始设置。将**动画模式**设置为**使用动画资产**，将**Anim
    to Play**设置为**无**：
- en: '![EventGraph](img/B03679_05_27.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/B03679_05_27.jpg)'
- en: 'To use **MyNPC_Blueprint** for this skeleton mesh, set **Animation Mode** to
    **Use Animation Blueprint**. Select **MyNPC_Blueprint** for **Anim Blueprint Generated
    Class**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**MyNPC_Blueprint**为此骨骼网格，将**动画模式**设置为**使用动画蓝图**。选择**MyNPC_Blueprint**作为**Anim
    Blueprint Generated Class**：
- en: '![EventGraph](img/B03679_05_28.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/B03679_05_28.jpg)'
- en: Now, compile and run the game; you would see the NPC walking on the same spot
    with the speed set as 100.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行游戏；你会看到NPC以100的速度在同一地点行走。
- en: Artificial intelligence
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能
- en: AI is a decision-making process that adds NPCs in a game. AI is a programmable
    decision-making process for NPCs to govern their responses and behaviors in a
    game. A game character that is not controlled by a human player has no form of
    intelligence, and when these characters need to have a higher form of decision-making
    process, we apply AI to them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: AI是一个决策过程，它将NPC添加到游戏中。AI是NPC的可编程决策过程，用于控制他们在游戏中的响应和行为。一个不由人类玩家控制的游戏角色没有智能形式，当这些角色需要更高形式的决策过程时，我们将其应用于它们。
- en: AI in games has progressed tremendously over the years and NPCs can be programmed
    to behave in a certain way, sometimes, with some form of randomness, making it
    almost unpredictable so that players do not have a simple, straightforward strategy
    to win the level.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，游戏中的AI取得了巨大的进步，NPC可以被编程以以某种方式行为，有时，带有某种形式的随机性，使其几乎不可预测，这样玩家就没有简单的、直接的策略来赢得关卡。
- en: The decision-making process, which is also the logic of the NPCs, is stored
    in a data structure known as a Behavior Tree. We will first learn how to design
    a simple Behavior Tree then learn how to implement this in Unreal Engine 4.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 决策过程，也是NPC的逻辑，存储在称为行为树的数据结构中。我们将首先学习如何设计一个简单的行为树，然后学习如何在虚幻引擎4中实现它。
- en: Understanding a Behavior Tree
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解行为树
- en: Learning how to design a good decision-making tree is very important. This is
    the foundation on which programmers or scripters rely to create the behavior of
    a character in a game. The Behavior Tree is the equivalent of a construction blueprint
    for architects who design your house.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何设计一个好的决策树非常重要。这是程序员或脚本编写者依赖的基础，以创建游戏中的角色行为。行为树是建筑师为设计你的房子而设计的建筑蓝图。
- en: 'A Behavior Tree has roots that branch out into layers of child nodes, which
    are ordered from left to right (this means that you always start from the left-most
    node when traversing the child nodes) that describe the decision-making process.
    The nodes that make up the Behavior Tree mainly fall into three categories: Composite,
    Decorator, or Leaf. Once you are familiar with a couple of the common types of
    nodes in each of the three categories, you would be ready to create your own complex
    behaviors:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树有根节点，这些根节点分支成多个子节点层，这些子节点从左到右排序（这意味着在遍历子节点时，你总是从最左边的节点开始）。这些节点描述了决策过程。构成行为树的节点主要分为三类：组合节点、装饰器节点或叶节点。一旦你熟悉了这三类中每种常见节点类型，你就可以准备创建自己的复杂行为：
- en: '|   | Composite | Decorator | Leaf |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|   | 组合节点 | 装饰器节点 | 叶节点 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Children nodes** | Having one or more children are possible. | This can
    only have a single child node. | This cannot have any children at all. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **子节点** | 可能有一个或多个子节点。 | 这只能有一个子节点。 | 这根本不能有任何子节点。 |'
- en: '| **Function** | Children nodes are processed, depending on the particular
    type of composite node. | This either transforms results from a child node''s
    status, terminates the child, or repeats the processing of the child, depending
    on the particular type of Decorator. | This executes specific game actions/tasks
    or tests. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 根据特定类型的组合节点处理子节点。 | 根据特定类型的装饰器，这可能转换来自子节点的状态结果、终止子节点或重复子节点的处理。 |
    执行特定的游戏动作/任务或测试。 |'
- en: '| **Node examples** | The **Sequence** node processes the children nodes from
    the left-most child in sequence, collects results from each child, and passes
    the overall success or failure result over to the parent (note that even when
    only one child fails and the rest succeed, the overall result is failure). This
    can be thought of as an **AND** node. | The **Inverter** node converts a success
    to a failure and pass this inverted result back to the parent. It works vice versa
    as well. | The **Shoot Once leaf** node shows that the NPC would shoot once and
    return a success or failure, depending on the result. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **节点示例** | **序列**节点按顺序处理从最左边的子节点开始的子节点，收集每个子节点的结果，并将整体成功或失败结果传递给父节点（注意，即使只有一个子节点失败而其余子节点成功，整体结果也是失败）。这可以被视为一个**AND**节点。
    | **反转器**节点将成功转换为失败，并将这个反转的结果传递回父节点。它也可以相反工作。 | **射击一次叶节点**显示NPC将射击一次，并返回成功或失败，具体取决于结果。
    |'
- en: Exercise – designing the logic of a Behavior Tree
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 - 设计行为树的逻辑
- en: 'This is a simple walkthrough of how a Behavior Tree can be constructed. The
    following legend will help you identify the different components of a Behavior
    Tree:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对如何构建行为树的一个简单概述。以下图例将帮助您识别行为树的不同组件：
- en: '![Exercise – designing the logic of a Behavior Tree](img/B03679_05_29.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![练习 - 设计行为树的逻辑](img/B03679_05_29.jpg)'
- en: Example – creating a simple Behavior Tree
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 创建一个简单的行为树
- en: The following figure shows a simple response for an enemy NPC. The enemy will
    only start attacking when the war starts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个敌人NPC的简单响应。敌人只有在战争开始时才会开始攻击。
- en: '![Example – creating a simple Behavior Tree](img/B03679_05_30.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![示例 - 创建一个简单的行为树](img/B03679_05_30.jpg)'
- en: The following figure has been expanded on the earlier Behavior Tree. It gives
    a more detailed description of how the enemy NPC should approach the target. The
    NPC will run towards the target (the player character in this case), and if it
    is close enough, it starts shooting the player.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下图在先前的行为树基础上进行了扩展。它更详细地描述了敌人NPC应该如何接近目标。NPC将朝向目标（在这个例子中是玩家角色）奔跑，如果足够接近，它就开始射击玩家。
- en: '![Example – creating a simple Behavior Tree](img/B03679_05_31.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![示例 - 创建一个简单的行为树](img/B03679_05_31.jpg)'
- en: 'Next, we set more behaviors that show how the NPC will shoot the player. We
    give the enemy NPC a little intelligence: hide if someone is shooting at it and
    start shooting if no one is shooting at it; if the player starts moving in toward
    it, the NPC starts moving backward to a better spot or goes for a death match
    (it shoots the player at close range).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置更多行为来展示NPC将如何射击玩家。我们给敌人NPC一点智慧：如果有人射击它就隐藏，如果没有人射击它就开始射击；如果玩家开始朝它移动，NPC就开始向后移动到一个更好的位置，或者进行死亡比赛（在近距离射击玩家）。
- en: '![Example – creating a simple Behavior Tree](img/B03679_05_32.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![示例 - 创建一个简单的行为树](img/B03679_05_32.jpg)'
- en: How to implement a Behavior Tree in Unreal Engine 4
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在虚幻引擎4中实现行为树
- en: The Unreal Editor allows complex Behavior Trees to be designed using the visual
    scripting Blueprints together with several AI components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal编辑器允许使用视觉脚本蓝图以及几个AI组件来设计复杂的行为树。
- en: There is also an option in Unreal Engine 4 where very complex AI behaviors can
    be programmed in the conventional way or in combination with Blueprint visual
    scripting.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine 4中，也有一个选项，可以以传统方式或与蓝图视觉脚本结合的方式编程非常复杂的AI行为。
- en: 'The nodes for BT in UE4 are broadly divided into five categories. Just to recap,
    we have already learned a little about the first four in the previous section;
    **Service** is the only new category here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: UE4中的BT节点大致分为五类。为了回顾，我们在上一节中已经对前四个有所了解；**服务节点**是这里唯一的新类别：
- en: '**Root**: The starting node for a Behavior Tree and every Behavior Tree has
    only one root.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**：行为树的起始节点，每个行为树只有一个根节点。'
- en: '**Composite**: These are the nodes that define the root of a branch and the
    base rules for how this branch is executed.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合节点**：这些节点定义了分支的根以及如何执行此分支的基本规则。'
- en: '**Decorator**: This is also known as a **conditional**. These attach themselves
    to another node and make decisions on whether or not a branch in the tree, or
    even a single node, can be executed.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：这也被称为**条件**。它们附着到另一个节点上，并决定树中的分支，甚至单个节点是否可以执行。'
- en: '**Task**: This is also known as a Leaf in a typical BT. These are the leaves
    of the tree, that is, the nodes that "do" things.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务节点**：这也可以称为典型的BT中的叶节点。这些是树的叶子，即执行“操作”的节点。'
- en: '**Service**: These are attachments to composite nodes. They are executed at
    a defined frequency, as long as their branch is being executed. These are often
    used to make checks and update the **Blackboard**. These take the place of traditional
    parallel nodes in other Behavior Tree systems.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务节点**：这些是复合节点的附件。只要它们的分支正在执行，就会以定义的频率执行。这些通常用于进行检查和更新**黑板**。它们取代了其他行为树系统中传统的并行节点。'
- en: Navigation Mesh
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航网格
- en: For AI characters to move around in the game level, we need to specifically
    tell the AI character which areas in the map are accessible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让AI角色在游戏关卡中移动，我们需要特别告诉AI角色地图中哪些区域是可访问的。
- en: Unreal Engine has implemented a mesh-like component known as **Navigation Mesh**.
    The Navigation Mesh is pretty much like a block volume; you could scale the size
    of the mesh to cover a specific area in the game level that an AI character can
    move around in. This limits the area in which an AI can go and makes the movement
    of the character more predictable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine实现了名为**导航网格**的类似网格的组件。导航网格基本上就像一个体积块；你可以调整网格的大小以覆盖游戏关卡中AI角色可以移动的特定区域。这限制了AI可以移动的区域，并使角色的移动更加可预测。
- en: Tutorial – creating a Navigation Mesh
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教程 – 创建导航网格
- en: 'Go to **Modes** | **Volumes**. Click and drop **Nav Mesh Bounds Volume** into
    your game level. The following screenshot shows where you can find **Nav Mesh
    Bounds Volume** in the editor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**模式** | **体积**。将**导航网格边界体积**拖放到你的游戏关卡中。以下截图显示了在编辑器中可以找到**导航网格边界体积**的位置：
- en: '![Tutorial – creating a Navigation Mesh](img/B03679_05_33.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建导航网格](img/B03679_05_33.jpg)'
- en: 'If you are unable to see **Nav Mesh Bounds Volume** in your map, go to the
    **Show** settings within the editor, as shown in the following screenshot. Make
    sure the checkbox next to **Navigation** is checked:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在你的地图中看到**导航网格边界体积**，请转到编辑器中的**显示**设置，如下截图所示。确保**导航**旁边的复选框被勾选：
- en: '![Tutorial – creating a Navigation Mesh](img/B03679_05_34.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建导航网格](img/B03679_05_34.jpg)'
- en: 'Scale and move the Navigation Mesh to cover the area of the floor you want
    the AI character to be able to access. What I have done in the following screenshot
    is to scale the mesh to fit the floor area which I want my AI character to walk
    in. Translate the mesh upward and downward to allow it to be slightly above the
    actual ground mesh. The Navigation Mesh should sort of enclose the ground mesh.
    This screenshot shows how the mesh looks when it is visible:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 调整导航网格的大小和位置，使其覆盖你希望AI角色能够访问的地面区域。以下截图显示的是我将网格调整到适合我AI角色行走的地面区域。将网格向上和向下移动，使其略微高于实际的地面网格。导航网格应该大致包围地面网格。此截图显示了网格可见时的样子：
- en: '![Tutorial – creating a Navigation Mesh](img/B03679_05_35.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![教程 – 创建导航网格](img/B03679_05_35.jpg)'
- en: Tutorial – setting up AI logic
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 教程 – 设置AI逻辑
- en: 'Here''s an overview of the components that we will create for this tutorial:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本教程中我们将创建的组件概述：
- en: Blueprint AIController (**MyNPC_AIController**)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图AIController（**MyNPC_AIController**）
- en: Blueprint Character (**MyNPC_Character**)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图角色（**MyNPC_Character**）
- en: BlackBoard (**MyNPC_Brain**)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑板（**MyNPC_Brain**）
- en: Behavior Tree (**MyNPC_BT**)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树（**MyNPC_BT**）
- en: Blueprint Behavior Tree Task (**Task_PickTargetLocation**)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图行为树任务（**Task_PickTargetLocation**）
- en: The important takeaway from this tutorial is to learn how the components are
    linked up to work together to create logic; we make use of this logic to control
    the behavior of the NPC.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的重要收获是学习组件如何相互连接以协同工作以创建逻辑；我们利用这种逻辑来控制NPC的行为。
- en: In terms of file structure in **Content Browser** for these different file types,
    you can group the different components into different folders. For this example,
    since we are only creating one NPC character with logic, I will put all these
    components into a single folder for simplicity. I created `MyFolder` under the
    main directory for this purpose.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中针对这些不同文件类型的文件结构，您可以将不同的组件分组到不同的文件夹中。对于这个例子，因为我们只创建一个具有逻辑的NPC角色，所以我会将这些组件全部放入一个文件夹中以便简化。为此，我在主目录下创建了`MyFolder`。
- en: We start creating the AI logic of our NPC starting with AIController and Character.
    The Character Blueprint is the object that contains the link to the mesh, and
    we will drag and drop this Character Blueprint into the level map after we make
    some initial configurations. The AIController is the component that gives the
    NPC character its logic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从AIController和Character开始创建NPC的AI逻辑。角色蓝图是包含网格链接的对象，我们将在进行一些初始配置后将其拖放到关卡地图中。AIController是赋予NPC角色逻辑的组件。
- en: We will discuss the rest of the other three components as we go along.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续讨论其他三个组件。
- en: Creating the Blueprint AIController
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建蓝图AIController
- en: Go to **Create** | **Blueprint**. Type in `AIController` into the textbox to
    filter by class, as shown in the following screenshot. Select **AIController**
    as the parent class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**创建** | **蓝图**。在文本框中输入`AIController`以按类过滤，如图所示。选择**AIController**作为父类。
- en: 'Rename this AIController Blueprint as `MyNPC_AIController`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将此AIController蓝图重命名为`MyNPC_AIController`：
- en: '![Creating the Blueprint AIController](img/B03679_05_36.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![创建蓝图AIController](img/B03679_05_36.jpg)'
- en: We will come back to configure this later.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回来配置这个。
- en: Creating the Blueprint character
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建蓝图角色
- en: Go to **Create** | **Blueprint**, and type in `Character` in the textbox to
    filter by class. Select **Character** as the parent class for the Blueprint, as
    shown in the following screenshot. Rename this Blueprint as `MyNPC_Character`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**创建** | **蓝图**，并在文本框中输入`Character`以按类过滤。选择蓝图中的**Character**作为父类，如图所示。将此蓝图重命名为`MyNPC_Character`。
- en: '![Creating the Blueprint character](img/B03679_05_37.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![创建蓝图角色](img/B03679_05_37.jpg)'
- en: Adding and configuring Mesh to a Character Blueprint
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将网格添加到角色蓝图并配置
- en: Double-click on **MyNPC_Character** in **Content Browser** to open the Character
    Blueprint editor. Go to the **Components** tab.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**MyNPC_Character**在**内容浏览器**中打开角色蓝图编辑器。转到**组件**选项卡。
- en: 'In the **Perspective** space view, you will see an empty wireframe-capsule-shaped
    object, as shown in the following screenshot. In the **Details** panel in the
    Blueprint editor, scroll to the **Mesh** section, and we will add a mesh to this
    Blueprint by selecting an existing mesh we have. You can go to **Content Browser**,
    select **HeroTPP**, and click on the arrow next to it. Alternatively, you can
    click on the search button next to the box and find **HeroTPP**:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在**视角**空间视图中，您将看到一个空白的线框-胶囊形状的对象，如图所示。在蓝图编辑器的**细节**面板中，滚动到**网格**部分，我们将通过选择现有的网格来向此蓝图添加网格。您可以转到**内容浏览器**，选择**HeroTPP**，然后点击其旁边的箭头。或者，您也可以点击框旁边的搜索按钮并找到**HeroTPP**：
- en: '![Adding and configuring Mesh to a Character Blueprint](img/B03679_05_38.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![将网格添加到角色蓝图并配置](img/B03679_05_38.jpg)'
- en: After selecting **HeroTPP** as the skeletal mesh, you will see the mesh appearing
    in the wireframe capsule. Notice that the **HeroTPP** skeletal mesh is much larger
    than the capsule wireframe, as shown in the following screenshot. We want to be
    able to adjust the size of the wireframe to surround the height and width of the
    skeletal mesh as closely as possible. This will define the collision volume of
    the character.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 **HeroTPP** 作为骨骼网格后，您将看到网格出现在线框胶囊中。请注意，**HeroTPP** 骨骼网格比胶囊线框大得多，如以下截图所示。我们希望能够调整线框的大小，使其尽可能紧密地包围骨骼网格的高度和宽度。这将定义角色的碰撞体积。
- en: '![Adding and configuring Mesh to a Character Blueprint](img/B03679_05_39.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![将网格添加和配置到角色蓝图](img/B03679_05_39.jpg)'
- en: 'This figure shows when the wireframe for the skeletal mesh is the correct height:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了当骨骼网格的线框高度正确时的情况：
- en: '![Adding and configuring Mesh to a Character Blueprint](img/B03679_05_40.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![将网格添加和配置到角色蓝图](img/B03679_05_40.jpg)'
- en: Linking AIController to the Character Blueprint
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 AIController 链接到角色蓝图
- en: Go to the **Default** tab of **MyNPC_Character**, scroll to the AI section,
    and click on the scroll box to display the options available for AIControllers.
    Select **MyNPC_AIController** to assign the character to use this AIController,
    as shown in this screenshot. Compile, save, and close **MyNPC_Character** for
    now.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 **MyNPC_Character** 的 **默认** 选项卡，滚动到 AI 部分，并单击滚动框以显示可用于 AIController 的选项。选择
    **MyNPC_AIController** 以将角色分配给使用此 AIController，如截图所示。编译、保存并暂时关闭 **MyNPC_Character**。
- en: '![Linking AIController to the Character Blueprint](img/B03679_05_41.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![将 AIController 链接到角色蓝图](img/B03679_05_41.jpg)'
- en: Go to **Content Browser**, and click and drop **MyNPC_Character** into the level
    map. Compile and play the level. You will see that the character appears in the
    level but it is static.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 **内容浏览器**，将 **MyNPC_Character** 拖放到关卡地图中。编译并播放关卡。您将看到角色出现在关卡中，但它处于静态状态。
- en: Adding basic animation
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加基本动画
- en: 'Similar to the early implementation of assigning an animation to the mesh,
    we will add animation to **MyNPC_Character**. Double-click on **MyNPC_Character**
    to open the editor. Go the **Default** tab, scroll to the **Animation** section,
    and assign the Animation Blueprint (**MyNPC_Blueprint**), which we created earlier
    for this Character Blueprint. The following screenshot shows how we can assign
    animation to the character. Compile and save **MyNPC_Character**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期将动画分配给网格的实现类似，我们将为 **MyNPC_Character** 添加动画。双击 **MyNPC_Character** 以打开编辑器。转到
    **默认** 选项卡，滚动到 **动画** 部分，并分配我们之前为该角色蓝图创建的动画蓝图（**MyNPC_Blueprint**）。以下截图显示了我们可以如何将动画分配给角色。编译并保存
    **MyNPC_Character**：
- en: '![Adding basic animation](img/B03679_05_42.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![添加基本动画](img/B03679_05_42.jpg)'
- en: Now, play the level again, and you will see that the character is now walking
    on the spot (as we have set the speed to 100 in the Animation Blueprint, **MyNPC_Blueprint**).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次播放关卡，您将看到角色现在原地踏步（因为我们已在动画蓝图 **MyNPC_Blueprint** 中将速度设置为 100）。
- en: Configuring AIController
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 AIController
- en: Go to **Content Browser**. Then, go to **MyFolder** and double-click on **MyNPC_AIController**
    to open the editor. We will now add nodes in EventGraph to design the logic.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 **内容浏览器**。然后，转到 **MyFolder** 并双击 **MyNPC_AIController** 以打开编辑器。我们现在将在 EventGraph
    中添加节点以设计逻辑。
- en: Our first mission is to get the character to move forward (instead of just walking
    on the same spot).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是让角色向前移动（而不仅仅是原地踏步）。
- en: Nodes to add in EventGraph
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 EventGraph 中添加的节点
- en: 'The following are the nodes to be added in EventGraph:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 EventGraph 中需要添加的节点：
- en: '**Event Tick**: This is used to trigger the loop to run at every tick'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件刻度**：这用于在每次刻度时触发循环'
- en: '**Get Controlled Pawn**: This returns the pawn of AIController (which will
    be the pawn of **HeroTPP**)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取受控单位**：这返回 AIController 的单位（这将将是 **HeroTPP** 的单位）'
- en: '**Get Actor Forward Vector**: This gets the forward vector'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取演员前向向量**：这获取前向向量'
- en: '**Add Movement Input**: This links the target to **Get Controlled Pawn** and
    **Link World Direction** to the output of **Get Actor Forward Vector**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加移动输入**：这将目标链接到 **获取受控单位**，并将 **链接世界方向** 链接到 **获取演员前向向量** 的输出'
- en: '**IsValid**: This is to ensure that the pawn exists first before actually changing
    the pawn values'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IsValid**：这是为了确保在实际上更改单位值之前单位首先存在'
- en: 'The following screenshot shows the final EventGraph that we want to create:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们要创建的最终 EventGraph：
- en: '![Nodes to add in EventGraph](img/B03679_05_43.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![在 EventGraph 中添加的节点](img/B03679_05_43.jpg)'
- en: Now, play the level again, and you will see that the character is now walking
    forward. But it's doing this a little too quickly. We want to adjust the maximum
    speed at which the character moves.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次播放关卡，您将看到角色现在正在向前走。但它走得有点太快。我们想要调整角色移动的最大速度。
- en: Adjusting movement speed
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整移动速度
- en: 'Double-click on **MyNPC_Character** to open the editor. Go to the **Default**
    tab, scroll to the **Character Movement** section, and set **Max Walk Speed**
    to **100**, as shown in this screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**MyNPC_Character**以打开编辑器。转到**默认**选项卡，滚动到**角色移动**部分，并将**最大行走速度**设置为**100**，如图所示：
- en: '![Adjusting movement speed](img/B03679_05_44.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![调整移动速度](img/B03679_05_44.jpg)'
- en: Creating the BlackBoardData
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建BlackBoardData
- en: BlackBoardData functions as the memory unit of the brain of the NPC. This is
    where you store and retrieve data that would be used to control the behavior of
    the NPC. Go to **Content Browser**, and navigate to **Create** | **Miscellaneous**
    | **Blackboard**. Rename it `MyNPC_Brain`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: BlackBoardData充当NPC大脑的内存单元。这是您存储和检索用于控制NPC行为的数据的地方。转到**内容浏览器**，导航到**创建** | **杂项**
    | **黑板**。将其重命名为`MyNPC_Brain`。
- en: '![Creating the BlackBoardData](img/B03679_05_45.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![创建BlackBoardData](img/B03679_05_45.jpg)'
- en: Adding a variable into BlackBoardData
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将变量添加到BlackBoardData中
- en: Double-click on **MyNPC_Brain** to open the BlackBoardData editor. Click on
    **New Key**, select **Key Type** as **Vector**, and name it `TargetLocation`.
    This screenshot shows that **TargetLocation** is created correctly. Save and close
    the editor.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**MyNPC_Brain**以打开BlackBoardData编辑器。单击**新建键**，选择**键类型**为**向量**，并将其命名为`TargetLocation`。此截图显示**TargetLocation**已正确创建。保存并关闭编辑器。
- en: '![Adding a variable into BlackBoardData](img/B03679_05_46.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![将变量添加到BlackBoardData中](img/B03679_05_46.jpg)'
- en: Creating a Behavior Tree
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建行为树
- en: Behavior Tree is the logic path that NPC goes through to determine what course
    of action to take.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树是NPC通过它来确定采取何种行动的逻辑路径。
- en: To create a Behavior Tree in Unreal Engine, go to **Content Browser** | **Create**
    | **Miscellaneous**, and then click on **Behavior Tree**. Rename it `MyNPC_BT`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚幻引擎中创建行为树，请转到**内容浏览器** | **创建** | **杂项**，然后单击**行为树**。将其重命名为`MyNPC_BT`。
- en: '![Creating a Behavior Tree](img/B03679_05_47.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![创建行为树](img/B03679_05_47.jpg)'
- en: Double-click on **MyNPC_BT** to open the Behavior Tree editor. The following
    screenshot shows the setting that we want for **MyNPC_BT**. It should have **MyNPC_Brain**
    set as the BlackBoard asset. If it doesn't, search for **MyNPC_Brain** and assign
    it as the BlackBoard asset.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**MyNPC_BT**以打开行为树编辑器。以下截图显示了我们对**MyNPC_BT**想要的设置。它应该将**MyNPC_Brain**设置为黑板资产。如果没有，搜索**MyNPC_Brain**并将其分配为黑板资产。
- en: If you have already gone through the earlier exercise and are familiar with
    a Behavior Tree, you will notice that in this editor that there is a **Root**
    node, which you could use to start building out your NPC's behavior.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经完成了前面的练习并且熟悉行为树，您会注意到在这个编辑器中有一个**根**节点，您可以使用它来开始构建NPC的行为。
- en: '![Creating a Behavior Tree](img/B03679_05_48.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![创建行为树](img/B03679_05_48.jpg)'
- en: Creating a simple BT using a Wait task
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用等待任务创建简单的BT
- en: The next step here is to add on a composite node (either **Sequence**, **Selector**,
    or **Simple Parallel**). In this example, we will select and use a **Sequence**
    node to extend our Behavior Tree here. You can click and drag from the **Root**
    node to open up the contextual menu, as shown in the following screenshot. Alternatively,
    just right-click to open up the menu and select the node that you want to create.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的下一步是添加一个组合节点（可以是**序列**、**选择器**或**简单并行**）。在这个例子中，我们将选择并使用**序列**节点来扩展这里的行为树。您可以点击并拖动从**根**节点以打开上下文菜单，如图所示。或者，只需右键单击打开菜单并选择您想要创建的节点。
- en: '![Creating a simple BT using a Wait task](img/B03679_05_49.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![使用等待任务创建简单的BT](img/B03679_05_49.jpg)'
- en: We will add a **Wait** task from the **Sequence** node. Click and drag to create
    a new connection from the **Sequence** node. From the contextual menu, select
    **Wait**. Set **Wait** to be **15.0s**, as shown in this screenshot. Save and
    compile **MyNPC_BT**.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**序列**节点添加一个**等待**任务。点击并拖动以从**序列**节点创建一个新的连接。从上下文菜单中选择**等待**。将**等待**设置为**15.0s**，如图所示。保存并编译**MyNPC_BT**。
- en: '![Creating a simple BT using a Wait task](img/B03679_05_50.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![使用等待任务创建简单的BT](img/B03679_05_50.jpg)'
- en: After compiling, click on **Play** in the Behavior Tree editor. You would see
    the light moving through the links and especially from the **Sequence** node to
    the **Wait** task for 15s.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，在行为树编辑器中点击**播放**。你会看到光线通过链接移动，特别是从**序列**节点到等待15秒的**等待**任务。
- en: Using the Behavior Tree
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用行为树
- en: Now that we have a simple implementation of the Behavior Tree, we want our NPC
    character to start using it. How do we do this? Go to **Content Browser** | **MyFolder**,
    and double-click on **MyNPC_AIController** to open up the editor. Go to the **EventGraph**
    tab where we initially created a simple move forward implementation. Break the
    initial links between the **IsValid** node and **Add Movement Input**. Rewire
    them based on the following screenshot by linking the **IsValid** node to a new
    **Run** Behavior Tree node. In the **Run** Behavior Tree node, assign **BTAsset**
    to **MyNPC_BT**. Next, replace **Event Tick** with **Event Begin Play** (since
    the BT will now replace the thinking function here). Save and compile.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个简单的行为树实现，我们想让我们的NPC角色开始使用它。我们该如何做？前往**内容浏览器** | **我的文件夹**，双击**MyNPC_AIController**以打开编辑器。前往我们最初创建简单向前移动实现的**事件图**选项卡。断开**IsValid**节点和**添加移动输入**之间的初始链接。根据以下截图重新布线，将**IsValid**节点链接到一个新的**运行**行为树节点。在**运行**行为树节点中，将**BTAsset**分配给**MyNPC_BT**。接下来，将**事件计时器**替换为**事件开始播放**（因为BT现在将替换这里的思考功能）。保存并编译。
- en: '![Using the Behavior Tree](img/B03679_05_51.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![使用行为树](img/B03679_05_51.jpg)'
- en: Creating a custom task for the Behavior Tree
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为行为树创建自定义任务
- en: We want to now make the NPC select a location on the map and walk toward it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想让NPC在地图上选择一个位置并朝它走去。
- en: This requires the creation of a custom task where the NPC has to select a target
    location. We have already created an entry in the BlackBoardData to store a vector
    value. However, we have not made a way to assign values to the data yet. This
    would be done by creating a custom Behavior Tree task.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要创建一个自定义任务，其中NPC必须选择一个目标位置。我们已经在BlackBoardData中创建了一个条目来存储矢量值。然而，我们还没有创建一种方法来分配数据值。这将通过创建一个自定义行为树任务来完成。
- en: Go to **Content Browser** | **Create** | **Blueprint**. For the parent class,
    search for **BTNode** and select **BTTask_BlueprintBase**, as shown in the following
    screenshot. Rename this task as `Task_PickTargetLocation`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**内容浏览器** | **创建** | **蓝图**。对于父类，搜索**BTNode**并选择**BTTask_BlueprintBase**，如图所示。将此任务重命名为`Task_PickTargetLocation`。
- en: '![Creating a custom task for the Behavior Tree](img/B03679_05_52.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![为行为树创建自定义任务](img/B03679_05_52.jpg)'
- en: 'Double-click on the newly created **Task_PickTargetLocation**. Go to **EventGraph**,
    create the following nodes, and link these nodes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 双击新创建的**Task_PickTargetLocation**。前往**事件图**，创建以下节点，并将这些节点链接起来：
- en: '**Event Receive Execute**: Link **Owner Actor** to the target of **Get Actor
    Location**. When **PickTargetLocation** is executed, **Event Receive Execute**
    starts.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件接收执行**：将**拥有者演员**链接到**获取演员位置**的目标。当**PickTargetLocation**执行时，**事件接收执行**开始。'
- en: '**Get Actor Location**: Link **Return Value** to **Origin of Get Random Point**
    in the **Radius** node.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取演员位置**：将**返回值**链接到**半径**节点中的**获取随机点**的**原点**。'
- en: '**Set Blackboard Value as Vector**: Link **Event Receive Execute** to the execution
    arrow of **Set Blackboard Value as Vector**.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置黑板值为矢量**：将**事件接收执行**链接到**设置黑板值为矢量**的执行箭头。'
- en: '**Get Random Point in Radius**: Link **Return Value** to the **Value** input
    for **Set Blackboard Value as Vector**.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在半径内获取随机点**：将**返回值**链接到**设置黑板值为矢量**的**值**输入。'
- en: '**Finish Execute**: Link **Set Blackboard Value as Vector** to the input execution
    of **Finish Execute**.![Creating a custom task for the Behavior Tree](img/B03679_05_53.jpg)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行完成**：将**设置黑板值为矢量**链接到**执行完成**的输入。![为行为树创建自定义任务](img/B03679_05_53.jpg)'
- en: Notice that there is a **New Target Loc** variable linked to **Key** of **Set
    Blackboard Value as Vector**. We need to create a new variable for this. Click
    on **+Variable**, as shown in the following screenshot, to create a new variable.
    Name the new variable `New Target Loc`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有一个**新目标位置**变量链接到**设置黑板值为矢量**的**键**。我们需要为这个创建一个新的变量。点击**+变量**，如图所示，以创建一个新的变量。将新变量命名为`New
    Target Loc`。
- en: '![Creating a custom task for the Behavior Tree](img/B03679_05_54.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![为行为树创建自定义任务](img/B03679_05_54.jpg)'
- en: 'Click on the newly created **New Target Loc** to display the details of the
    variable. Select **BlackBoardKeySelector** as the variable type, as shown in this
    screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 点击新创建的 **New Target Loc** 以显示变量的详细信息。选择 **BlackBoardKeySelector** 作为变量类型，如图所示：
- en: '![Creating a custom task for the Behavior Tree](img/B03679_05_55.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![为行为树创建自定义任务](img/B03679_05_55.jpg)'
- en: Save and compile the custom task.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并编译自定义任务。
- en: Using the PickTargetLocation custom task in BT
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 BT 中使用 PickTargetLocation 自定义任务
- en: 'Add a new link from the current **Sequence** composite node. Place the **Task_PickTargetLocation**
    node to the left of the **Sequence** node so that it would be executed first,
    as shown in the following screenshot. Make sure that **New Target Loc** is set
    as **TargetLocation**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前的 **Sequence** 组合节点添加一个新的链接。将 **Task_PickTargetLocation** 节点放置在 **Sequence**
    节点的左侧，以便它首先执行，如图所示。确保将 **New Target Loc** 设置为 **TargetLocation**：
- en: '![Using the PickTargetLocation custom task in BT](img/B03679_05_56.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![使用 BT 中的 PickTargetLocation 自定义任务](img/B03679_05_56.jpg)'
- en: Replacing the Wait task with Move To
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用 Move To 替换 Wait 任务
- en: 'Delete the **Wait** node, and add the **Move To** node in its place. Make sure
    that **Blackboard Key** for **Move To** is set as **TargetLocation**, as show
    in this screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 **Wait** 节点，并在其位置添加 **Move To** 节点。确保将 **Move To** 的 **Blackboard Key** 设置为
    **TargetLocation**，如图所示：
- en: '![Replacing the Wait task with Move To](img/B03679_05_57.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![用 Move To 替换 Wait 任务](img/B03679_05_57.jpg)'
- en: 'After compiling, click on **Play** to run the game. Double-click on **MyNPC_BT**
    to open the Behavior Tree editor. You would see the light moving through the links
    and the **TargetLocation** value changing in the Blackboard, as shown in this
    screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，点击 **Play** 运行游戏。双击 **MyNPC_BT** 打开行为树编辑器。你会看到光线穿过链接，以及黑板上 **TargetLocation**
    值的变化，如图所示：
- en: '![Replacing the Wait task with Move To](img/B03679_05_58.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![用 Move To 替换 Wait 任务](img/B03679_05_58.jpg)'
- en: Remember to go back to the map level and see how the NPC is behaving now. The
    NPC now selects a target location and then move to the target location. Then,
    it selects a new target location and moves to another spot.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 记得回到地图级别，看看 NPC 现在的行为。NPC 现在会选择一个目标位置，然后移动到目标位置。然后，它会选择一个新的目标位置并移动到另一个地方。
- en: With this example, you have gained a detailed understanding of how to set up
    AI behavior and getting AI to work in your level. Challenge yourself to create
    more complex behaviors using the knowledge gained in this section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，你已经详细了解了如何设置 AI 行为以及让 AI 在你的关卡中工作。挑战自己，利用本节中获得的知识创建更复杂的行为。
- en: Implementing AI in games
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏中的 AI 实现
- en: I am sure you have noticed that we definitely need to create more complex behaviors
    to make a game interesting. In terms of implementation, it is often easier to
    implement more complex AI through a combination of programming and use the editor
    functions to take this a step further. So, it is important to know how AI can
    be triggered via the editor and how you can customize AI for your game.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经注意到，我们确实需要创建更复杂的行为来使游戏更有趣。在实现方面，通常通过编程和利用编辑器功能结合使用，可以更容易地实现更复杂的 AI，并将这一过程进一步推进。因此，了解如何通过编辑器触发
    AI 以及如何为你的游戏自定义 AI 非常重要。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covers both animation and artificial intelligence. These are huge
    topics in game development and there is definitely more to learn about them. I
    hope that through this chapter, you now have a strong understanding of these two
    topics and will use your skills to further explore more functions in the Unreal
    Editor to create cooler stuff.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了动画和人工智能，这两个主题在游戏开发中都是非常重要的，肯定还有更多关于它们的内容可以学习。我希望通过本章，你现在对这些两个主题有了深入的理解，并将你的技能用于进一步探索
    Unreal 编辑器中的更多功能，以创建更酷的内容。
- en: We learned a little about the history of animation, how animation is created
    today in 3D computer games through various 3D modeling software, and finally,
    how to import this animation into Unreal Engine to be used in games. An animation
    sequence is the format in which animation is stored/played in Unreal, and you've
    learned about a simple blend technique to combine different animation sequences.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要了解了动画的历史，以及今天如何通过各种 3D 建模软件在 3D 计算机游戏中创建动画，最后是如何将此动画导入 Unreal Engine 以在游戏中使用。动画序列是动画在
    Unreal 中存储/播放的格式，你已经了解了一种简单的混合技术来组合不同的动画序列。
- en: Personally, I love how AI contributes to a game. In this chapter, you learned
    about the different components that make up AI logic. The main AI logic is executed
    through the Behavior Tree, and we learned how to construct a Behavior Tree in
    terms of logic as well as how to replicate this into the Unreal Editor itself
    through the use of BlackBoardData, Task, Composite, and other nodes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我非常喜欢人工智能对游戏做出的贡献。在本章中，你学习了构成人工智能逻辑的不同组件。主要的人工智能逻辑是通过行为树来执行的，我们也学习了如何从逻辑角度构建行为树，以及如何通过使用黑板数据、任务、组合和其他节点将这些逻辑复制到虚幻引擎编辑器中。
- en: Ending this chapter, we have covered a huge portion of what we need to create
    a game. In the next chapter, you will learn how to add sounds and particle effects
    into a game.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾，我们已经涵盖了创建游戏所需的大部分内容。在下一章中，你将学习如何将声音和粒子效果添加到游戏中。
