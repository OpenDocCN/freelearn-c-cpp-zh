- en: Chapter 4. Controlling Camera and Taking Photos
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 控制相机和拍照
- en: 'Through this chapter, you''ll find how easy it is to access and control a camera
    with Qt. The example in this chapter also demonstrates how to utilize the status
    bar and menu bar. In addition to the traditional Qt Widget applications, there
    is a QML camera example, which does the same thing as Qt/C++ but in a more elegant
    way. The following topics, which are covered in this chapter, will extend your
    application:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你会发现使用Qt访问和控制相机是多么容易。本章中的示例还演示了如何利用状态栏和菜单栏。除了传统的Qt Widget应用程序外，还有一个QML相机示例，它以更优雅的方式完成与Qt/C++相同的功能。本章涵盖的以下主题将扩展你的应用程序：
- en: Accessing the camera in Qt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt中访问相机
- en: Controlling the camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制相机
- en: Displaying errors in the status bar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态栏中显示错误
- en: Displaying the permanent widgets in the status bar
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态栏中显示永久小部件
- en: Utilizing the menu bar
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用菜单栏
- en: Using `QFileDialog`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QFileDialog`
- en: Using the QML Camera
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QML相机
- en: Accessing the camera in Qt
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt中访问相机
- en: Although we won't talk about the technical details of how a camera works, the
    overview of the implementation of a camera in Qt will be covered. Support for
    a camera is included in Qt Multimedia, which is a module that provides a rich
    set of QML types and C++ classes to handle multimedia content. Things such as
    audio playback, camera, and radio functionality are shown. To complement this,
    the Qt Multimedia Widgets module provides widget-based multimedia classes to make
    the work easier.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会讨论相机工作原理的技术细节，但Qt中实现相机的概述将会被涵盖。相机支持包含在Qt Multimedia模块中，这是一个提供丰富QML类型和C++类以处理多媒体内容的模块。例如，音频播放、相机和收音机功能等。为了补充这一点，Qt
    Multimedia Widgets模块提供了基于小部件的多媒体类，以简化工作。
- en: There are some classes to help us deal with the camera. For instance, `viewfinder`
    lets a user look through the camera to compose, and in many cases focus, the picture.
    In Qt/C++, you can use `QGraphicsView` along with `QGraphicsVideoItem` to do this
    job. `QGraphicsView` provides a widget to display the contents of `QGraphicsScene`.
    In this case, `QGraphicsVideoItem` is an item of the scene. This view-scene-item
    is the **Graphics View Framework**. For details on this concept, visit [http://doc.qt.io/qt-5/graphicsview.html](http://doc.qt.io/qt-5/graphicsview.html).
    In this example, we use `QCameraViewfinder`, which is the dedicated `viewfinder`
    class and is simpler and more straightforward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些类帮助我们处理相机。例如，`viewfinder`允许用户通过相机来构图，并在许多情况下聚焦图片。在Qt/C++中，你可以使用`QGraphicsView`与`QGraphicsVideoItem`来完成这项工作。`QGraphicsView`提供了一个小部件来显示`QGraphicsScene`的内容。在这种情况下，`QGraphicsVideoItem`是场景中的一个项目。这个视图-场景-项目是**图形视图框架**。关于这个概念的具体信息，请访问[http://doc.qt.io/qt-5/graphicsview.html](http://doc.qt.io/qt-5/graphicsview.html)。在这个例子中，我们使用`QCameraViewfinder`，这是一个专门的`viewfinder`类，它更简单、更直接。
- en: To capture a photo, we need to use the `QCameraImageCapture` class, which records
    the media content, while the focus and zoom are managed by the `QCameraFocus`
    class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕捉照片，我们需要使用`QCameraImageCapture`类，它记录媒体内容，而聚焦和缩放则由`QCameraFocus`类管理。
- en: 'After all, `QCamera` plays a core role in this process. The `QCamera` class
    provides an interface to access the camera devices, including webcams and mobile
    device cameras. There is another class, `QCameraInfo`, which can list all the
    available camera devices and choose which one to use. The following diagram will
    help you understand this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`QCamera`在这个过程中扮演核心角色。`QCamera`类提供了一个接口来访问相机设备，包括网络摄像头和移动设备摄像头。还有一个名为`QCameraInfo`的类，可以列出所有可用的相机设备并选择使用哪一个。以下图表将帮助您理解这一点：
- en: '![Accessing the camera in Qt](img/4615OS_04_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![在Qt中访问相机](img/4615OS_04_01.jpg)'
- en: 'To see a demonstration, create a new Qt Widget Application project named `CameraDemo`.
    Edit the `CameraDemo.pro` file. Add multimedia `multimediawidgets` to QT by appending
    a line, as shown here, or add two modules to the predefined QT line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CameraDemo`的新Qt Widget应用程序项目。编辑`CameraDemo.pro`文件。通过添加一行，如所示，将多媒体`multimediawidgets`添加到QT中，或者将两个模块添加到预定义的QT行中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After this modification, you need save the file and navigate to **Build** |
    **Run qmake** to load these new modules. Let''s edit the `mainwindow.ui` file
    of `CameraDemo` to add some widgets to use the camera by performing the following
    steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此修改后，您需要保存文件并导航到**构建** | **运行qmake**以加载这些新模块。让我们编辑`CameraDemo`的`mainwindow.ui`文件，通过以下步骤添加一些小部件来使用相机：
- en: Remove the status and menu bars. They will be re-added in the next sections.
    For now, they're removed for a cleaner user interface.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Widget** into the frame.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its name to `viewfinder`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `viewfinder` and select **Promote to …**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in `QCameraViewfinder` in the **Promoted class name** field. Remember to
    tick the **Global include** checkbox because this is a predefined Qt class. Click
    on **Add**, and then on **Promote**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **MainWindow** to **Lay Out Horizontally**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Vertical** layout on the right-hand side of `viewfinder`. Following
    this, components will be added to the layout.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **Label**, which is used to display the captured image. Note that, here
    we don't use `QGraphicsView`, simply because `QLabel` is good enough for this
    purpose and is much easier.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it as `previewLabel` and clear its text.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Combo Box** just beneath `previewLabel`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it as `cameraComboBox` since it'll be used to display all the available
    camera devices.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Push Button** named `captureButton` below `ComboBox` in the **Vertical**
    layout to let the user click to take a photo. This button should have the text
    `Capture` on it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should look like the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the camera in Qt](img/4615OS_04_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Now, go back to the `mainwindow.h` edit, as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As usual, in order to use the classes in the preceding code, we have to include
    them properly. In addition to this, we use `camList`, which is a type of `QList<QCameraInfo>`,
    to store the available camera devices. Since QList is a template class, we have
    to pass the type of list element, which is `QCameraInfo` in this case, to the
    constructor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: These private slots are responsible for the camera controls, namely, changing
    the camera device and clicking the capture button. Meanwhile, `onImageCaptured`
    is used to handle the `imageCaptured` signal of `QCameraImageCapture`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `maindow.cpp` file is shown as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's have a look at the constructor first. We give `camera` a `NULL` address
    to mark that there is no camera allocated and/or active. This is explained later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are overloaded signal functions for `QComboBox::currentIndexChanged`,
    you have to specify the signal that you want with `static_cast`. Otherwise, the
    compiler would complain and fail to compile. Only the new syntax statement of
    the signal and slot are affected, which means the old syntax statement, shown
    here, won''t pose any errors:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, as mentioned previously, the new syntax has many advantages and it's
    highly recommended that you replace the old one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: As we continue, we can fill in `camList` with the available cameras since `availableCameras`
    is a static member function of `QCameraInfo`, which returns a list of all available
    cameras on the system. Also, you can pass an argument to specify the camera position,
    such as the front or back camera, which is pretty useful on mobile platforms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add all the items in `camList` to our camera `combobox`. Here, it's
    the iterator that walks through the list and operates each one. Using iterators
    is very fast when dealing with a list, array, and so on. Qt supports this method,
    including both Java-style and STL-style iterators. In this case, we prefer and
    use STL-style iterators. The description function of `QCameraInfo` returns a human-readable
    description of the camera.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`camList`中的所有项目添加到我们的相机`combobox`中。在这里，迭代器遍历列表并对每个项目进行操作。在处理列表、数组等时，使用迭代器非常快。Qt支持这种方法，包括Java风格和STL风格的迭代器。在这种情况下，我们更喜欢并使用STL风格的迭代器。`QCameraInfo`的描述函数返回相机的可读描述。
- en: Now, let's go inside `onCameraChanged`. Before the construction of the camera,
    we need to check whether there is a camera present already. If there is, we stop
    the old camera. Then, we set up the `viewfinder` class using the `viewfinder`
    widget, which we did in the **Design** mode. After specifying the capture mode
    to `CaptureStillImage`, we can start the camera.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入`onCameraChanged`函数内部。在构建相机之前，我们需要检查是否已经存在相机。如果存在，我们停止旧的相机。然后，我们使用`viewfinder`小部件设置`viewfinder`类，这是我们之前在**设计**模式中做的。指定捕获模式为`CaptureStillImage`后，我们可以开始相机。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The camera cannot start again if it's not deallocated (stopped).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有释放（停止），相机将无法再次启动。
- en: Consequently, it goes to the `onCaptureButtonClicked` slot. Similarly, the `imgCapture`
    object is constructed by passing the `camera` and `this` arguments as its `QCamera`
    target and `QObject` parent respectively. Then, we have to connect the `imageCaptured`
    signal to the `onImageCaptured` slot of `MainWindow`. Now, let `camera->searchAndLock()`
    lock all the camera settings. This function is in response to the shutter button
    being half pressed. Before taking a shot, we set the capture destination to the
    file. Although it can be set to a buffer using the `QCameraImageCapture::CaptureToBuffer`
    flag if needed, bear in mind that it's not supported on all platforms.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它进入`onCaptureButtonClicked`槽。同样，`imgCapture`对象通过传递`camera`和`this`作为其`QCamera`目标和`QObject`父对象来构造。然后，我们必须将`imageCaptured`信号连接到`MainWindow`的`onImageCaptured`槽。现在，让`camera->searchAndLock()`锁定所有相机设置。这个函数是对快门按钮半按的响应。在拍照之前，我们将捕获目标设置为文件。如果需要，可以使用`QCameraImageCapture::CaptureToBuffer`标志将其设置为缓冲区，但请注意，这并不是所有平台都支持的。
- en: If everything goes well, an image will be captured by `camera` and the `imageCaptured`
    signal will be emitted. Then, the `onImageCaptured` slot function will be executed.
    Inside this function, we scale the captured image to the size of our `previewLabel`.
    Then, just set `QPixmap` for `previewLabel` and unlock `camera`. In the end, we
    call the `deleteLater()` function to safely delete the `imgCapture` instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，`camera`将捕获一张图片，并发出`imageCaptured`信号。然后，将执行`onImageCaptured`槽函数。在这个函数内部，我们将捕获的图片缩放到`previewLabel`的大小。然后，只需为`previewLabel`设置`QPixmap`并解锁`camera`。最后，我们调用`deleteLater()`函数来安全地删除`imgCapture`实例。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should explicitly indicate `Qt::KeepAspectRatio`, otherwise it uses the
    default `Qt::IgnoreAspectRatio` flag.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该明确指出`Qt::KeepAspectRatio`，否则它将使用默认的`Qt::IgnoreAspectRatio`标志。
- en: Now, run the demo and see what you get.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行演示并查看你得到的结果。
- en: '![Accessing the camera in Qt](img/4615OS_04_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![在Qt中访问相机](img/4615OS_04_03.jpg)'
- en: Just as we did in the previous chapters, feel free to change the window's title,
    application font, and so on. These trivial tweaks won't be detailed anymore.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的章节中所做的那样，你可以随意更改窗口标题、应用程序字体等。这些微小的调整将不再详细说明。
- en: Controlling the camera
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制相机
- en: The `QCameraFocus` class is mentioned to control the zoom and focus of the camera.
    Speaking of zoom, Qt supports both optical and digital zoom. As we all know, optical
    zoom offers a better quality than digital. Hence, optical zoom should take priority
    over digital.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`QCameraFocus`类被提及以控制相机的缩放和聚焦。说到缩放，Qt支持光学和数字缩放。众所周知，光学缩放的质量优于数字缩放。因此，光学缩放应优先于数字缩放。'
- en: Drag a horizontal slider and a label to **MainWindow** pane's `verticalLayout`
    just above the capture button. Name them `zoomSlider` and `zoomLabel`, respectively.
    Remember to change the text of `zoomLabel` to `Zoom` and `Horizontal` in `alignment`
    to `AlignHCenter`. Since Qt doesn't provide a floating point number slider, we
    simply multiply `10` to get an integer in the slider. Hence, change the `minimum`
    value of `zoomSlider` to `10`, which means zoom by 1.0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个水平滑块和一个标签拖到 **MainWindow** 面板的 `verticalLayout` 中，位于捕获按钮上方。分别命名为 `zoomSlider`
    和 `zoomLabel`。记得将 `zoomLabel` 的文本改为 `Zoom`，并将 `alignment` 中的文本改为 `AlignHCenter`。由于
    Qt 不提供浮点数滑块，我们简单地乘以 `10` 以在滑块中得到一个整数。因此，将 `zoomSlider` 的 `minimum` 值改为 `10`，这意味着缩放
    1.0。
- en: 'Include `QCameraFocus` in `mainwindow.h` and add these two private members:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mainwindow.h` 中包含 `QCameraFocus` 并添加这两个私有成员：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Not every camera supports zoom. If it doesn't, the maximum zoom is 1.0, which
    applies to both optical and digital zoom.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个相机都支持缩放。如果不支持，最大缩放为 1.0，适用于光学和数字缩放。
- en: There is a type named `qreal`, which is basically a `double` value. It was `float`
    on the ARM platforms for performance concerns and `double` on others. However,
    Qt has used `double` on ARM by default since the Qt 5.2 version. Anyway, using
    `qreal` is recommended if the application is deployed on different hardware platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个名为 `qreal` 的类型，它基本上是一个 `double` 值。出于性能考虑，在 ARM 平台上它是 `float`，而在其他平台上是 `double`。然而，从
    Qt 5.2 版本开始，Qt 默认在 ARM 上使用 `double`。无论如何，如果应用程序部署在不同的硬件平台上，建议使用 `qreal`。
- en: 'A new slot also needs to be declared:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要声明一个新的插槽：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, connect `zoomSlider` in the `MainWindow` class'' constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `MainWindow` 类的构造函数中连接 `zoomSlider`：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, `QCameraFocus` can''t be constructed explicitly. Instead, it can only
    be retrieved from the `QCamera` class. So, we get `cameraFocus` just after the
    construction of the `camera` argument inside `onCameraChanged`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`QCameraFocus` 不能显式构造。相反，它只能从 `QCamera` 类中检索。因此，我们在 `onCameraChanged` 中 `camera`
    参数构造之后获得 `cameraFocus`：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, set up `maximumOptZoom` and the `maximum` value of `zoomSlider`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置 `maximumOptZoom` 和 `zoomSlider` 的 `maximum` 值：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the camera doesn''t support zoom at all, the slider won''t be able to slide.
    The definition of the `onZoomChanged` slot is shown in the following lines:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相机根本不支持缩放，滑块将无法滑动。`onZoomChanged` 插槽的定义如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the first parameter of `zoomTo` is the optical zoom factor while
    the other is the digital zoom factor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`zoomTo` 的第一个参数是光学缩放因子，而另一个是数字缩放因子。
- en: Displaying errors on the status bar
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在状态栏上显示错误
- en: First of all, there could be errors during the whole camera process and it's
    a good practice to make the user aware of what the error is. It can be done by
    a pop-up dialog and/or status bar. You don't want to alert the user to every trivial
    error. Therefore, it'd be better to use a pop-up dialog only for critical errors,
    while displaying non-critical errors and warnings on the status bar.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，整个相机过程中可能会出现错误，让用户了解错误是什么是一个好的做法。可以通过弹出对话框和/或状态栏来实现。你不想提醒用户每个琐碎的错误。因此，最好只对关键错误使用弹出对话框，而在状态栏上显示非关键错误和警告。
- en: Qt began supporting the status bar a long time ago. The `QStatusBar` class is
    the one that provides a horizontal bar suitable for presenting status information.
    The status of the camera can be displayed as well and it'll be introduced in later
    topics.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 很早就开始支持状态栏了。`QStatusBar` 类是提供适合展示状态信息的水平栏。相机的状态也可以显示，这将在后续主题中介绍。
- en: To use the status bar, edit `mainwindow.ui`, right-click on `MainWindow`, and
    select **Create Status Bar** if it doesn't exist or was previously removed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用状态栏，编辑 `mainwindow.ui`，右键单击 `MainWindow`，如果不存在或之前已删除，则选择 **Create Status
    Bar**。
- en: 'Then, we should declare two slots to handle the camera and image capture errors,
    respectively. Add these two lines to `private slots` in `mainwindow.h`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该声明两个插槽来分别处理相机和图像捕获错误。将这两行添加到 `mainwindow.h` 中的 `private slots`：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The definitions in `mainwindow.cpp` are shown as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainwindow.cpp` 中的定义如下所示：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This simply makes `statusBar` show a temporary message for five seconds. Even
    if you pass zero to `showMessage`, it's still a temporary message. In later cases,
    it won't disappear after a given period; instead, it'll disappear if there is
    a new temporary message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是让 `statusBar` 显示一个持续五秒钟的临时消息。即使你传递零给 `showMessage`，它仍然是一个临时消息。在后续情况下，它不会在给定时间段后消失；相反，如果有新的临时消息，它才会消失。
- en: Since the signal error is different in `QCamera` from `QCameraImageCapture`,
    we use different slots to handle it. For `QCamera`, the `error` signal function
    has `QCamera::Error` as the only argument.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `QCameraImageCapture::error` provides three arguments: `int`,
    `QCameraImageCapture::Error`, and a `const QString` reference. Therefore, we can
    make use of this signal by using its error `string` directly.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to connect the signals and slots. Here, inside the `onCameraChanged`
    function, just after the `camera` construction, connect the `camera` error and
    the `onCameraError` slot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As there is another overloaded function called `error` in the `QCamera` class,
    we have to use `static_cast` to specify the signal function, as we did in `QComboBox`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, add the `connect` statement after the `imgCapture` object's construction
    in the `onCaptureButtonClicked` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is another overloaded `error` signal function. However, it's tedious because
    of three arguments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Permanent widgets in the status bar
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want a sort of indicator inside the status bar to display real-time
    status, such as the camera status. This is inappropriate if it's covered by temporary
    messages. In such a case, `QStatusBar` provides the `insertPermanentWidget` function
    to add a widget to the status bar permanently. It means that it won't be obscured
    by temporary messages and is located on the far right of the status bar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s make a camera status widget. Add a new C++ class named `CameraStatusWidget`
    that inherits from `QWidget`, but use `QLabel` as the base class. We use `QLabel`
    as the base class because the status of the camera is displayed in text and is
    basically a customized label widget. The `camerastatuswidget.h` content is shown
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Besides the `#include <QCamera>`, we only add a declaration of the `onCameraStatusChanged`
    slot to this header file. The relevant `camerastatuswidget.cpp` source file is
    pasted as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always handle exceptions in the `switch` statements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`QCamera::Status` is an `enum` type. That''s why we have to use a `switch`
    statement to `translate` the status to `string`. Since we have our camera status
    widget now, it''s time to add it to the status bar. Edit `mainwindow.h` and add
    a `CameraStatusWidget` pointer as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Don''t forget to include the `camerastatuswidget.h` header file. Then, set
    up `camStatusWid` just after `ui->setupUi(this)` by adding the following lines:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Navigate to the `onCameraChanged` function; we need to connect the `QCamera::statusChanged`
    signal. Just add the following line after construction of the camera:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Likewise, we can add current zoom to the status bar. In fact, for this small
    and easy-to-do widget, we don''t need to create a new class. Instead, we''ll use
    the existing `QLabel` class to achieve this by declaring a new member. In `mainwindow.h`,
    add a new private member:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Meanwhile, construct and insert the `zoomStatus` into `statusBar` in the `MainWindow`
    class constructor in `mainwindow.cpp`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we use a `number` function, which is a static public function of the
    `QString` class to convert a number (it can be `double` or `integer`) to `QString`.
    In order to update `zoomStatus` in time, append this line to the `onZoomChanged`
    function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After these modifications, the application will run as shown in the following
    screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Permanent widgets in the status bar](img/4615OS_04_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Utilizing the menu bar
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have finished the bar at the bottom, it's time to begin the one
    on top—the menu bar. Similar to the status bar, right-click on `MainWindow` in
    the **Design** mode, and select **Create Menu Bar** if it doesn't exist or was
    previously removed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Then, just follow the hints. Add a **File** menu containing the **Exit** action.
    Another menu could be **About**, which contains the **About CameraDemo** action.
    You should know that these actions are able to change in the **Action Editor**
    panel, which is in the same place as **Signals & Slots Editor**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the menu bar](img/4615OS_04_05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, the names of these actions are changed
    to `actionAbout` and `actionExit`, respectively. In addition to this, there is
    a shortcut, *Ctrl* + *Q,* for `actionExit`. Just double-click on the action and
    add shortcuts by pressing the shortcut you want. This is shown in the following
    screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the menu bar](img/4615OS_04_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: We already used `QMenu` and `QAction` in [Chapter 2](ch02.xhtml "Chapter 2. Building
    a Beautiful Cross-platform Clock"), *Building a Beautiful Cross-platform Clock*.
    The difference here is that you use `QMenu` as the menu bar, and set it up it
    in **Design** mode instead of writing code. But why is it called `QAction`? This
    is because the user can trigger a command on the menu, tool bar, or keyboard shortcut.
    They expect the same behavior regardless of where it is. Therefore, it should
    be abstracted into an action, which can be inserted into the menu or tool bar.
    You can set it to the checkable `QAction` option and use it as a simple `QCheckbox`
    option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish `actionExit` first, since it''s simpler than the other one. For
    `actionExit`, we only need one `connect` statement to make it work. Add the following
    statement to the `MainWindow` class constructor in the `mainwindow.cpp` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `triggered` signal will be emitted by either a mouse click or a keyboard
    shortcut (if there is a shortcut). Since we connect it to the `close` slot of
    `MainWindow`, it'll close `MainWindow`, which results in exiting the entire application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, we need to declare a slot to fulfill the connection with `actionAbout`.
    As usual, declare it in the `mainwindow.h` header file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You may think that we''re going to create a new class just to show an **About**
    dialog. Well, we don''t have to cook the **About** dialog ourselves because Qt
    has already done this for us. It''s included in `QMessageBox`, so you should include
    it with the following line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the definition of the slot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QMessageBox` class provides a modal dialog for informing or asking the
    user a question and receiving an answer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Almost every kind of pop-up dialog can be found in `QMessageBox`. Here, we use
    the static `About` function to create an **About** dialog. It has three arguments.
    The first one is the parent `QObject` pointer, followed by the title and context.
    Remember to connect the signal and slot in the `MainWindow` class constructor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you compile and run the application again, try to trigger the **About**
    dialog, which would look similar to the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the menu bar](img/4615OS_04_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to `About`, there are other useful static public members of `QMessageBox`.
    Most commonly, `critical`, `information`, `question`, and, `warning` are used
    to pop up a message box. Sometimes, you'll see an **About Qt** entry in the menu
    bar, which is to call the `aboutQt` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the **About** dialog will display an icon if it exists. There is an
    empty space since it lacks an icon. The order of the search icons is shown as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This first icon will be `parent->icon()`, if it exists.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second icon will be the top-level widget, which contains `parent`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third icon will be the active window.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth icon will be the `Information` icon.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using QFileDialog
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step of taking a photo is to save it to disk. At this point, the program
    saves an image to the file, but the location is determined by the camera backend.
    We can simply use a dialog, letting the user choose the directory and the filename
    of the photo. There is a `QFileDialog` class to help make the work easier. The
    easiest way to create a `QFileDialog` class is to use the static functions. Therefore,
    edit the `onCaptureButtonClicked` function in the `mainwindow.cpp` file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we''re using the `getSaveFileName` static function to create a file dialog
    to return the file that the user selected. If the user clicks on **Cancel**, the
    `location` type would be an empty `QString` reference and the image will be stored
    in a default location. The file doesn''t need to exist. In fact, if it exists,
    there will be an overwrite dialog. This function''s prototype is pasted as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first argument is the `QObject` parent, as usual. The second one is the
    dialog''s title, followed by the default directory. The `filter` object is used
    to restrict the file type and it''s possible to use multiple filters that are
    separated by two semicolons, `;;`. Here is an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Setting `selectedFilter` can change the default filter. Lastly, `Options` is
    used to define the behaviors of the file dialog. For more details, refer to the
    `QFileDialog` documentation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: QML camera
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML相机
- en: So far, we talked about how to access and control the camera in Qt/C++. Now
    it's time to see how QML does in this area. Although there are some limitations,
    you'll find it's much easier and more elegant to do this in Qt Quick/QML because
    of the many packages that Qt has to offer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何在Qt/C++中访问和控制相机。现在是时候看看QML在这个领域的表现了。尽管有一些限制，但你会发现，由于Qt提供了许多包，使用Qt
    Quick/QML来做这件事要容易得多，也更优雅。
- en: 'Create a new Qt Quick application project. The `main.qml` content is shown
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Qt Quick应用程序项目。`main.qml`的内容如下所示：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let me walk you through this one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带你了解这个。
- en: '`Camera` and `VideoOutput` are provided by the `QtMultimedia` module. Similar
    to the Qt/C++ classes, the `Camera` type is identical to the `QCamera` class.
    The preview is dealt with differently when `VideoOutput` is used as `viewfinder`.
    An `image` object is used to display the captured photo and it''s only visible
    for 2 seconds each time a picture is taken. This `photoPreview` is controlled
    by the timer, `previewTimer`. In other words, the 2 seconds show up of `photoPreview`
    depends on this `previewTimer` timer. At the same time, the `camera` type''s `imageCapture`
    will provide the `preview` image to `photoPreview` and turn on `previewTimer`
    once it captures a photo.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`和`VideoOutput`由`QtMultimedia`模块提供。与Qt/C++类类似，`Camera`类型与`QCamera`类相同。当使用`VideoOutput`作为取景器时，预览的处理方式不同。一个`image`对象用于显示捕获的图片，并且每次拍照时只可见2秒钟。这个`photoPreview`由计时器`previewTimer`控制。换句话说，`photoPreview`的2秒显示取决于这个`previewTimer`计时器。同时，`camera`类型的`imageCapture`将提供`preview`图像给`photoPreview`，并在捕获照片时启动`previewTimer`。'
- en: 'The last piece is `CaptureButton`, which is not provided by Qt but written
    in another file, `CaptureButton.qml`. Its content is shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分是`CaptureButton`，它不是由Qt提供的，而是在另一个文件`CaptureButton.qml`中编写的。其内容如下所示：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since there is no circular shape provided by Qt Quick, we use this `Rectangle`
    object as a workaround to display it as a circle. Just like what we did in the
    previous chapter, define a `diameter` property to hold both `height` and `width`.
    The trick is the radius value. By setting it to half the diameter, this `Rectangle`
    object becomes circular. Last but not least, add `MouseArea` to respond to a user's
    click. It's a pity that `MouseArea` can't be circular, so just leave it and fill
    in the button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Qt Quick没有提供圆形形状，我们使用这个`Rectangle`对象作为替代方案来显示圆形。就像我们在上一章所做的那样，定义一个`diameter`属性来同时持有`height`和`width`。关键在于半径值。通过将其设置为直径的一半，这个`Rectangle`对象就变成了圆形。最后但同样重要的是，添加`MouseArea`来响应用户的点击。遗憾的是，`MouseArea`不能是圆形的，所以只需留下它并填写按钮。
- en: 'Now you can run your application, and it should be something similar to this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行你的应用程序，它应该类似于以下内容：
- en: '![QML camera](img/4615OS_04_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![QML相机](img/4615OS_04_08.jpg)'
- en: It's not as powerful as the Qt/C++ demo. The first thing you probably notice
    is that you can't change the camera device. It's missing in the current version
    of Qt, but it should be supported in the future. In the meantime, the only solution
    to this is to write a C++ plugin while the main part is still written in QML.
    Since developing a C++ plugin for QML will be covered in a later chapter, we'll
    simply skip this part here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它不如Qt/C++演示强大。你可能首先注意到的是，你不能更改相机设备。在当前版本的Qt中缺少这一功能，但未来应该会支持。与此同时，唯一的解决方案是在主部分仍然是QML编写的同时编写一个C++插件。由于在后面的章节中会介绍如何为QML开发C++插件，所以我们在这里简单地跳过这一部分。
- en: 'We can make the file dialog in QML in an even more elegant way. Qt Quick provides
    commonly-used dialogs through the `QtQuick.Dialogs` module. Therefore, first import
    this module:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在QML中以一种更加优雅的方式制作文件对话框。Qt Quick通过`QtQuick.Dialogs`模块提供了常用的对话框。因此，首先导入这个模块：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What're we interested in is the `FileDialog` type, which provides a basic file
    chooser. It allows the user to select existing files and/or directories, or create
    new filenames. It uses the native platform file dialogs wherever possible. To
    use this type, add `FileDialog` inside `ApplicationWindow` in the `main.qml` file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是`FileDialog`类型，它提供了一个基本的文件选择器。它允许用户选择现有的文件和/或目录，或创建新的文件名。它尽可能使用原生平台的文件对话框。要使用此类型，请在`main.qml`文件中的`ApplicationWindow`内添加`FileDialog`。
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `string` type in QML is an extended version of the JavaScript `string` type.
    Wherever possible, you should avoid the `var` keyword and use the exact type,
    such as `int`, `double`, and `string`. According to the QML documentation, this
    will improve performance since the machine doesn't need to guess the data type.
    Here, we declare `location`, which is a `string` type, while the rest of its properties
    are similar to the dialog settings in Qt/C++, its `title` (caption), and `nameFilters`.
    You should set the `selectExisting` property to `false`, as it is `true` by default.
    Otherwise, it'll behave like an open file dialog.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `onAccepted` handler, pass the `fileUrl` value to `location` first.
    This handler is the response to the `accepted` signal, which is emitted if the
    user selects a file successfully. The `fileUrl` property will then be changed.
    It's in a URI format, which has an extra `file:///` prefix. In addition to this,
    there is currently an issue if we execute `slice` on `fileUrl` directly. So as
    a workaround, we use the explicitly declared `string location` to invoke the `slice`
    function. This is a JavaScript function, which will return a new `string` type
    that contains the extracted parts of a string. The `slice` method's prototype
    is `slice(start,end)` where `end` will be the end of the `string` type if it's
    omitted. Also, note that the character at the `start` position is included and
    the index starts from zero. After that, we simply call the `captureToLocation`
    function of `imageCapture` to store the image at the selected location.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make it work, we have to change the behavior of `CaptureButton`.
    Edit the `CaptureButton.qml` file and change `MouseArea`, as shown in the following
    lines:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In addition to this, to change the `onClicked` handler, we also add `onPressed`
    and `onReleased` to let it have the push effect. As you can see, the `open()`
    function will execute our `FileDialog`. On a desktop operating system, such as
    Windows, the platform file dialog is used as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![QML camera](img/4615OS_04_09.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: The inner circle of `CaptureButton` will become black once it's pressed, and
    then go back to blue when the mouse is released. Although it's just a minor visual
    effect, it definitely improves the user experience.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*"Do not fail to commit an act of kindness just because it is small in scale."*'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To complete this QML camera application, we need to add a zoom control as we
    did for the Qt/C++ camera. Add a new QML file named `ZoomControl.qml`, whose content
    is shown as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we declare `property` of the `real` type to store the current zoom, whose
    initial value is the camera's current zoom, which is itself the multiplication
    of the current digital and optical zoom. This is followed by a JavaScript-style
    function, `zoomControl`. As mentioned before, you can use JavaScript in QML anywhere
    seamlessly. This function is identical to the Qt/C++ slot, `onZoomChanged`, in
    the previous topic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is a `Text` element used to display the current `zoom` function
    on screen. These are just some visual customizations inside the `Text` element,
    which include centering in the parent by setting both the horizontal and vertical
    alignments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有一个 `Text` 元素用于在屏幕上显示当前的 `zoom` 函数。这些只是在 `Text` 元素内部的一些视觉自定义，包括通过设置水平和垂直对齐来在父元素中居中。
- en: What's next is a `Timer` element that controls the visibility of `Text`, similar
    to the controller of `photoPreview`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个控制 `Text` 可见性的 `Timer` 元素，类似于 `photoPreview` 的控制器。
- en: The last but also the trickiest is `MouseArea`. We use the mouse wheel to control
    the zoom, so the handler that can get the wheel event is `onWheel`. The `wheel.angleDelta.y`
    is the wheel, which is rotated to a vertical orientation. If it's positive, it
    goes up; otherwise, it goes down. It zooms in with a positive value, and zooms
    out with negative one. You have to ensure that the new zoom is within the supported
    zoom range of `camera` before invoking the `zoomControl` function. After this,
    let the `Text` indicator display `zoom` and turn on `Timer` so that it's only
    visible for 2 seconds. You can also see that there is a built-in function for
    the `real` element to convert it to `string`, just like the `QString::number`
    function in Qt/C++.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但也是最复杂的是 `MouseArea`。我们使用鼠标滚轮来控制缩放，因此可以获取滚轮事件的处理器是 `onWheel`。`wheel.angleDelta.y`
    是滚轮，它被旋转到垂直方向。如果是正数，它向上移动；否则，它向下移动。正数值用于放大，负数用于缩小。在调用 `zoomControl` 函数之前，你必须确保新的缩放值在
    `camera` 支持的缩放范围内。之后，让 `Text` 指示器显示 `zoom` 并打开 `Timer` 以使其仅在 2 秒内可见。你还可以看到有一个内置函数可以将
    `real` 元素转换为 `string`，就像 Qt/C++ 中的 `QString::number` 函数一样。
- en: 'After all this, edit `main.qml` and add `ZoomControl` to the application, as
    shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些之后，编辑 `main.qml` 并将 `ZoomControl` 添加到应用程序中，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Be aware that `ZoomControl` should fill in `viewfinder` instead of `parent`;
    otherwise, it may get overlaid by other components, such as `viewfinder`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ZoomControl` 应该填充 `viewfinder` 而不是 `parent`；否则，它可能被其他组件，如 `viewfinder`，覆盖。
- en: Give this QML camera a test run and compare which one is better.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个 QML 相机进行测试运行，并比较哪个更好。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By the end of this chapter, you should be able to write applications that can
    access camera devices in either Qt/C++ or QML. What's more is that you should
    be able to utilize the status and menu bar in traditional desktop applications,
    which are historically important and continue to play a crucial role as interactive
    functional widgets. In addition to this, don't forget the file dialog and message
    box since they make your coding work easier. In the next chapter, we're going
    to talk about an advanced topic, plugins, which is a popular way to extend large
    applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够编写能够访问 Qt/C++ 或 QML 中的相机设备的应用程序。更重要的是，你应该能够利用传统桌面应用程序中的状态栏和菜单栏，这些在历史上非常重要，并且继续作为交互式功能小部件发挥关键作用。此外，别忘了文件对话框和消息框，因为它们使你的编码工作变得更简单。在下一章中，我们将讨论一个高级主题，即插件，这是扩展大型应用程序的流行方式。
