- en: Chapter 4. Controlling Camera and Taking Photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through this chapter, you''ll find how easy it is to access and control a camera
    with Qt. The example in this chapter also demonstrates how to utilize the status
    bar and menu bar. In addition to the traditional Qt Widget applications, there
    is a QML camera example, which does the same thing as Qt/C++ but in a more elegant
    way. The following topics, which are covered in this chapter, will extend your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the camera in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying errors in the status bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the permanent widgets in the status bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the menu bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `QFileDialog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the QML Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the camera in Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we won't talk about the technical details of how a camera works, the
    overview of the implementation of a camera in Qt will be covered. Support for
    a camera is included in Qt Multimedia, which is a module that provides a rich
    set of QML types and C++ classes to handle multimedia content. Things such as
    audio playback, camera, and radio functionality are shown. To complement this,
    the Qt Multimedia Widgets module provides widget-based multimedia classes to make
    the work easier.
  prefs: []
  type: TYPE_NORMAL
- en: There are some classes to help us deal with the camera. For instance, `viewfinder`
    lets a user look through the camera to compose, and in many cases focus, the picture.
    In Qt/C++, you can use `QGraphicsView` along with `QGraphicsVideoItem` to do this
    job. `QGraphicsView` provides a widget to display the contents of `QGraphicsScene`.
    In this case, `QGraphicsVideoItem` is an item of the scene. This view-scene-item
    is the **Graphics View Framework**. For details on this concept, visit [http://doc.qt.io/qt-5/graphicsview.html](http://doc.qt.io/qt-5/graphicsview.html).
    In this example, we use `QCameraViewfinder`, which is the dedicated `viewfinder`
    class and is simpler and more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: To capture a photo, we need to use the `QCameraImageCapture` class, which records
    the media content, while the focus and zoom are managed by the `QCameraFocus`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all, `QCamera` plays a core role in this process. The `QCamera` class
    provides an interface to access the camera devices, including webcams and mobile
    device cameras. There is another class, `QCameraInfo`, which can list all the
    available camera devices and choose which one to use. The following diagram will
    help you understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the camera in Qt](img/4615OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see a demonstration, create a new Qt Widget Application project named `CameraDemo`.
    Edit the `CameraDemo.pro` file. Add multimedia `multimediawidgets` to QT by appending
    a line, as shown here, or add two modules to the predefined QT line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After this modification, you need save the file and navigate to **Build** |
    **Run qmake** to load these new modules. Let''s edit the `mainwindow.ui` file
    of `CameraDemo` to add some widgets to use the camera by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the status and menu bars. They will be re-added in the next sections.
    For now, they're removed for a cleaner user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Widget** into the frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its name to `viewfinder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `viewfinder` and select **Promote to …**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in `QCameraViewfinder` in the **Promoted class name** field. Remember to
    tick the **Global include** checkbox because this is a predefined Qt class. Click
    on **Add**, and then on **Promote**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **MainWindow** to **Lay Out Horizontally**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Vertical** layout on the right-hand side of `viewfinder`. Following
    this, components will be added to the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **Label**, which is used to display the captured image. Note that, here
    we don't use `QGraphicsView`, simply because `QLabel` is good enough for this
    purpose and is much easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it as `previewLabel` and clear its text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Combo Box** just beneath `previewLabel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it as `cameraComboBox` since it'll be used to display all the available
    camera devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Push Button** named `captureButton` below `ComboBox` in the **Vertical**
    layout to let the user click to take a photo. This button should have the text
    `Capture` on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the camera in Qt](img/4615OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go back to the `mainwindow.h` edit, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As usual, in order to use the classes in the preceding code, we have to include
    them properly. In addition to this, we use `camList`, which is a type of `QList<QCameraInfo>`,
    to store the available camera devices. Since QList is a template class, we have
    to pass the type of list element, which is `QCameraInfo` in this case, to the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: These private slots are responsible for the camera controls, namely, changing
    the camera device and clicking the capture button. Meanwhile, `onImageCaptured`
    is used to handle the `imageCaptured` signal of `QCameraImageCapture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `maindow.cpp` file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a look at the constructor first. We give `camera` a `NULL` address
    to mark that there is no camera allocated and/or active. This is explained later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are overloaded signal functions for `QComboBox::currentIndexChanged`,
    you have to specify the signal that you want with `static_cast`. Otherwise, the
    compiler would complain and fail to compile. Only the new syntax statement of
    the signal and slot are affected, which means the old syntax statement, shown
    here, won''t pose any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, as mentioned previously, the new syntax has many advantages and it's
    highly recommended that you replace the old one.
  prefs: []
  type: TYPE_NORMAL
- en: As we continue, we can fill in `camList` with the available cameras since `availableCameras`
    is a static member function of `QCameraInfo`, which returns a list of all available
    cameras on the system. Also, you can pass an argument to specify the camera position,
    such as the front or back camera, which is pretty useful on mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add all the items in `camList` to our camera `combobox`. Here, it's
    the iterator that walks through the list and operates each one. Using iterators
    is very fast when dealing with a list, array, and so on. Qt supports this method,
    including both Java-style and STL-style iterators. In this case, we prefer and
    use STL-style iterators. The description function of `QCameraInfo` returns a human-readable
    description of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go inside `onCameraChanged`. Before the construction of the camera,
    we need to check whether there is a camera present already. If there is, we stop
    the old camera. Then, we set up the `viewfinder` class using the `viewfinder`
    widget, which we did in the **Design** mode. After specifying the capture mode
    to `CaptureStillImage`, we can start the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The camera cannot start again if it's not deallocated (stopped).
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, it goes to the `onCaptureButtonClicked` slot. Similarly, the `imgCapture`
    object is constructed by passing the `camera` and `this` arguments as its `QCamera`
    target and `QObject` parent respectively. Then, we have to connect the `imageCaptured`
    signal to the `onImageCaptured` slot of `MainWindow`. Now, let `camera->searchAndLock()`
    lock all the camera settings. This function is in response to the shutter button
    being half pressed. Before taking a shot, we set the capture destination to the
    file. Although it can be set to a buffer using the `QCameraImageCapture::CaptureToBuffer`
    flag if needed, bear in mind that it's not supported on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes well, an image will be captured by `camera` and the `imageCaptured`
    signal will be emitted. Then, the `onImageCaptured` slot function will be executed.
    Inside this function, we scale the captured image to the size of our `previewLabel`.
    Then, just set `QPixmap` for `previewLabel` and unlock `camera`. In the end, we
    call the `deleteLater()` function to safely delete the `imgCapture` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should explicitly indicate `Qt::KeepAspectRatio`, otherwise it uses the
    default `Qt::IgnoreAspectRatio` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the demo and see what you get.
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the camera in Qt](img/4615OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just as we did in the previous chapters, feel free to change the window's title,
    application font, and so on. These trivial tweaks won't be detailed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `QCameraFocus` class is mentioned to control the zoom and focus of the camera.
    Speaking of zoom, Qt supports both optical and digital zoom. As we all know, optical
    zoom offers a better quality than digital. Hence, optical zoom should take priority
    over digital.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a horizontal slider and a label to **MainWindow** pane's `verticalLayout`
    just above the capture button. Name them `zoomSlider` and `zoomLabel`, respectively.
    Remember to change the text of `zoomLabel` to `Zoom` and `Horizontal` in `alignment`
    to `AlignHCenter`. Since Qt doesn't provide a floating point number slider, we
    simply multiply `10` to get an integer in the slider. Hence, change the `minimum`
    value of `zoomSlider` to `10`, which means zoom by 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include `QCameraFocus` in `mainwindow.h` and add these two private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not every camera supports zoom. If it doesn't, the maximum zoom is 1.0, which
    applies to both optical and digital zoom.
  prefs: []
  type: TYPE_NORMAL
- en: There is a type named `qreal`, which is basically a `double` value. It was `float`
    on the ARM platforms for performance concerns and `double` on others. However,
    Qt has used `double` on ARM by default since the Qt 5.2 version. Anyway, using
    `qreal` is recommended if the application is deployed on different hardware platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new slot also needs to be declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, connect `zoomSlider` in the `MainWindow` class'' constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `QCameraFocus` can''t be constructed explicitly. Instead, it can only
    be retrieved from the `QCamera` class. So, we get `cameraFocus` just after the
    construction of the `camera` argument inside `onCameraChanged`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set up `maximumOptZoom` and the `maximum` value of `zoomSlider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the camera doesn''t support zoom at all, the slider won''t be able to slide.
    The definition of the `onZoomChanged` slot is shown in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first parameter of `zoomTo` is the optical zoom factor while
    the other is the digital zoom factor.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying errors on the status bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, there could be errors during the whole camera process and it's
    a good practice to make the user aware of what the error is. It can be done by
    a pop-up dialog and/or status bar. You don't want to alert the user to every trivial
    error. Therefore, it'd be better to use a pop-up dialog only for critical errors,
    while displaying non-critical errors and warnings on the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: Qt began supporting the status bar a long time ago. The `QStatusBar` class is
    the one that provides a horizontal bar suitable for presenting status information.
    The status of the camera can be displayed as well and it'll be introduced in later
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: To use the status bar, edit `mainwindow.ui`, right-click on `MainWindow`, and
    select **Create Status Bar** if it doesn't exist or was previously removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we should declare two slots to handle the camera and image capture errors,
    respectively. Add these two lines to `private slots` in `mainwindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The definitions in `mainwindow.cpp` are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This simply makes `statusBar` show a temporary message for five seconds. Even
    if you pass zero to `showMessage`, it's still a temporary message. In later cases,
    it won't disappear after a given period; instead, it'll disappear if there is
    a new temporary message.
  prefs: []
  type: TYPE_NORMAL
- en: Since the signal error is different in `QCamera` from `QCameraImageCapture`,
    we use different slots to handle it. For `QCamera`, the `error` signal function
    has `QCamera::Error` as the only argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `QCameraImageCapture::error` provides three arguments: `int`,
    `QCameraImageCapture::Error`, and a `const QString` reference. Therefore, we can
    make use of this signal by using its error `string` directly.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to connect the signals and slots. Here, inside the `onCameraChanged`
    function, just after the `camera` construction, connect the `camera` error and
    the `onCameraError` slot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As there is another overloaded function called `error` in the `QCamera` class,
    we have to use `static_cast` to specify the signal function, as we did in `QComboBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, add the `connect` statement after the `imgCapture` object's construction
    in the `onCaptureButtonClicked` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is another overloaded `error` signal function. However, it's tedious because
    of three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Permanent widgets in the status bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want a sort of indicator inside the status bar to display real-time
    status, such as the camera status. This is inappropriate if it's covered by temporary
    messages. In such a case, `QStatusBar` provides the `insertPermanentWidget` function
    to add a widget to the status bar permanently. It means that it won't be obscured
    by temporary messages and is located on the far right of the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s make a camera status widget. Add a new C++ class named `CameraStatusWidget`
    that inherits from `QWidget`, but use `QLabel` as the base class. We use `QLabel`
    as the base class because the status of the camera is displayed in text and is
    basically a customized label widget. The `camerastatuswidget.h` content is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the `#include <QCamera>`, we only add a declaration of the `onCameraStatusChanged`
    slot to this header file. The relevant `camerastatuswidget.cpp` source file is
    pasted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always handle exceptions in the `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '`QCamera::Status` is an `enum` type. That''s why we have to use a `switch`
    statement to `translate` the status to `string`. Since we have our camera status
    widget now, it''s time to add it to the status bar. Edit `mainwindow.h` and add
    a `CameraStatusWidget` pointer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to include the `camerastatuswidget.h` header file. Then, set
    up `camStatusWid` just after `ui->setupUi(this)` by adding the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `onCameraChanged` function; we need to connect the `QCamera::statusChanged`
    signal. Just add the following line after construction of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can add current zoom to the status bar. In fact, for this small
    and easy-to-do widget, we don''t need to create a new class. Instead, we''ll use
    the existing `QLabel` class to achieve this by declaring a new member. In `mainwindow.h`,
    add a new private member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, construct and insert the `zoomStatus` into `statusBar` in the `MainWindow`
    class constructor in `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use a `number` function, which is a static public function of the
    `QString` class to convert a number (it can be `double` or `integer`) to `QString`.
    In order to update `zoomStatus` in time, append this line to the `onZoomChanged`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After these modifications, the application will run as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Permanent widgets in the status bar](img/4615OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Utilizing the menu bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have finished the bar at the bottom, it's time to begin the one
    on top—the menu bar. Similar to the status bar, right-click on `MainWindow` in
    the **Design** mode, and select **Create Menu Bar** if it doesn't exist or was
    previously removed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, just follow the hints. Add a **File** menu containing the **Exit** action.
    Another menu could be **About**, which contains the **About CameraDemo** action.
    You should know that these actions are able to change in the **Action Editor**
    panel, which is in the same place as **Signals & Slots Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the menu bar](img/4615OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, the names of these actions are changed
    to `actionAbout` and `actionExit`, respectively. In addition to this, there is
    a shortcut, *Ctrl* + *Q,* for `actionExit`. Just double-click on the action and
    add shortcuts by pressing the shortcut you want. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the menu bar](img/4615OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We already used `QMenu` and `QAction` in [Chapter 2](ch02.xhtml "Chapter 2. Building
    a Beautiful Cross-platform Clock"), *Building a Beautiful Cross-platform Clock*.
    The difference here is that you use `QMenu` as the menu bar, and set it up it
    in **Design** mode instead of writing code. But why is it called `QAction`? This
    is because the user can trigger a command on the menu, tool bar, or keyboard shortcut.
    They expect the same behavior regardless of where it is. Therefore, it should
    be abstracted into an action, which can be inserted into the menu or tool bar.
    You can set it to the checkable `QAction` option and use it as a simple `QCheckbox`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish `actionExit` first, since it''s simpler than the other one. For
    `actionExit`, we only need one `connect` statement to make it work. Add the following
    statement to the `MainWindow` class constructor in the `mainwindow.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `triggered` signal will be emitted by either a mouse click or a keyboard
    shortcut (if there is a shortcut). Since we connect it to the `close` slot of
    `MainWindow`, it'll close `MainWindow`, which results in exiting the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, we need to declare a slot to fulfill the connection with `actionAbout`.
    As usual, declare it in the `mainwindow.h` header file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You may think that we''re going to create a new class just to show an **About**
    dialog. Well, we don''t have to cook the **About** dialog ourselves because Qt
    has already done this for us. It''s included in `QMessageBox`, so you should include
    it with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the definition of the slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QMessageBox` class provides a modal dialog for informing or asking the
    user a question and receiving an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every kind of pop-up dialog can be found in `QMessageBox`. Here, we use
    the static `About` function to create an **About** dialog. It has three arguments.
    The first one is the parent `QObject` pointer, followed by the title and context.
    Remember to connect the signal and slot in the `MainWindow` class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run the application again, try to trigger the **About**
    dialog, which would look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the menu bar](img/4615OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to `About`, there are other useful static public members of `QMessageBox`.
    Most commonly, `critical`, `information`, `question`, and, `warning` are used
    to pop up a message box. Sometimes, you'll see an **About Qt** entry in the menu
    bar, which is to call the `aboutQt` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the **About** dialog will display an icon if it exists. There is an
    empty space since it lacks an icon. The order of the search icons is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This first icon will be `parent->icon()`, if it exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second icon will be the top-level widget, which contains `parent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third icon will be the active window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth icon will be the `Information` icon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using QFileDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step of taking a photo is to save it to disk. At this point, the program
    saves an image to the file, but the location is determined by the camera backend.
    We can simply use a dialog, letting the user choose the directory and the filename
    of the photo. There is a `QFileDialog` class to help make the work easier. The
    easiest way to create a `QFileDialog` class is to use the static functions. Therefore,
    edit the `onCaptureButtonClicked` function in the `mainwindow.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using the `getSaveFileName` static function to create a file dialog
    to return the file that the user selected. If the user clicks on **Cancel**, the
    `location` type would be an empty `QString` reference and the image will be stored
    in a default location. The file doesn''t need to exist. In fact, if it exists,
    there will be an overwrite dialog. This function''s prototype is pasted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is the `QObject` parent, as usual. The second one is the
    dialog''s title, followed by the default directory. The `filter` object is used
    to restrict the file type and it''s possible to use multiple filters that are
    separated by two semicolons, `;;`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Setting `selectedFilter` can change the default filter. Lastly, `Options` is
    used to define the behaviors of the file dialog. For more details, refer to the
    `QFileDialog` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: QML camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we talked about how to access and control the camera in Qt/C++. Now
    it's time to see how QML does in this area. Although there are some limitations,
    you'll find it's much easier and more elegant to do this in Qt Quick/QML because
    of the many packages that Qt has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Qt Quick application project. The `main.qml` content is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let me walk you through this one.
  prefs: []
  type: TYPE_NORMAL
- en: '`Camera` and `VideoOutput` are provided by the `QtMultimedia` module. Similar
    to the Qt/C++ classes, the `Camera` type is identical to the `QCamera` class.
    The preview is dealt with differently when `VideoOutput` is used as `viewfinder`.
    An `image` object is used to display the captured photo and it''s only visible
    for 2 seconds each time a picture is taken. This `photoPreview` is controlled
    by the timer, `previewTimer`. In other words, the 2 seconds show up of `photoPreview`
    depends on this `previewTimer` timer. At the same time, the `camera` type''s `imageCapture`
    will provide the `preview` image to `photoPreview` and turn on `previewTimer`
    once it captures a photo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece is `CaptureButton`, which is not provided by Qt but written
    in another file, `CaptureButton.qml`. Its content is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since there is no circular shape provided by Qt Quick, we use this `Rectangle`
    object as a workaround to display it as a circle. Just like what we did in the
    previous chapter, define a `diameter` property to hold both `height` and `width`.
    The trick is the radius value. By setting it to half the diameter, this `Rectangle`
    object becomes circular. Last but not least, add `MouseArea` to respond to a user's
    click. It's a pity that `MouseArea` can't be circular, so just leave it and fill
    in the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can run your application, and it should be something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![QML camera](img/4615OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's not as powerful as the Qt/C++ demo. The first thing you probably notice
    is that you can't change the camera device. It's missing in the current version
    of Qt, but it should be supported in the future. In the meantime, the only solution
    to this is to write a C++ plugin while the main part is still written in QML.
    Since developing a C++ plugin for QML will be covered in a later chapter, we'll
    simply skip this part here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the file dialog in QML in an even more elegant way. Qt Quick provides
    commonly-used dialogs through the `QtQuick.Dialogs` module. Therefore, first import
    this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What're we interested in is the `FileDialog` type, which provides a basic file
    chooser. It allows the user to select existing files and/or directories, or create
    new filenames. It uses the native platform file dialogs wherever possible. To
    use this type, add `FileDialog` inside `ApplicationWindow` in the `main.qml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `string` type in QML is an extended version of the JavaScript `string` type.
    Wherever possible, you should avoid the `var` keyword and use the exact type,
    such as `int`, `double`, and `string`. According to the QML documentation, this
    will improve performance since the machine doesn't need to guess the data type.
    Here, we declare `location`, which is a `string` type, while the rest of its properties
    are similar to the dialog settings in Qt/C++, its `title` (caption), and `nameFilters`.
    You should set the `selectExisting` property to `false`, as it is `true` by default.
    Otherwise, it'll behave like an open file dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `onAccepted` handler, pass the `fileUrl` value to `location` first.
    This handler is the response to the `accepted` signal, which is emitted if the
    user selects a file successfully. The `fileUrl` property will then be changed.
    It's in a URI format, which has an extra `file:///` prefix. In addition to this,
    there is currently an issue if we execute `slice` on `fileUrl` directly. So as
    a workaround, we use the explicitly declared `string location` to invoke the `slice`
    function. This is a JavaScript function, which will return a new `string` type
    that contains the extracted parts of a string. The `slice` method's prototype
    is `slice(start,end)` where `end` will be the end of the `string` type if it's
    omitted. Also, note that the character at the `start` position is included and
    the index starts from zero. After that, we simply call the `captureToLocation`
    function of `imageCapture` to store the image at the selected location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make it work, we have to change the behavior of `CaptureButton`.
    Edit the `CaptureButton.qml` file and change `MouseArea`, as shown in the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, to change the `onClicked` handler, we also add `onPressed`
    and `onReleased` to let it have the push effect. As you can see, the `open()`
    function will execute our `FileDialog`. On a desktop operating system, such as
    Windows, the platform file dialog is used as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![QML camera](img/4615OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The inner circle of `CaptureButton` will become black once it's pressed, and
    then go back to blue when the mouse is released. Although it's just a minor visual
    effect, it definitely improves the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Do not fail to commit an act of kindness just because it is small in scale."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To complete this QML camera application, we need to add a zoom control as we
    did for the Qt/C++ camera. Add a new QML file named `ZoomControl.qml`, whose content
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare `property` of the `real` type to store the current zoom, whose
    initial value is the camera's current zoom, which is itself the multiplication
    of the current digital and optical zoom. This is followed by a JavaScript-style
    function, `zoomControl`. As mentioned before, you can use JavaScript in QML anywhere
    seamlessly. This function is identical to the Qt/C++ slot, `onZoomChanged`, in
    the previous topic.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is a `Text` element used to display the current `zoom` function
    on screen. These are just some visual customizations inside the `Text` element,
    which include centering in the parent by setting both the horizontal and vertical
    alignments.
  prefs: []
  type: TYPE_NORMAL
- en: What's next is a `Timer` element that controls the visibility of `Text`, similar
    to the controller of `photoPreview`.
  prefs: []
  type: TYPE_NORMAL
- en: The last but also the trickiest is `MouseArea`. We use the mouse wheel to control
    the zoom, so the handler that can get the wheel event is `onWheel`. The `wheel.angleDelta.y`
    is the wheel, which is rotated to a vertical orientation. If it's positive, it
    goes up; otherwise, it goes down. It zooms in with a positive value, and zooms
    out with negative one. You have to ensure that the new zoom is within the supported
    zoom range of `camera` before invoking the `zoomControl` function. After this,
    let the `Text` indicator display `zoom` and turn on `Timer` so that it's only
    visible for 2 seconds. You can also see that there is a built-in function for
    the `real` element to convert it to `string`, just like the `QString::number`
    function in Qt/C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all this, edit `main.qml` and add `ZoomControl` to the application, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that `ZoomControl` should fill in `viewfinder` instead of `parent`;
    otherwise, it may get overlaid by other components, such as `viewfinder`.
  prefs: []
  type: TYPE_NORMAL
- en: Give this QML camera a test run and compare which one is better.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to write applications that can
    access camera devices in either Qt/C++ or QML. What's more is that you should
    be able to utilize the status and menu bar in traditional desktop applications,
    which are historically important and continue to play a crucial role as interactive
    functional widgets. In addition to this, don't forget the file dialog and message
    box since they make your coding work easier. In the next chapter, we're going
    to talk about an advanced topic, plugins, which is a popular way to extend large
    applications.
  prefs: []
  type: TYPE_NORMAL
