- en: Chapter 10. Expanding Space
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。扩展空间
- en: 'Now that you know how to build your 3D world, it is time to do stuff! As we
    are building a space racing game, we need to be able to move our space ship around.
    We will also put some obstacles in the game so that we have something to race
    against. In this chapter, you will learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何构建你的 3D 世界，是时候做一些事情了！由于我们正在构建太空赛车游戏，我们需要能够移动我们的太空船。我们还会在游戏中放置一些障碍物，以便我们有东西可以与之竞赛。在本章中，你将学习以下主题：
- en: '**Placing game objects**: We will take some 3D objects, load them into our
    game, and place them in 3D space.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**放置游戏对象**：我们将取一些 3D 对象，将它们加载到我们的游戏中，并在 3D 空间中放置它们。'
- en: '**Transformations**: We need to learn how to move in 3D. Moving in 2D was easy.
    In 3D, we have another dimension, and we will now also want to account for rotation
    as we move around.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变换**：我们需要学习如何在 3D 中移动。在 2D 中移动很容易。在 3D 中，我们还有一个维度，现在我们还将想要在移动时考虑旋转。'
- en: '**Point of view**: We will learn how the point of view affects how we play
    the game. Do you want to be in the pilot''s seat or just outside the ship?'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视角**：我们将学习视角如何影响我们玩游戏的方式。你想要坐在驾驶员座位上，还是只是在外面？'
- en: '**Collisions**: We performed some collision detection in our 2D game. Collision
    detection in 3D is more complicated because we now have to consider all three
    spatial dimensions in our checks.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞**：我们在 2D 游戏中进行了碰撞检测。3D 中的碰撞检测更复杂，因为现在我们必须考虑检查中的三个空间维度。'
- en: Creation 101
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 101
- en: Our first task is to load our world. We need a few basic components. First,
    we need a universe. This universe will contain stars, asteroids, and our space
    ship. Open up SpaceRacer3D and let's get coding!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是加载我们的世界。我们需要一些基本组件。首先，我们需要一个宇宙。这个宇宙将包含星星、小行星和我们的太空船。打开 SpaceRacer3D，让我们开始编码吧！
- en: Preparing the project
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备项目
- en: 'Before we get going, we will need to move some code over from our 2D project.
    Copy the following files and settings from RoboRacer2D to SpaceRacer3D:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要将一些代码从我们的 2D 项目中移动过来。从 RoboRacer2D 复制以下文件和设置到 SpaceRacer3D：
- en: Copy `Input.cpp` and `Input.h`—we will use these classes to handle user input.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `Input.cpp` 和 `Input.h`——我们将使用这些类来处理用户输入。
- en: Copy `Sprite.cpp`, `Sprite.h`, `SOIL.h`, and `SOIL.lib`—we will use them to
    support the user interface in the next chapter. You may need to remove the line
    `#include "stdafx.h"` from `Sprite.cpp`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `Sprite.cpp`、`Sprite.h`、`SOIL.h` 和 `SOIL.lib`——我们将在下一章中使用它们来支持用户界面。你可能需要从
    `Sprite.cpp` 中删除 `#include "stdafx.h"` 这一行。
- en: Copy `fmodex.dll`—we need this for audio support.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `fmodex.dll`——我们需要这个文件来支持音频。
- en: Copy the settings from the project `Configuration Properties/C/C++/General/Additional
    Include Directories` setting—this is necessary to provide access to FMOD library:![Preparing
    the project](img/8199OS_10_04.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制项目配置属性/C/C++/常规/附加包含目录设置中的设置——这是为了提供对 FMOD 库的访问：![准备项目](img/8199OS_10_04.jpg)
- en: Copy the settings from the project `Configuration Properties/Linker/Input/ Additional
    Dependencies` setting—this is necessary to provide access to the OpenGL, FMOD,
    and SOIL libraries:![Preparing the project](img/8199OS_10_05.jpg)
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制项目配置属性/链接器/输入/附加依赖项设置中的设置——这是为了提供对 OpenGL、FMOD 和 SOIL 库的访问：![准备项目](img/8199OS_10_05.jpg)
- en: Copy the settings from the project Configuration Properties/Linker/ General/Additional
    Library Directories setting—this is also necessary to provide access to FMOD library:![Preparing
    the project](img/8199OS_10_01a.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制项目配置属性/链接器/常规/附加库目录设置中的设置——这同样也是为了提供对 FMOD 库的访问：![准备项目](img/8199OS_10_01a.jpg)
- en: Loading game objects
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载游戏对象
- en: In the previous chapter, we learned how to create 3D objects in Blender and
    export them as `obj` files. We then added code to our project to load the `obj`
    data. Now, we will use that code to load some models into our game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在 Blender 中创建 3D 对象并将它们导出为 `obj` 文件。然后，我们将代码添加到我们的项目中以加载 `obj`
    数据。现在，我们将使用这段代码将一些模型加载到我们的游戏中。
- en: 'We are going to load four models into our game: the space ship, and three asteroids.
    The idea will be to race through the asteroid field. As our loader holds the model
    data as three arrays (vertices, uvs, and normals), we will create a model class
    that defines these arrays and then use this class for each model that we want
    to load into the game.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载四个模型到我们的游戏中：太空船和三个小行星。想法是通过小行星带进行竞赛。由于我们的加载器将模型数据作为三个数组（顶点、纹理坐标和法线）持有，我们将创建一个模型类来定义这些数组，然后使用这个类来加载我们想要加载到游戏中的每个模型。
- en: The Model class header
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型类头文件
- en: 'Create a new class and header file named `Model.cpp` and `Model.h`, respectively.
    Open `Model.h`. First, let''s get the header set up:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类和头文件，分别命名为 `Model.cpp` 和 `Model.h`。打开 `Model.h`。首先，让我们设置好头文件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to use some constants defined in `math.h`, so we need to add a preprocessor
    directive. Add `_USE_MATH_DEFINES` to `Configuration Properties/C/C++/Preprocessor/Preprocessor
    Definitions`. Also, notice that we include `LoadObj.h` because we will load the
    model from inside this class. Now, let''s create the class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用在 `math.h` 中定义的一些常量，因此我们需要添加一个预处理器指令。将 `_USE_MATH_DEFINES` 添加到 `Configuration
    Properties/C/C++/Preprocessor/Preprocessor Definitions`。注意，我们还包含了 `LoadObj.h`，因为我们将在类内部加载模型。现在，让我们创建这个类：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will be using color a lot, so we are defining a `struct` to hold the `r`,
    `g`, and `b` values to make things more convenient. Now, for our methods we use
    the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大量使用颜色，因此我们定义了一个 `struct` 来保存 `r`、`g` 和 `b` 值，使事情更加方便。现在，对于我们的方法，我们使用以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is a short description of each method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个方法的简要描述：
- en: '`Model` is the constructor. It takes a filename and a color. As our models
    are simple shapes, we will use color to give them some pizzazz.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model` 是构造函数。它接受一个文件名和一个颜色。由于我们的模型是简单的形状，我们将使用颜色来给它们增添一些魅力。'
- en: '`SetPosition` and `GetPosition` manage the object''s position in world space.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetPosition` 和 `GetPosition` 管理对象在全局空间中的位置。'
- en: '`SetHeading` and `GetHeading` manage the direction the object is heading.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetHeading` 和 `GetHeading` 管理对象前进的方向。'
- en: '`SetColor` and `GetColor` manage the objects color.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetColor` 和 `GetColor` 管理对象的颜色。'
- en: '`SetBaseRotation` and `GetBaseRotation` manage any local rotation applied to
    the object.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetBaseRotation` 和 `GetBaseRotation` 管理应用于对象的任何局部旋转。'
- en: '`SetHeadingRotation` and `GetHeadingRotation` manage the orientation of the
    object in world space.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetHeadingRotation` 和 `GetHeadingRotation` 管理对象在全局空间中的方向。'
- en: '`SetVelocity` and `GetVelocity` manage the speed of the object.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetVelocity` 和 `GetVelocity` 管理对象的速率。'
- en: 'Now, for the variables, we use the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于变量，我们使用以下代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are self-explanatory because they directly correspond to the methods described
    previously. This header is a good structure for everything that we will need to
    do to place objects in our world and move them around.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都是不言自明的，因为它们直接对应于之前描述的方法。这个头文件是我们放置世界中的对象并移动它们的良好结构。
- en: Implementing the Model class
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Model 类
- en: 'Now let''s implement the class. Open `Model.cpp` and let''s get started. First,
    we implement the header, constructor, and destructor:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现这个类。打开 `Model.cpp` 并开始。首先，我们实现头文件、构造函数和析构函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The constructor sets everything up. Notice that we call `LoadObj` from the
    constructor to actually load the object into the class. The results will be stored
    into member arrays `m_vertices` and `m_normals`. `m_primitive` will hold an enum
    telling us whether this object is defined by quads or triangles. The remaining
    variables are set to default values. These can be defined at any time in the game
    by using the appropriate `accessor` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数设置了所有内容。注意，我们从构造函数中调用 `LoadObj` 来实际将对象加载到类中。结果将存储在成员数组 `m_vertices` 和 `m_normals`
    中。`m_primitive` 将持有枚举，告诉我们这个对象是由四边形还是三角形定义的。其余变量被设置为默认值。这些可以在游戏中的任何时间通过使用适当的 `accessor`
    方法来定义：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Deg2Rad` is a helper function that will convert degrees to radians. As we
    move the ship around, we keep track of the heading angle in degrees, but we often
    need to use radians in OpenGL functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deg2Rad` 是一个辅助函数，它将度数转换为弧度。当我们移动船只时，我们跟踪航向角度的度数，但我们在 OpenGL 函数中经常需要使用弧度：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Update` function updates the position of the object based on the object''s
    velocity. Finally, we update `m_heading`, which will be used to orient the world
    camera during the render. Then update the object''s position in world space:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 函数根据对象的速率更新对象的位置。最后，我们更新 `m_heading`，它将在渲染期间用于定位世界相机。然后更新对象在全局空间中的位置：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Render` function takes care of rendering this particular object. The setup
    for the world matrix will happen in the game code. Then each object in the game
    will be rendered.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Render` 函数负责渲染这个特定的对象。世界矩阵的设置将在游戏代码中完成。然后，游戏中的每个对象都将被渲染。'
- en: Remember the camera? The camera is a virtual object that is used to view the
    scene. In our case, the camera is the ship. Wherever the ship goes, the camera
    will go. Whatever the ship points at, the camera will point at.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记得相机吗？相机是一个用于查看场景的虚拟对象。在我们的例子中，相机是船只。无论船只驶向何方，相机都会跟随。无论船只指向哪里，相机也会指向那里。
- en: Now for the real mind-blower; OpenGL doesn't really have a camera. That is,
    there really isn't a camera that you move around in the scene. Instead, the camera
    is always located at coordinates (**0.0, 0.0, 0.0**), or the world's origin. This
    means that our ship will always be located at the origin. Instead of moving the
    ship, we will actually move the other objects in the opposite direction. When
    we turn the ship, we will actually rotate the world in the opposite direction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正的震撼点；OpenGL实际上并没有相机。也就是说，在场景中并没有可以移动的相机。相反，相机始终位于坐标（**0.0, 0.0, 0.0**），即世界的原点。这意味着我们的船将始终位于原点。我们不会移动船，实际上我们会移动其他物体到相反的方向。当我们转向船时，实际上我们会旋转世界到相反的方向。
- en: 'Now look at the code for the `Render` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 `Render` 函数的代码：
- en: First, we use `glRotate` to rotate everything the object's base rotation. This
    comes in useful if we need to orient the object. For example, the cylinder that
    we modeled in the previous chapter is standing up, and it works better in the
    game lying on its side. You will see later that we apply a 90 degree rotation
    to the cylinder to achieve this.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `glRotate` 来旋转物体的基础旋转。如果需要定位物体，这会很有用。例如，我们在上一章中建模的圆柱体是立着的，在游戏中侧躺效果更好。你会在后面看到，我们给圆柱体应用了90度的旋转来实现这一点。
- en: Next, we have to decide whether we are going to render quads or triangles. When
    Blender exports a model, it exports it as either quads or triangles. The loader
    figures out whether a model is defined as quads or triangles and stores the result
    in `m_primitive`. We then use that to determine whether this particular object
    must be rendered using triangles or quads.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们必须决定是渲染四边形还是三角形。当Blender导出模型时，它将其导出为四边形或三角形。加载器会确定模型是定义为四边形还是三角形，并将结果存储在
    `m_primitive` 中。然后我们使用这个结果来确定这个特定物体是否必须使用三角形或四边形进行渲染。
- en: We use `glColor` to set the color of the object. At this point we haven't assigned
    any textures to our models, so color gives us a simple way to give each object
    a personality.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `glColor` 来设置物体的颜色。在这个阶段，我们还没有为我们的模型分配任何纹理，所以颜色为我们提供了一个简单的方式来给每个物体赋予个性。
- en: Now for the real work! We need to draw each vertex of the object in world space.
    To do this, we loop through each point in the vertices array, and we use `glVertex3f`
    to place each point.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正的工作时间！我们需要在全局空间中绘制物体的每个顶点。为此，我们遍历顶点数组中的每个点，并使用 `glVertex3f` 来放置每个点。
- en: The catch is this; the points in the vertices array are in local coordinates.
    If we drew every object using these points, then they would all be drawn at the
    origin. You will recall that we want to place each object in the game relative
    to the ship. So, we draw the ship at the origin, and we draw every other object
    in the game based on the position of the ship. We move the universe, not the ship.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意的是；顶点数组中的点是局部坐标。如果我们使用这些点绘制每个物体，那么它们都会在原点绘制。你可能会记得，我们希望将每个物体放置在相对于船的游戏中。因此，我们在原点绘制船，并根据船的位置绘制游戏中的每个其他物体。我们移动的是宇宙，而不是船。
- en: '![Implementing the Model class](img/8199OS_10_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![实现模型类](img/8199OS_10_01.jpg)'
- en: When the ship moves, the entire coordinate system moves with it. Actually, the
    coordinate system stays put and the entire universe moves past it!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当船移动时，整个坐标系也会随之移动。实际上，坐标系保持不动，整个宇宙都在它周围移动！
- en: '![Implementing the Model class](img/8199OS_10_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![实现模型类](img/8199OS_10_02.jpg)'
- en: If we happen to be rendering the ship, we just draw it using its local coordinates
    and it is rendered at the origin. All of the other objects are drawn at a distance
    away from the ship based on the ships position.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在渲染船，我们只需使用其局部坐标来绘制它，它将在原点渲染。所有其他物体都根据船的位置在船的某个距离处绘制。
- en: 'Now, for the rest of the class implementation, use the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于类实现的其余部分，使用以下代码：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These methods set and retrieve the object''s position. The position is changed
    based on the object''s velocity in the `Update` method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法设置和检索物体的位置。位置是基于物体在 `Update` 方法中的速度来改变的：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These methods set and retrieve the object''s heading. The heading is changed
    based on the object''s heading rotations in the `Update` method. Heading is the
    direction that the ship is headed in, and is used to rotate the world so that
    the ship appears to be heading in the correct direction:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法设置和检索物体的航向。航向是基于物体在 `Update` 方法中的航向旋转来改变的。航向是船前进的方向，用于旋转世界，使船看起来朝正确的方向前进：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These methods are used to manage the object''s color:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于管理对象的颜色：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These methods are used to manage the object''s velocity. The velocity is set
    in the game code during the input phase:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于管理对象的速率。速率在游戏代码的输入阶段设置：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These methods are used to manage the object''s base rotation. The base rotation
    is used to rotate the object in local space:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于管理对象的基本旋转。基本旋转用于在局部空间中旋转对象：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These methods are used to manage the object's heading rotation. The heading
    rotation is used to rotate the world around the object so that the object appears
    to be heading in a particular direction. Only one object (the ship) will have
    a heading rotation. Another way to think about this is that the heading rotation
    is the rotation of the camera, which in our game is attached to the ship.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于管理对象的方向旋转。方向旋转用于围绕对象旋转世界，使对象看起来朝向特定方向。只有一个对象（飞船）将具有方向旋转。另一种思考方式是，方向旋转是摄像机的旋转，在我们的游戏中，摄像机是附着在飞船上的。
- en: Modifying the game code
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改游戏代码
- en: Now it's time to modify our game code so that it can load and manipulate game
    models. Open `SpaceRacer3D.cpp`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候修改我们的游戏代码，使其能够加载和操作游戏模型了。打开 `SpaceRacer3D.cpp`。
- en: 'We''ll start by adding the appropriate headers. At the top of the code, modify
    the header definitions so that they look like the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加适当的头文件。在代码顶部，修改头文件定义，使其看起来像以下代码：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we have added `Model.h` to load our models. We also included `Sprite.h`
    and `Input.h` from RoboRacer2D so that we can use those classes in our new game
    when necessary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经添加了 `Model.h` 来加载我们的模型。我们还从 RoboRacer2D 中包含了 `Sprite.h` 和 `Input.h`，这样我们就可以在我们新游戏需要时使用这些类。
- en: 'Now, we need to define some global variables to manage model loading. Just
    under any global variables that are already defined, add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一些全局变量来管理模型加载。在已定义的任何全局变量下面，添加以下代码：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These variables defined pointers to our game objects. As the ship is kind of
    special, we give it its own pointer. We want to be able to have an arbitrary number
    of asteroids; we set up a vector (a nice dynamic array) of pointers called asteroids.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量定义了指向我们的游戏对象的指针。由于飞船有点特殊，我们给它自己的指针。我们希望能够有任意数量的小行星；我们设置了一个指针向量（一个很好的动态数组）称为
    asteroids。
- en: 'Move down to the `StartGame` function, which we use to initialize all of our
    game models. Modify the `StartGame` function to look like the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到 `StartGame` 函数，我们使用它来初始化所有的游戏模型。修改 `StartGame` 函数，使其看起来像以下代码：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are going to create one object for the ship and three asteroids. For each
    object, we first define a color, then we create a new `Model` passing the filename
    of the object and the color. The `Model` class will load the object file exported
    from Blender.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个飞船对象和三个小行星对象。对于每个对象，我们首先定义一个颜色，然后创建一个新的 `Model`，传递对象的文件名和颜色。`Model` 类将加载从
    Blender 导出的对象文件。
- en: Notice that we set the ship to be the camera with the `IsCamera(true)` call.
    We also attach the ship as the camera for every game object using the `AttachCamera(ship)`
    call.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `IsCamera(true)` 调用将飞船设置为相机。我们还使用 `AttachCamera(ship)` 调用将飞船作为相机附加到每个游戏对象。
- en: We also set a position for each object. This will set the position in world
    space. This way we don't end up drawing every object at the origin!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为每个对象设置了一个位置。这将设置世界空间中的位置。这样我们就不会在每个对象的原点绘制每个对象了！
- en: Each asteroid is put in the asteroids array using the `push.back` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小行星都使用 `push.back` 方法放入小行星数组中。
- en: 'Now, we move to the `Update` function. Modify the `Update` function so that
    it looks like the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转到 `Update` 函数。修改 `Update` 函数，使其看起来像以下代码：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The update simply calls the `Update` method for every object in the game. As
    always, the update is based on the amount of time that has passed in the game,
    so we pass in `p_deltaTime`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更新只是调用游戏中每个对象的 `Update` 方法。像往常一样，更新基于游戏中经过的时间量，所以我们传递 `p_deltaTime`。
- en: 'Now on to the `Render` function. Replace the existing code with the following
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到 `Render` 函数。用以下代码替换现有的代码：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The rendering code is the real workhorse of the game. First, we set up the
    render call for this frame, then we call the `Render` method for each game object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染代码是游戏中的真正工作马。首先，我们设置本帧的渲染调用，然后对每个游戏对象调用 `Render` 方法：
- en: '`GlClear`: This clears the render buffer.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlClear`：此操作清除渲染缓冲区。'
- en: '`GlMatrixMode`: This sets the model to the model view. All translations and
    rotations are applied to the in the model view.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlMatrixMode`：这会将模型设置为模型视图。所有平移和旋转都应用于模型视图。'
- en: '`glLoadIdentity()`: This resets the matrix.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glLoadIdentity()`：这会重置矩阵。'
- en: Next, we call the `Render` method for each object in the game.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们为游戏中的每个对象调用`Render`方法。
- en: Finally, we call `SwapBuffers`, which actually renders the scene to the screen.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们调用`SwapBuffers`，这实际上会将场景渲染到屏幕上。
- en: Congratulations! If you run the game now, you should see the ship and the three
    asteroids off in the distance. As we set the velocity of the ship to 1.0, you
    should also see the ship slowly moving past the asteroids. However, we don't have
    any way to control the ship yet because we haven't implemented any input.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！如果您现在运行游戏，应该能看到飞船和远处的三个小行星。由于我们设置了飞船的速度为1.0，您也应该看到飞船缓慢地穿过小行星。然而，我们还没有任何控制飞船的方法，因为我们还没有实现任何输入。
- en: '![Modifying the game code](img/8199OS_10_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![修改游戏代码](img/8199OS_10_06.jpg)'
- en: Taking control
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌控
- en: We now have a framework to load and render game objects. But, we don't have
    any way to move our ship! The good news is that we already wrote an input class
    for RoboRacer2D, and we can reuse that code here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个加载和渲染游戏对象的框架。但是，我们没有移动飞船的方法！好消息是，我们已经在RoboRacer2D中编写了一个输入类，并且可以在这里重用那段代码。
- en: Implementing input
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现输入
- en: Earlier in the chapter, I had you copy the `Input` class from RoboRacer2D into
    the source folder for SpaceRacer3D. Now, we have to simply wire it into our game
    code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我让您将`Input`类从RoboRacer2D复制到SpaceRacer3D的源文件夹中。现在，我们只需将其连接到我们的游戏代码中。
- en: 'Open SpaceRacer3D. First, we need to include the input header. Add the following
    line of code to the headers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开SpaceRacer3D。首先，我们需要包含输入头文件。在头文件中添加以下代码行：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also need to create a global pointer to manage the `Input` class. Add the
    following line just below the model pointers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个全局指针来管理`Input`类。在模型指针下方添加以下行：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we need to create an instance of the `Input` class. Add the following
    line of code to the top of the `StartGame` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`Input`类的一个实例。在`StartGame`函数顶部添加以下代码行：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we have to create a function to handle our input. Add the following function
    just above the `Update` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个函数来处理我们的输入。在`Update`方法上方添加以下函数：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code handles keyboard input. You will recall from RoboRacer2D that we
    mapped virtual commands to the following keys:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码处理键盘输入。您会记得从RoboRacer2D中，我们将虚拟命令映射到以下键：
- en: '`CM_STOP`: This is the spacebar. We use the spacebar as a toggle to both start
    and stop the ship. If the ship is stopped, pressing the spacebar sets the velocity.
    If the ship''s velocity is greater than zero, then pressing the spacebar sets
    the velocity to zero.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CM_STOP`：这是空格键。我们使用空格键作为切换来启动和停止飞船。如果飞船停止，按下空格键会设置速度。如果飞船的速度大于零，则按下空格键会将速度设置为零。'
- en: '`CM_UP`: This is both the up arrow and the *W* key. Pressing either of these
    keys changes the heading rotation so that the ship moves up.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CM_UP`：这是向上箭头键和*W*键。按下任一键都会改变航向旋转，使飞船向上移动。'
- en: '`CM_DOWN`: This is both the down arrow and the *S* key. Pressing either of
    these keys changes the heading rotation so that the ship moves down.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CM_DOWN`：这是向下箭头键和*S*键。按下任一键都会改变航向旋转，使飞船向下移动。'
- en: '`CM_LEFT`: This is both the left arrow and the *A* key. Pressing either of
    these keys changes the heading rotation so that the ship moves left.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CM_LEFT`：这是左箭头键和*A*键。按下任一键都会改变航向旋转，使飞船向左移动。'
- en: '`CM_RIGHT`: This is both the right arrow and the *D* key. Pressing either of
    these keys changes the heading rotation so that the ship moves up.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CM_RIGHT`：这是向右箭头键和*D*键。按下任一键都会改变航向旋转，使飞船向右移动。'
- en: Every directional command works by retrieving the current heading angle and
    changing the appropriate component of the heading vector by one degree. The heading
    angle is used by each object's `Update` method to calculate a heading vector,
    which is used to point the camera in the `Render` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方向命令通过检索当前航向角度并改变航向向量的适当分量一度来实现。航向角度由每个对象的`Update`方法用来计算航向向量，该向量用于在`Render`方法中指向相机。
- en: 'Finally, we need to call `HandleInput` from the games `Update` function. Add
    the following line of code to the top of the `Update` method, before the object
    update calls. We want to handle input first and then call each object''s update
    method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要从游戏的 `Update` 函数中调用 `HandleInput`。在对象更新调用之前，将以下代码行添加到 `Update` 方法的顶部。我们希望首先处理输入，然后调用每个对象的更新方法：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That's it! Pat yourself on the back and run the game. You can now use the keyboard
    to control the ship and navigate through your universe.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！给自己鼓掌并运行游戏。你现在可以使用键盘来控制飞船并导航你的宇宙。
- en: Asteroid slalom
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小行星回转滑雪
- en: It's now time to implement the final feature of this chapter. We are going to
    implement a slalom race with a twist. In a typical slalom, the point is to race
    around each obstacle without touching it. To keep things simple, we are going
    to race through each asteroid. If you successfully pass through each asteroid,
    you win the race.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现本章的最后一个特性了。我们将实现一个带有转折点的回转滑雪比赛。在典型的回转滑雪中，目标是绕过每个障碍物而不触碰它。为了简化问题，我们将通过每个小行星。如果你成功通过每个小行星，你就赢得了比赛。
- en: Setting up collision detection
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置碰撞检测
- en: In order to determine whether you have passed through an asteroid, we have to
    implement some 3D collision detection. There are many types of collision detection,
    but we are going to keep it simple and implement spherical collision detection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定你是否通过了小行星，我们必须实现一些3D碰撞检测。有许多种类的碰撞检测，但我们将保持简单，并实现球形碰撞检测。
- en: Spherical collision detection is a simple check to see whether the center of
    two 3D objects are within a certain distance of each other. As our asteroids are
    spheres, this will be a pretty accurate indication as to whether we have collided
    with one. The ship, however, is not a sphere, so this technique isn't perfect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 球形碰撞检测是一个简单的检查，看看两个3D对象中心是否在彼此的一定距离内。由于我们的陨石是球形的，这将是一个相当准确的指示，表明我们是否与之相撞。然而，飞船不是球形的，所以这种方法并不完美。
- en: 'Let''s start our collision detection coding by adding the appropriate methods
    to the `Model` class. Open `Model.h` and add the following methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `Model` 类添加适当的方法开始我们的碰撞检测编码。打开 `Model.h` 并添加以下方法：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is how we will use each method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何使用每个方法：
- en: '`IsCollideable` is used to either get or set the `m_collideable` flag. Objects
    are set to collide by default. All of the objects in our game are set to collide
    so that we can detect if the ship has hit an asteroid. However, it is very common
    to have some objects in a game that you don''t collide with. If you set `IsCollideable(false)`,
    then collision detection will be ignored.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsCollideable` 用于获取或设置 `m_collideable` 标志。对象默认设置为可碰撞。我们游戏中的所有对象都设置为可碰撞，这样我们就可以检测飞船是否撞上了小行星。然而，在游戏中有一些对象你不希望它们发生碰撞是很常见的。如果你设置
    `IsCollideable(false)`，则碰撞检测将被忽略。'
- en: '`CollidedWith` is the method that performs the actual collision detection.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollidedWith` 是执行实际碰撞检测的方法。'
- en: '`GetCenter` is a helper function that calculates the center point of the object
    in world space.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCenter` 是一个辅助函数，用于计算对象在全局空间中的中心点。'
- en: '`SetRadius` and `GetRadius` are help functions to manage the collision radius
    for the object.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetRadius` 和 `GetRadius` 是帮助函数，用于管理对象的碰撞半径。'
- en: 'We also need to add two variables to track the radius and collision:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加两个变量来跟踪半径和碰撞：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, open `Model.cpp` and add the following code to implement the collision
    methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `Model.cpp` 并添加以下代码以实现碰撞方法。
- en: 'First, we need to define the radius in the constructor. Add the following line
    of code to the constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在构造函数中定义半径。将以下代码行添加到构造函数中：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now add the following methods:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加以下方法：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`IsCollideable` and the override are used to either get whether the object
    can be collided with or get the state of the collision flag.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsCollideable` 和重写用于获取对象是否可以碰撞或获取碰撞标志的状态。'
- en: '`GetCenter` returns the current position of the object. As we modeled all of
    our objects with the object origin at the center, returning the position also
    returns the center of the object. A more sophisticated algorithm would use the
    bounding size of the object to calculate the center.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCenter` 返回对象的当前位置。由于我们用对象原点在中心建模了所有对象，返回位置也返回了对象中心。一个更复杂的算法将使用对象的边界大小来计算中心。'
- en: '`GetRadius` and `SetRadius` manage the radius, which is required for the collision
    check code.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRadius` 和 `SetRadius` 管理半径，这对于碰撞检查代码是必需的。'
- en: '`CollidedWith` is the method that performs all the work. After checking that
    both the current object and the target objects can collide, then the method performs
    the following actions:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollidedWith`是执行所有工作的方法。在确认当前对象和目标对象都可以发生碰撞之后，该方法执行以下操作：'
- en: Gets the center point of the two objects
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取两个物体的中心点
- en: Calculates the distance in 3D between the two centers
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个中心点之间的3D距离
- en: 'Checks to see whether the distance is less than the sum of the two radii. If
    so, the objects have collided:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查距离是否小于两个半径之和。如果是这样，则两个物体已经相撞：
- en: '![Setting up collision detection](img/8199OS_10_03.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置碰撞检测](img/8199OS_10_03.jpg)'
- en: If you are astute, you will notice that this collision detection is very similar
    to the collision detection used in RoboRacer2D. We simply added the z dimension
    to the equations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够敏锐，你会注意到这种碰撞检测与RoboRacer2D中使用的碰撞检测非常相似。我们只是简单地给方程增加了z维度。
- en: Turning on collision
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开碰撞
- en: 'Now, we will implement the collision code in our game. Open `SpaceRacer3D.cpp`
    and add the following function just before the `Update` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在游戏中实现碰撞检测代码。打开`SpaceRacer3D.cpp`文件，在`Update`函数之前添加以下函数：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method performs the following actions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法执行以下操作：
- en: It defines a collision flag.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个碰撞标志。
- en: It iterates through all of the asteroids.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历所有的陨石。
- en: It checks to see whether the asteroid has collided with the ship.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查小行星是否与飞船相撞。
- en: If the asteroid has collided with the ship, we set `IsCollideable` for the asteroid
    to `false`. This stops the collision from occurring multiple times as the ship
    passes through the asteroid. For our game, we only need to collide with each asteroid
    once, so this is sufficient.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小行星与飞船相撞，我们将小行星的`IsCollideable`属性设置为`false`。这样，当飞船穿过小行星时，碰撞就不会发生多次。对于我们的游戏，我们只需要与小行星碰撞一次，所以这已经足够了。
- en: 'We need to wire the collision into the `Update` function. Add the following
    line to the Update method just after the `HandleInput` call:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将碰撞检测连接到`Update`函数中。在`HandleInput`调用之后，向`Update`方法中添加以下行：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's it. We have now implemented basic collision detection!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在已经实现了基本的碰撞检测！
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of code in this chapter. You implemented a simple, yet effective
    framework to create and manage 3D objects in the game. This class included necessary
    features to load the model, position the model in 3D space, and check for collisions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的代码。你实现了一个简单而有效的框架，用于在游戏中创建和管理3D对象。这个类包括了加载模型、在3D空间中定位模型以及检测碰撞所必需的功能。
- en: We also implemented input and collision detection in the game to create a modified
    slalom race, requiring you to navigate through each asteroid.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在游戏中实现了输入和碰撞检测，以创建一个修改过的回旋赛，要求你穿过每一个陨石。
- en: In the next chapter, we will implement a user interface and scoring system to
    make this a more complete game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现用户界面和计分系统，使这个游戏更加完整。
