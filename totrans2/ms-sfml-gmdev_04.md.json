["```cpp\nclass GUI_FileManager { \npublic: \n  GUI_FileManager(std::string l_name, GUI_Manager* l_guiMgr, \n    StateManager* l_stateMgr); \n  ~GUI_FileManager(); \n\n  void SetDirectory(std::string l_dir); \n  void ParentDirCallback(EventDetails* l_details); \n  void HandleEntries(EventDetails* l_details); \n  void ActionButton(EventDetails* l_details); \n  void CloseButton(EventDetails* l_details); \n  void Hide(); \n  void Show(); \n  void LoadMode(); \n  void SaveMode(); \n  bool IsInSaveMode() const; \n\n  template<class T> \n  void SetActionCallback( \n    void(T::*l_method)(const std::string&), T* l_instance) \n  {...} \nprivate: \n  void ListFiles(); \n  GUI_Interface* m_interface; \n  std::string m_name; \n  std::string m_dir; \n\n  std::string m_folderEntry; \n  std::string m_fileEntry; \n\n  GUI_Manager* m_guiManager; \n  StateManager* m_stateMgr; \n  StateType m_currentState; \n  std::function<void(std::string)> m_actionCallback; \n  bool m_saveMode; \n}; \n\n```", "```cpp\nvoid SetActionCallback( \n  void(T::*l_method)(const std::string&), T* l_instance) \n{ \n  m_actionCallback = \n    [l_instance, l_method](const std::string& l_str) -> void \n    { (l_instance->*l_method)(l_str); }; \n} \n\n```", "```cpp\nGUI_FileManager::GUI_FileManager(std::string l_name, \n  GUI_Manager* l_guiMgr, StateManager* l_stateMgr): \n  m_guiManager(l_guiMgr), m_stateMgr(l_stateMgr), m_name(l_name), \n  m_saveMode(false) \n{ \n  m_guiManager->LoadInterface(\"\"FileManager.interface\"\", l_name); \n  m_interface = m_guiManager->GetInterface(l_name); \n  m_currentState = m_stateMgr->GetCurrentStateType(); \n  m_folderEntry = m_interface->GetElement(\"FolderEntry\")-> \n    GetStyleName(); \n  m_fileEntry = m_interface->GetElement(\"FileEntry\")-> \n    GetStyleName(); \n  m_interface->RemoveElement(\"FolderEntry\"); \n  m_interface->RemoveElement(\"FileEntry\"); \n  m_interface->SetContentRectSize({ 300, 260 }); \n  m_interface->SetContentOffset({ 0.f, 16.f }); \n  m_interface->PositionCenterScreen(); \n\n  auto mgr = m_stateMgr->GetContext()->m_eventManager; \n\n  mgr->AddCallback<GUI_FileManager>(\"FileManager_Parent\", \n    &GUI_FileManager::ParentDirCallback, this); \n  mgr->AddCallback<GUI_FileManager>(\"FileManager_Entries\", \n    &GUI_FileManager::HandleEntries, this); \n  mgr->AddCallback<GUI_FileManager>(\"FileManager_ActionButton\", \n    &GUI_FileManager::ActionButton, this); \n  mgr->AddCallback<GUI_FileManager>(\"FileManager_Close\", \n    &GUI_FileManager::CloseButton, this); \n\n  SetDirectory(Utils::GetWorkingDirectory()); \n} \n\n```", "```cpp\nGUI_FileManager::~GUI_FileManager() { \n  m_guiManager->RemoveInterface(m_currentState, m_name); \n  auto events = m_stateMgr->GetContext()->m_eventManager; \n  events->RemoveCallback(m_currentState, \"\"FileManager_Parent\"\"); \n  events->RemoveCallback(m_currentState, \"\"FileManager_Entries\"\"); \n  events->RemoveCallback(m_currentState, \n    \"\"FileManager_ActionButton\"\"); \n  events->RemoveCallback(m_currentState, \"\"FileManager_Close\"\"); \n} \n\n```", "```cpp\nvoid GUI_FileManager::SetDirectory(std::string l_dir) { \n  m_dir = l_dir; \n  std::replace(m_dir.begin(), m_dir.end(), '''', ''/''); \n  m_interface->RemoveElementsContaining(\"\"Entry_\"\"); \n  ListFiles(); \n} \n\n```", "```cpp\nvoid GUI_FileManager::ListFiles() { \n  m_interface->GetElement(\"\"Directory\"\")->SetText(m_dir); \n  auto list = Utils::GetFileList(m_dir, \"\"*.*\"\", true); \n  Utils::SortFileList(list); \n  auto ParentDir = m_interface->GetElement(\"\"ParentDir\"\"); \n  float x = ParentDir->GetPosition().x; \n  float y = ParentDir->GetPosition().y+ParentDir->GetSize().y+1.f; \n  size_t i = 0; \n  for (auto& file : list) { \n    if (file.first == \"\".\"\" || file.first == \"\"..\"\") { continue; } \n    std::string entry = (file.second ? \"FEntry_\"\" : \"\"Entry_\"); \n    m_interface->AddElement(GUI_ElementType::Label, \n      entry + std::to_string(i)); \n    auto element = m_interface->GetElement( \n      entry + std::to_string(i)); \n    element->SetText(file.first); \n    element->SetPosition({ x, y }); \n    m_guiManager->LoadStyle((file.second ? \n      m_folderEntry : m_fileEntry), element); \n    y += ParentDir->GetSize().y + 4.f; \n    ++i; \n  } \n} \n\n```", "```cpp\nvoid GUI_FileManager::HandleEntries(EventDetails* l_details) { \n  if(l_details->m_guiElement.find(\"FEntry_\")!= std::string::npos){ \n    std::string path = m_dir + \n      m_interface->GetElement(l_details->m_guiElement)->GetText() \n      + \"\"; \n    SetDirectory(path); \n    m_interface->UpdateScrollVertical(0); \n  } else if (l_details->m_guiElement.find(\"Entry_\") != \n    std::string::npos) \n  { \n    m_interface->GetElement(\"FileName\")->SetText( \n     m_interface->GetElement(l_details->m_guiElement)->GetText()); \n  } \n} \n\n```", "```cpp\nvoid GUI_FileManager::ParentDirCallback(EventDetails* l_details) { \n  auto i = m_dir.find_last_of(\"/\", m_dir.length() - 2); \n  if (i != std::string::npos) { \n    std::string dir = m_dir.substr(0U, i + 1); \n    SetDirectory(dir); \n  } \n} \n\n```", "```cpp\nvoid GUI_FileManager::ActionButton(EventDetails* l_details) { \n  if (m_actionCallback == nullptr) { return; } \n  auto filename = m_interface->GetElement(\"FileName\")->GetText(); \n  m_actionCallback(m_dir + filename); \n} \n\n```", "```cpp\nvoid GUI_FileManager::CloseButton(EventDetails* l_details){ \n  Hide(); \n} \n\n```", "```cpp\nvoid GUI_FileManager::Hide() { m_interface->SetActive(false); } \n\nvoid GUI_FileManager::Show() { \n  m_interface->SetActive(true); \n  m_interface->PositionCenterScreen(); \n  ListFiles(); \n  m_interface->Focus(); \n} \n\n```", "```cpp\nbool GUI_FileManager::IsInSaveMode() const { return m_saveMode; } \nvoid GUI_FileManager::LoadMode() { \n  m_interface->GetElement(\"ActionButton\")->SetText(\"Load\"); \n  m_saveMode = false; \n} \nvoid GUI_FileManager::SaveMode() { \n  m_interface->GetElement(\"ActionButton\")->SetText(\"Save\"); \n  m_saveMode = true; \n} \n\n```", "```cpp\nusing LoaderPaths = std::vector<std::pair<std::string, size_t>>; \n\n```", "```cpp\nclass FileLoader : public Worker { \npublic: \n  FileLoader(); \n  void AddFile(const std::string& l_file); \n  virtual void SaveToFile(const std::string& l_file); \n\n  size_t GetTotalLines() const; \n  size_t GetCurrentLine() const; \nprivate: \n  virtual bool ProcessLine(std::stringstream& l_stream) = 0;\nvirtual void ResetForNextFile(); \n  void Work(); \n  void CountFileLines(); \n\n  LoaderPaths m_files; \n  size_t m_totalLines; \n  size_t m_currentLine; \n}; \n\n```", "```cpp\nFileLoader::FileLoader() : m_totalLines(0), m_currentLine(0) {} \nvoid FileLoader::AddFile(const std::string& l_file) { \n  m_files.emplace_back(l_file, 0); \n} \nsize_t FileLoader::GetTotalLines() const{ return m_totalLines; } \nsize_t FileLoader::GetCurrentLine() const{ return m_currentLine; } \nvoid FileLoader::SaveToFile(const std::string& l_file) {} \nvoid FileLoader::ResetForNextFile() {} \n\n```", "```cpp\nvoid FileLoader::Work() { \n  CountFileLines(); \n  if (!m_totalLines) { return; } \n  for (auto& path : m_files) { \n    ResetForNextFile(); \n    std::ifstream file(path.first); \n    std::string line; \n    std::string name; \n    auto linesLeft = path.second; \n    while (std::getline(file, line)) { \n      { \n        sf::Lock lock(m_mutex); \n        ++m_currentLine; \n        --linesLeft; \n      } \n      if (line[0] == '|') { continue; } \n      std::stringstream keystream(line); \n      if (!ProcessLine(keystream)) { \n        { \n          sf::Lock lock(m_mutex); \n          m_currentLine += linesLeft; \n        } \n        break; \n      } \n    } \n    file.close(); \n  } \n  m_files.clear(); \n  Done(); \n} \n\n```", "```cpp\nvoid FileLoader::CountFileLines() { \n  m_totalLines = 0; \n  m_currentLine = 0; \n  for (auto path = m_files.begin(); path != m_files.end();) { \n    if (path->first.empty()) { \n      path = m_files.erase(path); \n      continue; \n    } \n    std::ifstream file(path->first); \n    if (!file.is_open()) { \n      path = m_files.erase(path); \n      continue; \n    } \n    file.unsetf(std::ios_base::skipws); \n    { \n      sf::Lock lock(m_mutex); \n      path->second = static_cast<size_t>(std::count( \n        std::istreambuf_iterator<char>(file), \n        std::istreambuf_iterator<char>(), \n        '\\n')); \n      m_totalLines += path->second; \n    } \n    ++path; \n    file.close(); \n  } \n} \n\n```", "```cpp\nusing LoaderContainer = std::vector<FileLoader*>; \n\n```", "```cpp\nclass State_Loading : public BaseState { \npublic: \n  ... // Other typical state methods. \n  void SetManualContinue(bool l_continue); \n  void Proceed(EventDetails* l_details); \nprivate: \n  void UpdateText(const std::string& l_text, float l_percentage); \n  float CalculatePercentage(); \n  LoaderContainer m_loaders; \n  sf::Text m_text; \n  sf::RectangleShape m_rect; \n  unsigned short m_percentage; \n  size_t m_originalWork; \n  bool m_manualContinue; \n}; \n\n```", "```cpp\nvoid State_Loading::OnCreate() { \n  auto context = m_stateMgr->GetContext(); \n  context->m_fontManager->RequireResource(\"Main\"); \n  m_text.setFont(*context->m_fontManager->GetResource(\"Main\")); \n  m_text.setCharacterSize(14); \n  m_text.setStyle(sf::Text::Bold); \n\n  sf::Vector2u windowSize = m_stateMgr->GetContext()-> \n    m_wind->GetRenderWindow()->getSize(); \n\n  m_rect.setFillColor(sf::Color(0, 150, 0, 255)); \n  m_rect.setSize(sf::Vector2f(0.f, 16.f)); \n  m_rect.setOrigin(0.f, 8.f); \n  m_rect.setPosition(0.f, windowSize.y / 2.f); \n\n  EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager; \n  evMgr->AddCallback(StateType::Loading, \n    \"Key_Space\", &State_Loading::Proceed, this); \n} \n\n```", "```cpp\nvoid State_Loading::OnDestroy() { \n  auto context = m_stateMgr->GetContext(); \n  EventManager* evMgr = context->m_eventManager; \n  evMgr->RemoveCallback(StateType::Loading, \"Key_Space\"); \n  context->m_fontManager->ReleaseResource(\"Main\"); \n} \n\n```", "```cpp\nvoid State_Loading::Update(const sf::Time& l_time) { \n  if (m_loaders.empty()) { \n    if (!m_manualContinue) { Proceed(nullptr); } \n    return; \n  } \n  auto windowSize = m_stateMgr->GetContext()-> \n    m_wind->GetRenderWindow()->getSize(); \n  if (m_loaders.back()->IsDone()) { \n    m_loaders.back()->OnRemove(); \n    m_loaders.pop_back(); \n    if (m_loaders.empty()) { \n      m_rect.setSize(sf::Vector2f( \n        static_cast<float>(windowSize.x), 16.f)); \n      UpdateText(\".Press space to continue.\", 100.f); \n      return; \n    } \n  } \n  if (!m_loaders.back()->HasStarted()){m_loaders.back()->Begin();} \n\n  auto percentage = CalculatePercentage(); \n  UpdateText(\"\", percentage); \n  m_rect.setSize(sf::Vector2f( \n    (windowSize.x / 100) * percentage, 16.f)); \n} \n\n```", "```cpp\nvoid State_Loading::Draw() { \n  sf::RenderWindow* wind = m_stateMgr-> \n    GetContext()->m_wind->GetRenderWindow(); \n  wind->draw(m_rect); \n  wind->draw(m_text); \n} \n\n```", "```cpp\nvoid State_Loading::UpdateText(const std::string& l_text, \n  float l_percentage) \n{ \n  m_text.setString(std::to_string( \n    static_cast<int>(l_percentage)) + \"%\" + l_text); \n  auto windowSize = m_stateMgr->GetContext()-> \n    m_wind->GetRenderWindow()->getSize(); \n  m_text.setPosition(windowSize.x / 2.f, windowSize.y / 2.f); \n  Utils::CenterSFMLText(m_text); \n} \n\n```", "```cpp\nfloat State_Loading::CalculatePercentage() { \n  float absolute = 100.f; \n  if (m_loaders.back()->GetTotalLines()) { \n    float d = (100.f * (m_originalWork - m_loaders.size())) / \n      static_cast<float>(m_originalWork); \n    float current = (100.f * m_loaders.back()->GetCurrentLine()) / \n      static_cast<float>(m_loaders.back()->GetTotalLines()); \n    float totalCurrent = current / \n      static_cast<float>(m_originalWork); \n    absolute = d + totalCurrent; \n  } \n  return absolute; \n} \n\n```", "```cpp\nvoid State_Loading::Proceed(EventDetails* l_details) { \n  if (!m_loaders.empty()) { return; } \n  m_stateMgr->SwitchTo(m_stateMgr->GetNextToLast()); \n} \n\n```", "```cpp\nvoid State_Loading::AddLoader(FileLoader* l_loader) { \n  m_loaders.emplace_back(l_loader); \n  l_loader->OnAdd(); \n} \nbool State_Loading::HasWork() const { return !m_loaders.empty(); } \nvoid State_Loading::Activate() { \n  m_originalWork = m_loaders.size(); \n} \n\n```", "```cpp\nclass State_MapEditor : public BaseState { \npublic: \n  ... \n  void ResetSavePath(); \n  void SetMapRedraw(bool l_redraw); \n  void MainMenu(EventDetails* l_details); \n  void MapEditorNew(EventDetails* l_details); \n  void MapEditorLoad(EventDetails* l_details); \n  void MapEditorSave(EventDetails* l_details); \n  void MapEditorSaveAs(EventDetails* l_details); \n  void MapEditorExit(EventDetails* l_details); \n  void MapAction(const std::string& l_name); \nprivate: \n  void SaveMap(const std::string& l_path); \n  void LoadMap(const std::string& l_path); \n  GUI_FileManager m_files; \n  MapControls m_mapControls; \n  std::string m_mapSavePath; \n  bool m_mapRedraw; \n}; \n\n```", "```cpp\nvoid State_MapEditor::OnCreate() { \n  auto context = m_stateMgr->GetContext(); \n  auto evMgr = context->m_eventManager; \n  evMgr->AddCallback(\"Key_Escape\", \n    &State_MapEditor::MainMenu, this); \n  evMgr->AddCallback(\"MapEditor_New\", \n    &State_MapEditor::MapEditorNew, this); \n  evMgr->AddCallback(\"MapEditor_Load\", \n    &State_MapEditor::MapEditorLoad, this); \n  evMgr->AddCallback(\"MapEditor_Save\", \n    &State_MapEditor::MapEditorSave, this); \n  evMgr->AddCallback(\"MapEditor_SaveAs\", \n    &State_MapEditor::MapEditorSaveAs, this); \n  evMgr->AddCallback(\"MapEditor_Exit\", \n    &State_MapEditor::MapEditorExit, this); \n\n  m_files.SetActionCallback(&State_MapEditor::MapAction, this); \n  m_files.SetDirectory(Utils::GetWorkingDirectory() + \n    \"media/maps/\"); \n  m_files.Hide(); \n  context->m_guiManager->LoadInterface( \n    \"MapEditorTop.interface\", \"MapEditorTop\"); \n  context->m_guiManager->GetInterface(\"MapEditorTop\")-> \n    SetPosition({ 200, 0 }); \n\n  context->m_particles->CreateState(StateType::MapEditor); \n} \n\n```", "```cpp\nvoid State_MapEditor::OnDestroy() { \n  auto context = m_stateMgr->GetContext(); \n  auto textureMgr = context->m_textureManager; \n  auto evMgr = context->m_eventManager; \n  evMgr->RemoveCallback(StateType::MapEditor, \"Key_Escape\"); \n  evMgr->RemoveCallback(StateType::MapEditor, \"MapEditor_New\"); \n  evMgr->RemoveCallback(StateType::MapEditor, \"MapEditor_Load\"); \n  evMgr->RemoveCallback(StateType::MapEditor, \"MapEditor_Save\"); \n  evMgr->RemoveCallback(StateType::MapEditor, \"MapEditor_SaveAs\"); \n  evMgr->RemoveCallback(StateType::MapEditor, \"MapEditor_Exit\"); \n  context->m_gameMap->PurgeMap(); \n  context->m_gameMap->GetTileMap()->SetMapSize({ 0,0 }); \n} \n\n```", "```cpp\nvoid State_MapEditor::MapEditorNew(EventDetails* l_details) { \n  m_mapControls.NewMap(); \n} \nvoid State_MapEditor::MapEditorLoad(EventDetails* l_details) { \n  m_files.LoadMode(); \n  m_files.Show(); \n} \n\nvoid State_MapEditor::MapEditorSave(EventDetails* l_details) { \n  if (m_mapSavePath.empty()) { MapEditorSaveAs(nullptr); return; } \n  SaveMap(m_mapSavePath); \n} \nvoid State_MapEditor::MapEditorSaveAs(EventDetails* l_details) { \n  m_files.SaveMode(); \n  m_files.Show(); \n} \n\nvoid State_MapEditor::MapEditorExit(EventDetails* l_details) { \n  m_stateMgr->SwitchTo(StateType::MainMenu); \n  m_stateMgr->Remove(StateType::MapEditor); \n} \n\n```", "```cpp\nvoid State_MapEditor::LoadMap(const std::string& l_path) { \n  auto context = m_stateMgr->GetContext(); \n  auto loading = m_stateMgr-> \n    GetState<State_Loading>(StateType::Loading); \n  context->m_particles->PurgeCurrentState(); \n  context->m_gameMap->PurgeMap(); \n  context->m_gameMap->ResetWorker(); \n  context->m_gameMap->GetTileMap()->GetTileSet().ResetWorker(); \n  context->m_gameMap->AddFile(l_path); \n  loading->AddLoader(context->m_gameMap); \n  loading->SetManualContinue(false); \n  m_mapRedraw = true; \n  m_mapSavePath = l_path; \n  m_stateMgr->SwitchTo(StateType::Loading); \n} \n\n```", "```cpp\nvoid State_MapEditor::SaveMap(const std::string& l_path) { \n  m_stateMgr->GetContext()->m_gameMap->SaveToFile(l_path); \n  m_mapSavePath = l_path; \n} \n\n```", "```cpp\nvoid State_MapEditor::MapAction(const std::string& l_path) { \n  if(m_files.IsInSaveMode()) { SaveMap(l_path); } \n  else { LoadMap(l_path); } \n  m_files.Hide(); \n} \n\n```", "```cpp\nvoid State_MapEditor::Activate() { \n  if (!m_mapRedraw) { return; } \n  auto map = m_stateMgr->GetContext()->m_gameMap; \n  map->Redraw(); \n  m_mapControls.SetTileSheetTexture( \n    map->GetTileSet()->GetTextureName()); \n  m_mapRedraw = false; \n} \n\n```", "```cpp\nvoid State_MapEditor::Update(const sf::Time& l_time) { \n  auto context = m_stateMgr->GetContext(); \n  m_mapControls.Update(l_time.asSeconds()); \n  context->m_gameMap->Update(l_time.asSeconds()); \n  context->m_systemManager->Update(l_time.asSeconds()); \n  context->m_particles->Update(l_time.asSeconds()); \n} \n\n```", "```cpp\nvoid State_MapEditor::Draw() { \n  auto context = m_stateMgr->GetContext(); \n  auto window = context->m_wind->GetRenderWindow(); \n  auto from = (m_mapControls.DrawSelectedLayers() ? \n    m_mapControls.GetSelectionOptions()->GetLowestLayer() : 0); \n  auto to = (m_mapControls.DrawSelectedLayers() ? \n    m_mapControls.GetSelectionOptions()->GetHighestLayer() \n    : Sheet::Num_Layers - 1); \n  for (auto i = from; i <= to; ++i) { \n    context->m_gameMap->Draw(i); \n    context->m_systemManager->Draw(context->m_wind, i); \n    context->m_particles->Draw(*window, i); \n  } \n  if(!m_mapControls.DrawSelectedLayers()) { \n    context->m_particles->Draw(*window, -1); \n  } \n  m_mapControls.Draw(window); \n} \n\n```", "```cpp\nvoid State_MapEditor::ResetSavePath() { m_mapSavePath = \"\"; } \nvoid State_MapEditor::SetMapRedraw(bool l_redraw) { \n  m_mapRedraw = l_redraw; \n} \n\n```", "```cpp\nenum class ControlMode{None, Pan, Brush, Bucket, Eraser, Select}; \n\n```", "```cpp\nclass MapControls { \npublic: \n  MapControls(Window* l_window, EventManager* l_eventManager, \n    StateManager* l_stateManager, Map* l_map, GUI_Manager* l_gui, \n    EntityManager* l_entityMgr, ParticleSystem* l_particles, \n    sf::View& l_view); \n  ~MapControls(); \n\n  void Update(float l_dT); \n  void Draw(sf::RenderWindow* l_window); \n\n  void NewMap(); \n  void SetTileSheetTexture(const std::string& l_sheet); \n  ControlMode GetMode() const; \n  bool IsInAction() const; \n  bool IsInSecondary() const; \n  GUI_SelectionOptions* GetSelectionOptions(); \n\n  sf::Vector2i GetMouseTileStart()const; \n  sf::Vector2i GetMouseTile()const; \n  sf::Vector2f GetMouseDifference()const; \n\n  bool DrawSelectedLayers()const; \n  void ToggleDrawingSelectedLayers(); \n\n  void MouseClick(EventDetails* l_details); \n  void MouseRelease(EventDetails* l_details); \n  void MouseWheel(EventDetails* l_details); \n  void ToolSelect(EventDetails* l_details); \n  void DeleteTiles(EventDetails* l_details); \n  void NewMapCreate(EventDetails* l_details); \n  void NewMapClose(EventDetails* l_details); \n\n  void SelectMode(ControlMode l_mode); \n  void RedrawBrush(); \nprivate: \n  void UpdateMouse(); \n  void PanUpdate(); \n  void BrushUpdate(); \n  void BucketUpdate(); \n  void EraserUpdate(); \n  void SelectionUpdate(); \n\n  void PlaceBrushTiles(); \n  void ResetZoom(); \n  void ResetTools(); \n  ... \n}; \n\n```", "```cpp\nclass MapControls { \nprivate: \n  ... \n  // Mode and mouse/layer flags. \n  ControlMode m_mode; \n  bool m_action; \n  bool m_secondaryAction; \n  bool m_rightClickPan; \n  bool m_drawSelectedLayers; \n  // Mouse information. \n  sf::Vector2i m_mousePosition; \n  sf::Vector2i m_mouseStartPosition; \n  sf::Vector2f m_mouseDifference; \n  sf::Vector2i m_mouseTilePosition; \n  sf::Vector2i m_mouseTileStartPosition; \n  float m_zoom; \n  // Brush information, and map bounds. \n  TileMap m_brush; \n  sf::RenderTexture m_brushTexture; \n  sf::RectangleShape m_brushDrawable; \n  sf::RectangleShape m_mapBoundaries; \n  // Other interfaces used here. \n  GUI_MapTileSelector m_tileSelector; \n  GUI_SelectionOptions m_selectionOptions; \n  GUI_Interface* m_mapSettings; \n  // Ties to other classes. \n  Window* m_window; \n  EventManager* m_eventManager; \n  StateManager* m_stateManager; \n  Map* m_map; \n  GUI_Manager* m_guiManager; \n  EntityManager* m_entityManager; \n  ParticleSystem* m_particleSystem; \n  sf::View& m_view; \n}; \n\n```", "```cpp\nMapControls::MapControls(Window* l_window, EventManager* l_eventManager, \n  StateManager* l_stateManager, Map* l_map, GUI_Manager* l_gui, \n  EntityManager* l_entityMgr, ParticleSystem* l_particles, \n  sf::View& l_view): \n  /* Storing arguments first. */ \n  m_window(l_window), m_eventManager(l_eventManager), \n  m_stateManager(l_stateManager), m_map(l_map), \n  m_guiManager(l_gui), m_entityManager(l_entityMgr), \n  m_particleSystem(l_particles), m_view(l_view), \n  /* Setting up initial data member values. */ \n  m_mode(ControlMode::Pan), m_action(false), \n  m_secondaryAction(false), m_rightClickPan(false), \n  m_zoom(1.f), m_brush(sf::Vector2u(1, 1), *l_map->GetTileSet()), \n  m_drawSelectedLayers(false), \n  /* Initializing other interface classes. */ \n  m_tileSelector(l_eventManager, l_gui, \n    l_gui->GetContext()->m_textureManager), \n  m_mapSettings(nullptr), \n  m_selectionOptions(l_eventManager, l_gui, this, \n    &m_tileSelector, l_map, &m_brush, l_entityMgr, l_particles) \n{ ... } \n\n```", "```cpp\nMapControls::MapControls(...) \n{ \n  ... // All of the callbacks gets set up. \n  m_guiManager->LoadInterface(\"MapEditorTools.interface\", \n    \"MapEditorTools\"); \n  m_guiManager->GetInterface(\"MapEditorTools\")-> \n    SetPosition({ 0.f, 16.f }); \n  m_guiManager->LoadInterface(\"MapEditorNewMap.interface\", \n    \"MapEditorNewMap\"); \n  m_mapSettings = m_guiManager->GetInterface(\"MapEditorNewMap\"); \n  m_mapSettings->PositionCenterScreen(); \n  m_mapSettings->SetActive(false); \n\n  m_brush.SetTile(0, 0, 0, 0); \n  m_brushDrawable.setFillColor({ 255, 255, 255, 200 }); \n  m_brushDrawable.setOutlineColor({ 255, 0, 0, 255 }); \n  m_brushDrawable.setOutlineThickness(-1.f); \n  m_mapBoundaries.setPosition({ 0.f, 0.f }); \n  m_mapBoundaries.setFillColor({ 0,0,0,0 }); \n  m_mapBoundaries.setOutlineColor({255, 50, 50, 255}); \n  m_mapBoundaries.setOutlineThickness(-1.f); \n\n  auto dropdown = static_cast<GUI_DropDownMenu*>( \n    m_mapSettings->GetElement(\"SheetDropdown\"))->GetMenu(); \n  dropdown->PurgeEntries(); \n  auto names = Utils::GetFileList(Utils::GetWorkingDirectory() + \n    \"media/Tilesheets/\", \"*.tilesheet\"); \n  for (auto& entity : names) { \n    dropdown->AddEntry(entity.first.substr( \n      0, entity.first.find(\".tilesheet\"))); \n  } \n  dropdown->Redraw(); \n} \n\n```", "```cpp\nvoid MapControls::Update(float l_dT) { \n  m_mapBoundaries.setSize(sf::Vector2f( \n    m_map->GetTileMap()->GetMapSize() * \n    static_cast<unsigned int>(Sheet::Tile_Size))); \n  UpdateMouse(); \n  if (m_mode == ControlMode::Pan || m_rightClickPan){PanUpdate();} \n  else if (m_mode == ControlMode::Brush) { BrushUpdate(); } \n  else if (m_mode == ControlMode::Bucket) { BucketUpdate(); } \n  else if (m_mode == ControlMode::Eraser) { EraserUpdate(); } \n  else if (m_mode == ControlMode::Select) { SelectionUpdate(); } \n} \n\n```", "```cpp\nvoid MapControls::Draw(sf::RenderWindow* l_window) { \n  l_window->draw(m_mapBoundaries); \n  if (m_mode == ControlMode::Brush) { \n    l_window->draw(m_brushDrawable); \n  } \n  m_selectionOptions.Draw(l_window); \n} \n\n```", "```cpp\nvoid MapControls::UpdateMouse() { \n  auto mousePos = m_eventManager->GetMousePos( \n    m_window->GetRenderWindow()); \n  m_mouseDifference = sf::Vector2f(mousePos - m_mousePosition); \n  m_mouseDifference *= m_zoom; \n  m_mousePosition = mousePos; \n  auto view = m_window->GetRenderWindow()->getView(); \n  auto viewPos = view.getCenter() - (view.getSize() * 0.5f); \n  auto mouseGlobal=viewPos+(sf::Vector2f(m_mousePosition)*m_zoom); \n  auto newPosition = sf::Vector2i( \n    floor(mouseGlobal.x / Sheet::Tile_Size), \n    floor(mouseGlobal.y / Sheet::Tile_Size) \n  ); \n\n  if (m_mouseTilePosition != newPosition && m_action) { \n    m_secondaryAction = true; \n  } \n  m_mouseTilePosition = newPosition; \n} \n\n```", "```cpp\nvoid MapControls::MouseClick(EventDetails* l_details) { \n  if (l_details->m_hasBeenProcessed) { return; } \n  if (l_details->m_keyCode != \n    static_cast<int>(MouseButtonType::Left)) \n  { \n    m_rightClickPan = true; \n    return; \n  } \n  m_mousePosition = m_eventManager->GetMousePos( \n    m_window->GetRenderWindow()); \n  m_mouseStartPosition = m_mousePosition; \n\n  auto view = m_window->GetRenderWindow()->getView(); \n  auto viewPos = view.getCenter() - (view.getSize() * 0.5f); \n  auto mouseGlobal = viewPos + (sf::Vector2f(m_mousePosition) \n    * m_zoom); \n  m_mouseTileStartPosition = sf::Vector2i( \n    floor(mouseGlobal.x / Sheet::Tile_Size), \n    floor(mouseGlobal.y / Sheet::Tile_Size) \n  ); \n\n  if (!m_selectionOptions.MouseClick(mouseGlobal)) { return; } \n\n  m_action = true; \n  m_secondaryAction = true; \n} \n\n```", "```cpp\nvoid MapControls::MouseRelease(EventDetails* l_details) { \n  if (l_details->m_keyCode != \n    static_cast<int>(MouseButtonType::Left)) \n  { \n    m_rightClickPan = false; \n    return; \n  } \n  m_action = false; \n  m_secondaryAction = false; \n  m_selectionOptions.MouseRelease(); \n} \n\n```", "```cpp\nvoid MapControls::MouseWheel(EventDetails* l_details) { \n  if (l_details->m_hasBeenProcessed) { return; } \n  float factor = 0.05f; \n  factor *= l_details->m_mouseWheelDelta; \n  factor = 1.f - factor; \n  m_view.zoom(factor); \n  m_zoom *= factor; \n} \n\n```", "```cpp\nvoid MapControls::ToolSelect(EventDetails* l_details) { \n  auto mode = ControlMode::None; \n  if (l_details->m_name == \"MapEditor_PanTool\") { \n    mode = ControlMode::Pan; \n  } else if (l_details->m_name == \"MapEditor_BrushTool\") { \n    mode = ControlMode::Brush; \n  } else if (l_details->m_name == \"MapEditor_PaintTool\") { \n    mode = ControlMode::Bucket; \n  } else if (l_details->m_name == \"MapEditor_EraserTool\") { \n    mode = ControlMode::Eraser; \n  } else if (l_details->m_name == \"MapEditor_SelectTool\") { \n    mode = ControlMode::Select; \n  } \n  SelectMode(mode); \n} \n\n```", "```cpp\nvoid MapControls::PanUpdate() { \n  if (!m_action && !m_rightClickPan) { return; } \n  if (m_mouseDifference == sf::Vector2f(0.f, 0.f)) { return; } \n  m_view.setCenter(m_view.getCenter() + \n    (sf::Vector2f(0.f, 0.f) - sf::Vector2f(m_mouseDifference))); \n} \n\n```", "```cpp\nvoid MapControls::BrushUpdate() { \n  auto tilePos = sf::Vector2f( \n    static_cast<float>(m_mouseTilePosition.x * Sheet::Tile_Size), \n    static_cast<float>(m_mouseTilePosition.y * Sheet::Tile_Size) \n  ); \n  m_brushDrawable.setPosition(tilePos); \n  PlaceBrushTiles(); \n} \n\n```", "```cpp\nvoid MapControls::PlaceBrushTiles() { \n  if (!m_action || !m_secondaryAction) { return; } \n  m_map->GetTileMap()->PlotTileMap(m_brush, \n    m_mouseTilePosition, m_selectionOptions.GetLowestLayer()); \n  auto size = m_brush.GetMapSize(); \n  auto from = sf::Vector3i(m_mouseTilePosition.x, \n    m_mouseTilePosition.y, m_selectionOptions.GetLowestLayer()); \n  auto to = sf::Vector3i(m_mouseTilePosition.x + size.x - 1, \n    m_mouseTilePosition.y + size.y - 1, \n    m_selectionOptions.GetHighestLayer()); \n  m_map->Redraw(from, to); \n  m_secondaryAction = false; \n  // Set it to false in order to avoid multiple placements. \n} \n\n```", "```cpp\nvoid MapControls::SelectionUpdate() { \n  m_selectionOptions.SelectionUpdate(); \n} \n\n```", "```cpp\nvoid MapControls::RedrawBrush() { \n  auto brushSize = m_brush.GetMapSize(); \n  auto brushRealSize = brushSize * \n    static_cast<unsigned int>(Sheet::Tile_Size); \n  auto textureSize = m_brushTexture.getSize(); \n  if (brushRealSize.x != textureSize.x || \n    brushRealSize.y != textureSize.y) \n  { \n    if (!m_brushTexture.create(brushRealSize.x, brushRealSize.y)) \n    { /* Error Message. */ } \n  } \n\n  m_brushTexture.clear({ 0, 0, 0, 0 }); \n\n  for (auto x = 0; x < brushSize.x; ++x) { \n    for (auto y = 0; y < brushSize.y; ++y) { \n      for (auto layer = 0; layer < Sheet::Num_Layers; ++layer) { \n        auto tile = m_brush.GetTile(x, y, layer); \n        if (!tile) { continue; } \n        auto info = tile->m_properties; \n        if (!info) { continue; } \n        info->m_sprite.setPosition(sf::Vector2f( \n          x * Sheet::Tile_Size, y * Sheet::Tile_Size)); \n        m_brushTexture.draw(info->m_sprite); \n      } \n    } \n  } \n\n  m_brushTexture.display(); \n  m_brushDrawable.setTexture(&m_brushTexture.getTexture()); \n  m_brushDrawable.setSize(sf::Vector2f(brushRealSize)); \n  m_brushDrawable.setTextureRect( \n    sf::IntRect(sf::Vector2i(0, 0), sf::Vector2i(brushRealSize))); \n} \n\n```", "```cpp\nvoid MapControls::DeleteTiles(EventDetails* l_details) { \n  if (m_mode != ControlMode::Select) { return; } \n  m_selectionOptions.RemoveSelection(l_details); \n} \n\n```", "```cpp\nvoid MapControls::ResetTools() { \n  auto defaultVector = sf::Vector2i(-1, -1); \n  m_mouseTilePosition = defaultVector; \n  m_mouseTileStartPosition = defaultVector; \n  m_selectionOptions.Reset(); \n  m_tileSelector.Hide(); \n} \n\n```", "```cpp\nvoid MapControls::ResetZoom() { \n  m_view.zoom(1.f / m_zoom); \n  m_zoom = 1.f; \n} \n\n```", "```cpp\nvoid MapControls::SelectMode(ControlMode l_mode) { \n  ResetTools(); \n  m_mode = l_mode; \n  if (m_mode == ControlMode::Brush) { RedrawBrush(); } \n  m_selectionOptions.SetControlMode(m_mode); \n} \n\n```", "```cpp\nvoid MapControls::NewMapCreate(EventDetails* l_details) { \n  auto s_x = m_mapSettings->GetElement(\"Size_X\")->GetText(); \n  auto s_y = m_mapSettings->GetElement(\"Size_Y\")->GetText(); \n  auto friction = m_mapSettings-> \n    GetElement(\"Friction\")->GetText(); \n  auto selection = static_cast<GUI_DropDownMenu*>( \n    m_mapSettings->GetElement(\"SheetDropdown\"))-> \n    GetMenu()->GetSelected(); \n  if (selection.empty()) { return; } \n\n  auto context = m_guiManager->GetContext(); \n  auto editorState = m_stateManager-> \n    GetState<State_MapEditor>(StateType::MapEditor); \n  m_particleSystem->PurgeCurrentState(); \n  m_map->PurgeMap(); \n  editorState->ResetSavePath(); \n\n  m_map->GetTileMap()->SetMapSize \n    sf::Vector2u(std::stoi(s_x), std::stoi(s_y))); \n  m_map->GetDefaultTile()->m_friction = \n    sf::Vector2f(std::stof(friction), std::stof(friction)); \n  m_map->GetTileSet()->ResetWorker(); \n  m_map->GetTileSet()->AddFile(Utils::GetWorkingDirectory() + \n    \"media/Tilesheets/\" + selection + \".tilesheet\"); \n  m_map->GetTileSet()->SetName(selection + \".tilesheet\"); \n\n  auto loading = m_stateManager-> \n    GetState<State_Loading>(StateType::Loading); \n  loading->AddLoader(context->m_gameMap->GetTileSet()); \n  loading->SetManualContinue(false); \n  editorState->SetMapRedraw(true); \n  m_mapSettings->SetActive(false); \n  m_stateManager->SwitchTo(StateType::Loading); \n} \n\n```", "```cpp\nvoid MapControls::NewMapClose(EventDetails* l_details) { \n  m_mapSettings->SetActive(false); \n} \n\n```", "```cpp\nvoid MapControls::NewMap() { m_mapSettings->SetActive(true); } \nvoid MapControls::SetTileSheetTexture(const std::string& l_sheet) { \n  m_tileSelector.SetSheetTexture(l_sheet); \n} \nControlMode MapControls::GetMode() const { return m_mode; } \nbool MapControls::IsInAction() const { return m_action; } \nbool MapControls::IsInSecondary() const{return m_secondaryAction;} \nGUI_SelectionOptions* MapControls::GetSelectionOptions() { \n  return &m_selectionOptions; \n} \nsf::Vector2i MapControls::GetMouseTileStart() const { \n  return m_mouseTileStartPosition; \n} \nsf::Vector2i MapControls::GetMouseTile() const { \n  return m_mouseTilePosition; \n} \nsf::Vector2f MapControls::GetMouseDifference() const { \n  return m_mouseDifference; \n} \nbool MapControls::DrawSelectedLayers() const { \n  return m_drawSelectedLayers; \n} \nvoid MapControls::ToggleDrawingSelectedLayers() { \n  m_drawSelectedLayers = !m_drawSelectedLayers; \n} \n\n```", "```cpp\nvoid MapControls::BucketUpdate() { /* IMPLEMENT */ } \nvoid MapControls::EraserUpdate() { /* IMPLEMENT */ } \n\n```"]