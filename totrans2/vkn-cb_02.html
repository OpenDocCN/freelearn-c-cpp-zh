<html><head></head><body>
        

            
                <h1 class="header-title">Image Presentation</h1>
            

            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a Vulkan Instance with WSI extensions enabled</li>
<li>Creating a presentation surface</li>
<li>Selecting a queue family that supports presentation to a given surface</li>
<li>Creating a logical device with WSI extensions enabled</li>
<li>Selecting a desired presentation mode</li>
<li>Getting capabilities of a presentation surface</li>
<li>Selecting a number of swapchain images</li>
<li>Choosing a size of swapchain images</li>
<li>Selecting desired usage scenarios of swapchain images</li>
<li>Selecting a transformation of swapchain images</li>
<li>Selecting a format of swapchain images</li>
<li>Creating a swapchain</li>
<li>Getting handles of swapchain images</li>
<li>Creating a swapchain with R8G8B8A8 format and a mailbox present mode</li>
<li>Acquiring a swapchain image</li>
<li>Presenting an image</li>
<li>Destroying a swapchain</li>
<li>Destroying a presentation surface</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Introduction</h1>
            

            
                
<p>APIs such as Vulkan can be used for many different purposes, such as mathematical and physical computations, image or video stream processing, and data visualizations. But the main purpose Vulkan was designed for and its most common usage is efficiently rendering 2D and 3D graphics. And when our application generates an image, we usually would like to display it on screen.</p>
<p>At first, it may seem surprising that the core of the Vulkan API doesn't allow for displaying generated images in the application's window. This is because Vulkan is a portable, cross-platform API but, unfortunately, there is no universal standard for presenting images on screen in different operating systems because they have drastically different architectures and standards.</p>
<p>That's why a set of extensions was introduced for the Vulkan API which allow us to present generated images in an application's window. These extensions are commonly referred to as Windowing System Integration (WSI). Each operating system on which Vulkan is available has its own set of extensions that integrate Vulkan with the windowing system specific for a given OS.</p>
<p>The most important extension is the one which allows us to create a swapchain. A swapchain is an array of images that can be presented (displayed) to the user. In this chapter, we will be preparing for drawing images on screen--setting up image parameters such as format, size, and so on. We will also take a look at the various available <strong>presentation</strong> modes that determine the way images are displayed, that is, define whether vertical sync is enabled or disabled. And, finally, we will see how to present the images--display them in the application's window.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a Vulkan Instance with WSI extensions enabled</h1>
            

            
                
<p>To be able to properly display images on screen, we need to enable a set of WSI extensions. They are divided into instance- and device-levels, depending on the functionality they introduce. The first step is to create a Vulkan Instance with a set of enabled extensions that allow us to create a presentation surface--a Vulkan representation of an application's window.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>On the Windows operating systems family, perform the following steps:</p>
<ol>
<li>Prepare a variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd>.</li>
<li>Prepare a variable of type <kbd>std::vector&lt;char const *&gt;</kbd> named <kbd>desired_extensions</kbd>. Store the names of all extensions you want to enable in the <kbd>desired_extensions</kbd> variable.</li>
<li>Add another element to the <kbd>desired_extensions</kbd> vector with the <kbd>VK_KHR_SURFACE_EXTENSION_NAME</kbd> value.</li>
<li>Add yet another element to the <kbd>desired_extensions</kbd> vector with the <kbd>VK_KHR_WIN32_SURFACE_EXTENSION_NAME</kbd> value.</li>
<li>Create a Vulkan Instance object for which enable all of the extensions specified in the <kbd>desired_extensions</kbd> variable (refer to the <em>Creating a Vulkan Instance</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>).</li>
</ol>
<p>On the Linux operating systems family with an <strong>X11</strong> windowing system through an <strong>XLIB</strong> interface, perform the following steps:</p>
<ol>
<li>Prepare a variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd>.</li>
<li>Prepare a variable of type <kbd>std::vector&lt;char const *&gt;</kbd> named <kbd>desired_extensions</kbd>. Store the names of all extensions you want to enable in the <kbd>desired_extensions</kbd> variable.</li>
<li>Add another element to the <kbd>desired_extensions</kbd> vector with the <kbd>VK_KHR_SURFACE_EXTENSION_NAME</kbd> value.</li>
<li>Add yet another element to the <kbd>desired_extensions</kbd> vector with the <kbd>VK_KHR_XLIB_SURFACE_EXTENSION_NAME</kbd> value.</li>
<li>Create a Vulkan Instance object for which enable all of the extensions specified in the <kbd>desired_extensions</kbd> variable (refer to the <em>Creating a Vulkan Instance</em> recipe from <a href="https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&amp;action=edit#post_42" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>).</li>
</ol>
<p>On the Linux operating systems family with an X11 windowing system through an <strong>XCB</strong> interface, perform the following steps:</p>
<ol>
<li>Prepare a variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd>.</li>
<li>Prepare a variable of type <kbd>std::vector&lt;char const *&gt;</kbd> named <kbd>desired_extensions</kbd>. Store the names of all extensions you want to enable in the <kbd>desired_extensions</kbd> variable.</li>
</ol>
<ol start="3">
<li>Add another element to the <kbd>desired_extensions</kbd> vector with the <kbd>VK_KHR_SURFACE_EXTENSION_NAME</kbd> value.</li>
<li>Add yet another element to the <kbd>desired_extensions</kbd> vector with the <kbd>VK_KHR_XCB_SURFACE_EXTENSION_NAME</kbd> value.</li>
<li>Create a Vulkan Instance object for which enable all of the extensions specified in the <kbd>desired_extensions</kbd> variable (refer to the <em>Creating a Vulkan Instance</em> recipe from <a href="https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&amp;action=edit#post_42" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>).</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>Instance-level extensions are responsible for managing, creating, and destroying a presentation surface. It is a (cross-platform) representation of an application's window. Through it, we can check whether we are able to draw to the window (displaying an image, a presentation, is an additional property of a queue family), what its parameters are, or what presentation modes are supported (if we want the vertical sync to be enabled or disabled).</p>
<p>The presentation surface is directly connected to our application's window, so it can be created only in a way that is specific for a given operating system. That's why this functionality is introduced through extensions and each operating system has its own extension for creating a presentation surface. On the Windows operating systems family, this extension is called <kbd>VK_KHR_win32_surface</kbd>. On the Linux operating systems family with an X11 windowing system, this extension is called <kbd>VK_KHR_xlib_surface</kbd>. On the Linux operating systems family with an XCB windowing system, this extension is called <kbd>VK_KHR_xcb_surface</kbd>.</p>
<p>The functionality of destroying a presentation surface is enabled via an additional extension called <kbd>VK_KHR_surface</kbd>. It is available on all operating systems. So in order to properly manage a presentation surface, check its parameters, and verify the ability to present to it, we need to enable two extensions during Vulkan Instance creation.</p>
<div><p><kbd>VK_KHR_win32_surface</kbd> and <kbd>VK_KHR_surface</kbd> extensions introduce the ability to create and destroy a presentation surface on the Windows OS family.</p>
<p><kbd>VK_KHR_xlib_surface</kbd> and <kbd>VK_KHR_surface</kbd> extensions introduce the ability to create and destroy a presentation surface on the Linux OS family with an X11 windowing system and an XLIB interface.</p>
<p><kbd>VK_KHR_xcb_surface</kbd> and <kbd>VK_KHR_surface</kbd> extensions introduce the ability to create and destroy a presentation surface on the Linux OS family with an X11 windowing system and an XCB interface.</p>
</div>
<p>In order to create a Vulkan Instance that supports the process of creating and destroying a presentation surface, we need to prepare the following code:</p>
<pre>
desired_extensions.emplace_back( VK_KHR_SURFACE_EXTENSION_NAME ); 
desired_extensions.emplace_back( 
#ifdef VK_USE_PLATFORM_WIN32_KHR 
  VK_KHR_WIN32_SURFACE_EXTENSION_NAME 

#elif defined VK_USE_PLATFORM_XCB_KHR 
  VK_KHR_XCB_SURFACE_EXTENSION_NAME 

#elif defined VK_USE_PLATFORM_XLIB_KHR 
  VK_KHR_XLIB_SURFACE_EXTENSION_NAME 
#endif 
); 

return CreateVulkanInstance( desired_extensions, application_name, instance );
</pre>
<p>In the preceding code, we begin with a vector variable in which the names of all extensions we want to enable are stored. We then add the required WSI extensions to the vector. The names of these extensions are provided through convenient preprocessor definitions. They are defined in the <kbd>vulkan.h</kbd> file. With them, we don't need to remember the exact names of extensions and if we make a mistake, compiler will tell us about it.</p>
<p>After we are done preparing the list of required extensions, we can create a Vulkan Instance object in the same way as described in the <em>Creating a Vulkan Instance</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>In <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em> see the following recipes:
<ul>
<li><em>Checking available Instance extensions</em></li>
<li><em>Creating a Vulkan Instance</em></li>
</ul>
</li>
<li>The following recipe in this chapter:
<ul>
<li><em>Creating a logical device with WSI extensions enabled</em></li>
</ul>
</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a presentation surface</h1>
            

            
                
<p>A presentation surface represents an application's window. It allows us to acquire the window's parameters, such as dimensions, supported color formats, required number of images, or presentation modes. It also allows us to check whether a given physical device is able to display an image in a given window.</p>
<p>That's why, in situations where we want to show an image on screen, we need to create a presentation surface first, as it will help us choose a physical device that suits our needs.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>To create a presentation surface, we need to provide the parameters of an application's window. In order to do that, the window must have been already created. In this recipe, we will provide its parameters through a structure of type <kbd>WindowParameters</kbd>. Its definition looks like this:</p>
<pre>
struct WindowParameters { 
#ifdef VK_USE_PLATFORM_WIN32_KHR 
  HINSTANCE          HInstance; 
  HWND               HWnd; 
#elif defined VK_USE_PLATFORM_XLIB_KHR 
  Display          * Dpy; 
  Window             Window; 
#elif defined VK_USE_PLATFORM_XCB_KHR 
  xcb_connection_t * Connection; 
  xcb_window_t       Window; 
#endif 
};
</pre>
<p>On Windows, the structure contains the following parameters:</p>
<ul>
<li>A variable of type <kbd>HINSTANCE</kbd> named <kbd>HInstance</kbd> in which we store the value acquired using the <kbd>GetModuleHandle()</kbd> function</li>
<li>A variable of type <kbd>HWND</kbd> named <kbd>HWnd</kbd> in which we store a value returned by the <kbd>CreateWindow()</kbd> function</li>
</ul>
<p>On Linux with an X11 windowing system and an XLIB interface, the structure contains the following members:</p>
<ul>
<li>A variable of type <kbd>Display*</kbd> named <kbd>Dpy</kbd> in which the value of the <kbd>XOpenDisplay()</kbd> function call is stored</li>
<li>A variable of type <kbd>Window</kbd> named <kbd>Window</kbd> to which we assign a value returned by <kbd>XCreateWindow()</kbd> or <kbd>XCreateSimpleWindow()</kbd> functions</li>
</ul>
<p>On Linux with an X11 windowing system and an XCB interface, the <kbd>WindowParameters</kbd> structure contains the following members:</p>
<ul>
<li>A variable of type <kbd>xcb_connection_t*</kbd> named <kbd>Connection</kbd> in which we store a value returned by the <kbd>xcb_connect()</kbd> function</li>
<li>A variable of type <kbd>xcb_window_t</kbd> named <kbd>Window</kbd> in which a value returned by the <kbd>xcb_generate_id()</kbd> function is stored</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>On the Windows operating systems family, perform the following steps:</p>
<ol>
<li>Take the variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd> in which a handle of a created Vulkan Instance is stored.</li>
<li>Create a variable of type <kbd>WindowParameters</kbd> named <kbd>window_parameters</kbd>. Assign the following values for its members:
<ul>
<li>A value returned by the <kbd>CreateWindow()</kbd> function for <kbd>HWnd</kbd></li>
<li>A value returned by the <kbd>GetModuleHandle(nullptr)</kbd> function for <kbd>HInstance</kbd></li>
</ul>
</li>
</ol>
<ol start="3">
<li>Create a variable of type <kbd>VkWin32SurfaceCreateInfoKHR</kbd> named <kbd>surface_create_info</kbd> and initialize its members with the following values:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li><kbd>window_parameters.HInstance</kbd> member for <kbd>hinstance</kbd></li>
<li><kbd>window_parameters.HWnd</kbd> member for <kbd>hwnd</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd> and assign a <kbd>VK_NULL_HANDLE</kbd> value to it.</li>
<li>Call <kbd>vkCreateWin32SurfaceKHR(instance, &amp;surface_create_info, nullptr, &amp;presentation_surface)</kbd>. Provide a handle of a created Instance in the first parameter, a pointer to the <kbd>surface_create_info</kbd> variable in the second parameter, a <kbd>nullptr</kbd> value in the third parameter, and a pointer to the <kbd>presentation_surface</kbd> variable in the last parameter.</li>
<li>Make sure the <kbd>vkCreateWin32SurfaceKHR()</kbd> function call was successful by checking whether the value returned by it is equal to <kbd>VK_SUCCESS</kbd> and the value of the <kbd>presentation_surface</kbd> variable is not equal to a <kbd>VK_NULL_HANDLE</kbd>.</li>
</ol>
<p>On the Linux operating systems family with an X11 windowing system and an XLIB interface, perform the following steps:</p>
<ol>
<li>Take the variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd> in which a handle of a created Vulkan Instance is stored.</li>
<li>Create a variable of type <kbd>WindowParameters</kbd> named <kbd>window_parameters</kbd>. Assign the following values for its members:
<ul>
<li>A value returned by the <kbd>XOpenDisplay()</kbd> function for <kbd>Dpy</kbd></li>
<li>A value returned by the <kbd>XCreateSimpleWindow()</kbd> or <kbd>XCreateWindow()</kbd> functions for <kbd>Window</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkXlibSurfaceCreateInfoKHR</kbd> named <kbd>surface_create_info</kbd> and initialize its members with the following values:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li><kbd>window_parameters.Dpy</kbd> member for <kbd>dpy</kbd></li>
<li><kbd>window_parameters.Window</kbd> member for <kbd>window</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd> and assign a <kbd>VK_NULL_HANDLE</kbd> value to it.</li>
</ol>
<ol start="5">
<li>Call <kbd>vkCreateXlibSurfaceKHR(instance, &amp;surface_create_info, nullptr, &amp;presentation_surface)</kbd>. Provide a handle of a created Instance in the first parameter, pointer to the <kbd>surface_create_info</kbd> variable in the second parameter, a <kbd>nullptr</kbd> value in the third parameter, and a pointer to the <kbd>presentation_surface</kbd> variable in the last parameter.</li>
<li>Make sure the <kbd>vkCreateXlibSurfaceKHR()</kbd> function call was successful by checking whether the value returned by it is equal to <kbd>VK_SUCCESS</kbd> and the value of the <kbd>presentation_surface</kbd> variable is not equal to <kbd>VK_NULL_HANDLE</kbd>.</li>
</ol>
<p>On the Linux operating systems family with an X11 windowing system and an XCB interface, perform the following steps:</p>
<ol>
<li>Take the variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd> in which a handle of a created Vulkan Instance is stored.</li>
<li>Create a variable of type <kbd>WindowParameters</kbd> named <kbd>window_parameters</kbd>. Assign the following values for its members:
<ul>
<li>A value returned by the <kbd>xcb_connect()</kbd> function for <kbd>Connection</kbd></li>
<li>A value returned by the <kbd>xcb_generate_id()</kbd> functions for <kbd>Window</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkXcbSurfaceCreateInfoKHR</kbd> named <kbd>surface_create_info</kbd> and initialize it's members with the following values:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li><kbd>window_parameters.Connection</kbd> member for <kbd>connection</kbd></li>
<li><kbd>window_parameters.Window</kbd> member for <kbd>window</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd> and assign a <kbd>VK_NULL_HANDLE</kbd> value to it.</li>
<li>Call <kbd>vkCreateXcbSurfaceKHR( instance, &amp;surface_create_info, nullptr, &amp;presentation_surface )</kbd>. Provide a handle of a created Instance in the first parameter, a pointer to the <kbd>surface_create_info</kbd> variable in the second parameter, a <kbd>nullptr</kbd> value in the third parameter, and a pointer to the <kbd>presentation_surface</kbd> variable in the last parameter.</li>
<li>Make sure the <kbd>vkCreateXcbSurfaceKHR()</kbd> function call was successful by checking whether the value returned by it is equal to <kbd>VK_SUCCESS</kbd> and the value of the <kbd>presentation_surface</kbd> variable is not equal to <kbd>VK_NULL_HANDLE</kbd>.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>Presentation surface creation depends heavily on parameters that are specific for a given operating system. On each OS, we need to create a variable of a different type and call a different function. Here is a code that creates a presentation surface on Windows:</p>
<pre>
#ifdef VK_USE_PLATFORM_WIN32_KHR 

VkWin32SurfaceCreateInfoKHR surface_create_info = { 
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR, 
  nullptr, 
  0, 
  window_parameters.HInstance, 
  window_parameters.HWnd 
}; 

VkResult result = vkCreateWin32SurfaceKHR( instance, &amp;surface_create_info, nullptr, &amp;presentation_surface );
</pre>
<p>Here is a part of the code that does the same on the Linux operating system, when we are using the X11 windowing system:</p>
<pre>
#elif defined VK_USE_PLATFORM_XLIB_KHR 

VkXlibSurfaceCreateInfoKHR surface_create_info = { 
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, 
  nullptr, 
  0, 
  window_parameters.Dpy, 
  window_parameters.Window 
}; 

VkResult result = vkCreateXlibSurfaceKHR( instance, &amp;surface_create_info, nullptr, &amp;presentation_surface );
</pre>
<p>And finally, here is the part for the XCB windowing system, also on Linux:</p>
<pre>
#elif defined VK_USE_PLATFORM_XCB_KHR 

VkXcbSurfaceCreateInfoKHR surface_create_info = { 
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, 
  nullptr, 
  0, 
  window_parameters.Connection, 
  window_parameters.Window 
}; 

VkResult result = vkCreateXcbSurfaceKHR( instance, &amp;surface_create_info, nullptr, &amp;presentation_surface ); 

#endif
</pre>
<p>The preceding code samples are very similar. In each, we create a variable of a structure type whose members we initialize with parameters of a created window. Next we call a <kbd>vkCreate???SurfaceKHR()</kbd> function which creates a presentation surface and stores its handle in the <kbd>presentation_surface</kbd> variable. After that, we should check whether everything worked as expected:</p>
<pre>
if( (VK_SUCCESS != result) || 
    (VK_NULL_HANDLE == presentation_surface) ) { 
  std::cout &lt;&lt; "Could not create presentation surface." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Getting capabilities of a presentation surface</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Destroying a presentation surface</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Selecting a queue family that supports presentation to a given surface</h1>
            

            
                
<p>Displaying an image on screen is performed by submitting a special command to the device's queue. We can't display images using any queues we want or, in other words, we can't submit this operation to any queue. This is because it may not be supported. Image presentation, along with the graphics, compute, transfer, and sparse operations, is another property of a queue family. And similar to all types of operations, not all queues may support it and, more importantly, not even all devices may support it. That's why we need to check what queue family from which physical device allows us to present an image on screen.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a physical device returned by the <kbd>vkEnumeratePhysicalDevices()</kbd> function. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Take the created presentation surface and store its handle in a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Create a <kbd>std::vector</kbd> with elements of type <kbd>VkQueueFamilyProperties</kbd> and call it <kbd>queue_families</kbd>.</li>
<li>Enumerate all queue families that are available on a physical device represented by the <kbd>physical_device</kbd> variable (refer to the <em>Checking available queue families and their properties</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>). Store the results of this operation in the <kbd>queue_families</kbd> variable.</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>queue_family_index</kbd>.</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>index</kbd>. Use it to loop over all elements of the <kbd>queue_families</kbd> vector. For each element of the <kbd>queue_families</kbd> variable, perform the following steps: 
<ol>
<li>Create a variable of type <kbd>VkBool32</kbd> named <kbd>presentation_supported</kbd>. Assign a value of <kbd>VK_FALSE</kbd> to this variable.</li>
<li>Call <kbd>vkGetPhysicalDeviceSurfaceSupportKHR(physical_device, index, presentation_surface, &amp;presentation_supported)</kbd>. Provide a handle of the physical device in the first argument, the number of the current loop iteration in the second argument, and a handle of the presentation surface in the third argument. Also, provide a pointer to the <kbd>presentation_supported</kbd> variable in the last argument.</li>
<li>Check whether the value returned by the <kbd>vkGetPhysicalDeviceSurfaceSupportKHR() </kbd>function is equal to <kbd>VK_SUCCESS</kbd> and whether the value of the <kbd>presentation_supported</kbd> variable is equal to <kbd>VK_TRUE</kbd>. If it is, store the value of a current loop iteration (<kbd>index</kbd> variable) in the <kbd>queue_family_index</kbd> variable and finish the loop.</li>
</ol>
</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>First we need to check what queue families are exposed by a given physical device. This operation is performed the same way as described in the <em>Checking available queue families and their properties</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>:</p>
<pre>
std::vector&lt;VkQueueFamilyProperties&gt; queue_families; 
if( !CheckAvailableQueueFamiliesAndTheirProperties( physical_device, queue_families ) ) { 
  return false; 
}
</pre>
<p>Next we can iterate over all available queue families and check whether a given family supports image presentation. This is performed by calling a <kbd>vkGetPhysicalDeviceSurfaceSupportKHR()</kbd> function which stores the information in a specified variable. If the image presentation is supported, we can remember an index of a given family. All queues from this family will support image presentation:</p>
<pre>
for( uint32_t index = 0; index &lt; static_cast&lt;uint32_t&gt;(queue_families.size()); ++index ) { 
  VkBool32 presentation_supported = VK_FALSE; 
  VkResult result = vkGetPhysicalDeviceSurfaceSupportKHR( physical_device, index, presentation_surface, &amp;presentation_supported ); 
  if( (VK_SUCCESS == result) &amp;&amp; 
      (VK_TRUE == presentation_supported) ) { 
    queue_family_index = index; 
    return true; 
  } 
} 
return false;
</pre>
<p>When there is no queue family exported by a given physical device that supports image presentation, we must check whether this operation is available on another physical device.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>In <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em> see the following recipes:</p>
<ul>
<li><em>Checking available queue families and their properties</em></li>
<li><em>Selecting index of a queue family with desired capabilities</em></li>
<li><em>Creating a logical device</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a logical device with WSI extensions enabled</h1>
            

            
                
<p>When we have created an Instance with WSI extensions enabled and have found a queue family that supports image presentation, it is time to create a logical device with another extension enabled. A device-level WSI extension allows us to create a swapchain. This is a collection of images which are managed by the presentation engine. In order to use any of these images and to render into them, we need to acquire them. After we are done, we give it back to the presentation engine. This operation is called a presentation and it informs the driver that we want to show an image to the user (present or display it on screen). The presentation engine displays it according to the parameters defined during swapchain creation. And we can create it only on logical devices with an enabled swapchain extension.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a physical device, for which there is a queue family that supports image presentation, and store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Prepare a list of queue families and a number of queues from each family. Assign a priority (a floating-point value between <kbd>0.0f</kbd> and <kbd>1.0f</kbd>) for each queue from each family. Store these parameters in a <kbd>std::vector</kbd> variable named <kbd>queue_infos</kbd> with elements of a custom type <kbd>QueueInfo</kbd> (refer to the <em>Creating a logical device</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>). Remember to include at least one queue from a family that supports image presentation.</li>
<li>Prepare a list of extensions that should be enabled. Store it in a variable of type <kbd>std::vector&lt;char const *&gt;</kbd> named <kbd>desired_extensions</kbd>.</li>
<li>Add another element to the <kbd>desired_extensions</kbd> variable with value equal to <kbd>VK_KHR_SWAPCHAIN_EXTENSION_NAME</kbd>.</li>
<li>Create a logical device using the parameters prepared in the <kbd>physical_device</kbd> and <kbd>queue_infos</kbd> variable and with all extensions enabled from the <kbd>desired_extensions</kbd> vector (refer to the <em>Creating a logical device</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>).</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>When we want to display images on screen, there is only one device-level extension that needs to be enabled during logical device creation. This is called <kbd>VK_KHR_swapchain</kbd> and allows us to create a swapchain.</p>
<p>A swapchain defines parameters that are very similar to the parameters of a default drawing buffer in the OpenGL API. It specifies, among others, the format of an image we want to render to, the number of images (which can be thought of as double or triple buffering), or a presentation mode (v-sync enabled or disabled). Images created along the swapchain are owned and managed by the presentation engine. We are not allowed to create or destroy them by ourselves. We can't even use them until we ask to do this. When we want to display an image on screen, we need to ask for one of the swapchain images (acquire it), render into it, and then give the image back to the presentation engine (present it).</p>
<p>The ability to specify a set of presentable images, to acquire them, and to display them on screen is defined in a <kbd>VK_KHR_swapchain</kbd> extension.</p>
<p>The functionality described is defined in the <kbd>VK_KHR_swapchain</kbd> extension. To enable it during logical device creation, we need to prepare the following code:</p>
<pre>
desired_extensions.emplace_back( VK_KHR_SWAPCHAIN_EXTENSION_NAME ); 

return CreateLogicalDevice( physical_device, queue_infos, desired_extensions, desired_features, logical_device );
</pre>
<p>The logical device creation code is identical to the operation described in the <em>Creating a logical device</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices</em>. Here, we just need to remember that we must check whether a given physical device supports a <kbd>VK_KHR_swapchain</kbd> extension, and after that, we need to include it in a list of extensions that should be enabled.</p>
<p>The name of the extension is specified through a <kbd>VK_KHR_SWAPCHAIN_EXTENSION_NAME</kbd> preprocessor definition. It is defined in the <kbd>vulkan.h</kbd> header file and it helps us avoid making typos in the name of the extension.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The following recipes in <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml" target="_blank">Chapter 1</a>, <em>Instance and Devices:</em>
<ul>
<li><em>Checking available device extensions</em></li>
<li><em>Creating a logical device</em></li>
</ul>
</li>
<li>The recipe <em>Creating a Vulkan Instance with WSI extensions</em> enabled in this chapter</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Selecting a desired presentation mode</h1>
            

            
                
<p>The ability to display images on screen is one of the most important features of a Vulkan's swapchain--and, in fact, it's what a swapchain was designed for. In OpenGL, when we finished rendering to a back buffer, we just switched it with a front buffer and the rendered image was displayed on screen. We could only determine whether we wanted to display an image along with blanking intervals (if we wanted a v-sync to be enabled) or not.</p>
<p>In Vulkan, we are not limited to only one image (back buffer) to which we can render. And, instead of two (v-sync enabled or disabled), we can select one of more ways in which images are displayed on screen. This is called a presentation mode and we need to specify it during swapchain creation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a physical device enumerated with the <kbd>vkEnumeratePhysicalDevices()</kbd> function. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Take the created presentation surface and store its handle in a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Create a variable of type <kbd>VkPresentModeKHR</kbd> named <kbd>desired_present_mode</kbd>. Store a desired presentation mode in this variable.</li>
</ol>
<ol start="4">
<li>Prepare a variable of type <kbd>uint32_t</kbd> named <kbd>present_modes_count</kbd>.</li>
<li>Call <kbd>vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, presentation_surface, &amp;present_modes_count, nullptr)</kbd>. Provide a handle of a physical device and a handle of a presentation surface as the first two arguments. In the third parameter, provide a pointer to the <kbd>present_modes_count</kbd> variable.</li>
<li>If a function call is successful, the <kbd>present_modes_count</kbd> variable will contain the number of supported presentation modes.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkPresentModeKHR&gt;</kbd> named <kbd>present_modes</kbd>. Resize the vector to be large enough to contain at least <kbd>present_modes_count</kbd> elements.</li>
<li>Once again, call <kbd>vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device, presentation_surface, &amp;present_modes_count, &amp;present_modes[0])</kbd>, but this time, in the last parameter, provide a pointer to the first element of the <kbd>present_modes</kbd> vector.</li>
<li>If the function returns a <kbd>VK_SUCCESS</kbd> value, the <kbd>present_modes</kbd> variable will contain the present modes supported on a given platform.</li>
<li>Iterate over all elements of the <kbd>present_modes</kbd> vector. Check whether one of the elements is equal to the desired present mode stored in the <kbd>desired_present_mode</kbd> variable.</li>
<li>If the desired present mode is not supported (none of the elements of the <kbd>present_modes</kbd> vector is equal to the <kbd>desired_present_mode</kbd> variable), select a FIFO present mode--a value of <kbd>VK_PRESENT_MODE_FIFO_KHR</kbd>--which always should be supported.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The presentation mode defines the way in which images are displayed on screen. Currently, there are four modes defined in a Vulkan API.</p>
<p>The simplest is an <strong>IMMEDIATE</strong> mode. Here, when an image is presented, it immediately replaces the image that is being displayed. There is no waiting involved, no queue, and no other parameters that should be considered from the application perspective. And because of that, screen tearing may (and probably will) be observed:</p>
<div><img class=" image-border" src="img/image_02_001.png"/></div>
<p>The presentation mode that is mandatory, that every Vulkan API implementation must support, is a <strong>FIFO mode</strong>. Here, when an image is presented, it is added to the First In First Out queue (the length of this queue is equal to the number of images in a swapchain minus one, <em>n - 1</em>). From this queue, images are displayed on screen in sync with blanking periods (v-sync), always in the same order they were added to the queue. There is no tearing in this mode, as v-sync is enabled. This mode is similar to OpenGL's buffer swapping with swap interval set to one.</p>
<p>The FIFO presentation mode must always be supported.</p>
<p>There is also a slight modification of a FIFO mode called <strong>FIFO RELAXED</strong>. The difference between these two is that in <strong>RELAXED</strong> mode, images are displayed on screen in sync with blanking periods only when they are presented quick enough, faster than the refresh rate. If an image is presented by the application and the time that has elapsed from the last presentation is greater than the refresh time between two blanking periods (the FIFO queue is empty), the image is presented immediately. So if we are quick enough, there is no screen tearing, but if we are drawing slower than the monitor's refresh rate, screen tearing will be visible. This behavior is similar to that specified in OpenGL's <kbd>EXT_swap_control_tear</kbd> extension:</p>
<div><img class=" image-border" src="img/image_02_002.png"/></div>
<p>The last presentation mode is called <strong>mailbox</strong> mode. It can be perceived as a triple buffering. Here also, there is a queue involved, but it contains just one element. An image that is waiting in this queue is displayed in sync with the blanking periods (v-sync is enabled). But when the application presents an image, the new image replaces the one waiting in the queue. So the presentation engine always displays the latest, the most recent, image available. And there is no screen tearing:</p>
<div><img class=" image-border" src="img/image_02_003.png"/></div>
<p>To select the desired presentation mode, we need to check what modes are available on the current platform. First, we need to acquire the number of all supported presentation modes. This is done by calling a <kbd>vkGetPhysicalDeviceSurfacePresentModesKHR()</kbd> function with the last parameter set to <kbd>nullptr</kbd>:</p>
<pre>
uint32_t present_modes_count = 0; 
VkResult result = VK_SUCCESS; 

result = vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device, presentation_surface, &amp;present_modes_count, nullptr ); 
if( (VK_SUCCESS != result) || 
    (0 == present_modes_count) ) { 
  std::cout &lt;&lt; "Could not get the number of supported present modes." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>Next we can prepare storage for all supported modes and once again call the same function, but this time with the last parameter pointing to the allocated storage:</p>
<pre>
std::vector&lt;VkPresentModeKHR&gt; present_modes( present_modes_count ); 
result = vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device, presentation_surface, &amp;present_modes_count, &amp;present_modes[0] ); 
if( (VK_SUCCESS != result) || 
  (0 == present_modes_count) ) { 
  std::cout &lt;&lt; "Could not enumerate present modes." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>Now that we know what presentation modes are available, we can check whether the selected mode is available. If it is not, we can choose another presentation mode from the acquired list or we just fall back to the default FIFO mode that is mandatory and should always be available:</p>
<pre>
for( auto &amp; current_present_mode : present_modes ) { 
  if( current_present_mode == desired_present_mode ) { 
    present_mode = desired_present_mode; 
    return true; 
  } 
} 

std::cout &lt;&lt; "Desired present mode is not supported. Selecting default FIFO mode." &lt;&lt; std::endl; 
for( auto &amp; current_present_mode : present_modes ) { 
  if( current_present_mode == VK_PRESENT_MODE_FIFO_KHR ) { 
    present_mode = VK_PRESENT_MODE_FIFO_KHR; 
    return true; 
  } 
}
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Selecting a number of swapchain images</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Creating a swapchain with R8G8B8A8 format and a mailbox present mode</em></li>
<li><em>Acquiring a swapchain image</em></li>
<li><em>Presenting an image</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting the capabilities of a presentation surface</h1>
            

            
                
<p>When we create a swapchain, we need to specify creation parameters. But we can't choose whatever values we want. We must provide values that fit into supported limits, which can be obtained from a presentation surface. So in order to properly create a swapchain, we need to acquire the surface's capabilities.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a selected physical device enumerated using the <kbd>vkEnumeratePhysicalDevices()</kbd> function and store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Take the handle of a created presentation surface. Store it in a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Create a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd> named <kbd>surface_capabilities</kbd>.</li>
<li>Call <kbd>vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, presentation_surface, &amp;surface_capabilities)</kbd> for which provide the handles of the physical device and a presentation surface, and a pointer to the <kbd>surface_capabilities</kbd> variable.</li>
<li>If the function call is successful, the <kbd>surface_capabilities</kbd> variable will contain the presentation surface's parameters, limits, and capabilities that can be used to create a swapchain.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>Acquiring the supported capabilities and ranges of parameters that can be used during swapchain creation is very straightforward:</p>
<pre>
VkResult result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR( physical_device, presentation_surface, &amp;surface_capabilities ); 

if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not get the capabilities of a presentation surface." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>We just call a <kbd>vkGetPhysicalDeviceSurfaceCapabilitiesKHR()</kbd> function, which stores the parameters in a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd>. It is a structure which contains members defining the following parameters:</p>
<ul>
<li>Minimal and maximal allowed number of swapchain images</li>
<li>Minimal, maximal, and current extent of a presentation surface</li>
<li>Supported image transformations (which can be applied before presentation) and the transformation currently in use</li>
<li>Maximal number of supported image layers</li>
<li>Supported usages</li>
<li>A list of the supported compositions of a surface's alpha value (how an image's alpha component should affect the application's window desktop composition)</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a presentation surface</em></li>
<li><em>Selecting a number of swapchain images</em></li>
<li><em>Choosing a size of swapchain images</em></li>
<li><em>Selecting desired usage scenarios of swapchain images</em></li>
<li><em>Selecting a transformation of swapchain images</em></li>
<li><em>Selecting a format of swapchain images</em></li>
<li><em>Creating a swapchain</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Selecting a number of swapchain images</h1>
            

            
                
<p>When an application wants to render into a swapchain image, it must acquire it from the presentation engine. An application can acquire more images; we are not limited to just one image at a time. But the number of images that are available (unused by the presentation engine at a given time) depends on the specified presentation mode, the application's current situation (rendering/presenting history), and the number of images--when we create a swapchain, we must specify the (minimal) number of images that should be created.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Acquire the capabilities of a presentation surface (refer to the <em>Getting capabilities of a presentation surface</em> recipe). Store them in a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd> named <kbd>surface_capabilities</kbd>.</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>number_of_images</kbd>.</li>
<li>Assign a value of <kbd>surface_capabilities.minImageCount + 1</kbd> to the <kbd>number_of_images</kbd> variable.</li>
<li>Check whether the value of the <kbd>maxImageCount</kbd> member of the <kbd>surface_capabilities</kbd> variable is greater than zero. If it is, this means there is a limit to the maximal allowed number of created images. In this case, check whether the value of the <kbd>number_of_images</kbd> variable is greater than the value of <kbd>surface_capabilities.maxImageCount</kbd>. If it is, clamp the value of the <kbd>number_of_images</kbd> variable to the limit defined in the <kbd>maxImageCount</kbd> member of the <kbd>surface_capabilities</kbd> variable.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>Images created (automatically) along with a swapchain are mainly used for presentation purposes. But they also allow the presentation engine to work properly. One image is (always) displayed on screen. The application can't use it until it is replaced by another image. Images that are presented replace the displayed image immediately, or wait in a queue for the proper moment (v-sync) to replace it, depending on the selected mode. An image that was displayed and is now being replaced becomes unused and can be acquired by the application.</p>
<p>An application can acquire only images that are currently in an unused state (refer to the <em>Selecting a desired presentation mode</em> recipe). We can acquire all of them. But as soon as all unused images are acquired, we need to present at least one of them in order to be able to acquire another one. If we don't do this, the acquiring operation may block indefinitely.</p>
<p>The number of unused images depends mainly on the presentation mode and the total number of images created with a swapchain. So the number of images that we want to create should be chosen based on the rendering scenarios we want to implement (how many images an application wants to possess at the same time) and the selected present mode.</p>
<p>Choosing the minimal number of images may look like this:</p>
<pre>
number_of_images = surface_capabilities.minImageCount + 1; 
if( (surface_capabilities.maxImageCount &gt; 0) &amp;&amp; 
    (number_of_images &gt; surface_capabilities.maxImageCount) ) { 
  number_of_images = surface_capabilities.maxImageCount; 
} 
return true;
</pre>
<p>Usually, in the most typical rendering scenarios, we will be rendering into a single image at a given time. So the minimal supported number of images may be enough. Creating more images allows us to acquire more of them at the same time, but, more importantly, it may also increase the performance of our application if a proper rendering algorithm is implemented. But we can't forget that images consume a considerable amount of memory. So the number of images we choose for the swapchain should be a compromise between our needs, memory usage, and the performance of our application.</p>
<p>In the preceding example, such a compromise is presented in which the application chooses one image more than the minimal value that allows the presentation engine to work properly. After that, we also need to check whether there is an upper limit and whether we exceed it. If we do, we need to clamp the selected value to the supported range.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Selecting a desired presentation mode</em></li>
<li><em>Getting the capabilities of a presentation surface</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Acquiring a swapchain image</em></li>
<li><em>Presenting an image</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Choosing a size of swapchain images</h1>
            

            
                
<p>Usually, images created for a swapchain should fit into an application's window. The supported dimensions are available in the presentation surface's capabilities. But on some operating systems, the size of the images defines the final size of the window. We also should keep that in mind and check what dimensions are proper for the swapchain images.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Acquire the capabilities of a presentation surface (refer to the <em>Getting capabilities of a presentation surface</em> recipe). Store them in a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd> named <kbd>surface_capabilities</kbd>.</li>
<li>Create a variable of type <kbd>VkExtent2D</kbd> named <kbd>size_of_images</kbd> in which we will store the desired size of swapchain images.</li>
<li>Check whether the <kbd>currentExtent.width</kbd> member of the <kbd>surface_capabilities</kbd> variable is equal to <kbd>0xFFFFFFFF</kbd> (<kbd>-1</kbd> converted to an unsigned value of <kbd>uint32_t</kbd> type). If it is, it means that the size of images determines the size of the window. In this situation:
<ul>
<li>Assign the desired values for <kbd>width</kbd> and <kbd>height</kbd> members of the <kbd>size_of_images</kbd> variable</li>
<li>Clamp the value of the <kbd>width</kbd> member of a <kbd>size_of_images</kbd> variable to the range defined by <kbd>surface_capabilities.minImageExtent.width</kbd> and <kbd>surface_capabilities.maxImageExtent.width</kbd></li>
<li>Clamp the value of the <kbd>height</kbd> member of the <kbd>size_of_images</kbd> variable to the range defined by <kbd>surface_capabilities.minImageExtent.height</kbd> and <kbd>surface_capabilities.maxImageExtent.height</kbd></li>
</ul>
</li>
<li>If the value of the <kbd>currentExtent.width</kbd> member of the <kbd>surface_capabilities</kbd> variable is not equal to <kbd>0xFFFFFFFF</kbd>, in the <kbd>size_of_images</kbd> variable, store the value of <kbd>surface_capabilities.currentExtent</kbd>.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The size of swapchain images must fit into supported limits. These are defined by the surface capabilities. In most typical scenarios, we want to render into an image that has the same dimensions as the application window's client area. This value is specified in the <kbd>currentExtent</kbd> member of surface's capabilities.</p>
<p>But there are operating systems on which the window's size is determined by the size of swapchain images. This situation is signaled by the <kbd>0xFFFFFFFF</kbd> value of the <kbd>currentExtent.width</kbd> or <kbd>currentExtent.height</kbd> member of the surface's capabilities. In this case, we can define the size of images, but it still must fall within a specified range:</p>
<pre>
if( 0xFFFFFFFF == surface_capabilities.currentExtent.width ) { 
  size_of_images = { 640, 480 }; 

  if( size_of_images.width &lt; surface_capabilities.minImageExtent.width ) { 
    size_of_images.width = surface_capabilities.minImageExtent.width; 
  } else if( size_of_images.width &gt; surface_capabilities.maxImageExtent.width ) { 
    size_of_images.width = surface_capabilities.maxImageExtent.width; 
  } 

  if( size_of_images.height &lt; surface_capabilities.minImageExtent.height ) { 
    size_of_images.height = surface_capabilities.minImageExtent.height; 
  } else if( size_of_images.height &gt; surface_capabilities.maxImageExtent.height ) { 
    size_of_images.height = surface_capabilities.maxImageExtent.height; 
  } 
} else { 
  size_of_images = surface_capabilities.currentExtent; 
} 
return true;
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Getting capabilities of a presentation surface</em></li>
<li><em>Creating a swapchain</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Selecting desired usage scenarios of swapchain images</h1>
            

            
                
<p>Images created with a swapchain are usually used as color attachments. This means that we want to render into them (use them as render targets). But we are not limited only to this scenario. We can use swapchain images for other purposes--we can sample from them, use them as a source of data in copy operations, or copy data into them. These are all different image usages and we can specify them during swapchain creation. But, again, we need to check whether these usages are supported.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Acquire the capabilities of a presentation surface (refer to the <em>Getting capabilities of a presentation surface</em> recipe). Store them in a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd> named <kbd>surface_capabilities</kbd>.</li>
<li>Choose the desired image usages and store them in a variable of a bit field type <kbd>VkImageUsageFlags</kbd> named <kbd>desired_usages</kbd>.</li>
<li>Create a variable of type <kbd>VkImageUsageFlags</kbd> named <kbd>image_usage</kbd> in which a list of requested usages that are supported on a given platform will be stored. Assign a value of <kbd>0</kbd> to the <kbd>image_usage</kbd> variable.</li>
<li>Iterate over all bits of the <kbd>desired_usages</kbd> bit field variable. For each bit in the variable:
<ul>
<li>Check whether the bit is set (is equal to one)</li>
<li>Check whether the corresponding bit of the <kbd>supportedUsageFlags</kbd> member of the <kbd>surface_capabilities</kbd> variable is set</li>
<li>If the preceding checks are true, set the same bit in the <kbd>image_usage</kbd> variable</li>
</ul>
</li>
<li>Make sure that all of the requested usages are supported on a given platform by checking if the values of the <kbd>desired_usages</kbd> and <kbd>image_usage</kbd> variables are equal.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The list of usages that can be selected for swapchain images is available in a <kbd>supportedUsageFlags</kbd> member of a presentation surface's capabilities. This member is a bit field in which each bit corresponds to a specific usage. If a given bit is set, it means that a given usage is supported.</p>
<p>Color attachment usage (<kbd>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</kbd>) must always be supported.</p>
<p><kbd>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</kbd> usage is mandatory and all Vulkan implementations must support it. Other usages are optional. That's why we shouldn't rely on their availability. Also, we shouldn't request usages that we don't need as this may impact the performance of our application.</p>
<p>Selecting a desired usage may look like this:</p>
<pre>
image_usage = desired_usages &amp; surface_capabilities.supportedUsageFlags; 

return desired_usages == image_usage;
</pre>
<p>We take only the common part of desired usages and the supported usages. We then check whether all requested usages are supported. We do this by comparing the values of the requested and the "final" usages. If their values differ, we know that not all of the desired usages are supported.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Getting capabilities of a presentation surface</em></li>
<li><em>Creating a swapchain</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Selecting a transformation of swapchain images</h1>
            

            
                
<p>On some (especially mobile) devices, images can be viewed from different orientations. Sometimes we would like to be able to specify how an image should be oriented when it is displayed on screen. In Vulkan, we have such a possibility. When creating a swapchain, we need to specify the transformation which should be applied to an image before it is presented.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Acquire the capabilities of a presentation surface (refer to the <em>Getting capabilities of a presentation surface</em> recipe). Store them in a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd> named <kbd>surface_capabilities</kbd>.</li>
<li>Store the desired transformations in a bit field variable of type <kbd>VkSurfaceTransformFlagBitsKHR</kbd> named <kbd>desired_transform</kbd>.</li>
<li>Create a variable of type <kbd>VkSurfaceTransformFlagBitsKHR</kbd> named <kbd>surface_transform</kbd> in which we will store the supported transformation.</li>
<li>Check whether all bits set in the <kbd>desired_transform</kbd> variable are also set in the <kbd>supportedTransforms</kbd> member of the presentation surface's capabilities. If they are, assign the value of the <kbd>desired_transform</kbd> variable to the <kbd>surface_transform</kbd> variable.</li>
<li>If not all desired transformations are supported, fall back to the current transformation by assigning a value of <kbd>surface_capabilities.currentTransform</kbd> to the <kbd>surface_transform</kbd> variable.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The <kbd>supportedTransforms</kbd> member of a presentation surface's capabilities defines a list of all image transformations that are available on a given platform. Transformations define how an image should be rotated or mirrored before it is displayed on screen. During swapchain creation, we can specify the desired transformation and a presentation engine applies it to the image as part of the displaying process.</p>
<p>We can choose any of the supported values. Here is a code sample that selects a desired transformation if it is available or otherwise just takes the currently used transformation:</p>
<pre>
if( surface_capabilities.supportedTransforms &amp; desired_transform ) { 
  surface_transform = desired_transform; 
} else { 
  surface_transform = surface_capabilities.currentTransform; 
}
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Getting capabilities of a presentation surface</em></li>
<li><em>Creating a swapchain</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Selecting a format of swapchain images</h1>
            

            
                
<p>The format defines the number of color components, the number of bits for each component, and the used data type. During swapchain creation, we must specify whether we want to use red, green, and blue channels with or without an alpha component, whether the color values should be encoded using unsigned integer or floating-point data types, and what their precision is. We must also choose whether we are encoding color values using linear or nonlinear color space. But as with other swapchain parameters, we can use only values that are supported by the presentation surface.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>In this recipe, we use several terms that may seem identical, but in fact they specify different parameters:</p>
<ul>
<li>Image format is used to describe the number of components, precision, and data type of an image's pixels. It corresponds to variables of type <kbd>VkFormat</kbd>.</li>
<li>Color space determines the way the values of color components are interpreted by the hardware, whether they are encoded or decoded using a linear or nonlinear function. Color space corresponds to variables of type <kbd>VkColorSpaceKHR</kbd>.</li>
<li>Surface format is a pair of image format and color space and is represented by variables of type <kbd>VkSurfaceFormatKHR</kbd>.</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a physical device returned by the <kbd>vkEnumeratePhysicalDevices()</kbd> function. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Take the created presentation surface and store its handle in a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Select the desired image format and color space and assign them to the members of a variable of type <kbd>VkSurfaceFormatKHR</kbd> named <kbd>desired_surface_format</kbd>.</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>formats_count</kbd>.</li>
<li>Call <kbd>vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface, &amp;formats_count, nullptr )</kbd>, provide a handle of the physical device in the first parameter, a handle of the presentation surface in the second parameter, and a pointer to the <kbd>formats_count</kbd> variable in the third variable. Leave the value of the last parameter set to <kbd>nullptr</kbd>.</li>
<li>If a function call is successful, the <kbd>formats_count</kbd> variable will contain the number of all supported format-color space pairs.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkSurfaceFormatKHR&gt;</kbd> named <kbd>surface_formats</kbd>. Resize the vector so it is able to hold at least <kbd>formats_count</kbd> elements.</li>
<li>Make the following call, <kbd>vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface, &amp;formats_count, &amp;surface_formats[0] )</kbd>. Provide the same arguments for the first three parameters. In the last parameter, provide a pointer to the first element of the <kbd>surface_formats</kbd> vector.</li>
<li>If the call is successful, all available image format-color space pairs will be stored in the <kbd>surface_formats</kbd> variable.</li>
<li>Create a variable of type <kbd>VkFormat</kbd> named <kbd>image_format</kbd> and a second variable of type <kbd>VkColorSpaceKHR</kbd> named <kbd>image_color_space</kbd> in which we will store selected values of format and color space used later during swapchain creation.</li>
<li>Check the number of elements in the <kbd>surface_formats</kbd> vector. If it holds only one element with a value of <kbd>VK_FORMAT_UNDEFINED</kbd>, it means that we can choose whatever surface format we want. Assign the members of the <kbd>desired_surface_format</kbd> variable to the <kbd>image_format</kbd> and <kbd>image_color_space</kbd> variables.</li>
</ol>
<ol start="12">
<li>If the <kbd>surface_formats</kbd> vector contains more elements, iterate over each element of the vector and compare the <kbd>format</kbd> and <kbd>colorSpace</kbd> members with the same members of the <kbd>desired_surface_format</kbd> variable. If we find an element in which both members are identical, it means that the desired surface format is supported and we can use it for swapchain creation. Assign the members of the <kbd>desired_surface_format</kbd> variable to the <kbd>image_format</kbd> and <kbd>image_color_space</kbd> variables.</li>
<li>If we haven't found a match, iterate over all elements of the <kbd>surface_formats</kbd> vector. Check whether the <kbd>format</kbd> member of any of its elements is identical to the value of a chosen <kbd>surface_format.format</kbd>. If there is such an element, assign the <kbd>desired_surface_format.format</kbd> value to the <kbd>image_format</kbd> variable, but take the corresponding color space from the currently viewed element of the <kbd>surface_formats</kbd> vector and assign it to the <kbd>image_color_space</kbd> variable.</li>
<li>If the <kbd>surface_formats</kbd> variable doesn't contain any element with the selected image format, take the first element of the vector and assign its <kbd>format</kbd> and <kbd>colorSpace</kbd> members to the <kbd>image_format</kbd> and <kbd>image_color_space</kbd> variables.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>To obtain a list of all supported surface formats, we need to make a double call of a <kbd>vkGetPhysicalDeviceSurfaceFormatsKHR()</kbd> function. First we acquire the number of all supported format-color space pairs:</p>
<pre>
uint32_t formats_count = 0; 
VkResult result = VK_SUCCESS; 

result = vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface, &amp;formats_count, nullptr ); 
if( (VK_SUCCESS != result) || 
    (0 == formats_count) ) { 
  std::cout &lt;&lt; "Could not get the number of supported surface formats." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>Next we can prepare storage for the actual values and make the second call to acquire them:</p>
<pre>
std::vector&lt;VkSurfaceFormatKHR&gt; surface_formats( formats_count ); 
result = vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface, &amp;formats_count, &amp;surface_formats[0] ); 
if( (VK_SUCCESS != result) || 
    (0 == formats_count) ) { 
  std::cout &lt;&lt; "Could not enumerate supported surface formats." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>After that, we can choose one of the supported surface formats that is the best match for our needs. If only one surface format was returned and it has a value of <kbd>VK_FORMAT_UNDEFINED</kbd>, it means that there are no restrictions on the supported format-color space pairs. In such a situation, we can choose any surface format we want and use it during swapchain creation:</p>
<pre>
if( (1 == surface_formats.size()) &amp;&amp; 
    (VK_FORMAT_UNDEFINED == surface_formats[0].format) ) { 
  image_format = desired_surface_format.format; 
  image_color_space = desired_surface_format.colorSpace; 
  return true; 
}
</pre>
<p>If there are more elements returned by the <kbd>vkGetPhysicalDeviceSurfaceFormatsKHR()</kbd> function, we need to take one of them. First we check whether the chosen surface format is supported "entirely"--both selected image format and color space are available:</p>
<pre>
for( auto &amp; surface_format : surface_formats ) { 
  if( (desired_surface_format.format == surface_format.format) &amp;&amp; 
      (desired_surface_format.colorSpace == surface_format.colorSpace) ) { 
    image_format = desired_surface_format.format; 
    image_color_space = desired_surface_format.colorSpace; 
    return true; 
  } 
}
</pre>
<p>If we can't find a match, we look for a member that has an identical image format, but other color space. We can't take any of the supported formats and any of the supported color spaces--we must take the same color space that corresponds to a given format:</p>
<pre>
for( auto &amp; surface_format : surface_formats ) { 
  if( (desired_surface_format.format == surface_format.format) ) { 
    image_format = desired_surface_format.format; 
    image_color_space = surface_format.colorSpace; 
    std::cout &lt;&lt; "Desired combination of format and colorspace is not supported. Selecting other colorspace." &lt;&lt; std::endl; 
    return true; 
  } 
}
</pre>
<p>Finally, if the format we wanted to use is not supported, we just take the first available image format-color space pair:</p>
<pre>
image_format = surface_formats[0].format; 
image_color_space = surface_formats[0].colorSpace; 
std::cout &lt;&lt; "Desired format is not supported. Selecting available format - colorspace combination." &lt;&lt; std::endl; 
return true;
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a swapchain</em></li>
<li><em>Creating a swapchain with R8G8B8A8 format and a mailbox present mode</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a swapchain</h1>
            

            
                
<p>A swapchain is used to display images on screen. It is an array of images which can be acquired by the application and then presented in our application's window. Each image has the same defined set of properties. When we have prepared all of these parameters, meaning that we chose a number, a size, a format, and usage scenarios for swapchain images, and also acquired and selected one of the available presentation modes, we are ready to create a swapchain.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a created logical device object. Store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Assign the handle of a created presentation surface to a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Take the desired number of swapchain images assigned to a variable of type <kbd>uint32_t</kbd> named <kbd>image_count</kbd>.</li>
</ol>
<ol start="4">
<li>Store the values of the selected image format and color space in a variable of type <kbd>VkSurfaceFormatKHR</kbd> named <kbd>surface_format</kbd>.</li>
<li>Prepare the required image size and assign it to a variable of type <kbd>VkExtent2D</kbd> named <kbd>image_size</kbd>.</li>
<li>Choose the desired usage scenarios for swapchain images. Store them in a bit field variable of type <kbd>VkImageUsageFlags</kbd> named <kbd>image_usage</kbd>.</li>
<li>Take the selected surface transformations stored in a variable of type <kbd>VkSurfaceTransformFlagBitsKHR</kbd> named <kbd>surface_transform</kbd>.</li>
<li>Prepare a variable of type <kbd>VkPresentModeKHR</kbd> named <kbd>present_mode</kbd> and assign a desired presentation mode to it.</li>
<li>Create a variable of type <kbd>VkSwapchainKHR</kbd> named <kbd>old_swapchain</kbd>. If there was a swapchain created previously, store a handle of that swapchain in this variable. Otherwise, assign a <kbd>VK_NULL_HANDLE</kbd> value to this variable.</li>
<li>Create a variable of type <kbd>VkSwapchainCreateInfoKHR</kbd> named <kbd>swapchain_create_info</kbd>. Assign the following values to the members of this variable:
<ul>
<li class="CodeWithinBulletsPACKT"><kbd>VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</kbd> value for <kbd>sType</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>presentation_surface</kbd> variable for <kbd>surface</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>image_count</kbd> variable for <kbd>minImageCount</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>surface_format.format</kbd> member for <kbd>imageFormat</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>surface_format.colorSpace</kbd> member for <kbd>imageColorSpace</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>image_size</kbd> variable for <kbd>imageExtent</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>1</kbd> value for <kbd>imageArrayLayers</kbd> (or more if we want to perform layered/stereoscopic rendering)</li>
<li class="CodeWithinBulletsPACKT"><kbd>image_usage</kbd> variable for <kbd>imageUsage</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>VK_SHARING_MODE_EXCLUSIVE</kbd> value for <kbd>imageSharingMode</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>0</kbd> value for <kbd>queueFamilyIndexCount</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>nullptr</kbd> value for <kbd>pQueueFamilyIndices</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>surface_transform</kbd> variable for <kbd>preTransform</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</kbd> value for <kbd>compositeAlpha</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>present_mode</kbd> variable for <kbd>presentMode</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>VK_TRUE</kbd> for <kbd>clipped</kbd></li>
<li class="CodeWithinBulletsPACKT"><kbd>old_swapchain</kbd> variable for <kbd>oldSwapchain</kbd></li>
</ul>
</li>
</ol>
<ol start="11">
<li>Create a variable of type <kbd>VkSwapchainKHR</kbd> named <kbd>swapchain</kbd>.</li>
<li>Call <kbd>vkCreateSwapchainKHR( logical_device, &amp;swapchain_create_info, nullptr, &amp;swapchain )</kbd>. Use the handle of a created logical device, a pointer to the <kbd>swapchain_create_info</kbd> variable, a <kbd>nullptr</kbd> value, and a pointer to the <kbd>swapchain</kbd> variable as the function's arguments.</li>
<li>Make sure the call was successful by comparing the returned value with a <kbd>VK_SUCCESS</kbd> value.</li>
<li>Call <kbd>vkDestroySwapchainKHR( logical_device, old_swapchain, nullptr )</kbd> to destroy the old swapchain. Provide a handle to the created logical device, a handle of an old swapchain, and a <kbd>nullptr</kbd> value for the function call.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>As was mentioned earlier, a swapchain is a collection of images. They are created automatically along with a swapchain. They are also destroyed when the swapchain is destroyed. Though an application can obtain handles of these images, it is not allowed to create or destroy them.</p>
<p>The process of swapchain creation isn't too complicated, but there is a considerable amount of data we need to prepare before we are able to create it:</p>
<pre>
VkSwapchainCreateInfoKHR swapchain_create_info = { 
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, 
  nullptr, 
  0, 
  presentation_surface, 
  image_count, 
  surface_format.format, 
  surface_format.colorSpace, 
  image_size, 
  1, 
  image_usage, 
  VK_SHARING_MODE_EXCLUSIVE, 
  0, 
  nullptr, 
  surface_transform, 
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR, 
  present_mode, 
  VK_TRUE, 
  old_swapchain 
}; 

VkResult result = vkCreateSwapchainKHR( logical_device, &amp;swapchain_create_info, nullptr, &amp;swapchain ); 
if( (VK_SUCCESS != result) || 
    (VK_NULL_HANDLE == swapchain) ) { 
  std::cout &lt;&lt; "Could not create a swapchain." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>Only one swapchain can be associated with a given application's window. When we create a new swapchain, we need to destroy any swapchain that was previously created for the same window:</p>
<pre>
if( VK_NULL_HANDLE != old_swapchain ) { 
  vkDestroySwapchainKHR( logical_device, old_swapchain, nullptr ); 
  old_swapchain = VK_NULL_HANDLE; 
}
</pre>
<p>When the swapchain is ready, we can acquire its images and perform tasks that fit into specified usage scenarios. We are not limited to acquiring just a single image, like we were used to in an OpenGL API (single back buffer). The number of images depends on the minimal specified number of images that should be created along with a swapchain, the chosen presentation mode, and current rendering history (number of images currently acquired and recently presented).</p>
<p>After we have acquired an image, we can use it in our application. The most common usage is rendering into the image (using it as a color attachment), but we are not limited to just this usage and we can perform other tasks with swapchain images. But we must make sure respective usages are available on a given platform and that they were specified during swapchain creation. Not all platforms may support all usages. Only color attachment usage is mandatory.</p>
<p>When we are done rendering into an image (or images) or performing other tasks, we can display an image by presenting it. This operation returns the image to the presentation engine which replaces the currently displayed image with the new one according to the specified presentation mode.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a presentation surface</em></li>
<li><em>Selecting a queue family that supports presentation to a given surface</em></li>
<li><em>Creating a logical device with WSI extensions enabled</em></li>
<li><em>Selecting a desired presentation mode</em></li>
<li><em>Getting capabilities of a presentation surface</em></li>
<li><em>Selecting a number of swapchain images</em></li>
<li><em>Choosing a size of swapchain images</em></li>
<li><em>Selecting desired usage scenarios of swapchain images</em></li>
<li><em>Selecting a transformation of swapchain images</em></li>
<li><em>Selecting a format of swapchain images</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting handles of swapchain images</h1>
            

            
                
<p>When the swapchain object is created, it may be very useful to acquire the number and handles of all images that were created along with the swapchain.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a created logical device object. Store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Assign the handle of a created swapchain to a variable of type <kbd>VkSwapchainKHR</kbd> named <kbd>swapchain</kbd>.</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>images_count</kbd>.</li>
<li>Call <kbd>vkGetSwapchainImagesKHR(logical_device, swapchain, &amp;images_count, nullptr)</kbd> for which provide the handle to the created logical device in the first parameter, the handle of the swapchain in the second, and a pointer to the <kbd>images_count</kbd> variable in the third parameter. Provide a <kbd>nullptr</kbd> value in the last parameter.</li>
<li>If the call is successful, meaning that the returned value is equal to <kbd>VK_SUCCESS</kbd>, the <kbd>images_count</kbd> variable will contain the total number of images created for a given swapchain object.</li>
<li>Create a <kbd>std::vector</kbd> with elements of type <kbd>VkImage</kbd>. Name the vector <kbd>swapchain_images</kbd> and resize it so it is able to hold at least <kbd>images_count</kbd> number of elements.</li>
</ol>
<ol start="7">
<li>Call <kbd>vkGetSwapchainImagesKHR(logical_device, swapchain, &amp;images_count, &amp;swapchain_images[0])</kbd> and provide the same arguments for the first three parameters as previously. In the last parameter, provide a pointer to the first element of the <kbd>swapchain_images</kbd> vector.</li>
<li>On success, the vector will contain the handles of all swapchain images.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>Drivers may create more images than were requested in the swapchain's creation parameters. There, we just defined the minimum required number but Vulkan implementations are allowed to create more.</p>
<p>We need to know the total number of created images to be able to acquire their handles. In Vulkan, when we want to render into an image, we need to know its handle. It is required to create an image view that wraps the image and is used during framebuffer creation. A framebuffer, as in OpenGL, specifies a set of images that are used during the rendering process (mostly that we render into them).</p>
<p>But this is not the only case in which we need to know what images were created along with a swapchain. It's been said that when an application wants to use a presentable image, it must acquire it from the presentation engine. The process of image acquisition returns a number, not the handle itself. The provided number represents an index of an image in the array of images acquired with the <kbd>vkGetSwapchainImagesKHR()</kbd> function (a <kbd>swapchain_images</kbd> variable). So the knowledge of the total number of images, their order, and their handles is necessary to properly use a swapchain and its images.</p>
<p>To acquire the total number of images, we need to use the following code:</p>
<pre>
uint32_t images_count = 0; 
VkResult result = VK_SUCCESS; 

result = vkGetSwapchainImagesKHR( logical_device, swapchain, &amp;images_count, nullptr ); 
if( (VK_SUCCESS != result) || 
    (0 == images_count) ) { 
  std::cout &lt;&lt; "Could not get the number of swapchain images." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>Next, we can prepare storage for all images and acquire their handles:</p>
<pre>
swapchain_images.resize( images_count ); 
result = vkGetSwapchainImagesKHR( logical_device, swapchain, &amp;images_count, &amp;swapchain_images[0] ); 
if( (VK_SUCCESS != result) || 
  (0 == images_count) ) { 
  std::cout &lt;&lt; "Could not enumerate swapchain images." &lt;&lt; std::endl; 
  return false; 
} 

return true;
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Selecting a number of swapchain images</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Acquiring a swapchain image</em></li>
<li><em>Presenting an image</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a swapchain with R8G8B8A8 format and a mailbox present mode</h1>
            

            
                
<p>To create a swapchain, we need to acquire a lot of additional information and prepare a considerable number of parameters. To present the order of all the steps required for the preparation phases and how to use the acquired information, we will create a swapchain with arbitrarily chosen parameters. For it, we will set a mailbox presentation mode, the most commonly used R8G8B8A8 color format with unsigned normalized values (similar to OpenGL's RGBA8 format), no transformations, and a standard color attachment image usage.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Prepare a physical device handle. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Take the handle of a created presentation surface and assign it to a variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Take the logical device created from the handle represented by the <kbd>physical_device</kbd> variable. Store the handle of the logical device in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkSwapchainKHR</kbd> named <kbd>old_swapchain</kbd>. If a swapchain was previously created, assign its handle to the <kbd>old_swapchain</kbd> variable. Otherwise, assign a <kbd>VK_NULL_HANDLE</kbd> to it.</li>
<li>Create a variable of type <kbd>VkPresentModeKHR</kbd> named <kbd>desired_present_mode</kbd>.</li>
<li>Check whether the <kbd>VK_PRESENT_MODE_MAILBOX_KHR</kbd> presentation mode is supported and assign it to the <kbd>desired_present_mode</kbd> variable. If this mode is not supported, use a <kbd>VK_PRESENT_MODE_FIFO_KHR</kbd> mode (refer to <em>Selecting a desired presentation mode</em> recipe).</li>
<li>Create a variable of type <kbd>VkSurfaceCapabilitiesKHR</kbd> named <kbd>surface_capabilities</kbd>.</li>
<li>Get the capabilities of a presentation surface and store them in the <kbd>surface_capabilities</kbd> variable.</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>number_of_images</kbd>. Based on the acquired surface capabilities, assign a minimal required number of images to the <kbd>number_of_images</kbd> variable (refer to the <em>Selecting a number of swapchain images</em> recipe).</li>
<li>Create a variable of type <kbd>VkExtent2D</kbd> named <kbd>image_size</kbd>. Based on the acquired surface capabilities, assign a size of swapchain images to the <kbd>image_size</kbd> variable (refer to the <em>Choosing a size of swapchain images</em> recipe).</li>
<li>Make sure the <kbd>width</kbd> and <kbd>height</kbd> members of the <kbd>image_size</kbd> variable are greater than zero. If they are not, do not attempt to create a swapchain, but don't close the application--such a situation may occur when a window is minimized.</li>
<li>Create a variable of type <kbd>VkImageUsageFlags</kbd> named <kbd>image_usage</kbd>. Assign a <kbd>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</kbd> image usage to it (refer to the <em>Selecting desired usage scenarios of swapchain images</em> recipe).</li>
</ol>
<ol start="13">
<li>Create a variable of type <kbd>VkSurfaceTransformFlagBitsKHR</kbd> named <kbd>surface_transform</kbd>. Store an identity transform (a value of <kbd>VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR</kbd>) in the variable. Based on the acquired surface capabilities, check whether it is supported. If it is not, assign the <kbd>currentTransform</kbd> member of the acquired capabilities to the <kbd>surface_transform</kbd> variable (refer to the <em>Selecting a transformation of swapchain images</em> recipe).</li>
<li>Create a variable of type <kbd>VkFormat</kbd> named <kbd>image_format</kbd> and a variable of type <kbd>VkColorSpaceKHR</kbd> named <kbd>image_color_space</kbd>.</li>
<li>Using the acquired capabilities, try to use the <kbd>VK_FORMAT_R8G8B8A8_UNORM</kbd> image format with a <kbd>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</kbd> color space. If format or color space, or both, are not supported, select other values from the surface capabilities (refer to the <em>Selecting a format of swapchain images</em> recipe).</li>
<li>Create a variable of type <kbd>VkSwapchainKHR</kbd> named <kbd>swapchain</kbd>.</li>
<li>Using the <kbd>logical_device</kbd>, <kbd>presentation_surface</kbd>, <kbd>number_of_images</kbd>, <kbd>image_format</kbd>, <kbd>image_color_space</kbd>, <kbd>size_of_images</kbd>, <kbd>image_usage</kbd>, <kbd>surface_transform</kbd>, <kbd>desired_present_mode</kbd>, and <kbd>old_swapchain</kbd> variables, create a swapchain and store its handle in the <kbd>swapchain</kbd> variable. Remember to check if the swapchain creation was successful. (refer to the <em>Creating a swapchain</em> recipe).</li>
<li>Create a variable of type <kbd>std::vector&lt;VkImage&gt;</kbd> named <kbd>swapchain_images</kbd> and store the handles of the created swapchain images in it (refer to the <em>Getting handles of swapchain images</em> recipe).</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>When we want to create a swapchain, we first need to think what presentation mode we would like to use. As the mailbox mode allows us to present the most recent image without screen tearing (it is similar to a triple buffering), it looks like a good choice:</p>
<pre>
VkPresentModeKHR desired_present_mode; 
if( !SelectDesiredPresentationMode( physical_device, presentation_surface, VK_PRESENT_MODE_MAILBOX_KHR, desired_present_mode ) ) { 
  return false; 
}
</pre>
<p>Next we need to acquire the presentation surface capabilities and use them to set up the required number of images, their size (dimensions), usage scenarios, transformations applied during presentation, and their format and color space:</p>
<pre>
VkSurfaceCapabilitiesKHR surface_capabilities; 
if( !GetCapabilitiesOfPresentationSurface( physical_device, presentation_surface, surface_capabilities ) ) { 
  return false; 
} 

uint32_t number_of_images; 
if( !SelectNumberOfSwapchainImages( surface_capabilities, number_of_images ) ) { 
  return false; 
} 

VkExtent2D image_size; 
if( !ChooseSizeOfSwapchainImages( surface_capabilities, image_size ) ) { 
  return false; 
} 
if( (0 == image_size.width) || 
    (0 == image_size.height) ) { 
  return true; 
} 

VkImageUsageFlags image_usage; 
if( !SelectDesiredUsageScenariosOfSwapchainImages( surface_capabilities, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, image_usage ) ) { 
  return false; 
} 

VkSurfaceTransformFlagBitsKHR surface_transform; 
SelectTransformationOfSwapchainImages( surface_capabilities, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, surface_transform ); 

VkFormat image_format; 
VkColorSpaceKHR image_color_space; 
if( !SelectFormatOfSwapchainImages( physical_device, presentation_surface, { VK_FORMAT_R8G8B8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR }, image_format, image_color_space ) ) { 
  return false; 
}
</pre>
<p>Finally, with all these preparations, we can create a swapchain, destroy an old one (if we want to replace a previously created swapchain with the new one), and acquire the handles of images created along with it:</p>
<pre>
if( !CreateSwapchain( logical_device, presentation_surface, number_of_images, { image_format, image_color_space }, image_size, image_usage, surface_transform, desired_present_mode, old_swapchain, swapchain ) ) { 
  return false; 
} 

if( !GetHandlesOfSwapchainImages( logical_device, swapchain, swapchain_images ) ) { 
  return false; 
} 
return true;
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a presentation surface</em></li>
<li><em>Creating a logical device with WSI extensions enabled</em></li>
<li><em>Selecting a desired presentation mode</em></li>
<li><em>Getting capabilities of a presentation surface</em></li>
<li><em>Selecting a number of swapchain images</em></li>
<li><em>Choosing a size of swapchain images</em></li>
<li><em>Selecting desired usage scenarios of swapchain images</em></li>
<li><em>Selecting a transformation of swapchain images</em></li>
<li><em>Selecting a format of swapchain images</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Getting handles of swapchain images</em></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Acquiring a swapchain image</h1>
            

            
                
<p>Before we can use a swapchain image, we need to ask a presentation engine for it. This process is called <strong>image acquisition</strong>. It returns an image's index into the array of images returned by the <kbd>vkGetSwapchainImagesKHR()</kbd> function as described in the <em>Getting handles of swapchain images</em> recipe.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>To acquire an image in Vulkan, we need to specify one of two types of objects that haven't been described yet. These are semaphores and fences.</p>
<p>Semaphores are used to synchronize device's queues. It means that when we submit commands for processing, these commands may require another job to be finished. In such a situation, we can specify that these commands should wait for the other commands before they are executed. And this is what semaphores are for. They are for internal queue synchronization, but we can't use them to synchronize an application with the submitted commands (refer to the <em>Creating a semaphore</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml">Chapter 3</a>, <em>Command Buffers and Synchronization</em>).</p>
<p>To do so, we need to use fences. They are used to inform an application about some work being finished. An application can acquire the state of a fence and, based on the acquired information, check whether some commands are still being processed or whether they have finished the assigned tasks (refer to the <em>Creating a fence</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml">Chapter 3</a>, <em>Command Buffers and Synchronization</em>).</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a created logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Prepare the handle of a swapchain object and assign it to a <kbd>VkSwapchainKHR</kbd> variable named <kbd>swapchain</kbd>.</li>
<li>Prepare a semaphore in the form of a variable of type <kbd>VkSemaphore</kbd> named <kbd>semaphore</kbd> or prepare a fence and assign its handle to the variable of type <kbd>VkFence</kbd> named <kbd>fence</kbd>. You can prepare both synchronization objects but at least one of them is required (no matter which one).</li>
<li>Create a variable of type <kbd>uint32_t</kbd> named <kbd>image_index</kbd>.</li>
<li>Call <kbd>vkAcquireNextImageKHR( logical_device, swapchain, &lt;timeout&gt;, semaphore, fence, &amp;image_index )</kbd>. Provide a handle of the logical device in the first parameter and a handle of a swapchain object in the second. For the third parameter, named <kbd>&lt;timeout&gt;</kbd>, provide a value of time after which the function will return a timeout error. You also need to provide one or both synchronization primitives--a swapchain and/or a fence. For the last parameter, provide a pointer to the <kbd>image_index</kbd> variable.</li>
</ol>
<ol start="6">
<li>Check the value returned by the <kbd>vkAcquireNextImageKHR()</kbd> function. If the returned value was equal to <kbd>VK_SUCCESS</kbd> or <kbd>VK_SUBOPTIMAL_KHR</kbd>, the call was successful and an <kbd>image_index</kbd> variable will hold an index of swapchain images which points to the element of an array returned by the <kbd>vkGetSwapchainImagesKHR()</kbd> function (refer to the <em>Getting handles of swapchain images</em> recipe). But if the <kbd>VK_ERROR_OUT_OF_DATE_KHR</kbd> value was returned, you can't use any images from the swapchain. You must destroy the given swapchain and recreate it once again in order to acquire images.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The <kbd>vkAcquireNextImageKHR()</kbd>function returns an index into the array of swapchain images returned by the <kbd>vkGetSwapchainImagesKHR()</kbd> function. It does not return the handle of that image. The following code illustrates the recipe:</p>
<pre>
VkResult result; 

result = vkAcquireNextImageKHR( logical_device, swapchain, 2000000000, semaphore, fence, &amp;image_index ); 
switch( result ) { 
  case VK_SUCCESS: 
  case VK_SUBOPTIMAL_KHR: 
    return true; 
default: 
  return false; 
}
</pre>
<p>In the code sample, we call the <kbd>vkAcquireNextImageKHR()</kbd> function. Sometimes images may not be available immediately due to the internal mechanism of a presentation engine. It is even possible that we may wait indefinitely! It occurs in situations when we want to acquire more images than the presentation engine can provide. That's why in the third parameter of the preceding function, we provide a timeout value in nanoseconds. It tells the hardware how long we can wait for the image. After this time, the function will inform us that it took too long to acquire an image. In the preceding sample, we inform the driver that we don't want to wait more than 2 seconds for the image to be acquired.</p>
<p>The other interesting parameters are a semaphore and a fence. When we acquire an image, we still may not use it immediately for our purposes. We need to wait for all previously submitted operations that referenced this image to finish. For this purpose, a fence can be used, using which an application can check when it is safe to modify an image. But we can also tell the driver that it should wait before it starts processing new commands that use a given image. For this purpose, a semaphore is used, which, in general, is a better option.</p>
<p>Waiting on the application side hurts the performance much more than waiting solely on the GPU.</p>
<p>Return values are also very important during swapchain image acquisition. When the function returns a <kbd>VK_SUBOPTIMAL_KHR</kbd> value, it means we can still use an image but it may no longer be best suited for the presentation engine. We should recreate the swapchain from which an image was acquired. But we don't need to do it immediately. When the function returns a <kbd>VK_ERROR_OUT_OF_DATE_KHR</kbd> value, we can't use images from a given swapchain anymore and we need to recreate it as soon as possible.</p>
<p>And the last thing to note about swapchain image acquisition is that before we can use an image, we need to change (transition) its layout. The layout is the image's internal memory organization, which may be different depending on the current purpose for which image is used. And if we want to use the image in a different way, we need to change its layout.</p>
<p>For example, images used by the presentation engine must have a <kbd>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</kbd> layout. But if we want to render into an image, it must have a <kbd>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</kbd> layout. The operation of changing the layout is called a transition (refer to the <em>Setting an image memory barrier</em> recipe from <a href="f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml">Chapter 4</a>, <em>Resources and Memory</em>).</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The following recipes in this chapter:
<ul>
<li><em>Selecting a desired presentation mode</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Getting handles of swapchain images</em></li>
<li><em>Presenting an image</em></li>
</ul>
</li>
<li>In <a href="f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml">Chapter 4</a>, <em>Resources and Memory</em> see the following recipe:
<ul>
<li><em>Setting an image memory barrier</em></li>
</ul>
</li>
<li>In <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml">Chapter 3</a>, <em>Command Buffers and Synchronization</em> see the following recipe:
<ul>
<li><em>Creating a semaphore</em></li>
<li><em>Creating a fence</em></li>
</ul>
</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Presenting an image</h1>
            

            
                
<p>After we are done rendering into a swapchain image or using it for any other purposes, we need to give the image back to the presentation engine. This operation is called a presentation and it displays an image on screen.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>In this recipe, we will be using a custom structure defined as follows:</p>
<pre>
struct PresentInfo { 
  VkSwapchainKHR  Swapchain; 
  uint32_t        ImageIndex; 
};
</pre>
<p>It is used to define a swapchain from which we want to present an image, and an image (its index) that we want to display. For each swapchain, we can present only one image at a time.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Prepare a handle of a queue that supports presenting. Store it in a variable of type <kbd>VkQueue</kbd> named <kbd>queue</kbd>.</li>
<li>Prepare a variable of type <kbd>std::vector&lt;VkSemaphore&gt;</kbd> named <kbd>rendering_semaphores</kbd>. Into this vector, insert semaphores associated with rendering commands that reference images which we want to present.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkSwapchainKHR&gt;</kbd> named <kbd>swapchains</kbd> in which store the handles of all swapchains from which we want to present images.</li>
<li>Create a variable of type <kbd>std::vector&lt;uint32_t&gt;</kbd> named <kbd>image_indices</kbd>. Resize the vector to be the same size as the <kbd>swapchains</kbd> vector. For each element of the <kbd>image_indices</kbd> variable, assign an index of an image from the corresponding swapchain (at the same position in the <kbd>swapchains</kbd> vector).</li>
<li>Create a variable of type <kbd>VkPresentInfoKHR</kbd> named <kbd>present_info</kbd>. Assign the following values for its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li>A number of elements of the <kbd>rendering_semaphores</kbd> vector for <kbd>waitSemaphoreCount</kbd></li>
<li>A pointer to the first element of the <kbd>rendering_semaphores</kbd> vector for <kbd>pWaitSemaphores</kbd></li>
<li>The number of elements in the <kbd>swapchains</kbd> vector for <kbd>swapchainCount</kbd></li>
<li>A pointer to the first element of the <kbd>swapchains</kbd> vector for <kbd>pSwapchains</kbd></li>
<li>A pointer to the first element of the <kbd>image_indices</kbd> vector for <kbd>pImageIndices</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pResults</kbd></li>
</ul>
</li>
<li>Call <kbd>vkQueuePresentKHR( queue, &amp;present_info )</kbd> and provide the handle of the queue to which we want to submit this operation, and a pointer to the <kbd>present_info</kbd> variable.</li>
<li>Make sure the call was successful by comparing the returned value with a <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>A presentation operation gives an image back to the presentation engine, which displays an image according to the presentation mode. We can present multiple images at the same time, but only one image from a given swapchain. To present an image, we provide its index into the array returned by the <kbd>vkGetSwapchainImagesKHR()</kbd> function (refer to the <em>Getting handles of swapchain images</em> recipe):</p>
<pre>
VkPresentInfoKHR present_info = { 
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, 
  nullptr, 
  static_cast&lt;uint32_t&gt;(rendering_semaphores.size()), 
  rendering_semaphores.size() &gt; 0 ? &amp;rendering_semaphores[0] : nullptr, 
  static_cast&lt;uint32_t&gt;(swapchains.size()), 
  swapchains.size() &gt; 0 ? &amp;swapchains[0] : nullptr, 
  swapchains.size() &gt; 0 ? &amp;image_indices[0] : nullptr, 
  nullptr 
};  

result = vkQueuePresentKHR( queue, &amp;present_info ); 
switch( result ) { 
case VK_SUCCESS: 
  return true; 
default: 
  return false; 
}
</pre>
<p>In the preceding sample, the handles of swapchains from which we want to present images and the indices of images are placed in the <kbd>swapchains</kbd> and <kbd>image_indices</kbd> vectors.</p>
<p>Before we can submit an image, we need to change its layout to a <kbd>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</kbd> or the presentation engine may be not able to correctly display such an image.</p>
<p>Semaphores are used to inform the hardware when it can safely display an image. When we submit a rendering command, we can associate a semaphore with such a submission. This semaphore will then change its state to signaled when the commands are finished. We should create and associate a semaphore with commands that reference a presentable image. This way, when we present an image and provide such a semaphore, the hardware will know when an image is no longer in use and displaying it will not interrupt any previously issued operations.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The following recipes in this chapter:
<ul>
<li><em>Selecting a desired presentation mode</em></li>
<li><em>Creating a swapchain</em></li>
<li><em>Getting handles of swapchain images</em></li>
<li><em>Acquiring a swapchain image</em></li>
</ul>
</li>
<li>In <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml">Chapter 3</a>, <em>Command Buffers and Synchronization</em> see the following recipe:
<ul>
<li><em>Creating a semaphore</em></li>
<li><em>Creating a fence</em></li>
</ul>
</li>
<li>In <a href="https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&amp;action=edit#post_207">Chapter 4</a>, <em>Resources and Memory</em> see the following recipe:
<ul>
<li><em>Setting an image memory barrier</em></li>
</ul>
</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Destroying a swapchain</h1>
            

            
                
<p>When we are done using a swapchain, because we don't want to present images any more, or because we are just closing our application, we should destroy it. We need to destroy it before we destroy a presentation surface which was used during a given swapchain creation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Take the handle of a logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a swapchain object that needs to be destroyed. Store it in a variable of type <kbd>VkSwapchainKHR</kbd> named <kbd>swapchain</kbd>.</li>
<li>Call <kbd>vkDestroySwapchainKHR( logical_device, swapchain, nullptr )</kbd> and provide the <kbd>logical_device</kbd> variable as the first argument and the swapchain handle as the second argument. Set the last parameter to <kbd>nullptr</kbd>.</li>
<li>For safety reasons, assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>swapchain</kbd> variable.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>To destroy a swapchain, we can prepare code that is similar to the following example:</p>
<pre>
if( swapchain ) { 
  vkDestroySwapchainKHR( logical_device, swapchain, nullptr ); 
  swapchain = VK_NULL_HANDLE; 
}
</pre>
<p>First we check whether a swapchain was really created (if its handle is not empty). Next we call the <kbd>vkDestroySwapchainKHR()</kbd> function and then we assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>swapchain</kbd> variable to be sure that we won't try to delete the same object twice.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li><em>Creating a swapchain</em> recipe in this chapter</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Destroying a presentation surface</h1>
            

            
                
<p>The presentation surface represents the window of our application. It is used, among other purposes, during swapchain creation. That's why we should destroy the presentation surface after the destruction of a swapchain that is based on a given surface is finished.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Prepare the handle of a Vulkan Instance and store it in a variable of type <kbd>VkInstance</kbd> named <kbd>instance</kbd>.</li>
<li>Take the handle of a presentation surface and assign it to the variable of type <kbd>VkSurfaceKHR</kbd> named <kbd>presentation_surface</kbd>.</li>
<li>Call <kbd>vkDestroySurfaceKHR( instance, presentation_surface, nullptr )</kbd> and provide the <kbd>instance</kbd> and <kbd>presentation_surface</kbd> variables in the first two parameters and a <kbd>nullptr</kbd> value in the last parameter.</li>
<li>For safety reasons, assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>presentation_surface</kbd> variable.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The presentation surface's destruction is very similar to the destruction of other Vulkan resources presented so far. We make sure we don't provide a <kbd>VK_NULL_HANDLE</kbd> value and we call a <kbd>vkDestroySurfaceKHR()</kbd> function. After that, we assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>presentation_surface</kbd> variable:</p>
<pre>
if( presentation_surface ) { 
  vkDestroySurfaceKHR( instance, presentation_surface, nullptr ); 
  presentation_surface = VK_NULL_HANDLE; 
}
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li><em>Creating a presentation surface</em> recipe in this chapter</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>