- en: Chapter 5. Sensing with Digital Inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arduino boards have inputs and outputs. Indeed, this is also one of the strengths
    of this platform: to directly provide headers connecting the ATMega chipset legs.
    We can then directly wire an input or output to any other external component or
    circuit without having to solder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you need it here, I''m reminding you of some points:'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino has digital and analog inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino has digital outputs that can also be used to mimic analog outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to talk about digital inputs in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about the global concept of sensing the world. We are going to meet
    a new companion named **Processing** because it is a nice way to visualize and
    illustrate all that we are going to do in a more graphical way. It is also a pretext
    to show you this very powerful and open source tool. Then, it will drive us to
    design the first serial communication protocol between the board and a piece of
    software.
  prefs: []
  type: TYPE_NORMAL
- en: We'll specifically play with switches, but we will also cover some useful hardware
    design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Sensing the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our over-connected world, a lot of systems don't even have sensors. We, humans,
    own a bunch of biological sensors directly in and over our body. We are able to
    feel temperature with our skin, light with our eyes, chemical components with
    both our nose and mouth, and air movement with ears. From a characteristic of
    our world, we are able to sense, integrate this feeling, and eventually to react.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I go a bit further, I can remember a definition for senses from my early
    physiological courses at university (you remember, I was a biologist in one of
    my previous lives):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Senses are physiological capacities that provide data for perception"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This basic physiological model is a nice way to understand how we can work with
    an Arduino board to make it sense the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, it introduces three elements we need:'
  prefs: []
  type: TYPE_NORMAL
- en: A capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A perception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensors provide new capacities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sensor is a physical converter, able to measure a physical quantity and to
    translate it into a signal understandable directly or indirectly by humans or
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: A thermometer, for example, is a sensor. It is able to measure the local temperature
    and to translate it into a signal. Alcohol-based or Mercury-based thermometers
    provide a scale written on them and the contraction/dilatation of the chemical
    matter according to the temperature makes them easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make our Arduino able to sense the world, temperature for instance,
    we would have to connect a sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Some types of sensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can find various types of types of sensors. We often think about environmental
    sensors when we use the term sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll begin by quoting some environmental quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: Temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas sensors (gas-specific or not, smoke)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electromagnetic fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anemometer (wind speed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capacitance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a non-exhaustive list. For almost each quantity, we can find a sensor.
    Indeed, for each quantifiable physical or chemical phenomenon, there is a way
    to measure and track it. Each of them provides data related to the quantity measured.
  prefs: []
  type: TYPE_NORMAL
- en: Quantity is converted to data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use sensors, the reason is that we need to have a numeric value coming
    from a physical phenomenon, such as temperature or movement. If we could directly
    measure the temperature with our skin's thermal sensors, we would have been able
    to understand the relationship between the volume of chemical components and temperature
    itself. Because we know this relationship from other physical measures or calculations,
    we have been able to design thermometers.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, thermometers are converting a quantity (here a volume) related to the
    temperature into a value readable on the scale of the thermometer. In fact, we
    have a double conversion here. The volume is a function depending on the temperature.
    The height of the liquid inside the thermometer is a function depending on the
    volume of the liquid. Thus, we can understand that the height and temperature
    are related. This is the double conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, the thermometer is a nice module that integrates all this mathematical
    and physical wizardry to provide data, a value: the temperature. As shown in the
    following figure, volume is used to provide a temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quantity is converted to data](img/7584_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All sensors work like that. They are modules measuring physical phenomenon and
    providing a value. We'll see later that those values can be very different, and
    eventually encoded too.
  prefs: []
  type: TYPE_NORMAL
- en: Data has to be perceived
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data provided by a sensor makes more sense if it is read. This can be obvious
    but imagine that the reader isn't a human but is instead an instrument, a machine,
    or in our case, an Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, let''s take an electronic thermal sensor. At first, this one has to
    be supplied with electricity in order to work. Then, if we are able to supply
    it but unable to physically measure the electric potential generated by it from
    its pins, we couldn''t appreciate the main value it tries to provide us: the temperature.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the Arduino would be the device that is able to convert the electric
    potential to something readable or at least easier to understand for us, humans.
    This is again a conversion. From the physical phenomenon that we want to translate,
    to the device displaying the value explaining the physical phenomenon, there are
    conversions and perceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can simplify the process as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data has to be perceived](img/7584_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What does digital mean?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's define precisely what the digital term means here.
  prefs: []
  type: TYPE_NORMAL
- en: Digital and analog concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital, in the computer and electronic worlds, means discrete, which is the
    opposite of analog/continuous. It is also a mathematical definition. We often
    talk about domains to define the cases for use of digital and analog.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the analog domain is the domain related to physical measures. Our temperature
    can have all the values that are possible and that exist, even if our measuring
    equipment dosen't have an infinite resolution.
  prefs: []
  type: TYPE_NORMAL
- en: The digital domain is the one of computers. Because of the encoding and finite
    memory size, computers translates analog/continuous values into digital representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a graph, this could be visualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Digital and analog concepts](img/7584_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inputs and outputs of Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arduino owns inputs and outputs. We can also distinguish analog and digital
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to remember the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino provides digital pins that can be both an input or an output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino provides only analog input, not output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputs and outputs are pins provided by the board to communicate with external
    peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inputs provide the ability to feel the world.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs provide the ability to alter the world.
  prefs: []
  type: TYPE_NORMAL
- en: We often talk about *reading pins* for inputs and *writing pins* for outputs.
    Indeed, from the Arduino board point of view, we are reading from the world and
    writing to the world, aren't we?
  prefs: []
  type: TYPE_NORMAL
- en: A digital input is a digital pin set up like an input and providing the capacity
    for electrical potential reading and conversion to 0 or 1 to the Arduino board.
    We'll illustrate this very soon using switches.
  prefs: []
  type: TYPE_NORMAL
- en: But before manipulating this directly, let me introduce a new friend named **Processing**.
    We'll use it to easily illustrate our Arduino tests further in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a new friend – Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing is an open source programming language and Integrated Development
    Environment (IDE) for people who want to create images, animations, and interaction.
  prefs: []
  type: TYPE_NORMAL
- en: This major open source project was initiated in 2001 by Ben Fry and Casey Reas,
    two gurus and former students of John Maeda at the Aesthetics and Computation
    Group at the MIT Media Lab.
  prefs: []
  type: TYPE_NORMAL
- en: It is a programming framework most used by non-programmers. Indeed, it has been
    designed primarily for this purpose. One of the first targets of Processing is
    to provide an easy way of programming for non-programmers through the instant
    gratification of visual feedback. Indeed, as we know, programming can be very
    abstract. Processing natively provides a canvas on which we can draw, write, and
    do more. It also provides a very user-friendly IDE that we are going to see on
    the official website at [http://processing.org](http://processing.org).
  prefs: []
  type: TYPE_NORMAL
- en: You'll probably also find the term Processing written as **Proce55ing** as the
    domain name `processing.org` was already taken at the time of its inception.
  prefs: []
  type: TYPE_NORMAL
- en: Is Processing a language?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing isn't a language in the strictest sense. It's a subset of Java with
    some external libraries and a custom IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with Processing is usually performed using the native IDE comes
    with the download as we will see in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses the Java language but provides simplified syntax and graphics
    programming. It also simplifies all compilations steps into a one-click action
    like Arduino IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Like Arduino core, it provides a huge set of ready-to-use functions. You can
    find all references at [http://processing.org/reference](http://processing.org/reference).
  prefs: []
  type: TYPE_NORMAL
- en: There is now more than one way to use Processing. Indeed, because JavaScript
    runtimes integrated in web browsers became more and more powerful, we can use
    a JavaScript derived project. You still continue to code using Java, you include
    this code in your webpage, and as the official website says "*Processing.js does
    the rest. It's not magic, but almost*." The website is [http://processingjs.org](http://processingjs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also something very interesting: You can package applications coded
    using Processing for Android mobile OS. You can read this if you are interested
    at [http://processing.org/learning/android](http://processing.org/learning/android).'
  prefs: []
  type: TYPE_NORMAL
- en: I will avoid going on a tangent with the JS and Android applications, but I
    felt it was important enough to mention these usages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's install and launch it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the Arduino framework, the Processing framework doesn't include installation
    program. You just have to put it somewhere and run it from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The download URL is: [http://processing.org/download](http://processing.org/download).'
  prefs: []
  type: TYPE_NORMAL
- en: First, download the package corresponding to your OS. Please refer to the website
    for the install process for your specific OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'On OS X, you have to deflate the zip file and run the resulting file with the
    icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s install and launch it](img/7584_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Processing icon
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the icon, and you''ll see a pretty nice splash screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s install and launch it](img/7584_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then you''ll see the Processing IDE as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s install and launch it](img/7584_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Processing's IDE looks like others
  prefs: []
  type: TYPE_NORMAL
- en: A very familiar IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indeed, the Processing IDE looks like the Arduino one. The Processing IDE is
    like the father of the Arduino IDE.
  prefs: []
  type: TYPE_NORMAL
- en: This is totally normal because the Arduino IDE has been forked from the Processing
    IDE. Now, we are going to check that we'll be very comfortable with the Processing
    IDE as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore it and run a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Files** | **Examples Basics** | **Arrays** | **ArraysObjects**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the first icon (the play symbol arrow). You should see the following
    screenshot:![A very familiar IDE](img/7584_05_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running ArrayObjects native example in Processing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now click on the small square (stop symbol). Yes, this new playground is very
    familiar.![A very familiar IDE](img/7584_05_008.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Processing IDE with ArrayObjects example opened
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top we can see some familiar icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'From left to right, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Run** (small arrow): This is used to compile and run your program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop** (small square): This is used to stop the program when it is running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New project** (small page): This is used to open a blank canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open project** (top arrow): This is used to open an existing project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Save project** (down arrow): This is used to save a project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export application** (right arrow): This is used to create an application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No Upload button of course. There is no need to upload anything here; we are
    on the computer and we only want to code applications, compile them, and run them.
  prefs: []
  type: TYPE_NORMAL
- en: With Processing, you have everything in hand to code, compile, and run.
  prefs: []
  type: TYPE_NORMAL
- en: You can have some tabs if you use more than one file in your project (especially
    if you use some separate Java classes).
  prefs: []
  type: TYPE_NORMAL
- en: Under this tab zone, you have the text area where you type your code. Code is
    colored as in the Arduino IDE, and this is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: At last, at the bottom, you have the log console area where all the messages
    can be output, from errors to our own tracer messages.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative IDEs and versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in digging some IDE alternatives, I'd suggest that you
    use the universal and open source software development environment Eclipse. I
    suggest that to all the students I meet who want to go further in pure-development
    fields. This powerful IDE can be easily set up to support versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning is a very nice concept providing an easy way to track versions of
    your code. You can, for instance, code something, test it, back it up in your
    versioning system, then continue your code design. If you run it and have a nice
    and cute crash at some point, you can easily check the differences between your
    working code and the new non working one and make your troubleshooting much easier!
    I won't describe versioning systems in detail, but I want to introduce you to
    the two main systems that are widely used a
  prefs: []
  type: TYPE_NORMAL
- en: '[http://subversion.apache.org](http://subversion.apache.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: [http://git-scm.com](http://git-scm.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a small piece of code showing some cheap and easy design patterns.
    You can also find this code in the folder `Chapter05` `/p` `rocessingMultipleEasing/`
    in the code bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can run this piece of code. Then, you can move the mouse into the canvas
    and enjoy what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking an example](img/7584_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: processingMultipleEasing code running and showing a strange series of particles
    following the mouse
  prefs: []
  type: TYPE_NORMAL
- en: First, check the code. Basically, this is Java. I guess you aren't shocked too
    much, are you? Indeed, Java derives from C.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see three main parts in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations/definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setup()`function that runs only once at the beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `draw()` function that runs infinitely until you press stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ok. You can see the `setup()` functions in the Arduino core and Processing have
    similar roles, and `loop()` and `draw()` too.
  prefs: []
  type: TYPE_NORMAL
- en: This piece of code shows some usual design patterns with Processing. I first
    initiate a variable storing the global number of particles, then I initiate some
    arrays for each particle I want to create. Please notice all these arrays are
    empty at this step!
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is usual because it offers good readability and works fine too.
    I could have used classes or even multidimensional arrays, but in this latter
    case, I would not even have benefits except a shorter (but less readable) code.
    In all those arrays, the *N*th indexed value represents the particle *N*. In order
    to store/retrieve the parameters of particle *N*, I have to manipulate the *N*th
    value for each array. The parameters are spread inside each array but are easy
    to store and retrieve, aren't they?
  prefs: []
  type: TYPE_NORMAL
- en: In `setup()`, I define and instantiate the canvas and its size of 600 x 600\.
    Then, I'm defining that there will be no stroke in any of my drawings. The stroke
    of a circle, for instance, is its border.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I'm filling the `easing` and `radii` arrays using a `for` loop structure.
    This is a very usual pattern where we can use `setup()` to initialize a bunch
    of parameters at the beginning. Then we can check the `draw()` loop. I'm defining
    a color for the background. This function also erases the canvas and fills it
    with the color in argument. Check the background function on the reference page
    to understand how we can use it. This erase/fill is a nice way to erase each frame
    and to reset the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: After this erase/fill, I'm storing the current position of the mouse for each
    coordinate in the local variables `targetX` and `targetY`.
  prefs: []
  type: TYPE_NORMAL
- en: The core of the program sits in the `for` loop. This loop walks over each particle
    and makes something for each of them. The code is quite self-explanatory. I can
    add here that I'm checking the distance between the mouse and each particle for
    each frame (each run of `draw()`), and I draw each particle by moving them a bit,
    according to its easing.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple example but a nice one I used to show to illustrate the
    power of Processing.
  prefs: []
  type: TYPE_NORMAL
- en: Processing and Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing and Arduino are very good friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, they are both open source. It is a very friendly characteristic bringing
    a lot of advantages like code source sharing and gigantic communities, among others.
    They are available for all OSes: Windows, OS X, and Linux. We also can download
    them for free and run them in a couple of clicks.'
  prefs: []
  type: TYPE_NORMAL
- en: I began to program primarily with Processing, and I use it a lot for some of
    my own data visualization projects and art too. Then, we can illustrate complex
    and abstract data flows by smooth and primitive shapes on a screen.
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do together now is display Arduino activity on the Processing
    canvas. Indeed, this is a common use of Processing as an eye-friendly software
    for Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to design a very trivial and cheap protocol of communication between
    the hardware and the software. This will show you the path that we'll dig further
    in the next chapters of this book. Indeed, if you want to get your Arduino talking
    with another software framework (I'm thinking about Max 6, openFrameworks, Cinder,
    and many others), you'll have to follow the same ways of design.
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing and Arduino](img/7584_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Arduino and some software friends
  prefs: []
  type: TYPE_NORMAL
- en: I often say Arduino can work as a very smart *organ* of software. If you want
    to connect some software to the real, physical world, Arduino is the way to go.
    Indeed, that way, software can sense the world, providing your computer with new
    features. Let's move on by displaying some physical world events on the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to have fun. Yes, this is the very special moment when we are going
    to link the physical world to the virtual world. Arduino is all about this.
  prefs: []
  type: TYPE_NORMAL
- en: What is a button, a switch?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **switch** is an electrical component that is able to break an electrical
    circuit. There are a lot of different types of switches.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of switches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some switches are called **toggles**. Toggles are also named continuous switches.
    In order to act on the circuit, the toggle can be pushed and released each time
    you want to act and when you release it, the action continues.
  prefs: []
  type: TYPE_NORMAL
- en: Some others are called **momentaries**. Momentaries are named **push for action**
    too. In order to act on the circuit, you have to push and keep the switch pushed
    to continue the action. If you release it, the action stops.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, all our switches at home are toggles. Except the one for the mixer
    that you have to push to cut and release to stop it, which means it is a momentary.
  prefs: []
  type: TYPE_NORMAL
- en: A basic circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a basic circuit with an Arduino, a momentary switch and a resistor.
  prefs: []
  type: TYPE_NORMAL
- en: We want to turn the board's built-in LED ON when we push the momentary switch
    and turn it OFF when we release it.
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic circuit](img/7584_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A small circuit
  prefs: []
  type: TYPE_NORMAL
- en: I'm presenting you with the circuit on which we are going to work right now.
    This is also a nice pretext to make you more familiar with circuit diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Wires
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each line represents a link between two components. By definition, a line is
    a wire and there is no electrical potential from one side to the other. It can
    also be defined as follows: a wire has a resistance of 0 ohm. Then we can say
    that two points linked by a wire have the same electrical potential.'
  prefs: []
  type: TYPE_NORMAL
- en: The circuit in the real world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, I didn't want to show you the next diagram directly. Now we have
    to build the real circuit, so please take some wires, your breadboard, and the
    momentary switch, and wire the whole circuit as shown in the next diagram.
  prefs: []
  type: TYPE_NORMAL
- en: You can take a resistor around 10 Kohms. We'll explain the purpose of the resistor
    in the next pages.
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit in the real world](img/7584_05_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The momentary switch in a real circuit
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain things a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Let's remember the breadboard wiring; I'm using cold and hot rails at the top
    of the breadboard (cold is blue and means ground, hot is red and means +5 V).
    After I have wired the ground and +5 V from the Arduino to the rails, I'm using
    rails to wire the other parts of the board; it is easier and requires shorter
    cables.
  prefs: []
  type: TYPE_NORMAL
- en: There is a resistor between the ground and the digital pin 2\. There is a momentary
    switch between the +5 V line and the pin 2 as well. The pin 2 will be set up as
    an input, which means it will be able to sink current.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, switches are *push-to-on*. Pushing them closes the circuit and lets
    the current flow. So, in that case, if I don't push the switch, there is no current
    from +5 V to the pin 2.
  prefs: []
  type: TYPE_NORMAL
- en: For the duration it is pressed, the circuit is closed. Then, current flows from
    the +5 V to the pin 2\. It is a bit metaphoric and abusive, and I should say we
    have created an electrical potential between +5 V and the pin 2, but I need to
    be shorter to hit the point home.
  prefs: []
  type: TYPE_NORMAL
- en: And this resistor, why is it here?
  prefs: []
  type: TYPE_NORMAL
- en: The pull-up and pull-down concept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the global circuit is easy, the resistor part can be a bit tricky at first
    sight.
  prefs: []
  type: TYPE_NORMAL
- en: A digital pin set up as an input provides the ability to *sink* current. This
    means it behaves like the ground. Indeed, and in fact, internally, it works exactly
    as if the concerned pin was connected to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: With a properly coded firmware, we would have the ability to check pin 2\. This
    means we could test it and read the value of the electrical potential. Because
    it is a digital input, an electrical potential near +5 V would be translated as
    the value HIGH, and if it is near 0 V, it will be translated as the value LOW.
    Both values are constants defined inside the Arduino core. But if everything seems
    totally perfect in a perfect digital world, it is not true.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the input signal noise could potentially be read as a button press.
  prefs: []
  type: TYPE_NORMAL
- en: To be sure and safe, we use what we call a *pull-down resistor*. This is usually
    a high impedance resistance that provides a current sink to the digital pin considered,
    making it safer at the value 0 V if the switch is not pressed. Pull down to be
    more consistently recognized as a LOW value, pull up to be more consistently recognized
    as the HIGH value.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the global energy consumption increases a bit. In our case, this
    is not important here but you have to know that. On this same concept, a pull-up
    resistor can be used to link the +5 V to the digital output. Generally, you should
    know that a chipset's I/O shouldn't be floating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what you have to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of Digital Pin | Input | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pull Resistor | Pull-down resistor | Pull-up resistor |'
  prefs: []
  type: TYPE_TB
- en: We want to push a switch, and particularly, this action has to turn the LED
    ON. We are going to write a pseudocode first.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudocode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a possible pseudocode. Following are the steps we want our firmware
    to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable for the current switch state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the LED pin as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the switch pin as an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up an infinite loop. In the infinite loop do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the input state and store it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the input state is HIGH, turn the LED ON.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Else turn the LED OFF.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a translation of this pseudocode in valid C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As usual you can also find the code in the `Chapter05/MonoSwitch/` folder available
    for download along with other code files on Packt Publishing's site.
  prefs: []
  type: TYPE_NORMAL
- en: Upload it and see what happens. You should have a nice system on which you can
    push a switch and turn on an LED. Splendid!
  prefs: []
  type: TYPE_NORMAL
- en: Now let's make the Arduino board and Processing communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Making Arduino and Processing talk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we want to visualize our switch's manipulations on the computer.
  prefs: []
  type: TYPE_NORMAL
- en: We have to define a small communication protocol between Arduino and Processing.
    Of course, we'll use a serial communication protocol because it is quite easy
    to set it up and it is light.
  prefs: []
  type: TYPE_NORMAL
- en: We could design a protocol as a library of communication. We only design a protocol
    using the native Arduino core at the moment. Then, later in this book, we will
    design a library.
  prefs: []
  type: TYPE_NORMAL
- en: The communication protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A communication protocol is a system of rules and formats designed for exchanging
    messages between two entities. Those entities can be humans, computers and maybe
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, I''d use a basic analogy with our language. In order to understand
    each other, we have to follow some rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic and grammatical rules (I have to use words that you know)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical rules (I have to talk loud enough)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social rules (I shouldn't insult you just before asking you for the time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I could quote many other rules like the speed of talking, the distance between
    the two entities, and so on. If each rule is agreed upon and verified, we can
    talk together. Before designing a protocol, we have to define our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What do we want to do?
  prefs: []
  type: TYPE_NORMAL
- en: We need a communication protocol between our Arduino and Processing inside the
    computer. Right! These requirements are usually the same for a lot of communication
    protocols you'll design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short list of very important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol must be expandable without having to rewrite everything each time
    I want to add new message types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protocol must be able to send enough data quite quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protocol must be easy to understand and well commented, especially for open
    source and collaborative projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol design
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each message will be 2 bytes in size. This is a common data packet size and
    I propose to organize data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte 1**: switch number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Byte 2**: switch state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that I defined byte 1 as a representation of the switch number is typically
    because of the requirement of expandability. With one switch, the number will
    be 0.
  prefs: []
  type: TYPE_NORMAL
- en: I can easily instantiate serial communication between the board and the computer.
    Indeed, we already made that when we used Serial Monitoring at least on the Arduino
    side.
  prefs: []
  type: TYPE_NORMAL
- en: How can we do that using Processing?
  prefs: []
  type: TYPE_NORMAL
- en: The Processing code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processing comes with very useful set of libraries already integrated into its
    core. Specifically, we are going to use the serial library.
  prefs: []
  type: TYPE_NORMAL
- en: Let's sketch a pseudocode first, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Sketching a pseudocode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What do we want the program to do?
  prefs: []
  type: TYPE_NORMAL
- en: I propose to have a big circle. Its color will represent the switch's state.
    *Dark* will mean released, and *green* will mean pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define and instantiate the serial port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a current drawing color to dark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the infinite loop, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the serial port and grab data have been received.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If data indicates that state is off, change current drawing from color to dark.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Else, change current drawing color to green.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the circle with the current drawing color.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's write that code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's open a new processing canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Because the Processing IDE works like the Arduino IDE and needs to create all
    saved project files in a folder, I'd suggest that you directly save the canvas,
    even empty, in the right place on your disk. Call it `processingOneButtonDisplay`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in the `Chapter05/processingOneButtonDisplay/` folder
    available for download along with other code files on Packt's site.
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s write that code](img/7584_05_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making a library inclusion in your code
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the serial library from the Processing core, you can go to **Sketch
    | Import Library… | serial**. It adds this row to your code: `processing.serial.*;`'
  prefs: []
  type: TYPE_NORMAL
- en: You could also type this statement by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code, with a lot of comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Variable definitions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`theSerialPort` is an object of the `Serial` library. I have to create it first.'
  prefs: []
  type: TYPE_NORMAL
- en: '`serialBytesArray` is an array of two integers used to store messages coming
    from Arduino. Do you remember? When we designed the protocol, we talked about
    2 byte messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '`switchState` and `switchID` are global but temporary variables used to store
    the switch state and the switch ID corresponding to the message coming from the
    board. Switch ID has been put there for (close) future implementation to distinguish
    the different switches in case we use more than one.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bytesCount` is a useful variable tracking the current position in our message
    reading.'
  prefs: []
  type: TYPE_NORMAL
- en: '`init` is defined to `false` at the beginning and becomes `true` when the first
    byte from the Arduino (and a special one, `Z`) has been received for the first
    time. It is a kind of first-contact purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we keep a trace of the fill color and the initial one is `40`. `40` is
    only an integer and will be used a bit further as an argument of the function
    `fill()`.
  prefs: []
  type: TYPE_NORMAL
- en: setup()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define the canvas (size, background color, and no stroke).
  prefs: []
  type: TYPE_NORMAL
- en: We print a list of all the serial ports available on your computer. This is
    debug information for the next statement where we store the name of the first
    serial port into a String. Indeed, you could be led to change the array element
    from 0 to the correct one according to the position of your Arduino's port in
    the printed list.
  prefs: []
  type: TYPE_NORMAL
- en: This String is then used in the very important statement that instantiates serial
    communication at 9600 bauds.
  prefs: []
  type: TYPE_NORMAL
- en: This `setup()` function, of course, runs only once.
  prefs: []
  type: TYPE_NORMAL
- en: draw()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The draw function is very light here.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the variable `fillColor` to the `fill()` function, setting up the color
    with which all further shapes will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we draw the circle with the ellipse function. This function takes four
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: x coordinates of the center of the ellipse (here `width/2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: y coordinates of the center of the ellipse (here `height/2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Width of the ellipse (here `230`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Height of the ellipse (here `230`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` and `height` colored in blue in the Processing IDE are the current
    width and height of the canvas. It is very useful to use them because if you change
    the `setup()` statement by choosing a new size for the canvas, all `width` and
    `height` in your code will be updated automatically without needing to change
    them all manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that an ellipse with same values for `width` and `height`
    is a circle (!). Ok. But where is the magic here? It will only draw a circle,
    every time the same one (size and position). `fillColor` is the only variable
    of the `draw()` function. Let's see that strange callback named `serialEvent()`.
  prefs: []
  type: TYPE_NORMAL
- en: The serialEvent() callback
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We talked about callbacks in [Chapter 4](ch04.html "Chapter 4. Improve Programming
    with Functions, Math, and Timing"), *Improve Programming with Functions, Math,
    and Timing*.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have a pure callback method in Processing. This is an event-driven
    callback. It is useful and efficient not to have to poll every time our serial
    port wants to know if there is something to read. Indeed, user interfaces related
    events are totally less numerous than the number of Arduino board's processor
    cycles. It is smarter to implement a callback in that case; as soon as a serial
    event occurs (that is, a message is received), we execute a series of statements.
  prefs: []
  type: TYPE_NORMAL
- en: '`myPort.read()` will first read the bytes received. Then we make the test with
    the `init` variable. Indeed, if this is the very first message, we want to check
    if the communication has already begun.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case where it is the first hello (`init == false`), if the message coming
    from the Arduino Board is `Z`, Processing program clear its own serial port, stores
    the fact the communication has just started, and resends back `Z` to the Arduino
    board. It is not so tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we can begin to talk only if we begin by saying "hello" to each other.
    We aren't watching each other (no event). Then I begin to talk. You turn your
    head to me (serial event occurs) and listen. Am I saying "hello" to you? (whether
    the message is `Z`?). If I'm not, you just turn your head back (no `else` statement).
    If I am, you answer "hello" (sending back `Z`) and the communication begins.
  prefs: []
  type: TYPE_NORMAL
- en: What happens then?
  prefs: []
  type: TYPE_NORMAL
- en: If communication has already begun, we have to store bytes read into the `serialBytesArray`
    and increment the `bytesCount`. While bytes are being received and `bytesCount`
    is smaller or equal to 1, this means we don't have a complete message (a complete
    message is two bytes) and we store more bytes in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the bytes count equals `2`, we have a complete message and we can
    "split" it into the variables `switchID` and `switchState`. Here''s how we do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This next statement is a debug one: we print each variable. Then, the core
    of the method is the test of the `switchState` variable. If it is `0`, it means
    the switch is released, and we modify the `fillColor` to `40` (dark color, `40`
    means the value 40 for each RGB component; check `color()` method in Processing
    reference at [http://processing.org/reference/color_.html](http://processing.org/reference/color_.html)).
    If it isn''t `0`, we modify the `fillColor` to `255`, which means white. We could
    be a bit safer by not using only `else`, but `else if (switchState ==1)` also.'
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because if we are not sure about all the messages that can be sent (lack
    of documentation or whatever else making us unsure), we can modify the color to
    white *only* if `switchState` equals `1`. This concept can be done at the optimization
    state too, but here, it is quite light so we can leave it like that.
  prefs: []
  type: TYPE_NORMAL
- en: Ok. It is a nice, heavy piece, right? Now, let's see how we have to modify the
    Arduino code. Do you remember? It isn't communication ready yet.
  prefs: []
  type: TYPE_NORMAL
- en: The new Arduino firmware talk-ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we now have a nice way to display our switch state, I''ll remove all
    things related to the built-in LED of the board and following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What do we have to add? All the `Serial` stuff. I also want to add a small function
    dedicated to the first "hello".
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result, then we will see the explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m defining one new variable first: `inByte`. This stores the bytes read.
    Then inside the `setup()` method, I''m instantiating serial communication as we
    already learned to do with Arduino. I''m setting up the `pinMode` method of the
    switch pin then, I''m calling `sayHello()`.'
  prefs: []
  type: TYPE_NORMAL
- en: This function just waits for something. Please focus on this.
  prefs: []
  type: TYPE_NORMAL
- en: I'm calling this function in `setup()`. This is a *simple* call, not a callback
    or whatever else. This function contains a `while` loop while `Serial.available()`
    is smaller or equal to zero. What does this mean? It means this function pauses
    the `setup()` method while the first byte comes to the serial port of the Arduino
    board. The `loop()` done doesn't run while the `setup()` done has finished, so
    this is a nice trick to wait for the first external event; in this case, the first
    communication. Indeed, the board is sending the message `Z` (that is, the "hello")
    while Processing doesn't answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The consequence is that when you can plug in your board, it sends `Z` continuously
    while you run your Processing program. Then the communication begins and you can
    push the switch and see what is happening. Indeed, as soon as the communication
    begins, `loop()` begins its infinite loop. At first a test is made at each cycle
    and we only test if a byte is being received. Whatever the byte received (Processing
    only sends `Z` to the board), we read the digital pin of the switch and send back
    two bytes. Here too, pay attention please: each byte is written to the serial
    port using `Serial.write()`. You have to send 2 bytes, so you stack two `Serial.write()`.
    The first byte is the number (ID) of the switch that is pushed/released; here,
    it is not a variable because we have one and only one switch, so it is an integer
    0\. The second byte is the switch state. We just saw here a nice design pattern
    involving the board, an external program running on a computer and a communication
    between both of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go further and play with more than one switch.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with multiple buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extrapolate our previously designed logic with more than one switch.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to use multiple switches, and, in general, multiple inputs
    on the Arduino. We're going to see a cheap and easy first way right now. This
    way doesn't involve multiplexing a lot of inputs on only a couple of Arduino inputs
    but a basic one to one wiring where each switch is wired to one input. We'll learn
    multiplexing a bit later (in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is the circuit diagram required to work with multiple switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit](img/7584_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wiring three momentary switches to the Arduino board
  prefs: []
  type: TYPE_NORMAL
- en: The schematic is an extrapolation of the previous one that showed only one switch.
    We can see the three switches between the +5 V and the three pull-down resistors.
    Then we can also see the three wires going to digital inputs 2 to 4 again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small memory refresh: Why didn''t I use the digital pins 0 or 1?'
  prefs: []
  type: TYPE_NORMAL
- en: Because I'm using serial communication from the Arduino, we cannot use the digital
    pins 0 and 1 (each one respectively corresponding to RX and TX used in serial
    communication). Even if we are using the USB link as the physical support for
    our serial messages, the Arduino board is designed like that and we have to be
    very careful with it.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the circuit view with the breadboard. I voluntarily didn't align every
    wire. Why? Don't you remember that I want you to be totally autonomous after reading
    this book and yes, you'll find many schematics in the real world made sometimes
    like that. You have to become familiar with them too. It could be an (easy) homework
    assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit](img/7584_05_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding circuit shows the three switches, the three pull-down resistors,
    and the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: Both source codes have to be modified to provide a support for the new circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add things there.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the new code; of course, you can find it in the `Chapter05/MultipleSwitchesWithProcessing/`
    folder available for download along with other code files on Packt''s site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's explain this code.
  prefs: []
  type: TYPE_NORMAL
- en: At first, I defined a constant `switchesNumber` to the number `3`. This number
    can be changed to any other number from `1` to `12`. This number represents the
    current number of switches wired to the board from digital pin 2 to digital pin
    14\. All switches have to be linked without an empty pin between them.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I defined an array to store the switch's states. I declared it using the
    `switchesNumber` constant as the length. I have to fill this array with zeroes
    in the `setup()` method, that I made with a `for` loop. It provides a safe way
    to be sure that all switches have a release state in the code.
  prefs: []
  type: TYPE_NORMAL
- en: I still use the `sayHello()` function, to set up the communication start with
    Processing.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, I have to fill each switch state in the array `switchesStates` so I
    added the `for` loop. Please notice the index trick in each `for` loop. Indeed,
    because it seems to be more convenient to start from 0 and because in the real
    world we mustn't use digital pins 0 and 1 while using serial communications, I
    added `2` as soon as I dealt with the real number of the digital pin, that is,
    with the two functions `pinMode()` and `digitalRead()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's upgrade the Processing code too.
  prefs: []
  type: TYPE_NORMAL
- en: The Processing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the new code; you can find it in the `Chapter05/MultipleSwitchesWithProcessing/`
    folder available for download along with other code files on Packt''s site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is a screenshot of the render of this code used with five switches
    while I was pushing on the fourth button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Processing code](img/7584_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what did I alter?
  prefs: []
  type: TYPE_NORMAL
- en: Following the same concept as with the Arduino code, I added a variable (not
    a constant here), named `switchesNumber`. A nice evolution could be to add something
    to the protocol about the number of the switch. For instance, the Arduino board
    could inform Processing about the switch's number according to only one constant
    defined in the Arduino firmware. This would save the manual update of the processing
    code when we change this number.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also transformed the variable `switchState` into an array of integers `switchesStates`.
    This one stores all the switches'' states. I added two variables related to the
    display: `distanceCircles` and `radii`. Those are used for dynamically displaying
    the position of circles according to the number of switches. Indeed, we want one
    circle per switch.'
  prefs: []
  type: TYPE_NORMAL
- en: The `setup()` function is almost the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: I'm calculating here the distance between two circles by dividing the width
    of the canvas by the number of circles. Then, I'm calculating the radii of each
    circle by using the distance between them divided by 2\. These numbers can be
    changed. You could have a very different aesthetical choice.
  prefs: []
  type: TYPE_NORMAL
- en: Then the big difference here is also the `for` loop. I'm filling the whole `switchesStates`
    array with zeroes to initialize it. At the beginning, none of the switches are
    pushed. The `draw()` function now also includes a `for` loop. Pay attention here.
    I removed the `fillColor` method because I moved the fill color choice to the
    draw. This is an alternative, showing you the flexibility of the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the same for loop, I'm drawing the circle number *i*. I will let you check
    for yourself how I have placed the circles. The `serialEvent()` method doesn't
    change a lot either. I removed the fill color change as I wrote before. I also
    used the `switchesStates` array, and the index provided by the first byte of the
    message that I stored in `switchID`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can run the code on each side after you have uploaded the firmware
    on the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: Magic? I guess you now know that it isn't magic at all, but beautiful, maybe.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go a bit further talking about something important about switches, but
    also related to other switches.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the debounce concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now here is a small section that is quite cool and light compared to analog
    inputs, which we will dive into in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to talk about something that happens when someone pushes a button.
  prefs: []
  type: TYPE_NORMAL
- en: What? Who is bouncing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we have to take our microscopic biocybernetic eyes to zoom into the switch's
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: A switch is made with pieces of metal and plastic. When you push the cap, a
    piece of metal moves and comes into contact with another piece of metal, closing
    the circuit. Microscopically and during a very small time interval, things aren't
    that clean. Indeed, the moving piece of metal bounces against the other part.
    With an oscilloscope measuring the electrical potential at the digital pin of
    the Arduino, we can see some noise in the voltage curve around 1 ms after the
    push.
  prefs: []
  type: TYPE_NORMAL
- en: These oscillations could generate incorrect inputs in some programs. Imagine,
    that you want to count the states transitions in order, for instance, to run something
    when the user pushed the switch seven times. If you have a bouncing system, by
    pushing only once, the program could count a lot of transitions even if the user
    pushed the switch only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the next graph. It represents the voltage in relation to time. The small
    arrows on the time axis show the moment when the switch has been pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What? Who is bouncing?](img/7584_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How can we deal with these oscillations?
  prefs: []
  type: TYPE_NORMAL
- en: How to debounce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two distinct elements on which we can act:'
  prefs: []
  type: TYPE_NORMAL
- en: The circuit itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit itself can be modified. I could quote some solutions such as adding
    diodes, capacitors, and some Schmitt trigger inverters. I won't explain that solution
    in detail because we are going to do that in software, but I can explain the global
    concept. The capacitor in that case will be charged and discharged while the switch
    will be bouncing, smoothing those peaks of noise. Of course, some tests are needed
    in order to find the perfect components fitting your precise needs.
  prefs: []
  type: TYPE_NORMAL
- en: The firmware can also be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we can use a time-based filter, because the bounce occurs during
    a particular amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code, then will come explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Following is an example of the debouncing cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning, I defined some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lastSwitchState`: This stores the last read state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastDebounceTime`: This stores the moment when the last debounce occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debounceDelay`: This is the value during which nothing is taken as a safe
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using `millis()` here in order to measure the time. We already talked
    about this time function in [Chapter 4](ch04.html "Chapter 4. Improve Programming
    with Functions, Math, and Timing"), *Improve Programming with Functions, Math,
    and Timing*.
  prefs: []
  type: TYPE_NORMAL
- en: Then, at each `loop()` cycle, I read the input but basically I don't store it
    in the `switchState` variable that is used to the test to turning ON or OFF the
    LED. Basically, I used to say that `switchState` is the official variable that
    I don't want to modify before the debounce process. Using other terms, I can say
    that I'm storing something in `switchState` only when I'm sure about the state,
    not before.
  prefs: []
  type: TYPE_NORMAL
- en: So I read the input at each cycle and I store it in `readInput`. I compare `readInput`
    to the `lastSwitchState` variable that is the last read value. If both variables
    are different, what does it mean? It means a change occurs, but it can be a bounce
    (unwanted event) or a real push. Anyway, in that case, we reset the counter by
    putting the current time provided by `millis()` to `lastDebounceTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we check if the time since the last debounce is greater than our delay.
    If it is, then we can consider the last `readInput` in this cycle as the real
    switch state and we can store it into the corresponding variable. In the other
    case, we store the last read value into `lastSwitchState` to keep it for the next
    cycle comparison.
  prefs: []
  type: TYPE_NORMAL
- en: This method is a general concept used to smooth inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We can find here and there some examples of software debouncing used not only
    for switches but also for noisy inputs. In everything related to a user-driven
    event, I would advise using this kind of debouncer. But for everything related
    to system communication, debounce can be very useless and even a problem, because
    we can ignore some important messages and data. Why? Because a communication system
    is much faster than any user, and if we can use 50 ms as the time during which
    nothing is considered as a real push or a real release with users, we cannot do
    that for very fast chipset signals and other events that could occurs between
    systems themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learnt a bit more about digital inputs. Digital inputs can be used *directly*,
    as we just did, or also *indirectly*. I'm using this term because indeed, we can
    use other peripherals for encoding data before sending them to digital inputs.
    I used some distance sensors that worked like that, using digital inputs and not
    analog inputs. They encoded distance and popped it out using the I2C protocol.
    Some specific operations were required to extract and use the distance. In this
    way, we are making an indirect use of digital inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice way to sense the world is the use of analog inputs. Indeed, this
    opens a new world of continuous values. Let's move on.
  prefs: []
  type: TYPE_NORMAL
