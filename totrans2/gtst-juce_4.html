<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Using Media Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Media Files</h1></div></div></div><p>JUCE provides its own classes for reading and writing files and many helper classes for specific media formats. This chapter introduces the main examples of these classes. In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using simple input and output streams</li><li class="listitem" style="list-style-type: disc">Reading and writing image files</li><li class="listitem" style="list-style-type: disc">Playing audio files</li><li class="listitem" style="list-style-type: disc">Working with the Binary Builder tool to turn binary files into source code</li></ul></div><p>By the end of this chapter, you will be able to manipulate a range of media files<a id="id213" class="indexterm"/> using JUCE.</p><div class="section" title="Using simple input and output streams"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Using simple input and output streams</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Essential Data Structures">Chapter 3</a>, <span class="emphasis"><em>Essential Data Structures</em></span>, we introduced the JUCE <code class="literal">File</code> class, which is used for <a id="id214" class="indexterm"/>specifying file paths in a cross-platform manner. In addition, the <code class="literal">File</code> class includes some convenience functions for reading and writing <a id="id215" class="indexterm"/>files as blocks of data or strings of text. In many cases these functions are sufficient, but in others, raw access to input and output streams may be more useful.</p><div class="section" title="Reading and writing text files"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Reading and writing text files</h2></div></div></div><p>First, <a id="id216" class="indexterm"/>create a console application project in the Introjucer <a id="id217" class="indexterm"/>application and name it <code class="literal">Chapter04_01</code>. In this<a id="id218" class="indexterm"/> simple example<a id="id219" class="indexterm"/>, we will declare two functions, one for writing text to the file—<code class="literal">writeFile()</code>
<a id="id220" class="indexterm"/>, and one for reading the contents of the file—<code class="literal">readFile()</code>
<a id="id221" class="indexterm"/>. Each of these functions is passed the same file path reference created in the way we did in <a class="link" href="ch03.html" title="Chapter 3. Essential Data Structures">Chapter 3</a>, <span class="emphasis"><em>Essential Data Structures</em></span>. Replace the contents of the <code class="literal">Main.cpp</code> file with the following, where we declare the file reading and writing functions, and define a <code class="literal">main()</code> function:</p><div class="informalexample"><pre class="programlisting">#include "../JuceLibraryCode/JuceHeader.h"

void writeFile (File const&amp; file);
void readFile (File const&amp; file);

int main (int argc, char* argv[])
{
  File file (File::getSpecialLocation(File::currentExecutableFile)
             .getParentDirectory()
             .getChildFile ("chapter04_01_test.txt"));
  
  writeFile (file);
  readFile (file);
  
  return 0;
}</pre></div><p>Then, add the definition for the <code class="literal">writeFile()</code> function:</p><div class="informalexample"><pre class="programlisting">void writeFile (File const&amp; file)
{
  Logger *log = Logger::getCurrentLogger();
  FileOutputStream stream (file);
  
  if (!stream.openedOk()) {
    log-&gt;writeToLog ("failed to open stream");
    return;
  }
  
  stream.setPosition (0);
  stream.truncate();
  
  String text ("The quick brown fox jumps over the lazy dog.");
  
  bool asUTF16 = false;
  bool byteOrderMark = false;
  stream.writeText (text, asUTF16, byteOrderMark);
}</pre></div><p>Here, we<a id="id222" class="indexterm"/> create a <code class="literal">FileOutputStream</code> object, passing it the <code class="literal">File</code> object <a id="id223" class="indexterm"/>that refers to the file path. The <code class="literal">FileOutputStream</code> class inherits from the base class <code class="literal">OutputStream</code> that represents the general notions of writing data to a stream. There can be other types of output stream, such as the <code class="literal">MemoryOutputStream</code> class for writing data to areas of computer memory in a stream-like manner. The default behavior of the <code class="literal">FileOutputStream</code> class on construction is to position the stream's write position at the end of the file if the file already exists (or to create an empty file if it doesn't). The calls to the <code class="literal">FileOutputStream::setPosition()</code> and <code class="literal">FileOutputStream::truncate()</code> functions <a id="id224" class="indexterm"/>effectively <a id="id225" class="indexterm"/>empty the file each time before we write it. Of course, in a real application you may not want to do this each time. The call to the <code class="literal">FileOutputStream::writeText()</code> function is almost equivalent to the <code class="literal">File::appendText()</code> function, although the flags for controlling the output in Unicode UTF16 format are implicit for the <code class="literal">File::appendText()</code> function, but need to be specified explicitly for the <code class="literal">FileOutputStream::writeText()</code> function. Here, we write the data in UTF8 format by setting both flags to <code class="literal">false</code>.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>The UFT8 format is probably most convenient, because the text we are writing is plain ASCII text, which is compatible with UTF8 encoding.</p></div></div><p>Finally, add the definition for the <code class="literal">readFile()</code> function:</p><div class="informalexample"><pre class="programlisting">void readFile (File const&amp; file)
{
  Logger *log = Logger::getCurrentLogger();
  FileInputStream stream (file);
  
  if (!stream.openedOk()) {
    log-&gt;writeToLog ("failed to open stream");
    return;
  }
  
  log-&gt;writeToLog ("fileText: " +stream.readEntireStreamAsString());
}</pre></div><p>Here, we attempt to read the entire stream into a <code class="literal">String</code>, and post it to the log. We use a <code class="literal">FileInputStream</code> object, which inherits from the more general <code class="literal">InputStream</code> class. In both the <code class="literal">writeFile()</code> and <code class="literal">readFile()</code> functions we check that the streams opened successfully before proceeding. In addition to this, the stream objects gracefully close the streams when they go out of scope.</p></div><div class="section" title="Reading and writing binary files"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Reading and writing binary files</h2></div></div></div><p>The <a id="id226" class="indexterm"/>output and input streams can be used for binary data <a id="id227" class="indexterm"/>too, and <a id="id228" class="indexterm"/>offer much <a id="id229" class="indexterm"/>greater functionality over the <code class="literal">File</code> class convenience functions. Here, you can write raw numerical data, and choose the byte order for multibyte data types.</p><p>Create a new console application in the Introjucer application and name it <code class="literal">Chapter04_02</code>. The following example writes <code class="literal">int</code>, <code class="literal">float</code>, and <code class="literal">double</code> data types to a file, and then reads this data back in, posting the result to the log. Replace the contents of <code class="literal">Main.cpp</code> file with the following code:</p><div class="informalexample"><pre class="programlisting">#include "../JuceLibraryCode/JuceHeader.h"

void writeFile (File const&amp; file);
void readFile (File const&amp; file);

int main (int argc, char* argv[])
{
  File file (File::getSpecialLocation(File::currentExecutableFile)
             .getParentDirectory()
             .getChildFile ("chapter04_02_test.bin"));
  
  writeFile (file);
  readFile (file);
  
  return 0;
}

void writeFile (File const&amp; file)
{
  Logger *log = Logger::getCurrentLogger();
  FileOutputStream stream (file);
  
  if (!stream.openedOk()) {
    log-&gt;writeToLog ("failed to open stream");
    return;
  }
  
  stream.setPosition (0);
  stream.truncate();
  stream.writeInt (1234);
  stream.writeFloat (3.142);
  stream.writeDouble (0.000000001);
}

void readFile (File const&amp; file)
{
  Logger *log = Logger::getCurrentLogger();
  FileInputStream stream (file);
  
  if (!stream.openedOk()) {
    log-&gt;writeToLog ("failed to open stream");
    return;
  }
  
  log-&gt;writeToLog("readInt: " + String (stream.readInt()));
  log-&gt;writeToLog("readFloat: " + String (stream.readFloat()));
  log-&gt;writeToLog("readDouble: " + String (stream.readDouble()));
}</pre></div><p>The <code class="literal">OutputStream</code> and <code class="literal">InputStream</code> classes and their respective subclasses, support writing and reading the various built-in types using functions <a id="id230" class="indexterm"/>
<code class="literal">writeInt()</code>,<a id="id231" class="indexterm"/>
<code class="literal">writeFloat()</code>,<a id="id232" class="indexterm"/>
<code class="literal">readInt()</code>, <a id="id233" class="indexterm"/>
<code class="literal">readFloat()</code>, and so on. These versions of the functions write these multi-byte types using little endian byte order. For file formats requiring big endian storage, there are equivalent functions <a id="id234" class="indexterm"/>
<code class="literal">writeIntBigEndian()</code>, <a id="id235" class="indexterm"/>
<code class="literal">writeFloatBigEndian()</code>, <code class="literal">readIntBigEndian</code>
<a id="id236" class="indexterm"/>
<code class="literal">()</code>, <code class="literal">readFloatBigEndian()</code>
<a id="id237" class="indexterm"/>, and so on.</p><p>The <a id="id238" class="indexterm"/>JUCE stream <a id="id239" class="indexterm"/>classes are <a id="id240" class="indexterm"/>useful but quite low level. For many purposes, JUCE already includes high-level classes for reading and writing specific <a id="id241" class="indexterm"/>file types. Of course, these are built on top of the stream classes, but, unless you are dealing with a custom data format, it is likely to be more sensible to use built-in functionality for handling things such as images, audio, and other formats such as <span class="strong"><strong>Extensible Markup Language</strong></span> (<span class="strong"><strong>XML</strong></span>) and <span class="strong"><strong>JavaScript Object Notation</strong></span> (<span class="strong"><strong>JSON</strong></span>).</p></div></div></div>
<div class="section" title="Reading and writing image files"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Reading and writing image files</h1></div></div></div><p>JUCE includes <a id="id242" class="indexterm"/>built-in support for reading and writing GIF, PNG, and JPEG image files. JUCE also includes its own <code class="literal">Image</code> class for holding bitmap <a id="id243" class="indexterm"/>images. The following example illustrates <a id="id244" class="indexterm"/>how to present a native file browser to choose an image file,<a id="id245" class="indexterm"/> load the image file, and display it in an <code class="literal">ImageComponent</code> object. Create a new GUI project in the Introjucer application with a basic window named <code class="literal">Chapter04_03</code>. and make the window resizable in the <code class="literal">Main.cpp</code> file, as we did in earlier chapters. You should then change the <code class="literal">MainComponent.h</code> file to contain:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component,
                             public Button::Listener
{
public:
  MainContentComponent();
  void resized();
  void buttonClicked (Button* button);
  
private:
  TextButton readFileButton;
  ImageComponent imageComponent;
  Image image;
};
#endif</pre></div><p>Change <code class="literal">MainComponent.cpp</code> to contain:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: readFileButton ("Read Image File...")
{
  addAndMakeVisible (&amp;readFileButton);
  addAndMakeVisible (&amp;imageComponent);
  
  readFileButton.addListener (this);
 
  setSize (500, 400);
}

void MainContentComponent::resized()
{
  int buttonHeight = 20;
  int margin = 10;
  readFileButton.setBounds(margin, margin,
                           getWidth() – margin * 2, buttonHeight);
  imageComponent.setBounds(margin, margin + buttonHeight + margin,
                           getWidth() – margin * 2,
                           getHeight() – buttonHeight – margin * 3);
}

void MainContentComponent::buttonClicked (Button* button)
{
  if (&amp;readFileButton == button)
  {
    FileChooser chooser ("Choose an image file to display...");
    
    if (chooser.browseForFileToOpen()) {
      image = ImageFileFormat::loadFrom (chooser.getResult());
      
      if (image.isValid())
        imageComponent.setImage (image);
    }
  }
}</pre></div><p>Here, we create a <code class="literal">FileChooser</code> object in response to the user clicking on the <span class="strong"><strong>Read Image File…</strong></span> button. This presents a native dialog window that allows the user to choose a file. We <a id="id246" class="indexterm"/>use the <code class="literal">ImageFileFormat::loadFrom()</code> function<a id="id247" class="indexterm"/> to attempt to load the file as an image. Because we didn't limit the <a id="id248" class="indexterm"/>file types displayed or enabled in the file chooser, the user may not have chosen a valid image file. We check the validity of the image, and if it is valid we pass the loaded image to the <code class="literal">ImageComponent</code> object for display. The <code class="literal">ImageComponent</code> class has various options to control the way the image is positioned and scaled, depending on how the original image size and component rectangle compare. These can be controlled using the <a id="id249" class="indexterm"/>
<code class="literal">ImageComponent::setImagePlacement()</code> function. The following screenshot shows the application that reads an image file:</p><div class="mediaobject"><img src="graphics/3316_04_01.jpg" alt="Reading and writing image files"/></div><p>The <code class="literal">Image</code> class is similar to the <code class="literal">String</code> class, in that it uses a reference-counted object internally such that several <code class="literal">Image</code> objects may share the same internal data.</p><div class="section" title="Manipulating image data"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Manipulating image data</h2></div></div></div><p>In the <a id="id250" class="indexterm"/>next example we will add a slider to control the <a id="id251" class="indexterm"/>brightness of the displayed image and a button to write this processed image as a PNG file. Change the contents of the <code class="literal">MainComponent.h</code> file, where the changes are highlighted in the following code listing:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component,
                             public Button::Listener<span class="strong"><strong>,</strong></span>
<span class="strong"><strong>                             public Slider::Listener</strong></span>
{
  public:
    MainContentComponent();
    void resized();
    void buttonClicked (Button* button);
<span class="strong"><strong>    void sliderValueChanged (Slider* slider);</strong></span>
  private:
    TextButton readFileButton;
    ImageComponent imageComponent;
<span class="strong"><strong>    Slider brightnessSlider;</strong></span>
<span class="strong"><strong>    TextButton writeFileButton;</strong></span>
<span class="strong"><strong>    Image origImage, procImage;</strong></span>
};
#endif</pre></div><p>Now<a id="id252" class="indexterm"/> replace the <code class="literal">MainComponent.cpp</code> file with the include directive and the constructor:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: readFileButton ("Read Image File..."),
  writeFileButton ("Write Image File...")
{
  brightnessSlider.setRange (0.0, 10.0);
  addAndMakeVisible (&amp;readFileButton);
  addAndMakeVisible (&amp;imageComponent);
  addAndMakeVisible (&amp;brightnessSlider);
  addAndMakeVisible (&amp;writeFileButton);
  
  readFileButton.addListener (this);
  writeFileButton.addListener (this);
  brightnessSlider.addListener (this);
  
  setSize (500, 400);
}</pre></div><p>Add the <code class="literal">resized()</code> function that positions the components:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::resized()
{
  int controlHeight = 20;
  int margin = 10;
  int width = getWidth() - margin * 2;

  readFileButton.setBounds
    (margin, margin, width, controlHeight);
  imageComponent.setBounds
    (margin, readFileButton.getBottom() + margin, width,
     getHeight() - (controlHeight + margin) * 3 - margin * 2);
  brightnessSlider.setBounds
    (margin, imageComponent.getBottom() + margin, 
     width, controlHeight);
  writeFileButton.setBounds
    (margin, brightnessSlider.getBottom() + margin,
     width, controlHeight);
}</pre></div><p>Add <a id="id253" class="indexterm"/>the <code class="literal">buttonClicked()</code> function<a id="id254" class="indexterm"/> that responds to the button interactions:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::buttonClicked (Button* button)
{
  if (&amp;readFileButton == button) {
    FileChooser chooser ("Choose an image file to display...");
    
    if (chooser.browseForFileToOpen()) {
      origImage = ImageFileFormat::loadFrom (chooser.getResult());
      
      if (origImage.isValid()) {
        procImage = origImage.createCopy();
        imageComponent.setImage (procImage);
      }
    }
  } else if (&amp;writeFileButton == button) {
    if (procImage.isValid()) {
      FileChooser chooser ("Write processed image to file...");
      
      if (chooser.browseForFileToSave (true)) {
        FileOutputStream stream (chooser.getResult());
        PNGImageFormat pngImageFormat;
        pngImageFormat.writeImageToStream (procImage, stream);
      }
    }
  }
}</pre></div><p>Finally, add the <code class="literal">sliderValueChanged()</code> function<a id="id255" class="indexterm"/> that responds to the slider interaction:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::sliderValueChanged (Slider* slider)
{
  if (&amp;brightnessSlider == slider) {
    if (origImage.isValid() &amp;&amp;
        procImage.isValid()) {
      const float amount = (float)brightnessSlider.getValue();

      if (amount == 0.f) {
        procImage = origImage.createCopy();
      } else {
        for (int v = 0; v &lt; origImage.getHeight(); ++v) {
          for (int h = 0; h &lt; origImage.getWidth(); ++h) {
            Colour col = origImage.getPixelAt (h, v);
            
            if (amount &gt; 0.f)
              procImage.setPixelAt (h, v, col.brighter (amount));
            else if (amount &lt; 0.f)
              procImage.setPixelAt (h, v, col.darker (-amount));
          }
        }
      }
                                      
      imageComponent.repaint();
    }
  }
}</pre></div><p>Here, we <a id="id256" class="indexterm"/>keep a copy of the original image and a processed version. Each time the slider changes, the image is updated with the new brightness by iterating over each of the pixels. When the <span class="strong"><strong>Write Image File…</strong></span> button is clicked, we create a <code class="literal">FileChooser</code> object and present this to the user with the <code class="literal">FileChooser::browseForFileToSave()</code> function,<a id="id257" class="indexterm"/> rather than the <code class="literal">FileChooser::browseForFileToOpen()</code> function<a id="id258" class="indexterm"/> as we did for reading the file. Then the <code class="literal">PNGImageFormat</code> class is used to write the processed image to the selected file as a file stream. The image processing here could be significantly optimized, but that is beyond the scope of this book.</p></div></div>
<div class="section" title="Playing audio files"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Playing audio files</h1></div></div></div><p>JUCE provides<a id="id259" class="indexterm"/> a sophisticated set of classes for dealing with audio. This includes: sound file reading and writing utilities, interfacing with the native<a id="id260" class="indexterm"/> audio hardware, audio data conversion functions, and a cross-platform framework for creating audio plugins for a range of well-known host applications. Covering all of these aspects is beyond the scope of this book, but the examples in this section will outline the principles of playing sound files and communicating with the audio hardware. In addition to showing the audio features of JUCE, in this section we will also create the GUI and autogenerate some other aspects of the code using the Introjucer application.</p><div class="section" title="Creating a GUI to control audio file play"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Creating a GUI to control audio file play</h2></div></div></div><p>Create a <a id="id261" class="indexterm"/>new GUI application Introjucer project named <code class="literal">Chapter04_04</code>, selecting the option to create a basic window. In<a id="id262" class="indexterm"/> the Introjucer application, select the <span class="strong"><strong>Config</strong></span> panel, and select <span class="strong"><strong>Modules</strong></span> in the hierarchy.</p><p>For this project we need the <code class="literal">juce_audio_utils</code> module (which contains a special <code class="literal">Component</code> class for configuring the audio device hardware); therefore, turn <code class="literal">ON</code> this module. Even though we created a basic window and a basic component, we are going to create the GUI using the Introjucer application in a similar way to that at the end of <a class="link" href="ch02.html" title="Chapter 2. Building User Interfaces">Chapter 2</a>, <span class="emphasis"><em>Building User Interfaces</em></span>.</p><p>Navigate to the <span class="strong"><strong>Files</strong></span> panel and right-click (on the Mac, press <span class="emphasis"><em>control</em></span> and click) on the <span class="strong"><strong>Source</strong></span> folder in the hierarchy, and select <span class="strong"><strong>Add New GUI Component…</strong></span> from the contextual menu.</p><p>When asked, name the header <code class="literal">MediaPlayer.h</code> and click on <span class="strong"><strong>Save</strong></span>. In the <span class="strong"><strong>Files</strong></span> hierarchy, select the <code class="literal">MediaPlayer.cpp</code> file. First select the <span class="strong"><strong>Class</strong></span> panel and change the <span class="strong"><strong>Class name</strong></span> from <code class="literal">NewComponent</code> to <code class="literal">MediaPlayer</code>. We will need four buttons for this basic project: a button to open an audio file, a <span class="strong"><strong>Play</strong></span> button, a <span class="strong"><strong>Stop</strong></span> button, and an audio device settings button. Select the <span class="strong"><strong>Subcomponents</strong></span> panel, and add four <code class="literal">TextButton</code> components to the editor by right-clicking to access the contextual menu. Space the buttons equally near the top of the editor, and configure each button as outlined in the table as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th><th style="text-align: left" valign="bottom">
<p>member name</p>
</th><th style="text-align: left" valign="bottom">
<p>name</p>
</th><th style="text-align: left" valign="bottom">
<p>text</p>
</th><th style="text-align: left" valign="bottom">
<p>background (normal)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Open file</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">openButton</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">open</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Open…</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Default</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Play/pause file</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">playButton</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">play</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Play</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Green</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Stop playback</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">stopButton</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">stop</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Stop</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Configure audio</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">settingsButton</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">settings</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Audio Settings…</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Default</p>
</td></tr></tbody></table></div><p>Arrange the buttons as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3316_04_02.jpg" alt="Creating a GUI to control audio file play"/></div><p>For each button, access the <span class="strong"><strong>mode</strong></span> pop-up menu for the <span class="strong"><strong>width</strong></span> setting, and choose <span class="strong"><strong>Subtracted from width of parent</strong></span>. This will keep the right-hand side of the buttons the same distance <a id="id263" class="indexterm"/>from the right-hand side of the window if the <a id="id264" class="indexterm"/>window is resized. There are more customizations to be done in the Introjucer project, but for now, make sure that you have saved the <code class="literal">MediaPlayer.h</code> file, the <code class="literal">MediaPlayer.cpp </code>file, and the Introjucer project before you open your native IDE project.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Make sure that you have saved all of these files in the Introjucer application; otherwise the files may not get correctly updated in the file system when the project is opened in the IDE.</p></div></div><p>In the IDE we need to replace the <code class="literal">MainContentComponent</code> class code to place a <code class="literal">MediaPlayer</code> object within it. Change the <code class="literal">MainComponent.h</code> file as follows:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"
<span class="strong"><strong>#include "MediaPlayer.h"</strong></span>

class MainContentComponent   : public Component
{
public:
  MainContentComponent();
  void resized();
  
<span class="strong"><strong>private:</strong></span>
<span class="strong"><strong>  MediaPlayer player;</strong></span>
};
#endif</pre></div><p>Then, change the <code class="literal">MainComponent.cpp</code> file to:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  addAndMakeVisible (&amp;player);
  setSize (player.getWidth(),player.getHeight());
}

void MainContentComponent::resized()
{
  player.setBounds (0, 0, getWidth(), getHeight());
}</pre></div><p>Finally, make the window resizable in the <code class="literal">Main.cpp</code> file (as we did in the <span class="emphasis"><em>Adding child components</em></span> section of <a class="link" href="ch02.html" title="Chapter 2. Building User Interfaces">Chapter 2</a>, <span class="emphasis"><em>Building User Interfaces</em></span>), and build and run the project to check that the window appears as expected.</p></div><div class="section" title="Adding audio file playback support"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Adding audio file playback support</h2></div></div></div><p>Quit the<a id="id265" class="indexterm"/> application and return to the <code class="literal">Introjucer</code> project. Select the <code class="literal">MediaPlayer.cpp</code> file in the <span class="strong"><strong>Files</strong></span> panel hierarchy and select its <span class="strong"><strong>Class</strong></span> panel. The <span class="strong"><strong>Parent classes</strong></span> setting already contains <code class="literal">public Component</code>. We are going to be listening for state changes from two of our member objects that are <code class="literal">ChangeBroadcaster</code> objects. To do this, we need our <code class="literal">MediaPlayer</code> class to inherit from the <code class="literal">ChangeListener</code> class. Change the <span class="strong"><strong>Parent classes</strong></span> setting such that it reads:</p><div class="informalexample"><pre class="programlisting">public Component, public ChangeListener</pre></div><p>Save the <code class="literal">MediaPlayer.h</code> file, the <code class="literal">MediaPlayer.cpp</code> file, and the <code class="literal">Introjucer</code> project again, and open it into your IDE. Notice in the <code class="literal">MediaPlayer.h</code> file that the parent classes have been updated to reflect this change. For convenience, we are going to add some enumerated constants to reflect the current playback state of our <code class="literal">MediaPlayer</code> object, and a function to centralize the change of this state (which will, in turn, update the state of various objects, such as the text displayed on the buttons). The <code class="literal">ChangeListener</code> class also has one pure virtual function, which we need to add. Add the following code to the <code class="literal">[UserMethods]</code> section of <code class="literal">MediaPlayer.h</code>:</p><div class="informalexample"><pre class="programlisting">//[UserMethods]-- You can add your own custom methods...
enum TransportState {
  Stopped,
  Starting,
  Playing,
  Pausing,
  Paused,
  Stopping
};
void changeState (TransportState newState);
void changeListenerCallback (ChangeBroadcaster* source); 
//[/UserMethods]</pre></div><p>We also need <a id="id266" class="indexterm"/>some additional member variables to support our audio playback. Add these to the <code class="literal">[UserVariables]</code> section:</p><div class="informalexample"><pre class="programlisting">//[UserVariables]   -- You can add your own custom variables...
AudioDeviceManager deviceManager;
AudioFormatManager formatManager;
ScopedPointer&lt;AudioFormatReaderSource&gt; readerSource;
AudioTransportSource transportSource;
AudioSourcePlayer sourcePlayer;
TransportState state;
 //[/UserVariables]</pre></div><p>The <code class="literal">AudioDeviceManager</code> object<a id="id267" class="indexterm"/> will manage our interface between the application and the audio hardware. The <code class="literal">AudioFormatManager</code> object will assist in creating an object that will read and decode the audio data from an audio file. This object will be stored in the <code class="literal">ScopedPointer&lt;AudioFormatReaderSource&gt;</code> object. The <code class="literal">AudioTransportSource</code> object will control the playback of the audio file and perform any sampling rate conversion that may be required (if the sampling rate of the audio file differs from the audio hardware sampling rate). The <code class="literal">AudioSourcePlayer</code> object will stream audio from the <code class="literal">AudioTransportSource</code> object to the <code class="literal">AudioDeviceManager</code> object. The <code class="literal">state</code> variable will store one of our enumerated constants to reflect the current playback state of our <code class="literal">MediaPlayer</code> object.</p><p>Now add some code to the <code class="literal">MediaPlayer.cpp</code> file. In the <code class="literal">[Constructor]</code> section of the constructor, add following two lines:</p><div class="informalexample"><pre class="programlisting">playButton-&gt;setEnabled (false);
stopButton-&gt;setEnabled (false);</pre></div><p>This sets the <span class="strong"><strong>Play</strong></span> and <span class="strong"><strong>Stop</strong></span> buttons to be disabled (and grayed out) initially. Later, we enable the <span class="strong"><strong>Play</strong></span> button once a valid file is loaded, and change the state of each button and the text displayed on the buttons, depending on whether the file is currently playing or not. In this <code class="literal">[Constructor]</code> section you should also initialize the <code class="literal">AudioFormatManager</code> as follows:</p><div class="informalexample"><pre class="programlisting">formatManager.registerBasicFormats();</pre></div><p>This allows the <code class="literal">AudioFormatManager</code> object to detect different audio file formats and create appropriate file reader objects. We also need to connect the <code class="literal">AudioSourcePlayer</code>, <code class="literal">AudioTransportSource</code> and <code class="literal">AudioDeviceManager</code> objects together, and initialize the <code class="literal">AudioDeviceManager</code> object. To do this, add the following lines to the <code class="literal">[Constructor]</code> section:</p><div class="informalexample"><pre class="programlisting">sourcePlayer.setSource (&amp;transportSource);
deviceManager.addAudioCallback (&amp;sourcePlayer);
deviceManager.initialise (0, 2, nullptr, true);</pre></div><p>The first line<a id="id268" class="indexterm"/> connects the <code class="literal">AudioTransportSource</code> object to the <code class="literal">AudioSourcePlayer</code> object. The second line connects the <code class="literal">AudioSourcePlayer</code> object to the <code class="literal">AudioDeviceManager</code> object. The final line initializes the <code class="literal">AudioDeviceManager</code> object with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number of required audio input channels (<code class="literal">0</code> in this case).</li><li class="listitem" style="list-style-type: disc">The number of required audio output channels (<code class="literal">2</code> in this case, for stereo output).</li><li class="listitem" style="list-style-type: disc">An optional "saved state" for the <code class="literal">AudioDeviceManager</code> object (<code class="literal">nullptr</code> initializes from scratch).</li><li class="listitem" style="list-style-type: disc">Whether to open the default device if the saved state fails to open. As we are not using a saved state, this argument is irrelevant, but it is useful to set this to <code class="literal">true</code> in any case.</li></ul></div><p>The final three lines to add to the <code class="literal">[Constructor]</code> section to configure our <code class="literal">MediaPlayer</code> object as a listener to the <code class="literal">AudioDeviceManager</code> and <code class="literal">AudioTransportSource</code> objects, and sets the current state to <code class="literal">Stopped</code>:</p><div class="informalexample"><pre class="programlisting">deviceManager.addChangeListener (this);
transportSource.addChangeListener (this); 
state = Stopped;</pre></div><p>In the <code class="literal">buttonClicked()</code> function we need to add some code to the various sections. In the <code class="literal">[UserButtonCode_openButton]</code> section, add:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_openButton] -- add your button handler...
FileChooser chooser ("Select a Wave file to play...",
                     File::nonexistent,
                     "*.wav");

if (chooser.browseForFileToOpen()) {
  File file (chooser.getResult());
  readerSource = new AudioFormatReaderSource(formatManager.createReaderFor (file), true);
  transportSource.setSource (readerSource);
  playButton-&gt;setEnabled (true);
} 
//[/UserButtonCode_openButton]</pre></div><p>When the <code class="literal">openButton</code> button is clicked, this will create a <code class="literal">FileChooser</code> object that allows the user to select a file using the native interface for the platform. The types of files that are allowed to be selected are limited using the wildcard <code class="literal">*.wav</code> to allow only files with the <code class="literal">.wav</code> file extension to be selected.</p><p>If the user actually <a id="id269" class="indexterm"/>selects a file (rather than cancels the operation), the code can call the <code class="literal">FileChooser::getResult()</code> function to retrieve a reference to the file that was selected. This file is then passed to the <code class="literal">AudioFormatManager</code> object to create a file reader object, which in turn is passed to create an <code class="literal">AudioFormatReaderSource</code> object that will manage and own this file reader object. Finally, the <code class="literal">AudioFormatReaderSource</code> object is connected to the <code class="literal">AudioTransportSource</code> object and the <span class="strong"><strong>Play</strong></span> button is enabled.</p><p>The handlers for the <code class="literal">playButton</code> and <code class="literal">stopButton</code> objects will make a call to our <code class="literal">changeState()</code> function depending on the current transport state. We will define the <code class="literal">changeState()</code> function in a moment where its purpose should become clear.</p><p>In the <code class="literal">[UserButtonCode_playButton]</code> section, add the following code:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_playButton] -- add your button handler...
if ((Stopped == state) || (Paused == state))
  changeState (Starting);
else if (Playing == state)
  changeState (Pausing); 
//[/UserButtonCode_playButton]</pre></div><p>This changes the state to <code class="literal">Starting</code> if the current state is either <code class="literal">Stopped</code> or <code class="literal">Paused</code>, and changes the state to <code class="literal">Pausing</code> if the current state is <code class="literal">Playing</code>. This is in order to have a button with combined play and pause functionality.</p><p>In the <code class="literal">[UserButtonCode_stopButton]</code> section, add the following code:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_stopButton] -- add your button handler...
if (Paused == state)
  changeState (Stopped);
else
  changeState (Stopping); 
//[/UserButtonCode_stopButton]</pre></div><p>This sets the state to <code class="literal">Stopped</code> if the current state is <code class="literal">Paused</code>, and sets it to <code class="literal">Stopping</code> in other cases. Again, we will add the <code class="literal">changeState()</code> function in a moment, where these state changes update various objects.</p><p>In the <code class="literal">[UserButtonCode_settingsButton]</code> section add the following code:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_settingsButton] -- add your button handler...
bool showMidiInputOptions = false;
bool showMidiOutputSelector = false;
bool showChannelsAsStereoPairs = true;
bool hideAdvancedOptions = false;

AudioDeviceSelectorComponent settings (deviceManager,
                                       0, 0, 1, 2,
                                       showMidiInputOptions,
                                       showMidiOutputSelector,
                                       showChannelsAsStereoPairs,
                                       hideAdvancedOptions);
settings.setSize (500, 400);

DialogWindow::showModalDialog(String ("Audio Settings"),
                            &amp;settings,
                            TopLevelWindow::getTopLevelWindow (0),
                            Colours::white,
                            true); //[/UserButtonCode_settingsButton]</pre></div><p>This <a id="id270" class="indexterm"/>presents a useful interface to configure the audio device settings.</p><p>We need to add the <code class="literal">changeListenerCallback()</code> function to respond to changes in the <code class="literal">AudioDeviceManager</code> and <code class="literal">AudioTransportSource</code> objects. Add the following to the <code class="literal">[MiscUserCode]</code> section of the <code class="literal">MediaPlayer.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">//[MiscUserCode] You can add your own definitions...
void MediaPlayer::changeListenerCallback (ChangeBroadcaster* src)
{
  if (&amp;deviceManager == src) {
    AudioDeviceManager::AudioDeviceSetup setup;
    deviceManager.getAudioDeviceSetup (setup);

    if (setup.outputChannels.isZero())
      sourcePlayer.setSource (nullptr);
    else
      sourcePlayer.setSource (&amp;transportSource);
  } else if (&amp;transportSource == src) {
    if (transportSource.isPlaying()) {
      changeState (Playing);
    } else {
      if ((Stopping == state) || (Playing == state))
        changeState (Stopped);
      else if (Pausing == state)
        changeState (Paused);
    }
  }
} 
//[/MiscUserCode]</pre></div><p>If our <code class="literal">MediaPlayer</code> object receives a message that the <code class="literal">AudioDeviceManager</code> object changed<a id="id271" class="indexterm"/> in some way, we need to check that this change wasn't to disable all of the audio output channels, by obtaining the setup information from the device manager. If the number of output channels is zero, we disconnect our <code class="literal">AudioSourcePlayer</code> object from the <code class="literal">AudioTransportSource</code> object (otherwise our application may crash) by setting the source to <code class="literal">nullptr</code>. If the number of output channels becomes nonzero again, we reconnect these objects.</p><p>If our <code class="literal">AudioTransportSource</code> object<a id="id272" class="indexterm"/> has changed, this is likely to be a change in its playback state. It is important to note the difference between requesting the transport to start or stop, and this change actually taking place. This is why we created the enumerated constants for all the other states (including transitional states). Again we issue calls to the <code class="literal">changeState()</code> function depending on the current value of our <code class="literal">state</code> variable and the state of the <code class="literal">AudioTransportSource</code> object.</p><p>Finally, add the important <code class="literal">changeState()</code> function<a id="id273" class="indexterm"/> to the <code class="literal">[MiscUserCode]</code> section of the <code class="literal">MediaPlayer.cpp</code> file that handles all of these state changes:</p><div class="informalexample"><pre class="programlisting">void MediaPlayer::changeState (TransportState newState)
{
  if (state != newState) {
    state = newState;
    switch (state) {
      case Stopped:
        playButton-&gt;setButtonText ("Play");
        stopButton-&gt;setButtonText ("Stop");
        stopButton-&gt;setEnabled (false);
        transportSource.setPosition (0.0);
        break;
      case Starting:
        transportSource.start();
        break;
      case Playing:
        playButton-&gt;setButtonText ("Pause");
        stopButton-&gt;setButtonText ("Stop");
        stopButton-&gt;setEnabled (true);
        break;
      case Pausing:
        transportSource.stop();
        break;
      case Paused:
        playButton-&gt;setButtonText ("Resume");
        stopButton-&gt;setButtonText ("Return to Zero");
        break;
      case Stopping:
        transportSource.stop();
        break;
    }
  }
}</pre></div><p>After checking that the <code class="literal">newState</code> value is different from the current value of the <code class="literal">state</code> variable, we <a id="id274" class="indexterm"/>update the <code class="literal">state</code> variable with the new value. Then, we perform the appropriate actions for this particular point in the cycle of state changes. These are summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">Stopped</code> state, the buttons are configured with the <span class="strong"><strong>Play</strong></span> and <span class="strong"><strong>Stop</strong></span> labels, the <span class="strong"><strong>Stop</strong></span> button is disabled, and the transport is positioned to the start of the audio file.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">Starting</code> state, the <code class="literal">AudioTransportSource</code> object is told to start. Once the <code class="literal">AudioTransportSource</code> object has actually started playing, the system will be in the <code class="literal">Playing</code> state. Here we update the <code class="literal">playButton</code> button to display the text <span class="strong"><strong>Pause</strong></span>, ensure the <code class="literal">stopButton</code> button displays the text <span class="strong"><strong>Stop</strong></span>, and we enable the <span class="strong"><strong>Stop</strong></span> button.</li><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>Pause</strong></span> button is clicked, the state becomes <code class="literal">Pausing</code>, and the transport is told to stop. Once the transport has actually stopped, the state changes to <code class="literal">Paused</code>, the <code class="literal">playButton</code> button is updated to display the text <span class="strong"><strong>Resume</strong></span> and the <code class="literal">stopButton</code> button is updated to display <span class="strong"><strong>Return to Zero</strong></span>.</li><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>Stop</strong></span> button is clicked, the state is changed to <code class="literal">Stopping</code>, and the transport is told to stop. Once the transport has actually stopped, the state changes to <code class="literal">Stopped</code> (as described in the first point).</li><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>Return to Zero</strong></span> button is clicked, the state is changed directly to <code class="literal">Stopped</code> (again, as previously described).</li><li class="listitem" style="list-style-type: disc">When the audio file reaches the end of the file, the state is also changed to <code class="literal">Stopped</code>.</li></ul></div><p>Build and run the application. You should be able to select a <code class="literal">.wav</code> audio file after clicking the <span class="strong"><strong>Open...</strong></span> button, play, pause, resume, and stop the audio file using the respective buttons, and configure the audio device using the <span class="strong"><strong>Audio Settings… </strong></span>button. The audio settings window allows you to select the input and output device, the sample rate, and the hardware buffer size. It also provides a <span class="strong"><strong>Test</strong></span> button that plays a tone through the selected output device.</p></div></div>
<div class="section" title="Working with the Binary Builder tool"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Working with the Binary Builder tool</h1></div></div></div><p>One<a id="id275" class="indexterm"/> problem with writing cross-platform applications is the packaging of binary files for use within the application. JUCE includes the <span class="strong"><strong>Binary Builder</strong></span> tool that transforms binary files into source code, which is then compiled into the application's code. This ensures that the files will behave identically on all platforms, rather than relying on peculiarities of the runtime machine. Although the Binary Builder is available as a separate project (in <code class="literal">juce/extras/binarybuilder</code>), its functionality is available within the Introjucer application's GUI component editor.</p><div class="section" title="Embedding an image file using the Introjucer application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Embedding an image file using the Introjucer application</h2></div></div></div><p>Create<a id="id276" class="indexterm"/> a new Introjucer project named <code class="literal">Chapter04_05</code> with a basic window. Add a new GUI component as before; this time name it <code class="literal">EmbeddedImage</code> (remembering to also change the name in its <span class="strong"><strong>Class</strong></span> panel). In its <span class="strong"><strong>Subcomponents</strong></span> panel, right-click in the canvas and choose <span class="strong"><strong>New Generic Component</strong></span> and resize it to fill the canvas with a small border around the edge. Change the <span class="strong"><strong>member name</strong></span> and <span class="strong"><strong>name</strong></span> to <code class="literal">image</code>, and change the <span class="strong"><strong>class</strong></span> to <code class="literal">ImageComponent</code>. In the <span class="strong"><strong>Resources</strong></span> panel, choose <span class="strong"><strong>Add new resource…</strong></span> and select an image file to add. This will create a resource that is the binary file converted to code. It will be given a variable name within this component based on the original filename, and will be stored as a static variable. For example, a file named <code class="literal">sample.png</code> will be named <code class="literal">sample_png</code>. In addition to this a static variable storing this resource's size as an integer will be created and will have <code class="literal">Size</code> appended to this name, for example, <code class="literal">sample_pngSize</code>. Save the project and open it into your IDE. Update the <code class="literal">MainComponent</code> file's contents as before. Change the <code class="literal">MainComponent.h</code> file as follows:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"
<span class="strong"><strong>#include "EmbeddedImage.h"</strong></span>

class MainContentComponent   : public Component
{
public:
  MainContentComponent();
  void resized();
  
<span class="strong"><strong>private:</strong></span>
<span class="strong"><strong>  EmbeddedImage embeddedImage;</strong></span>
};
#endif</pre></div><p>Then change the <code class="literal">MainComponent.cpp</code> file to:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  addAndMakeVisible (&amp;embeddedImage);
  setSize (embeddedImage.getWidth(),embeddedImage.getHeight());
}

void MainContentComponent::resized()
{
  embeddedImage.setBounds (0, 0, getWidth(), getHeight());
}</pre></div><p>Finally in<a id="id277" class="indexterm"/> the <code class="literal">EmbeddedImage.cpp</code> file notice the large arrays of numbers at the end of the file, this is the image file converted to code. In the <code class="literal">[Constructor]</code> section, add the following two lines (although you may need to use different names from <code class="literal">sample_png</code>, <code class="literal">sample_pngSize</code>, depending on the file resource you added previously):</p><div class="informalexample"><pre class="programlisting">//[Constructor] You can add your own custom stuff here...
MemoryInputStream stream (sample_png, sample_pngSize, false);
image-&gt;setImage (ImageFileFormat::loadFrom (stream));
//[/Constructor]</pre></div><p>This creates a memory stream from our resource, providing the data pointer and the data size (the final <code class="literal">false</code> argument tells the memory stream not to copy the data). Then we load the image as before using the <code class="literal">ImageFileFormat</code> class. Build and run the application, and the image should be displayed into the application's window.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Summary</h1></div></div></div><p>This chapter has covered a range of techniques for dealing with files in JUCE, focusing in particular on image and audio files. You are encouraged to explore the online JUCE documentation, which provides even more detail on many of the possibilities introduced here. We have also introduced the Binary Builder tool that provides a means of transforming media files into source code that is suitable for cross-platform use. You are encouraged to read the online JUCE documentation for each of the classes introduced in this chapter. This chapter has given only an introduction to get you started; there are many other options and alternative approaches, which may suit different circumstances. The JUCE documentation will take you through each of these and point you to related classes and functions. The next chapter covers some useful utilities available within JUCE for creating cross-platform applications.</p></div></body></html>