<html><head></head><body>
<div class="book" title="Chapter&#xA0;5.&#xA0;Functions and Macros" id="10DJ41-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Functions and Macros</h1></div></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Functions and Macros" id="10DJ41-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Functions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec30" class="calibre1"/>Functions</h1></div></div></div><p class="calibre9">Some<a id="id160" class="calibre1"/> things needs to be repeated. Code is not one of them. A function is a bundle of code that can get called any number of times, as often you wish.</p><p class="calibre9">Analogies are good. Let's explore an analogy that deals with waiters, chefs, pizzas, and functions. In English, when we say a person has a function, we mean that the person performs some very specific (usually, very important) task. They can do this task again and again and whenever they are called upon to do so.</p><p class="calibre9">The following comic strip shows the interaction between a waiter (caller) and a chef (callee). The waiter wants food for his table, so he calls upon the chef to prepare the food required by the waiting table. </p><p class="calibre9">The chef prepares the food and then returns the result to the waiter.</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="Functions" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Here, the chef<a id="id161" class="calibre1"/> performs his function of cooking food. The chef accepted the parameters about what type of food to cook (three pepperoni pan pizzas). The chef then went away, did some work, and returned with three pizzas. Note that the waiter does not know and does not care about how the chef goes about cooking the pizzas. The chef abstracts away the process of cooking pizzas for the waiter, so cooking a pizza is just a simple, single-line command for the waiter. The waiter just wants his request to be completed and the pizzas returned to him.</p><p class="calibre9">When a function (chef) gets called with some arguments (types of pizzas to be prepared), the function performs some actions (preparing the pizzas) and optionally returns a result (the actual finished pizzas).</p></div></div>
<div class="book" title="An example of a &lt;cmath&gt; library function &#x2013; sqrt()" id="11C3M1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec31" class="calibre1"/>An example of a &lt;cmath&gt; library function – sqrt()</h1></div></div></div><p class="calibre9">Now, let's talk about<a id="id162" class="calibre1"/> a more practical example and relate it to the pizza example.</p><p class="calibre9">There is a function in the <code class="email">&lt;cmath&gt;</code> library called the<a id="id163" class="calibre1"/> <code class="email">sqrt()</code> function. Let<a id="id164" class="calibre1"/> me quickly illustrate its use, as shown in the following code:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
int main()
{
  double rootOf5 = sqrt( 5 ); // function call to the sqrt  function
  cout &lt;&lt; rootOf5  &lt;&lt; endl;
}</pre></div><p class="calibre9">So, <code class="email">sqrt()</code> can find the mathematical square root of any number given to it.</p><p class="calibre9">Do you know how to find the square root of a tough number such as 5? It's not simple. A clever soul sat down and wrote a function that can find the square roots of all types of numbers. Do you have to understand the math behind how the square root of 5 is found to use the <code class="email">sqrt(5)</code> function call? Heck, no! So, just as the waiter didn't have to understand how to cook a pizza in order to get a pizza as the result, the caller of a C++ library function does not have to fully understand how that library function works internally to use it effectively.</p><p class="calibre9">The following are the<a id="id165" class="calibre1"/> advantages of using functions:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Functions abstract away a complex task into a simple, callable routine. This makes the code required to <span class="strong"><em class="calibre10">cook a pizza</em></span>, for instance, just a single-line command for the caller (the caller is typically your program).</li><li class="listitem" value="2">Functions avoid the repetition of code where it is not necessary. Say we have 20 or so lines of code that can find the square root of a double value. We wrap these lines of code into a callable function; instead of repeatedly copying and pasting these 20 lines of code, we simply call the <code class="email">sqrt</code> function (with the number to root) function whenever we need a root.</li></ol><div class="calibre14"/></div><p class="calibre9">The following illustration shows the process of finding a square root:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="An example of a &lt;cmath&gt; library function – sqrt()" class="calibre11"/></div><p class="calibre12"> </p></div>

<div class="book" title="Writing our own functions"><div class="book" id="12AK82-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec32" class="calibre1"/>Writing our own functions</h1></div></div></div><p class="calibre9">Say, we want to<a id="id166" class="calibre1"/> write some code that prints out a strip of road, as shown here:</p><div class="note"><pre class="programlisting">cout &lt;&lt; "*   *" &lt;&lt; endl;
cout &lt;&lt; "* | *" &lt;&lt; endl;
cout &lt;&lt; "* | *" &lt;&lt; endl;
cout &lt;&lt; "*   *" &lt;&lt; endl;</pre></div><p class="calibre9">Now, say we want to print two strips of road, in a row, or three strips of road. Or, say we want to print any number of strips of road. We will have to repeat the four lines of code that produce the first strip of road once per strip of road we're trying to print.</p><p class="calibre9">What if we introduced our own C++ command that allowed us to print a strip of road on being called the command. Here's how that will look:</p><div class="note"><pre class="programlisting">void printRoad()
{
  cout &lt;&lt; "*   *" &lt;&lt; endl;
  cout &lt;&lt; "* | *" &lt;&lt; endl;
  cout &lt;&lt; "* | *" &lt;&lt; endl;
  cout &lt;&lt; "*   *" &lt;&lt; endl;
}</pre></div><p class="calibre9">This is the definition<a id="id167" class="calibre1"/> of a function. A C++ function has the following anatomy:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Writing our own functions" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Using a function is simple: we simply invoke the function we want to execute by name, followed by two round brackets<span class="strong"><em class="calibre10"> </em></span>(). For example, calling the<a id="id168" class="calibre1"/> <code class="email">printRoad()</code> function will cause the <code class="email">printRoad()</code> function to run. Let's trace an example program to fully understand what this means.</p></div>

<div class="book" title="Writing our own functions">
<div class="book" title="A sample program trace"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec46" class="calibre1"/>A sample program trace</h2></div></div></div><p class="calibre9">Here's a complete <a id="id169" class="calibre1"/>example of how a function call works:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
void printRoad()
{
  cout &lt;&lt; "*   *" &lt;&lt; endl;
  cout &lt;&lt; "* | *" &lt;&lt; endl;
  cout &lt;&lt; "* | *" &lt;&lt; endl;
  cout &lt;&lt; "*   *" &lt;&lt; endl;
}
int main()
{
  cout &lt;&lt; "Program begin!" &lt;&lt; endl;
  printRoad();
  cout &lt;&lt; "Program end" &lt;&lt; endl;
  return 0;
}</pre></div><p class="calibre9">Let's trace the program's execution from beginning to end. Remember that for all C++ programs, execution begins on the first line of <code class="email">main()</code>.</p><div class="note" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre9">
<code class="email">main()</code> is<a id="id170" class="calibre1"/> also a function. It oversees the execution of the whole program. Once <code class="email">main()</code> executes the <code class="email">return</code> statement, your program ends.</p></div><p class="calibre9">When the<a id="id171" class="calibre1"/> last line of the <code class="email">main()</code> function is reached, the program ends.</p><p class="calibre9">A line-by-line trace of the execution of the preceding program is shown as follows:</p><div class="note"><pre class="programlisting">void printRoad()
{
  cout &lt;&lt; "*   *" &lt;&lt; endl;          // 3: then we jump up here
  cout &lt;&lt; "* | *" &lt;&lt; endl;          // 4: run this
  cout &lt;&lt; "* | *" &lt;&lt; endl;          // 5: and this
  cout &lt;&lt; "*   *" &lt;&lt; endl;          // 6: and this
}
int main()
{
  cout &lt;&lt; "Program begin!" &lt;&lt; endl; // 1: first line to execute
  printRoad();                      // 2: second line..
  cout &lt;&lt; "Program end" &lt;&lt; endl;    // 7: finally, last line
  return 0;                         // 8: and return to o/s
}</pre></div><p class="calibre9">This is how the output of this program will look:</p><div class="note"><pre class="programlisting">Program begin!
*   *
* | *
* | *
*   *
Program end</pre></div><p class="calibre9">Here's an<a id="id172" class="calibre1"/> explanation of the preceding code, line by line:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The program's execution begins on the first line of <code class="email">main()</code>, which outputs <code class="email">program begin!.</code></li><li class="listitem" value="2">The next line of code that is run is the call to <code class="email">printRoad()</code>. What this does is it jumps the program counter to the first line of <code class="email">printRoad()</code>. All the lines of <code class="email">printRoad()</code> then execute in order (steps 3–6).</li><li class="listitem" value="3">Finally, after the function call to <code class="email">printRoad()</code> is complete, control returns to the <code class="email">main()</code> statement. We then see <code class="email">Program end</code> printed.</li></ol><div class="calibre14"/></div><div class="note" title="Note"><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre9">Don't forget the brackets after the function call to <code class="email">printRoad()</code>. A function call must always be followed by round brackets (), otherwise the function call will not work and you will get a compiler error.</p></div><p class="calibre9">The following code is used to print four strips of road:</p><div class="note"><pre class="programlisting">int main()
{
	printRoad();
	printRoad();
	printRoad();
	printRoad();
}</pre></div><p class="calibre9">Alternatively, you can also use the following code:</p><div class="note"><pre class="programlisting">for( int i = 0; i &lt; 4; i++ )
printRoad();</pre></div><p class="calibre9">So, instead of repeating the four lines of <code class="email">cout</code> every time a box is printed, we simply call the <code class="email">printRoad()</code> function to make it print. Also, if we want to change how a printed road looks, we have to simply modify the implementation of the <code class="email">printRoad()</code> function.</p><p class="calibre9">Calling a function entails running the entire body of that function, line by line. After the function call is complete, the control of the program then resumes at the point of the function call.</p></div></div>

<div class="book" title="Writing our own functions">
<div class="book" title="Exercise"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec47" class="calibre1"/>Exercise</h2></div></div></div><p class="calibre9">As an <a id="id173" class="calibre1"/>exercise, find out what is wrong with the following code:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
void myFunction()
{
   cout &lt;&lt; "You called?" &lt;&lt; endl;
}
int main()
{
   cout &lt;&lt; "I'm going to call myFunction now." &lt;&lt; endl;
   myFunction;
}</pre></div></div></div>

<div class="book" title="Writing our own functions">
<div class="book" title="Solution"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec48" class="calibre1"/>Solution</h2></div></div></div><p class="calibre9">The <a id="id174" class="calibre1"/>correct answer to this problem is that the call to <code class="email">myFunction</code> (in the last line of <code class="email">main()</code>) is not followed by round brackets. All function calls must be followed by round brackets. The last line of <code class="email">main()</code> should read <code class="email">myFunction();</code>, not just <code class="email">myFunction</code>.</p></div></div>
<div class="book" title="Functions with arguments" id="1394Q1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec33" class="calibre1"/>Functions with arguments</h1></div></div></div><p class="calibre9">How can <a id="id175" class="calibre1"/>we extend the <code class="email">printRoad()</code> function to print a road with a certain number of segments? The answer is simple. We can let the <code class="email">printRoad()</code> function accept a parameter, called <code class="email">numSegments</code>, to print a certain number of road segments.</p><p class="calibre9">The following code snippet shows how that will look:</p><div class="note"><pre class="programlisting">void printRoad(int numSegments)
{
  // use a for loop to print numSegments road segments
  for( int i = 0; i &lt; numSegments; i++)
  {
    cout &lt;&lt; "*   *" &lt;&lt; endl;
    cout &lt;&lt; "* | *" &lt;&lt; endl;
    cout &lt;&lt; "* | *" &lt;&lt; endl;
    cout &lt;&lt; "*   *" &lt;&lt; endl;
  }
}</pre></div><p class="calibre9">The following <a id="id176" class="calibre1"/>screenshot shows the anatomy of a function that accepts an argument:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Functions with arguments" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Call this new version of <code class="email">printRoad()</code>, asking it to print four segments, as follows:</p><div class="note"><pre class="programlisting">printRoad( 4 );    // function call</pre></div><p class="calibre9">The 4 between the brackets of the <code class="email">function call</code> in the preceding statement gets assigned to the <code class="email">numSegments</code> variable of the <code class="email">printRoad(int numSegments)</code> function. This is how the value 4 gets passed to <code class="email">numSegments</code>:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Functions with arguments" class="calibre11"/><div class="caption"><p class="calibre16">An illustration of how printRoad(4) will assign the value 4 to the numSegments variable</p></div></div><p class="calibre12"> </p><p class="calibre9">So, <code class="email">numSegments</code> gets assigned the value passed between the brackets in the call to <code class="email">printRoad()</code>.</p></div>

<div class="book" title="Functions that return values" id="147LC1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec34" class="calibre1"/>Functions that return values</h1></div></div></div><p class="calibre9">An example of a <a id="id177" class="calibre1"/>function that returns a value is the <code class="email">sqrt()</code> function. The <code class="email">sqrt()</code> function accepts a single parameter between its brackets (the number to root) and returns the actual root of the number.</p><p class="calibre9">Here's an example usage of the <code class="email">sqrt</code> function:</p><div class="note"><pre class="programlisting">cout &lt;&lt; sqrt( 4 ) &lt;&lt; endl;</pre></div><p class="calibre9">The <code class="email">sqrt()</code> function<a id="id178" class="calibre1"/> does something analogous to what the chef did when preparing the pizzas.</p><p class="calibre9">As a caller of the function, you do not care about what goes on inside the body of the <code class="email">sqrt()</code> function; that information is irrelevant since all you want is the result of the square root of the number that you are passing.</p><p class="calibre9">Let's declare our own simple function that returns a value, as shown in the following code:</p><div class="note"><pre class="programlisting">int sum(int a, int b)
{
  return a + b;
}</pre></div><p class="calibre9">The following screenshot shows the anatomy of a function with parameters and a returned value:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Functions that return values" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The <code class="email">sum</code> function <a id="id179" class="calibre1"/>is very basic. All it does is take two <code class="email">int</code> numbers <code class="email">a</code> and <code class="email">b</code>, sums them up together, and returns a result. You might say that we don't even need an entire function just to add two numbers. You're right, but bear with me for a moment. We will use this simple function to explain the concept of returned values.</p><p class="calibre9">You will use the <code class="email">sum</code> function in this way (from <code class="email">main()</code>):</p><div class="note"><pre class="programlisting">int sum( int a, int b )
{
  return a + b;
}
int main()
{
  cout &lt;&lt; "The sum of 5 and 6 is " &lt;&lt; sum( 5,6 ) &lt;&lt; endl; 
}</pre></div><p class="calibre9">For the <code class="email">cout</code> command to complete, the <code class="email">sum( 5,6 )</code> function call must be evaluated. At the point where the <code class="email">sum( 5,6 )</code> function call occurs, the returned value from <code class="email">sum( 5,6 )</code> is put right there.</p><p class="calibre9">In other words, this is the line of code that <code class="email">cout</code> actually sees after evaluating the <code class="email">sum( 5,6 )</code> function call:</p><div class="note"><pre class="programlisting">cout &lt;&lt; "The sum of 5 and 6 is " &lt;&lt; 11 &lt;&lt; endl;	</pre></div><p class="calibre9">The returned value from <code class="email">sum( 5,6 )</code> is effectively cut and pasted at the point of the function call.</p><p class="calibre9">A value must<a id="id180" class="calibre1"/> always be returned by a function that promises to do so (if the return type of the function is anything other than <code class="email">void</code>).</p></div>

<div class="book" title="Functions that return values" id="147LC1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Exercises"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec49" class="calibre1"/>Exercises</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Write <a id="id181" class="calibre1"/>an <code class="email">isPositive</code> function that returns <code class="email">true</code> when the double parameter passed to it is indeed positive.</li><li class="listitem" value="2">Complete the following function definition:<div class="note"><pre class="programlisting">// function returns true when the magnitude of 'a'
// is equal to the magnitude of 'b' (absolute value)
bool absEqual(int a, int b){
    // to complete this exercise, try to not use
    // cmath library functions
}</pre></div></li><li class="listitem" value="3">Write a <code class="email">getGrade()</code> function that accepts an integer value (marks out of 100) and returns the grade (either A, B, C, D, or F).</li><li class="listitem" value="4">A mathematical function is of the form <code class="email">f(x) = 3x + 4</code>. Write a C++ function that returns values for <code class="email">f(x)</code>.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Functions that return values" id="147LC1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Solutions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec50" class="calibre1"/>Solutions</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">isPositive</code> function<a id="id182" class="calibre1"/> accepts a double parameter and returns a boolean value:<div class="note"><pre class="programlisting">bool isPositive( double value )
{
  return value &gt; 0;
}</pre></div></li><li class="listitem" value="2">The following is the completed <code class="email">absEqual</code> function:<div class="note"><pre class="programlisting">bool absEqual( int a, int b )
{
  // Make a and b positive
if( a &lt; 0 )
    a = -a;
  if( b &lt; 0 )
    b = -b;
  // now since they're both +ve,
  // we just have to compare equality of a and b together
  return a == b;
}</pre></div></li><li class="listitem" value="3">The <code class="email">getGrade()</code> function<a id="id183" class="calibre1"/> is given in the following code:<div class="note"><pre class="programlisting">char getGrade( int grade )
{
  if( grade &gt;= 80 )
    return 'A';
  else if( grade &gt;= 70 )
    return 'B';
  else if( grade &gt;= 60 )
    return 'C';
  else if( grade &gt;= 50 )
    return 'D';
  else
    return 'F';
}</pre></div></li><li class="listitem" value="4">This program is a simple one that should entertain you. The origin of the <code class="email">name</code> function in C++ actually came from the math world, as shown in the following code:<div class="note"><pre class="programlisting">double f( double x )
{
  return 3*x + 4;
}</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Variables, revisited"><div class="book" id="1565U2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Variables, revisited</h1></div></div></div><p class="calibre9">It's always<a id="id184" class="calibre1"/> nice to revisit a topic you've covered before, now that you understand C++ coding much more in depth.</p></div>

<div class="book" title="Variables, revisited">
<div class="book" title="Global variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec51" class="calibre1"/>Global variables</h2></div></div></div><p class="calibre9">Now that<a id="id185" class="calibre1"/> we've introduced the concept of functions, the concept of a global variable can be introduced.</p><p class="calibre9">What is a<a id="id186" class="calibre1"/> global variable? A global variable is any variable that is made accessible to all the functions of the program. How can we make a variable that is accessible to all the functions of the program? We <a id="id187" class="calibre1"/>simply <a id="id188" class="calibre1"/>declare the global variable at the top of the code file, usually after or near the <code class="email">#include</code> statements.</p><p class="calibre9">Here's an example program with some global variables:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

string g_string;	// global string variable,
// accessible to all functions within the program
// (because it is declared before any of the functions
// below!)

void addA(){ g_string += "A"; }
void addB(){ g_string += "B"; }
void addC(){ g_string += "C"; }

int main()
{
  addA();
  addB();
  cout &lt;&lt; g_string &lt;&lt; endl;
  addC();
  cout &lt;&lt; g_string &lt;&lt; endl;
}</pre></div><p class="calibre9">Here, the same <code class="email">g_string</code> global variable is accessible to all the four functions in the program (<code class="email">addA()</code>, <code class="email">addB()</code>, <code class="email">addC()</code>, and <code class="email">main()</code>). Global variables live for the duration of the program.</p><div class="note" title="Note"><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre9">People sometimes prefer to prefix global variables with <code class="email">g_</code>, but prefixing the variable name with <code class="email">g_</code> is not a requirement for a variable to be global.</p></div></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="Local variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec52" class="calibre1"/>Local variables</h2></div></div></div><p class="calibre9">A local variable<a id="id189" class="calibre1"/> is a variable that is defined within a block of code. Local variables<a id="id190" class="calibre1"/> go out of the scope at the end of the block in which they are declared. Some examples will follow in the next section, <span class="strong"><em class="calibre10">The</em></span> <span class="strong"><em class="calibre10">scope of a variable</em></span>.</p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="The scope of a variable"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec53" class="calibre1"/>The scope of a variable</h2></div></div></div><p class="calibre9">The<a id="id191" class="calibre1"/> scope of a variable<a id="id192" class="calibre1"/> is the area of code where that variable can be used. The scope of any variable is basically the block in which it is defined. We can demonstrate a variable's scope using an example, as shown in the following code:</p><div class="note"><pre class="programlisting">int g_int; // global int, has scope until end of file
void func( int arg )
{
  int fx;
} // &lt;/fx&gt; dies, &lt;/arg&gt; dies

int main()
{
  int x; // variable &lt;x&gt; has scope starting here..
         // until the end of main()
  if( x == 0 )
  {
    int y;  // variable &lt;y&gt; has scope starting here,
            // until closing brace below
  } // &lt;/y&gt; dies
  if( int x2 = x ) // variable &lt;x2&gt; created and set equal to &lt;x&gt;
  {
    // enter here if x2 was nonzero
  } // &lt;/x2&gt; dies

for( int c = 0; c &lt; 5; c++ ) // c is created and has
  { // scope inside the curly braces of the for loop
    cout &lt;&lt; c &lt;&lt; endl;
  } // &lt;/c&gt; dies only when we exit the loop
} // &lt;/x&gt; dies</pre></div><p class="calibre9">The main thing that defines a variable's scope is a block. Let's discuss the scope of a couple of the variables defined in the preceding code example:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">g_int</code>: This is a<a id="id193" class="calibre1"/> global integer with a scope that ranges from the point it was declared until the end of the code file. That is to say, <code class="email">g_int</code> can be used inside <code class="email">func()</code> and <code class="email">main()</code>, but it cannot be used in other code files. To have a single global variable that is used across multiple code files, you will need an external variable.</li><li class="listitem"><code class="email">arg</code> (the argument of <code class="email">func()</code>): This<a id="id194" class="calibre1"/> can be used from the first line of <code class="email">func()</code> (after the opening curly brace {) to the last line of <code class="email">func()</code> (until the closing curly brace }).</li><li class="listitem"><code class="email">fx</code>: This can be<a id="id195" class="calibre1"/> used anywhere inside <code class="email">func()</code> until the closing curly brace of <code class="email">func()</code>}.</li><li class="listitem"><code class="email">main()</code>(variables inside <code class="email">main()</code>): This<a id="id196" class="calibre1"/> can be used as marked in the comments.</li></ul></div><p class="calibre9">Notice <a id="id197" class="calibre1"/>how<a id="id198" class="calibre1"/> variables declared inside the brackets of a function's argument list can only be used inside the block below that function's declaration. For example, the <code class="email">arg</code> variable passed to <code class="email">func()</code>:</p><div class="note"><pre class="programlisting">void func( int arg )
{
  int fx;
} // &lt;/fx&gt; dies, &lt;/arg&gt; dies</pre></div><p class="calibre9">The <code class="email">arg</code> variable will die after the closing curly brace (<code class="email">}</code>) of the <code class="email">func()</code> function. This is counterintuitive as the round brackets are technically outside the curly braces that define the <code class="email">{</code> block <code class="email">}</code>.</p><p class="calibre9">The same goes for variables declared inside the round brackets of a <code class="email">for</code> loop. Take as an example the following <code class="email">for</code> loop:</p><div class="note"><pre class="programlisting">for( int c = 0; c &lt; 5; c++ )
{
  cout &lt;&lt; c &lt;&lt; endl;
} // c dies here</pre></div><p class="calibre9">The <code class="email">int c</code> variable can be used inside the round brackets of the <code class="email">for</code> loop declaration or inside the block below the <code class="email">for</code> loop declaration. The <code class="email">c</code> variable will die after the closing of the curly brace of the <code class="email">for</code> loop it is declared in. If you want the <code class="email">c</code> variable to live on after the brace brackets of the <code class="email">for</code> loop, you need to declare the <code class="email">c</code> variable before the <code class="email">for</code> loop, as shown here:</p><div class="note"><pre class="programlisting">int c;
for( c = 0; c &lt; 5; c++ )
{
  cout &lt;&lt; c &lt;&lt; endl;
} // c does not die here</pre></div></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="Static local variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec54" class="calibre1"/>Static local variables</h2></div></div></div><p class="calibre9">The <a id="id199" class="calibre1"/>
<code class="email">static</code> local variables are exactly like global variables, only<a id="id200" class="calibre1"/> they have a local scope, as shown in the following code:</p><div class="note"><pre class="programlisting">void testFunc()
{
  static int runCount = 0; // this only runs ONCE, even on
  // subsequent calls to testFunc()!
  cout &lt;&lt; "Ran this function " &lt;&lt; ++runCount &lt;&lt; " times" &lt;&lt; endl;
} // runCount stops being in scope, but does not die here

int main()
{
  testFunc();  // says 1 time
  testFunc();  // says 2 times!
}</pre></div><p class="calibre9">With the use of the <code class="email">static</code> keyword inside <code class="email">testFunc()</code>, the <code class="email">runCount</code> variable remembers its value between calls of <code class="email">testFunc()</code>. So, the output of the two separate preceding runs of <code class="email">testFunc()</code> is:</p><div class="note"><pre class="programlisting">Ran this function 1 times
Ran this function 2 times</pre></div><p class="calibre9">That's because static variables are only created and initialized once (the first time when the function they are declared in runs), and after that, the static variable retains its old value. Say, we declare <code class="email">runCount</code> as a regular, local, nonstatic variable:</p><div class="note"><pre class="programlisting">int runCount = 0; // if declared this way, runCount is local</pre></div><p class="calibre9">Then, this is how the output will look:</p><div class="note"><pre class="programlisting">Ran this function 1 times
Ran this function 1 times</pre></div><p class="calibre9">Here, we see <code class="email">testFunc</code> saying <code class="email">Ran this function 1 time</code> both the times. As a local variable, the value of <code class="email">runCount</code> is not retained between function calls.</p><p class="calibre9">You should not overuse static local variables. In general, you should only use a static local variable when it is absolutely necessary.</p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="Const variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec55" class="calibre1"/>Const variables</h2></div></div></div><p class="calibre9">A<a id="id201" class="calibre1"/> <code class="email">const</code> variable<a id="id202" class="calibre1"/> is a variable whose value you promise the compiler not to change after the first initialization. We can declare one simply, for example, for the value of <code class="email">pi</code>:</p><div class="note"><pre class="programlisting">const double pi = 3.14159;</pre></div><p class="calibre9">Since <code class="email">pi</code> is a universal constant (one of the few things you can rely on to be the same), there should be no need to change <code class="email">pi</code> after initialization. In fact, changes to <code class="email">pi</code> should be forbidden by the compiler. Try, for example, to assign <code class="email">pi</code> a new value:</p><div class="note"><pre class="programlisting">pi *= 2;</pre></div><p class="calibre9">We will get the following compiler error:</p><div class="note"><pre class="programlisting">error C3892: 'pi' : you cannot assign to a variable that is const</pre></div><p class="calibre9">This error makes perfect sense, because besides the initial initialization, we should not be able to change the value of <code class="email">pi</code>— a variable that is constant.</p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="Function prototypes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec56" class="calibre1"/>Function prototypes</h2></div></div></div><p class="calibre9">A<a id="id203" class="calibre1"/> function prototype is the signature of the function without the<a id="id204" class="calibre1"/> body. For example, let's prototype the <code class="email">isPositive</code>, <code class="email">absEqual</code>, and <code class="email">getGrade</code> functions from the following exercises:</p><div class="note"><pre class="programlisting">bool isPositive( double value );
bool absEqual( int a, int b );
char getGrade( int grade );</pre></div><p class="calibre9">Notice how the function prototypes are just the return type, function name, and argument list that the function requires. Function prototypes don't get a body. The body of the function is typically put in the <code class="email">.cpp</code> file.</p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title=".h and .cpp files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch05lvl2sec57" class="calibre1"/>.h and .cpp files</h2></div></div></div><p class="calibre9">It is typical to put <a id="id205" class="calibre1"/>your function prototypes in an <code class="email">.h</code> file<a id="id206" class="calibre1"/> and the bodies <a id="id207" class="calibre1"/>of the functions in a <code class="email">.cpp</code> file. The reason for this is you can include your <code class="email">.h</code> file in a bunch of <code class="email">.cpp</code> files <a id="id208" class="calibre1"/>and not get multiple definition errors.</p><p class="calibre9">The following screenshot gives you a clear picture of <code class="email">.h</code> and <code class="email">.cpp</code> files:.</p><div class="mediaobject"><img src="../images/00058.jpeg" alt=".h and .cpp files" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Here, we <a id="id209" class="calibre1"/>have<a id="id210" class="calibre1"/> three files in this Visual C++ project:</p><div class="mediaobject"><img src="../images/00059.jpeg" alt=".h and .cpp files" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="prototypes.h contains"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch05lvl2sec58" class="calibre1"/>prototypes.h contains</h2></div></div></div><div class="note"><pre class="programlisting">// Make sure these prototypes are
// only included in compilation ONCE
#pragma once
extern int superglobal; // extern: variable "prototype"
// function prototypes
bool isPositive( double value );
bool absEqual( int a, int b );
char getGrade( int grade );</pre></div><p class="calibre9">The <code class="email">prototypes.h</code> file <a id="id211" class="calibre1"/>contains function prototypes. We <a id="id212" class="calibre1"/>will explain<a id="id213" class="calibre1"/> what the <code class="email">extern</code> keyword <a id="id214" class="calibre1"/>does in a few paragraphs.</p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="funcs.cpp contains"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch05lvl2sec59" class="calibre1"/>funcs.cpp contains</h2></div></div></div><div class="note"><pre class="programlisting">#include "prototypes.h" // every file that uses isPositive,
// absEqual or getGrade must #include "prototypes.h"
int superglobal; // variable "implementation"
// The actual function definitions are here, in the .cpp file
bool isPositive( double value )
{
  return value &gt; 0;
}
bool absEqual( int a, int b )
{
  // Make a and b positive
  if( a &lt; 0 )
    a = -a;
  if( b &lt; 0 )
    b = -b;
  // now since they're both +ve,
  // we just have to compare equality of a and b together
  return a == b;
}
char getGrade( int grade )
{
  if( grade &gt;= 80 )
    return 'A';
  else if( grade &gt;= 70 )
    return 'B';
  else if( grade &gt;= 60 )
    return 'C';
  else if( grade &gt;= 50 )
    return 'D';
  else
    return 'F';
}</pre></div></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="main.cpp contains"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_10"><a id="ch05lvl2sec60" class="calibre1"/>main.cpp contains</h2></div></div></div><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
#include "prototypes.h" // for use of isPositive, absEqual 
// functions
int main()
{
  cout &lt;&lt; boolalpha &lt;&lt; isPositive( 4 ) &lt;&lt; endl;
  cout &lt;&lt; absEqual( 4, -4 ) &lt;&lt; endl;
}</pre></div><p class="calibre9">When <a id="id215" class="calibre1"/>you<a id="id216" class="calibre1"/> split up the code into <code class="email">.h</code> and <code class="email">.cpp</code> files, the <code class="email">.h</code> file (the header file) is called the interface and the <code class="email">.cpp</code> file (the one with the actual functions in it) is called the implementation.</p><p class="calibre9">The puzzling part at first for some programmers is how does C++ know where the <code class="email">isPositive</code> and <code class="email">getGrade</code> function bodies are, if we only <code class="email">#include</code> the prototypes? Shouldn't we <code class="email">#include</code> the <code class="email">funcs.cpp</code> file into <code class="email">main.cpp</code> too?</p><p class="calibre9">The answer is <span class="strong"><em class="calibre10">magic</em></span>. You only need to <code class="email">#include</code> the <code class="email">prototypes.h</code> header file in both <code class="email">main.cpp</code> and <code class="email">funcs.cpp</code>. As long as both <code class="email">.cpp</code> files are included in <a id="id217" class="calibre1"/>your C++ <span class="strong"><strong class="calibre2">Integrated Development Environment</strong></span> (<span class="strong"><strong class="calibre2">IDE</strong></span>) project (that is, they appear in the <span class="strong"><strong class="calibre2">Solution Explorer</strong></span> tree view at the left-hand side), the linkup of the prototypes to the function bodies is done automatically by the compiler.</p></div></div>

<div class="book" title="Variables, revisited">
<div class="book" title="Extern variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_11"><a id="ch05lvl2sec61" class="calibre1"/>Extern variables</h2></div></div></div><p class="calibre9">An <a id="id218" class="calibre1"/>
<code class="email">extern</code> declaration is similar to a function prototype, only it is<a id="id219" class="calibre1"/> used on a variable. You can put an <code class="email">extern</code> global variable declaration in an <code class="email">.h</code> file, and include this <code class="email">.h</code> file in a whole bunch of other files. This way, you can have a single global variable that gets shared across multiple source files, without getting the multiply defined symbols found linker error. You'd put the actual variable declaration in a <code class="email">.cpp</code> file so that the variable only gets declared once. There is an <code class="email">extern</code> variable in the <code class="email">prototypes.h</code> file in the previous example.</p></div></div>

<div class="book" title="Macros" id="164MG1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Macros</h1></div></div></div><p class="calibre9">C++ macros <a id="id220" class="calibre1"/>are from a class of C++ commands called preprocessor directives. A preprocessor directive is executed before compilation takes place.</p><p class="calibre9">Macros start with <code class="email">#define</code>. For example, say we have the following macro:</p><div class="note"><pre class="programlisting">#define PI 3.14159</pre></div><p class="calibre9">At the lowest level, macros are simply copy and paste operations that occur just before compile time. In the preceding macro statement, the <code class="email">3.14159</code> literal will be copied and pasted everywhere the symbol <code class="email">PI</code> occurs in the program.</p><p class="calibre9">Take an example of the following code:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14159
int main()
{
  double r = 4;
  cout &lt;&lt; "Circumference is " &lt;&lt; 2*PI*r &lt;&lt; endl;
}</pre></div><p class="calibre9">What the C++ preprocessor will do is first go through the code and look for any usage of the <code class="email">PI</code> symbol. It will find one such usage on this line:</p><div class="note"><pre class="programlisting">cout &lt;&lt; "Circumference is " &lt;&lt; 2*PI*r &lt;&lt; endl;</pre></div><p class="calibre9">The preceding line will convert to the following just before compilation:</p><div class="note"><pre class="programlisting">cout &lt;&lt; "Circumference is " &lt;&lt; 2*3.14159*r &lt;&lt; endl;</pre></div><p class="calibre9">So, all that happens with a <code class="email">#define</code> statement is that all the occurrences of the symbol used (example, <code class="email">PI</code>) are replaced by the literal number <code class="email">3.14159</code> even before compilation occurs. The point of using macros in this way is to avoid hardcoding numbers into the code. Symbols are typically easier to read than big, long numbers.</p></div>

<div class="book" title="Macros" id="164MG1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Advice – try to use const variables where possible"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec62" class="calibre1"/>Advice – try to use const variables where possible</h2></div></div></div><p class="calibre9">You can use <a id="id221" class="calibre1"/>macros to define constant variables. You can also use <code class="email">const</code> variable expressions instead. So, say we have the following line of code:</p><div class="note"><pre class="programlisting">#define PI 3.14159</pre></div><p class="calibre9">We will be encouraged to use the following instead:</p><div class="note"><pre class="programlisting">const double PI = 3.14159;</pre></div><p class="calibre9">Using a <code class="email">const</code> variable <a id="id222" class="calibre1"/>will be encouraged because it stores your value inside an actual variable. The variable is typed, and typed data is a good thing.</p></div></div>

<div class="book" title="Macros with arguments" id="173721-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Macros with arguments</h1></div></div></div><p class="calibre9">We can also write <a id="id223" class="calibre1"/>macros that accept arguments. Here's an example of a macro with an argument:</p><div class="note"><pre class="programlisting">#define println(X) cout &lt;&lt; X &lt;&lt; endl;</pre></div><p class="calibre9">What this macro will do is every time <code class="email">println("Some value")</code> is encountered in the code, the code on the right-hand side (<code class="email">cout &lt;&lt; "Some value" &lt;&lt; endl</code>) will be copied and pasted on the console. Notice how the argument between the brackets is copied in the place of <code class="email">X</code>. Say we had the following line of code:</p><div class="note"><pre class="programlisting">println( "Hello there" )</pre></div><p class="calibre9">This will be replaced by the following statement:</p><div class="note"><pre class="programlisting">cout &lt;&lt; "Hello there" &lt;&lt; endl;</pre></div><p class="calibre9">Macros with arguments are exactly like very short functions. Macros cannot contain any newline characters in them.</p></div>

<div class="book" title="Macros with arguments" id="173721-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Advice – use inline functions instead of macros with arguments"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec63" class="calibre1"/>Advice – use inline functions instead of macros with arguments</h2></div></div></div><p class="calibre9">You<a id="id224" class="calibre1"/> have to know about how macros with arguments work because you will encounter them in C++ code a lot. Whenever possible, however, many C++ programmers prefer to use inline functions over macros with arguments.</p><p class="calibre9">A normal function call execution involves a <code class="email">jump</code> instruction to the function and then the execution of the function. An inline<span class="strong"><em class="calibre10"> </em></span>function is one whose lines of code are copied to the point of the function call and no jump is issued. Using inline functions usually makes sense for very small, simple functions that don't have a lot of lines of code. For example, we might inline a simple function <code class="email">max</code> that finds the larger of two values:</p><div class="note"><pre class="programlisting">inline int max( int a, int b )
{
  if( a &gt; b ) return a;
  else return b;
}</pre></div><p class="calibre9">Everywhere this <code class="email">max</code> function is used, the code for the function body will be copied and pasted at the point of the function call. Not having to <code class="email">jump</code> to the function saves execution time, making inline functions effectively similar to macros.</p><p class="calibre9">There is a catch <a id="id225" class="calibre1"/>to using inline functions. Inline functions must have their bodies completely contained in the <code class="email">.h</code> header file. This is so that the compiler can make optimizations and actually inline the function wherever it is used. Functions are made inline typically for speed (since you don't have to jump to another body of the code to execute the function) but at the cost of code bloat.</p><p class="calibre9">The following are the reasons why inline functions are preferred over macros:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Macros are error prone: the argument to the macro is not typed.</li><li class="listitem" value="2">Macros have to be written in one line or you will see them using use escaped<div class="note"><pre class="programlisting">\
newline characters \
like this \
which is hard to read</pre></div></li><li class="listitem" value="3">If the macro is not carefully written, it will result in difficult-to-fix compiler errors. For example, if you do not bracket your argument properly, your code will just be wrong.</li><li class="listitem" value="4">Large macros are hard to debug.</li></ol><div class="calibre14"/></div><p class="calibre9">It should be said that macros do allow you to perform some preprocessor compiler magic. UE4 makes a lot of use of macros with arguments, as you will see later.</p></div></div>
<div class="book" title="Summary" id="181NK1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">Function calls allow you to reuse basic code. Code reuse is important for a number of reasons: mainly because programming is hard and duplicating effort should be avoided wherever possible. The efforts of the programmer that wrote the <code class="email">sqrt()</code> function do not need to be repeated by other programmers who want to solve the same problem.</p></div></body></html>