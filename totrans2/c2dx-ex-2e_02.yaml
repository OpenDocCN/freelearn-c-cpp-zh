- en: Chapter 2. You Plus C++ Plus Cocos2d-x
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 你、C++ 和 Cocos2d-x
- en: '*This chapter will be aimed at two types of developers: the original Cocos2d
    developer who is scared of C++ but won''t admit it to his friends and the C++
    coder who never even heard of Cocos2d and finds Objective-C funny looking.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章将针对两种类型的开发者：害怕 C++ 但不会向朋友承认的原始 Cocos2d 开发者，以及从未听说过 Cocos2d 且认为 Objective-C
    看起来很奇怪的 C++ 程序员。*'
- en: '*I''ll go over the main syntax differences Objective-C developers should pay
    attention to and the few code style changes involved in developing with Cocos2d-x
    that C++ developers should be aware of. But first, a quick introduction to Cocos2d-x
    and what it is all about.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我将概述 Objective-C 开发者应该注意的主要语法差异，以及在使用 Cocos2d-x 开发时涉及的一些代码风格更改，C++ 开发者应该了解。但首先，让我们快速介绍一下
    Cocos2d-x 以及它是什么以及它所涉及的一切。*'
- en: 'You will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习以下主题：
- en: What Cocos2d-x is and what it can do for you
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cocos2d-x 是什么以及它能为您做什么
- en: How to create classes in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 C++ 中创建类
- en: How to memory manage your objects in Cocos2d-x and C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Cocos2d-x 和 C++ 中管理您的对象内存
- en: What you get out of Ref
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Ref 获取的内容
- en: Cocos2d-x – an introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cocos2d-x – 简介
- en: So what is a 2D framework? If I had to define it in as few words as possible,
    I'd say rectangles in a loop.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是 2D 框架呢？如果我要用尽可能少的词来定义它，我会说是在循环中的矩形。
- en: At the heart of Cocos2d-x, you find the `Sprite` class and what that class does,
    in simple terms, is keep a reference to two very important rectangles. One is
    the image (or texture) rectangle, also called the source rectangle, and the other
    is the destination rectangle. If you want an image to appear in the center of
    the screen, you will use `Sprite`. You will pass it the information of what and
    where that image source is and where on the screen you want it to appear.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 的核心，您会发现 `Sprite` 类以及这个类所做的工作，简单来说，就是保持对两个非常重要的矩形的引用。一个是图像（或纹理）矩形，也称为源矩形，另一个是目标矩形。如果您想让图像出现在屏幕中央，您将使用
    `Sprite`。您将传递有关图像源是什么以及在哪里显示的信息，以及您想在屏幕上的哪个位置显示它。
- en: There is not much that needs to be done to the first rectangle, the source one;
    but there is a lot that can be changed in the destination rectangle, including
    its position on the screen, its size, opacity, rotation, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个矩形，即源矩形，不需要做太多工作；但在目标矩形中可以改变很多东西，包括其在屏幕上的位置、大小、不透明度、旋转等。
- en: Cocos2d-x will then take care of all the OpenGL drawing necessary to display
    your image where you want it and how you want it, and it will do so inside a render
    loop. Your code will most likely tap into that same loop to update its own logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 将负责所有必要的 OpenGL 绘制工作，以显示您想要的位置和方式显示您的图像，并且它将在渲染循环内完成这些工作。您的代码很可能会利用同一个循环来更新自己的逻辑。
- en: Pretty much any 2D game you can think of can be built with Cocos2d-x with a
    few sprites and a loop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何您能想到的 2D 游戏都可以使用 Cocos2d-x 和一些精灵以及循环来构建。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Version 3.x of the framework, there was a mild separation between Cocos2d-x
    and its counterpart Cocos2d. It dropped the prefix CC in favor of namespaces,
    embraced C++11 features, and became that much nicer to work with because of it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架的 3.x 版本中，Cocos2d-x 和其对应版本 Cocos2d 之间存在轻微的分离。它放弃了 CC 前缀，转而使用命名空间，采用了 C++11
    的特性，因此它变得更加易于使用。
- en: Containers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: Also important in Cocos2d-x is the notion of containers (or nodes). These are
    all the objects that can have sprites inside them (or other nodes.) This is extremely
    useful at times because by changing aspects of the container, you automatically
    change aspects of its children. Move the container and all its children will move
    with it. Rotate the container and well, you get the picture!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 中，也很重要的是容器（或节点）的概念。这些都是可以包含精灵（或其他节点）的对象。在某些时候，这非常有用，因为通过改变容器的一些方面，您会自动改变其子节点的某些方面。移动容器，所有子节点都会随之移动。旋转容器，嗯，您应该能想象出来！
- en: 'The containers are: `Scene`, `Layer`, and `Sprite`. They all inherit from a
    base container class called **node**. Each container will have its peculiarities,
    but basically you will arrange them as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器包括：`Scene`、`Layer` 和 `Sprite`。它们都继承自一个名为 **node** 的基本容器类。每个容器都会有其独特之处，但基本上您将按照以下方式排列它们：
- en: '`Scene`: This will contain one or more `Node`, usually `Layer` types. It is
    common to break applications into multiple scenes; for instance, one for the main
    menu, one for settings, and one for the actual game. Technically, each scene will
    behave as a separate entity in your application, almost as subapplications themselves,
    and you can run a series of transition effects when changing between scenes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scene`: 这将包含一个或多个 `Node`，通常是 `Layer` 类型。将应用程序拆分为多个场景很常见；例如，一个用于主菜单，一个用于设置，一个用于实际游戏。技术上，每个场景都将作为你应用程序中的独立实体行为，几乎就像子应用程序一样，你可以在场景之间切换时运行一系列过渡效果。'
- en: '`Layer`: This will most likely contain `Sprite`. There are a number of specialized
    `Layer` objects aimed at saving you, the developer, some time in creating things
    such as menus for instance (`Menu`), or a colored background (`LayerColor`). You
    can have more than one `Layer` per scene, but good planning makes this usually
    unnecessary.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layer`: 这很可能会包含 `Sprite`。有一些专门的 `Layer` 对象旨在为你，开发者，节省时间，例如创建菜单（`Menu`）或彩色背景（`LayerColor`）。每个场景可以有多个
    `Layer`，但良好的规划通常使这变得不必要。'
- en: '`Sprite`: This will contain your images and be added as children to `Layer`
    derived containers. To my mind, this is the most important class in all of Cocos2d-x,
    so much so, that after your application initializes, when both a `Scene` and a
    `Layer` object are created, you could build your entire game only with sprites
    and never use another container class in Cocos2d-x.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`: 这将包含你的图像，并作为子元素添加到由 `Layer` 派生的容器中。在我看来，这是 Cocos2d-x 中最重要的类，如此重要，以至于在应用程序初始化后，当创建了一个
    `Scene` 和一个 `Layer` 对象时，你只需使用精灵就能构建整个游戏，而无需在 Cocos2d-x 中使用另一个容器类。'
- en: '`Node`: This super class to all containers blurs the line between itself and
    `Layer`, and even `Sprite` at times. It has its own set of specialized subclasses
    (besides the ones mentioned earlier), such as `MotionStreak`, `ParallaxNode`,
    and `SpriteBatchNode`, to name a few. It can, with a few adjustments, behave just
    as `Layer`. But most of the time you will use it to create your own specialized
    nodes or as a general reference in polymorphism.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node`: 这个超级类对所有容器模糊了其自身与 `Layer`，甚至 `Sprite` 之间的界限。它有一系列专门的子类（除了之前提到的那些），例如
    `MotionStreak`、`ParallaxNode` 和 `SpriteBatchNode`，仅举几例。经过一些调整，它可以表现得就像 `Layer`
    一样。但大多数时候，你会用它来创建自己的专用节点或作为多态中的通用参考。'
- en: The Director and cache classes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导演和缓存类
- en: After containers comes the all-knowing `Director` and all-encompassing cache
    objects. The `Director` object manages scenes and knows all about your application.
    You will make calls to it to get to that information and to change some of the
    things such as screen size, frame rate, scale factor, and so forth.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器之后，是无所不知的 `Director` 和包罗万象的缓存对象。`Director` 对象管理场景，并了解你应用程序的所有信息。你将调用它来获取这些信息，并更改一些事情，如屏幕大小、帧率、缩放因子等等。
- en: The caches are collector objects. The most important ones are `TextureCache`,
    `SpriteFrameCache`, and `AnimationCache`. These are responsible for storing key
    information regarding those two important rectangles I mentioned about earlier.
    But every type of data that is used repeatedly in Cocos2d-x will be kept in some
    sort of cache list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是收集器对象。其中最重要的有 `TextureCache`、`SpriteFrameCache` 和 `AnimationCache`。这些负责存储关于我之前提到的两个重要矩形的关键信息。但
    Cocos2d-x 中使用的任何重复数据类型都将保存在某种缓存列表中。
- en: Both `Director` and all cache objects are singletons. These are special sort
    of classes that are instantiated only once; and this one instance can be accessed
    by any other object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Director` 和所有缓存对象都是单例。这些是特殊类型的类，它们只实例化一次；并且这个实例可以被任何其他对象访问。'
- en: The other stuff
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他东西
- en: 'After the basic containers, the caches and the `Director` object, comes the
    remaining 90 percent of the framework. Among all this, you will find:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本容器、缓存和 `Director` 对象之后，是框架剩余的 90%。在这其中，你会发现：
- en: '**Actions**: Animations will be handled through these and what a treat they
    are!'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：动画将通过这些来处理，它们是多么美妙啊！'
- en: '**Particles**: Particles systems for your delight.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子**：粒子系统，让你的快乐倍增。'
- en: '**Specialized nodes**: For things such as menus, progress bars, special effects,
    parallax effect, tile maps, and much, much more.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用节点**：用于菜单、进度条、特殊效果、视差效果、瓦片地图等等。'
- en: '**The macros, structures, and helper methods**: Hundreds of time-saving, magical
    bits of logic. You don''t need to know them all, but chances are that you will
    be coding something that can be easily replaced by a macro or a helper method
    and feel incredibly silly when you find out about it later.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏、结构和辅助方法**：数百个节省时间的神奇逻辑片段。你不需要知道它们全部，但很可能你会编写一些可以用宏或辅助方法轻松替换的代码，并在后来发现时感到非常愚蠢。'
- en: Do you know C++?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你知道C++吗？
- en: Don't worry, the C part is easy. The first plus goes by really fast, but that
    second plus, oh boy!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，C部分很简单。第一个加号过得非常快，但那个第二个加号，哎呀！
- en: Remember, it is C. And if you have coded in Objective-C with the original Cocos2d,
    you know good old C already even if you saw it in between brackets most of the
    time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是C。如果你使用原始Cocos2d在Objective-C中编码过，即使你大部分时间看到的是在括号中，你也已经熟悉了古老的C语言。
- en: But C++ also has classes, just like Objective-C, and these classes are declared
    in the interface files just like in Objective-C. So let's go over the creation
    of a C++ class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但C++也有类，就像Objective-C一样，这些类在接口文件中声明，就像在Objective-C中一样。所以，让我们回顾一下C++类的创建。
- en: The class interface
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类接口
- en: This will be done in a `.h` file. We'll use a text editor to create this file
    since I don't want any code hinting and autocompletion features getting in the
    way of you learning the basics of C++ syntax. So for now at least, open up your
    favorite text editor. Let's create a class interface!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`.h`文件中完成。我们将使用文本编辑器来创建这个文件，因为我不想任何代码提示和自动完成功能干扰你学习C++语法的基础知识。所以至少现在，打开你最喜欢的文本编辑器。让我们创建一个类接口！
- en: Time for action – creating the interface
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建接口
- en: The interface, or header file, is just a text file with the `.h` extension.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接口，或头文件，只是一个带有`.h`扩展名的文本文件。
- en: 'Create a new text file and save it as `HelloWorld.h`. Then, enter the following
    lines at the top:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文本文件，并将其保存为`HelloWorld.h`。然后，在顶部输入以下行：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add the namespace declaration:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加命名空间声明：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, declare your class name and the name of any inherited classes:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明你的类名和任何继承的类名：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add the properties and methods:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加属性和方法：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We finish by closing the `#ifndef` statement:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过关闭`#ifndef`语句来完成：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'You created a header file in C++. Let''s go over the important bits of information:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你在C++中创建了一个头文件。让我们回顾一下重要的信息：
- en: In C++ you include, you do not import. The `import` statement in Objective-C
    checks whether something needs to be included; `include` does not. But we accomplish
    the same thing through that clever use of definitions at the top. There are other
    ways to run the same check (with `#pragma once`, for instance) but this one is
    added to any new C++ files you create in Xcode.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中，你包含，而不是导入。Objective-C中的`import`语句检查是否需要包含某些内容；`include`则不检查。但我们通过在顶部使用定义的巧妙方式完成相同的事情。还有其他方法可以运行相同的检查（例如使用`#pragma
    once`），但这个是在你创建的任何新的Xcode C++文件中添加的。
- en: You can make your life easier by declaring the namespaces you'll use in the
    class. These are similar to packages in some languages. You may have noticed that
    all the uses of `cocos2d::` in the code are not necessary because of the namespace
    declaration. But I wanted to show you the bit you can get rid of by adding a namespace
    declaration.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过声明在类中使用的命名空间来使你的生活更简单。这些在有些语言中类似于包。你可能已经注意到，由于命名空间声明，代码中所有对`cocos2d::`的使用都是不必要的。但我想要展示的是，通过添加命名空间声明可以去掉的部分。
- en: So next you give your class a name and you may choose to inherit from some other
    class. In C++ you can have as many super classes as you want. And you must declare
    whether your super class is public or not.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以接下来，给你的类起一个名字，你可以选择从其他类继承。在C++中，你可以有任意多的超类。你必须声明你的超类是否是公开的。
- en: You declare your `public`, `protected` and `private` methods and members between
    the curly braces. `HelloWorld` is the constructor and `~HelloWorld` is the destructor
    (it will do what `dealloc` does in Objective-C).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在花括号之间声明你的`public`、`protected`和`private`方法和成员。`HelloWorld`是构造函数，`~HelloWorld`是析构函数（它将执行Objective-C中的`dealloc`所做的操作）。
- en: The `virtual` keyword is related to overrides. When you mark a method as `virtual,`
    you are telling the compiler not to set in stone the owner of the method, but
    to keep it in memory as execution will reveal the obvious owner. Otherwise, the
    compiler may erroneously decide that a method belongs to the super and not its
    inheriting class.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual` 关键字与重写有关。当你将一个方法标记为 `virtual` 时，你是在告诉编译器不要将方法的所有权固定下来，而是将其保留在内存中，因为执行将揭示明显的主人。否则，编译器可能会错误地决定一个方法属于超类而不是其继承类。'
- en: Also, it's good practice to make all your destructors `virtual`. You only need
    use the keyword once in the super class to mark potential overrides, but it is
    common practice to repeat the `virtual` keyword in all subclasses so developers
    know which methods are overrides (C++11 adds a tag `override,` which makes this
    distinction even clearer, and you will see examples of it in this book's code).
    In this case, `init` comes from `Layer` and `HelloWorld` wants to override it.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，将所有析构函数设置为 `virtual` 是一种良好的实践。你只需要在超类中使用一次关键字来标记潜在的覆盖，但通常的做法是在所有子类中重复 `virtual`
    关键字，这样开发者就知道哪些方法是覆盖（C++11 添加了一个 `override` 标签，这使得这种区分更加清晰，你将在本书的代码中看到它的例子）。在这种情况下，`init`
    来自 `Layer`，而 `HelloWorld` 想要覆盖它。
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Oh yes, in C++ you must declare overrides in your interfaces. No exceptions!
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噢，是的，在 C++ 中，你必须在你的接口中声明重写。没有例外！
- en: The `inline` method is something new to you, probably. These methods are added
    to the code by the compiler wherever they are called for. So every time I make
    a call to `addTwoIntegers`, the compiler will replace it with the lines for the
    method declared in the interface. So the `inline` method works just as statements
    inside a method; they do not require their own bit of memory in the stack. But
    if you have a two-line `inline` method called 50 times in your program, it means
    that the compiler will add a hundred lines to your code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline` 方法对你来说可能是新的。这些方法在它们被调用的地方由编译器添加到代码中。所以每次我调用 `addTwoIntegers`，编译器都会用接口中声明的方法的行来替换它。所以
    `inline` 方法就像方法内部的表达式一样工作；它们不需要在栈中占用自己的内存。但是如果你在程序中调用了一个两行的 `inline` 方法50次，这意味着编译器将向你的代码中添加一百行。'
- en: The class implementation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类实现
- en: This will be done in a `.cpp` file. So let's go back to our text editor and
    create the implementation for our `HelloWorld` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在一个 `.cpp` 文件中完成。所以让我们回到我们的文本编辑器，为我们的 `HelloWorld` 类创建实现。
- en: Time for action – creating the implementation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动——创建实现
- en: 'The implementation is a text file with the `.cpp` extension:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实现是一个具有 `.cpp` 扩展名的文本文件：
- en: 'Create a new text file and save it as `HelloWorld.cpp`. At the top, let''s
    start by including our header file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文本文件，并将其保存为 `HelloWorld.cpp`。在顶部，让我们先包含我们的头文件：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we implement our constructor and destructor:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现构造函数和析构函数：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then comes our static method:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是我们的静态方法：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then come our two remaining public methods:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是我们的两个剩余的公共方法：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*What just happened?*'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We created the implementation for our `HelloWorld` class. Here are the most
    important bits to take notice of:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的 `HelloWorld` 类创建了实现。以下是需要注意的最重要部分：
- en: The `HelloWorld::` scope resolution is not optional here. Every single method
    declared in your interface belongs to the new class that needs the correct scope
    resolution in the implementation file.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`HelloWorld::` 作用域解析不是可选的。你接口中声明的每个方法都属于需要正确作用域解析的新类。
- en: You also need the scope resolution when calling the super class like `Layer::init()`.
    There is no built-in `super` keyword in the standard C++ library.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用超类如 `Layer::init()` 时，也需要作用域解析。在标准 C++ 库中没有内置的 `super` 关键字。
- en: You use `this` instead of `self`. The `->` notation is used when you're trying
    to access an object's properties or methods through a pointer to the object (a
    pointer is the information of where you find the actual object in memory). The
    `.` (dot) notation is used to access an object's methods and properties through
    its actual instance (the blob of memory that comprises the actual object).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 `this` 而不是 `self`。当你试图通过指向对象的指针（指针是你在内存中找到实际对象的信息）来访问对象的属性或方法时，使用 `->` 符号。使用
    `.`（点）符号通过其实例（构成实际对象的内存块）来访问对象的方法和属性。
- en: We create an `update` loop, which takes a float for its delta time value simply
    by calling `scheduleUpdate`. You will see more options related to this later in
    this book.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `update` 循环，它通过调用 `scheduleUpdate` 简单地接受一个浮点数作为其 delta 时间值。你将在本书后面的部分看到更多与此相关的选项。
- en: You can use the `auto` keyword as the type of an object if it's obvious enough
    to the compiler which type an object is.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器足够清楚对象的类型，你可以使用`auto`关键字作为对象的类型。
- en: The `inline` methods, of course, are not implemented in the class since they
    exist only in the interface.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，`inline`方法不会在类中实现，因为它们只存在于接口中。
- en: And that's enough of syntax for now. C++ is one of the most extensive languages
    out there and I do not wish to leave you with the impression that I have covered
    all of it. But it is a language made by developers for developers. Trust me, you
    will feel right at home working with it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，语法讲解就到这里。C++是现有最广泛的语言之一，我不希望给你留下我已经涵盖了所有内容的印象。但这是一个由开发者为开发者制作的语言。相信我，你将感到与它一起工作非常自在。
- en: 'The information listed previously will become clearer once we move on to building
    the games. But now, onwards to the big scary monster: memory management.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的信息在我们开始构建游戏后将会更加清晰。但现在，让我们直面这个令人畏惧的大怪物：内存管理。
- en: Instantiating objects and managing memory
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化对象并管理内存
- en: 'There is no **Automatic Reference Counting** (**ARC**) in Cocos2d-x, so Objective-C
    developers who have forgotten memory management might have a problem here. However,
    the rule regarding memory management is very simple with C++: if you use `new`,
    you must delete. C++11 makes this even easier by introducing special pointers
    that are memory-managed (these are `std::unique_ptr` and `std::shared_ptr`).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x中没有**自动引用计数（ARC**），因此忘记内存管理的Objective-C开发者可能会在这里遇到问题。然而，关于内存管理的规则在C++中非常简单：如果你使用`new`，你必须删除。C++11通过引入特殊的内存管理的指针（这些是`std::unique_ptr`和`std::shared_ptr`）使这一点变得更加容易。
- en: Cocos2d-x, however, will add a few other options and commands to help with memory
    management, similar to the ones we have in Objective-C (without ARC). This is
    because Cocos2d-x, unlike C++ and very much like Objective-C, has a root class.
    The framework is more than just a C++ port of Cocos2d. It also ports certain notions
    of Objective-C to C++ in order to recreate its memory-management system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Cocos2d-x会添加一些其他选项和命令来帮助进行内存管理，类似于我们在Objective-C（没有ARC）中使用的那些。这是因为Cocos2d-x，与C++不同，与Objective-C非常相似，有一个根类。这个框架不仅仅是Cocos2d的C++端口，它还将Objective-C的一些概念移植到C++中，以重新创建其内存管理系统。
- en: Cocos2d-x has a `Ref` class that is the root of every major object in the framework.
    It allows the framework to have `autorelease` pools and `retain` counts, as well
    other Objective-C equivalents.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x有一个`Ref`类，它是框架中每个主要对象的根。它允许框架拥有`autorelease`池和`retain`计数，以及其他Objective-C等效功能。
- en: 'When instantiating Cocos2d-x objects, you have basically two options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化Cocos2d-x对象时，你基本上有两个选项：
- en: Using static methods
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态方法
- en: The C++ and Cocos2d-x style
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++和Cocos2d-x风格
- en: Using static methods
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态方法
- en: 'Using static methods is the recommended way. The three-stage instantiation
    process of Objective-C, with `alloc`, `init`, and `autorelease`/`retain`, is recreated
    here. So, for instance, a `Player` class, which extends `Sprite`, might have the
    following methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法是推荐的方式。Objective-C的三阶段实例化过程，包括`alloc`、`init`和`autorelease`/`retain`，在这里被重新创建。例如，一个扩展`Sprite`的`Player`类可能具有以下方法：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For instantiation, you call the static `create` method. It will create a new
    `Player` object as an empty husk version of `Player`. No major initialization
    should happen inside the constructor, just in case you may have to delete the
    object due to some failure in the instantiation process. Cocos2d-x has a series
    of macros for object deletion and release, like the `CC_SAFE_DELETE` macro used
    previously.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例化，你调用静态的`create`方法。它将创建一个新的`Player`对象，作为`Player`的空壳版本。构造函数内部不应该进行任何主要初始化，以防你可能因为实例化过程中的某些失败而需要删除该对象。Cocos2d-x有一系列用于对象删除和释放的宏，就像之前使用的`CC_SAFE_DELETE`宏一样。
- en: You then initialize the super through one of its available methods. In Cocos2d-x,
    these `init` methods return a `boolean` value for success. You may now begin filling
    the `Player` object with some data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过其可用方法之一初始化超类。在Cocos2d-x中，这些`init`方法返回一个`boolean`值表示成功。现在，你可以开始用一些数据填充`Player`对象。
- en: If successful, then initialize your object with its proper data if not done
    in the previous step, and return it as an `autorelease` object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，那么在之前的步骤中没有完成的情况下，使用正确的数据初始化你的对象，并以一个`autorelease`对象的形式返回它。
- en: 'So in your code the object would be instantiated as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你的代码中，对象将按照以下方式实例化：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even if the `player` variable were a member of the class (say, `m_player`),
    you wouldn''t have to retain it to keep it in scope. By adding the object to some
    Cocos2d-x list or cache, the object is automatically retained. So you may continue
    to address that memory through its pointer:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `player` 变量是类的一个成员（比如说，`m_player`），你也不必保留它以保持其作用域。通过将对象添加到某个 Cocos2d-x 列表或缓存中，对象会自动保留。因此，你可以继续通过其指针来引用该内存：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The C++ and Cocos2d-x style
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 和 Cocos2d-x 风格
- en: 'In this option, you would instantiate the previous `Player` object as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个选项中，你会按照以下方式实例化之前的 `Player` 对象：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Player` could do without a static method in this case and the `player` pointer
    will not access the same memory in future as it''s set to be autoreleased (so
    it would not stick around for long). In this case, however, the memory would not
    leak. It would still be retained by a Cocos2d-x list (the `addChild` command takes
    care of that). You can still access that memory by going over the children list
    added to `this`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Player` 可以没有静态方法，并且 `player` 指针在将来不会访问相同的内存，因为它被设置为自动释放（所以它不会长时间存在）。然而，在这种情况下，内存不会泄漏。它仍然会被
    Cocos2d-x 列表（`addChild` 命令负责这一点）保留。你仍然可以通过遍历添加到 `this` 的子项列表来访问该内存。
- en: 'If you needed the pointer to be a member property you could use `retain()`
    instead of `autorelease()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要指针作为成员属性，你可以使用 `retain()` 而不是 `autorelease()`：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then sometime later, you would have to release it; otherwise, it will leak:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在某个时候，你必须释放它；否则，它将会泄漏：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Hardcore C++ developers may choose to forget all about the `autorelease` pool
    and simply use `new` and `delete`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 硬核的 C++ 开发者可能会选择忘记所有关于 `autorelease` 池的事情，而仅仅使用 `new` 和 `delete`：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will not work. You have to use `autorelease`, `retain`, or leave the previous
    code without the `delete` command and hope there won't be any leak.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不会起作用。你必须使用 `autorelease`、`retain` 或者让之前的代码不带 `delete` 命令，并希望不会出现任何泄漏。
- en: C++ developers must keep in mind that `Ref` is managed by the framework. This
    means that objects are being internally added to caches and the `autorelease`
    pool even though you may not want this to happen. When you create that `Player`
    sprite, for instance, the `player.png` file you used will be added to the texture
    cache, or the sprite frame cache. When you add the sprite to a layer, the sprite
    will be added to a list of all children of that layer, and this list will be managed
    by the framework. My advice is, relax and let the framework work for you.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 开发者必须记住，`Ref` 是由框架管理的。这意味着对象正在被内部添加到缓存和 `autorelease` 池中，即使你可能不希望这种情况发生。例如，当你创建那个
    `Player` 精灵时，你使用的 `player.png` 文件将被添加到纹理缓存或精灵帧缓存中。当你将精灵添加到图层时，精灵将被添加到该图层的所有子项列表中，而这个列表将由框架管理。我的建议是，放松并让框架为你工作。
- en: 'Non-C++ developers should keep in mind that any class not derived from `Ref`
    should be managed the usual way, that is, if *you* are creating a new object you
    must delete it at some point:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 非 C++ 开发者应该记住，任何没有从 `Ref` 派生的类都应该以通常的方式管理，也就是说，如果你 *创建* 一个新对象，你必须在某个时候删除它：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What you get with Ref
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ref 得到的东西
- en: With `Ref` you get managed objects. This means that `Ref` derived objects will
    have a reference count property, which will be used to determine whether an object
    should be deleted from memory or not. The reference count is updated every time
    an object is added or removed from a Cocos2d-x collection object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Ref` 你可以得到托管对象。这意味着 `Ref` 派生对象将有一个引用计数属性，该属性将用于确定对象是否应该从内存中删除。每当对象被添加到或从
    Cocos2d-x 集合对象中移除时，引用计数都会更新。
- en: For instance, Cocos2d-x comes with a `Vector` collection object that extends
    the functionality of the C++ standard library vector (`std::vector`) by increasing
    and decreasing the reference count when objects are added and removed from it.
    For that reason, it can only store `Ref` derived objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Cocos2d-x 附带了一个 `Vector` 集合对象，它通过在对象被添加到或从其中移除时增加和减少引用计数来扩展 C++ 标准库向量 (`std::vector`)
    的功能。因此，它只能存储 `Ref` 派生对象。
- en: Once again, every `Ref` derived class can be managed the way things used to
    be managed in Objective-C before ARC- with `retain` counts and `autorelease` pools.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，每个 `Ref` 派生类都可以像在 ARC 之前 Objective-C 中管理事物一样进行管理——使用 `retain` 计数和 `autorelease`
    池。
- en: C++, however, comes packed with its own wonderful dynamic list classes, similar
    to the ones you would find in Java and C#. But for `Ref` derived objects, you
    would probably be best served by Cocos2d-x managed lists, or else remember to
    retain and release each object when applicable. If you create a class which does
    not extend `Ref` and you need to store instances of this class in a list container,
    then choose the standard library ones.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++自带了许多自己非常棒的动态列表类，类似于你在Java和C#中找到的类。但对于`Ref`派生对象，你可能最好使用Cocos2d-x管理的列表，或者记得在适用的情况下保留和释放每个对象。如果你创建了一个不扩展`Ref`的类，并且需要将这个类的实例存储在列表容器中，那么请选择标准库中的那些。
- en: In the examples that follow in this book I will code primarily from within the
    framework, so you will get to see plenty of examples of `cocos2d::Vector` being
    used, for instance, but I will also use a `std::vector` instance or two in some
    of the games.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书接下来的示例中，我将主要在框架内部进行编码，因此你们将有机会看到许多`cocos2d::Vector`的使用示例，例如，但我也将在一些游戏中使用一个或两个`std::vector`实例。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hopefully, non-C++ developers have now learned that there is nothing to be feared
    from the language, and hardcore C++ developers have not scoffed too much at the
    notion of a root class and its retains and autoreleases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 希望非C++开发者现在已经了解到这个语言没有什么可怕的地方，而核心C++开发者也没有对根类及其保留和自动释放的概念嘲笑得太多。
- en: All the stuff that root classes have brought to languages such as Java and Objective-C
    will forever be a moot point. The creepy, underlying operations that go on behind
    your back with root objects cannot be shut down or controlled. They are not optional,
    and this forceful nature of root objects has bothered C++ developers ever since
    notions such as garbage collectors first surfaced.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有根类为Java和Objective-C等语言带来的东西将永远是一个无意义的问题。那些在你背后进行的令人毛骨悚然的底层操作无法关闭或控制。它们不是可选的，而根对象这种强制性质自从垃圾收集器等概念首次出现以来就一直困扰着C++开发者。
- en: Having said that, memory management of `Ref` objects is extremely helpful and
    I hope even the most distrustful developers will soon learn to be thankful for
    it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`Ref`对象的内存管理非常有帮助，我希望即使是那些最不信任的开发者也会很快学会对此表示感谢。
- en: Furthermore, Cocos2d-x is awesome. So let's create a game already!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Cocos2d-x非常出色。那么，让我们现在就创建一个游戏吧！
