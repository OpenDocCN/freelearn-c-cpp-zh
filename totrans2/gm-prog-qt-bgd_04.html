<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Qt Core Essentials</h1></div></div></div><div><blockquote class="blockquote"><p><em>This chapter will help you master Qt ways of basic data processing and storage. First of all, you will learn how to handle textual data and how to match text against regular expressions. Then, you will see how to store and fetch data from files and how to use different storage formats for text and binary data. By the end of this chapter, you will be able to implement non-trivial logic and data processing in your games efficiently. You will also know how to load external data in your games and how to save your own data in permanent storage for future use.</em></p></blockquote></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Text handling</h1></div></div></div><p>Applications with a <a id="id154" class="indexterm"/>graphical user interface (and games surely fall into this category) are able to interact with users by displaying text and by expecting textual input from the user. We have already scratched the surface of this topic in the previous chapter by using the <code class="literal">QString</code> class. Now, we will go into more details.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Manipulating strings</h2></div></div></div><p>Text in Qt is <a id="id155" class="indexterm"/>internally encoded using Unicode, which allows to <a id="id156" class="indexterm"/>represent characters in almost all languages spoken in the world and is de facto standard for native encoding of text in most modern operating systems. You have to be aware though that contrary to the <code class="literal">QString</code> class, the C++ language does not use Unicode by default. Thus, each string literal (that is, each bare text you wrap in quotation marks) that you enter in your code needs to be converted to Unicode first before it can be stored in any of Qt's string handling classes. By default, this is done implicitly assuming that the string literal is UTF-8 encoded, but <code class="literal">QString</code> provides a number of static methods to convert from other encodings such as <code class="literal">QString::fromLatin1()</code> or <code class="literal">QString::fromUtf16()</code>. This conversion is done at runtime, which adds an overhead to the program execution time, especially if you tend to do a lot of such conversions in your programs. Luckily, there is a solution for this:</p><div><pre class="programlisting">QString str = QStringLiteral("I'm writing my games using Qt");</pre></div><p>You can wrap your string literal in a call to <code class="literal">QStringLiteral</code>, as shown in the preceding code, which if your compiler supports, will perform the conversion at compile time. It's a good habit to wrap all your string literals into <code class="literal">QStringLiteral</code> but it is not required, so don't worry if you forget to do that.</p><p>We will not <a id="id157" class="indexterm"/>go into great detail here when describing the <code class="literal">QString</code> class, as in many aspects it is similar to <code class="literal">std::string</code>, which is part of the standard <a id="id158" class="indexterm"/>C++. Instead, we will focus on the differences between the two classes.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Encoding and decoding text</h3></div></div></div><p>The first <a id="id159" class="indexterm"/>difference has already been mentioned—<code class="literal">QString</code> keeps the data encoded as <a id="id160" class="indexterm"/>Unicode. This has the advantage of being able to express text in virtually any language at the cost of having to convert from other encodings. Most popular encodings—UTF-8, UTF-16, and Latin1—have convenience methods in <code class="literal">QString</code> for converting from and to the internal representation. But, Qt knows how to handle many other encodings as well. This is done using the <code class="literal">QTextCodec</code> class.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>You can list the codecs supported on your installation by using the <code class="literal">QTextCodec::availableCodecs()</code>static method. In most installations, Qt can handle almost 1,000 different text codecs.</p></div></div><p>Most Qt entities that handle text can access instances of this class to transparently perform the conversion. If you want to perform such conversion manually, you can ask Qt for an instance of a codec by its name and make use of the <code class="literal">fromUnicode()</code> and <code class="literal">toUnicode()</code> methods:</p><div><pre class="programlisting">QByteArray big5Encoded = "你好";
QTextCodec *big5Codec = QTextCodec::codecForName("Big5");
QString text = big5Codec-&gt;toUnicode(big5Encoded);
QTextCodec *utf8Codec = QTextCodec::codecForMib(106); // UTF-8
QByteArray utf8Encoded = utf8Codec-&gt;fromUnicode(text);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Basic string operations</h3></div></div></div><p>The most <a id="id161" class="indexterm"/>basic tasks that involve text strings are those where <a id="id162" class="indexterm"/>you add or remove characters from the string, concatenate strings, and access the string's content. In this regard, <code class="literal">QString</code> offers an interface that is compatible with <code class="literal">std::string</code>, but it also goes beyond that, exposing many more useful methods.</p><p>Adding data at the beginning or at the end of the string can be done using the <code class="literal">prepend()</code> and <code class="literal">append()</code> methods, which have a couple of overloads that accept different objects that can hold textual data, including the classic <code class="literal">const char*</code> array. Inserting data in the middle of a string can be done with the <code class="literal">insert()</code> method that takes the position of the character where we need to start inserting as its first argument and the actual text as its second argument. The <code class="literal">insert</code> method has exactly the same overloads as <code class="literal">prepend</code> and <code class="literal">append</code>, excluding <code class="literal">const char*</code>. Removing characters from a string is similar. The basic way to do this is to use the <code class="literal">remove()</code> method that accepts the position at which we need to delete characters and the number of characters to delete is as shown:</p><div><pre class="programlisting">QString str = QStringLiteral("abcdefghij");
str.remove(2, 4); // str = "abghij"</pre></div><p>There is also a <a id="id163" class="indexterm"/>remove overload that accepts another string. When <a id="id164" class="indexterm"/>called, all its occurrences are removed from the original string. This overload has an optional argument that states whether comparison should be done in the default case-sensitive (<code class="literal">Qt::CaseSensitive</code>) or case-insensitive (<code class="literal">Qt::CaseInsensitive</code>) way:</p><div><pre class="programlisting">QString str = QStringLiteral("Abracadabra");
str.remove(QStringLiteral("ab"), Qt::CaseInsensitive); // str = "racadra"</pre></div><p>To concatenate strings, you can either simply add two strings together or you can append one string to the other:</p><div><pre class="programlisting">QString str1 = QStringLiteral("abc");
QString str2 = QStringLiteral("def");
QString str1_2 = str1+str2;
QString str2_1 = str2;
str2_1.append(str1);</pre></div><p>Accessing strings can be divided into two use cases. The first is when you wish to extract a part of the string. For this, you can use one of these three methods: <code class="literal">left()</code>, <code class="literal">right()</code>, and <code class="literal">mid()</code> that return the given number of characters from the beginning or end of the string or extract a substring of a specified length, starting from a given position in the string:</p><div><pre class="programlisting">QString original = QStringLiteral("abcdefghij");
QString l = original.left(3); // "abc"
QString r = original.right(2); // "ij"
QString m = original.mid(2, 5); // "cdefg"</pre></div><p>The second use case is when you wish to access a single character of the string. The use of the index operator works with <code class="literal">QString</code> in a similar fashion as with <code class="literal">std::string</code>, returning a copy or non-const reference to a given character that is represented by the <code class="literal">QChar</code> class, as shown in the following code:</p><div><pre class="programlisting">QString str = "foo";
QChar f = str[0]; // const
str[0] = 'g'; // non-const</pre></div><p>In addition to this, Qt <a id="id165" class="indexterm"/>offers a dedicated method—<code class="literal">at()</code>—that returns a <a id="id166" class="indexterm"/>copy of the character:</p><div><pre class="programlisting">QChar f = str.at(0);</pre></div><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>You should prefer to use <code class="literal">at()</code> instead of the index operator for operations that do not modify the character, as this explicitly sets the operation.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>The string search and lookup</h3></div></div></div><p>The second <a id="id167" class="indexterm"/>group of functionality is related to searching for the string. You can use methods such as <code class="literal">startsWith()</code>, <code class="literal">endsWith()</code>, and <code class="literal">contains()</code> to search for substrings in the beginning or end or in an arbitrary place in the string. The number of occurrences of a substring in the string can be retrieved by using the <code class="literal">count()</code> method.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>Be careful, there is also a <code class="literal">count()</code> method that doesn't take any parameters and returns the number of characters in the string.</p></div></div><p>If you need to know the exact position of the match, you can use <code class="literal">indexOf()</code> or <code class="literal">lastIndexOf()</code> to receive the position in the string where the match occurs. The first call works by searching forward and the other one searches backwards. Each of these calls takes two optional parameters—the second one determines whether the search is case-sensitive (similar to how <code class="literal">remove</code> works). The first one is the position in the string where the search begins. It lets you find all the occurrences of a given substring:</p><div><pre class="programlisting">#include &lt;QtDebug&gt;
// ...
int pos = -1;
QString str = QStringLiteral("Orangutans like bananas.");
do {
  pos = str.indexOf("an", pos+1);
  qDebug() &lt;&lt; "'an' found starts at position" &lt;&lt; pos;
} while(pos!=-1);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Dissecting strings</h3></div></div></div><p>There is one <a id="id168" class="indexterm"/>more group of useful string functionalities that makes <code class="literal">QString</code> different from <code class="literal">std::string</code>. That is, cutting strings into smaller parts and building larger strings from smaller pieces.</p><p>Very often, a string contains substrings that are glued together by a repeating separator. A common case is <a id="id169" class="indexterm"/>the <strong>Comma-separated Values</strong> (<strong>CSV</strong>) format where a data record is encoded in a single string where fields in the record are separated by commas. While you could extract each field from the record using functions that you already know (for example, <code class="literal">indexOf</code>), an easier way exists. <code class="literal">QString</code> contains a <code class="literal">split()</code> method that takes the separator string as its parameter and returns a list of strings that are represented in Qt by the <code class="literal">QStringList</code> class. Then, dissecting the record into separate fields is as easy as calling the following code:</p><div><pre class="programlisting">QString record = "1,4,8,15,16,24,42";
QStringList fields = record.split(",");
for(int i=0; i&lt; fields.count(); ++i){
  qDebug() &lt;&lt; fields.at(i);
}</pre></div><p>The inverse of this method is the <code class="literal">join()</code> method present in the <code class="literal">QStringList</code> class, which returns all the items in the list as a single string merged together with a given separator:</p><div><pre class="programlisting">QStringList fields = { "1", "4", "8", "15", "16", "24", "42" }; // C++11 syntax!
QString record = fields.join(",");</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Converting between numbers and strings</h3></div></div></div><p>
<code class="literal">QString</code> also <a id="id170" class="indexterm"/>provides some methods for convenient conversion between textual and numerical values. Methods such as <code class="literal">toInt()</code>, <code class="literal">toDouble()</code>, or <code class="literal">toLongLong()</code> make it easy to extract numerical values from strings. Apart from <code class="literal">toDouble()</code>, they all take two optional parameters—the first one is a pointer to a <code class="literal">bool</code> variable that is set to <code class="literal">true</code> or <code class="literal">false</code> depending on whether the conversion was successful or not. The second parameter specifies the numerical base (for example, binary, octal, decimal, or hexadecimal) of the value. The <code class="literal">toDouble()</code> method only takes a <code class="literal">bool</code> pointer to mark the success or failure as shown in the following code:</p><div><pre class="programlisting">bool ok;
int v1 = QString("42").toInt(&amp;ok, 10); // v1 = 42, ok = true
long long v2 = QString("0xFFFFFF").toInt(&amp;ok, 16); // v2 = 16777215, ok = true
double v3 = QString("not really a number").toDouble(&amp;ok); //v3 = 0.0, ok = false</pre></div><p>A static method called <code class="literal">number()</code> performs the conversion in the other direction—it takes a numerical value and number base and returns the textual representation of the value:</p><div><pre class="programlisting">QString txt = QString::number(255, 16); // txt = "0xFF"</pre></div><p>If you have to combine both <code class="literal">QString</code> and <code class="literal">std::string</code> in one program, <code class="literal">QString</code> offers you the <code class="literal">toStdString()</code> and <code class="literal">fromStdString()</code> methods to perform an adequate conversion.</p><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>Some of the <a id="id171" class="indexterm"/>other classes that represent values also provide conversions to and from <code class="literal">QString</code>. An example of such a class is <code class="literal">QDate</code>, which represents a date and provides the <code class="literal">fromString()</code> and <code class="literal">toString()</code> methods.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec15"/>Using arguments in strings</h3></div></div></div><p>A common task is to <a id="id172" class="indexterm"/>have a string that needs to be dynamic in such a way that its content depends on the value of some external variable—for instance, you would like to inform the user about the number of files being copied, showing "copying file 1 of 2" or "copying file 2 of 5" depending on the value of counters that denote the current file and total number of files. It might be tempting to do this by assembling all the pieces together using one of the available approaches:</p><div><pre class="programlisting">QString str = "Copying file " + QString::number(current) + " of "+QString::number(total);</pre></div><p>There are a number of drawbacks to such an approach; the biggest of them is the problem of translating the string into other languages (this will be discussed later in this chapter) where in different languages their grammar might require the two arguments to be positioned differently than in English.</p><p>Instead, Qt allows us to specify positional parameters in strings and then replace them with real values. Positions in the string are marked with the <code class="literal">%</code> sign (for example, <code class="literal">%1</code>, <code class="literal">%2</code>, and so on) and they are replaced by making a call to <code class="literal">arg()</code> and passing it the value that is used to replace the next lowest marker in the string. Our file copy message construction code then becomes:</p><div><pre class="programlisting">QString str = QStringLiteral("Copying file %1 of %2")
                                             .arg(current).arg(total);</pre></div><p>The <code class="literal">arg</code> method can accept single characters, strings, integers, and real numbers and its syntax is similar to that of <code class="literal">QString::number()</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Regular expressions</h2></div></div></div><p>Let's briefly talk about <a id="id173" class="indexterm"/>
<strong>regular expressions</strong>—usually shortened as <strong>regex</strong> or <strong>regexp</strong>. You will need these regular expressions whenever you have to check whether a string or parts of it matches a given pattern or when you want to find specific parts inside the text and possibly want to extract them. Both the validity check and the finding/extraction are based on the so-called pattern of the regular expression, which describes the format a string must have to be valid, to be found, or to be extracted. Since this book is focused on Qt, there is unfortunately no time to cover regular expressions in depth. This is not a huge problem, however, since you can find plenty of good websites that provide introductions to regular expressions on the Internet. A short introduction can be found in Qt's documentation of <code class="literal">QRegExp</code> as well.</p><p>Even though there are many flavors of the regular expression's syntax, the one that Perl uses has become the <em>de facto</em> standard. According to <code class="literal">QRegularExpression</code>, Qt offers Perl-compatible regular <a id="id174" class="indexterm"/>expressions.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>
<code class="literal">QRegularExpression</code> was first introduced with Qt 5. In the previous versions, you'll find the older <code class="literal">QRegExp</code> class. Since <code class="literal">QRegularExpression</code> is closer to the Perl standard and since its execution speed is much faster compared to <code class="literal">QRegExp</code>, we advise you to use <code class="literal">QRegularExpression</code> whenever possible. Nevertheless, you can read the <code class="literal">QRegExp</code> documentation about the general introduction of regular expressions.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Time for action – a simple quiz game</h1></div></div></div><p>To introduce <a id="id175" class="indexterm"/>you to the main usage of <code class="literal">QRegularExpression</code>, let's imagine this game: a photo, showing an object, is shown to multiple players and each of them has to estimate the object's weight. The player whose estimate is closest to the actual weight wins. The estimates will be submitted via <code class="literal">QLineEdit</code>. Since you can write anything in a line edit, we have to make sure that the content is valid.</p><p>So what does valid mean? In this example, we define that a value between 1 g and 999 kg is valid. Knowing this specification, we can construct a regular expression that will verify the format. The first part of the text is a number, which can be between 1 and 999. Thus, the corresponding pattern looks like <code class="literal">[1-9][0-9]{0,2}</code>, where <code class="literal">[1-9]</code> allows—and demands—exactly one digit, except zero, which is optionally followed by up to two digits including zero. This is expressed through <code class="literal">[0-9]{0,2}</code>. The last part of the input is the weight's unit. With a pattern such as <code class="literal">(mg|g|kg)</code>, we allow the weight to be input in <strong>milligrams</strong> (<strong>mg</strong>), <strong>grams</strong> (<strong>g</strong>), or <strong>kilograms</strong> (<strong>kg</strong>). With <code class="literal">[ ]?</code>, we finally allow an optional space between the number and unit. Combined together, the pattern and construction of the related <code class="literal">QRegularExpression</code> object looks like this:</p><div><pre class="programlisting">QRegularExpression regex("[1-9][0-9]{0,2}[ ]? (mg|g|kg)");
regex.setPatternOptions(QRegularExpression:: CaseInsensitiveOption);</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>
<em>What just happened?</em>
</h2></div></div></div><p>In the first line, we constructed the aforementioned <code class="literal">QRegularExpression</code> object while passing the regular expression's pattern as a parameter to the constructor. We also could have called <code class="literal">setPattern()</code> to set the pattern:</p><div><pre class="programlisting">QRegularExpression regex;
regex.setPattern("[1-9][0-9]{0,2}[ ]?(mg|g|kg)");</pre></div><p>Both the approaches are equivalent. If you have a closer look at the unit, you can see that right now, the unit is only allowed to be entered in lowercase. We want, however, to also allow it to be in uppercase or mixed case. To achieve this, we can of course write <code class="literal">(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)</code>. Not only is this a hell of a work when you have more units, this is also very error-prone, and so we opt for a cleaner and more readable solution. On the second line of the initial code example, you see the answer: a pattern option. We used <code class="literal">setPatternOptions()</code> to set the <code class="literal">QRegularExpression::CaseInsensitiveOption</code> option, which does not respect the case of the characters used. Of course, there are a few more options that you can read about in Qt's documentation on <code class="literal">QRegularExpression::PatternOption</code>. Instead of calling <code class="literal">setPatternOptions()</code>, we could have also passed the option as a second parameter to the constructor of <code class="literal">QRegularExpression</code>:</p><div><pre class="programlisting">QRegularExpression regex("[1-9][0-9]{0,2}[ ]?(mg|g|kg)",
           QRegularExpression::CaseInsensitiveOption);</pre></div><p>Now, let's see how to use this expression to verify the validity of a string. For the sake of simplicity and better illustration, we simply declared a string called <code class="literal">input</code>:</p><div><pre class="programlisting">QString input = "23kg";
QRegularExpressionMatch match = regex.match(input);
bool isValid = match.hasMatch();</pre></div><p>All we have to do is call <code class="literal">match()</code>, passing the string we would like to check against it. In return, we get an <a id="id176" class="indexterm"/>object of the <code class="literal">QRegularExpressionMatch</code> type that contains all the information that is further needed—and not only to check the validity. With <code class="literal">QRegularExpressionMatch::hasMatch()</code>, we then can determine whether the input matches our criteria, as it returns <code class="literal">true</code> if the pattern could be found. Otherwise, of course, <code class="literal">false</code> is returned.</p><p>Attentive readers surely will have noticed that our pattern is not quite finished. The <code class="literal">hasMatch()</code> method would also return <code class="literal">true</code> if we matched it against "foo 142g bar". So, we have to define that the pattern is checked from the beginning to the end of the matched string. This is done by the <code class="literal">\A</code> and <code class="literal">\z</code> anchors. The former marks the start of a string and the latter the end of a string. Don't forget to escape the slashes when you use such anchors. The correct pattern would then look as follows:</p><div><pre class="programlisting">QRegularExpression regex("\\A[1-9][0-9]{0,2}[ ]?(mg|g|kg)\\z",
           QRegularExpression::CaseInsensitiveOption);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Extracting information out of a string</h2></div></div></div><p>After we have <a id="id177" class="indexterm"/>checked that the sent guess is well formed, we have to extract the actual weight from the string. In order to be able to easily compare the different guesses, we further need to transform all values to a common reference unit. In this case, it should be a milligram, the lowest unit. So, let's see what <code class="literal">QRegularExpressionMatch</code> can offer us for this task.</p><p>With <code class="literal">capturedTexts()</code>, we get a string list of the pattern's captured groups. In our example, this list would contain "23kg" and "kg". The first element is always the string that was fully matched by the pattern followed by all the sub strings captured by the used brackets. Since we are missing the actual number, we have to alter the pattern's beginning to <code class="literal">([1-9][0-9]{0,2})</code>. Now, the list's second element is the number and the third element is the unit. Thus, we can write the following:</p><div><pre class="programlisting">int getWeight(const QString &amp;input) {
  QRegularExpression regex("\\A([1-9][0-9]{0,2}) [ ]?(mg|g|kg)\\z");
  regex.setPatternOptions(QRegularExpression:: CaseInsensitiveOption);
  QRegularExpressionMatch match = regex.match(input);
  if(match.hasMatch()) {
    const QString number = match.captured(1);
    int weight = number.toInt();
    const QString unit = match.captured(2).toLower();
    if (unit == "g") {
      weight *= 1000;
    } else if (unit == "kg") {
      weight *= 1000000 ;
    }
    return weight;
  } else {
    return -1;
  }
}</pre></div><p>In the function's first two lines, we set up the pattern and its option. Then, we match it against the passed argument. If <code class="literal">QRegularExpressionMatch::hasMatch()</code> returns <code class="literal">true</code>, the input is valid and we extract the number and unit. Instead of fetching the entire list of captured text with <code class="literal">capturedTexts()</code>, we query specific elements directly by calling <code class="literal">QRegularExpressionMatch::captured()</code>. The passed integer argument signifies the element's position inside the list. So, calling <code class="literal">captured(1)</code> returns the matched digits as a <code class="literal">QString</code>.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>
<code class="literal">QRegularExpressionMatch::captured()</code> also takes <code class="literal">QString</code> as the argument's type. This is useful if you have used named groups inside the pattern, for example, if you have written <code class="literal">(?&lt;number&gt;[1-9][0-9]{0,2})</code>, then you can get the digits by calling <code class="literal">match.captured("number")</code>. Named groups pay off if you have long patterns or when there is a high probability that further brackets will be added in future. Be aware that adding a group at a later time will shift the indices of all the following groups by <code class="literal">1</code> and you will have to adjust your code!</p></div></div><p>To be able to calculate using the extracted number, we need to convert <code class="literal">QString</code> into an integer. This is done by calling <code class="literal">QString::toInt()</code>. The result of this conversion is then stored in the <code class="literal">weight</code> variable. Next, we fetch the unit and transform it to lowercase characters on-the-fly. This way, we can, for example, easily determine whether the user's guess is expressed in grams by checking the unit against the lowercase "g". We do not need to take care of the capital "G" or the variants "KG", "Kg", and the unusual "kG" for kilogram.</p><p>To get the standardized <a id="id178" class="indexterm"/>weight in milligrams, we multiply <code class="literal">weight</code> by 1,000 or 1,000,000, depending on whether this was expressed in g or kg. Lastly, we return this standardized weight. If the string wasn't well formed, we return <code class="literal">-1</code> to indicate that the given guess was invalid. It is then the caller's duty to determinate which player's guess was the best.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Pay attention to whether your chosen integer type can handle the weight's value. For our example, 100,000,000 is the biggest possible value that can be held by a signed integer on a 32-bit system. If you are not sure whether your code will be compiled on a 32-bit system, use <code class="literal">qint32</code>, which is guaranteed to be a 32-bit integer on every system that Qt supports, allowing decimal notations.</p></div></div><p>As an exercise, try to extend the example by allowing decimal numbers so that 23.5g is a valid guess. To achieve this, you have to alter the pattern in order to enter decimal numbers and you also have to deal with <code class="literal">double</code> instead of <code class="literal">int</code> for the standardized weight.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Finding all pattern occurrences</h2></div></div></div><p>Lastly, let's have a <a id="id179" class="indexterm"/>final look at how to find, for example, all numbers inside a string, even those leading with zeros:</p><div><pre class="programlisting">QString input = "123 foo 09 1a 3";
QRegularExpression regex("\\b[0-9]+\\b");
QRegularExpressionMatchIterator i = regex.globalMatch(input);
while (i.hasNext()) {
  QRegularExpressionMatch match = i.next();
  qWarning() &lt;&lt; match.capturedTexts();
}</pre></div><p>The <code class="literal">input</code> QString instance contains an exemplary text in which we would like to find all numbers. The "foo" as well as "1a" variables should not be found by the pattern since these are not valid numbers. Therefore, we set up the pattern defining that we require at least one digit, <code class="literal">[0-9]+</code>, and that this digit—or these digits—should be wrapped by word boundaries, <code class="literal">\b</code>. Note that you have to escape the slash. With this pattern, we initiate the <code class="literal">QRegularExpression</code> object and call <code class="literal">globalMatch()</code> on it. Inside the passed argument, the pattern will be searched. This time, we do not get <code class="literal">QRegularExpressionMatch</code> back but, instead, an iterator of the <code class="literal">QRegularExpressionMatchIterator</code> type. Since <code class="literal">QRegularExpressionMatchIterator</code> behaves like a Java iterator, with <code class="literal">hasNext()</code>, we check whether there is a further match and if so we bring up the next match by calling <code class="literal">next()</code>. The type of the returned match is then <code class="literal">QRegularExpressionMatch</code>, which you already know.</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>If you need to know about the next match inside the <code class="literal">while</code> loop, you can use <code class="literal">QRegularExpressionMatchIterator::peekNext()</code> to receive it. The upside of this function is that it does not move the iterator.</p></div></div><p>This way, you can iterate all pattern occurrences in the string. This is helpful if you, for example, want to highlight a search string in text.</p><p>Our example would <a id="id180" class="indexterm"/>give the output: <code class="literal">("123"), ("09") and ("3")</code>.</p><p>Taking into account that this was just a brief introduction to regular expressions, we would like to encourage you to read the <em>Detailed Description</em> section in the documentation to <code class="literal">QRegularExpression</code>, <code class="literal">QRegularExpressionMatch</code>, and <code class="literal">QRegularExpressionMatchIterator</code>. Regular expressions are very powerful and useful, so, in your daily programming life, you can benefit from the profound knowledge of regular expressions!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Data storage</h1></div></div></div><p>When implementing <a id="id181" class="indexterm"/>games, you will often have to work with persistent data—you will need to store the saved game data, load maps, and so on. For that, you have to learn about the mechanisms that let you use the data stored on digital media.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Files and devices</h2></div></div></div><p>The most basic and <a id="id182" class="indexterm"/>low-level mechanism that is used to access data is to save and load it from the files. While you can use the classic file access approaches provided by C and C++, such as <code class="literal">stdio</code> or <code class="literal">iostream</code>, Qt provides its own wrapper over the file <a id="id183" class="indexterm"/>abstraction that hides platform-dependent details and provides a clean API that works across all platforms in a uniform manner.</p><p>The two basic classes that you will work with when using files are <code class="literal">QDir</code> and <code class="literal">QFile</code>. The former represents the contents of a directory, lets you traverse filesystems, creates and remove directories, and finally, access all files in a particular directory.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec16"/>Traversing directories</h3></div></div></div><p>Traversing <a id="id184" class="indexterm"/>directories with <code class="literal">QDir</code> is really easy. The first thing to do is to have an instance of <code class="literal">QDir</code> in the first place. The easiest way to do this is to pass the directory path to the <code class="literal">QDir</code> constructor.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>Qt handles file paths in a platform-independent way. Even though the regular directory separator on Windows is a backwards slash character (<code class="literal">\</code>) and on other platforms it is the forward slash (<code class="literal">/</code>), Qt accepts forward slash as a directory separator on Windows platforms as well. Therefore, you can always use <code class="literal">/</code> to separate directories when you pass paths to Qt functions.</p><p>You can learn the native directory separator for the current platform is by calling the <code class="literal">QDir::separator()</code>static function. You can transform between native and non-native separators with the <code class="literal">QDir::toNativeSeparators()</code> and <code class="literal">QDir::fromNativeSeparators()</code>functions.</p></div></div><p>Qt provides a number of static methods to access some special directories. The following table lists these special directories and functions that access them:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Access function</p>
</th><th style="text-align: left" valign="bottom">
<p>Directory</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::current()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The current working directory</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::home()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The home directory of the current user</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::root()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The root directory—usually <code class="literal">/</code> for Unix and <code class="literal">C:\</code> for Windows</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::temp()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The system temporary directory</p>
</td></tr></tbody></table></div><p>When you already have a valid <code class="literal">QDir</code> object, you can start moving between directories. To do that, you can use the <code class="literal">cd()</code> and <code class="literal">cdUp()</code> methods. The former moves to the named subdirectory, while the latter moves to the parent directory.</p><p>To list files and subdirectories in a particular directory, you can use the <code class="literal">entryList()</code> method, which returns a list of entries in the directory that match the criteria passed to <code class="literal">entryList()</code>. This method has two overloads. The basic version takes a list of flags that correspond to the different attributes that an entry needs to have to be included in the result and a set of flags that determine the order in which entries are included in the set. The other overload also accepts a list of file name patterns in the form of <code class="literal">QStringList</code> as its first parameter. The <a id="id185" class="indexterm"/>most commonly used filter and sort flags are listed as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="2" style="text-align: center" valign="bottom">
<p>Filter flags</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::Dirs, QDir::Files, QDir::Drives, QDir::AllEntries</code>
</p>
</td><td style="text-align: left" valign="top">
<p>List directories, files, drives (or all) that match the filters</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::AllDirs</code>
</p>
</td><td style="text-align: left" valign="top">
<p>List all subdirectories regardless of whether they match the filter or not</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::Readable, QDir::Writable, QDir::Executable</code>
</p>
</td><td style="text-align: left" valign="top">
<p>List entries that can be read, written, or executed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::Hidden, QDir::System</code>
</p>
</td><td style="text-align: left" valign="top">
<p>List hidden files and system files</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>Sort flags</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::Unsorted</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The order of entries is undefined</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::Name, QDir::Time, QDir::Size, QDir::Type</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sort by appropriate entry attributes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDir::DirsFirst, QDir::DirsLast</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Determines whether directories should be listed before or after files</p>
</td></tr></tbody></table></div><p>Here is an example call that returns all JPEG files in the user's <code class="literal">home</code> directory sorted by size:</p><div><pre class="programlisting">QDir dir = QDir::home();
QStringList nameFilters;
nameFilters &lt;&lt; QStringLiteral("*.jpg") &lt;&lt; QStringLiteral("*.jpeg");
QStringList entries = dir.entryList(nameFilters,
                      QDir::Files|QDir::Readable, QDir::Size);</pre></div><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>The <code class="literal">&lt;&lt;</code> operator is a nice and fast way to append entries to <code class="literal">QStringList</code>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Getting access to the basic file</h3></div></div></div><p>Once you <a id="id186" class="indexterm"/>know the path to a file (either by using <code class="literal">QDir::entryList()</code>, from some external source, or even by hardcoding the file path in code), you can pass it to <code class="literal">QFile</code> to receive an object that acts as a handle to the file. Before the file contents can be accessed, the file needs to be opened using the <code class="literal">open()</code> method. The basic variant of this method takes a mode in which we need to open the file. The following table explains the modes that are available:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mode</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ReadOnly</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This file can be read from</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">WriteOnly</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This file can be written to</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ReadWrite</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This file can be read from and written to</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Append</code>
</p>
</td><td style="text-align: left" valign="top">
<p>All data writes will be written at the end of the file</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Truncate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If the file is present, its content is deleted before we open it</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Text</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Native line endings are transformed to <code class="literal">\n</code> and back</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Unbuffered</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The flag prevents the file from being buffered by the system</p>
</td></tr></tbody></table></div><p>The <code class="literal">open()</code> method returns <code class="literal">true</code> or <code class="literal">false</code> depending on whether the file was opened or not. The current status of the file can be checked by calling <code class="literal">isOpen()</code> on the file object. Once the file is open, it can be read from or written to depending on the options that are passed when the file is opened. Reading and writing is done using the <code class="literal">read()</code> and <code class="literal">write()</code> methods. These methods have a number of overloads, but I suggest that you focus on using those variants that accept or return a <code class="literal">QByteArray</code> object, which is essentially a series of bytes—it can hold both textual and nontextual data. If you are working with plain text, then a useful overload for <code class="literal">write</code> is the one that accepts the text directly as input. Just remember that the text has to be null or terminated. When reading from a file, Qt offers a number of other methods that might come in handy in some situations. One of these methods is <code class="literal">readLine()</code>, which tries to read from the file until it encounters a new line character. If you use it together with the <code class="literal">atEnd()</code> method that tells you whether you have reached the end of the file, you can realize the line-by-line reading of a text file:</p><div><pre class="programlisting">QStringList lines;
while(!file.atEnd()) {
  QByteArray line = file.readLine();
  lines.append(QString::fromUtf8(line));
}</pre></div><p>Another useful method is <code class="literal">readAll()</code>, which simply returns the file content, starting from the current position of the file pointer until the end of the file.</p><p>You have to remember though that when using these helper methods, you should be really careful if you don't know how much data the file contains. It might happen that when reading line by line or trying to read the whole file into memory in one step, you exhaust the amount of memory that is available for your process (you can check the size of the file by calling <code class="literal">size()</code> on the <code class="literal">QFile</code> instance). Instead, you should process the file's data in steps, reading only as much as you require at a time. This makes the code more complex but allows us to better manage the available resources. If you require constant access to some part of the file, you can use the <code class="literal">map()</code> and <code class="literal">unmap()</code> calls that add and remove mappings <a id="id187" class="indexterm"/>of the parts of a file to a memory address that you can then use like a regular array of bytes:</p><div><pre class="programlisting">QFile f("myfile");
if(!f.open(QFile::ReadWrite)) return;
uchar *addr = f.map(0, f.size());
if(!addr) return;
f.close();
doSomeComplexOperationOn(addr);
f.unmap(addr);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec18"/>Devices</h3></div></div></div><p>
<code class="literal">QFile</code> is really a <a id="id188" class="indexterm"/>descendant class of <code class="literal">QIODevice</code>, which is a Qt interface that is used to abstract entities related to reading and writing. There are two types of devices: sequential and random access devices. <code class="literal">QFile</code> belongs to the latter group—it has the concepts of start, end, size, and current position that can be changed by the user with the <code class="literal">seek()</code> method. Sequential devices, such as sockets and pipes, represent streams of data—there is no way to rewind the stream or check its size; you can only keep reading the data sequentially—piece by piece, and you can check how far away you currently are from the end of data.</p><p>All I/O devices can be opened and closed. They all implement <code class="literal">open()</code>, <code class="literal">read()</code>, and <code class="literal">write()</code> interfaces. Writing to the device queues the data for writing; when the data is actually written, the <code class="literal">bytesWritten()</code> signal is emitted that carries the amount of data that was written to the device. If more data becomes available in the sequential device, it emits the <code class="literal">readyRead()</code> signal, which informs you that if you call <code class="literal">read</code> now, you can expect to receive some data from the device.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Time for action – implementing a device to encrypt data</h1></div></div></div><p>Let's <a id="id189" class="indexterm"/>implement a really simple device that encrypts or decrypts the data that is streamed through it using a very simple algorithm—the Caesar cipher. What it does is that when encrypting, it shifts each character in the plaintext by a number of characters defined by the key and does the reverse when decrypting. Thus, if the key is <code class="literal">2</code> and the plaintext character is <code class="literal">a</code>, the ciphertext becomes <code class="literal">c</code>. Decrypting <code class="literal">z</code> with the key <code class="literal">4</code> will yield the value <code class="literal">v</code>.</p><p>We will start by creating a new empty project and adding a class derived from <code class="literal">QIODevice</code>. The basic interface of the class is going to accept an integer key and set an underlying device that serves as the source or destination of data. This is all simple coding that you should already understand, so it shouldn't need any extra explanation, as shown:</p><div><pre class="programlisting">class CaesarCipherDevice : public QIODevice
{
    Q_OBJECT
    Q_PROPERTY(int key READ key WRITE setKey)
public:
    explicit CaesarCipherDevice(QObject *parent = 0) : QIODevice(parent) {
      m_key = 0;
      m_device = 0;
    }
    void setBaseDevice(QIODevice *dev) { m_device = dev; }
    QIODevice *baseDevice() const { return m_device; }
    void setKey(int k) { m_key = k; }
    inline int key() const { return m_key; }
private:
    int m_key;
    QIODevice *m_device;
};</pre></div><p>The next thing <a id="id190" class="indexterm"/>is to make sure that the device cannot be used if there is no device to operate on (that is, when <code class="literal">m_device == 0</code>). For this, we have to reimplement the <code class="literal">QIODevice::open()</code> method and return <code class="literal">false</code> when we want to prevent operating on our device:</p><div><pre class="programlisting">bool open(OpenMode mode) {
  if(!baseDevice())
    return false;
  if(baseDevice()-&gt;openMode() != mode)
    return false;
  return QIODevice::open(mode);
}</pre></div><p>The method accepts the mode that the user wants to open the device with. We perform an additional check to verify that the base device was opened in the same mode before calling the base class implementation that will mark the device as open.</p><p>To have a fully functional device, we still need to implement the two protected pure virtual methods, which do the actual reading and writing. These methods are called by Qt from other methods of the class when needed. Let's start with <code class="literal">writeData()</code>, which accepts a pointer to a buffer containing the data and size of that a buffer:</p><div><pre class="programlisting">qint64 CaesarCipherDevice::writeData(const char *data, qint64 len) {
    QByteArray ba(data, len);
    for(int i=0;i&lt;len;++i)
      ba.data()[i] += m_key;
    int written = m_device-&gt;write(ba);
    emit bytesWritten(written);
    return written;
}</pre></div><p>First, we copy the data into a local byte array. Then, we iterate the array, adding to each byte the value of the key (which effectively performs the encryption). Finally, we try to write the byte array to the underlying device. Before informing the caller about the amount of data that was really written, we emit a signal that carries the same information.</p><p>The last method that we need to implement is the one that performs decryption by reading from the <a id="id191" class="indexterm"/>base device and adding the key to each cell of the data. This is done by implementing <code class="literal">readData()</code>, which accepts a pointer to the buffer that the method needs to write to and the size of the buffer. The code is quite similar to that of <code class="literal">writeData()</code> except that we are subtracting the key value instead of adding it:</p><div><pre class="programlisting">qint64 CaesarCipherDevice::readData(char *data, qint64 maxlen) {
  QByteArray baseData = m_device-&gt;read(maxlen);
  const int s = baseData.size();  for(int i=0;i&lt;s;++i)
    data[i] = baseData[i]-m_key;
  return s;
}</pre></div><p>First, we read from the underlying device as much as we can fit into the buffer and store the data in a byte array. Then, we iterate the array and set subsequent bytes of data buffer to the decrypted value. Finally, we return the amount of data that was really read.</p><p>A simple <code class="literal">main()</code> function that can test the class looks as follows:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QByteArray ba = "plaintext";
  QBuffer buf;
  buf.open(QIODevice::WriteOnly);
  CaesarCipherDevice encrypt;
  encrypt.setKey(3);
  encrypt.setBaseDevice(&amp;buf);
  encrypt.open(buf.openMode());
  encrypt.write(ba);
  qDebug() &lt;&lt; buf.data();

  CaesarCipherDevice decrypt;
  decrypt.setKey(3);
  decrypt.setBaseDevice(&amp;buf);
  buf.open(QIODevice::ReadOnly);
  decrypt.open(buf.openMode());
  qDebug() &lt;&lt; decrypt.readAll();
  return 0;
}</pre></div><p>We use the <code class="literal">QBuffer</code> class that implements the <code class="literal">QIODevice</code> API and acts as an adapter for <code class="literal">QByteArray</code> or <code class="literal">QString</code>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created an encryption object and set its key to <code class="literal">3</code>. We also told it to use a <code class="literal">QBuffer</code> instance to store the <a id="id192" class="indexterm"/>processed content. After opening it for writing, we sent some data to it that gets encrypted and written to the base device. Then, we created a similar device, passing the same buffer again as the base device, but now, we open the device for reading. This means that the base device contains ciphertext. After this, we read all data from the device, which results in reading data from the buffer, decrypting it, and returning the data so that it can be written to the debug console.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Have a go hero – a GUI for the Caesar cipher</h2></div></div></div><p>You can <a id="id193" class="indexterm"/>combine what you already know by implementing a full-blown GUI application that is able to encrypt or decrypt files using the Caesar cipher <code class="literal">QIODevice</code> class that we just implemented. Remember that <code class="literal">QFile</code> is also <code class="literal">QIODevice</code>, so you can pass its pointer directly to <code class="literal">setBaseDevice()</code>.</p><p>This is just a starting point for you. The <code class="literal">QIODevice</code> API is quite rich and contains numerous methods that are virtual, so you can reimplement them in subclasses.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Text streams</h2></div></div></div><p>Much of the data <a id="id194" class="indexterm"/>produced by computers nowadays is based on text. You can create such files using a mechanism that you already know—opening <code class="literal">QFile</code> to write, converting all data into strings using <code class="literal">QString::arg()</code>, optionally encoding strings using <code class="literal">QTextCodec</code>, and dumping the resulting bytes to the file by calling <code class="literal">write</code>. However, Qt provides a nice mechanism that does most of this automatically for you in a way similar to how the standard C++ <code class="literal">iostream</code> classes work. The <code class="literal">QTextStream</code> class operates on any <code class="literal">QIODevice</code> API in a stream-oriented way. You can send tokens to the stream using the <code class="literal">&lt;&lt;</code> operator, where they get converted into strings, separated by spaces, encoded using a codec of your choice, and written to the underlying device. It also works the other way round; using the <code class="literal">&gt;&gt;</code> operator, you can stream data from a text file, transparently converting it from strings to appropriate variable types. If the conversion fails, you can discover it by inspecting the result of the <code class="literal">status()</code> method—if you get <code class="literal">ReadPastEnd</code> or <code class="literal">ReadCorruptData</code>, then this means that the read has failed.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>While <code class="literal">QIODevice</code> is the main class that <code class="literal">QTextStream</code> operates on, it can also manipulate <code class="literal">QString</code> or <code class="literal">QByteArray</code>, which makes it useful for us to compose or parse strings.</p></div></div><p>Using <code class="literal">QTextStream</code> is simple—you just have to pass it the device that you want it to operate on and you're good to go. The stream accepts strings and numerical values:</p><div><pre class="programlisting">QFile file("output.txt");
file.open(QFile::WriteOnly|QFile::Text);
QTextStream stream(&amp;file);
stream &lt;&lt; "Today is " &lt;&lt; QDate::currentDate().toString() &lt;&lt; endl;
QTime t = QTime::currentTime();
stream &lt;&lt; "Current time is " &lt;&lt; t.hour() &lt;&lt; " h and " &lt;&lt; t.minute() &lt;&lt; "m." &lt;&lt; endl;</pre></div><p>Apart from directing <a id="id195" class="indexterm"/>content into the stream, the stream can accept a number of manipulators, such as <code class="literal">endl</code>, which have a direct or indirect influence on how the stream behaves. For instance, you can tell the stream to display a number as decimal and another as hexadecimal with uppercase digits using the following code (highlighted in the code are all manipulators):</p><div><pre class="programlisting">for(int i=0;i&lt;10;++i) {
  int num = qrand() % 100000;  // random number between 0 and 99999
  stream &lt;&lt; <strong>dec</strong> &lt;&lt; num &lt;&lt; <strong>showbase</strong> &lt;&lt; <strong>hex</strong> &lt;&lt; <strong>uppercasedigits</strong> &lt;&lt; num &lt;&lt; <strong>endl</strong>;
}</pre></div><p>This is not the end of the capabilities of <code class="literal">QTextStream</code>. It also allows us to display data in a tabular manner by defining column widths and alignments. Suppose that you have a set of records for game players that is defined by the following structure:</p><div><pre class="programlisting">struct Player {
  QString name;
  qint64 experience;
  QPoint position;
  char direction;
};
QList&lt;Player&gt; players;</pre></div><p>Let's dump such info into a file in a tabular manner:</p><div><pre class="programlisting">QFile file("players.txt");
file.open(QFile::WriteOnly|QFile::Text);
QTextStream stream(&amp;file);
stream &lt;&lt; center;
stream &lt;&lt; qSetFieldWidth(16) &lt;&lt; "Player" &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
stream &lt;&lt; qSetFieldWidth(10) &lt;&lt; "Experience" &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
stream &lt;&lt; qSetFieldWidth(13) &lt;&lt; "Position" &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
stream &lt;&lt; "Direction" &lt;&lt; endl;
for(int i=0;i&lt;players.size();++i) {
  const Player &amp;p = players.at(i);
  stream &lt;&lt; left &lt;&lt; qSetFieldWidth(16) &lt;&lt; p.name &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
  stream &lt;&lt; right &lt;&lt; qSetFieldWidth(10) &lt;&lt; p.experience &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
  stream &lt;&lt; right &lt;&lt; qSetFieldWidth(6) &lt;&lt; p.position.x() &lt;&lt; qSetFieldWidth(0) &lt;&lt; " " &lt;&lt; qSetFieldWidth(6) &lt;&lt; p.position.y() &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
  stream &lt;&lt; center &lt;&lt; qSetFieldWidth(10);
  switch(p.direction) {
    case 'n' : stream &lt;&lt; "north"; break;
    case 's' : stream &lt;&lt; "south"; break;
    case 'e' : stream &lt;&lt; "east"; break;
    case 'w' : stream &lt;&lt; "west"; break;
    default: stream &lt;&lt; "unknown"; break;
  }
  stream &lt;&lt; qSetFieldWidth(0) &lt;&lt; endl;
}</pre></div><p>After running the <a id="id196" class="indexterm"/>program, you should get a result similar to the one shown in the following screenshot:</p><div><img src="img/8874OS_04_01.jpg" alt="Text streams"/></div><p>One last thing about <code class="literal">QTextStream</code> is that it can operate on standard C file structures, which makes it possible for us to use <code class="literal">QTextStream</code> to, for example, write to <code class="literal">stdout</code> or read from <code class="literal">stdin</code>, as shown in the following code:</p><div><pre class="programlisting">QTextStream qout(stdout);
qout &lt;&lt; "This text goes to process standard output." &lt;&lt; endl;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Data serialization</h2></div></div></div><p>More than often, we <a id="id197" class="indexterm"/>have to store object data in a device-independent <a id="id198" class="indexterm"/>way so that it can be restored later, possibly on a different machine with a different data layout and so on. In computer science, this is called serialization. Qt provides several serialization mechanisms and now we will have a brief look at some of them.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec19"/>Binary streams</h3></div></div></div><p>If you look at <code class="literal">QTextStream</code> from a distance, you will notice that what it really does is serialize <a id="id199" class="indexterm"/>and deserialize data to a text format. Its close cousin is the <code class="literal">QDataStream</code> class that handles serialization and deserialization of arbitrary data to a binary format. It uses a custom data format to store and retrieve data from <code class="literal">QIODevice</code> in a platform-independent way. It stores enough data so that a stream written on one platform can be successfully read on a different platform.</p><p>
<code class="literal">QDataStream</code> is used in a similar fashion as <code class="literal">QTextStream</code>—the operators <code class="literal">&lt;&lt;</code> and <code class="literal">&gt;&gt;</code> are used to redirect data into or out of the stream. The class supports most of the built-in Qt types so that you can operate on classes such as <code class="literal">QColor</code>, <code class="literal">QPoint</code>, or <code class="literal">QStringList</code> directly:</p><div><pre class="programlisting">QFile file("outfile.dat");
file.open(QFile::WriteOnly|QFile::Truncate);
QDataStream stream(&amp;file);
double dbl = 3.14159265359;
QColor color = Qt::red;
QPoint point(10, -4);
QStringList stringList = QStringList() &lt;&lt; "foo" &lt;&lt; "bar";
stream &lt;&lt; dbl &lt;&lt; color &lt;&lt; point &lt;&lt; stringList;</pre></div><p>If you want to serialize custom data types, you can teach <code class="literal">QDataStream</code> to do that by implementing proper redirection operators.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Time for action – serialization of a custom structure</h1></div></div></div><p>Let's perform <a id="id200" class="indexterm"/>another small exercise by implementing functions that are required to use <code class="literal">QDataStream</code> to serialize the same simple structure that contains the player information that we used for text streaming:</p><div><pre class="programlisting">struct Player {
  QString name;
  qint64 experience;
  QPoint position;
  char direction;
};</pre></div><p>For this, two functions need to be implemented, both returning a <code class="literal">QDataStream</code> reference that was taken earlier as an argument to the call. Apart from the stream itself, the serialization operator accepts a constant reference to the class that is being saved. The most simple implementation just streams each member into the stream and returns the stream afterwards:</p><div><pre class="programlisting">QDataStream&amp; operator&lt;&lt;(QDataStream &amp;stream, const Player &amp;p) {
  stream &lt;&lt; p.name;
  stream &lt;&lt; p.experience;
  stream &lt;&lt; p.position;
  stream &lt;&lt; p.direction;
  return stream;
}</pre></div><p>Complementary to this, deserializing is done by implementing a redirection operator that accepts a mutable <a id="id201" class="indexterm"/>reference to the structure that is filled by data that is read from the stream:</p><div><pre class="programlisting">QDataStream&amp; operator&gt;&gt;(QDataStream &amp;stream, Player &amp;p) {
   stream &gt;&gt; p.name;
   stream &gt;&gt; p.experience;
   stream &gt;&gt; p.position;
   stream &gt;&gt; p.direction;
   return stream;
}</pre></div><p>Again, at the end, the stream itself is returned.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>
<em>What just happened?</em>
</h2></div></div></div><p>We provided two standalone functions that define redirection operators for the <code class="literal">Player</code> class to and from a <code class="literal">QDataStream</code> instance. This lets your class be serialized and deserialized using mechanisms offered and used by Qt.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl3sec20"/>XML streams</h2></div></div></div><p>XML has become <a id="id202" class="indexterm"/>one of the most popular standards that is used to store hierarchical data. Despite its verbosity and difficulty to read by human eye, it <a id="id203" class="indexterm"/>is used in virtually any domain where data persistency is required, as it is very easy to read by machines. Qt provides support for reading and writing XML documents in two modules. First, the <code class="literal">QtXml</code> module provides access using the <a id="id204" class="indexterm"/>
<strong>Document Object Model</strong> (<strong>DOM</strong>) standard with classes such as <code class="literal">QDomDocument</code>, <code class="literal">QDomElement</code>, and others. We will not discuss this approach here, as now the recommended approach is to use streaming classes from the <code class="literal">QtCore</code> module. One of the downsides of <code class="literal">QDomDocument</code> is that it requires us to load the whole XML tree into the memory before parsing it. In some situations, this is compensated for by the ease of use of the DOM approach as compared to a streamed approach, so you can consider using it if you feel you have found the right task for it.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>If you want to use the DOM access to XML in Qt, remember to enable the <code class="literal">QtXml</code> module in your applications by adding a <code class="literal">QT += xml</code> line in the project configuration files.</p></div></div><p>As already said, we will <a id="id205" class="indexterm"/>focus on the stream approach implemented by the <code class="literal">QXmlStreamReader</code> and <code class="literal">QXmlStreamWriter</code> classes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Time for action – implementing an XML parser for player data</h1></div></div></div><p>In this <a id="id206" class="indexterm"/>exercise, we are <a id="id207" class="indexterm"/>going to create a parser to fill data that represents players and their inventory in an RPG game:</p><div><pre class="programlisting">struct InventoryItem {
  enum Type { Weapon, Armor, Gem, Book, Other } type;
  QString subType;
  int durability;
};

struct Player {
  QString name;
  QString password;
  int experience;
  int hitPoints;
  QList&lt;Item&gt; inventory;
  QString location;
  QPoint position;
};

struct PlayerInfo {
  QList&lt;Player&gt; players;
};</pre></div><p>Save the following document somewhere. We will use it to test whether the parser can read it:</p><div><pre class="programlisting">&lt;PlayerInfo&gt;
    &lt;Player hp="40" exp="23456"&gt;
        &lt;Name&gt;Gandalf&lt;/Name&gt;
        &lt;Password&gt;mithrandir&lt;/Password&gt;
        &lt;Inventory&gt;
            &lt;InvItem type="weapon" durability="3"&gt;
                &lt;SubType&gt;Long sword&lt;/SubType&gt;
            &lt;/InvItem&gt;
            &lt;InvItem type="armor" durability="10"&gt;
                &lt;SubType&gt;Chain mail&lt;/SubType&gt;
            &lt;/InvItem&gt;
        &lt;/Inventory&gt;
        &lt;Location name="room1"&gt;
            &lt;Position x="1" y="0"/&gt;
        &lt;/Location&gt;
    &lt;/Player&gt;
&lt;/PlayerInfo&gt;</pre></div><p>Let's create a class called <code class="literal">PlayerInfoReader</code> that will wrap <code class="literal">QXmlStreamReader</code> and expose a <a id="id208" class="indexterm"/>parser interface for the <code class="literal">PlayerInfo</code> instances. The class will contain two private members—the reader itself and a <code class="literal">PlayerInfo</code> instance that acts as a container for the data that is currently being <a id="id209" class="indexterm"/>read. We'll provide a <code class="literal">result()</code> method that returns this object once the parsing is complete, as shown in the following code:</p><div><pre class="programlisting">class PlayerInfoReader {
public:
  PlayerInfoReader(QIODevice *);
  inline const PlayerInfo&amp; result() const { return m_pinfo; }
private:
  QXmlStreamReader reader;
  PlayerInfo m_pinfo;
};</pre></div><p>The class constructor accepts a <code class="literal">QIODevice</code> pointer that the reader is going to use to retrieve data as it needs it. The constructor is trivial, as it simply passes the device to the <code class="literal">reader</code> object:</p><div><pre class="programlisting">PlayerInfoReader(QIODevice *device) {
    reader.setDevice(device);
}</pre></div><p>Before we go into parsing, let's prepare some code to help us with the process. First, let's add an enumeration type to the class that will list all the possible tokens—tag names that we want to handle in the parser:</p><div><pre class="programlisting">enum Token {
  T_Invalid = -1,
  T_PlayerInfo,                                 /* root tag */
  T_Player,                                     /* in PlayerInfo */
  T_Name, T_Password, T_Inventory, T_Location,  /* in Player */
  T_Position,                                   /* in Location */
  T_InvItem                                     /* in Inventory */
};</pre></div><p>To use these tags, we'll add a static method to the class that returns the token type based on its textual representation:</p><div><pre class="programlisting">static Token PlayerInfoReader::tokenByName(const QStringRef &amp;r) {
  static QStringList tokenList = QStringList() &lt;&lt; "PlayerInfo" &lt;&lt; "Player"
    &lt;&lt; "Name" &lt;&lt; "Password"
    &lt;&lt; "Inventory" &lt;&lt; "Location"
    &lt;&lt; "Position" &lt;&lt; "InvItem";
  int idx = tokenList.indexOf(r.toString());
  return (Token)idx;
}</pre></div><p>You can notice that we are using a class called <code class="literal">QStringRef</code>. It represents a string reference—a substring in an existing string—and is implemented in a way that avoids expensive string construction; therefore, it is very fast. We're using this class here because that's how <code class="literal">QXmlStreamReader</code> reports tag names. Inside this static method, we are converting the string reference to a real string and trying to match it against a list of known tags. If the matching fails, <code class="literal">-1</code> is returned, which corresponds to our <code class="literal">T_Invalid</code> token.</p><p>Now, let's <a id="id210" class="indexterm"/>add an entry point to <a id="id211" class="indexterm"/>start the parsing process. Add a public <code class="literal">read</code> method that initializes the data structure and performs initial checks on the input stream:</p><div><pre class="programlisting">bool PlayerInfoReader::read() {
  m_pinfo = PlayerInfo();
  if(reader.readNextStartElement() &amp;&amp; tokenByName(reader.name()) == T_PlayerInfo) {
      return readPlayerInfo();
  } else {
    return false;
  }
}</pre></div><p>After clearing the data structure, we call <code class="literal">readNextStartElement()</code> on the reader to make it find the starting tag of the first element, and if it is found, we check whether the root tag of the document is what we expect it to be. If so, we call the <code class="literal">readPlayerInfo()</code> method and return its result, denoting whether the parsing was successful. Otherwise, we bail out, reporting an error.</p><p>The <code class="literal">QXmlStreamReader</code> subclasses usually follow the same pattern. Each parsing method first checks whether it operates on a tag that it expects to find. Then, it iterates all the starting elements, handling those it knows and ignoring all others. Such an approach lets us maintain forward compatibility, since all tags introduced in newer versions of the document are silently skipped by an older parser.</p><p>Now, let's implement the <code class="literal">readPlayerInfo</code> method:</p><div><pre class="programlisting">bool readPlayerInfo() {
  if(tokenByName(reader.name()) != T_PlayerInfo)
    return false;
  while(reader.readNextStartElement()) {
    if(tokenByName(reader.name()) == T_Player) {
      Player p = readPlayer();
      m_pinfo.players.append(p);
    } else
      reader.skipCurrentElement();
  }
  return true;
}</pre></div><p>After verifying <a id="id212" class="indexterm"/>that we are working on a <code class="literal">PlayerInfo</code> tag, we iterate all the starting subelements of the current tag. For <a id="id213" class="indexterm"/>each of them, we check whether it is a <code class="literal">Player</code> tag and call <code class="literal">readPlayer()</code> to descend into the level of parsing data for a single player. Otherwise, we call <code class="literal">skipCurrentElement()</code>, which fast-forwards the stream until a matching ending element is encountered.</p><p>The structure of <code class="literal">readPlayer()</code> is similar; however, it is more complicated as we also want to read data from attributes of the <code class="literal">Player</code> tag itself. Let's take a look at the function piece by piece:</p><div><pre class="programlisting">Player readPlayer() {
  if(tokenByName(reader.name()) != T_Player) return Player();
  Player p;  const QXmlStreamAttributes&amp; playerAttrs = reader.attributes();
  p.hitPoints = playerAttrs.value("hp").toString().toInt();
  p.experience = playerAttrs.value("exp").toString().toInt();</pre></div><p>After checking for the right tag, we get the list of attributes associated with the opening tag and ask for values of the two attributes that we are interested in. After this, we loop all child tags and fill the <code class="literal">Player</code> structure based on the tag names. By converting tag names to tokens, we can use a <code class="literal">switch</code> statement to neatly structure the code in order to extract information from different tag types, as shown in the following code:</p><div><pre class="programlisting">while(reader.readNextStartElement()) {
  Token t = tokenByName(reader.name());
  switch(t) {
  case Name:      p.name = reader.readElementText(); break;
  case Password:  p.password = reader.readElementText(); break;
  case Inventory: p.inventory = readInventory(); break;</pre></div><p>If we are interested in the textual content of the tag, we can use <code class="literal">readElementText()</code> to extract it. This method reads until it encounters the closing tag and returns the text contained within it. For the <code class="literal">Inventory</code> tag, we call the dedicated <code class="literal">readInventory()</code> method.</p><p>For the <code class="literal">Location</code> tag, the code is more complex than before as we again descend into reading child tags, extracting the required information and skipping all unknown tags:</p><div><pre class="programlisting">        case T_Location: {
            p.location = reader.attributes().value("name").toString();
            while(reader.readNextStartElement()) {
                if(tokenByName(reader.name()) == T_Position) {
                    const QXmlStreamAttributes&amp; attrs = reader.attributes();
                    p.position.setX(attrs.value("x").toString().toInt());
                    p.position.setY(attrs.value("y").toString().toInt());
                    reader.skipCurrentElement();
                } else
                    reader.skipCurrentElement();
            }
        }; break;
        default:
            reader.skipCurrentElement();
        }
    }
    return p;
}</pre></div><p>The last <a id="id214" class="indexterm"/>method is similar in <a id="id215" class="indexterm"/>structure to the previous one—iterate all the tags, skip everything that we don't want to handle (everything that is not an inventory item), fill the inventory item data structure, and append the item to the list of already parsed items, as shown in the following code:</p><div><pre class="programlisting">QList&lt;InventoryItem&gt; readInventory() {
  QList&lt;InventoryItem&gt; inventory;
  while(reader.readNextStartElement()) {
    if(tokenByName(reader.name()) != T_InvItem) {
      reader.skipCurrentElement();
      continue;
    }
    InventoryItem item;
    const QXmlStreamAttributes&amp; attrs = reader.attributes();
      item.durability = attrs.value("durability").toString().toInt();
    QStringRef typeRef = attrs.value("type");
    if(typeRef == "weapon") {
      item.type = InventoryItem::Weapon;
    } else if(typeRef == "armor") {
      item.type = InventoryItem::Armor;
    } else if(typeRef == "gem") {
      item.type = InventoryItem::Gem;
    } else if(typeRef == "book") {
      item.type = InventoryItem::Book;
    } else item.type = InventoryItem::Other;
    while(reader.readNextStartElement()) {
      if(reader.name() == "SubType")
      item.subType = reader.readElementText();
      else
        reader.skipCurrentElement();
    }
    inventory &lt;&lt; item;
  }
  return inventory;
}</pre></div><p>In <code class="literal">main()</code> of your <a id="id216" class="indexterm"/>project, write <a id="id217" class="indexterm"/>some code that will check whether the parser works correctly. You can use the <code class="literal">qDebug()</code> statements to output the sizes of lists and contents of variables. Take a look at the following code for an example:</p><div><pre class="programlisting">qDebug() &lt;&lt; "Count:" &lt;&lt; playerInfo.players.count();
qDebug() &lt;&lt; "Size of inventory:" &lt;&lt; playerInfo.players.first().inventory.size();
qDebug() &lt;&lt; "Room: " &lt;&lt; playerInfo.players.first().location &lt;&lt; playerInfo.players.first().position;</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>
<em>What just happened?</em>
</h2></div></div></div><p>The code you just wrote implements a full top-down parser of the XML data. First, the data goes through a tokenizer, which returns identifiers that are much easier to handle than strings. Then, each method can easily check whether the token it receives is an acceptable input for the current parsing stage. Based on the child token, the next parsing function is determined and the parser descends to a lower level until there is nowhere to descend to. Then, the flow goes back up one level and processes the next child. If at any point an unknown tag is found, it gets ignored. This approach supports a situation when a new version of software introduces new tags to the file format specification, but an old version of software can still read the file by skipping all the tags that it doesn't understand.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Have a go hero – an XML serializer for player data</h2></div></div></div><p>Now that <a id="id218" class="indexterm"/>you know how to parse XML <a id="id219" class="indexterm"/>data, you can create the complementary part—a module that will serialize <code class="literal">PlayerInfo</code> structures into XML documents using <code class="literal">QXmlStreamWriter</code>. Use methods such as <code class="literal">writeStartDocument()</code>, <code class="literal">writeStartElement()</code>, <code class="literal">writeCharacters()</code>, and <code class="literal">writeEndElement()</code> for this. Verify that the documents saved with your code can be parsed with what we implemented together.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl3sec21"/>JSON files</h2></div></div></div><p>
<strong>JSON</strong> stands for <strong>JavaScript Object Notation,</strong> which is a popular lightweight textual format <a id="id220" class="indexterm"/>that is used to store object-oriented <a id="id221" class="indexterm"/>data in a human-readable form. It comes from JavaScript where it is the native format used to store object information; however, it is commonly used across many programming languages and a popular format for web data exchange. A simple JSON-formatted definition looks as follows:</p><div><pre class="programlisting">{
    "name": "Joe",
    "age": 14,
    "inventory: [
        { "type": "gold; "amount": "144000" },
        { "type": "short_sword"; "material": "iron" }
    ]
}</pre></div><p>JSON can express two kinds of entities: objects (enclosed in braces) and arrays (enclosed in square brackets) where an object is defined as a set of key-value pairs, where a value can be a simple string, an object, or array. In the previous example, we had an object containing three properties—name, age, and inventory. The first two properties are simple values and the last property is an array that contains two objects with two properties each.</p><p>Qt can create and read JSON descriptions using the <code class="literal">QJsonDocument</code> class. A document can be created from the UTF-8-encoded text using the <code class="literal">QJsonDocument::fromJson()</code> static method and can later be stored in a textual form again using <code class="literal">toJson()</code>. Since the structure of JSON closely resembles that of <code class="literal">QVariant</code> (which can also hold key-value pairs using <code class="literal">QVariantMap</code> and arrays using <code class="literal">QVariantList</code>), conversion methods to this class also exist using a set of <code class="literal">fromVariant()</code> and <code class="literal">toVariant()</code> calls. Once a JSON document is created, you can check whether it represents an object or an array using one of the <code class="literal">isArray</code> and <code class="literal">isObject</code> calls. Then, the document can be transformed into <code class="literal">QJsonArray</code> or <code class="literal">QJsonObject</code> using the <code class="literal">toArray</code> and <code class="literal">toObject</code> methods.</p><p>
<code class="literal">QJsonObject</code> is an iterable type that can be queried for a list of keys (using <code class="literal">keys()</code>) or asked for a value of a specific key (with a <code class="literal">value()</code> method). Values are represented using the <code class="literal">QJsonValue</code> class, which can store simple values, an array, or object. New properties can be added to the object using the <code class="literal">insert()</code> method that takes a key as a string, a value can be added as <code class="literal">QJsonValue</code>, and the existing properties can be removed using <code class="literal">remove()</code>.</p><p>
<code class="literal">QJsonArray</code> is also <a id="id222" class="indexterm"/>an iterable type that contains a classic list API—it contains methods such as <code class="literal">append()</code>, <code class="literal">insert()</code>, <code class="literal">removeAt()</code>, <code class="literal">at()</code>, and <code class="literal">size()</code> to manipulate entries in the array, again working on <code class="literal">QJsonValue</code> as the item type.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Time for action – the player data JSON serializer</h1></div></div></div><p>Our next <a id="id223" class="indexterm"/>exercise is to create a serializer of the same <code class="literal">PlayerInfo</code> structure as we used for the XML exercise, but this time the destination data format is going to be JSON.</p><p>Start by creating a <code class="literal">PlayerInfoJSON</code> class and give it an interface similar to the one shown in the following code:</p><div><pre class="programlisting">class PlayerInfoJSON {
public:
  PlayerInfoJSON(){}
  QByteArray writePlayerInfo(const PlayerInfo &amp;pinfo) const;
};</pre></div><p>All that is really required is to implement the <code class="literal">writePlayerInfo</code> method. This method will use <code class="literal">QJsonDocument::fromVariant()</code> to perform the serialization; thus, what we really have to do is convert our player data to a variant. Let's add a protected method to do that:</p><div><pre class="programlisting">QVariant PlayerInfoJSON::toVariant(const PlayerInfo &amp;pinfo) const {
  QVariantList players;
  foreach(const Player &amp;p, pinfo.players) players &lt;&lt; toVariant(p);
  return players;
}</pre></div><p>Since the structure is really a list of players, we can iterate the list of players, serialize each player to a variant, and append the result to <code class="literal">QVariantList</code>. Having this function ready, we can descend a level and implement an overload for <code class="literal">toVariant()</code> that takes a <code class="literal">Player</code> object:</p><div><pre class="programlisting">QVariant PlayerInfoJSON::toVariant(const Player &amp;player) const {
  QVariantMap map;
  map["name"]       = player.name;
  map["password"]   = player.password;
  map["experience"] = player.experience;
  map["hitpoints"]  = player.hitPoints;
  map["location"]   = player.location;
  map["position"]   = QVariantMap({ {"x", player.position.x()},
                                    {"y", player.position.y()} });
  map["inventory"]  = toVariant(player.inventory);
  return map;
}</pre></div><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>Qt's <code class="literal">foreach</code> macro takes two parameters—a declaration of a variable and a container to iterate. At each iteration, the macro assigns subsequent elements to the declared variable and executes the statement located directly after the macro. A C++11 equivalent of <code class="literal">foreach</code> is a range that is based for construct:</p><div><pre class="programlisting">for(const Player &amp;p: pinfo.players) players &lt;&lt; toVariant(p);</pre></div></div></div><p>This time, we are using <code class="literal">QVariantMap</code> as our base type, since we want to associate values with keys. For each key, we use the index operator to add entries to the map. The position key holds a <code class="literal">QPoint</code> value, which is supported natively by <code class="literal">QVariant</code>; however, such a variant can't be automatically encoded in JSON, so we convert the point to a variant map using the C++11 initializer list. The situation is different with the inventory—again, we have to write an overload for <code class="literal">toVariant</code> that will perform the conversion:</p><div><pre class="programlisting">QVariant PlayerInfoJSON::toVariant(const QList&lt;InventoryItem&gt; &amp;items) const {
  QVariantList list;
  foreach(const InventoryItem &amp;item, items) list &lt;&lt; toVariant(item);
  return list;
}</pre></div><p>The code is <a id="id224" class="indexterm"/>almost identical to the one handling <code class="literal">PlayerInfo</code> objects, so let's focus on the last overload of <code class="literal">toVariant</code>—the one that accepts <code class="literal">Item</code> instances:</p><div><pre class="programlisting">QVariant PlayerInfoJSON::toVariant(const InventoryItem &amp;item) const {
  QVariantMap map;
  map["type"] = (int)item.type;
  map["subtype"] = item.subType;
  map["durability"] = item.durability;
  return map;
}</pre></div><p>There is not much to comment here—we add all keys to the map, treating the item type as an integer for simplicity (this is not the best approach in a general case, as if we serialize our data and then change the order of values in the original enumeration, we will not get the proper item types after deserialization).</p><p>What remains is to use the code we have just written in the <code class="literal">writePlayerInfo</code> method:</p><div><pre class="programlisting">QByteArray PlayerInfoJSON::writePlayerInfo(const PlayerInfo &amp;pinfo) const {
  QJsonDocument doc = QJsonDocument::fromVariant(toVariant(pinfo));
  return doc.toJson();
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Time for action – implementing a JSON parser</h1></div></div></div><p>Let's <a id="id225" class="indexterm"/>extend the <code class="literal">PlayerInfoJSON</code> class and equip it with a reverse conversion:</p><div><pre class="programlisting">PlayerInfo PlayerInfoJSON::readPlayerInfo(const QByteArray &amp;ba) const {
  QJsonDocument doc = QJsonDocument::fromJson(ba);
  if(doc.isEmpty() || !doc.isArray()) return PlayerInfo();
  return readPlayerInfo(doc.array());
}</pre></div><p>First, we read <a id="id226" class="indexterm"/>the document and check whether it is valid and holds the expected array. Upon failure, an empty structure is returned; otherwise, <code class="literal">readPlayerInfo</code> is called and is given <code class="literal">QJsonArray</code> to work with:</p><div><pre class="programlisting">PlayerInfo PlayerInfoJSON::readPlayerInfo(const QJsonArray &amp;array) const {
  PlayerInfo pinfo;
  foreach(QJsonValue value, array)
    pinfo.players &lt;&lt; readPlayer(value.toObject());
  return pinfo;
}</pre></div><p>Since the <a id="id227" class="indexterm"/>array is iterable, we can again use <code class="literal">foreach</code> to iterate it and use another method—<code class="literal">readPlayer</code>—to extract all the needed data:</p><div><pre class="programlisting">Player PlayerInfoJSON::readPlayer(const QJsonObject &amp;object) const {
  Player player;
  player.name = object.value("name").toString();
  player.password = object.value("password").toString();
  player.experience = object.value("experience").toDouble();
  player.hitPoints = object.value("hitpoints").toDouble();
  player.location = object.value("location").toString();
  QVariantMap positionMap = object.value("position").toVariant().toMap();
  player.position = QPoint(positionMap["x"].toInt(), positionMap["y"].toInt());
  player.inventory = readInventory(object.value("inventory").toArray());
  return player;
}</pre></div><p>In this function, we used <code class="literal">QJsonObject::value()</code> to extract data from the object and then we used different functions to convert the data to the desired type. Note that in order to convert to <code class="literal">QPoint</code>, we first converted it to <code class="literal">QVariantMap</code> and then extracted the values before using them to build <code class="literal">QPoint</code>. In each case, if the conversion fails, we get a default value for that type (for example, an empty string). To read the inventory, we employ a custom method:</p><div><pre class="programlisting">QList&lt;InventoryItem&gt; PlayerInfoJSON::readInventory(const QJsonArray &amp;array) const {
  QList&lt;InventoryItem&gt; inventory;
  foreach(QJsonValue value, array) inventory &lt;&lt; readItem(value.toObject());
  return inventory;
}</pre></div><p>What <a id="id228" class="indexterm"/>remains is to implement <code class="literal">readItem()</code>:</p><div><pre class="programlisting">InventoryItem PlayerInfoJSON::readItem(const QJsonObject &amp;object) const {
  Item item;
  item.type = (InventoryItem::Type)object.value("type").toDouble();
  item.subType = object.value("subtype").toString();
  item.durability = object.value("durability").toDouble();
  return item;
}</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>
<em>What just happened?</em>
</h2></div></div></div><p>The class that was implemented can be used for bidirectional conversion between <code class="literal">Item</code> instances and a <code class="literal">QByteArray</code> object, which contains the object data in the JSON format. We didn't do any error checking here; instead, we relied on automatic type conversion handling in <code class="literal">QJsonObject</code> and <code class="literal">QVariant</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl3sec22"/>QSettings</h2></div></div></div><p>While not <a id="id229" class="indexterm"/>strictly a serialization issue, the aspect of storing application settings is closely related to the described subject. A Qt solution for this is the <a id="id230" class="indexterm"/>
<code class="literal">QSettings</code> class. By default, it uses different backends on different platforms, such as system registry on Windows or INI files on Linux. The basic use of <code class="literal">QSettings</code> is very easy—you just need to create the object and use <code class="literal">setValue()</code> and <code class="literal">value()</code> to store and load data from it:</p><div><pre class="programlisting">QSettings settings;
settings.setValue("windowWidth", 80);
settings.setValue("windowTitle", "MySuperbGame");
// …
int windowHeight = settings.value("windowHeight").toInt();</pre></div><p>The only thing you need to remember is that it operates on <code class="literal">QVariant</code>, so the return value needs to be converted to the proper type if needed as shown in the last line of the preceding code. A call to <code class="literal">value()</code> can take an additional argument that contains the value to be returned if the requested key is not present in the map. This allows you to handle default values, for example, in a situation when the application is first started and the settings are not saved yet:</p><div><pre class="programlisting">int windowHeight = settings.value("windowHeight", 800);</pre></div><p>The simplest scenario assumes that settings are "flat" in the way that all keys are defined on the same level. However, this does not have to be the case—correlated settings can be put into named groups. To operate on a group, you can use the <code class="literal">beginGroup()</code> and <code class="literal">endGroup()</code> calls:</p><div><pre class="programlisting">settings.beginGroup("Server");
QString srvIP = settings.value("host").toString();
int port = settings.value("port").toInt();
settings.endGroup();</pre></div><p>When using this syntax, you have to remember to end the group after you are done with it. An alternative to using the two mentioned methods is to pass the group name directly to invocation of <code class="literal">value()</code>:</p><div><pre class="programlisting">QString srvIP = settings.value("Server/host").toString();
int port = settings.value("Server/port").toInt();</pre></div><p>As was mentioned earlier, <code class="literal">QSettings</code> can use different backends on different platforms; however, we can have some influence on which is chosen and which options are passed to it by passing <a id="id231" class="indexterm"/>appropriate options to the constructor of the <a id="id232" class="indexterm"/>
<code class="literal">settings</code> object. By default, the place where the settings for an application are stored is determined by two values—the organization and the application name. Both are textual values and both can be passed as arguments to the <code class="literal">QSettings</code> constructor or defined a priori using appropriate static methods in <code class="literal">QCoreApplication</code>:</p><div><pre class="programlisting">QCoreApplication::setOrganizationName("Packt");
QCoreApplication::setApplicationName("Game Programming using Qt");
QSettings settings;</pre></div><p>This code is equivalent to:</p><div><pre class="programlisting">QSettings settings("Packt", "Game Programming using Qt");</pre></div><p>All of the preceding code use the default backend for the system. However, it is often desirable to use a different backend. This can be done using the <code class="literal">Format</code> argument, where we can pass one of the two options—<code class="literal">NativeFormat</code> or <code class="literal">IniFormat</code>. The former chooses the default backend, while the latter forces the INI-file backend. When choosing the backend, you can also decide whether settings should be saved in a system-wide location or in the user's settings storage by passing one more argument—the scope of which can be either <code class="literal">UserScope</code> or <code class="literal">SystemScope</code>. This can extend our final construction call to:</p><div><pre class="programlisting">QSettings settings(QSettings::IniFormat, QSettings::UserScope,
                "Packt", "Game Programming using Qt");</pre></div><p>There is one more option available for total control of where the settings data resides—tell the constructor directly where the data should be located:</p><div><pre class="programlisting">QSettings settings(
  QStandardPaths::writableLocation(
    QStandardPaths::ConfigLocation
  ) +"/myapp.conf", QSettings::IniFormat
);</pre></div><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>The <code class="literal">QStandardPaths</code> class provides methods to determine standard locations for files depending on the task at hand.</p></div></div><p>
<code class="literal">QSettings</code> also <a id="id233" class="indexterm"/>allows you to register your own formats so that you can control the way your settings are stored—for example, by storing them using XML or by adding on-the-fly encryption. This is done using <code class="literal">QSettings::registerFormat()</code>, where you need to pass the file extension and two pointers to functions that perform reading and writing of the <a id="id234" class="indexterm"/>settings, respectively, as follows:</p><div><pre class="programlisting">bool readCCFile(QIODevice &amp;device, QSettings::SettingsMap &amp;map) {
  CeasarCipherDevice ccDevice;
  ccDevice.setBaseDevice(&amp;device);
  // ...
  return true;
}
bool writeCCFile(QIODevice &amp;device, const QSettings::SettingsMap &amp;map) { ... }
const QSettings::Format CCFormat = QSettings::registerFormat("ccph", readCCFile, writeCCFile);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Pop quiz – Qt core essentials</h2></div></div></div><p>Q1. What is the closest equivalent <code class="literal">std::string</code> in Qt?</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">QString</code></li><li class="listitem"><code class="literal">QByteArray</code></li><li class="listitem"><code class="literal">QStringLiteral</code></li></ol></div><p>Q2. Which regular expression can be used to validate an IPv4 address, which is an address composed of four dot-separated decimal numbers with values ranging from 0 to 255?</p><p>Q3. Which do you think is the best serialization mechanism to use if you expect the data structure to evolve (gain new information) in future versions of the software?</p><div><ol class="orderedlist arabic"><li class="listitem">JSON</li><li class="listitem">XML</li><li class="listitem">QDataStream</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, you learned a number of core Qt technologies ranging from text manipulation, to accessing devices that can be used to transfer or store data using a number of popular technologies such as XML or JSON. You should be aware that we have barely scratched the surface of what Qt offers and there are many other interesting classes you should familiarize yourself with but this minimum amount of information should give you a head start and show you the direction to follow with your future research.</p><p>In the next chapter, we will switch from describing data manipulation, which can be visualized using text or only in your imagination, to a more appealing media. We will start talking about graphics and how to transfer what you can see in your imagination to the screen of your computer.</p></div></body></html>