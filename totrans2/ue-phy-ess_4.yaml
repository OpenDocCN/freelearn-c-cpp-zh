- en: Chapter 4. Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are constraints?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constraints are basic physical actors in Unreal Engine 4\. Imagine that physical
    rules need something to be presented with, such as a tool, switch, calculator,
    or container. It's called **physic actor**, and physic actors that are responsible
    for simulating the physical behavior between two objects are known as physics
    constraint actor.
  prefs: []
  type: TYPE_NORMAL
- en: It works in a similar way to a minicomputer. You can connect two inputs to it,
    and it calculates how these two should play with the physical rules in the game.
    Finally, it applies the changes to the object as real-time processing during the
    game play.
  prefs: []
  type: TYPE_NORMAL
- en: The first physics constraint actor experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start working in Unreal Editor, we will need to have a project to
    work with. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open Unreal Editor by clicking on the **Launch** button from Unreal Engine
    launcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new project from **Project** browser by selecting the **New Project**
    tab. Select **First Person** and make sure that **With Starter Content** is selected
    and give the project a name (`constraints_test`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are finished, locate the two cubes on your view. Select one and then
    click on the small icon in the top-right corner of your view:![The first physics
    constraint actor experience](img/image00277.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have four viewports on your screen. It's good practice when you are
    working with constraints to check your stage from four views. Now, select one
    of the cubes, middle-click on the top view, and press the *F* key. This automatically
    navigates all your viewports so that they are all focused on your actual selection.![The
    first physics constraint actor experience](img/image00278.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to move one cube onto another one. Also, rotate the upper cube
    so that it fits the same angle as the one after it. Use the move and rotate tools
    to create your stage, as shown in the following screenshot. As you can see, the
    upper cube is about three times further away from the lower cube:![The first physics
    constraint actor experience](img/image00279.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's click on the area in the top-right corner of your **Perspective** view
    to expand it and press **Play**. You will see one cube just fall on the lower
    cube. This is caused by gravity. Also, you can move the cubes by shooting balls
    at them. We need to disable this physic rules for the upper cube. Now, click on
    **Stop** to exit the play mode. Select the upper cube and uncheck **Simulate Physics**
    in **Details** on the right-hand side of your editor. Then, click on **Play**
    again.![The first physics constraint actor experience](img/image00280.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the upper cube not only falls, but also, when you shoot at it, it doesn't
    move. This gives an ideal location to hang the other cube to this one. For this
    purpose, Unreal Engine defines some tools (known as **PhysX Constraint**). These
    tools allow you to simulate reality based on the physical behavior and the mode
    of the game world. Then, switch back to four views, click on **All Classes** in
    **Modes**, and locate **PhysicsConstraintActor** near **All Classes**:![The first
    physics constraint actor experience](img/image00281.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop this actor and place it in the middle of the cubes. Locate the
    **Constraint** section from the right-hand side list. Each physics constraint
    actor needs two objects to operate with. This means that we need to give the actor
    object names and then this actor presents a physical-based action in the game
    world during the game play. How we do this? You will find two similar actors in
    the **Constraint** section: **Constraint Actor 1** and **Constraint Actor 2**.
    Here, we can define objects. Simply click on the picker icon and then on the upper
    cube for **Constraint Actor 1** and another cube for **Constraint Actor 2**, as
    shown in the following screenshot:![The first physics constraint actor experience](img/image00282.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, switch to the **Perspective** view, move the lower cube a bit up, press
    **Play**, and shoot the lower cube from different angles and locations, as shown
    in the following screenshot:![The first physics constraint actor experience](img/image00283.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, it looks like something is grabbing the lower cube and forcing
    it to remain there and rotate around that point. Also, the cube shows normal behavior
    with gravity.![The first physics constraint actor experience](img/image00284.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What you observe here is how physic constraints work in Unreal Engine. You
    can change the physical parameters related to each object and obtain different
    results. Let''s take a look at some:'
  prefs: []
  type: TYPE_NORMAL
- en: For the upper cube, check **Physics** in the **Details** window. When you play,
    it seems that all the cubes are connected to each other, whereas when you move
    one, others react to your interaction. Click on **Stop** and uncheck **Physics**
    for the upper cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the lower cube. Then, in **Physics**, change **Mass Scale** from `1.0`
    to `1000`. Now, play the game and try to move the cube. It looks like it's heavy,
    very heavy. So, click on **Stop** and change **Mass Scale** to `1.0`.![The first
    physics constraint actor experience](img/image00285.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the lower cube, uncheck **Enable Gravity**, and click on **Play**. Try
    to shoot the cube and observe the difference. It saves its connection to other
    objects, but doesn't follow the gravity of the game world.![The first physics
    constraint actor experience](img/image00286.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, press **Stop** and check **Enable Gravity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customizing physics constraint actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we know that this actor connects two objects to each other by supporting
    the gravity and physical aspects of each object. We also know that it is invisible
    to players. In addition, **Physics Constraint Actor** has some properties that
    strongly shape the physical behavior of objects. Let''s start with position. Switch
    back to four views and move your **Physics Constraint Actor** close to the upper
    cube, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing physics constraint actor](img/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, press **Play** and shoot the cube. As you can see, it even goes over the
    upper cube. It seems that the rotation point is going higher. This is correct.
    The exact description is that you move your physics constraint actor to the top.
    This basically changes the way these two objects behave based on physical rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on **Stop**. Then, click on your physics constraint actor and press
    *F*. In **Angular Limits**, in the **Details** section on the right-hand side,
    set **Angular Swing 1Motion** to **Locked**, **Angular Twist Motion** to **Limited**,
    and **Twist Limit Angel** and **Angular Swing 2Motion** to **60**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing physics constraint actor](img/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on **Play**. As you can see, the cube plays in a pyramid-like area
    between 60 degrees and nowhere else. Then, click on **Stop** and change **Angular
    Swing 1Motion** to **Free**. Finally, click on **Play**. As you can see, the cube
    has free rotation on its *z* axis.
  prefs: []
  type: TYPE_NORMAL
- en: A simple game with Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you click on **Stop**, select the cubes and your actor. Then, hold *Alt*
    and create a copy of all by moving on the *Y* axis. Now, click on the second actor
    and pick the upper and lower cubes. Then, select one point light object from **Modes**
    | **Basic** on the left-hand side and place it close to the stage surface between
    the two cubes. Our goal is to turn on the light when the cubes experience collision
    and break one of the cube's physical constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple game with Blueprint](img/image00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on point light and navigate to **Rendering** in the **Details**
    section and uncheck **Visible**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple game with Blueprint](img/image00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on **Blueprint** and select **Open Level Blueprint**. Navigate back
    to editor and select your point light. Now, go back to the **Blueprint** editor,
    right click on it, and select **Create a Reference to PointLight** from the list.
    You will have a curvy box with the **PointLight** title on your blueprint stage.
    Now, locate the small blue hollow circle in the top-right corner of your point
    light box. Then, click and hold the mouse and move the pointer to the right. You
    will find a wire-like line that follows your mouse. When you leave the mouse,
    a list will appear with a search area to type. Enter toggle and click on **Toggle
    Visibility (PointLightComponent)** from the names in the list, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple game with Blueprint](img/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, navigate back to editor and select one of the lower cubes. Then, go back
    to **Blueprint** and use the same method to open the list, but this time, open
    **Add Event** for your cube name. Then, open **Collision** and select **Add On
    Actor Hit**. Now, connect a wire to the previous box you made, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple game with Blueprint](img/image00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What this does is you first define the reference to your **PointLight** and
    then add the **Toggle** functionality to the visibility of the light. However,
    you need to turn the light on by selecting **Hit Event** for your cubes. So, we
    can add **Event** for collision and set the event to execute our toggle function.
    Click on **Play** and check how it works. As you can see, **PointLight** turns
    on and off on each hit to the selected cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to define another rule for our game. We need to disable the physical
    actor on the hit event. Then, select your actor over the other cube. Create a
    reference for it as you did for the lamp. Then, create the **Break Constraint**
    function with the break keyword on the search area. Now, select the cube that
    responds to the actor and then create another hit event and connect it to this
    function. This is how the result should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple game with Blueprint](img/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, test the game. As a result of the heat effect, one cube turns the light
    on/off, whereas another falls on the game stage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way game designers and artists try to project the mode and presentation
    of objects in the game meets the frame by frame animation, or wisely use the physical
    aspects of Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Twenty years ago, game designers animated the open and close movement of a simple
    door with the frame by frame method as an image-sequence file (such as GIF). Now,
    we can do the same in real time with light effects, materials, physical rules,
    and the blueprint code. Unreal Engine 4 provides the detailed properties and customizations
    for movements and dependency between objects in the game world. This is how creativity
    meets artistic details in a game design. Working with constraints is a kind of
    creative art.
  prefs: []
  type: TYPE_NORMAL
