<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Drawing in SDL</h1></div></div></div><p>Graphics are very important to games and they can also be one of the main performance bottlenecks if not handled correctly. With SDL 2.0 we can really take advantage of the GPU when rendering, which gives us a real boost in terms of the speed of rendering.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basics of drawing with SDL</li><li class="listitem" style="list-style-type: disc">Source and destination rectangles</li><li class="listitem" style="list-style-type: disc">Loading and displaying textures</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">SDL_image</code> extension</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Basic SDL drawing</h1></div></div></div><p>In the previous chapter we created an SDL window but we have yet to render anything to the screen. SDL can use two structures to draw to the screen. One is the <code class="literal">SDL_Surface</code> structure, which contains a <a class="indexterm" id="id107"/>collection of pixels and is rendered using<a class="indexterm" id="id108"/> software rendering processes (not the GPU). The other is <code class="literal">SDL_Texture</code>; this can be used for hardware-accelerated rendering. We want our games to be as efficient as possible so we will focus on using <code class="literal">SDL_Texture</code>.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Getting some images</h2></div></div></div><p>We need some images to load throughout this chapter. We do not want to spend any time creating art assets for our games <a class="indexterm" id="id109"/>at this point; we want to focus entirely on the programming side. In this book we will use assets from the <code class="literal">SpriteLib</code> collection available at <a class="ulink" href="http://www.widgetworx.com/widgetworx/portfolio/spritelib.html">http://www.widgetworx.com/widgetworx/portfolio/spritelib.html</a>.</p><p>I have altered some of these files to allow us to easily use them in the upcoming chapters. These images are available with the source code download for this book. The first one we will use is the <code class="literal">rider.bmp</code> image file:</p><div><img alt="Getting some images" src="img/6821OT_02_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Creating an SDL texture</h2></div></div></div><p>First we will create a pointer to an <code class="literal">SDL_Texture</code> object as a member variable in our <code class="literal">Game.h</code> header file. We<a class="indexterm" id="id110"/> will also create some rectangles to be used when drawing the texture.</p><div><pre class="programlisting">SDL_Window* m_pWindow;
SDL_Renderer* m_pRenderer;

SDL_Texture* m_pTexture; // the new SDL_Texture variable
SDL_Rect m_sourceRectangle; // the first rectangle
SDL_Rect m_destinationRectangle; // another rectangle</pre></div><p>We can load this texture in our game's <code class="literal">init</code> function for now. Open up <code class="literal">Game.cpp</code> and follow the steps to load and draw an <code class="literal">SDL_Texture</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">First we will make an assets folder to hold our images, place this in the same folder as your source code (not the executable code). When you want to distribute the game you will copy this assets folder along with your executable. But for development purposes we will keep it in the same folder as the source code. Place the <code class="literal">rider.bmp</code> file into this assets folder.</li><li class="listitem">In our game's <code class="literal">init</code> function we can load our image. We will use the <code class="literal">SDL_LoadBMP</code> function which returns an <code class="literal">SDL_Surface*</code>. From this <code class="literal">SDL_Surface*</code> we can create <code class="literal">SDL_Texture</code> structure using the <code class="literal">SDL_CreateTextureFromSurface</code> function. We then free the temporary surface, releasing any used memory.<div><pre class="programlisting">SDL_Surface* pTempSurface = SDL_LoadBMP("assets/rider.bmp");

m_pTexture = SDL_CreateTextureFromSurface(m_pRenderer, pTempSurface);

SDL_FreeSurface(pTempSurface);</pre></div></li><li class="listitem">We now have <code class="literal">SDL_Texture</code> ready to be drawn to the screen. We will first get the dimensions of the texture we have just loaded, and use them to set the width and height of <code class="literal">m_sourceRectangle</code> so that we can draw it correctly.<div><pre class="programlisting">SDL_QueryTexture(m_pTexture, NULL, NULL, &amp;m_sourceRectangle.w, &amp;m_sourceRectangle.h);</pre></div></li><li class="listitem">Querying the texture will allow us to set the width and height of our source rectangle to the exact dimensions needed. So now that we have the correct height and width of <a class="indexterm" id="id111"/>our texture stored in <code class="literal">m_sourceRectangle</code> we must also set the destination rectangle's height and width. This is done so that our renderer knows which part of the window to draw our image to, and also the width and height of the image we want to render. We will set both x and y coordinates to <code class="literal">0</code> (top left). Window coordinates can be represented with an <code class="literal">x</code> and <code class="literal">y</code> value, with <code class="literal">x</code> being the horizontal position and <code class="literal">y</code> the vertical. Therefore the coordinates for the top-left of a window in SDL would be (0,0) and the center point would be the width of the window divided by two for <code class="literal">x</code>, and the height of the window divided by two for <code class="literal">y</code>.<div><pre class="programlisting">m_destinationRectangle.x = m_sourceRectangle.x = 0;
m_destinationRectangle.y = m_sourceRectangle.y = 0;
m_destinationRectangle.w = m_sourceRectangle.w;
m_destinationRectangle.h = m_sourceRectangle.h;</pre></div></li><li class="listitem">Now that we have a loaded texture and its dimensions, we can move on to rendering it to the screen. Move to our game's <code class="literal">render</code> function and we will add the code to draw our texture. Put this function between the calls to <code class="literal">SDL_RenderClear</code> and <code class="literal">SDL_RenderPresent</code>.<div><pre class="programlisting">SDL_RenderCopy(m_pRenderer, m_pTexture, &amp;m_sourceRectangle, &amp;m_destinationRectangle);</pre></div></li><li class="listitem">Build the project and you will see our loaded texture.<div><img alt="Creating an SDL texture" src="img/6821OT_02_02.jpg"/></div></li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Source and destination rectangles</h1></div></div></div><p>Now that we have something drawn to the screen, it is a good idea to cover the purpose of source and destination rectangles, as they will be extremely important for topics such as tile map loading and drawing. They are also important for sprite sheet animation which we will be covering later in this chapter.</p><p>We can think of a <a class="indexterm" id="id112"/>source rectangle as defining the area we want to copy from a texture onto the window:</p><div><ol class="orderedlist arabic"><li class="listitem">In the previous example, we used the entire image so we could simply define the source rectangle's dimensions with the same dimensions as those of the loaded texture.<div><img alt="Source and destination rectangles" src="img/6821OT_02_03.jpg"/></div></li><li class="listitem">The red box in the preceding screenshot is a visual representation of the source rectangle we used when drawing to the screen. We want to copy pixels from inside the source rectangle to a specific area of the renderer, the destination rectangle<a class="indexterm" id="id113"/> (the red box in the following screenshot).<div><img alt="Source and destination rectangles" src="img/6821OT_02_04.jpg"/></div></li><li class="listitem">As you would expect, these rectangles can be defined however you wish. For example, let's open up our <code class="literal">Game.cpp</code> file again and take a look at changing the size of the source rectangle. Place this code after the <code class="literal">SDL_QueryTexture</code> function.<div><pre class="programlisting">m_sourceRectangle.w = 50;
m_sourceRectangle.h = 50;</pre></div><p>Now build again and you should see that only a 50 x 50 square of the image has been copied across to the renderer.</p><div><img alt="Source and destination rectangles" src="img/6821OT_02_05.jpg"/></div></li><li class="listitem">Now let us move the destination rectangle by changing its <code class="literal">x</code> and <code class="literal">y</code> values.<div><pre class="programlisting">m_destinationRectangle.x = 100;
m_destinationRectangle.y = 100;</pre></div><p>Build the project <a class="indexterm" id="id114"/>again and you will see that our source rectangle location has remained the same but the destination rectangle has moved. All we have done is move the location that we want the pixels inside the source rectangle to be copied to.</p><div><img alt="Source and destination rectangles" src="img/6821OT_02_06.jpg"/></div></li><li class="listitem">So far we have left the <a class="indexterm" id="id115"/>source rectangle's <code class="literal">x</code> and <code class="literal">y</code> coordinates at 0 but they can also be moved around to only draw the section of the image that you want. We can move the <code class="literal">x</code> and <code class="literal">y</code> coordinates of the source to draw<a class="indexterm" id="id116"/> the bottom-right section of the image rather than the top-left. Place this code just before where we set the destination rectangle's location.<div><pre class="programlisting">m_sourceRectangle.x = 50;
m_sourceRectangle.y = 50;</pre></div><p>You can see that we are still drawing to the same destination location but we are copying a different 50 x 50 section of the image.</p><div><img alt="Source and destination rectangles" src="img/6821OT_02_07.jpg"/></div></li><li class="listitem">We can also pass null into the render copy for either rectangle.<div><pre class="programlisting">SDL_RenderCopy(m_pRenderer, m_pTexture, 0, 0);</pre></div><p>Passing<a class="indexterm" id="id117"/> null into the<a class="indexterm" id="id118"/> source rectangle parameter will make the renderer use the entire texture. Likewise, passing null to the destination rectangle parameter will use the entire renderer for display.</p><div><img alt="Source and destination rectangles" src="img/6821OT_02_08.jpg"/></div></li></ol></div><p>We have covered a few different <a class="indexterm" id="id119"/>ways that we can use rectangles to <a class="indexterm" id="id120"/>define areas of images that we would like to draw. We will now put that knowledge into practice by displaying an animated sprite sheet.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Animating a sprite sheet</h2></div></div></div><p>We can apply our understanding of source and destination rectangles to the animation of a sprite sheet. A sprite sheet is a series of animation frames all put together into one image. The separate <a class="indexterm" id="id121"/>frames need to have a very specific width and height so that they create a seamless motion. If one part of the sprite <a class="indexterm" id="id122"/>sheet is not correct it will make the whole animation look out of place or completely wrong. Here is an example sprite sheet that we will use for this demonstration:</p><div><img alt="Animating a sprite sheet" src="img/6821OT_02_09.jpg"/></div><div><ol class="orderedlist arabic"><li class="listitem">This animation is six frames long and each frame is 128 x 82 pixels. We know from the previous section that we can use a source rectangle to grab a certain part of an image. <a class="indexterm" id="id123"/>Therefore<a class="indexterm" id="id124"/> we can start by defining a source rectangle that encompasses the first frame of the animation only.<div><img alt="Animating a sprite sheet" src="img/6821OT_02_10.jpg"/></div></li><li class="listitem">Since we know the width, height, and location of the frame on the sprite sheet we can go ahead and hardcode these values into our source rectangle. First we must load the new <code class="literal">animate.bmp</code> file. Place it into your assets folder and alter the loading code.<div><pre class="programlisting">SDL_Surface* pTempSurface = SDL_LoadBMP("assets/animate.bmp");</pre></div></li><li class="listitem">This will now load our new sprite sheet BMP. We can remove the <code class="literal">SDL_QueryTexture</code> function as we are now defining our own sizes. Alter the size of the source rectangle to only get the first frame of the sheet.<div><pre class="programlisting">m_sourceRectangle.w = 128;
m_sourceRectangle.h = 82;</pre></div></li><li class="listitem">We will leave the <code class="literal">x</code> and <code class="literal">y</code> position of both rectangles at <code class="literal">0</code> so that we draw the image from the top-left corner and also copy it to the top-left corner of the renderer. We will also leave the dimensions of the destination rectangle as we want it to remain the same as the source rectangle. Pass both rectangles into the <code class="literal">SDL_RenderCopy</code> function:<div><pre class="programlisting">SDL_RenderCopy(m_pRenderer, m_pTexture, &amp;m_sourceRectangle, &amp;m_destinationRectangle);</pre></div><p>Now when we build we will have the first frame of the animation.</p><div><img alt="Animating a sprite sheet" src="img/6821OT_02_11.jpg"/></div></li><li class="listitem">Now that we have the first frame, we can move on to animating the sprite sheet. Each frame has<a class="indexterm" id="id125"/> the exact<a class="indexterm" id="id126"/> same dimensions. This is extremely important for this sheet to animate correctly. All we want to do is move the location of the source rectangle, not its dimensions.<div><img alt="Animating a sprite sheet" src="img/6821OT_02_12.jpg"/></div></li><li class="listitem">Every time we want to move another frame, we simply move the location of the source rectangle and copy it to the renderer. To do this we will use our <code class="literal">update</code> function.<div><pre class="programlisting">void Game::update()
{
  m_sourceRectangle.x = 128 * int(((SDL_GetTicks() / 100) % 6));
}</pre></div></li><li class="listitem">Here we have used <code class="literal">SDL_GetTicks()</code> to find out the amount of milliseconds since SDL was initialized. We then divide this by the amount of time (in ms) we want between frames and then use the modulo operator to keep it in range of the amount of<a class="indexterm" id="id127"/> frames we have in our animation. This code will (every 100 milliseconds) shift the <code class="literal">x</code> value of our source<a class="indexterm" id="id128"/> rectangle by 128 pixels (the width of a frame), multiplied by the current frame we want, giving us the correct position. Build the project and you should see the animation displayed.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Flipping images</h2></div></div></div><p>In most games, players, enemies, and so on, will move in more than one direction. To allow the sprite to face in the direction it is moving we will have to flip our sprite sheet. We could of <a class="indexterm" id="id129"/>course create a new row in our sprite sheet with the frames flipped, but this would use more memory, which we do not want. SDL 2.0 has another render function that allows us to pass <a class="indexterm" id="id130"/>in the way we want our image to be flipped or rotated. The function we will use is <code class="literal">SDL_RenderCopyEx</code>. This function takes the same parameters as <code class="literal">SDL_RenderCopy</code> but also takes specific parameters for rotation and flipping. The fourth parameter is the angle we want the image to be displayed with <a class="indexterm" id="id131"/>parameter five being the center point we want for the rotation. The final parameter is an enumerated type called <code class="literal">SDL_RendererFlip</code>.</p><p>The following table shows the available values for the <code class="literal">SDL_RendererFlip</code> enumerated type:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SDL_RendererFlip value</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_FLIP_NONE</code>
<a class="indexterm" id="id132"/>
</p>
</td><td style="text-align: left" valign="top">
<p>No flipping</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_FLIP_HORIZONTAL</code>
<a class="indexterm" id="id133"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Flip the texture horizontally</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_FLIP_VERTICAL</code>
<a class="indexterm" id="id134"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Flip the texture vertically</p>
</td></tr></tbody></table></div><p>We can use this parameter to flip our image. Here is the revised render function:</p><div><pre class="programlisting">void Game::render()
{
  SDL_RenderClear(m_pRenderer);

  SDL_RenderCopyEx(m_pRenderer, m_pTexture,
  &amp;m_sourceRectangle, &amp;m_destinationRectangle,
  0, 0, SDL_FLIP_HORIZONTAL); // pass in the horizontal flip

  SDL_RenderPresent(m_pRenderer);
}</pre></div><p>Build the project and you will see that the image has been flipped and is now facing to the left. Our characters<a class="indexterm" id="id135"/> and enemies will also have frames <a class="indexterm" id="id136"/>specifically for animations such as attack and jump. These can be added to different rows of the sprite sheet and the source rectangle's <code class="literal">y</code> value is incremented accordingly. (We will cover this in more detail when we create our game objects.)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Installing SDL_image</h1></div></div></div><p>So far we have only <a class="indexterm" id="id137"/>been loading BMP image files. This is all that SDL supports without any extensions. We can use <code class="literal">SDL_image</code> to enable us to load many different image file types such as BMP, GIF, JPEG, LBM, PCX, PNG, PNM, TGA, TIFF, WEBP, XCF, XPM, and XV. First we will need to clone the latest build of <code class="literal">SDL_image</code> to ensure it will work with SDL 2.0:</p><div><ol class="orderedlist arabic"><li class="listitem">Open up the <code class="literal">TortoiseHg</code> workbench and use <em>Ctrl</em> + <em>Shift</em> + <em>N</em> to clone a new repository.</li><li class="listitem">The repository for SDL_image is listed on <a class="ulink" href="http://www.libsdl.org/projects/SDL_image/">http://www.libsdl.org/projects/SDL_image/</a> and <a class="ulink" href="http://hg.libsdl.org/SDL_image/">http://hg.libsdl.org/SDL_image/</a>. So let's go ahead and type that into the <strong>Source</strong> box.</li><li class="listitem">Our destination will be a new directory, <code class="literal">C:\SDL2_image</code>. After typing this into the <strong>Destination</strong> box, hit <strong>clone</strong> and wait for it to complete.</li><li class="listitem">Once you have created this folder, navigate to our <code class="literal">C:\SDL2_image</code> cloned repository. Open up the <code class="literal">VisualC</code> folder and then open the <code class="literal">SDL_image_VS2010</code> VC++ project with Visual Studio 2010 express.</li><li class="listitem">Right-click on the <code class="literal">SDL2_image</code> project and then click on <strong>Properties</strong>. Here we have to include the <code class="literal">SDL.h</code> header file. Change the configuration to <strong>All Configurations</strong>, navigate to <strong>VC++ Directories</strong>, click on the <strong>Include Directories</strong> drop-down, and then on <strong>&lt;Edit…&gt;</strong>. Here we can put in our <code class="literal">C:\SDL2\include\</code> directory.</li><li class="listitem">Next move to <strong>Library Directories</strong> and add our <code class="literal">C:\SDL2\lib\</code> folder. Now navigate to <strong>Linker</strong> | <strong>Input</strong> | <strong>Additional Dependencies</strong> and add <code class="literal">SDL2.lib</code>.</li><li class="listitem">Click on <strong>OK</strong> and we are almost ready to build. We are now using <code class="literal">SDL2.lib</code>, so we can remove the <code class="literal">SDL.lib</code> and the <code class="literal">SDLmain.lib</code> files from the <code class="literal">SDL_image</code> project. Locate <a class="indexterm" id="id138"/>the files in the solution explorer, right-click and then remove the files. Change the build configuration to <strong>release</strong> and then build.</li><li class="listitem">An error about being unable to start the program may appear. Just click on <strong>OK</strong> and we can close the project and continue.</li><li class="listitem">There will now be a <code class="literal">Release</code> folder inside our <code class="literal">C:\SDL2_image\VisualC\</code> folder. Open it and copy the <code class="literal">SDL_image.dll</code> to our game's executable folder.</li><li class="listitem">Next copy the <code class="literal">SDL2_image.lib</code> file into our original <code class="literal">C:\SDL2\lib\</code> directory. Also copy the <code class="literal">SDL_image</code> header from <code class="literal">C:\SDL2_image\</code> to the <code class="literal">C:\SDL2\include\</code> directory.</li><li class="listitem">We just have a few more libraries to get and we are done. Download the <code class="literal">SDL_image-1.2.12-win32.zip</code> file (or the x64 if you are targeting a 64 bit platform) from <a class="ulink" href="http://www.libsdl.org/projects/SDL_image/">http://www.libsdl.org/projects/SDL_image/</a>. Extract all and then copy all of the <code class="literal">.dll</code> files apart from <code class="literal">SDL_image.dll</code> into our game's executable folder.</li><li class="listitem">Open up our game project and go into its properties. Navigate to <strong>Linker</strong> | <strong>Input</strong> | <strong>Additional Dependencies</strong> and add <code class="literal">SDL2_image.lib</code>.<div><img alt="Installing SDL_image" src="img/6821OT_02_14.jpg"/></div></li><li class="listitem">We have now installed <code class="literal">SDL_image</code> and can start to load all kinds of different image files. Copy the <code class="literal">animate.png</code> and <code class="literal">animate-alpha.png </code>images from the source <a class="indexterm" id="id139"/>downloads to our games assets folder and we can start loading PNG files.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Using SDL_image</h2></div></div></div><p>So we have the library installed, now how do we use it? It is simple to use SDL_image in place of the regular <a class="indexterm" id="id140"/>SDL image loading. In our case we only need to replace one function and also add <code class="literal">#include &lt;SDL_image.h&gt;</code>.</p><div><pre class="programlisting">SDL_Surface* pTempSurface = SDL_LoadBMP("assets/animate.bmp");</pre></div><p>The preceding code will be changed as follows:</p><div><pre class="programlisting">SDL_Surface* pTempSurface = IMG_Load("assets/animate.png");</pre></div><p>We are now loading a <code class="literal">.png</code> image. PNG files are great to work with, they have a small file size and support an alpha channel. Let's perform a test. Change our renderer clear color to red.</p><div><pre class="programlisting">SDL_SetRenderDrawColor(m_pRenderer, 255,0,0,255);</pre></div><p>You will see that we still have our black background from the image we are using; this is definitely not ideal for our purposes.</p><div><img alt="Using SDL_image" src="img/6821OT_02_15.jpg"/></div><p>When using PNG files, we can resolve this by using an alpha channel. We remove the background from the<a class="indexterm" id="id141"/> image and then when we load it, SDL will not draw anything from the alpha channel.</p><div><img alt="Using SDL_image" src="img/6821OT_02_16.jpg"/></div><p>Let's load this image and see how it looks:</p><div><pre class="programlisting">SDL_Surface* pTempSurface = IMG_Load("assets/animate-alpha.png");</pre></div><p>This is exactly what we want:</p><div><img alt="Using SDL_image" src="img/6821OT_02_17.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Tying it into the framework</h1></div></div></div><p>We have covered a lot on the subject of drawing images with SDL but we have yet to tie everything together into our framework so that it becomes reusable throughout our game. What we will now cover is creating a texture manager class that will have all of the functions we need to easily load and draw textures.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Creating the texture manager</h2></div></div></div><p>The texture manager <a class="indexterm" id="id142"/>will have functions that allow us to load and create an <code class="literal">SDL_Texture</code> structure from an image file, draw the texture (either static or animated), and also hold a list of <code class="literal">SDL_Texture*</code>, so that we can use them whenever we need to. Let's go<a class="indexterm" id="id143"/> ahead and create the <code class="literal">TextureManager.h</code> file:</p><div><ol class="orderedlist arabic"><li class="listitem">First we declare our <code class="literal">load</code> function. As parameters, the function takes the filename of the image we want to use, the ID we want to use to refer to the texture, and the renderer we want to use.<div><pre class="programlisting">bool load(std::string fileName,std::string id, SDL_Renderer* pRenderer);</pre></div></li><li class="listitem">We will create two draw functions, <code class="literal">draw</code> and <code class="literal">drawFrame</code>. They will both take the ID of the texture we want to draw, the <code class="literal">x</code> and <code class="literal">y</code> position we want to draw to, the height and width of the frame or the image we are using, the renderer we will copy to, and an <code class="literal">SDL_RendererFlip</code> value to describe how we want the image to be displayed (default is <code class="literal">SDL_FLIP_NONE</code>). The <code class="literal">drawFrame</code> function will take two additional parameters, the current frame we want to draw and which row it is on in the sprite sheet.<div><pre class="programlisting">// draw
void draw(std::string id, int x, int y, int width, int height, SDL_Renderer* pRenderer, SDL_RendererFlip flip = SDL_FLIP_NONE);

// drawframe

void drawFrame(std::string id, int x, int y, int width, int height, int currentRow, int currentFrame, SDL_Renderer* pRenderer, SDL_RendererFlip flip = SDL_FLIP_NONE);</pre></div></li><li class="listitem">The <code class="literal">TextureManager</code> class<a class="indexterm" id="id144"/> will also contain <code class="literal">std::map</code> of pointers to the <code class="literal">SDL_Texture</code> objects, keyed using <code class="literal">std::strings</code>.<div><pre class="programlisting">std::map&lt;std::string, SDL_Texture*&gt; m_textureMap;</pre></div></li><li class="listitem">We now must define these functions in a <code class="literal">TextureManager.cpp</code> file. Let's start with the <code class="literal">load</code> function. We will take the code from our previous texture loading and use it within this <code class="literal">load</code> method.<div><pre class="programlisting">bool TextureManager::load(std::string fileName, std::string id, SDL_Renderer* pRenderer)
{
  SDL_Surface* pTempSurface = IMG_Load(fileName.c_str());

  if(pTempSurface == 0)
  {
    return false;
  }

  SDL_Texture* pTexture = 
  SDL_CreateTextureFromSurface(pRenderer, pTempSurface);

  SDL_FreeSurface(pTempSurface);

  // everything went ok, add the texture to our list
  if(pTexture != 0)
  {
    m_textureMap[id] = pTexture;
    return true;
  }

  // reaching here means something went wrong
  return false;
}</pre></div></li><li class="listitem">When we<a class="indexterm" id="id145"/> call this function we will then have <code class="literal">SDL_Texture</code> that can be used by accessing it from the map using its ID; we will use this in our <code class="literal">draw</code> functions. The<a class="indexterm" id="id146"/> <code class="literal">draw</code> function can be defined as follows:<div><pre class="programlisting">void TextureManager::draw(std::string id, int x, int y, int width, int height, SDL_Renderer* pRenderer, SDL_RendererFlip flip)
{
  SDL_Rect srcRect;
  SDL_Rect destRect;

  srcRect.x = 0;
  srcRect.y = 0;
  srcRect.w = destRect.w = width;
  srcRect.h = destRect.h = height;
  destRect.x = x;
  destRect.y = y;

  SDL_RenderCopyEx(pRenderer, m_textureMap[id], &amp;srcRect, 
  &amp;destRect, 0, 0, flip);
}</pre></div></li><li class="listitem">We again use <code class="literal">SDL_RenderCopyEx</code> using the passed in ID variable to get the <code class="literal">SDL_Texture</code> <a class="indexterm" id="id147"/>object we want to draw. We also build our source and destination variables using the passed in <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">width</code>, and <code class="literal">height</code> values. Now we can move onto <code class="literal">drawFrame</code>:<div><pre class="programlisting">void TextureManager::drawFrame(std::string id, int x, int y, int width, int height, int currentRow, int currentFrame, SDL_Renderer *pRenderer, SDL_RendererFlip flip)
{
  SDL_Rect srcRect;
  SDL_Rect destRect;
  srcRect.x = width * currentFrame;
  srcRect.y = height * (currentRow - 1);
  srcRect.w = destRect.w = width;
  srcRect.h = destRect.h = height;
  destRect.x = x;
  destRect.y = y;

  SDL_RenderCopyEx(pRenderer, m_textureMap[id], &amp;srcRect, 
  &amp;destRect, 0, 0, flip);
}</pre></div><p>In this function, we create a source rectangle to use the appropriate frame of the animation using the <code class="literal">currentFrame</code> and <code class="literal">currentRow</code> variables. The source rectangle's <code class="literal">x</code> position for the current frame is the width of the source rectangle multiplied by the <code class="literal">currentFrame</code> value (covered in the <em>Animating a sprite sheet</em> section). Its <code class="literal">y</code> value is the height of the rectangle multiplied by <code class="literal">currentRow – 1</code> (it sounds more natural to use the first row, rather than the zeroth row).</p></li><li class="listitem">We now have everything we need to easily load and draw textures throughout our game. Let's go ahead and test it out using the <code class="literal">animated.png</code> image. Open up <code class="literal">Game.h</code>. We will not need our texture member variables or the rectangles anymore, so delete any of the code dealing with them from the <code class="literal">Game.h</code> and <code class="literal">Game.cpp</code> files. We will however create two new member variables.<div><pre class="programlisting">int m_currentFrame;
TextureManager m_textureManager;</pre></div></li><li class="listitem">We will use the <code class="literal">m_currentFrame</code> variable to allow us to animate our sprite sheet and <a class="indexterm" id="id148"/>we also need an instance of our new <code class="literal">TextureManager</code> class (ensure you include <code class="literal">TextureManager.h</code>). We can now load a texture in the game's <code class="literal">init</code> function.<div><pre class="programlisting">m_textureManager.load("assets/animate-alpha.png", "animate", m_pRenderer);</pre></div></li><li class="listitem">We have given this texture an ID of <code class="literal">"animate"</code> which we can use in our <code class="literal">draw</code> functions. We will start by drawing a static image at 0,0 and an animated image at 100,100. Here is the render function:<div><pre class="programlisting">void Game::render()
{

  SDL_RenderClear(m_pRenderer);

  m_textureManager.draw("animate", 0,0, 128, 82, 
  m_pRenderer);

  m_textureManager.drawFrame("animate", 100,100, 128, 82, 
  1, m_currentFrame, m_pRenderer);

  SDL_RenderPresent(m_pRenderer);

}</pre></div></li><li class="listitem">The drawFrame function uses our <code class="literal">m_currentFrame</code> member variable. We can increment this in the <a class="indexterm" id="id149"/><code class="literal">update</code> function like we did before, but we now do the calculation of the source rectangle inside the <code class="literal">draw</code> function.<div><pre class="programlisting">void Game::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));
}</pre></div><p>Now we can build and see our hard work in action.</p></li></ol></div><div><img alt="Creating the texture manager" src="img/6821OT_02_18.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Using texture manager as a singleton</h2></div></div></div><p>Now that we have our texture manager in place we still have one problem. We want to reuse this <code class="literal">TextureManager</code> throughout our game so we don't want it to be a member of our <code class="literal">Game</code> class because<a class="indexterm" id="id150"/> then we would have to pass it into our draw function. A good option for us is to implement <code class="literal">TextureManager</code> as a singleton. A singleton is a class that can only have one instance. This works for us, as we want to reuse the same <code class="literal">TextureManager</code> throughout our game. We can make our <code class="literal">TextureManager</code> a singleton by first making its constructor private.</p><div><pre class="programlisting">private:

TextureManager() {}</pre></div><p>This is to ensure that it cannot be created like other objects. It can only be created and accessed using the <a class="indexterm" id="id151"/>
<code class="literal">Instance</code> function, which we will declare and define.</p><div><pre class="programlisting">static TextureManager* Instance()
{
  if(s_pInstance == 0)
  {
    s_pInstance = new TextureManager();
    return s_pInstance;
  }

  return s_pInstance;
}</pre></div><p>This function checks whether we already have an instance of our <code class="literal">TextureManager</code>. If not, then it constructs it,<a class="indexterm" id="id152"/> otherwise it simply returns the static instance. We will also <code class="literal">typedef</code> the <code class="literal">TextureManager</code>.</p><div><pre class="programlisting">typedef TextureManager TheTextureManager;</pre></div><p>We must also define the static instance in <code class="literal">TextureManager.cpp</code>.</p><div><pre class="programlisting">TextureManager* TextureManager::s_pInstance = 0;</pre></div><p>We can now use our <code class="literal">TextureManager</code> as a singleton. We no longer have to have an instance of <code class="literal">TextureManager</code> in our<a class="indexterm" id="id153"/> <code class="literal">Game</code> class, we just include the header and use it as follows:</p><div><pre class="programlisting">// to load
if(!TheTextureManager::Instance()-&gt;load("assets/animate-alpha.png", "animate", m_pRenderer))
{
   return false;
}
// to draw
TheTextureManager::Instance()-&gt;draw("animate", 0,0, 128, 82, m_pRenderer);</pre></div><p>When we load a texture in our <code class="literal">Game</code> (or any other) class we can then access it throughout our code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>This chapter has been all about rendering images onto the screen. We have covered source and destination rectangles and animating a sprite sheet. We took what we learned and applied it to creating a reusable texture manager class, enabling us to easily load and draw images throughout our game. In the next chapter, we will cover using inheritance and polymorphism to create a base game object class and use it within our game framework.</p></div></body></html>