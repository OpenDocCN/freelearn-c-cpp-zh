<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">Creating Flexibility with the Component Object Model</h1>
            

            
                
<p class="calibre2">In the last chapter, we saw how the Singleton pattern can help us solve the problem of creating and using the big core engines of our game. The engine code is designed to work with any game, meaning there is nothing gameplay-specific about it. So as the game design evolves, we don't need to worry about changes in game design breaking our engine. The goal when writing code for a graphics or physics engine is to make it as reusable or game-agnostic as possible. This means that when you are done making the current game, you should be able to use the code in the next game with very little or no change. The way to do this is to separate the engine code from anything related to the specific game.</p>
<p class="calibre2">Game objects, on the other hand, are completely specific to our game. If the game changes, all our object types will need to change as well. If we are making a platformer and suddenly change to making a Space Shooter, our graphics and physics engine code probably doesn't need to change. However, every single game object and behavior will change. While this may be the most extreme example, the fact is that our game objects are likely to change a lot. So let's look at how we can use patterns to solve this small, but very important, piece of our game.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            
                
<p class="calibre2">In this chapter, we will be focusing on creating a game object that is flexible enough to adapt as our game design changes. We will do this by first looking at the two most common ways that new programmers create a game object, and the problems that arise when we use these approaches. Then we will discuss two design patterns that can help us solve our problem. Finally, we will arrive at our solution of creating a reusable, flexible game object. Since we know our game design and game objects are likely to change, the questions we are going to answer are the following:</p>
<ul class="calibre17">
<li class="calibre18">Is it possible to write game objects in a reusable way?</li>
<li class="calibre18">How can we decouple our game objects from our core engine code?</li>
<li class="calibre18">If we have a reusable game object, how can we make it flexible enough to use in different games or account for changes in our game design while the game is being developed?</li>
</ul>
<p class="calibre2">Along the way, we will discuss a few important design principles that will come up again and again in this book that will help you write clean and solid code.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            
                
<p class="calibre2">Over the course of this chapter, we will be focusing on a lot of important concepts and diving deep into some interesting code. Some of these concepts are about ways not to implement a game object. Learning the wrong way is often just as important as learning the right way. Here is an outline of the topics we will cover and your tasks for this chapter:</p>
<ul class="calibre17">
<li class="calibre18">Why a monolithic game object is a bad design</li>
<li class="calibre18">Why inheritance hierarchies are inflexible</li>
<li class="calibre18">Learning and implementing the Strategy pattern and the Decorator pattern</li>
<li class="calibre18">Learning and implementing the Component Object Model</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Why a monolithic game object is a bad design</h1>
            

            
                
<p class="calibre2">When you break it down to the simplest terms, programming is about solving problems with code. Someone has an idea for a game or an app, and the problem that needs to be solved is how to describe that idea logically and correctly to the computer. Day to day, these problems usually come in the form of integrating code you wrote today with code written earlier by you or another programmer. When solving these problems, there is a constant struggle between doing things the <em class="calibre12">easy way</em> or doing them the <em class="calibre12">right way</em>.</p>
<p class="calibre2">The <em class="calibre12">easy way</em> to solve a problem means solving the immediate problem in the fastest way possible. Examples of this might be hardcoding a number or string literal instead of using a named constant, copying code instead of writing a function or refactoring code into a base class, or just writing code without thinking about how it can impact the rest of the code base.</p>
<p class="calibre2">On the other hand, solving a problem the <em class="calibre12">right way</em> means thinking about how the new code will interact with the old code. It also means thinking about how the new code will interact with future code if the design changes. The <em class="calibre12">right way</em> doesn't mean that there is only one correct solution to the problem. There are often many possible ways to reach the same result. The creativity involved in programming is one of the reasons programming is so much fun.</p>
<p class="calibre2">Veteran programmers know that in the long run, the <em class="calibre12">easy way</em> often turns out to be more difficult. This is often because a quick fix solves an immediate problem but doesn't consider the changes that will occur as the project evolves.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The monolithic game object</h1>
            

            
                
<p class="calibre2">The <em class="calibre12">easy way</em> to do a game object is to have a single <kbd class="calibre14">struct</kbd> that contains all of the data a game object will need. This seems correct because everything in the game has the same basic data. For example, we know players and enemies all have a position, scale, and rotation. So our struct will look like this:</p>
<pre class="calibre23">
struct GameObject <br class="title-page-name"/>{ <br class="title-page-name"/>  //using vectors from the Mach 5 Engine <br class="title-page-name"/>  M5Vec2 pos; <br class="title-page-name"/>  M5Vec2 scale; <br class="title-page-name"/>  float rotation; <br class="title-page-name"/>};
</pre>
<p class="calibre2">This game object works well in theory, but it is too basic. It is true that everything in our game probably needs a position, scale, and rotation. Even an invisible trigger region needs these properties. However, as it stands, we can't draw our object: we have no health, and no way to do damage. So, let's add a few things to make the game object a little more real:</p>
<pre class="calibre23">
struct Object <br class="title-page-name"/>{ <br class="title-page-name"/>  //using vectors from the Mach 5 Engine <br class="title-page-name"/>  M5Vec2 pos; <br class="title-page-name"/>  M5Vec2 scale; <br class="title-page-name"/>  float rotation; <br class="title-page-name"/>  float damage; <br class="title-page-name"/>  int health; <br class="title-page-name"/>  int textureID;      //for drawing <br class="title-page-name"/>  float textureCoords[4]; //for sprite animation <br class="title-page-name"/>  unsignedchar color[4]; //the color of our image <br class="title-page-name"/>};
</pre>
<p class="calibre2">Now we have added a few more basic elements to our game object. Most of our game object types will have health and damage, and we have added a texture ID so we can draw our game object, and some texture coordinates so we can use a sprite sheet for animation. Finally, we added a color so we can reuse the same texture and color it differently for different enemies (think about the different ghosts in Namco's <em class="calibre12">Pacman</em>).</p>
<p class="calibre2">This is not that bad yet but, unfortunately, this is just the beginning. Once we start making a real game instead of just brainstorming about a basic game object, our struct member count starts to explode.</p>
<p class="calibre2">Imagine we are making a Space Shooter. There are lots of things we will want to add:</p>
<ul class="calibre17">
<li class="calibre18">The player will have multiple types of weapons that all do different amounts of damage</li>
<li class="calibre18">The player might have access to bombs and missiles that each have an ammo count</li>
<li class="calibre18">The missile needs a target to seek</li>
<li class="calibre18">The bomb needs an explosion radius</li>
<li class="calibre18">There are two super enemies that each have a special ability with a cool-down time</li>
<li class="calibre18">The player and one super enemy both have the ability to use a shield</li>
<li class="calibre18">The UI buttons have some actions associated with clicking them</li>
<li class="calibre18">We have power-ups that add health and add lives</li>
<li class="calibre18">We need to add a lives count to all objects to account for the power up</li>
<li class="calibre18">We should add velocity to objects and do time-based movement instead of just setting the position directly</li>
<li class="calibre18">We need to add an enumeration for the type of the game object so we can update it properly</li>
</ul>
<p class="calibre2">Here is what our game object looks like now:</p>
<pre class="calibre23">
struct GameObject <br class="title-page-name"/>{ <br class="title-page-name"/> M5Vec2    pos; <br class="title-page-name"/> M5Vec2    scale; <br class="title-page-name"/> M5Vec2    vel; <br class="title-page-name"/> float     rotation;  <br class="title-page-name"/> ObjectType  type;     //Our object type enum <br class="title-page-name"/> int       objectID;   //So the missile can target <br class="title-page-name"/> int       lives; <br class="title-page-name"/> int       shieldHealth; //For Player and SuperBomber <br class="title-page-name"/> int       health; <br class="title-page-name"/> float     playerLaserDamage; <br class="title-page-name"/> float     playerIonDamage; <br class="title-page-name"/> float     playerWaveCannonDamage; <br class="title-page-name"/> float     superRaiderDamage; <br class="title-page-name"/> float     superRaiderAbilityDamage; <br class="title-page-name"/> float     superRaiderAbilityCoolDownTime; <br class="title-page-name"/> float     superBomberDamage; <br class="title-page-name"/> float     superBomberAbilityDamage; <br class="title-page-name"/> float     superBomberAbilityCoolDownTime; <br class="title-page-name"/> int       bombCount; <br class="title-page-name"/> float     bombRadius; <br class="title-page-name"/> int       missileCount; <br class="title-page-name"/> int       missileTargetID; <br class="title-page-name"/> int       textureID;    //the object image <br class="title-page-name"/> float     textureCoords[4];//for sprite animation <br class="title-page-name"/> unsigned  char color[4];    //the color of our image <br class="title-page-name"/> Command*  command;     //The command to do <br class="title-page-name"/>};
</pre>
<p class="calibre2">As you can see, this basic method of creating a game object doesn't scale very well. We already have more than 25 members in our struct and we haven't even talked about adding space stations that can spawn or repair units. We have only two boss types, we can make a few enemy types by allowing different enemies to use different player weapons such as the laser or missiles, but we are still limited.</p>
<p class="calibre2">The major problem with this approach is that, as the game gets bigger, our game object must also get very big. Some types, such as the player, will use many of these members, but other types, such as a UI button, will only use a small amount. This means if we have lots of game objects, we are very likely wasting a lot of memory per object.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The problem with object behavior</h1>
            

            
                
<p class="calibre2">So far, we have only considered what members the game object has. We haven't considered how each object will have its behavior updated. Right now, the game object is just data. Since it has no functions, it can't update itself. We could easily add an <kbd class="calibre14">Update</kbd> function for the game object but, in order to update each type of object correctly, we would need a <kbd class="calibre14">switch</kbd> statement:</p>
<pre class="calibre23">
//Create our objects <br class="title-page-name"/>Object gameObjects[MAX_COUNT]; <br class="title-page-name"/> <br class="title-page-name"/>//initialization code here <br class="title-page-name"/>//... <br class="title-page-name"/> <br class="title-page-name"/>//Update loop <br class="title-page-name"/>for(int i = 0; i &lt; objectInUse; ++i) <br class="title-page-name"/>{ <br class="title-page-name"/>  switch(gameObjects[i].type) <br class="title-page-name"/>  { <br class="title-page-name"/>    case OT_PLAYER: <br class="title-page-name"/>      //Update based on input <br class="title-page-name"/>      break; <br class="title-page-name"/>    case OT_SUPER_RAIDER: <br class="title-page-name"/>      //Add intercept code here <br class="title-page-name"/>      break; <br class="title-page-name"/>    case OT_SUPER_BOMBER: <br class="title-page-name"/>      //Add case code here <br class="title-page-name"/>      break; <br class="title-page-name"/>    case OT_MISSILE: <br class="title-page-name"/>      //Add find target and chase code here <br class="title-page-name"/>      break; <br class="title-page-name"/>    case OT_BOMB: <br class="title-page-name"/>      //add grow to max radius code here <br class="title-page-name"/>      break; <br class="title-page-name"/>    default: <br class="title-page-name"/>      M5DEBUG_ASSERT(true, "Incorrect Object Type"); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Again, this approach doesn't scale well. As we add more object types, we need to add even more cases to our <kbd class="calibre14">switch</kbd> statement. Since we only have one <kbd class="calibre14">struct</kbd> type, we need to have a <kbd class="calibre14">switch</kbd> statement, whenever we need to do something object-type-specific.</p>
<p class="calibre2">If we are adding behaviors, we will also face the decision of adding data to our object or hardcoding a value into the <kbd class="calibre14">switch</kbd> statement. For example, if our bomb grows in size, how does it grow? We could hard code <kbd class="calibre14">scale.x *= 1.1f</kbd> into our <kbd class="calibre14">switch</kbd> statement or we can add member data float <kbd class="calibre14">bombScaleFactor</kbd> to our struct.</p>
<p class="calibre2">In the end, this approach just isn't that flexible. Changing our design is very difficult because there are <kbd class="calibre14">switch</kbd> statements and public members throughout our code. If we were to make a game like this, then our code base would be a complete mess after only a few months. The worst part would be that once the game was completed, we wouldn't be able to reuse any code. The game object and all behaviors would be so gameplay-specific that unless we make a sequel, we would need to remake a brand new game object.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The benefits of the monolithic game object</h1>
            

            
                
<p class="calibre2">It is worth noting that even if you choose this approach, you can still have your core engines decoupled from the game object. When writing the graphics engine, for example, instead of passing in a game object as a parameter to a <kbd class="calibre14">Draw</kbd> function, we could pass in the members that the graphics engine needs:</p>
<pre class="calibre23">
void Graphics::SetTexture(int textureID); <br class="title-page-name"/>void Graphics::SetTextureCoords(const float* coordArray); <br class="title-page-name"/>void Graphics::Draw(const M5Mtx44&amp; worldMtx); <br class="title-page-name"/>vs <br class="title-page-name"/>void Graphics::Draw(const Object&amp; obj);
</pre>
<p class="calibre2">Another argument for creating objects like this is that we know exactly what is in our game object. Compared with other approaches, we never need to cast our object or search for properties within the object. These operations make the code more complicated and have a slight performance cost. By using a simple <kbd class="calibre14">struct</kbd>, we have direct access to the variables and the code is easier to understand.</p>
<p class="calibre2">The only time we might use this approach is if we know 100% that the number of object types won't be large, for example, if you are making a puzzle game and the only game objects are sheep and walls. Puzzle games are often very simple and use the same mechanics over and over. In this case, this is a good approach because it is easy and doesn't require any time building a complicated system.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Why inheritance hierarchies are inflexible</h1>
            

            
                
<p class="calibre2">The idea that <strong class="calibre1">Players</strong>, <strong class="calibre1">Enemies</strong>, <strong class="calibre1">Missiles</strong>, and <strong class="calibre1">Medics</strong> should all derive from one base object is very common to programmers new to object-oriented programming. It makes a lot of sense on paper that if you have a Raider and a SuperRaider, one should inherit from the other. I believe this comes from how inheritance is taught. When you are first learning about inheritance, you will almost always see a picture similar to this:</p>
<div><img class="image-border11" src="img/00024.jpeg"/></div>
<p>Figure 3.1 - A typical inheritance diagram when learning to program</p>
<p class="calibre2">Many introductory programming courses are so focused on the mechanics of inheritance that they forget to tell you how to use it properly. A picture like the one above makes it easy to understand that ITWorker is an Employee, which is a Person. However, once you go beyond the mechanics, it is time to learn how to use inheritance correctly. This is why books on design patterns exist.</p>
<p class="calibre2">Inheritance is a powerful tool that lets us extend classes by adding members and methods that are specific to the derived classes. It allows us to start with general code and create more specialized classes. This solves one of the original problems that we had with the extremely bloated object struct in the first section. Inheritance lets us take an existing class, such as a Raider, and add more members to create a SuperRaider:</p>
<pre class="calibre23">
//Inheritance Based Object: <br class="title-page-name"/>class Object <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    Object(void); <br class="title-page-name"/>    virtual ~Object(void);//virtual destructor is important <br class="title-page-name"/>    virtual void Update(float dt); <br class="title-page-name"/>    virtual void CollisionReaction(Object* pCollidedWith); <br class="title-page-name"/>  protected: <br class="title-page-name"/>    //We still need the basic data in all object <br class="title-page-name"/>    M5Vec2 m_pos; <br class="title-page-name"/>    M5Vec2 m_scale; <br class="title-page-name"/>    float m_rotation; <br class="title-page-name"/>    int m_textureID; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//Inheritance Based derived class <br class="title-page-name"/>class Unit: public Object <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    Unit(void); <br class="title-page-name"/>    virtual ~Unit(void);   <br class="title-page-name"/>    virtual void Update(float dt); <br class="title-page-name"/>    virtual void CollisionReaction(Object* pCollidedWith); <br class="title-page-name"/>  protected: <br class="title-page-name"/>    M5Vec2 m_vel;//So that Units can move <br class="title-page-name"/>    float m_maxSpeed; <br class="title-page-name"/>    float m_health; <br class="title-page-name"/>    float m_damage; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class Enemy: public Unit <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    Enemy(void); <br class="title-page-name"/>    virtual ~Enemy(void); <br class="title-page-name"/>    virtual void Update(float dt); <br class="title-page-name"/>    virtual void CollisionReaction(Object* pCollidedWith); <br class="title-page-name"/>  protected: <br class="title-page-name"/>    unsigned char m_color[4]; <br class="title-page-name"/>    float m_textureCoords[4];//For animation <br class="title-page-name"/>};
</pre>
<div><img class="image-border12" src="img/00025.jpeg"/></div>
<p>Figure 3.2 - An example of Space Shooter inheritance hierarchy</p>
<p class="calibre2">This hierarchy makes a lot of sense when first designing a space shooter. It allows us to separate the details of a <kbd class="calibre14">Raider</kbd> class or a <kbd class="calibre14">Bomber</kbd> class away from the <kbd class="calibre14">Player</kbd> class. Adding a game object is easy because we can extend a class to create what we need. Removing a game object is easy because all the code is contained within each derived class. In fact, now that we have separate classes, each one can be responsible for itself via class methods. This means we no longer need <kbd class="calibre14">switch</kbd> statements all over our code.</p>
<p class="calibre2">Best of all, we can use the power of virtual functions to decouple our derived classes from the core engines of our game. By using an array of base class pointers to the derived class instances, our core engines such as graphics or physics are only coupled to the object interface instead of derived classes, such as <kbd class="calibre14">Planet</kbd> or <kbd class="calibre14">SpawnerStation</kbd>.</p>
<p class="calibre2">Without inheritance hierarchy, the code would be as follows:</p>
<pre class="calibre23">
//Create our objects <br class="title-page-name"/>Object gameObjects[MAX_COUNT]; <br class="title-page-name"/> <br class="title-page-name"/>//initialization code here <br class="title-page-name"/>//... <br class="title-page-name"/> <br class="title-page-name"/>for(int i = 0; i &lt; objectsInUse; ++i) <br class="title-page-name"/>{ <br class="title-page-name"/> switch(gameObjects[i].type) <br class="title-page-name"/> { <br class="title-page-name"/>  case OT_PLAYER: <br class="title-page-name"/>   //Update based on input <br class="title-page-name"/>  break; <br class="title-page-name"/>  case OT_PLANET: <br class="title-page-name"/>   //Add intercept code here <br class="title-page-name"/>  break; <br class="title-page-name"/>  case OT_ENEMY_SPAWNER: <br class="title-page-name"/>   //Add case code here <br class="title-page-name"/>  break; <br class="title-page-name"/>  case OT_RAIDER: <br class="title-page-name"/>   //Add find target and chase code here <br class="title-page-name"/>  break; <br class="title-page-name"/>  case OT_BOMBER: <br class="title-page-name"/>   //Move slowly and do large damage code here <br class="title-page-name"/>  break; <br class="title-page-name"/>  default: <br class="title-page-name"/>   M5DEBUG_ASSERT(true, "Incorrect Object Type"); <br class="title-page-name"/> } <br class="title-page-name"/>}
</pre>
<p class="calibre2">With inheritance and polymorphism, the code is as follows:</p>
<pre class="calibre23">
//Create our objects <br class="title-page-name"/>Object* gameObjects[MAX_COUNT];//array of pointers <br class="title-page-name"/> <br class="title-page-name"/>//initialization code here <br class="title-page-name"/>//... <br class="title-page-name"/> <br class="title-page-name"/>for(int i = 0; i &lt; objectsInUse; ++i) <br class="title-page-name"/>gameObjects[i]-&gt;Update(dt);
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Organizing the code by what it does, not what it is</h1>
            

            
                
<p class="calibre2">What is the difference between the Raider and the Bomber, really? How are a Raider and a SuperRaider different? Maybe they have a different speed, a different texture, and a different damage value? Do these changes in data really require a new class? Those are really just different values, not different behaviors. The problem is that we are creating extra classes because the concept of a Raider and SuperRaider is different, but there aren't differences in behavior.</p>
<p class="calibre2">Our class hierarchy actually violates three principles I teach, two of which I learned from the Gang of Four book:</p>
<p>"Keep your inheritance trees shallow"</p>
<p>"Favor object composition over class inheritance" - Gang of Four, p20</p>
<p>"Consider what should be variable in your design. This approach is the opposite of focusing on the cause of redesign. Instead of considering what might force a change to a design, consider what you want to be able to change without redesign. The focus here is on encapsulating the concept that varies, a theme of many design patterns" - Gang of Four, p29</p>
<p class="calibre2">A different way to state the third principle is the following:</p>
<p>"Find what varies and encapsulate it"</p>
<p class="calibre2">These principles exist to eliminate, or completely avoid, the problems that can and will arise when using inheritance.</p>
<p class="calibre2">The problem with our current design is that if we create a new class for every object type, we will end up with a lot of little classes that are mostly the same. Raider, SuperRaider, Bomber, and SuperBomber are mostly the same with just a few minor differences, some of which are only differences in <kbd class="calibre14">float</kbd> and <kbd class="calibre14">int</kbd> values. While this approach may seem like an improvement over the <em class="calibre12">easy way</em>, it becomes a problem because we will end up writing the same behavior code over and over again in many classes. If we have a lot of enemies, we might end up writing the same basic <kbd class="calibre14">ChasePlayerAI</kbd> code in every <kbd class="calibre14">Update</kbd> function. The only solution is moving the <kbd class="calibre14">ChasePlayerAI</kbd> up to a base class.</p>
<p class="calibre2">Let's take another look at our Space Shooter hierarchy but this time, let's add in some different behaviors to our classes:</p>
<div><img class="alignnone7" src="img/00026.jpeg"/></div>
<p>Figure 3.3 - After adding behavior to our objects (refer graphic bundle)</p>
<p class="calibre2">We have decided that our base <kbd class="calibre14">object</kbd> class will at least be drawable to make things simple. If an object such as a trigger region needs to be invisible, we can simply support disabling rendering by putting a <kbd class="calibre14">bool</kbd> in the drawable behavior so it won't get drawn. However, with this game object approach, I still have some duplicated code. Both the <kbd class="calibre14">Raider</kbd> class and the <kbd class="calibre14">AttackStation</kbd> class have some AI that targets and shoots bullets at the Player. We have only duplicated our code once so maybe it isn't a big deal.</p>
<p class="calibre2">Unfortunately, all game designs will change. What happens when our designer wants to add asteroids to our game? Technically, they are structures so they need some of the data inherited from that class, but they also move. Our designer also really liked the <kbd class="calibre14">SpawnerStation</kbd> class and wants to add that ability to a new <kbd class="calibre14">SpawnerPlanet</kbd> class, and to a new <kbd class="calibre14">BossSpawner</kbd> class. Should we rewrite the code two more times, or refactor the code into the base class? Our designer also wants to give the <kbd class="calibre14">Station</kbd> the ability to slowly patrol an area. This means the <kbd class="calibre14">Station</kbd> class needs the Patrol AI ability as well. Let's take a look at our hierarchy now:</p>
<div><img class="alignnone8" src="img/00027.jpeg"/></div>
<p>Figure 3 4 - After refactoring duplicate code to our base class (refer graphic bundle)</p>
<p class="calibre2">As it turns out, this approach isn't as flexible as it originally seemed. In order for our design to be really flexible, almost all of the behaviors need to be factored up into the base class. In the end, we aren't much better off than when we wrote our game object the <em class="calibre12">easy way</em>. And it is still possible that our designer will want to create the <kbd class="calibre14">RepairHelper</kbd> that chases the Player, meaning that everything will be in the base class.</p>
<p class="calibre2">This might sound like a contrived example but remember that games take years to develop and are likely to change. DMA Design's <em class="calibre12">Grand Theft Auto</em> was originally titled <em class="calibre12">Race'n'Chase</em>, but it was changed because a bug caused the police to try and run the Player off the road instead of pull them over. This ended up being way more fun. Another example is Blizzard's first-person shooter <em class="calibre12">Overwatch</em>, which was originally in development for 7 years as a massively multiplayer online game.</p>
<p>The purpose of object-oriented programming is to recognize that designs will change and to write code with that change in mind.</p>
<p class="calibre2">Another problem with our inheritance approach is that it isn't very easy to add or remove abilities at runtime. Let's say our game has a special power-up item that will let the Player use a shield for 1 minute. The shield will absorb 50% of the damage done to the Player for 1 minute then remove itself. We now have the problem of making sure that when a bullet collides with the shield, it will transfer some of the damage to the Player. The shield isn't just responsible for itself; it is responsible for the Player object too.</p>
<p class="calibre2">This same situation exists for all things that will affect another game object for some duration of time. Imagine if we want our Raider to be able to do acid damage to the Player over 5 seconds instead. We need a way to attach this acid damage to the Player, and to remember to remove it after 5 seconds. We could add new variables such as <kbd class="calibre14">bool</kbd> <kbd class="calibre14">hasAcid</kbd> and <kbd class="calibre14">float</kbd> <kbd class="calibre14">acidTime</kbd> in the <kbd class="calibre14">Player</kbd> class that we can use to know whether we should do acid damage in this frame. However, this still isn't a flexible solution, because each new type of damage caused over time will need new variables like this.</p>
<p class="calibre2">In addition, there is no way to stack the acid damage effect if three enemies are attacking the Player with acid damage. If we like this ability and want the Player to use it, we also need to give all game objects these extra time-based damage variables and behavior code. What we would really like to do is attach acid behavior (or any effect) onto a game object at runtime and have it automatically detach itself when the effect is over. We are going to talk about how to do that later in this chapter, but first we need to talk about one more problem related to inherence hierarchies in C++.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Avoiding the Diamond of Death</h1>
            

            
                
<p class="calibre2">The final problem with our inheritance approach involves the situation where we take code reuse to the extreme. In our hierarchy, we have SuperRaider, which is very fast, weak, and shoots little bullets. We also have SuperBomber, which is slow, strong, and shoots big bombs. Someday, a clever designer will want to create SuperBomberRaider that is very fast, strong, and shoots both little bullets and big bombs. Here is our partial tree:</p>
<div><img class="alignnone9" src="img/00028.jpeg"/></div>
<p>Figure 3.5 - Example of the Diamond of Death</p>
<p class="calibre2">This, of course, is the <strong class="calibre1">Diamond of Death</strong> (or <strong class="calibre1">Dreaded Diamond of Death</strong>), so named because the inheritance tree forms a diamond. The problem is that our <kbd class="calibre14">SuperBomberRaider</kbd> inherits from both the <kbd class="calibre14">SuperBomber</kbd> and <kbd class="calibre14">SuperRaider</kbd>. Those two classes each inherit from the <kbd class="calibre14">Enemy</kbd>, <kbd class="calibre14">Unit</kbd>, and <kbd class="calibre14">object</kbd>. That means <kbd class="calibre14">SuperBomberRaider</kbd> will have two copies of <kbd class="calibre14">m_pos</kbd>, <kbd class="calibre14">m_scale</kbd>, <kbd class="calibre14">m_rotation</kbd>, and every other member of <kbd class="calibre14">object</kbd>, <kbd class="calibre14">Unit</kbd>, and <kbd class="calibre14">Enemy</kbd>.</p>
<p class="calibre2">There will also be two copies of any functions that are contained in the <kbd class="calibre14">Object</kbd>, <kbd class="calibre14">Unit</kbd>, and <kbd class="calibre14">Enemy</kbd>. This means we need to specify which version of the functions we wish to use. This might sound good, since we get behavior from both classes, but remember that the individual base class function will only modify their version of variables. After calling <kbd class="calibre14">SuperRaider::Update</kbd> and <kbd class="calibre14">SuperBomber::Update</kbd>, we now need to figure out what version of <kbd class="calibre14">m_pos</kbd> (and <kbd class="calibre14">m_scale</kbd> and <kbd class="calibre14">m_rotation</kbd>) we want to use when we draw our object.</p>
<p class="calibre2">C++ has ways of solving this problem, but most programmers agree that the solution makes things more complicated to understand and more difficult to use. The rule of thumb is that we should just avoid using multiple inheritance. We have seen some of the problems that it can cause and we haven't even talked about bugs related to using <kbd class="calibre14">new</kbd> and <kbd class="calibre14">delete</kbd> in a situation like this.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Strategy pattern and the Decorator pattern</h1>
            

            
                
<p class="calibre2">We saw that in trying to be more flexible with our game object, a lot of behavior was factored into the base class. We also said that it would be nice to attach a behavior at runtime and have it detach itself when we are done with it.</p>
<p class="calibre2">There are actually two design patterns that have the potential to help our design, the Strategy pattern and the Decorator pattern. The Strategy pattern is all about encapsulating sets of behaviors instead of inheriting. The Decorator pattern is all about dynamically adding responsibilities as needed.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Strategy pattern explained</h1>
            

            
                
<p class="calibre2">The Strategy pattern is about encapsulating a set of behaviors and having the client control the behavior through an interface, instead of hardcoding the behavior into the client function itself. What this means is that we want the game object to be completely independent of the behavior it uses. Imagine that we want to give each enemy a different attack and flight AI. We could use the Strategy pattern instead of creating an inheritance tree:</p>
<pre class="calibre23">
class Enemy: public Unit <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    Enemy(void); <br class="title-page-name"/>    virtual ~Enemy(void); <br class="title-page-name"/>    virtual void Update(float dt); <br class="title-page-name"/>    virtual void CollisionReaction(Object* pCollidedWith); <br class="title-page-name"/>  protected: <br class="title-page-name"/>    unsigned char m_color[4]; <br class="title-page-name"/>    FlightAI*   m_flight; <br class="title-page-name"/>    AttackAI*   m_attack; <br class="title-page-name"/>};
</pre>
<p class="calibre2">In this case, our client is the <kbd class="calibre14">Enemy</kbd> class and the interfaces that the client controls are the <kbd class="calibre14">AttackAI</kbd> and <kbd class="calibre14">FlightAI</kbd>. This is a much better solution than inheriting from the <kbd class="calibre14">Enemy</kbd> because we are only encapsulating what varies: the behavior. This pattern allows us to create as many <kbd class="calibre14">FlightAI</kbd> derived classes as we need and to reuse them to create different kinds of game object types, without needing to expand our inheritance tree. Since we can mix different strategy combinations, we can get a large number of different overall behaviors.</p>
<p class="calibre2">We are going to share the same strategies for both units and structures, so we should actually remove our inheritance tree altogether and just use the <kbd class="calibre14">Object</kbd> as our client. This way, the <kbd class="calibre14">Object</kbd> class becomes a collection of strategies, and our design is simpler. Plus, we are following some great programming principles:</p>
<ul class="calibre17">
<li class="calibre18">Programing to an interface means that our client depends on behavior in an abstract class instead putting behavior in the client itself.</li>
<li class="calibre18">Our interfaces are opened for extension so we can easily add as many behaviors as we need. The interface is simple so it won't need to be changed, which might break code.</li>
<li class="calibre18">Our inheritance trees are shallow so we don't need to worry about the Diamond of Death.</li>
</ul>
<div><img class="image-border13" src="img/00029.jpeg"/></div>
<p>Figure 3.6 - Example of our Object using the Strategy pattern</p>
<p class="calibre2">The Strategy pattern allows our game object to be very flexible without the need for an inheritance tree. With these six small classes shown in the preceding diagram, we can have a total of nine different game object behaviors. If we add a new <strong class="calibre1">FlightAI</strong>, we have 12 possible game object behaviors. Creating brand new strategies allows for an amazing amount of mixed behaviors. However, if we only extend just the two strategies, we don't need to modify the <strong class="calibre1">Object</strong> at all. This works for the Player as well, if we make an <strong class="calibre1">AttackAI</strong> and <strong class="calibre1">FlightAI</strong> that have access to input.</p>
<p class="calibre2">Staying with only two strategies is unlikely, which means that whenever we add a new strategy, we will need to change the <strong class="calibre1">Object</strong> by adding a new member and modifying the <kbd class="calibre14">Update</kbd> function. This means that while the pattern is flexible enough to let us change strategies at runtime, we can't add behaviors dynamically. If we need to add acid damage as a debuff in our game, we would need a <kbd class="calibre14">Damage</kbd> base class, and to give a <kbd class="calibre14">Damage</kbd> base class pointer to the <kbd class="calibre14">object</kbd>:</p>
<pre class="calibre23">
class Object <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    //Same as before... <br class="title-page-name"/>  protected: <br class="title-page-name"/>     //Other Object Strategies <br class="title-page-name"/>     //... <br class="title-page-name"/>     Damage* m_damage. <br class="title-page-name"/>};
</pre>
<p class="calibre2">This doesn't seem like a great solution because most damage will be instantaneous and, most of the time, the player isn't even taking damage. That means this will be either null or an empty strategy class, such as using a <kbd class="calibre14">NoDamage</kbd> derived class, that will be updated every frame but will do nothing. This is also no way to stack corrosive effects or to have two types of damage affecting the Player, such as corrosive damage and ice damage, which might cause the Player to move slower for 10 seconds. We really need a way to dynamically add and remove these abilities. Luckily, there is a pattern for that.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Decorator pattern explained</h1>
            

            
                
<p class="calibre2">The purpose of the Decorator pattern is to dynamically add responsibilities to an object at runtime. The goal is to be a flexible alternative to creating derived classes while still allowing for extended behavior. What this means is that we can take our <kbd class="calibre14">object</kbd> and add decorations or, in our case, behaviors at runtime.</p>
<p class="calibre2">This pattern requires that the <kbd class="calibre14">Decorator</kbd> and our <kbd class="calibre14">object</kbd> are derived from a common base class so they share the same interface. Each <kbd class="calibre14">Decorator</kbd> will then layer itself on top of an <kbd class="calibre14">object</kbd> or another <kbd class="calibre14">Decorator</kbd> to create more interesting object types and effects. When a function gets called on a <kbd class="calibre14">Decorator</kbd>, it will call the corresponding function on the next layer down, eventually calling the function of the <kbd class="calibre14">object</kbd>. It is similar in concept to the <em class="calibre12">Russian Matryoshka</em> dolls, the dolls that contain smaller and smaller versions inside of themselves. The final, most nested object is always the object with the core functionality:</p>
<div><img class="image-border8" src="img/00030.jpeg"/></div>
<p>Figure 3.7 - The layering effects of the Decorator pattern</p>
<p class="calibre2">Here is a simplified version in code:</p>
<pre class="calibre23">
class Component //Our base interface <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    virtual ~Component(void) {} <br class="title-page-name"/>    virtual std::string Describe(void) const = 0; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class Object: public Component //Our core class to decorate <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    Object(const std::string&amp; name):m_name(name){} <br class="title-page-name"/>    virtual std::string Describe(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    return m_name; <br class="title-page-name"/>  } <br class="title-page-name"/>  private: <br class="title-page-name"/>    std::string m_name; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//Our base and derived Decorators <br class="title-page-name"/>class Decorator: public Component <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    Decorator(Component* comp):m_comp(comp){} <br class="title-page-name"/>    virtual ~Decorator(void) { delete m_comp; } <br class="title-page-name"/>  protected: <br class="title-page-name"/>    Component* m_comp; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class RocketBoosters: public Decorator <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    RocketBoosters(Component* comp) : Decorator(comp) {} <br class="title-page-name"/>    virtual std::string Describe(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    return m_comp-&gt;Describe() + " with RocketBoosters"; <br class="title-page-name"/>  } <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class LaserCannons: public Decorator <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    LaserCannons(Component* comp) : Decorator(comp) {} <br class="title-page-name"/>    virtual std::string Describe(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    return m_comp-&gt;Describe() + " with LaserCannons"; <br class="title-page-name"/>  } <br class="title-page-name"/>};
</pre>
<div><img class="image-border14" src="img/00031.jpeg"/></div>
<p>Figure 3.8 - The Decorator pattern using our Object</p>
<pre class="calibre23">
//Using this code: <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  Component* ship = new Object("Player"); <br class="title-page-name"/>  std::cout &lt;&lt; ship-&gt;Describe() &lt;&lt; std::endl; <br class="title-page-name"/>  delete ship; <br class="title-page-name"/> <br class="title-page-name"/>  Component* rocketShip = new RocketBoosters(new <br class="title-page-name"/>     GameObject("Enemy")); <br class="title-page-name"/>  std::cout &lt;&lt; rocketShip-&gt;Describe() &lt;&lt; std::endl; <br class="title-page-name"/>  delete rocketShip; <br class="title-page-name"/> <br class="title-page-name"/>  Component* laserRocketShip = new LaserCannons(new <br class="title-page-name"/>     RocketBoosters(new GameObject("Boss"))); <br class="title-page-name"/>  std::cout &lt;&lt; laserRocketShip-&gt;Describe() &lt;&lt; std::endl; <br class="title-page-name"/>  delete laserRocketShip; <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">Decorator</kbd> classes layer our concrete <kbd class="calibre14">object</kbd> class and add more information on top of the <kbd class="calibre14">object</kbd>. However, right now, all we are doing is adding superficial decorations. Since the <kbd class="calibre14">Decorator</kbd> class doesn't know whether it has a pointer to the <kbd class="calibre14">object</kbd> class or another <kbd class="calibre14">Decorator</kbd>, it can't modify the <kbd class="calibre14">object</kbd>. A good analogy is that the Strategy pattern changes the guts of the object, while the Decorator pattern changes the skin. This can be useful but doesn't help us with our buff/debuff problem. To solve this problem, we would need to add a method to find the <kbd class="calibre14">object</kbd> down the chain, or give a pointer to the <kbd class="calibre14">object</kbd> in the constructor of a <kbd class="calibre14">Decorator</kbd>.</p>
<p class="calibre2">Another problem is that this pattern was designed to add a <kbd class="calibre14">Decorator</kbd> dynamically, but doesn't allow us to remove one. In the case of using a corrosive damage <kbd class="calibre14">Decorator</kbd>, we would only want it to exist for a set time, and then automatically detach itself. This can't be done, since a <kbd class="calibre14">Decorator</kbd> doesn't have a pointer to its parent.</p>
<p class="calibre2">The final problem for games is that our <kbd class="calibre14">Decorators</kbd> can't live in a vacuum. Sometimes, different gameplay behaviors may need to interact with each other. For example, the corrosive damage <kbd class="calibre14">Decorator</kbd> may affect the health of an <kbd class="calibre14">object</kbd>; however, it may first need to check whether the <kbd class="calibre14">object</kbd> has a shield <kbd class="calibre14">Decorator</kbd> and remove health from the shield.</p>
<p class="calibre2">Unfortunately, neither the Decorator nor the Strategy pattern will work perfectly for us. What we really need is a new pattern that is a combination of the Strategy and Decorator patterns that does the following:</p>
<ul class="calibre17">
<li class="calibre18">Encapsulates specific behavior into components so we avoid <kbd class="calibre14">Object</kbd> inheritance trees</li>
<li class="calibre18">Allows for a flexible number of components so we don't need to modify the <kbd class="calibre14">Object</kbd> each time we create a new component type</li>
<li class="calibre18">Lets us add and remove components at runtime</li>
<li class="calibre18">Gives components direct access to the <kbd class="calibre14">Object</kbd> so it can be modified</li>
<li class="calibre18">Allows components to be searchable by other components so they can interact</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Component Object Model explained</h1>
            

            
                
<p class="calibre2">The alternative can be found by many names, though none are definitive yet. In this book, we will call it the <strong class="calibre1">Component Object Model</strong>, but others have called the <strong class="calibre1">Entity Component System</strong> or just <strong class="calibre1">Component System</strong>. No matter what you call it, the concept is surprisingly simple to learn and easy to implement.</p>
<p class="calibre2">The Component Object Model inverts the concept of the Decorator pattern, where each <kbd class="calibre14">Decorator</kbd> added a new layer on top of the game object. Instead of layering our <kbd class="calibre14">object</kbd>, which we have already seen problems with, we will put the decorations inside of it. Since we don't know how many we will need, our <kbd class="calibre14">object</kbd> will hold a container of decorations, as opposed to a single pointer. In the simplest form, our <kbd class="calibre14">object</kbd> is nothing more than a container for these components.</p>
<p class="calibre2">If you search for Component Object Model (or Component Based object Model) on the Internet, you will get results that are similar to what we saw in the Strategy pattern. The object contains hardcoded pointers to each possible strategy. While using this approach alone is much better than a monolithic object or an inheritance-based object, we are stuck checking for null pointers or constantly modifying what strategies exists in our <kbd class="calibre14">object</kbd>.</p>
<p class="calibre2">In this alternative method, every strategy type will derive from a common interface. This way, our <kbd class="calibre14">object</kbd> can contain an array, or in our case an STL vector of base class <kbd class="calibre14">Component</kbd> pointers. This is like the <kbd class="calibre14">Decorator</kbd>, except our <kbd class="calibre14">object</kbd> is a separate class; it doesn't derive from the <kbd class="calibre14">Component</kbd> interface. Instead, a <kbd class="calibre14">Component</kbd> will have a pointer to its parent <kbd class="calibre14">object</kbd> class. This solves the problem in which a <kbd class="calibre14">Decorator</kbd> didn't know whether it held a pointer to another <kbd class="calibre14">Decorator</kbd>, or to the actual <kbd class="calibre14">object</kbd>. Here we avoid that problem by always giving our <kbd class="calibre14">Component</kbd> a pointer to the <kbd class="calibre14">object</kbd> it controls:</p>
<pre class="calibre23">
//Using only Strategy Pattern <br class="title-page-name"/>class Object <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    void Update(float dt);//Non virtual function to update <br class="title-page-name"/>       Strategies <br class="title-page-name"/> //Other interface here <br class="title-page-name"/> //... <br class="title-page-name"/>  private://Lots of different Strategies <br class="title-page-name"/>    GfxComp*   m_gfx; <br class="title-page-name"/>    BehaviorComp* m_behavior; <br class="title-page-name"/>    ColliderComp* m_collider; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//Using Flexible Component Object Model <br class="title-page-name"/>class Object <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    void Update(float dt);//Non virtual function to update <br class="title-page-name"/>       Components <br class="title-page-name"/>    //Other interface here <br class="title-page-name"/> //... <br class="title-page-name"/>  private: <br class="title-page-name"/>    std::vector&lt;Component*&gt; m_components. <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//Our Base Component <br class="title-page-name"/>class Component <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    virtual void Update(float dt) = 0; <br class="title-page-name"/>  protected: <br class="title-page-name"/>    Object* m_obj; <br class="title-page-name"/>};
</pre>
<div><img class="image-border15" src="img/00032.jpeg"/></div>
<p>Figure 3.9 - The Component Object Model</p>
<p class="calibre2">This approach allows us to be very flexible because our <strong class="calibre1">object</strong> is nothing more than components. There is nothing in it that is specific to any type. There is no code that is strictly for the Player or SuperRaider. We are free to add, change, or remove anything at runtime. This is important because in the early stages of development, the game design and game objects will change a lot. If we were to hardcode pointers to different base class <kbd class="calibre14">Strategies</kbd>, we would spend a lot of time changing those pointer types in the game object.</p>
<p class="calibre2">Using the Component Object Model makes our code almost completely reusable as well. The game object itself is just an empty container of Components, and they are often so simple that most of them, such as a <strong class="calibre1">CircleCollider</strong>, can be used in any game. This means that a behavior component, originally meant only for the Player or SpawnerStation, can be easily used for any game object.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Implementing the Component Object Model</h1>
            

            
                
<p class="calibre2">Now that we have seen a basic version in code as well as a diagram, let's look at exactly how the Mach5 Engine implements this system. As you will see, the <kbd class="calibre14">M5object</kbd>, as it is called, contains a position, rotation, scale, and velocity. Of course, these elements could be contained in a transform component; however, these are so common that most other components will need access to this information. This is different to data such as texture coordinates or a circle collider's radius, which might not need to be shared at all:</p>
<pre class="calibre23">
//Component based Game object used in the Mach 5 Engine <br class="title-page-name"/>class M5Object <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    M5Object(M5ArcheTypes type); <br class="title-page-name"/>    ~M5Object(void); <br class="title-page-name"/> <br class="title-page-name"/>    //Public interface <br class="title-page-name"/>    void     Update(float dt); <br class="title-page-name"/>    void     AddComponent(M5Component* pComponent); <br class="title-page-name"/>    void     RemoveComponent(M5Component* pComponent); <br class="title-page-name"/>    void     RemoveAllComponents(void); <br class="title-page-name"/>    void     RemoveAllComponents(M5ComponentTypes type); <br class="title-page-name"/>    int     GetID(void) const; <br class="title-page-name"/>    M5ArcheTypes GetType(void) const; <br class="title-page-name"/>    M5Object*  Clone(void) const; <br class="title-page-name"/>    template&lt;typename T&gt; <br class="title-page-name"/>    void GetComponent(M5ComponentTypes type, T*&amp; pComp); <br class="title-page-name"/>    template&lt;typename T&gt; <br class="title-page-name"/>    void GetAllComponents(M5ComponentTypes type,<br class="title-page-name"/>       std::vector&lt;T*&gt;&amp; comps); <br class="title-page-name"/> <br class="title-page-name"/>    M5Vec2    pos;    <br class="title-page-name"/>    M5Vec2    scale;    <br class="title-page-name"/>    M5Vec2    vel;    <br class="title-page-name"/>    float    rotation;  <br class="title-page-name"/>    float    rotationVel; <br class="title-page-name"/>    bool     isDead; <br class="title-page-name"/>  private: <br class="title-page-name"/>    //Shorter name for my vector <br class="title-page-name"/>    typedef std::vector&lt;M5Component*&gt; ComponentVec; <br class="title-page-name"/>    //Shorter name for my iterator <br class="title-page-name"/>    typedef ComponentVec::iterator  VecItor; <br class="title-page-name"/> <br class="title-page-name"/>    ComponentVec m_components; <br class="title-page-name"/>    M5ArcheTypes m_type;      <br class="title-page-name"/>    int     m_id;       <br class="title-page-name"/>    static int  s_objectIDCounter; <br class="title-page-name"/>};
</pre>
<p class="calibre2">The first thing you will notice is that there are two enumerations in this code, <kbd class="calibre14">M5ArcheTypes</kbd> and <kbd class="calibre14">M5ComponentTypes</kbd>. These will become more useful later when we talk about creating Factories. However, for now, it is enough to understand that these will allow us to search through a collection of <kbd class="calibre14">M5objects</kbd> and get the components we need. For example, if we have a collection of <kbd class="calibre14">M5objects</kbd> but we need to find the Player, the <kbd class="calibre14">M5ArcheTypes</kbd> enum will allow us to do that.</p>
<p class="calibre2">The next thing you will notice is the <kbd class="calibre14">M5object</kbd> is more than just a container of components. It has some public and private data. The public data is unlikely to need validating or protecting. We could create getters and setters but they would really just simply get and set the data, so it isn't 100% necessary. Since they are public, we are locked into keeping them public forever. If you wish to make them <kbd class="calibre14">private</kbd> and create <kbd class="calibre14">accessor</kbd> methods, that is fine. There are some very important variables that we want to be private. The ID and the type are set once and can't be changed, and the array of components is accessed through functions to add, remove, and clear all components. Let's discuss the purpose of the public variables first:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre14">pos</kbd>: The position of the <kbd class="calibre14">M5Object</kbd>. This is the rotational center, or pivot point, of the object.</li>
<li class="calibre18"><kbd class="calibre14">scale</kbd>: The height and width of the <kbd class="calibre14">M5Object</kbd>, before rotation.</li>
<li class="calibre18"><kbd class="calibre14">vel</kbd>: The velocity of the <kbd class="calibre14">M5Object</kbd>. This is used to do time-based movement instead of simply setting the position to plus or minus some value.</li>
<li class="calibre18"><kbd class="calibre14">rotation</kbd>: The rotation in radians. Positive rotations are counterclockwise.</li>
<li class="calibre18"><kbd class="calibre14">rotationalVel</kbd>: The rotational velocity of the <kbd class="calibre14">M5Object</kbd>, used to do time-based rotations.</li>
<li class="calibre18"><kbd class="calibre14">isDead</kbd>: This allows the <kbd class="calibre14">M5Object</kbd> to mark itself for deletion. Other objects or components are free to call one of the <kbd class="calibre14">DestroyObject</kbd> functions found in the <kbd class="calibre14">M5ObjectManager</kbd>; however, it isn't a good idea for an object to delete itself in the middle of its own <kbd class="calibre14">Update</kbd> function.</li>
</ul>
<p class="calibre2">We are keeping these as part of the <kbd class="calibre14">M5object</kbd> because they are so common that all or almost all components will need access to them. We are marking these as public because there is no validation or protecting that we need to do on the data.</p>
<p class="calibre2">The private section starts with two type <kbd class="calibre14">defs</kbd>. They let us create shorter names for templated types. This is simply a style choice. Another style choice is to have an <kbd class="calibre14">m_</kbd> in front of all of the private member variable names. This or something similar is a common practice for class members. We didn't do this with our public members because we are treating them more like properties. Now let's look at the rest of the private data:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre14">m_components</kbd>: This is the array of <kbd class="calibre14">M5Component</kbd> pointers. Each component in the vector will get updated in the <kbd class="calibre14">Update</kbd> function.</li>
<li class="calibre18"><kbd class="calibre14">m_type</kbd>: The type of object. It will get set in the constructor and never change. It allows the user to use the <kbd class="calibre14">M5ObjectManager</kbd> to search or remove objects based on type.</li>
<li class="calibre18"><kbd class="calibre14">m_id</kbd>: This is a unique ID among <kbd class="calibre14">M5Objects</kbd>. It can be useful in cases such as a missile needing to target a specific instance of an object. If the missile contains a pointer to the target object, it can't know whether the object has been destroyed. If we instead know the ID, we can search to see whether the target still exists.</li>
<li class="calibre18"><kbd class="calibre14">s_objectIDCounter</kbd>: This is the shared ID counter for all <kbd class="calibre14">M5Objects</kbd>. This guarantees that each object will get a unique value because they are all using the same shared variable. Notice that this is marked with an <kbd class="calibre14">s_</kbd> to indicate that it is static.</li>
</ul>
<p class="calibre2">That is all of the data in the <kbd class="calibre14">object</kbd>. Now, let's look at the functions.</p>
<p class="calibre2"><kbd class="calibre14">M5object</kbd> is the constructor for the class. It sets starting values for the variables as well as setting the type and giving a unique ID. Notice that we reserve an amount of starting space for the vector. A game object can have as many components as it needs, but in an actual game, we don't expect them to have more than a few on average. By pre-allocating, we may avoid any additional calls to new (we will be a doing a lot anyway):</p>
<pre class="calibre23">
M5Object::M5Object(M5ArcheTypes type) : <br class="title-page-name"/>pos(0, 0), <br class="title-page-name"/>  scale(1, 1), <br class="title-page-name"/>  vel(0, 0), <br class="title-page-name"/>  rotation(0), <br class="title-page-name"/>  rotationVel(0), <br class="title-page-name"/>  isDead(false), <br class="title-page-name"/>  m_components(), <br class="title-page-name"/>  m_type(type), <br class="title-page-name"/>  m_id(++s_objectIDCounter) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_components.reserve(START_SIZE); <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">~M5object</kbd> is the destructor for our game object. Here we want to make sure that we delete all of the components in our game object, so we make use of one of our public functions to help us:</p>
<pre class="calibre23">
M5Object::~M5Object(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  RemoveAllComponents(); <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">AddComponent</kbd> adds the given component pointer to this object vector. You will notice that before the component is added, you will need to first check to make sure the same pointer isn't already in the list. While this isn't very likely to happen, it could be a hard bug to find later so it is worth the check. It is also important when given a component to use the <kbd class="calibre14">SetParent</kbd> method of <kbd class="calibre14">M5Component</kbd> to make sure this object will be controlled by the component:</p>
<pre class="calibre23">
void M5Object::AddComponent(M5Component* pToAdd) <br class="title-page-name"/>{  <br class="title-page-name"/>  //Make sure this component doesn't already exist <br class="title-page-name"/>  VecItor found = std::find(m_components.begin(), <br class="title-page-name"/>     m_components.end(), pComponent); <br class="title-page-name"/> <br class="title-page-name"/>  if (found != m_components.end()) <br class="title-page-name"/>   return; <br class="title-page-name"/>   <br class="title-page-name"/>  //Set this object as the parent <br class="title-page-name"/>  pComponent-&gt;SetParent(this); <br class="title-page-name"/>  m_components.push_back(pComponent); <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">Update</kbd> is the most used function in the <kbd class="calibre14">M5object</kbd>. This will get called automatically by the <kbd class="calibre14">M5ObjectManager</kbd> every frame. It is used to update every component as well as update position and rotation based on their velocities. The other important role of the <kbd class="calibre14">Update</kbd> function is that it deletes any dead components. Except for the <kbd class="calibre14">RemoveAllComponents</kbd> function, this is the only place where components are deleted:</p>
<pre class="calibre23">
void M5Object::Update(float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  int endIndex = m_components.size() - 1; <br class="title-page-name"/>  for (; endIndex &gt;= 0; --endIndex) <br class="title-page-name"/>  { <br class="title-page-name"/>    if (m_components[endIndex]-&gt;isDead) <br class="title-page-name"/>    { <br class="title-page-name"/>      delete m_components[endIndex]; <br class="title-page-name"/>      m_components[endIndex] = m_components[m_components.size() <br class="title-page-name"/>         - 1]; <br class="title-page-name"/>      m_components.pop_back(); <br class="title-page-name"/>    } <br class="title-page-name"/>    else <br class="title-page-name"/>    { <br class="title-page-name"/>      m_components[endIndex]-&gt;Update(dt); <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/>//Update object data <br class="title-page-name"/>  pos.x  += vel.x * dt; <br class="title-page-name"/>  pos.y  += vel.y * dt; <br class="title-page-name"/>  rotation += rotationVel * dt; <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">RemoveComponent</kbd> is used for cases such as when you have buffs or debuffs on an object and you want the stage, or some other object, to delete it. For example, the Player may be using a shield but, after being hit with ion damage, the physics collider finds the shield and immediately removes it. Instead of using this method, it would also be fine to simply mark the component as dead and it will be cleaned up in the next update loop.</p>
<p class="calibre2">This code follows a similar pattern to the <kbd class="calibre14">AddComponent</kbd> function. First, we test to make sure the component exists. If it does exist, we swap places with the last item in the vector and pop back the vector. After that, we use the <kbd class="calibre14">SetParent</kbd> method to remove this object as the parent pointer before deleting it. This is a small precaution as, in case another pointer to this component exists, the program will crash instead of causing an undefined error:</p>
<pre class="calibre23">
void M5Object::RemoveComponent(M5Component* pComponent) <br class="title-page-name"/>{ <br class="title-page-name"/>  //Make the sure the instance exists in this object <br class="title-page-name"/>  VecItor end = m_components.end(); <br class="title-page-name"/>  VecItor itor = std::find(m_components.begin(), end, pToRemove); <br class="title-page-name"/>   <br class="title-page-name"/>  if (itor != end) <br class="title-page-name"/>    return; <br class="title-page-name"/> <br class="title-page-name"/>  (*itor)-&gt;isDead = true; <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">RemoveAllComponents</kbd> is the helper function used in the destructor. It deletes all components in the object. Except for the destructor, there probably isn't much use for it. However, it was made public for those rare occasions where this is the behavior you need. This function simply loops through the vector and deletes every component, then finally clears the vector:</p>
<pre class="calibre23">
void M5Object::RemoveAllComponents(void) <br class="title-page-name"/>  { <br class="title-page-name"/>  VecItor itor = m_components.begin(); <br class="title-page-name"/>  VecItor end = m_components.end(); <br class="title-page-name"/>  while (itor != end) <br class="title-page-name"/>  { <br class="title-page-name"/>    delete (*itor); <br class="title-page-name"/>    ++itor; <br class="title-page-name"/>  } <br class="title-page-name"/>  m_components.clear(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The second version of <kbd class="calibre14">RemoveAllComponents</kbd> removes all components of a specific type. This is another situation where external code, such as a stage, object, or even another component needs to remove a group of the same component type. This could be used to remove all corrosive damage effects on the Player, for example.</p>
<p class="calibre2">In this code, we are searching for the correct type, so we cannot use the <kbd class="calibre14">std::vector::find</kbd> method. Instead, we use a <kbd class="calibre14">for</kbd> loop and check the type of each component. If we find the correct type, we delete the current one, swap with the end and pop back. Since we are doing a swap, but continue searching, we must make sure to check the current index again to see whether it matches as well:</p>
<pre class="calibre23">
void M5Object::RemoveAllComponents(M5ComponentTypes type) <br class="title-page-name"/>{ <br class="title-page-name"/>   for (size_t i = 0; i &lt; m_components.size(); ++i)  <br class="title-page-name"/>   { <br class="title-page-name"/>    if (m_components[i]-&gt;GetType() == type) <br class="title-page-name"/>     m_components[i]-&gt;isDead = true; <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">GetComponent</kbd> and <kbd class="calibre14">GetAllComponents</kbd> are helper functions to find and cast specific component types in an <kbd class="calibre14">M5object</kbd>, if they exist. As I said before, sometimes it is necessary that components interact. In that case, we need a way to search for a specific component and to convert it to the correct type. These two functions are almost the same. The first one finds the first instance of the correct component type and assigns it to the pointer parameter. If one doesn't exist, we make sure to set the parameter to <kbd class="calibre14">0</kbd>. The second one finds all components of the correct type and saves them in the vector parameter. These are template functions so the component can be cast to the correct type supplied by the user:</p>
<pre class="calibre23">
template&lt;typename T&gt; <br class="title-page-name"/>void M5Object::GetComponent(M5ComponentTypes type, T*&amp; pComp) <br class="title-page-name"/>{ <br class="title-page-name"/>  size_t size = m_components.size(); <br class="title-page-name"/>  for (size_t i = 0; i &lt; size; ++i) <br class="title-page-name"/>  { <br class="title-page-name"/>    //if we found the correct type, set and return <br class="title-page-name"/>    if (m_components[i]-&gt;GetType() == type) <br class="title-page-name"/>    { <br class="title-page-name"/>      pComp = static_cast&lt;T*&gt;(m_components[i]); <br class="title-page-name"/>      return; <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/>  pComp = 0; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>template&lt;typename T&gt; <br class="title-page-name"/>void GetAllComponent(M5ComponentTypes type, std::vector&lt;T*&gt;&amp; comps) <br class="title-page-name"/>{ <br class="title-page-name"/>  size_t size = m_components.size(); <br class="title-page-name"/>  for (size_t i = 0; i &lt; size; ++i) <br class="title-page-name"/>  { <br class="title-page-name"/>    //if we found the correct type, add to vector <br class="title-page-name"/>    if (m_components[i]-&gt;GetType() == type) <br class="title-page-name"/>    comps.push_back(static_cast&lt;T*&gt;(m_components[i])); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">GetID</kbd> and <kbd class="calibre14">GetType</kbd> functions just return the private class data. The <kbd class="calibre14">Clone</kbd> method is more interesting but we will go into more detail about it when we discuss the Prototype pattern.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Implementing components</h1>
            

            
                
<p class="calibre2">Now that you have seen the <kbd class="calibre14">M5object</kbd>, let's take a look at how the Mach5 Engine creates and uses the component hierarchy. Since this is an abstract class, there is no way to create an instance of an <kbd class="calibre14">M5Component</kbd>. It is only an interface.</p>
<p class="calibre2">As you will see, the base component contains some of the same members as the <kbd class="calibre14">M5object</kbd>. Since we will have a lot of components, it is important to give each one a type, so they can be searchable. It is important to give each a unique ID. Since these components can be deleted at any time, it is important to save an ID instead of a pointer, which can become invalid:</p>
<pre class="calibre23">
class M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    M5Component(M5ComponentTypes type); <br class="title-page-name"/>    virtual ~M5Component(void); <br class="title-page-name"/>    virtual M5Component* Clone(void) = 0; <br class="title-page-name"/>    virtual void Update(float dt)= 0; <br class="title-page-name"/>    virtual void FromFile(M5IniFile&amp;); <br class="title-page-name"/>    void SetParent(M5Object* pParent); <br class="title-page-name"/>    M5ComponentTypes GetType(void) const; <br class="title-page-name"/>    int GetID(void) const; <br class="title-page-name"/> //public data <br class="title-page-name"/>    bool isDead; <br class="title-page-name"/>  protected: <br class="title-page-name"/>    M5Object* m_pObj; <br class="title-page-name"/>  private: <br class="title-page-name"/>    int m_id; <br class="title-page-name"/>    M5ComponentTypes m_type; <br class="title-page-name"/>    staticint    s_compIDCounter; <br class="title-page-name"/>};
</pre>
<p class="calibre2">The data section doesn't contain as much as the <kbd class="calibre14">M5object</kbd>, but now it is split into three sections which are <kbd class="calibre14">public</kbd>, <kbd class="calibre14">private</kbd>, and <kbd class="calibre14">protected</kbd>:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre14">isDead</kbd>: This is the only public data and it serves a similar function to the member in the game object. This allows the component to mark itself for deletion. It isn't a good idea for a component to call <kbd class="calibre14">RemoveComponent</kbd> on itself during its own <kbd class="calibre14">Update</kbd> function.</li>
<li class="calibre18"><kbd class="calibre14">m_pObj</kbd>: This is a pointer to the <kbd class="calibre14">M5Object</kbd> that owns this component.</li>
<li class="calibre18"><kbd class="calibre14">m_id</kbd>: The unique ID of this component. This allows users to get access to this specific component again, without the risk of saving a pointer which may become invalid.</li>
<li class="calibre18"><kbd class="calibre14">m_type</kbd>: The type of this component. This allows users to search for a specific component within a game object.</li>
<li class="calibre18"><kbd class="calibre14">s_compIDCounter</kbd>: This is used to create a unique ID for each component.</li>
</ul>
<p class="calibre2">The functions of the <kbd class="calibre14">M5Component</kbd> are not that interesting because they are mostly virtual. However, it is worth going over their purpose.</p>
<p class="calibre2"><kbd class="calibre14">M5Component</kbd> is the non-default constructor for the component. This takes an argument of type <kbd class="calibre14">M5ComponentTypes</kbd> so that the private data <kbd class="calibre14">m_type</kbd> is guaranteed to be set by a derived type:</p>
<pre class="calibre23">
M5Component::M5Component(M5ComponentTypes type): <br class="title-page-name"/>  isDead(false), <br class="title-page-name"/>  m_pObj(0), <br class="title-page-name"/>  m_type(type), <br class="title-page-name"/>  m_id(++s_componentID) <br class="title-page-name"/>{ <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">~M5Component</kbd> is the destructor for the class. Since this is meant to be a base class, it is important that a virtual destructor exists so that the correct method will be called when using polymorphism:</p>
<pre class="calibre23">
M5Component::~M5Component(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  //Empty Base Class virtual destructor <br class="title-page-name"/>}
</pre>
<p class="calibre2"><kbd class="calibre14">Update</kbd> is where the component does the action. This method will be called every frame and its intended purpose is to add a behavior and/or data to the <kbd class="calibre14">M5object</kbd>. It is marked as pure virtual (<kbd class="calibre14">= 0</kbd>) so that the base class is forced to override it. That also means there is no body to the base class version.</p>
<p class="calibre2"><kbd class="calibre14">FromFile</kbd> is a virtual function that allows the component to read data from a preloaded INI file. It is not marked as pure virtual, meaning that a component doesn't need to override this function. This might be the case if the derived component has no data to be loaded from a file:</p>
<pre class="calibre23">
void M5Component::FromFile(M5IniFile&amp;) <br class="title-page-name"/>{ <br class="title-page-name"/>  //Empty for the base class <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">SetParent</kbd> method is simply a setter for <kbd class="calibre14">m_pObj</kbd>. Recall the <kbd class="calibre14">AddComponent</kbd> function of <kbd class="calibre14">M5object</kbd>. When a component is added to an object, the object uses this function so the component knows which object to control.</p>
<p class="calibre2">The <kbd class="calibre14">GetType</kbd> and <kbd class="calibre14">GetID</kbd> functions are similar to the functions in <kbd class="calibre14">M5object</kbd>. They allow the component to be searchable and saved without needing to use pointers that may become invalid. The <kbd class="calibre14">M5Component</kbd> also has a pure virtual <kbd class="calibre14">Clone</kbd> method. There is no function body in the base class. We will discuss the <kbd class="calibre14">Clone</kbd> method of both <kbd class="calibre14">M5Component</kbd> and <kbd class="calibre14">M5object</kbd> when we discuss the Prototype pattern.</p>
<div><p class="calibre28">To add a behavior to an object, we must derive from the <kbd class="calibre26">M5Component</kbd> base class, overload the necessary methods, add a value to the <kbd class="calibre26">M5ComponentTypes</kbd> enumeration, then finally register the class and the associated builder with the object manager. Of course, these steps are prone to error and doing them repeatedly would be very tedious.</p>
<p class="calibre28">For this reason, the Mach5 engine has included a batch file to do these steps automatically. By adding components to the <kbd class="calibre26">Source</kbd> folder within the file hierarchy, the batch file will find all files named <kbd class="calibre26">*Component.h</kbd>, where the asterisk is a wildcard character that includes any valid C++ identifier.</p>
<p class="calibre28">For example, if a component named <kbd class="calibre26">LazerComponent</kbd> is located within a file named <kbd class="calibre26">LazerComponent.h</kbd>, an enumeration value named <kbd class="calibre26">CT_LazerComponent</kbd> will be automatically created along with the correct class builder, and both will be registered with the <kbd class="calibre26">M5ObjectManager</kbd>.</p>
</div>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Creating and removing objects and components</h1>
            

            
                
<p class="calibre2">In order to use the Component Object Model, first create a game object, then add some components, then finally add it to the <kbd class="calibre14">M5ObjectManager</kbd> which calls an update on the game object every frame. Let's look at some code for creating objects and components.</p>
<p class="calibre2">If we wanted to create a <kbd class="calibre14">Player</kbd> object to fly around on screen, but stay within the bounds of the screen, we could do this inside the <kbd class="calibre14">Init</kbd> method of a stage:</p>
<pre class="calibre23">
M5Object* pObj = new M5Object(AT_Player); <br class="title-page-name"/>GfxComponent* pGfxComp = new GfxComponent; <br class="title-page-name"/>PlayerInputComponent* pInput = new PlayerInputComponent; <br class="title-page-name"/>ClampComponent* pClamp = new ClampComponent; <br class="title-page-name"/>pObj-&gt;AddComponent(pGfxComp); <br class="title-page-name"/>pObj-&gt;AddComponent(pInput); <br class="title-page-name"/>pObj-&gt;AddComponent(pClamp ); <br class="title-page-name"/>//Set position, rotation, scale here <br class="title-page-name"/>//... <br class="title-page-name"/>M5ObjectManager::AddObject(pObj);
</pre>
<p class="calibre2">This code works fine, but there are a few problems. First, we didn't specify what texture we want. However, we could easily add a <kbd class="calibre14">textureID</kbd> or filename as a parameter to the <kbd class="calibre14">GfxComponent</kbd> constructor. The larger problem is that this code was tedious to write and we don't want to write it again and again. If we are creating a Player in another stage, it will likely contain the exact same code. So a better approach is to factor this code into the <kbd class="calibre14">M5ObjectManager</kbd>:</p>
<pre class="calibre23">
M5Object* M5ObjectManager::CreateObject(M5ArcheTypes type) <br class="title-page-name"/>{ <br class="title-page-name"/>  switch(type) <br class="title-page-name"/>  { <br class="title-page-name"/>    case AT_Player: <br class="title-page-name"/>    M5Object* pObj = new M5Object(AT_Player); <br class="title-page-name"/>    GfxComponent* pGfxComp = new GfxComponent; <br class="title-page-name"/>    PlayerInputComponent* pInput = new PlayerInputComponent; <br class="title-page-name"/>    ClampComponent* pClamp = new ClampComponent; <br class="title-page-name"/>    pObj-&gt;AddComponent(pGfxComp); <br class="title-page-name"/>    pObj-&gt;AddComponent(pInput); <br class="title-page-name"/>    pObj-&gt;AddComponent(pClamp ); <br class="title-page-name"/>    AddObject(pObj); <br class="title-page-name"/>    //Set position, rotation, scale here <br class="title-page-name"/>    //... <br class="title-page-name"/>    return pObj; <br class="title-page-name"/>    break; <br class="title-page-name"/>    case AT_Bullet: <br class="title-page-name"/>     //...More Code here
</pre>
<p class="calibre2">Now in our stage <kbd class="calibre14">Init</kbd> function, we can simply write the following:</p>
<pre class="calibre23">
M5Object* pObj = M5ObjectManager::CreateObject(AT_Splash); <br class="title-page-name"/>//Set additional data here if needed
</pre>
<p class="calibre2">However, this is pretty hardcoded. This explicitly creates all of the components that a Player (and every type) needs, which means that our <kbd class="calibre14">M5ObjectManager</kbd> now contains game-specific code. The benefit of using the Component Object Model is that it is flexible, but we have lost some of that flexibility by having a hardcoded <kbd class="calibre14">switch</kbd> statement. We really want our designers, not programmers, to choose what goes into a Player, Raider, or SuperRaider. That means loading our object types from a file. In our case, we will use INI files because they are simple to use and simple to understand. They consist of global or labeled sections of key/value pairs. Here is an example Player archetype found in <kbd class="calibre14">Player.ini</kbd>:</p>
<pre class="calibre23">
posX  = 0 <br class="title-page-name"/>posY  = 0 <br class="title-page-name"/>velX  = 0 <br class="title-page-name"/>velY  = 0 <br class="title-page-name"/>scaleX = 10 <br class="title-page-name"/>scaleY = 10 <br class="title-page-name"/>rot  = 0 <br class="title-page-name"/>rotVel = 0 <br class="title-page-name"/>components = GfxComponent PlayerInputComponent ClampComponent <br class="title-page-name"/> <br class="title-page-name"/>[GfxComponent] <br class="title-page-name"/>texture = playerShip.tga <br class="title-page-name"/> <br class="title-page-name"/>[PlayerInputComponent] <br class="title-page-name"/>forwardSpeed = 100 <br class="title-page-name"/>bulletSpeed = 7000 <br class="title-page-name"/>rotationSpeed = 10
</pre>
<p class="calibre2">Notice that the first (global) section of the INI file contains all data found in the <kbd class="calibre14">M5object</kbd>. Since we know that those variables always exist in the object, they are placed at the top. This includes a list of components that this archetype will use. Here we have <kbd class="calibre14">GfxComponent</kbd>, <kbd class="calibre14">PlayerInputComponent</kbd>, and <kbd class="calibre14">ClampComponent</kbd>. The next sections are data associated with each component, for example, with the <kbd class="calibre14">GfxComponent</kbd> we can specify our texture to load. The <kbd class="calibre14">ClampComponent</kbd> doesn't need any data loaded so we didn't need to add a section for it.</p>
<p class="calibre2">Comparing the Component Object Model with the monolithic object or the inheritance tree, we can see that the component-based approach is vastly more flexible and reusable. With this method, we can write as many different components as we want and let the designer choose what behaviors each object uses. The best part is that everything but the most game-specific components can be reused in another game.</p>
<p class="calibre2">That means that the <kbd class="calibre14">PlayerInputComponent</kbd> probably can't be reused in another game, but the <kbd class="calibre14">ClampComponent</kbd> and <kbd class="calibre14">GfxComponent</kbd> can be used whether we are making another Space Shooter, Platformer, or Racer.</p>
<p class="calibre2">One note about components used for graphics and physics, such as <kbd class="calibre14">GfxComponent</kbd> and <kbd class="calibre14">CircleColliderComponent</kbd>: these are special in the sense that they need to interact with core engines in a way that other components may not need to. For example, the Graphics engine might want to organize these components based on whether they are world space objects or screen space objects (referred to as HUD space, since these would be things such as buttons and health bars). The Physics engine might want to use a special partition data structure to minimize the number of collision tests that need to be performed. For this reason, these components are automatically registered to their respective core engines when created through the object Manager and they automatically unregister when they are deleted.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Performance concerns</h1>
            

            
                
<p class="calibre2">There are a lot of benefits to using the Component Object Model. These days, many engines use this approach because of the flexibility it provides. However, that flexibility comes at a cost to performance. The biggest performance costs are calls to new/delete, cache coherency, and virtual methods.</p>
<p class="calibre2">Our <kbd class="calibre14">M5ObjectManager</kbd> uses pointers to <kbd class="calibre14">M5objects</kbd> which uses an STL vector of pointers to components. This means that as we create <kbd class="calibre14">Bullets</kbd>, <kbd class="calibre14">Asteroids</kbd>, <kbd class="calibre14">Raiders</kbd>, and <kbd class="calibre14">Planets</kbd>, we are constantly calling new and delete. These are slow functions and have the chance to fragment our memory. In a later chapter, we will see how object pools can help us solve both of these problems.</p>
<p class="calibre2">However, even with object pools, we still have problems with cache misses. The fact is that iterating over an array of contiguous data is much faster than iterating over an array of pointers to data. When using the Component object Model, the CPU will be spending a lot more time chasing pointers and loading that data into the cache than if we just used arrays. Unfortunately, this is the price we pay for flexibility. Depending on the game, this may or may not cause a problem.</p>
<p class="calibre2">Virtual methods are also a source of potential performance problems because the function to call must always be looked up at runtime and they cannot be inlined by the compiler. Again, this is the price we pay for flexibility. We have an approach that allows our designer to load a behavior from a file and change that behavior at runtime. In my opinion, that outweighs the performance issues, at least at the beginning of the development cycle.</p>
<p class="calibre2">You may have heard <em class="calibre12">premature optimization is the root of all evil</em>. It is more important to focus on making a fun game and to solve the performance problems later. You always have the option of hardcoding specific behaviors or data in the game object much later in the development cycle. If possible, you might merge two or more components that always get used together once you are in the polish stage. However, by limiting your flexibility early on, you may never discover a fun feature that comes from mixing two components in a way that wasn't originally planned.</p>
<p class="calibre2">My advice is to focus first on algorithmic optimizations, then macro optimizations, then finally micro optimizations. What I mean is that it is better to worry about the time complexity of your physics engine and how many draw calls or collision tests you are performing, before worrying about what is in the CPU cache or the performance cost of virtual functions. While they can be a problem, these things fall under the category of micro optimizations.</p>
<p class="calibre2">However, before starting the long process of creating a game using an unfamiliar game engine, it can be a good idea to do some simple prototype tests to make sure the engine can meet the needs of the game. For example, a programmer could approximate the number of objects, and components, and test for performance to see whether the engine will work.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">In this chapter, we have explored many different ways to create a game object. We have seen the problems with using monolithic objects or large inheritance trees. We now know that neither of those approaches scale when creating a large game. They both suffer from the problem of giant bloated classes and dependencies in our code.</p>
<p class="calibre2">We have also seen the flexibility that using the Component Object Model can bring to our games. It lets programmers focus on writing new code, while allowing designers to use that code to create new object types, even at runtime. Since we can now define objects completely in a file, we can create a tool that will let our designer, or even players, make completely new objects, or possibly a new game.</p>
<p class="calibre2">We also briefly touched on the performance issues related to using the Component Object Model. While these can be a problem, it is much better to focus on algorithmic optimizations then very low-level CPU instruction optimizations. We will revisit these problems in later chapters.</p>
<p class="calibre2">For now, let's move on to a design pattern that can help us implement one of the big core engines of our game, as well as a small but important type of component. In the next chapter, we will discover how the State pattern can help decouple our code and can give us a great way to implement artificial intelligence in our game.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>