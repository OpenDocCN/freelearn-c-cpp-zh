<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Iterator-Pair Algorithms</h1>
                
            
            
                
<p class="calibre2">Now that you've been introduced to iterator types--both standard-provided and user-defined--it's time to look at some of the things you can <em class="calibre22">do</em> with iterators.</p>
<p class="calibre2">In this chapter you'll learn:</p>
<ul class="calibre14">
<li class="calibre15">The notion of a "half-open range," which nails down the exact manner in which two iterators can be said to define a <em class="calibre22">range</em></li>
<li class="calibre15">How to classify each standard algorithm as "read-only," "write-only", "transformative", or "permutative"; and as "one-range", "two-range", or "one-and-a-half range"</li>
<li class="calibre15">That some standard algorithms, such as <kbd class="calibre12">merge</kbd> and <kbd class="calibre12">make_heap</kbd>, are merely the necessary building blocks out of which we make higher-level entities such as <kbd class="calibre12">stable_sort</kbd> and <kbd class="calibre12">priority_queue</kbd></li>
<li class="calibre15">How to sort a range based on a comparator other than <kbd class="calibre12">operator&lt;</kbd></li>
<li class="calibre15">How to manipulate sorted arrays using the <em class="calibre22">erase-remove idiom</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A note about headers</h1>
                
            
            
                
<p class="calibre2">Most function templates discussed in this chapter are defined in the standard header <kbd class="calibre12">&lt;algorithm&gt;</kbd>. The special iterator types, on the other hand, are generally defined in <kbd class="calibre12">&lt;iterator&gt;</kbd>. If you're wondering where to find a specific entity, I strongly recommend that you consult an online reference such as <a href="https://cppreference.com" class="calibre4">cppreference.com</a> for the authoritative answer; don't just guess!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Read-only range algorithms</h1>
                
            
            
                
<p class="calibre2">In the preceding chapters, we built up an algorithm that we called <kbd class="calibre12">distance</kbd> and another called <kbd class="calibre12">count_if</kbd>. Both of these algorithms appear in the standard library.</p>
<p class="calibre2"><kbd class="calibre12">std::count_if(a,b,p)</kbd> returns the number of elements between <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd> that satisfy the predicate function <kbd class="calibre12">p</kbd>--that is, the number of elements <kbd class="calibre12">e</kbd> for which <kbd class="calibre12">p(e)</kbd> is <kbd class="calibre12">true</kbd>.</p>
<p class="calibre2">Notice that, whenever we say "between <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd>", we're talking about the range that includes <kbd class="calibre12">*a</kbd> but does not include <kbd class="calibre12">*b</kbd>--what mathematicians call a "half-open range" and represented by the asymmetrical notation <kbd class="calibre12">[a,b)</kbd>. Why should we not include <kbd class="calibre12">*b</kbd>? Well, for one thing, if <kbd class="calibre12">b</kbd> is the <kbd class="calibre12">end()</kbd> of some vector, then it doesn't point to an element of that vector at all! So in general, dereferencing the <em class="calibre22">end point</em> of a range is a dangerous thing to do. For another thing, using half-open ranges conveniently allows us to represent <em class="calibre22">empty</em> ranges; for example, the range "from <kbd class="calibre12">x</kbd> to <kbd class="calibre12">x</kbd>" is an empty range consisting of zero data elements.</p>
<p class="calibre2">Half-open ranges are quite natural in C++ just as they are in C. For decades, we've been writing for-loops that range from a lower bound (inclusive) to an upper bound (exclusive); this idiom is so common that deviation from the idiom often indicates a bug:</p>
<pre class="calibre23">    constexpr int N = 10;<br class="title-page-name"/>    int a[N];<br class="title-page-name"/><br class="title-page-name"/>    // A correct for-loop.<br class="title-page-name"/>    for (int i=0; i &lt; N; ++i) {<br class="title-page-name"/>      // ...<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    // One variety of "smelly" for-loop.<br class="title-page-name"/>    for (int i=0; i &lt;= N; ++i) {<br class="title-page-name"/>      // ... <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    // A correct invocation of a standard algorithm.<br class="title-page-name"/>    std::count_if(std::begin(a), std::end(a), [](int){ return true; });<br class="title-page-name"/><br class="title-page-name"/>    // A "smelly" invocation.<br class="title-page-name"/>    std::count_if(std::begin(a), std::end(a) - 1, [](int){ return true; });<br class="title-page-name"/><br class="title-page-name"/>    // A "trivial" invocation: counting a range of length zero.<br class="title-page-name"/>    std::count_if(std::begin(a), std::begin(a), [](int){ return true; });</pre>
<p class="calibre2"><kbd class="calibre12">std::distance(a,b)</kbd> returns the number of elements between <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd>--that is, the number of times you'd have to apply <kbd class="calibre12">++</kbd> to <kbd class="calibre12">a</kbd> in order to reach <kbd class="calibre12">b</kbd>. You could think of this function as being equivalent in its effects to <kbd class="calibre12">std::count_if(a,b,[](auto&amp;&amp;){return true;})</kbd>.</p>
<p class="calibre2">As we saw in <a href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>, if the iterators in question are random-access iterators, this number can be quickly computed as <kbd class="calibre12">(b - a)</kbd>, and so the standard <kbd class="calibre12">std::distance</kbd> will do so. Notice that <kbd class="calibre12">(b - a)</kbd> might be a negative number, if you gave the arguments in the "wrong" order!</p>
<pre class="calibre23">    int a[] {1, 2, 3, 4, 5};<br class="title-page-name"/>    std::list&lt;int&gt; lst {1, 2, 3, 4, 5};<br class="title-page-name"/>    std::forward_list&lt;int&gt; flst {1, 2, 3, 4, 5};<br class="title-page-name"/><br class="title-page-name"/>    assert(std::distance(std::begin(a), std::end(a)) == 5);<br class="title-page-name"/>    assert(std::distance(std::begin(lst), std::end(lst)) == 5);<br class="title-page-name"/>    assert(std::distance(std::begin(lst), std::end(lst)) == 5);<br class="title-page-name"/><br class="title-page-name"/>    assert(std::distance(std::end(a), std::begin(a)) == -5);</pre>
<p class="calibre2">When the iterators are random-access iterators, <kbd class="calibre12">std::distance</kbd> does nothing more than subtract them; so passing in "wrongly ordered" arguments is explicitly supported and blessed by the C++ standard. However, if the iterators in question are merely bidirectional iterators (such as <kbd class="calibre12">std::list&lt;int&gt;::iterator</kbd>--see <a href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>), "wrongly ordered" iterators are <em class="calibre22">not</em> supported. You might expect that <kbd class="calibre12">std::distance(b,a) == -std::distance(a,b)</kbd> should be true of all iterator types; but consider, how would the <kbd class="calibre12">std::distance</kbd> algorithm itself have any idea whether the iterators you gave it were "wrongly ordered" or not? The only thing it <em class="calibre22">can</em> do (in the absence of an <kbd class="calibre12">operator-</kbd>) is to keep incrementing <kbd class="calibre12">a</kbd>--perhaps past the end of the container and off into space--in the vain hope that it'll eventually reach <kbd class="calibre12">b</kbd>:</p>
<pre class="calibre23">    // The following line gives an "incorrect" answer!<br class="title-page-name"/>    // assert(std::distance(std::end(lst), std::begin(lst)) == 1);<br class="title-page-name"/>    // And this one just segfaults!<br class="title-page-name"/>    // std::distance(std::end(flst), std::begin(flst));</pre>
<p>Consult the diagrams of <kbd class="calibre25">std::list</kbd> and <kbd class="calibre25">std::forward_list</kbd> in <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre28">Chapter 4</a>, <em class="calibre29">The Container Zoo</em>, to understand this code sample's odd behavior.</p>
<p class="calibre2"><kbd class="calibre12">std::count(a,b,v)</kbd> returns the number of elements between <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd> that are equal to <kbd class="calibre12">v</kbd>--that is, the number of elements <kbd class="calibre12">e</kbd> for which <kbd class="calibre12">e == v</kbd> is true. You can think of this function as being equivalent in its effects to <kbd class="calibre12">std::count_if(a,b,[&amp;v](auto&amp;&amp; e){return e == v;})</kbd>, and in fact both versions should give the same assembly code. If C++ had had lambda-expressions in 1998, they probably wouldn't have put the <kbd class="calibre12">std::count</kbd> algorithm in the standard library.</p>
<p class="calibre2">Notice that <kbd class="calibre12">std::count(a,b,v)</kbd> necessarily loops over <em class="calibre22">all</em> of the elements in the range between <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd>. It can't take advantage of special information you might have about the arrangement of the data in the range. For example, suppose I want to count the instances of <kbd class="calibre12">42</kbd> in a <kbd class="calibre12">std::set&lt;int&gt;</kbd>? I could write the code in either of the following ways:</p>
<pre class="calibre23">    std::set&lt;int&gt; s { 1, 2, 3, 10, 42, 99 };<br class="title-page-name"/>    bool present;<br class="title-page-name"/><br class="title-page-name"/>    // O(n): compare each element with 42<br class="title-page-name"/>    present = std::count(s.begin(), s.end(), 42);<br class="title-page-name"/><br class="title-page-name"/>    // O(log n): ask the container to look up 42 itself<br class="title-page-name"/>    present = s.count(42);</pre>
<p class="calibre2">The raw algorithm <kbd class="calibre12">std::count</kbd> is outperformed by the second approach, which simply asks the <kbd class="calibre12">set</kbd> itself for the answer. This turns a O(<em class="calibre22">n</em>) traversal of the whole set into a O(log <em class="calibre22">n</em>) tree lookup. Similarly, <kbd class="calibre12">std::unordered_set</kbd> provides a <kbd class="calibre12">count</kbd> method that is roughly O(1).</p>
<p class="calibre2">For more about these containers, see <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>; the takeaway point here right now is that, Q sometimes there is important structure in your data that can be exploited by choosing the proper tool for the job. Even though I'm pointing to cases where the standard algorithms seem to "magically" do the right thing (as with <kbd class="calibre12">std::distance</kbd> delegating to <kbd class="calibre12">(b - a)</kbd>), you should not imagine that this "magic" stretches farther than it does. The standard algorithms know only as much as they're told, which is to say, only about the properties of the <em class="calibre22">iterator types</em> you pass them. They'll never change their behavior based on the relationships of the <em class="calibre22">underlying data elements</em> to each other. Arranging your code to exploit relationships in the underlying data (for example, "this data is sorted," "this range spans the entire container") is part of your job as the programmer.</p>
<p class="calibre2">Here are some more algorithms similar to <kbd class="calibre12">std::count</kbd> and <kbd class="calibre12">std::count_if</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::find(a,b,v)</kbd> and <kbd class="calibre12">std::find_if(a,b,p)</kbd> work just like <kbd class="calibre12">std::count(a,b,v)</kbd> and <kbd class="calibre12">std::count_if(a,b,p)</kbd> respectively, except that, rather than looping over the entire range and returning the <em class="calibre22">count</em> of matching elements, the <kbd class="calibre12">find</kbd> variants loop only until they've found the first match, and then return an iterator to the data element that matched. There is also a variant <kbd class="calibre12">find_if_not</kbd> that is just like <kbd class="calibre12">find_if</kbd> but with the sense of the predicate negated; this variant also probably wouldn't have needed to exist if we'd gotten lambdas earlier in the history of C++:</p>
<pre class="calibre23">    template&lt;class InputIterator, class UnaryPredicate&gt;<br class="title-page-name"/>    InputIterator find_if(InputIterator first, InputIterator last,<br class="title-page-name"/>      UnaryPredicate p) <br class="title-page-name"/>    {<br class="title-page-name"/>      for (; first != last; ++first) {<br class="title-page-name"/>        if (p(*first)) {<br class="title-page-name"/>          return first;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return last;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class It, class U&gt;<br class="title-page-name"/>    It find_if_not(It first, It last, U p) {<br class="title-page-name"/>      return std::find_if(first, last, [&amp;](auto&amp;&amp; e){ return !p(e); }); <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class It, class T&gt;<br class="title-page-name"/>    It find(It first, It last, T value) {<br class="title-page-name"/>      return std::find_if(first, last, [&amp;](auto&amp;&amp; e)<br class="title-page-name"/>        { return e == value; }); <br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that because <kbd class="calibre12">find</kbd> returns <em class="calibre22">immediately</em> upon finding the first match, it's faster on average than the <kbd class="calibre12">count</kbd> algorithm (which scans the whole range no matter what). This kind of "return immediately" behavior is often referred to as "short-circuiting".</p>
<p class="calibre2"><kbd class="calibre12">std::all_of(a,b,p)</kbd>, <kbd class="calibre12">std::any_of(a,b,p)</kbd>, and <kbd class="calibre12">std::none_of(a,b,p)</kbd> return either <kbd class="calibre12">true</kbd> or <kbd class="calibre12">false</kbd>, depending on how often the provided predicate function <kbd class="calibre12">p</kbd> is true of the elements in the range. They can all be built on top of the <kbd class="calibre12">find</kbd> algorithms, thus picking up the short-circuiting behavior for free:</p>
<pre class="calibre23">    template&lt;class It, class UnaryPredicate&gt;<br class="title-page-name"/>    bool all_of(It first, It last, UnaryPredicate p)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::find_if_not(first, last, p) == last;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template &lt;class It, class U&gt;<br class="title-page-name"/>    bool any_of(It first, It last, U p)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::find_if(first, last, p) != last;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template &lt;class It, class U&gt;<br class="title-page-name"/>    bool none_of(It first, It last, U p)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::find_if(first, last, p) == last;<br class="title-page-name"/>    }</pre>
<p class="calibre2">There is one more <kbd class="calibre12">find</kbd>-related algorithm I should mention: <kbd class="calibre12">find_first_of</kbd>. It implements the operation of "looking in a sequence for the first occurrence of any of a fixed set of target elements"--that is, just like <kbd class="calibre12">strcspn</kbd> in the C standard library, but for any type, not just <kbd class="calibre12">char</kbd>. Abstractly speaking, <kbd class="calibre12">find_first_of</kbd> takes two conceptual parameters: the range to search in, and the set of target elements. This being the STL, they're both passed in as ranges, which is to say, pairs of iterators. So a call to this algorithm looks like <kbd class="calibre12">find_first_of(haystack, haystack, needle, needle)</kbd>: two pairs of iterators side by side. This can get confusing--beware of algorithms taking multiple similar parameters!</p>
<pre class="calibre23">    template &lt;class It, class FwdIt&gt;<br class="title-page-name"/>    It find_first_of(It first, It last, FwdIt targetfirst,<br class="title-page-name"/>      FwdIt targetlast)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::find_if(first, last, [&amp;](auto&amp;&amp; e) {<br class="title-page-name"/>        return std::any_of(targetfirst, targetlast, [&amp;](auto&amp;&amp; t) {<br class="title-page-name"/>          return e == t;<br class="title-page-name"/>        });<br class="title-page-name"/>      });<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template &lt;class It, class FwdIt, class BinaryPredicate&gt;<br class="title-page-name"/>    It find_first_of(It first, It last, FwdIt targetfirst,<br class="title-page-name"/>      FwdIt targetlast, BinaryPredicate p)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::find_if(first, last, [&amp;](auto&amp;&amp; e) {<br class="title-page-name"/>        return std::any_of(targetfirst, targetlast, [&amp;](auto&amp;&amp; t) {<br class="title-page-name"/>          return p(e, t);<br class="title-page-name"/>        });<br class="title-page-name"/>      });<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that the "haystack" iterators are expected to be of any old <kbd class="calibre12">InputIterator</kbd> type, but the "needle" iterators are required to be at least <kbd class="calibre12">ForwardIterator</kbd>. Recall from <a href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>, that the big thing about <kbd class="calibre12">ForwardIterator</kbd> types is that they can be meaningfully <em class="calibre22">copied</em>, letting the same range be traversed multiple times. This is exactly what <kbd class="calibre12">find_first_of</kbd> needs! It traverses the "needle" range once per character in the "haystack"; so the "needle" must be re-traversable--and incidentally, must be finite in size! Contrariwise, there's nothing particularly requiring that the "haystack" be finite; it might be pulling its elements from a potentially unbounded input stream:</p>
<pre class="calibre23">    std::istream_iterator&lt;char&gt; ii(std::cin);<br class="title-page-name"/>    std::istream_iterator&lt;char&gt; iend{};<br class="title-page-name"/>    std::string s = "hello";<br class="title-page-name"/><br class="title-page-name"/>    // Chomp characters from std::cin until finding an 'h', 'e', 'l', or 'o'.<br class="title-page-name"/>    std::find_first_of(ii, iend, s.begin(), s.end());</pre>
<p class="calibre2">Speaking of multiple similar parameters, let's finish our look at simple read-only algorithms with these two: <kbd class="calibre12">std::equal</kbd> and <kbd class="calibre12">std::mismatch</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::equal(a,b,c,d)</kbd> takes two iterator-pairs: the range <kbd class="calibre12">[a,b)</kbd> and the range <kbd class="calibre12">[c,d)</kbd>. It returns <kbd class="calibre12">true</kbd> if the two ranges are element-for-element equal, and <kbd class="calibre12">false</kbd> otherwise.</p>
<p class="calibre2"><kbd class="calibre12">std::mismatch(a,b,c,d)</kbd> is sort of like <kbd class="calibre12">find</kbd>: it'll tell you exactly which pair of elements was the one that torpedoed the match:</p>
<pre class="calibre23">    template&lt;class T&gt; constexpr bool is_random_access_iterator_v =<br class="title-page-name"/>      std::is_base_of_v&lt;std::random_access_iterator_tag, typename <br class="title-page-name"/>      std::iterator_traits&lt;T&gt;::iterator_category&gt;;<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class It1, class It2, class B&gt;<br class="title-page-name"/>    auto mismatch(It1 first1, It1 last1, It2 first2, It2 last2, B p)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first1 != last1 &amp;&amp; first2 != last2 &amp;&amp; p(*first1, *first2)) {<br class="title-page-name"/>        ++first1;<br class="title-page-name"/>        ++first2;<br class="title-page-name"/>      }<br class="title-page-name"/>      return std::make_pair(first1, first2);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class It1, class It2&gt;<br class="title-page-name"/>    auto mismatch(It1 first1, It1 last1, It2 first2, It2 last2)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::mismatch(first1, last1, first2, last2, std::equal_to&lt;&gt;{});<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class It1, class It2, class B&gt;<br class="title-page-name"/>    bool equal(It1 first1, It1 last1, It2 first2, It2 last2, B p)<br class="title-page-name"/>    {<br class="title-page-name"/>      if constexpr (is_random_access_iterator_v&lt;It1&gt; &amp;&amp;<br class="title-page-name"/>        is_random_access_iterator_v&lt;It2&gt;) {<br class="title-page-name"/>        // Ranges of different lengths can never be equal.<br class="title-page-name"/>        if ((last2 - first2) != (last1 - first1)) {<br class="title-page-name"/>          return false;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return std::mismatch(first1, last1, first2, last2, p) ==<br class="title-page-name"/>        std::make_pair(last1, last2);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class It1, class It2&gt;<br class="title-page-name"/>    bool equal(It1 first1, It1 last1, It2 first2, It2 last2)<br class="title-page-name"/>    {<br class="title-page-name"/>      return std::equal(first1, last1, first2, last2, std::equal_to&lt;&gt;{});<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice the use of <kbd class="calibre12">std::equal_to&lt;&gt;{}</kbd> as a predicate object; we won't cover the built-in predicates in depth in this book, so just take it for granted that <kbd class="calibre12">std::equal_to&lt;&gt;{}</kbd> is an object whose behavior is similar to <kbd class="calibre12">[](auto a, auto b){ return a == b; }</kbd> but with more <em class="calibre22">perfect forwarding</em> involved.</p>
<p class="calibre2">Finally, watch out again! Many of the two-range algorithms in the C++17 standard library also have variant forms colloquially known as one-and-a-half-range algorithms. For example, in addition to <kbd class="calibre12">std::mismatch(a,b,c,d)</kbd> you'll find <kbd class="calibre12">std::mismatch(a,b,c)</kbd>--the second range's "end" point is simply assumed to be at <kbd class="calibre12">c + std::distance(a, b)</kbd>. If <kbd class="calibre12">c</kbd> actually points into a container where <kbd class="calibre12">c + std::distance(a, b)</kbd> would be "off the end," then, tough luck!</p>
<p class="calibre2">Because "tough luck" is never a really <em class="calibre22">great</em> answer to a technical question, the C++17 standard added safe two-range variants for many of the one-and-a-half-range algorithms that had existed in C++14.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Shunting data with std::copy</h1>
                
            
            
                
<p class="calibre2">We've just seen our first few two-range algorithms. The <kbd class="calibre12">&lt;algorithm&gt;</kbd> header is full of two-range algorithms and their siblings, the one-and-a-half-range algorithms. What's the simplest possible such algorithm?</p>
<p class="calibre2">A reasonable answer would be: "Copy each data element from the first range into the second range." Indeed, the STL provides that algorithm, under the name <kbd class="calibre12">std::copy</kbd>:</p>
<pre class="calibre23">    template&lt;class InIt, class OutIt&gt;<br class="title-page-name"/>    OutIt copy(InIt first1, InIt last1, OutIt destination)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first1 != last1) {<br class="title-page-name"/>        *destination = *first1;<br class="title-page-name"/>        ++first1;<br class="title-page-name"/>        ++destination;<br class="title-page-name"/>      }<br class="title-page-name"/>      return destination;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that this is a one-and-a-half-range algorithm. The standard library actually does not provide a two-range version of <kbd class="calibre12">std::copy</kbd>; the assumption is that if you are actually trying to write into a buffer, then you must have checked its size already, so checking "are we at the end of the buffer yet" inside the loop would be both redundant and inefficient.</p>
<p class="calibre2">Now I can practically hear you exclaiming: "Horrors! This is the same crude logic that brought us <kbd class="calibre12">strcpy</kbd>, <kbd class="calibre12">sprintf</kbd>, and <kbd class="calibre12">gets</kbd>! This is an invitation to buffer overflows!" Well, <em class="calibre22">if</em> you were to exclaim thusly, you'd be right about the bad behavior of <kbd class="calibre12">gets</kbd>--in fact, the <kbd class="calibre12">gets</kbd> function has been officially removed from the C++17 standard library. And you'd be right about <kbd class="calibre12">sprintf</kbd>--anyone who needs that functionality is better of using the range-checked version <kbd class="calibre12">snprintf</kbd>, which is analogous to a "two-range algorithm" in this context. But about <kbd class="calibre12">strcpy</kbd> I'd disagree. With <kbd class="calibre12">gets</kbd> it is <em class="calibre22">impossible</em> to know the correct size for the output buffer; with <kbd class="calibre12">sprintf</kbd> it is <em class="calibre22">difficult</em>; but with <kbd class="calibre12">strcpy</kbd> it is <em class="calibre22">trivial</em>: you just measure the <kbd class="calibre12">strlen</kbd> of the input buffer and that's your answer. Likewise with <kbd class="calibre12">std::copy</kbd>, the relationship between "input elements consumed" and "output elements produced" is exactly one-to-one, so sizing the output buffer doesn't present a technical challenge.</p>
<p class="calibre2">Notice that the parameter we called <kbd class="calibre12">destination</kbd> is an <em class="calibre22">output iterator</em>. This means that we can use <kbd class="calibre12">std::copy</kbd>, not merely to shunt data around in memory, but even to feed data to an arbitrary "sink" function. For example:</p>
<pre class="calibre23">    class putc_iterator : public boost::iterator_facade&lt;<br class="title-page-name"/>      putc_iterator, // T<br class="title-page-name"/>      const putc_iterator, // value_type<br class="title-page-name"/>      std::output_iterator_tag<br class="title-page-name"/>      &gt;<br class="title-page-name"/>    {<br class="title-page-name"/>      friend class boost::iterator_core_access;<br class="title-page-name"/><br class="title-page-name"/>       auto&amp; dereference() const { return *this; }<br class="title-page-name"/>       void increment() {}<br class="title-page-name"/>       bool equal(const putc_iterator&amp;) const { return false; }<br class="title-page-name"/>       public:<br class="title-page-name"/>       // This iterator is its own proxy object!<br class="title-page-name"/>       void operator= (char ch) const { putc(ch, stdout); }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::string s = "hello";<br class="title-page-name"/>      std::copy(s.begin(), s.end(), putc_iterator{});<br class="title-page-name"/>    }</pre>
<p class="calibre2">You may find it instructive to compare this version of our <kbd class="calibre12">putc_iterator</kbd> to the version from <a target="_blank" href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>; this version is using <kbd class="calibre12">boost::iterator_facade</kbd> as introduced at the end of <a target="_blank" href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em> and also using a common trick to return <kbd class="calibre12">*this</kbd> instead of a new proxy object.</p>
<p class="calibre2">Now we can use the flexibility of <kbd class="calibre12">destination</kbd> to solve our concerns about buffer overflow! Suppose that, instead of writing into a fixed-size array, we were to write into a resizable <kbd class="calibre12">std::vector</kbd> (see <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>). Then "writing an element" corresponds to "pushing an element back" on the vector. So we could write an output iterator very similar to <kbd class="calibre12">putc_iterator</kbd>, that would <kbd class="calibre12">push_back</kbd> instead of <kbd class="calibre12">putc</kbd>, and then we'd have an overflow-proof way of filling up a vector. Indeed, the standard library provides just such an output iterator, in the <kbd class="calibre12">&lt;iterator&gt;</kbd> header:</p>
<pre class="calibre23">    namespace std {<br class="title-page-name"/>      template&lt;class Container&gt;<br class="title-page-name"/>      class back_insert_iterator {<br class="title-page-name"/>        using CtrValueType = typename Container::value_type;<br class="title-page-name"/>        Container *c;<br class="title-page-name"/>      public:<br class="title-page-name"/>        using iterator_category = output_iterator_tag;<br class="title-page-name"/>        using difference_type = void;<br class="title-page-name"/>        using value_type = void;<br class="title-page-name"/>        using pointer = void;<br class="title-page-name"/>        using reference = void;<br class="title-page-name"/><br class="title-page-name"/>        explicit back_insert_iterator(Container&amp; ctr) : c(&amp;ctr) {}<br class="title-page-name"/><br class="title-page-name"/>        auto&amp; operator*() { return *this; }<br class="title-page-name"/>        auto&amp; operator++() { return *this; }<br class="title-page-name"/>        auto&amp; operator++(int) { return *this; }<br class="title-page-name"/><br class="title-page-name"/>        auto&amp; operator= (const CtrValueType&amp; v) {<br class="title-page-name"/>            c-&gt;push_back(v);<br class="title-page-name"/>            return *this;<br class="title-page-name"/>        }<br class="title-page-name"/>        auto&amp; operator= (CtrValueType&amp;&amp; v) {<br class="title-page-name"/>            c-&gt;push_back(std::move(v));<br class="title-page-name"/>            return *this;<br class="title-page-name"/>        }<br class="title-page-name"/>      };<br class="title-page-name"/>  <br class="title-page-name"/>      template&lt;class Container&gt;<br class="title-page-name"/>      auto back_inserter(Container&amp; c)<br class="title-page-name"/>      {<br class="title-page-name"/>         return back_insert_iterator&lt;Container&gt;(c);<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::string s = "hello";<br class="title-page-name"/>      std::vector&lt;char&gt; dest;<br class="title-page-name"/>      std::copy(s.begin(), s.end(), std::back_inserter(dest));<br class="title-page-name"/>      assert(dest.size() == 5);<br class="title-page-name"/>    }</pre>
<p class="calibre2">The function call <kbd class="calibre12">std::back_inserter(dest)</kbd> simply returns a <kbd class="calibre12">back_insert_iterator</kbd> object. In C++17, we could rely on template type deduction for constructors and write the body of that function as simply <kbd class="calibre12">return std::back_insert_iterator(dest)</kbd>; or dispense with the function entirely and just write <kbd class="calibre12">std::back_insert_iterator(dest)</kbd> directly in our code--where C++14 code would have to "make do" with <kbd class="calibre12">std::back_inserter(dest)</kbd>. However, why would we want all that extra typing? The name <kbd class="calibre12">back_inserter</kbd> was deliberately chosen to be easy to remember, since it's the one that we were expected to use most often. Although C++17 allows us to write <kbd class="calibre12">std::pair</kbd> in place of <kbd class="calibre12">std::make_pair</kbd>, and <kbd class="calibre12">std::tuple</kbd> in place of <kbd class="calibre12">std::make_tuple</kbd>, it would be silly to write the cumbersome <kbd class="calibre12">std::back_insert_iterator</kbd> in place of <kbd class="calibre12">std::back_inserter</kbd>. You should prefer <kbd class="calibre12">std::back_inserter(dest)</kbd> even in C++17.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variations on a theme - std::move and std::move_iterator</h1>
                
            
            
                
<p class="calibre2">As you might guess from the name, or you might have noticed in the preceding implementation, the <kbd class="calibre12">std::copy</kbd> algorithm works by copying elements from the input range to the output. As of C++11, you might wonder: What if instead of <em class="calibre22">copying</em> the elements, we used move semantics to <em class="calibre22">move</em> them from the input to the output?</p>
<p class="calibre2">The STL provides two different approaches to this problem. The first one is the most straightforward: there is a <kbd class="calibre12">std::move</kbd> algorithm (defined in the <kbd class="calibre12">&lt;algorithm&gt;</kbd> header) with the following definition:</p>
<pre class="calibre23">    template&lt;class InIt, class OutIt&gt;<br class="title-page-name"/>    OutIt move(InIt first1, InIt last1, OutIt destination)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first1 != last1) {<br class="title-page-name"/>        *destination = std::move(*first1);<br class="title-page-name"/>        ++first1;<br class="title-page-name"/>        ++destination;<br class="title-page-name"/>      }<br class="title-page-name"/>      return destination;<br class="title-page-name"/>    }</pre>
<p class="calibre2">It's exactly the same as the <kbd class="calibre12">std::copy</kbd> algorithm except for the addition of a single <kbd class="calibre12">std::move</kbd> on the input element (be careful--this inner <kbd class="calibre12">std::move</kbd>, with <em class="calibre22">one</em> argument, defined in the <kbd class="calibre12">&lt;utility&gt;</kbd> header, is a completely different beast from the outer, three-argument <kbd class="calibre12">std::move</kbd> defined in <kbd class="calibre12">&lt;algorithm&gt;</kbd>! The fact that they share a name is unfortunate. Ironically, one of the few other STL functions to suffer a similar situation is <kbd class="calibre12">std::remove</kbd>; see the <em class="calibre22">Deleting from a sorted array</em> section, and also <a href="part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 12</a>, <em class="calibre22">Filesystem</em>).</p>
<p class="calibre2">The other approach is a variation of what we saw previously with <kbd class="calibre12">back_inserter</kbd>. Rather than switching out the core <em class="calibre22">algorithm</em>, we can continue using <kbd class="calibre12">std::copy</kbd> but parameterize it differently. Suppose we passed in a new type of iterator, which (like <kbd class="calibre12">back_inserter</kbd>) wrapped around our original object and changed its behavior? In particular, we need an input iterator whose <kbd class="calibre12">operator*</kbd> returns an rvalue. We can do that!</p>
<pre class="calibre23">    template&lt;class It&gt;<br class="title-page-name"/>    class move_iterator {<br class="title-page-name"/>      using OriginalRefType = typename std::iterator_traits&lt;It&gt;::reference;<br class="title-page-name"/>      It iter;<br class="title-page-name"/>      public:<br class="title-page-name"/>       using iterator_category = typename<br class="title-page-name"/>         std::iterator_traits&lt;It&gt;::iterator_category;<br class="title-page-name"/>       using difference_type = typename<br class="title-page-name"/>         std::iterator_traits&lt;It&gt;::difference_type;<br class="title-page-name"/>       using value_type = typename std::iterator_traits&lt;It&gt;::value_type;<br class="title-page-name"/>       using pointer = It;<br class="title-page-name"/>       using reference = std::conditional_t&lt;<br class="title-page-name"/>         std::is_reference_v&lt;OriginalRefType&gt;,<br class="title-page-name"/>         std::remove_reference_t&lt;OriginalRefType&gt;&amp;&amp;,<br class="title-page-name"/>         OriginalRefType<br class="title-page-name"/>         &gt;;<br class="title-page-name"/><br class="title-page-name"/>       move_iterator() = default;<br class="title-page-name"/>       explicit move_iterator(It it) : iter(std::move(it)) {}<br class="title-page-name"/><br class="title-page-name"/>       // Allow constructing or assigning from any kind of move-iterator.<br class="title-page-name"/>       // These templates also serve as our own type's copy constructor<br class="title-page-name"/>       // and assignment operator, respectively.<br class="title-page-name"/>       template&lt;class U&gt;<br class="title-page-name"/>       move_iterator(const move_iterator&lt;U&gt;&amp; m) : iter(m.base()) {}<br class="title-page-name"/>       template&lt;class U&gt;<br class="title-page-name"/>       auto&amp; operator=(const move_iterator&lt;U&gt;&amp; m)<br class="title-page-name"/>         { iter = m.base(); return *this; }<br class="title-page-name"/><br class="title-page-name"/>       It base() const { return iter; }<br class="title-page-name"/><br class="title-page-name"/>       reference operator*() { return static_cast&lt;reference&gt;(*iter); }<br class="title-page-name"/>       It operator-&gt;() { return iter; }<br class="title-page-name"/>       decltype(auto) operator[](difference_type n) const <br class="title-page-name"/>         { return *std::move(iter[n]); }<br class="title-page-name"/><br class="title-page-name"/>      auto&amp; operator++() { ++iter; return *this; }<br class="title-page-name"/>      auto&amp; operator++(int)<br class="title-page-name"/>        { auto result = *this; ++*this; return result; }<br class="title-page-name"/>      auto&amp; operator--() { --iter; return *this; }<br class="title-page-name"/>      auto&amp; operator--(int)<br class="title-page-name"/>        { auto result = *this; --*this; return result; } <br class="title-page-name"/><br class="title-page-name"/>      auto&amp; operator+=(difference_type n) const<br class="title-page-name"/>        { iter += n; return *this; }<br class="title-page-name"/>      auto&amp; operator-=(difference_type n) const<br class="title-page-name"/>        { iter -= n; return *this; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // I've omitted the definitions of non-member operators<br class="title-page-name"/>    // == != &lt; &lt;= &gt; &gt;= + - ; can you fill them in?<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class InputIterator&gt;<br class="title-page-name"/>    auto make_move_iterator(InputIterator&amp; c) <br class="title-page-name"/>    {<br class="title-page-name"/>      return move_iterator(c);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Sorry for the density of that code; trust me that you can safely skip over the details. For those who like this kind of thing, you might notice that we're providing a templated constructor from <kbd class="calibre12">move_iterator&lt;U&gt;</kbd> that happens to double as our copy constructor (when <kbd class="calibre12">U</kbd> is the same type as <kbd class="calibre12">It</kbd>); and that we're providing a lot of member functions (such as <kbd class="calibre12">operator[]</kbd> and <kbd class="calibre12">operator--</kbd>) whose bodies will error out for a lot of possible types of <kbd class="calibre12">It</kbd> (for example, when <kbd class="calibre12">It</kbd> is a forward iterator--see <a target="_blank" href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>), but this is fine because their bodies won't get instantiated unless the user actually tries to call those functions at compile time (if the user actually <em class="calibre22">does</em> try to <kbd class="calibre12">--</kbd> a <kbd class="calibre12">move_iterator&lt;list_of_ints::iterator&gt;</kbd>, then of course that'll yield a compile-time error).</p>
<p class="calibre2">Just as with <kbd class="calibre12">back_inserter</kbd>, notice that the STL provides a helper function <kbd class="calibre12">make_move_iterator</kbd> for the benefit of pre-C++17 compilers that don't have constructor template type deduction. In this case, as with <kbd class="calibre12">make_pair</kbd> and <kbd class="calibre12">make_tuple</kbd>, the "helper" name is uglier than the actual class name, and so I tentatively recommend using the C++17 feature in your code; why type an extra five characters and instantiate an extra function template if you don't have to?</p>
<p class="calibre2">Now we have two different ways of moving data from one container or range to another: the <kbd class="calibre12">std::move</kbd> algorithm and the <kbd class="calibre12">std::move_iterator</kbd> adaptor class. Here are examples of both idioms:</p>
<pre class="calibre23">    std::vector&lt;std::string&gt; input = {"hello", "world"};<br class="title-page-name"/>    std::vector&lt;std::string&gt; output(2);<br class="title-page-name"/><br class="title-page-name"/>    // First approach: use the std::move algorithm<br class="title-page-name"/>    std::move(input.begin(), input.end(), output.begin());<br class="title-page-name"/><br class="title-page-name"/>    // Second approach: use move_iterator<br class="title-page-name"/>    std::copy(<br class="title-page-name"/>      std::move_iterator(input.begin()),<br class="title-page-name"/>      std::move_iterator(input.end()),<br class="title-page-name"/>      output.begin()<br class="title-page-name"/>    );</pre>
<p class="calibre2">The first approach, using <kbd class="calibre12">std::move</kbd>, is obviously much cleaner if moving data is all you're doing. So why did the standard library bother to provide this "messier" approach with <kbd class="calibre12">move_iterator</kbd>? To answer that question, we'll have to explore yet another algorithm that is fundamentally related to <kbd class="calibre12">std::copy</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Complicated copying with std::transform</h1>
                
            
            
                
<p class="calibre2">You might have noticed, way back when we presented the implementation of <kbd class="calibre12">std::copy</kbd>, that the <kbd class="calibre12">value_type</kbd> of the two iterator type parameters were not constrained to be the same. This is a feature, not a bug! It means that we can write code that relies on implicit conversions and it will just Do The Right Thing:</p>
<pre class="calibre23">    std::vector&lt;const char *&gt; input = {"hello", "world"};<br class="title-page-name"/>    std::vector&lt;std::string&gt; output(2);<br class="title-page-name"/><br class="title-page-name"/>    std::copy(input.begin(), input.end(), output.begin());<br class="title-page-name"/><br class="title-page-name"/>    assert(output[0] == "hello");<br class="title-page-name"/>    assert(output[1] == "world");</pre>
<p class="calibre2">Looks trivial, right? Look closely! Deep within our instantiation of <kbd class="calibre12">std::copy</kbd> is a call to the implicit constructor that converts <kbd class="calibre12">const char *</kbd> (the type of <kbd class="calibre12">*input.begin()</kbd>) to <kbd class="calibre12">std::string</kbd> (the type of <kbd class="calibre12">*output.begin()</kbd>). So for the umpteenth time, we're seeing an example of generic code that does surprisingly complicated operations simply by virtue of being given certain iterator types.</p>
<p class="calibre2">But sometimes you want to apply a complicated transformation function during the copying operation--something more complicated than implicit conversions can handle. The standard library has got you covered!</p>
<pre class="calibre23">    template&lt;class InIt, class OutIt, class Unary&gt;<br class="title-page-name"/>    OutIt transform(InIt first1, InIt last1, OutIt destination, Unary op)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first1 != last1) {<br class="title-page-name"/>        *destination = op(*first1);<br class="title-page-name"/>        ++first1;<br class="title-page-name"/>        ++destination;<br class="title-page-name"/>      }<br class="title-page-name"/>      return destination;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() <br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;std::string&gt; input = {"hello", "world"};<br class="title-page-name"/>      std::vector&lt;std::string&gt; output(2);<br class="title-page-name"/><br class="title-page-name"/>      std::transform(<br class="title-page-name"/>        input.begin(),<br class="title-page-name"/>        input.end(),<br class="title-page-name"/>        output.begin(),<br class="title-page-name"/>        [](std::string s) {<br class="title-page-name"/>          // It works for transforming in-place, too!<br class="title-page-name"/>          std::transform(s.begin(), s.end(), s.begin(), ::toupper);<br class="title-page-name"/>          return s;<br class="title-page-name"/>        }<br class="title-page-name"/>      );<br class="title-page-name"/><br class="title-page-name"/>      assert(input[0] == "hello");<br class="title-page-name"/>      assert(output[0] == "HELLO");<br class="title-page-name"/>    }</pre>
<p class="calibre2">Sometimes you even need to do a transformation using a function that takes <em class="calibre22">two</em> arguments. Again the library has you covered:</p>
<pre class="calibre23">    template&lt;class InIt1, class InIt2, class OutIt, class Binary&gt;<br class="title-page-name"/>    OutIt transform(InIt1 first1, InIt1 last1, InIt2 first2, OutIt destination,<br class="title-page-name"/>      Binary op)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first1 != last1) {<br class="title-page-name"/>        *destination = op(*first1, *first2);<br class="title-page-name"/>        ++first1;<br class="title-page-name"/>        ++first2;<br class="title-page-name"/>        ++destination;<br class="title-page-name"/>      }<br class="title-page-name"/>      return destination;<br class="title-page-name"/>    }</pre>
<p class="calibre2">This version of <kbd class="calibre12">std::transform</kbd> might be humorously described as a one-and-two-halves-range algorithm!</p>
<p class="calibre2">(What about functions of three arguments? Four arguments? Unfortunately there's no fully variadic version of <kbd class="calibre12">std::transform</kbd>; variadic templates weren't introduced to C++ until C++11. You might try implementing a variadic version and see what kinds of problems you run into--they're surmountable but certainly not trivial.)</p>
<p class="calibre2">The existence of <kbd class="calibre12">std::transform</kbd> gives us yet a third way to move data elements from one place to another:</p>
<pre class="calibre23">    std::vector&lt;std::string&gt; input = {"hello", "world"};<br class="title-page-name"/>    std::vector&lt;std::string&gt; output(2);<br class="title-page-name"/><br class="title-page-name"/>    // Third approach: use std::transform<br class="title-page-name"/>    std::transform(<br class="title-page-name"/>      input.begin(),<br class="title-page-name"/>      input.end(),<br class="title-page-name"/>      output.begin(),<br class="title-page-name"/>      std::move&lt;std::string&amp;&gt;<br class="title-page-name"/>    );</pre>
<p class="calibre2">I certainly don't recommend this approach, though! The biggest and reddest of its red flags is that it contains explicit specialization of the <kbd class="calibre12">std::move</kbd> template. Whenever you see an explicit specialization--those angle brackets after the template's name--that's an almost sure sign of very subtle and fragile code. Advanced readers might enjoy figuring out how the compiler deduces which of the two <kbd class="calibre12">std::move</kbd>s I meant; remember, there's one in <kbd class="calibre12">&lt;utility&gt;</kbd> and one in <kbd class="calibre12">&lt;algorithm&gt;</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Write-only range algorithms</h1>
                
            
            
                
<p class="calibre2">We began this chapter looking at algorithms such as <kbd class="calibre12">std::find</kbd> that march through a range reading its elements in order without modification. You might be surprised to learn that the inverse operation also makes sense: there is a family of standard algorithms that march through a range <em class="calibre22">modifying</em> each element without reading it!</p>
<p class="calibre2"><kbd class="calibre12">std::fill(a,b,v)</kbd> does what its name implies: fill each element of the given range <kbd class="calibre12">[a,b)</kbd> with a copy of the provided value <kbd class="calibre12">v</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::iota(a,b,v)</kbd> is slightly more interesting: it fills the elements of the given range with copies of <kbd class="calibre12">++v</kbd>. That is, <kbd class="calibre12">std::iota(a,b,42)</kbd> will set <kbd class="calibre12">a[0]</kbd> equal to 42, <kbd class="calibre12">a[1]</kbd> equal to 43, <kbd class="calibre12">a[2]</kbd> equal to 44, and so on all the way up to <kbd class="calibre12">b</kbd>. This algorithm's funny name comes from the APL programming language, where a function named <kbd class="calibre12"></kbd> (that's the Greek letter <em class="calibre22">iota</em>) performed this operation. Another funny thing about this algorithm is that, for whatever reason, its definition is found in the standard <kbd class="calibre12">&lt;numeric&gt;</kbd> header instead of in <kbd class="calibre12">&lt;algorithm&gt;</kbd>. It's just an oddball that way.</p>
<p class="calibre2"><kbd class="calibre12">std::generate(a,b,g)</kbd> is even more interesting: it fills the elements of the given range with the successive results of <kbd class="calibre12">g()</kbd>, whatever it is:</p>
<pre class="calibre23">    template&lt;class FwdIt, class T&gt;<br class="title-page-name"/>    void fill(FwdIt first, FwdIt last, T value) {<br class="title-page-name"/>      while (first != last) {<br class="title-page-name"/>        *first = value;<br class="title-page-name"/>         ++first;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class FwdIt, class T&gt;<br class="title-page-name"/>    void iota(FwdIt first, FwdIt last, T value) {<br class="title-page-name"/>      while (first != last) {<br class="title-page-name"/>        *first = value;<br class="title-page-name"/>        ++value;<br class="title-page-name"/>        ++first;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class FwdIt, class G&gt;<br class="title-page-name"/>    void generate(FwdIt first, FwdIt last, G generator) {<br class="title-page-name"/>      while (first != last) {<br class="title-page-name"/>        *first = generator();<br class="title-page-name"/>        ++first;<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Here's an example of using each of these standard algorithms to fill a vector of strings with different contents. Test your understanding: do you understand why each call produces the output that it does? The example I picked for <kbd class="calibre12">std::iota</kbd> is particularly interesting (yet unlikely to be helpful in real-world code):</p>
<pre class="calibre23">    std::vector&lt;std::string&gt; v(4);<br class="title-page-name"/><br class="title-page-name"/>    std::fill(v.begin(), v.end(), "hello");<br class="title-page-name"/>    assert(v[0] == "hello");<br class="title-page-name"/>    assert(v[1] == "hello");<br class="title-page-name"/>    assert(v[2] == "hello");<br class="title-page-name"/>    assert(v[3] == "hello");<br class="title-page-name"/><br class="title-page-name"/>    std::iota(v.begin(), v.end(), "hello");<br class="title-page-name"/>    assert(v[0] == "hello");<br class="title-page-name"/>    assert(v[1] == "ello");<br class="title-page-name"/>    assert(v[2] == "llo");<br class="title-page-name"/>    assert(v[3] == "lo");<br class="title-page-name"/><br class="title-page-name"/>    std::generate(v.begin(), v.end(), [i=0]() mutable {<br class="title-page-name"/>      return ++i % 2 ? "hello" : "world";<br class="title-page-name"/>    });<br class="title-page-name"/>    assert(v[0] == "hello");<br class="title-page-name"/>    assert(v[1] == "world");<br class="title-page-name"/>    assert(v[2] == "hello");<br class="title-page-name"/>    assert(v[3] == "world");</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Algorithms that affect object lifetime</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">&lt;memory&gt;</kbd> header provides an obscure family of algorithms with names such as <kbd class="calibre12">std::uninitialized_copy</kbd>, <kbd class="calibre12">std::uninitialized_default_construct</kbd>, and <kbd class="calibre12">std::destroy</kbd> (for the full list, consult an online reference such as <a href="http://cppreference.com" class="calibre4">cppreference.com</a>). Consider the following algorithm that uses explicit destructor calls to destroy the elements of a range:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    void destroy_at(T *p)<br class="title-page-name"/>    {<br class="title-page-name"/>      p-&gt;~T();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class FwdIt&gt;<br class="title-page-name"/>    void destroy(FwdIt first, FwdIt last)<br class="title-page-name"/>    {<br class="title-page-name"/>      for ( ; first != last; ++first) {<br class="title-page-name"/>        std::destroy_at(std::addressof(*first));<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that <kbd class="calibre12">std::addressof(x)</kbd> is a convenient little helper function that returns the address of its parameter; it's exactly the same thing as <kbd class="calibre12">&amp;x</kbd> except in the rare case that <kbd class="calibre12">x</kbd> is of some class type that sadistically overloads its own <kbd class="calibre12">operator&amp;</kbd>.</p>
<p class="calibre2">And consider this algorithm that uses explicit placement-new syntax to "copy-construct into" the elements of a range (notice how it neatly cleans up after itself if an exception is thrown during the copying). This algorithm clearly shouldn't be used on any range whose elements already exist; so the following example looks very contrived:</p>
<pre class="calibre23">    template&lt;class It, class FwdIt&gt;<br class="title-page-name"/>    FwdIt uninitialized_copy(It first, It last, FwdIt out)<br class="title-page-name"/>    {<br class="title-page-name"/>      using T = typename std::iterator_traits&lt;FwdIt&gt;::value_type;<br class="title-page-name"/>      FwdIt old_out = out;<br class="title-page-name"/>      try {<br class="title-page-name"/>        while (first != last) {<br class="title-page-name"/>          ::new (static_cast&lt;void*&gt;(std::addressof(*out))) T(*first);<br class="title-page-name"/>          ++first;<br class="title-page-name"/>          ++out;<br class="title-page-name"/>        }<br class="title-page-name"/>        return out;<br class="title-page-name"/>      } catch (...) {<br class="title-page-name"/>        std::destroy(old_out, out);<br class="title-page-name"/>        throw;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    { <br class="title-page-name"/>      alignas(std::string) char b[5 * sizeof (std::string)];  <br class="title-page-name"/>      std::string *sb = reinterpret_cast&lt;std::string *&gt;(b);<br class="title-page-name"/><br class="title-page-name"/>      std::vector&lt;const char *&gt; vec = {"quick", "brown", "fox"};<br class="title-page-name"/><br class="title-page-name"/>      // Construct three std::strings.<br class="title-page-name"/>      auto end = std::uninitialized_copy(vec.begin(), vec.end(), sb);<br class="title-page-name"/><br class="title-page-name"/>      assert(end == sb + 3);<br class="title-page-name"/><br class="title-page-name"/>      // Destroy three std::strings.<br class="title-page-name"/>      std::destroy(sb, end);<br class="title-page-name"/>    }</pre>
<p class="calibre2">We'll see more about how these algorithms are <em class="calibre22">meant</em> to be used in <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>, when we talk about <kbd class="calibre12">std::vector</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Our first permutative algorithm: std::sort</h1>
                
            
            
                
<p class="calibre2">So far all the algorithms we've covered simply walk through their given ranges in order, linearly, from one element to the next. Our next family of algorithms doesn't behave that way. Instead, it takes the values of the elements in the given range and shuffles them around so that the same values still appear, but in a different order. The mathematical name for this operation is a <em class="calibre22">permutation</em>.</p>
<p class="calibre2">The simplest permutative algorithm to describe is <kbd class="calibre12">std::sort(a,b)</kbd>. It does what the name implies: sort the given range so that the smallest elements appear at the front and the biggest elements at the back. To figure out which elements are "smallest," <kbd class="calibre12">std::sort(a,b)</kbd> uses <kbd class="calibre12">operator&lt;</kbd>.</p>
<p class="calibre2">If you want a different order, you could try to overload <kbd class="calibre12">operator&lt;</kbd> to return <kbd class="calibre12">true</kbd> under different conditions--but probably what you should do is use the three-argument version of the algorithm, <kbd class="calibre12">std::sort(a,b,cmp)</kbd>. The third argument should be a <em class="calibre22">comparator</em>; that is, a function, functor, or lambda that returns <kbd class="calibre12">true</kbd> whenever its first argument is "smaller" than its second argument. For example:</p>
<pre class="calibre23">    std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9};<br class="title-page-name"/>    std::sort(v.begin(), v.end(), [](auto&amp;&amp; a, auto&amp;&amp; b) {<br class="title-page-name"/>      return a % 7 &lt; b % 7;<br class="title-page-name"/>    });<br class="title-page-name"/>    assert((v == std::vector{1, 1, 9, 3, 4, 5}));</pre>
<p class="calibre2">Notice that I carefully chose my lambda in this example so that it would sort the array in a deterministic way. If I'd chosen the function <kbd class="calibre12">(a % 6 &lt; b % 6)</kbd> instead, then there would have been two possible outputs: either <kbd class="calibre12">{1, 1, 3, 9, 4, 5}</kbd> or <kbd class="calibre12">{1, 1, 9, 3, 4, 5}</kbd>. The standard <kbd class="calibre12">sort</kbd> algorithm doesn't guarantee anything about the relative position of elements that happen to be <em class="calibre22">equal</em> under the given comparison function!</p>
<p class="calibre2">To fix this problem (if it <em class="calibre22">is</em> a problem), you should replace your use of <kbd class="calibre12">std::sort</kbd> with <kbd class="calibre12">std::stable_sort</kbd>. The latter might be a little slower, but it will guarantee that in the case of equal elements the original order is preserved--that is, in this case we'll get <kbd class="calibre12">{1, 1, 3, 9, 4, 5}</kbd> because in the original (unsorted) vector, element <kbd class="calibre12">3</kbd> came in front of element <kbd class="calibre12">9</kbd>.</p>
<p class="calibre2">There's an even worse thing that can happen with <kbd class="calibre12">sort</kbd> and <kbd class="calibre12">stable_sort</kbd>--what if I had chosen the comparison function <kbd class="calibre12">(a % 6 &lt; b)</kbd>? Then I would have had certain pairs of elements <kbd class="calibre12">x, y</kbd> where <kbd class="calibre12">x &lt; y</kbd> and simultaneously <kbd class="calibre12">y &lt; x</kbd>! (One such pair of elements in the original vector is <kbd class="calibre12">5</kbd> and <kbd class="calibre12">9</kbd>.) In this case, there's nothing that can save us; we've passed in a "comparison function" that simply <em class="calibre22">isn't</em> a comparison function! This is a violation of the preconditions of <kbd class="calibre12">std::sort</kbd>, just as if we'd passed it a null pointer. When sorting an array, make sure you're sorting it based on a comparison function that makes sense!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Swapping, reversing, and partitioning</h1>
                
            
            
                
<p class="calibre2">The STL contains a surprisingly large number of permutative algorithms besides <kbd class="calibre12">std::sort</kbd>. Many of these algorithms can be seen as "building blocks" that implement just a small part of the overall sorting algorithm.</p>
<p class="calibre2"><kbd class="calibre12">std::swap(a,b)</kbd> is the most basic building block; it just takes its two arguments and "swaps" them--which is to say, it exchanges their values. This is implemented in terms of the given type's move constructor and move assignment operator. <kbd class="calibre12">swap</kbd> is actually a little special among the standard algorithms because it is <em class="calibre22">such</em> a primitive operation, and because there is <em class="calibre22">almost always</em> a faster way to swap two arbitrary objects than by performing the equivalent of <kbd class="calibre12">temp = a; a = b; b = temp;</kbd>. The usual idiom for standard library types (such as <kbd class="calibre12">std::vector</kbd>) is for the type itself to implement a <kbd class="calibre12">swap</kbd> member function (as in <kbd class="calibre12">a.swap(b)</kbd>), and then to add a function overload of <kbd class="calibre12">swap</kbd> in the same namespace as the type--that is, if we're implementing <kbd class="calibre12">my::obj</kbd>, we'd add the overload in namespace <kbd class="calibre12">my</kbd>--such that <kbd class="calibre12">swap(a,b)</kbd> for that particular type, will call <kbd class="calibre12">a.swap(b)</kbd> instead of doing the three move operations. Here's an example:</p>
<pre class="calibre23">    namespace my {<br class="title-page-name"/>      class obj {<br class="title-page-name"/>        int v;<br class="title-page-name"/>      public:<br class="title-page-name"/>        obj(int value) : v(value) {}<br class="title-page-name"/><br class="title-page-name"/>        void swap(obj&amp; other) {<br class="title-page-name"/>          using std::swap;<br class="title-page-name"/>          swap(this-&gt;v, other.v);<br class="title-page-name"/>        }<br class="title-page-name"/>      };<br class="title-page-name"/><br class="title-page-name"/>      void swap(obj&amp; a, obj&amp; b) {<br class="title-page-name"/>        a.swap(b);<br class="title-page-name"/>      }<br class="title-page-name"/>    } // namespace my<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      int i1 = 1, i2 = 2;<br class="title-page-name"/>      std::vector&lt;int&gt; v1 = {1}, v2 = {2};<br class="title-page-name"/>      my::obj m1 = 1, m2 = 2;<br class="title-page-name"/>      using std::swap;<br class="title-page-name"/>      swap(i1, i2); // calls std::swap&lt;int&gt;(int&amp;, int&amp;)<br class="title-page-name"/>      swap(v1, v2); // calls std::swap(vector&amp;, vector&amp;)<br class="title-page-name"/>      swap(m1, m2); // calls my::swap(obj&amp;, obj&amp;)<br class="title-page-name"/>    }</pre>
<p class="calibre2">Now that we have <kbd class="calibre12">swap</kbd> and bidirectional iterators, we can build <kbd class="calibre12">std::reverse(a,b)</kbd>, a permutative algorithm that simply reverses the order of a range of elements by swapping the first item with the last item, the second item with the penultimate item, and so on. One common application of <kbd class="calibre12">std::reverse</kbd> is to reverse the order of larger chunks of a string--for example, to reverse the order of the words in a sentence:</p>
<pre class="calibre23">    void reverse_words_in_place(std::string&amp; s)<br class="title-page-name"/>    {<br class="title-page-name"/>      // First, reverse the whole string.<br class="title-page-name"/>      std::reverse(s.begin(), s.end());<br class="title-page-name"/><br class="title-page-name"/>      // Next, un-reverse each individual word.<br class="title-page-name"/>      for (auto it = s.begin(); true; ++it) {<br class="title-page-name"/>        auto next = std::find(it, s.end(), ' ');<br class="title-page-name"/>        // Reverse the order of letters in this word.<br class="title-page-name"/>        std::reverse(it, next);<br class="title-page-name"/>        if (next == s.end()) {<br class="title-page-name"/>          break;<br class="title-page-name"/>        }<br class="title-page-name"/>        it = next;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::string s = "the quick brown fox jumps over the lazy dog";<br class="title-page-name"/>      reverse_words_in_place(s);<br class="title-page-name"/>      assert(s == "dog lazy the over jumps fox brown quick the");<br class="title-page-name"/>    }</pre>
<p class="calibre2">A small tweak to the implementation of <kbd class="calibre12">std::reverse</kbd> gives us another building block of <kbd class="calibre12">sort</kbd>, namely <kbd class="calibre12">std::partition</kbd>. Whereas <kbd class="calibre12">std::reverse</kbd> walks through the range from both ends swapping each pair of elements unconditionally, <kbd class="calibre12">std::partition</kbd> swaps them only if they are "out of order" with respect to a certain predicate function. In the following example, we're partitioning all <em class="calibre22">even</em> elements to the front of our range and all <em class="calibre22">odd</em> elements to the back. If we were using <kbd class="calibre12">std::partition</kbd> to build a Quicksort sorting routine, we'd be partitioning elements <em class="calibre22">less than the pivot element</em> to the front of the range and elements <em class="calibre22">greater than the pivot element</em> to the back:</p>
<pre class="calibre23">    template&lt;class BidirIt&gt;<br class="title-page-name"/>    void reverse(BidirIt first, BidirIt last)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first != last) {<br class="title-page-name"/>        --last;<br class="title-page-name"/>        if (first == last) break;<br class="title-page-name"/>        using std::swap;<br class="title-page-name"/>        swap(*first, *last);<br class="title-page-name"/>        ++first;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class BidirIt, class Unary&gt;<br class="title-page-name"/>    auto partition(BidirIt first, BidirIt last, Unary p)<br class="title-page-name"/>    {<br class="title-page-name"/>      while (first != last &amp;&amp; p(*first)) {<br class="title-page-name"/>        ++first;<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      while (first != last) {<br class="title-page-name"/>        do {<br class="title-page-name"/>          --last;<br class="title-page-name"/>        } while (last != first &amp;&amp; !p(*last));<br class="title-page-name"/>        if (first == last) break;<br class="title-page-name"/>        using std::swap;<br class="title-page-name"/>        swap(*first, *last);<br class="title-page-name"/>        do {<br class="title-page-name"/>          ++first;<br class="title-page-name"/>        } while (first != last &amp;&amp; p(*first));<br class="title-page-name"/>      }<br class="title-page-name"/>      return first;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()  <br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5};<br class="title-page-name"/>      auto it = std::partition(v.begin(), v.end(), [](int x) {<br class="title-page-name"/>        return x % 2 == 0;<br class="title-page-name"/>      });<br class="title-page-name"/>      assert(it == v.begin() + 3);<br class="title-page-name"/>      assert((v == std::vector{6, 2, 4, 1, 5, 9, 1, 3, 5}));<br class="title-page-name"/>    }</pre>
<p class="calibre2">You might notice something interesting about the preceding code: The code for <kbd class="calibre12">reverse</kbd> and the code for <kbd class="calibre12">partition</kbd> are almost identical! The only difference is that <kbd class="calibre12">partition</kbd> contains an awkward do-while loop where <kbd class="calibre12">reverse</kbd> has just a simple increment or decrement.</p>
<p class="calibre2">You might also have noticed that the first do-while loop in <kbd class="calibre12">partition</kbd> is equivalent to a standard algorithm we've already seen; namely, <kbd class="calibre12">std::find_if_not</kbd>. And the second do-while loop is sort of equivalent to <kbd class="calibre12">std::find_if</kbd>... except that it needs to run <em class="calibre22">backwards</em>, not forwards! Unfortunately for us, there is no such algorithm as <kbd class="calibre12">std::rfind_if</kbd>. But--as you might have suspected by now--the standard library isn't going to leave us in the lurch.</p>
<p class="calibre2">We need something that behaves just like an iterator for the purposes of <kbd class="calibre12">std::find_if</kbd>, but iterates "backwards." The standard library provides this exact thing in the form of the <kbd class="calibre12">std::reverse_iterator</kbd> adaptor. We won't show the code for it; revisit <a target="_blank" href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>, if you need a refresher on how it might be implemented. Suffice it to say, a <kbd class="calibre12">std::reverse_iterator&lt;FwdIt&gt;</kbd> object wraps and behaves just like a <kbd class="calibre12">FwdIt</kbd> object, except that when you increment the wrapper, it decrements the wrapped object, and vice versa. So we can write <kbd class="calibre12">partition</kbd> in terms of <kbd class="calibre12">reverse_iterator</kbd> as follows:</p>
<pre class="calibre23">    // Shorthands for "reversing" and "unreversing".<br class="title-page-name"/>    template&lt;class It&gt;<br class="title-page-name"/>    auto rev(It it) {<br class="title-page-name"/>      return std::reverse_iterator(it);<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class InnerIt&gt;<br class="title-page-name"/>    auto unrev(std::reverse_iterator&lt;InnerIt&gt; it) {<br class="title-page-name"/>      return it.base();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class BidirIt, class Unary&gt;<br class="title-page-name"/>    auto partition(BidirIt first, BidirIt last, Unary p)<br class="title-page-name"/>    {<br class="title-page-name"/>      first = std::find_if_not(first, last, p);<br class="title-page-name"/><br class="title-page-name"/>      while (first != last) {<br class="title-page-name"/>        last = unrev(std::find_if(rev(last), rev(first), p));<br class="title-page-name"/>        if (first == last) break;<br class="title-page-name"/>        using std::swap;<br class="title-page-name"/>        swap(*first++, *--last);<br class="title-page-name"/>        first = std::find_if_not(first, last, p);<br class="title-page-name"/>      }<br class="title-page-name"/>      return first;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Of course, sometimes it's useful to partition a range without changing the relative order of the elements in either partition. For those times, there's <kbd class="calibre12">std::stable_partition(a,b,p)</kbd> (but see the section <em class="calibre22">Merges and mergesort</em> for a caveat about <kbd class="calibre12">stable_partition</kbd>: It may allocate memory using <kbd class="calibre12">operator new</kbd>).</p>
<p class="calibre2">There are a few non-permutative algorithms that also deal with partitions:</p>
<p class="calibre2"><kbd class="calibre12">std::is_partitioned(a,b,p)</kbd> returns <kbd class="calibre12">true</kbd> if the given range is already partitioned by the predicate <kbd class="calibre12">p</kbd> (so that all the elements satisfying <kbd class="calibre12">p</kbd> come at the front and all the ones not satisfying <kbd class="calibre12">p</kbd> come at the back).</p>
<p class="calibre2"><kbd class="calibre12">std::partition_point(a,b,p)</kbd> uses binary search to find the first element in an already partitioned range that doesn't satisfy <kbd class="calibre12">p</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::partition_copy(a,b,ot,of,p)</kbd> copies each of the elements in the range <kbd class="calibre12">[a,b)</kbd> to one or the other of the output iterators: <kbd class="calibre12">*ot++ = e</kbd> for elements where <kbd class="calibre12">p(e)</kbd> is <kbd class="calibre12">true</kbd>, and <kbd class="calibre12">*of++ = e</kbd> for elements where <kbd class="calibre12">p(e)</kbd> is <kbd class="calibre12">false</kbd>.</p>
<p class="calibre2">Incidentally, if you only want one output sequence or the other, then you can use <kbd class="calibre12">std::copy_if(a,b,ot,p)</kbd> or <kbd class="calibre12">std::remove_copy_if(a,b,of,p)</kbd> respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rotation and permutation</h1>
                
            
            
                
<p class="calibre2">Remember our code from <em class="calibre22">Swapping, reversing, and partitioning</em> to reverse the order of words in a sentence? When the "sentence" contains only two words, there is another way to look at the reversal: you could consider it a <em class="calibre22">cyclic rotation</em> of the elements in the underlying range. <kbd class="calibre12">std::rotate(a,mid,b)</kbd> rotates the elements of the range <kbd class="calibre12">[a,b)</kbd> so that the element formerly addressed by <kbd class="calibre12">mid</kbd> is now at <kbd class="calibre12">a</kbd> (and returns an iterator pointing to the element whose value was formerly at <kbd class="calibre12">a</kbd>):</p>
<pre class="calibre23">    template&lt;class FwdIt&gt;<br class="title-page-name"/>    FwdIt rotate(FwdIt a, FwdIt mid, FwdIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      auto result = a + (b - mid);<br class="title-page-name"/><br class="title-page-name"/>      // First, reverse the whole range.<br class="title-page-name"/>      std::reverse(a, b);<br class="title-page-name"/><br class="title-page-name"/>      // Next, un-reverse each individual segment.<br class="title-page-name"/>      std::reverse(a, result);<br class="title-page-name"/>      std::reverse(result, b);<br class="title-page-name"/><br class="title-page-name"/>      return result;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};<br class="title-page-name"/>      auto five = std::find(v.begin(), v.end(), 5);<br class="title-page-name"/>      auto one = std::rotate(v.begin(), five, v.end());<br class="title-page-name"/>      assert((v == std::vector{5, 6, 1, 2, 3, 4}));<br class="title-page-name"/>      assert(*one == 1);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Another miscellaneous but sometimes useful permutative algorithm is <kbd class="calibre12">std::next_permutation(a,b)</kbd>. Calling this function in a loop runs through all the possible permutations of <em class="calibre22">n</em> elements, which might be useful if you're trying to brute-force a solution to a (small) instance of the Traveling Salesman Problem:</p>
<pre class="calibre23">    std::vector&lt;int&gt; p = {10, 20, 30};<br class="title-page-name"/>    std::vector&lt;std::vector&lt;int&gt;&gt; results;<br class="title-page-name"/><br class="title-page-name"/>    // Collect the permutations of these three elements.<br class="title-page-name"/>    for (int i=0; i &lt; 6; ++i) {<br class="title-page-name"/>      results.push_back(p);<br class="title-page-name"/>      std::next_permutation(p.begin(), p.end());<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    assert((results == std::vector&lt;std::vector&lt;int&gt;&gt;{<br class="title-page-name"/>      {10, 20, 30},<br class="title-page-name"/>      {10, 30, 20},<br class="title-page-name"/>      {20, 10, 30},<br class="title-page-name"/>      {20, 30, 10},<br class="title-page-name"/>      {30, 10, 20},<br class="title-page-name"/>      {30, 20, 10},<br class="title-page-name"/>    }));</pre>
<p class="calibre2">Notice that <kbd class="calibre12">next_permutation</kbd> uses the idea of a "less-than relationship" to determine that one permutation is lexicographically "less than" another; for example, <kbd class="calibre12">{20, 10, 30}</kbd> is "less than" <kbd class="calibre12">{20, 30, 10}</kbd> because 10 is less than 30. Therefore, <kbd class="calibre12">next_permutation</kbd> also has a comparator-based version: <kbd class="calibre12">std::next_permutation(a,b,cmp)</kbd>. There are also <kbd class="calibre12">std::prev_permutation(a,b)</kbd> and <kbd class="calibre12">std::prev_permutation(a,b,cmp)</kbd>, which count lexicographically "downward" instead of "upward."</p>
<p class="calibre2">By the way, to compare two sequences lexicographically in this way, you could use <kbd class="calibre12">std::mismatch</kbd> from section <em class="calibre22">Read-only range algorithms</em>, or you could just use the standard-provided <kbd class="calibre12">std::lexicographical_compare(a,b,c,d)</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Heaps and heapsort</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre12">std::make_heap(a,b)</kbd> (or its comparator-based version, <kbd class="calibre12">std::make_heap(a,b,cmp)</kbd>) takes a range of unsorted elements and rearranges them into an order that satisfies the <em class="calibre22">max-heap property</em>: in an array with the max-heap property, each element of the range at index <em class="calibre22">i</em> will be at least as great as either of the elements at indices 2<em class="calibre22">i</em>+1 and 2<em class="calibre22">i</em>+2. This implies that the greatest element of all will be at index 0.</p>
<p class="calibre2"><kbd class="calibre12">std::push_heap(a,b)</kbd> (or its comparator-based version) assumes that the range <kbd class="calibre12">[a,b-1)</kbd> is already a max-heap. It takes the element currently at <kbd class="calibre12">b[-1]</kbd> and "bubbles it up," by swapping with its parent in the heap, until the max-heap property is restored for the whole range <kbd class="calibre12">[a,b)</kbd>. Notice that <kbd class="calibre12">make_heap</kbd> can be implemented as a simple loop repeatedly calling <kbd class="calibre12">std::push_heap(a,++b)</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::pop_heap(a,b)</kbd> (or its comparator-based version) assumes that the range <kbd class="calibre12">[a,b)</kbd> is already a max-heap. It swaps <kbd class="calibre12">a[0]</kbd> with <kbd class="calibre12">b[-1]</kbd>, so that the greatest element is now at the <em class="calibre22">back</em> of the range instead of at the front; and then it swaps <kbd class="calibre12">a[0]</kbd> with one of its children in the heap, and so on, "bubbling it down" until the max-heap property is restored. After a call to <kbd class="calibre12">pop_heap(a,b)</kbd>, the greatest element will be at <kbd class="calibre12">b[-1]</kbd> and the range <kbd class="calibre12">[a, b-1)</kbd> will have the max-heap property.</p>
<p class="calibre2"><kbd class="calibre12">std::sort_heap(a,b)</kbd> (or its comparator-based version) takes a range with the max-heap property and permutes it into sorted order by repeatedly calling <kbd class="calibre12">std::pop_heap(a, b--)</kbd>.</p>
<p class="calibre2">Using these building blocks, we can implement the classic "heapsort" algorithm. The standard library's <kbd class="calibre12">std::sort</kbd> function might reasonably be implemented like this (but in practice it is typically implemented as a hybrid algorithm, such as "introsort"):</p>
<pre class="calibre23">    template&lt;class RandomIt&gt;<br class="title-page-name"/>    void push_heap(RandomIt a, RandomIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      auto child = ((b-1) - a);<br class="title-page-name"/>      while (child != 0) {<br class="title-page-name"/>        auto parent = (child - 1) / 2;<br class="title-page-name"/>        if (a[child] &lt; a[parent]) {<br class="title-page-name"/>          return; // max-heap property has been restored<br class="title-page-name"/>        }<br class="title-page-name"/>        std::iter_swap(a+child, a+parent);<br class="title-page-name"/>        child = parent;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class RandomIt&gt;<br class="title-page-name"/>    void pop_heap(RandomIt a, RandomIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      using DistanceT = decltype(b - a);<br class="title-page-name"/><br class="title-page-name"/>      std::iter_swap(a, b-1);<br class="title-page-name"/><br class="title-page-name"/>      DistanceT parent = 0;<br class="title-page-name"/>      DistanceT new_heap_size = ((b-1) - a);<br class="title-page-name"/><br class="title-page-name"/>      while (true) {<br class="title-page-name"/>        auto leftchild = 2 * parent + 1;<br class="title-page-name"/>        auto rightchild = 2 * parent + 2;<br class="title-page-name"/>        if (leftchild &gt;= new_heap_size) {<br class="title-page-name"/>          return;<br class="title-page-name"/>        }<br class="title-page-name"/>        auto biggerchild = leftchild;<br class="title-page-name"/>        if (rightchild &lt; new_heap_size &amp;&amp; a[leftchild] &lt; a[rightchild]) {<br class="title-page-name"/>          biggerchild = rightchild;<br class="title-page-name"/>        }<br class="title-page-name"/>        if (a[biggerchild] &lt; a[parent]) {<br class="title-page-name"/>          return; // max-heap property has been restored<br class="title-page-name"/>        }<br class="title-page-name"/>        std::iter_swap(a+parent, a+biggerchild);<br class="title-page-name"/>        parent = biggerchild;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class RandomIt&gt;<br class="title-page-name"/>    void make_heap(RandomIt a, RandomIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      for (auto it = a; it != b; ) {<br class="title-page-name"/>        push_heap(a, ++it);<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class RandomIt&gt;<br class="title-page-name"/>    void sort_heap(RandomIt a, RandomIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      for (auto it = b; it != a; --it) {<br class="title-page-name"/>        pop_heap(a, it);<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class RandomIt&gt;<br class="title-page-name"/>    void sort(RandomIt a, RandomIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      make_heap(a, b);<br class="title-page-name"/>      sort_heap(a, b);<br class="title-page-name"/>    }</pre>
<p class="calibre2">We'll see another application of <kbd class="calibre12">push_heap</kbd> and <kbd class="calibre12">pop_heap</kbd> in <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>, when we talk about <kbd class="calibre12">std::priority_queue</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Merges and mergesort</h1>
                
            
            
                
<p class="calibre2">As long as we're on the topic of sorting algorithms, let's write <kbd class="calibre12">sort</kbd> a different way!</p>
<p class="calibre2"><kbd class="calibre12">std::inplace_merge(a,mid,b)</kbd> takes a single range <kbd class="calibre12">[a,b)</kbd> which has already been sorted with the equivalent of <kbd class="calibre12">std::sort(a,mid)</kbd> and <kbd class="calibre12">std::sort(mid,b)</kbd>, and merges the two subranges together into a single sorted range. We can use this building block to implement the classic mergesort algorithm:</p>
<pre class="calibre23">    template&lt;class RandomIt&gt;<br class="title-page-name"/>    void sort(RandomIt a, RandomIt b)<br class="title-page-name"/>    {<br class="title-page-name"/>      auto n = std::distance(a, b);<br class="title-page-name"/>      if (n &gt;= 2) {<br class="title-page-name"/>        auto mid = a + n/2;<br class="title-page-name"/>        std::sort(a, mid);<br class="title-page-name"/>        std::sort(mid, b);<br class="title-page-name"/>        std::inplace_merge(a, mid, b);<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">However, beware! The name <kbd class="calibre12">inplace_merge</kbd> seems to imply that the merging is happening "in-place" without the need for any additional buffer space; but this is not what happens in fact. In actuality, the <kbd class="calibre12">inplace_merge</kbd> function allocates a buffer for its own use, typically by calling <kbd class="calibre12">operator new</kbd>. If you are programming in an environment where heap allocation is problematic, then you should <em class="calibre22">avoid</em> <kbd class="calibre12">inplace_merge</kbd> <em class="calibre22">like the plague</em>.</p>
<p class="calibre2">The other standard algorithms that may allocate temporary buffers on the heap are <kbd class="calibre12">std::stable_sort</kbd> and <kbd class="calibre12">std::stable_partition</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::merge(a,b,c,d,o)</kbd> is the non-allocating merge algorithm; it takes two iterator-pairs representing the ranges <kbd class="calibre12">[a,b)</kbd> and <kbd class="calibre12">[c,d)</kbd> and merges them into the output range defined by <kbd class="calibre12">o</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Searching and inserting in a sorted array with std::lower_bound</h1>
                
            
            
                
<p class="calibre2">Once a range of data has been sorted, it becomes possible to search within that data using binary search, as opposed to the slower linear search. The standard algorithm that implements binary search is called <kbd class="calibre12">std::lower_bound(a,b,v)</kbd>:</p>
<pre class="calibre23">    template&lt;class FwdIt, class T, class C&gt;<br class="title-page-name"/>    FwdIt lower_bound(FwdIt first, FwdIt last, const T&amp; value, C lessthan)<br class="title-page-name"/>    {<br class="title-page-name"/>      using DiffT = typename std::iterator_traits&lt;FwdIt&gt;::difference_type;<br class="title-page-name"/>      FwdIt it;<br class="title-page-name"/>      DiffT count = std::distance(first, last);<br class="title-page-name"/><br class="title-page-name"/>      while (count &gt; 0) {<br class="title-page-name"/>        DiffT step = count / 2;<br class="title-page-name"/>        it = first;<br class="title-page-name"/>        std::advance(it, step);<br class="title-page-name"/>        if (lessthan(*it, value)) {<br class="title-page-name"/>          ++it;<br class="title-page-name"/>          first = it;<br class="title-page-name"/>          count -= step + 1;<br class="title-page-name"/>        } else {<br class="title-page-name"/>          count = step;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return first;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;class FwdIt, class T&gt;<br class="title-page-name"/>    FwdIt lower_bound(FwdIt first, FwdIt last, const T&amp; value) <br class="title-page-name"/>    {<br class="title-page-name"/>      return std::lower_bound(first, last, value, std::less&lt;&gt;{});<br class="title-page-name"/>    }</pre>
<p class="calibre2">This function returns an iterator to the first element in the range that is <em class="calibre22">not less than</em> the given value <kbd class="calibre12">v</kbd>. If there is an instance of the value <kbd class="calibre12">v</kbd> already in the range, then the returned iterator will point at it (in fact, it will point at the <em class="calibre22">first</em> such value in the range). If there's no instance already in the range, then the returned iterator will point at the place where <kbd class="calibre12">v</kbd> should go.</p>
<p class="calibre2">We can use the return value of <kbd class="calibre12">lower_bound</kbd> as the input to <kbd class="calibre12">vector::insert</kbd> in order to insert <kbd class="calibre12">v</kbd> into the proper place in a sorted vector while preserving its sorted order:</p>
<pre class="calibre23">    std::vector&lt;int&gt; vec = {3, 7};<br class="title-page-name"/>    for (int value : {1, 5, 9}) {<br class="title-page-name"/>      // Find the appropriate insertion point...<br class="title-page-name"/>      auto it = std::lower_bound(vec.begin(), vec.end(), value);<br class="title-page-name"/>      // ...and insert our value there.<br class="title-page-name"/>      vec.insert(it, value);<br class="title-page-name"/>    }<br class="title-page-name"/>    // The vector has remained sorted.<br class="title-page-name"/>    assert((vec == std::vector{1, 3, 5, 7, 9}));</pre>
<p class="calibre2">The similar function <kbd class="calibre12">std::upper_bound(a,b,v)</kbd> returns an iterator to the first element in the range that is <em class="calibre22">greater than</em> the given value <kbd class="calibre12">v</kbd>. If <kbd class="calibre12">v</kbd> is not in the given range, then <kbd class="calibre12">std::lower_bound</kbd> and <kbd class="calibre12">std::upper_bound</kbd> will have the same return value. But if <kbd class="calibre12">v</kbd> is present in the range, then <kbd class="calibre12">lower_bound</kbd> will return an iterator pointing to the first instance of <kbd class="calibre12">v</kbd> in the range and <kbd class="calibre12">upper_bound</kbd> will return an iterator pointing "one past" the last instance of <kbd class="calibre12">v</kbd> in the range. In other words, using the two functions together will give you a half-open range <kbd class="calibre12">[lower, upper)</kbd> containing nothing but instances of the value <kbd class="calibre12">v</kbd>:</p>
<pre class="calibre23">    std::vector&lt;int&gt; vec = {2, 3, 3, 3, 4};<br class="title-page-name"/>    auto lower = std::lower_bound(vec.begin(), vec.end(), 3);<br class="title-page-name"/><br class="title-page-name"/>    // First approach:<br class="title-page-name"/>    // upper_bound's interface is identical to lower_bound's.<br class="title-page-name"/>    auto upper = std::upper_bound(vec.begin(), vec.end(), 3);<br class="title-page-name"/> <br class="title-page-name"/>    // Second approach:<br class="title-page-name"/>    // We don't need to binary-search the whole array the second time.<br class="title-page-name"/>    auto upper2 = std::upper_bound(lower, vec.end(), 3);<br class="title-page-name"/>    assert(upper2 == upper);<br class="title-page-name"/><br class="title-page-name"/>    // Third approach:<br class="title-page-name"/>    // Linear scan from the lower bound might well be faster<br class="title-page-name"/>    // than binary search if our total range is really big.<br class="title-page-name"/>    auto upper3 = std::find_if(lower, vec.end(), [](int v) {<br class="title-page-name"/>      return v != 3;<br class="title-page-name"/>    });<br class="title-page-name"/>    assert(upper3 == upper);<br class="title-page-name"/><br class="title-page-name"/>    // No matter which approach we take, this is what we end up with.<br class="title-page-name"/>    assert(*lower &gt;= 3);<br class="title-page-name"/>    assert(*upper &gt; 3);<br class="title-page-name"/>    assert(std::all_of(lower, upper, [](int v) { return v == 3; }));</pre>
<p class="calibre2">This handles searching and inserting values in a sorted array. But what about deletion?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Deleting from a sorted array with std::remove_if</h1>
                
            
            
                
<p class="calibre2">In all our discussion of standard generic algorithms up to this point, we haven't covered the question of how to remove items from a range. This is because the concept of "a range" is fundamentally read-only: we might change the <em class="calibre22">values</em> of the elements of a given range, but we can never use a standard algorithm to shorten or lengthen <em class="calibre22">the range itself</em>. When, in the <em class="calibre22">Shunting data with std::copy</em> section, we used <kbd class="calibre12">std::copy</kbd> to "insert into" a vector named <kbd class="calibre12">dest</kbd>, it wasn't the <kbd class="calibre12">std::copy</kbd> algorithm that was doing the inserting; it was the <kbd class="calibre12">std::back_insert_iterator</kbd> object itself that held a reference to the underlying container and was able to insert into the container. <kbd class="calibre12">std::copy</kbd> didn't take <kbd class="calibre12">dest.begin()</kbd> and <kbd class="calibre12">dest.end()</kbd> as parameters; instead it took the special object <kbd class="calibre12">std::back_inserter(dest)</kbd>.</p>
<p class="calibre2">So how do we erase items from a range? Well, we can't. All we can do is erase items from a <em class="calibre22">container</em>; and the algorithms of the STL do not deal in containers. So what we ought to be looking for is a way to rearrange the values of a range so that the "removed" items will wind up somewhere predictable, so that we can quickly erase them all from the underlying container (using some means other than an STL algorithm).</p>
<p class="calibre2">We've seen one possible approach already:</p>
<pre class="calibre23">    std::vector&lt;int&gt; vec = {1, 3, 3, 4, 6, 8};<br class="title-page-name"/><br class="title-page-name"/>    // Partition our vector so that all the non-3s are at the front<br class="title-page-name"/>    // and all the 3s are at the end.<br class="title-page-name"/>    auto first_3 = std::stable_partition(<br class="title-page-name"/>      vec.begin(), vec.end(), [](int v){ return v != 3; }<br class="title-page-name"/>    );<br class="title-page-name"/><br class="title-page-name"/>    assert((vec == std::vector{1, 4, 6, 8, 3, 3}));<br class="title-page-name"/><br class="title-page-name"/>    // Now erase the "tail" of our vector.<br class="title-page-name"/>    vec.erase(first_3, vec.end());<br class="title-page-name"/><br class="title-page-name"/>    assert((vec == std::vector{1, 4, 6, 8}));</pre>
<p class="calibre2">But this is much more wasteful than it needs to be (notice that <kbd class="calibre12">stable_partition</kbd> is one of those few STL algorithms that allocates a temporary buffer on the heap!). The algorithm we want is actually much simpler:</p>
<pre class="calibre23">    template&lt;class FwdIt, class T&gt;<br class="title-page-name"/>    FwdIt remove(FwdIt first, FwdIt last, const T&amp; value) <br class="title-page-name"/>    {<br class="title-page-name"/>      auto out = std::find(first, last, value);<br class="title-page-name"/>      if (out != last) {<br class="title-page-name"/>        auto in = out;<br class="title-page-name"/>        while (++in != last) {<br class="title-page-name"/>          if (*in == value) {<br class="title-page-name"/>             // don't bother with this item<br class="title-page-name"/>          } else {<br class="title-page-name"/>             *out++ = std::move(*in);<br class="title-page-name"/>          }<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return out;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;int&gt; vec = {1, 3, 3, 4, 6, 8};<br class="title-page-name"/><br class="title-page-name"/>      // Partition our vector so that all the non-3s are at the front.<br class="title-page-name"/>      auto new_end = std::remove(<br class="title-page-name"/>        vec.begin(), vec.end(), 3<br class="title-page-name"/>      );<br class="title-page-name"/><br class="title-page-name"/>      // std::remove_if doesn't preserve the "removed" elements.<br class="title-page-name"/>      assert((vec == std::vector{1, 4, 6, 8, 6, 8}));<br class="title-page-name"/><br class="title-page-name"/>      // Now erase the "tail" of our vector.<br class="title-page-name"/>      vec.erase(new_end, vec.end());<br class="title-page-name"/> <br class="title-page-name"/>      assert((vec == std::vector{1, 4, 6, 8}));<br class="title-page-name"/><br class="title-page-name"/>      // Or, do both steps together in a single line.<br class="title-page-name"/>      // This is the "erase-remove idiom":<br class="title-page-name"/>      vec.erase(<br class="title-page-name"/>        std::remove(vec.begin(), vec.end(), 3),<br class="title-page-name"/>        vec.end()<br class="title-page-name"/>      );<br class="title-page-name"/><br class="title-page-name"/>      // But if the array is very long, and we know it's sorted,<br class="title-page-name"/>      // then perhaps it would be better to binary-search for<br class="title-page-name"/>      // the elements to erase.<br class="title-page-name"/>      // Here the "shifting-down" is still happening, but it's<br class="title-page-name"/>      // happening inside vector::erase instead of inside std::remove.<br class="title-page-name"/>      auto first = std::lower_bound(vec.begin(), vec.end(), 3);<br class="title-page-name"/>      auto last = std::upper_bound(first, vec.end(), 3);<br class="title-page-name"/>      vec.erase(first, last);<br class="title-page-name"/>    }</pre>
<p class="calibre2"><kbd class="calibre12">std::remove(a,b,v)</kbd> removes all values equal to <kbd class="calibre12">v</kbd> from a range <kbd class="calibre12">[a,b)</kbd>. Notice that the range does <em class="calibre22">not</em> have to be sorted--but <kbd class="calibre12">remove</kbd> will preserve whatever order was there before, by "shifting down" the non-removed elements to fill in the gaps in the range. If <kbd class="calibre12">remove</kbd> removes <em class="calibre22">k</em> elements from the range, then when the <kbd class="calibre12">remove</kbd> function returns, there will be <em class="calibre22">k</em> elements at the end of the range whose values are in the moved-from state, and return value of <kbd class="calibre12">remove</kbd> will be an iterator pointing to the first such moved-from element.</p>
<p class="calibre2"><kbd class="calibre12">std::remove_if(a,b,p)</kbd> removes all elements satisfying the given predicate; that is, it removes all elements <kbd class="calibre12">e</kbd> such that <kbd class="calibre12">p(e)</kbd> is true. Just like <kbd class="calibre12">remove</kbd>, <kbd class="calibre12">remove_if</kbd> shifts elements down to fill in the range and returns an iterator to the first "moved-from" element.</p>
<p class="calibre2">The common idiom for removing items from a sequence container is what's known as the <em class="calibre22">erase-remove idiom</em>, because it involves passing that return value straight into the container's own <kbd class="calibre12">.erase()</kbd> member function.</p>
<p class="calibre2">Another standard library algorithm that works with the erase-remove idiom is <kbd class="calibre12">std::unique(a,b)</kbd>, which takes a range and, for each set of consecutive equivalent items, removes all but the first of them. Like <kbd class="calibre12">std::remove</kbd>, the input range doesn't need to be sorted; the algorithm will preserve whatever ordering was there to begin with:</p>
<pre class="calibre23">    std::vector&lt;int&gt; vec = {1, 2, 2, 3, 3, 3, 1, 3, 3};<br class="title-page-name"/><br class="title-page-name"/>    vec.erase(<br class="title-page-name"/>      std::unique(vec.begin(), vec.end()),<br class="title-page-name"/>      vec.end()<br class="title-page-name"/>    );<br class="title-page-name"/><br class="title-page-name"/>    assert((vec == std::vector{1, 2, 3, 1, 3}));</pre>
<p class="calibre2">Finally, notice that we can often do better than <kbd class="calibre12">std::remove</kbd> in general, either by using the <kbd class="calibre12">erase</kbd> member function of whatever our underlying container is (for example, we'll see in the next chapter how <kbd class="calibre12">std::list::erase</kbd> can be much faster than the erase-remove idiom on a <kbd class="calibre12">std::list</kbd>)--and even if we're removing from a vector whose order happens <em class="calibre22">not</em> to be significant, we'll still usually be better off with something like the following generic algorithm <kbd class="calibre12">unstable_remove</kbd>, which has been proposed for future standardization but (at the time of writing) not yet adopted into the STL:</p>
<pre class="calibre23">    namespace my {<br class="title-page-name"/>      template&lt;class BidirIt, class T&gt;<br class="title-page-name"/>      BidirIt unstable_remove(BidirIt first, BidirIt last, const T&amp; value)<br class="title-page-name"/>      {<br class="title-page-name"/>        while (true) {<br class="title-page-name"/>          // Find the first instance of "value"...<br class="title-page-name"/>          first = std::find(first, last, value);<br class="title-page-name"/>          // ...and the last instance of "not value"...<br class="title-page-name"/>          do {<br class="title-page-name"/>            if (first == last) {<br class="title-page-name"/>              return last;<br class="title-page-name"/>            }<br class="title-page-name"/>            --last;<br class="title-page-name"/>          } while (*last == value);<br class="title-page-name"/>          // ...and move the latter over top of the former.<br class="title-page-name"/>          *first = std::move(*last);<br class="title-page-name"/>          // Rinse and repeat.<br class="title-page-name"/>          ++first;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    } // namespace my<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;int&gt; vec = {4, 1, 3, 6, 3, 8};<br class="title-page-name"/><br class="title-page-name"/>      vec.erase(<br class="title-page-name"/>        my::unstable_remove(vec.begin(), vec.end(), 3),<br class="title-page-name"/>        vec.end()<br class="title-page-name"/>      );<br class="title-page-name"/><br class="title-page-name"/>      assert((vec == std::vector{4, 1, 8, 6}));<br class="title-page-name"/>    }</pre>
<p class="calibre2">In the next chapter, we'll look at <em class="calibre22">containers</em>--the STL's answer to the question, "Where are all these elements being stored, anyway?"</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">The Standard Template Library has a generic algorithm for (almost) every desire. If you're doing something algorithmic, check the STL first!</p>
<p class="calibre2">STL algorithms deal in the half-open ranges defined by pairs of iterators. Be careful when dealing with any of the one-and-a-half-range algorithms.</p>
<p class="calibre2">STL algorithms that deal with comparison and sorting will use <kbd class="calibre12">operator&lt;</kbd> by default, but you can always pass a two-argument "comparator" instead. If you want to perform a non-trivial operation on a whole range of data, remember that the STL might support it directly (<kbd class="calibre12">std::move</kbd>, <kbd class="calibre12">std::transform</kbd>) or indirectly via a special iterator type (<kbd class="calibre12">std::back_inserter</kbd>, <kbd class="calibre12">std::istream_iterator</kbd>).</p>
<p class="calibre2">You should know what a "permutation" is, and how the standard permutative algorithms (<kbd class="calibre12">swap</kbd>, <kbd class="calibre12">reverse</kbd>, <kbd class="calibre12">rotate</kbd>, <kbd class="calibre12">partition</kbd>, <kbd class="calibre12">sort</kbd>) are implemented in terms of one another. Just three STL algorithms (<kbd class="calibre12">stable_sort</kbd>, <kbd class="calibre12">stable_partition</kbd>, <kbd class="calibre12">inplace_merge</kbd>) may quietly allocate memory from the heap; if you can't afford heap allocation, avoid these three algorithms like the plague.</p>
<p class="calibre2">Use the erase-remove idiom to maintain the sort order of a sequence container even as you delete items from it. Use something like <kbd class="calibre12">my::unstable_remove</kbd> if you don't care about the sort order. Use <kbd class="calibre12">.erase()</kbd> for containers that support it.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            

            
        
    </body></html>