- en: Chapter 2. Steps in Writing a Frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a TOY language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a lexer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Abstract Syntax Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing simple expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing binary expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking a driver for parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running lexer and parser on our TOY language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining IR code generation methods for each AST class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating IR code for expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating IR code for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding IR optimization support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will get to know about how to write a frontend for a language.
    By making use of a custom-defined TOY language, you will have recipes on how to
    write a lexer and a parser, and how to generate IR code from the **Abstract Syntax
    Tree** (**AST**) generated by the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a TOY language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before implementing a lexer and parser, the syntax and grammar of the language
    need to be determined first. In this chapter, a TOY language is used to demonstrate
    how a lexer and a parser can be implemented. The purpose of this recipe is to
    show how a language is skimmed through. For this purpose, the TOY language to
    be used is simple but meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: A language typically has some variables, some function calls, some constants,
    and so on. To keep things simple, our TOY language in consideration has only numeric
    constants of 32-bit Integer type A, a variable that need not declare its type
    (like Python, in contrast to C/C++/Java, which require a type declaration) in
    the TOY language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The grammar can be defined as follows (the production rules are defined below,
    with non-terminals on **Left Hand Side** (**LHS**) and a combination of terminals
    and non-terminals on **Right Hand Side** (**RHS**); when LHS is encountered, it
    yields appropriate RHS defined in the production rule):'
  prefs: []
  type: TYPE_NORMAL
- en: 'A numeric expression will give a constant number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A parenthesis expression will have an expression in between an opening and
    a closing bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An identifier expression will either yield an identifier or a function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If identifier `_expr` is a function call, it will either have no arguments
    or list of arguments separated by a comma:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There will be some primary expression, the starting point of the grammar, which
    may yield an identifier expression, a numeric expression, or a parenthesis expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An expression can lead to a binary expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A binary operation with RHS can yield combinations of binary operators and
    expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A function declaration can have grammar as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A function definition is distinguished by a `def` keyword followed by a function
    declaration and an expression that defines its body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, there will be a top level expression that will yield an expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example of the TOY language based on the previously defined grammar can
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since we have defined the grammar, the next step is to write a lexer and parser
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a lexer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lexer is a part of the first phase in compiling a program. Lexer tokenizes a
    stream of input in a program. Then parser consumes these tokens to construct an
    AST. The language to tokenize is generally a context-free language. A token is
    a string of one or more characters that are significant as a group. The process
    of forming tokens from an input stream of characters is called tokenization. Certain
    delimiters are used to identify groups of words as tokens. There are lexer tools
    to automate lexical analysis, such as **LEX**. In the TOY lexer demonstrated in
    the following procedure is a handwritten lexer using C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must have a basic understanding of the TOY language defined in the recipe.
    Create a file named `toy.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All the code that follows will contain all the lexer, parser, and code generation
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While implementing a lexer, types of tokens are defined to categorize streams
    of input strings (similar to states of an automata). This can be done using the
    **enumeration** (**enum**) type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the `enum` in the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following is the term list for the preceding example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`EOF_TOKEN`: It states the end of file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NUMERIC_TOKEN:` The current token is of numeric type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDENTIFIER_TOKEN:` The current token is identifier'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PARAN_TOKEN:` The current token is parenthesis'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEF_TOKEN`: The current token `def` states that whatever follows is a function
    definition'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To hold numeric values, a static variable is defined in the `toy.cpp` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To hold the `Identifier` string name, a static variable can be defined in the
    `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the lexer function can be defined by using library functions such as `isspace()`,
    `isalpha()`, and `fgetc()` in the `toy.cpp` file, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example TOY language defined earlier was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The lexer will get the preceding program as input. It will come across the `def`
    keyword and determine that whatever follows is a definition token, and hence returns
    the enum value `DEF_TOKEN`. After this, it will come across the function definition
    and its arguments. Then, there is an expression that involves two binary operators,
    two variables, and a numeric constant. How these are stored in data structures
    is demonstrated in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See more sophisticated and detailed handwritten lexer for the C++ language is
    written in Clang, at [http://clang.llvm.org/doxygen/Lexer_8cpp_source.html](http://clang.llvm.org/doxygen/Lexer_8cpp_source.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Abstract Syntax Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AST is a tree representation of the abstract syntactic structure of the source
    code of a programming language. The ASTs of programming constructs, such as expressions,
    flow control statements, and so on, are grouped into operators and operands. ASTs
    represent relationships between programming constructs, and not the ways they
    are generated by grammar. ASTs ignore unimportant programming elements such as
    punctuations and delimiters. ASTs generally contain additional properties of every
    element in it, which are useful in further compilation phases. Location of source
    code is one such property, which can be used to throw an error line number if
    an error is encountered in determining the correctness of the source code in accordance
    with the grammar (location, line number, column number, and so on, and other related
    properties are stored in an object of the `SourceManager` class in Clang frontend
    for C++).
  prefs: []
  type: TYPE_NORMAL
- en: The AST is used intensively during semantic analysis, where the compiler checks
    for correct usage of the elements of the program and the language. The compiler
    also generates symbol tables based on the AST during semantic analysis. A complete
    traversal of the tree allows verification of the correctness of the program. After
    verifying correctness, the AST serves as the base for code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must have run the lexer by now to obtain the tokens that will be used in
    generating the AST. The languages we intend to parse consist of expressions, function
    definitions, and function declarations. Again we have various types of expressions—variables,
    binary operators, numeric expressions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define AST structure, proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Below the lexer code, define ASTs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A `base` class is defined for parsing an expression as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, several derived classes are defined for every type of expression to be
    parsed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An AST class for variable expressions is defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The language has some numeric expressions. The `AST` class for such numeric
    expressions can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For expressions involving binary operation, the `AST` class can be defined
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AST` class for function declaration can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AST` class for function definition can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AST` class for function call can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The basic skeleton of the AST is now ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AST acts as a data structure for storing various information about the tokens
    given by the lexer. This information is generated in the parser logic and ASTs
    are filled up according to the type of token being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having generated the AST, we will implement the parser, and only after that
    will we see an example where both lexer and parser will be invoked. For a more
    detailed AST structure of C++ in Clang, refer to: [http://clang.llvm.org/docs/IntroductionToTheClangAST.html](http://clang.llvm.org/docs/IntroductionToTheClangAST.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parser analyzes a code syntactically according to the rules of the language's
    grammar. The parsing phase determines if the input code can be used to form a
    string of tokens according to the defined grammar. A parse tree is constructed
    in this phase. Parser defines functions to organize language into a data structure
    called AST. The parser defined in this recipe uses a recursive decent parser technique
    which is a top-down parser, and uses mutually recursive functions to build the
    AST.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must have the custom-defined language, that is the TOY language in this case,
    and also a stream of tokens generated by the lexer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define some basic value holders in our TOY parser as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a global static variable to hold the current token from the lexer as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to get the next token from the input stream from the lexer
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to define functions for expression parsing by using the AST
    data structure defined in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a generic function to call specific parsing functions according to the
    types of tokens determined by the lexer, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stream of input is tokenized and fed to the parser. `Current_token` holds
    the token to be processed. The type of token is known at this stage and the corresponding
    parser functions are called to initialize ASTs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In next few recipes, you will learn how to parse different expressions. For
    more detailed parsing of the C++ language implemented in Clang, refer to it works:
    [http://clang.llvm.org/doxygen/classclang_1_1Parser.html](http://clang.llvm.org/doxygen/classclang_1_1Parser.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing simple expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to parse a simple expression. A simple expression
    may consist of numeric values, identifiers, function calls, a function declaration,
    and function definitions. For each type of expression, individual parser logic
    needs to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must have the custom-defined language—that is, the TOY language in this case—and
    also stream of tokens generated by lexer. We already defined ASTs above. Further,
    we are going to parse the expression and invoke AST constructors for every type
    of expression.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To parse simple expressions, proceed with the following code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We already have lexer logic present in the `toy.cpp` file. Whatever code follows
    needs to be appended after the lexer code in the `toy.cpp` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `parser` function for numeric expression as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `parser` function for an identifier expression. Note that identifier
    can be a variable reference or a function call. They are distinguished by checking
    if the next token is `(`. This is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `parser` function for the function declaration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `parser` function for the function definition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the function called `expression_parser` used in the preceding code,
    parses the expression. The function can be defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a numeric token is encountered, the constructor for the numeric expression
    is invoked and the AST object for the numeric value is returned by the parser,
    filling up the AST for numeric values with the numeric data.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for identifier expressions, the parsed data will either be a variable
    or a function call. For function declaration and definitions, the name of the
    function and function arguments is parsed and the corresponding AST class constructors
    are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing binary expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to parse a binary expression.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must have the custom-defined language—that is, the toy language in this case—and
    also stream of tokens generated by lexer. The binary expression parser requires
    precedence of binary operators for determining LHS and RHS in order. An STL map
    can be used to define precedence of binary operators.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To parse a binary expression, proceed with the following code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `map` for operator precedence to store the precedence at global scope
    in the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The TOY language for demonstration has 4 operators where precedence of operators
    is defined as `-`< `+` < `/` < `*`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A function to initialize precedence—that is, to store precedence value in `map`—can
    be defined in global scope in the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A helper function to return precedence of binary operator can be defined as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the `binary` operator parser can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, precedence of current operator is checked with the precedence of old operator,
    and the outcome is decided according to LHS and RHS of binary operators. Note
    that the binary operator parser is recursively called since the RHS can be an
    expression and not just a single identifier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A `parser` function for parenthesis can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some top-level functions acting as wrappers around these `parser` functions
    can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the remaining recipes in this chapter pertain to user objects. For detailed
    parsing of expressions, and for C++ parsing, please refer to: [http://clang.llvm.org/doxygen/classclang_1_1Parser.html](http://clang.llvm.org/doxygen/classclang_1_1Parser.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking a driver for parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to call the parser function from the main
    function of our TOY parser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To invoke a driver program to start parsing, define the driver function as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `Driver` function called from the main function, and a parser can now be
    defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function to run the whole program can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main function is responsible for calling the lexer and parser so that both
    can act over a piece of code that is being input to the compiler frontend. From
    the main function, driver function is invoked to start the process of parsing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For details on how the main function and driver function work for c++ parsing
    in Clang, refer to [http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running lexer and parser on our TOY language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that a full-fledged lexer and parser for our TOY language grammar are defined,
    it's time to run it on example TOY language.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you should have understanding of TOY language grammar and all the
    previous recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run and test the Lexer and Parser on TOY Language, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First step is to compile the `toy.cpp` program into an executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `toy` executable is our TOY compiler frontend. The `toy` language to be
    parsed is in a file called `example`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This file is passed as argument to be processed by the `toy` compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TOY compiler will open the `example` file in read mode. Then, it will tokenize
    the stream of words. It will come across the def keyword and return `DEF_TOKEN`.
    Then, the `HandleDefn()` function will be called, which will store the function
    name and the argument. It will recursively check for the type of token and then
    call the specific token handler functions to store them into respective ASTs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aforementioned lexer and parser do not handle errors in syntax except a
    few trivial ones. To implement Error handling, refer to [http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics](http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining IR code generation methods for each AST class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, since the AST is ready with all the necessary information in its data structure,
    the next phase is to generate LLVM IR. LLVM APIs are used in this code generation.
    LLVM IR has a predefined format that is generated by the inbuilt APIs of LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have created the AST from any input code of the TOY language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to generate LLVM IR, a virtual `CodeGen` function is defined in each
    AST class (the AST classes were defined earlier in the AST section; these functions
    are additional to those classes) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `BaseAST` class defined earlier, append the `Codegen()` functions as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This virtual `Codegen()` function is included in every AST class we defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This function returns an LLVM Value object, which represents **Static Single
    Assignment** (**SSA**) value in LLVM. A few more static variables are defined
    that will be used during Codegen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Declare the following static variables in global scope as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Module_Ob` module contains all the functions and variables in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The `Builder` object helps to generate LLVM IR and keeps track of the current
    point in the program to insert LLVM instructions. The `Builder` object has functions
    to create new instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Named_Values` map keeps track of all the values defined in the current
    scope like a symbol table. For our language, this map will contain function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Generating IR code for expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will see how IR code gets generated for an expression using
    the compiler frontend.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement LLVM IR code generation for our TOY language, proceed with the
    following code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `toy.cpp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function to generate code for numeric values can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In LLVM IR, integer constants are represented by the `ConstantInt` class whose
    numeric value is held by the `APInt` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The function for generating code for variable expressions can be defined as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Codegen()` function for binary expression can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the code above emits multiple `addtmp` variables, LLVM will automatically
    provide each one with an increasing, unique numeric suffix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe shows how to generate IR code for function; we will learn how
    the code generation actually works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating IR code for functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe you, will learn how to generate IR code for a function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Codegen()` function for the function call can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we have the function to call, we recursively call the `Codegen()` function
    for each argument that is to be passed in and create an LLVM call instruction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the `Codegen()` function for a function call has been defined, it's
    time to define the `Codegen()` functions for declarations and function definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Codegen()` function for function declarations can be defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Codegen()` function for function definition can be defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! LLVMIR is now ready. These `Codegen()` functions can be called
    in the wrappers written to parse top-level expressions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, after parsing successfully, the respective `Codegen()` functions are called
    to generate the LLVM IR. The `dump()` function is called to print the generated
    IR.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Codegen()` functions use LLVM inbuilt function calls to generate IR. The
    header files to include for this purpose are `llvm/IR/Verifier.h`, `llvm/IR/DerivedTypes.h`,
    `llvm/IR/IRBuilder.h`, and `llvm/IR/LLVMContext.h`, `llvm/IR/Module.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While compiling, this code needs to be linked with LLVM libraries. For this
    purpose, the `llvm-config` tool can be used as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this purpose, the `toy` program is recompiled with additional flags as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the `toy` compiler is now run on `example` code, it will generate LLVM
    IR as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another `example2` file has a function `call.$ cat example2`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Its LLVM IR will be dumped as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For details on how `Codegen()` functions for C++ in Clang, refer to [http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding IR optimization support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM provides a wide variety of optimization passes. LLVM allows a compiler
    implementation to decide which optimizations to use, their order, and so on. In
    this recipe, you will learn how to add IR optimization support.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the addition of IR optimization support, first of all a static
    variable for function manager has to be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, a function pass manager needs to be defined for the `Module` object used
    previously. This can be done in the `main()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now a pipeline of various optimizer passes can be added in the `main()` function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the static global function Pass Manager is assigned to this pipeline as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This PassManager has a run method, which we can run on the function IR generated
    before returning from `Codegen()` of the function definition. This is demonstrated
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a lot more beneficial as it optimizes the function in place, improving
    the code generated for the function body.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to add our own optimization pass and its run method will be demonstrated
    in the later chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
