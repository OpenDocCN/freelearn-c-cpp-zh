- en: Chapter 2. Steps in Writing a Frontend
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。编写前端步骤
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Defining a TOY language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个TOY语言
- en: Implementing a lexer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个词法分析器
- en: Defining Abstract Syntax Tree
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义抽象语法树
- en: Implementing a parser
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个解析器
- en: Parsing simple expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析简单表达式
- en: Parsing binary expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析二进制表达式
- en: Invoking a driver for parsing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用解析驱动程序
- en: Running lexer and parser on our TOY language
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的TOY语言上运行词法分析和解析器
- en: Defining IR code generation methods for each AST class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个AST类定义IR代码生成方法
- en: Generating IR code for expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为表达式生成IR代码
- en: Generating IR code for functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数生成IR代码
- en: Adding IR optimization support
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加IR优化支持
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will get to know about how to write a frontend for a language.
    By making use of a custom-defined TOY language, you will have recipes on how to
    write a lexer and a parser, and how to generate IR code from the **Abstract Syntax
    Tree** (**AST**) generated by the frontend.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解如何编写一种语言的前端。通过使用自定义的TOY语言，你将获得如何编写词法分析和解析器以及如何从前端生成的**抽象语法树**（**AST**）生成IR代码的配方。
- en: Defining a TOY language
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个TOY语言
- en: Before implementing a lexer and parser, the syntax and grammar of the language
    need to be determined first. In this chapter, a TOY language is used to demonstrate
    how a lexer and a parser can be implemented. The purpose of this recipe is to
    show how a language is skimmed through. For this purpose, the TOY language to
    be used is simple but meaningful.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现词法分析和解析器之前，需要首先确定语言的语法和语法规则。在本章中，使用TOY语言来演示如何实现词法分析和解析器。本配方的目的是展示如何浏览一种语言。为此，要使用的TOY语言简单但有意义。
- en: A language typically has some variables, some function calls, some constants,
    and so on. To keep things simple, our TOY language in consideration has only numeric
    constants of 32-bit Integer type A, a variable that need not declare its type
    (like Python, in contrast to C/C++/Java, which require a type declaration) in
    the TOY language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一种语言通常有一些变量、一些函数调用、一些常量等等。为了保持简单，我们考虑的TOY语言只有32位整型常量A，一个不需要声明其类型（如Python，与C/C++/Java不同，后者需要类型声明）的变量。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The grammar can be defined as follows (the production rules are defined below,
    with non-terminals on **Left Hand Side** (**LHS**) and a combination of terminals
    and non-terminals on **Right Hand Side** (**RHS**); when LHS is encountered, it
    yields appropriate RHS defined in the production rule):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可以定义为如下（生产规则定义如下，非终结符在**左侧**（**LHS**）上，终结符和非终结符的组合在**右侧**（**RHS**）上；当遇到LHS时，它将产生生产规则中定义的适当RHS）：
- en: 'A numeric expression will give a constant number:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个数值表达式将给出一个常数：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A parenthesis expression will have an expression in between an opening and
    a closing bracket:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 括号表达式将在一个开括号和一个闭括号之间有一个表达式：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An identifier expression will either yield an identifier or a function call:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标识符表达式将产生一个标识符或一个函数调用：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If identifier `_expr` is a function call, it will either have no arguments
    or list of arguments separated by a comma:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果标识符 `_expr` 是一个函数调用，它将没有参数或由逗号分隔的参数列表：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There will be some primary expression, the starting point of the grammar, which
    may yield an identifier expression, a numeric expression, or a parenthesis expression:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有一些原始表达式，语法的起点，它可能产生一个标识符表达式、一个数值表达式或一个括号表达式：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An expression can lead to a binary expression:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个表达式可以导致一个二进制表达式：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A binary operation with RHS can yield combinations of binary operators and
    expressions:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右侧的二进制运算可以产生二进制运算符和表达式的组合：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A function declaration can have grammar as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数声明可以有如下语法：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A function definition is distinguished by a `def` keyword followed by a function
    declaration and an expression that defines its body:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数定义通过一个`def`关键字后跟一个函数声明和一个定义其体的表达式来区分：
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, there will be a top level expression that will yield an expression:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将有一个顶层表达式，它将产生一个表达式：
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An example of the TOY language based on the previously defined grammar can
    be written as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于先前定义的语法的TOY语言的一个示例可以写成如下：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we have defined the grammar, the next step is to write a lexer and parser
    for it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了语法，下一步是为其编写词法分析和解析器。
- en: Implementing a lexer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个词法分析器
- en: Lexer is a part of the first phase in compiling a program. Lexer tokenizes a
    stream of input in a program. Then parser consumes these tokens to construct an
    AST. The language to tokenize is generally a context-free language. A token is
    a string of one or more characters that are significant as a group. The process
    of forming tokens from an input stream of characters is called tokenization. Certain
    delimiters are used to identify groups of words as tokens. There are lexer tools
    to automate lexical analysis, such as **LEX**. In the TOY lexer demonstrated in
    the following procedure is a handwritten lexer using C++.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Lexer 是程序编译的第一个阶段的组成部分。Lexer 将程序中的输入流进行标记化。然后 parser 消费这些标记以构建 AST。标记化的语言通常是上下文无关语言。标记是一组一个或多个字符的字符串，这些字符作为一个整体是有意义的。从字符输入流中形成标记的过程称为标记化。某些分隔符用于识别单词组作为标记。存在一些
    lexer 工具来自动进行词法分析，例如 **LEX**。在以下过程中演示的 TOY lexer 是一个使用 C++ 编写的 hand-written lexer。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'We must have a basic understanding of the TOY language defined in the recipe.
    Create a file named `toy.cpp` as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对配方中定义的 TOY 语言有一个基本理解。创建一个名为 `toy.cpp` 的文件，如下所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the code that follows will contain all the lexer, parser, and code generation
    logic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的所有代码将包含 lexer、parser 和代码生成逻辑。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'While implementing a lexer, types of tokens are defined to categorize streams
    of input strings (similar to states of an automata). This can be done using the
    **enumeration** (**enum**) type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 lexer 时，定义标记类型以对输入字符串流进行分类（类似于自动机的状态）。这可以通过使用 **枚举** （**enum**） 类型来完成：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打开 `toy.cpp` 文件：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Write the `enum` in the `toy.cpp` file as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `toy.cpp` 文件中按如下方式编写 `enum`：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Following is the term list for the preceding example:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是为前一个示例定义的术语列表：
- en: '`EOF_TOKEN`: It states the end of file'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EOF_TOKEN`: 它表示文件结束'
- en: '`NUMERIC_TOKEN:` The current token is of numeric type'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NUMERIC_TOKEN:` 当前标记是数值类型'
- en: '`IDENTIFIER_TOKEN:` The current token is identifier'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDENTIFIER_TOKEN:` 当前标记是标识符'
- en: '`PARAN_TOKEN:` The current token is parenthesis'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PARAN_TOKEN:` 当前标记是括号'
- en: '`DEF_TOKEN`: The current token `def` states that whatever follows is a function
    definition'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEF_TOKEN`: 当前标记 `def` 表示随后的内容是一个函数定义'
- en: 'To hold numeric values, a static variable is defined in the `toy.cpp` file
    as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要存储数值，可以在 `toy.cpp` 文件中定义一个静态变量，如下所示：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To hold the `Identifier` string name, a static variable can be defined in the
    `toy.cpp` file as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要存储 `Identifier` 字符串名称，可以在 `toy.cpp` 文件中定义一个静态变量，如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the lexer function can be defined by using library functions such as `isspace()`,
    `isalpha()`, and `fgetc()` in the `toy.cpp` file, as shown in the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以在 `toy.cpp` 文件中使用库函数如 `isspace()`、`isalpha()` 和 `fgetc()` 定义 lexer 函数，如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The example TOY language defined earlier was as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的示例 TOY 语言如下：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The lexer will get the preceding program as input. It will come across the `def`
    keyword and determine that whatever follows is a definition token, and hence returns
    the enum value `DEF_TOKEN`. After this, it will come across the function definition
    and its arguments. Then, there is an expression that involves two binary operators,
    two variables, and a numeric constant. How these are stored in data structures
    is demonstrated in the following recipes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: lexer 将获取前面的程序作为输入。它将遇到 `def` 关键字并确定随后的内容是一个定义标记，因此返回枚举值 `DEF_TOKEN`。之后，它将遇到函数定义及其参数。然后，有一个涉及两个二元运算符、两个变量和一个数值常数的表达式。以下食谱演示了这些是如何存储在数据结构中的。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See more sophisticated and detailed handwritten lexer for the C++ language is
    written in Clang, at [http://clang.llvm.org/doxygen/Lexer_8cpp_source.html](http://clang.llvm.org/doxygen/Lexer_8cpp_source.html)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [http://clang.llvm.org/doxygen/Lexer_8cpp_source.html](http://clang.llvm.org/doxygen/Lexer_8cpp_source.html)
    查看为 C++ 语言编写的更复杂和详细的 hand-written lexer。
- en: Defining Abstract Syntax Tree
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义抽象语法树
- en: AST is a tree representation of the abstract syntactic structure of the source
    code of a programming language. The ASTs of programming constructs, such as expressions,
    flow control statements, and so on, are grouped into operators and operands. ASTs
    represent relationships between programming constructs, and not the ways they
    are generated by grammar. ASTs ignore unimportant programming elements such as
    punctuations and delimiters. ASTs generally contain additional properties of every
    element in it, which are useful in further compilation phases. Location of source
    code is one such property, which can be used to throw an error line number if
    an error is encountered in determining the correctness of the source code in accordance
    with the grammar (location, line number, column number, and so on, and other related
    properties are stored in an object of the `SourceManager` class in Clang frontend
    for C++).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: AST是编程语言源代码的抽象语法结构的树表示。编程结构（如表达式、流程控制语句等）的AST被分组为操作符和操作数。AST表示编程结构之间的关系，而不是它们由语法生成的途径。AST忽略了诸如标点符号和分隔符等不重要的编程元素。AST通常包含每个元素的附加属性，这些属性在后续编译阶段很有用。源代码的位置是这样一个属性，当根据语法确定源代码的正确性时，如果遇到错误，可以使用它来抛出错误行号（位置、行号、列号等，以及其他相关属性存储在Clang前端C++的`SourceManager`类对象中）。
- en: The AST is used intensively during semantic analysis, where the compiler checks
    for correct usage of the elements of the program and the language. The compiler
    also generates symbol tables based on the AST during semantic analysis. A complete
    traversal of the tree allows verification of the correctness of the program. After
    verifying correctness, the AST serves as the base for code generation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义分析期间，AST被大量使用，编译器检查程序元素和语言的正确使用。编译器在语义分析期间还基于AST生成符号表。对树的完整遍历允许验证程序的正确性。验证正确性后，AST作为代码生成的基。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We must have run the lexer by now to obtain the tokens that will be used in
    generating the AST. The languages we intend to parse consist of expressions, function
    definitions, and function declarations. Again we have various types of expressions—variables,
    binary operators, numeric expressions, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们必须已经运行了词法分析器以获取用于生成AST的标记。我们打算解析的语言包括表达式、函数定义和函数声明。我们再次有各种类型的表达式——变量、二元运算符、数值表达式等。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To define AST structure, proceed with the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义AST结构，请按照以下步骤进行：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打开`toy.cpp`文件：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Below the lexer code, define ASTs.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在词法分析代码下方定义AST。
- en: 'A `base` class is defined for parsing an expression as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析表达式的`base`类可以定义为以下内容：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, several derived classes are defined for every type of expression to be
    parsed.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，为要解析的每种表达式类型定义几个派生类。
- en: 'An AST class for variable expressions is defined as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量表达式的AST类可以定义为以下内容：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The language has some numeric expressions. The `AST` class for such numeric
    expressions can be defined as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语言有一些数值表达式。此类数值表达式的`AST`类可以定义为以下内容：
- en: '[PRE21]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For expressions involving binary operation, the `AST` class can be defined
    as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于涉及二元运算的表达式，`AST`类可以定义为以下内容：
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `AST` class for function declaration can be defined as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数声明的`AST`类可以定义为以下内容：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `AST` class for function definition can be defined as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数定义的`AST`类可以定义为以下内容：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `AST` class for function call can be defined as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数调用的`AST`类可以定义为以下内容：
- en: '[PRE25]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The basic skeleton of the AST is now ready to use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AST的基本骨架现在已准备好使用。
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The AST acts as a data structure for storing various information about the tokens
    given by the lexer. This information is generated in the parser logic and ASTs
    are filled up according to the type of token being parsed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AST充当存储由词法分析器提供的各种信息的数据结构。这些信息在解析器逻辑中生成，并根据正在解析的标记类型填充AST。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Having generated the AST, we will implement the parser, and only after that
    will we see an example where both lexer and parser will be invoked. For a more
    detailed AST structure of C++ in Clang, refer to: [http://clang.llvm.org/docs/IntroductionToTheClangAST.html](http://clang.llvm.org/docs/IntroductionToTheClangAST.html).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 AST 后，我们将实现解析器，然后我们将看到同时调用词法分析和解析器的示例。有关 Clang 中 C++ 的更详细 AST 结构，请参阅：[http://clang.llvm.org/docs/IntroductionToTheClangAST.html](http://clang.llvm.org/docs/IntroductionToTheClangAST.html)。
- en: Implementing a parser
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现解析器
- en: Parser analyzes a code syntactically according to the rules of the language's
    grammar. The parsing phase determines if the input code can be used to form a
    string of tokens according to the defined grammar. A parse tree is constructed
    in this phase. Parser defines functions to organize language into a data structure
    called AST. The parser defined in this recipe uses a recursive decent parser technique
    which is a top-down parser, and uses mutually recursive functions to build the
    AST.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器根据语言的语法规则对代码进行语法分析。解析阶段确定输入代码是否可以根据定义的语法形成标记串。在此阶段构建一个解析树。解析器定义函数将语言组织成称为
    AST 的数据结构。本食谱中定义的解析器使用递归下降解析技术，这是一种自顶向下的解析器，并使用相互递归的函数来构建 AST。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We must have the custom-defined language, that is the TOY language in this case,
    and also a stream of tokens generated by the lexer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须拥有自定义的语言，即在本例中的 TOY 语言，以及由词法分析器生成的标记流。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Define some basic value holders in our TOY parser as shown in the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 TOY 解析器中定义一些基本值持有者，如下所示：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤打开 `toy.cpp` 文件：
- en: '[PRE26]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define a global static variable to hold the current token from the lexer as
    follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个全局静态变量以保存来自词法分析器的当前标记，如下所示：
- en: '[PRE27]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define a function to get the next token from the input stream from the lexer
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义一个从输入流中获取下一个标记的函数：
- en: '[PRE28]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next step is to define functions for expression parsing by using the AST
    data structure defined in the previous section.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义使用上一节中定义的 AST 数据结构进行表达式解析的函数。
- en: 'Define a generic function to call specific parsing functions according to the
    types of tokens determined by the lexer, as shown in the following:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个通用函数，根据词法分析器确定的标记类型调用特定的解析函数，如下所示：
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The stream of input is tokenized and fed to the parser. `Current_token` holds
    the token to be processed. The type of token is known at this stage and the corresponding
    parser functions are called to initialize ASTs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输入流被标记化并传递给解析器。`Current_token` 保存要处理的标记。在此阶段已知标记的类型，并调用相应的解析函数以初始化 AST。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In next few recipes, you will learn how to parse different expressions. For
    more detailed parsing of the C++ language implemented in Clang, refer to it works:
    [http://clang.llvm.org/doxygen/classclang_1_1Parser.html](http://clang.llvm.org/doxygen/classclang_1_1Parser.html).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的几个食谱中，你将学习如何解析不同的表达式。有关 Clang 中实现的 C++ 语言的更详细解析，请参阅：[http://clang.llvm.org/doxygen/classclang_1_1Parser.html](http://clang.llvm.org/doxygen/classclang_1_1Parser.html)。
- en: Parsing simple expressions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析简单表达式
- en: In this recipe, you will learn how to parse a simple expression. A simple expression
    may consist of numeric values, identifiers, function calls, a function declaration,
    and function definitions. For each type of expression, individual parser logic
    needs to be defined.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何解析一个简单的表达式。一个简单的表达式可能包括数值、标识符、函数调用、函数声明和函数定义。对于每种类型的表达式，都需要定义单独的解析逻辑。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We must have the custom-defined language—that is, the TOY language in this case—and
    also stream of tokens generated by lexer. We already defined ASTs above. Further,
    we are going to parse the expression and invoke AST constructors for every type
    of expression.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须拥有自定义的语言——在本例中即为 TOY 语言，以及由词法分析器生成的标记流。我们已经在上面定义了抽象语法树（AST）。进一步地，我们将解析表达式并调用每种类型表达式的
    AST 构造函数。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To parse simple expressions, proceed with the following code flow:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析简单表达式，按照以下代码流程进行：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤打开 `toy.cpp` 文件：
- en: '[PRE30]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We already have lexer logic present in the `toy.cpp` file. Whatever code follows
    needs to be appended after the lexer code in the `toy.cpp` file.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经在 `toy.cpp` 文件中实现了词法分析器逻辑。接下来的代码需要附加在 `toy.cpp` 文件中的词法分析器代码之后。
- en: 'Define the `parser` function for numeric expression as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义用于数值表达式的 `parser` 函数：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the `parser` function for an identifier expression. Note that identifier
    can be a variable reference or a function call. They are distinguished by checking
    if the next token is `(`. This is implemented as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义标识符表达式的`parser`函数。请注意，标识符可以是变量引用或函数调用。它们通过检查下一个标记是否为`(`来区分。这如下实现：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the `parser` function for the function declaration as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数声明`parser`函数如下：
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `parser` function for the function definition as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数定义的`parser`函数如下：
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that the function called `expression_parser` used in the preceding code,
    parses the expression. The function can be defined as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在前面代码中使用的名为`expression_parser`的函数用于解析表达式。该函数可以定义为以下内容：
- en: '[PRE35]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: If a numeric token is encountered, the constructor for the numeric expression
    is invoked and the AST object for the numeric value is returned by the parser,
    filling up the AST for numeric values with the numeric data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到数字标记，将调用数字表达式的构造函数，并返回由解析器返回的AST对象，用数字数据填充AST的数值部分。
- en: Similarly, for identifier expressions, the parsed data will either be a variable
    or a function call. For function declaration and definitions, the name of the
    function and function arguments is parsed and the corresponding AST class constructors
    are invoked.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于标识符表达式，解析的数据将是变量或函数调用。对于函数声明和定义，将解析函数名和函数参数，并调用相应的AST类构造函数。
- en: Parsing binary expressions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析二进制表达式
- en: In this recipe, you will learn how to parse a binary expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何解析二进制表达式。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We must have the custom-defined language—that is, the toy language in this case—and
    also stream of tokens generated by lexer. The binary expression parser requires
    precedence of binary operators for determining LHS and RHS in order. An STL map
    can be used to define precedence of binary operators.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须有一个自定义定义的语言，即在本例中的玩具语言，以及由词法分析器生成的标记流。二进制表达式解析器需要二进制运算符的优先级来确定左右顺序。可以使用STL
    map来定义二进制运算符的优先级。
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To parse a binary expression, proceed with the following code flow:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析二进制表达式，请按照以下代码流程进行：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打开`toy.cpp`文件：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Declare a `map` for operator precedence to store the precedence at global scope
    in the `toy.cpp` file as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toy.cpp`文件中声明一个用于运算符优先级的`map`，以在全局范围内存储优先级，如下所示：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The TOY language for demonstration has 4 operators where precedence of operators
    is defined as `-`< `+` < `/` < `*`.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于演示的TOY语言有4个运算符，运算符的优先级定义为`-` < `+` < `/` < `*`。
- en: 'A function to initialize precedence—that is, to store precedence value in `map`—can
    be defined in global scope in the `toy.cpp` file as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在全局范围内定义一个初始化优先级的函数，即存储`map`中的优先级值，如下所示：
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A helper function to return precedence of binary operator can be defined as
    follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以定义一个辅助函数来返回二进制运算符的优先级，如下所示：
- en: '[PRE39]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the `binary` operator parser can be defined as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，可以定义如下所示的`binary`运算符解析器：
- en: '[PRE40]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, precedence of current operator is checked with the precedence of old operator,
    and the outcome is decided according to LHS and RHS of binary operators. Note
    that the binary operator parser is recursively called since the RHS can be an
    expression and not just a single identifier.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，通过检查当前运算符的优先级与旧运算符的优先级，并根据二进制运算符的左右两边（LHS和RHS）来决定结果。请注意，由于右边的表达式可以是一个表达式而不是单个标识符，因此二进制运算符解析器是递归调用的。
- en: 'A `parser` function for parenthesis can be defined as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以定义一个用于括号的`parser`函数，如下所示：
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Some top-level functions acting as wrappers around these `parser` functions
    can be defined as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些作为这些`parser`函数包装器的顶级函数可以定义为以下内容：
- en: '[PRE42]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'All of the remaining recipes in this chapter pertain to user objects. For detailed
    parsing of expressions, and for C++ parsing, please refer to: [http://clang.llvm.org/doxygen/classclang_1_1Parser.html](http://clang.llvm.org/doxygen/classclang_1_1Parser.html).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中所有剩余的菜谱都与用户对象相关。有关表达式的详细解析和C++解析，请参阅：[http://clang.llvm.org/doxygen/classclang_1_1Parser.html](http://clang.llvm.org/doxygen/classclang_1_1Parser.html)。
- en: Invoking a driver for parsing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用解析驱动程序
- en: In this recipe, you will learn how to call the parser function from the main
    function of our TOY parser.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在我们的TOY解析器的`main`函数中调用解析函数。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To invoke a driver program to start parsing, define the driver function as
    shown in the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用驱动程序以开始解析，请定义如以下所示的驱动函数：
- en: 'Open the `toy.cpp` file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`toy.cpp`文件：
- en: '[PRE43]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A `Driver` function called from the main function, and a parser can now be
    defined as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主函数中调用的`Driver`函数，现在可以定义解析器如下：
- en: '[PRE44]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `main()` function to run the whole program can be defined as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以定义如下`main()`函数来运行整个程序：
- en: '[PRE45]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The main function is responsible for calling the lexer and parser so that both
    can act over a piece of code that is being input to the compiler frontend. From
    the main function, driver function is invoked to start the process of parsing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数负责调用词法分析和解析器，以便它们可以作用于输入到编译器前端的代码片段。从主函数中，调用驱动函数以启动解析过程。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For details on how the main function and driver function work for c++ parsing
    in Clang, refer to [http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Clang中c++解析的主函数和驱动函数的工作原理的详细信息，请参阅[http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp)
- en: Running lexer and parser on our TOY language
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的玩具语言上运行词法分析和解析器
- en: Now that a full-fledged lexer and parser for our TOY language grammar are defined,
    it's time to run it on example TOY language.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的TOY语言语法定义了完整的词法分析和解析器，是时候在示例TOY语言上运行它了。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To do this, you should have understanding of TOY language grammar and all the
    previous recipes of this chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您应该了解TOY语言语法和本章的所有先前的配方。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Run and test the Lexer and Parser on TOY Language, as shown in the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下所示，在TOY语言上运行并测试词法分析和解析器：
- en: 'First step is to compile the `toy.cpp` program into an executable:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将`toy.cpp`程序编译成可执行文件：
- en: '[PRE46]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `toy` executable is our TOY compiler frontend. The `toy` language to be
    parsed is in a file called `example`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toy`可执行文件是我们的TOY编译器前端。要解析的`toy`语言在名为`example`的文件中：'
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This file is passed as argument to be processed by the `toy` compiler:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件作为参数传递给`toy`编译器进行处理：
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The TOY compiler will open the `example` file in read mode. Then, it will tokenize
    the stream of words. It will come across the def keyword and return `DEF_TOKEN`.
    Then, the `HandleDefn()` function will be called, which will store the function
    name and the argument. It will recursively check for the type of token and then
    call the specific token handler functions to store them into respective ASTs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: TOY编译器将以读取模式打开`example`文件。然后，它将对单词流进行标记化。它将遇到`def`关键字并返回`DEF_TOKEN`。然后，将调用`HandleDefn()`函数，该函数将存储函数名和参数。然后，它将递归检查令牌类型，然后调用特定的令牌处理函数将它们存储到相应的AST中。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The aforementioned lexer and parser do not handle errors in syntax except a
    few trivial ones. To implement Error handling, refer to [http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics](http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述词法分析和解析器除了处理一些简单的语法错误外，不处理语法错误。要实现错误处理，请参阅[http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics](http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics)。
- en: Defining IR code generation methods for each AST class
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为每个AST类定义IR代码生成方法
- en: Now, since the AST is ready with all the necessary information in its data structure,
    the next phase is to generate LLVM IR. LLVM APIs are used in this code generation.
    LLVM IR has a predefined format that is generated by the inbuilt APIs of LLVM.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于AST已经准备好，其数据结构中包含所有必要的信息，下一个阶段是生成LLVM IR。在此代码生成中使用了LLVM API。LLVM IR有一个预定义的格式，该格式由LLVM内置API生成。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have created the AST from any input code of the TOY language.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须已从TOY语言的任何输入代码中创建AST。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to generate LLVM IR, a virtual `CodeGen` function is defined in each
    AST class (the AST classes were defined earlier in the AST section; these functions
    are additional to those classes) as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成LLVM IR，在AST类中定义了一个虚拟的`CodeGen`函数（这些AST类在AST部分中定义较早；这些函数是这些类的附加功能）如下：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打开`toy.cpp`文件：
- en: '[PRE49]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `BaseAST` class defined earlier, append the `Codegen()` functions as
    follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前定义的`BaseAST`类中，按如下方式添加`Codegen()`函数：
- en: '[PRE50]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This virtual `Codegen()` function is included in every AST class we defined.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个虚拟的`Codegen()`函数包含在我们定义的每个AST类中。
- en: This function returns an LLVM Value object, which represents **Static Single
    Assignment** (**SSA**) value in LLVM. A few more static variables are defined
    that will be used during Codegen.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数返回一个LLVM Value对象，它代表LLVM中的**静态单赋值**（**SSA**）值。定义了一些额外的静态变量，这些变量将在Codegen过程中使用。
- en: 'Declare the following static variables in global scope as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式在全局作用域中声明以下静态变量：
- en: '[PRE51]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Module_Ob` module contains all the functions and variables in the code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module_Ob`模块包含代码中的所有函数和变量。'
- en: The `Builder` object helps to generate LLVM IR and keeps track of the current
    point in the program to insert LLVM instructions. The `Builder` object has functions
    to create new instructions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Builder`对象帮助生成LLVM IR，并跟踪程序中的当前位置以插入LLVM指令。`Builder`对象有创建新指令的函数。'
- en: The `Named_Values` map keeps track of all the values defined in the current
    scope like a symbol table. For our language, this map will contain function parameters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Named_Values`映射表跟踪当前作用域中定义的所有值，就像符号表一样。对于我们的语言，这个映射表将包含函数参数。'
- en: Generating IR code for expressions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为表达式生成IR代码
- en: In this recipe, you will see how IR code gets generated for an expression using
    the compiler frontend.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将看到如何使用编译器前端生成表达式的IR代码。
- en: How to do it…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To implement LLVM IR code generation for our TOY language, proceed with the
    following code flow:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的TOY语言实现LLVM IR代码生成，请按照以下代码流程进行：
- en: 'Open the `toy.cpp` file as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打开`toy.cpp`文件：
- en: '[PRE52]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The function to generate code for numeric values can be defined as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成数值代码的功能可以定义为如下：
- en: '[PRE53]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In LLVM IR, integer constants are represented by the `ConstantInt` class whose
    numeric value is held by the `APInt` class.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在LLVM IR中，整数常量由`ConstantInt`类表示，其数值由`APInt`类持有。
- en: 'The function for generating code for variable expressions can be defined as
    follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成变量表达式代码的函数可以定义为如下：
- en: '[PRE54]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `Codegen()` function for binary expression can be defined as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二元表达式的`Codegen()`函数可以定义为如下：
- en: '[PRE55]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the code above emits multiple `addtmp` variables, LLVM will automatically
    provide each one with an increasing, unique numeric suffix.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果上面的代码生成了多个`addtmp`变量，LLVM将自动为每个变量提供一个递增的唯一数字后缀。
- en: See also
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe shows how to generate IR code for function; we will learn how
    the code generation actually works.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例将展示如何为函数生成IR代码；我们将学习代码生成是如何实际工作的。
- en: Generating IR code for functions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为函数生成IR代码
- en: In this recipe you, will learn how to generate IR code for a function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何为函数生成IR代码。
- en: How to do it…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Do the following steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The `Codegen()` function for the function call can be defined as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数调用的`Codegen()`函数可以定义为如下：
- en: '[PRE56]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Once we have the function to call, we recursively call the `Codegen()` function
    for each argument that is to be passed in and create an LLVM call instruction.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们有了要调用的函数，我们将递归地调用`Codegen()`函数，为每个要传入的参数调用，并创建一个LLVM调用指令。
- en: Now that the `Codegen()` function for a function call has been defined, it's
    time to define the `Codegen()` functions for declarations and function definitions.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，函数调用的`Codegen()`函数已经定义，是时候定义声明和函数定义的`Codegen()`函数了。
- en: 'The `Codegen()` function for function declarations can be defined as follows:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数声明的`Codegen()`函数可以定义为如下：
- en: '[PRE57]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Codegen()` function for function definition can be defined as follows:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数定义的`Codegen()`函数可以定义为如下：
- en: '[PRE58]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That''s it! LLVMIR is now ready. These `Codegen()` functions can be called
    in the wrappers written to parse top-level expressions as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！LLVM IR现在准备好了。这些`Codegen()`函数可以在解析顶层表达式的包装器中调用，如下所示：
- en: '[PRE59]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, after parsing successfully, the respective `Codegen()` functions are called
    to generate the LLVM IR. The `dump()` function is called to print the generated
    IR.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在解析成功后，将调用相应的`Codegen()`函数来生成LLVM IR。调用`dump()`函数以打印生成的IR。
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Codegen()` functions use LLVM inbuilt function calls to generate IR. The
    header files to include for this purpose are `llvm/IR/Verifier.h`, `llvm/IR/DerivedTypes.h`,
    `llvm/IR/IRBuilder.h`, and `llvm/IR/LLVMContext.h`, `llvm/IR/Module.h`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codegen()`函数使用LLVM内置函数调用来生成IR。为此需要包含的头文件有`llvm/IR/Verifier.h`、`llvm/IR/DerivedTypes.h`、`llvm/IR/IRBuilder.h`和`llvm/IR/LLVMContext.h`、`llvm/IR/Module.h`。'
- en: 'While compiling, this code needs to be linked with LLVM libraries. For this
    purpose, the `llvm-config` tool can be used as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译时，此代码需要与LLVM库链接。为此，可以使用`llvm-config`工具，如下所示：
- en: '[PRE60]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For this purpose, the `toy` program is recompiled with additional flags as
    follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这个目的，使用以下附加标志重新编译 `toy` 程序：
- en: '[PRE61]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When the `toy` compiler is now run on `example` code, it will generate LLVM
    IR as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `toy` 编译器现在运行 `example` 代码时，它将生成如下所示的 LLVM IR：
- en: '[PRE62]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another `example2` file has a function `call.$ cat example2`:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个 `example2` 文件有一个函数 `call.$ cat example2`：
- en: '[PRE63]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Its LLVM IR will be dumped as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的 LLVM IR 将如下所示：
- en: '[PRE64]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For details on how `Codegen()` functions for C++ in Clang, refer to [http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Clang 中 C++ 的 `Codegen()` 函数的详细信息，请参阅 [http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/)
- en: Adding IR optimization support
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 IR 优化支持
- en: LLVM provides a wide variety of optimization passes. LLVM allows a compiler
    implementation to decide which optimizations to use, their order, and so on. In
    this recipe, you will learn how to add IR optimization support.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 提供了各种优化过程。LLVM 允许编译器实现决定使用哪些优化、它们的顺序等等。在本教程中，你将学习如何添加 IR 优化支持。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Do the following steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'To start with the addition of IR optimization support, first of all a static
    variable for function manager has to be defined as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始添加 IR 优化支持，首先需要定义一个用于函数管理器的静态变量，如下所示：
- en: '[PRE65]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, a function pass manager needs to be defined for the `Module` object used
    previously. This can be done in the `main()` function as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，需要为之前使用的 `Module` 对象定义一个函数过程管理器。这可以在 `main()` 函数中如下完成：
- en: '[PRE66]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now a pipeline of various optimizer passes can be added in the `main()` function
    as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以在 `main()` 函数中添加各种优化过程的管道，如下所示：
- en: '[PRE67]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now the static global function Pass Manager is assigned to this pipeline as
    follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将静态全局函数 Pass Manager 分配给此管道，如下所示：
- en: '[PRE68]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This PassManager has a run method, which we can run on the function IR generated
    before returning from `Codegen()` of the function definition. This is demonstrated
    as follows:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 PassManager 有一个运行方法，我们可以在函数定义的 `Codegen()` 返回之前对生成的函数 IR 运行它。如下所示进行演示：
- en: '[PRE69]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is a lot more beneficial as it optimizes the function in place, improving
    the code generated for the function body.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这更有益，因为它在原地优化函数，提高了为函数体生成的代码。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: How to add our own optimization pass and its run method will be demonstrated
    in the later chapters
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何添加我们自己的优化过程及其运行方法将在后续章节中演示
