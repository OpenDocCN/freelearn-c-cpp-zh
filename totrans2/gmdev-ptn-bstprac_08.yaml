- en: Controlling the UI via the Command Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过命令模式控制UI
- en: In the last chapter, we dived deeply into the bits and bytes of computer memory
    so we could make our components more efficient and easier to debug. Understanding
    these details can be the difference between a game running at 60 frames per second
    or 30 frames per second. Knowing how to control memory usage is an important aspect
    of becoming a great programmer. It is also one of the hardest things about programming.
    In this chapter, we will take a break from low-level programming and look at something
    high level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入探讨了计算机内存的位和字节，以便使我们的组件更加高效且易于调试。了解这些细节可能是游戏以每秒60帧或30帧运行的区别。了解如何控制内存使用是成为一名优秀程序员的重要方面。这也是编程中最困难的事情之一。在本章中，我们将从底层编程中暂时休息一下，看看一些高级内容。
- en: The user interface, or UI, is just as important as memory management or stage
    switching. You could even argue that it is more important because the player doesn't
    care about the low-level details. They just want a game that is fun. However,
    it doesn't matter how fun the gameplay is; if the UI is difficult to navigate
    or control, the fun level drops fast.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面，或UI，与内存管理或场景切换一样重要。你甚至可以争论它更重要，因为玩家不关心底层细节。他们只想玩一个有趣的游戏。然而，不管游戏玩法有多有趣，如果UI难以导航或控制，乐趣水平会迅速下降。
- en: Can you remember a time when you played a game with terrible controls? Did you
    keep playing the game? It is interesting because, for something so important,
    it often has the chance of being left until the end of a project. Even in this
    book, we had to wait until the eighth chapter to cover it. However, great games
    make the design of the UI and the user experience a top priority.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你能记得你玩过一个控制极差的游戏的时刻吗？你继续玩游戏了吗？这很有趣，因为对于如此重要的事情，它经常有机会被推迟到项目结束时。即使在本书中，我们也必须等到第八章才能涵盖它。然而，优秀的游戏将UI设计和用户体验设计为首要任务。
- en: There are a lot of great books on how to design user interfaces and craft the
    user experience. This isn't one of those books. Instead, we will look at how the
    code behind the UI can be implemented in a flexible way that works with the rest
    of our engine. The first step to making a great UI is designing the code that
    will make buttons and other input easy to create and change.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多关于如何设计用户界面和制作用户体验的优秀书籍。这不是其中之一。相反，我们将查看UI背后的代码如何以灵活的方式实现，以便与我们的引擎的其他部分一起工作。制作一个优秀的UI的第一步是设计代码，使按钮和其他输入易于创建和更改。
- en: We will start by looking at a very simple but powerful pattern that allows us
    to decouple our function calls from the objects that want to call them. While
    we are discussing the pattern, we will look at some of the syntactically ugly
    and confusing ways C++ allows us to treat functions as if they were objects. We
    will also see how the Mach5 Engine uses this pattern to create clickable UI buttons.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看一个非常简单但强大的模式开始，这个模式允许我们将函数调用与想要调用它们的对象解耦。当我们讨论这个模式时，我们将查看C++允许我们将函数视为对象的一些语法上丑陋且令人困惑的方式。我们还将看到Mach5引擎如何使用这个模式来创建可点击的UI按钮。
- en: Chapter overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: This chapter is all about separating the user interface and input from the actions
    they perform. We will learn about the Command pattern and how it can help us decouple
    our code. We will do this by first understanding the problem then looking at how
    this could be solved in a C style fashion. Then after looking at the Command pattern
    in depth, we will see how it is implemented in the Mach5 Engine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于将用户界面和输入与其执行的动作分离。我们将学习命令模式以及它如何帮助我们解耦代码。我们将通过首先理解问题，然后查看如何以C风格的方式解决这个问题来做到这一点。然后，在深入研究了命令模式之后，我们将看到它在Mach5引擎中的实现。
- en: Your objectives
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'The following lists the things to be accomplished in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了本章要完成的事情：
- en: Learn the naive approach to handling input and why it should be avoided
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习处理输入的简单方法以及为什么应该避免它
- en: Implement the Command pattern using function pointers and the class method pointer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数指针和类方法指针实现命令模式
- en: Learn how the Mach5 Engine uses the Command pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Mach5引擎如何使用命令模式
- en: Implement UI buttons within the Mach5 Engine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mach5引擎中实现UI按钮
- en: How can we control actions through buttons?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何通过按钮控制动作？
- en: In [Chapter 3](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7), *Improving
    on the Decorator Pattern with the Component Object Model*, we implemented game
    objects. Now that we have them, it seems trivial to create buttons on the screen.
    In fact, in genres such as real-time strategy, there is no difference between
    clickable buttons and game objects. The player can click on any unit or building
    and give them orders.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第三章](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7)，“使用组件对象模型改进装饰器模式”，我们实现了游戏对象。现在我们有了它们，创建屏幕上的按钮似乎很简单。事实上，在实时策略等类型中，可点击按钮和游戏对象之间没有区别。玩家可以点击任何单位或建筑并给予指令。
- en: At first thought, our buttons could just be game objects. They both have a position,
    scale, and texture, and that texture will be drawn to the screen. Depending on
    the game, you might draw your buttons using orthographic projection while the
    objects will be drawn using perspective projection. However, the differences go
    deeper than that.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，我们的按钮可以是游戏对象。它们都有位置、缩放和纹理，这个纹理将被绘制到屏幕上。根据游戏的不同，你可能使用正交投影来绘制按钮，而对象则使用透视投影来绘制。然而，差异远不止于此。
- en: At its core, a button has an action that needs to be performed when it is clicked
    or selected. This behavior is usually simple; it doesn't require creating an entire
    state machine class. It does however, require a little thought so we don't end
    up hardcoding button functionality all over our high-level modules or repeating
    similar code in many different places.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，按钮有一个在点击或选择时需要执行的操作。这种行为通常是简单的；它不需要创建一个完整的状态机类。然而，它确实需要一点思考，这样我们才不会在高级模块中到处硬编码按钮功能，或者在不同地方重复类似的代码。
- en: 'In [Chapter 5](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7), *Decoupling
    Code via the Factory Method Pattern*, we saw an extremely naive way to handle
    a button click on a menu screen. Recall that this code was written by one of the
    authors early in their programming career:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第五章](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7)，“通过工厂方法模式解耦代码”，我们看到了处理菜单屏幕上按钮点击的一个极其简单的方法。回想一下，这段代码是由作者在他们编程生涯早期编写的：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a lot of problems with this code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在很多问题：
- en: First, the rectangular click region is hardcoded to the aspect ratio in full
    screen mode. If we were to switch from widescreen 16:9 aspect ratio to standard
    4:3 aspect ratio or even if we changed from full screen to windowed mode, this
    code wouldn't work correctly.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，矩形点击区域被硬编码到全屏模式的比例中。如果我们从宽屏16:9比例切换到标准4:3比例，或者如果我们从全屏模式切换到窗口模式，这段代码将无法正确工作。
- en: Second, the click region is based on the screen and not the button itself. If
    the button position or size were to change, this code wouldn't work correctly.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，点击区域基于屏幕而不是按钮本身。如果按钮位置或大小发生变化，这段代码将无法正确工作。
- en: Third, this menu screen is coupled to the Windows `GetSystemMetrics` function
    instead of an encapsulated platform code class like the `M5App` class. This means
    if we want to run on a different operating system or platform, this menu and possibly
    all menus need to be modified.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，这个菜单屏幕是与 Windows 的 `GetSystemMetrics` 函数耦合的，而不是像 `M5App` 类这样的封装平台代码类。这意味着如果我们想在不同的操作系统或平台上运行，这个菜单以及可能的所有菜单都需要进行修改。
- en: Finally, the state (stage in Mach5) switching action is hardcoded to the menu.
    If we decide to perform a different action, we need to modify the menu. If this
    action can be performed by both a button click and keyboard input, we need to
    update and maintain both sections of code.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，状态（Mach5中的阶段）切换动作被硬编码到菜单中。如果我们决定执行不同的动作，我们需要修改菜单。如果这个动作可以通过按钮点击和键盘输入来执行，我们需要更新和维护这两部分代码。
- en: As you can see, this isn't an ideal way to handle buttons in a game. This is
    basically the worst way you can implement buttons. This code is very likely to
    break if anything changes. It would be nice if the author could say this code
    was only written as a demonstration of what not to do. Unfortunately, a book like
    the one you are reading didn't exist at the time, so he had to learn the hard
    way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这不是处理游戏中按钮的理想方式。这基本上是你可以实现按钮的最糟糕的方式。如果任何东西发生变化，这段代码很可能就会出错。如果作者能说这段代码只是为了演示不应该做什么，那会很好。不幸的是，在你阅读这本书的时候，这样的书并不存在，所以他不得不通过艰难的方式学习。
- en: Callback functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: A better way to deal with these button actions is with callback functions. Callback
    functions in C/C++ are implemented using pointers to functions. They allow you
    to pass functions around as if they were variables. This means functions can be
    passed to other functions, returned from functions, or even stored in a variable
    and called later. This allows us to decouple a specific function from the module
    that will call it. It is a C style way to change which function will be called
    at runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些按钮动作的更好方法是使用回调函数。在C/C++中，回调函数是通过函数指针实现的。它们允许你像传递变量一样传递函数。这意味着函数可以被传递到其他函数，从函数返回，甚至存储在变量中并在以后调用。这允许我们将特定函数与调用它的模块解耦。这是在运行时更改要调用哪个函数的C风格方法。
- en: 'Just as pointers to `int` can only point at `int`, and pointers to `float`
    can only point at `float`, a pointer to a function can only point at a function
    with the same signature. An example would be the function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如指向`int`的指针只能指向`int`，指向`float`的指针只能指向`float`一样，指向函数的指针只能指向具有相同签名的函数。一个例子是以下函数：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function takes a single `int` as a parameter and returns an `int`. This
    return value and parameter list are the function''s signature. So, a pointer to
    this function would be:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个单个`int`作为参数并返回一个`int`。此返回值和参数列表是函数的签名。因此，此函数的指针将是：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We haven''t given the function pointer a name, so it should look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有给函数指针命名，所以它应该看起来像这样：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the parentheses around the variable name `pFunc` are required, otherwise
    the compiler will think this is a prototype of a function that returns a pointer
    to an `int`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变量名`pFunc`周围的括号是必需的，否则编译器会认为这是一个返回指针到`int`的函数的原型。
- en: 'We can now create a pointer to a specific function and call that function through
    the variable:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个指向特定函数的指针并通过该变量调用该函数：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/00052.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: Figure 8 1 - Function pointer output
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 1 - 函数指针输出
- en: Notice that we didn't need to take the address of the `Square` function (although
    that syntax is allowed); this is because in C and C++ the name of the function
    is already a pointer to that function. That is why we can call `pFunc` without
    needing to dereference it. Unfortunately, everything about function pointers is
    weird until you get used to them. You must work at remembering the syntax since
    it doesn't work the same as pointers to variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要取`Square`函数的地址（尽管这种语法是允许的）；这是因为C和C++中函数的名称已经是该函数的指针。这就是为什么我们可以调用`pFunc`而无需解引用它。不幸的是，关于函数指针的一切在你习惯之前都很奇怪。你必须努力记住语法，因为它与变量指针的工作方式不同。
- en: 'By looking at a larger example, we can get familiar with this syntax. Let''s
    write a program with three different ways to fill an array with values and a way
    to print the array:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看更大的示例，我们可以熟悉这种语法。让我们编写一个程序，用三种不同的方式填充数组并打印数组：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our goal with this program is to write a function that can fill an array with
    any fill function, including one that hasn''t been written yet. Since we have
    a common function signature, we can create a function called `FillAndPrint` that
    will take a pointer to any function with a matching signature as a parameter.
    This will allow `FillAndPrint` to be decoupled from a specific fill function and
    allow it to be used with functions that do not exist yet. The prototype for `FillAndPrint`
    will look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写此程序的目标是编写一个函数，该函数可以用任何填充函数填充数组，包括尚未编写的函数。由于我们有一个通用的函数签名，我们可以创建一个名为`FillAndPrint`的函数，它将接受任何具有匹配签名的函数的指针作为参数。这将允许`FillAndPrint`与特定的填充函数解耦，并允许它用于尚未存在的函数。`FillAndPrint`的原型将如下所示：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is incredibly ugly and difficult to read. So, let''s use a `typedef` to
    clean up the code a little. Remember that a `typedef` allows us to give a different,
    hopefully more readable, name to our type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常丑陋且难以阅读。所以，让我们使用`typedef`来稍微清理一下代码。记住，`typedef`允许我们给我们的类型起一个不同的、更易读的名字：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In main, the user of this code can pick which fill function they want to use
    or even write a completely new one (if the signature is the same), without changing
    `FillAndPrint`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，此代码的用户可以选择他们想要使用的填充函数，甚至可以编写一个完全新的函数（如果签名相同），而无需更改`FillAndPrint`：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is what this code would output to the command line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是此代码将输出到命令行的内容：
- en: '![](img/00053.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: Figure 8 2 - Using FillAndPrint in different ways
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 2 - 以不同方式使用FillAndPrint
- en: 'We could even allow the user to pick the fill at runtime if we included a `helper`
    function to select and return the correct fill function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包含一个 `helper` 函数来选择并返回正确的填充函数，我们甚至可以在运行时允许用户选择填充：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a very simple example, but you can already see how using function pointers
    allows us to write flexible code. `FillAndPrint` is completely decoupled from
    any specific function call. Unfortunately, you can also see two flaws with this
    system. The functions must have the exact same signature, and the parameters of
    the function must be passed to the user of the function pointer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但你已经可以看到使用函数指针如何使我们能够编写灵活的代码。`FillAndPrint` 完全与任何特定的函数调用解耦。不幸的是，你也能看到这个系统的两个缺陷。函数必须具有完全相同的签名，并且函数的参数必须传递给函数指针的使用者。
- en: These two problems make function pointers interesting and powerful, but not
    the best solution for in-game buttons that need to support a wide variety of actions
    with varying parameter lists. Additionally, we might want to support actions that
    use C++ member functions. So far, all the examples that we have seen were C style
    global functions. We will solve these problems in a moment, but first we should
    look at how we will trigger our button click.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题使得函数指针既有趣又强大，但并不是支持具有各种参数列表的多种动作的游戏按钮的最佳解决方案。此外，我们可能还想支持使用 C++ 成员函数的动作。到目前为止，我们所看到的所有示例都是
    C 风格的全局函数。我们将在稍后解决这些问题，但首先我们应该看看我们将如何触发我们的按钮点击。
- en: Repeated code in the component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件中的重复代码
- en: We have the problem of wanting to decouple a specific function call from the
    place that calls it. It would be nice to be able to create a button component
    that could save a function pointer or something like it, and call it when the
    component is clicked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个想要将特定的函数调用与其调用位置解耦的问题。如果能创建一个按钮组件来保存函数指针或类似的东西，并在组件被点击时调用它，那就太好了。
- en: 'One solution could be to create a new component for every action we want to
    execute. For example, we might want to create a component that will change the
    stage to the main menu. We could create a component class that knows how to perform
    that exact action:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是为我们想要执行的所有动作创建一个新的组件。例如，我们可能想要创建一个将舞台更改为主菜单的组件。我们可以创建一个知道如何执行该特定动作的组件类：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding case is a very simple example because it is only calling a static
    function with the parameter hardcoded, but the function pointer as well as the
    function parameters could easily be passed in to the constructor of this component.
    In fact, we could pass any object to the constructor and hardcode a specific method
    call in the update function. For example, we could pass an `M5Object` to a component
    such as the one above. The button click might change the texture of the object.
    For example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是一个非常简单的例子，因为它只是调用了一个带有硬编码参数的静态函数，但函数指针以及函数参数可以很容易地传递给这个组件的构造函数。实际上，我们可以将任何对象传递给构造函数，并在更新函数中硬编码一个特定的方法调用。例如，我们可以将一个
    `M5Object` 传递给上面的组件。按钮点击可能会改变对象的纹理。例如：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Unfortunately, there is a big problem with code like this; the action is completely
    coupled to the button click. This is bad for two reasons. First, we can't use
    this action for a keyboard or controller press unless we add additional keys to
    our UI button click component. Second, what happens when we have a list of actions
    that we want to perform? For example, synchronizing the movement of multiple UI
    objects, or scripting an in-game cut scene. Since the actions require the mouse
    to be pressed on the object, our action is very limited.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种代码有一个大问题；动作完全耦合到按钮点击。这有两个原因不好。首先，除非我们向我们的 UI 按钮点击组件添加额外的键，否则我们无法使用这个动作来响应键盘或控制器的按下。其次，当我们有一系列想要执行的动作时会发生什么？例如，同步多个
    UI 对象的移动，或者编写游戏中的场景脚本。由于动作需要鼠标在对象上按下，我们的动作非常有限。
- en: The other reason this approach is bad is because we must repeat the exact same
    mouse click test code in every button component that we create. What we would
    like to do is decouple the action from the button click component. We would need
    to create a separate UI button component and an action class. By doing that, we
    would factor out the part of the code that repeats, and we would gain the ability
    to use the actions on their own.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不好的另一个原因是我们必须在创建的每个按钮组件中重复相同的鼠标点击测试代码。我们希望做的是将动作与按钮点击组件解耦。我们需要创建一个单独的 UI
    按钮组件和一个动作类。通过这样做，我们可以提取重复的代码部分，并且能够独立使用这些动作。
- en: The Command pattern explained
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式的解释
- en: 'The Command pattern is exactly the pattern that solves our problem. The purpose
    of the Command pattern is to decouple the requester of an action from the object
    that performs the action. That is exactly the problem we have. Our requester is
    the button, and it needs to be decoupled from whatever specific function call
    will be made. The Command pattern takes our concept of a function pointer and
    wraps it into a class with a simple interface for performing the function call.
    However, this pattern allows us more flexibility. We will easily be able to encapsulate
    function pointers with multiple parameters, as well as with C++ object and member
    functions. Let''s start off easy with just two simple functions that have the
    same parameter count and return type:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式正是解决我们问题的模式。命令模式的目的就是将请求动作的请求者与执行动作的对象解耦。这正是我们面临的问题。我们的请求者是按钮，它需要与将要进行的任何特定函数调用解耦。命令模式将我们的函数指针概念包装成一个具有简单接口的类，用于执行函数调用。然而，这个模式给了我们更多的灵活性。我们将能够轻松地封装具有多个参数的函数指针，以及C++对象和成员函数。让我们从两个具有相同参数数量和返回类型的简单函数开始：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Command pattern encapsulates a request into an object, and it gives a common
    interface to perform that request. In our example, we will call our interface
    method `Execute()`, but it could be called anything. Let''s look at the `Command`
    abstract class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式将请求封装成一个对象，并提供一个公共接口来执行该请求。在我们的例子中，我们将调用我们的接口方法`Execute()`，但它可以是任何名称。让我们看看`Command`抽象类：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the Command pattern interface is very simple--it is just a single
    method. As usual, we mark the method as pure virtual so the base class can't be
    instantiated. Additionally, we create an empty virtual destructor so the correct
    derived class destructor will be called when needed. As I said, the name of the
    method isn't important. I have seen examples such as `Do`, `DoAction`, `Perform`,
    and so on. Here we call it `Execute` because that was the name in the original
    book written by the Gang of Four.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，命令模式接口非常简单——它只是一个单一的方法。通常，我们将该方法标记为纯虚函数，这样基类就不能被实例化。此外，我们创建一个空的虚析构函数，以便在需要时调用正确的派生类析构函数。正如我所说的，方法名称并不重要。我见过例如`Do`、`DoAction`、`Perform`等例子。在这里，我们将其称为`Execute`，因为这是《四人帮》所著原始书籍中的名称。
- en: 'Right from the start, we gain a benefit over function pointers by using this
    pattern. For every derived class we are writing the `Execute` method, which means
    we can directly hardcode any function and any parameters in that `Execute` function.
    Recall that when using function pointers, we needed to pass in parameters at the
    time of the call:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就通过使用这个模式获得了比函数指针更多的好处。对于每个我们编写的派生类`Execute`方法，这意味着我们可以在那个`Execute`函数中直接硬编码任何函数和任何参数。回想一下，当使用函数指针时，我们需要在调用时传递参数：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are just hardcoding the function call and the function parameter
    in place. This may not seem very useful now for such a simple function, but it
    could be used in-game. As we will see later, the Mach5 Engine has a command to
    quit the game. The command directly calls `StageManager::Quit()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是将函数调用和函数参数硬编码在原地。现在对于这样一个简单的函数来说，这可能看起来不太有用，但在游戏中可能会用到。正如我们稍后将要看到的，Mach5
    引擎有一个退出游戏的命令。该命令直接调用`StageManager::Quit()`。
- en: 'In most cases, we probably don''t want to hardcode the function and parameters.
    This is where the power of this pattern shows. In this next example, we can use
    the fact that both functions have the same signature. That means we can create
    a function pointer, and pass the function, and parameters to the command. The
    benefit here is that because the command is an object, it has a constructor. So,
    we can construct an object with an action and the parameters that will be used
    by that action:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们可能不想硬编码函数和参数。这正是这个模式力量的体现。在接下来的例子中，我们可以利用这两个函数具有相同签名的事实。这意味着我们可以创建一个函数指针，并将函数及其参数传递给命令。这里的优点是，因为命令是一个对象，它有一个构造函数。因此，我们可以构造一个具有动作及其参数的对象，该参数将由该动作使用：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a few interesting things going on here. The first is that this command
    can call any function that returns an `int` and takes one `int` as a parameter.
    That means it can work for Square and Cube, but also any other functions that
    we come up with later. The next interesting thing is that we can set the action
    and parameter in the constructor; this allows us to save parameters within the
    class and use them later. We could not do this by using function pointers alone.
    Finally, you may have noticed that we are passing in a pointer to an `int`, instead
    of just an `int`. This demonstrates how we can save the return value of a function
    call, and also allows us to think about these commands in a more flexible way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情正在发生。首先，这个命令可以调用任何返回 `int` 并接受一个 `int` 参数的函数。这意味着它可以用于 Square 和 Cube，也可以用于我们以后想出的任何其他函数。下一个有趣的事情是我们可以在构造函数中设置操作和参数；这允许我们在类中保存参数并在以后使用它们。仅使用函数指针是无法做到这一点的。最后，你可能已经注意到我们传递的是一个指向
    `int` 的指针，而不是一个 `int`。这展示了我们如何保存函数调用的返回值，并且也允许我们以更灵活的方式考虑这些命令。
- en: Commands are not just for quitting the game or changing the stage. We could
    have a command that changes the position of a game object when executed, or perhaps
    swaps the position of the player and an enemy based on some user input or a button
    click. By using commands, we can control everything about the game via the UI.
    That sounds a lot like a level editor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 命令不仅用于退出游戏或更改阶段。我们可以有一个在执行时改变游戏对象位置的命令，或者根据某些用户输入或按钮点击交换玩家和敌人的位置。通过使用命令，我们可以通过
    UI 控制游戏的各个方面。这听起来很像一个关卡编辑器。
- en: 'Now that we have seen two types of commands, let''s look at how the client
    would use them. We will start out with a simple main function. We will be constructing
    the command in the same function that calls it, but these could be set via a function
    call instead. The important thing is that at the point where the client calls
    Execute, they don''t need to know which function is being called, or what parameters
    (if any) are needed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了两种命令类型，让我们看看客户端如何使用它们。我们将从一个简单的 main 函数开始。我们将在这个调用它的函数中构建命令，但它们也可以通过函数调用设置。重要的是，在客户端调用
    Execute 的点上，他们不需要知道正在调用哪个函数，或者需要什么参数（如果有的话）：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the client could call different functions using the same interface,
    and does not need to care about function parameters. For such a simple pattern,
    the Command pattern is amazing. And it gets even better.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，客户端可以使用相同的接口调用不同的函数，而且不需要关心函数参数。对于这样一个简单的模式，命令模式是惊人的。而且它变得更好。
- en: Two parameters and beyond
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个参数及以上
- en: 'We saw that one limitation of using function pointers was that the signatures
    must be the same. They must have the same return type, as well as the same parameter
    types and count. We can already see that this isn''t true with the Command pattern.
    The client doesn''t need to know or care about the specific signature at call
    time since every command shares the common Execute interface. As an example, let''s
    look at a function with more than one parameter and create a command for that
    type. Here is the function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到使用函数指针的一个限制是签名必须相同。它们必须有相同的返回类型，以及相同的参数类型和数量。我们可以看到这一点在命令模式中并不成立。客户端在调用时不需要知道或关心具体的签名，因为每个命令都共享公共的
    Execute 接口。作为一个例子，让我们看看一个具有多个参数的函数，并为该类型创建一个命令。以下是该函数：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we mentioned before, the complexity of the function isn''t important. For
    now, let''s focus on functions that take more than one parameter, as in the case
    of this Add function. To make our code easier to read, let''s create a `typedef`
    for this signature too:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，函数的复杂性并不重要。现在，让我们专注于接受多个参数的函数，就像这个 Add 函数的情况一样。为了使我们的代码更容易阅读，让我们也为这个签名创建一个
    `typedef`：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s create a `Command` for all functions that match this signature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为所有匹配此签名的函数创建一个 `Command`：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `main` function is now updated to the following. Here we are only showing
    the parts of the code that changed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数现在更新如下。这里我们只显示代码中更改的部分：'
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we can easily create a new command for every function pointer
    signature we need. When the client calls the method, they don't need to know how
    many parameters are used. Unfortunately, even though our commands can take multiple
    arguments, those arguments are stuck using only the `int`. If we wanted them to
    use the float, we would need to make new commands or use the create a template
    command.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以轻松地为每个需要的函数指针签名创建一个新的命令。当客户端调用方法时，他们不需要知道使用了多少参数。不幸的是，尽管我们的命令可以接受多个参数，但这些参数仍然只能使用`int`。如果我们想让他们使用`float`，我们就需要创建新的命令或使用模板命令。
- en: In a real-world scenario, you could get away with creating the commands as you
    need them, and only creating them for the types you need. Another option, and
    one that is more common, is to have commands call C++ class methods, since the
    method has the option to use class variables instead of passed in parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，你可以根据需要创建命令，并且只为需要的类型创建它们。另一个更常见的选项是让命令调用C++类方法，因为方法有使用类变量而不是传入参数的选项。
- en: Pointers to member functions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员函数指针
- en: So far, we have seen how we can use the Command pattern with function pointers
    and allow the client to call our functions without caring about the parameter
    types or counts. This is incredibly useful. But what about using commands with
    C++ objects? While we can get commands to work with objects, we need to think
    about the problem a little first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用函数指针与命令模式结合，允许客户端调用我们的函数而无需关心参数类型或数量。这非常实用。但是，关于使用C++对象与命令结合，我们该怎么办？虽然我们可以让命令与对象一起工作，但我们需要先思考一下这个问题。
- en: 'The most basic way to call member functions is to simply hardcode them in the
    `Execute` method. For example, we could pass in an object to a command constructor
    and always call a very specific function. In the example, `m_gameObject` is a
    pointer to an object that was passed to the constructor. However, `Draw` is the
    hardcoded method that we always call. This is the same as hardcoding the function
    in `Square5Command`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 调用成员函数最基本的方法是在`Execute`方法中简单地硬编码它们。例如，我们可以将一个对象传递给命令构造函数，并始终调用一个非常具体的函数。在示例中，`m_gameObject`是指向传递给构造函数的对象的指针。然而，`Draw`是我们总是调用的硬编码方法。这与在`Square5Command`中硬编码函数相同：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since `m_gameObject` is a variable, the object that will call `Draw` can change,
    but we are still always calling `Draw`. In this case, we don't have the option
    to call something else. This is still useful, but we would like the ability to
    call any method on a class type. So, how do we get this ability? We need to learn
    about pointers to member functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`m_gameObject`是一个变量，调用`Draw`的对象可以改变，但我们仍然总是调用`Draw`。在这种情况下，我们没有调用其他内容的选项。这仍然很有用，但我们希望有调用类类型上任何方法的能力。那么，我们如何获得这种能力呢？我们需要了解成员函数指针。
- en: 'Using pointers to member functions isn''t that different from pointers to non-member
    functions. However, the syntax is a little stranger than you might expect. Recall
    that when calling a non-static class method, the first parameter is always implicit
    to the pointer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用成员函数指针与使用非成员函数指针并没有太大的区别。然而，语法可能比你想象的要奇怪一些。回想一下，在调用非静态类方法时，第一个参数总是隐式传递给指针：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `this` pointer is what allows the class method to know which instance of
    the class it needs to modify. The compiler automatically passes it in as the first
    parameter to all non-static member functions, and the address of the `this` pointer
    is used as an offset for all member variables:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`指针允许类方法知道它需要修改哪个类的实例。编译器自动将其作为第一个参数传递给所有非静态成员函数，并且使用`this`指针的地址作为所有成员变量的偏移量：'
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Even though it is implicitly passed in and is not part of the parameter list,
    we still have access to the `this` pointer in our code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它是隐式传递的，并且不是参数列表的一部分，我们仍然可以在我们的代码中访问`this`指针：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is important to understand this because normal functions and member functions
    are not the same. Class members are part of the class scope and they have an implicit
    parameter. So, we can''t save pointers to them like normal functions. The signature
    of a class method includes the class type, meaning we must use the scope resolution
    operator:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要，因为普通函数和成员函数并不相同。类成员是类作用域的一部分，并且它们有一个隐式参数。因此，我们不能像普通函数那样保存对它们的指针。类方法的签名包括类类型，这意味着我们必须使用作用域解析运算符：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Just having the correct pointer type is not enough. The class member access
    operators, known as the dot operator (`.`) and arrow operator ( `->` ), are not
    designed to work with arbitrary function pointers. They are designed to work with
    known data types or known function names as declared in the class. Since our function
    pointer isn't known until runtime, these operators won't work. We need different
    operators that will know how to work with member function pointers. These operators
    are the pointer to member operators, ( `.*` ) and ( `->*`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有正确的指针类型是不够的。类成员访问运算符，即点运算符（`.`）和箭头运算符（`->`），并不是设计用来与任意函数指针一起工作的。它们是设计用来与已知的数据类型或已知函数名称一起工作的，这些函数名称在类中声明。由于我们的函数指针直到运行时才知道，这些运算符将不起作用。我们需要不同的运算符，这些运算符将知道如何与成员函数指针一起工作。这些运算符是成员指针运算符（`.*`）和（`->*`）。
- en: 'Unfortunately, these operators have lower precedence than the function call
    operator. So, we need to add an extra set of parentheses around our object and
    our member function pointer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些运算符的优先级低于函数调用运算符。因此，我们需要在对象和成员函数指针周围添加一个额外的括号组：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is a lot more to pointers to members. This section here was just a short
    introduction. If you want more information, please go to [https://isocpp.org/wiki/faq/pointers-to-members](https://isocpp.org/wiki/faq/pointers-to-members).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 成员指针还有很多内容。这里只是简要介绍。如果您想了解更多信息，请访问[https://isocpp.org/wiki/faq/pointers-to-members](https://isocpp.org/wiki/faq/pointers-to-members)。
- en: Pointer to member command
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员指针命令
- en: 'Now that we know how to use pointers to member functions, we can create commands
    that can take an object and a specific member function to call. Just like before,
    we will use a simple example. The example class isn''t designed to do anything
    interesting, it is just used to demonstrate the concepts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用成员函数指针，我们可以创建可以接受一个对象和要调用的特定成员函数的命令。就像之前一样，我们将使用一个简单的例子。示例类并没有设计成做任何有趣的事情，它只是用来演示概念：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is a simple class called `SomeObject`. It has a constructor that takes
    an `int` parameter and uses it to set the private member variable `m_x`. It also
    has two functions: one that will print the value to the screen and one that changes
    the value. For now, we are keeping things simple by giving both member functions
    the same signature and not taking any arguments. This allows us to create a `typedef`
    for this type of method. Remember that the class type is part of the function
    signature:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的类，称为`SomeObject`。它有一个接受`int`参数的构造函数，并使用它来设置私有成员变量`m_x`。它还有两个函数：一个将值打印到屏幕上，另一个改变值。目前，我们通过给这两个成员函数相同的签名并且不接收任何参数来保持事情简单。这允许我们为这种类型的方法创建一个`typedef`。请记住，类类型是函数签名的一部分：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This creates a type called `SomeObjectMember` that can easily be used as a
    function parameter, function return type, or even saved as a member to another
    class (of course, that is exactly what we will do next). Even if you feel very
    comfortable with the syntax of function pointers and pointer to member functions,
    it is still good practice to make these `typedefs`. They make the code more readable
    for everyone, as you will see in the next code example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`SomeObjectMember`的类型，它可以很容易地用作函数参数、函数返回类型，甚至可以作为一个成员保存到另一个类中（当然，这正是我们接下来将要做的）。即使你对函数指针和成员函数指针的语法非常熟悉，仍然是一个好的实践来创建这些`typedef`。它们使代码对每个人来说都更容易阅读，正如你将在下一个代码示例中看到的那样：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since the syntax of calling a member function pointer can be tricky to get
    right, it can be useful to use a `#define` macro. While most of the time, macros
    should be avoided, this is one of the few times they can help by making your code
    more readable:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调用成员函数指针的语法可能很难正确使用，使用`#define`宏可能会有所帮助。虽然大多数时候应该避免使用宏，但这是少数几次宏可以帮助使代码更易读的情况：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This changes our `Execute` function to this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的`Execute`函数改为如下：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All we have done is hide the ugliness away in a macro, but at least people will
    have a better understanding of what it is doing. It is important to note that
    this macro only works with object pointers because it uses the arrow star operator
    ( `->*` ).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切就是将丑陋的东西隐藏在宏中，但至少人们会更好地理解它在做什么。需要注意的是，这个宏只适用于对象指针，因为它使用了箭头星运算符（`->*`）。
- en: 'Now, in main we can create commands to object members:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中，我们可以创建指向对象成员的命令：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is the class diagram of command hierarchy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指令层次结构的类图：
- en: '![](img/00054.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.jpeg)'
- en: Figure 8.3 - The command hierarchy
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 命令层次结构
- en: 'Even though this is just a simple demo, we can see the client code is the same
    whether they are calling a function pointer or a pointer to a member function,
    and regardless of parameter count. Unfortunately, we still need to create a `typedef`
    for every function and class type we need. However, C++ templates can help us
    here too. We can create a template command class that can call class methods of
    a specific signature (in our case, `void (Class::*)(void)`) that will work for
    all classes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是一个简单的演示，但我们可以看到，无论它们是调用函数指针还是成员函数指针，无论参数数量如何，客户端代码都是相同的。不幸的是，我们仍然需要为每个需要的函数和类类型创建一个`typedef`。然而，C++模板也可以帮助我们。我们可以创建一个模板命令类，它可以调用具有特定签名（在我们的情况下，`void
    (Class::*)(void)`）的类方法，这将适用于所有类：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see in the `Execute` method, this is limited to only calling methods
    without arguments, but it could easily be modified to suit your game's needs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在`Execute`方法中看到的，这仅限于调用不带参数的方法，但它可以很容易地修改以适应你游戏的需求。
- en: The benefits of the command pattern
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式的好处
- en: If looking at all that crazy code makes your eyes glaze over, you are not alone.
    The complex syntax of function pointers and pointer to member functions calls
    are some of the most difficult parts of C++. For that reason, many people avoid
    them. However, they also miss out on the power offered by such features.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看所有那些疯狂的代码让你眼花缭乱，你并不孤单。函数指针和成员函数指针调用的复杂语法是C++中最难的部分之一。因此，许多人避免使用它们。然而，他们也错过了这些特性提供的强大功能。
- en: On the other hand, just because something is powerful, it doesn't mean it is
    always the right tool for the job. Simple is often better and, because of the
    many levels of indirection, code like we just saw has the chance to cause a lot
    of bugs. It will be up to you to decide if using these tools is right for your
    project. That being said, let's discuss some of the benefits of using the Command
    pattern so you can better decide when and where to use it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，仅仅因为某件事物很强大，并不意味着它总是适合这项工作的正确工具。简单通常更好，而且由于存在许多间接层次，我们刚才看到的代码有可能引发很多错误。是否使用这些工具取决于你自己的决定。话虽如此，让我们讨论一下使用命令模式的优点，这样你可以更好地决定何时何地使用它。
- en: Treating a function call like an object
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数调用视为对象
- en: The biggest benefit of using the Command pattern is that we are encapsulating
    the function or method call and the parameters. This means that everything needed
    for the call can be passed to another function, returned from a function, or stored
    as a variable for later use. This is an extra level of indirection over only using
    function or method pointers, but it means the client doesn't need to worry about
    the details. They only need to decide when to execute the command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令模式的最大好处是我们封装了函数或方法调用及其参数。这意味着调用所需的一切都可以传递给另一个函数，从函数返回，或存储为变量以供以后使用。这比仅使用函数或方法指针提供了额外的间接层次，但它意味着客户端不需要担心细节。他们只需要决定何时执行命令。
- en: This might not seem very useful since we need to know all the function arguments
    before we pass it to the client. However, this situation can happen more often
    than you might think. The fact that the client doesn't need to know the details
    of the function call means that systems such as the UI can be incredibly flexible,
    and possibly even read from a file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在传递给客户端之前我们需要知道所有函数参数，这可能看起来并不很有用。然而，这种情况可能比你想象的更常见。客户端不需要知道函数调用的细节意味着，例如UI这样的系统可以非常灵活，甚至可能从文件中读取。
- en: In the above example, it is obvious that at the time of the call, the client
    doesn't know which command exists at a given array index. This is by design. What
    might not be so obvious, is that the array could have been populated using the
    return value from a function instead of hardcoded calls to a new operator (which
    we learned in [Chapter 5](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7),
    *Decoupling Code via the Factory Method Pattern*, leads to inflexible code). This
    flexibility means that the function to be executed can be changed at runtime.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，很明显，在调用时，客户端不知道给定数组索引中存在哪个命令。这是设计上的。可能不那么明显的是，数组可能已经使用函数的返回值而不是使用新操作符（我们在[第5章](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7)，*通过工厂方法模式解耦代码*中学到）的硬编码调用填充。这种灵活性意味着要执行的函数可以在运行时更改。
- en: A perfect example of this is a context sensitive *action button* in a game.
    Since there is a limited number of buttons on a gamepad, it is often useful to
    have the action of button change depending on what the player is doing. This could
    mean one button is responsible for talking to an NPC, picking up an item, opening
    a door, or triggering a *quick time event* depending on the player's location
    and what they are doing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个完美例子是游戏中一个上下文相关的 *动作按钮*。由于游戏手柄上的按钮数量有限，根据玩家正在做什么来改变按钮的动作通常很有用。这可能意味着一个按钮负责与NPC交谈、拾取物品、打开门或根据玩家的位置和所做的事情触发
    *快速反应事件*。
- en: Without the Command pattern, the logic involved in organizing, maintaining,
    and executing all the possible actions in a game would be incredibly complex.
    With the Command pattern, it is giving every actionable item a command, and making
    it available when the player is near.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有命令模式，组织、维护和执行游戏中所有可能动作的逻辑将会极其复杂。有了命令模式，它为每个可执行项提供了一个命令，并在玩家靠近时使其可用。
- en: Physically decoupling the client and the function call
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理上解耦客户端和函数调用
- en: One aspect of good design is low coupling. We have talked about this a lot before,
    and it applies here as well. First, since the client is only dependent on the
    base `Command` class, it is easier to test. This is because both the client and
    the specific function calls or actions can be tested independently to ensure that
    they work. Furthermore, since these unit tests are testing smaller amounts of
    code, we can be more confident that all possible cases are tested. This also means
    that the client or the commands have a better chance to be reused because of the
    low coupling within this project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好设计的其中一个方面是低耦合。我们之前已经讨论过很多次这个问题，这里同样适用。首先，由于客户端只依赖于基础 `Command` 类，因此更容易进行测试。这是因为客户端和特定的函数调用或操作都可以独立测试，以确保它们能正常工作。此外，由于这些单元测试测试的是更小的代码量，我们可以更有信心地认为所有可能的用例都得到了测试。这也意味着客户端或命令有更大的机会因为项目内部低耦合而被重用。
- en: Second, the client is less likely to break when changes to the code base occur.
    Since the client doesn't know which functions or methods are called, any changes
    to parameter counts or method names are local only to the commands that implement
    the changed methods. If more commands need to be added, those commands will automatically
    work with the existing client because they will use the `Command` class interface.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当代码库发生变化时，客户端不太可能出错。由于客户端不知道调用的是哪些函数或方法，任何对参数数量或方法名称的更改都仅限于实现更改方法的命令。如果需要添加更多命令，这些命令将自动与现有客户端一起工作，因为它们将使用
    `Command` 类接口。
- en: Finally, compile times can be reduced because the client needs to include fewer
    header files. Including fewer header files can lower the compile time since every
    time the header changes, every source file that includes it must be recompiled.
    Even the smallest change to a comment in a header file means that all the function
    calls from that header need to be rechecked for correct syntax at compile time
    and relinked at link time. Since our client doesn't know the details of the functions
    calls, there are no header files to include.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编译时间可以减少，因为客户端需要包含的头部文件更少。包含更少的头部文件可以降低编译时间，因为每次头部文件发生变化时，包含它的每个源文件都必须重新编译。即使是头部文件中注释的最小更改，也意味着所有从该头部文件调用的函数调用都必须在编译时重新检查语法，并在链接时重新链接。由于我们的客户端不知道函数调用的细节，因此不需要包含任何头部文件。
- en: Temporal decoupling
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间解耦
- en: 'This type of decoupling isn''t talked about much because it only applies to
    a few situations and, most of the time, this isn''t what we want. Usually, when
    we call a function we want it to execute immediately. We have a specific algorithm
    in our code and the timing and order of that code is very important. This isn''t
    true of all code. One situation is multithreaded code, in which multiple paths
    of code are executing simultaneously. Other situations are UI or context sensitive
    buttons, where the action to be executed is set up in advance instead of hardcoded
    in place. Let''s look at some code as an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的解耦讨论得不多，因为它只适用于少数情况，而且大多数情况下，这并不是我们想要的。通常，当我们调用一个函数时，我们希望它立即执行。我们代码中有特定的算法，该代码的时序和顺序非常重要。这并不适用于所有代码。一种情况是多线程代码，其中多个代码路径同时执行。其他情况是UI或上下文相关的按钮，其中要执行的操作是预先设置的，而不是硬编码在位置上。让我们通过一些代码作为例子来看一下：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In all four of the above situations, the functions and parameters are given.
    However, the command versions can be passed to other methods, called and/or recalled
    based on the need of the client.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述所有四种情况下，都给出了函数和参数。然而，命令版本可以根据客户端的需求传递给其他方法，根据需要调用和/或恢复。
- en: Undo and redo
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撤销和重做
- en: Another major benefit of having the call details packaged together in a class
    is the ability to undo an operation. Every modern desktop application, as well
    as the best web applications being made these days, features the ability to undo
    the last action or actions. This should be a standard that you strive to follow
    when implementing a level editor for your game.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用细节打包到类中的另一个主要好处是能够撤销操作。每个现代桌面应用程序，以及目前制作得最好的网络应用程序，都具备撤销最后一步或几步操作的能力。当你为你的游戏实现关卡编辑器时，这应该是一个你努力遵循的标准。
- en: Implementing a single level of undo in an application can seem like a large
    task. The naive approach might be to save the entire state of the application,
    possibly to a file, and reload that state when we need to undo. Depending on the
    application, there might be a lot of data to save. This method doesn't scale well
    in applications that can have dozens or hundreds of levels of undo. As the user
    does more actions, you would need to make sure to delete the oldest state before
    saving the current one.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中实现单级撤销可能看起来是一项庞大的任务。直观的方法可能是保存应用程序的整个状态，可能是一个文件，并在需要撤销时重新加载该状态。根据应用程序的不同，可能需要保存大量数据。这种方法在可以具有数十或数百级撤销的应用程序中扩展性不好。随着用户执行更多操作，你需要确保在保存当前状态之前删除最旧的状态。
- en: This simple approach is even more difficult when you also need to implement
    redo. Obviously, the text editors and tools that we use every day don't store
    hundreds of undo and redo files on the hard drive. There must be a better way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你还需要实现重做时，这种简单的方法变得更加困难。显然，我们每天使用的文本编辑器和工具不会在硬盘上存储数百个撤销和重做文件。一定有更好的方法。
- en: 'Instead of saving the entire state of the program, you only need to save information
    about the action that happened, and what data was changed. Saving a function and
    the parameters to the function sounds a lot like the Command pattern. Let''s look
    at a simple example of moving a game object from one place to another in a level
    editor. We could create a command like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是保存整个程序的状态，你只需要保存关于发生动作的信息以及哪些数据被更改。保存一个函数及其参数听起来很像命令模式。让我们看看一个简单的例子，在关卡编辑器中将游戏对象从一个地方移动到另一个地方。我们可以创建一个像这样的命令：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By adding the `Undo` method to the command interface and making sure to save
    the old data that will be modified in the `Execute` method, performing undo and
    redo becomes incredibly simple. First, we need to implement a command for every
    action that can be performed in our editor. Then, when the user interacts with
    the editor, instead of directly calling a function, they always call a command
    and add it to the end of our array of commands. Undoing and redoing is just a
    matter of calling the `Execute` or `Undo` method of the current array index.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Undo`方法添加到命令接口，并确保在`Execute`方法中保存将被修改的旧数据，撤销和重做变得极其简单。首先，我们需要为我们的编辑器中可以执行的所有操作实现一个命令。然后，当用户与编辑器交互时，他们总是调用一个命令并将其添加到我们的命令数组末尾。撤销和重做只是调用当前数组索引的`Execute`或`Undo`方法的问题。
- en: It might seem like a lot of work to create all those commands, and it is. However,
    that work is replacing the work of hardcoding function calls when a user presses
    keys or clicks the mouse. In the end, you will build a better system that people
    will want to use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所有这些命令可能看起来工作量很大，确实如此。然而，这项工作取代了当用户按键或点击鼠标时硬编码函数调用的工作。最终，你会构建一个人们愿意使用的更好的系统。
- en: Easy UI with commands in Mach5
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mach5中使用命令实现简单UI
- en: Now that we have seen what the Command pattern is, let's look at how it is used
    in the Mach5 Engine. You will be surprised that there isn't much code here. That
    is because using the Command pattern is easy once you understand the code behind
    it. In this section, we will look at both the component responsible for the mouse
    click and the commands that are used within the engine.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了命令模式是什么，让我们看看它在Mach5引擎中的应用。你会惊讶地发现这里代码并不多。这是因为一旦你理解了背后的代码，使用命令模式就变得很简单。在本节中，我们将查看负责鼠标点击的组件以及引擎内部使用的命令。
- en: 'Let''s have a look at the `M5Command` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`M5Command`类：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here is the `M5Command` class used in the Mach5 Engine. As you can see, it looks
    almost identical to the `Command` class we used in the example. The only difference
    is that since we plan on using this within a component, it needs to have a virtual
    constructor. That way we can make a copy of it without knowing the true type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Mach5 引擎中使用的 `M5Command` 类。正如你所见，它几乎与我们在示例中使用的 `Command` 类完全相同。唯一的区别是，由于我们计划在组件内部使用它，因此它需要一个虚拟构造函数。这样我们就可以在不了解真实类型的情况下复制它。
- en: 'The code for the `UIButtonComponent` class is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIButtonComponent` 类的代码如下：'
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, our UI button is a component. This means that any game object
    has the potential to be clicked. However, this class is specifically designed
    to work with objects that are in screen space, which is how the operating system
    gives us the mouse coordinates. The rest of the code here looks like you might
    expect. As part of the `UIButtonComponent` class, we have a private `M5Command`.
    Although this class is simple, it will be worth it for us to go through and see
    what each method does:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的 UI 按钮是一个组件。这意味着任何游戏对象都有可能被点击。然而，这个类是专门设计来与屏幕空间中的对象一起工作的，这是操作系统给我们鼠标坐标的方式。这里的其余代码看起来可能正如你所期望的那样。作为
    `UIButtonComponent` 类的一部分，我们有一个私有的 `M5Command`。尽管这个类很简单，但我们会逐一查看每个方法的功能：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The constructor is simple (as are most component constructors) since they are
    designed to be created via a factory. We set the component type and make sure
    to set the command pointer to null so we set ourselves up for safer code later:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数很简单（就像大多数组件构造函数一样），因为它们被设计为通过工厂创建。我们设置组件类型，并确保将命令指针设置为空，以便为后续的更安全代码做好准备：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The destructor is where that null pointer comes in handy. It is perfectly legal
    to delete a null pointer, so we know that this code will work, even if this component
    never receives a command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数是空指针派上用场的地方。删除空指针是完全合法的，因此我们知道这段代码将工作，即使这个组件从未收到命令：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Update` function is where we perform the test to see if the mouse click
    intersects the rectangle created by the object. As we mentioned before, this class
    could work with all objects, but to simplify the code we decided we would only
    use this class for screen space items. The code that is important in this decision
    is the `GetMouse` function. This function always returns coordinates in screen
    space. It would be possible to check if the object was in screen space or world
    space and convert the coordinates using the `M5Gfx` method `ConvertScreenToWorld`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 函数是我们执行测试以查看鼠标点击是否与对象创建的矩形相交的地方。正如我们之前提到的，这个类可以与所有对象一起工作，但为了简化代码，我们决定只使用这个类来处理屏幕空间中的项目。在这个决定中，重要的代码是
    `GetMouse` 函数。这个函数始终返回屏幕空间中的坐标。检查对象是在屏幕空间还是世界空间中，并使用 `M5Gfx` 方法 `ConvertScreenToWorld`
    转换坐标是可能的。'
- en: 'That null pointer comes in handy here as well. Since we know that the command
    pointer is valid or null, we can do a debug assert to test our code before we
    execute it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那个空指针在这里也很有用。由于我们知道命令指针是有效的或为空，我们可以在执行它之前对代码进行调试断言来测试我们的代码：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Clone` method looks like you might expect after reading [Chapter 6](part0112.html#3APV00-04600e4b10ea45a2839ef4fc3675aeb7),
    *Creating Objects with the Prototype Pattern*. This is one situation where we
    always need to test for null before using the command. We can''t clone a null
    command and it is completely valid to clone this component, whether the command
    has been set or not:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone` 方法看起来可能正如你在阅读[第6章](part0112.html#3APV00-04600e4b10ea45a2839ef4fc3675aeb7)，*使用原型模式创建对象*后所期望的那样。这是我们需要在使用命令之前始终测试空值的一种情况。我们不能克隆一个空命令，并且无论命令是否已设置，克隆此组件都是完全有效的：'
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `SetOnClick` method allows us to set and reset the command that is associated
    with this component. Again, we don't need to test our command before deleting.
    We also don't need to test if the method parameter is non-null, because a null
    value is perfectly acceptable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetOnClick` 方法允许我们设置和重置与此组件关联的命令。再次强调，我们在删除命令之前不需要测试我们的命令。同样，我们也不需要测试方法参数是否为非空，因为空值是完全可接受的。'
- en: 'Even though we haven''t done it for this class, this class could easily be
    expanded to include an `OnMouseOver` event that gets triggered when the mouse
    is inside the object rectangle but the mouse isn''t clicked. A feature like this
    could have lots of uses for both UI and world objects. Implementing it would be
    as easy as swapping the two conditional statements in the `Update` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有为这个类做这个，但这个类可以很容易地扩展以包括一个 `OnMouseOver` 事件，当鼠标在对象矩形内但未点击时，该事件会被触发。这样的功能可以为UI和世界对象提供很多用途。实现它就像在
    `Update` 函数中交换两个条件语句一样简单：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using commands
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令
- en: 'Now that we have seen the base `M5Command` class and `UIButtonComponent` class,
    let''s look at one of the derived commands to see how it is used in the game.
    The command that we will look at is a common one needed in games. This is the
    action that will allow us to change stages from one to the next:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了基本的 `M5Command` 类和 `UIButtonComponent` 类，让我们看看其中一个派生命令，看看它在游戏中是如何使用的。我们将要查看的命令是游戏中常见的一个。这是允许我们从一个阶段切换到下一个阶段的动作：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When used with a `UIButtonComponent`, this will allow the user to click a button
    and change to a new stage. As you can see, there are two ways to change the stage
    in the constructor and in the `SetNextStage` method. This allows the user the
    ability to create a command and decide later what stage it will switch to. The
    `Execute` method is as simple as can be since the `StageManager` is a Singleton:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `UIButtonComponent` 一起使用时，这将允许用户点击按钮并切换到新阶段。正如你所见，在构造函数和 `SetNextStage` 方法中，有两种方式可以改变阶段。这使用户能够创建一个命令，并在以后决定它将切换到哪个阶段。`Execute`
    方法尽可能简单，因为 `StageManager` 是一个单例：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将要输出的内容：
- en: '![](img/00055.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: Figure 8 4 - An example of UIButtons in the Mach5 Engine
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 4 - Mach5引擎中UIButtons的示例
- en: To be truly flexible, we would want all `UIButtons` loaded from a file. As with
    game objects, it would be best if menus and levels were not coupled to specific
    commands. At the very least, we would prefer to avoid hardcoding positions and
    sizes for each button. This proved to be easy with game objects. The Player or
    Raider game objects are so specific that when reading a level file, we only need
    to overwrite the position of each object. The size, texture name, and other attributes
    can be read from the more specific archetype file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正实现灵活性，我们希望所有 `UIButtons` 都能从文件中加载。就像游戏对象一样，最好菜单和关卡不与特定命令耦合。至少，我们更愿意避免为每个按钮硬编码位置和大小。这在使用游戏对象时证明是很容易的。玩家或掠夺者游戏对象非常具体，所以在读取关卡文件时，我们只需要覆盖每个对象的位置。大小、纹理名称和其他属性可以从中更具体的原型文件中读取。
- en: Buttons are more difficult since each one may use a different texture name,
    have a different size, and use a different command. We can't set this data in
    a button archetype file because all buttons will be different. Furthermore, game
    commands that need to control a specific game object are difficult to load from
    file since we have no information about the object except the type. This means
    that while we could create and load a command that controls the player, which
    we only have one of, we can't create and load a command that controls an arbitrary
    Raider, since we could have many per stage.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮更难一些，因为每个按钮可能使用不同的纹理名称，有不同的尺寸，并使用不同的命令。我们无法在按钮原型文件中设置这些数据，因为所有按钮都是不同的。此外，需要控制特定游戏对象的命令很难从文件中加载，因为我们除了类型之外没有关于对象的信息。这意味着虽然我们可以创建和加载一个控制玩家的命令，我们只有一个，但我们不能创建和加载一个控制任意掠夺者的命令，因为我们可能每个阶段都有很多。
- en: Having a high-quality level editor would solve both issues because the tool
    can manage data better. This could even include assigning object IDs that could
    be used by commands in the game. For this book, defining archetypes for every
    button worked well. While this may seem like a lot of work, the data in each archetype
    file would have otherwise been hardcoded into a `.cpp` file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高质量的关卡编辑器可以解决这两个问题，因为工具可以更好地管理数据。这甚至可以包括分配可以由游戏中的命令使用的对象ID。对于这本书，为每个按钮定义原型效果很好。虽然这看起来像是一项大量工作，但每个原型文件中的数据否则将硬编码到
    `.cpp` 文件中。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we focused on creating flexible, reusable buttons. Even though
    the UI may not be as fun to code or talk about as gameplay mechanics, to the player,
    it is just as important. That is why creating a good system to add and manage
    the UI in an intelligent way is so vital to making a great game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于创建灵活、可重用的按钮。尽管UI可能不如游戏机制那样有趣或值得讨论，但对玩家来说，它同样重要。这就是为什么创建一个良好的系统，以智能的方式添加和管理UI，对于制作一款优秀的游戏至关重要。
- en: We took an in-depth look at C++ function pointers and pointers to members. This
    is well known for being confusing and difficult. However, by mastering the techniques,
    we could create flexible commands that can call any C style function or C++ object
    method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了C++函数指针和成员指针。这因其复杂性和难以理解而闻名。然而，通过掌握这些技术，我们可以创建灵活的命令，可以调用任何C风格函数或C++对象方法。
- en: While this technique isn't always needed, in the case of UI, it allowed us to
    create an incredibly flexible system. Our UI objects and most commands can be
    set up and read from a file. If you were to create a level editor, you could easily
    use this system to create and read all UI buttons and commands from a file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这项技术并非总是必需的，但在UI方面，它使我们能够创建一个极其灵活的系统。我们的UI对象和大多数命令都可以从文件中设置和读取。如果你要创建一个关卡编辑器，你可以轻松地使用这个系统从文件中创建和读取所有UI按钮和命令。
- en: Now that we have a flexible system for creating the UI, let's move on to another
    problem everyone has when making games. In the next chapter, we will talk about
    a pattern that will allow us to better separate our engine code from our gameplay
    code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个灵活的系统来创建UI，让我们继续讨论制作游戏时每个人都会遇到的其他问题。在下一章中，我们将讨论一种模式，它将使我们能够更好地将引擎代码与游戏代码分离。
