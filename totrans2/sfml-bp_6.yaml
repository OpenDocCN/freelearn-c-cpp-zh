- en: Chapter 6. Boost Your Code Using Multithreading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用多线程提升代码性能
- en: 'In this chapter, we will gain skills about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下技能：
- en: How to run multiple parts of your program in parallel
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何并行运行程序中的多个部分
- en: How to protect memory access to avoid data race
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何保护内存访问以避免数据竞争
- en: How to incorporate those functionalities into Gravitris
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将这些功能集成到Gravitris中
- en: At the end of this chapter, you will be able to use all the power offered by
    the CPU of the computer, by paralyzing your code in a smart way. But first, let's
    describe the theory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够通过以智能的方式暂停你的代码来利用计算机CPU提供的所有功能。但首先，让我们描述一下理论。
- en: What is multithreading?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是多线程？
- en: In computer science, a software can be seen as a stream with a start and exit
    point. Each software starts its life with the `main()` function in C/C++. This
    is the entry point of your program. Until this point, you are able to do whatever
    you want; including creating new routine streams, cloning the entire software,
    and starting another program. The common point with all these examples is that
    another stream is created and has its own life, but they are not equivalent.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，一个软件可以被看作是一个有起始点和退出点的流。每个软件都以C/C++中的`main()`函数开始其生命周期。这是你程序的入口点。直到这一点，你可以做任何你想做的事情；包括创建新的例程流，克隆整个软件，并启动另一个程序。所有这些示例的共同点是都创建了一个新的流，并且它们有自己独立的生命周期，但它们并不等价。
- en: The fork() function
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fork()函数
- en: This functionality is pretty simple. Calling `fork()` will duplicate your entire
    running process to a new one. The new process that is created is totally separated
    from its parent (new PID, new memory area as the exact copy of its parent), and
    will start just after the `fork()` call. The return value of the `fork()` function
    is the only difference between the two executions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能相当简单。调用`fork()`将复制你的整个运行进程到一个新的进程中。新创建的进程与其父进程完全分离（新的PID，新的内存区域作为其父进程的精确副本），并在`fork()`调用后立即开始。`fork()`函数的返回值是两次执行之间的唯一区别。
- en: 'Following is an example of the `fork()` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`fork()`函数的示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it is very simple to use, but there are also some limitations
    with this use. The most important one concerns the sharing of memory. Because
    each process has its own memory area, you are not able to share some variables
    between them. A solution to this is to use files as sockets, pipes, and so on.
    Moreover, if the parent process dies, the child will still continue its own life
    without paying attention to its parent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用它非常简单，但也有一些使用上的限制。其中最重要的一个与内存共享有关。因为每个进程都有自己的内存区域，所以你无法在它们之间共享一些变量。一个解决方案是使用文件作为套接字、管道等。此外，如果父进程死亡，子进程仍将继续其自己的生命周期，而不会关注其父进程。
- en: So this solution is interesting only when you don't want to share anything between
    your different executions, even their states.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个解决方案只有在你不希望在不同的执行之间共享任何内容，甚至包括它们的状态时才有兴趣。
- en: The exec() family functions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: exec()族函数
- en: 'The `exec()` family functions (`execl()`, `execlp()`, `execle()`, `execv()`,
    `execvp()`, `execvpe()`) will replace the entire running program with another
    one. When paired with `fork()`, these functions become very powerful. Following
    is an example of these functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`族函数（`execl()`, `execlp()`, `execle()`, `execv()`, `execvp()`, `execvpe()`）将用另一个程序替换整个运行程序。当与`fork()`函数结合使用时，这些函数变得非常强大。以下是一个这些函数的示例：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This little code snippet will create two different processes as previously mentioned.
    Then, the child process will be replaced by an instance of Gravitris. As a call
    of any of the `exec()` family functions replace the entire running stream with
    a new one, all the code under the `exec` call will not be executed, except if
    an error occurs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的小代码片段将创建两个不同的进程，如前所述。然后，子进程将被Gravitris的一个实例替换。由于`exec()`族函数中的任何调用都会用一个新的流替换整个运行流，所以`exec`调用下的所有代码都不会执行，除非发生错误。
- en: Thread functionality
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程功能
- en: Now, we will speak about threads. The threads' functionalities are very close
    to the fork ones, but with some important differences. A thread will create a
    new stream to your running process. Its starting point is a function that is specified
    as a parameter. A thread will also be executed in the same context as its parent.
    The main implication is that the memory is the same, but it's not the only one.
    If the parent process dies, all its threads will die too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论线程。线程的功能与`fork`功能非常相似，但有一些重要的区别。一个线程将为你的运行进程创建一个新的流。它的起点是一个作为参数指定的函数。线程也将与其父进程在相同的环境中执行。主要影响是内存是相同的，但这不是唯一的一个。如果父进程死亡，所有它的线程也会死亡。
- en: These two points can be a problem if you don't know how to deal with them. Let's
    take an example of the concurrent memory access.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何处理这些问题，这两个点可能会成为一个问题。让我们以并发内存访问为例。
- en: Let's say that you have a global variable in your program named `var`. The main
    process will then create a thread. This thread will then write into `var` and
    at the same time, the main process can write in it too. This will result in an
    undefined behavior. There are different solutions to avoid this behavior and the
    common one is to lock the access to this variable with a mutex.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在程序中有一个名为`var`的全局变量。然后主进程将创建一个线程。这个线程将写入`var`，同时主进程也可以写入它。这将导致未定义的行为。有几种不同的解决方案可以避免这种行为，其中常见的一种是使用互斥锁来锁定对这个变量的访问。
- en: To put it simply, a mutex is a token. We can try to take (lock) it or release
    it (unlock). If more than one process wants to lock it at the same time, the first
    one will effectively lock it and the second process will be waiting until the
    unlock function is called on the mutex by the first one. To sum up, if you want
    to access to a shared variable by more than one thread, you have to create a mutex
    for it. Then, each time you want to access it, lock the mutex, access the variable,
    and finally unlock the mutex. With this solution, you are sure that you don't
    make any data corrupt.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，互斥锁是一个令牌。我们可以尝试获取（锁定）它或释放它（解锁）。如果有多个进程同时想要锁定它，第一个进程将有效地锁定它，第二个进程将等待第一个进程调用互斥锁的解锁函数。总结一下，如果你想通过多个线程访问共享变量，你必须为它创建一个互斥锁。然后，每次你想访问它时，锁定互斥锁，访问变量，最后解锁互斥锁。使用这种解决方案，你可以确保不会发生任何数据损坏。
- en: The second problem concerns the synchronization of the end of the execution
    of your thread with the main process. In fact, there is a simple solution for
    this. At the end of the main stream, you need to wait until the end of all the
    running threads. The stream will be blocked as long as any threads remain alive
    and consequently will not die.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题涉及到你的线程执行结束与主进程同步的问题。实际上，这个问题有一个简单的解决方案。在主流的末尾，你需要等待所有正在运行的线程结束。只要还有线程存活，流就会被阻塞，因此不会死亡。
- en: 'Here is an example of usage of a thread''s functionality:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用线程功能的示例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that the theory has been explained, let's explain what is the motivation
    to use multithreading.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然理论已经解释了，让我们解释一下使用多线程的动机是什么。
- en: Why do we need to use the thread functionality?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们需要使用线程功能？
- en: Nowadays, computers in general have a CPU that is able to deal with several
    threads at the same time. Most of the time 4-12 calculation units are present
    in a CPU. Each of these units are able to do a task independently from the others.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一般的计算机都有一个能够同时处理多个线程的CPU。大多数情况下，CPU中有4-12个计算单元。这些单元中的每一个都能够独立于其他单元完成任务。
- en: Let's pretend that your CPU has only four calculation units.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你的CPU只有四个计算单元。
- en: If you take the example of our previous games, all the work was done in a single
    thread. So only one core is used over the four present. This is a shame, because
    all the work is done by only one component, and the others are simply not used.
    We can make it better by splitting our code into several parts. Each of these
    parts will be executed into a different thread, and the job will be shared between
    them. Then, the different threads will be executed into a different core (with
    a maximum of four in our case). So the work is now done in parallel.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以我们之前的游戏为例，所有的工作都是在单个线程中完成的。所以只有四个核心中的一个被使用。这是很遗憾的，因为所有的工作都是由一个组件完成的，而其他的组件则没有被使用。我们可以通过将代码分成几个部分来改进这一点。每个部分将在不同的线程中执行，工作将在它们之间共享。然后，不同的线程将在不同的核心上执行（在我们的例子中最多四个）。所以现在工作是在并行中完成的。
- en: Creating several threads offers you the possibility to exploit all the power
    offered by the computer, allowing you to spend more time on some functionalities
    such as artificial intelligence.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个线程可以让您利用计算机提供的所有功能，让您有更多时间专注于某些功能，如人工智能。
- en: Another way of usage is when you use some blocking functions such as waiting
    for a message from the network, playing music, and so on. The problem here is
    that the running process will be in wait for something, and can't continue its
    execution. To deal with this, you can simply create a thread and delegate a job
    to it. This is exactly how `sf::Music` works. There is an internal thread that
    is used to play music. This is the reason why our games do not freeze when we
    play a sound or music. Each time a thread is created for this task, it appears
    transparent to the user. Now that the theory has been explained, let's use it
    in practice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种用法是当您使用一些阻塞函数时，例如等待网络消息、播放音乐等。这里的问题是运行中的进程将等待某事，无法继续执行。为了处理这个问题，您可以简单地创建一个线程并将任务委托给它。这正是
    `sf::Music` 的工作方式。有一个内部线程用于播放音乐。这也是为什么我们在播放声音或音乐时游戏不会冻结的原因。每次为这个任务创建线程时，它对用户来说都是透明的。现在理论已经解释清楚，让我们将其应用于实践。
- en: Using threads
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线程
- en: 'In [Chapter 4](ch04.html "Chapter 4. Playing with Physics"), *Playing with
    Physics*, we have introduced physics to our game. For this functionality, we have
    created two game loops: one for logic and another one for physics. Until now,
    the executions of the physics loop and the other one were made in the same process.
    Now, it''s time to separate their execution into distinct threads.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.html "第 4 章。玩转物理")中，我们介绍了物理到我们的游戏中。为了这个功能，我们创建了两个游戏循环：一个用于逻辑，另一个用于物理。到目前为止，物理循环和其他循环的执行是在同一个进程中进行的。现在，是时候将它们的执行分离到不同的线程中去了。
- en: 'We will need to create a thread, and protect our variables using a `Mutex`
    class. There are two options:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个线程，并使用 `Mutex` 类来保护我们的变量。有两种选择：
- en: Using object from the standard library
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库中的对象
- en: Using object from the SFML library
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SFML 库中的对象
- en: Here is a table that summarizes the functionalities needed and the conversion
    from a standard C++ library to SFML.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个总结所需功能和从标准 C++ 库到 SFML 转换的表格。
- en: 'The `thread` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread` 类：'
- en: '| Library | Header | Class | Start | Wait |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 头文件 | 类 | 启动 | 等待 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| C++ | `<thread>` | `std::thread` | Directly after construction | `::join()`
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| C++ | `<thread>` | `std::thread` | 构造后直接 | `::join()` |'
- en: '| SFML | `<SFML/System.hpp>` | `sf::Thread` | `::launch()` | `::wait()` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| SFML | `<SFML/System.hpp>` | `sf::Thread` | `::launch()` | `::wait()` |'
- en: 'The `mutex` class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex` 类：'
- en: '| Library | Header | Class | Lock | Unlock |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 头文件 | 类 | 锁定 | 解锁 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| C++ | `<mutex>` | `std::mutex` | `::lock()` | `::unlock()` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| C++ | `<mutex>` | `std::mutex` | `::lock()` | `::unlock()` |'
- en: '| SFML | `<SFML/System.hpp>` | `sf::Mutex` | `::lock()` | `::unlock()` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| SFML | `<SFML/System.hpp>` | `sf::Mutex` | `::lock()` | `::unlock()` |'
- en: 'There is a third class that can be used. It automatically calls `mutex::lock()`
    on construction and `mutex::unlock()` on destruction, in respect of the RAII idiom.
    This class is called a lock or guard. Its use is simple, construct it with mutex
    as a parameter and it will automatically lock/unlock it. Following table explains
    the details of this class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可以使用的第三种类。它会在构造时自动调用 `mutex::lock()`，并在析构时调用 `mutex::unlock()`，遵循 RAII 习惯。这个类被称为锁或保护器。它的使用很简单，用
    mutex 作为参数来构造它，它将自动锁定/解锁。以下表格解释了这个类的详细信息：
- en: '| Library | Header | Class | Constructor |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 头文件 | 类 | 构造函数 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| C++ | `<mutex>` | `std::lock_guard` | `std::lock_guard(std::mutex&)` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| C++ | `<mutex>` | `std::lock_guard` | `std::lock_guard(std::mutex&)` |'
- en: '| SFML | `<SFML/System.hpp>` | `sf::Lock` | `sf::Lock(sf::Mutex&)` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| SFML | `<SFML/System.hpp>` | `sf::Lock` | `sf::Lock(sf::Mutex&)` |'
- en: As you can see both libraries offer the same functionalities. The API changed
    a bit for the `thread` class, but nothing really important.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个库提供了相同的功能。`thread` 类的 API 有一些变化，但并不重要。
- en: In this book, I will use the SFML library. There is no real reason for this
    choice, except that it allows me to show you a bit more of the SFML possibilities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将使用 SFML 库。选择这个库没有真正的理由，只是因为它让我能够向您展示更多 SFML 的可能性。
- en: 'Now that the class has been introduced, let''s get back to the previous example
    to apply our new skills as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了这个类，让我们回到之前的例子，并按照以下方式应用我们的新技能：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are several parts in this simple example. The first part initializes the
    global variables. Then, we create a function named `f()` that prints **"Hello
    world"** and then prints another message. In the `main()` function, we create
    a thread attached to the `f()` function, we launch it, and print the value of
    `i`. Each time, we protect the access of the shared variable with a mutex (the
    two different approaches are used).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，有几个部分。第一部分初始化全局变量。然后，我们创建一个名为`f()`的函数，它打印**"Hello world"**，然后打印另一条消息。在`main()`函数中，我们创建一个与`f()`函数关联的线程，启动它，并打印`i`的值。每次，我们使用互斥锁（使用了两种不同的方法）来保护对共享变量`i`的访问。
- en: The print message from the `f()` function is unpredictable. It could be **"The
    value of i is 1 from f()"** or **"The value of i is 2 from f()"**. We are not
    able to say which one of the `f()` or `main()` prints will be made first, so we
    don't know the value that will be printed. The only point that we are sure of
    is that there is no concurrent access to `i` and the thread will be ended before
    the `main()` function, thanks to the `thread.wait()` call.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`f()`函数的打印消息是不可预测的。它可能是**"来自f()的i的值是1"**或**"来自f()的i的值是2"**。我们无法确定`f()`或`main()`哪个先打印，因此不知道将打印的值。我们唯一确定的是，没有对`i`的并发访问，并且线程将在`main()`函数之前结束，这要归功于`thread.wait()`调用。
- en: Now that the class that we needed have been explained and shown, let's modify
    our games to use them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释并展示了所需的类，让我们修改我们的游戏以使用它们。
- en: Adding multithreading to our games
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多线程添加到我们的游戏中
- en: 'We will now modify our Gravitris to paralyze the physics calculations from
    the rest of the program. We will need to change only two files: `Game.hpp` and
    `Game.cpp`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改我们的Gravitris以使物理计算从程序的其他部分中瘫痪。我们只需要更改两个文件：`Game.hpp`和`Game.cpp`。
- en: 'In the header file, we will not only need to add the required header, but also
    change the prototype of the `update_physics()` function and finally add some attributes
    to the class. So here are the different steps to follow:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们不仅需要添加所需的头文件，还需要更改`update_physics()`函数的原型，并最终给类添加一些属性。所以以下是需要遵循的不同步骤：
- en: Add `#include <SFML/System.hpp>`, this will allow us to have access to all the
    classes needed.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#include <SFML/System.hpp>`，这将允许我们访问所有需要的类。
- en: 'Then, change the following code snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更改以下代码片段：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'to:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'to:'
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The reason is that a thread is not able to pass any parameters to its wrapped
    function so we will use another solution: member variables.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原因在于一个线程无法向其包装的函数传递任何参数，因此我们将使用另一种解决方案：成员变量。
- en: 'Add the following variables into the `Game` class as private:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下变量添加到`Game`类中作为私有变量：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All these variables will be used by the physics thread, and the `_mutex` variable
    will ensure that no concurrent access to one of those variables is made. We will
    also need to protect the access to the `_world` variable for the same reasons.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些变量都将由物理线程使用，`_mutex`变量将确保不会对这些变量之一进行并发访问。出于相同的原因，我们还需要保护对`_world`变量的访问。
- en: Now that the header contains all the requirements, let's turn to the implementation.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在头文件包含了所有要求，让我们转向实现部分。
- en: First of all, we will not only need to update our constructor to initialize
    the `_physicsThread` and `_isRunning` variables, but also protect the access to
    `_world`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们不仅需要更新构造函数以初始化`_physicsThread`和`_isRunning`变量，还需要保护对`_world`的访问。
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the constructor, we will not only initialize the new member variables, but
    also protect our `_world` variable used in one of the callbacks. This lock is
    important to be sure that no data race occurs randomly during the execution.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们不仅需要初始化新的成员变量，还需要保护在其中一个回调中使用的`_world`变量。这个锁非常重要，以确保在执行过程中不会随机发生数据竞争。
- en: 'Now that the constructor has been updated, we need to change the `run()` function.
    The goal is to run the physics thread. There are not a lot of changes to make.
    See it by yourself:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构造函数已经更新，我们需要更改`run()`函数。目标是运行物理线程。需要做的更改不多。请自己看看：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that the main game loop has been updated, we need to make a small change
    in the `update()` method to protect the member `_world` variable.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在主游戏循环已经更新，我们需要在`update()`方法中进行一个小改动以保护成员`_world`变量。
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see there is only one modification. We just need to protect the
    access to the `_world` variable, that''s it. Now, we need to change the `updatePhysics()`
    function. This one will be changed a lot as shown in the following code snippet:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，只有一处修改。我们只需要保护 `_world` 变量的访问，仅此而已。现在，我们需要修改 `updatePhysics()` 函数。这个函数将会像以下代码片段所示进行大量修改：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We need to change the signature of this function because we are not able to
    give it some parameters through the thread. So we add an internal clock for this
    function, with its own loop. The rest of the function follows the logic developed
    in the `update()` method. Of course, we also use the mutex to protect the access
    to all the variables used. Now, the physics is able to be updated independently
    from the rest of the game.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要更改这个函数的签名，因为我们无法通过线程传递给它一些参数。因此，我们为这个函数添加了一个内部时钟，以及它自己的循环。函数的其余部分遵循在 `update()`
    方法中开发的逻辑。当然，我们也使用互斥锁来保护所有使用的变量的访问。现在，物理计算可以独立于游戏的其他部分进行更新。
- en: There are now little changes to be made in other functions where `_world` is
    used such as `initGame()` and `render()`. Each time, we will need to lock the
    access of this variable using the mutex.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在其他使用 `_world` 的函数，如 `initGame()` 和 `render()`，需要做的小改动很少。每次，我们都需要使用互斥锁来锁定这个变量的访问。
- en: 'The changes are as follows concerning the `initGame()` function:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于 `initGame()` 函数的修改如下：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And now take a look at the `render()` function after it is updated:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在看看更新后的 `render()` 函数：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the changes made were really minimalistic, but required to avoid
    any race conditions.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，所做的更改非常简约，但这是为了避免任何竞态条件。
- en: Now that all the changes have been made in the code, you should be able to compile
    the project and test it. The graphical result will stay unchanged, but the usage
    of the different cores of your CPU has changed. Now, the project uses two threads
    instead of only one. The first one used for the physics and another one for the
    rest of the game.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码中的所有更改都已完成，您应该能够编译项目并测试它。图形结果将保持不变，但CPU不同核心的使用方式已经改变。现在，项目使用两个线程而不是一个。第一个线程用于物理计算，另一个线程用于游戏的其他部分。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the use of multithreading and applied it to our
    existing Gravitris project. We have learned the reason for this, the different
    possible uses, and the protection of the shared variables.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了多线程的使用，并将其应用于现有的 Gravitris 项目中。我们学习了这样做的原因，不同的可能用途，以及共享变量的保护。
- en: In our actual game, multithreading is a bit overkill, but in a bigger one for
    instance with hundreds of players, networking, and real-time strategies; it becomes
    a *must have*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实际游戏中，多线程可能有些过度，但在更大型的游戏中，例如有数百玩家、网络和实时策略的情况下，它就变成了**必须的**。
- en: In the next chapter, we will build an entire new game and introduce new things
    such as the isometric view, component system, path finding, and more.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个全新的游戏，并介绍新的内容，如等距视图、组件系统、路径查找等。
