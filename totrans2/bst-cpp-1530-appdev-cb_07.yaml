- en: Chapter 7. Manipulating Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing cases and case-insensitive comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching strings using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and replacing strings using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting strings using safe printf-like functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing and erasing strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing a string with two iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a reference to string type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This whole chapter is devoted to different aspects of changing, searching, and
    representing strings. We'll see how some common string-related tasks can be easily
    done using the Boost libraries. This chapter is easy enough; it addresses very
    common string manipulation tasks. So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Changing cases and case-insensitive comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a pretty common task. We have two non-Unicode or ANSI character strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need to compare them in a case-insensitive manner. There are a lot of methods
    to do that; let's take a look at Boost's.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of `std::string` is all we need here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some different ways to do case-insensitive comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most trivial one is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the Boost predicate and STL method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Making a lowercase copy of both the strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Making an uppercase copy of the original strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Converting the original strings to lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second method is not an obvious one. In the second method, we compare the
    length of the strings; if they have the same length, we compare the strings character
    by character using an instance of the `boost::is_iequal` predicate. The `boost::is_iequal`
    predicate compares two characters in a case-insensitive way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Boost.StringAlgorithm` library uses `i` in the name of the method or class,
    if this method is case-insensitive. For example, `boost::is_iequal`, `boost::iequals`,
    `boost::is_iless`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each function and the functional object of the `Boost.StringAlgorithm` library
    that work with cases accept `std::locale`. By default (and in our examples), methods
    and classes use a default constructed `std::locale`. If we work a lot with strings,
    it may be a good optimization to construct a `std::locale` variable once and pass
    it to all the methods. Another good optimization would be to use the ''C'' locale
    (if your application logic permits that) via `std::locale::classic()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nothing forbids you to use both optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, C++11 has no string functions from `Boost.StringAlgorithm`. All
    the algorithms are fast and reliable, so do not be afraid to use them in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Official documentation on the Boost String Algorithms library can be found at
    [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *C++ Coding Standards* book by Andrei Alexandrescu and Herb Sutter for
    an example on how to make a case-insensitive string with a few lines of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching strings using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's do something useful! It's common that the user's input must be checked
    using some regular expression-specific pattern that provides a flexible means
    of match. The problem is that there are a lot of regex syntaxes; expressions written
    using one syntax are not handled well by the other syntax. Another problem is
    that long regexes are not easy to write.
  prefs: []
  type: TYPE_NORMAL
- en: So in this recipe, we'll write a program that may use different types of regular
    expression syntaxes and checks that the input strings match the specified regexes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of STL. Knowledge of regular expression
    syntax can be helpful, but it is not really required.
  prefs: []
  type: TYPE_NORMAL
- en: Linking examples against the `libboost_regex` library is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This regex matcher consists of a few lines of code in the `main()` function;
    however, I use it a lot. It'll help you some day.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement it, we''ll need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the start of the program, we need to output the available regex syntaxes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now correctly set up flags, according to the chosen syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll be requesting regex patterns in a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Getting a string to match in a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Applying regex to it and outputting the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finishing our example by restoring `std::cin` and requesting new regex patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now if we run the preceding example, we''ll get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All this is done by the `boost::regex` class. It constructs an object that is
    capable of regex parsing and compilation. The `flags` variable adds additional
    configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the regular expression is incorrect, it throws an exception; if the `boost::regex::no_except`
    flag was passed, it reports an error returning as non-zero in the `status()` call
    (just like in our example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Regular expression matching is done by a call to the `boost::regex_match` function.
    It returns `true` in case of a successful match. Additional flags may be passed
    to `regex_match`, but we avoided their usage for brevity of the example.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 contains almost all the `Boost.Regex` classes and flags. They can be found
    in the `<regex>` header of the `std::` namespace (instead of `boost::`). Official
    documentation provides information about the differences between C++11 and `Boost.Regex`.
    It also contains some performance measures that tell `Boost.Regex` is fast.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Searching and replacing strings using regular expressions* recipe will
    give you more information about `Boost.Regex` usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also consider official documentation to get more information about flags,
    performance measures, regular expression syntaxes, and C++11 conformance at [http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and replacing strings using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My wife enjoyed the *Matching strings using regular expressions* recipe very
    much and told me that I'll get no food until I improve it to be able to replace
    parts of the input string according to a regex match. Each matched subexpression
    (part of the regex in parenthesis) must get a unique number starting from 1; this
    number will be used to create a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how an updated program will work like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the code from the *Matching strings using regular expressions*
    recipe. You should read it before getting your hands on this one.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the example against the `libboost_regex` library is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the code from the previous one. Let's see what must
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'No additional headers will be included; however, we''ll need an additional
    string to store the replace pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll replace `boost::regex_match` with `boost::regex_find` and output matched
    results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to get the replace pattern and apply it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! Everyone's happy and I'm fed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `boost::regex_search` function doesn''t only return a true or a false (such
    as the `boost::regex_match` function does) value, but also stores matched parts.
    We output matched parts using the following construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that we outputted the results by skipping the first result (`results.begin()
    + 1`); that is because `results.begin()` contains the whole regex match.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::regex_replace` function does all the replacing and returns the modified
    string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different variants of the `regex_*` function; some of them receive
    bidirectional iterators instead of strings and some provide output to the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::smatch` is a `typedef` for `boost::match_results<std::string::const_iterator>`;
    so if you are using some other bidirectional iterators instead of `std::string::const_iterator`,
    you will need to use the type of your bidirectional iterators as a template parameter
    for `match_results`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`match_results` has a format function, so we can tune our example with it.
    Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We may use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, `replace_string` may have different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All the classes and functions from this recipe exist in C++11, in the `std::`
    namespace of the `<regex>` header.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official documentation on `Boost.Regex` will give you more examples and
    information about performance, C++11 standard compatibility, and regular expression
    syntax at [http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html).
    The *Matching strings using regular expressions* recipe will tell you the basics
    of `Boost.Regex`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting strings using safe printf-like functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `printf` family of functions is a threat to security. It is a very bad design
    to allow users to put their own strings as a type and format the specifiers. So
    what do we do when user-defined format is required? How shall we implement the
    `std::string to_string(const std::string& format_specifier) const;` member function
    of the following class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of STL is more than enough for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wish to allow users to specify their own output format for a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that in a safe manner, we''ll need the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will add some comments for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it is time to make all of them work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s all. Take a look at this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Imagine that `class_instance` has a member `i` equal to `100`, an `s` member
    equal to `"Reader"`, and a member `c` equal to `''!''`. Then, the program will
    output the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::format` class accepts the string that specifies the resulting string.
    Arguments are passed to `boost::format` using `operator%`. Values `%1%`, `%2%`,
    `%3%`, `%4%`, and so on, in the format specifying string, will be replaced by
    arguments passed to `boost::format`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We disable the exceptions for cases when a format string contains fewer arguments
    than passed to `boost::format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done to allow some formats like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And what will happen in case of an incorrect format?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, in that case, no assertion will be triggered and the following lines
    will be outputted to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: C++11 has no `std::format`. The `Boost.Format` library is not a very fast library;
    try not to use it much in performance critical sections.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official documentation contains more information about the performance of
    the `Boost.Format` library. More examples and documentation on extended printf-like
    format is available at [http://www.boost.org/doc/libs/1_53_0/libs/format/](http://www.boost.org/doc/libs/1_53_0/libs/format/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing and erasing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Situations where we need to erase something in a string, replace a part of the
    string, or erase the first or last occurrence of some substring are very common.
    STL allows us to do most of this, but it usually involves writing too much code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw the `Boost.StringAlgorithm` library in action in the *Changing cases
    and case-insensitive comparison* recipe. Let''s see how it can be used to simplify
    our lives when we need to modify some strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows how different string-erasing and replacing methods from the
    `Boost.StringAlgorithm` library work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Erasing requires the `#include <boost/algorithm/string/erase.hpp>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing requires the `<boost/algorithm/string/replace.hpp>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the examples are self-documenting. The only one that is not obvious is the
    `replace_head_copy` function. It accepts a number of bytes to replace as a second
    parameter and a replace string as the third parameter. So, in the preceding example,
    `Hello` gets replaced with `Whaaaaaaa!`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also methods that modify strings in-place. They don't just end on
    `_copy` and return `void`. All the case insensitive methods (the ones that start
    with `i`) accept `std::locale` as the last parameter, and use a default constructed
    locale as a default parameter.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 does not have `Boost.StringAlgorithm` methods and classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official documentation contains a lot of examples and a full reference on
    all the methods at [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Changing cases and case-insensitive comparison* recipe from this chapter
    for more information about the `Boost.StringAlgorithm` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing a string with two iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations when we need to split some strings into substrings and
    do something with those substrings. For example, count whitespaces in the string
    and, of course, we want to use Boost and be as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll need some basic knowledge of STL algorithms for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We won't be counting whitespaces; instead we'll split the string into sentences.
    You'll see that it is very easy with Boost.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, include the right headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s define our test string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we make a `typedef` for our splitting iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct that iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can iterate between matches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Count the number of characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And count the whitespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it. Now if we run this example, it will output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea of this recipe is that we do not need to construct `std::string`
    from substrings. We even do not need to tokenize the whole string at once. All
    we need to do is find the first substring and return it as a pair of iterators
    to the beginning and to the end of substring. If we need more substrings, find
    the next substring and return a pair of iterators for that substring.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4880OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's take a closer look at `boost::split_iterator`. We constructed one
    using the `boost::make_split_iterator` function that takes `range` as the first
    argument and a binary finder predicate (or binary predicate) as the second. When
    `split_iterator` is dereferenced, it returns the first substring as `boost::iterator_range<const
    char*>`, which just holds a pair of iterators and has a few methods to work with
    them. When we increment `split_iterator`, it will try to find the next substring,
    and if there is no substring found, `split_iterator::eof()` will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::iterator_range` class is widely used across all the Boost libraries.
    You may find it useful for your own code and libraries in situations where a pair
    of iterators must be returned or where a function should accept/work with a pair
    of iterators.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::split_iterator<>` and `boost::iterator_range<>` classes accept a
    forward iterator type as a template parameter. Because we were working with a
    character array in the preceding example, we provided `const char*` as iterators.
    If we were working with `std::wstring`, we would need to use the `boost::split_iterator<std::wstring::const_iterator>`
    and `boost::iterator_range<std::wstring::const_iterator>` types.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has neither `iterator_range` nor `split_iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: As the `boost::iterator_range` class has no virtual functions and no dynamic
    memory allocations, it is fast and efficient. However, its output stream operator
    `<<` has no specific optimizations for character arrays, so streaming it is slow.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::split_iterator` class has a `boost::function` class in it, so constructing
    it may be slow; however, iterating adds only a tiny overhead that you won't notice
    even in performance critical sections.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe will tell you about a nice replacement for `boost::iterator_range<const
    char*>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation for `Boost.StringAlgorithm` will provide you with
    more detailed information about classes and a whole bunch of examples at [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about `boost::iterator_range` can be found here: [http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html](http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html).
    It is a part of the `Boost.Range` library that is not described in this book,
    but you may wish to study it by yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a reference to string type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is the most important recipe in this chapter! Let''s take a look
    at a very common case, where we write a function that accepts a string and returns
    the part of the string between character values passed in the `starts` and `ends`
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you like this implementation? In my opinion, it looks awful; consider the
    following call to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a temporary `std::string` variable will be constructed from
    `"Getting expression (between brackets)"`. The character array is long enough,
    so there is a big chance that dynamic memory allocation will be called inside
    the `std::string` constructor and the character array will be copied into it.
    Then, somewhere inside the `between_str` function, new `std::string` will be constructed,
    which may also lead to another dynamic memory allocation and result in copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this simple function may, and in most cases will:'
  prefs: []
  type: TYPE_NORMAL
- en: Call dynamic memory allocation (twice)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy string (twice)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deallocate memory (twice)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we do better?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of STL and C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do not really need a `std::string` class here, we only need some pointer
    to the character array and the array's size. Boost has the `std::string_ref` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `boost::string_ref` class, include the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the method''s signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `std::string` to `boost::string_ref:` everywhere inside the function
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `boost::string_ref` constructor accepts size as a second parameter, so
    we need to slightly change the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! Now we may call `between("Getting expression (between brackets)",
    ''('', '')'')` and it will work without any dynamic memory allocation and characters
    copying. And we can still use it for `std::string`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As already mentioned, `boost::string_ref` contains only a pointer to the character
    array and size of data. It has a lot of constructors and may be initialized in
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `boost::string_ref` class has all the methods required by the container
    class, so it is usable with STL algorithms and Boost algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `boost::string_ref` class does not really own string, so all its methods
    return constant iterators. Because of that, we cannot use it in methods that modify
    data, such as `boost::to_lower(r)`.
  prefs: []
  type: TYPE_NORMAL
- en: While working with `boost::string_ref`, we should take additional care about
    data that it refers to; it must exist and be valid for the whole lifetime of `boost::string_ref`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::string_ref` class is not a part of C++11, but it is proposed for
    inclusion in the next standard.
  prefs: []
  type: TYPE_NORMAL
- en: The `string_ref` classes are fast and efficient; use them wherever it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `boost::string_ref` class is actually a typedef in the `boost::` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also find useful the following typedefs for wide characters in the
    `boost::` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official `string_ref` proposal for inclusion in C++ standard can be found
    at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost documentation for `string_ref` could be found at [http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html](http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
