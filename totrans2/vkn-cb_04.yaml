- en: Resources and Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和内存
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a buffer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建缓冲区
- en: Allocating and binding a memory object for a buffer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为缓冲区分配和绑定内存对象
- en: Setting a buffer memory barrier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置缓冲区内存屏障
- en: Creating a buffer view
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建缓冲区视图
- en: Creating an image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像
- en: Allocating and binding a memory object to an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配并绑定内存对象到图像
- en: Setting an image memory barrier
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置图像内存屏障
- en: Creating an image view
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像视图
- en: Creating a 2D image and view
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建2D图像和视图
- en: Creating a layered 2D image with a CUBEMAP view
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有CUBEMAP视图的分层2D图像
- en: Mapping, updating, and unmapping host-visible memory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射、更新和取消映射主机可见内存
- en: Copying data between buffers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缓冲区之间复制数据
- en: Copying data from a buffer to an image
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区复制数据到图像
- en: Copying data from an image to a buffer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图像复制数据到缓冲区
- en: Using a staging buffer to update a buffer with a device-local memory bound
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阶段缓冲区更新具有设备本地内存绑定的缓冲区
- en: Using a staging buffer to update an image with a device-local memory bound
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阶段缓冲区更新具有设备本地内存绑定的图像
- en: Destroying an image view
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁图像视图
- en: Destroying an image
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁图像
- en: Destroying a buffer view
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁缓冲区视图
- en: Freeing a memory object
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放内存对象
- en: Destroying a buffer
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁缓冲区
- en: Introduction
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In Vulkan, there are two very important types of resources in which data can
    be stored--buffers and images. Buffers represent linear arrays of data. Images,
    similarly to OpenGL''s textures, represent one-, two-, or three-dimensional data
    organized in a way that is (generally) specific for a given hardware (so we don''t
    know the internal memory structure). Buffers and images can be used for various
    purposes: in shaders, we can read or sample data from them, or store data in them.
    Images can be used as color or depth/stencil attachments (render targets), which
    means that we can render into them. Buffers can also store vertex attributes,
    indices, or parameters used during indirect drawing.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，有两种非常重要的资源类型可以存储数据--缓冲区和图像。缓冲区表示数据的线性数组。图像，类似于OpenGL的纹理，表示一维、二维或三维数据，其组织方式（通常）针对特定硬件是特定的（因此我们不知道内部内存结构）。缓冲区和图像可用于各种目的：在着色器中，我们可以从它们读取或采样数据，或者在其中存储数据。图像可以用作颜色或深度/模板附件（渲染目标），这意味着我们可以向它们渲染。缓冲区还可以存储用于间接绘制的顶点属性、索引或参数。
- en: What is very important is that each of the mentioned usages must be specified
    during resource creation (we can provide many of them at once). We also need to
    inform the driver when we change the way in which a given resource is used in
    our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，在资源创建期间必须指定提到的每种用法（我们一次可以提供许多）。我们还需要在应用程序中更改给定资源的使用方式时通知驱动程序。
- en: As opposed to high-level APIs such as OpenGL, buffers and images in Vulkan don't
    have their own storage. They require us to specifically create and bind appropriate
    memory objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与像OpenGL这样的高级API不同，Vulkan中的缓冲区和图像没有自己的存储。它们需要我们特别创建和绑定适当的内存对象。
- en: In this chapter, we will learn how to use these resources and how to allocate
    memory for them and bind it to them. We will also learn how to upload data from
    the CPU to the GPU, and how to copy data between resources.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用这些资源，以及如何为它们分配内存并将它们绑定。我们还将学习如何从CPU上传数据到GPU，以及如何在资源之间复制数据。
- en: Creating a buffer
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建缓冲区
- en: 'Buffers are the simplest  resources because they represent data which can be
    laid out in memory only  linearly, just like in typical C/C++ arrays:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是最简单的资源，因为它们代表的数据只能在内存中线性布局，就像典型的C/C++数组一样：
- en: '![](img/image_04_01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_01.png)'
- en: Buffers can be used for various purposes. They can be used in pipelines via
    descriptor sets to back data stores for uniform buffers, storage buffers, or texel
    buffers, among others. They can be a source of data for vertex indices or attributes,
    or can be used as **staging resources**--intermediate resources for data transfer
    from the CPU to the GPU. For all these purposes, we just need to create a buffer
    and specify its usage.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可用于各种目的。它们可以通过描述符集在管道中使用，作为统一缓冲区、存储缓冲区或texel缓冲区等数据存储的 backing store，它们可以是顶点索引或属性的数据源，或者可以用作**阶段资源**--从CPU到GPU数据传输的中间资源。对于所有这些用途，我们只需要创建一个缓冲区并指定其使用方式。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a created logical device stored in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为`logical_device`的`VkDevice`类型变量中的已创建逻辑设备的句柄。
- en: Create a variable of type `VkDeviceSize` named `size`, in which store a value
    that will represent the size of data (in bytes) which a buffer will be able to
    store.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `size` 的 `VkDeviceSize` 类型的变量，在其中存储一个表示缓冲区能够存储的数据大小（以字节为单位）的值。
- en: Think of desired scenarios a buffer will be used for. Create a variable of a
    bitfield type `VkBufferUsageFlags` named `usage`. Assign a value that is a logical
    sum (`OR`) of all desired buffer usages.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到缓冲区将被用于的预期场景。创建一个名为 `usage` 的 `VkBufferUsageFlags` 类型的位域变量。分配一个值，它是所有期望的缓冲区使用的逻辑和（`OR`）。
- en: 'Create a variable of type `VkBufferCreateInfo` named `buffer_create_info`.
    Assign the following values to its members:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `buffer_create_info` 的 `VkBufferCreateInfo` 类型的变量。将其成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO` value for `sType`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO` 的值为 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 的值用于 `pNext`'
- en: '`0` value for `flags`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的值为 `0`'
- en: '`size` variable for `size`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size` 变量用于 `size`'
- en: '`usage` variable for `usage`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage` 变量用于 `usage`'
- en: '`VK_SHARING_MODE_EXCLUSIVE` value for `sharingMode`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SHARING_MODE_EXCLUSIVE` 的值为 `sharingMode`'
- en: '`0` value for `queueFamilyIndexCount`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 的值为 `queueFamilyIndexCount`'
- en: '`nullptr` value for `pQueueFamilyIndices`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 的值为 `pQueueFamilyIndices`'
- en: Create a variable of type `VkBuffer` named `buffer`, in which a handle of a
    created buffer will be stored.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `buffer` 的 `VkBuffer` 类型的变量，在其中存储已创建的缓冲区的句柄。
- en: Call `vkCreateBuffer( logical_device, &buffer_create_info, nullptr, &buffer
    )`, and provide a handle of the logical device in the first parameter, a pointer
    to the `buffer_create_info` variable in the second parameter, a `nullptr` value
    in the third parameter, and a pointer to the `buffer` variable in the last parameter.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateBuffer(logical_device, &buffer_create_info, nullptr, &buffer)`，并在第一个参数中提供一个逻辑设备的句柄，在第二个参数中提供一个指向
    `buffer_create_info` 变量的指针，在第三个参数中使用 `nullptr` 值，并在最后一个参数中提供一个指向 `buffer` 变量的指针。
- en: Make sure the function call was successful by checking whether the returned
    valued is equal to `VK_SUCCESS`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查返回值是否等于 `VK_SUCCESS` 来确保函数调用成功。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before we can create a buffer, we need to know how big the buffer should be
    and how we want to use it. A buffer's size is determined by the amount of data
    we would like to store in it. All the ways in which buffer will be used in our
    application are specified by the buffer's usage. We can't use a buffer in a way
    that wasn't defined during buffer creation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建缓冲区之前，我们需要知道缓冲区应该有多大以及我们希望如何使用它。缓冲区的大小由我们希望存储在其中的数据量决定。缓冲区在应用程序中将如何使用，由缓冲区的使用情况指定。我们不能以在缓冲区创建期间未定义的方式使用缓冲区。
- en: Buffers can only be used for purposes (usages) specified during their creation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区只能用于创建时指定的目的（使用情况）。
- en: 'Here is a list of supported ways in which buffers can be used:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个支持缓冲区使用的列表：
- en: '`VK_BUFFER_USAGE_TRANSFER_SRC_BIT` specifies that the buffer can be a source
    of data for copy operations'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_TRANSFER_SRC_BIT` 指定缓冲区可以作为复制操作的数据源'
- en: '`VK_BUFFER_USAGE_TRANSFER_DST_BIT` specifies that we can copy data to the buffer'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_TRANSFER_DST_BIT` 指定我们可以将数据复制到缓冲区'
- en: '`VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` indicates that the buffer can be
    used in shaders as a uniform texel buffer'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` 表示缓冲区可以作为均匀像素缓冲区在着色器中使用'
- en: '`VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` specifies that the buffer can be
    used in shaders as a storage texel buffer'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` 指定缓冲区可以作为存储像素缓冲区在着色器中使用'
- en: '`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` indicates that the buffer can be used
    in shaders as a source of values for uniform variables'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` 表示缓冲区可以作为着色器中均匀变量的值的来源使用'
- en: '`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` indicates that we can store data in the
    buffer from within shaders'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` 表示我们可以在着色器中从缓冲区存储数据'
- en: '`VK_BUFFER_USAGE_INDEX_BUFFER_BIT` specifies that the buffer can be used as
    a source of vertex indices during drawing'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_INDEX_BUFFER_BIT` 指定缓冲区可以作为绘制期间顶点索引的源使用'
- en: '`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` indicates that the buffer can be a source
    of data for vertex attributes specified during drawing'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` 表示缓冲区可以作为绘制期间指定的顶点属性的源'
- en: '`VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT` indicates that the buffer can contain
    data that will be used during indirect drawing'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT` 表示缓冲区可以包含在间接绘制过程中使用的数据'
- en: 'To create a buffer, we need to prepare a variable of type `VkBufferCreateInfo`
    in which we provide the following data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建缓冲区，我们需要准备一个 `VkBufferCreateInfo` 类型的变量，在其中提供以下数据：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `size` and `usage` variables define the amount of data the buffer can hold
    and the ways in which we can use the buffer in our application, respectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`和`usage`变量分别定义了缓冲区可以存储的数据量以及我们在应用程序中使用缓冲区的方式。'
- en: The preceding `VK_SHARING_MODE_EXCLUSIVE` value provided for the `sharingMode`
    member is another very important parameter. Through it, we specify whether queues
    from multiple families can access the buffer at the same time. **Exclusive sharing
    mode** tells the driver that the buffer can be referenced only by queues from
    one family at a single time. If we want to use the buffer in commands submitted
    to queues from another family, we must explicitly tell the driver when the ownership
    has changed (when we transferred ownership from one family to another). This option
    gives us a better performance, but with a cost of more work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为`sharingMode`成员提供的先前`VK_SHARING_MODE_EXCLUSIVE`值是另一个非常重要的参数。通过它，我们指定多个家族的队列是否可以同时访问缓冲区。**独占共享模式**告诉驱动程序，缓冲区只能由一个家族的队列在某一时刻引用。如果我们想使用提交给另一个家族队列的命令中的缓冲区，我们必须明确告诉驱动程序所有权的变更（当我们从一个家族转移到另一个家族时）。这个选项给我们带来了更好的性能，但代价是更多的劳动。
- en: We can also specify a `VK_SHARING_MODE_CONCURRENT` sharing mode. With it, multiple
    queues from multiple families can access a buffer at the same time and we don't
    need to perform an ownership transfer. But, the trade-off is that a **concurrent
    access** may have lower performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定`VK_SHARING_MODE_CONCURRENT`共享模式。使用它，多个家族的多个队列可以同时访问一个缓冲区，我们不需要执行所有权转移。但是，权衡是并发访问可能具有较低的性能。
- en: 'After we have prepared the creation data, we can create a buffer like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备好了创建数据后，我们可以创建一个缓冲区如下：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Allocating and binding a memory object for a buffer*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为缓冲区分配和绑定内存对象*'
- en: '*Setting a buffer memory barrier*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置缓冲区内存屏障*'
- en: '*Creating a buffer view*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区视图*'
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新具有设备本地内存绑定的缓冲区*'
- en: '*Destroying a buffer*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区*'
- en: Allocating and binding a memory object for a buffer
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为缓冲区分配和绑定内存对象
- en: In Vulkan, buffers don't have their own memory. To be able to use buffers in
    our application and to store any data inside them, we need to allocate a memory
    object and bind it to a buffer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，缓冲区没有自己的内存。为了能够在我们的应用程序中使用缓冲区并在其中存储任何数据，我们需要分配一个内存对象并将其绑定到缓冲区。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a physical device from which the logical device was created.
    Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建逻辑设备所用的物理设备中获取句柄。将其存储在名为`physical_device`的`VkPhysicalDevice`类型变量中。
- en: Create a variable of type `VkPhysicalDeviceMemoryProperties` named `physical_device_memory_properties`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`physical_device_memory_properties`的`VkPhysicalDeviceMemoryProperties`类型变量。
- en: Call `vkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties
    )`, for which provide the handle of a physical device and a pointer to the `physical_device_memory_properties`
    variable. This call will store memory parameters (number of heaps, their size,
    and types) of the physical device used for processing.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties
    )`，为它提供物理设备的句柄和指向`physical_device_memory_properties`变量的指针。这个调用将存储用于处理的物理设备的内存参数（堆的数量、它们的大小和类型）。
- en: Take the handle of a logical device created from the physical device, represented
    by the `physical_device` variable. Store the handle in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从物理设备创建的逻辑设备，由`physical_device`变量表示。将句柄存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Take the handle of a created buffer represented by a variable of type `VkBuffer`
    named `buffer`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由名为`buffer`的`VkBuffer`类型变量表示的已创建缓冲区的句柄。
- en: Create a variable of type `VkMemoryRequirements` named `memory_requirements`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`memory_requirements`的`VkMemoryRequirements`类型变量。
- en: Acquire parameters of a memory that needs to be used for the buffer. Do this
    by calling `vkGetBufferMemoryRequirements( logical_device, buffer, &memory_requirements
    )`, and providing the handle of the logical device in the first parameter, the
    handle of the created buffer in the second parameter, and a pointer to the `memory_requirements`
    variable in the third parameter.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用于缓冲区的内存参数。通过调用`vkGetBufferMemoryRequirements( logical_device, buffer, &memory_requirements
    )`来完成，第一个参数提供逻辑设备的句柄，第二个参数提供创建的缓冲区的句柄，第三个参数提供指向`memory_requirements`变量的指针。
- en: Create a variable of type `VkDeviceMemory` named `memory_object` that will represent
    the created buffer's memory object, and assign a `VK_NULL_HANDLE` value to it.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`memory_object`的`VkDeviceMemory`类型的变量，它将表示创建的缓冲区的内存对象，并将其分配一个`VK_NULL_HANDLE`值。
- en: Create a variable of type `VkMemoryPropertyFlagBits` named `memory_properties`.
    Store additional (chosen) memory properties in the variable.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`memory_properties`的`VkMemoryPropertyFlagBits`类型的变量，并将额外的（选择的）内存属性存储在该变量中。
- en: 'Iterate over the available physical device''s memory types represented by the
    `memoryTypeCount` member of a `physical_device_memory_properties` variable. Do
    this by using the variable of type `uint32_t` named `type`. For each loop iteration,
    perform the following steps:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历由`physical_device_memory_properties`变量的`memoryTypeCount`成员表示的可用物理设备内存类型。通过使用名为`type`的`uint32_t`类型的变量来完成此操作。对于每次循环迭代，执行以下步骤：
- en: Make sure that the bit of the `memoryTypeBits` member of the `memory_requirements`
    variable on the position represented by the `type` variable is set.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`memory_requirements`变量的`memoryTypeBits`成员中，由`type`变量表示的位置上的位是设置的。
- en: Make sure that the `memory_properties` variable has the same bits set as a `propertyFlags`
    member of the memory type, at index `type` of the `memoryTypes` array in the `physical_device_memory_properties`
    variable.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`memory_properties`变量具有与`memoryTypes`数组中索引`type`的内存类型的`propertyFlags`成员相同的位设置。
- en: If points 1 and 2 are not true, continue iterating the loop.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果1和2点不成立，则继续迭代循环。
- en: 'Create a variable of type `VkMemoryAllocateInfo` named `buffer_memory_allocate_info`,
    and assign the following values for its members:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`buffer_memory_allocate_info`的`VkMemoryAllocateInfo`类型的变量，并为其成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO` value for `sType`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO`值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值'
- en: '`memory_requirements.size` variable for `allocationSize`'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_requirements.size`变量用于`allocationSize`'
- en: '`type` variable for `memoryTypeIndex`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`变量用于`memoryTypeIndex`'
- en: Call `vkAllocateMemory( logical_device, &buffer_memory_allocate_info, nullptr,
    &memory_object )`, for which provide the handle of the logical device, a pointer
    to the `buffer_memory_allocate_info` variable, a `nullptr` value, and a pointer
    to the `memory_object` variable.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkAllocateMemory(logical_device, &buffer_memory_allocate_info, nullptr, &memory_object)`，为它提供逻辑设备的句柄、指向`buffer_memory_allocate_info`变量的指针、一个`nullptr`值以及指向`memory_object`变量的指针。
- en: Make sure the call was successful by checking if the value returned by the call
    was equal to `VK_SUCCESS`, and stop iterating the loop.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查调用返回的值是否等于`VK_SUCCESS`来确保调用成功，并停止循环迭代。
- en: Make sure that memory object allocation inside the loop was successful by checking
    whether the `memory_object` variable is not equal to `VK_NULL_HANDLE`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保循环内内存对象的分配成功，通过检查`memory_object`变量是否不等于`VK_NULL_HANDLE`。
- en: Bind the memory object to the buffer by calling `vkBindBufferMemory( logical_device,
    buffer, memory_object, 0 )`, for which provide the `logical_device`, `buffer`,
    and `memory_object` variables and a `0` value.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`vkBindBufferMemory(logical_device, buffer, memory_object, 0)`将内存对象绑定到缓冲区，为它提供`logical_device`、`buffer`、`memory_object`变量和一个`0`值。
- en: Make sure the call was successful and the returned value was equal to `VK_SUCCESS`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用成功，并且返回值等于`VK_SUCCESS`。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To allocate a memory object for a buffer (or memory object in general), we
    need to know what memory types are available on a given physical device, and how
    many of them there are. This is done by calling the `vkGetPhysicalDeviceMemoryProperties()`
    function, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为缓冲区（或一般内存对象）分配内存对象，我们需要知道在给定的物理设备上可用的内存类型有哪些，以及它们的数量。这通过调用`vkGetPhysicalDeviceMemoryProperties()`函数来完成，如下所示：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to know how much storage a given buffer requires (the buffer''s
    memory may need to be bigger than the buffer''s size) and what memory type is
    compatible with it. All this is stored in a variable of type `VkMemoryRequirements`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道给定缓冲区需要多少存储空间（缓冲区的内存可能需要比缓冲区的大小更大）以及与之兼容的内存类型。所有这些信息都存储在一个类型为`VkMemoryRequirements`的变量中：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to check which memory type corresponds to the buffer''s memory
    requirements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查哪种内存类型对应于缓冲区的内存需求：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we iterate over all available memory types and check whether a given type
    can be used for our buffer. We can also request some additional memory properties
    that need to be fulfilled. For example, if we want to upload data directly from
    our application (from the CPU), memory mapping must be supported. In this case,
    we need to use a memory type that is **host-visible**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有可用的内存类型，并检查给定的类型是否可以用于我们的缓冲区。我们还可以请求一些需要满足的额外内存属性。例如，如果我们想直接从我们的应用程序（从CPU）上传数据，内存映射必须得到支持。在这种情况下，我们需要使用一个**主机可见**的内存类型。
- en: 'When we have found a proper memory type, we can use it to allocate a memory
    object and we can stop the loop. After that, we make sure that the memory was
    allocated properly (if we didn''t leave the loop without allocating the object)
    and next, we bind it to our buffer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到一个合适的内存类型时，我们可以用它来分配一个内存对象，并且我们可以停止循环。之后，我们确保内存被正确分配（如果我们没有在未分配对象的情况下离开循环），然后我们将其绑定到我们的缓冲区：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: During binding, we specify a memory offset, among other parameters. This allows
    us to bind a part of the memory that's not at the beginning of the memory object.
    We can (and should) use the `offset` parameter to bind multiple, separate parts
    of a memory object to multiple buffers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定过程中，我们指定一个内存偏移量，以及其他参数。这允许我们绑定不在内存对象开始处的内存的一部分。我们可以（并且应该）使用`offset`参数将内存对象的不同部分绑定到多个缓冲区。
- en: From now on, the buffer can be used in our application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，缓冲区可以在我们的应用程序中使用。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: This recipe shows how to allocate and bind a memory object to a buffer. But
    in general, we shouldn't use a separate memory object for each buffer. We should
    allocate bigger memory objects and use parts of them for multiple buffers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何分配和绑定一个内存对象到缓冲区。但通常，我们不应该为每个缓冲区使用一个单独的内存对象。我们应该分配更大的内存对象，并使用它们的一部分为多个缓冲区服务。
- en: In this recipe, we also acquired the parameters of a physical device's available
    memory types by calling a `vkGetPhysicalDeviceMemoryProperties()` function. But
    in general, to improve the performance of our application, we don't need to call
    it every time we want to allocate a memory object. We can call this function only
    once, after we choose a physical device that will be used for a logical device
    (refer to the *Creating a logical device* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*) and use the variable in which the parameters were stored.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们还通过调用`vkGetPhysicalDeviceMemoryProperties()`函数获取了物理设备可用内存类型的参数。但通常，为了提高我们应用程序的性能，我们不需要每次想要分配内存对象时都调用它。我们只需调用一次这个函数，在我们选择用于逻辑设备的物理设备之后（参考第1章的*创建逻辑设备*配方[d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml]，*实例和设备*)，并使用存储参数的变量。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a buffer*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Setting a buffer memory barrier*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置缓冲区内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新具有设备本地内存限制的缓冲区*'
- en: '*Freeing a memory object*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: '*Destroying a buffer*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区*'
- en: Setting a buffer memory barrier
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置缓冲区内存屏障
- en: Buffers can be used for various purposes. For each buffer, we can upload data
    to it or copy data from it; we can bind a buffer to a pipeline via descriptor
    sets and use it inside shaders as a source of data, or we can store data in the
    buffer from within the shaders.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可用于各种目的。对于每个缓冲区，我们可以向其上传数据或从中复制数据；我们可以通过描述符集将缓冲区绑定到管道并在着色器内部将其用作数据源，或者我们可以在着色器内部将数据存储在缓冲区中。
- en: We must inform a driver about each such usage, not only during buffer creation,
    but also before the intended usage. When we have been using a buffer for one purpose
    and from now on we want to use it differently, we must tell the driver about a
    change in the buffer's usage. This is done through buffer memory barriers. They
    are set as part of the pipeline barriers during command buffer recording (refer
    to the *Beginning a command buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通知驱动程序关于此类使用的每个情况，不仅是在缓冲区创建期间，而且在预期使用之前。当我们已经使用缓冲区完成一个目的，而现在我们想要以不同的方式使用它时，我们必须告诉驱动程序关于缓冲区使用的变化。这是通过缓冲区内存屏障来完成的。它们在命令缓冲区记录期间的管道屏障部分被设置（参考第3章的*开始命令缓冲区记录操作*配方[fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml]，*命令缓冲区和同步*)。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purpose of this recipe, we will use a custom structure type named `BufferTransition`
    with the following definition:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用一个名为 `BufferTransition` 的自定义结构体类型，其定义如下：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Through this structure, we will define the parameters we want to use for the
    buffer memory barrier. In `CurrentAccess` and `NewAccess`, we store information
    about how the buffer has been used so far and how it will be used from now on,
    respectively (in this case, usage is defined as types of memory operations that
    will involve a given buffer). The `CurrentQueueFamily` and `NewQueueFamily` members
    are used when we want to transfer ownership from queues from one family to another.
    We need to do this when we have specified **exclusive sharing mode** during buffer
    creation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个结构，我们将定义我们想要用于缓冲区内存屏障的参数。在 `CurrentAccess` 和 `NewAccess` 中，我们存储有关缓冲区到目前为止的使用情况和将来如何使用的相关信息（在这种情况下，使用定义为将涉及给定缓冲区的内存操作类型）。当我们在缓冲区创建期间指定
    **独占共享模式** 时，使用 `CurrentQueueFamily` 和 `NewQueueFamily` 成员。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Prepare parameters for each buffer you want to set up a barrier for. Store
    them in a vector of type `std::vector<BufferTransition>` named `buffer_transitions`.
    For each buffer, store the following parameters:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你想要为每个缓冲区设置屏障的每个缓冲区准备参数。将它们存储在一个名为 `buffer_transitions` 的 `std::vector<BufferTransition>`
    类型的向量中。对于每个缓冲区，存储以下参数：
- en: Buffer's handle in the `Buffer` member
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Buffer` 成员中的缓冲区句柄。'
- en: Type of memory operations that have involved the buffer so far in the `CurrentAccess`
    member
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止已涉及该缓冲区的内存操作类型在 `CurrentAccess` 成员中。
- en: Type of memory operations that will be performed on the buffer from now on (after
    the barrier) in the `NewAccess` member
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始（在屏障之后）将在缓冲区上执行的内存操作类型在 `NewAccess` 成员中。
- en: Index of a queue family that has been referencing the buffer so far (or a `VK_QUEUE_FAMILY_IGNORED`
    value if we don't want to transfer queue ownership) in the `CurrentQueueFamily`
    member
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止一直引用该缓冲区的队列家族的索引（或者如果不想转移队列所有权，则使用 `VK_QUEUE_FAMILY_IGNORED` 值）在 `CurrentQueueFamily`
    成员中。
- en: Index of a queue family that will be referencing the buffer from now on (or
    a `VK_QUEUE_FAMILY_IGNORED` value if we don't want to transfer queue ownership)
    in the `NewQueueFamily` member
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始引用该缓冲区的队列家族的索引（或者如果不想转移队列所有权，则使用 `VK_QUEUE_FAMILY_IGNORED` 值）在 `NewQueueFamily`
    成员中。
- en: Create a vector variable of type `std::vector<VkBufferMemoryBarrier>` named
    `buffer_memory_barriers`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `buffer_memory_barriers` 的 `std::vector<VkBufferMemoryBarrier>` 类型的向量变量。
- en: 'For each element of the `buffer_transitions` variable, add a new element to
    the `buffer_memory_barriers` vector. Use the following values for members of the
    new element:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `buffer_transitions` 变量的每个元素，向 `buffer_memory_barriers` 向量中添加一个新元素。为新元素成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER` value for `sType` member'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType` 成员的值为 `VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER`。'
- en: '`nullptr` value for `pNext`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`。'
- en: '`CurrentAccess` value of the current element for `srcAccessMask`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcAccessMask` 当前元素的 `CurrentAccess` 值。'
- en: '`NewAccess` value of the current element for `dstAccessMask`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstAccessMask` 当前元素的 `NewAccess` 值。'
- en: '`CurrentQueueFamily` value of the current element for `srcQueueFamilyIndex`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcQueueFamilyIndex` 当前元素的 `CurrentQueueFamily` 值。'
- en: '`NewQueueFamily` value of the current element for `dstQueueFamilyIndex`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstQueueFamilyIndex` 当前元素的 `NewQueueFamily` 值。'
- en: Buffer's handle for `buffer`
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer` 的缓冲区句柄。'
- en: '`0` value for `offset`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `0`。'
- en: '`VK_WHOLE_SIZE` value for `size`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size` 的值为 `VK_WHOLE_SIZE`。'
- en: Take the handle of the command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到命令缓冲区的句柄并将其存储在一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量中。
- en: Make sure the command buffer represented by the `command_buffer` handle is in
    the recording state (that the recording operation was started for the command
    buffer).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保由 `command_buffer` 句柄表示的命令缓冲区处于记录状态（记录操作已为命令缓冲区启动）。
- en: Create a variable of a bit field type `VkPipelineStageFlags` named `generating_stages`.
    In this variable, store values representing pipeline stages that have been using
    the buffer so far.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `generating_stages` 的位字段类型 `VkPipelineStageFlags` 变量。在这个变量中，存储表示到目前为止已使用该缓冲区的管道阶段的值。
- en: Create a variable of a bit field type `VkPipelineStageFlags` named `consuming_stages`.
    In this variable, store values representing pipeline stages in which the buffer
    will be used after the barrier.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `consuming_stages` 的位字段类型 `VkPipelineStageFlags` 变量。在这个变量中，存储表示屏障之后将使用该缓冲区的管道阶段的值。
- en: Call `vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages,
    0, 0, nullptr, static_cast<uint32_t>(buffer_memory_barriers.size()), &buffer_memory_barriers[0],
    0, nullptr )`, and provide the handle of the command buffer in the first parameter,
    and `generating_stages` and `consuming_stages` variables in the second and third
    parameters respectively. The number of elements of the `buffer_memory_barriers`
    vector should be provided in the seventh parameter, and the eighth parameter should
    point to the first element of the `buffer_memory_barriers` vector.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdPipelineBarrier(command_buffer, generating_stages, consuming_stages,
    0, 0, nullptr, static_cast<uint32_t>(buffer_memory_barriers.size()), &buffer_memory_barriers[0],
    0, nullptr)`，并在第一个参数中提供命令缓冲区的句柄，在第二个和第三个参数中分别提供 `generating_stages` 和 `consuming_stages`
    变量。应在第七个参数中提供 `buffer_memory_barriers` 向量的元素数量，第八个参数应指向 `buffer_memory_barriers`
    向量的第一个元素。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In Vulkan, operations that are submitted to queues are executed in order, but
    they are independent. Sometimes, it is possible for some operations to start before
    the previous operations have finished. This parallel execution is one of the most
    important performance factors of current graphics hardware. But sometimes, it
    is crucial that some operations should wait for the results of earlier operations:
    this is when memory barriers come in handy.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，提交到队列的操作是按顺序执行的，但它们是独立的。有时，某些操作可能在之前的操作完成之前开始。这种并行执行是当前图形硬件最重要的性能因素之一。但有时，某些操作等待早期操作的结果是至关重要的：这时内存屏障就派上用场了。
- en: Memory barriers are used to define moments in command buffers' executions, in
    which later commands should wait for the earlier commands to finish their job.
    They also cause the results of these operations to become visible for other operations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 内存屏障用于定义命令缓冲区执行中的时刻，在这些时刻，后续的命令应该等待早期命令完成其工作。它们还导致这些操作的结果对其他操作可见。
- en: In the case of buffers, through memory barriers, we specify how the buffer was
    used and which pipeline stages were using it up to the moment in which we placed
    a barrier. Next we need to define which pipeline stages will be using it and how,
    after the barrier. With this information, the driver can pause operations that
    need to wait for the results of earlier operations to become available, but execute
    operations that won't reference the buffer at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区的情况下，通过内存屏障，我们指定了缓冲区的使用方式和在放置屏障之前使用它的管道阶段。接下来，我们需要定义在屏障之后将使用它的管道阶段以及如何使用。有了这些信息，驱动程序可以暂停需要等待早期操作结果成为可用的操作，但执行不会引用缓冲区的操作。
- en: 'Buffers can be used only for purposes defined during creation. Each such usage
    corresponds with the type of memory operation through which the buffer''s contents
    can be accessed. Here is a list of supported memory access types:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区只能用于创建时定义的目的。每个这样的用途都与可以通过哪种内存操作访问缓冲区内容的内存操作类型相对应。以下是支持的内存访问类型列表：
- en: '`VK_ACCESS_INDIRECT_COMMAND_READ_BIT` is used when the buffer''s contents are
    a source of data for indirect drawing'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区的内容是间接绘制数据源时，使用 `VK_ACCESS_INDIRECT_COMMAND_READ_BIT`
- en: '`VK_ACCESS_INDEX_READ_BIT` indicates the buffer''s contents are used for indices
    during drawing operations'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_INDEX_READ_BIT` 表示缓冲区的内容在绘制操作期间用作索引'
- en: '`VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT` specifies that the buffer is a source
    of vertex attributes that are read during drawing'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT` 指定缓冲区是绘制期间读取的顶点属性的源'
- en: '`VK_ACCESS_UNIFORM_READ_BIT` is used when the buffer will be accessed through
    shaders as an uniform buffer'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区将通过着色器作为统一缓冲区访问时，使用 `VK_ACCESS_UNIFORM_READ_BIT`
- en: '`VK_ACCESS_SHADER_READ_BIT` indicates that the buffer can be read inside shaders
    (but not as a uniform buffer)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_SHADER_READ_BIT` 表示缓冲区可以在着色器内部读取（但不能作为统一缓冲区）'
- en: '`VK_ACCESS_SHADER_WRITE_BIT` specifies that shaders will write data to the
    buffer'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_SHADER_WRITE_BIT` 指定着色器将数据写入缓冲区'
- en: '`VK_ACCESS_TRANSFER_READ_BIT` is used when we want to copy data from the buffer'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要从缓冲区复制数据时，使用 `VK_ACCESS_TRANSFER_READ_BIT`
- en: '`VK_ACCESS_TRANSFER_WRITE_BIT` is used when we want to copy data to the buffer'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要将数据复制到缓冲区时，使用 `VK_ACCESS_TRANSFER_WRITE_BIT`
- en: '`VK_ACCESS_HOST_READ_BIT` specifies that the application will read the buffer''s
    contents (via memory mapping)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_HOST_READ_BIT` 指定应用程序将读取缓冲区的内容（通过内存映射）'
- en: '`VK_ACCESS_HOST_WRITE_BIT` is used when the application will write data to
    the buffer (via memory mapping)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序将通过内存映射将数据写入缓冲区时，使用 `VK_ACCESS_HOST_WRITE_BIT`
- en: '`VK_ACCESS_MEMORY_READ_BIT` is used when the buffer''s memory will be read
    in any other way not specified above'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区的内存将以任何未在上文中指定的其他方式读取时，使用`VK_ACCESS_MEMORY_READ_BIT`
- en: '`VK_ACCESS_MEMORY_WRITE_BIT` is used when the buffer''s memory will be written
    through any other way not described above'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区的内存将通过上述未描述的任何其他方式写入时，使用`VK_ACCESS_MEMORY_WRITE_BIT`
- en: 'Barriers are needed for memory operations to become visible for later commands.
    Without them, commands that read the buffer''s contents may start reading them
    before the contents were even properly written by the previous operations. But,
    such a break in the command buffer''s execution causes stalls in the graphics
    hardware''s processing pipeline. And this, unfortunately, may impact the performance
    of our application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内存操作对后续命令可见，需要设置障碍。如果没有它们，读取缓冲区内容的命令可能会在之前操作尚未正确写入内容之前就开始读取。但是，这种在命令缓冲区执行中的中断会导致图形硬件处理管道中的停滞。不幸的是，这可能会影响我们应用程序的性能：
- en: '![](img/image_04_002.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_002.png)'
- en: We should aggregate usage and ownership transitions for as many buffers as possible
    in as few barriers as possible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能在尽可能少的障碍中聚合尽可能多的缓冲区的使用和所有权转换。
- en: 'To set up a memory barrier for a buffer, we need to prepare a variable of type
    `VkBufferMemoryBarrier`. If possible, we should aggregate data for multiple buffers
    in one memory barrier. That''s why a vector with elements of type `VkBufferMemoryBarrier`
    seems very useful for this reason, and can be filled like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要为缓冲区设置内存障碍，我们需要准备一个类型为`VkBufferMemoryBarrier`的变量。如果可能，我们应该在一个内存障碍中聚合多个缓冲区的数据。这就是为什么一个包含类型为`VkBufferMemoryBarrier`的元素的向量在这个原因上看起来非常有用，并且可以像这样填充：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we set up a memory barrier in the command buffer. This is done during
    the command buffer''s recording operation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在命令缓冲区中设置一个内存障碍。这是在命令缓冲区的记录操作期间完成的：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the barrier we specify which pipeline stages of the commands, executed after
    the barrier, should wait for the results of which pipeline stages of commands
    executed before the barrier.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在障碍中，我们指定在障碍之后执行的命令的哪些管道阶段应该等待在障碍之前执行的命令的哪些管道阶段的结果。
- en: Remember that we need to set a barrier only when the usage is changed. We don't
    need to do it if the buffer is used for the same purpose multiple times. Imagine
    a situation in which we want to copy data to a buffer two times, from two different
    resources. First, we need to set one barrier that will inform the driver that
    we will perform operations involving memory access of a `VK_ACCESS_TRANSFER_WRITE_BIT`
    type. After that, we can copy data to the buffer as many times as we want. Next,
    if we want to use a buffer, for example, as a vertex buffer (source of vertex
    attributes during rendering), we need to set another barrier indicating that we
    will read vertex attribute data from the buffer--these operations are represented
    by a `VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT` memory access. When we are done drawing
    and a buffer will be used for yet another purpose, even if once again we want
    to copy data to the buffer, we yet again need to set a memory barrier with proper
    parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们只有在使用改变时才需要设置障碍。如果缓冲区多次用于同一目的，我们不需要这样做。想象一下这样的情况，我们想要将数据复制到缓冲区两次，来自两个不同的资源。首先，我们需要设置一个障碍，通知驱动程序我们将执行涉及`VK_ACCESS_TRANSFER_WRITE_BIT`类型内存访问的操作。之后，我们可以将数据复制到缓冲区，次数不限。接下来，如果我们想使用缓冲区，例如，作为顶点缓冲区（渲染期间顶点属性的来源），我们需要设置另一个障碍，表明我们将从缓冲区读取顶点属性数据--这些操作由`VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT`内存访问表示。当我们完成绘制并且缓冲区将用于另一个目的时，即使我们再次想要将数据复制到缓冲区，我们仍然需要设置一个带有正确参数的内存障碍。
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We don't need to set up a barrier for the whole buffer. We can do it only for
    part of the buffer's memory. To do this, we just need to specify proper values
    for the `offset` and `size` members of a variable of type `VkBufferMemoryBarrier`,
    defined for a given buffer. Through these members, we define where the contents
    of the memory start, and what the size of the memory is for which we want to define
    a barrier. These values are specified in machine units (bytes).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为整个缓冲区设置障碍。我们只能为缓冲区内存的一部分设置。为此，我们只需要为给定缓冲区定义的类型为`VkBufferMemoryBarrier`的变量的`offset`和`size`成员指定适当的值。通过这些成员，我们定义内存内容的起始位置，以及我们想要定义障碍的内存的大小。这些值以机器单位（字节）指定。
- en: See also
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Creating a buffer*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象分配和绑定到缓冲区*'
- en: '*Setting an image memory barrier*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新绑定设备本地内存的缓冲区*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新绑定设备本地内存的图像*'
- en: Creating a buffer view
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建缓冲区视图
- en: When we want to use a given buffer as a uniform texel buffer or as a storage
    texel buffer, we need to create a buffer view for it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将给定的缓冲区用作统一纹理缓冲区或存储纹理缓冲区时，我们需要为它创建一个缓冲区视图。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a logical device from which a given buffer was created. Store
    it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建给定缓冲区的逻辑设备中获取句柄。将其存储在名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Take the handle of a created buffer and store it in a variable of type `VkBuffer`
    named `buffer`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的缓冲区的句柄，并将其存储在名为 `buffer` 的 `VkBuffer` 类型的变量中。
- en: Choose a format for a buffer view (how the buffer's contents should be interpreted)
    and use it to initialize a variable of type `VkFormat` named `format`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为缓冲区视图选择一个格式（如何解释缓冲区的内容）并使用它初始化一个名为 `format` 的 `VkFormat` 类型的变量。
- en: Select the part of a buffer's memory for which a view should be created. Set
    the starting point of this memory (offset from the beginning of the buffer's memory)
    in a variable of type `VkDeviceSize` named `memory_offset`. Define the size of
    this memory through a variable of type `VkDeviceSize` named `memory_range`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择应创建视图的缓冲区内存的一部分。在名为 `memory_offset` 的 `VkDeviceSize` 类型的变量中设置此内存的起始点（从缓冲区内存的起始点偏移）。通过名为
    `memory_range` 的 `VkDeviceSize` 类型的变量定义此内存的大小。
- en: 'Create a variable of type `VkBufferViewCreateInfo` named `buffer_view_create_info`.
    Use the following values to initialize its members:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `buffer_view_create_info` 的 `VkBufferViewCreateInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO` value for `sType`'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`'
- en: '`0` value for `flags`'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 值用于 `flags`'
- en: '`buffer` variable for `buffer`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer` 变量用于 `buffer`'
- en: '`format` variable for `format`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 变量用于 `format`'
- en: '`memory_offset` variable for `offset`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_offset` 变量用于 `offset`'
- en: '`memory_range` variable for `range`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_range` 变量用于 `range`'
- en: Create a variable of type `VkBufferView` named `buffer_view`. It will be used
    to store the handle of a created buffer view.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `buffer_view` 的 `VkBufferView` 类型的变量。它将用于存储创建的缓冲区视图的句柄。
- en: Call `vkCreateBufferView( logical_device, &buffer_view_create_info, nullptr,
    &buffer_view )`, for which provide the handle of the logical device in the first
    parameter, a pointer to the `buffer_view_create_info` variable in the second parameter,
    a `nullptr` value as the third parameter, and a pointer to the `buffer_view` variable
    in the last parameter.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateBufferView( logical_device, &buffer_view_create_info, nullptr, &buffer_view
    )`，其中在第一个参数中提供逻辑设备的句柄，在第二个参数中提供一个指向 `buffer_view_create_info` 变量的指针，第三个参数为 `nullptr`
    值，在最后一个参数中提供一个指向 `buffer_view` 变量的指针。
- en: Make sure the call was successful by checking whether the value returned by
    the call was equal to `VK_SUCCESS`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查调用返回的值是否等于 `VK_SUCCESS` 来确保调用成功。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To create a buffer view, the most important things we need to think about are
    the view''s format and the memory parts for which the view will be created. This
    way, inside shaders, a buffer''s contents can be interpreted similarly to images
    (textures). We define these parameters as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建缓冲区视图，我们需要考虑的最重要的事情是视图的格式和视图将创建的内存部分。这样，在着色器内部，缓冲区的内容可以像图像（纹理）一样被解释。我们定义以下参数：
- en: '[PRE9]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create the buffer itself using the specified parameters:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用指定的参数创建缓冲区本身：
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a buffer*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象分配和绑定到缓冲区*'
- en: '*Destroying an image view*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像视图*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml) 的 *描述符集* 中，查看以下食谱：
- en: '*Creating a descriptor set layout*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Updating descriptor sets*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: Creating an image
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像
- en: Images represent data that can have one, two, or three dimensions, and can have
    additional mipmap levels and layers. Each element of an image's data (a texel)
    can also have one or more samples.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图像表示具有一维、二维或三维的数据，并且可以具有额外的米普贴层和层。图像数据的每个元素（一个纹理元素）也可以有一个或多个样本。
- en: Images can be used for many different purposes. We can use them as a source
    of data for copy operations. We can bind images to pipelines via descriptor sets
    and use them as textures (similarly to OpenGL). We can render into images, in
    which case we use images as color or depth attachments (render targets).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可用于许多不同的目的。我们可以将它们用作复制操作的数据源。我们可以通过描述符集将图像绑定到管线，并将它们用作纹理（类似于 OpenGL）。我们可以将渲染结果输出到图像中，在这种情况下，我们使用图像作为颜色或深度附件（渲染目标）。
- en: We specify image parameters such as size, format, and its intended usages during
    image creation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建图像时指定图像参数，如大小、格式和其预期用途。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device on which we want to create an image. Store
    it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们想要在其上创建图像的逻辑设备的句柄。将其存储在名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Choose an image type (if an image should have one, two, or three dimensions)
    and use a proper value to initialize a variable of type `VkImageType` named `type`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像类型（如果图像应该有一个、两个或三个维度）并使用适当的值初始化一个名为 `type` 的 `VkImageType` 类型的变量。
- en: Select the image's format--the number of components and number of bits each
    image's element should contain. Store the format in a variable of type `VkFormat`
    named `format`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像的格式--每个图像元素应包含的组件数和位数。将格式存储在名为 `format` 的 `VkFormat` 类型的变量中。
- en: Select the image's size (dimensions) and use it to initialize a variable of
    type `VkExtent3D` named `size`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像的大小（维度）并使用它来初始化一个名为 `size` 的 `VkExtent3D` 类型的变量。
- en: Choose the number of mipmap levels that should be defined for the image. Store
    the number of mipmap levels in a variable of type `uint32_t` named `num_mipmaps`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择应为图像定义的米普级别数。将米普级别数存储在名为 `num_mipmaps` 的 `uint32_t` 类型的变量中。
- en: Choose the number of layers that should be defined for the image and store it
    in a variable of type `uint32_t` named `num_layers`. If an image will be used
    as a cubemap, the number of layers must be a multiple of six.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择应为图像定义的层数并将其存储在名为 `num_layers` 的 `uint32_t` 类型的变量中。如果图像将用作立方体贴图，则层数必须是六的倍数。
- en: Create a variable of type `VkSampleCountFlagBits` named `samples`, and initialize
    it with a value representing the number of samples.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `samples` 的 `VkSampleCountFlagBits` 类型的变量，并用表示样本数的值初始化它。
- en: Select the intended image usages. Define them in a variable of type `VkImageUsageFlags`
    named `usage_scenarios`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择预期的图像用途。在名为 `usage_scenarios` 的 `VkImageUsageFlags` 类型的变量中定义它们。
- en: 'Create a variable of type `VkImageCreateInfo` named `image_create_info`. Use
    the following values for its members:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `image_create_info` 的 `VkImageCreateInfo` 类型的变量。为其成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO` value for `sType`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType` 的 `VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: For `flags`, use the `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` value if the image
    should be used as a cubemap, otherwise use a `0` value
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `flags`，如果图像应用作立方体贴图，则使用 `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` 值，否则使用 `0`
    值。
- en: '`type` variable for `imageType`'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageType` 的 `type` 变量'
- en: '`format` variable for `format`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的 `format` 变量'
- en: '`size` variable for `extent`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extent` 的 `size` 变量'
- en: '`num_mipmaps` variable for `mipLevels`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mipLevels` 的 `num_mipmaps` 变量'
- en: '`num_layers` variable for `arrayLayers`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayLayers` 的 `num_layers` 变量'
- en: '`samples` variable for `samples`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples` 的 `samples` 变量'
- en: '`VK_IMAGE_TILING_OPTIMAL` value for `tiling`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiling` 的 `VK_IMAGE_TILING_OPTIMAL` 值'
- en: '`usage_scenarios` variable for `usage`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage` 的 `usage_scenarios` 变量'
- en: '`VK_SHARING_MODE_EXCLUSIVE` value for `sharingMode`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sharingMode` 的 `VK_SHARING_MODE_EXCLUSIVE` 值'
- en: '`0` value for `queueFamilyIndexCount`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queueFamilyIndexCount` 的 `0` 值'
- en: '`nullptr` value for `pQueueFamilyIndices`'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pQueueFamilyIndices` 的 `nullptr` 值'
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout` 的 `VK_IMAGE_LAYOUT_UNDEFINED` 值'
- en: Create a variable of type `VkImage` named `image`. In it, a handle of a created
    image will be stored.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `image` 的 `VkImage` 类型的变量。在其中，将存储创建的图像的句柄。
- en: Call `vkCreateImage( logical_device, &image_create_info, nullptr, &image )`,
    for which provide the handle of the logical device, a pointer to the `image_create_info`
    variable, a `nullptr` value, and a pointer to the `image` variable.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateImage(logical_device, &image_create_info, nullptr, &image)`，其中提供逻辑设备的句柄、`image_create_info`
    变量的指针、一个 `nullptr` 值和 `image` 变量的指针。
- en: Make sure the value return by the `vkCreateImage()` call was equal to `VK_SUCCESS`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保由 `vkCreateImage()` 调用返回的值等于 `VK_SUCCESS`。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we want to create an image, we need to prepare multiple parameters: the
    image''s type, dimensions (size), number of components, and the number of bits
    for each component (format). We also need to know whether the image will contain
    mipmaps or whether it will have multiple layers (a normal image must contain at
    least one, and a cubemap image must contain at least six). We should also think
    about the intended usage scenarios, which are also defined during image creation.
    We can''t use an image in a way that wasn''t defined during its creation.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建一个图像时，我们需要准备多个参数：图像的类型、维度（大小）、组件数量以及每个组件的位数（格式）。我们还需要知道图像是否包含多级细节图（mipmap）或是否具有多个层（一个普通图像至少包含一个，立方体贴图图像至少包含六个）。我们还应该考虑预期的使用场景，这些场景也在图像创建时定义。我们不能以创建时未定义的方式使用图像。
- en: Images can only be used for purposes (usages) specified during their creation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图像只能用于创建时指定的目的（用途）。
- en: 'Here is a list of purposes for which images can be used:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了可以使用图像的目的：
- en: '`VK_IMAGE_USAGE_TRANSFER_SRC_BIT` specifies that the image can be used as a
    source of data for copy operations'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_TRANSFER_SRC_BIT` 表示图像可以用作复制操作的数据源'
- en: '`VK_IMAGE_USAGE_TRANSFER_DST_BIT` specifies that we can copy data to the image'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_TRANSFER_DST_BIT` 表示我们可以将数据复制到图像中'
- en: '`VK_IMAGE_USAGE_SAMPLED_BIT` indicates that we can sample data from the image
    inside shaders'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_SAMPLED_BIT` 表示我们可以在着色器内部从图像中采样数据'
- en: '`VK_IMAGE_USAGE_STORAGE_BIT` specifies that the image can be used as a storage
    image inside shaders'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_STORAGE_BIT` 表示图像可以用作着色器中的存储图像'
- en: '`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` specifies that we can render into an
    image (use it as a color render target/attachment in a framebuffer)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` 表示我们可以将内容渲染到图像中（在帧缓冲区中使用它作为颜色渲染目标/附件）'
- en: '`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` indicates that the image can
    be used as a depth and/or stencil buffer (as a depth render target/attachment
    in a framebuffer)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` 表示图像可以用作深度和/或模板缓冲区（作为帧缓冲区中的深度渲染目标/附件）'
- en: '`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` indicates that the memory bound to
    the image will be allocated lazily (on demand)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` 表示绑定到图像的内存将按需分配（延迟分配）'
- en: '`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` specifies that the image can be used
    as an input attachment inside shaders'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` 指定图像可以用作着色器中的输入附件'
- en: Different usage scenarios require different image layouts to be used. These
    are changed (transitioned) using image memory barriers. But during creation, we
    can specify only `VK_IMAGE_LAYOUT_UNDEFINED` (if we don't care about the initial
    contents) or `VK_IMAGE_LAYOUT_PREINITIALIZED` (if we want to upload data by mapping
    the **host-visible** memory), and we always need to transition to another layout
    before the actual use.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的使用场景需要使用不同的图像布局。这些布局通过图像内存屏障进行更改（转换）。但在创建时，我们只能指定 `VK_IMAGE_LAYOUT_UNDEFINED`（如果我们不关心初始内容）或
    `VK_IMAGE_LAYOUT_PREINITIALIZED`（如果我们想通过映射**主机可见**的内存来上传数据），并且我们总是在实际使用之前将其转换为另一个布局。
- en: 'All the image parameters are specified through a variable of type `VkImageCreateInfo`,
    like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图像参数都通过类型为 `VkImageCreateInfo` 的变量指定，如下所示：
- en: '[PRE11]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we create an image, we also need to specify the tiling. It defines the
    image''s memory structure. There are two available types of image tiling: linear
    and optimal.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建图像时，我们还需要指定平铺。它定义了图像的内存结构。有两种可用的图像平铺类型：线性和平滑。
- en: When using **linear tiling**, as the name suggests, an image's data is laid
    out in memory linearly, similarly to buffers or C/C++ arrays. This allows us to
    map an image's memory and read it or initialize it directly from our application,
    because we know how the memory is organized. Unfortunately, it restricts us from
    using an image for many purposes; for example, we can't use an image as a depth
    texture or as a cubemap (some drivers may support it, but it is not required by
    the specification and, in general, we shouldn't rely on it). Linear tiling can
    also lower the performance of our application.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**线性平铺**时，正如其名所示，图像的数据在内存中线性排列，类似于缓冲区或 C/C++ 数组。这使我们能够映射图像的内存并直接从我们的应用程序中读取或初始化它，因为我们知道内存是如何组织的。不幸的是，它限制了我们可以使用图像的许多目的；例如，我们不能将图像用作深度纹理或立方体贴图（某些驱动程序可能支持它，但它不是规范所要求的，并且通常我们不应该依赖它）。线性平铺也可能降低我们应用程序的性能。
- en: For the best performance, it is recommended to create images with optimal tiling.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，建议使用最佳平铺方式创建图像。
- en: 'Images with **optimal tiling** can be used for all purposes; they also have
    much better performance. But this comes with a trade-off--we don''t know how the
    image''s memory is organized. In the following diagram we can see an example of
    image''s data and it''s internal structure:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最佳贴图的图像可用于所有目的；它们还具有更好的性能。但这也带来了权衡——我们不知道图像的内存是如何组织的。在以下图中，我们可以看到一个图像的数据及其内部结构的示例：
- en: '![](img/image_04_03-1.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_03-1.png)'
- en: Each type of graphics hardware can store image data in a different way that
    is optimal for it. Because of that, we can't map an image's memory and initialize
    or read it directly from our application. In this situation, we are required to
    use **staging resources**.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的图形硬件都可以以对其最优的方式存储图像数据。正因为如此，我们无法映射图像的内存并直接从我们的应用程序中初始化或读取它。在这种情况下，我们需要使用
    **阶段资源**。
- en: 'When we are ready, we can create an image with the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好时，我们可以使用以下代码创建一个图像：
- en: '[PRE12]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到图像*'
- en: '*Setting an image memory barrier*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Creating an image view*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像视图*'
- en: '*Creating a 2D image and view*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建二维图像和视图*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新具有设备本地内存绑定的图像*'
- en: '*Destroying an image*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像*'
- en: Allocating and binding a memory object to an image
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配和绑定内存对象到图像
- en: Images, similarly to buffers, are not created with a bound memory storage. We
    need to implicitly create a memory object and bind it to the image. We can also
    use an existing memory object for this purpose.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与缓冲区类似，图像不是与绑定内存存储一起创建的。我们需要隐式创建一个内存对象并将其绑定到图像上。我们也可以为此目的使用现有的内存对象。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a physical device from which a logical device was created.
    Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取从物理设备创建的逻辑设备的句柄。将其存储在名为 `physical_device` 的 `VkPhysicalDevice` 类型变量中。
- en: Create a variable of type `VkPhysicalDeviceMemoryProperties` named `physical_device_memory_properties`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `physical_device_memory_properties` 的 `VkPhysicalDeviceMemoryProperties`
    类型的变量。
- en: Call `vkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties
    )`, for which provide the handle of the physical device and a pointer to the `physical_device_memory_properties`
    variable. This call will store memory parameters (number of heaps, their size,
    and types) of the physical device used for processing submitted operations.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties
    )`，其中提供物理设备的句柄以及指向 `physical_device_memory_properties` 变量的指针。此调用将存储用于处理提交操作的物理设备的内存参数（堆的数量、它们的大小和类型）。
- en: Take the handle of a logical device created from the physical device, represented
    by the `physical_device` variable. Store the handle in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由 `physical_device` 变量表示的从物理设备创建的逻辑设备的句柄。将句柄存储在名为 `logical_device` 的 `VkDevice`
    类型变量中。
- en: Take the handle of a created image represented by a variable of type `VkImage`
    named `image`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由名为 `image` 的 `VkImage` 类型变量表示的已创建图像的句柄。
- en: Create a variable of type `VkMemoryRequirements` named `memory_requirements`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `memory_requirements` 的 `VkMemoryRequirements` 类型的变量。
- en: Acquire the parameters of the memory that needs to be used for the image. Do
    this by calling `vkGetImageMemoryRequirements( logical_device, image, &memory_requirements
    )` and providing the handle of the logical device in the first parameter, the
    handle of the created image in the second parameter, and a pointer to the `memory_requirements`
    variable in the third parameter.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用于图像所需的内存的参数。通过调用 `vkGetImageMemoryRequirements( logical_device, image, &memory_requirements
    )` 并在第一个参数中提供逻辑设备的句柄，在第二个参数中提供创建的图像的句柄，以及在第三个参数中提供指向 `memory_requirements` 变量的指针来完成此操作。
- en: Create a variable of type `VkDeviceMemory` named `memory_object`, that will
    represent the memory object created for the image and assign a `VK_NULL_HANDLE`
    value to it.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `memory_object` 的 `VkDeviceMemory` 类型的变量，该变量将表示为图像创建的内存对象，并将其赋值为 `VK_NULL_HANDLE`。
- en: Create a variable of type `VkMemoryPropertyFlagBits` named `memory_properties`.
    Store additional (chosen) memory properties in the variable, or a `0` value if
    no additional properties are required.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `memory_properties` 的 `VkMemoryPropertyFlagBits` 类型的变量。将额外的（选择的）内存属性存储在变量中，或者如果不需要额外的属性，则存储
    `0` 值。
- en: 'Iterate over the available physical device''s memory types, represented by
    the `memoryTypeCount` member of a `physical_device_memory_properties` variable.
    Do this by using a variable of type `uint32_t` named `type`. For each loop iteration:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历由`physical_device_memory_properties`变量的`memoryTypeCount`成员表示的可用的物理设备内存类型。通过一个名为`type`的`uint32_t`类型的变量来完成此操作。对于每次循环迭代：
- en: Make sure that the bit on the position, represented by the `type` variable in
    the `memoryTypeBits` member of the `memory_requirements` variable, is set.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保由`memory_requirements`变量中的`memoryTypeBits`成员的`type`变量表示的位置上的位被设置。
- en: Make sure that the `memory_properties` variable has the same bits set as a `propertyFlags`
    member of the memory type `memoryTypes`, at index `type` in the `physical_device_memory_properties`
    variable.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`memory_properties`变量具有与`memoryTypes`内存类型的`propertyFlags`成员相同的位，在`physical_device_memory_properties`变量中的索引为`type`。
- en: If points 1 and 2 are not true, continue iterating the loop.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果1和2点不成立，则继续迭代循环。
- en: 'Create a variable of type `VkMemoryAllocateInfo` named `image_memory_allocate_info`
    and assign the following values for its members:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_memory_allocate_info`的`VkMemoryAllocateInfo`类型的变量，并为其成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO` value for `sType`'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO`值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值'
- en: '`memory_requirements.size` variable for `allocationSize`'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_requirements.size`变量用于`allocationSize`'
- en: '`type` variable for `memoryTypeIndex`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`变量用于`memoryTypeIndex`'
- en: Call `vkAllocateMemory( logical_device, &image_memory_allocate_info, nullptr,
    &memory_object )`, for which provide the handle of the logical device, a pointer
    to the `image_memory_allocate_info` variable, a `nullptr` value, and a pointer
    to the `memory_object` variable.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkAllocateMemory(logical_device, &image_memory_allocate_info, nullptr, &memory_object)`，为此提供逻辑设备的句柄、`image_memory_allocate_info`变量的指针、一个`nullptr`值以及`memory_object`变量的指针。
- en: Make sure the call was successful by checking whether the value returned by
    the call was equal to `VK_SUCCESS`, and stop iterating the loop.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查调用返回的值是否等于`VK_SUCCESS`来确保调用成功，并停止迭代循环。
- en: Make sure that memory object allocation inside the loop was successful by checking
    whether the `memory_object` variable is not equal to `VK_NULL_HANDLE`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`memory_object`变量是否不等于`VK_NULL_HANDLE`，确保在循环内内存对象分配成功。
- en: Bind the memory object to the image by calling `vkBindImageMemory( logical_device,
    image, memory_object, 0 )` , for which provide the `logical_device`, `image` and
    `memory_object` variables and a `0` value.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`vkBindImageMemory(logical_device, image, memory_object, 0)`将内存对象绑定到图像，为此提供`logical_device`、`image`和`memory_object`变量以及一个`0`值。
- en: Make sure the call was successful and the returned value was equal to `VK_SUCCESS`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用成功，并且返回值等于`VK_SUCCESS`。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Similarly to the memory object created for a buffer, we start by checking what
    memory types are available on a given physical device and what their properties
    are. We can, of course, omit these steps and gather this information once at the
    initialization stage of our application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与为缓冲区创建的内存对象类似，我们首先检查给定物理设备上可用的内存类型及其属性。当然，我们可以省略这些步骤，并在我们应用程序的初始化阶段一次性收集这些信息：
- en: '[PRE13]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we acquire the specific memory requirements of a given image. These can
    (and probably will) be different for each image, as they depend on the format,
    size, number of mipmaps and layers, and other properties of the image:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取给定图像的具体内存需求。这些可能（并且很可能）对每个图像都不同，因为它们取决于图像的格式、大小、mipmap数量和层数以及其他属性：
- en: '[PRE14]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to find a memory type that has proper parameters and is compatible
    with the image''s memory requirements:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到一个具有适当参数且与图像内存需求兼容的内存类型：
- en: '[PRE15]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we iterate over all available memory types. If a given bit of the `memoryTypeBits`
    member of an image's memory properties is set, this means that a memory type with
    the same number is compatible with the image and we can use it for the memory
    object. We can also check for other properties of the memory type and find the
    one that is suitable for our needs. For example, we may want to use a memory that
    can be mapped on the CPU (a **host-visible** memory).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有可用的内存类型。如果一个图像内存属性的`memoryTypeBits`成员的给定位被设置，这意味着具有相同编号的内存类型与图像兼容，我们可以用它来创建内存对象。我们还可以检查内存类型的其他属性，找到适合我们需求的类型。例如，我们可能想要使用可以映射到CPU上的内存（一个**主机可见**的内存）。
- en: 'Next, we check whether the memory object allocation inside the loop was successful.
    And if yes, we bind the created memory object with our image:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查循环内内存对象分配是否成功。如果是，我们将创建的内存对象与我们的图像绑定：
- en: '[PRE16]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From now on, we can use the image for all purposes defined during its creation.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们可以使用图像进行其创建期间定义的所有目的。
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Similarly to binding memory objects to buffers, we should allocate bigger memory
    objects and bind parts of them to multiple images. This way, we perform fewer
    memory allocations and the driver has to track a smaller number of memory objects.
    This may improve the performance of our application. It may also allow us to save
    some memory, as each allocation may require more memory than requested during
    allocation (in other words, its size may always be rounded up to a multiple of
    the memory page size). Allocating bigger memory objects and reusing parts of them
    for multiple images spares us the wasted area.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于将内存对象绑定到缓冲区，我们应该分配更大的内存对象，并将它们的部分绑定到多个图像。这样，我们执行更少的内存分配，驱动程序需要跟踪的内存对象数量更少。这可能会提高我们应用程序的性能。它还可能允许我们节省一些内存，因为每次分配可能需要比分配时请求的更多内存（换句话说，其大小可能总是向上舍入到内存页面大小的倍数）。分配更大的内存对象并重复使用它们的部分来为多个图像节省了浪费的空间。
- en: See also
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'The following recipes in this chapter:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下菜谱：
- en: '*Creating an image*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Setting an image memory barrier*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新具有设备本地内存绑定的图像*'
- en: '*Destroying an image*'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像*'
- en: '*Freeing a memory object*'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: Setting an image memory barrier
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置图像内存屏障
- en: Images are created for various purposes--they are used as textures, by binding
    them to a pipeline via descriptor sets, as render targets, or as presentable images
    in swapchains. We can copy data to or from images--these are also separate usages
    defined during image creation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图像被创建用于各种目的——它们被用作纹理，通过将它们绑定到管道的描述符集，作为渲染目标，或作为交换链中的可呈现图像。我们可以将数据复制到或从图像中——这些也是在图像创建期间定义的单独使用方式。
- en: Before we start using an image for any purpose, and every time we want to change
    the current usage of a given image, we need to inform a driver about this operation.
    We do this by using image memory barriers which are set during command buffer
    recording.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用图像进行任何目的之前，以及每次我们想要更改给定图像的当前使用方式时，我们需要通知驱动程序此操作。我们通过在命令缓冲区记录期间设置图像内存屏障来完成此操作。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purpose of this recipe, a custom structure type `ImageTransition` is
    introduced. It has the following definition:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，引入了一个自定义结构类型 `ImageTransition`。它具有以下定义：
- en: '[PRE17]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `CurrentAccess` and `NewAccess` members define types of memory operations
    that were taking place in regard to a given image before the barrier, and that
    will occur after the barrier.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentAccess` 和 `NewAccess` 成员定义了在屏障之前和之后针对给定图像进行的内存操作类型。'
- en: In Vulkan, images used for different purposes may have different internal memory
    organization. In other words, the memory of a given image may have a different
    layout for different image usages. When we want to start using an image in a different
    way, we also need to change this memory layout. This is done through the `CurrentLayout`
    and `NewLayout` members.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，用于不同目的的图像可能具有不同的内部内存组织。换句话说，给定图像的内存可能对不同图像使用具有不同的布局。当我们想要以不同的方式开始使用图像时，我们也需要更改此内存布局。这是通过
    `CurrentLayout` 和 `NewLayout` 成员来完成的。
- en: Memory barriers also allow us to transfer queue family ownership if an image
    was created with an exclusive sharing mode. In the `CurrentQueueFamily` member,
    we define the index of a family from which queues have been using an image so
    far. In `NewQueueFamily`, we need to define a family index for queues that will
    be using an image after the barrier. We can also use a `VK_QUEUE_FAMILY_IGNORED`
    special value for both when we don't want to transfer an ownership.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 内存屏障还允许我们在图像以独占共享模式创建时转移队列家族所有权。在 `CurrentQueueFamily` 成员中，我们定义了一个家族的索引，该家族的队列到目前为止一直在使用图像。在
    `NewQueueFamily` 中，我们需要定义一个队列家族索引，该索引用于屏障之后将使用图像的队列。我们还可以在两种情况下使用 `VK_QUEUE_FAMILY_IGNORED`
    特殊值，即当我们不想转移所有权时。
- en: The `Aspect` member defines the image's usage "context". We can choose from
    color, depth, or stencil aspects.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aspect` 成员定义了图像的使用“上下文”。我们可以从颜色、深度或模板方面进行选择。'
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Prepare parameters for each image you want to set up a barrier for. Store them
    in a vector of type `std::vector<ImageTransition>` named `image_transitions`.
    For each image, use the following values:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你想要设置障碍的每个图像准备参数。将它们存储在名为`image_transitions`的类型为`std::vector<ImageTransition>`的向量中。对于每个图像，使用以下值：
- en: Image's handle in an `Image` member
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像在`Image`成员中的句柄。
- en: Type of memory operations that involved the image so far in the `CurrentAccess`
    member
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止涉及图像的内存操作类型在`CurrentAccess`成员中。
- en: Type of memory operations that will be performed on the image from now on, after
    the barrier, in the `NewAccess` member
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在障碍之后，从现在开始将在图像上执行的内存操作类型在`NewAccess`成员中。
- en: Current image's internal memory layout in `CurrentLayout` member
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前图像在`CurrentLayout`成员中的内部内存布局。
- en: Layout image's memory should change into after the barrier in `NewLayout` member
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`NewLayout`成员中，图像的内存布局应在障碍后更改。
- en: Index of a queue family that has been referencing the image so far (or a `VK_QUEUE_FAMILY_IGNORED`
    value if we don't want to transfer queue ownership) in the `CurrentQueueFamily`
    member
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CurrentQueueFamily`成员中，引用图像的队列家族的索引（或如果不想转移队列所有权，则为`VK_QUEUE_FAMILY_IGNORED`值）。
- en: Index of a queue family that will be referencing the image from now on (or a
    `VK_QUEUE_FAMILY_IGNORED` value if we don't want to transfer queue ownership)
    in the `NewQueueFamily` member
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现在开始将引用图像的队列家族的索引（或如果不想转移队列所有权，则为`VK_QUEUE_FAMILY_IGNORED`值）在`NewQueueFamily`成员中。
- en: Image's aspect (color, depth, or stencil) in the `Aspect` member
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像在`Aspect`成员中的方面（颜色、深度或模板）。
- en: Create a vector variable of type `std::vector<VkImageMemoryBarrier>` named `image_memory_barriers`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_memory_barriers`的类型为`std::vector<VkImageMemoryBarrier>`的向量变量。
- en: 'For each element of the `image_transitions` variable, add a new element to
    the `image_memory_barriers` vector. Use the following values for members of the
    new element:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`image_transitions`变量的每个元素，向`image_memory_barriers`向量添加一个新元素。为新元素成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER` value for `sType` member.'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType`成员的`VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER`值。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值。'
- en: '`CurrentAccess` value of the current element for `srcAccessMask`.'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`srcAccessMask`的`CurrentAccess`值。
- en: '`NewAccess` value of the current element for `dstAccessMask`.'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`dstAccessMask`的`NewAccess`值。
- en: '`CurrentLayout` member of the current element for `oldLayout`.'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`oldLayout`的`CurrentLayout`成员。
- en: '`NewLayout` value of the current element for `newLayout`.'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`newLayout`的`NewLayout`值。
- en: '`CurrentQueueFamily` value of the current element for `srcQueueFamilyIndex`.'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`srcQueueFamilyIndex`的`CurrentQueueFamily`值。
- en: '`NewQueueFamily` value of the current element for `dstQueueFamilyIndex`.'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`dstQueueFamilyIndex`的`NewQueueFamily`值。
- en: Image's handle for `image`.
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的`image`句柄。
- en: 'The following values for the `subresourceRange` member of the new element:'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新元素`subresourceRange`成员的以下值：
- en: '`Aspect` member of the current element for `aspectMask`'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前元素的`aspectMask`的`Aspect`成员。
- en: '`0` value for `baseMipLevel`'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseMipLevel`的`0`值。'
- en: '`VK_REMAINING_MIP_LEVELS` value for `levelCount`'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelCount`的`VK_REMAINING_MIP_LEVELS`值。'
- en: '`0` value for `baseArrayLayer`'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseArrayLayer`的`0`值。'
- en: '`VK_REMAINING_ARRAY_LAYERS` value for `layerCount`'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layerCount`的`VK_REMAINING_ARRAY_LAYERS`值。'
- en: Take the handle of the command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获命令缓冲区的句柄，并将其存储在名为`command_buffer`的类型为`VkCommandBuffer`的变量中。
- en: Make sure the command buffer represented by the `command_buffer` handle is in
    the recording state (that the recording operation was started for the command
    buffer).
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保由`command_buffer`句柄表示的命令缓冲区处于记录状态（记录操作已开始用于命令缓冲区）。
- en: Create a variable of a bitfield type `VkPipelineStageFlags` named `generating_stages`.
    In this variable, store values representing pipeline stages that have been using
    the image so far.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`generating_stages`的位字段类型`VkPipelineStageFlags`变量。在这个变量中，存储表示到目前为止已经使用图像的管道阶段的值。
- en: Create a variable of a bitfield type `VkPipelineStageFlags` named `consuming_stages`.
    In this variable, store values representing pipeline stages in which the image
    will be referenced after the barrier.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`consuming_stages`的位字段类型`VkPipelineStageFlags`变量。在这个变量中，存储表示图像在障碍之后将被引用的管道阶段的值。
- en: Call `vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages,
    0, 0, nullptr, 0, nullptr, static_cast<uint32_t>(image_memory_barriers.size()),
    &image_memory_barriers[0] )` and provide the handle of the command buffer in the
    first parameter, and the `generating_stages` and `consuming_stages` variables
    in the second and third parameters respectively. The number of elements of the
    `image_memory_barriers` vector should be provided in the second to last parameter,
    and the last parameter should point to the first element of the `image_memory_barriers`
    vector.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages,
    0, 0, nullptr, 0, nullptr, static_cast<uint32_t>(image_memory_barriers.size()),
    &image_memory_barriers[0] )` 并在第一个参数中提供命令缓冲区的句柄，以及在第二个和第三个参数中分别提供 `generating_stages`
    和 `consuming_stages` 变量。应在倒数第二个参数中提供 `image_memory_barriers` 向量的元素数量，最后一个参数应指向
    `image_memory_barriers` 向量的第一个元素。
- en: How it works...
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Vulkan, operations are processed in a pipeline. Even though the processing
    of operations needs to be started in the order in which they were submitted, parts
    of the pipeline may still be executed concurrently. But sometimes, we may need
    to synchronize these operations and tell the driver that we want some of them
    to wait for results of other operations.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，操作在管道中处理。尽管操作的执行需要按照它们提交的顺序开始，但管道的某些部分仍可能并发执行。但有时，我们可能需要同步这些操作，并告知驱动程序我们希望其中一些操作等待其他操作的结果。
- en: Memory barriers are used to define moments in command buffers' execution, in
    which later commands should wait for the earlier commands to finish their job.
    They also cause the results of these operations to become visible for other operations.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 内存障碍用于定义命令缓冲区执行中的时刻，在此时刻后续命令应等待早期命令完成其工作。它们还导致这些操作的结果对其他操作可见。
- en: 'Barriers are needed for memory operations to become visible for later commands.
    In cases where the operations write data to images and further operations will
    read from them, we need to use image memory barriers. The opposite situation also
    requires memory barriers to be used--operations that overwrite images'' data should
    wait for earlier operations to stop reading data from them. Failing to do so,
    in both cases, will make the contents of an image invalid. But such situations
    should be as rare as possible or our application may suffer from performance loss.
    This is because such a pause in the command buffer''s execution causes stalls
    in the graphics hardware''s processing pipeline and, as a result, time being wasted:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内存操作在后续命令中可见，需要设置障碍。在操作将数据写入图像且后续操作将从中读取的情况下，我们需要使用图像内存障碍。相反的情况也需要使用内存障碍——覆盖图像数据的操作应该等待早期操作停止从它们那里读取数据。在两种情况下，不这样做都会使图像的内容无效。但这种情况应该尽可能少发生，否则我们的应用程序可能会遭受性能损失。这是因为命令缓冲区执行中的这种暂停会导致图形硬件处理管道中的停滞，从而浪费时间：
- en: To avoid a negative impact on the performance of our application, we should
    set up parameters for as many images as possible in as few barriers as possible.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免对我们应用程序性能的负面影响，我们应该尽可能在尽可能少的障碍中为尽可能多的图像设置参数。
- en: '![](img/image_04_004.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_004.png)'
- en: Image memory barriers are also used to define a change in how images are used.
    Such a usage change typically also requires us to synchronize submitted operations;
    that's why this is also done through memory barriers. For the purpose of changing
    an image's usage, we need to define types of memory operations that were performed
    on an image before and after the barrier (memory access). We also specify what
    the memory layout was before the barrier, and how memory should be laid out after
    the barrier. This is because images may have different memory organization when
    they are used for different purposes. For example, sampling data from images inside
    shaders may need them to be cached in such a way that neighbor texels are also
    neighbors in memory. But, writing data to images may be performed faster when
    a memory is laid out linearly. That's why image layouts were introduced in Vulkan.
    Each image usage has its own, designated layout. There is one, general layout,
    which can be used for all purposes. But, using the general layout is not recommended
    because it may impact the performance on some hardware platforms.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图像内存屏障也用于定义图像使用方式的变化。这种使用变化通常还需要我们同步提交的操作；这就是为什么这也通过内存屏障来完成。为了改变图像的使用，我们需要定义在屏障（内存访问）之前和之后在图像上执行的记忆操作类型。我们还指定了屏障之前的内存布局，以及屏障之后内存应该如何布局。这是因为图像在用于不同目的时可能具有不同的内存组织。例如，从着色器内部采样图像数据可能需要它们以这种方式缓存，以便相邻的纹理元素在内存中也是相邻的。但是，当内存线性布局时，写入图像数据可能执行得更快。这就是为什么在Vulkan中引入了图像布局。每个图像使用都有自己的、指定的布局。有一个通用的布局，可以用于所有目的。但是，不建议使用通用布局，因为它可能会影响某些硬件平台上的性能。
- en: For the best performance, it is recommended to use designated image memory layouts
    for specific usages, though care must be taken if layout transitions are performed
    too frequently.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，建议使用特定用途指定的图像内存布局，尽管如果布局转换过于频繁，则需要小心。
- en: 'Parameters that define usage change are specified through the variables of
    a `VkImageMemoryBarrier` type, like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 定义使用变化的参数通过`VkImageMemoryBarrier`类型的变量指定，如下所示：
- en: '[PRE18]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But for the barrier to work properly, we also need to define pipeline stages
    in which images have been used so far, and in which images will be used from now
    on:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了让屏障正常工作，我们还需要定义已经使用过图像的管道阶段，以及从现在开始将使用图像的管道阶段：
- en: '![](img/image_04_005.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_005.png)'
- en: In the preceding diagram, we can see two examples of pipeline barriers. On the
    left, color is generated by the fragment shader and, after all the fragment tests
    (depth test, blending), color data is written into the image. This image is then
    used in the vertex shader of the successive commands. There is a high chance that
    such a setup will generate stalls in the pipeline.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到两个管道屏障的例子。在左侧，颜色是由片段着色器生成的，在所有片段测试（深度测试、混合）之后，颜色数据被写入图像。然后，这个图像被用于后续命令的顶点着色器。这种情况很可能在管道中产生停滞。
- en: 'The example on the right shows another dependency in graphics commands. Here,
    data is written into a resource in the vertex shader. Such data is then used by
    the fragment shader of the next command. This time, there is a high probability
    that all instances of the vertex shader will finish their jobs before the fragment
    shader of the next command begins executing. That''s why it is important to lower
    the number of pipeline barriers and, if required, to properly set up drawing commands
    and choose pipeline stages for the barrier. The parameters of the barrier (generating
    and consuming stages) are aggregated for all images specified in the barrier using
    the following call:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的示例显示了图形命令中的另一个依赖关系。在这里，数据被写入顶点着色器中的资源。然后，这些数据被下一个命令的片段着色器使用。这一次，所有顶点着色器的实例很可能在下一个命令的片段着色器开始执行之前完成它们的工作。这就是为什么减少管道屏障的数量，并在需要时正确设置绘图命令和选择屏障的管道阶段很重要。屏障的参数（生成和消耗阶段）通过以下调用对所有在屏障中指定的图像进行聚合：
- en: '[PRE19]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the image is used in the same way multiple times and is not used for other
    purposes in between, we don't need to set a barrier before the image is actually
    used. We set it to signal the usage change, not the usage itself.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像以相同的方式多次使用，并且在之间没有用于其他目的，我们实际上在使用图像之前不需要设置屏障。我们设置它来表示使用的变化，而不是使用本身。
- en: See also
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'See the following recipes in this chapter:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看以下食谱：
- en: '*Creating an image*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到图像*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新绑定设备本地内存的图像*'
- en: Creating an image view
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像视图
- en: Images are rarely used directly in Vulkan commands. Framebuffers and shaders
    (via descriptor sets) access images through image views. Image views define a
    selected part of an image's memory and specify additional information needed to
    properly read an image's data. That's why we need to know how to create an image
    view.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图像很少直接在Vulkan命令中使用。帧缓冲区和着色器（通过描述符集）通过图像视图访问图像。图像视图定义了图像内存的一部分，并指定了正确读取图像数据所需的其他信息。这就是为什么我们需要知道如何创建图像视图。
- en: How to do it...
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a logical device and use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄，并使用它来初始化一个名为`logical_device`的`VkDevice`类型的变量。
- en: Use the handle of a created image to initialize a variable of type `VkImage`
    named `image`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的图像的句柄来初始化一个名为`image`的`VkImage`类型的变量。
- en: 'Create a variable of type `VkImageViewCreateInfo` named `image_view_create_info`.
    Use the following values for its members:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_view_create_info`的`VkImageViewCreateInfo`类型的变量。为其成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO` value for `sType`'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO`值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`值用于`pNext`'
- en: '`0` value for `flags`'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`值用于`flags`'
- en: '`image` variable for `image`'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`变量用于`image`'
- en: Type of image view for `viewType`
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像视图的类型用于`viewType`
- en: Format of an image or other compatible format (if you want to reinterpret it
    inside the view) for `format`
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像或其他兼容格式（如果您想在视图中重新解释它）的格式用于`format`
- en: '`VK_COMPONENT_SWIZZLE_IDENTITY` value for all members of a `components` member'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_COMPONENT_SWIZZLE_IDENTITY`值用于`components`成员的所有成员'
- en: 'Use the following values for members of a `subresourceRange` member:'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下值作为`subresourceRange`成员的成员：
- en: Image's aspect (color, depth, or stencil) for `aspectMask`
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的方面（颜色、深度或模板）用于`aspectMask`
- en: '`0` value for `baseMipLevel`'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`值用于`baseMipLevel`'
- en: '`VK_REMAINING_MIP_LEVELS` value for `levelCount`'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_REMAINING_MIP_LEVELS`值用于`levelCount`'
- en: '`0` for `baseArrayLayer`'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`用于`baseArrayLayer`'
- en: '`VK_REMAINING_ARRAY_LAYERS` for `layerCount`'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_REMAINING_ARRAY_LAYERS`用于`layerCount`'
- en: Create a variable of type `VkImageView` named `image_view`. We will store a
    handle of a created image view in it.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_view`的`VkImageView`类型的变量。我们将存储创建的图像视图的句柄。
- en: Call `vkCreateImageView( logical_device, &image_view_create_info, nullptr, &image_view
    )`, for which provide the handle of the logical device, a pointer to the `image_view_create_info`
    variable, a `nullptr` value, and a pointer to the `image_view` variable.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateImageView(logical_device, &image_view_create_info, nullptr, &image_view)`，为它提供逻辑设备的句柄、`image_view_create_info`变量的指针、`nullptr`值和`image_view`变量的指针。
- en: Make sure the call was successful by comparing the returned value with the `VK_SUCCESS`
    value.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将返回值与`VK_SUCCESS`值进行比较，确保调用成功。
- en: How it works...
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Image view defines additional metadata used for accessing the image. Through
    it, we can specify the parts of an image that should be accessed by the commands.
    Though this recipe shows how to create an image view for the whole image data,
    it is possible to specify a smaller range of the resource which should be accessed.
    For example, when we render into an image inside a render pass, we can specify
    that only one mipmap level should be updated.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图定义了用于访问图像的附加元数据。通过它，我们可以指定命令应访问图像的哪些部分。尽管这个食谱展示了如何为整个图像数据创建图像视图，但也可以指定一个更小的资源范围，该范围应被访问。例如，当我们在一个渲染通道内渲染图像时，我们可以指定只更新一个mipmap级别。
- en: Image view also defines how an image's memory should be interpreted. A good
    example is an image with multiple layers. For it, we can define an image view
    that interprets the image directly, as a layered image, or we can use image view
    to create a cubemap from it.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图还定义了图像内存应该如何被解释。一个很好的例子是多层的图像。对于它，我们可以定义一个直接解释图像为分层图像的图像视图，或者我们可以使用图像视图从它创建一个立方体贴图。
- en: 'These parameters are specified like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数指定如下：
- en: '[PRE20]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The image view creation is performed through a single call of the `vkCreateImageView()`
    function. An example of such a call is shown here:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图的创建是通过 `vkCreateImageView()` 函数的单次调用来执行的。以下是一个此类调用的示例：
- en: '[PRE21]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See also
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating an image*'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Creating a 2D image and view*'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 2D 图像和视图*'
- en: '*Destroying an image view*'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像视图*'
- en: Creating a 2D image and view
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 2D 图像和视图
- en: The most common image type that is used in many popular applications or games
    is typical 2D textures with four RGBA components and 32 bits per texel. To create
    such a resource in Vulkan, we need to create a 2D image and a proper image view.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多流行的应用程序或游戏中使用的最常见图像类型是典型的具有四个 RGBA 分量和每 texel 32 位的 2D 纹理。要在 Vulkan 中创建此类资源，我们需要创建一个
    2D 图像和一个合适的图像视图。
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take a handle of a logical device and use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个逻辑设备句柄并使用它来初始化一个名为 `logical_device` 的 `VkDevice` 类型的变量。
- en: Select the data format used in the image and initialize a variable of type `VkFormat`
    named `format` with the selected value.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像中使用的数据格式，并使用所选值初始化一个名为 `format` 的 `VkFormat` 类型的变量。
- en: Choose the size of the image. Store it in a variable of type `VkExtent2D` named
    `size`.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像的大小。将其存储在一个名为 `size` 的 `VkExtent2D` 类型的变量中。
- en: Choose the number of mipmap levels that should compose the image. Initialize
    a variable of type `uint32_t` named `num_mipmaps` with the selected number of
    mipmaps.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择应组成图像的 mipmap 级数数量。使用所选的 mipmap 数量初始化一个名为 `num_mipmaps` 的 `uint32_t` 类型的变量。
- en: Specify the number of image layers using a variable of type `uint32_t` named
    `num_layers`.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个名为 `num_layers` 的 `uint32_t` 类型的变量指定图像层数。
- en: Select the number of per texel samples and store it in a variable of type `VkSampleCountFlagBits`
    named `samples`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每 texel 样本的数量，并将其存储在一个名为 `samples` 的 `VkSampleCountFlagBits` 类型的变量中。
- en: Think of all the purposes for which the image will be used in the application.
    Store the value that is a logical sum (**OR**) of all these usages in a variable
    of type `VkImageUsageFlags` named `usage`.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑图像在应用程序中将用于的所有目的。将这些用途的逻辑和（**或**）存储在一个名为 `usage` 的 `VkImageUsageFlags` 类型的变量中。
- en: Create an image of `VK_IMAGE_TYPE_2D` type using the `logical_device`, `format`,
    `size`, `num_mipmaps`, `num_layers`, `samples`, and `usage` variables. Store the
    handle of the created image in a variable of type `VkImage` named `image` (refer
    to the *Creating an image* recipe).
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device`、`format`、`size`、`num_mipmaps`、`num_layers`、`samples` 和 `usage`
    变量创建一个 `VK_IMAGE_TYPE_2D` 类型的图像。将创建的图像句柄存储在一个名为 `image` 的 `VkImage` 类型的变量中（参考
    *创建图像* 食谱）。
- en: Take the handle of a physical device from which the `logical_device` handle
    was acquired. Store the physical device's handle in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从获取 `logical_device` 处理器的物理设备中获取句柄。将物理设备的句柄存储在一个名为 `physical_device` 的 `VkPhysicalDevice`
    类型的变量中。
- en: Acquire the memory properties of the `physical_device` and use them to allocate
    a memory object that will be bound to an image represented by the `image` variable.
    Make sure a memory type with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    is used. Store the allocated memory object in a variable of type `VkDeviceMemory`
    named `memory_object` (refer to the *Allocating and binding memory object to an
    image* recipe).
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `physical_device` 的内存属性，并使用它们来分配一个将绑定到由 `image` 变量表示的图像的内存对象。确保使用具有 `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`
    属性的内存类型。将分配的内存对象存储在一个名为 `memory_object` 的 `VkDeviceMemory` 类型的变量中（参考 *分配和绑定内存对象到图像*
    食谱）。
- en: Select the image's aspect used for the image view creation (color or depth and/or
    stencil) and store it in a variable of type `VkImageAspectFlags` named `aspect`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用于创建图像视图的图像的方面（颜色或深度和/或模板）并将其存储在一个名为 `aspect` 的 `VkImageAspectFlags` 类型的变量中。
- en: Create an image view of a `VK_IMAGE_VIEW_TYPE_2D` type. Use the `logical_device`,
    `image`, `format`, and `aspect` variables during image view creation. Store the
    created handle in a variable of type `VkImageView` named `image_view` (refer to
    the *Creating an image view* recipe).
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `VK_IMAGE_VIEW_TYPE_2D` 类型的图像视图。在创建图像视图时使用 `logical_device`、`image`、`format`
    和 `aspect` 变量。将创建的句柄存储在一个名为 `image_view` 的 `VkImageView` 类型的变量中（参考 *创建图像视图* 食谱）。
- en: How it works...
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Image creation requires us to perform three general steps:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图像创建需要我们执行三个一般步骤：
- en: Create an image.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图像。
- en: Create a memory object (or use an existing one) and bind it to the image.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个内存对象（或使用现有的一个）并将其绑定到图像。
- en: Create an image view.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图像视图。
- en: For an image typically used as a texture, we need to create an image of the
    type `VK_IMAGE_TYPE_2D` and the format `VK_FORMAT_R8G8B8A8_UNORM`, but we can
    set these parameters as we want. The rest of the image's properties depend on
    the size of the image (in other words, we are creating a texture from an existing
    image file and we need to match its dimensions), the type of filtering that should
    applied to an image (if we want to use mipmapping), the number of samples (if
    it should be multisampled), and the desired usage scenarios.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通常用作纹理的图像，我们需要创建一个类型为`VK_IMAGE_TYPE_2D`和格式为`VK_FORMAT_R8G8B8A8_UNORM`的图像，但我们可以根据需要设置这些参数。图像的其余属性取决于图像的大小（换句话说，我们正在从现有的图像文件创建纹理，我们需要匹配其尺寸），应用于图像的过滤类型（如果我们想使用米级贴图），样本数（如果它应该是多采样），以及所需的用法场景。
- en: 'Image creation defined in the *Creating an image* recipe can be simplified
    to the following code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建图像*的说明中定义的图像创建可以简化为以下代码：
- en: '[PRE22]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to allocate and bind a memory object to the image as described
    in the *Allocating and binding a memory object to an image* recipe. For the best
    performance, the memory object should be allocated on a fast, **device-local**
    memory like this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要按照*将内存对象分配和绑定到图像*的说明将内存对象分配并绑定到图像上。为了获得最佳性能，内存对象应该分配在快速、**设备本地**的内存上，如下所示：
- en: '[PRE23]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can of course use an existing memory object if it fulfills the image's memory
    requirements and has enough storage.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有的内存对象满足图像的内存要求并且有足够的存储空间，我们当然可以使用它。
- en: 'After that, we must create an image view. With it, we can tell the hardware
    how the image data should be interpreted. We can also use a different (but still
    compatible) format for an image view. But for many (if not most) purposes, it
    is not necessary and we will specify the same format that was used for the image.
    For standard 2D textures, we also use a color aspect for view creation, but for
    images with depth data (in other words, for images used as depth attachments),
    depth aspect must be specified. For more details on image view creation, follow
    the *Creating an image view* recipe:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们必须创建一个图像视图。有了它，我们可以告诉硬件如何解释图像数据。我们还可以为图像视图使用不同的（但仍然兼容）格式。但对于许多（如果不是大多数）用途，这并不是必要的，我们将指定与图像相同的格式。对于标准的2D纹理，我们也在创建视图时使用颜色方面，但对于具有深度数据的图像（换句话说，用于深度附件的图像），必须指定深度方面。有关图像视图创建的更多详细信息，请参阅*创建图像视图*的说明：
- en: '[PRE24]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, the image is ready to be used in our application. We can upload data from
    a file to the image and use it as a texture inside shaders (in this case, we also
    need a sampler and descriptor sets). We can also bind the image's view to a framebuffer
    and use it as a color attachment (render target).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图像已准备好在我们的应用程序中使用。我们可以从文件上传数据到图像，并在着色器（在这种情况下，我们还需要一个采样器和描述符集）内部将其用作纹理。我们还可以将图像视图绑定到帧缓冲区，并将其用作颜色附件（渲染目标）。
- en: See also
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下说明：
- en: '*Creating an image*'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象分配和绑定到图像*'
- en: '*Creating an image view*'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像视图*'
- en: '*Destroying an image view*'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像视图*'
- en: '*Destroying an image*'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像*'
- en: '*Freeing a memory object*'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: Creating a layered 2D image with a CUBEMAP view
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有CUBEMAP视图的分层2D图像
- en: A quite common example of images used in 3D applications or games are CUBEMAPs,
    used for simulating an object reflecting its environment. For this purpose, we
    don't create a CUBEMAP image. We need to create a layered image and through image
    view, we tell the hardware that it should interpret its layers as six CUBEMAP
    faces.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D应用程序或游戏中使用的图像的一个相当常见的例子是CUBEMAPs，用于模拟对象反射其环境。为此目的，我们不创建CUBEMAP图像。我们需要创建一个分层图像，并通过图像视图告诉硬件它应该将其层解释为六个CUBEMAP面。
- en: How to do it...
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take a handle of a logical device. Store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄。将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Choose the size of an image and remember it must be square. Save the image's
    dimensions in a variable of type `uint32_t` named `size`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像的大小，并记住它必须是正方形。将图像的尺寸保存到名为`size`的`uint32_t`类型变量中。
- en: Select the number of the image's mipmap levels. Initialize a variable of type
    `uint32_t` named `num_mipmaps` with the chosen number.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图像的米级贴图级别数量。将名为`num_mipmaps`的`uint32_t`类型变量初始化为所选的数量。
- en: Think about all different scenarios in which the image will be used. Store the
    logical sum (OR) of all these usages in a variable of type `VkImageUsageFlags`
    named `usage`.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑所有不同的场景，在这些场景中，图像将被使用。将这些使用的逻辑和（OR）存储在名为`usage`的`VkImageUsageFlags`类型变量中。
- en: Create an image of a `VK_IMAGE_TYPE_2D` type, a `VK_FORMAT_R8G8B8A8_UNORM` format,
    six layers, and one sample per texel. Use the `logical_device`, `size`, `num_mipmaps`,
    and `usage` variables for the rest of the image parameters. Store the handle of
    the created image in a variable of type `VkImage` named `image` (refer to the
    *Creating an image* recipe).
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`VK_IMAGE_TYPE_2D`类型、`VK_FORMAT_R8G8B8A8_UNORM`格式、六个层和一个texel每个样本的图像。使用`logical_device`、`size`、`num_mipmaps`和`usage`变量设置其余图像参数。将创建的图像句柄存储在名为`image`的`VkImage`类型变量中（参考*创建图像*配方）。
- en: Take the handle of the physical device from which the `logical_device` handle
    was acquired. Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从获取`logical_device`句柄的物理设备中获取句柄。将其存储在名为`physical_device`的`VkPhysicalDevice`类型变量中。
- en: Acquire the memory properties of a `physical_device`. Use them to allocate a
    memory object using a memory type with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`
    property. Store the handle of the allocated memory object in a variable of type
    `VkDeviceMemory` named `memory_object`, and bind it to the image (refer to the
    *Allocating and binding a memory object to an image* recipe).
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`physical_device`的内存属性。使用具有`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`属性的内存类型来分配内存对象。将分配的内存对象的句柄存储在名为`memory_object`的`VkDeviceMemory`类型变量中，并将其绑定到图像（参考*将内存对象绑定到图像上*配方）。
- en: Select the color aspect and store it in a variable of a `VkImageAspectFlags`
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择颜色方面并将其存储在一个`VkImageAspectFlags`类型的变量中
- en: type named `aspect`.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型名为`aspect`。
- en: Create an image view of a `VK_IMAGE_VIEW_TYPE_CUBE` type and a `VK_FORMAT_R8G8B8A8_UNORM`
    format. Use the `logical_device`, `image`, and `aspect` variables during image
    view creation. Store the created handle in a variable of type `VkImageView` named
    `image_view` (refer to the *Creating an image view* recipe).
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`VK_IMAGE_VIEW_TYPE_CUBE`类型和`VK_FORMAT_R8G8B8A8_UNORM`格式的图像视图。在创建图像视图时使用`logical_device`、`image`和`aspect`变量。将创建的句柄存储在名为`image_view`的`VkImageView`类型变量中（参考*创建图像视图*配方）。
- en: How it works...
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The process of creating a CUBEMAP is very similar to creating any other type
    of images. First, we create the image itself. We just need to remember that the
    image should have at least six layers that will be interpreted as six CUBEMAP
    faces. For CUBEMAPs, we also cannot use more than one sample per texel:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CUBEMAP的过程与创建任何其他类型的图像非常相似。首先，我们创建图像本身。我们只需记住图像应该至少有六个层，这些层将被解释为六个CUBEMAP面。对于CUBEMAP，我们也不能在每个texel上使用超过一个样本：
- en: '[PRE25]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we allocate and bind a memory object in the same way as for other resources:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以与其他资源相同的方式分配和绑定一个内存对象：
- en: '[PRE26]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we need to create an image view. Through it, we specify a CUBEMAP
    view type:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个图像视图。通过它，我们指定CUBEMAP视图类型：
- en: '[PRE27]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When using a CUBEMAP image view, image layers correspond to faces in the order
    +X, -X, +Y, -Y, +Z, and -Z.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CUBEMAP图像视图时，图像层按照顺序对应于+X、-X、+Y、-Y、+Z和-Z的各个面。
- en: See also
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating an image*'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象绑定到图像上*'
- en: '*Creating an image view*'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像视图*'
- en: '*Destroying an image view*'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像视图*'
- en: '*Destroying an image*'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像*'
- en: '*Freeing a memory object*'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: Mapping, updating and unmapping host-visible memory
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射、更新和取消映射主机可见内存
- en: For images and buffers that are used during rendering, it is recommended to
    bind a memory that is located on the graphics hardware (**device-local** memory).
    This gives us the best performance. But we can't access such memory directly,
    and we need to use intermediate (staging) resources which mediate the data transfer
    between a GPU (device) and a CPU (host).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在渲染过程中使用的图像和缓冲区，建议绑定位于图形硬件上的内存（**设备本地**内存）。这给我们提供了最佳性能。但我们不能直接访问此类内存，我们需要使用中间（准备）资源，这些资源在GPU（设备）和CPU（主机）之间介导数据传输。
- en: '**Staging resources**, on the other hand, need to use memory that is **host-visible**.
    To upload data to such memory, or to read data from it, we need to map it.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**准备资源**，另一方面，需要使用**主机可见**的内存。要将数据上传到此类内存或从中读取数据，我们需要将其映射。'
- en: How to do it...
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a created logical device and store it in a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的逻辑设备的句柄，并将其存储在一个名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Select a memory object that was allocated on a memory type with a `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`
    property. Store the memory object's handle in a variable of type `VkDeviceMemory`
    named `memory_object`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个在具有 `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` 属性的内存类型上分配的内存对象。将内存对象的句柄存储在一个名为
    `memory_object` 的 `VkDeviceMemory` 类型的变量中。
- en: Choose a memory region that should be mapped and updated. Store the offset (in
    bytes) from the beginning of a memory object's memory in a variable of type `VkDeviceSize`
    named `offset`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个应该被映射和更新的内存区域。将内存对象内存的起始偏移量（以字节为单位）存储在一个名为 `offset` 的 `VkDeviceSize` 类型的变量中。
- en: Select the size of data to be copied to the selected region of the memory object.
    Represent the data size with a variable of type `VkDeviceSize` named `data_size`.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要复制到所选内存对象区域的数据大小。使用一个名为 `data_size` 的 `VkDeviceSize` 类型的变量表示数据大小。
- en: Prepare data that should be copied to the memory object. Set up a pointer to
    the beginning of the data and use it to initialize a variable of type `void*`
    named `data`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备要复制到内存对象中的数据。设置一个指向数据开始的指针，并使用它来初始化一个名为 `data` 的 `void*` 类型的变量。
- en: Create a variable of type `void*` named `pointer`. It will contain a pointer
    to the mapped memory range.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pointer` 的 `void*` 类型的变量。它将包含指向映射内存范围的指针。
- en: Map the memory with a `vkMapMemory( logical_device, memory_object, offset, data_size,
    0, &local_pointer )` call. Provide handles of the logical device and the memory
    object, offset from the start of the memory and the size (in bytes) of the region
    we want to map, a `0` value, and a pointer to the `pointer` variable.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `vkMapMemory( logical_device, memory_object, offset, data_size, 0, &local_pointer
    )` 调用映射内存。提供逻辑设备和内存对象的句柄、从开始处的偏移量以及我们想要映射的区域的大小（以字节为单位）、一个 `0` 值以及指向 `pointer`
    变量的指针。
- en: Make sure the call was successful by checking whether the returned value was
    equal to `VK_SUCCESS`.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用成功，通过检查返回值是否等于 `VK_SUCCESS`。
- en: 'Copy the prepared data to the memory pointed to by the `pointer` variable.
    It can be done with the following call: `std::memcpy( local_pointer, data, data_size
    )`.'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将准备好的数据复制到由 `pointer` 变量指向的内存中。可以使用以下调用完成：`std::memcpy( local_pointer, data,
    data_size )`。
- en: 'Create a variable of type `std::vector<VkMappedMemoryRange>` named `memory_ranges`.
    For each modified range, add an element to the vector and use the following values
    to initialize its members:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `memory_ranges` 的 `std::vector<VkMappedMemoryRange>` 类型的变量。对于每个修改的范围，向向量中添加一个元素，并使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE` value for `sType`'
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`'
- en: '`memory_object` variable for `memory`'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory` 的 `memory_object` 变量'
- en: Offset of each range for `offset`
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个范围的偏移量用于 `offset`
- en: Size of each range for `size`
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个范围的尺寸用于 `size`
- en: Inform the driver which parts of the memory have changed. Do this by making
    the `vkFlushMappedMemoryRanges( logical_device, static_cast<uint32_t>(memory_ranges.size()),
    &memory_ranges[0] )` call, for which provide the `logical_device` variable, the
    number of modified ranges (elements in the `memory_ranges` vector), and a pointer
    to the first element of the `memory_ranges` vector.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知驱动程序哪些内存部分已更改。通过调用 `vkFlushMappedMemoryRanges( logical_device, static_cast<uint32_t>(memory_ranges.size()),
    &memory_ranges[0] )` 来完成此操作，并提供 `logical_device` 变量、修改的范围数量（`memory_ranges` 向量中的元素数量）以及
    `memory_ranges` 向量第一个元素的指针。
- en: Make sure the flushing was successful and the call returned a `VK_SUCCESS` value.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保刷新成功，并且调用返回了 `VK_SUCCESS` 值。
- en: To unmap the memory, call `vkUnmapMemory( logical_device, memory_object )`.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要取消映射内存，调用 `vkUnmapMemory( logical_device, memory_object )`。
- en: How it works...
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Mapping the memory is the simplest way to upload data to the Vulkan resources.
    During the mapping, we specify which part of the memory should be mapped (offset
    from the beginning of the memory object and a size of the mapped range):'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 映射内存是将数据上传到 Vulkan 资源的最简单方法。在映射过程中，我们指定应该映射内存的哪一部分（从内存对象开始的偏移量和映射范围的尺寸）：
- en: '[PRE28]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Mapping gives us a pointer to the requested memory part. We can use this pointer
    like we use other pointers in typical C++ applications. There are no restrictions
    on whether we write or read data from such memory. In this recipe, we copy data
    from the application to the memory object:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 映射为我们提供了请求的内存部分的指针。我们可以像在典型的 C++ 应用程序中使用其他指针一样使用这个指针。在写入或从此类内存读取数据方面没有限制。在这个菜谱中，我们从应用程序复制数据到内存对象：
- en: '[PRE29]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we update the mapped memory range, we need to inform the driver that memory
    contents were modified or the uploaded data may not immediately become visible
    for other operations submitted to queues. Informing about the memory data modifications
    performed by the CPU (host) is called flushing. For this, we prepare a list of
    updated memory ranges which don''t need to cover the whole mapped memory:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新映射的内存范围时，我们需要通知驱动程序内存内容已被修改，或者上传的数据可能不会立即对提交到队列的其他操作可见。通知 CPU（主机）执行的内存数据修改操作称为刷新。为此，我们准备一个更新内存范围的列表，该列表不需要覆盖整个映射内存：
- en: '[PRE30]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After we are done dealing with a mapped memory, we can unmap it. Memory mapping
    shouldn''t influence the performance of our application and we can keep the acquired
    pointer for the whole lifetime of our application. But, we should release it (unmap)
    before we close the application and destroy all resources:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成处理映射内存后，我们可以取消映射它。内存映射不应影响我们应用程序的性能，并且我们可以保留获取的指针，直到我们应用程序的整个生命周期。但是，在关闭应用程序和销毁所有资源之前，我们应该释放它（取消映射）：
- en: '[PRE31]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以下配方：
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配并绑定内存对象到缓冲区*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配并绑定内存对象到图像*'
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新与设备本地内存绑定的缓冲区*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新与设备本地内存绑定的图像*'
- en: '*Freeing a memory object*'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: Copying data between buffers
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在缓冲区之间复制数据
- en: In Vulkan, to upload data to a buffer, we are not limited only to the memory
    mapping technique. It is possible to copy data between buffers, even if the memory
    objects bound to them were allocated from different memory types.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，上传数据到缓冲区不仅限于内存映射技术。可以在不同内存类型分配的内存对象之间复制数据。
- en: How to do it...
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a command buffer. Store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state
    (refer to the *Beginning a command buffer recording operation* recipe from [Chapter
    3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and Synchronization*).
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区的句柄。将其存储在名为 `command_buffer` 的类型为 `VkCommandBuffer` 的变量中。确保命令缓冲区处于记录状态（参考第
    3 章 *开始命令缓冲区记录操作* 的配方，*命令缓冲区和同步*）。
- en: Take the buffer from which data will be copied. Represent this buffer with a
    variable of type `VkBuffer` named `source_buffer`.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从将要复制数据的缓冲区中取出。使用名为 `source_buffer` 的类型为 `VkBuffer` 的变量来表示此缓冲区。
- en: Take the buffer to which data will be uploaded. Represent this buffer using
    a variable of type `VkBuffer` named `destination_buffer`.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从将要上传数据的缓冲区中取出。使用名为 `destination_buffer` 的类型为 `VkBuffer` 的变量来表示此缓冲区。
- en: Create a variable of type `std::vector<VkBufferCopy>` named `regions`. For each
    memory region from which data should be copied, add an element to the `regions`
    vector. In each element, specify the memory offset in the source buffer from which
    data should be copied, a memory offset in the target buffer to which data should
    be copied, and the size of data to be copied from a given region.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regions` 的类型为 `std::vector<VkBufferCopy>` 的变量。对于应该从中复制数据的每个内存区域，向 `regions`
    向量中添加一个元素。在每个元素中，指定从源缓冲区中复制数据的内存偏移量、要复制到目标缓冲区的内存偏移量以及从给定区域复制的数据大小。
- en: Call `vkCmdCopyBuffer( command_buffer, source_buffer, destination_buffer, static_cast<uint32_t>(regions.size()),
    &regions[0] )`, for which use the `command_buffer`, `source_buffer` and `destination_buffer`
    variables, the number of elements in the `regions` vector, and a pointer to the
    first element of that vector.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdCopyBuffer(command_buffer, source_buffer, destination_buffer, static_cast<uint32_t>(regions.size()),
    &regions[0])`，其中使用 `command_buffer`、`source_buffer` 和 `destination_buffer` 变量、`regions`
    向量中的元素数量以及该向量第一个元素的指针。
- en: How it works...
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copying data between buffers is another way of updating the memory contents
    of a given resource. This operation needs to be recorded to the command buffer,
    like this:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区之间复制数据是更新给定资源内存内容的一种另一种方式。此操作需要记录到命令缓冲区中，如下所示：
- en: '[PRE32]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For the best performance, resources that are used during rendering should have
    a device-local memory bound. But, we can't map such memory. Using the `vkCmdCopyBuffer()`
    function, we can copy data to such a buffer from another buffer that has a host-visible
    memory bound to it. Such memory can be mapped and updated directly from our application.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，在渲染期间使用的资源应该具有设备本地内存绑定。但是，我们不能映射此类内存。使用 `vkCmdCopyBuffer()` 函数，我们可以从具有主机可见内存绑定的另一个缓冲区将数据复制到此类缓冲区。此类内存可以直接从我们的应用程序映射和更新。
- en: Buffers from which data can be copied must be created with a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    usage.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从其中复制数据的缓冲区必须使用 `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` 用法创建。
- en: Buffers into which we transfer data must be created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    usage.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `VK_BUFFER_USAGE_TRANSFER_DST_BIT` 用法创建用于传输数据的缓冲区。
- en: When we want to use a buffer as a target for transfer operations (we want to
    copy data to the buffer), we should set a memory barrier that will inform the
    driver that from now on, operations performed on the buffer are represented by
    a `VK_ACCESS_TRANSFER_WRITE_BIT` memory access scheme. After we are done copying
    data to the destination buffer and we want to use it for the desired purpose,
    we should set another memory barrier. This time, we should specify that previously
    we were transferring data to the buffer (so the operations were represented by
    the `VK_ACCESS_TRANSFER_WRITE_BIT` memory access type), but after the barrier
    the buffer will be used differently, with another memory access type representing
    operations performed on it (refer to the *Setting a buffer memory barrier* recipe).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将缓冲区用作传输操作的目标（我们想要将数据复制到缓冲区）时，我们应该设置一个内存屏障，告知驱动程序从现在开始，在缓冲区上执行的操作将由 `VK_ACCESS_TRANSFER_WRITE_BIT`
    内存访问方案表示。在将数据复制到目标缓冲区并完成复制后，我们想要使用它来完成所需的目的，我们应该设置另一个内存屏障。这次，我们应该指定之前我们正在将数据传输到缓冲区（因此操作由
    `VK_ACCESS_TRANSFER_WRITE_BIT` 内存访问类型表示），但在屏障之后，缓冲区将以不同的方式使用，使用另一个内存访问类型来表示对其执行的操作（参考
    *设置缓冲区内存屏障* 菜谱）。
- en: See also
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下菜谱：
- en: '*Creating a buffer*'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Setting a buffer memory barrier*'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置缓冲区内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新设备本地内存绑定的缓冲区*'
- en: Copying data from a buffer to an image
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从缓冲区复制数据到图像
- en: For images, we can bind memory objects that are allocated from different memory
    types. Only host-visible memory can be mapped and updated directly from our application.
    When we want to update the memory of an image that uses a device-local memory,
    we need to copy data from a buffer.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像，我们可以绑定从不同内存类型分配的内存对象。只有主机可见内存可以直接从我们的应用程序映射和更新。当我们想要更新使用设备本地内存的图像的内存时，我们需要从缓冲区复制数据。
- en: How to do it...
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is already in a recording
    state (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出命令缓冲区的句柄，并将其存储在一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量中。确保命令缓冲区已经处于记录状态（参考第
    3 章 *命令缓冲区和同步* 中的 *开始命令缓冲区记录操作* 菜谱）。
- en: Take a buffer from which data will be copied. Store its handle in a variable
    of type `VkBuffer` named `source_buffer`.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出一个将要复制数据的缓冲区。将其句柄存储在一个名为 `source_buffer` 的 `VkBuffer` 类型的变量中。
- en: Take the image to which data will be copied. Represent this image with a variable
    of type `VkImage` named `destination_image`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出将要复制数据的图像。使用一个名为 `destination_image` 的 `VkImage` 类型的变量来表示这个图像。
- en: Create a variable of type `VkImageLayout` named `image_layout`, in which the
    image's current layout will be stored.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `image_layout` 的 `VkImageLayout` 类型的变量，用于存储图像的当前布局。
- en: 'Create a variable of type `std::vector<VkBufferImageCopy>` named `regions`.
    For each memory region from which data should be copied, add an element to the
    `regions` vector. Specify the following values for members of each element:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regions` 的 `std::vector<VkBufferImageCopy>` 类型的变量。对于应该从中复制数据的每个内存区域，向
    `regions` 向量添加一个元素。为每个元素的成员指定以下值：
- en: Offset from the beginning of a buffer's memory from which data should be copied
    for `bufferOffset`.
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区内存的起始位置偏移量，从该位置复制数据到 `bufferOffset`。
- en: The length of data that represents a single row in the buffer or a `0` value
    if the data is tightly packed (according to the size of the destination image)
    for `bufferRowLength`.
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区中代表单行数据的长度，或者如果数据紧密打包（根据目标图像的大小）则为`0`值，对于`bufferRowLength`。
- en: The height of the imaginary image stored in the buffer or a `0` value if the
    buffer's data is tightly packed (according to the size of the destination image)
    for `bufferImageHeight`.
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区中存储的虚拟图像的高度或如果缓冲区数据紧密打包（根据目标图像的大小）则为`0`值，对于`bufferImageHeight`。
- en: 'Initialize the `imageSubresource` member with the following values:'
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下值初始化`imageSubresource`成员：
- en: Image's aspect (color, depth or stencil) for `aspectMask`
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的方面（颜色、深度或模板），对于`aspectMask`。
- en: Number (index) of mipmap level to be updated for `mipLevel`
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更新的mipmap级别的数量（索引），对于`mipLevel`。
- en: Number of the first array layer to be updated for `baseArrayLayer`
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更新的第一个数组层的编号，对于`baseArrayLayer`。
- en: Number of array layers that will be updated for `layerCount`
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更新的数组层数量，对于`layerCount`。
- en: Initial offset (in texels) of image's sub region that should be updated for
    `imageOffset`
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像子区域初始偏移量（以texels为单位），该子区域应更新为`imageOffset`。
- en: The size (dimensions) of an image for `imageExtent`
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的大小（维度），对于`imageExtent`。
- en: Call `vkCmdCopyBufferToImage( command_buffer, source_buffer, destination_image,
    image_layout, static_cast<uint32_t>(regions.size()), &regions[0] )`, for which
    use the `command_buffer`, `source_buffer`, `destination_image` and `image_layout`
    variables, the number of elements in the `regions` vector, and a pointer to the
    first element of that vector.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdCopyBufferToImage(command_buffer, source_buffer, destination_image,
    image_layout, static_cast<uint32_t>(regions.size()), &regions[0])`，其中使用`command_buffer`、`source_buffer`、`destination_image`和`image_layout`变量，`regions`向量的元素数量，以及该向量第一个元素的指针。
- en: How it works...
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copying data between a buffer and an image is done through a command buffer,
    in which we record the following operation:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令缓冲区中通过命令执行缓冲区在缓冲区和图像之间复制数据，其中我们记录以下操作：
- en: '[PRE33]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We need to know how the image data is laid out inside the buffer, so the image's
    memory is properly uploaded. We need to provide a memory offset (from the beginning
    of the buffer's memory), the length of the data row, and the height of the data
    in a buffer. This allows the driver to properly address the memory and copy the
    buffer's contents into the image. We can also provide zeros for row length and
    a height, which means that the buffer contains data that is tightly packed and
    it corresponds to the destination image's dimensions.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道图像数据在缓冲区内的布局，以便正确上传图像的内存。我们需要提供内存偏移量（从缓冲区内存的起始位置），数据行长度和数据在缓冲区中的高度。这允许驱动程序正确地寻址内存并将缓冲区的内容复制到图像中。我们还可以提供行长度和高度为零，这意味着缓冲区包含紧密打包的数据，并且与目标图像的维度相对应。
- en: We also need to provide information about the destination of a data transfer
    operation. This involves defining an offset from the image's origin (from the
    upper-left corner in texels) for x, y, and z dimensions, the mipmap level into
    which data will be copied and a base array layer, and the number of layers that
    will be updated. We also need to specify the destination image's dimensions.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供有关数据传输操作目标的信息。这涉及到定义从图像原点（以texels为单位从左上角开始）的x、y和z维度的偏移量，数据将要复制到的mipmap级别和基本数组层，以及要更新的层数量。我们还需要指定目标图像的维度。
- en: All the preceding parameters are specified through an array of `VkBufferImageCopy`
    elements. We can provide many regions at once and copy memory ranges that are
    not continuous.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个参数都是通过`VkBufferImageCopy`元素数组指定的。我们可以一次性提供多个区域，并复制非连续的内存范围。
- en: On hardware architectures with several different memory types exposed by a physical
    device, it is recommended to use a device-local-only memory for resources that
    are used during rendering (performance-critical paths of our application). Such
    memory is usually faster than the memory that is also host-visible. Host-visible
    memory should be used only for staging resources which are used to upload data
    from, or download data to, the CPU (our application).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在由物理设备暴露的多个不同内存类型的硬件架构上，建议仅使用设备本地内存来存储在渲染过程中使用的资源（我们应用程序的性能关键路径）。这种内存通常比同时可见于主机的内存更快。仅应为主机可见内存使用阶段资源，这些资源用于从CPU上传数据或向CPU下载数据（我们的应用程序）。
- en: On architectures with only one memory type that is both device-local and host-visible,
    we don't need to bother with intermediate staging resources for data upload. But,
    the presented approach is still valid and may unify the application's behavior
    across different execution environments. This may make maintenance of our application
    easier.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一种既是设备本地又是主机可见的内存类型的架构上，我们不需要为数据上传而烦恼中间阶段资源。但是，所提出的方法仍然有效，并且可能在不同执行环境中统一应用程序的行为。这可能会使我们的应用程序维护更容易。
- en: In both cases, we can easily map the staging resource's memory and access it
    in our application. Next we can use it to transfer data to and from a device-local
    memory, which (generally) cannot be mapped. This is achieved with the copy operation
    described in this recipe.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们可以轻松地将阶段资源的内存进行映射，并在我们的应用程序中访问它。接下来，我们可以使用它将数据从设备本地内存传输到和从它，这（通常）不能进行映射。这是通过本食谱中描述的复制操作实现的。
- en: Buffers from which data can be copied must be created with a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    usage.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从中复制数据的缓冲区必须使用具有 `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` 用法的创建。
- en: Images into which we transfer data must be created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    usage. Before the transfer operation, we also need to transition the image layout
    to a `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据传输到其中的图像必须使用具有 `VK_BUFFER_USAGE_TRANSFER_DST_BIT` 用法的创建。在传输操作之前，我们还需要将图像布局转换为
    `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`。
- en: Before we can transfer data to an image, we must change its memory layout. We
    can only copy data to an image whose current memory layout is set to `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`.
    We can also use a `VK_IMAGE_LAYOUT_GENERAL` layout, but it is not recommended
    due to lower performance.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将数据传输到图像之前，我们必须更改其内存布局。我们只能将数据复制到当前内存布局设置为 `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
    的图像。我们也可以使用 `VK_IMAGE_LAYOUT_GENERAL` 布局，但由于性能较低，不推荐这样做。
- en: So before we can copy data to an image, we should set a memory barrier that
    will change the image's memory access type from the one that occurred so far to
    a `VK_ACCESS_TRANSFER_WRITE_BIT`. The barrier should also perform a layout transition
    from the current layout to the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` layout.
    After we are done copying data to the image and we want to use it for other purposes,
    we should set another memory barrier. This time, we should change the memory access
    type from `VK_ACCESS_TRANSFER_WRITE_BIT` to the access that corresponds to the
    purpose for which the image will be used. And we should also transition the image's
    layout from `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` to the one that is compatible
    with the image's next usage (refer to the *Setting an image memory barrier* recipe).
    Without these barriers, not only might the data transfer operation be invalid,
    but the data might not become visible for other operations performed on the image.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们能够将数据复制到图像之前，我们应该设置一个内存屏障，该屏障将图像的内存访问类型从迄今为止发生的类型更改为 `VK_ACCESS_TRANSFER_WRITE_BIT`。屏障还应执行从当前布局到
    `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` 布局的布局转换。在我们完成将数据复制到图像并希望将其用于其他目的之后，我们应该设置另一个内存屏障。这次，我们应该将内存访问类型从
    `VK_ACCESS_TRANSFER_WRITE_BIT` 更改为与图像将用于的目的相对应的访问类型。我们还应该将图像的布局从 `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
    转换为与图像的下一个使用兼容的布局（参考 *设置图像内存屏障* 食谱）。如果没有这些屏障，数据传输操作可能无效，而且数据可能不会对图像上执行的其他操作可见。
- en: If the buffer that is a source of data is used for other purposes, we should
    also set a memory barrier for it and perform similar memory access changes before
    and after the transfer operation. But as the buffer is a source of data, we set
    a `VK_ACCESS_TRANSFER_READ_BIT` access type in the first barrier. It can be done
    with the same pipeline barriers which changed the parameters of the image. Refer
    to the *Setting a buffer memory barrier* recipe for more details.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用作数据源的数据缓冲区用于其他目的，我们还应该为它设置一个内存屏障，并在传输操作前后执行类似的内存访问更改。但是，由于缓冲区是数据源，我们在第一个屏障中设置
    `VK_ACCESS_TRANSFER_READ_BIT` 访问类型。可以使用与更改图像参数相同的管道屏障来完成。有关更多详细信息，请参阅 *设置缓冲区内存屏障*
    食谱。
- en: See also
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a buffer*'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Setting a buffer memory barrier*'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置缓冲区内存屏障*'
- en: '*Creating an image*'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到图像*'
- en: '*Setting an image memory barrier*'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Copying data from an image to a buffer*'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从图像到缓冲区的数据复制*'
- en: Copying data from an image to a buffer
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像到缓冲区的数据复制
- en: In Vulkan, we can not only transfer data from a buffer to an image, but also
    the other way--we can copy data from an image to the buffer. It doesn't matter
    what the properties of memory objects bound to them are. But, the data copy operation
    is the only way to update a device-local memory which cannot be mapped.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，我们不仅可以从缓冲区传输数据到图像，还可以反过来--我们可以从图像复制数据到缓冲区。不管绑定到它们上的内存对象的属性是什么。但是，数据复制操作是唯一一种更新无法映射的设备本地内存的方法。
- en: How to do it...
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is already in a recording
    state (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个命令缓冲区的句柄并将其存储在名为 `command_buffer` 的 `VkCommandBuffer` 类型变量中。确保命令缓冲区已经处于记录状态（参考第
    3 章 *命令缓冲区和同步* 中的 *开始命令缓冲区记录操作* 菜谱 [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)）。
- en: Take an image from which data will be copied. Store its handle in a variable
    of type `VkImage` named `source_image`.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个将要复制数据的图像。将其句柄存储在名为 `source_image` 的 `VkImage` 类型变量中。
- en: Take the source image's current memory layout and use it to initialize a variable
    of type `VkImageLayout` named `image_layout`.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到源图像的当前内存布局并使用它来初始化一个名为 `image_layout` 的 `VkImageLayout` 类型的变量。
- en: Take the buffer to which data will be copied. Prepare its handle in a variable
    of type `VkBuffer` named `destination_buffer`.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到将要复制数据的缓冲区。在名为 `destination_buffer` 的 `VkBuffer` 类型变量中准备其句柄。
- en: 'Create a variable of type `std::vector<VkBufferImageCopy>` named `regions`.
    For each region in the memory from which data should be copied, add an element
    to the `regions` vector. Specify the following values for members of each element:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regions` 的 `std::vector<VkBufferImageCopy>` 类型的变量。对于应该从内存中复制数据的每个区域，向
    `regions` 向量中添加一个元素。为每个元素的成员指定以下值：
- en: Offset from the beginning of a buffer's memory to which data should be copied
    for `bufferOffset`.
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区内存开始到要复制数据的偏移量，对于 `bufferOffset`。
- en: The length of data that will compose a single row in the buffer or a `0` value
    if the data is tightly packed (according to the size of the source image) for
    `bufferRowLength`.
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组成缓冲区中单行数据的长度或如果数据紧密打包（根据源图像的大小）则为 `0` 值的 `bufferRowLength`。
- en: The height of the image in the buffer (number of rows) or a `0` value if the
    buffer's data is tightly packed (according to the size of the source image) for
    `bufferImageHeight`.
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区中图像的高度（行数）或如果缓冲区的数据紧密打包（根据源图像的大小）则为 `0` 值的 `bufferImageHeight`。
- en: 'Initialize `imageSubresource` member with the following values:'
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下值初始化 `imageSubresource` 成员：
- en: Image's aspect (color, depth or stencil) for `aspectMask`
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspectMask` 的图像的方面（颜色、深度或模板）。'
- en: Number (index) of a mipmap level from which data will be copied for `mipLevel`
  id: totrans-611
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要复制数据的米普级别（索引）的编号，对于 `mipLevel`。
- en: Index of the first array layer from which contents will be copied for `baseArrayLayer`
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要复制内容的第一层数组索引，对于 `baseArrayLayer`。
- en: Number of array layers to copy for `layerCount`
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要复制的数组层数，对于 `layerCount`。
- en: Initial offset (in texels) of image's subregion from which data will be read
    and copied to buffer for `imageOffset`.
  id: totrans-614
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像子区域的初始偏移量（以像素为单位），从该子区域读取并复制到缓冲区，对于 `imageOffset`。
- en: The size of an image for `imageExtent`.
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageExtent` 的图像大小。'
- en: Call `vkCmdCopyImageToBuffer( command_buffer, source_image, image_layout, destination_buffer,
    static_cast<uint32_t>(regions.size()), &regions[0] )`, for which use the `command_buffer`,
    `source_image`, `image_layout`, and `destination_buffer` variables, the number
    of elements in the `regions` vector, and a pointer to the first element of that
    vector.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdCopyImageToBuffer( command_buffer, source_image, image_layout, destination_buffer,
    static_cast<uint32_t>(regions.size()), &regions[0] )`，其中使用 `command_buffer`、`source_image`、`image_layout`
    和 `destination_buffer` 变量，`regions` 向量中的元素数量，以及该向量第一个元素的指针。
- en: How it works...
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Data copy from an image to a buffer is an operation that is recorded to the
    command buffer like this:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像到缓冲区的数据复制是一个记录到命令缓冲区的操作，如下所示：
- en: '[PRE34]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The command buffer must be already in a recording state.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区必须已经处于记录状态。
- en: For the data to be copied properly, we need to provide multiple parameters that
    define the source of the data and the destination to which the data will be copied.
    These parameters consist of an offset from the image's origin (from the upper-left
    corner in texels) for x, y, and z dimensions, the mipmap level and a base array
    layer from which data will be copied, and the number of layers that will be the
    source of the data. Image dimensions are also required.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确复制数据，我们需要提供多个参数来定义数据的源和目标。这些参数包括从图像原点（从左上角的texels开始）到x、y和z维度的偏移量，mipmap级别以及从其中复制数据的基数组层，以及将成为数据源的层数。还需要图像尺寸。
- en: For the destination buffer, we specify a memory offset (from the beginning of
    the buffer's memory), the length of the data row and the height of the data in
    a buffer. We can also provide zeros for row length and height, which means that
    the data copied to the buffer will be tightly packed and will correspond to the
    source image's dimensions.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标缓冲区，我们指定内存偏移量（从缓冲区内存的开始处），数据行长度和缓冲区中的数据高度。我们也可以为行长度和高度提供零，这意味着复制到缓冲区的数据将紧密打包，并对应于源图像的尺寸。
- en: The preceding parameters are specified using an array of `VkBufferImageCopy`
    elements, similar to copying data from a buffer to an image as described in the
    *Copying data from a buffer to an image* recipe. We can provide many regions and
    copy memory ranges that are not continuous all as part of one copy operation.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 之前指定的参数使用`VkBufferImageCopy`元素数组，类似于在*从缓冲区复制数据到图像*的说明中描述的从缓冲区到图像的数据复制。我们可以提供许多区域，并将非连续的内存范围作为一次复制操作的一部分。
- en: Images from which we copy data must be created with a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    usage. Before the transfer operation, we also need to transition the image's layout
    to a `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从其中复制数据的图像必须使用`VK_BUFFER_USAGE_TRANSFER_SRC_BIT`用途创建。在传输操作之前，我们还需要将图像的布局转换为`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`。
- en: Buffers to which data can be copied must be created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    usage.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 可以复制数据的缓冲区必须使用`VK_BUFFER_USAGE_TRANSFER_DST_BIT`用途创建。
- en: Before we can copy data from an image, we should set a memory barrier and change
    the image's layout from the one currently used to the `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` layout.
    We also should change the type of memory access from the one that occurred so
    far to `VK_ACCESS_TRANSFER_READ_BIT`. A barrier should also be set after we are
    done copying data from the image, if it will be used for other purposes from now
    on. This time, we should change the memory access type from `VK_ACCESS_TRANSFER_READ_BIT`
    to the access that corresponds to the purpose for which the image will be used.
    At the same time, we should transition the layout from `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`
    to the one that is compatible with the image's next usage (refer to the *Setting
    an image memory barrier* recipe). Without these barriers, not only might the data
    transfer operation be performed in the wrong way, but later commands may overwrite
    the image's contents before the transfer operation has finished.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以从图像复制数据之前，我们应该设置内存屏障并将图像的布局从当前使用的布局转换为`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`布局。我们还应该将内存访问类型从迄今为止发生的类型更改为`VK_ACCESS_TRANSFER_READ_BIT`。在从图像复制数据完成后，如果它将用于其他目的，我们还应设置一个屏障。这次，我们应该将内存访问类型从`VK_ACCESS_TRANSFER_READ_BIT`更改为与图像将用于的目的相对应的访问类型。同时，我们应该将布局从`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`转换为与图像的下一个使用兼容的布局（参考*设置图像内存屏障*的说明）。如果没有这些屏障，不仅数据传输操作可能会以错误的方式进行，而且后续命令可能会在传输操作完成之前覆盖图像的内容。
- en: Similar barriers should be set for the buffer (but they can be a part of the
    same pipeline barrier). If previously the buffer was used for other purposes,
    we should change the memory access to `VK_ACCESS_TRANSFER_WRITE_BIT` before the
    transfer operation, as described in the *Setting a buffer memory barrier* recipe.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 应为缓冲区设置类似的屏障（但它们可以是同一管道屏障的一部分）。如果之前缓冲区用于其他目的，我们应在传输操作之前将内存访问更改为`VK_ACCESS_TRANSFER_WRITE_BIT`，如*设置缓冲区内存屏障*的说明中所述。
- en: See also
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以下内容：
- en: '*Creating a buffer*'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Setting a buffer memory barrier*'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置缓冲区内存屏障*'
- en: '*Creating an image*'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到图像*'
- en: '*Setting an image memory barrier*'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Copying data from a buffer to an image*'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从缓冲区到图像复制数据*'
- en: Using a staging buffer to update a buffer with a device-local memory bound
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阶段缓冲区更新具有设备本地内存绑定的缓冲区
- en: Staging resources are used to update the contents of a memory that is not host-visible.
    Such memory cannot be mapped, so we need an intermediate buffer whose contents
    can be easily mapped and updated, and from which data can be transferred.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段资源用于更新非主机可见的内存内容。这种内存无法映射，因此我们需要一个中间缓冲区，其内容可以轻松映射和更新，并且可以从其中传输数据。
- en: How to do it...
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device stored in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个名为 `logical_device` 的 `VkDevice` 类型的变量中存储的逻辑设备的句柄。
- en: Prepare the data that should be uploaded to the target buffer. Set up a pointer
    to the beginning of a data source and store it in a variable of type `void*` named
    `data`. The size of the data (in bytes) should be represented with a variable
    of type `VkDeviceSize` named `data_size`.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备要上传到目标缓冲区的数据。设置一个指向数据源开头的指针，并将其存储在名为 `data` 的 `void*` 类型的变量中。数据的大小（以字节为单位）应使用名为
    `data_size` 的 `VkDeviceSize` 类型的变量表示。
- en: Create a variable of type `VkBuffer` named `staging_buffer`. In it, the handle
    of a staging buffer will be stored.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `staging_buffer` 的 `VkBuffer` 类型的变量。在其中，将存储阶段缓冲区的句柄。
- en: Create a buffer that is big enough to hold the `data_size` number of bytes.
    Specify `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage during buffer creation. Use the
    `logical_device` variable during the creation process and store the created handle
    in the `staging_buffer` variable (refer to the *Creating a buffer* recipe).
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个足够大的缓冲区以容纳 `data_size` 字节数。在创建缓冲区时指定 `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    用法。在创建过程中使用 `logical_device` 变量，并将创建的句柄存储在 `staging_buffer` 变量中（参考 *创建缓冲区* 菜谱）。
- en: Take the handle of the physical device from which the `logical_device` handle
    was created. Use the physical device's handle to initialize a variable of type
    `VkPhysicalDevice` named `physical_device`.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建 `logical_device` 句柄的物理设备中获取句柄。使用物理设备的句柄初始化一个名为 `physical_device` 的 `VkPhysicalDevice`
    类型的变量。
- en: Create a variable of type `VkDeviceMemory` named `memory_object` that will be
    used to create a memory object for the staging buffer.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `memory_object` 的 `VkDeviceMemory` 类型的变量，该变量将用于为阶段缓冲区创建内存对象。
- en: Allocate a memory object using the `physical_device`, `logical_device`, and
    `staging_buffer` variables. Allocate a memory object from a memory type that has
    a `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` property. Store the created handle in
    the `memory_object` variable and bind it to the staging buffer (refer to the *Allocating
    and binding a memory object to a buffer* recipe).
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `physical_device`、`logical_device` 和 `staging_buffer` 变量分配一个内存对象。从具有 `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`
    属性的内存类型中分配一个内存对象。将创建的句柄存储在 `memory_object` 变量中，并将其绑定到阶段缓冲区（参考 *将内存对象分配和绑定到缓冲区*
    菜谱）。
- en: Map the memory of the `memory_object` using the `logical_device` variable, a
    `0` value for offset, and the `data_size` variable for the size of the mapped
    memory. Copy the data from the `data` pointer to the memory pointed to by the
    acquired pointer. Un-map the memory (refer to the *Mapping, updating, and unmapping
    host-visible memory* recipe).
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device` 变量、`0` 偏移量和 `data_size` 变量作为映射内存的大小来映射 `memory_object` 的内存。将数据从
    `data` 指针复制到由获取的指针指向的内存。取消映射内存（参考 *映射、更新和取消映射主机可见内存* 菜谱）。
- en: Take the handle of an allocated primary command buffer and use it to initialize
    a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到分配的主命令缓冲区的句柄，并使用它来初始化一个名为 `command_buffer` 的 `VkCommandBuffer` 类型的变量。
- en: Begin recording of the `command_buffer`. Provide a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`
    flag (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始记录 `command_buffer`。提供一个 `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` 标志（参考第
    3 章 *开始命令缓冲区记录操作* 菜谱，*命令缓冲区和同步*）。
- en: Take the handle of a buffer to which data will be transferred. Make sure it
    was created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage. Store its handle
    in a variable of type `VkBuffer` named `destination_buffer`.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到将要传输数据的缓冲区的句柄。确保它是以 `VK_BUFFER_USAGE_TRANSFER_DST_BIT` 用法创建的。将其句柄存储在名为 `destination_buffer`
    的 `VkBuffer` 类型的变量中。
- en: Record a memory barrier for a `destination_buffer` in the `command_buffer` variable.
    Provide pipeline stages which have been referencing the `destination_buffer` so
    far for the generating stages, and use a `VK_PIPELINE_STAGE_TRANSFER_BIT` stage
    for the consuming stages. Provide the type of memory access operations that have
    been referencing the buffer so far and use a `VK_ACCESS_TRANSFER_WRITE_BIT` value
    for the new memory access type. Ignore queue family indices--provide `VK_QUEUE_FAMILY_IGNORED`
    for both indices (refer to the *Setting a buffer memory barrier* recipe).
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`变量中为`destination_buffer`记录一个内存屏障。提供至今为止引用了`destination_buffer`的管道阶段，并为生成阶段使用`VK_PIPELINE_STAGE_TRANSFER_BIT`阶段，对于消费阶段使用。提供至今为止引用了该缓冲区的内存访问操作类型，并为新的内存访问类型使用`VK_ACCESS_TRANSFER_WRITE_BIT`值。忽略队列家族索引--为两个索引都提供`VK_QUEUE_FAMILY_IGNORED`（参考*设置缓冲区内存屏障*配方）。
- en: Create a variable of type `VkDeviceSize` named `destination_offset`, and initialize
    it with an offset value to which data should be transferred to in the target buffer's
    memory.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`destination_offset`的`VkDeviceSize`类型变量，并用数据应传输到目标缓冲区内存中的偏移值初始化它。
- en: Copy data from the `staging_buffer` to the `destination_buffer` using the `command_buffer`
    variable. Provide a `0` value for the source offset, the `destination_offset`
    variable for the destination offset, and the `data_size` variable for the size
    of the data to be transferred (refer to the *Copying data between buffers* recipe).
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`command_buffer`变量从`staging_buffer`复制数据到`destination_buffer`。为源偏移提供`0`值，为目的地偏移提供`destination_offset`变量，为要传输的数据大小提供`data_size`变量（参考*在缓冲区之间复制数据*配方）。
- en: Record another memory barrier for the `destination_buffer` in the `command_buffer`
    variable. Provide a `VK_PIPELINE_STAGE_TRANSFER_BIT` value for the generating
    stages and a set of pipeline stages in which `destination_buffer` will be used
    from now on. Use the `VK_ACCESS_TRANSFER_WRITE_BIT` value for the current memory
    access type and a value that is proper for the way in which the buffer will be
    used after the memory transfer. Use a `VK_QUEUE_FAMILY_IGNORED` value for queue
    family indices (refer to the *Setting a buffer memory barrier* recipe).
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`变量中为`destination_buffer`记录另一个内存屏障。为生成阶段提供一个`VK_PIPELINE_STAGE_TRANSFER_BIT`值，并为`destination_buffer`将要从现在开始使用的管道阶段集合。使用`VK_ACCESS_TRANSFER_WRITE_BIT`值作为当前内存访问类型，以及适合缓冲区在内存传输后使用方式的值。为队列家族索引使用`VK_QUEUE_FAMILY_IGNORED`值（参考*设置缓冲区内存屏障*配方）。
- en: End recording of the `command_buffer` (refer to the *Ending a command buffer
    recording operation* recipe in [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束`command_buffer`的记录（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*结束命令缓冲区记录操作*配方）。
- en: Take the handle of the queue on which the transfer operation will be performed
    and store it in a variable of type `VkQueue` named `queue`.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取将要执行传输操作的队列句柄，并将其存储在名为`queue`的`VkQueue`类型变量中。
- en: Create a list of semaphores that should be signaled when the transfer operation
    is completed. Store their handles in a variable of type `std::vector<VkSemaphore>`
    named `signal_semaphores`.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个当传输操作完成时应发出信号的信号量列表。将它们的句柄存储在名为`signal_semaphores`的`std::vector<VkSemaphore>`类型变量中。
- en: Create a variable of type `VkFence` named `fence`.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fence`的`VkFence`类型变量。
- en: Create an unsignaled fence using the `logical_device` variable. Store the created
    handle in the `fence` variable (refer to the *Creating a fence* recipe from [Chapter
    3](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201),
    *Command Buffers and Synchronization*).
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`变量创建一个未发出信号的门。将创建的句柄存储在`fence`变量中（参考[第3章](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201)，*命令缓冲区和同步*中的*创建门*配方）。
- en: Submit `command_buffer` to the `queue`. Provide a list of semaphores from the
    `signal_semaphores` vector as a list of semaphores to be signaled, and the `fence`
    variable for the fence to be signaled (refer to the *Submitting command buffers
    to the queue* recipe in [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`command_buffer`提交到`queue`。提供一个来自`signal_semaphores`向量的信号信号量列表，以及用于信号的门变量（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*将命令缓冲区提交到队列*配方）。
- en: Wait for the fence object to be signaled using the `logical_device` and `fence`
    variables. Provide a desired timeout value (refer to the *Waiting for fences*
    recipe in [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*).
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`和`fence`变量等待栅栏对象被信号。提供一个期望的超时值（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*等待栅栏*食谱）。
- en: Destroy the buffer represented by the `staging_buffer` variable (refer to the
    *Destroying a buffer* recipe).
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁由`staging_buffer`变量表示的缓冲区（参考*销毁缓冲区*食谱）。
- en: Free the memory object represented by the `memory_object` variable (refer to
    the *Freeing a memory object* recipe).
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放由`memory_object`变量表示的内存对象（参考*释放内存对象*食谱）。
- en: How it works...
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To use a staging resource for a transfer operation, we need a buffer with a
    memory that can be mapped. We can use an existing buffer or create a new one like
    this:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预存资源进行传输操作，我们需要一个可以映射的内存缓冲区。我们可以使用现有的缓冲区或创建一个新的，如下所示：
- en: '[PRE35]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we need to map the buffer''s memory and update its contents:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要映射缓冲区的内存并更新其内容：
- en: '[PRE36]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With a staging buffer ready, we can begin a transfer operation that will copy
    the data to the desired, target buffer. First, we start by beginning the command
    buffer recording operation and setting a memory barrier for the destination buffer
    to change its usage to the target for data copy operation. We don''t need the
    memory barrier for the staging buffer. When we map and update the buffer''s memory,
    its contents become visible for other commands, because an implicit barrier is
    set for the host writer when we start a command buffer recording:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 预存缓冲区准备就绪后，我们可以开始一个传输操作，将数据复制到目标缓冲区。首先，我们开始记录命令缓冲区操作，并为目标缓冲区设置一个内存屏障，以将其使用改变为目标，以便进行数据复制操作。我们不需要为预存缓冲区设置内存屏障。当我们映射和更新缓冲区的内存时，其内容对其他命令可见，因为我们开始命令缓冲区记录时设置了一个隐式屏障：
- en: '[PRE37]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we can record data copying from the **staging resource** to the destination
    buffer:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以记录从**预存资源**到目标缓冲区的数据复制：
- en: '[PRE38]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After this, we need a second memory barrier for the target buffer. This time,
    we change its usage from being a target of copy operations to the one the buffer
    will be used for after the data transfer. We can also end command buffer recording:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要为目标缓冲区设置第二个内存屏障。这次，我们将它的使用从复制操作的目标改为数据传输后缓冲区将用于的状态。我们还可以结束命令缓冲区记录：
- en: '[PRE39]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we create a fence and submit the command buffer to the queue, where it
    will be processed and the data transfer will be actually performed:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个栅栏并将命令缓冲区提交到队列，在那里它将被处理，并且数据传输将实际执行：
- en: '[PRE40]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we don''t want to use a staging buffer any more, we can destroy it. But,
    we can''t do this until the staging buffer won''t be used any more by the commands
    submitted to the queue: that''s why we need a fence. We wait on it until the driver
    signals when the processing of a submitted command buffer has finished. Then,
    we can safely destroy a staging buffer and free the memory object bound to it:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不再想使用预存缓冲区，我们可以将其销毁。但是，我们无法这样做，直到提交到队列的命令不再使用预存缓冲区：这就是为什么我们需要一个栅栏。我们等待它，直到驱动程序信号处理提交的命令缓冲区的处理已完成。然后，我们可以安全地销毁一个预存缓冲区并释放与其绑定的内存对象：
- en: '[PRE41]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In real-life scenarios, we should use an existing buffer and reuse it as a staging
    buffer as many times as possible to avoid unnecessary buffer creation and destruction
    operations. This way, we also avoid waiting on a fence.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，我们应该使用现有的缓冲区，尽可能多地将其作为预存缓冲区重用，以避免不必要的缓冲区创建和销毁操作。这样，我们也避免了等待栅栏。
- en: See also
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201),
    *Command Buffers and Synchronization*, see the following recipes:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201)，*命令缓冲区和同步*中，查看以下食谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Ending a command buffer recording operation*'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束命令缓冲区记录操作*'
- en: '*Creating a fence*'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建栅栏*'
- en: '*Waiting for fences*'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Submitting command buffers to the queue*'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: 'See the following recipes in this chapter:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看以下食谱：
- en: '*Creating a buffer*'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为缓冲区分配和绑定内存对象*'
- en: '*Setting an image memory barrier*'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Copying data from a buffer to an image*'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从缓冲区复制数据到图像*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用具有设备本地内存绑定的暂存缓冲区更新图像*'
- en: '*Freeing a memory object*'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: '*Destroying a buffer*'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区*'
- en: Using a staging buffer to update an image with a device-local memory bound
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用具有设备本地内存绑定的暂存缓冲区更新图像
- en: '**Staging** buffers can be used not only to transfer data between buffers,
    but also to and from an image. Here, we will show how to map a buffer''s memory
    and copy its contents to a desired image.'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**暂存**缓冲区不仅可以用于在缓冲区之间传输数据，还可以用于图像之间。在这里，我们将展示如何映射缓冲区的内存并将内容复制到所需的图像中。'
- en: How to do it...
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a staging buffer big enough to hold the entire data to be transferred.
    Specify a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage for the buffer and store its
    handle in a variable of type `VkBuffer` named `staging_buffer`. Allocate a memory
    object that supports the `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` property and bind
    it to the staging buffer. Store the memory object's handle in a variable of type
    `VkDeviceMemory` named `memory_object`. Map the memory and update its contents
    with the data to be transferred to the image. Unmap the memory. Perform these
    steps as described in more detail in the *Using a staging buffer to update a buffer
    with a device-local memory bound* recipe.
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个足够大的暂存缓冲区以容纳要传输的全部数据。为该缓冲区指定`VK_BUFFER_USAGE_TRANSFER_SRC_BIT`的使用方式，并将其句柄存储在名为`staging_buffer`的`VkBuffer`类型变量中。分配一个支持`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`属性的内存对象，并将其绑定到暂存缓冲区。将内存对象的句柄存储在名为`memory_object`的`VkDeviceMemory`类型变量中。映射内存并使用要传输到图像的数据更新其内容。取消映射内存。按照在*使用暂存缓冲区更新具有设备本地内存绑定的缓冲区*菜谱中更详细描述的步骤执行这些操作。
- en: Take the handle of a primary command buffer and use it to initialize a variable
    of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取主命令缓冲区的句柄，并使用它初始化一个名为`command_buffer`的`VkCommandBuffer`类型变量。
- en: Begin recording of the `command_buffer`. Provide a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`
    flag (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始记录`command_buffer`。提供一个`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`标志（参考第3章的*开始命令缓冲区记录操作*菜谱，*命令缓冲区和同步*）。
- en: Take the handle of the image to which data will be transferred and make sure
    it was created with a `VK_IMAGE_USAGE_TRANSFER_DST_BIT` specified. Use the handle
    to initialize a variable of type `VkImage` named `destination_image`.
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取要传输数据的目标图像的句柄，并确保它是通过指定`VK_IMAGE_USAGE_TRANSFER_DST_BIT`创建的。使用句柄初始化一个名为`destination_image`的`VkImage`类型变量。
- en: Record an image memory barrier in the `command_buffer`. Specify the stages in
    which the image was used so far and use a `VK_PIPELINE_STAGE_TRANSFER_BIT` stage
    for the consuming stages. Use the `destination_image` variable, provide the image's
    current access, and use a `VK_ACCESS_TRANSFER_WRITE_BIT` value for the new access.
    Specify the image's current layout and use a `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
    value for the new layout. Provide the image's aspect, but ignore queue family
    indices--use `VK_QUEUE_FAMILY_IGNORED` values for both (refer to the *Setting
    an image memory barrier* recipe).
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中记录一个图像内存屏障。指定图像迄今为止使用过的阶段，并使用`VK_PIPELINE_STAGE_TRANSFER_BIT`阶段作为消费阶段。使用`destination_image`变量，提供图像的当前访问权限，并使用`VK_ACCESS_TRANSFER_WRITE_BIT`值作为新访问权限。指定图像的当前布局，并使用`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`值作为新布局。提供图像的方面，但忽略队列家族索引--对于两者都使用`VK_QUEUE_FAMILY_IGNORED`值（参考*设置图像内存屏障*菜谱）。
- en: In the `command_buffer`, record the data transfer operation from `staging_buffer`
    to `destination_image`. Provide a `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` value
    as an image layout, a `0` value for the buffer's offset, a `0` value for the buffer's
    row lengths, and a `0` value for the buffer's image height. Specify the image's
    memory region into which data should be copied by providing the desired mipmap
    level, base array layer index, and the number of layers to be updated. Provide
    the image's aspect too. Specify the offset into the image's x, y, and z coordinates
    (in texels) and the image's size (refer to the *Copying data from a buffer to
    an image* recipe).
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`command_buffer`中，记录从`staging_buffer`到`destination_image`的数据传输操作。提供一个`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`值作为图像布局，`0`值作为缓冲区的偏移量，`0`值作为缓冲区的行长度，以及`0`值作为缓冲区的图像高度。指定应将数据复制到的图像内存区域，通过提供所需的mipmap级别、基本数组层索引和要更新的层数来实现。也提供图像的方面。指定图像的x、y和z坐标（以texels为单位）的偏移量以及图像的大小（参考*从缓冲区复制数据到图像*菜谱）。
- en: Record another image memory barrier into the `command_buffer`. This time, specify
    a `VK_PIPELINE_STAGE_TRANSFER_BIT` value for generating stages and set proper
    stages in which the target image will be used after the data transfer. In the
    barrier, change the image's layout from `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
    into the value proper for the new usage. Set a `VK_QUEUE_FAMILY_IGNORED` value
    for both queue families and also provide the image's aspect (refer to the *Setting
    an image memory barrier* recipe).
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个图像内存屏障记录到`command_buffer`中。这次，指定一个`VK_PIPELINE_STAGE_TRANSFER_BIT`值来生成阶段，并设置在数据传输后目标图像将使用的适当阶段。在屏障中，将图像的布局从`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`更改为适合新使用的值。为两个队列家族设置`VK_QUEUE_FAMILY_IGNORED`值，并提供图像的方面（参考*设置图像内存屏障*配方）。
- en: End the command buffer recording operation, create an unsignaled fence and use
    it, along with semaphores that should be signaled, during submitting the command
    buffer to the queue. Wait for the created fence to be signaled, destroy the staging
    buffer, and free its memory object as described in the *Using a staging buffer
    to update a buffer with a device-local memory bound* recipe.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束命令缓冲区记录操作，创建一个未通知的栅栏并使用它，在提交命令缓冲区到队列时，与应通知的信号量一起使用。等待创建的栅栏被通知，销毁临时缓冲区，并按照*使用临时缓冲区更新具有设备本地内存绑定的缓冲区*配方释放其内存对象。
- en: How it works...
  id: totrans-708
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is very similar to the *Using a staging buffer to update a buffer
    with a device-local memory bound* recipe; that's why only the differences are
    described in more detail.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方与*使用临时缓冲区更新具有设备本地内存绑定的缓冲区*配方非常相似；这就是为什么只详细描述了差异。
- en: 'First we create a staging buffer, allocate a memory object for it, bind it
    to the buffer, and map it to upload data from our application to the GPU:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个临时缓冲区，为其分配一个内存对象，将其绑定到缓冲区，并将其映射到从我们的应用程序上传数据到GPU：
- en: '[PRE42]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next we begin command buffer recording, and set one barrier for the destination
    image so it can be used as a target for data transfer. We also record the data
    transfer operation:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始命令缓冲区记录，并为目标图像设置一个屏障，使其可以作为数据传输的目标。我们还记录了数据传输操作：
- en: '[PRE43]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we record another barrier that changes the image''s usage from being
    the target of the copy operation to the one that is valid for the purpose for
    which the image will be used next. We also end the command buffer recording operation:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们记录另一个屏障，将图像的使用从复制操作的目标更改为适用于图像将被用于下一个目的的屏障。我们还结束了命令缓冲区记录操作：
- en: '[PRE44]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After that, we create a fence and submit a command buffer to the queue. We
    then wait on the fence to know the moment when we can safely delete the staging
    buffer and its memory object. We do it afterwards:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个栅栏并将命令缓冲区提交到队列。然后我们在栅栏上等待，以知道何时可以安全地删除临时缓冲区和其内存对象。我们之后这样做：
- en: '[PRE45]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we are reusing the existing buffer as a staging resource, we don't need the
    fence, because the buffer will live much longer, maybe for the whole lifetime
    of the application. This way, we can avoid frequent and unnecessary buffer creation
    and deletion, and memory object allocation and freeing.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将现有的缓冲区作为临时资源重复使用，我们不需要栅栏，因为缓冲区将存活得更久，可能整个应用程序的生命周期。这样，我们可以避免频繁且不必要的缓冲区创建和删除，以及内存对象的分配和释放。
- en: See also
  id: totrans-719
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201),
    *Command Buffer and Synchronization*, see the following recipes:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201)，*命令缓冲区和同步*，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Ending a command buffer recording operation*'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束命令缓冲区记录操作*'
- en: '*Creating a fence*'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个栅栏*'
- en: '*Waiting for fences*'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Submitting command buffers to the queue*'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: 'See the following recipes in this chapter:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看以下配方：
- en: '*Creating a buffer*'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Setting an image memory barrier*'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: '*Mapping, updating, and unmapping host-visible memory*'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射、更新和取消映射主机可见内存*'
- en: '*Copying data from a buffer to an image*'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从缓冲区复制数据到图像*'
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用临时缓冲区更新具有设备本地内存绑定的图像*'
- en: '*Freeing a memory object*'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: '*Destroying a buffer*'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个缓冲区*'
- en: Destroying an image view
  id: totrans-735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁图像视图
- en: When we don't need an image view any more, we should destroy it.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要图像视图时，我们应该销毁它。
- en: How to do it...
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个逻辑设备的句柄并将它存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Take the handle of an image view stored in a variable of type `VkImageView`
    named `image_view`.
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个存储在名为 `image_view` 的 `VkImageView` 类型变量中的图像视图句柄。
- en: Call `vkDestroyImageView( logical_device, image_view, nullptr )` and provide
    the handle of the logical device, the handle of the image view, and a `nullptr`
    value.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyImageView(logical_device, image_view, nullptr)` 并提供逻辑设备的句柄、图像视图的句柄以及一个
    `nullptr` 值。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `image_view` variable.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值赋给 `image_view` 变量。
- en: How it works...
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Destroying an image view requires us to use its handle and the handle of the
    logical device on which the image view was created. It is performed in the following
    way:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁图像视图需要我们使用其句柄以及创建图像视图的逻辑设备的句柄。操作如下：
- en: '[PRE46]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we check whether the handle is not empty. We don't need to do it--destroying
    a null handle is silently ignored. But it's good to skip unnecessary function
    calls. Next, we destroy the image view and assign a null handle to the variable
    in which the handle was stored.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查句柄是否不为空。我们不需要这样做--销毁一个空句柄会被静默忽略。但跳过不必要的函数调用是个好习惯。接下来，我们销毁图像视图并将一个空句柄赋值给存储句柄的变量。
- en: See also
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Creating an image view* recipe in this chapter'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中创建一个图像视图* 菜单'
- en: Destroying an image
  id: totrans-748
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁图像
- en: Images that won't be used any more should be destroyed to release their resources.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用的图像应该被销毁以释放其资源。
- en: How to do it...
  id: totrans-750
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take a logical device and store its handle in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个逻辑设备并将它的句柄存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Use the image's handle to initialize a variable of type `VkImage` named `image`.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图像的句柄并使用它初始化一个名为 `image` 的 `VkImage` 类型变量。
- en: Call `vkDestroyImage( logical_device, image, nullptr )`. Provide the handle
    of the logical device, the handle of the image, and a `nullptr` value.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyImage(logical_device, image, nullptr)`。提供逻辑设备的句柄、图像的句柄以及一个 `nullptr`
    值。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `image` variable.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值赋给 `image` 变量。
- en: How it works...
  id: totrans-755
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Images are destroyed through a single call of the `vkDestroyImage()` function.
    For it, we provide the handle of the logical device, the handle of the image,
    and a `nullptr` value, like this:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 图像通过 `vkDestroyImage()` 函数的单次调用被销毁。为此，我们提供逻辑设备的句柄、图像的句柄以及一个 `nullptr` 值，如下所示：
- en: '[PRE47]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We also try to avoid unnecessary function calls by checking whether the image's
    handle is not empty.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过检查图像的句柄是否不为空来尝试避免不必要的函数调用。
- en: See also
  id: totrans-759
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Creating an image* recipe in this chapter'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中创建一个图像* 菜单'
- en: Destroying a buffer view
  id: totrans-761
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁缓冲区视图
- en: When we don't need a buffer view any more, we should destroy it.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要缓冲区视图时，我们应该销毁它。
- en: How to do it...
  id: totrans-763
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take a logical device and store its handle in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个逻辑设备并将它的句柄存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Use the buffer's view handle and initialize a variable of type `VkBufferView`
    named `buffer_view` with it.
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用缓冲区的视图句柄并使用它初始化一个名为 `buffer_view` 的 `VkBufferView` 类型变量。
- en: Call `vkDestroyBufferView( logical_device, buffer_view, nullptr )`. Provide
    the handle of the logical device, the handle of the buffer view, and a `nullptr`
    value.
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyBufferView(logical_device, buffer_view, nullptr)`。提供逻辑设备的句柄、缓冲区视图的句柄以及一个
    `nullptr` 值。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `buffer_view` variable.
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值赋给 `buffer_view` 变量。
- en: How it works...
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Buffer views are destroyed using the `vkDestroyBufferView()` function:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区视图通过 `vkDestroyBufferView()` 函数被销毁：
- en: '[PRE48]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To avoid unnecessary function calls, we check whether the buffer view's handle
    is not empty before we call a buffer view destroying function.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用缓冲区视图销毁函数之前，我们检查缓冲区视图的句柄是否不为空，以避免不必要的函数调用。
- en: See also
  id: totrans-772
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Creating a buffer view* recipe in this chapter'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中创建一个缓冲区视图* 菜单'
- en: Freeing a memory object
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放内存对象
- en: In Vulkan, when we create resources, we later destroy them. On the other hand,
    resources that represent different memory objects or pools are allocated and freed.
    Memory objects bound to images and buffers are also freed. We should free them
    when we no longer need them.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，当我们创建资源时，我们稍后会销毁它们。另一方面，代表不同内存对象或池的资源被分配和释放。绑定到图像和缓冲区的内存对象也被释放。我们应该在我们不再需要它们时释放它们。
- en: How to do it...
  id: totrans-776
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the logical device's handle and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Take the variable of type `VkDeviceMemory` named `memory_object`, in which the
    handle of the memory object is stored.
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取名为`memory_object`的`VkDeviceMemory`类型变量，其中存储了内存对象的句柄。
- en: Call `vkFreeMemory( logical_device, memory_object, nullptr )`. Use the handle
    of the logical device, the handle of the memory object, and a `nullptr` value.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkFreeMemory(logical_device, memory_object, nullptr)`。使用逻辑设备的句柄、内存对象的句柄和一个`nullptr`值。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `memory_object`
    variable.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于安全原因，将`VK_NULL_HANDLE`值分配给`memory_object`变量。
- en: How it works...
  id: totrans-781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Memory objects can be freed before resources that were using them are destroyed.
    But we can't use these resources any more, we can only destroy them. In general,
    we can't bind one memory object to the resource, free it, and then bind another
    memory object to the same resource.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 内存对象可以在使用它们的资源被销毁之前被释放。但我们不能再使用这些资源了，我们只能销毁它们。一般来说，我们不能将一个内存对象绑定到资源，释放它，然后再将另一个内存对象绑定到同一个资源。
- en: 'To free a memory object, we can write the following code:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放内存对象，我们可以编写以下代码：
- en: '[PRE49]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Memory objects must have been allocated from a logical device represented by
    the `logical_device` variable.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 内存对象必须是从由`logical_device`变量表示的逻辑设备中分配的。
- en: See also
  id: totrans-786
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Allocating and binding a memory object to an image*'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到图像*'
- en: Destroying a buffer
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁缓冲区
- en: When a buffer is no longer used, we should destroy it.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个缓冲区不再被使用时，我们应该销毁它。
- en: How to do it...
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Store the buffer's handle in a variable of type `VkBuffer` named `buffer`.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓冲区的句柄存储在名为`buffer`的`VkBuffer`类型变量中。
- en: Call `vkDestroyBuffer( logical_device, buffer, nullptr )` and provide the handle
    of the logical device, the handle of the buffer, and a `nullptr` value.
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkDestroyBuffer(logical_device, buffer, nullptr)`并提供逻辑设备的句柄、缓冲区的句柄和一个`nullptr`值。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `buffer` variable.
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于安全原因，将`VK_NULL_HANDLE`值分配给`buffer`变量。
- en: How it works...
  id: totrans-797
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Buffers are destroyed using the `vkDestroyBuffer()` function like this:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vkDestroyBuffer()`函数销毁缓冲区，如下所示：
- en: '[PRE50]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`logical_device` is a variable representing the logical device on which the
    buffer was created. When we destroy a buffer, we assign an empty handle to the
    variable representing this buffer, so we won''t try to destroy the same resource
    twice.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`logical_device`是一个表示创建缓冲区的逻辑设备的变量。当我们销毁一个缓冲区时，我们将一个空句柄分配给表示此缓冲区的变量，这样我们就不会尝试两次销毁相同的资源。'
- en: See also
  id: totrans-801
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a buffer view* recipe in this chapter'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建缓冲区视图*配方
