- en: Resources and Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and binding a memory object for a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a buffer memory barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a buffer view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and binding a memory object to an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting an image memory barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 2D image and view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a layered 2D image with a CUBEMAP view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping, updating, and unmapping host-visible memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data between buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data from a buffer to an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data from an image to a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a staging buffer to update a buffer with a device-local memory bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a staging buffer to update an image with a device-local memory bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an image view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying a buffer view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freeing a memory object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Vulkan, there are two very important types of resources in which data can
    be stored--buffers and images. Buffers represent linear arrays of data. Images,
    similarly to OpenGL''s textures, represent one-, two-, or three-dimensional data
    organized in a way that is (generally) specific for a given hardware (so we don''t
    know the internal memory structure). Buffers and images can be used for various
    purposes: in shaders, we can read or sample data from them, or store data in them.
    Images can be used as color or depth/stencil attachments (render targets), which
    means that we can render into them. Buffers can also store vertex attributes,
    indices, or parameters used during indirect drawing.'
  prefs: []
  type: TYPE_NORMAL
- en: What is very important is that each of the mentioned usages must be specified
    during resource creation (we can provide many of them at once). We also need to
    inform the driver when we change the way in which a given resource is used in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to high-level APIs such as OpenGL, buffers and images in Vulkan don't
    have their own storage. They require us to specifically create and bind appropriate
    memory objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use these resources and how to allocate
    memory for them and bind it to them. We will also learn how to upload data from
    the CPU to the GPU, and how to copy data between resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Buffers are the simplest  resources because they represent data which can be
    laid out in memory only  linearly, just like in typical C/C++ arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Buffers can be used for various purposes. They can be used in pipelines via
    descriptor sets to back data stores for uniform buffers, storage buffers, or texel
    buffers, among others. They can be a source of data for vertex indices or attributes,
    or can be used as **staging resources**--intermediate resources for data transfer
    from the CPU to the GPU. For all these purposes, we just need to create a buffer
    and specify its usage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a created logical device stored in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkDeviceSize` named `size`, in which store a value
    that will represent the size of data (in bytes) which a buffer will be able to
    store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of desired scenarios a buffer will be used for. Create a variable of a
    bitfield type `VkBufferUsageFlags` named `usage`. Assign a value that is a logical
    sum (`OR`) of all desired buffer usages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkBufferCreateInfo` named `buffer_create_info`.
    Assign the following values to its members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `flags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` variable for `size`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usage` variable for `usage`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHARING_MODE_EXCLUSIVE` value for `sharingMode`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `queueFamilyIndexCount`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pQueueFamilyIndices`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a variable of type `VkBuffer` named `buffer`, in which a handle of a
    created buffer will be stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCreateBuffer( logical_device, &buffer_create_info, nullptr, &buffer
    )`, and provide a handle of the logical device in the first parameter, a pointer
    to the `buffer_create_info` variable in the second parameter, a `nullptr` value
    in the third parameter, and a pointer to the `buffer` variable in the last parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the function call was successful by checking whether the returned
    valued is equal to `VK_SUCCESS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can create a buffer, we need to know how big the buffer should be
    and how we want to use it. A buffer's size is determined by the amount of data
    we would like to store in it. All the ways in which buffer will be used in our
    application are specified by the buffer's usage. We can't use a buffer in a way
    that wasn't defined during buffer creation.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers can only be used for purposes (usages) specified during their creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of supported ways in which buffers can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_TRANSFER_SRC_BIT` specifies that the buffer can be a source
    of data for copy operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_TRANSFER_DST_BIT` specifies that we can copy data to the buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` indicates that the buffer can be
    used in shaders as a uniform texel buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` specifies that the buffer can be
    used in shaders as a storage texel buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` indicates that the buffer can be used
    in shaders as a source of values for uniform variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` indicates that we can store data in the
    buffer from within shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_INDEX_BUFFER_BIT` specifies that the buffer can be used as
    a source of vertex indices during drawing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` indicates that the buffer can be a source
    of data for vertex attributes specified during drawing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT` indicates that the buffer can contain
    data that will be used during indirect drawing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a buffer, we need to prepare a variable of type `VkBufferCreateInfo`
    in which we provide the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `size` and `usage` variables define the amount of data the buffer can hold
    and the ways in which we can use the buffer in our application, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `VK_SHARING_MODE_EXCLUSIVE` value provided for the `sharingMode`
    member is another very important parameter. Through it, we specify whether queues
    from multiple families can access the buffer at the same time. **Exclusive sharing
    mode** tells the driver that the buffer can be referenced only by queues from
    one family at a single time. If we want to use the buffer in commands submitted
    to queues from another family, we must explicitly tell the driver when the ownership
    has changed (when we transferred ownership from one family to another). This option
    gives us a better performance, but with a cost of more work.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify a `VK_SHARING_MODE_CONCURRENT` sharing mode. With it, multiple
    queues from multiple families can access a buffer at the same time and we don't
    need to perform an ownership transfer. But, the trade-off is that a **concurrent
    access** may have lower performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have prepared the creation data, we can create a buffer like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object for a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting a buffer memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and binding a memory object for a buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, buffers don't have their own memory. To be able to use buffers in
    our application and to store any data inside them, we need to allocate a memory
    object and bind it to a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a physical device from which the logical device was created.
    Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkPhysicalDeviceMemoryProperties` named `physical_device_memory_properties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties
    )`, for which provide the handle of a physical device and a pointer to the `physical_device_memory_properties`
    variable. This call will store memory parameters (number of heaps, their size,
    and types) of the physical device used for processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a logical device created from the physical device, represented
    by the `physical_device` variable. Store the handle in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a created buffer represented by a variable of type `VkBuffer`
    named `buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkMemoryRequirements` named `memory_requirements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire parameters of a memory that needs to be used for the buffer. Do this
    by calling `vkGetBufferMemoryRequirements( logical_device, buffer, &memory_requirements
    )`, and providing the handle of the logical device in the first parameter, the
    handle of the created buffer in the second parameter, and a pointer to the `memory_requirements`
    variable in the third parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkDeviceMemory` named `memory_object` that will represent
    the created buffer's memory object, and assign a `VK_NULL_HANDLE` value to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkMemoryPropertyFlagBits` named `memory_properties`.
    Store additional (chosen) memory properties in the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the available physical device''s memory types represented by the
    `memoryTypeCount` member of a `physical_device_memory_properties` variable. Do
    this by using the variable of type `uint32_t` named `type`. For each loop iteration,
    perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the bit of the `memoryTypeBits` member of the `memory_requirements`
    variable on the position represented by the `type` variable is set.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the `memory_properties` variable has the same bits set as a `propertyFlags`
    member of the memory type, at index `type` of the `memoryTypes` array in the `physical_device_memory_properties`
    variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If points 1 and 2 are not true, continue iterating the loop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkMemoryAllocateInfo` named `buffer_memory_allocate_info`,
    and assign the following values for its members:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_requirements.size` variable for `allocationSize`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` variable for `memoryTypeIndex`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkAllocateMemory( logical_device, &buffer_memory_allocate_info, nullptr,
    &memory_object )`, for which provide the handle of the logical device, a pointer
    to the `buffer_memory_allocate_info` variable, a `nullptr` value, and a pointer
    to the `memory_object` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful by checking if the value returned by the call
    was equal to `VK_SUCCESS`, and stop iterating the loop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that memory object allocation inside the loop was successful by checking
    whether the `memory_object` variable is not equal to `VK_NULL_HANDLE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the memory object to the buffer by calling `vkBindBufferMemory( logical_device,
    buffer, memory_object, 0 )`, for which provide the `logical_device`, `buffer`,
    and `memory_object` variables and a `0` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful and the returned value was equal to `VK_SUCCESS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allocate a memory object for a buffer (or memory object in general), we
    need to know what memory types are available on a given physical device, and how
    many of them there are. This is done by calling the `vkGetPhysicalDeviceMemoryProperties()`
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to know how much storage a given buffer requires (the buffer''s
    memory may need to be bigger than the buffer''s size) and what memory type is
    compatible with it. All this is stored in a variable of type `VkMemoryRequirements`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to check which memory type corresponds to the buffer''s memory
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we iterate over all available memory types and check whether a given type
    can be used for our buffer. We can also request some additional memory properties
    that need to be fulfilled. For example, if we want to upload data directly from
    our application (from the CPU), memory mapping must be supported. In this case,
    we need to use a memory type that is **host-visible**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have found a proper memory type, we can use it to allocate a memory
    object and we can stop the loop. After that, we make sure that the memory was
    allocated properly (if we didn''t leave the loop without allocating the object)
    and next, we bind it to our buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: During binding, we specify a memory offset, among other parameters. This allows
    us to bind a part of the memory that's not at the beginning of the memory object.
    We can (and should) use the `offset` parameter to bind multiple, separate parts
    of a memory object to multiple buffers.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, the buffer can be used in our application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to allocate and bind a memory object to a buffer. But
    in general, we shouldn't use a separate memory object for each buffer. We should
    allocate bigger memory objects and use parts of them for multiple buffers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we also acquired the parameters of a physical device's available
    memory types by calling a `vkGetPhysicalDeviceMemoryProperties()` function. But
    in general, to improve the performance of our application, we don't need to call
    it every time we want to allocate a memory object. We can call this function only
    once, after we choose a physical device that will be used for a logical device
    (refer to the *Creating a logical device* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*) and use the variable in which the parameters were stored.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting a buffer memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a buffer memory barrier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffers can be used for various purposes. For each buffer, we can upload data
    to it or copy data from it; we can bind a buffer to a pipeline via descriptor
    sets and use it inside shaders as a source of data, or we can store data in the
    buffer from within the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: We must inform a driver about each such usage, not only during buffer creation,
    but also before the intended usage. When we have been using a buffer for one purpose
    and from now on we want to use it differently, we must tell the driver about a
    change in the buffer's usage. This is done through buffer memory barriers. They
    are set as part of the pipeline barriers during command buffer recording (refer
    to the *Beginning a command buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe, we will use a custom structure type named `BufferTransition`
    with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Through this structure, we will define the parameters we want to use for the
    buffer memory barrier. In `CurrentAccess` and `NewAccess`, we store information
    about how the buffer has been used so far and how it will be used from now on,
    respectively (in this case, usage is defined as types of memory operations that
    will involve a given buffer). The `CurrentQueueFamily` and `NewQueueFamily` members
    are used when we want to transfer ownership from queues from one family to another.
    We need to do this when we have specified **exclusive sharing mode** during buffer
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prepare parameters for each buffer you want to set up a barrier for. Store
    them in a vector of type `std::vector<BufferTransition>` named `buffer_transitions`.
    For each buffer, store the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffer's handle in the `Buffer` member
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type of memory operations that have involved the buffer so far in the `CurrentAccess`
    member
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type of memory operations that will be performed on the buffer from now on (after
    the barrier) in the `NewAccess` member
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Index of a queue family that has been referencing the buffer so far (or a `VK_QUEUE_FAMILY_IGNORED`
    value if we don't want to transfer queue ownership) in the `CurrentQueueFamily`
    member
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Index of a queue family that will be referencing the buffer from now on (or
    a `VK_QUEUE_FAMILY_IGNORED` value if we don't want to transfer queue ownership)
    in the `NewQueueFamily` member
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a vector variable of type `std::vector<VkBufferMemoryBarrier>` named
    `buffer_memory_barriers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each element of the `buffer_transitions` variable, add a new element to
    the `buffer_memory_barriers` vector. Use the following values for members of the
    new element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER` value for `sType` member'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentAccess` value of the current element for `srcAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewAccess` value of the current element for `dstAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentQueueFamily` value of the current element for `srcQueueFamilyIndex`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewQueueFamily` value of the current element for `dstQueueFamilyIndex`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer's handle for `buffer`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_WHOLE_SIZE` value for `size`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the handle of the command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the command buffer represented by the `command_buffer` handle is in
    the recording state (that the recording operation was started for the command
    buffer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of a bit field type `VkPipelineStageFlags` named `generating_stages`.
    In this variable, store values representing pipeline stages that have been using
    the buffer so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of a bit field type `VkPipelineStageFlags` named `consuming_stages`.
    In this variable, store values representing pipeline stages in which the buffer
    will be used after the barrier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages,
    0, 0, nullptr, static_cast<uint32_t>(buffer_memory_barriers.size()), &buffer_memory_barriers[0],
    0, nullptr )`, and provide the handle of the command buffer in the first parameter,
    and `generating_stages` and `consuming_stages` variables in the second and third
    parameters respectively. The number of elements of the `buffer_memory_barriers`
    vector should be provided in the seventh parameter, and the eighth parameter should
    point to the first element of the `buffer_memory_barriers` vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Vulkan, operations that are submitted to queues are executed in order, but
    they are independent. Sometimes, it is possible for some operations to start before
    the previous operations have finished. This parallel execution is one of the most
    important performance factors of current graphics hardware. But sometimes, it
    is crucial that some operations should wait for the results of earlier operations:
    this is when memory barriers come in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory barriers are used to define moments in command buffers' executions, in
    which later commands should wait for the earlier commands to finish their job.
    They also cause the results of these operations to become visible for other operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of buffers, through memory barriers, we specify how the buffer was
    used and which pipeline stages were using it up to the moment in which we placed
    a barrier. Next we need to define which pipeline stages will be using it and how,
    after the barrier. With this information, the driver can pause operations that
    need to wait for the results of earlier operations to become available, but execute
    operations that won't reference the buffer at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Buffers can be used only for purposes defined during creation. Each such usage
    corresponds with the type of memory operation through which the buffer''s contents
    can be accessed. Here is a list of supported memory access types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_ACCESS_INDIRECT_COMMAND_READ_BIT` is used when the buffer''s contents are
    a source of data for indirect drawing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_INDEX_READ_BIT` indicates the buffer''s contents are used for indices
    during drawing operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT` specifies that the buffer is a source
    of vertex attributes that are read during drawing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_UNIFORM_READ_BIT` is used when the buffer will be accessed through
    shaders as an uniform buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_SHADER_READ_BIT` indicates that the buffer can be read inside shaders
    (but not as a uniform buffer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_SHADER_WRITE_BIT` specifies that shaders will write data to the
    buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_TRANSFER_READ_BIT` is used when we want to copy data from the buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_TRANSFER_WRITE_BIT` is used when we want to copy data to the buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_HOST_READ_BIT` specifies that the application will read the buffer''s
    contents (via memory mapping)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_HOST_WRITE_BIT` is used when the application will write data to
    the buffer (via memory mapping)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_MEMORY_READ_BIT` is used when the buffer''s memory will be read
    in any other way not specified above'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_MEMORY_WRITE_BIT` is used when the buffer''s memory will be written
    through any other way not described above'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Barriers are needed for memory operations to become visible for later commands.
    Without them, commands that read the buffer''s contents may start reading them
    before the contents were even properly written by the previous operations. But,
    such a break in the command buffer''s execution causes stalls in the graphics
    hardware''s processing pipeline. And this, unfortunately, may impact the performance
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_002.png)'
  prefs: []
  type: TYPE_IMG
- en: We should aggregate usage and ownership transitions for as many buffers as possible
    in as few barriers as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a memory barrier for a buffer, we need to prepare a variable of type
    `VkBufferMemoryBarrier`. If possible, we should aggregate data for multiple buffers
    in one memory barrier. That''s why a vector with elements of type `VkBufferMemoryBarrier`
    seems very useful for this reason, and can be filled like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up a memory barrier in the command buffer. This is done during
    the command buffer''s recording operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the barrier we specify which pipeline stages of the commands, executed after
    the barrier, should wait for the results of which pipeline stages of commands
    executed before the barrier.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we need to set a barrier only when the usage is changed. We don't
    need to do it if the buffer is used for the same purpose multiple times. Imagine
    a situation in which we want to copy data to a buffer two times, from two different
    resources. First, we need to set one barrier that will inform the driver that
    we will perform operations involving memory access of a `VK_ACCESS_TRANSFER_WRITE_BIT`
    type. After that, we can copy data to the buffer as many times as we want. Next,
    if we want to use a buffer, for example, as a vertex buffer (source of vertex
    attributes during rendering), we need to set another barrier indicating that we
    will read vertex attribute data from the buffer--these operations are represented
    by a `VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT` memory access. When we are done drawing
    and a buffer will be used for yet another purpose, even if once again we want
    to copy data to the buffer, we yet again need to set a memory barrier with proper
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't need to set up a barrier for the whole buffer. We can do it only for
    part of the buffer's memory. To do this, we just need to specify proper values
    for the `offset` and `size` members of a variable of type `VkBufferMemoryBarrier`,
    defined for a given buffer. Through these members, we define where the contents
    of the memory start, and what the size of the memory is for which we want to define
    a barrier. These values are specified in machine units (bytes).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a buffer view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to use a given buffer as a uniform texel buffer or as a storage
    texel buffer, we need to create a buffer view for it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device from which a given buffer was created. Store
    it in a variable of type `VkDevice` named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a created buffer and store it in a variable of type `VkBuffer`
    named `buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a format for a buffer view (how the buffer's contents should be interpreted)
    and use it to initialize a variable of type `VkFormat` named `format`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the part of a buffer's memory for which a view should be created. Set
    the starting point of this memory (offset from the beginning of the buffer's memory)
    in a variable of type `VkDeviceSize` named `memory_offset`. Define the size of
    this memory through a variable of type `VkDeviceSize` named `memory_range`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkBufferViewCreateInfo` named `buffer_view_create_info`.
    Use the following values to initialize its members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `flags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buffer` variable for `buffer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format` variable for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_offset` variable for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_range` variable for `range`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a variable of type `VkBufferView` named `buffer_view`. It will be used
    to store the handle of a created buffer view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCreateBufferView( logical_device, &buffer_view_create_info, nullptr,
    &buffer_view )`, for which provide the handle of the logical device in the first
    parameter, a pointer to the `buffer_view_create_info` variable in the second parameter,
    a `nullptr` value as the third parameter, and a pointer to the `buffer_view` variable
    in the last parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful by checking whether the value returned by
    the call was equal to `VK_SUCCESS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a buffer view, the most important things we need to think about are
    the view''s format and the memory parts for which the view will be created. This
    way, inside shaders, a buffer''s contents can be interpreted similarly to images
    (textures). We define these parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the buffer itself using the specified parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a descriptor set layout*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updating descriptor sets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images represent data that can have one, two, or three dimensions, and can have
    additional mipmap levels and layers. Each element of an image's data (a texel)
    can also have one or more samples.
  prefs: []
  type: TYPE_NORMAL
- en: Images can be used for many different purposes. We can use them as a source
    of data for copy operations. We can bind images to pipelines via descriptor sets
    and use them as textures (similarly to OpenGL). We can render into images, in
    which case we use images as color or depth attachments (render targets).
  prefs: []
  type: TYPE_NORMAL
- en: We specify image parameters such as size, format, and its intended usages during
    image creation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device on which we want to create an image. Store
    it in a variable of type `VkDevice` named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an image type (if an image should have one, two, or three dimensions)
    and use a proper value to initialize a variable of type `VkImageType` named `type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the image's format--the number of components and number of bits each
    image's element should contain. Store the format in a variable of type `VkFormat`
    named `format`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the image's size (dimensions) and use it to initialize a variable of
    type `VkExtent3D` named `size`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the number of mipmap levels that should be defined for the image. Store
    the number of mipmap levels in a variable of type `uint32_t` named `num_mipmaps`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the number of layers that should be defined for the image and store it
    in a variable of type `uint32_t` named `num_layers`. If an image will be used
    as a cubemap, the number of layers must be a multiple of six.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkSampleCountFlagBits` named `samples`, and initialize
    it with a value representing the number of samples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the intended image usages. Define them in a variable of type `VkImageUsageFlags`
    named `usage_scenarios`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkImageCreateInfo` named `image_create_info`. Use
    the following values for its members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `flags`, use the `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` value if the image
    should be used as a cubemap, otherwise use a `0` value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` variable for `imageType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format` variable for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` variable for `extent`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_mipmaps` variable for `mipLevels`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_layers` variable for `arrayLayers`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`samples` variable for `samples`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_TILING_OPTIMAL` value for `tiling`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usage_scenarios` variable for `usage`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SHARING_MODE_EXCLUSIVE` value for `sharingMode`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `queueFamilyIndexCount`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pQueueFamilyIndices`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a variable of type `VkImage` named `image`. In it, a handle of a created
    image will be stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCreateImage( logical_device, &image_create_info, nullptr, &image )`,
    for which provide the handle of the logical device, a pointer to the `image_create_info`
    variable, a `nullptr` value, and a pointer to the `image` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the value return by the `vkCreateImage()` call was equal to `VK_SUCCESS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to create an image, we need to prepare multiple parameters: the
    image''s type, dimensions (size), number of components, and the number of bits
    for each component (format). We also need to know whether the image will contain
    mipmaps or whether it will have multiple layers (a normal image must contain at
    least one, and a cubemap image must contain at least six). We should also think
    about the intended usage scenarios, which are also defined during image creation.
    We can''t use an image in a way that wasn''t defined during its creation.'
  prefs: []
  type: TYPE_NORMAL
- en: Images can only be used for purposes (usages) specified during their creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of purposes for which images can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_TRANSFER_SRC_BIT` specifies that the image can be used as a
    source of data for copy operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_TRANSFER_DST_BIT` specifies that we can copy data to the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_SAMPLED_BIT` indicates that we can sample data from the image
    inside shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_STORAGE_BIT` specifies that the image can be used as a storage
    image inside shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` specifies that we can render into an
    image (use it as a color render target/attachment in a framebuffer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` indicates that the image can
    be used as a depth and/or stencil buffer (as a depth render target/attachment
    in a framebuffer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` indicates that the memory bound to
    the image will be allocated lazily (on demand)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` specifies that the image can be used
    as an input attachment inside shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different usage scenarios require different image layouts to be used. These
    are changed (transitioned) using image memory barriers. But during creation, we
    can specify only `VK_IMAGE_LAYOUT_UNDEFINED` (if we don't care about the initial
    contents) or `VK_IMAGE_LAYOUT_PREINITIALIZED` (if we want to upload data by mapping
    the **host-visible** memory), and we always need to transition to another layout
    before the actual use.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the image parameters are specified through a variable of type `VkImageCreateInfo`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create an image, we also need to specify the tiling. It defines the
    image''s memory structure. There are two available types of image tiling: linear
    and optimal.'
  prefs: []
  type: TYPE_NORMAL
- en: When using **linear tiling**, as the name suggests, an image's data is laid
    out in memory linearly, similarly to buffers or C/C++ arrays. This allows us to
    map an image's memory and read it or initialize it directly from our application,
    because we know how the memory is organized. Unfortunately, it restricts us from
    using an image for many purposes; for example, we can't use an image as a depth
    texture or as a cubemap (some drivers may support it, but it is not required by
    the specification and, in general, we shouldn't rely on it). Linear tiling can
    also lower the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: For the best performance, it is recommended to create images with optimal tiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images with **optimal tiling** can be used for all purposes; they also have
    much better performance. But this comes with a trade-off--we don''t know how the
    image''s memory is organized. In the following diagram we can see an example of
    image''s data and it''s internal structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_03-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Each type of graphics hardware can store image data in a different way that
    is optimal for it. Because of that, we can't map an image's memory and initialize
    or read it directly from our application. In this situation, we are required to
    use **staging resources**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are ready, we can create an image with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a 2D image and view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and binding a memory object to an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images, similarly to buffers, are not created with a bound memory storage. We
    need to implicitly create a memory object and bind it to the image. We can also
    use an existing memory object for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a physical device from which a logical device was created.
    Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkPhysicalDeviceMemoryProperties` named `physical_device_memory_properties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkGetPhysicalDeviceMemoryProperties( physical_device, &physical_device_memory_properties
    )`, for which provide the handle of the physical device and a pointer to the `physical_device_memory_properties`
    variable. This call will store memory parameters (number of heaps, their size,
    and types) of the physical device used for processing submitted operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a logical device created from the physical device, represented
    by the `physical_device` variable. Store the handle in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a created image represented by a variable of type `VkImage`
    named `image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkMemoryRequirements` named `memory_requirements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire the parameters of the memory that needs to be used for the image. Do
    this by calling `vkGetImageMemoryRequirements( logical_device, image, &memory_requirements
    )` and providing the handle of the logical device in the first parameter, the
    handle of the created image in the second parameter, and a pointer to the `memory_requirements`
    variable in the third parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkDeviceMemory` named `memory_object`, that will
    represent the memory object created for the image and assign a `VK_NULL_HANDLE`
    value to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkMemoryPropertyFlagBits` named `memory_properties`.
    Store additional (chosen) memory properties in the variable, or a `0` value if
    no additional properties are required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the available physical device''s memory types, represented by
    the `memoryTypeCount` member of a `physical_device_memory_properties` variable.
    Do this by using a variable of type `uint32_t` named `type`. For each loop iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the bit on the position, represented by the `type` variable in
    the `memoryTypeBits` member of the `memory_requirements` variable, is set.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the `memory_properties` variable has the same bits set as a `propertyFlags`
    member of the memory type `memoryTypes`, at index `type` in the `physical_device_memory_properties`
    variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If points 1 and 2 are not true, continue iterating the loop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkMemoryAllocateInfo` named `image_memory_allocate_info`
    and assign the following values for its members:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_requirements.size` variable for `allocationSize`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` variable for `memoryTypeIndex`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkAllocateMemory( logical_device, &image_memory_allocate_info, nullptr,
    &memory_object )`, for which provide the handle of the logical device, a pointer
    to the `image_memory_allocate_info` variable, a `nullptr` value, and a pointer
    to the `memory_object` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful by checking whether the value returned by
    the call was equal to `VK_SUCCESS`, and stop iterating the loop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that memory object allocation inside the loop was successful by checking
    whether the `memory_object` variable is not equal to `VK_NULL_HANDLE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the memory object to the image by calling `vkBindImageMemory( logical_device,
    image, memory_object, 0 )` , for which provide the `logical_device`, `image` and
    `memory_object` variables and a `0` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful and the returned value was equal to `VK_SUCCESS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly to the memory object created for a buffer, we start by checking what
    memory types are available on a given physical device and what their properties
    are. We can, of course, omit these steps and gather this information once at the
    initialization stage of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we acquire the specific memory requirements of a given image. These can
    (and probably will) be different for each image, as they depend on the format,
    size, number of mipmaps and layers, and other properties of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to find a memory type that has proper parameters and is compatible
    with the image''s memory requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we iterate over all available memory types. If a given bit of the `memoryTypeBits`
    member of an image's memory properties is set, this means that a memory type with
    the same number is compatible with the image and we can use it for the memory
    object. We can also check for other properties of the memory type and find the
    one that is suitable for our needs. For example, we may want to use a memory that
    can be mapped on the CPU (a **host-visible** memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether the memory object allocation inside the loop was successful.
    And if yes, we bind the created memory object with our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we can use the image for all purposes defined during its creation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to binding memory objects to buffers, we should allocate bigger memory
    objects and bind parts of them to multiple images. This way, we perform fewer
    memory allocations and the driver has to track a smaller number of memory objects.
    This may improve the performance of our application. It may also allow us to save
    some memory, as each allocation may require more memory than requested during
    allocation (in other words, its size may always be rounded up to a multiple of
    the memory page size). Allocating bigger memory objects and reusing parts of them
    for multiple images spares us the wasted area.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting an image memory barrier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are created for various purposes--they are used as textures, by binding
    them to a pipeline via descriptor sets, as render targets, or as presentable images
    in swapchains. We can copy data to or from images--these are also separate usages
    defined during image creation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start using an image for any purpose, and every time we want to change
    the current usage of a given image, we need to inform a driver about this operation.
    We do this by using image memory barriers which are set during command buffer
    recording.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe, a custom structure type `ImageTransition` is
    introduced. It has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `CurrentAccess` and `NewAccess` members define types of memory operations
    that were taking place in regard to a given image before the barrier, and that
    will occur after the barrier.
  prefs: []
  type: TYPE_NORMAL
- en: In Vulkan, images used for different purposes may have different internal memory
    organization. In other words, the memory of a given image may have a different
    layout for different image usages. When we want to start using an image in a different
    way, we also need to change this memory layout. This is done through the `CurrentLayout`
    and `NewLayout` members.
  prefs: []
  type: TYPE_NORMAL
- en: Memory barriers also allow us to transfer queue family ownership if an image
    was created with an exclusive sharing mode. In the `CurrentQueueFamily` member,
    we define the index of a family from which queues have been using an image so
    far. In `NewQueueFamily`, we need to define a family index for queues that will
    be using an image after the barrier. We can also use a `VK_QUEUE_FAMILY_IGNORED`
    special value for both when we don't want to transfer an ownership.
  prefs: []
  type: TYPE_NORMAL
- en: The `Aspect` member defines the image's usage "context". We can choose from
    color, depth, or stencil aspects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prepare parameters for each image you want to set up a barrier for. Store them
    in a vector of type `std::vector<ImageTransition>` named `image_transitions`.
    For each image, use the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Image's handle in an `Image` member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of memory operations that involved the image so far in the `CurrentAccess`
    member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of memory operations that will be performed on the image from now on, after
    the barrier, in the `NewAccess` member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Current image's internal memory layout in `CurrentLayout` member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout image's memory should change into after the barrier in `NewLayout` member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Index of a queue family that has been referencing the image so far (or a `VK_QUEUE_FAMILY_IGNORED`
    value if we don't want to transfer queue ownership) in the `CurrentQueueFamily`
    member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Index of a queue family that will be referencing the image from now on (or a
    `VK_QUEUE_FAMILY_IGNORED` value if we don't want to transfer queue ownership)
    in the `NewQueueFamily` member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image's aspect (color, depth, or stencil) in the `Aspect` member
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a vector variable of type `std::vector<VkImageMemoryBarrier>` named `image_memory_barriers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each element of the `image_transitions` variable, add a new element to
    the `image_memory_barriers` vector. Use the following values for members of the
    new element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER` value for `sType` member.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentAccess` value of the current element for `srcAccessMask`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewAccess` value of the current element for `dstAccessMask`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentLayout` member of the current element for `oldLayout`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewLayout` value of the current element for `newLayout`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentQueueFamily` value of the current element for `srcQueueFamilyIndex`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewQueueFamily` value of the current element for `dstQueueFamilyIndex`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image's handle for `image`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following values for the `subresourceRange` member of the new element:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aspect` member of the current element for `aspectMask`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `baseMipLevel`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_REMAINING_MIP_LEVELS` value for `levelCount`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `baseArrayLayer`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_REMAINING_ARRAY_LAYERS` value for `layerCount`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the handle of the command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the command buffer represented by the `command_buffer` handle is in
    the recording state (that the recording operation was started for the command
    buffer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of a bitfield type `VkPipelineStageFlags` named `generating_stages`.
    In this variable, store values representing pipeline stages that have been using
    the image so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of a bitfield type `VkPipelineStageFlags` named `consuming_stages`.
    In this variable, store values representing pipeline stages in which the image
    will be referenced after the barrier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages,
    0, 0, nullptr, 0, nullptr, static_cast<uint32_t>(image_memory_barriers.size()),
    &image_memory_barriers[0] )` and provide the handle of the command buffer in the
    first parameter, and the `generating_stages` and `consuming_stages` variables
    in the second and third parameters respectively. The number of elements of the
    `image_memory_barriers` vector should be provided in the second to last parameter,
    and the last parameter should point to the first element of the `image_memory_barriers`
    vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, operations are processed in a pipeline. Even though the processing
    of operations needs to be started in the order in which they were submitted, parts
    of the pipeline may still be executed concurrently. But sometimes, we may need
    to synchronize these operations and tell the driver that we want some of them
    to wait for results of other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Memory barriers are used to define moments in command buffers' execution, in
    which later commands should wait for the earlier commands to finish their job.
    They also cause the results of these operations to become visible for other operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Barriers are needed for memory operations to become visible for later commands.
    In cases where the operations write data to images and further operations will
    read from them, we need to use image memory barriers. The opposite situation also
    requires memory barriers to be used--operations that overwrite images'' data should
    wait for earlier operations to stop reading data from them. Failing to do so,
    in both cases, will make the contents of an image invalid. But such situations
    should be as rare as possible or our application may suffer from performance loss.
    This is because such a pause in the command buffer''s execution causes stalls
    in the graphics hardware''s processing pipeline and, as a result, time being wasted:'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid a negative impact on the performance of our application, we should
    set up parameters for as many images as possible in as few barriers as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Image memory barriers are also used to define a change in how images are used.
    Such a usage change typically also requires us to synchronize submitted operations;
    that's why this is also done through memory barriers. For the purpose of changing
    an image's usage, we need to define types of memory operations that were performed
    on an image before and after the barrier (memory access). We also specify what
    the memory layout was before the barrier, and how memory should be laid out after
    the barrier. This is because images may have different memory organization when
    they are used for different purposes. For example, sampling data from images inside
    shaders may need them to be cached in such a way that neighbor texels are also
    neighbors in memory. But, writing data to images may be performed faster when
    a memory is laid out linearly. That's why image layouts were introduced in Vulkan.
    Each image usage has its own, designated layout. There is one, general layout,
    which can be used for all purposes. But, using the general layout is not recommended
    because it may impact the performance on some hardware platforms.
  prefs: []
  type: TYPE_NORMAL
- en: For the best performance, it is recommended to use designated image memory layouts
    for specific usages, though care must be taken if layout transitions are performed
    too frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters that define usage change are specified through the variables of
    a `VkImageMemoryBarrier` type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'But for the barrier to work properly, we also need to define pipeline stages
    in which images have been used so far, and in which images will be used from now
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_005.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see two examples of pipeline barriers. On the
    left, color is generated by the fragment shader and, after all the fragment tests
    (depth test, blending), color data is written into the image. This image is then
    used in the vertex shader of the successive commands. There is a high chance that
    such a setup will generate stalls in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example on the right shows another dependency in graphics commands. Here,
    data is written into a resource in the vertex shader. Such data is then used by
    the fragment shader of the next command. This time, there is a high probability
    that all instances of the vertex shader will finish their jobs before the fragment
    shader of the next command begins executing. That''s why it is important to lower
    the number of pipeline barriers and, if required, to properly set up drawing commands
    and choose pipeline stages for the barrier. The parameters of the barrier (generating
    and consuming stages) are aggregated for all images specified in the barrier using
    the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the image is used in the same way multiple times and is not used for other
    purposes in between, we don't need to set a barrier before the image is actually
    used. We set it to signal the usage change, not the usage itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are rarely used directly in Vulkan commands. Framebuffers and shaders
    (via descriptor sets) access images through image views. Image views define a
    selected part of an image's memory and specify additional information needed to
    properly read an image's data. That's why we need to know how to create an image
    view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device and use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the handle of a created image to initialize a variable of type `VkImage`
    named `image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkImageViewCreateInfo` named `image_view_create_info`.
    Use the following values for its members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `flags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image` variable for `image`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of image view for `viewType`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Format of an image or other compatible format (if you want to reinterpret it
    inside the view) for `format`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_COMPONENT_SWIZZLE_IDENTITY` value for all members of a `components` member'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following values for members of a `subresourceRange` member:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image's aspect (color, depth, or stencil) for `aspectMask`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `baseMipLevel`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_REMAINING_MIP_LEVELS` value for `levelCount`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` for `baseArrayLayer`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_REMAINING_ARRAY_LAYERS` for `layerCount`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a variable of type `VkImageView` named `image_view`. We will store a
    handle of a created image view in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCreateImageView( logical_device, &image_view_create_info, nullptr, &image_view
    )`, for which provide the handle of the logical device, a pointer to the `image_view_create_info`
    variable, a `nullptr` value, and a pointer to the `image_view` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful by comparing the returned value with the `VK_SUCCESS`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image view defines additional metadata used for accessing the image. Through
    it, we can specify the parts of an image that should be accessed by the commands.
    Though this recipe shows how to create an image view for the whole image data,
    it is possible to specify a smaller range of the resource which should be accessed.
    For example, when we render into an image inside a render pass, we can specify
    that only one mipmap level should be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Image view also defines how an image's memory should be interpreted. A good
    example is an image with multiple layers. For it, we can define an image view
    that interprets the image directly, as a layered image, or we can use image view
    to create a cubemap from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameters are specified like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The image view creation is performed through a single call of the `vkCreateImageView()`
    function. An example of such a call is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a 2D image and view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 2D image and view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common image type that is used in many popular applications or games
    is typical 2D textures with four RGBA components and 32 bits per texel. To create
    such a resource in Vulkan, we need to create a 2D image and a proper image view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a handle of a logical device and use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the data format used in the image and initialize a variable of type `VkFormat`
    named `format` with the selected value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the size of the image. Store it in a variable of type `VkExtent2D` named
    `size`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the number of mipmap levels that should compose the image. Initialize
    a variable of type `uint32_t` named `num_mipmaps` with the selected number of
    mipmaps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the number of image layers using a variable of type `uint32_t` named
    `num_layers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the number of per texel samples and store it in a variable of type `VkSampleCountFlagBits`
    named `samples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of all the purposes for which the image will be used in the application.
    Store the value that is a logical sum (**OR**) of all these usages in a variable
    of type `VkImageUsageFlags` named `usage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an image of `VK_IMAGE_TYPE_2D` type using the `logical_device`, `format`,
    `size`, `num_mipmaps`, `num_layers`, `samples`, and `usage` variables. Store the
    handle of the created image in a variable of type `VkImage` named `image` (refer
    to the *Creating an image* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a physical device from which the `logical_device` handle
    was acquired. Store the physical device's handle in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire the memory properties of the `physical_device` and use them to allocate
    a memory object that will be bound to an image represented by the `image` variable.
    Make sure a memory type with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    is used. Store the allocated memory object in a variable of type `VkDeviceMemory`
    named `memory_object` (refer to the *Allocating and binding memory object to an
    image* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the image's aspect used for the image view creation (color or depth and/or
    stencil) and store it in a variable of type `VkImageAspectFlags` named `aspect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an image view of a `VK_IMAGE_VIEW_TYPE_2D` type. Use the `logical_device`,
    `image`, `format`, and `aspect` variables during image view creation. Store the
    created handle in a variable of type `VkImageView` named `image_view` (refer to
    the *Creating an image view* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Image creation requires us to perform three general steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a memory object (or use an existing one) and bind it to the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an image view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For an image typically used as a texture, we need to create an image of the
    type `VK_IMAGE_TYPE_2D` and the format `VK_FORMAT_R8G8B8A8_UNORM`, but we can
    set these parameters as we want. The rest of the image's properties depend on
    the size of the image (in other words, we are creating a texture from an existing
    image file and we need to match its dimensions), the type of filtering that should
    applied to an image (if we want to use mipmapping), the number of samples (if
    it should be multisampled), and the desired usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Image creation defined in the *Creating an image* recipe can be simplified
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to allocate and bind a memory object to the image as described
    in the *Allocating and binding a memory object to an image* recipe. For the best
    performance, the memory object should be allocated on a fast, **device-local**
    memory like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can of course use an existing memory object if it fulfills the image's memory
    requirements and has enough storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we must create an image view. With it, we can tell the hardware
    how the image data should be interpreted. We can also use a different (but still
    compatible) format for an image view. But for many (if not most) purposes, it
    is not necessary and we will specify the same format that was used for the image.
    For standard 2D textures, we also use a color aspect for view creation, but for
    images with depth data (in other words, for images used as depth attachments),
    depth aspect must be specified. For more details on image view creation, follow
    the *Creating an image view* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, the image is ready to be used in our application. We can upload data from
    a file to the image and use it as a texture inside shaders (in this case, we also
    need a sampler and descriptor sets). We can also bind the image's view to a framebuffer
    and use it as a color attachment (render target).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a layered 2D image with a CUBEMAP view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quite common example of images used in 3D applications or games are CUBEMAPs,
    used for simulating an object reflecting its environment. For this purpose, we
    don't create a CUBEMAP image. We need to create a layered image and through image
    view, we tell the hardware that it should interpret its layers as six CUBEMAP
    faces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a handle of a logical device. Store it in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the size of an image and remember it must be square. Save the image's
    dimensions in a variable of type `uint32_t` named `size`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the number of the image's mipmap levels. Initialize a variable of type
    `uint32_t` named `num_mipmaps` with the chosen number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think about all different scenarios in which the image will be used. Store the
    logical sum (OR) of all these usages in a variable of type `VkImageUsageFlags`
    named `usage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an image of a `VK_IMAGE_TYPE_2D` type, a `VK_FORMAT_R8G8B8A8_UNORM` format,
    six layers, and one sample per texel. Use the `logical_device`, `size`, `num_mipmaps`,
    and `usage` variables for the rest of the image parameters. Store the handle of
    the created image in a variable of type `VkImage` named `image` (refer to the
    *Creating an image* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of the physical device from which the `logical_device` handle
    was acquired. Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire the memory properties of a `physical_device`. Use them to allocate a
    memory object using a memory type with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`
    property. Store the handle of the allocated memory object in a variable of type
    `VkDeviceMemory` named `memory_object`, and bind it to the image (refer to the
    *Allocating and binding a memory object to an image* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the color aspect and store it in a variable of a `VkImageAspectFlags`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: type named `aspect`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an image view of a `VK_IMAGE_VIEW_TYPE_CUBE` type and a `VK_FORMAT_R8G8B8A8_UNORM`
    format. Use the `logical_device`, `image`, and `aspect` variables during image
    view creation. Store the created handle in a variable of type `VkImageView` named
    `image_view` (refer to the *Creating an image view* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of creating a CUBEMAP is very similar to creating any other type
    of images. First, we create the image itself. We just need to remember that the
    image should have at least six layers that will be interpreted as six CUBEMAP
    faces. For CUBEMAPs, we also cannot use more than one sample per texel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we allocate and bind a memory object in the same way as for other resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create an image view. Through it, we specify a CUBEMAP
    view type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When using a CUBEMAP image view, image layers correspond to faces in the order
    +X, -X, +Y, -Y, +Z, and -Z.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping, updating and unmapping host-visible memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For images and buffers that are used during rendering, it is recommended to
    bind a memory that is located on the graphics hardware (**device-local** memory).
    This gives us the best performance. But we can't access such memory directly,
    and we need to use intermediate (staging) resources which mediate the data transfer
    between a GPU (device) and a CPU (host).
  prefs: []
  type: TYPE_NORMAL
- en: '**Staging resources**, on the other hand, need to use memory that is **host-visible**.
    To upload data to such memory, or to read data from it, we need to map it.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a created logical device and store it in a variable of type
    `VkDevice` named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a memory object that was allocated on a memory type with a `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`
    property. Store the memory object's handle in a variable of type `VkDeviceMemory`
    named `memory_object`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a memory region that should be mapped and updated. Store the offset (in
    bytes) from the beginning of a memory object's memory in a variable of type `VkDeviceSize`
    named `offset`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the size of data to be copied to the selected region of the memory object.
    Represent the data size with a variable of type `VkDeviceSize` named `data_size`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare data that should be copied to the memory object. Set up a pointer to
    the beginning of the data and use it to initialize a variable of type `void*`
    named `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `void*` named `pointer`. It will contain a pointer
    to the mapped memory range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the memory with a `vkMapMemory( logical_device, memory_object, offset, data_size,
    0, &local_pointer )` call. Provide handles of the logical device and the memory
    object, offset from the start of the memory and the size (in bytes) of the region
    we want to map, a `0` value, and a pointer to the `pointer` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful by checking whether the returned value was
    equal to `VK_SUCCESS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the prepared data to the memory pointed to by the `pointer` variable.
    It can be done with the following call: `std::memcpy( local_pointer, data, data_size
    )`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkMappedMemoryRange>` named `memory_ranges`.
    For each modified range, add an element to the vector and use the following values
    to initialize its members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE` value for `sType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_object` variable for `memory`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Offset of each range for `offset`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Size of each range for `size`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inform the driver which parts of the memory have changed. Do this by making
    the `vkFlushMappedMemoryRanges( logical_device, static_cast<uint32_t>(memory_ranges.size()),
    &memory_ranges[0] )` call, for which provide the `logical_device` variable, the
    number of modified ranges (elements in the `memory_ranges` vector), and a pointer
    to the first element of the `memory_ranges` vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the flushing was successful and the call returned a `VK_SUCCESS` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To unmap the memory, call `vkUnmapMemory( logical_device, memory_object )`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mapping the memory is the simplest way to upload data to the Vulkan resources.
    During the mapping, we specify which part of the memory should be mapped (offset
    from the beginning of the memory object and a size of the mapped range):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Mapping gives us a pointer to the requested memory part. We can use this pointer
    like we use other pointers in typical C++ applications. There are no restrictions
    on whether we write or read data from such memory. In this recipe, we copy data
    from the application to the memory object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we update the mapped memory range, we need to inform the driver that memory
    contents were modified or the uploaded data may not immediately become visible
    for other operations submitted to queues. Informing about the memory data modifications
    performed by the CPU (host) is called flushing. For this, we prepare a list of
    updated memory ranges which don''t need to cover the whole mapped memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After we are done dealing with a mapped memory, we can unmap it. Memory mapping
    shouldn''t influence the performance of our application and we can keep the acquired
    pointer for the whole lifetime of our application. But, we should release it (unmap)
    before we close the application and destroy all resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data between buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, to upload data to a buffer, we are not limited only to the memory
    mapping technique. It is possible to copy data between buffers, even if the memory
    objects bound to them were allocated from different memory types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer. Store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state
    (refer to the *Beginning a command buffer recording operation* recipe from [Chapter
    3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the buffer from which data will be copied. Represent this buffer with a
    variable of type `VkBuffer` named `source_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the buffer to which data will be uploaded. Represent this buffer using
    a variable of type `VkBuffer` named `destination_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `std::vector<VkBufferCopy>` named `regions`. For each
    memory region from which data should be copied, add an element to the `regions`
    vector. In each element, specify the memory offset in the source buffer from which
    data should be copied, a memory offset in the target buffer to which data should
    be copied, and the size of data to be copied from a given region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCmdCopyBuffer( command_buffer, source_buffer, destination_buffer, static_cast<uint32_t>(regions.size()),
    &regions[0] )`, for which use the `command_buffer`, `source_buffer` and `destination_buffer`
    variables, the number of elements in the `regions` vector, and a pointer to the
    first element of that vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copying data between buffers is another way of updating the memory contents
    of a given resource. This operation needs to be recorded to the command buffer,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For the best performance, resources that are used during rendering should have
    a device-local memory bound. But, we can't map such memory. Using the `vkCmdCopyBuffer()`
    function, we can copy data to such a buffer from another buffer that has a host-visible
    memory bound to it. Such memory can be mapped and updated directly from our application.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers from which data can be copied must be created with a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers into which we transfer data must be created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to use a buffer as a target for transfer operations (we want to
    copy data to the buffer), we should set a memory barrier that will inform the
    driver that from now on, operations performed on the buffer are represented by
    a `VK_ACCESS_TRANSFER_WRITE_BIT` memory access scheme. After we are done copying
    data to the destination buffer and we want to use it for the desired purpose,
    we should set another memory barrier. This time, we should specify that previously
    we were transferring data to the buffer (so the operations were represented by
    the `VK_ACCESS_TRANSFER_WRITE_BIT` memory access type), but after the barrier
    the buffer will be used differently, with another memory access type representing
    operations performed on it (refer to the *Setting a buffer memory barrier* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting a buffer memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update a buffer with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data from a buffer to an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For images, we can bind memory objects that are allocated from different memory
    types. Only host-visible memory can be mapped and updated directly from our application.
    When we want to update the memory of an image that uses a device-local memory,
    we need to copy data from a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is already in a recording
    state (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a buffer from which data will be copied. Store its handle in a variable
    of type `VkBuffer` named `source_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the image to which data will be copied. Represent this image with a variable
    of type `VkImage` named `destination_image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkImageLayout` named `image_layout`, in which the
    image's current layout will be stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkBufferImageCopy>` named `regions`.
    For each memory region from which data should be copied, add an element to the
    `regions` vector. Specify the following values for members of each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Offset from the beginning of a buffer's memory from which data should be copied
    for `bufferOffset`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of data that represents a single row in the buffer or a `0` value
    if the data is tightly packed (according to the size of the destination image)
    for `bufferRowLength`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of the imaginary image stored in the buffer or a `0` value if the
    buffer's data is tightly packed (according to the size of the destination image)
    for `bufferImageHeight`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialize the `imageSubresource` member with the following values:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image's aspect (color, depth or stencil) for `aspectMask`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number (index) of mipmap level to be updated for `mipLevel`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of the first array layer to be updated for `baseArrayLayer`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of array layers that will be updated for `layerCount`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial offset (in texels) of image's sub region that should be updated for
    `imageOffset`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The size (dimensions) of an image for `imageExtent`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkCmdCopyBufferToImage( command_buffer, source_buffer, destination_image,
    image_layout, static_cast<uint32_t>(regions.size()), &regions[0] )`, for which
    use the `command_buffer`, `source_buffer`, `destination_image` and `image_layout`
    variables, the number of elements in the `regions` vector, and a pointer to the
    first element of that vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copying data between a buffer and an image is done through a command buffer,
    in which we record the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We need to know how the image data is laid out inside the buffer, so the image's
    memory is properly uploaded. We need to provide a memory offset (from the beginning
    of the buffer's memory), the length of the data row, and the height of the data
    in a buffer. This allows the driver to properly address the memory and copy the
    buffer's contents into the image. We can also provide zeros for row length and
    a height, which means that the buffer contains data that is tightly packed and
    it corresponds to the destination image's dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to provide information about the destination of a data transfer
    operation. This involves defining an offset from the image's origin (from the
    upper-left corner in texels) for x, y, and z dimensions, the mipmap level into
    which data will be copied and a base array layer, and the number of layers that
    will be updated. We also need to specify the destination image's dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding parameters are specified through an array of `VkBufferImageCopy`
    elements. We can provide many regions at once and copy memory ranges that are
    not continuous.
  prefs: []
  type: TYPE_NORMAL
- en: On hardware architectures with several different memory types exposed by a physical
    device, it is recommended to use a device-local-only memory for resources that
    are used during rendering (performance-critical paths of our application). Such
    memory is usually faster than the memory that is also host-visible. Host-visible
    memory should be used only for staging resources which are used to upload data
    from, or download data to, the CPU (our application).
  prefs: []
  type: TYPE_NORMAL
- en: On architectures with only one memory type that is both device-local and host-visible,
    we don't need to bother with intermediate staging resources for data upload. But,
    the presented approach is still valid and may unify the application's behavior
    across different execution environments. This may make maintenance of our application
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we can easily map the staging resource's memory and access it
    in our application. Next we can use it to transfer data to and from a device-local
    memory, which (generally) cannot be mapped. This is achieved with the copy operation
    described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers from which data can be copied must be created with a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Images into which we transfer data must be created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    usage. Before the transfer operation, we also need to transition the image layout
    to a `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can transfer data to an image, we must change its memory layout. We
    can only copy data to an image whose current memory layout is set to `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`.
    We can also use a `VK_IMAGE_LAYOUT_GENERAL` layout, but it is not recommended
    due to lower performance.
  prefs: []
  type: TYPE_NORMAL
- en: So before we can copy data to an image, we should set a memory barrier that
    will change the image's memory access type from the one that occurred so far to
    a `VK_ACCESS_TRANSFER_WRITE_BIT`. The barrier should also perform a layout transition
    from the current layout to the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` layout.
    After we are done copying data to the image and we want to use it for other purposes,
    we should set another memory barrier. This time, we should change the memory access
    type from `VK_ACCESS_TRANSFER_WRITE_BIT` to the access that corresponds to the
    purpose for which the image will be used. And we should also transition the image's
    layout from `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` to the one that is compatible
    with the image's next usage (refer to the *Setting an image memory barrier* recipe).
    Without these barriers, not only might the data transfer operation be invalid,
    but the data might not become visible for other operations performed on the image.
  prefs: []
  type: TYPE_NORMAL
- en: If the buffer that is a source of data is used for other purposes, we should
    also set a memory barrier for it and perform similar memory access changes before
    and after the transfer operation. But as the buffer is a source of data, we set
    a `VK_ACCESS_TRANSFER_READ_BIT` access type in the first barrier. It can be done
    with the same pipeline barriers which changed the parameters of the image. Refer
    to the *Setting a buffer memory barrier* recipe for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting a buffer memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Copying data from an image to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data from an image to a buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, we can not only transfer data from a buffer to an image, but also
    the other way--we can copy data from an image to the buffer. It doesn't matter
    what the properties of memory objects bound to them are. But, the data copy operation
    is the only way to update a device-local memory which cannot be mapped.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is already in a recording
    state (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take an image from which data will be copied. Store its handle in a variable
    of type `VkImage` named `source_image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the source image's current memory layout and use it to initialize a variable
    of type `VkImageLayout` named `image_layout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the buffer to which data will be copied. Prepare its handle in a variable
    of type `VkBuffer` named `destination_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<VkBufferImageCopy>` named `regions`.
    For each region in the memory from which data should be copied, add an element
    to the `regions` vector. Specify the following values for members of each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Offset from the beginning of a buffer's memory to which data should be copied
    for `bufferOffset`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of data that will compose a single row in the buffer or a `0` value
    if the data is tightly packed (according to the size of the source image) for
    `bufferRowLength`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of the image in the buffer (number of rows) or a `0` value if the
    buffer's data is tightly packed (according to the size of the source image) for
    `bufferImageHeight`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialize `imageSubresource` member with the following values:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image's aspect (color, depth or stencil) for `aspectMask`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number (index) of a mipmap level from which data will be copied for `mipLevel`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Index of the first array layer from which contents will be copied for `baseArrayLayer`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of array layers to copy for `layerCount`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial offset (in texels) of image's subregion from which data will be read
    and copied to buffer for `imageOffset`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of an image for `imageExtent`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `vkCmdCopyImageToBuffer( command_buffer, source_image, image_layout, destination_buffer,
    static_cast<uint32_t>(regions.size()), &regions[0] )`, for which use the `command_buffer`,
    `source_image`, `image_layout`, and `destination_buffer` variables, the number
    of elements in the `regions` vector, and a pointer to the first element of that
    vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data copy from an image to a buffer is an operation that is recorded to the
    command buffer like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The command buffer must be already in a recording state.
  prefs: []
  type: TYPE_NORMAL
- en: For the data to be copied properly, we need to provide multiple parameters that
    define the source of the data and the destination to which the data will be copied.
    These parameters consist of an offset from the image's origin (from the upper-left
    corner in texels) for x, y, and z dimensions, the mipmap level and a base array
    layer from which data will be copied, and the number of layers that will be the
    source of the data. Image dimensions are also required.
  prefs: []
  type: TYPE_NORMAL
- en: For the destination buffer, we specify a memory offset (from the beginning of
    the buffer's memory), the length of the data row and the height of the data in
    a buffer. We can also provide zeros for row length and height, which means that
    the data copied to the buffer will be tightly packed and will correspond to the
    source image's dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding parameters are specified using an array of `VkBufferImageCopy`
    elements, similar to copying data from a buffer to an image as described in the
    *Copying data from a buffer to an image* recipe. We can provide many regions and
    copy memory ranges that are not continuous all as part of one copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: Images from which we copy data must be created with a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    usage. Before the transfer operation, we also need to transition the image's layout
    to a `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers to which data can be copied must be created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can copy data from an image, we should set a memory barrier and change
    the image's layout from the one currently used to the `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` layout.
    We also should change the type of memory access from the one that occurred so
    far to `VK_ACCESS_TRANSFER_READ_BIT`. A barrier should also be set after we are
    done copying data from the image, if it will be used for other purposes from now
    on. This time, we should change the memory access type from `VK_ACCESS_TRANSFER_READ_BIT`
    to the access that corresponds to the purpose for which the image will be used.
    At the same time, we should transition the layout from `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`
    to the one that is compatible with the image's next usage (refer to the *Setting
    an image memory barrier* recipe). Without these barriers, not only might the data
    transfer operation be performed in the wrong way, but later commands may overwrite
    the image's contents before the transfer operation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: Similar barriers should be set for the buffer (but they can be a part of the
    same pipeline barrier). If previously the buffer was used for other purposes,
    we should change the memory access to `VK_ACCESS_TRANSFER_WRITE_BIT` before the
    transfer operation, as described in the *Setting a buffer memory barrier* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting a buffer memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Copying data from a buffer to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a staging buffer to update a buffer with a device-local memory bound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Staging resources are used to update the contents of a memory that is not host-visible.
    Such memory cannot be mapped, so we need an intermediate buffer whose contents
    can be easily mapped and updated, and from which data can be transferred.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device stored in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the data that should be uploaded to the target buffer. Set up a pointer
    to the beginning of a data source and store it in a variable of type `void*` named
    `data`. The size of the data (in bytes) should be represented with a variable
    of type `VkDeviceSize` named `data_size`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkBuffer` named `staging_buffer`. In it, the handle
    of a staging buffer will be stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a buffer that is big enough to hold the `data_size` number of bytes.
    Specify `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage during buffer creation. Use the
    `logical_device` variable during the creation process and store the created handle
    in the `staging_buffer` variable (refer to the *Creating a buffer* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of the physical device from which the `logical_device` handle
    was created. Use the physical device's handle to initialize a variable of type
    `VkPhysicalDevice` named `physical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkDeviceMemory` named `memory_object` that will be
    used to create a memory object for the staging buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate a memory object using the `physical_device`, `logical_device`, and
    `staging_buffer` variables. Allocate a memory object from a memory type that has
    a `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` property. Store the created handle in
    the `memory_object` variable and bind it to the staging buffer (refer to the *Allocating
    and binding a memory object to a buffer* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the memory of the `memory_object` using the `logical_device` variable, a
    `0` value for offset, and the `data_size` variable for the size of the mapped
    memory. Copy the data from the `data` pointer to the memory pointed to by the
    acquired pointer. Un-map the memory (refer to the *Mapping, updating, and unmapping
    host-visible memory* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of an allocated primary command buffer and use it to initialize
    a variable of type `VkCommandBuffer` named `command_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin recording of the `command_buffer`. Provide a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`
    flag (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a buffer to which data will be transferred. Make sure it
    was created with a `VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage. Store its handle
    in a variable of type `VkBuffer` named `destination_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record a memory barrier for a `destination_buffer` in the `command_buffer` variable.
    Provide pipeline stages which have been referencing the `destination_buffer` so
    far for the generating stages, and use a `VK_PIPELINE_STAGE_TRANSFER_BIT` stage
    for the consuming stages. Provide the type of memory access operations that have
    been referencing the buffer so far and use a `VK_ACCESS_TRANSFER_WRITE_BIT` value
    for the new memory access type. Ignore queue family indices--provide `VK_QUEUE_FAMILY_IGNORED`
    for both indices (refer to the *Setting a buffer memory barrier* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkDeviceSize` named `destination_offset`, and initialize
    it with an offset value to which data should be transferred to in the target buffer's
    memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy data from the `staging_buffer` to the `destination_buffer` using the `command_buffer`
    variable. Provide a `0` value for the source offset, the `destination_offset`
    variable for the destination offset, and the `data_size` variable for the size
    of the data to be transferred (refer to the *Copying data between buffers* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record another memory barrier for the `destination_buffer` in the `command_buffer`
    variable. Provide a `VK_PIPELINE_STAGE_TRANSFER_BIT` value for the generating
    stages and a set of pipeline stages in which `destination_buffer` will be used
    from now on. Use the `VK_ACCESS_TRANSFER_WRITE_BIT` value for the current memory
    access type and a value that is proper for the way in which the buffer will be
    used after the memory transfer. Use a `VK_QUEUE_FAMILY_IGNORED` value for queue
    family indices (refer to the *Setting a buffer memory barrier* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End recording of the `command_buffer` (refer to the *Ending a command buffer
    recording operation* recipe in [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of the queue on which the transfer operation will be performed
    and store it in a variable of type `VkQueue` named `queue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list of semaphores that should be signaled when the transfer operation
    is completed. Store their handles in a variable of type `std::vector<VkSemaphore>`
    named `signal_semaphores`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkFence` named `fence`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an unsignaled fence using the `logical_device` variable. Store the created
    handle in the `fence` variable (refer to the *Creating a fence* recipe from [Chapter
    3](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201),
    *Command Buffers and Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submit `command_buffer` to the `queue`. Provide a list of semaphores from the
    `signal_semaphores` vector as a list of semaphores to be signaled, and the `fence`
    variable for the fence to be signaled (refer to the *Submitting command buffers
    to the queue* recipe in [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the fence object to be signaled using the `logical_device` and `fence`
    variables. Provide a desired timeout value (refer to the *Waiting for fences*
    recipe in [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destroy the buffer represented by the `staging_buffer` variable (refer to the
    *Destroying a buffer* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Free the memory object represented by the `memory_object` variable (refer to
    the *Freeing a memory object* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a staging resource for a transfer operation, we need a buffer with a
    memory that can be mapped. We can use an existing buffer or create a new one like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to map the buffer''s memory and update its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With a staging buffer ready, we can begin a transfer operation that will copy
    the data to the desired, target buffer. First, we start by beginning the command
    buffer recording operation and setting a memory barrier for the destination buffer
    to change its usage to the target for data copy operation. We don''t need the
    memory barrier for the staging buffer. When we map and update the buffer''s memory,
    its contents become visible for other commands, because an implicit barrier is
    set for the host writer when we start a command buffer recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can record data copying from the **staging resource** to the destination
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we need a second memory barrier for the target buffer. This time,
    we change its usage from being a target of copy operations to the one the buffer
    will be used for after the data transfer. We can also end command buffer recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a fence and submit the command buffer to the queue, where it
    will be processed and the data transfer will be actually performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t want to use a staging buffer any more, we can destroy it. But,
    we can''t do this until the staging buffer won''t be used any more by the commands
    submitted to the queue: that''s why we need a fence. We wait on it until the driver
    signals when the processing of a submitted command buffer has finished. Then,
    we can safely destroy a staging buffer and free the memory object bound to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In real-life scenarios, we should use an existing buffer and reuse it as a staging
    buffer as many times as possible to avoid unnecessary buffer creation and destruction
    operations. This way, we also avoid waiting on a fence.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201),
    *Command Buffers and Synchronization*, see the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ending a command buffer recording operation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a fence*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Waiting for fences*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to the queue*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Copying data from a buffer to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a staging buffer to update an image with a device-local memory bound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Staging** buffers can be used not only to transfer data between buffers,
    but also to and from an image. Here, we will show how to map a buffer''s memory
    and copy its contents to a desired image.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a staging buffer big enough to hold the entire data to be transferred.
    Specify a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage for the buffer and store its
    handle in a variable of type `VkBuffer` named `staging_buffer`. Allocate a memory
    object that supports the `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` property and bind
    it to the staging buffer. Store the memory object's handle in a variable of type
    `VkDeviceMemory` named `memory_object`. Map the memory and update its contents
    with the data to be transferred to the image. Unmap the memory. Perform these
    steps as described in more detail in the *Using a staging buffer to update a buffer
    with a device-local memory bound* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a primary command buffer and use it to initialize a variable
    of type `VkCommandBuffer` named `command_buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin recording of the `command_buffer`. Provide a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`
    flag (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of the image to which data will be transferred and make sure
    it was created with a `VK_IMAGE_USAGE_TRANSFER_DST_BIT` specified. Use the handle
    to initialize a variable of type `VkImage` named `destination_image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record an image memory barrier in the `command_buffer`. Specify the stages in
    which the image was used so far and use a `VK_PIPELINE_STAGE_TRANSFER_BIT` stage
    for the consuming stages. Use the `destination_image` variable, provide the image's
    current access, and use a `VK_ACCESS_TRANSFER_WRITE_BIT` value for the new access.
    Specify the image's current layout and use a `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
    value for the new layout. Provide the image's aspect, but ignore queue family
    indices--use `VK_QUEUE_FAMILY_IGNORED` values for both (refer to the *Setting
    an image memory barrier* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `command_buffer`, record the data transfer operation from `staging_buffer`
    to `destination_image`. Provide a `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` value
    as an image layout, a `0` value for the buffer's offset, a `0` value for the buffer's
    row lengths, and a `0` value for the buffer's image height. Specify the image's
    memory region into which data should be copied by providing the desired mipmap
    level, base array layer index, and the number of layers to be updated. Provide
    the image's aspect too. Specify the offset into the image's x, y, and z coordinates
    (in texels) and the image's size (refer to the *Copying data from a buffer to
    an image* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record another image memory barrier into the `command_buffer`. This time, specify
    a `VK_PIPELINE_STAGE_TRANSFER_BIT` value for generating stages and set proper
    stages in which the target image will be used after the data transfer. In the
    barrier, change the image's layout from `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
    into the value proper for the new usage. Set a `VK_QUEUE_FAMILY_IGNORED` value
    for both queue families and also provide the image's aspect (refer to the *Setting
    an image memory barrier* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End the command buffer recording operation, create an unsignaled fence and use
    it, along with semaphores that should be signaled, during submitting the command
    buffer to the queue. Wait for the created fence to be signaled, destroy the staging
    buffer, and free its memory object as described in the *Using a staging buffer
    to update a buffer with a device-local memory bound* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is very similar to the *Using a staging buffer to update a buffer
    with a device-local memory bound* recipe; that's why only the differences are
    described in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we create a staging buffer, allocate a memory object for it, bind it
    to the buffer, and map it to upload data from our application to the GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we begin command buffer recording, and set one barrier for the destination
    image so it can be used as a target for data transfer. We also record the data
    transfer operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we record another barrier that changes the image''s usage from being
    the target of the copy operation to the one that is valid for the purpose for
    which the image will be used next. We also end the command buffer recording operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we create a fence and submit a command buffer to the queue. We
    then wait on the fence to know the moment when we can safely delete the staging
    buffer and its memory object. We do it afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we are reusing the existing buffer as a staging resource, we don't need the
    fence, because the buffer will live much longer, maybe for the whole lifetime
    of the application. This way, we can avoid frequent and unnecessary buffer creation
    and deletion, and memory object allocation and freeing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&action=edit#post_201),
    *Command Buffer and Synchronization*, see the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ending a command buffer recording operation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a fence*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Waiting for fences*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to the queue*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting an image memory barrier*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapping, updating, and unmapping host-visible memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Copying data from a buffer to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a staging buffer to update an image with a device-local memory bound*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an image view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we don't need an image view any more, we should destroy it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of an image view stored in a variable of type `VkImageView`
    named `image_view`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroyImageView( logical_device, image_view, nullptr )` and provide
    the handle of the logical device, the handle of the image view, and a `nullptr`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `image_view` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Destroying an image view requires us to use its handle and the handle of the
    logical device on which the image view was created. It is performed in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the handle is not empty. We don't need to do it--destroying
    a null handle is silently ignored. But it's good to skip unnecessary function
    calls. Next, we destroy the image view and assign a null handle to the variable
    in which the handle was stored.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating an image view* recipe in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images that won't be used any more should be destroyed to release their resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a logical device and store its handle in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the image's handle to initialize a variable of type `VkImage` named `image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroyImage( logical_device, image, nullptr )`. Provide the handle
    of the logical device, the handle of the image, and a `nullptr` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `image` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Images are destroyed through a single call of the `vkDestroyImage()` function.
    For it, we provide the handle of the logical device, the handle of the image,
    and a `nullptr` value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We also try to avoid unnecessary function calls by checking whether the image's
    handle is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating an image* recipe in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying a buffer view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we don't need a buffer view any more, we should destroy it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a logical device and store its handle in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the buffer's view handle and initialize a variable of type `VkBufferView`
    named `buffer_view` with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroyBufferView( logical_device, buffer_view, nullptr )`. Provide
    the handle of the logical device, the handle of the buffer view, and a `nullptr`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `buffer_view` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Buffer views are destroyed using the `vkDestroyBufferView()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To avoid unnecessary function calls, we check whether the buffer view's handle
    is not empty before we call a buffer view destroying function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating a buffer view* recipe in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freeing a memory object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vulkan, when we create resources, we later destroy them. On the other hand,
    resources that represent different memory objects or pools are allocated and freed.
    Memory objects bound to images and buffers are also freed. We should free them
    when we no longer need them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the logical device's handle and store it in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the variable of type `VkDeviceMemory` named `memory_object`, in which the
    handle of the memory object is stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkFreeMemory( logical_device, memory_object, nullptr )`. Use the handle
    of the logical device, the handle of the memory object, and a `nullptr` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `memory_object`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory objects can be freed before resources that were using them are destroyed.
    But we can't use these resources any more, we can only destroy them. In general,
    we can't bind one memory object to the resource, free it, and then bind another
    memory object to the same resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'To free a memory object, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Memory objects must have been allocated from a logical device represented by
    the `logical_device` variable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to a buffer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding a memory object to an image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying a buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a buffer is no longer used, we should destroy it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the buffer's handle in a variable of type `VkBuffer` named `buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroyBuffer( logical_device, buffer, nullptr )` and provide the handle
    of the logical device, the handle of the buffer, and a `nullptr` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `buffer` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Buffers are destroyed using the `vkDestroyBuffer()` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`logical_device` is a variable representing the logical device on which the
    buffer was created. When we destroy a buffer, we assign an empty handle to the
    variable representing this buffer, so we won''t try to destroy the same resource
    twice.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating a buffer view* recipe in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
