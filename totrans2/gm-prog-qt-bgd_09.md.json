["```cpp\nimport QtQuick 2.1\n```", "```cpp\nItem { }\n```", "```cpp\nItem {\n  x: 10\n  y: 20\n  width: 400\n  height: 300\n}\n```", "```cpp\nRectangle {\n  color: \"red\"\n  width: 400\n  height: 400\n}\n```", "```cpp\nRectangle {\n  color: \"red\"\n  width: 400\n height: width\n}\n```", "```cpp\nRectangle {\n  height: width\n  color: \"red\"\n  width: 400\n}\n```", "```cpp\nRectangle {\n  width: 600\n  height: 400\n color: width > height ? \"red\" : \"blue\"\n}\n```", "```cpp\nRectangle {\n  width: 600\n  height: 400\n color: colorFromSize()\n\n function colorFromSize() {\n if(width == height) return \"green\"\n if(width > height) return \"red\"\n return \"blue\"\n }\n}\n```", "```cpp\nfunction colorByTime() {\n  var d = new Date()\n  var minutes = d.getMinutes()\n  if(minutes < 15) return \"red\"\n  if(minutes < 30) return \"green\"\n  if(minutes < 45) return \"blue\"\n  return \"purple\"\n}\n```", "```cpp\nRectangle {\n  color: \"red\"\n  width: 400\n  height: 300\n border.width: 4\n border.color: \"black\"\n}\n```", "```cpp\nRectangle {\n  color: \"red\"\n  width: 400\n  height: 300\n border {\n width: 4\n color: \"black\"\n }\n}\n```", "```cpp\nRectangle {\n  border { width: 2; color: \"black\" }\n  radius: 5\n  color: \"transparent\"\n  width: 50; height: 30\n\n  Text {\n    text: \"Button Text\"\n  }\n}\n```", "```cpp\nRectangle {\n  border { width: 2; color: \"black\" }\n  radius: 5\n  color: \"transparent\"\n width: buttonText.width+8; height: buttonText.height+8\n\n  Text {\n id: buttonText\n    text: \"Button Text\"\n x:4; y: 4\n  }\n}\n```", "```cpp\nRectangle {\n id: button\n  border { width: 2; color: \"black\" }\n  radius: 5\n  color: \"transparent\"\n width: 4 + buttonIcon.width + 4 + buttonText.width + 4\n height: Math.max(buttonIcon.height, buttonText.height) + 8\n\n Image {\n id: buttonIcon\n source: \"edit-undo.png\"\n x: 4; y: button.height/2-height/2\n }\n  Text { \n    id: buttonText\n    text: \"Button Text\"\n x: 4+buttonIcon.width+4\n y: button.height/2-height/2\n  }\n}\n```", "```cpp\nanchors.left: otherObject.right\n```", "```cpp\nRectangle {\n  border { width: 2; color: \"black\" }\n  radius: 5\n  color: \"transparent\"\n  width: 4 + buttonIcon.width + 4 + buttonText.width + 4\n  height: Math.max(buttonIcon.height, buttonText.height) + 8\n\n  Image {\n    id: buttonIcon\n    source: \"edit-undo.png\"\n anchors {\n left: parent.left;\n leftMargin: 4;\n verticalCenter: parent.verticalCenter\n }\n  }\n  Text {\n    id: butonText\n    text: \"Button Text\"\n anchors {\n left: buttonIcon.right;\n leftMargin: 4;\n verticalCenter: parent.verticalCenter\n }\n  }\n}\n```", "```cpp\nRectangle {\n  id: button\n  anchors.centerIn: parent\n  border { width: 1; color: \"black\" }\n  radius: 5\n  width: 100; height: 30\n  gradient: Gradient {\n    GradientStop { position: 0; color: \"#eeeeee\" }\n    GradientStop { position: 1; color: \"#777777\" }\n  }\n}\n```", "```cpp\nRectangle {\n  id: button\n  // …\n  gradient: Gradient {\n    GradientStop { position: 0; color: \"#eeeeee\" }\n    GradientStop { position: 1; color: \"#777777\" }\n  }\n  width: buttonContent.width+8\n  height: buttonContent.height+8\n\n  Row {\n    id: buttonContent\n    anchors.centerIn: parent\n    spacing: 4\n\n    Image {\n        id: buttonIcon\n        source: \"edit-undo.png\"\n    }\n    Text {\n        id: buttonText\n        text: \"ButtonText\"\n    }\n  }\n}\n```", "```cpp\nclip: true\nimplicitWidth: Math.max(buttonContent.implicitWidth+8, 80)\nimplicitHeight: buttonContent.implicitHeight+8\n```", "```cpp\nimport QtQuick 2.0\n\nRectangle {\n  width: 360\n  height: 360\n  Button {\n    id: button\n  }\n}\n```", "```cpp\nRectangle {\n  id: button\n  // ... \n  Row { ... }\n MouseArea {\n id: buttonMouseArea\n\n anchors.fill:parent\n onClicked: button.clicked()\n }\n}\n```", "```cpp\nRectangle {\n  id: button\n\n signal clicked()\n  // ...\n}\n```", "```cpp\nonClicked: console.log(\"Clicked!\")\n```", "```cpp\nRow {\n  id: buttonContent\n  // …\n  anchors.verticalCenterOffset: buttonMouseArea.pressed ? 1 : 0\n  anchors.horizontalCenterOffset: buttonMouseArea.pressed ? 1 : 0\n  // …\n}\n```", "```cpp\nhoverEnabled: true\n```", "```cpp\nText {\n  id: buttonText\n  text: \"ButtonText\"\n color: buttonMouseArea.containsMouse ? \"white\" : \"black\"\n}\n```", "```cpp\nMouseArea {\n  anchors.fill: parent\n  hoverEnabled: true\n\n  onClicked: {\n    switch(mouse.button) {\n      case Qt.LeftButton:   console.log(\"Left button clicked\"); break;\n      case Qt.MiddleButton: console.log(\"Middle button clicked\"); break;\n      case Qt.RightButton:  console.log(\"Right button clicked\"); break;\n    }\n  }\n  onPositionChanged: {\n    console.log(\"Position: [\"+mouse.x+\"; \"+mouse.y+\"]\")\n  }\n}\n```", "```cpp\nRectangle {\n  id: button\n property color topColor: \"#eeeeee\"\n property color bottomColor: \"#777777\"\n property color textColor: \"black\"\n property color textPressedColor: \"white\"\n  signal clicked()\n```", "```cpp\ngradient: Gradient {\n  GradientStop { position: 0; color: button.topColor }\n  GradientStop { position: 1; color: button.bottomColor }\n}\n```", "```cpp\nText {\n  id: buttonText\n  text: \"ButtonText\"\n color: buttonMouseArea.containsMouse ?\n button.textPressedColor : button.textColor\n}\n```", "```cpp\nproperty alias pressed: buttonMouseArea.pressed\n```", "```cpp\nproperty int foo: someobject.prop\nproperty alias bar: someobject.prop\n```", "```cpp\n  foo = 7\n  bar = 7\n```", "```cpp\nButton {\n  // …\n\n  onPressedChanged: {\n  console.log(\"The button is currently \"\n  +(pressed ? \"\" : \"not \")+\"pressed\")\n}\n```", "```cpp\nRectangle {\n  id: circle\n  width: 60; height: width\n  radius: width/2\n  color: \"red\"\n}\n```", "```cpp\nMouseArea {\n  anchors.fill: parent\n  drag.target: circle\n}\n```", "```cpp\nImage {\n  id: image\n  anchors.centerIn: parent\n  source: \"wilanow.jpg\"\n}\n```", "```cpp\nPinchArea {\n  anchors.fill: parent\n  pinch {\n    target: image\n    minimumScale: 0.2; maximumScale: 2.0\n    minimumRotation: -90; maximumRotation: 90\n  }\n}\n```", "```cpp\nMouseArea {\n  acceptedButtons: Qt.LeftButton|Qt.RightButton\n  onPositionChanged: console.log(mouse.button)\n}\n```", "```cpp\nfocus: true\n```", "```cpp\nRectangle {\n  focus: true\n  Keys.onPressed:  { if(event.key == Qt.Key_Space) color = \"red\"  }\n  Keys.onReleased: { if(event.key == Qt.Key_Space) color = \"blue\" }\n}\n```", "```cpp\nRectangle {\n  focus: true\n  Keys.onSpacePressed:      color = \"purple\"\n  Keys.onReturnPressed:     color = \"navy\"\n  Keys.onVolumeUpPressed:   color = \"blue\"\n  Keys.onRightPressed:      color = \"green\"\n  Keys.onEscapePressed:     color = \"yellow\"\n  Keys.onTabPressed:        color = \"orange\"\n  Keys.onDigit0Pressed:     color = \"red\"\n}\n```", "```cpp\nimport QtQuick 2.1\nItem {\n  property int number: 0\n  width: 200; height: width\n  focus: true\n  Keys.onSpacePressed: number++\n\n  Text { text: number; anchors.centerIn: parent }\n}\n```", "```cpp\nKeys.onSpacePressed: if(!event.isAutoRepeat) number++\n```", "```cpp\nRow {\n  spacing: 5\n\n  Rectangle {\n    id: first\n    width: 50; height: width\n    color: focus ? \"blue\" : \"lightgray\"\n    focus: true\n\n    KeyNavigation.right: second\n  }\n  Rectangle {\n    id: second\n    width: 50; height: width\n    color: focus ? \"blue\" : \"lightgray\"\n\n    KeyNavigation.right: third\n    KeyNavigation.left: first\n  }\n  Rectangle {\n    id: third\n    width: 50; height: width\n    color: focus ? \"blue\" : \"lightgray\"\n\n    KeyNavigation.left: second\n  }\n}\n```", "```cpp\nTextInput {\n  id: ipAddress\n  width: 100\n  validator: RegExpValidator {\n    regExp: /\\d+\\.\\d+\\.\\d+\\.\\d+/ \n    /* four numbers separated by dots*/\n  }\n  focus: true\n}\n```", "```cpp\nRectangle {\n  id: textInputFrame\n  width: 200\n  height: 40\n  border { color: \"black\"; width: 2 }\n  radius: 10\n  antialiasing: true\n  color: \"darkGray\"\n}\nTextInput {\n  id: textInput\n  anchors.fill: textInputFrame\n  anchors.margins: 5\n  font.pixelSize: height-2\n  verticalAlignment: TextInput.AlignVCenter\n  clip: true\n}\n```", "```cpp\nimport QtQuick 2.0\n\nClock {\n  id: clock\n  width:  400\n  height: 400\n}\n```", "```cpp\nimport QtQuick 2.0\n\nItem {\n  id: clock\n\n  property color color: \"lightgray\"\n\n  Rectangle {\n    id: plate\n\n    anchors.centerIn: parent\n    width: Math.min(clock.width, clock.height)\n    height: width\n    radius: width/2\n    color: clock.color\n    border.color: Qt.darker(color)\n    border.width: 2\n  }\n}\n```", "```cpp\nRepeater {\n  model: 12\n\n  Item {\n    id: hourContainer\n\n    property int hour: index\n    height: plate.height/2\n    transformOrigin: Item.Bottom\n    rotation: index * 30\n    x: plate.width/2\n    y: 0\n\n    Rectangle {\n      width: 2\n      height: (hour % 3 == 0) ? plate.height*0.1 \n                              : plate.height*0.05\n      color: plate.border.color\n      antialiasing: true\n      anchors.horizontalCenter: parent.horizontalCenter\n      anchors.top: parent.top\n      anchors.topMargin: 4\n    }\n  }\n}\n```", "```cpp\nimport QtQuick 2.0\n\nRectangle {\n  id: root\n\n  property int value: 0\n  property int granularity: 60\n  property alias length: root.height\n  width: 2\n  height: parent.height/2\n  radius: width/2\n  antialiasing: true\n  anchors.bottom: parent.verticalCenter\n  anchors.horizontalCenter: parent.horizontalCenter\n  transformOrigin: Item.Bottom\n  rotation: 360/granularity * (value % granularity)\n}\n```", "```cpp\nNeedle {\n  length: plate.height*0.3\n  color: \"blue\"\n  value: clock.hours; granularity: 12\n}\nNeedle {\n  length: plate.height*0.4\n  color: \"darkgreen\"\n  value: clock.minutes; granularity: 60\n}\nNeedle {\n  width: 1\n  length: plate.height*0.45\n  color: \"red\"\n  value: clock.seconds; granularity: 60\n}\n```", "```cpp\nproperty int hours: 0\nproperty int minutes: 0\nproperty int seconds: 0\n```", "```cpp\nimport QtQuick 2.0\n\nClock {\n  id: clock\n  width:  400\n  hours: 7\n  minutes: 42\n  seconds: 17\n}\n```", "```cpp\nvar currentDate = new Date()\nvar hours   = currentDate.getHours()\nvar minutes = currentDate.getMinutes()\nvar seconds = currentDate.getSeconds()\n```", "```cpp\nItem {\n  id: clock\n  property int hours:   currentDate.getHours()\n  property int minutes: currentDate.getMinutes()\n  property int seconds: currentDate.getSeconds()\n  property var currentDate: new Date()\n  // ...\n}\n```", "```cpp\nItem {\n  id: clock\n  property int hours: currentDate.getHours()\n  property int minutes: currentDate.getMinutes()\n  property int seconds: currentDate.getSeconds()\n  readonly property var currentDate: new Date()\n  property alias running: timer.running\n  Timer {\n    id: timer\n    repeat: true\n    interval: 500\n    running: true\n    onTriggered: clock.currentDate = new Date()\n  }\n}\n```", "```cpp\nimport \"Bar\"\n```", "```cpp\nimport \"Foo.Bar\"\n```", "```cpp\nComponent {\n  id: circleComponent\n  Item {\n    property int diameter: 20\n    property alias color: rect.color\n    property alias border: rect.border\n\n    implicitWidth: diameter\n    implicitHeight: diameter\n\n    Rectangle {\n      id: rect  \n      width: radius; height: radius; radius: diameter/2\n      anchors.centerIn: parent\n    }\n  }\n}\n```", "```cpp\nvar circleComponent = Qt.createComponent(\"circle.qml\")\n```", "```cpp\nvar circleComponent = Qt.createComponent(\"http://example.com/circle.qml\")\nif(circleComponent.status === Component.Ready) {\n  // use the component\n} else {\n  circleComponent.statusChanged.connect(function() {\n    if(circleComponent.status === Component.Ready) {\n       // use the component\n    }\n  })\n}\n```", "```cpp\nif(circleComponent.status === Component.Error) {\n  console.warn(circleComponent.errorString())\n}\n```", "```cpp\nvar circle = circleComponent.createObject(someItem)\n```", "```cpp\ncircle.diameter = 20\ncircle.color = 'red'\n```", "```cpp\nvar circle = circleComponent.createObject(someItem, {diameter: 20, color: 'red'})\n```", "```cpp\nLoader {\n  id: ldr\n}\nldr.source = \"MightySword.qml\"You could also directly attach a real component to sourceComponent of a Loader:\nComponent {\n  id: swordComponent\n  // ...\n}\nLoader {\n  id: ldr\n  sourceComponent: shouldBeLoaded ? swordComponent : undefined\n}\n```", "```cpp\nLoader {\n  anchors {\n    left: parent.left; leftMargin: 0.2*parent.width\n    right: parent.right;\n    verticalCenter: parent.verticalCenter\n  }\n  height: 250\n\n  source: \"Armor.qml\"\n}\n```", "```cpp\nRectangle {\n  Component.onCompleted: console.log(\"Rectangle created\")\n}\n```", "```cpp\nItem {\n  id: root\n\n  QtObject {\n    id: priv\n    property bool complete: false\n\n    function layoutItems() {\n      if(!complete) return\n      // ...\n    }\n  }\n  onChildrenChanged: priv.layoutItems()\n  Component.onCompleted: { priv.complete = true; priv.layoutItems(); }\n}\n```", "```cpp\nimport QtQuick 2.2\n\nCanvas {\n  id: canvas\n\n  implicitWidth: 600\n  implicitHeight: 300\n\n  onPaint: {\n    var ctx = canvas.getContext(\"2d\")\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n  }\n}\n```", "```cpp\nproperty int lineWidth: 2\nproperty var points: []\nproperty real arg: -Math.PI\n```", "```cpp\nTimer {\n  interval: 10\n  repeat: true\n  running: true\n  onTriggered: {\n    arg += Math.PI/180\n    while(arg >= Math.PI) arg -= 2*Math.PI\n  }\n}\n```", "```cpp\nonArgChanged: {\n  points.push(func(arg))\n  points = points.slice(-canvas.width)\n  canvas.requestPaint()\n}\n```", "```cpp\nfunction func(argument) {\n  var a=(2*Math.PI/10); var b=4*Math.PI/5\n  return Math.sin(20*argument) * (\n      Math.exp(-Math.pow(argument/a, 2)) +\n      Math.exp(-Math.pow((argument-b)/a,2)) +\n      Math.exp(-Math.pow((argument+b)/a,2))\n  )\n}\n```", "```cpp\nonPaint: {\n  var ctx = canvas.getContext(\"2d\")\n  ctx.reset()\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n  var pointsToDraw = points.slice(-canvas.width)\n  ctx.translate(0, canvas.height/2)\n  ctx.beginPath()\n  ctx.moveTo(0, -pointsToDraw[0]*canvas.height/2)\n  for(var i=1; i<pointsToDraw.length; i++)\n    ctx.lineTo(i, -pointsToDraw[i]*canvas.height/2)\n  ctx.lineWidth = canvas.lineWidth\n  ctx.stroke()\n}\n```", "```cpp\nQtObject {\n  id: priv\n  property var points: []\n  property real arg: -Math.PI\n\n  onArgChanged: {\n    points.push(func(arg))\n    points = points.slice(-canvas.width)\n    canvas.requestPaint()\n  }\n}\n```", "```cpp\nonPaint: {\n    ...\n // fill:\n ctx.beginPath()\n ctx.moveTo(0, 0)\n var i\n for(i=0; i<pointsToDraw.length; i++)\n ctx.lineTo(i, -pointsToDraw[i]*canvas.height/2)\n ctx.lineTo(i, 0)\n var gradient = ctx.createLinearGradient(0, -canvas.height/2, 0, canvas.height/2)\n gradient.addColorStop(0.1, canvas.topColor)\n gradient.addColorStop(0.5, Qt.rgba(1, 1, 1, 0))\n    gradient.addColorStop(0.9, canvas.bottomColor)\n    ctx.fillStyle = gradient\n    ctx.fill()\n\n    // stroke:\n    ctx.beginPath()\n    ctx.moveTo(0, -pointsToDraw[0]*canvas.height/2)\n    for(var i=1; i<pointsToDraw.length; i++)\n        ctx.lineTo(i, -pointsToDraw[i]*canvas.height/2)\n    ctx.lineWidth = canvas.lineWidth\n    ctx.strokeStyle = canvas.color\n    ctx.stroke()\n}\n```", "```cpp\nimport QtQuick 2.3\nimport QtQuick.Window 2.2\n\nWindow {\n  visible: true\n  width: 360\n  height: 360\n\n  MouseArea {\n    anchors.fill: parent\n    onClicked: {\n      Qt.quit();\n    }\n  }\n\n  Text {\n    text: qsTr(\"Hello World\")\n    anchors.centerIn: parent\n  }\n}\n```", "```cpp\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n\nint main(int argc, char *argv[])\n{\n  QGuiApplication app(argc, argv);\n\n  QQmlApplicationEngine engine;\n  engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n  return app.exec();\n}\n```", "```cpp\n#include <QGuiApplication>\n#include <QQuickView>\n\nint main(int argc, char *argv[])\n{\n  QGuiApplication app(argc, argv);\n\n  QQuickView view;\n  view.setSource(QUrl::fromLocalFile(QStringLiteral(\"main.qml\")));\n  view.show();\n\n  return app.exec();\n}\n```", "```cpp\nQQmlEngine *engine = new QQmlEngine;\nQQmlComponent component(engine, QUrl::fromLocalFile(QStringLiteral(\"main.qml\")));\nQObject *object = component.create();\n```", "```cpp\nQQuickItem *item = qobject_cast<QQuickItem*>(object);\nQ_CHECK_PTR(item); // assert to check if qobject_cast returned a valid pointer\nitem->setOpacity(0.5);\n```", "```cpp\nQQuickView *view;\n// …\nQQmlComponent component(view->engine(), QUrl::fromLocalFile(\"foobar.qml\"));\ncomponent.create();\n```", "```cpp\nQQmlComponent component(engine, QUrl::fromLocalFile(\"ComplexObject.qml\"));\nQQmlIncubator incubator;\ncomponent.create(incubator);\nwhile(!incubator.isError() && !incubator.isReady())\n  QCoreApplication::processEvents();\nQObject *object = incubator.isReady() ? incubator.object() : 0;\n```", "```cpp\nimport QmlProject 1.1\n\nProject {\n  mainFile: \"main.qml\"\n\n  importPaths: [ \"plugins\" ]\n\n  QmlFiles {\n    files: [ \"Clock.qml\", \"Needle.qml\" ]\n  }\n  JavaScriptFiles {\n    directory: \".\"\n  }\n  ImageFiles {\n    directory: \".\"\n  \t}\n}\n```", "```cpp\nimport QtQuick 2.0\n\nItem {\n  width: 400; height: 400\n  Rectangle {\n    id: rect\n    objectName: \"redRectangle\"\n    color: \"red\"\n    anchors.centerIn: parent\n    width: height; height: parent.height*2/3\n  }\n  Rectangle {\n    id: circle\n    objectName: \"blueCircle\"\n    color: \"blue\"\n    anchors.centerIn: parent\n    radius: width/2; width: height; height: parent.height*1/3\n  }\n}\n```", "```cpp\nQObject *root = view->rootObject();\nQObject *rect = root->findChild<QObject*>(\"redRectangle\");\nQObject *circle = root->findChild<QObject*>(\"blueCircle\");\nif(circle && rect)\n    circle->setProperty(\"width\", rect->property(\"width\").toInt());\n```", "```cpp\nQQmlContext *context = new QQmlContext(engine);\nQObject *object = new MyObject(...);\ncontext->setContextProperty(\"foo\", object);\n```", "```cpp\nQQmlContext *parentContext = new QQmlContext(engine);\nQQmlContext *childContext1 = new QQmlContext(parentContext);\nQQmlContext *childContext2 = new QQmlContext(parentContext);\nQQmlContext *childContext3 = new QQmlContext(parentContext);\nQObject *objectA = new A, *objectB = new B, *object C = new C;\nparentContext->setContextProperty(\"foo\", objectA);\nchildContext1->setContextProperty(\"foo\", objectB);\nchildContext2->setContextProperty(\"foo\", objectC);\n```", "```cpp\nint temperature = 17;\ndouble humidity = 0.648;\nQDate today = QDate::currentDate();\nengine->rootContext()->setContextProperty(\"temperature\", temperature);\nengine->rootContext()->setContextProperty(\"humidity\", humidity);\nengine->rootContext()->setContextProperty(\"today\", Qt.formatDate(today, \"\"));\n```", "```cpp\nimport QtQuick 2.0\n\nRectangle {\n  id: root\n  width: 400; height: width; radius: width/10\n  color: \"navy\"\n  border { width: 2; color: Qt.darker(root.color) }\n\n  Grid {\n    id: grid\n    anchors.centerIn: parent\n    columns: 2; spacing: 5\n    Text { color: \"white\"; font.pixelSize: 20; text: \"Temperature:\" }\n    Text { color: \"white\"; font.pixelSize: 20; text: temperature+\"°C\"}\n    Text { color: \"white\"; font.pixelSize: 20; text: \"Humidity:\" }\n    Text { color: \"white\"; font.pixelSize: 20; text: humidity*100+\"%\"}\n  }\n  Text {\n    anchors {\n      horizontalCenter: grid.horizontalCenter;\n      bottom: grid.top; bottomMargin: 5\n    }\n    font.pixelSize: 24; color: \"white\"\n    text: \"Weather for \"+Qt.formatDate(today)\n  }\n}\n```", "```cpp\nQVariantMap weather;\nweather[\"temperature\"] = 17;\nweather[\"humidity\"] = 0.648;\nweather[\"today\"] = QDate::currentDate();\nengine->rootContext()->setContextProperty(\"weather\", weather);\n```", "```cpp\nGrid {\n  // ...\n  Text { color: \"white\"; font.pixelSize: 20; text: \"Temperature:\" }\n  Text { color: \"white\"; font.pixelSize: 20; text: weather.temperature+\"°C\" }\n  Text { color: \"white\"; font.pixelSize: 20; text: \"Humidity:\" }\n  Text { color: \"white\"; font.pixelSize: 20; text: weather.humidity*100+\"%\"}\n}\nText {\n  // ...\n  text: \"Weather for \"+Qt.formatDate(weather.today)\n}\n```", "```cpp\n  Q_PROPERTY(int rpm READ rpm NOTIFY rpmChanged)\n  Q_PROPERTY(int gear READ gear NOTIFY gearChanged)\n  Q_PROPERTY(int speed READ speed NOTIFY speedChanged)\n  Q_PROPERTY(QDate today READ today NOTIFY todayChanged)\n  Q_PROPERTY(double distance READ distance NOTIFY distanceChanged)\n```", "```cpp\nint CarInfo::speed() const { return m_speed; }\nvoid CarInfo::setSpeed(int newSpeed) {\n  if(m_speed == newSpeed) return;\n  m_speed = newSpeed;\n  emit speedChanged(m_speed);\n}\n```", "```cpp\nqreal CarInfo::distance() const { return ui->distanceBox->value(); }\n```", "```cpp\nvoid CarInfo::setDistance(qreal newDistance) \n{ ui->distanceBox->setValue(newDistance); }\n```", "```cpp\nconnect(ui->distanceBox, SIGNAL(valueChanged(double)), this, SIGNAL(distanceChanged(double)));\n```", "```cpp\nint main(int argc, char **argv) {\n  QApplication app(argc, argv);\n  CarInfo cinfo;\n  cinfo.show();\n  return app.exec();\n};\n```", "```cpp\nint main(int argc, char **argv) {\n  QApplication app(argc, argv);\n  CarInfo cinfo;\n  QQuickView view;\n view.engine()->rootContext()->setContextProperty(\"carData\", &cinfo);\n view.setSource(\"qrc:/main.qml\");\n  view.show();\n  cinfo.show();\n  return app.exec();\n};\n```", "```cpp\nimport QtQuick 2.3\n\nImage {\n  source: \"dashboard.png\"\n  Item {\n    id: leftContainer\n    anchors.centerIn: parent\n    anchors.horizontalCenterOffset: -550\n    width: 400; height: width\n  }\n  Item {\n    id: middleContainer\n    anchors.centerIn: parent\n    width: 700; height: width\n  }\n  Item {\n    id: rightContainer\n    anchors.centerIn: parent\n    anchors.horizontalCenterOffset: 525\n    width: 400; height: width\n  }\n}\n```", "```cpp\nimport QtQuick 2.0\n\nItem {\n  id: root\n  property int length: parent.width*0.4\n  property color color: \"white\"\n  property color middleColor: \"red\"\n  property int size: 2\n\n  Rectangle {    // needle\n    width: root.size\n    height: length+20\n    color: root.color\n    anchors.horizontalCenter: parent.horizontalCenter\n    anchors.bottom: parent.bottom\n    anchors.bottomMargin: -20\n    antialiasing: true\n  }\n  Rectangle {    // fixing\n    anchors.centerIn: parent\n    width: 8+root.size; height: width; radius: width/2\n    color: root.color\n    Rectangle {  // middle dot\n      anchors { fill: parent; margins: parent.width*0.25 }\n      color: root.middleColor\n    }\n  }\n}\n```", "```cpp\nfunction calculatePosition(angle, radius) {\n  if( radius === undefined) radius = width/2*0.8\n  var a = angle * Math.PI/180 // convert degrees to radians\n  var px = width/2 + radius * Math.cos(a)\n  var py = width/2 + radius * Math.sin(a)\n  return Qt.point(px, py)\n}\n```", "```cpp\nItem {\n  id: middleContainer\n  // ...\n  function calculatePosition(angle, radius) { /* ... */ }\n  Repeater {\n    model: 24/2\n    Item {\n      property point pt:\n      middleContainer.calculatePosition(120+index*12*2)\n      x: pt.x; y: pt.y\n      Label {\n        anchors.centerIn: parent\n        text: index*20\n      }\n    }\n  }\n  Needle {\n    anchors.centerIn: parent\n    length: parent.width*0.35\n    size: 4\n    rotation: 210+(carData.speed*12/10)\n    color: \"yellow\"\n  }\n}\n```", "```cpp\nimport QtQuick 2.0\n\nText {\n  color: \"white\"\n  font.pixelSize: 24\n}\n```", "```cpp\nRepeater {\n  model: 120-4\n\n  Item {\n    property point pt: middleContainer.calculatePosition(\n      120+index*1.2*2, middleContainer.width*0.35\n    )\n    x: pt.x; y: pt.y\n    Rectangle {\n      width: 2\n      height: index % 5 ? 5 : 10\n        color: \"white\"\n        rotation: 210+index*1.2*2\n        anchors.centerIn: parent\n        antialiasing: true\n    }\n  }\n}\n```", "```cpp\nText {\n    anchors.centerIn: parent\n    anchors.verticalCenterOffset: 40\n    text: \"SPEED\\n[kph]\"\n    horizontalAlignment: Text.AlignHCenter\n    color: \"#aaa\"\n    font.pixelSize: 16\n}\n```", "```cpp\nItem {\n  id: gearContainer\n  anchors.centerIn: parent\n  anchors.horizontalCenterOffset: 10\n  anchors.verticalCenterOffset: -10\n\n  Text {\n    id: gear\n    property int value: carData.gear\n    property var gears: [\n \"R\", \"N\",\n      \"1<sup>st</sup>\", \"2<sup>nd</sup>\", \"3<sup>rd</sup>\",\n \"4<sup>th</sup>\", \"5<sup>th</sup>\"\n    ]\n    text: gears[value+1]\n    anchors.left: parent.left\n    anchors.bottom: parent.bottom\n    color: \"yellow\"\n    font.pixelSize: 32\n    textFormat: Text.RichText\n  }\n}\n```", "```cpp\nQ_PROPERTY(Object* engine READ engine NOTIFY engineChanged)\n```", "```cpp\n    QObject* engine() const { return m_engine; }\nprivate:\n    CarInfoEngine *m_engine;\n```", "```cpp\nsignals:\n    void engineChanged();\n```", "```cpp\nm_engine = new CarInfoEngine(this);\n```", "```cpp\nItem {\n  id: leftContainer\n  // ...\n\n  Item {\n    id: gearContainer\n    Text {\n      id: gear\n      property int value: carData.engine.gear\n      // ...\n    }\n  }\n  Needle {\n    anchors.centerIn: parent\n    length: parent.width*0.35\n    rotation: 210+(carInfo.engine.rpm*35)\n  }\n}\n```", "```cpp\nqmlRegisterType<FooClass>(\"foo.bar.baz\", 1, 0, \"Foo\");\n```", "```cpp\n#include <QGuiApplication>\n#include <QQuickView>\n#include <QtQml>\n\nint main(int argc, char **argv) {\n  QGuiApplication app(argc, argv);\n  QQuickView view;\n  qmlRegisterType<FooClass>(\"foo.bar.baz\", 1, 0, \"Foo\");\n  view.setSource(QUrl(\"main.qml\"));\n  view.show();\n  return app.exec();\n}\n```", "```cpp\nimport QtQuick 2.0\nimport foo.bar.baz 1.0\n\nItem {\n Foo {\n id: foo\n  }\n}\n```", "```cpp\nimport QtQuick 2.0\nimport CarInfo 1.0\n\nImage {\n  source: \"dashboard.png\"\n\n CarInfo {\n id: carData\n visible: true // make the widget visible\n  }\n  // ...\n}\n```", "```cpp\nint main(int argc, char **argv) {\n  QGuiApplication app(argc, argv);\n  QQuickView view;\n  qmlRegisterType<CarInfo>(\"CarInfo\", 1, 0, \"CarInfo\");\n  view.setSource(QUrl(\"qrc://main.qml\"));\n  view.show();\n  return app.exec();\n}\n```", "```cpp\nclass CarInfoProxy : public QObject {\n  Q_OBJECT\n  Q_PROPERTY(QObject *engine READ engine NOTIFY engineChanged)\n  Q_PROPERTY(int speed READ speed WRITE setSpeed NOTIFY speedChanged)\n  // ...\n```", "```cpp\n  Q_PROPERTY(bool visible READ visible WRITE setVisible NOTIFY visibleChanged)\n```", "```cpp\nprivate:\n  CarInfo m_car;\n```", "```cpp\npublic:\n  CarInfoProxy(QObject *parent = 0) : QObject(parent) {\n    connect(&m_car, SIGNAL(engineChanged()), this, SIGNAL(engineChanged()));\n    connect(&m_car, SIGNAL(speedChanged(int)), this, SIGNAL(speedChanged(int)));\n  }\n  QObject *engine() const { return m_car.engine(); }\n  bool visible() const { return m_car.isVisible(); }\n  void setVisible(bool v) {\n    if(v == visible()) return;\n    m_car.setVisible(v);\n    emit visibleChanged(v);\n  }\n  int speed() const { return m_car.speed(); }\n  void setSpeed(int v) { m_car.setSpeed(v); }\nsignals:\n  void engineChanged();\n  void visibleChanged(bool);\n  void speedChanged(int);\n};\n```", "```cpp\n  qmlRegisterType<CarInfoProxy>(\"CarInfo\", 1, 0, \"CarInfo\");\n```", "```cpp\nCannot assign to non-existent property \"gear\"\n engine.gear: 3\n ^\n\n```", "```cpp\nQ_PROPERTY(CarInfoEngine* engine READ engine NOTIFY engineChanged)\n```", "```cpp\nCarInfoEngine* engine() const { return m_engine; }\n```", "```cpp\nQString msg = QStringLiteral(\"Objects of type CarInfoEngine cannot be created\");\nqmlRegisterUncreatableType<CarInfoEngine>(\"CarInfo\", 1, 0, \"CarInfoEngine\", msg);\n```", "```cpp\nclass RegularPolygon : public QQuickItem {\n  Q_OBJECT\n  Q_PROPERTY(int sides READ sides WRITE setSides NOTIFY sidesChanged)\n  Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)\npublic:\n  RegularPolygon(QQuickItem *parent = 0);\n\n  int sides() const { return m_sideCount; }\n  void setSides (int s);\n\n  QColor color() const { return m_color; }\n  void setColor(const QColor &c);\n\n  QSGNode *updatePaintNode(QSGNode *, UpdatePaintNodeData *);\n\nsignals:\n  void sidesChanged(int);\n  void colorChanged(QColor);\nprivate:\n  int m_sideCount;\n  QColor m_color;\n};\n```", "```cpp\nRegularPolygon::RegularPolygon(QQuickItem *parent) : QQuickItem(parent) {\n  setFlag(ItemHasContents, true);\n  m_sideCount = 6;\n}\n```", "```cpp\nvoid RegularPolygon::setSides(int s) {\n  s = qMax(3, s);\n  if(s == sides()) return;\n  m_sideCount = v;\n  emit sidesChanged(v);\n  update();\n}\n\nvoid RegularPolygon::setColor(const QColor &c) {\n  if(color() == c) return;\n  m_color = c;\n  emit colorChanged(c);\n  update();\n}\n```", "```cpp\nQSGNode *RegularPolygon::updatePaintNode(QSGNode *oldNode, \n                         QQuickItem::UpdatePaintNodeData *) {\n```", "```cpp\n  QSGGeometryNode *node = 0;\n  QSGGeometry *geometry = 0;\n  QSGFlatColorMaterial *material = 0;\n```", "```cpp\n  if (!oldNode) {\n    node = new QSGGeometryNode;\n    geometry = new QSGGeometry(QSGGeometry::defaultAttributes_Point2D(), m_sideCount+2);\n    geometry->setDrawingMode(GL_TRIANGLE_FAN);\n    node->setGeometry(geometry);\n    node->setFlag(QSGNode::OwnsGeometry);\n```", "```cpp\n        material = new QSGFlatColorMaterial;\n        material->setColor(m_color);\n        node->setMaterial(material);\n        node->setFlag(QSGNode::OwnsMaterial);\n```", "```cpp\n    } else {\n      node = static_cast<QSGGeometryNode *>(oldNode);\n      geometry = node->geometry();\n      geometry->allocate(m_sideCount+2);\n```", "```cpp\nmaterial = static_cast<QSGFlatColorMaterial*>(node->material());\nif(material->color() != m_color) {\n  material->setColor(m_color);\n  node->markDirty(QSGNode::DirtyMaterial);\n}\n}\n```", "```cpp\n  QRectF bounds = boundingRect();\n  QSGGeometry::Point2D *vertices = geometry->vertexDataAsPoint2D();\n\n  // first vertex is the shared one (middle)\n  QPointF center = bounds.center();\n\n  vertices[0].set(center.x(), center.y());\n\n  // vertices are distributed along circumference of a circle\n\n  const qreal angleStep = 360.0/m_sideCount;\n  const qreal radius = qMin(width(), height())/2;\n\n  for (int i = 0; i < m_sideCount; ++i) {\n    qreal rads = angleStep*i*M_PI/180;\n    qreal x = center.x()+radius*std::cos(rads);\n    qreal y = center.y()+radius*std::sin(rads);\n    vertices[1+i].set(x, y);\n  }\n  vertices[1+m_sideCount] = vertices[1];\n```", "```cpp\n  node->markDirty(QSGNode::DirtyGeometry);\n  return node;\n}\n```", "```cpp\nRegularPolygon {\n  id: poly\n  vertices: 5\n  color: \"blue\"\n}\n```", "```cpp\nint main(int argc, char **argv) {\n  QGuiApplication app(argc, argv);\n  QQuickView view;\n  QSurfaceFormat format = view.format();\n format.setSamples(16); // enable multisampling\n  view.setFormat(format);\n  qmlRegisterType<RegularPolygon>(\"RegularPolygon\", 1, 0, \n                              \"RegularPolygon\");\n  view.setSource(QUrl(\"qrc://main.qml\"));\n  view.setResizeMode(QQuickView::SizeRootObjectToView);\n  view.show();\n  return app.exec();\n}\n```", "```cpp\nimport QtQuick 2.3\nimport OutlineTextItem 1.0\n\nRectangle {\n  width: 800; height: 400\n  OutlineTextItem {\n    anchors.centerIn: parent\n    text: \"This is outlined text\"\n    fontFamily: \"Arial\"\n    fontPixelSize: 64\n    color: \"#33ff0000\"\n    antialiasing: true\n    border {\n      color: \"blue\"\n      width: 2\n      style: Qt.DotLine\n    }\n  }\n}\n```", "```cpp\nclass OutlineTextItemBorder : public QObject {\n  Q_OBJECT\n  Q_PROPERTY(int width MEMBER m_width NOTIFY widthChanged)\n  Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)\n  Q_PROPERTY(int style MEMBER m_style NOTIFY styleChanged)\npublic:\n  OutlineTextItemBorder(QObject *parent) : QObject(parent),\n    m_width(0), m_color(Qt::transparent), m_style(Qt::SolidLine) {}\n\n  int width() const { return m_width; }\n  QColor color() const { return m_color; }\n  Qt::PenStyle style() const { return (Qt::PenStyle)m_style; }\n  QPen pen() const {\n   QPen p;\n   p.setColor(m_color);\n   p.setWidth(m_width);\n   p.setStyle((Qt::PenStyle)m_style);\n   return p;\n  }\nsignals:\n  void widthChanged(int);\n  void colorChanged(QColor);\n  void styleChanged(int);\nprivate:\n  int m_width;\n  QColor m_color;\n  int m_style;\n};\n```", "```cpp\nclass OutlineTextItem : public QQuickPaintedItem {\n  Q_OBJECT\n  Q_PROPERTY(OutlineTextItemBorder* border READ border NOTIFY borderChanged)\n  Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)\n  Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)\n  Q_PROPERTY(QString fontFamily MEMBER m_ffamily NOTIFY fontFamilyChanged)\n  Q_PROPERTY(int fontPixelSize MEMBER m_fsize NOTIFY fontPixelSizeChanged)\npublic:\n  OutlineTextItem(QQuickItem *parent = 0);\n  void paint(QPainter *painter);\n  OutlineTextItemBorder* border() const { return m_border; }\n  QPainterPath shape(const QPainterPath &path) const;\nprivate slots:\n  void updateItem();\nsignals:\n  void textChanged(QString);\n  void colorChanged(QColor);\n  void borderChanged();\n  void fontFamilyChanged(QString);\n  void fontPixelSizeChanged(int);\nprivate:\n  OutlineTextItemBorder* m_border;\n  QPainterPath m_path;\n  QRectF m_br;\n  QString m_text;\n  QColor m_color;\n  QString m_ffamily;\n  int m_fsize;\n};\n```", "```cpp\nOutlineTextItem::OutlineTextItem(QQuickItem *parent) : QQuickPaintedItem(parent) {\n    m_border = new OutlineTextItemBorder(this);\n    connect(this, SIGNAL(textChanged(QString)), SLOT(updateItem()));\nconnect(this, SIGNAL(colorChanged(QColor)), SLOT(updateItem()));\nconnect(this, SIGNAL(fontFamilyChanged(QString)), SLOT(updateItem()));\nconnect(this, SIGNAL(fontPixelSizeChanged(int)), SLOT(updateItem()));\nconnect(m_border, SIGNAL(widthChanged(int)), SLOT(updateItem()));\nconnect(m_border, SIGNAL(colorChanged(QColor)), SLOT(updateItem()));\nconnect(m_border, SIGNAL(styleChanged(int)), SLOT(updateItem()));\nupdateItem();\n}\n```", "```cpp\nvoid OutlineTextItem::updateItem() {\n  QFont font(m_ffamily, m_fsize);\n  m_path = QPainterPath();\n  m_path.addText(0, 0 , font, m_text);\n  m_br = shape(m_path).controlPointRect();\n  setImplicitWidth(m_br.width());\n  setImplicitHeight(m_br.height());\n  update();\n}\n```", "```cpp\nQPainterPath OutlineTextItem::shape(const QPainterPath &path) const\n{\n  QPainterPathStroker ps;\n  if(m_border->width() > 0 && m_border->style() != Qt::NoPen) {\n    ps.setWidth(m_border->width());\n  } else {\n    ps.setWidth(0.0000001); // workaround a bug in Qt\n  }\n  QPainterPath p = ps.createStroke(path);\n  p.addPath(path);\n  return p;\n}\n```", "```cpp\nvoid OutlineTextItem::paint(QPainter *painter) {\n  if(m_text.isEmpty()) return;\n  painter->setPen(m_border->pen());\n  painter->setBrush(m_color);\n  painter->setRenderHint(QPainter::Antialiasing, true);\n  painter->translate(-m_br.topLeft());\n  painter->drawPath(m_path);\n}\n```", "```cpp\nqmlRegisterUncreatableType<OutlineTextItemBorder>(\n  \"OutlineTextItem\", 1, 0, \"OutlineTextItemBorder\", \n  \"Can't create items of OutlineTetItemBorder type\"\n);\nqmlRegisterType<OutlineTextItem>(\n  \"OutlineTextItem\", 1, 0, \"OutlineTextItem\"\n);\n```"]