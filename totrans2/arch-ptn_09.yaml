- en: Microservices Architecture Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: Microservices architecture (**MSA**) is being proclaimed as the most powerful
    architectural pattern for designing, developing, deploying, and delivering next-generation
    software applications. Microservices are clearly emerging as the prime building
    block for constructing enterprise-grade and mission-critical applications. Microservices
    are fine-grained, typically single-purpose, and loosely-coupled services facilitating
    easy and independent deployment and horizontal scalability. Microservices are
    self-defined, cleanly isolated, and autonomous, and intrinsically support the
    popular polyglot model. The polyglot paradigm represents multiple programming
    languages, data transmission protocols, and persistence mechanisms. The idea is
    to build and run highly reliable, scalable, available, resilient, message-driven,
    and secure microservices. Microservices are interoperable, technology-agnostic,
    and composable to produce process-centric applications. Microservices and the
    Docker-enabled containerization go hand in hand in agile software engineering
    and rapid IT service delivery. There are a variety of best practices, key guidelines,
    design and evaluation metrics, and enabling patterns being unearthed by many accomplished
    professionals in order to speed up the process of migration from monolithic workloads
    to microservices-based workloads. Besides, there are API gateways, integrated
    platforms for service integration and orchestration, deployment and delivery environments
    such as Docker containers, and so on for increasing the MSA adoption rate. Product
    vendors, system integrators, cloud service providers, DevOps engineers, and other
    IT professionals are teaming up for accelerating the use of services in realizing
    highly flexible, extensible, elastic, and sustainable applications. This chapter
    is dedicated to illustrating all the existing and emerging patterns in this new
    field for our readers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构（**MSA**）正被宣称为设计、开发、部署和交付下一代软件应用的最强大的架构模式。微服务显然正在成为构建企业级和关键任务应用的主要构建块。微服务是细粒度的、通常是单功能的、松散耦合的服务，便于独立部署和水平扩展。微服务是自我定义的、干净隔离的、自主的，并且本质上支持流行的多语言模型。多语言范式代表多种编程语言、数据传输协议和持久化机制。目标是构建和运行高度可靠、可扩展、可用、弹性、消息驱动和安全的微服务。微服务是互操作性的、技术无关的，并且可组合以产生以流程为中心的应用。微服务和Docker容器化在敏捷软件开发和快速IT服务交付中相辅相成。许多有成就的专业人士正在发现各种最佳实践、关键指南、设计和评估指标以及促进模式，以加快从单体工作负载到基于微服务的工作负载的迁移过程。此外，还有API网关、服务集成和编排的集成平台、如Docker容器等部署和交付环境，以提高MSA的采用率。产品供应商、系统集成商、云服务提供商、DevOps工程师和其他IT专业人士正在合作，以加速服务在实现高度灵活、可扩展、弹性、可持续的应用中的使用。本章致力于向读者展示这个新领域中所有现有和新兴的模式。
- en: Microservices patterns
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务模式
- en: 'Several IT professionals, based on their extensive experiences, have come out
    with a number of enabling patterns for producing microservices-based applications.
    Further on, there are patterns exclusively for building fresh services from the
    ground up. Not only for development, but also for testing, deployment, and delivery,
    exquisite patterns are being unearthed and popularized. One strategic impact of
    MSA is on the risk-free translation of legacy applications into MSA-based modern
    applications. There are facilitating patterns of decomposition of massive and
    monolithic applications into several microservices. In the following sections,
    we will discuss the prominent patterns in detail. There are mainly two patterns:
    architecture and design patterns.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几位IT专业人士，基于他们丰富的经验，提出了一系列促进基于微服务应用生产的模式。更进一步，还有一些模式专门用于从头开始构建新的服务。不仅限于开发，还包括测试、部署和交付，精致的分解模式正在被发现并普及。MSA的一个战略影响是将遗留应用程序无风险地转换为基于MSA的现代应用程序。有促进将大型和单体应用程序分解为多个微服务的模式。在接下来的章节中，我们将详细讨论突出的模式。主要有两种模式：架构模式和设计模式。
- en: Decomposition patterns
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解模式
- en: Patterns are vital for any new paradigm to thrive. The microservices paradigm
    too has to be accordingly enabled with many novel and value-adding patterns in
    order to sustain and simplify its long and arduous journey. Whether designing,
    developing, deploying, and delivering newer microservices, or dismantling legacy
    and monolithic applications into a myriad of interactive microservices, the role
    and relevance of architecture and design patterns is extremely high. Without an
    iota of doubt, the IT team of every company across the world is burdened with
    a number of inflexible, closed, expensive to maintain, and largely sized software
    applications. Having understood the significant benefits being envisaged through
    the MSA proposition, worldwide corporates are keenly exploring the possibility
    of leveraging it with all the clarity and confidence for modernizing current applications.
    This technology-induced transition and transformation empower every business house
    to be ready for the digital economy and era. Microservices are being touted as
    the way forward to realize the dream of digital enterprises, and there is a clarion
    call for unearthing powerful and game-changing patterns to speed up the setting
    up and sustaining microservices-centric applications. Let us start with a few
    interesting decomposition patterns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 模式对于任何新范式的发展至关重要。微服务范式也需要通过许多新颖且具有增值的图案来相应地启用，以便维持并简化其漫长而艰巨的旅程。无论是设计、开发、部署和交付新的微服务，还是将遗留和单体应用程序分解成无数个交互式微服务，架构和设计模式的作用和相关性极高。毫无疑问，世界各地的IT团队都背负着许多不灵活、封闭、维护成本高且规模庞大的软件应用程序。在理解了通过MSA提议所预期的显著好处后，全球企业都热衷于探索利用它来清晰、自信地现代化当前应用程序的可能性。这种技术驱动的转型和变革使每个企业都准备好迎接数字经济和时代。微服务被吹捧为实现数字企业梦想的前进之路，并且有一个响亮的号召去发掘强大且变革性的模式来加速构建和维持以微服务为中心的应用程序。让我们从一些有趣的分解模式开始。
- en: 'The microservices architecture pattern corresponds to the *y* axis scaling
    of the scale cube, which is a 3D model of scalability as shown in the following
    diagram:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构模式对应于扩展立方体的*y* 轴缩放，这是一个如图所示的三维扩展模型：
- en: '![](img/02be04cb-f1e5-439e-a74b-17b44e617beb.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![扩展立方体图](img/02be04cb-f1e5-439e-a74b-17b44e617beb.png)'
- en: The *x* axis scaling is for running multiple cloned copies of an application
    behind a load balancer. This is the most common way of achieving horizontal scalability.
    The *y* axis scaling represents an application that is split by a function, service,
    or resource. Each service is responsible for one or more closely related functions.
    The *z* axis scaling is commonly used to scale databases because the data is partitioned
    across a set of servers. Each server runs an identical copy of the code and each
    service request is routed to the appropriate server. The *z* axis scaling, like
    *x* axis scaling, improves the application's capacity and availability. However,
    to solve the problems of increasing development and application complexity, the
    *y* axis scaling is recommended. The *y* axis scaling splits the application into
    multiple services.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 轴缩放是为了在负载均衡器后面运行多个应用程序的克隆副本。这是实现横向扩展最常见的方式。*y* 轴缩放表示一个由功能、服务或资源分割的应用程序。每个服务负责一个或多个紧密相关的功能。*z*
    轴缩放通常用于扩展数据库，因为数据被分割到一组服务器上。每个服务器运行相同的代码副本，每个服务请求都被路由到相应的服务器。*z* 轴缩放，就像*x* 轴缩放一样，可以提高应用程序的容量和可用性。然而，为了解决日益增长的开发和应用复杂性问题，建议使用*y*
    轴缩放。*y* 轴缩放将应用程序分割成多个服务。'
- en: Decomposition by use case pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过用例模式进行分解
- en: There are many bases and causes for segmenting big applications into a dynamic
    pool of smaller and cooperative components. As we all know, software packages
    and libraries are being constructed in order to automate and accelerate multiple
    use cases. Hence, this pattern unambiguously specifies the ways and means of expertly
    partitioning massive applications into many small modules; each of them will accomplish
    at least one use case. We know that there are breakthrough business and technical
    cases for any technology to survive by beating all kinds of competitions at the
    increasingly knowledgeable market. However, use cases are typically the benefits
    being accrued by users (humans), user agents/services (software), or IoT and I/O
    devices while using any technology-sponsored applications and services. In this
    pattern, it is all about starting, identifying, and prioritizing use cases. Use
    cases are definitely the crucial factor and the turning point for developing new
    applications as well as modernizing existing applications. This pattern helps
    to produce next-generation applications by producing fresh services and by extracting
    the hidden microservices encapsulated inside big applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将大型应用程序分割成动态的小型且协作的组件集合有许多基础和原因。众所周知，软件包和库正在被构建，目的是自动化和加速多个用例。因此，这种模式明确地指定了如何专业地将大型应用程序分割成许多小模块的方法；每个模块至少完成一个用例。我们知道，任何技术要生存下来，都必须在日益知识化的市场中击败各种竞争，这需要突破性的商业和技术案例。然而，用例通常是在使用任何技术支持的应用和服务时，用户（人类）、用户代理/服务（软件）或物联网和I/O设备所获得的好处。在这个模式中，关键是开始、识别和优先考虑用例。用例无疑是开发新应用程序以及现代化现有应用程序的关键因素和转折点。这种模式通过产生新的服务和提取大应用程序内部封装的隐藏微服务，有助于产生下一代应用程序。
- en: Decomposition by resources pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于资源的分解模式
- en: In this pattern, it is defining microservices based on the resources (server
    machines, storage appliances, network components, software infrastructures, databases,
    and so on) that they access or control. This allows the creation of a set of microservices
    that function as channels for access to individual resources. We are envisioning
    the days of application-aware infrastructures and infrastructure-aware applications.
    For microservices to exhibit their special capabilities, the underlying resources
    play an important role, which cannot be sidestepped.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，它是根据它们访问或控制的资源（服务器机器、存储设备、网络组件、软件基础设施、数据库等）来定义微服务的。这允许创建一组微服务，它们作为访问单个资源的通道。我们展望着应用程序感知基础设施和基础设施感知应用程序的时代。为了微服务展现其特殊能力，底层资源发挥着重要作用，这一点不容忽视。
- en: Decomposition by business capability pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于业务能力的分解模式
- en: Functionality is another option to decompose monolithic applications into many
    interoperable microservices. These functions or responsibilities are generally
    business-specific or agnostic. That is, these vertical, as well as horizontal
    functions, can be easily used by more than one part of the application. These
    functions are coarse-grained in the sense that many fine-grained services can
    be born out of these bigger functionalities/responsibilities. This is an interesting
    pattern for the MSA era.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性是另一种将单体应用程序分解成许多可互操作的微服务的选项。这些功能或责任通常是业务特定的或非特定的。也就是说，这些垂直以及水平功能可以很容易地被应用程序的多个部分使用。从粗粒度角度来看，许多细粒度服务可以由这些更大的功能/责任产生。这是MSA时代的一个有趣模式。
- en: Increasingly, business applications are becoming sophisticated and complicated.
    A myriad of third-party applications is getting integrated. Monolithic and massive-scale
    applications are the most prevalent and prominent these days. **Service-oriented
    architecture** (**SOA**) patterns are majorly leveraged for establishing and sustaining
    seamless and spontaneous integration between different and distributed applications
    using specific wrappers and service-oriented interfaces. That is, enterprise and
    cloud application integration is being enabled through SOA techniques and tips.
    Having understood the strategic significance of the MSA pattern, business behemoths
    are strategizing to smoothly go in the MSA way to be right and relevant to their
    customers and clients. Besides partitioning the large-scale application into a
    dynamic collection of easily manageable, lightly coupled, and relatively simple
    services, the MSA paradigm is to accelerate software development by enabling continuous
    delivery/deployment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的业务应用正变得复杂和复杂。大量的第三方应用正在集成。单体和大规模应用是目前最普遍和突出的。**面向服务的架构**（**SOA**）模式主要用于通过特定的包装和面向服务的接口在不同和分布式应用程序之间建立和维持无缝和自发的集成。也就是说，企业级和云应用集成是通过SOA技术和技巧实现的。在理解了MSA模式战略意义之后，商业巨头正在制定战略，以平稳地进入MSA之路，以正确和适当地服务于他们的客户和客户。除了将大规模应用分解为易于管理、松散耦合且相对简单的服务集合之外，MSA范式通过实现持续交付/部署来加速软件开发。
- en: For achieving the aforementioned benefits, the decomposition of the application
    into microservices has to be done very carefully. A useful guideline for the **object-oriented
    design** (**OOD**) world is the **single responsibility principle** (**SRP**)
    that defines a responsibility of a class as a reason to change and states that
    a class should only have one reason to change. Another useful principle from OOD
    is the **common closure principle** (**CCP**); things that change together should
    be packaged together to ensure that each change affects only one service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述好处，必须非常小心地将应用程序分解为微服务。面向对象设计（**OOD**）世界的一个有用指南是**单一职责原则**（**SRP**），它将类的职责定义为改变的原因，并指出类应该只有一个改变的原因。面向对象设计中的另一个有用原则是**共同封闭原则**（**CCP**）；一起改变的事物应该打包在一起，以确保每次改变只影响一个服务。
- en: 'The promising solution approach is as follows. Define services corresponding
    to business capabilities. A business capability is something that a business does
    in order to generate value. A business capability often corresponds to a business
    object, for example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有前景的解决方案方法如下。定义与业务能力相对应的服务。业务能力是指企业为了创造价值所做的事情。业务能力通常对应于业务对象，例如：
- en: Order management is responsible for orders
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理负责订单
- en: Customer management is responsible for customers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户管理负责客户
- en: This sort of business capability-based decomposition of monolithic applications
    is to benefit businesses in the long run. Also, bigger and better business capabilities
    can be realized through the orchestration of business capability services. There
    are API gateways, partitioning best practices, Docker containers to host microservices,
    orchestration tools, and governance engines in order to derive process-aware composite
    applications at runtime on a need basis.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于业务能力的单体应用分解是为了长期造福企业。此外，通过业务能力服务的编排，可以实现更大、更好的业务能力。为了在运行时根据需要生成过程感知的复合应用程序，有API网关、分区最佳实践、用于托管微服务的Docker容器、编排工具和治理引擎。
- en: Decomposition by subdomain pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子域模式分解
- en: For bringing up modular software applications, application components and services
    need to be loosely coupled (each service has an API that encapsulates its implementation,
    the implementation can be changed without affecting its clients) and cohesive
    (a service should implement a small set of strongly related functions). With component-based
    software assembly and **service-oriented architecture** (**SOA**) approaches,
    setting up and sustaining modular applications has been the case. These components
    and services are typically coarse-grained. With the surging popularity and pervasiveness
    of service architectures, creating fine-grained services is gathering momentum.
    The principal goal of MSA is to quickly take software solutions to the market
    by enabling continuous integration, deployment, and delivery. Hence, the systematic
    and sagacious decomposition of applications and coarse-grained services is acquiring
    special consideration. In the aforementioned pattern, we discussed that business
    capability is the base for disintegrating applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建模块化软件应用程序，应用程序组件和服务需要松散耦合（每个服务都有一个封装其实施的API，其实施可以更改而不影响其客户端）和内聚（一个服务应实现一组强相关的功能）。通过基于组件的软件组装和**面向服务架构**（**SOA**）方法，设置和维护模块化应用程序已经成为常态。这些组件和服务通常是粗粒度的。随着服务架构的日益普及和深入，创建细粒度服务正在积聚势头。MSA的主要目标是通过对持续集成、部署和交付的支持，快速将软件解决方案推向市场。因此，对应用程序和粗粒度服务的系统化和明智的分解正在获得特别的关注。在上述模式中，我们讨论了业务能力是分解应用程序的基础。
- en: 'This pattern recommends decomposing by subdomains. It is recommended to define
    services corresponding to **domain-driven design** (**DDD**) subdomains. DDD refers
    to the application''s problem space (the business) as the domain. A domain consists
    of multiple subdomains. Each subdomain corresponds to a different part of the
    business. The subdomains of an online store application include:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议按子域进行分解。建议定义与**领域驱动设计**（**DDD**）子域相对应的服务。DDD指的是应用程序的问题空间（业务）作为领域。一个领域由多个子域组成。每个子域对应业务的不同部分。在线商店应用的子域包括：
- en: Product catalogue
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品目录
- en: Inventory management
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存管理
- en: Order management
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理
- en: Delivery management
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配送管理
- en: The resulting service architecture is quite stable since the subdomains are
    relatively stable. The challenge is to precisely identify the subdomains. Decomposition
    follows the *Divide and Conquer* paradigm. With the digital era all set to dawn,
    the software complexity is to rise, and hence bring the technique of decomposition
    into the picture. Big and packaged applications need to be divided in order to
    gain a decisive and deeper understanding.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子域相对稳定，因此结果服务架构相当稳定。挑战在于精确识别子域。分解遵循**分而治之**范式。随着数字时代的到来，软件复杂性将上升，因此将分解技术纳入视野。大型和打包的应用程序需要分解，以便获得决定性和深入的理解。
- en: Microservices deployment pattern
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务部署模式
- en: There is a myriad of ways and means for deploying microservices. There are a
    few runtime and execution environments including **bare metal** (**BM**) servers,
    **virtual machines** (**VMs**), and containers. Therefore, the deployment options
    have increased. Then, there are one or more instances of the same microservice
    to be accommodated in one server. The deployment pattern choices are not straightforward
    and instead depend on various parameters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的部署方式和手段多种多样。包括一些运行时和执行环境，如**裸机**（**BM**）服务器、**虚拟机**（**VMs**）和容器。因此，部署选项也增多了。然后，一个服务器需要容纳一个或多个相同的微服务实例。部署模式的选取并不简单，而是取决于各种参数。
- en: Multiple service instances per host pattern
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个主机上的多个服务实例模式
- en: Microservices are generally small in size and hence are quickly built, tweaked,
    composed, and deployed. The availability and throughput of microservices are important.
    Redundancy is one widely used aspect for guaranteeing high availability and throughput.
    That is, each service is deployed as a set of service instances.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常规模较小，因此可以快速构建、调整、组合和部署。微服务的可用性和吞吐量很重要。冗余是保证高可用性和吞吐量的一个广泛使用的方法。也就是说，每个服务都作为一组服务实例进行部署。
- en: The beauty of microservices is that services can be implemented using different
    programming languages and frameworks. As articulated in the beginning, microservices
    can be independently deployable and horizontally scalable. Service instances have
    to be clearly isolated from one another to ensure the safety and security of services.
    The resources (processors/cores/threads, memory, storage, and so on) consumed
    by service instances need to be minutely monitored, measured, and managed in order
    to ensure the optimized utilization of different IT resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的美丽之处在于服务可以使用不同的编程语言和框架来实现。正如一开始所阐述的，微服务可以独立部署和水平扩展。为了确保服务的安全和安全，服务实例必须彼此明确隔离。服务实例消耗的资源（处理器/核心/线程、内存、存储等）需要被细致地监控、测量和管理，以确保不同IT资源的优化利用。
- en: It is possible to run multiple instances of different services on a physical
    or virtual server. It is possible to deploy each service instance as a JVM process,
    and it is also possible to deploy multiple instances in the same JVM. With higher
    density, the utilization of resources, as well as services, is bound to go up.
    The issues alluding to this pattern are the competition for resources, resource
    dependencies, and resource monitoring.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理或虚拟服务器上运行不同服务的多个实例是可能的。可以将每个服务实例作为JVM进程部署，也可以在同一JVM中部署多个实例。随着密度的提高，资源以及服务的利用率必然会增加。与此模式相关的问题包括资源竞争、资源依赖和资源监控。
- en: Single service instance per host pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个主机一个服务实例模式
- en: 'This is another service deployment pattern. There are requirements and scenarios
    wherein multiple instances of a service are deployed on a single server. On the
    other hand, there are needs for deploying only one instance and running it on
    a host machine. The benefits of this approach include:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种服务部署模式。存在一些需求和场景，其中服务的多个实例部署在单个服务器上。另一方面，也有只部署一个实例并在主机机器上运行的需求。这种方法的优点包括：
- en: Service instances are fully isolated from one another
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实例之间是完全隔离的
- en: There is no competition for resources and the issues being associated with dependencies
    are no more
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有资源竞争，与依赖相关的问题也不再存在
- en: A service instance can consume at most the resources of a single host
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实例最多只能消耗单个主机的资源
- en: It is easy to monitor, manage, and redeploy each service instance
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控、管理和重新部署每个服务实例都很简单
- en: The drawback is that the resource utilization may decrease.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是资源利用率可能会降低。
- en: Service instance per VM pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个虚拟机一个服务实例模式
- en: There are a few options for service instance deployment. BM servers,VMs, and
    in the recent past, Docker containers are the mainstream deployment and runtime
    environments. This pattern specifies the deployment of a service in a VM. Cloud
    environments are increasingly virtualized and hence VM-hosted services are flourishing.
    The auto-scaling facility being supplied by **cloud service providers** (**CSPs**)
    helps to provision fresh VMs quickly and concurrently to scale the number of service
    instances horizontally. This mechanism ensures the required performance level
    and the service availability. The service isolation happens at the VM level. The
    typical issue here is that VM provisioning consumes a couple of minutes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实例部署有几种选择。BM服务器、虚拟机（VMs）以及最近，Docker容器是主流的部署和运行环境。此模式指定了在虚拟机中部署服务。云环境正日益虚拟化，因此托管在虚拟机上的服务正在蓬勃发展。由**云服务提供商**（**CSPs**）提供的自动扩展功能有助于快速且并发地提供新的虚拟机，以水平扩展服务实例的数量。此机制确保了所需的性能水平和服务的可用性。服务隔离发生在虚拟机级别。这里典型的难题是虚拟机配置需要几分钟。
- en: Service instance per container pattern
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个容器一个服务实例模式
- en: Every software module is being containerized through the Docker packaging format
    and the open-source platform, and the resulting Docker image of that particular
    application or service is being stocked in publicly discoverable and accessible
    hubs. When a Docker image gets committed, it automatically becomes a Docker container
    that can be immediately deployed and run. The container starts to deliver the
    implemented service to the outside world to be subscribed and consumed. The original
    and open-source Docker platform is being speedily strengthened through a host
    of pioneering tools, engines, and frameworks to bring all-around automation. There
    are Docker machines, container cluster management platforms, orchestration and
    networking tools, container monitoring tools, and so on in order to proclaim the
    Docker-enabled containerization as a production-level technology. The pivotal
    convergence of microservices and Docker paradigms is to lay a solid and stimulating
    foundation for producing bigger and better software applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件模块都通过Docker打包格式和开源平台进行容器化，该特定应用或服务的Docker镜像被存储在公开可发现和可访问的枢纽中。当Docker镜像被提交时，它自动成为一个可以立即部署和运行的Docker容器。容器开始向外界提供实现的服务，以便订阅和消费。原始的开源Docker平台正在通过一系列开创性的工具、引擎和框架迅速加强，以实现全方位的自动化。有Docker机器、容器集群管理平台、编排和网络工具、容器监控工具等等，以宣布Docker支持的容器化成为生产级技术。微服务和Docker范式的关键融合是为了为生产更大、更好的软件应用奠定坚实的基础。
- en: Unlike VMs, container creation and running is quite fast. That means, through
    the leverage of containers, it is possible to achieve real-time scalability. As
    a best practice, every container is to host a service instance. Through multiple
    containers, it is possible to have multiple instances of a service. Generally,
    due to the lightweight nature of containers, there can be tens or even hundreds
    of application containers running comfortably on a physical host.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机不同，容器的创建和运行速度相当快。这意味着，通过利用容器，可以实现实时可伸缩性。作为最佳实践，每个容器都应该托管一个服务实例。通过多个容器，可以拥有多个服务实例。通常，由于容器的轻量级特性，可以在物理主机上舒适地运行数十个甚至数百个应用容器。
- en: Serverless deployment pattern
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器部署模式
- en: Serverless computing, alternatively termed as **Function as a Service** (**FaaS**),
    is attracting a lot of mind and market shares. Development, debugging, deployment,
    delivery, and decommissioning of application services are the major portion of
    any **application lifecycle management** (**ALM**) process. That is, there is
    a need for operational guys to set up and sustain optimized infrastructures for
    deploying and running software applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算，也被称为**函数即服务**（**FaaS**），正吸引着众多关注和市场份额。应用服务的开发、调试、部署、交付和退役是任何**应用生命周期管理**（**ALM**）过程中的主要部分。也就是说，需要运维人员建立并维护优化的基础设施来部署和运行软件应用。
- en: This serverless deployment pattern recommends a kind of deployment infrastructure
    that hides the concept of servers (whether physical or virtual). The infrastructure
    takes the application service's code and runs it. The user has to pay for each
    of his requests based on the resources consumed. The performance, scalability,
    and availability requirements are being automatically met. Almost all the established
    cloud service providers are providing this new deployment pattern. This is a new
    cloud service ensuring every function is being delivered as a service.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种无服务器部署模式推荐一种隐藏服务器概念（无论是物理的还是虚拟的）的部署基础设施。该基础设施运行应用服务的代码。用户必须根据消耗的资源为他的每个请求付费。性能、可伸缩性和可用性要求将自动满足。几乎所有的主流云服务提供商都在提供这种新的部署模式。这是一种新的云服务，确保每个功能都作为服务提供。
- en: For an example, start with an AWS Lambda function, which is a stateless component
    to handle events. To create an AWS Lambda function, the user has to package his
    NodeJS, Java, or Python code for his service in a ZIP file and upload it to AWS
    Lambda. When an event occurs, AWS Lambda finds an idle instance of the function
    and launches one if none are available and invokes the handler function. AWS Lambda
    can run more instances automatically on a need basis to handle extra users and
    payloads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从一个 AWS Lambda 函数开始，这是一个无状态的组件，用于处理事件。要创建 AWS Lambda 函数，用户必须将他的 NodeJS、Java
    或 Python 代码打包成 ZIP 文件，并上传到 AWS Lambda。当发生事件时，AWS Lambda 会找到一个空闲的函数实例，如果没有可用实例，则会启动一个实例并调用处理函数。AWS
    Lambda 可以根据需要自动运行更多实例，以处理额外的用户和负载。
- en: 'There are four ways to invoke a lambda function. One option is to configure
    the lambda function to be invoked in response to an event generated by an AWS
    service. The examples of events include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 lambda 函数有四种方式。一种选项是将 lambda 函数配置为在 AWS 服务生成的事件响应中调用。以下是一些事件的示例：
- en: An object being deposited in an S3 bucket
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象被存放在 S3 桶中
- en: An item is created, updated, or deleted in a DynamoDB table
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 DynamoDB 表中创建、更新或删除一个条目
- en: A message is available to read from a Kinesis stream
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从 Kinesis 流中读取一条消息
- en: Another way to invoke a lambda function is to configure the AWS Lambda Gateway
    to route HTTP requests to the lambda function. AWS Gateway transforms an HTTP
    request into an event object, invokes the lambda function, and generates an HTTP
    response from the lambda function's result.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调用 lambda 函数的方式是配置 AWS Lambda 网关将 HTTP 请求路由到 lambda 函数。AWS 网关将 HTTP 请求转换为事件对象，调用
    lambda 函数，并从 lambda 函数的结果生成 HTTP 响应。
- en: It is also possible to invoke the lambda function using the AWS Lambda Web Service
    API. The application that invokes the lambda function supplies a JSON object,
    which is passed to the lambda function. The web service call returns the value
    returned by the lambda. The final and fourth way to invoke a lambda function is
    periodically using a cron-like mechanism. It is possible to tell AWS to invoke
    the lambda function every five minutes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 AWS Lambda Web 服务 API 调用 lambda 函数。调用 lambda 函数的应用程序提供一个 JSON 对象，该对象传递给
    lambda 函数。Web 服务调用返回 lambda 返回的值。调用 lambda 函数的第四种和最后一种方式是定期使用类似于 cron 的机制。可以告诉
    AWS 每五分钟调用一次 lambda 函数。
- en: The advantages are many; the infrastructure provisioning, setting up and administering
    time, and treasure and talent get reduced significantly. Software engineers can
    coolly focus on their core strengths without any botheration of the readying infrastructure
    to run their applications. However, there are a few limitations. AWS Lambda at
    this point in time supports a few languages. It is only suitable for deploying
    stateless applications that run quickly and respond to requests. Running long-running
    stateful applications such as a database or message broker in the serverless model
    is not possible. If an application takes a long time to start, then the application
    is not a good fit for serverless deployment. Similarly, legacy monolithic and
    massive applications are not suitable for serverless computing. Serverless deployment
    is typically reactive, not proactive, and hence the issue of high latency can
    arise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 优点很多；基础设施的配置、设置和管理时间，以及财力和人才都得到了显著减少。软件工程师可以冷静地专注于他们的核心优势，而无需为准备基础设施来运行他们的应用程序而烦恼。然而，也有一些限制。目前
    AWS Lambda 支持的语言有限。它仅适用于部署快速响应请求的无状态应用程序。在无服务器模式下运行长时间运行的状态应用程序，如数据库或消息代理是不可能的。如果一个应用程序启动时间很长，那么这个应用程序不适合无服务器部署。同样，遗留的单一和大型应用程序也不适合无服务器计算。无服务器部署通常是反应性的，而不是主动性的，因此可能会出现高延迟的问题。
- en: Service deployment platform pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务部署平台模式
- en: 'There are a few automated software deployment tools on the market. IBM UrbanCode
    Deploy is an application release automation solution. This software allows for
    seamlessly deploying to distributed data centers and cloud environments on demand
    or on schedule. It is possible to scale up to enterprise-class deployments handling
    thousands of servers. The other popular software deployment automation solutions
    include:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有一些自动化的软件部署工具。IBM UrbanCode Deploy 是一个应用程序发布自动化解决方案。该软件允许按需或按计划无缝部署到分布式数据中心和云环境。它可以扩展到企业级部署，处理数千台服务器。其他流行的软件部署自动化解决方案包括：
- en: Docker orchestration frameworks including Docker swarm and Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker编排框架，包括 Docker Swarm 和 Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))
- en: Serverless platforms such as AWS Lambda
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器平台，例如 AWS Lambda
- en: PaaS including Cloud Foundry
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PaaS 包括 Cloud Foundry
- en: Deployment, release, and delivery activities are increasingly being automated
    through a bevy of tools. For faster software delivery to the market, the tools-supported
    continuous integration, deployment, and delivery are indispensable, and the aforementioned
    patterns come in handy for software architects and designers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 部署、发布和交付活动正越来越多地通过一系列工具实现自动化。为了更快地将软件推向市场，工具支持的持续集成、部署和交付是必不可少的，上述模式对于软件架构师和设计师来说非常有用。
- en: Microservices design patterns
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: Designing competent microservices that can work with other services seamlessly
    and spontaneously is essential for the intended success of the MSA. Similarly,
    designing the architecture of cloud, enterprise, mobile, IoT, analytical, operational,
    and transactional applications through the power of microservices has to be done
    elegantly and expediently. As enunciated previously, microservices can be realized
    through multiple technologies and tools. Also, the resplendent MSA paradigm is
    futuristic in the sense that any new technology can be easily used for producing
    next-generation microservices that are easily findable, accessible, assessable,
    maneuverable, replaceable, substitutable, and so on. The ensuing section will
    list all the dominant design patterns for progressively journeying toward the
    projected MSA era.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设计能够与其他服务无缝且自发地工作的微服务对于 MSA 的预期成功至关重要。同样，通过微服务的力量优雅且高效地设计云、企业、移动、物联网、分析、运营和事务性应用程序的架构也必须如此。正如之前所述，微服务可以通过多种技术和工具实现。此外，辉煌的
    MSA 架构范式在未来的意义上是，任何新技术都可以轻松用于生产下一代微服务，这些微服务易于发现、访问、评估、操作、替换、替代等。接下来的部分将列出所有主导的设计模式，以逐步迈向预期的
    MSA 时代。
- en: Design patterns are typically fine-grained and immensely contribute to building
    individual as well as composite microservices. Not only business logic, but also
    design patterns help in attaching data connectivity and persistence logic. Design
    patterns are therefore comprehensive for supplying the envisaged success of the
    MSA paradigm. The following section enumerates and explains the key design patterns.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常是细粒度的，并且对构建单个以及复合微服务做出了巨大贡献。不仅业务逻辑，设计模式也有助于附加数据连接性和持久性逻辑。因此，设计模式对于提供 MSA
    架构预期的成功至关重要。以下部分将列举并解释关键的设计模式。
- en: Aggregator microservice design pattern
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合器微服务设计模式
- en: Service and data aggregation are very vital for the intended success of the
    MSA pattern. As services are relatively micro in size and typically a microservice
    implements a single task, multiple distributed and decentralized services need
    to be identified and aggregated to serve a fully-fledged business functionality
    and feature. The aggregator pattern is therefore essential for the MSA era. Since
    each service is exposed using the lightweight RESTful interface, an application,
    which comprises many microservices, can retrieve the data from different services
    and process/display it accordingly by using this aggregator pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和数据聚合对于 MSA 模式的预期成功至关重要。由于服务相对较小，并且通常一个微服务实现单个任务，因此需要识别和聚合多个分布式和去中心化的服务，以提供全面的企业功能特性。因此，聚合器模式对于
    MSA 时代至关重要。由于每个服务都是通过轻量级的 RESTful 接口暴露的，一个由许多微服务组成的应用程序可以通过使用此聚合器模式从不同的服务中检索数据，并相应地处理/显示它。
- en: 'There are viable options to bring in the required business logic if there is
    a requirement for a kind of processing on the retrieved data before the data gets
    displayed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数据显示之前需要对检索到的数据进行某种处理，存在可行的选项来引入所需业务逻辑：
- en: '![](img/573665ab-e497-4e19-a63e-c6216eb6f084.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/573665ab-e497-4e19-a63e-c6216eb6f084.png)'
- en: If the aggregation has to happen at the service level to create composite services,
    then the aggregator would just collect the data from each of the participating
    services, apply the ordained business logic to it, and aggregate and publish it
    using a composite REST endpoint. This process-centric composite service can then
    be consumed by other services that need it. All the microservices may have their
    own cache and database. The composite service can also be blessed with its own
    caching and database layer. An aggregator can scale independently on the *x* axis
    and *z* axis as well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果聚合必须在服务级别发生以创建组合服务，那么聚合器将仅从每个参与的服务中收集数据，对其应用规定的业务逻辑，然后使用组合REST端点进行聚合和发布。这个以过程为中心的组合服务然后可以被需要它的其他服务消费。所有微服务可能都有自己的缓存和数据库。组合服务也可以拥有自己的缓存和数据库层。聚合器可以在*x*轴和*z*轴上独立扩展。
- en: Proxy microservice design pattern
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理微服务设计模式
- en: This pattern is a slight variation of the aggregator. In this case, the client
    is not involved in the aggregation activity. Based on business needs, different
    microservices can be invoked. The proxy pattern can scale independently on *x*
    axis and *z* axis as well. The idea is that each microservice need not be exposed
    to the consumer. The proxy may be a dumb proxy, in which case it just delegates
    the request to one of the services. Alternatively, it may be a smart proxy where
    some data transformation is applied before the response is served to the client.
    With the explosion of different IoT and I/O devices, this proxy pattern is a beneficial
    one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是聚合器的一种轻微变化。在这种情况下，客户端不参与聚合活动。根据业务需求，可以调用不同的微服务。代理模式也可以在*x*轴和*z*轴上独立扩展。其想法是每个微服务不需要暴露给消费者。代理可能是一个哑代理，在这种情况下，它只是将请求委派给其中一个服务。或者，它可能是一个智能代理，在向客户端提供响应之前，对某些数据进行转换。随着不同物联网和I/O设备的爆炸式增长，这种代理模式是有益的。
- en: Chained microservice design pattern
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式微服务设计模式
- en: This is for producing a single consolidated response to a request. In this case,
    the request from the client is received by Service A, which is then communicating
    with Service B, which in turn may be communicating with Service C. All the services
    are likely using a synchronous HTTP request/response message. The key concern
    here is that the client is blocked until all the services in the chain finish
    the processing. That is, the chain of Service A to Service B and then Service
    B to Service C gets completed. The chain has to be short and small, otherwise,
    the synchronous communication may lead to a delay.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了对一个请求产生一个单一的汇总响应。在这种情况下，客户端的请求由服务A接收，然后与服务B通信，服务B反过来可能与服务C通信。所有服务都可能使用同步的HTTP请求/响应消息。这里的关键问题是客户端在链中的所有服务完成处理之前被阻塞。也就是说，服务A到服务B再到服务B到服务C的链必须短且小，否则，同步通信可能会导致延迟。
- en: Microservice chassis pattern
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务底盘模式
- en: Cross-cutting concerns are many and also repeated across the source code of
    any application. The aspect-oriented programming model through a unique fashion
    was the first one to tackle these cross-cutting concerns that are prevalent in
    an enterprise-class application. The well-known examples include identity and
    access, network locations of databases and messaging platforms, logging, data
    encryption, evaluation metrics, and so on. As we all know, microservices are small
    in size and quick in development, testing, debugging, deployment, and delivery.
    That is, a small team of developers can build a service in a day or two. As per
    the MSA pattern, such small-scale services from multiple development teams are
    picked up purposefully and blended to form mission-critical applications instantaneously.
    The whole process of generating process-aware, microservices-based applications
    are completed in a short span of time. Herein, wasting a lot of additional time
    to attach all kinds of cross-cutting concerns is not a logically sound proposition.
    Therefore, the microservices chassis framework gets formulated and recommended
    to build microservices in the application perspective. Developers, when leveraging
    the MSA pattern, also have to incorporate the MSA-specific cross-cutting concerns,
    such as service registration and discovery and circuit breakers for reliably handling
    partial failure. Therefore, the best solution approach is that when creating a
    microservice, it is crucial to add the lean and clean code for handling the aforementioned
    cross-cutting concerns. This way of embedding cross-cutting concerns is the smartest
    way forward for the MSA world.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点众多，并且在任何应用程序的源代码中也是重复出现的。以独特的方式解决这些在企业级应用程序中普遍存在的横切关注点的面向方面编程模型是第一个。众所周知的例子包括身份和访问、数据库和网络位置、消息平台、日志记录、数据加密、评估指标等等。众所周知，微服务在规模上较小，在开发、测试、调试、部署和交付方面都很快。也就是说，一个小团队的开发者可以在一天或两天内构建一个服务。根据MSA模式，这些来自多个开发团队的小规模服务被有目的地挑选出来，并即时融合形成关键任务应用程序。生成基于微服务的流程感知应用程序的整个过程在短时间内完成。在这里，花费大量额外时间来附加各种横切关注点并不是一个逻辑上合理的论点。因此，微服务底盘框架被制定并推荐用于从应用程序的角度构建微服务。当开发者利用MSA模式时，还必须结合MSA特定的横切关注点，例如服务注册和发现以及断路器，以可靠地处理部分故障。因此，最佳解决方案是在创建微服务时，至关重要的是添加处理上述横切关注点的精简和清晰代码。这种嵌入横切关注点的方式是MSA世界中最明智的前进方式。
- en: Externalized configuration pattern
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部化配置模式
- en: Any enterprise-grade application typically uses one or more infrastructures
    and third-party services. For example, the application has to use a few common
    infrastructure services such as service registry, authentication, authorization
    and audit services, message broker and queue, filesystem, database, knowledge
    visualization platform, security, and so on. Further on, there are several third-party
    applications and services such as payment gateway, email server, and so on. Thus,
    any production-grade application has to be directly or indirectly attached to
    local as well as remote services to exhibit a highly integrated capability. Another
    pertinent question is, how do we enable a service to run in multiple environments
    without any modification?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任何企业级应用程序通常使用一个或多个基础设施和第三方服务。例如，应用程序必须使用一些常见的基础设施服务，如服务注册、身份验证、授权和审计服务、消息代理和队列、文件系统、数据库、知识可视化平台、安全等。进一步来说，还有几个第三方应用程序和服务，如支付网关、电子邮件服务器等。因此，任何生产级应用程序都必须直接或间接地连接到本地和远程服务，以展示高度集成的功能。另一个相关的问题是，我们如何使服务能够在多个环境中运行而无需任何修改？
- en: Generally, a service must be provided with configuration data that tells it
    how to connect with other services. For example, for connecting to a database,
    the database network location and credentials have to be attached to the configuration
    data. Also, there are variations such as a QA database versus a production environment
    database. The prominent solution approach is to externalize all application-centric
    configuration information so that a service reads the configuration details from
    the external source to complete its functionality perfectly. The advantage of
    this pattern is that application services run in multiple environments without
    modification and/or recompilation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个服务必须提供配置数据，以告知它如何连接到其他服务。例如，为了连接到数据库，数据库的网络位置和凭证必须附加到配置数据中。此外，还有诸如QA数据库与生产环境数据库之类的变体。突出的解决方案方法是将所有以应用为中心的配置信息外部化，以便服务从外部源读取配置细节以完美地完成其功能。这种模式的优点是应用服务可以在多个环境中运行而无需修改和/或重新编译。
- en: Microservices database patterns
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务数据库模式
- en: Data persistence is an important factor in any microservice. There have been
    new database management systems in the recent past for stocking raw and processed
    data. There are big, fast, streaming, IoT data, and various data processing types
    such as batch, real-time, interactive, and iterative processing. Fresh data capture,
    ingestion, storage, processing, mining, analytics, and visualization technologies
    and tools are emerging and evolving in order to support data-driven insights and
    insight-driven decisions. There are several data-related patterns in the MSA world,
    and this section is specially prepared for discussing them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数据持久性是任何微服务的重要因素。近期，为了存储原始和加工后的数据，出现了新的数据库管理系统。有大型、快速、流式、物联网数据，以及各种数据处理类型，如批量、实时、交互式和迭代处理。为了支持数据驱动的洞察和洞察驱动的决策，新鲜数据捕获、摄取、存储、处理、挖掘、分析和可视化技术和工具正在涌现并不断发展。在MSA（微服务架构）世界中存在几个与数据相关的模式，本节专门准备来讨论这些模式。
- en: Database per service pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个服务一个数据库模式
- en: The MSA pattern is being embraced by mission-critical applications, and such
    MSA-compliant applications invariably provide a variety of business, technical,
    and user advantages. Having realized the strategic significance of the MSA idea,
    worldwide businesses, organizations, and institutions are keenly formulating workable
    and winning strategies and plans for leveraging the distinct capabilities of the
    MSA paradigm. As we know, microservices can be coded using multiple languages,
    and the data persistence needs of microservices can be served by multiple systems
    including **database management systems** (**DBMS**), filesystems, and so on.
    Further on, there are SQL, NoSQL, NewSQL, in-memory, in-database database management
    systems. Thus, microservices support the polyglot capability. This pattern recommends
    the leverage of a database for each service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: MSA（微服务架构）模式正在被关键任务应用所采用，并且这些符合MSA规范的应用必然提供了各种业务、技术和用户优势。意识到MSA理念的战略意义后，全球的企业、组织和机构都热衷于制定可行的和获胜的策略和计划，以利用MSA范式独特的功能。正如我们所知，微服务可以使用多种语言进行编码，微服务的数据持久化需求可以由包括**数据库管理系统**（**DBMS**）、文件系统等在内的多个系统来满足。进一步来说，还有SQL、NoSQL、NewSQL、内存中、数据库内数据库管理系统。因此，微服务支持多语言能力。此模式建议利用每个服务的一个数据库。
- en: There is a growing family of data-intensive applications such as e-commerce,
    business, supply chain management, and so on, and these get segmented into a pool
    of interacting services. Herein, each service needs to persist its own data. Therefore,
    each microservice has to be accordingly enabled through its own data persistence
    mechanism. There are challenges when each microservice uses its own database.
    Complex business transactions have to work across multiple services, and hence,
    multiple databases. Further on, some business operations must update data owned
    by multiple services. There are occasions wherein there is a demand to query data
    that is owned by multiple services. Databases must sometimes be replicated and
    shared in order to scale.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据密集型应用（如电子商务、商业、供应链管理等）的日益增多，这些应用被分割成一组相互作用的服务的集合。在此，每个服务都需要持久化自己的数据。因此，每个微服务必须通过其自身的数据持久化机制相应地启用。当每个微服务使用自己的数据库时，会存在一些挑战。复杂的业务交易需要在多个服务、多个数据库之间工作。进一步来说，某些业务操作必须更新多个服务拥有的数据。有时，需要查询多个服务拥有的数据。为了扩展，数据库有时需要复制和共享。
- en: For ensuring the much-needed isolation for utmost data security, API-driven
    access is being insisted. The service's database is effectively a part of the
    implementation of that service. The database cannot be accessed directly by other
    services. APIs are the way forward for database access. There are a few different
    ways to keep a service's persistent data private. Firstly, a separate table can
    be built and allocated for each microservice. Secondly, a separate schema can
    be generated for each microservice. Finally, a separate database server can be
    allocated for each service. Having a database per service ensures that microservices
    are loosely coupled and the best database solution can be chosen for every service
    based on its task. For example, a microservice performing text searching can be
    given a text mining and search engine. Similarly, a microservice performing social
    media analytics can be empowered with a graph database such as Neo4j.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所需的最大数据安全隔离，正在坚持API驱动的访问。服务的数据库实际上是该服务实现的一部分。数据库不能被其他服务直接访问。API是数据库访问的前进方向。有一些不同的方法可以保持服务持久数据的隐私。首先，可以为每个微服务构建一个单独的表并分配给它。其次，可以为每个微服务生成一个单独的模式。最后，可以为每个服务分配一个单独的数据库服务器。每个服务都有一个数据库确保微服务是松散耦合的，并且可以根据每个服务的任务选择最佳的数据库解决方案。例如，执行文本搜索的微服务可以分配一个文本挖掘和搜索引擎。同样，执行社交媒体分析的微服务可以配备一个图数据库，如Neo4j。
- en: However, as we all know, NoSQL databases do not support the ACID properties,
    and hence distributed and nested transactions are not suitable for microservices
    that involve NoSQL backend systems. The option here is to use an eventually consistent
    and **event-driven architecture** (**EDA**). Service producers publish their messages
    into message queues in the form of topics, whereas service consumers subscribe
    to those topics and use them. Some queries mandate to join data from multiple
    databases. The way forward is to empower applications to do the join operation
    rather than being accomplished at the database. For example, the API gateway or
    a kind of composition service could retrieve a customer, and his/her orders from
    the customer and order microservices. Then, the *join* action can be done by the
    API gateway or the composition service. Another option is to leverage the **command
    query responsibility segregation** (**CQRS**) pattern.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，众所周知，NoSQL数据库不支持ACID属性，因此分布式和嵌套事务不适合涉及NoSQL后端系统的微服务。这里的选项是使用最终一致性和**事件驱动架构**（**EDA**）。服务生产者将他们的消息以主题的形式发布到消息队列中，而服务消费者订阅这些主题并使用它们。一些查询需要从多个数据库中联合数据。前进的方式是赋予应用程序执行联合操作的能力，而不是在数据库中完成。例如，API网关或一种组合服务可以检索客户及其订单，来自客户和订单微服务。然后，*联合*操作可以由API网关或组合服务完成。另一种选择是利用**命令查询责任分离**（**CQRS**）模式。
- en: Shared data design pattern
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享数据设计模式
- en: Microservices are self-defined and autonomous. That is, microservices have all
    the modules (presentation logic, business logic, integration logic, data connectivity,
    and persistence logic) to run in an independent fashion. Further on, services
    can easily draw upon the strength of proven technologies and tools to be fully
    polyglot. That is, nowadays, there are several database management systems such
    as SQL, NoSQL, NewSQL, and so on, and microservices can choose any one of them
    for the data persistence they need to be extremely and elegantly contributory
    to the originally expressed and envisaged business goal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是自我定义和自治的。也就是说，微服务拥有所有模块（表示逻辑、业务逻辑、集成逻辑、数据连接性和持久性逻辑），可以独立运行。进一步来说，服务可以轻松地利用经过验证的技术和工具，实现完全的多语言。也就是说，如今，有几种数据库管理系统，如SQL、NoSQL、NewSQL等，微服务可以选择其中任何一个来满足它们所需的数据持久性，以极其优雅地贡献于最初表达和设想的企业目标。
- en: Organizations modernize their legacy applications to become microservices-enabled,
    modern applications. One standout challenge here is the database normalization.
    That is, each microservice has to have the right amount of data. In this design
    pattern, some services, likely in a chain, may share caching and database stores.
    This is logical if there is a strong coupling between the two services. This pattern
    may be categorized as an anti-pattern because microservices postulate and propose
    the share-nothing phenomenon. For greenfield microservices-centric applications,
    this pattern is undoubtedly an anti-pattern. This pattern can be leveraged as
    a temporary aspect during the transition phase from the monolithic to microservice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 组织将遗留应用程序现代化，使其成为具有微服务功能的现代应用程序。这里的突出挑战之一是数据库规范化。也就是说，每个微服务都必须拥有正确数量的数据。在这个设计模式中，一些服务，可能是一个链中的服务，可能会共享缓存和数据库存储。如果这两个服务之间存在强烈的耦合，这是合理的。这种模式可能被归类为反模式，因为微服务假设并提出了无共享现象。对于以微服务为中心的绿色田野应用，这种模式无疑是反模式。这种模式可以在从单体到微服务的过渡阶段作为临时方面得到利用。
- en: Shared database pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享数据库模式
- en: There are several unique factors for the runaway success of microservices architecture.
    We have been well-versed with shared databases. Now, in the big data and webscale
    applications era, a variety of new and differently abled databases have emerged
    and are doing well for several new-generation applications. The previously discussed
    pattern, therefore, has recommended dedicated databases for different services.
    However, there are certain requirements such as the ACID-centric transactions
    and transactional applications. The solution approach is to use a single database
    that is shared by multiple microservices. Every microservice is comfortably and
    conveniently able to access data owned by other microservices. The shared database
    ensures utmost data consistency. The management and operational complexities of
    a single shared database are on the lower side.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的成功逃逸有几个独特的因素。我们熟悉共享数据库。现在，在大数据和Web规模应用时代，各种新的、功能不同的数据库已经出现，并为许多新一代应用做出了贡献。因此，之前讨论的模式建议为不同的服务使用专用数据库。然而，存在某些要求，如以ACID为中心的事务和事务型应用。解决方案是使用由多个微服务共享的单个数据库。每个微服务都能舒适且方便地访问其他微服务拥有的数据。共享数据库确保了数据的一致性达到极致。单个共享数据库的管理和运营复杂性较低。
- en: As usual, there are a few drawbacks being associated with the shared database
    pattern. The first and foremost is the tight coupling between services and the
    database. The second one is the issues associated with the data sharing. The traditional
    SQL databases do not support horizontal scalability, and hence, the surge in data
    volumes cannot be handled by SQL databases that are shared across.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，共享数据库模式存在一些缺点。首先也是最重要的是服务与数据库之间的紧密耦合。其次是与数据共享相关的问题。传统的SQL数据库不支持水平扩展，因此，数据量的激增无法由跨多个服务的共享SQL数据库处理。
- en: Command-query responsibility segregation (CQRS) pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）模式
- en: In the microservices world, implementing queries that join data from multiple
    services and their own databases is a real challenge. The solution approach is
    to split the application into two parts; the command side and the query side.
    The command side handles create, update, and delete requests and emits events
    when data changes. The query side handles queries by executing them against one
    or more materialized views that are kept up to date by subscribing to the stream
    of events emitted when data changes. The advantages are many. This pattern is
    especially necessary for an **event-driven architecture** (**EDA**) environment.
    This gives improved separation of concerns and supports multiple denormalized
    views.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，实现连接来自多个服务和它们自己的数据库的查询是一个真正的挑战。解决方案是将应用程序分成两部分；命令端和查询端。命令端处理创建、更新和删除请求，并在数据更改时发出事件。查询端通过执行一个或多个由订阅数据更改时发出的事件流来保持更新的物化视图来处理查询。这种模式有很多优点。这种模式对于**事件驱动架构（EDA**）环境尤其必要。这提供了更好的关注点分离，并支持多个非规范化视图。
- en: Microservices integration patterns
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务集成模式
- en: Microservices are autonomous and self-defined. Still, distributed and decentralized
    services ought to talk to each other in order to produce powerful process-centric
    and business-critical applications. This section is specially allocated for letting
    you know about the brewing integration patterns in the MSA environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是自治和自定义的。然而，分布式和去中心化的服务应该相互交谈，以产生强大的以流程为中心和业务关键的应用。本节专门分配给您了解MSA环境中正在酝酿的集成模式。
- en: Remote procedure invocation (RPI) pattern
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用（RPI）模式
- en: Microservices have to interoperate with multiple microservices in order to complete
    any complex functionality. For this purpose, services use an inter-process communication
    protocol. The solution approach is to leverage the RPI for any inter-service communication
    and collaboration. The client uses a request/reply-based protocol to make requests
    to a service. The well-known RPI technologies include REST, gRPC, and Apache Thrift.
    This pattern is easy to implement and there is no need for any intermediate broker
    for facilitating the intended communication. However, there are a few critical
    drawbacks being associated with this pattern. That is, services are tightly coupled
    and have to be online to find, bind, and interact. Other prominent interaction
    types such as notifications, request/asynchronous response, publish/subscribe,
    and publish/asynchronous response are not supported here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务必须与多个微服务交互才能完成任何复杂的功能。为此，服务使用进程间通信协议。解决方案是利用RPI进行任何服务间的通信和协作。客户端使用基于请求/回复的协议向服务发送请求。知名的RPI技术包括REST、gRPC和Apache
    Thrift。这种模式易于实现，无需任何中间代理来促进预期的通信。然而，这种模式有几个关键的缺点。那就是，服务之间紧密耦合，必须在线才能找到、绑定和交互。其他突出的交互类型，如通知、请求/异步响应、发布/订阅和发布/异步响应，这里不支持。
- en: Messaging design pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息设计模式
- en: 'Messaging is typically asynchronous in nature and is used extensively for inter-service
    communication. Services talk to one another by exchanging standardized messages
    over messaging channels. There are message brokers, hubs, and queues (Apache Kafka,
    RabbitMQ, and so on) in the market. This pattern has the following benefits:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通常是异步的，在服务间通信中被广泛使用。服务通过在消息通道上交换标准化的消息来相互交谈。市场上存在消息代理、中心节点和队列（如Apache Kafka、RabbitMQ等）。这种模式有以下优点：
- en: Messaging enables loose and light coupling between participating and contributing
    services. The dependency hell gets eliminated here.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息使得参与和贡献服务之间松散且轻量级的耦合成为可能。依赖地狱在这里被消除。
- en: Message brokers typically buffer messages until the subscriber/consumer is able
    to receive and process them. This intermediary-based message storage enhances
    the message availability. This pattern supports a variety of communication patterns
    such as fire and forgets, polling, publish, and subscribe.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理通常将消息缓冲，直到订阅者/消费者能够接收和处理它们。这种基于中间代理的消息存储增强了消息的可用性。这种模式支持多种通信模式，如“发送即忘”，轮询、发布和订阅。
- en: Asynchronous communication through messaging middleware solutions turns out
    to be the messiah for the distributed computing era.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息中间件解决方案实现的异步通信最终成为分布式计算时代的救世主。
- en: Asynchronous messaging design pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步消息设计模式
- en: Message-based asynchronous communication is insisted on setting up and sustaining
    reliable and resilient microservices. The loose and light coupling between microservices
    and the interactions happening through passing standardized messages are being
    touted as the success formula for the MSA pattern. The highly popular REST design
    pattern is typically synchronous and hence blocks the client service. The much-needed
    asynchronous interaction is still possible through the RESTful protocol, but it
    has to be achieved at the application level. Therefore, the leverage of message
    brokers and queues has gone up significantly in the MSA world. Further on, there
    is a mix of both synchronous and asynchronous communications. For example, Service
    A may call Service C synchronously, which is then communicating with Service B
    and D asynchronously using a shared message queue. By using WebSockets, Service
    A can talk to Service C in an asynchronous manner to achieve the mandated scalability.
    Precisely speaking, a combination of the request/response (REST) and pub/sub messaging
    may be used to accomplish any unique business needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 强调基于消息的异步通信，以建立和维护可靠的弹性微服务。微服务之间松散且轻量级的耦合以及通过传递标准化消息发生的交互被视为 MSA 模式的成功公式。高度流行的
    REST 设计模式通常是同步的，因此会阻塞客户端服务。通过 RESTful 协议，仍然可以实现所需的异步交互，但这必须在应用层面实现。因此，在 MSA 世界中，消息代理和队列的使用显著增加。进一步来说，存在同步和异步通信的混合。例如，服务
    A 可能同步调用服务 C，然后通过共享的消息队列异步与服务 B 和 D 通信。通过使用 WebSockets，服务 A 可以以异步方式与服务 C 通信，以实现规定的可伸缩性。精确地说，可以使用请求/响应（REST）和发布/订阅消息的组合来完成任何独特的业务需求。
- en: Domain-specific protocol pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定协议模式
- en: There are a wider variety of inter-process communication protocols. For certain
    scenarios, domain-specific protocols are being recommended for inter-process communication.
    For email services, SMTP and IMAP are the preferred ones. For media streaming
    requirements, RTMP, HLS, and HDS are being used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着更多种类的进程间通信协议。对于某些场景，推荐使用领域特定协议进行进程间通信。对于电子邮件服务，SMTP 和 IMAP 是首选的协议。对于媒体流需求，RTMP、HLS
    和 HDS 正在得到应用。
- en: API gateway pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 网关模式
- en: There are several challenges in the MSA world. Microservices are generally fine-grained
    and each of them is blessed with a granular API. The other characteristics include
    different services are being coded using different languages and many data transmission
    protocols and data persistence methods. In short, services support the polyglot
    architecture. Further on, there are several client options such as desktop, mobile,
    wearable, portable, and fixed devices. There are telling scenarios that consume
    data and application logic from different and distributed microservices and data
    services. Precisely speaking, we are heading into the days of distributed computing.
    Microservices need to find the appropriate services to interact with and contribute
    to completing the desired business functionality and goals in a time-bound and
    SLA-compliant manner.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MSA 世界中存在一些挑战。微服务通常是细粒度的，并且每个微服务都拥有粒度化的 API。其他特点包括不同的服务使用不同的语言编写，以及许多数据传输协议和数据持久化方法。简而言之，服务支持多语言架构。进一步来说，存在多种客户端选项，如桌面、移动、可穿戴、便携式和固定设备。有明确的情况是，从不同的和分布式的微服务和数据服务中消耗数据和应用程序逻辑。精确地说，我们正走向分布式计算的时代。微服务需要找到适当的交互服务，并在规定的时间和
    SLA 合规的范围内完成所需的业务功能目标。
- en: Network topologies and technologies also play a vital role in shaping up MSA
    applications. The latency of different methods such as WAN, MAN, LAN, CAN, PAN,
    and BAN differs. That is, the latency is lower in personal area networks, whereas
    it is on the higher side for wide area networks. Microservices can quickly access
    nearby microservices multiple times, whereas, in the case of remote services,
    the number of service access is lower and time-consuming.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 网络拓扑和技术在塑造 MSA 应用中也发挥着至关重要的作用。WAN、MAN、LAN、CAN、PAN 和 BAN 等不同方法的延迟不同。也就是说，个人区域网络的延迟较低，而广域网络的延迟较高。微服务可以快速多次访问附近的微服务，而在远程服务的情况下，服务访问次数较低且耗时较长。
- en: The viable and value-adding solution approach is to have an API gateway as the
    **single point of contact** (**SPOC**) for all kinds of services in order to interact
    with local as well as remote services. All kinds of connectivity, mediation, brokerage,
    aggregation, message enrichment, protocol and data format translations, and so
    on are being taken care of by this standardized API gateway solution. Multiple
    services and data sources are neatly found and composed by this API gateway service
    that can also expose a unique API for each client. The security requirements of
    the data and messages flowing through the network channels are also accomplished
    by this product.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可行且增值的解决方案方法是将API网关作为所有类型服务的**单一接触点**（SPOC）以与本地和远程服务进行交互。所有类型的连接性、调解、经纪、聚合、消息丰富、协议和数据格式转换等均由这种标准化的API网关解决方案负责。通过此API网关服务，可以整洁地找到和组合多种服务和数据源，该服务还可以为每个客户端暴露独特的API。通过网络通道传输的数据和消息的安全要求也由该产品完成。
- en: Backend for frontend pattern
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端后端模式
- en: This pattern recommends and defines a separate API for each kind of client.
    Typically, apart from the traditional web interface, mobile and management interfaces
    are common these days. An API gateway has the capability of providing different
    APIs for different client types. The API gateway insulates the clients from the
    application, which can be partitioned into multiple cooperative microservices.
    This way, any kind of application refactoring, re-platforming, and retrofitting
    does not have any sinister impact on approaching clients. The optimal APIs can
    be chosen and used for the appropriate client. The API gateway enables clients
    to retrieve data from multiple services and sources with a single round-trip operation.
    Fewer requests also mean less overhead and improve the user experience. Multiple
    backend microservices and data sources can be orchestrated on a need basis to
    produce bigger and better applications. This transformation gives a unique experience
    for user agents. The API gateway intrinsically takes care of all kinds of data
    and protocol translations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议并为每种类型的客户端定义一个独立的API。通常，除了传统的Web界面外，移动和管理界面在当今也很常见。API网关具有为不同客户端类型提供不同API的能力。API网关能够隔离客户端与应用程序，应用程序可以被划分为多个协作的微服务。这样，任何类型的应用程序重构、重新平台化和改造都不会对接近客户端产生任何恶意影响。可以根据适当的客户端选择和使用的最佳API。API网关使客户端能够通过单次往返操作从多个服务和来源检索数据。更少的请求也意味着更少的开销，并改善了用户体验。可以根据需要编排多个后端微服务和数据源，以产生更大更好的应用程序。这种转型为用户代理提供了独特的体验。API网关本质上负责所有类型的数据和协议转换。
- en: Microservices registration, discovery, and usage patterns
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务注册、发现和使用模式
- en: Services need to be registered in a publicly available service registry in order
    to enable services to be found at runtime and leveraged accordingly. In a dynamic
    and distributed environment, services move around, so the task of runtime service
    discovery has to be facilitated through such network-accessible registries and
    repositories. Not only services, but also their instances, have to be registered
    to simplify the goal of high availability of services.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行时找到并相应地利用服务，服务需要在公开可用的服务注册表中注册。在动态和分布式环境中，服务会移动，因此运行时服务发现的任务必须通过此类网络可访问的注册表和存储库来简化。不仅服务，它们的实例也必须注册，以简化服务高可用性的目标。
- en: Service discovery pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现模式
- en: Microservices have to find one or more appropriate microservice to initiate
    a kind of conversation towards fulfilling the identified business functionality.
    As we all know, there are several service discovery mechanisms, service registries,
    and repositories. In the traditional web service world, we used to play around
    with WSDL and UDDI for service interfacing, discovery, and initiation. In the
    earlier era too, we were tinkering with RPC, RMI, CORBA, EJB, Jini, and so on.
    In the recent past, RESTful service interactions are the most common way of establishing
    service connectivity and service fulfillment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务必须找到一个或多个适当的微服务，以启动一种对话，以满足已识别的业务功能。众所周知，有几种服务发现机制、服务注册表和存储库。在传统的Web服务世界中，我们曾经围绕WSDL和UDDI进行服务接口、发现和启动的实验。在早期时代，我们也曾尝试RPC、RMI、CORBA、EJB、Jini等。在最近过去，RESTful服务交互是建立服务连接和服务实现的最常见方式。
- en: However, microservices are quite distinct in the sense that they are more dynamic,
    varied, and versatile and many in numbers. Further on, services are predominantly
    made to run inside virtual machines and containers. Virtualized and containerized
    environments are dynamic with the inherent ability to provide live-in migration
    of virtualized resources and workloads. The API gateway is one solution for appropriately
    enabling services to discover services to correspond and complete the business
    functionality. The service registry is to have all the required information such
    as location, host, port, and so on of all the participating and contributing services.
    This sort of mechanism aids in sharply reducing the number of network hops for
    services trying to involve other services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，微服务在动态性、多样性和灵活性方面非常独特，数量众多。进一步来说，服务主要是为了在虚拟机和容器中运行而设计的。虚拟化和容器化环境具有动态性，固有地能够提供虚拟化资源和工作负载的实时迁移能力。API网关是一种解决方案，可以适当地使服务能够发现服务以对应并完成业务功能。服务注册包含所有参与和贡献服务的必要信息，如位置、主机、端口等。这种机制有助于显著减少尝试涉及其他服务的服务的网络跳数。
- en: For enterprise-class services, the connectivity typically happens through a
    clustered load balancer. The location of the load balancer is predefined and determined.
    Services send the request to the load balancer, which in turn queries a service
    registry, which may be built into the load balancer. The load balancer then forwards
    the service request and query to an available instance of the particular service.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业级服务，连接通常通过集群负载均衡器来实现。负载均衡器的位置是预定义和确定的。服务将请求发送到负载均衡器，负载均衡器随后查询服务注册，该注册可能集成在负载均衡器中。然后负载均衡器将服务请求和查询转发到特定服务的可用实例。
- en: The popular clustering solutions such as Kubernetes ([https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md))
    and Marathon ([https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html](https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html))
    run a proxy on each host. The proxy actually functions as a server-side discovery
    router/load balancer. In order to access a service, a client service connects
    to the local proxy using the port assigned to that service. The proxy then forwards
    the request to a service instance running somewhere in the cluster. Routers, **application
    delivery controllers** (**ADCs**), load balancers, and other network solution
    modules are made available in large-scale IT environments such as clouds.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的集群解决方案，如Kubernetes ([https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md))
    和Marathon ([https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html](https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html))
    在每个主机上运行一个代理。代理实际上充当服务器端发现路由器/负载均衡器。为了访问一个服务，客户端服务通过分配给该服务的端口连接到本地代理。然后代理将请求转发到集群中某处运行的服务实例。路由器、**应用交付控制器**（**ADCs**）、负载均衡器和其他网络解决方案模块在大规模IT环境中（如云）可用。
- en: Service registry pattern
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册模式
- en: 'Service registries and repositories are very vital for any software development
    organization. With microservices emerging as the next-generation application building
    block, the relevance of services and their one-stop registry is on the climb.
    A service registry has all the right references for each of the services in the
    environment. That is, each service, once developed, has to be registered with
    the service registry in order to be found, bound, and to contribute immensely.
    Thus, any service wanting to connect with other services has to first connect
    to the service registry to collect all the discovery, access, and leverage details
    of the services. A service registry might invoke a service instance''s health
    check API to verify that it is able to handle requests. The well-known service
    registry technologies are:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册和存储库对于任何软件开发组织都至关重要。随着微服务成为下一代应用构建块，服务和它们一站式注册的相关性正在上升。服务注册为环境中的每个服务提供所有正确的引用。也就是说，每个服务一旦开发完成，就必须在服务注册中注册，以便被发现、绑定并做出巨大贡献。因此，任何想要与其他服务连接的服务都必须首先连接到服务注册，以收集所有服务的发现、访问和利用细节。服务注册可能会调用服务实例的健康检查API来验证它是否能够处理请求。知名的服务注册技术包括：
- en: Apache Zookeeper
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Zookeeper
- en: Consul
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Consul
- en: Etcd
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Etcd
- en: A service registry is very critical in the service world and it has to be highly
    available. If it is not available even for a short time, then the business continuity
    is in danger.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务世界中，服务注册表非常重要，它必须高度可用。如果它连短时间内都无法可用，那么业务连续性就处于危险之中。
- en: Service registration pattern
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册模式
- en: We have discussed the importance of the service registry. Because of the dynamism
    being exhibited by microservices, the role of the service registry acquires special
    significance. Every single service has to be registered with the service registry
    in order to be extremely beneficial for businesses. That is, the details of each
    service instance must be registered with the service registry when each instance
    begins its long and arduous journey. On the other hand, the service instance gets
    unregistered on getting decommissioned or shut down.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了服务注册的重要性。由于微服务的动态性，服务注册表的作用变得特别重要。每个服务都必须在服务注册表中注册，以便对业务极为有益。也就是说，每个实例的详细信息必须在每个实例开始其漫长而艰巨的旅程时注册到服务注册表中。另一方面，当服务实例被退役或关闭时，服务实例将被注销。
- en: Microservices can register themselves or a third-party solution can be assigned
    to register each service instance. For the first case, microservices are solely
    responsible for registering themselves with the service registry. On start-up,
    the service registers itself (host and IP address) with the service registry and
    makes itself available to be discovered and hooked. Not only services, but also
    each instance of those services has to register methodically with the service
    registry. If one service instance fails, the other service instances come in handy
    in sustaining the business operations, offerings, and outputs. For the second
    case, third-party solution and service providers can be contracted to set up a
    service registry to register each service instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以自行注册，或者可以指定第三方解决方案来注册每个服务实例。在第一种情况下，微服务完全负责将自己注册到服务注册表中。在启动时，服务会将自己（主机和IP地址）注册到服务注册表中，并使其可被发现和连接。不仅服务本身，而且这些服务的每个实例都必须有系统地注册到服务注册表中。如果一个服务实例失败，其他服务实例可以方便地维持业务运营、提供和输出。在第二种情况下，可以与第三方解决方案和服务提供商签订合同，以设置服务注册表来注册每个服务实例。
- en: Event-driven architecture (EDA) patterns
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构（EDA）模式
- en: With the emergence of legions of digitized items/smart objects/sentient materials,
    along with the scores of connected devices in our everyday environments, everyone
    is going to be significantly sagacious in his or her decisions, deeds, and deals.
    In the projected IoT world, a lot of decisive and deeper automation is bound to
    happen. Any tangible thing in our midst is internally as well as externally empowered
    in time to proactively and pre-emptively act on all kinds of noteworthy events.
    That is, every single entity in and around us is going to be event-driven. The
    role of IT in the projected event-driven world is paramount and path-breaking.
    The IT systems and business applications/services have to capture, buffer, process,
    mine, and analyze all incoming events to spit out insights. The days ahead are
    definitely digital, and our everyday systems ought to be adequately and adroitly
    empowered to be *sense* and *react*. Herein, the role and responsibility of EDA
    in enabling our IT and business systems to be innovative, disruptive, and transformative
    are bound to grow further.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 随着大量数字化物品/智能对象/感知材料的出现，以及我们日常环境中成百上千的连接设备，每个人在决策、行为和交易方面都将变得更加明智。在预期的物联网世界中，许多决定性和更深入的自动化必将发生。我们周围的所有有形事物都将内外部获得权力，以便在适当的时候主动和预防性地对各种值得注意的事件采取行动。也就是说，我们周围和周围的每一个实体都将被事件驱动。在预期的事件驱动世界中，IT的作用至关重要，具有突破性。IT系统和业务应用程序/服务必须捕获、缓冲、处理、挖掘和分析所有传入的事件，以产生见解。未来的日子肯定是数字化的，我们的日常系统应该足够聪明和熟练，以便能够*感知*和*反应*。在这里，EDA在使我们的IT和业务系统具有创新性、颠覆性和变革性方面发挥的作用和责任必将进一步增长。
- en: Database per service is the predominant solution approach in the MSA world.
    But there are specific requirements wherein the ACID transaction is mandatory
    for guaranteeing the goal of data consistency. The way forward is to use the proven
    and potential event-driven architecture to attain the data consistency. That is,
    each service publishes an event whenever it updates its data. Other services subscribe
    to those published events and accordingly update their own databases. This guarantees
    data consistency across multiple microservices without going through the traditionally
    distributed transactions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSA（微服务架构）世界中，每个服务使用数据库是主要的解决方案。但是，有一些特定要求，其中ACID事务对于保证数据一致性目标是强制性的。前进的道路是使用经过验证和潜在的事件驱动架构来实现数据一致性。也就是说，每个服务在更新其数据时都会发布一个事件。其他服务订阅这些发布的事件，并相应地更新它们自己的数据库。这保证了多个微服务之间的数据一致性，而无需通过传统的分布式事务。
- en: To fulfil the promise of faster delivery cycles, teams need autonomy. Dependence
    across teams is a recipe for slow progress. This is why monolithic architectures
    progress slowly. Isolation between services is how teams can retain autonomy -
    maintaining this isolation is critical.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更快交付周期的承诺，团队需要自主权。团队间的依赖是缓慢进步的配方。这就是为什么单体架构进步缓慢的原因。服务之间的隔离是团队保持自主权的方式——维持这种隔离至关重要。
- en: Each team must be empowered to make independent decisions even about their data
    layer without impacting or becoming dependent on any other team. Even the choice
    of the types of data store should be independent—this concept is known as polyglot
    persistence. How the data is modeled should also be an autonomous decision, local
    to each service. The team should have full control over making schema changes,
    that is, adding or dropping tables and entities, or columns and attributes. What
    about modifying, adding, or deleting classes and objects? In autonomous teams,
    these need to be non-breaking changes for other teams, to protect each team's
    autonomy. The safest way to ensure that each team has the independence to make
    their own data layer choices is to not share the data store across microservices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队都必须有权做出独立决策，甚至关于他们的数据层，而不会影响或依赖任何其他团队。甚至数据存储类型的选择也应该是独立的——这个概念被称为多语言持久性。数据如何建模也应该是一个自主决策，本地化到每个服务。团队应该完全控制对模式进行更改，即添加或删除表和实体，或列和属性。那么修改、添加或删除类和对象呢？在自主团队中，这些需要是对其他团队非破坏性的更改，以保护每个团队的自主权。确保每个团队都有权做出自己的数据层选择的最佳方式是不在微服务之间共享数据存储。
- en: The isolation between services sets boundaries around each microservice, while
    the event-driven mechanism addresses how services communicate. The role of the
    event-driven system is critical to the overall operation of the architecture.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 服务之间的隔离为每个微服务设定了边界，而事件驱动机制解决了服务如何通信的问题。事件驱动系统在架构的整体运行中起着至关重要的作用。
- en: Event sourcing pattern
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源模式
- en: Event sourcing is an architectural pattern in which the state of an application
    is determined by a sequence of events. Each event in the sequence is recorded
    in an append-only event store or stream. Conventionally, most software applications
    work with data and the application has to maintain the current state of the data
    by updating it as users work with the data. A typical data process is to read
    data from the store, make some modifications to it, and update the current state
    of the data with the new values. The transaction is one that changes the data
    value. However, this way of data update and keeping up the data consistency has
    many inherent limitations. It requires a **two-phase commit** (**2PC**) when accomplishing
    distributed transactions. Any 2PC commit reduces the throughput of transactions
    substantially. When there are many concurrent users, there is a possibility for
    data update conflicts because the update operations take place on a single item
    of data. Further on, there is a need for an additional auditing mechanism, which
    records the details of each operation in a separate log, otherwise, the history
    is lost.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是一种架构模式，其中应用程序的状态由一系列事件确定。序列中的每个事件都记录在只追加的事件存储库或流中。传统上，大多数软件应用与数据交互，并且应用必须通过在用户操作数据时更新数据来维护数据的当前状态。典型的数据处理过程是从存储中读取数据，对其进行一些修改，并使用新值更新数据的当前状态。事务是改变数据值的过程。然而，这种数据更新和数据一致性维护的方式有许多固有的局限性。在完成分布式事务时，需要**两阶段提交**（**2PC**）。任何2PC提交都会大幅度降低事务吞吐量。当有多个并发用户时，由于更新操作发生在单个数据项上，可能会出现数据更新冲突的可能性。进一步来说，还需要一个额外的审计机制，该机制记录每个操作的详细信息到一个单独的日志中，否则历史记录就会丢失。
- en: Event sourcing achieves the much-needed atomicity without the complex 2PC process
    by using the event-centric approach. Rather than storing the current state of
    an entity, the application stores a sequence of state-changing events. That is,
    whenever the state of a business entity changes, a new event is created and appended
    to the list of already captured and stored events. Since saving an event is a
    single operation, it is inherently atomic. The software application can then easily
    reconstruct an entity's current state by replaying the events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源通过使用以事件为中心的方法，实现了所需的原子性，而不需要复杂的2PC过程。而不是存储实体的当前状态，应用程序存储一系列状态改变的事件。也就是说，每当业务实体的状态发生变化时，就会创建一个新的事件并将其附加到已捕获和存储的事件列表中。由于保存事件是一个单一操作，因此它是原子的。然后，软件应用可以通过回放事件轻松地重建实体的当前状态。
- en: Software applications and services classically are persisting events in an event
    store (a database of events) and the event store exposes an API for adding and
    retrieving a business entity's events. The event store also behaves like a *publish
    and subscribe* message broker. Subscribers can subscribe to particular events.
    Whenever there is a new event, the event store delivers it to all the rightful
    subscribers. Further on, an application can periodically save a snapshot of an
    entity's current state. To reconstruct the current state, the application takes
    the most recent snapshot and the events that have occurred since that snapshot.
    Thus, sourcing and storing events acquires special significance in the event-driven
    world.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用和服务通常将事件持久化存储在事件存储库（事件数据库）中，事件存储库公开了一个API，用于添加和检索业务实体的事件。事件存储库还像是一个*发布和订阅*消息代理。订阅者可以订阅特定的事件。每当有新事件发生时，事件存储库将其发送给所有合法的订阅者。进一步来说，应用程序可以定期保存实体的当前状态快照。为了重建当前状态，应用程序将最近的快照和自该快照以来发生的事件进行回放。因此，在事件驱动世界中，事件溯源和存储变得尤为重要。
- en: Transaction log tailing pattern
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务日志尾部模式
- en: This is another option for achieving distributed transactions. The idea is to
    tail the database transaction log and publish each change as an event. The benefit
    with this pattern is that there is no change required at the application level;
    everything happens at the database level. Avoiding duplicate publishing is a bit
    difficult. This pattern ensures low-level DB changes, but it is quite difficult
    to determine the business-level events.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现分布式事务的另一种选择。其思路是跟踪数据库事务日志，并将每个更改发布为一个事件。这种模式的优点是无需在应用层进行任何更改；所有操作都在数据库层完成。避免重复发布有点困难。这种模式确保了低级别的数据库更改，但确定业务级别的事件相当困难。
- en: Publishing events using the database trigger pattern
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库触发器模式发布事件
- en: This is another solution approach for the challenge and concern of distributed
    transactions among multiple microservices. One or more database triggers insert
    events into an `EVENTS` table, which is polled by a separate process that publishes
    the events to a message broker, and the required microservices and their databases
    consume them and get updated accordingly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决多个微服务之间分布式事务挑战和关注点的另一种解决方案方法。一个或多个数据库触发器将事件插入到`EVENTS`表中，该表由一个独立的过程轮询，该过程将事件发布到消息代理，并且所需的微服务和它们的数据库消费它们并相应地更新。
- en: Application publishes events pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序发布事件模式
- en: The application inserts events into an `EVENTS` table as a part of the local
    transaction. A separate process polls the `EVENTS` table and publishes the events
    to a message broker. The key concerns being associated with this pattern is that
    appropriate changes have to be enacted on the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将事件插入到作为本地事务一部分的`EVENTS`表中。一个独立的过程轮询`EVENTS`表并将事件发布到消息代理。与这种模式相关的主要关注点是必须在应用程序上实施适当的更改。
- en: It is going to be an event-driven world. Events in formalized and standardized
    forms are going to be the real differentiators for the futuristic systems to be
    sensitive, responsive, and resilient in their actions and reactions. With the
    IoT era fast dawning, there will be trillions of events and the IT systems, plus
    the business applications, that have to be accordingly defined and designed. Herein,
    the role of microservices in setting up and sustaining such kinds of adaptive,
    people-centric, process-optimized, service-oriented, and event-driven applications
    is remarkably growing. The EDA pattern is turning out to be an extremely rightful
    entity for the IoT world. Microservices are capable of capturing and processing
    event messages for producing rightful outputs. The message-based asynchronous
    communication model is also supported by microservices.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将成为一个事件驱动的世界。形式化和标准化的事件将成为未来系统敏感、响应和弹性行动和反应的真实区分器。随着物联网时代的迅速到来，将有数万亿的事件和必须相应定义和设计的IT系统以及业务应用程序。在此，微服务在建立和维持此类适应性、以人为本、流程优化、面向服务和事件驱动的应用程序中的作用显著增长。EDA模式正成为物联网世界的极其合适的实体。微服务能够捕获和处理事件消息以产生正确的输出。基于消息的异步通信模型也由微服务支持。
- en: Testing and troubleshooting patterns
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和故障排除模式
- en: Performing service verification and validation for understanding its ability
    to provide its assigned functionality, as well as the **non-functional requirements**
    (**NFRs**), is an important parameter and factor for the proclaimed success of
    microservices. This section will throw some light on service testing, debugging,
    and troubleshooting.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行服务验证和验证以了解其提供分配功能的能力，以及**非功能性需求**（**NFRs**），是微服务宣称成功的重要参数和因素。本节将简要介绍服务测试、调试和故障排除。
- en: Access token pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问令牌模式
- en: We talked about the contributions of the API gateway for attaining the intended
    success of the microservices architecture pattern. The API gateway is the first
    entry point for client services and it works thereafter on behalf of the client
    services. However, the challenge is how to do user identification, authentication,
    and authorization. That is, how to communicate the identity of user agents/requesting
    services to the requested services to kick-start the task as per the expressed
    intention.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了API网关在实现微服务架构模式预期成功方面的贡献。API网关是客户端服务的第一个入口点，它代表客户端服务工作。然而，挑战是如何进行用户识别、认证和授权。也就是说，如何将用户代理/请求服务的身份与请求的服务通信，以启动按表达意图执行的任务。
- en: The API gateway authenticates the request and passes an access token (for example,
    JSON Web Token, [https://jwt.io/](https://jwt.io/)) that securely identifies the
    requestor in each request to the services. A service can include the access token
    in requests it makes to other services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: API网关验证请求并传递一个访问令牌（例如，JSON Web Token，[https://jwt.io/](https://jwt.io/)），该令牌在每个请求中安全地识别请求者。一个服务可以在它对其他服务的请求中包含访问令牌。
- en: Service component test pattern
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务组件测试模式
- en: Testing microservices and their instances is very important for service verification
    and validation. Writing exemplary test cases and leveraging automated testing
    tools comes in handy in checking whether services function as intended. The end-to-end
    testing of applications that in turn involve many distributed and decentralized
    microservices is not an easy affair indeed. The solution approach is to use a
    proven test suite. Microservices pass the test in isolation but testing microservices-based
    applications present a few challenges.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试微服务和它们的实例对于服务验证和验证非常重要。编写示例测试用例并利用自动化测试工具有助于检查服务是否按预期运行。对涉及许多分布式和去中心化微服务的应用程序进行端到端测试确实不是一件容易的事情。解决方案是使用经过验证的测试套件。微服务可以独立通过测试，但基于微服务的应用程序的测试带来了一些挑战。
- en: Log aggregation pattern
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志聚合模式
- en: Each instance of any microservice writes information about what it is doing
    to a log file in a standardized format. The log file typically contains errors,
    warnings, information, and debug messages. The challenge is to understand the
    application behavior and to troubleshoot the application using the individual
    logs. The way forward is to use a centralized logging service that innately aggregates
    all the logs being produced by each service instance. There are automated tools
    for log analytics. In general, log analytics prewarn if there is any substantial
    deviation in the functioning of both software and hardware components. Administrators
    and users separately visit the log store and search for any useful information
    out of the logs to ponder about the next course of action.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 任何微服务的每个实例都会以标准化的格式将其正在执行的操作信息写入日志文件。日志文件通常包含错误、警告、信息和调试消息。挑战在于理解应用程序行为，并使用单个日志来排除应用程序的故障。前进的方式是使用一个集中的日志服务，该服务本质上会聚合每个服务实例产生的所有日志。有日志分析自动化工具。一般来说，日志分析会在软件和硬件组件的功能出现任何重大偏差时发出预警。管理员和用户分别访问日志存储并从日志中搜索任何有用的信息，以便思考下一步的行动。
- en: Application metrics pattern
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用指标模式
- en: This is another way prescribed to understand and articulate application behavior.
    All along, we have been bombarded with a number of software design and evaluation
    metrics. Finalizing all the right and relevant metrics for microservices is a
    good starting point in order to reach the goal of getting to know application
    behavior. The recommended solution is to have a centralized metrics service that
    gathers and stocks the decision-enabling statistics of each of the service operations.
    Microservices can push their metrics information to the metrics service. On the
    other side, the metrics service can pull metrics from the microservice. Metrics
    services are emerging as an important ingredient in the MSA world.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是理解并阐述应用程序行为的另一种方法。一直以来，我们都被大量的软件设计和评估指标所包围。为微服务最终确定所有正确和相关的指标是一个好的起点，以便达到了解应用程序行为的目标。推荐的解决方案是拥有一个集中的指标服务，该服务收集并存储每个服务操作的决策支持统计数据。微服务可以将它们的指标信息推送到指标服务。另一方面，指标服务可以从微服务中拉取指标。指标服务正在成为MSA世界中的一个重要组成部分。
- en: Audit logging pattern
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计日志模式
- en: The auditability of services is very essential. This helps in understanding
    the behavior of users as well as applications. Keeping an audit of all the user
    interactions is going to be helpful in setting up and sustaining the microservices
    environment. The auditing code has to be intertwined with the business logic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的可审计性非常关键。这有助于理解用户以及应用程序的行为。对所有用户交互进行审计将有助于设置和维持微服务环境。审计代码必须与业务逻辑交织在一起。
- en: Distributed tracing pattern
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式跟踪模式
- en: The currently available techniques and tools for software testing and troubleshooting
    are being found obsolete and incompetent, especially for microservice-based applications.
    As we move from the monolithic era to the promising microservices era, there is
    a need for a bunch of versatile tools for checking services in isolation as well
    as microservice-centric applications in totality. As individual services cannot
    give the big picture, the new-generation testing and debugging tools have to have
    the distinct capability to do the same at the application level. That is, the
    tools must present the complete picture of application performance along with
    how the application delivers its functionality.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可用的软件测试和故障排除技术和工具被发现已经过时和无力，尤其是对于基于微服务的应用程序。随着我们从单体时代迈向有希望的微服务时代，我们需要一系列多功能的工具来检查独立的服务以及整体微服务应用程序。由于单个服务不能提供整体图景，新一代的测试和调试工具必须具有在应用层面做到同样事情的独特能力。也就是说，工具必须展示应用程序性能的完整图景，以及应用程序如何交付其功能。
- en: Therefore, this pattern recommends the leverage of a distributed tracing tool,
    which can track every request and capture the associated data as it scans through
    multiple microservices. The tool then aggregates the collected details to give
    an integrated and 360-degree view of the application behavior and performance.
    The solution approach is to instrument each microservice with code that assigns
    each external request a unique ID. The code enables to pass the ID to all the
    services involved in handling the request, to include the ID in all the log messages,
    and finally to record the value-adding information such as start and end times.
    This pattern enables developers to see how an individual request is being handled
    by searching across aggregated logs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此模式建议利用分布式跟踪工具，该工具可以跟踪每个请求并在扫描多个微服务时捕获相关数据。然后，该工具将收集的详细信息汇总，以提供对应用程序行为和性能的全面和360度视图。解决方案方法是使用代码对每个微服务进行配置，为每个外部请求分配一个唯一的ID。该代码使能够将ID传递给所有参与处理请求的服务，将ID包含在所有日志消息中，并最终记录如开始和结束时间等增值信息。此模式使开发者能够通过搜索汇总日志来查看单个请求的处理方式。
- en: Exception tracking pattern
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常跟踪模式
- en: Microservices and their various instances are made to run on multiple BM servers,
    VMs, and even inside Docker containers. Errors may occur when services handle
    requests from other services. Typically, services throw an exception with an error
    message and a stack trace. The need here is to de-duplicate the exceptions, record,
    and investigate them consciously to understand and resolve the issue. The approach
    is to report all exceptions to a centralized exception tracking service. Developers
    and debugging professionals can view exceptions and ensure their resolution in
    time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和它们的各个实例被部署在多个BM服务器、虚拟机（VM）甚至Docker容器中。当服务处理来自其他服务的请求时可能会发生错误。通常，服务会抛出一个包含错误信息和堆栈跟踪的异常。这里的需要是对异常进行去重、记录并自觉地调查它们，以理解和解决这些问题。方法是向集中式异常跟踪服务报告所有异常。开发者和调试专业人员可以查看异常并确保及时解决。
- en: Health check API pattern
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查API模式
- en: The health check has been an important part of the IT industry. All kinds of
    software and hardware systems are being regularly checked for their health. It
    is the same with microservices. Services are running, but sometimes, they are
    unable to handle service requests due to various reasons. In these circumstances,
    the service monitoring system has to generate an alert and send it to the operational
    team to act upon in real time. The load balancer also understands any failed service
    instances and accordingly routes requests to the live services in order to guarantee
    business continuity. The service registry also has to take note of the failing
    instances so that any client service is given the access details of functioning
    services. The solution mechanism is to have a health check API endpoint for each
    of the services to perform various health check-ups.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查一直是IT行业的重要组成部分。各种软件和硬件系统都在定期进行健康检查。对于微服务也是如此。服务在运行，但有时由于各种原因，它们无法处理服务请求。在这种情况下，服务监控系统必须生成警报并将其实时发送给运维团队进行处理。负载均衡器也理解任何失败的服务实例，并相应地将请求路由到实时服务，以确保业务连续性。服务注册表也必须注意失败实例，以便任何客户端服务都能获得功能服务的访问详情。解决方案机制是为每个服务提供一个健康检查API端点以执行各种健康检查。
- en: Microservices composition patterns
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务组合模式
- en: 'The composition activity is being achieved through two ways: orchestration
    and choreography. The composition task goes beyond service composition. That is,
    process, UI, and data composition is also very much important for service engineering.
    Service mesh is a new buzzword in the industry and there are platforms, practices,
    and patterns for creating service meshes in order to envision hitherto unknown
    service compositions that are business and process-aware.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 组合活动是通过两种方式实现的：编排和协奏。组合任务超出了服务组合的范围。也就是说，流程、UI和数据组合对于服务工程也非常重要。服务网格是行业中的新术语，有平台、实践和模式用于创建服务网格，以设想以前未知且业务和流程感知的服务组合。
- en: Server-side page fragment composition pattern
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端页面片段组合模式
- en: There are customer-facing applications such as B2C e-commerce web applications
    and corporate portals. These are being designed and developed by using multiple
    services (purpose-specific and agnostic). There are proven mechanisms such as
    business capability, technology superiority, cross-cutting concerns, domain-centricity,
    **quality of service** (**QoS**), and so on to partition the original application
    into many microservices or to build microservices from the ground up. One aspect
    here is some UI screens/pages services have to display data from multiple services.
    UI designers sketch the overall look whereas web application developers focus
    on different HTML fragments that implement the particular region of the web page.
    The UI team is responsible for developing the page templates that build pages
    by performing server-side aggregation of the service-specific HTML fragments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有面向客户的软件应用，如B2C电子商务网络应用和公司门户网站。这些应用是通过使用多个服务（专用和非专用）设计和开发的。有经过验证的机制，如业务能力、技术优势、横切关注点、领域中心性、**服务质量**（**QoS**）等，可以将原始应用程序分割成许多微服务，或者从头开始构建微服务。这里的一个方面是一些UI屏幕/页面服务必须显示来自多个服务的数据。UI设计师绘制整体外观，而网络应用开发者专注于实现网页特定区域的HTML片段。UI团队负责开发页面模板，通过在服务器端聚合特定于服务的HTML片段来构建页面。
- en: Client-side UI composition pattern
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端UI组合模式
- en: The challenge, as articulated previously, is to implement a UI screen or page
    that displays data aggregated from multiple services. The web developers construct
    client-side UI components that ultimately implement the region of the web page.
    A UI team is responsible for implementing the page skeletons that build pages/screens
    by composing multiple, service-specific UI components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的挑战是实现一个显示从多个服务聚合数据的UI屏幕或页面。网络开发者构建客户端UI组件，最终实现网页的区域。UI团队负责实现页面骨架，通过组合多个特定于服务的UI组件来构建页面/屏幕。
- en: Messaging-based microservices composition pattern
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于消息的微服务组合模式
- en: Some communication between services is a requirement, even when they're isolated.
    Since applications consist of several microservices, the microservices will need
    to function together as an application in some way. Changes in the state of a
    given service may be of interest to other microservices. Data from one microservice
    may be needed by another microservice. There are many reasons for services to
    communicate. Good architectures manage communications by making the microservice
    API the only entry point for accessing its services.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 即使服务是隔离的，服务之间的某些通信也是必需的。由于应用程序由多个微服务组成，微服务需要以某种方式协同工作作为应用程序的一部分。给定服务的状态变化可能对其他微服务感兴趣。一个微服务的数据可能需要另一个微服务。服务之间通信的原因有很多。好的架构通过使微服务API成为访问其服务的唯一入口点来管理通信。
- en: Microservices APIs can be either synchronous or asynchronous. Synchronous patterns
    can be problematic because of network latencies and intermittent connectivity.
    Hence, asynchronous, non-blocking messaging is on the rise because it lets microservices
    continue processing without waiting for each other. These messages form a basis
    of the loose coupling between microservices. Asynchronous messaging requires a
    small compromise in consistency—it is an eventually consistent model. The loose
    coupling and performance gained, as a result, makes this a good trade-off.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务API可以是同步的或异步的。由于网络延迟和间歇性连接，同步模式可能会出现问题。因此，异步、非阻塞的消息正在兴起，因为它允许微服务在等待彼此之前继续处理。这些消息构成了微服务之间松散耦合的基础。异步消息需要在一致性上做出一些妥协——它是一个最终一致性的模型。因此，获得的松散耦合和性能使得这是一个很好的权衡。
- en: An asynchronous, message-based, event-driven system honors the need for isolation
    between microservices by making the required communications between them non-intrusive.
    Microservices can produce events without needing to be aware of which services
    are consuming these events and how the events are being handled. For microservices
    development teams, an event-driven architecture allows each team to focus on their
    own problem domain.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个异步的、基于消息的事件驱动系统通过使它们之间的必要通信非侵入性，满足了微服务之间隔离的需求。微服务可以产生事件，而无需知道哪些服务正在消费这些事件以及事件是如何被处理的。对于微服务开发团队来说，事件驱动架构允许每个团队专注于自己的问题域。
- en: Microservices generally comprise the full technology stack including the UI,
    the middle-tier application, and the last tier of data persistence. Composition
    patterns are being used in every tier and layer separately based on the business
    needs. An integrated view is one such requirement. Similarly, data stores need
    to be logically integrated in order to retrieve data to give a consolidated view.
    Finally, there are certain situations and scenarios wherein multiple discrete
    and atomic services ought to be integrated and orchestrated to create powerful
    composites. Thus, the involvement of composition patterns is growing great and
    grandeur in shaping up and propping up the era of microservices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常包括完整的科技栈，包括用户界面、中间层应用程序和最后一级数据持久化。根据业务需求，每个层级和层都分别使用组合模式。集成视图是一个这样的需求。同样，数据存储需要逻辑上集成，以便检索数据以提供综合视图。最后，在某些情况和场景中，需要将多个离散和原子服务集成和编排，以创建强大的复合体。因此，组合模式在塑造和支撑微服务时代方面发挥着越来越重要的作用。
- en: Resilient and reliable microservices patterns
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性和可靠的微服务模式
- en: Instead of replicating the application, one or more services, which are the
    part of the application, can be scaled out independently. That is the power of
    microservices. The scalability feature is insisted for tackling extra user and
    data loads. Microservice instances can easily fit into Docker containers. Creating
    additional containers is quite easy and fast and hence, for achieving real-time
    scalability, microservices embedded inside containers are turning out to be the
    appropriate approach. In this section, we are going to discuss the various patterns
    for readying reliable, resilient, elastic, and available microservices-centric
    applications.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与复制整个应用程序不同，应用程序的一部分或多个服务可以独立扩展。这就是微服务的力量。可扩展性功能被强调用于处理额外的用户和数据负载。微服务实例可以轻松地适应Docker容器。创建额外的容器既容易又快，因此，为了实现实时可扩展性，容器内嵌入的微服务正成为适当的方法。在本节中，我们将讨论准备可靠、弹性、可用和以微服务为中心的应用程序的多种模式。
- en: Circuit breaker pattern
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路断路器模式
- en: Microservices-based application design has wrought in a subtle and smart change
    in the way software applications are being designed, deployed, and delivered.
    Applications now become a dynamic collection of services that rely on each other
    to perform various tasks. Highly complicated and sophisticated applications are
    bound to involve a large number of interdependent microservices. More dependencies
    mean more complications and complexities. This pattern acquires prominence because
    it contributes immensely for avoiding cascading service failure. The idea of the
    pattern is to continuously monitor the application's microservices and the traffic
    flowing among them in order to prevent failures. When failures do happen, this
    pattern comes handy in minimizing the impact of those failures on the application.
    This pattern also attempts to prevent failure in the first place. For some types
    of error conditions such as running out of memory, it is possible to recognize
    that failure is imminent and to take appropriate measures to prevent it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的应用程序设计在软件应用程序的设计、部署和交付方式上带来了微妙而智能的改变。现在，应用程序变成了一个动态的服务集合，这些服务相互依赖以执行各种任务。高度复杂和精细的应用程序必然涉及大量相互依赖的微服务。更多的依赖意味着更多的复杂性和复杂性。这种模式之所以突出，是因为它极大地有助于避免级联服务故障。这种模式的理念是持续监控应用程序的微服务和它们之间的流量，以防止故障。当故障发生时，这种模式有助于最小化这些故障对应用程序的影响。这种模式还试图从一开始就防止故障。对于某些类型的错误条件，例如内存耗尽，有可能认识到故障即将发生，并采取适当的措施来预防它。
- en: This is typically accomplished by the service signaling that it is becoming
    unhealthy and the circuit breaker then gives the service a chance to recover by
    throttling back the number of requests or rerouting them completely. Once the
    service gets recovered, the circuit breaker slowly ramps up requests to the service
    so as not to immediately overwhelm it and risk it becoming unhealthy again.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过服务发出它正在变得不健康的信号来实现的，然后断路器给服务一个机会通过减少请求数量或完全重新路由它们来恢复。一旦服务恢复，断路器会缓慢地增加对服务的请求数量，以免立即压倒它并使其再次变得不健康。
- en: For microservices, the circuit breaker pattern guarantees the bottom‑up resilience.
    If this pattern is implemented correctly, it can help in avoiding cascading failures
    by ensuring continuity of service even when services are unavailable. Precisely
    speaking, it is possible to build MSA applications that use this pattern to gracefully
    degrade functionality when a method call fails.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务，断路器模式保证了自下而上的弹性。如果这种模式被正确实现，它可以通过确保即使在服务不可用的情况下服务的连续性来帮助避免级联故障。确切地说，可以构建使用此模式的应用程序来优雅地降低功能，当方法调用失败时。
- en: Shared caching layer pattern
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享缓存层模式
- en: All the instances of any microservice at any point in time have the same data
    requirements, so it makes a lot of sense to have and share a caching layer across
    these instances. This practice is often not followed when each instance has its
    own internal *cache* in its memory for storing session state. This sort of arrangement
    fragments data across different instances that should be treated as a whole. Sharing
    a caching layer eliminates the operational complexity that results from this otherwise
    fragmented data tier, but it places requirements on the shared caching layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时间点，任何微服务的所有实例都有相同的数据需求，因此在这些实例之间拥有和共享一个缓存层是非常有意义的。当每个实例在其内存中都有自己的内部*缓存*来存储会话状态时，这种做法通常不会被遵循。这种安排将数据分散到不同的实例中，而这些实例应该被视为一个整体。共享缓存层消除了由这种其他情况下分散的数据层产生的运营复杂性，但它对共享缓存层提出了要求。
- en: The application layer has a single view of user data and it is accessible through
    any instance. When using a shared cache, updates to data are available to all
    microservice instances. If the data layer is not shared, then each service would
    have a myopic view of the data and the architecture would have to be set up so
    that any given user is always routed to the same instance. Thus, having a shared
    caching layer gives an integrated and uniform view of data. A shared caching layer
    provides an isolation layer to the backing store(s). Changes to the backing store
    can be done in just one place, and these changes benefit all the microservice
    instances.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层对用户数据有一个统一的视图，并且可以通过任何实例访问。当使用共享缓存时，数据的更新对所有微服务实例都是可用的。如果数据层不是共享的，那么每个服务都会对数据有一个狭隘的视角，并且架构必须设置得使得任何给定的用户总是被路由到同一个实例。因此，拥有一个共享缓存层提供了对数据的一个集成和统一的视图。共享缓存层为后端存储提供了隔离层。对后端存储的更改只需在一个地方进行，并且这些更改将惠及所有微服务实例。
- en: As indicated previously, adding additional instances instantaneously gives cloud-native
    applications an effective and efficient way of scaling the application logic and
    improving performance. For the overall system to benefit from this, the data layer
    also has to get this capability. The application performance and scalability can
    be significantly eroded if the data layer is a bottleneck. The introduction of
    a shared cache and its real-time scalability comes in handy in ensuring the application
    performance. The data latency is very low also. The scalability of the cache layer
    can be achieved through data distribution and replication.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，添加额外的实例立即为云原生应用程序提供了一种有效且高效的方式来扩展应用程序逻辑并提高性能。为了使整个系统从中受益，数据层也必须具备这种能力。如果数据层成为瓶颈，应用程序的性能和可扩展性可能会受到严重影响。引入共享缓存及其实时可扩展性对于确保应用程序性能非常有用。数据延迟也非常低。缓存层的可扩展性可以通过数据分布和复制来实现。
- en: High availability microservices pattern
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可用性微服务模式
- en: Scaling out microservices by adding their instances ensures the service availability
    and resilience. If a microservice instance goes down, then another instance of
    the same microservice can simply come forward to replace the failed one so that
    the business continuity is being ensured through such kinds of technological solutions.
    Microservices instances can be added or removed at will depending on the evolving
    capacity needs. By running every instance in a different container/virtual machine/bare
    metal server, an added degree of availability can be assured. Fault tolerance
    is another attribute in the cloud era and this is accomplished simply by running
    each instance on a different server within the cloud center or on a geographically
    distributed cloud server. The shared data cache should provide a similar degree
    of fault tolerance from server failures or site outages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加微服务的实例来扩展其规模，确保了服务的可用性和弹性。如果一个微服务实例出现故障，那么同一微服务的另一个实例可以简单地站出来替换失败的实例，从而通过这类技术解决方案确保业务连续性。根据不断变化的容量需求，可以随意添加或删除微服务实例。通过在每个不同的容器/虚拟机/裸机服务器上运行每个实例，可以确保更高的可用性。容错性是云时代另一个属性，这可以通过在云中心内的不同服务器或地理上分布的云服务器上运行每个实例来实现。共享数据缓存应该提供类似的容错性，以应对服务器故障或站点中断。
- en: High availability and fault-tolerance requirements are essential for services
    to be beneficial for enterprise-grade business applications. Microservices in
    association with Docker containers can fulfil the need for horizontal scalability
    by automatically adding additional instances of microservices in the case of an
    emergency and urgency. That is, the formation of service clusters and meshes is
    the key differentiator for the digital world. Google tinkers with millions of
    containers every day in order to keep up its business obligations to the consumers,
    customers, and clients. Server failures are proactively identified and resolved
    in order to ensure the business continuity. Reliability and resilience of microservices
    go a long way in their adoption and adaption.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 高可用性和容错性要求对于服务有益于企业级业务应用至关重要。与Docker容器结合的微服务可以通过在紧急和紧迫的情况下自动添加微服务的额外实例来满足水平扩展的需求。也就是说，服务集群和网格的形成是数字世界的关键区别。谷歌每天调整数百万个容器，以保持其对消费者、客户和客户的业务承诺。服务器故障被积极识别和解决，以确保业务连续性。微服务的可靠性和弹性在其采用和适应中起着重要作用。
- en: If a server running a microservice fails, the system automatically re-routes
    work to an alternate instance of the microservice, spins up a new instance to
    restore capacity, and provides access to the same data from the new instance.
    This recovery scenario has several implications for how the data layer is set
    up for accommodating various types of failures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行微服务的服务器出现故障，系统会自动将工作重定向到微服务的备用实例，启动一个新的实例以恢复容量，并从新实例提供相同的数据访问。这种恢复场景对如何为适应各种类型的故障设置数据层有多个影响。
- en: Concurrent requests for data pattern
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模式并发请求
- en: Running multiple application instances will have a solid impact on the shared
    caching layer because there will be a rise in the number of concurrent requests
    to avail data. Therefore, the shared caching layer also needs to be strengthened
    by adding instances on a need basis. That is, the cache layer also has to have
    the elasticity capability to meet the additional requests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行多个应用程序实例将对共享缓存层产生重大影响，因为将会有更多并发请求来获取数据。因此，根据需要添加实例来加强共享缓存层也是必要的。也就是说，缓存层也必须具备弹性能力，以满足额外的请求。
- en: Event store pattern
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件存储模式
- en: A key component of the solution is an event store. The event store system is
    immutable, sequential, and serves as the destination for the event streams from
    each service. Consumers of these events can then subscribe to and read the events
    of interest. The event store essentially serves as an event source for each consumer.
    Consumers maintain their own logic related to the filters that will be applied
    to determine whether an event is of interest. Each consumer also maintains their
    own pointer/offset into the event store to serially process the events.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的关键组件是一个事件存储库。事件存储系统是不可变的、顺序的，并且是每个服务事件流的目的地。这些事件的消费者可以订阅并读取感兴趣的事件。事件存储本质上为每个消费者提供了事件源。消费者维护自己的逻辑，以确定事件是否感兴趣。每个消费者还维护自己的指针/偏移量，以顺序处理事件存储库中的事件。
- en: Events can be generated either from the application layer or directly from the
    data layer. Generating events from the application layer provides visibility into
    and control over the flow of events, but this comes at the cost of having to manage
    and maintain the flow of events across all the producers and consumers. Having
    the events emanating from the data layer frees the application layer, and developers,
    from having to essentially build major pieces of an event-driven system within
    the application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以从应用层或直接从数据层生成。从应用层生成事件可以提供对事件流的可见性和控制，但这也意味着必须管理和维护所有生产者和消费者之间的事件流。如果事件来自数据层，则可以解放应用层和开发者，使他们不必在应用中构建事件驱动系统的关键部分。
- en: Event streams and the unified event log pattern
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件流和统一事件日志模式
- en: A unified event log is the collection point/storehouse for all events (state
    changes, threshold break-ins or any noteworthy deviations, deficiencies, disturbances,
    and so on) that occurred in any participating microservice. Each participating
    service can also opt to retain a local log of its own state changes. However,
    collecting and stocking all kinds of event logs in a single and unified event
    store is capable of opening up a host of fresh possibilities and opportunities.
    The complete and 360-degree view of all the events presented in the unified event
    log can be used to play back selected events and create a projection of the information
    in any way desired. A variety of data analytics can be done on the event data
    in real time in order to extract actionable insights. The microservices' performance/throughput,
    scalability, availability, auditability, security, operational status, and so
    on can be easily deduced from the event store. The predictive and preventive maintenance
    of microservices can also be achieved through such a centralized and consolidated
    event log data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 统一事件日志是所有参与微服务中发生的所有事件（状态变化、阈值突破或任何值得注意的偏差、不足、干扰等）的收集点/仓库。每个参与服务也可以选择保留其自身状态变化的本地日志。然而，将所有类型的事件日志收集和存储在单个统一的事件存储库中，可以开辟一系列新的可能性和机会。统一事件日志中呈现的所有事件的完整和360度视图可以用于回放选定的事件，并以任何期望的方式创建信息投影。可以在实时事件数据上执行各种数据分析，以提取可操作的见解。可以从事件存储库中轻松推断出微服务的性能/吞吐量、可扩展性、可用性、可审计性、安全性、运营状态等。通过这种集中和整合的事件日志数据，还可以实现微服务的预测性和预防性维护。
- en: A unified log can have demanding requirements for performance and scalability
    given a large number of microservices that can potentially source event streams.
    Apache Kafka's design for speed, scale, durability, and massive concurrency, together
    with its model allowing only immutable records to be written to it, makes it an
    increasingly popular choice as a unified log. Kafka maintains message feeds in
    distributed and replicated partitions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量可能提供事件流的微服务存在的情况下，一个统一的日志可能对性能和可扩展性有较高的要求。Apache Kafka的设计旨在追求速度、可扩展性、持久性和大规模并发，加上其只允许写入不可变记录的模式，使其成为统一日志的越来越受欢迎的选择。Kafka通过分布式和复制的分区来维护消息流。
- en: Due to the continuous explosion of multifaceted, networked, and embedded devices,
    the number of events getting generated and captured is growing rapidly. The need
    is undoubted to have a highly scalable messaging platform that is able to receive
    a very high number of events emanating from different and distributed sources.
    We all know that the Apache Kafka messaging platform has the inherent ability
    to receive millions of events per second. The events are then partitioned so that
    both batch and real-time processing requirements can be met. Since service architecture
    patterns call for smart endpoints and dumb pipes, Kafka will do just enough for
    most application and system integration use cases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多方面、网络化和嵌入式设备的持续爆炸性增长，生成和捕获的事件数量正在迅速增加。无疑需要有一个高度可扩展的消息平台，能够接收来自不同和分布式源的大量事件。我们都知道，Apache
    Kafka消息平台具有接收每秒数百万事件的内禀能力。然后，事件被分区，以满足批处理和实时处理的需求。由于服务架构模式要求智能端点和愚笨管道，Kafka将满足大多数应用程序和系统集成用例的需求。
- en: Asynchronous command calls pattern
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步命令调用模式
- en: Composing services' atomic calls into complex flows often require proper orchestration
    over asynchronous actions. These are usually local integration use cases, connecting
    related microservices that must exchange messages with a delivery guarantee. The
    messaging layer in this use case has substantially different needs from an event
    firehose since its messages are point-to-point (queues instead of topics). This
    usually requires a delivery guarantee and most are short-lived (albeit still asynchronous)
    and conversational. It's a traditional broker-centric use case, reliably connecting
    endpoints through asynchronous communication. The communication flows through
    atomic messages exchanged between parties, instead of a constant stream of events
    potentially handled by multiple processes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务原子调用组合成复杂流程通常需要对异步操作进行适当的编排。这些通常是本地集成用例，连接必须交换消息并保证交付的关联微服务。在这个用例中，消息层的需求与事件流火管有显著不同，因为其消息是点对点的（队列而不是主题）。这通常需要保证交付，尽管仍然是异步的，并且是会话式的。这是一个传统的以代理为中心的用例，通过异步通信可靠地连接端点。通信流程通过各方之间交换的原子消息进行，而不是由多个进程处理的事件的持续流。
- en: 'In summary, the highly distributed nature of microservices-based applications
    introduces several lingering questions about how the data layer should be handled.
    Microservices facilitate complete isolation and autonomy. The dependency-related
    issues simply disappear here. But how multiple microservices can be found, connected,
    and aggregated to produce composite services is a challenge in a truly distributed
    environment. The performance and security queries pop up in a distributed environment,
    leveraging powerful and pioneering design practices, patterns, and processes to
    produce next-generation modernized applications. An in-memory caching layer brings
    fast response times for both read and write access to data needs:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，基于微服务的应用的高度分布式特性引发了对如何处理数据层的几个悬而未决的问题。微服务促进了完全隔离和自主性。依赖相关的问题在这里简单地消失了。但在真正分布式环境中，如何找到、连接和聚合多个微服务以产生复合服务是一个挑战。在分布式环境中，性能和安全问题浮现出来，利用强大的和开创性的设计实践、模式和流程来产生下一代现代化应用。内存缓存层为读取和写入数据需求提供快速响应时间：
- en: Asynchronous updates and event-driven architecture protect the autonomy between
    teams and allow for high-velocity software development
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步更新和事件驱动架构保护团队之间的自主性，并允许高速软件开发
- en: The elasticity and scalability of a service's architecture are inextricably
    tied to the elasticity and scalability of the data layer
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的架构弹性和可扩展性与数据层的弹性和可扩展性密不可分
- en: Legacy systems can be modernized and carried forward into the world of microservices
    with the help of a caching isolation layer
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缓存隔离层，可以将遗留系统现代化并带入微服务世界
- en: This is the age of digital transformation. Everything in and around us is systematically
    getting digitized to enable every kind of physical, mechanical, electrical, and
    electronic system to join in the mainstream computing. The digital economy and
    era are staring at us. We need competent information technologies, agile development
    platforms, practices, and patterns. Microservices architecture (MSA) is an offshoot
    of the fully matured and stabilized SOA paradigm and is emerging as the way forward
    for developing, deploying, and delivering digital services and applications. This
    chapter is specially crafted and drafted for discussing the prominent and dominant
    patterns for risk-free adoption and acceleration of the promising MSA paradigm.
    Patterns are recognized as one indispensable ingredient for any paradigm to be
    conveniently and confidently used. Readers will be trustfully inspired to formulate
    fresh patterns to make MSA penetrative, participative, and pervasive.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们数字转型的时代。我们周围的一切都在系统地数字化，以使各种物理、机械、电气和电子系统能够加入主流计算。数字经济和时代正迎面而来。我们需要有竞争力的信息技术、敏捷的开发平台、实践和模式。微服务架构（MSA）是成熟稳定的服务导向架构（SOA）范式的衍生品，正成为开发、部署和交付数字服务和应用程序的前进方向。本章专门编写和制定，旨在讨论风险无忧采用和加速有前景的MSA范式的突出和主导模式。模式被认为是任何范式方便和自信使用的一个不可或缺的组成部分。读者将受到启发，制定新的模式，使MSA具有渗透力、参与性和普遍性。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got a brief about microservice architecture patterns and
    we also learned about the uniqueness of the fast emerging and evolving MSA and
    the associated architectural patterns. We also covered the architectural and design
    patterns being associated with the raging MSA.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了微服务架构模式，并学习了快速涌现和演变的微服务架构（MSA）的独特性以及相关的架构模式。我们还涵盖了与狂热发展的MSA相关的架构和设计模式。
- en: 'Bibliography and additional resources for this chapter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的参考文献和额外资源：
- en: '[http://microservices.io/patterns/microservices.html</a&gt;](http://microservices.io/patterns/microservices.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)'
- en: '[https://dzone.com/articles/microservice-design-patterns](https://dzone.com/articles/microservice-design-patterns)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dzone.com/articles/microservice-design-patterns](https://dzone.com/articles/microservice-design-patterns)'
- en: '[https://azure.microsoft.com/en-us/blog/design-patterns-for-microservices/](https://azure.microsoft.com/en-us/blog/design-patterns-for-microservices/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-us/blog/design-patterns-for-microservices/](https://azure.microsoft.com/en-us/blog/design-patterns-for-microservices/)'
- en: '[https://www.sumologic.com/blog/devops/top-patterns-building-successful-microservices-architecture/](https://www.sumologic.com/blog/devops/top-patterns-building-successful-microservices-architecture/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.sumologic.com/blog/devops/top-patterns-building-successful-microservices-architecture/](https://www.sumologic.com/blog/devops/top-patterns-building-successful-microservices-architecture/)'
- en: '[https://mapr.com/blog/event-driven-microservices-patterns/](https://mapr.com/blog/event-driven-microservices-patterns/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mapr.com/blog/event-driven-microservices-patterns/](https://mapr.com/blog/event-driven-microservices-patterns/)'
- en: '[https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices](https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices](https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices)'
- en: '[http://soapatterns.org/design_patterns/microservice_deployment](http://soapatterns.org/design_patterns/microservice_deployment)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://soapatterns.org/design_patterns/microservice_deployment](http://soapatterns.org/design_patterns/microservice_deployment)'
- en: '[http://blog.christianposta.com/](http://blog.christianposta.com/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://blog.christianposta.com/](http://blog.christianposta.com/)'
- en: '[https://blogs.oracle.com/developers/getting-started-with-microservices-part-three](https://blogs.oracle.com/developers/getting-started-with-microservices-part-three)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.oracle.com/developers/getting-started-with-microservices-part-three](https://blogs.oracle.com/developers/getting-started-with-microservices-part-three)'
