- en: Chapter 5. Rendering Simple 3D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 渲染简单的3D图形
- en: Now that we've covered user input, 2D graphics, and sound, let's take a look
    at 3D graphics. Most games these days are 3D, probably because 3D graphics are
    cooler than 2D graphics! That's not to say that 2D graphics are bad or outdated.
    There are still many games made using 2D graphics, but creating a game in 3D literally
    adds another dimension to the game, giving the world that much more depth and
    making it more interesting to explore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了用户输入、2D图形和声音，让我们来看看3D图形。如今的大多数游戏都是3D的，可能是因为3D图形比2D图形更酷！这并不是说2D图形不好或过时。仍然有许多使用2D图形制作的游戏，但在3D中创建游戏实际上为游戏增加了另一个维度，使世界更具深度，使其更具探索性。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Direct3D graphics rendering pipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Direct3D图形渲染管线
- en: Shaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器
- en: Rendering a triangle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染三角形
- en: Rendering a cube with texturing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带纹理的立方体渲染
- en: The Direct3D graphics rendering pipeline
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Direct3D图形渲染管线
- en: 'The Direct3D graphics rendering pipeline takes our geometry data and turns
    it into graphics on the screen. It is designed to generate graphics for real-time
    applications such as video games. The pipeline consists of a number of stages
    that our data goes through to produce the finished image for the current frame.
    Some of these stages are programmable, giving us a lot more power. Let''s take
    a look at the main pipeline stages, which are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Direct3D图形渲染管线将我们的几何数据转换为屏幕上的图形。它旨在为实时应用程序（如视频游戏）生成图形。该管线由多个阶段组成，我们的数据通过这些阶段生成当前帧的最终图像。其中一些阶段是可编程的，这为我们提供了更多的功能。让我们看看主要的管线阶段，它们是：
- en: Input assembler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入汇编器
- en: Vertex shader
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: Rasterizer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光栅化器
- en: Pixel shader
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素着色器
- en: Output merger
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出合并
- en: Input assembler
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入汇编器
- en: The main purpose of the **input assembler** is to take our raw vertex data (points,
    lines, or triangles), and assemble them into primitives, such as `PrimitiveType.TriangleList`,
    which can be used by the graphics rendering pipeline. This primitive type tells
    Direct3D that our vertex data is arranged so that every three vertices in the
    list make a single triangle. All of the primitive types supported by Direct3D
    are defined in the `PrimitiveType` enumeration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入汇编器**的主要目的是将我们的原始顶点数据（点、线或三角形）组装成原语，例如`PrimitiveType.TriangleList`，这些原语可以被图形渲染管线使用。这种原语类型告诉Direct3D我们的顶点数据是按照列表中的每个三个顶点构成一个三角形的顺序排列的。Direct3D支持的所有原语类型都在`PrimitiveType`枚举中定义。'
- en: Vertex shader
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The **vertex shader** stage performs per-vertex operations on vertex data outputted
    from the input assembler stage. These operations are things such as transformations,
    per-vertex lighting, morphing, and skinning.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点着色器**阶段对从输入汇编器阶段输出的顶点数据进行逐顶点操作。这些操作包括变换、逐顶点光照、变形和蒙皮。'
- en: Rasterizer
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光栅化器
- en: The **rasterizer** stage takes the primitives processed in the previous stages
    and turns them into pixels to make a rendered image. It also performs the clipping
    of vertices, which means that if part of a triangle is off the screen, it will
    clip that part of the triangle off, so to speak, since it doesn't need to be drawn.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**光栅化器**阶段将之前阶段处理过的原语转换为像素，以生成渲染图像。它还执行顶点裁剪，这意味着如果三角形的一部分在屏幕外，它将裁剪掉这部分三角形，换句话说，因为它不需要被绘制。'
- en: Pixel shader
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素着色器
- en: The **pixel shader** stage of the graphics pipeline performs shading techniques,
    such as per-pixel lighting or post-processing stuff. The rasterizer invokes the
    pixel shader stage once for each pixel, which is covered by the current primitive
    that it is processing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线中的**像素着色器**阶段执行着色技术，例如逐像素光照或后期处理内容。光栅化器为它正在处理的当前原语中的每个像素调用像素着色器阶段。
- en: Output merger
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出合并
- en: The **output merger** generates the final pixel color using a combination of
    numerous things, including the current state of the graphics pipeline, the data
    generated by the pixel shader stage, and the contents of render targets, and depth/stencil
    buffers, which we'll get into a bit later in the chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出合并器**通过结合众多因素生成最终的像素颜色，包括图形管线的当前状态、像素着色器阶段生成的数据以及渲染目标的内容，以及稍后在本章中将要讨论的深度/模板缓冲区。'
- en: 'This was a pretty quick overview of the Direct3D graphics pipeline. There are
    other stages in the pipeline besides these, but we will not be using them. For
    a more in-depth look at the graphics pipeline, check out Microsoft''s documentation:
    [http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个对Direct3D图形管道的简要概述。除了这些阶段之外，管道中还有其他阶段，但我们不会使用它们。要深入了解图形管道，请查看微软的文档：[http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx)。
- en: Shaders
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: 'As you can see above, **shaders** are a fairly integral part of 3D graphics
    programming. So what exactly is a shader? A shader is a small program that we
    write for one of the programmable stages of the Direct3D graphics pipeline. Two
    of the stages we previously looked at are programmable: the vertex shader stage
    and the pixel shader stage. These are not the only programmable stages in the
    graphics pipeline though.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，**着色器**是3D图形编程的一个相当重要的部分。那么，着色器究竟是什么呢？着色器是我们为Direct3D图形管道的可编程阶段编写的小程序。我们之前查看的两个阶段是可编程的：顶点着色器阶段和像素着色器阶段。然而，图形管道中并不仅限于这些可编程阶段。
- en: Shaders have what is known as a **shader signature**. The signature of a shader
    is just a list of the input and/or output parameters of that shader.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器有一个被称为**着色器签名**的东西。着色器的签名只是该着色器的输入和/或输出参数的列表。
- en: In this chapter we will create two demos. Each will have its own shader file,
    named `Effects.fx`. This is just a text file containing the code for our shaders.
    Shaders are written in **HLSL** (**High Level Shader Language**). The downloadable
    code for this chapter includes the `Effects.fx` files for both demo projects (they
    are *NOT* the same).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建两个演示。每个演示都将有自己的着色器文件，命名为`Effects.fx`。这是一个包含我们着色器代码的文本文件。着色器是用**HLSL**（**高级着色器语言**）编写的。本章的可下载代码包括两个演示项目的`Effects.fx`文件（它们**不相同**）。
- en: For more information on shaders and HLSL, check out the HLSL programming guide
    on Microsoft's website at [http://msdn.microsoft.com/en-us/library/windows/desktop/bb509635(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/bb509635(v=vs.85).aspx).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于着色器和HLSL的信息，请查看微软网站上的HLSL编程指南：[http://msdn.microsoft.com/en-us/library/windows/desktop/bb509635(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/bb509635(v=vs.85).aspx)。
- en: Rendering a triangle
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染三角形
- en: In this section we will set up a basic Direct3D application and render a simple
    triangle on the screen. We will start by creating a new project called `Triangle`.
    In this project, we will first create a new class named `TriangleGameWindow.cs`.
    We will need to make it inherit from our `GameWindow` base class and implement
    `IDisposable`, of course.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置一个基本的Direct3D应用程序，并在屏幕上渲染一个简单的三角形。我们首先将创建一个名为`Triangle`的新项目。在这个项目中，我们首先将创建一个名为`TriangleGameWindow.cs`的新类。我们需要让它继承我们的`GameWindow`基类并实现`IDisposable`，当然。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to get the downloadable code for this book to complete this chapter,
    particularly for the second demo we will create in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要获取本书的可下载代码来完成本章，特别是我们将在本章中创建的第二个演示。
- en: 'Now that we have a new game window class, the next item of business is to get
    Direct3D set up and ready to go. We will need to add some `using` statements to
    the top of the file first though. These allow us to use Direct3D in our code.
    The following are the new statements that we need:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新的游戏窗口类，下一步要做的就是将Direct3D设置好并准备好。我们首先需要在文件顶部添加一些`using`语句。这些语句允许我们在代码中使用Direct3D。以下是我们需要的新语句：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to create our member variables. They are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的成员变量。它们如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `m_Device` variable will hold our Direct3D device object. The `m_DeviceContext`
    variable is just a convenience variable that holds the device context for us.
    This shortens some lines of code since we don't have to access it through `m_Device`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_Device`变量将保存我们的Direct3D设备对象。`m_DeviceContext`变量只是一个方便的变量，它为我们保存设备上下文。这缩短了一些代码行，因为我们不需要通过`m_Device`来访问它。'
- en: The `m_RenderTargetView` variable will hold our `RenderTargetView` object, which
    is similar to the `RenderTarget` object we worked with in [Chapter 3](ch03.html
    "Chapter 3. Rendering 2D Graphics"), *Rendering 2D Graphics*. This is basically
    our Direct3D render target.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_RenderTargetView`变量将保存我们的`RenderTargetView`对象，这与我们在[第3章](ch03.html "第3章。渲染2D图形")中使用的`RenderTarget`对象类似，*渲染2D图形*。这基本上是我们的Direct3D渲染目标。'
- en: The `m_SwapChain` variable will hold our **swap chain**. The swap chain is just
    a chain of buffers. Remember that a buffer is just an area in memory for storing
    data. The simplest swap chain would have two buffers, which hold the graphics
    that our program is drawing. Each time we draw a new frame, the buffers get swapped,
    so the buffer containing our new frame becomes visible on the screen. The buffer
    we draw into is called the **back buffer** because it is behind the scenes, so
    the player cannot see it while we are drawing the next frame. The buffer that
    is currently displayed on the screen is called the **front buffer**. When the
    buffers get swapped, the back buffer becomes the new front buffer and vice versa.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_SwapChain`变量将保存我们的**交换链**。交换链只是一系列缓冲区。记住，缓冲区只是内存中用于存储数据的一个区域。最简单的交换链将有两个缓冲区，它们保存着程序绘制的图形。每次我们绘制一个新帧时，缓冲区就会交换，因此包含我们新帧的缓冲区就会在屏幕上可见。我们绘制到的缓冲区被称为**后缓冲区**，因为它在幕后，所以当我们在绘制下一个帧时，玩家看不到它。当前显示在屏幕上的缓冲区被称为**前缓冲区**。当缓冲区交换时，后缓冲区成为新的前缓冲区，反之亦然。'
- en: At first, this may seem like a waste of memory. Why not just draw into the buffer
    that is currently displayed onscreen so we can have one buffer rather than two?
    The reason is that doing so can cause some flickering. This is because the player
    could see things appear on the screen as they are being drawn. So instead, we
    draw into an offscreen buffer until the frame is fully drawn. Then, we swap the
    buffers so that the new frame appears on the screen all at once. This makes for
    smoother animation. This rendering technique is called **double buffering** .
    You can add more buffers in between the back buffer and the front buffer as well.
    If you add one additional buffer in between them, you will be doing **triple buffering**,
    which actually provides speed improvement over double buffering.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能会感觉像是一种内存浪费。为什么不直接绘制到当前显示在屏幕上的缓冲区，这样我们就可以有一个缓冲区而不是两个？这样做的原因是，这样可能会引起一些闪烁。这是因为玩家可能会看到东西在屏幕上被绘制出来。所以，我们而是在离屏缓冲区中绘制，直到帧完全绘制完成。然后，我们交换缓冲区，使新帧一次性出现在屏幕上。这使得动画更加平滑。这种渲染技术被称为**双缓冲**。你还可以在后台缓冲区和前台缓冲区之间添加更多的缓冲区。如果你在它们之间添加一个额外的缓冲区，你将进行**三缓冲**，这实际上比双缓冲提供了速度提升。
- en: Back to our member variables; the next one is `m_Viewport`. The view port simply
    specifies the area of the render target that we want to draw on. It also specifies
    the minimum and maximum depth values. These are normally set to `0.0f` and `1.0f`
    respectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的成员变量；下一个是`m_Viewport`。视口简单地指定了我们想要绘制在渲染目标上的区域。它还指定了最小和最大深度值。这些通常设置为`0.0f`和`1.0f`。
- en: The next member variable is `m_InputLayout`. The `InputLayout` object tells
    Direct3D about the vertex format and shader model we are using. Remember that,
    a shader is basically just a small program that is run by the video card.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个成员变量是`m_InputLayout`。`InputLayout`对象告诉Direct3D我们正在使用的顶点格式和着色器模型。记住，着色器基本上只是一个由显卡运行的小程序。
- en: The `m_VertexShader` variable will hold our vertex shader. The `m_VShaderSignature`
    variable holds the signature for the vertex shader. A shader signature is just
    a list of parameters that are inputted to or outputted from the shader. And lastly,
    `m_PixelShader` will hold our pixel shader. We'll get into shaders a bit later
    in the chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_VertexShader`变量将保存我们的顶点着色器。`m_VShaderSignature`变量保存顶点着色器的签名。着色器签名只是一个参数列表，这些参数被输入到或从着色器输出。最后，`m_PixelShader`将保存我们的像素着色器。我们将在本章稍后讨论着色器。'
- en: If you don't fully understand all of these member variables, that's fine. They
    should become a little clearer once we start using them. We need to initialize
    Direct3D now, so let's get started.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解所有这些成员变量，那没关系。一旦我们开始使用它们，它们应该会变得稍微清晰一些。我们现在需要初始化Direct3D，所以让我们开始吧。
- en: Initializing Direct3D
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化Direct3D
- en: 'We are now ready to initialize Direct3D. For this task, we will create a new
    method named `InitD3D()`. The following is the code for this method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备初始化Direct3D。为此任务，我们将创建一个新的方法，命名为`InitD3D()`。以下是这个方法的代码：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the first thing we do in this method is create `SwapChainDescription`
    to configure the swap chain we will create in a moment. We are using the initializer
    syntax here, which is a handy way for us to set the values of the struct's properties
    when it is created. You can use the initializer syntax for structs, arrays, and
    lists by opening a brace block after the line that creates the new object, and
    then setting the values of its properties inside the brace block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这个方法中我们首先做的事情是创建 `SwapChainDescription` 来配置我们即将创建的交换链。我们在这里使用初始化器语法，这是一种方便的方式，让我们在创建结构体时设置其属性的值。你可以通过在创建新对象的行之后打开花括号块，并在花括号块内设置其属性的值来使用结构体、数组和列表的初始化器语法。
- en: The `BufferCount` property specifies how many buffers we want to have in our
    swap chain, in addition to the front buffer. You should not use more than four
    buffers as you will get a performance decrease with too many. In the windowed
    mode, the desktop is used as the front buffer, but in the fullscreen mode, a dedicated
    front buffer is required in the swap chain. The `Usage` property specifies how
    we intend to use our swap chain surfaces. The term **surface** refers to a buffer
    that we will draw on, so the surfaces of our swap chain are just the buffers that
    are in it. For the `OutputHandle` property, we set this to the handle of our game
    window to tell it what window we will be displaying our graphics in. The `IsWindowed`
    property determines whether we want to start the program in windowed mode. Remember
    that we haven't implemented fullscreen mode yet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferCount` 属性指定了我们希望在交换链中拥有的缓冲区数量，除了前缓冲区。你不应该使用超过四个缓冲区，因为过多的缓冲区会导致性能下降。在窗口模式下，桌面被用作前缓冲区，但在全屏模式下，交换链中需要一个专用的前缓冲区。`Usage`
    属性指定了我们打算如何使用我们的交换链表面。术语 **surface** 指的是我们将要绘制的缓冲区，因此交换链的表面只是其中的缓冲区。对于 `OutputHandle`
    属性，我们将它设置为游戏窗口的句柄，以告诉它我们将要在哪个窗口中显示我们的图形。`IsWindowed` 属性确定我们是否希望以窗口模式启动程序。请记住，我们还没有实现全屏模式。'
- en: Next, we have the `ModeDescription` property, which specifies the video mode
    we want to use. The first two parameters of the `ModeDescription` object are the
    height and width. In other words, they are the screen resolution we want to use.
    The third parameter is the refresh rate specified as a numerator and a denominator.
    Here, we have it set to the fraction *60/1*, which means a refresh rate of 60
    times per second. And lastly, we have the format parameter. This tells it the
    pixel format, and as you can see, we have it set to `Format.R8G8B8A8_UNorm`. This
    means we have eight bits for each of the four color channels (red, green, blue,
    and alpha). The `UNorm` part of this format name indicates that the values of
    the color channels are unsigned, normalized integers (normalized meaning they
    are in the range `0.0`-`1.0`). An **unsigned integer** is similar to a normal
    `integer` variable, except that it does not support negative numbers. This allows
    an unsigned integer to hold much larger values than you can store in a normal
    integer variable of the same size. The opposite of an unsigned integer is a **signed
    integer** variable, which has to use half of its possible values to represent
    negative numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `ModeDescription` 属性，它指定了我们想要使用的视频模式。`ModeDescription` 对象的前两个参数是高度和宽度。换句话说，它们是我们想要使用的屏幕分辨率。第三个参数是一个分数，表示刷新率，这里我们将其设置为
    *60/1*，这意味着每秒刷新60次。最后，我们有格式参数。这告诉它像素格式，正如你所见，我们将其设置为 `Format.R8G8B8A8_UNorm`。这意味着我们为每个四个颜色通道（红色、绿色、蓝色和alpha）分配了8位。格式名称中的
    `UNorm` 部分表示颜色通道的值是无符号、归一化的整数（归一化意味着它们在 `0.0`-`1.0` 范围内）。一个 **无符号整数** 类似于一个正常的
    `integer` 变量，但它不支持负数。这使得无符号整数可以存储比相同大小的正常整数变量更大的值。无符号整数的对立面是 **有符号整数** 变量，它必须使用其可能值的一半来表示负数。
- en: 'The next property we set on the `SwapChainDescription` object is the `SampleDescription`
    property. For this, we create a new sample description object and give it two
    parameters: the first parameter is the number of multisamples per pixel, and the
    second parameter is the quality level. The valid range for the quality level is
    `0` to one less than the level returned by the `CheckMultisampleQualityLevel()`
    method of the Direct3D device object (remember that the device is stored in our
    `m_Device` member variable). Of course, higher quality levels are more expensive
    to perform than lower ones. Here, we set the count to `1` and quality to `0`.
    This is the default sampler state with no anti-aliasing. Note that there are also
    a couple of standard values we can use to set our multisampling level, and they
    are defined in the `Direct3D11.StandardMultisamplQualityLevel` enumeration.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SwapChainDescription`对象上设置的下一个属性是`SampleDescription`属性。为此，我们创建一个新的采样描述对象，并给它两个参数：第一个参数是每像素的多采样次数，第二个参数是质量级别。质量级别的有效范围是`0`到Direct3D设备对象的`CheckMultisampleQualityLevel()`方法返回的级别减一（记住设备存储在我们的`m_Device`成员变量中）。当然，质量级别越高，执行成本越高。在这里，我们将计数设置为`1`，质量设置为`0`。这是没有抗锯齿的默认采样器状态。请注意，我们还可以使用一些标准值来设置我们的多采样级别，这些值定义在`Direct3D11.StandardMultisamplQualityLevel`枚举中。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your PC is not able to use Direct3D 11, you can change the code in this chapter
    to use Direct3D 10 instead. The code should be nearly identical, since Direct3D
    11 is in reality an extension of Direct3D 10, and we are not using any advanced
    features or new stuff that Direct3D 11 brings to the table. Just make sure you
    change all objects from the Direct3D 11 namespace to their counterparts in the
    Direct3D 10 namespace.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的PC无法使用Direct3D 11，你可以将本章中的代码更改为使用Direct3D 10。代码应该几乎相同，因为Direct3D 11实际上是Direct3D
    10的扩展，我们没有使用Direct3D 11带来的任何高级功能或新特性。只需确保将所有Direct3D 11命名空间的对象更改为Direct3D 10命名空间中的对应对象。
- en: You may notice that there is also Direct3D 11.1\. We are not using this because
    it is the Windows 8 version of Direct3D 11, and you can only use it on Windows
    8.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，也存在Direct3D 11.1。我们不使用它，因为它只是Windows 8版本的Direct3D 11，并且你只能在Windows 8上使用它。
- en: 'So what is **multisampling** and **anti-aliasing**? Anti-aliasing is actually
    an effect of multisampling, where the jagged edges of objects are smoothed, so
    they don''t look jagged on the screen anymore. This jaggedness is caused by the
    fact that the pixels on the screen are not infinitely small, and thus you can
    sometimes see a stair-step pattern on the edges of objects on the screen. Multisampling
    involves looking at the colors of adjacent pixels and blending them together in
    some fashion so as to soften edges on the screen and remove other graphical artifacts
    that can be caused by aliasing, such as moiré patterns. You can look up for moiré
    patterns on Wikipedia: [http://en.wikipedia.org/wiki/Moir%C3%A9_pattern](http://en.wikipedia.org/wiki/Moir%C3%A9_pattern).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是**多采样**和**抗锯齿**呢？抗锯齿实际上是多采样的一种效果，它通过平滑物体的锯齿边缘，使得它们在屏幕上不再显得锯齿状。这种锯齿状是由屏幕上的像素不是无限小的事实造成的，因此你有时会在屏幕上物体的边缘看到类似阶梯的图案。多采样涉及查看相邻像素的颜色并将它们以某种方式混合在一起，以在屏幕上软化边缘并消除由走样引起的其他图形伪影，例如摩尔纹。你可以在维基百科上查找摩尔纹：[http://en.wikipedia.org/wiki/Moir%C3%A9_pattern](http://en.wikipedia.org/wiki/Moir%C3%A9_pattern)。
- en: The next property we set on the `SwapChainDescription` object is the `Flags`
    property. This property lets us set various flags that affect the behavior of
    our swap chain. In this case, we set it to the `SwapChainFlags.AllowModeSwitch`
    flag, which allows us to switch the screen mode of our swap chain by calling its
    `ResizeTarget()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SwapChainDescription`对象上设置的下一个属性是`Flags`属性。此属性允许我们设置影响我们的交换链行为的各种标志。在这种情况下，我们将它设置为`SwapChainFlags.AllowModeSwitch`标志，这允许我们通过调用其`ResizeTarget()`方法来切换交换链的屏幕模式。
- en: And the final property we are setting on our `SwapChainDescription` object is
    the `SwapEffect` property. This sets options for how to handle the back buffer's
    contents after it has been displayed on the screen. We have set this to `SwapEffect.Discard`.
    And with that, we are done setting up our `SwapChainDescription` object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SwapChainDescription`对象上设置的最后一个属性是`SwapEffect`属性。这设置了处理屏幕上已显示的后缓冲区内容的方式的选项。我们将此设置为`SwapEffect.Discard`。就这样，我们完成了`SwapChainDescription`对象的设置。
- en: We are now ready to create our swap chain and the Direct3D device. Both of these
    are accomplished with the next line of code, which calls a static member of the
    `SlimDX.Direct3D11.Device` class; that method is the `CreateWithSwapChain()` method.
    As you can see, there are six parameters. The first parameter specifies the driver
    type. In this case, we set it to `DriverType.Hardware`, since we want hardware
    acceleration if it is available. The second parameter is the device creation flag.
    In this case, we have used `DeviceCreationFlags.Debug`, which creates a Direct3D
    device that supports the debug layer. Of course, you would change this to something
    else before you release your game, since the debug code slows down the game and
    hurts performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的交换链和 Direct3D 设备。这两者都通过下一行代码完成，该代码调用 `SlimDX.Direct3D11.Device`
    类的静态成员方法；该方法就是 `CreateWithSwapChain()` 方法。正如你所见，有六个参数。第一个参数指定了驱动类型。在这种情况下，我们将其设置为
    `DriverType.Hardware`，因为我们想要如果可用的话硬件加速。第二个参数是设备创建标志。在这种情况下，我们使用了 `DeviceCreationFlags.Debug`，这会创建一个支持调试层的
    Direct3D 设备。当然，在你发布游戏之前，你会将其更改为其他设置，因为调试代码会减慢游戏速度并损害性能。
- en: The third parameter specifies feature levels. In this case, we have only used
    `FeatureLevel.Level_11_0`, which means we want the Direct3D 11 features. As this
    parameter is an array, you can, of course, provide more than one feature level
    if your program needs to support more levels.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数指定了功能级别。在这种情况下，我们只使用了 `FeatureLevel.Level_11_0`，这意味着我们想要 Direct3D 11 的功能。由于这个参数是一个数组，当然，如果你的程序需要支持更多级别，你可以提供多个功能级别。
- en: The fourth parameter is our `SwapChainDescription` object, and the last two
    parameters begin with the `out` keyword. This means they are actually output from
    the function, or in other words, the variables we pass in are modified by the
    function to return data. In this case, the fifth parameter is our `m_Device` member
    variable, and the sixth parameter is our `m_SwapChain` variable. So this function
    creates the Direct3D device and stores it in the variable we passed into the fifth
    parameter. And it also creates the swap chain, storing it in the variable that
    we passed into the sixth parameter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个参数是我们的 `SwapChainDescription` 对象，最后两个参数以 `out` 关键字开头。这意味着它们实际上是函数的输出，换句话说，我们传递的变量被函数修改以返回数据。在这种情况下，第五个参数是我们的
    `m_Device` 成员变量，第六个参数是我们的 `m_SwapChain` 变量。所以这个函数创建了 Direct3D 设备并将其存储在我们传递到第五个参数的变量中。它还创建了交换链，并将其存储在我们传递到第六个参数的变量中。
- en: The next thing we need to do is create our render target. As you can see, the
    next piece of code is a `using` block, which creates a `SlimDX.Direct3D11.Resource`
    object using the `Resource` class's static method, `FromSwapChain()`. The `<Texture2D>`
    part of this line indicates that the function is **generic**. A generic method
    is one that allows you to specify a data type when you call it. In other words,
    it is a function that is able to act on multiple data types, whereas a normal
    function can't do that. In this case, we have specified the data type of `Direct3D11.Texture2D`.
    A `Texture2D` object represents an image. The `FromSwapChain()` method takes two
    parameters. The first one is the swap chain we want to create the resource from,
    and the second parameter is the index of one of the buffers in that swap chain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的渲染目标。正如你所见，下一行代码是一个 `using` 块，它使用 `Resource` 类的静态方法 `FromSwapChain()`
    创建了一个 `SlimDX.Direct3D11.Resource` 对象。这一行中的 `<Texture2D>` 部分表示这个函数是 **泛型** 的。一个泛型方法是在调用它时允许你指定数据类型的方法。换句话说，它是一个能够作用于多种数据类型的函数，而普通函数则不能。在这种情况下，我们指定了
    `Direct3D11.Texture2D` 的数据类型。一个 `Texture2D` 对象代表一个图像。`FromSwapChain()` 方法接受两个参数。第一个参数是我们想要从中创建资源的交换链，第二个参数是那个交换链中一个缓冲区的索引。
- en: Then, inside of this `using` statement, we have a single line of code that creates
    our `RenderTargetView` object. This object is essentially our render target. As
    you can see, we pass in two parameters when we create the `RenderTargetView` object.
    The first parameter is our Direct3D device, and the second parameter is the resource
    we just created.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个 `using` 语句内部，我们有一行代码创建我们的 `RenderTargetView` 对象。这个对象本质上就是我们的渲染目标。正如你所见，当我们创建
    `RenderTargetView` 对象时，我们传递了两个参数。第一个参数是我们的 Direct3D 设备，第二个参数是我们刚刚创建的资源。
- en: The next line of code stores the Direct3D device context in our `m_DeviceContext`
    member variable. Remember that this variable is just for convenience. Using it
    allows us to shorten some of our lines of code. The device context is accessed
    via the Direct3D device object's `ImmediateContext` property.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码将 Direct3D 设备上下文存储到我们的 `m_DeviceContext` 成员变量中。请记住，这个变量只是为了方便。使用它允许我们缩短一些代码行。设备上下文是通过
    Direct3D 设备对象的 `ImmediateContext` 属性访问的。
- en: Next up, we create our viewport. The `ViewPort` object specifies the area of
    the swap chain buffer that we want to draw onto, as well as the minimum and maximum
    depth values. The first two parameters we pass in when we create the `Viewport`
    object are the x and y position of the rectangular area we want to draw in. The
    third and fourth parameters are the width and height of that area. As you can
    see, we have specified that we want to use the entire window to draw on. The last
    two parameters are the minimum and maximum depth values, which are usually set
    to `0.0f` and `1.0f` respectively. These specify how much of the depth range to
    draw. Setting them to `0.0f` and `1.0f` tells it to draw the entire depth range
    of the scene. You could set both to `0.0f` to draw all objects to the foreground,
    or set both to `1.0f` to draw everything in the background.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的视口。`ViewPort` 对象指定了我们想要绘制到交换链缓冲区的区域，以及最小和最大的深度值。当我们创建 `Viewport`
    对象时，我们传递的前两个参数是我们想要绘制的矩形区域的 x 和 y 位置。第三个和第四个参数是该区域的宽度和高度。正如你所见，我们指定了想要使用整个窗口进行绘制。最后两个参数是最小和最大的深度值，通常分别设置为
    `0.0f` 和 `1.0f`。这些指定了绘制深度范围的大小。将它们设置为 `0.0f` 和 `1.0f` 告诉它绘制场景的整个深度范围。你可以将它们都设置为
    `0.0f` 来绘制所有对象到前景，或者将它们都设置为 `1.0f` 来绘制所有对象到背景。
- en: As you can see, next up is code consisting of two lines. The first one sets
    the `Viewport` we just created on the **rasterizer**. Remember that, the rasterizer
    is one of the stages in the Direct3D graphics processing pipeline. It clips primitives,
    prepares them for the pixel shader (another stage in the pipeline), and also determines
    how to call the pixel shaders for them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，接下来是两行代码。第一行将我们刚刚创建的 `Viewport` 设置到 **光栅化器** 上。请记住，光栅化器是 Direct3D 图形处理管道中的一个阶段。它裁剪原语，为像素着色器（管道中的另一个阶段）做准备，并确定如何调用这些像素着色器。
- en: The second line of code here sets our `RenderTargetView` on the output merger
    (remember that the output merger is a stage of the graphics pipeline).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第二行代码将我们的 `RenderTargetView` 设置到输出合并器（请记住，输出合并器是图形管道的一个阶段）。
- en: 'We''ve finally reached the last piece of code in our `InitD3D()` method. It''s
    another `using` block, this time getting a `Factory` object. It then calls the
    `SetWindowAssociation()` method on this object. This method takes two parameters:
    the first being the handle of our game window and the second being the window
    association flags we want to use. In this case, we are using the `WindowAssociationFlags.IgnoreAltEnter`
    flag. So why are we doing this? The answer is to prevent **DXGI** from handling
    *Alt* + *Enter* since it does not work properly with WinForms. Remember that DXGI
    is one of the namespaces that we included with a `using` statement when we started
    this project. DXGI is short for DirectX Graphics Infrastructure. We will handle
    the *Alt* + *Enter* keyboard shortcut ourselves later. It will toggle the fullscreen
    mode for our program.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了 `InitD3D()` 方法中的最后一部分代码。这是一个 `using` 块，这次获取一个 `Factory` 对象。然后它调用这个对象的
    `SetWindowAssociation()` 方法。这个方法接受两个参数：第一个是我们游戏窗口的句柄，第二个是我们想要使用的窗口关联标志。在这种情况下，我们使用的是
    `WindowAssociationFlags.IgnoreAltEnter` 标志。我们为什么要这样做呢？答案是防止 **DXGI** 处理 *Alt*
    + *Enter*，因为它与 WinForms 不兼容。请记住，DXGI 是我们在开始这个项目时通过 `using` 语句包含的命名空间之一。DXGI 是
    DirectX Graphics Infrastructure 的缩写。我们稍后会自己处理 *Alt* + *Enter* 键盘快捷键。它将切换我们程序的全屏模式。
- en: 'With that done, we need to create two more initialization functions: one will
    initialize our shaders, and the other will initialize our geometry (the triangle
    we are going to draw).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们需要创建另外两个初始化函数：一个用于初始化我们的着色器，另一个用于初始化我们的几何形状（即我们要绘制的三角形）。
- en: Initializing the shaders
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化着色器
- en: 'We will create a new method named `InitShaders()` to initialize our shaders
    for us. In this demo, we will set up both a vertex shader and a pixel shader.
    The following is the code for this method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `InitShaders()` 的新方法来初始化我们的着色器。在这个演示中，我们将设置一个顶点着色器和像素着色器。以下是这个方法的代码：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see that this function contains two blocks of code that are quite similar
    to each other. The first one initializes our vertex shader. The downloadable code
    contains a file called `Effects.fx`, which is simply a text file containing the
    code of our basic shaders.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个函数包含了两块相当相似的代码块。第一个初始化我们的顶点着色器。可下载的代码中包含一个名为 `Effects.fx` 的文件，它只是一个包含我们基本着色器代码的文本文件。
- en: The first line creates a string variable named `vsCompileError`. This will receive
    any errors that are raised by the next piece of code. As you can see, it is a
    `using` block that calls the `ShaderBytecode.CompileFromFile()` method to compile
    our vertex shader. The returned byte code is the compiled form of our vertex shader.
    The `CreateFromFile()` method takes a handful of parameters, and it also has several
    overloads. An `overload` method is another version of the same function with a
    different parameter list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个名为 `vsCompileError` 的字符串变量。这个变量将接收下一行代码引发的任何错误。正如你所见，它是一个 `using` 块，调用
    `ShaderBytecode.CompileFromFile()` 方法来编译我们的顶点着色器。返回的字节码是我们顶点着色器的编译形式。`CreateFromFile()`
    方法接受一些参数，并且有几个重载版本。重载方法是与相同功能具有不同参数列表的另一个版本。
- en: The first parameter of the `CompileFromFile()` method is the file containing
    the code of the shader we want to compile. The second parameter is the name of
    the method in the shader file that contains the code for this shader. The third
    parameter is the shader model. In this case we used `"vs_4_0"`, which tells it
    that we want to use shader model 4\. The fourth parameter is the shader flags
    we use. We used `ShaderFlags.Debug` here. Again, you'd probably want to remove
    this flag when your game is done since the debug code will slow down performance.
    The next two parameters are a list of shader macros to define during shader compilation
    and an interface for handling the `include` files. These two parameters are set
    to `null` as they are beyond the scope of this chapter. And the final parameter
    is the `psCompileError` variable we created above the `using` block. If there
    are any errors, they will be put in this variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompileFromFile()` 方法的第一个参数是要编译的着色器代码的文件。第二个参数是包含此着色器代码的着色器文件中的方法名称。第三个参数是着色器模型。在这种情况下，我们使用了
    `"vs_4_0"`，这告诉它我们想要使用着色器模型 4。第四个参数是我们使用的着色器标志。在这里我们使用了 `ShaderFlags.Debug`。同样，当你完成游戏时，你可能想要移除这个标志，因为调试代码会降低性能。接下来的两个参数是定义在着色器编译期间的着色器宏列表和处理
    `include` 文件的接口。这两个参数设置为 `null`，因为它们超出了本章的范围。最后一个参数是我们上面 `using` 块中创建的 `psCompileError`
    变量。如果有任何错误，它们将被放入这个变量中。'
- en: Inside of this `using` block we have two lines of code. The first gets the signature
    for this shader. Remember that the signature of a shader is just a list of the
    input and/or output parameters of that shader. The second line of code creates
    a `VertexShader` object to hold our vertex shader, and stores it in our `m_VertexShader`
    variable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `using` 块内部，我们有两行代码。第一行获取这个着色器的签名。记住，着色器的签名只是该着色器输入和/或输出参数的列表。第二行代码创建一个
    `VertexShader` 对象来保存我们的顶点着色器，并将其存储在我们的 `m_VertexShader` 变量中。
- en: The second block of code in our `InitShaders()` method is very similar to the
    first one. It does the same stuff but for the pixel shader. It compiles our pixel
    shader and stores it in our `m_PixelShader` member variable. You may have noticed
    that it uses the same shader file as the vertex shader code at the top of this
    method. You can define multiple shaders in a single file, and we've done that
    here for simplicity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `InitShaders()` 方法中的第二个代码块与第一个非常相似。它执行与顶点着色器相同的功能，但针对的是像素着色器。它编译我们的像素着色器并将其存储在我们的
    `m_PixelShader` 成员变量中。你可能已经注意到，它使用了与该方法顶部顶点着色器代码相同的着色器文件。你可以在单个文件中定义多个着色器，我们在这里这样做是为了简化。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the vertex shader is one of the stages in the Direct3D graphics
    pipeline, as is the pixel shader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，顶点着色器是 Direct3D 图形管线中的阶段之一，像素着色器也是如此。
- en: The last two lines of code in this method tell the graphics processing pipeline
    to use our vertex shader and pixel shader. So why do we have shaders anyway? The
    reason is because some stages in the Direct3D graphics pipeline are programmable.
    Shaders are the programs we write for these stages, so a shader is essentially
    a small program that tells Direct3D what to do during that stage in the pipeline.
    There are more shader types besides vertex and pixel shaders too, but they are
    beyond the scope of this book. Shaders are a powerful tool that allow us to customize
    the graphics processing pipeline, so we can do things that otherwise we might
    not be able to do. You can have more than one shader of a given type and switch
    between them at will too (we will actually do this in the second demo we make
    in this chapter), so you're not stuck with the first shader you set. At this point,
    we are ready to initialize our scene.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法中的最后两行代码告诉图形处理管线使用我们的顶点着色器和像素着色器。那么为什么我们还需要着色器呢？原因是Direct3D图形管线中的某些阶段是可编程的。着色器是我们为这些阶段编写的程序，因此着色器本质上是一个小程序，它告诉Direct3D在管线中的该阶段要做什么。除了顶点和像素着色器之外，还有更多类型的着色器，但它们超出了本书的范围。着色器是一个强大的工具，它允许我们自定义图形处理管线，因此我们可以做一些我们可能无法做到的事情。您可以有多个给定类型的着色器，并且可以随意在它们之间切换（我们将在本章制作的第二个演示中实际这样做），因此您不会卡在您设置的第一个着色器上。到目前为止，我们已经准备好初始化我们的场景。
- en: Initializing the scene
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化场景
- en: 'In 3D graphics, the term **scene** is used much as it is in the movies. However,
    in this case, the term scene refers to the world, or 3D scene, that we are rendering.
    To initialize our scene, we will create one more initialization method named `InitScene()`.
    The code for this method looks as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D图形中，术语**场景**的使用方式与电影中的使用方式大致相同。然而，在这种情况下，术语场景指的是我们正在渲染的世界或3D场景。为了初始化我们的场景，我们将创建一个名为`InitScene()`的初始化方法。此方法的代码如下：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing we do in this method is create an array of the `Vector3` objects.
    These are the vertices that make up our inverted triangle. So, each `Vector3`
    object contains the x, y, and z coordinates for the vertex it represents.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们首先创建一个`Vector3`对象的数组。这些是我们组成倒置三角形的顶点。因此，每个`Vector3`对象包含它所代表的顶点的x、y和z坐标。
- en: The next block of code is a `using` block that creates a `DataStream` object.
    We pass in the three parameters when we create this object. The first parameter
    is the total size in bytes of our vertex data. The last two parameters are `canRead`
    and `canWrite`. They specify whether or not reading and writing to the buffer
    should be allowed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是一个`using`块，用于创建一个`DataStream`对象。我们在创建此对象时传递了三个参数。第一个参数是我们顶点数据的总字节数。最后两个参数是`canRead`和`canWrite`。它们指定是否允许读取和写入缓冲区。
- en: The next line sets the position of the data stream to the start. The following
    three lines write our vertices into the data stream one by one. And the last line
    here sets the data stream's position back to the beginning again.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将数据流的定位设置为起始位置。接下来的三行将我们的顶点逐个写入数据流。最后一行将数据流的定位再次设置回开始位置。
- en: Now that our geometry data is ready, we need to create a `VertexBuffer` object
    to put it in. The next block of code creates a `BufferDescription` object for
    this purpose. We set the `ResourceUsage` property to `ResourceUsage.Default`.
    Next, we set the `SizeInBytes` property to the size of our vertex data, so the
    vertex buffer will be big enough to hold it all. Then, we set the `BindFlags`
    property to `BindFlags.VertexBuffer` since this buffer is going to be used as
    a vertex buffer. We have set both the `CpuAccessFlags` and `OptionFlags` properties
    to `None` on the next two lines as they are beyond the scope of this discussion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了几何数据，我们需要创建一个`VertexBuffer`对象来存放它。下一块代码创建了一个用于此目的的`BufferDescription`对象。我们将`ResourceUsage`属性设置为`ResourceUsage.Default`。接下来，我们将`SizeInBytes`属性设置为我们的顶点数据的大小，这样顶点缓冲区就足够大，可以容纳所有数据。然后，我们将`BindFlags`属性设置为`BindFlags.VertexBuffer`，因为此缓冲区将用作顶点缓冲区。在接下来的两行中，我们将`CpuAccessFlags`和`OptionFlags`属性都设置为`None`，因为它们超出了本次讨论的范围。
- en: The next line of code creates the `VertexBuffer` object. We pass in three parameters
    when we create it. The first parameter is our Direct3D device. The second parameter
    is the `DataStream` object we wrote our vertex data into, and the last parameter
    is the `BufferDescription` object we just created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码创建了一个`VertexBuffer`对象。我们在创建它时传递了三个参数。第一个参数是我们的Direct3D设备。第二个参数是我们写入顶点数据到其中的`DataStream`对象，最后一个参数是我们刚刚创建的`BufferDescription`对象。
- en: At this point, the `using` block ends. When program execution reaches this point,
    our `DataStream` object gets disposed of since we no longer need it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`using` 块结束了。当程序执行到达这一点时，我们的 `DataStream` 对象被销毁，因为我们不再需要它。
- en: The next bit of code creates an array of the `InputElement` objects. This tells
    Direct3D what data we have stored in each of our vertices, and how it is formatted.
    As you can see, we have only added one input element here. It is the position
    of the vertex in 3D space.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一小段代码创建了一个 `InputElement` 对象的数组。这告诉 Direct3D 我们在每个顶点中存储了哪些数据，以及它们的格式。正如你所见，我们这里只添加了一个输入元素。它是顶点在
    3D 空间中的位置。
- en: There are a handful of parameters we pass in when creating this `InputElement`
    object. The first parameter is a string indicating what type of element this is.
    We set this to `"POSITION"` since this input element holds the position of our
    vertex in 3D space. The second parameter is an index that is used when you have
    multiple elements with the same name. So if we had two elements named `"POSITION"`,
    we would set the index parameter to `1` for the second one. The third parameter
    is the data format used by this input element. In this case, we need to store
    three numbers since a coordinate in 3D space is composed of three integers. So,
    we used the format `Format.R32G32B32_Float`. This format holds three float values,
    each of which is 32 bits in size. The next parameter is an offset to the next
    input element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个 `InputElement` 对象时，我们传递了一些参数。第一个参数是一个字符串，表示这个元素的类型。我们将其设置为 `"POSITION"`，因为这个输入元素持有我们在
    3D 空间中顶点的位置。第二个参数是一个索引，当有多个具有相同名称的元素时使用。所以如果我们有两个名为 `"POSITION"` 的元素，我们会将索引参数设置为
    `1` 对第二个元素。第三个参数是此输入元素使用的数据格式。在这种情况下，我们需要存储三个数字，因为 3D 空间中的一个坐标由三个整数组成。因此，我们使用了格式
    `Format.R32G32B32_Float`。这个格式包含三个浮点值，每个值的大小为 32 位。下一个参数是到下一个输入元素的偏移量。
- en: For convenience, we've set this to `InputElement.AppendAligned`, which means
    this input element will start directly after the previous one. The next parameter
    is the input slot to use for this input element. The valid values for this property
    are `0`-`15`. Then, we have the slot class parameter, which we've set to `InputClassification.PerVertexData`.
    This is because this element is being used on a per-vertex basis since we need
    to store the position for every vertex. The last parameter is the step rate. We
    have set this to `0` in our code since we are not using this feature, and it is
    beyond the scope of this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们将其设置为 `InputElement.AppendAligned`，这意味着这个输入元素将直接在之前的元素之后开始。下一个参数是要使用的输入槽位。这个属性的合法值是
    `0` 到 `15`。然后，我们有槽位类参数，我们将其设置为 `InputClassification.PerVertexData`。这是因为这个元素是按顶点基础使用的，因为我们需要为每个顶点存储位置。最后一个参数是步进速率。在我们的代码中，我们将其设置为
    `0`，因为我们没有使用这个功能，而且它超出了本章的范围。
- en: With that, we're almost done now. The next line of code creates an `InputLayout`
    object that will hold the information we just set up. We pass in three parameters
    when we create it. The first parameter is our Direct3D device object. The second
    parameter is the signature of our vertex shader, and the last parameter is the
    input elements array we just created.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们几乎就完成了。下一行代码创建了一个 `InputLayout` 对象，它将保存我们刚刚设置的信息。我们创建它时传递了三个参数。第一个参数是我们的
    Direct3D 设备对象。第二个参数是我们顶点着色器的签名，最后一个参数是我们刚刚创建的输入元素数组。
- en: The next line of code tells the input assembler to use our new `InputLayout`
    object. Remember from earlier in this chapter that the input assembler is a stage
    in the Direct3D graphics pipeline.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码告诉输入装配器使用我们新的 `InputLayout` 对象。记得在本章前面提到，输入装配器是 Direct3D 图形管道中的一个阶段。
- en: Next, we call the `SetVertexBuffers()` method on the `InputAssembler`. This
    tells it what vertex buffer we want to use. If you had multiple objects to draw,
    you can reset the vertex buffers multiple times in the `RenderScene()` method.
    This method takes three parameters. The first parameter is the slot we want to
    use. Depending on the feature level we are using, the maximum number of slots
    available to use can vary. The second parameter is a `VertexBufferBinding` object.
    We give it three parameters when we create it. The first parameter is our vertex
    buffer that we created a moment ago. The second parameter is the total size of
    our vertex buffer, and the last parameter is an offset to the first vertex in
    the buffer. We have set this to `0` since our first vertex is at the very beginning
    of the buffer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `InputAssembler` 上调用 `SetVertexBuffers()` 方法。这告诉它我们想要使用哪个顶点缓冲区。如果你有多个对象要绘制，你可以在
    `RenderScene()` 方法中多次重置顶点缓冲区。此方法有三个参数。第一个参数是我们想要使用的槽位。根据我们使用的功能级别，可用的最大槽位数量可能会有所不同。第二个参数是一个
    `VertexBufferBinding` 对象。我们创建它时给它提供了三个参数。第一个参数是我们刚刚创建的顶点缓冲区。第二个参数是我们顶点缓冲区的总大小，最后一个参数是缓冲区中第一个顶点的偏移量。我们将其设置为
    `0`，因为我们的第一个顶点位于缓冲区的开头。
- en: Finally, we have one more line of code to set the **primitive topology**. This
    setting basically tells the graphics pipeline how to interpret our vertex data.
    In this case, we set this to `PrimitiveTopology.TriangleList`. This tells Direct3D
    that our vertex data is a list of triangles, or, in other words, every three vertices
    in the list form a triangle. There are a number of other options you can use for
    this setting, and they are all defined in the `PrimitiveTopology` enumeration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一行代码来设置**原语拓扑**。这个设置基本上告诉图形管线如何解释我们的顶点数据。在这种情况下，我们将此设置为 `PrimitiveTopology.TriangleList`。这告诉
    Direct3D，我们的顶点数据是一个三角形的列表，换句话说，列表中的每个三个顶点形成一个三角形。对于这个设置，你可以使用许多其他选项，它们都在 `PrimitiveTopology`
    枚举中定义。
- en: The input assembler also has a `SetIndexBuffer()` method for setting **index
    buffers**. An index buffer simply holds a list of offsets into a vertex buffer
    to allow for more efficient rendering. For example, let's say we want to render
    a square. It has four vertices, but we'd have to create six to render it using
    a vertex buffer alone (three per triangle, and a square is composed of two triangles).
    We could accomplish this using only four vertices if we use an index buffer. Our
    index buffer would have two values in it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输入汇编器还提供了一个 `SetIndexBuffer()` 方法用于设置**索引缓冲区**。索引缓冲区简单地保存了一个指向顶点缓冲区中偏移量的列表，以便更有效地渲染。例如，假设我们想要渲染一个正方形。它有四个顶点，但如果我们仅使用顶点缓冲区来渲染它，则需要创建六个顶点（每个三角形三个，而一个正方形由两个三角形组成）。如果我们使用索引缓冲区，则只需四个顶点就能完成。我们的索引缓冲区将包含两个值。
- en: The first value would be `0`, since the first triangle starts with the first
    vertex. The second value would be the index of the first vertex of the second
    triangle in the vertex buffer. This allows triangles to share vertices, as it
    is very common for two triangles to have vertices that are at the same point in
    3D space. Clearly, this wastes memory if we re-define the same vertex more than
    once to create a separate instance of it for each triangle that has that vertex
    in it. Index buffers allow us to get around this problem. For simplicity though,
    we will not use an index buffer in this demo.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值将是 `0`，因为第一个三角形从第一个顶点开始。第二个值将是第二个三角形在顶点缓冲区中第一个顶点的索引。这允许三角形共享顶点，因为在三维空间中，两个三角形共享相同点的顶点是常见的。显然，如果我们为包含该顶点的每个三角形重新定义相同的顶点，则会浪费内存。索引缓冲区允许我们解决这个问题。然而，为了简单起见，我们将在本演示中不使用索引缓冲区。
- en: Rendering the scene
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染场景
- en: 'To draw our scene, we just need to add three lines of code to our `RenderScene()`
    method so that it looks like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制我们的场景，我们只需在 `RenderScene()` 方法中添加三行代码，使其看起来如下：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, this code is fairly simple. At the top of the method, we have
    the same `if` statement we've been using here in previous demos. Remember that
    this `if` statement prevents this method from doing anything if the program isn't
    initialized yet or if it has already been disposed of. This prevents the crashing
    that could otherwise occur when the program first starts up or shuts down.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码相当简单。在方法顶部，我们有之前在演示中使用的相同 `if` 语句。请记住，这个 `if` 语句防止在程序尚未初始化或已被销毁时执行此方法，从而防止程序启动或关闭时可能发生的崩溃。
- en: The next line of code clears the screen using whatever color is stored in our
    `ClearColor` property that is defined by the `GameWindow` base class. Then, we
    call the `Draw()` method of the Direct3D device context to draw our geometry.
    This method takes two parameters. The first one is the total number of vertices
    we want to draw. The second parameter is the index to start at in the vertex buffer.
    We want to draw all of our vertices, so we set this to `0` to start with the first
    vertex.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码使用存储在由`GameWindow`基类定义的`ClearColor`属性中的颜色清除屏幕。然后，我们调用Direct3D设备上下文的`Draw()`方法来绘制我们的几何形状。此方法接受两个参数。第一个参数是我们想要绘制的顶点总数。第二个参数是在顶点缓冲区中开始的位置的索引。我们想要绘制所有顶点，所以我们将这个设置为`0`以从第一个顶点开始。
- en: And lastly, we call the `Present()` method on the swap chain. It takes two parameters.
    The first parameter is the sync interval, and the second is the present flags.
    Both of these are beyond the scope of this chapter, so we are using `0` for the
    first parameter, and `PresentFlags.None` for the second parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在交换链上调用`Present()`方法。它接受两个参数。第一个参数是同步间隔，第二个参数是呈现标志。这两个参数都不在本章的讨论范围内，所以我们使用`0`作为第一个参数，并使用`PresentFlags.None`作为第二个参数。
- en: 'Before we test the code, we''ll do one more little thing. We will edit the
    `ToggleFullscreen()` method of our `TriangleGameWindow` class so it looks like
    the next code snippet. Remember that this function is an override of a method
    defined by our `GameWindow` base class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码之前，我们还会做一件小事。我们将编辑`TriangleGameWindow`类的`ToggleFullscreen()`方法，使其看起来像下面的代码片段。记住，这个函数是`GameWindow`基类中定义的方法的覆盖：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line toggles the value of our `IsFullScreen` property that was defined
    by the `GameWindow` base class. The second line sets the fullscreen state of our
    swap chain to the new value in the `IsFullScreen` property. With this bit of code,
    we can now toggle fullscreen mode while the program is running. If you press *Alt*
    + *Enter*, the program will toggle its fullscreen mode. Remember that we added
    code to detect the *Alt* + *Enter* key stroke back in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, when we created the `GameWindow` base class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行切换由`GameWindow`基类定义的`IsFullScreen`属性的值。第二行将交换链的全屏状态设置为`IsFullScreen`属性中的新值。通过这段代码，我们可以在程序运行时切换全屏模式。如果您按下*Alt*
    + *Enter*，程序将切换其全屏模式。记住，我们在[第1章](ch01.html "第1章。入门")的“入门”部分创建`GameWindow`基类时添加了检测*Alt*
    + *Enter*键位的代码。
- en: Note that the resolution we are rendering at does not change when you do this.
    When we resize the window, the image we drew simply gets stretched to fit the
    new size of the window. You can have your swap chain and viewport resized by adding
    an event handler and subscribing it to the `Resize` event of our form (remember
    that our `RenderForm` object is stored in our `FormObject` property that is defined
    by the `GameWindow` base class). In this event handler, you would dispose of the
    `RenderTargetView` object using its `Dispose()` method and recreate it with the
    new window size. You would then reset the viewport as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当您这样做时，渲染的分辨率不会改变。当我们调整窗口大小时，我们绘制的图像会简单地拉伸以适应新窗口的大小。您可以通过添加事件处理程序并订阅表单的`Resize`事件来调整交换链和视口的尺寸（记住，我们的`RenderForm`对象存储在我们的由`GameWindow`基类定义的`FormObject`属性中）。在这个事件处理程序中，您将使用其`Dispose()`方法处理`RenderTargetView`对象，并使用新的窗口大小重新创建它。然后，您还需要重置视口。
- en: 'Before you run the program, remember to edit the `Dispose(bool)` method, and
    make sure it disposes of all of our objects. See the downloadable code for this
    chapter to see the new code for this method. Once that''s done, we''re ready to
    run the program. The following is a screenshot of this program in action, showing
    our inverted triangle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，请记住编辑`Dispose(bool)`方法，并确保它处理掉我们所有的对象。查看本章的可下载代码，以查看此方法的新代码。完成这些后，我们就可以运行程序了。以下是在运行中的程序截图，显示了我们的倒置三角形：
- en: '![Rendering the scene](img/7389_05_01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![渲染场景](img/7389_05_01.jpg)'
- en: Our inverted triangle being rendered in our game window
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏窗口中渲染的倒置三角形
- en: You may be wondering why the triangle is blue. We never set a color for it,
    so how did that happen? Well, if you look in our `Effects.fx` file at the shader
    code, you will see that the pixel shader is hardcoded to shade every pixel it
    draws blue. The pixel shader has only a single line of code that returns the color
    blue in RGBA format. The color returned by the pixel shader is the color for the
    current pixel that the graphics pipeline is processing. The `Effects.fx` file
    is included with the downloadable code for this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么三角形是蓝色的。我们从未为它设置颜色，那么这是怎么发生的呢？好吧，如果您查看我们的 `Effects.fx` 文件中的着色器代码，您将看到像素着色器被硬编码为绘制每个像素为蓝色。像素着色器只有一行代码，返回
    RGBA 格式的蓝色。像素着色器返回的颜色是图形管道正在处理的当前像素的颜色。`Effects.fx` 文件包含在本章的可下载代码中。
- en: Rendering a cube
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染一个立方体
- en: In this section we will render a cube since it is actually 3D, unlike our triangle
    in the previous demo. We will modify the project from the previous demo to create
    the cube demo. In the downloadable code for this chapter, you will find the code
    for the cube demo in a separate project so you can look at the code for both demos.
    The `Triangle` project is set as the startup project by default. When you want
    to run the `Cube` demo, remember that you will have to set the `Cube` project
    as the startup project to run it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将渲染一个立方体，因为它实际上是三维的，与之前演示中的三角形不同。我们将修改之前的演示项目以创建立方体演示。在本章的可下载代码中，您将找到立方体演示的代码，它位于一个单独的项目中，这样您就可以查看两个演示的代码。默认情况下，`Triangle`
    项目被设置为启动项目。当您想要运行 `Cube` 演示时，请记住您必须将 `Cube` 项目设置为启动项目才能运行它。
- en: 'To get started, we will add an enumeration named `GraphicsMode`. We will use
    it to specify how we will render our cube. This enumeration looks like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将添加一个名为 `GraphicsMode` 的枚举。我们将使用它来指定我们将如何渲染我们的立方体。这个枚举看起来如下所示：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first option will make the program render all the pixels of the cube blue.
    The second option renders the cube using colors specified with each vertex and
    blending them across each **face** (or side) of the cube. And the third option
    will render our cube with a texture on it, which happens to be the red brick tile
    from our 2D demo in [Chapter 3](ch03.html "Chapter 3. Rendering 2D Graphics"),
    *Rendering 2D Graphics*. Next, we need to make a new structure to represent a
    vertex since we need to store more information for each vertex now. We will name
    it `Vertex`. It looks as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项将使程序渲染立方体的所有像素为蓝色。第二个选项使用每个顶点指定的颜色渲染立方体，并将它们混合到立方体的每个**面**（或侧面）上。第三个选项将渲染带有纹理的立方体，这个纹理恰好来自我们第
    3 章的 2D 演示中的红砖瓦片，[第 3 章](ch03.html "第 3 章。渲染 2D 图形")，*渲染 2D 图形*。接下来，我们需要创建一个新的结构来表示顶点，因为我们现在需要为每个顶点存储更多信息。我们将它命名为
    `Vertex`。它看起来如下所示：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first variable holds the position of the vertex in 3D space. The second
    one stores a color for this vertex, and the third variable stores the texture
    coordinates for this vertex. The texture coordinates simply define how the texture
    is applied to the polygon. For example, to texture a square, you'd give the upper-left
    vertex `(0,0)` for its texture coordinates. The upper-right vertex would be `(1,0)`,
    the lower-left vertex would be `(0,1)`, and the lower-right vertex would have
    `(1,1)` for its texture coordinates. In the texture coordinates, `(0,0)` is the
    upper-left corner of the texture image, and `(1,1)` represents the bottom-right
    corner of the texture image. So, the texture coordinates we just saw would make
    the texture fill the entire face of the square. They are basically attaching the
    top-left corner of the texture to the top-left corner of the square, the bottom-right
    corner of the texture to the bottom-right corner of the square, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量存储顶点在 3D 空间中的位置。第二个变量存储该顶点的颜色，第三个变量存储该顶点的纹理坐标。纹理坐标简单地定义了纹理如何应用于多边形。例如，要纹理化一个正方形，您会给左上角的顶点
    `(0,0)` 分配纹理坐标。右上角的顶点将是 `(1,0)`，左下角的顶点将是 `(0,1)`，而右下角的顶点将具有 `(1,1)` 的纹理坐标。在纹理坐标中，`(0,0)`
    是纹理图像的左上角，`(1,1)` 代表纹理图像的右下角。因此，我们刚才看到的纹理坐标将使纹理填充整个正方形的面。它们基本上是将纹理的左上角附着到正方形的左上角，纹理的右下角附着到正方形的右下角，依此类推。
- en: 'Now, we will need to add a few sets of new member variables. The first one
    is for our **constant buffers** . A constant buffer is just a buffer that we use
    to communicate certain information to the video card, such as the projection and
    view matrices. We have four variables for our constant buffers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加几组新的成员变量。第一个是为我们的**常量缓冲区**。常量缓冲区只是一个我们用来向显卡传达某些信息的缓冲区，例如投影和视图矩阵。我们有四个变量用于我们的常量缓冲区：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first three variables will hold our three constant buffers. But why do we
    have three? The reason is that it's more efficient this way compared to using
    only one. The `m_CbChangesOnResize` buffer will hold the projection matrix that
    only needs to change when the window is resized. In this demo, this never changes
    since we just let it keep rendering at the same resolution and stretch it to fit
    the window. By having it in a separate buffer, we never have to change it unless
    the window changes size, which saves time. The `m_CbChangesPerFrame` buffer will
    hold our view matrix, which can change per frame any time that you press one of
    the movement keys. And lastly, the `m_CbChangesPerObject` buffer will hold information
    that is object-specific. This buffer would be updated each time before you draw
    the next object in your scene by filling it with the information for that object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个变量将存储我们的三个常量缓冲区。但为什么是三个呢？原因是这样比只用一个更有效率。`m_CbChangesOnResize` 缓冲区将存储仅需要在窗口大小调整时改变的投影矩阵。在这个演示中，这个矩阵永远不会改变，因为我们只是让它保持以相同的分辨率渲染，并将其拉伸以适应窗口。通过将其放在单独的缓冲区中，我们只有在窗口大小改变时才需要更改它，这样可以节省时间。`m_CbChangesPerFrame`
    缓冲区将存储我们的视图矩阵，该矩阵可以在你按下任意一个移动键时每帧改变。最后，`m_CbChangesPerObject` 缓冲区将存储特定于对象的信息。这个缓冲区将在你绘制场景中的下一个对象之前更新，通过填充该对象的信息来实现。
- en: 'Next up, we need to add a few matrix variables:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加几个矩阵变量：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first two variables will hold our view and projection matrices. We will
    look at these matrices in more detail in a moment. The other two variables hold
    two matrices for our cube object. The **world matrix** is used to convert the
    coordinates of a **model** into **world space** , which is the coordinate system
    of our 3D world.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量将存储我们的视图和投影矩阵。我们将在稍后更详细地查看这些矩阵。其他两个变量存储了立方体对象的两个矩阵。**世界矩阵**用于将**模型**的坐标转换为**世界空间**，这是我们的3D世界的坐标系。
- en: A model is a 3D geometrical representation of an object. In other words, it
    holds all of the geometry for the object it represents. Models often have their
    own coordinate system known as **model space** , which is why we need to convert
    it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是对象的3D几何表示。换句话说，它存储了它所代表对象的全部几何信息。模型通常有自己的坐标系，称为**模型空间**，这就是为什么我们需要将其转换的原因。
- en: Lastly, the rotation matrix you see there for our cube controls the pitch, yaw,
    and roll of our cube. It is known as a **transformation matrix** , because it
    transforms the object we use it on in some way, such as moving it, scaling it,
    or rotating it. The projection and view matrices are, of course, also transformation
    matrices. Transformation matrices are a very central concept in 3D graphics.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到的用于控制立方体的旋转矩阵控制着立方体的俯仰、偏航和翻滚。它被称为**变换矩阵**，因为它以某种方式变换了我们使用的对象，例如移动它、缩放它或旋转它。投影和视图矩阵当然也是变换矩阵。变换矩阵是3D图形中的一个非常核心的概念。
- en: 'Now, we also need to add a few depth stencil and sampler member variables:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要添加几个深度模板和采样器成员变量：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first variable holds the depth stencil's texture. The **depth stencil**
    is basically a texture. Each pixel in it holds a depth value representing the
    nearest object that has been drawn on that pixel so far while rendering the current
    frame. This is how Direct3D knows whether an object is in front of or behind another
    object. When the pixel shader goes to draw a pixel, it checks the depth value
    for that pixel in the depth stencil texture. If that pixel's depth value is closer
    than the depth of the pixel it is trying to draw, that pixel is discarded since
    it belongs to an object behind another closer one that we already drew on this
    pixel.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量存储深度模板的纹理。**深度模板**基本上是一个纹理。它中的每个像素都存储一个深度值，代表在渲染当前帧时已经绘制在该像素上的最近对象。这就是Direct3D知道一个对象是否在另一个对象之前或之后的原因。当像素着色器准备绘制一个像素时，它会检查深度模板纹理中该像素的深度值。如果该像素的深度值比它试图绘制的像素的深度值更近，那么该像素将被丢弃，因为它属于一个比我们已经在该像素上绘制的更近的对象。
- en: The second variable holds our `DepthStencilView` object, which accesses the
    depth stencil texture when Direct3D is doing depth testing on a pixel. The next
    two variables have to do with sampling. The first one will hold our texture that
    we will put on the cube. The second variable holds the sampler state that we will
    use with our texture.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量存储我们的`DepthStencilView`对象，当Direct3D在像素上进行深度测试时，它会访问深度模板纹理。接下来的两个变量与采样有关。第一个将存储我们将放在立方体上的纹理。第二个变量存储我们将与纹理一起使用的采样器状态。
- en: '**Sampling** is the act of reading image data from our texture so that we can
    use it to render pixels in the pixel shader. Basically, the pixel shader gets
    the pixel color from the texture based on the texture coordinates of the vertices
    that make up the face it is drawing.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样**是从我们的纹理中读取图像数据的行为，以便我们可以在像素着色器中使用它来渲染像素。基本上，像素着色器根据构成它所绘制面的顶点的纹理坐标从纹理中获取像素颜色。'
- en: 'Lastly, we have one more small set of member variables to look at:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一组更小的成员变量要查看：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first variable here keeps track of the position of our camera, of course.
    The second variable tracks the current rotation amount (on the y axis) for our
    cube. The `m_MoveSpeed` variable specifies how fast the camera moves when you
    press one of the movement keys. And the last variable specifies how we want to
    render our cube.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个变量当然跟踪我们摄像机的位置。第二个变量跟踪我们立方体的当前旋转量（在y轴上）。`m_MoveSpeed`变量指定当你按下移动键时，摄像机移动的速度。最后一个变量指定我们想要如何渲染我们的立方体。
- en: I wanted to make a demo that we could really experiment with, so I added this
    feature. So how does it work? If you look at the code in the `InitShaders()` method
    in the downloadable code for this demo, you can see that we have changed the code
    that loads the pixel shader. Now, it has `if` statements above it that check the
    value of the `m_GraphicsMode` member variable. So basically, depending on which
    graphics mode you set, it will load and use the appropriate pixel shader. If you
    look in the `Effects.fx` file in the downloadable code for this demo, you can
    see that we have three pixel shaders in there, one for each of our three graphics
    modes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我想制作一个我们可以真正实验的演示，所以我添加了这个功能。那么它是如何工作的？如果你查看这个演示的可下载代码中的`InitShaders()`方法中的代码，你可以看到我们已经更改了加载像素着色器的代码。现在，它上面有`if`语句，检查`m_GraphicsMode`成员变量的值。所以基本上，根据你设置的图形模式，它将加载并使用适当的像素着色器。如果你查看这个演示的可下载代码中的`Effects.fx`文件，你可以看到里面有三个像素着色器，每个对应我们的三种图形模式。
- en: Initializing the depth stencil
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化深度模板
- en: 'Anyway, now that we''ve covered the new member variables and the changes to
    the `InitShaders()` method, we need to add a couple of entirely new methods. The
    first one is the `InitDepthStencil()` method that will initialize our depth stencil
    for us:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，现在我们已经涵盖了新的成员变量和`InitShaders()`方法的更改，我们需要添加几个全新的方法。第一个是`InitDepthStencil()`方法，它将为我们初始化深度模板：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the first thing we do is create a `Texture2DDescription` to
    configure the depth stencil texture. The `width` and `height` properties, of course,
    are setting its size to the same size as our rendering area. The `MipLevels` and
    `ArraySize` parameters are beyond the scope of this text, so we will ignore them.
    The `Format` property is, of course, the format our texture is in. The `D24_UNorm_S8_UInt`
    format means 24 bits for depth and 8 bits for the stencil component, but this
    is getting into the details of how the depth stencil actually works, which is
    beyond the scope of this text. The `SampleDescription` property sets the multisampling
    parameters for this texture. The `Usage` property specifies how this resource
    will be used during rendering. We set the `BindFlags` property to `BindFlags.DepthStencil`
    to tell Direct3D that this will be used for depth stenciling. And lastly, we set
    the `CpuAccessFlags` and `OptionsFlags` to `None` as we've done before.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先创建一个`Texture2DDescription`来配置深度模板纹理。当然，`width`和`height`属性是将它的大小设置为与我们的渲染区域相同。`MipLevels`和`ArraySize`参数超出了本文的范围，所以我们将忽略它们。`Format`属性当然是我们的纹理格式。`D24_UNorm_S8_UInt`格式意味着深度有24位，模板组件有8位，但这涉及到深度模板实际工作细节，这超出了本文的范围。`SampleDescription`属性设置了这个纹理的多采样参数。`Usage`属性指定了在渲染过程中如何使用这个资源。我们将`BindFlags`属性设置为`BindFlags.DepthStencil`来告诉Direct3D这将用于深度模板化。最后，我们将`CpuAccessFlags`和`OptionsFlags`设置为`None`，就像我们之前做的那样。
- en: Next, we create a `DepthStencilViewDescription` to configure the depth stencil
    view object. The `Format` property specifies the format, for which we just pass
    in the value we set for the `Format` property of the depth stencil texture description
    we just filled in. We set the `Dimension` property to `DepthStencilViewDimension.Texture2D`
    since we are using a `Texture2D` object for the depth stencil texture. And the
    `MipSlice` property is beyond the scope of this text, so we set it to `0`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`DepthStencilViewDescription`来配置深度模板视图对象。`Format`属性指定了格式，我们只需传入我们刚刚设置的深度模板纹理描述中的`Format`属性的值。我们将`Dimension`属性设置为`DepthStencilViewDimension.Texture2D`，因为我们正在使用`Texture2D`对象作为深度模板纹理。而`MipSlice`属性超出了本文的范围，所以我们将其设置为`0`。
- en: The next line of code creates the depth stencil texture object. And after that,
    the following line creates the `DepthStencilView` object. And the last line tells
    the output merger to use our new depth stencil along with our render target.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码创建深度模板纹理对象。之后，下一行创建`DepthStencilView`对象。最后一行指示输出合并器使用我们新的深度模板和渲染目标。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this demo we only have one object, so we won't really see the depth stencil
    in action. If we had two cubes, with one partially obscured by the other, then
    we'd see the depth stencil in action, making the front cube actually get drawn
    in front as we want.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中我们只有一个对象，所以我们实际上看不到深度模板的作用。如果我们有两个立方体，其中一个部分被另一个遮挡，那么我们就会看到深度模板的作用，使得前面的立方体实际上按照我们的意愿被绘制在前面。
- en: With that done, we need to initialize our constant buffers now, so that we can
    communicate various bits of information to the graphics card, such as our projection
    and view matrices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在需要初始化我们的常量缓冲区，以便我们可以将各种信息传达给显卡，例如我们的投影和视图矩阵。
- en: Initializing the constant buffers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化常量缓冲区
- en: 'Next we will create the `InitConstantBuffers()` method to initialize our constant
    buffers:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`InitConstantBuffers()`方法来初始化我们的常量缓冲区：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this method, we start by creating a `BufferDescription`. In this case, all
    three of our constant buffers will be the same size (64 bytes), which means we
    can get away with using just this one `BufferDescription` to create all three
    buffers. We set its `ResourceUsage` property to `default` and its `BindFlags`
    property to `BindFlags.ConstantBuffer` since we want to use these buffers as constant
    buffers. We set the `CpuAccessFlags` property to `None` once again, and the `SizeInBytes`
    property we set to `64` since that's the size we need our constant buffers to
    be. The reason is that in this demo, each of these buffers will simply hold a
    single 4 x 4 matrix, which takes 64 bytes of memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先创建一个`BufferDescription`。在这种情况下，我们所有的三个常量缓冲区都将具有相同的大小（64字节），这意味着我们可以只使用这个`BufferDescription`来创建所有三个缓冲区。我们将它的`ResourceUsage`属性设置为`default`，将`BindFlags`属性设置为`BindFlags.ConstantBuffer`，因为我们想将这些缓冲区用作常量缓冲区。我们再次将`CpuAccessFlags`属性设置为`None`，并将`SizeInBytes`属性设置为`64`，因为这是我们需要的常量缓冲区的大小。原因是，在这个演示中，这些缓冲区中的每一个将简单地存储一个4
    x 4的矩阵，这需要64字节的内存。
- en: The next three lines of code create each of our three constant buffers. Then,
    the next block of code creates a `DataStream` object and stores it in our `m_DataStream`
    member variable so we can re-use it. Then we set the position of the data stream
    to `0` so that we start writing at the beginning of it. Next, we write the transpose
    of the projection matrix into the data stream and reset its position back to `0`
    again. The last line is slightly complex, but it simply sends the data in the
    data stream into the `m_CbChangesOnResize` constant buffer to make it available
    to the graphics pipeline. The details of how this line actually works are beyond
    the scope of this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行代码创建了我们的三个常量缓冲区中的每一个。然后，下一块代码创建了一个`DataStream`对象，并将其存储在我们的`m_DataStream`成员变量中，以便我们可以重用它。然后我们将数据流的定位设置为`0`，以便我们从它的开始处写入。接下来，我们将投影矩阵的转置写入数据流，并将其位置重置回`0`。最后一行稍微复杂一些，但它只是将数据流中的数据发送到`m_CbChangesOnResize`常量缓冲区，使其对图形管道可用。这一行实际工作细节超出了本章的范围。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that we didn't create our `DataStream` object in a `using`
    block this time. The reason is that we continue to use it throughout the life
    of the program, so we can't dispose of it here, or else the demo would crash!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这次我们没有在`using`块中创建我们的`DataStream`对象。原因是我们在整个程序的生命周期中继续使用它，所以我们不能在这里销毁它，否则演示会崩溃！
- en: The next set of code does the same thing, but for the view matrix, sending it
    into the `m_CbChangesPerFrame` constant buffer. And lastly, the final three lines
    in this method tell the vertex shader to use our three new constant buffers. As
    you can see, we put each constant buffer in its own slot; hence, the second parameter
    increments by one in each line. This parameter specifies which slot to set the
    constant buffer to.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码执行同样的操作，但针对视图矩阵，将其发送到`m_CbChangesPerFrame`常量缓冲区。最后，这个方法中的最后三行告诉顶点着色器使用我们新的三个常量缓冲区。正如你所见，我们将每个常量缓冲区放入它自己的槽中；因此，每一行的第二个参数递增。这个参数指定了将常量缓冲区设置到哪个槽中。
- en: We are now ready to initialize our scene and create our cube!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备初始化场景并创建我们的立方体！
- en: Initializing the scene
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化场景
- en: 'A lot of the code for this method is the same as before, so we won''t show
    it all here. At the top of this method, we add some new code to initialize the
    projection and view matrices:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的很多代码与之前相同，所以我们不会在这里展示所有代码。在这个方法的顶部，我们添加了一些新的代码来初始化投影和视图矩阵：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line creates the projection matrix. The projection matrix is analogous
    to choosing a type of lens for the camera. The four parameters we pass into the
    `Matrix.PerspectiveFovLH()` method set the vertical field of view, the aspect
    ratio, and the **near clipping plane** and **far clipping plane** distances. The
    `Fov` part in the method name is, of course, short for field of view. The `LH`
    part indicates that this is the method to use if you are working in a left-handed
    coordinate system. We are using a left-handed coordinate system in this demo because
    video games generally use the left-handed coordinate system. There is, of course,
    another version of this method that ends in `RH` for use in right-handed coordinate
    systems. For a more in-depth look at these two types of coordinate systems, take
    a look at this article on Microsoft's MSDN website [http://msdn.microsoft.com/en-us/library/windows/desktop/bb324490(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/bb324490(v=vs.85).aspx).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了投影矩阵。投影矩阵类似于为相机选择一种镜头类型。我们传递给`Matrix.PerspectiveFovLH()`方法的四个参数设置了垂直视野、宽高比以及**近裁剪面**和**远裁剪面**的距离。《Fov》部分在方法名称中当然是视野的缩写。《LH》部分表示如果你在一个左手坐标系中工作，这是你应该使用的方法。在这个演示中，我们使用左手坐标系，因为视频游戏通常使用左手坐标系。当然，还有另一个以`RH`结尾的方法，用于右手坐标系。要深入了解这两种类型的坐标系，请查看微软MSDN网站上的这篇文章
    [http://msdn.microsoft.com/en-us/library/windows/desktop/bb324490(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/bb324490(v=vs.85).aspx)。
- en: Clipping is the removing of objects from the render list that don't need to
    be drawn in the current frame—generally because they are not visible anyway. This
    provides performance benefits and is necessary since trying to render everything
    in your 3D world is not practical unless it happens to be a very small world.
    Trying to do so may result in very low frame rates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪是从渲染列表中移除不需要在当前帧中绘制的物体——通常是因为它们无论如何都是不可见的。这提供了性能上的好处，并且是必要的，因为试图渲染你3D世界中的所有内容并不实际，除非它碰巧是一个非常小的世界。这样做可能会导致非常低的帧率。
- en: The near clipping plane is the minimum distance an object must be from the camera
    to be rendered. If an object is closer to the camera than this, it will not be
    rendered. This can prevent objects from being partially rendered if the player
    gets too close to them. Likewise, the far clipping plane is the maximum distance
    an object can be from the camera and still be drawn. An object farther away than
    this will not be drawn. Note that Direct3D takes care of basic clipping for us.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 近裁剪面是指物体必须与相机保持的最小距离，才能被渲染。如果一个物体比这个距离更靠近相机，它将不会被渲染。这可以防止玩家离物体太近时物体被部分渲染。同样，远裁剪面是指物体可以离相机多远仍然可以被绘制。超过这个距离的物体将不会被绘制。请注意，Direct3D会为我们处理基本的裁剪。
- en: The next bit of code creates the view matrix using the `Matrix.LookAtLH()` method.
    The three parameters we pass in are all `Vector3` objects. The first one is the
    position of the camera (in other words, the player's viewpoint) in 3D space. The
    second parameter is the coordinates for the camera to look at. And the last parameter
    is simply a vector that specifies which way is up in our 3D world. We are using
    the positive y axis as the vertical axis here, which is what you'll use most of
    the time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码使用`Matrix.LookAtLH()`方法创建视图矩阵。我们传递的三个参数都是`Vector3`对象。第一个是相机（换句话说，玩家的视点）在3D空间中的位置。第二个参数是相机要看的坐标。最后一个参数是一个向量，指定了在3D世界中向上是哪个方向。在这里，我们使用正y轴作为垂直轴，这是你大多数时候会使用的。
- en: Under this code, we have new vertex data, but it is far too big to show here,
    so check out the downloadable code to see it. It specifies a position, color,
    and texture coordinates for each vertex, which is a big departure from our previous
    demo that only had a position for each vertex. This means that the input elements
    array will be very different this time too. Again, check out the downloadable
    code to see this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码下方，我们有新的顶点数据，但它太大，无法在这里显示，所以请查看可下载的代码以查看它。它指定了每个顶点的位置、颜色和纹理坐标，这与我们之前的演示有很大的不同，之前的演示只为每个顶点提供了位置。这意味着这次输入元素数组也会非常不同。同样，请查看可下载的代码以查看这一点。
- en: 'Lastly, we need to add this code to the bottom of this method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将以下代码添加到这个方法的底部：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the first line loads our cube texture. As mentioned before,
    this is just the red brick tile from our 2D demo back in [Chapter 3](ch03.html
    "Chapter 3. Rendering 2D Graphics"), *Rendering 2D Graphics* . Next, we create
    a sampler description, which we will use to create a sampler state to use with
    our cube texture. Most of the properties of the `SamplerDescription` are beyond
    the scope of this text. And finally, the last line creates a `SamplerState` for
    our cube texture. Now that our cube texture is set up, we are ready to update
    the scene in our `UpdateScene()` method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第一行加载了我们的立方体纹理。如前所述，这只是我们2D演示中的红色砖块瓦片，来自[第3章](ch03.html "第3章。渲染2D图形")，*渲染2D图形*。接下来，我们创建一个采样器描述，我们将使用它来创建用于我们的立方体纹理的采样器状态。`SamplerDescription`的大多数属性超出了本文的范围。最后，最后一行为我们立方体纹理创建了一个`SamplerState`。现在，我们的立方体纹理已经设置好，我们就可以在`UpdateScene()`方法中更新场景了。
- en: Updating the scene
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新场景
- en: 'Next, we need to modify our `UpdateScene()` method. First, we need to add the
    following code after the `if` statement at the top of this method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的`UpdateScene()`方法。首先，我们需要在方法顶部的`if`语句之后添加以下代码：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we increment the `m_CubeRotation` variable to increase the cube's rotation
    slightly for this frame. Note that this rotation value is in radians, not degrees.
    The `if` statement resets this variable to `0` when it gets too large. Over many
    frames, this causes the cube to rotate.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们增加`m_CubeRotation`变量的值，以略微增加这个帧中立方体的旋转。请注意，这个旋转值是以弧度为单位的，而不是以度为单位。当这个变量太大时，`if`语句将其重置为`0`。在许多帧中，这会导致立方体旋转。
- en: 'Below that, we will add the following `if` statement:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，我们将添加以下`if`语句：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `if` statement checks if the player has pressed the up arrow key or the
    *W* key. If so, we increase the camera's position on the z axis. Then, below this
    we would add another `if` statement that does the same for moving backwards if
    you press the down arrow key or the *D* key. If you have pressed one of these
    keys, it will decrease the camera's position on the z axis. Check out the downloadable
    code for this chapter to see this code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`语句检查玩家是否按下了上箭头键或*W*键。如果是这样，我们将增加相机在z轴上的位置。然后，在这个下面，我们会添加另一个`if`语句，如果你按下下箭头键或*D*键，它将执行相同的向后移动。如果你按下了这些键之一，它将减少相机在z轴上的位置。请查看本章的可下载代码以查看此代码。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that `UserInput` is a variable defined by our `GameWindow` base class,
    which provides access to its `UserInput` object that we created in [Chapter 2](ch02.html
    "Chapter 2. Responding to Player Inputs"), *Responding to Player Inputs*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`UserInput`是我们`GameWindow`基类定义的变量，它提供了对其`UserInput`对象的访问，我们在[第2章](ch02.html
    "第2章。响应玩家输入")，*响应玩家输入*中创建了它。
- en: 'You may notice that the camera acts a bit oddly if you move forward until you
    pass the cube. This is just because the camera is effectively locked on to the
    cube. If you try to add controls for moving left/right or up/down, you will notice
    the camera will act a bit oddly for this same reason when you move it in those
    directions. The camera auto-rotates so that it is always looking towards the cube,
    no matter where you move it. The next block of code recreates the view matrix,
    and then sends that data into the `m_CbChangesPerFrame` constant buffer. We need
    to update the view matrix every time the camera moves. The following is that code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，如果您向前移动直到超过立方体，相机会表现得有点奇怪。这仅仅是因为相机实际上被锁定在立方体上。如果您尝试添加左右或上下移动的控制，您会注意到当您向这些方向移动时，相机会因为相同的原因表现得有点奇怪。相机会自动旋转，使其始终朝向立方体，无论您将其移动到何处。下一块代码重新创建视图矩阵，然后将这些数据发送到`m_CbChangesPerFrame`常量缓冲区。我们需要在每次相机移动时更新视图矩阵。以下就是那段代码：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, we update the cube''s rotation matrix with the new value in the `m_CubeRotation`
    variable that we updated at the top of this method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将立方体的旋转矩阵更新为新值，这个值位于我们在此方法顶部更新的`m_CubeRotation`变量中：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first parameter of the `Matrix.RotationAxis()` method is `Vector3` specifying
    the axis we want the cube to rotate around. The second parameter is our rotation
    amount in radians, which is in our `m_CubeRotation` member variable. And finally
    we update the cube's world matrix with the new rotation matrix we just created.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix.RotationAxis()`方法的第一个参数是`Vector3`，指定了立方体要围绕其旋转的轴。第二个参数是我们以弧度表示的旋转量，它位于我们的`m_CubeRotation`成员变量中。最后，我们使用我们刚刚创建的新旋转矩阵更新立方体的世界矩阵。'
- en: Rendering the scene
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染场景
- en: 'We have one last thing to change and we should be ready to run the program.
    We need to change the code in our `RenderScene()` method to draw the cube. After
    the line that clears the screen, we add the following line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一件事要更改，然后我们就可以运行程序了。我们需要更改`RenderScene()`方法中的代码来绘制立方体。在清除屏幕的行之后，我们添加以下行：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This line clears the depth stencil texture, so it is empty before we start
    rendering this frame. Then below this, we need to add the following block of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这行清除深度模板纹理，因此在开始渲染这一帧之前它是空的。然后在此之下，我们需要添加以下代码块：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two lines set our cube texture as a resource on the pixel shader so
    that it can use it. The second line sets the sampler state to use with it. Then
    the next block of code uses our `DataStream` to send the updated information for
    our cube into the `m_CbChangesPerObject` constant buffer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行将我们的立方体纹理设置为像素着色器上的资源，以便它可以使用它。第二行设置用于它的采样状态。然后下一块代码使用我们的`DataStream`将立方体的更新信息发送到`m_CbChangesPerObject`常量缓冲区。
- en: 'Now we need to change the line that calls the `Draw()` method on the `DeviceContext`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更改调用`DeviceContext`上的`Draw()`方法的行：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we've changed it to draw 36 vertices now. This is because our
    cube has 36 vertices. But a cube only has eight corners, right? Well, each corner
    vertex is duplicated for each side it is shared by. You can avoid this somewhat
    by using the `TriangleStrip` primitive topology rather than `TriangleList` as
    we've used here and by using index buffers as discussed earlier in this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在改为绘制36个顶点。这是因为我们的立方体有36个顶点。但一个立方体只有八个角，对吧？嗯，每个角顶点都会被它所共享的每一面重复。您可以通过使用我们这里使用的`TriangleList`而不是`TriangleStrip`原语拓扑，以及使用本章前面讨论过的索引缓冲区来避免这种情况。
- en: 'As always, don''t forget to edit the `Dispose(bool)` method, and make sure
    it disposes of all of our disposable objects. The following are some examples
    of the program running in all three of our graphics modes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，不要忘记编辑`Dispose(bool)`方法，并确保它释放了所有可释放的对象。以下是一些程序在所有三种图形模式下的运行示例：
- en: '![Rendering the scene](img/7389_05_02.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![渲染场景](img/7389_05_02.jpg)'
- en: The cube demo in all three graphics modes
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种图形模式下的立方体演示
- en: The first part of the previous diagram shows the program when you set `m_GraphicsMode`
    to `GraphicsMode.SolidBlue`. The second image shows `GraphicsMode.PerVertexColoring`,
    and the last image shows `GraphicsMode.Textured`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图的第一部分显示了当将`m_GraphicsMode`设置为`GraphicsMode.SolidBlue`时的程序。第二张图显示了`GraphicsMode.PerVertexColoring`，最后一张图显示了`GraphicsMode.Textured`。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we dived into the world of 3D graphics. It's a very complicated
    subject, but we drew a blue triangle on the screen in our first demo, where we
    looked at the basics of setting up a Direct3D application. Then, we started work
    on our cube demo, where we introduced the concepts of depth stencils and constant
    buffers. We gave this demo three graphics modes that you can run it in by changing
    the value of the `m_GraphicsMode` member variable in the `CubeGameWindow` class.
    In the next chapter, we'll take a look at a few other topics briefly and discuss
    where to go from here in learning the art of game programming.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探索了3D图形的世界。这是一个非常复杂的话题，但在我们的第一个演示中，我们在屏幕上绘制了一个蓝色三角形，那时我们学习了设置Direct3D应用程序的基础。然后，我们开始制作我们的立方体演示，其中我们介绍了深度模板和常量缓冲区等概念。我们为这个演示提供了三种图形模式，您可以通过更改`CubeGameWindow`类中的`m_GraphicsMode`成员变量的值来运行它。在下一章中，我们将简要地探讨几个其他主题，并讨论在游戏编程艺术的学习中下一步该走向何方。
