<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. IR to Selection DAG phase</h1></div></div></div><p class="calibre7">Until the previous chapter, we saw how a frontend language can be converted to LLVM IR. We also saw how IR can be transformed into more optimized code. After a series of analysis and transformation passes, the final IR is the most optimized machine independent code. However, the IR is still an abstract representation of the actual machine code. The compiler has to generate target architecture code for execution.</p><p class="calibre7">LLVM uses DAG—a directed acyclic graph representation for code generation. The idea is to convert IR into a <code class="email">SelectionDAG</code> and then go over a series of phases—DAG combine, legalization, instruction selection, instruction scheduling, etc—to finally allocate registers and emit machine code. Note that register allocation and instruction scheduling take place in an intertwined manner.</p><p class="calibre7">We are going to cover following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Converting IR to selectionDAG</li><li class="listitem">Legalizing selectionDAG</li><li class="listitem">Optimizing selectionDAG</li><li class="listitem">Instruction selection</li><li class="listitem">Scheduling and emitting machine instructions</li><li class="listitem">Register allocation</li><li class="listitem">Code emission</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec40" class="calibre1"/>Converting IR to selectionDAG</h1></div></div></div><p class="calibre7">An IR instruction can be<a id="id205" class="calibre1"/> represented by an SDAG node. The whole <a id="id206" class="calibre1"/>set of instructions thus forms an interconnected directed acyclic graph, with each node corresponding to an IR instruction.</p><p class="calibre7">For example, consider the following LLVM IR:</p><div><pre class="programlisting">
<strong class="calibre2">$ cat test.ll</strong>
<strong class="calibre2">define i32 @test(i32 %a, i32 %b, i32 %c) {</strong>
<strong class="calibre2">%add = add nsw i32 %a, %b</strong>
<strong class="calibre2">%div = sdiv i32 %add, %c</strong>
<strong class="calibre2">ret i32 %div</strong>
<strong class="calibre2">}</strong>
</pre></div><p class="calibre7">LLVM provides a <code class="email">SelectionDAGBuilder</code> interface to create DAG nodes corresponding to IR instructions. Consider the binary operation:</p><div><pre class="programlisting">
<strong class="calibre2"> %add = add nsw i32 %a, %b</strong>
</pre></div><p class="calibre7">The following function is called when the given IR is encountered:</p><div><pre class="programlisting">void SelectionDAGBuilder::visit(unsigned Opcode, const User &amp;I) {
  // Note: this doesn't use InstVisitor, because it has to work with
  // ConstantExpr's in addition to instructions.
  switch (Opcode) {
  default: llvm_unreachable("Unknown instruction type encountered!");
    // Build the switch statement using the Instruction.def file.
#define HANDLE_INST(NUM, OPCODE, CLASS) \
    case Instruction::OPCODE: visit##OPCODE((const CLASS&amp;)I); break;
#include "llvm/IR/Instruction.def"
  }
}</pre></div><p class="calibre7">Depending on the<a id="id207" class="calibre1"/> opcode—which is <code class="email">Add</code> here—the corresponding visit<a id="id208" class="calibre1"/> function is invoked. In this case, <code class="email">visitAdd()</code> is invoked, which further invokes the <code class="email">visitBinary()</code> function. The <code class="email">visitBinary()</code> function is as follows:</p><div><pre class="programlisting">void SelectionDAGBuilder::visitBinary(const User &amp;I, unsigned OpCode) {
<strong class="calibre2">  SDValue Op1 = getValue(I.getOperand(0));</strong>
<strong class="calibre2">  SDValue Op2 = getValue(I.getOperand(1));</strong>

  bool nuw = false;
  bool nsw = false;
  bool exact = false;
  FastMathFlags FMF;

  if (const OverflowingBinaryOperator *OFBinOp =
          dyn_cast&lt;const OverflowingBinaryOperator&gt;(&amp;I)) {
    nuw = OFBinOp-&gt;hasNoUnsignedWrap();
    nsw = OFBinOp-&gt;hasNoSignedWrap();
  }
  if (const PossiblyExactOperator *ExactOp =
          dyn_cast&lt;const PossiblyExactOperator&gt;(&amp;I))
    exact = ExactOp-&gt;isExact();
  if (const FPMathOperator *FPOp = dyn_cast&lt;const FPMathOperator&gt;(&amp;I))
    FMF = FPOp-&gt;getFastMathFlags();

  SDNodeFlags Flags;
  Flags.setExact(exact);
  Flags.setNoSignedWrap(nsw);
  Flags.setNoUnsignedWrap(nuw);
  if (EnableFMFInDAG) {
    Flags.setAllowReciprocal(FMF.allowReciprocal());
    Flags.setNoInfs(FMF.noInfs());
    Flags.setNoNaNs(FMF.noNaNs());
    Flags.setNoSignedZeros(FMF.noSignedZeros());
    Flags.setUnsafeAlgebra(FMF.unsafeAlgebra());
  }
<strong class="calibre2">  SDValue BinNodeValue = DAG.getNode(OpCode, getCurSDLoc(), Op1.getValueType(), Op1, Op2, &amp;Flags);</strong>
  setValue(&amp;I, BinNodeValue);
}</pre></div><p class="calibre7">This function <a id="id209" class="calibre1"/>takes two operands of the binary operator from IR and <a id="id210" class="calibre1"/>stores them into <code class="email">SDValue</code> type. Then it invokes the <code class="email">DAG.getNode()</code> function with opcode of the binary operator. This results in formation of a DAG node, which somewhat looks like the following:</p><div><img src="img/00009.jpeg" alt="Converting IR to selectionDAG" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">The operands <code class="email">0</code> and <code class="email">1</code> are load DAG nodes.</p><p class="calibre7">Consider the IR:</p><div><pre class="programlisting">
<strong class="calibre2">%div = sdiv i32 %add, %c</strong>
</pre></div><p class="calibre7">On encountering the <code class="email">sdiv</code> instruction, the function <code class="email">visitSDiv()</code> is invoked.</p><div><pre class="programlisting">void SelectionDAGBuilder::visitSDiv(const User &amp;I) {
  SDValue Op1 = getValue(I.getOperand(0));
  SDValue Op2 = getValue(I.getOperand(1));

  SDNodeFlags Flags;
  Flags.setExact(isa&lt;PossiblyExactOperator&gt;(&amp;I) &amp;&amp;
                 cast&lt;PossiblyExactOperator&gt;(&amp;I)-&gt;isExact());
  setValue(&amp;I, DAG.getNode(ISD::SDIV, getCurSDLoc(), Op1.getValueType(), Op1, Op2, &amp;Flags));
}</pre></div><p class="calibre7">Similar to <code class="email">visitBinary()</code>, this function also stores the two operands into <code class="email">SDValue</code> gets a DAG node with <code class="email">ISD::SDIV</code> as its operator. The node looks like the following:</p><div><img src="img/00010.jpeg" alt="Converting IR to selectionDAG" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">In our IR, the<a id="id211" class="calibre1"/> operand 0 is <code class="email">%add</code>. Operand <code class="email">1</code> is <code class="email">%c</code>, which is passed as<a id="id212" class="calibre1"/> an argument to the function, which transforms to a load node when converting IR to <code class="email">SelectionDAG</code>. For implementation of Load DAG node, go through the <code class="email">visitLoad()</code> function in the <code class="email">lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp</code> file.</p><p class="calibre7">After visiting all the IR instructions mentioned earlier, finally the IR is converted to <code class="email">SelectionDAG</code> as follows:</p><div><img src="img/00011.jpeg" alt="Converting IR to selectionDAG" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">In the <a id="id213" class="calibre1"/>preceding diagram, note the following:</p><div><ul class="itemizedlist"><li class="listitem">Black <a id="id214" class="calibre1"/>arrows mean data flow dependency</li><li class="listitem">Red arrows mean glue dependency</li><li class="listitem">Blue dashed arrows mean chain dependency</li></ul></div><p class="calibre7">Glue prevents the two nodes from being broken up during scheduling. Chain dependencies prevent nodes with side effects. A data dependency indicates when an instruction depends on the result of a previous instruction.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec41" class="calibre1"/>Legalizing SelectionDAG</h1></div></div></div><p class="calibre7">In the preceding topic, we <a id="id215" class="calibre1"/>saw how an IR is converted to <code class="email">SelectionDAG</code>. The whole process didn't involve any knowledge of target architecture for which we are trying to generate code. A DAG node might be illegal for the given target architecture. For example, the X86 architecture doesn't support the <code class="email">sdiv</code> instruction. Instead, it supports <code class="email">sdivrem</code> instruction. This target specific information is conveyed to the <code class="email">SelectionDAG</code> phase by the <code class="email">TargetLowering</code> interface. Targets implement this interface to describe how LLVM IR instructions should be lowered to legal <code class="email">SelectionDAG</code> operations.</p><p class="calibre7">In our IR case, we need to 'expand' the <code class="email">sdiv</code> instruction to <code class="email">'sdivrem'</code> instruction. In the function void <code class="email">SelectionDAGLegalize::LegalizeOp(SDNode *Node)</code>, the <code class="email">TargetLowering::Expand</code> case is encountered, which invokes the <code class="email">ExpandNode()</code> function call on that particular node.</p><div><pre class="programlisting">void SelectionDAGLegalize::LegalizeOp(SDNode *Node){
…
…
case TargetLowering::Expand:
      ExpandNode(Node);
      return;
…
…
}</pre></div><p class="calibre7">This function expands SDIV into the SDIVREM node:</p><div><pre class="programlisting">case ISD::SDIV: {
    bool isSigned = Node-&gt;getOpcode() == ISD::SDIV;
    unsigned DivRemOpc = isSigned ? ISD::SDIVREM : ISD::UDIVREM;
    EVT VT = Node-&gt;getValueType(0);
    SDVTList VTs = DAG.getVTList(VT, VT);
    if (TLI.isOperationLegalOrCustom(DivRemOpc, VT) ||
        (isDivRemLibcallAvailable(Node, isSigned, TLI) &amp;&amp;
         useDivRem(Node, isSigned, true)))
      Tmp1 = DAG.getNode(DivRemOpc, dl, VTs, Node-&gt;getOperand(0),
                         Node-&gt;getOperand(1));
    else if (isSigned)
      Tmp1 = ExpandIntLibCall(Node, true,
                              RTLIB::SDIV_I8,
                              RTLIB::SDIV_I16, RTLIB::SDIV_I32,
                              RTLIB::SDIV_I64, RTLIB::SDIV_I128);
    else
      Tmp1 = ExpandIntLibCall(Node, false,
                              RTLIB::UDIV_I8,
                              RTLIB::UDIV_I16, RTLIB::UDIV_I32,
                              RTLIB::UDIV_I64, RTLIB::UDIV_I128);
    Results.push_back(Tmp1);
    break;
  }</pre></div><p class="calibre7">Finally, after legalization, the node becomes <code class="email">ISD::SDIVREM</code>:</p><div><img src="img/00012.jpeg" alt="Legalizing SelectionDAG" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">Thus the above instruction has been '<code class="email">legalized</code>' mapping to the instruction supported on the target architecture. What we saw above was an example of expand legalization. There are two other types of legalization—promotion and custom. A promotion promotes one type to a larger type. A custom legalization involves target-specific hook (maybe a custom operation—majorly <a id="id216" class="calibre1"/>seen with IR intrinsic). We leave it to the readers to explore these more in the <code class="email">CodeGen</code> phase.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Optimizing SelectionDAG</h1></div></div></div><p class="calibre7">After converting the IR<a id="id217" class="calibre1"/> into <code class="email">SelectionDAG</code>, many opportunities may arise to optimize the DAG itself. These optimization takes place in the <code class="email">DAGCombiner</code> phase. These opportunities may arise due to set of architecture specific instructions.</p><p class="calibre7">Let's take an example:</p><div><pre class="programlisting">#include &lt;arm_neon.h&gt;
unsigned hadd(uint32x4_t a) {
  return a[0] + a[1] + a[2] + a[3];
}</pre></div><p class="calibre7">The preceding example in IR looks like the following:</p><div><pre class="programlisting">define i32 @hadd(&lt;4 x i32&gt; %a) nounwind {
  %vecext = extractelement &lt;4 x i32&gt; %a, i32 3
  %vecext1 = extractelement &lt;4 x i32&gt; %a, i32 2
  %add = add i32 %vecext, %vecext1
  %vecext2 = extractelement &lt;4 x i32&gt; %a, i32 1
  %add3 = add i32 %add, %vecext2
  %vecext4 = extractelement &lt;4 x i32&gt; %a, i32 0
  %add5 = add i32 %add3, %vecext4
  ret i32 %add5
}</pre></div><p class="calibre7">The example is basically extracting single element from a vector of <code class="email">&lt;4xi32&gt;</code> and adding each element of the vector to give a scalar result.</p><p class="calibre7">Advanced architectures such as ARM has one single instruction to do the preceding operation—adding across single vector. The SDAG needs to be combined into a single DAG node by identifying the preceding pattern in <code class="email">SelectionDAG</code>.</p><p class="calibre7">This can be done while <a id="id218" class="calibre1"/>selecting instruction in <code class="email">AArch64DAGToDAGISel</code>.</p><div><pre class="programlisting"> SDNode *AArch64DAGToDAGISel::Select(SDNode *Node) {
…
…
  case ISD::ADD: {
     if (SDNode *I = SelectMLAV64LaneV128(Node))
       return I;
    <strong class="calibre2">if (SDNode *I = SelectADDV(Node))</strong>
<strong class="calibre2">      return I;</strong>
     break;
  }
}</pre></div><p class="calibre7">We define the <code class="email">SelectADDV()</code> function as follows:</p><div><pre class="programlisting">SDNode *AArch64DAGToDAGISel::SelectADDV(SDNode *N) {
  if (N-&gt;getValueType(0) != MVT::i32)
    return nullptr;
  SDValue SecondAdd;
  SDValue FirstExtr;
  if (!<strong class="calibre2">checkVectorElemAdd</strong>(N, SecondAdd, FirstExtr))
    return nullptr;

  SDValue Vector = FirstExtr.getOperand(0);
  if (Vector.getValueType() != MVT::v4i32)
    return nullptr;

  uint64_t LaneMask = 0;
  ConstantSDNode *LaneNode = cast&lt;ConstantSDNode&gt;(FirstExtr-&gt;getOperand(1));
  LaneMask |= 1 &lt;&lt; LaneNode-&gt;getZExtValue();

  SDValue ThirdAdd;
  SDValue SecondExtr;
  if (!checkVectorElemAdd(SecondAdd.getNode(), ThirdAdd, SecondExtr))
    return nullptr;
  if (Vector != SecondExtr.getOperand(0))
    return nullptr;
  ConstantSDNode *LaneNode2 = cast&lt;ConstantSDNode&gt;(SecondExtr-&gt;getOperand(1));
  LaneMask |= 1 &lt;&lt; LaneNode2-&gt;getZExtValue();
  SDValue LHS = ThirdAdd.getOperand(0);
  SDValue RHS = ThirdAdd.getOperand(1);
  if (LHS.getOpcode() != ISD::EXTRACT_VECTOR_ELT ||
      RHS.getOpcode() != ISD::EXTRACT_VECTOR_ELT ||
      LHS.getOperand(0) != Vector ||
      RHS.getOperand(0) != Vector)
    return nullptr;
  ConstantSDNode *LaneNode3 = cast&lt;ConstantSDNode&gt;(LHS-&gt;getOperand(1));
  LaneMask |= 1 &lt;&lt; LaneNode3-&gt;getZExtValue();
  ConstantSDNode *LaneNode4 = cast&lt;ConstantSDNode&gt;(RHS-&gt;getOperand(1));
  LaneMask |= 1 &lt;&lt; LaneNode4-&gt;getZExtValue();
  if (LaneMask != 0x0F)
    return nullptr;
  return CurDAG-&gt;getMachineNode(AArch64::ADDVv4i32v, SDLoc(N), MVT::i32,
                                Vector);
}</pre></div><p class="calibre7">Note that we have defined a helper function <code class="email">checkVectorElemAdd()</code> earlier to check the chain of add <a id="id219" class="calibre1"/>selection DAG nodes.</p><div><pre class="programlisting">static bool checkVectorElemAdd(SDNode *N, SDValue &amp;Add, SDValue &amp;Extr) {
  SDValue Op0 = N-&gt;getOperand(0);
  SDValue Op1 = N-&gt;getOperand(1);
  const unsigned Opc0 = Op0-&gt;getOpcode();
  const unsigned Opc1 = Op1-&gt;getOpcode();

  const bool AddLeft  = (Opc0 == ISD::ADD &amp;&amp; Opc1 == ISD::EXTRACT_VECTOR_ELT);
  const bool AddRight = (Opc0 == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Opc1 == ISD::ADD);

  if (!(AddLeft || AddRight))
    return false;

  Add  = AddLeft ? Op0 : Op1;
  Extr = AddLeft ? Op1 : Op0;
  return true;
}</pre></div><p class="calibre7">Let's see how this affects the code generation:</p><div><pre class="programlisting">
<strong class="calibre2">$ llc -mtriple=aarch64-linux-gnu -verify-machineinstrs hadd.ll</strong>
</pre></div><p class="calibre7">Before the preceding code, the final code generated will be as follows:</p><div><pre class="programlisting">  mov  w8, v0.s[3]
  mov  w9, v0.s[2]
  add  w8, w8, w9
  mov  w9, v0.s[1]
  add  w8, w8, w9
  fmov  w9, s0
  add  w0, w8, w9
  ret</pre></div><p class="calibre7">Clearly, the <a id="id220" class="calibre1"/>preceding code is a scalar code. After adding the preceding patch and compiling, the code generated will be as follows:</p><div><pre class="programlisting">  addv  s0, v0.4s
  fmov  w0, s0
  ret</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Instruction Selection</h1></div></div></div><p class="calibre7">The <code class="email">SelectionDAG</code> at this phase is <a id="id221" class="calibre1"/>optimized and legalized. However, the instructions are still not in machine code form. These instructions need to be mapped to architecture-specific instructions in the <code class="email">SelectionDAG</code> itself. The <code class="email">TableGen</code> class helps select target-specific instructions.</p><p class="calibre7">The <code class="email">CodeGenAndEmitDAG()</code> function calls the <code class="email">DoInstructionSelection()</code> function that visits each DAG node and calls the Select() function for each node. The <code class="email">Select()</code> function is the main hook targets implement to select a node. The <code class="email">Select()</code> function is a virtual method to be implemented by the targets.</p><p class="calibre7">For consideration, assume our target architecture is X86. The <code class="email">X86DAGToDAGISel::Select()</code> function intercepts some nodes for manual matching, but delegates the bulk of the work to the <code class="email">X86DAGToDAGISel::SelectCode()</code> function. The <code class="email">X86DAGToDAGISel::SelectCode()</code> function is auto generated by <code class="email">TableGen</code>. It contains the matcher table, followed by a call to the generic <code class="email">SelectionDAGISel::SelectCodeCommon()</code> function, passing it the table.</p><div><pre class="programlisting">SDNode *ResNode = SelectCode(Node);</pre></div><p class="calibre7">For example, consider the following:</p><div><pre class="programlisting">
<strong class="calibre2">$ cat test.ll</strong>
<strong class="calibre2">define i32 @test(i32 %a, i32 %b, i32 %c) {</strong>
<strong class="calibre2">%add = add nsw i32 %a, %b</strong>
<strong class="calibre2">%div = sdiv i32 %add, %c</strong>
<strong class="calibre2">ret i32 %div</strong>
<strong class="calibre2">}</strong>
</pre></div><p class="calibre7">Before <a id="id222" class="calibre1"/>instruction selection, the SDAG looks like the following:</p><div><pre class="programlisting">
<strong class="calibre2">$ llc –view-isel-dags test.ll</strong>
</pre></div><div><img src="img/00013.jpeg" alt="Instruction Selection" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">After Instruction Selection, SDAG looks like the following:</p><div><pre class="programlisting">
<strong class="calibre2">$ llc –view-sched-dags test.ll</strong>
</pre></div><div><img src="img/00014.jpeg" alt="Instruction Selection" class="calibre9"/></div><p class="calibre10"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Scheduling and emitting machine instructions</h1></div></div></div><p class="calibre7">Until now, we have been <a id="id223" class="calibre1"/>performing the operations on DAG. Now, for the<a id="id224" class="calibre1"/> machine to execute, we need to convert the DAGs into instruction that the machine can execute. One step towards it is emitting the list of instructions into <code class="email">MachineBasicBlock</code>. This is done by the <code class="email">Scheduler</code>, whose goal is to linearize the DAGs. The scheduling is dependent on the target architecture, as certain Targets will have target specific hooks which can affect the scheduling.</p><p class="calibre7">The class <code class="email">InstrEmitter::EmitMachineNode</code> takes <code class="email">SDNode *Node</code> as one of the input parameters for which it will be emitting machine instructions of the class <code class="email">MachineInstr</code>. These instructions are emitted into a <code class="email">MachineBasicBlock</code>.</p><p class="calibre7">The function calls <code class="email">EmitSubregNode</code>, <code class="email">EmitCopyToRegClassNode</code> and <code class="email">EmitRegSequence</code> for the handling of <code class="email">subreg</code> insert/extract, <code class="email">COPY_TO_REGCLASS</code>, and <code class="email">REG_SEQUENCE</code> respectively.</p><p class="calibre7">The call <code class="email">MachineInstrBuilder</code> <code class="email">MIB = BuildMI(*MF, Node-&gt;getDebugLoc(), II);</code> is used to build the Machine Instruction. The <code class="email">CreateVirtualRegisters</code> function is called to add result register values created by this instruction.</p><p class="calibre7">The <code class="email">for</code> loop emits the operands of the instruction :</p><div><pre class="programlisting">for (unsigned i = NumSkip; i != NodeOperands; ++i)
    AddOperand(MIB, Node-&gt;getOperand(i), i-NumSkip+NumDefs, &amp;II,
               VRBaseMap, /*IsDebug=*/false, IsClone, IsCloned);
MBB-&gt;insert(InsertPos, MIB); </pre></div><p class="calibre7">It inserts the instruction into its position in the <code class="email">MachineBasicBlock</code>.</p><p class="calibre7">The following code marks unused registers as dead:</p><div><pre class="programlisting">if (!UsedRegs.empty() || II.getImplicitDefs())
    MIB-&gt;setPhysRegsDeadExcept(UsedRegs, *TRI);</pre></div><p class="calibre7">As we had discussed earlier that the target specific hooks affect the scheduling, the code for that in this function is as follows:</p><div><pre class="programlisting">if (II.hasPostISelHook())
    TLI-&gt;AdjustInstrPostInstrSelection(MIB, Node);</pre></div><p class="calibre7">The <code class="email">AdjustInstrPostInstrSelection</code> is a virtual function implemented by Targets.</p><p class="calibre7">Let's take an <a id="id225" class="calibre1"/>example to see the machine instructions generated in <a id="id226" class="calibre1"/>this step. To do this, we need to pass the command-line option <code class="email">-print-machineinstrs</code> to the <code class="email">llc</code> tool. Let's take the same testcode used earlier:</p><div><pre class="programlisting">
<strong class="calibre2">$ cat test.ll</strong>
<strong class="calibre2">define i32 @test(i32 %a, i32 %b, i32 %c) {</strong>
<strong class="calibre2">%add = add nsw i32 %a, %b</strong>
<strong class="calibre2">%div = sdiv i32 %add, %c</strong>
<strong class="calibre2">ret i32 %div</strong>
<strong class="calibre2">}</strong>
</pre></div><p class="calibre7">Now, invoke the llc command and pass the <code class="email">–print-machineinstrs</code> to it. Pass <code class="email">test.ll</code> as the input file and store the output in the outfile:</p><div><pre class="programlisting">
<strong class="calibre2">llc -print-machineinstrs test.ll &gt; outfile 2&gt;&amp;1</strong>
</pre></div><p class="calibre7">The <code class="email">outfile</code> is large, containing many other phases of code generation apart from scheduling. We need to look into the section after "<code class="email"># After Instruction Selection:</code>" in the output file, which is as follows:</p><div><pre class="programlisting"># After Instruction Selection:
# Machine code for function test: SSA
Function Live Ins: %EDI in %vreg0, %ESI in %vreg1, %EDX in %vreg2
BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI %EDX
        %vreg2&lt;def&gt; = COPY %EDX; GR32:%vreg2
        %vreg1&lt;def&gt; = COPY %ESI; GR32:%vreg1
        %vreg0&lt;def&gt; = COPY %EDI; GR32:%vreg0
        %vreg3&lt;def,tied1&gt; = ADD32rr %vreg0&lt;tied0&gt;, %vreg1, %EFLAGS&lt;imp-def,dead&gt;; GR32:%vreg3,%vreg0,%vreg1
        %EAX&lt;def&gt; = COPY %vreg3; GR32:%vreg3
        CDQ %EAX&lt;imp-def&gt;, %EDX&lt;imp-def&gt;, %EAX&lt;imp-use&gt;
        IDIV32r %vreg2, %EAX&lt;imp-def&gt;, %EDX&lt;imp-def,dead&gt;, %EFLAGS&lt;imp-def,dead&gt;, %EAX&lt;imp-use&gt;, %EDX&lt;imp-use&gt;; GR32:%vreg2
        %vreg4&lt;def&gt; = COPY %EAX; GR32:%vreg4
        %EAX&lt;def&gt; = COPY %vreg4; GR32:%vreg4
        RETQ %EAX
# End machine code for function test.</pre></div><p class="calibre7">We can see in<a id="id227" class="calibre1"/> the output that certain places being taken by physical <a id="id228" class="calibre1"/>registers and some by virtual registers. We can also see the machine instruction <code class="email">IDIV32r</code> in the output. In the next section, we will see how physical registers are assigned to these virtual registers present in the code.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>Register allocation</h1></div></div></div><p class="calibre7">The next step of the code generator is<a id="id229" class="calibre1"/> register allocation. As we saw in the previous example, some of the registers being used were virtual registers. Register allocation is the task of assigning physical registers to these virtual registers. In LLVM, the virtual registers can be infinite in number, but the numbers of physical registers are limited depending on the target. So, by register allocation, we aim at maximizing the number of physical registers being assigned to virtual registers. We must note that the physical registers are limited in number, so it is not always possible that all the virtual registers can be assigned a physical register. If there is no physical register available at some point and we need a physical register for a variable, we might move a variable that is present in physical register to main memory and thus assign the freed register to the variable we want. This process of moving a variable from physical register to memory is called<a id="id230" class="calibre1"/> <strong class="calibre2">spilling</strong>. There are various algorithms to calculate which variable should be spilled from register to memory.</p><p class="calibre7">Another important role that the register allocator plays is SSA form deconstruction. The phi instructions present in the machine instruction till now need to be replaced with a regular instruction. The traditional way of doing so is to replace it with a copy instruction.</p><p class="calibre7">It must be noted that some of the machine fragments have already registers assigned to them. This is due to target requirements where it wants certain registers fixed to certain operations. Apart from these fixed registers, the register allocator takes care of the rest of the non-fixed registers.</p><p class="calibre7">Register allocation for mapping virtual registers to physical registers can be done in the following two ways:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Direct Mapping</strong>: It <a id="id231" class="calibre1"/>makes use of the <code class="email">TargetRegisterInfo</code> class and the <code class="email">MachineOperand</code> class. The developer in this case needs to provide the location where load and store instructions are to be inserted to get values from the memory and store values in the memory.</li><li class="listitem"><strong class="calibre2">Indirect Mapping</strong>: In <a id="id232" class="calibre1"/>this, the <code class="email">VirtRegMap</code> class takes care of inserting loads and stores. It also gets value from memory and stores value to memory. We need to use the <code class="email">VirtRegMap::assignVirt2Phys(vreg, preg)</code> function for mapping virtual register to physical register.</li></ul></div><p class="calibre7">LLVM has four register allocation techniques. We will briefly look what they are without going into the details of the algorithm. The four allocators are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Basic Register Allocator</strong>: The <a id="id233" class="calibre1"/>most basic register allocation<a id="id234" class="calibre1"/> technique of all the techniques. It can serve as a starter for implementing other register allocation techniques. The algorithm makes use of spill weight for prioritizing the virtual registers. The virtual register with the least weight gets the register allocated to it. When no physical register is available, the virtual register is spilled to memory.</li><li class="listitem"><strong class="calibre2">Fast Register Allocator</strong>: This <a id="id235" class="calibre1"/>allocation is done at <a id="id236" class="calibre1"/>basic block level at a time and attempts to reuse values in registers by keeping them in registers for longer period of time.</li><li class="listitem"><strong class="calibre2">PBQP Register Allocator</strong>: As <a id="id237" class="calibre1"/>mentioned in the <a id="id238" class="calibre1"/>source code file for this register allocation(<code class="email">llvm/lib/CodeGen/RegAllocPBQP.cpp</code>), this allocator works by representing the register allocator as a PBQP problem and then solving it using PBQP solver.</li><li class="listitem"><strong class="calibre2">Greedy Register Allocator</strong>: This is <a id="id239" class="calibre1"/>one of the <a id="id240" class="calibre1"/>efficient allocator of LLVM and works across the functions. Its allocation is done using live range splitting and minimizing spill costs.</li></ul></div><p class="calibre7">Let's take an example to see the register allocation for the previous testcode <code class="email">test.ll</code> and see how vregs are replaced with actual registers. Let's take the greedy allocator for allocation. You can choose any other allocator as well. The target machine used is x86-64 machine.</p><div><pre class="programlisting">
<strong class="calibre2">$ llc test.ll –regalloc=greedy –o test1.s</strong>
<strong class="calibre2">$ cat test1.s</strong>
<strong class="calibre2">  .text</strong>
<strong class="calibre2">  .file  "test.ll"</strong>
<strong class="calibre2">  .globl  test</strong>
<strong class="calibre2">  .align  16, 0x90</strong>
<strong class="calibre2">  .type  test,@function</strong>
<strong class="calibre2">test:                                   # @test</strong>
<strong class="calibre2">  .cfi_startproc</strong>
<strong class="calibre2"># BB#0:</strong>
<strong class="calibre2">  movl  %edx, %ecx</strong>
<strong class="calibre2">  leal  (%rdi,%rsi), %eax</strong>
<strong class="calibre2">  cltd</strong>
<strong class="calibre2">  idivl  %ecx</strong>
<strong class="calibre2">  retq</strong>
<strong class="calibre2">.Lfunc_end0:</strong>
<strong class="calibre2">  .size  test, .Lfunc_end0-test</strong>
<strong class="calibre2">  .cfi_endproc</strong>
<strong class="calibre2">  .section  ".note.GNU-stack","",@progbits</strong>
</pre></div><p class="calibre7">We can see all the vregs present are gone now and have been replaced by actual registers. The machine used here was x86-64. You can try out register allocation with <code class="email">pbqp</code> allocator and see the difference in allocation. The <code class="email">leal  (%rdi,%rsi), %eax</code> instruction will be replaced with the following instructions:</p><div><pre class="programlisting">movl  %esi, %edx
movl  %edi, %eax
leal  (%rax, %rdx), %eax.</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Code Emission</h1></div></div></div><p class="calibre7">We started from LLVM IR in the<a id="id241" class="calibre1"/> first section and converted it to <code class="email">SelectioDAG</code> and then to <code class="email">MachineInstr</code>. Now, we need to emit this code. Currently, we have LLVM JIT and MC to do so. LLVM JIT is the traditional way of generating the object code for a target on the go directly in the memory. What we are more interested in is the LLVM MC layer.</p><p class="calibre7">The MC layer is responsible for generation of assembly file/object file from the <code class="email">MachineInstr</code> passed on to it from the previous step. In the MC Layer, the instructions are represented as <code class="email">MCInst</code>, which are lightweight, as in they don't carry much information about the program as <code class="email">MachineInstr</code>.</p><p class="calibre7">The code emission starts with the <code class="email">AsmPrinter</code> class, which is overloaded by the target specific <code class="email">AsmPrinter</code> class. This class deals with general lowering process by converting the <code class="email">MachineFunction</code> functions into MC label constructs by making use of the  target specific <code class="email">MCInstLowering</code> interface(for x86 it is <code class="email">X86MCInstLower</code> class in the <code class="email">lib/Target/x86/X86MCInstLower.cpp</code> file).</p><p class="calibre7">Now, we have <code class="email">MCInst</code> instructions that are passed to <code class="email">MCStreamer</code> class for further step of generating either the assembly file or object code. Depending on the choice <code class="email">MCStreamer</code> makes use of its subclass <code class="email">MCAsmStreamer</code> to generate assembly code and <code class="email">MCObjectStreamer</code> to generate the object code.</p><p class="calibre7">The target specific <code class="email">MCInstPrinter</code> is called by <code class="email">MCAsmStreamer</code> to print the assembly instructions. To generate the binary code, the LLVM object code assembler is called by <code class="email">MCObjectStreamer</code>. The assembler in turn calls the <code class="email">MCCodeEmitter::EncodeInstruction()</code> to generate the binary instructions.</p><p class="calibre7">We must note that the <a id="id242" class="calibre1"/>MC Layer is one of the big difference between LLVM and GCC. GCC always outputs assembly and then needs an external assembler to transform this assembly into object files, whereas for LLVM using its own assembler we can easily print the instructions in binary and by putting some wraps around them can generate the object file directly. This not only guarantees that the output emitted in text or binary forms will be same but also saves time over GCC by removing the calls to external processes.</p><p class="calibre7">Now, let's take an example to look at the MC Instruction corresponding to assembly using the <code class="email">llc</code> tool. We make use of the same testcode <code class="email">test.ll</code> file used earlier in the chapter.</p><p class="calibre7">To view the MC Instructions, we need to pass the command-line option <code class="email">–asm-show-inst</code> option to <code class="email">llc</code>. It will show the MC instructions as assembly file comments.</p><div><pre class="programlisting">llc test.ll -asm-show-inst -o -
  .text
  .file  "test.ll"
  .globl  test
  .align  16, 0x90
  .type  test,@function
test:                                   # @test
  .cfi_startproc
# BB#0:
  movl  %edx, %ecx              # &lt;MCInst #1674 MOV32rr
                                        #  &lt;MCOperand Reg:22&gt;
                                        #  &lt;MCOperand Reg:24&gt;&gt;
  leal  (%rdi,%rsi), %eax       # &lt;MCInst #1282 LEA64_32r
                                        #  &lt;MCOperand Reg:19&gt;
                                        #  &lt;MCOperand Reg:39&gt;
                                        #  &lt;MCOperand Imm:1&gt;
                                        #  &lt;MCOperand Reg:43&gt;
                                        #  &lt;MCOperand Imm:0&gt;
                                        #  &lt;MCOperand Reg:0&gt;&gt;
  cltd                            # &lt;MCInst #388 CDQ&gt;
  idivl  %ecx                    # &lt;MCInst #903 IDIV32r
                                        #  &lt;MCOperand Reg:22&gt;&gt;
  retq                            # &lt;MCInst #2465 RETQ
                                        #  &lt;MCOperand Reg:19&gt;&gt;
.Lfunc_end0:
  .size  test, .Lfunc_end0-test
  .cfi_endproc


  .section  ".note.GNU-stack","",@progbits</pre></div><p class="calibre7">We see the <code class="email">MCInst</code> and <code class="email">MCOperands</code> in the assembly comments. We can also view the binary encoding in assembly<a id="id243" class="calibre1"/> comments by passing the option <code class="email">–show-mc-encoding</code> to <code class="email">llc</code>.</p><div><pre class="programlisting">
<strong class="calibre2">$ llc test.ll -show-mc-encoding -o -</strong>
<strong class="calibre2">  .text  </strong>
<strong class="calibre2">  .file  "test.ll"</strong>
<strong class="calibre2">  .globl  test</strong>
<strong class="calibre2">  .align  16, 0x90</strong>
<strong class="calibre2">  .type  test,@function</strong>
<strong class="calibre2">test:                                   # @test</strong>
<strong class="calibre2">  .cfi_startproc</strong>
<strong class="calibre2"># BB#0:</strong>
<strong class="calibre2">  movl  %edx, %ecx              # encoding: [0x89,0xd1]</strong>
<strong class="calibre2">  leal  (%rdi,%rsi), %eax       # encoding: [0x8d,0x04,0x37]</strong>
<strong class="calibre2">  cltd                            # encoding: [0x99]</strong>
<strong class="calibre2">  idivl  %ecx                    # encoding: [0xf7,0xf9]</strong>
<strong class="calibre2">  retq                            # encoding: [0xc3]</strong>
<strong class="calibre2">.Lfunc_end0:</strong>
<strong class="calibre2">  .size  test, .Lfunc_end0-test</strong>
<strong class="calibre2">  .cfi_endproc</strong>

<strong class="calibre2">  .section  ".note.GNU-stack","",@progbits</strong>
</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec47" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we saw how LLVM IR is converted to <code class="email">SelectionDAG</code>. The SDAG then goes through variety of transformation. The instructions are legalized, so are the data types. <code class="email">SelectionDAG</code> also goes through the optimization phase where DAG nodes are combined to result in optimal nodes, which may be target-spacific. After DAG combine, it goes through instruction selection phase, where target architecture instructions are mapped to DAG nodes. After this, the DAGs are ordered in a linear order to facilitate execution by CPU, these DAGs are converted to <code class="email">MachineInstr</code> and DAGs are destroyed. Assigning of physical register takes place in the next step to all the virtual registers present in the code. After this, the MC layer comes into picture and deals with the generation of Object and Assembly Code. Going ahead in the next chapter, we will see how to define a target; the various aspects of how a target is represented in LLVM by making use of Table Descriptor files and <code class="email">TableGen</code>.</p></div></body></html>