<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch02" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Chapter 2. Building a Beautiful Cross-platform Clock</h1></div></div></div><p class="calibre9">In this chapter, you will learn that Qt is a great tool to build cross-platform applications. A Qt/C++ clock example is used as a demonstration here. The topics covered in this chapter, which are listed here, are essential for any real-world applications. These are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Creating a basic digital clock</li><li class="listitem">Tweaking the digital clock</li><li class="listitem">Saving and restoring settings</li><li class="listitem">Building on Unix platforms</li></ul></div><div><div><div><div><h1 class="title2"><a id="ch02lvl1sec15" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Creating a basic digital clock</h1></div></div></div><p class="calibre9">It's time to create a<a id="id56" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> new project, so we will create a Qt Widgets application named <code class="literal">Fancy_Clock</code>.</p><div><div><h3 class="title4"><a id="note08" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">We won't utilize any Qt Quick knowledge in this chapter.</p></div></div><p class="calibre9">Now, change the window title to <code class="literal">Fancy Clock</code> or any other name that you like. Then, the main window UI needs to be tailored because the clock is displayed at the top of the desktop. The menu bar, status bar, and toolbar are all removed. After that, we need to drag an <strong class="calibre10">LCD Number</strong> widget into <code class="literal">centralWidget</code>. Next, change the layout of <code class="literal">MainWindow</code> to <strong class="calibre10">LayOut Horizontally</strong> in order to autoresize the subwidget. The last thing that needs to be done to the UI file is to change <strong class="calibre10">frameShape</strong> to <strong class="calibre10">NoFrame</strong> under the <strong class="calibre10">QFrame</strong> column in the property of <code class="literal">lcdNumber</code>. If you've done this right, you'll get a prototype of a digital clock, as shown here:</p><div><img src="img/4615OS_02_01.jpg" alt="Creating a basic digital clock" class="calibre22"/></div><p class="calibre9">In order to update the LCD number display repeatedly, we have to<a id="id57" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> make use of the <code class="literal">QTimer</code> class to set<a id="id58" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> up a timer that emits a signal repetitively. In addition to this, we need to create a slot to receive the signal and to update the LCD number display to the current time. Thus, the <a id="id59" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">QTime</code> class is also needed. This is how the header file of <code class="literal">MainWindowmainwindow.h</code> will look now:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;

private slots:
  void updateTime();
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">As you can see, the only modification made here is the declaration of a private <code class="literal">updateTime</code> slot. As usual, we're supposed to<a id="id60" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> define this slot in <code class="literal">mainwindow.cpp</code>, whose content is pasted here. Note that we need to include <code class="literal">QTimer</code> and <code class="literal">QTime</code>.</p><div><pre class="programlisting">#include &lt;QTimer&gt;
#include &lt;QTime&gt;
#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);

  QTimer *timer = new QTimer(this);
  connect(timer, &amp;QTimer::timeout, this, &amp;MainWindow::updateTime);
  timer-&gt;start(1000);

  updateTime();
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::updateTime()
{
  QTime currentTime = QTime::currentTime();
  QString currentTimeText = currentTime.toString("hh:mm");
  if (currentTime.second() % 2 == 0) {
    currentTimeText[2] = ' ';
  }
  ui-&gt;lcdNumber-&gt;display(currentTimeText);
}</pre></div><p class="calibre9">Inside the <code class="literal">updateTime</code> slot, the <code class="literal">QTime</code> class is used to deal with the time, that is, the clock. This class can provide <a id="id61" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>accuracy of up to 1 millisecond, if the underlying operating system supports it. However, <code class="literal">QTime</code> has nothing to do with the time zone or daylight saving time. It is, at least, sufficient for our little clock. The<a id="id62" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">currentTime()</code> function is a static public <a id="id63" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function, which is used to create a <code class="literal">QTime</code> object that contains the system's local time.</p><p class="calibre9">As for the second line of the <code class="literal">updateTime</code> function, we used the <code class="literal">toString</code> function provided by <code class="literal">QTime</code> to convert the time to a string, and then saved it in <code class="literal">currentTimeText</code>. The arguments that are passed to <code class="literal">toString</code> are in the format of the time string. The full list of expressions can be obtained<a id="id64" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> from <strong class="calibre10">Qt Reference Documentation</strong>. The colon in the middle of the clock should be flashing, just as in the case of a real digital clock. Hence, we used an <code class="literal">if</code> statement to control this. The colon will vanish when the second's value is even, and it will reappear when the second's value is odd. Here, inside the <code class="literal">if</code> block, we used the <code class="literal">[2]</code> operator to get a modifiable reference of the third character because this is the only way to do direct modifications to a character inside a string. Here, the counting of the <code class="literal">currentTimeText</code> string starts from <code class="literal">0</code>. Meanwhile, the<a id="id65" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">at()</code> function of <code class="literal">QString</code> returns a constant character, which you have no right to change. At last, this function will let <code class="literal">lcdNumber</code> display the time string. Now, let's get back to the constructor of <code class="literal">MainWindow</code>. After the initialization of the UI, the first thing it does is to create a <code class="literal">QTimer</code> object. Why can't we use a local variable? The answer to that question is because the local variables will be destroyed after the construction of <code class="literal">MainWindow</code>. If the timer has gone, there's no way to trigger <code class="literal">updateTime</code> repetitively. We don't use a member variable because there is no need to perform the declaration work in the header file, since we won't use this timer elsewhere.</p><p class="calibre9">The <code class="literal">QTimer</code> class is<a id="id66" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> used to create a repetitive and single-shot timer. It will emit the <code class="literal">timeout</code> signal at constant intervals after <code class="literal">start</code> is called. Here, we create one timer and connect the <code class="literal">timeout</code> signal to the <code class="literal">updateTime</code> slot so that <code class="literal">updateTime</code> is called every second.</p><p class="calibre9">There is another important aspect in<a id="id67" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> Qt called <strong class="calibre10">parent-child mechanism</strong>. Although it's not as well-known as signals and slots, it plays a crucial role in the development of the Qt applications. Basically speaking, when we create an <code class="literal">QObject</code> child with a parent or explicitly set a parent by calling <code class="literal">setParent</code>, the parent will add this <code class="literal">QObject</code> child to its list of children. Then, when the parent is deleted, it'll go through its list of children and delete each child. In most cases, especially in the design of a UI, the parent-child relationship is set up implicitly. The parent widget or layout automatically becomes the parent object to its children widgets or layouts. In other cases, we have to explicitly set the parent for a <code class="literal">QObject</code> child so that the parent can take over its ownership and manage the release of its memory. Hence, we pass the <code class="literal">QObject</code> parent, which is this, a <code class="literal">MainWindow</code> class to the constructor of <code class="literal">QTimer</code>. This ensures that <code class="literal">QTimer</code> will be deleted after <code class="literal">MainWindow</code> is deleted. That's why we don't have to explicitly write the <code class="literal">delete</code> statements in the destructor.</p><p class="calibre9">At the end of the<a id="id68" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> constructor, we need to call <code class="literal">updateTime</code> explicitly, which will allow the clock to display the current time. If we don't do this, the application will display a zero for a second until the <code class="literal">timeout</code> signal is emitted by <code class="literal">timer</code>. Now, run your application; it will be similar to the following screenshot:</p><div><img src="img/4615OS_02_02.jpg" alt="Creating a basic digital clock" class="calibre23"/></div></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch02lvl1sec16" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tweaking the digital clock</h1></div></div></div><p class="calibre9">It's time to make this basic <a id="id69" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>digital clock look more beautiful. Let's add something like a transparent background, which sits on top of the frameless window. Using a transparent background can deliver a fantastic visual effect. While the frameless window hides window decorations, including a border and the title bar, a desktop widget, such as a clock, should be frameless and displayed on top of the desktop.</p><p class="calibre9">To make our clock translucent, simply add the following line to the constructor of <code class="literal">MainWindow</code>:</p><div><pre class="programlisting">setAttribute(Qt::WA_TranslucentBackground);</pre></div><p class="calibre9">The effect of the <code class="literal">WA_TranslucentBackground</code> attribute depends on the composition managers on the X11 platforms.</p><p class="calibre9">A widget may have lots of attributes, and this function is used to switch on or switch off a specified attribute. It's<a id="id70" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> turned on by default. You need to pass a false Boolean as the second argument to disable an attribute. The full list of <code class="literal">Qt::WidgetAttribute</code> can be found in the Qt Reference Documentation.</p><p class="calibre9">Now, add the following line to the constructor as well, which will make the clock look frameless and make it stay on top of the desktop:</p><div><pre class="programlisting">setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint);</pre></div><p class="calibre9">Similarly, <code class="literal">Qt::WindowFlags</code> is used to define the type of widget. It controls the behavior of the widget, rather than of its properties. Thus, two hints are given: one is to stay on top and the other is to be frameless. If you want to preserve old flags while setting new ones, you need to add them to the combination.</p><div><pre class="programlisting">setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | windowFlags());</pre></div><p class="calibre9">Here, the <code class="literal">windowFlags</code> function<a id="id71" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> is used to retrieve the window flags. One thing you may be interested to know is that <code class="literal">setWindowFlags</code> will result in the invisibility of the widget after the<a id="id72" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">show</code> function. So, you can either call <code class="literal">setWindowFlags</code> before the <code class="literal">show</code> function of the window or widget or call <code class="literal">show</code> again after <code class="literal">setWindowFlags</code>.</p><p class="calibre9">After the modification to the constructor, this is how the clock is expected to look:</p><div><img src="img/4615OS_02_03_03.jpg" alt="Tweaking the digital clock" class="calibre24"/></div><p class="calibre9">There is a useful<a id="id73" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> trick that you can use to hide the clock from the taskbar. Of course, a clock doesn't need to be displayed among the applications in a taskbar. You should never set a flag such as <code class="literal">Qt::Tool</code> or <code class="literal">Qt::ToolTip</code> alone to achieve this because this will cause the exit behavior of the application to be abnormal. This trick is even simpler; here is the code of <code class="literal">main.cpp</code>:</p><div><pre class="programlisting">#include "mainwindow.h"
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  QWidget wid;
  MainWindow w(&amp;wid);
  w.show();

  return a.exec();
}</pre></div><p class="calibre9">The preceding code makes our <code class="literal">MainWindow w</code> object a child of <code class="literal">QWidget wid</code>. The child widgets won't display on the taskbar because there should be only one top parent widget. Meanwhile, our parent widget, <code class="literal">wid</code>, doesn't even show. It's tricky, but it's the only one that does the trick without breaking any other logic.</p><p class="calibre9">Well, a new problem has just surfaced. The clock is unable to move and the only way to close it is by stopping it through the Qt Creator's panel or through a keyboard shortcut. This is because we declared it as a frameless window, which led to an inability to control it via a window manager. Since there is no way to interact with it, it's impossible to close it by itself. Hence, the solution<a id="id74" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to this problem is to write our own functions to move and close the clock.</p><p class="calibre9">Closing this application may be more urgent. Let's see how to reimplement some functions to achieve this goal. First, we need to declare a new <code class="literal">showContextMenu</code> slot to display a context menu and reimplement <code class="literal">mouseReleaseEvent</code>. The following code shows the content of <code class="literal">mainwindow.h</code>:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT
public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;

private slots:
  void updateTime();
  void showContextMenu(const QPoint &amp;pos);

protected:
  void mouseReleaseEvent(QMouseEvent *);
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">There are two new classes defined in the preceding code: <code class="literal">QPoint</code> and <code class="literal">QMouseEvent</code>. The <code class="literal">QPoint</code> class defines<a id="id75" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> a point in the plane by using integer precision. Relatively, there is another class named <code class="literal">QPointF</code>, which provides float precision. Well, the <code class="literal">QMouseEvent</code> class inherits <code class="literal">QEvent</code> and <code class="literal">QInputEvent</code>. It contains some parameters that describe a mouse event. Let's see why we need them in <code class="literal">mainwindow.cpp</code>:</p><div><pre class="programlisting">#include &lt;QTimer&gt;
#include &lt;QTime&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QMenu&gt;
#include &lt;QAction&gt;
#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);

  setAttribute(Qt::WA_TranslucentBackground);
  setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | windowFlags());

  connect(this, &amp;MainWindow::customContextMenuRequested, this, &amp;MainWindow::showContextMenu);

  QTimer *timer = new QTimer(this);
  connect(timer, &amp;QTimer::timeout, this, &amp;MainWindow::updateTime);
  timer-&gt;start(1000);

  updateTime();
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::updateTime()
{
  QTime currentTime = QTime::currentTime();
  QString currentTimeText = currentTime.toString("hh:mm");
  if (currentTime.second() % 2 == 0) {
    currentTimeText[2] = ' ';
  }
  ui-&gt;lcdNumber-&gt;display(currentTimeText);
}

void MainWindow::showContextMenu(const QPoint &amp;pos)
{
  QMenu contextMenu;
  contextMenu.addAction(QString("Exit"), this, SLOT(close()));
  contextMenu.exec(mapToGlobal(pos));
}

void MainWindow::mouseReleaseEvent(QMouseEvent *e)
{
  if (e-&gt;button() == Qt::RightButton) {
    emit customContextMenuRequested(e-&gt;pos());
  }
  else {
    QMainWindow::mouseReleaseEvent(e);
  }
}</pre></div><p class="calibre9">Note that you should include <code class="literal">QMouseEvent</code>, <code class="literal">QMenu</code>, and <code class="literal">QAction</code> in order to utilize these classes. There is a predefined <code class="literal">customContextMenuRequested</code> signal, which is coupled with the newly created <code class="literal">showContextMenu</code> slot. For the sake of consistency, we will follow the rule that Qt defined, which means that the <code class="literal">QPoint</code> argument in <code class="literal">customContextMenuRequested</code> should be a local position instead of a global position. That's why we need a<a id="id76" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">mapToGlobal</code> function to translate <code class="literal">pos</code> to a global position. As for the <a id="id77" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">QMenu</code> class, it provides a <code class="literal">menu</code> widget for a menu bar, context menu, or other pop-up menus. So, we<a id="id78" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> create the <code class="literal">contextMenu</code> object, and then add a new action with the <code class="literal">Exit</code> text. This is coupled with a <code class="literal">close</code> slot of <code class="literal">MainWindow</code>. The last statement is used to execute the <code class="literal">contextMenu</code> object at the specified global position. In other words, this slot will display a pop-up menu at the given position.</p><p class="calibre9">The reimplementation of <code class="literal">mouseReleaseEvent</code> is done to check the triggered button of the event. If it's the right button, emit the <code class="literal">customContextMenuRequested</code> signal with the local position of the mouse. Otherwise, simply call the default <code class="literal">mouseReleaseEvent</code> function of <code class="literal">QMainWindow</code>.</p><p class="calibre9">Make use of the default member functions of the base class when you reimplement it.</p><p class="calibre9">Run the application again; you can quit by right-clicking on it and then selecting <strong class="calibre10">Exit</strong>. Now, we should continue the reimplementation to make the clock movable. This time, we need to rewrite two protected functions: <code class="literal">mousePressEvent</code> and <code class="literal">mouseMoveEvent</code>. Therefore, this is how the header file looks:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;
  QPoint m_mousePos;

private slots:
  void updateTime();
  void showContextMenu(const QPoint &amp;pos);

protected:
  void mouseReleaseEvent(QMouseEvent *);
  void mousePressEvent(QMouseEvent *);
  void mouseMoveEvent(QMouseEvent *);
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">There is also a declaration of a new private member variable in the preceding code, <code class="literal">m_mousePos</code>, which is a <code class="literal">QPoint</code> object used to store the local position of the mouse. The following code<a id="id79" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> defines <code class="literal">mousePressEvent</code> and <code class="literal">mouseMoveEvent</code>:</p><div><pre class="programlisting">void MainWindow::mousePressEvent(QMouseEvent *e)
{
  m_mousePos = e-&gt;pos();
}

void MainWindow::mouseMoveEvent(QMouseEvent *e)
{
  this-&gt;move(e-&gt;globalPos() - m_mousePos);
}</pre></div><p class="calibre9">It's easier than you thought. When a mouse button is pressed, the local position of the mouse is stored as <code class="literal">m_mousePos</code>. When the mouse is moving, we call the <code class="literal">move</code> function to move <code class="literal">MainWindow</code> to a new position. Because the position passed to <code class="literal">move</code> is a global position, we need to use <code class="literal">globalPos</code> of the event minus the local position of the mouse. Confused? The <code class="literal">m_mousePos</code> variable is the mouse's relative position to the top-left point of the parent widget, which is <code class="literal">MainWindow</code> in our case. The<a id="id80" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">move</code> function will move the top-left point<a id="id81" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> of <code class="literal">MainWindow</code> to the given global position. While the <code class="literal">e-&gt;globalPos()</code> function is the global position of the mouse and not <code class="literal">MainWindow</code>, we need to subtract the relative position of <code class="literal">m_mousePos</code> to translate the mouse's global position to the top-left point position of <code class="literal">MainWindow</code>. After all this effort, the clock should look much more satisfying.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch02lvl1sec17" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Saving and restoring settings</h1></div></div></div><p class="calibre9">Although the clock can be moved, it won't restore its last position after restarting. In addition to this, we can give users some choices to adjust the clock's appearance, such as the font color. To<a id="id82" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> make it work, we need the <code class="literal">QSettings</code> class, which provides platform-independent persistent settings. It needs a company or organization name and the<a id="id83" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> name of an application. A typical <code class="literal">QSettings</code> object can be constructed by using this line:</p><div><pre class="programlisting">QSettings settings("Qt5 Blueprints", "Fancy Clock");</pre></div><p class="calibre9">Here, <code class="literal">Qt5 Blueprints</code> is the organization's name and <code class="literal">Fancy Clock</code> is the application's name.</p><p class="calibre9">The settings are stored in the system registry on Windows, while they are stored in the XML preferences files on Mac OS X and the INI text files on the other Unix operating systems, such as Linux. However, we do not usually need to be concerned with this, since <code class="literal">QSettings</code> provides high-level interfaces to manipulate the settings.</p><p class="calibre9">If we're going to read and/or write settings in multiple places, we'd better set the organization and application in <code class="literal">QCoreApplication</code>, which is inherited by <code class="literal">QApplication</code>. The <code class="literal">main.cpp</code> file's content is shown as follows:</p><div><pre class="programlisting">#include "mainwindow.h"
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  a.setOrganizationName(QString("Qt5 Blueprints"));
  a.setApplicationName(QString("Fancy Clock"));

  QWidget wid;
  MainWindow w(&amp;wid);
  w.show();

  return a.exec();
}</pre></div><p class="calibre9">This enables us to use the default <code class="literal">QSettings</code> constructor to access the same settings. In order to save the geometry and state of <code class="literal">MainWindow</code>, we need to reimplement <code class="literal">closeEvent</code>. First, we need to declare <code class="literal">closeEvent</code> to be a protected member function, as follows:</p><div><pre class="programlisting">void closeEvent(QCloseEvent *);</pre></div><p class="calibre9">Then, let's<a id="id84" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> define the <code class="literal">closeEvent</code> function in <code class="literal">mainwindow.cpp</code>, as follows:</p><div><pre class="programlisting">void MainWindow::closeEvent(QCloseEvent *e)
{
  QSettings sts;
  sts.setValue("MainGeometry", saveGeometry());
  sts.setValue("MainState", saveState());
  e-&gt;accept();
}</pre></div><p class="calibre9">Remember to add <code class="literal">#include &lt;QSettings&gt;</code> in order to include the <code class="literal">QSettings</code> header files.</p><p class="calibre9">Thanks to <code class="literal">setOrganizationName</code> and <code class="literal">setApplicationName</code>, we don't need to pass any arguments to the <code class="literal">QSettings</code> constructor now. Instead, we call a<a id="id85" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">setValue</code> function to save the <a id="id86" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>settings. The <code class="literal">saveGeometry()</code> and <code class="literal">saveState()</code> functions return the <code class="literal">MainWindow</code> geometry and state respectively as the <code class="literal">QByteArray</code> objects.</p><p class="calibre9">The next step is to read these settings and restore the geometry and state. This can be done inside the constructor of <code class="literal">MainWindow</code>. You just need to add two statements to it:</p><div><pre class="programlisting">QSettings sts;
restoreGeometry(sts.value("MainGeometry").toByteArray());
restoreState(sts.value("MainState").toByteArray());</pre></div><p class="calibre9">Here, <code class="literal">toByteArray()</code> can translate the stored value to a <code class="literal">QByteArray</code> object. How do we test to see if this works? To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem1">Rebuild this application.</li><li class="listitem1">Run it.</li><li class="listitem1">Move its position.</li><li class="listitem1">Close it.</li><li class="listitem1">Run it again.</li></ol></div><p class="calibre9">You'll see that the clock will appear at exactly the same position as it was before it closed. Now that you're pretty much familiar with widgets, layouts, settings, signals, and slots, it's time to cook a preference dialog by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem1">Right-click on the <code class="literal">Fancy_Clock</code> project in the <strong class="calibre10">Projects</strong> panel.</li><li class="listitem1">Select <strong class="calibre10">Add New…</strong>.</li><li class="listitem1">Select <strong class="calibre10">Qt</strong> in the <strong class="calibre10">Files and Classes</strong> panel.</li><li class="listitem1">Click on <strong class="calibre10">Qt Designer Form Class</strong> in the middle panel.</li><li class="listitem1">Select <strong class="calibre10">Dialog with Buttons Bottom</strong>.</li><li class="listitem1">Fill in <code class="literal">Preference</code> under <strong class="calibre10">Class name</strong>.</li><li class="listitem1">Click on <strong class="calibre10">Next</strong>, and then select <strong class="calibre10">Finish</strong>.</li></ol></div><p class="calibre9">Qt Creator will<a id="id87" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> redirect you to the <strong class="calibre10">Design</strong> mode. First, let's change <code class="literal">windowTitle</code> to <a id="id88" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><strong class="calibre10">Preference</strong>, and then do some UI work. Perform the following steps to do this:</p><div><ol class="orderedlist"><li class="listitem1">Drag <strong class="calibre10">Label</strong> to <code class="literal">QDialog</code> and change its <code class="literal">objectName</code> property to <code class="literal">colourLabel</code>. Next, change its text to <code class="literal">Colour</code>.</li><li class="listitem1">Add <strong class="calibre10">QComboBox</strong> and change its <code class="literal">objectName</code> property to <code class="literal">colourBox</code>.</li><li class="listitem1">Add the <code class="literal">Black</code>, <code class="literal">White</code>, <code class="literal">Green</code>, and <code class="literal">Red</code> items to <code class="literal">colourBox</code>.</li><li class="listitem1">Change the layout of <code class="literal">Preference</code> to <strong class="calibre10">Lay Out in a Form Lay Out</strong>.</li></ol></div><p class="calibre9">Close this UI file. Go back to editing the <code class="literal">preference.h</code> add a private <code class="literal">onAccepted</code> slot. The following code shows the content of this file:</p><div><pre class="programlisting">#ifndef PREFERENCE_H
#define PREFERENCE_H

#include &lt;QDialog&gt;

namespace Ui {
  class Preference;
}

class Preference : public QDialog
{
  Q_OBJECT

public:
  explicit Preference(QWidget *parent = 0);
  ~Preference();

private:
  Ui::Preference *ui;

private slots:
  void onAccepted();
};

#endif // PREFERENCE_H</pre></div><p class="calibre9">As usual, we define this slot in the source file. Besides, we have to set up some initializations in the<a id="id89" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> constructor of <code class="literal">Preference</code>. Thus, <code class="literal">preference.cpp</code> becomes similar to the<a id="id90" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> following code:</p><div><pre class="programlisting">#include &lt;QSettings&gt;
#include "preference.h"
#include "ui_preference.h"

Preference::Preference(QWidget *parent) :
  QDialog(parent),
  ui(new Ui::Preference)
{
  ui-&gt;setupUi(this);

  QSettings sts;
  ui-&gt;colourBox-&gt;setCurrentIndex(sts.value("Colour").toInt());

  connect(ui-&gt;buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;Preference::onAccepted);
}

Preference::~Preference()
{
  delete ui;
}

void Preference::onAccepted()
{
  QSettings sts;
  sts.setValue("Colour", ui-&gt;colourBox-&gt;currentIndex());
}</pre></div><p class="calibre9">Similarly, we load the settings and change the current item of <code class="literal">colourBox</code>. Then, it's the signal and slot coupling that follow. Note that Qt Creator has automatically generated the accept and reject connections between <code class="literal">buttonBox</code> and <code class="literal">Preference</code> for us. The <code class="literal">accepted</code> signal of <code class="literal">buttonBox</code> is emitted when the <strong class="calibre10">OK</strong> button is clicked. Likewise, the <code class="literal">rejected</code> signal is emitted if the user clicks on <strong class="calibre10">Cancel</strong>. You may want to check <strong class="calibre10">Signals &amp; Slots Editor</strong> in the <strong class="calibre10">Design</strong> mode to see which connections are defined there. This is shown in the following screenshot:</p><div><img src="img/4615OS_02_04.jpg" alt="Saving and restoring settings" class="calibre25"/></div><p class="calibre9">As for the definition of the <code class="literal">onAccepted</code> slot, it saves <code class="literal">currentIndex</code> of <code class="literal">colourBox</code> to the settings so<a id="id91" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> that we can read this setting elsewhere.</p><p class="calibre9">Now, what we're <a id="id92" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>going to do next is add an entry for <code class="literal">Preference</code> in the pop-up menu and change the color of <code class="literal">lcdNumber</code> according to the <code class="literal">Colour</code> setting value. Therefore, you should define a private slot and a private member function in <code class="literal">mainwindow.h</code> first.</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;
  QPoint m_mousePos;
  void setColour();

private slots:
  void updateTime();
  void showContextMenu(const QPoint &amp;pos);
  void showPreference();

protected:
  void mouseReleaseEvent(QMouseEvent *);
  void mousePressEvent(QMouseEvent *);
  void mouseMoveEvent(QMouseEvent *);
  void closeEvent(QCloseEvent *);
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">The <code class="literal">setColour</code><a id="id93" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> function is used to change the color of <code class="literal">lcdNumber</code>, while the <code class="literal">showPreference</code> slot<a id="id94" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> will execute a <code class="literal">Preference</code> object. The definitions of these two members are in the <code class="literal">mainwindow.cpp</code> file, which is displayed in the following manner:</p><div><pre class="programlisting">#include &lt;QTimer&gt;
#include &lt;QTime&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QMenu&gt;
#include &lt;QAction&gt;
#include &lt;QSettings&gt;
#include "mainwindow.h"
#include "preference.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);

  setAttribute(Qt::WA_TranslucentBackground);
  setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | windowFlags());

  QSettings sts;
  restoreGeometry(sts.value("MainGeometry").toByteArray());
  restoreState(sts.value("MainState").toByteArray());
  setColour();

  connect(this, &amp;MainWindow::customContextMenuRequested, this, &amp;MainWindow::showContextMenu);

  QTimer *timer = new QTimer(this);
  connect(timer, &amp;QTimer::timeout, this, &amp;MainWindow::updateTime);
  timer-&gt;start(1000);

  updateTime();
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::updateTime()
{
  QTime currentTime = QTime::currentTime();
  QString currentTimeText = currentTime.toString("hh:mm");
  if (currentTime.second() % 2 == 0) {
    currentTimeText[2] = ' ';
  }
  ui-&gt;lcdNumber-&gt;display(currentTimeText);
}

void MainWindow::showContextMenu(const QPoint &amp;pos)
{
  QMenu contextMenu;
  contextMenu.addAction(QString("Preference"), this, SLOT(showPreference()));
  contextMenu.addAction(QString("Exit"), this, SLOT(close()));
  contextMenu.exec(mapToGlobal(pos));
}

void MainWindow::mouseReleaseEvent(QMouseEvent *e)
{
  if (e-&gt;button() == Qt::RightButton) {
    emit customContextMenuRequested(e-&gt;pos());
  }
  else {
    QMainWindow::mouseReleaseEvent(e);
  }
}

void MainWindow::mousePressEvent(QMouseEvent *e)
{
  m_mousePos = e-&gt;pos();
}

void MainWindow::mouseMoveEvent(QMouseEvent *e)
{
  this-&gt;move(e-&gt;globalPos() - m_mousePos);
}

void MainWindow::closeEvent(QCloseEvent *e)
{
  QSettings sts;
  sts.setValue("MainGeometry", saveGeometry());
  sts.setValue("MainState", saveState());
  e-&gt;accept();
}

void MainWindow::setColour()
{
  QSettings sts;
  int i = sts.value("Colour").toInt();
  QPalette c;
  switch (i) {
  case 0://black
    c.setColor(QPalette::Foreground, Qt::black);
    break;
  case 1://white
    c.setColor(QPalette::Foreground, Qt::white);
    break;
  case 2://green
    c.setColor(QPalette::Foreground, Qt::green);
    break;
  case 3://red
    c.setColor(QPalette::Foreground, Qt::red);
    break;
  }
  ui-&gt;lcdNumber-&gt;setPalette(c);
  this-&gt;update();
}

void MainWindow::showPreference()
{
  Preference *pre = new Preference(this);
  pre-&gt;exec();
  setColour();
}</pre></div><p class="calibre9">We call <code class="literal">setColour</code> in the constructor in order to set the color of <code class="literal">lcdNumber</code> correctly. Inside <code class="literal">setColour</code>, we first read the <code class="literal">Colour</code> value from the settings, and then use a <code class="literal">switch</code> statement to <a id="id95" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>get the correct <code class="literal">QPalette</code> class before calling <code class="literal">setPalette</code> to change the color of <code class="literal">lcdNumber</code>. Since Qt doesn't provide a direct way to change the foreground <a id="id96" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>color of the <code class="literal">QLCDNumber</code> objects, we need to use this tedious method to achieve this. At the end of this member function, we call <code class="literal">update()</code> to update the <code class="literal">MainWindow</code> user interface.</p><div><div><h3 class="title4"><a id="note09" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Don't forget to add the <code class="literal">Preference</code> action to <code class="literal">contextMenu</code> inside <code class="literal">showContextMenu</code>. Otherwise, there will be no way to open the dialog.</p></div></div><p class="calibre9">In the relevant <code class="literal">showPreference</code> slot, we create a new <code class="literal">Preference</code> object, which is the child of <code class="literal">MainWindow</code>, and then call <code class="literal">exec()</code> to execute and show it. Lastly, we call <code class="literal">setColour()</code> to change the color of <code class="literal">lcdNumber</code>. As <code class="literal">Preference</code> is modal and <code class="literal">exec()</code> has its own event loop, it will block the application until <code class="literal">pre</code> is finished. After <code class="literal">pre</code> finishes executing, either by <code class="literal">accepted</code> or <code class="literal">rejected</code>, <code class="literal">setColour</code> will be called next. Of course, you can use the signal-slot way to implement it, but we have to apply some modifications to the previous code. Firstly, delete the <code class="literal">accepted-accept</code> signal-slot couple in <code class="literal">preference.ui</code> in the <strong class="calibre10">Design</strong> mode. Then, add <code class="literal">accept()</code> to the end of <code class="literal">onAccepted</code> in <code class="literal">preference.cpp</code>.</p><div><pre class="programlisting">void Preference::onAccepted()
{
  QSettings sts;
  sts.setValue("Colour", ui-&gt;colourBox-&gt;currentIndex());
  this-&gt;accept();
}</pre></div><p class="calibre9">Now, <code class="literal">showPreference</code> in <code class="literal">mainwindow.cpp</code> can be rewritten as follows:</p><div><pre class="programlisting">void MainWindow::showPreference()
{
  Preference *pre = new Preference(this);
  connect(pre, &amp;Preference::accepted, this, &amp;MainWindow::setColour);
  pre-&gt;exec();
}</pre></div><div><div><h3 class="title4"><a id="tip05" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">The <code class="literal">connect</code> statement shouldn't be placed after <code class="literal">exec()</code>, as it will cause the binding to fail.</p></div></div><p class="calibre9">No matter which <a id="id97" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>way you prefer, the clock should have a <strong class="calibre10">Preference</strong> dialog now. Run it, select <strong class="calibre10">Preference</strong> from the pop-up menu, and change the color to whatever you<a id="id98" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> please. You should expect a result similar to what is shown in the following screenshot:</p><div><img src="img/4615OS_02_05.jpg" alt="Saving and restoring settings" class="calibre26"/></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch02lvl1sec18" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Building on the Unix platforms</h1></div></div></div><p class="calibre9">So far, we are still trapped <a id="id99" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>with our applications on Windows. It's time to test whether our code can be built on other platforms. In this chapter, the code involved with only desktop operating systems, while we'll get a chance to build applications for mobile platforms later in this book. In terms of other desktop operating systems, there are plenty of them, and most of them are Unix-like. Qt officially supports Linux and Mac OS X, along with Windows. Hence, users of other systems, such as <strong class="calibre10">FreeBSD</strong>, may <a id="id100" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>need to compile Qt from scratch or get prebuilt packages from their own communities. In this book, the Linux<a id="id101" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> distribution <strong class="calibre10">Fedora 20</strong> is used as a demonstration to introduce platform crossing. Please bear in mind that there are lots of desktop environments and theming tools on Linux, so don't be surprised if the user interface differs. Well, since you're curious, let me tell you that the desktop environment is<a id="id102" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <strong class="calibre10">KDE 4</strong> with <code class="literal">QtCurve</code>, unifying GTK+ / Qt 4 / Qt 5 in my case. Let's get started as soon as you're ready. You can perform the following steps to do this:</p><div><ol class="orderedlist"><li class="listitem1">Copy the source code of <code class="literal">Fancy Clock</code> to a directory under Linux.</li><li class="listitem1">Delete the <code class="literal">Fancy_Clock.pro.user</code> file.</li><li class="listitem1">Open this project in Qt Creator.</li></ol></div><p class="calibre9">Now, build and<a id="id103" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> run this application. Everything is good except that there's a taskbar icon. Small issues such as this can't be avoided without testing. Well, to fix this, just modify a single line in the constructor of <code class="literal">MainWindow</code>. Changing the window flags will amend this:</p><div><pre class="programlisting">setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::Tool);</pre></div><p class="calibre9">If you run the file again, <code class="literal">Fancy Clock</code> won't show up in the taskbar any more. Please keep the <code class="literal">MainWindow</code> object, <code class="literal">w</code>, as a child of <code class="literal">QWidget wid</code>; otherwise, the application won't terminate after you click on <strong class="calibre10">Close</strong>.</p><p class="calibre9">Note that the <strong class="calibre10">Preference</strong> dialog uses native UI controls, rather than bringing the other platform's controls to this one. This is one of the most fascinating things that Qt has provided. All the Qt applications will look and behave like native applications across all platforms.</p><div><img src="img/4615OS_02_06.jpg" alt="Building on the Unix platforms" class="calibre27"/></div><p class="calibre9">It's not a hustle but the truth is that once you code the Qt application, you can run it everywhere. You don't need to write different GUIs for different platforms. That dark age has long gone. However, you may want to write some functions for specific platforms, either because of particular needs or workarounds. Firstly, I'd like to introduce you to some Qt Add-On modules dedicated for several platforms.</p><p class="calibre9">Take Qt Windows Extras as an example. Some cool features that Windows provides, such as <a id="id104" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><strong class="calibre10">Thumbnail Toolbar</strong> and<a id="id105" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <strong class="calibre10">Aero Peek</strong>, are supported by Qt through this add-on module.</p><p class="calibre9">Well, adding this<a id="id106" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> module to the project file directly, which in this case is <code class="literal">Fancy_Clock.pro</code> file, will definitely upset other platforms. A better way to do this is to test whether it's on Windows; if so, add this module to the project. Otherwise, skip this step. The following code shows you the <code class="literal">Fancy_Clock.pro</code> file, which will add the <code class="literal">winextras</code> module if it's built on Windows:</p><div><pre class="programlisting">QT       += core gui

win32: QT += winextras

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = Fancy_Clock
TEMPLATE = app


SOURCES += main.cpp\
    mainwindow.cpp \
    preference.cpp

HEADERS  += mainwindow.h \
    preference.h

FORMS    += mainwindow.ui \
    preference.ui</pre></div><p class="calibre9">As you can see, <code class="literal">win32</code> is a conditional statement, which is <code class="literal">true</code> only if the host machine is Windows. After a <code class="literal">qmake</code> rerun for this project, you'll be able to include and utilize those extra classes.</p><p class="calibre9">Similarly, if you want to do something on the Unix platforms, simply use the keyword <code class="literal">unix</code>, but <code class="literal">unix</code> will be <code class="literal">true</code> only on Linux/X11 or Mac OS X. To distinguish Mac OS X from Linux, here's an example:</p><div><pre class="programlisting">win32 {
  message("Built on Windows")
}
else: unix: macx{
  message("Built on Mac OS X")
}
else {
  message("Built on Linux")
}</pre></div><p class="calibre9">In fact, you can just use <code class="literal">unix: !macx</code> as the conditional statement to do some platform-specific work on Linux. It's a common practice to have many platform-specific statements in the project file(s), especially when your project needs to be linked with other libraries. You have to specify different paths for these libraries on different platforms, otherwise the compiler will complain about missing libraries or unknown symbols.</p><p class="calibre9">In addition to this, you<a id="id107" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> may want to know how to write platform-specific code while keeping it from other platforms. Similar to C++, it's a predefined macro that is handled by various compilers. However, these compiler macro lists may differ from one compiler to another. So, it is better to use <code class="literal">Global Qt Declarations</code> instead. I'll use a the following short example to explain this further:</p><div><pre class="programlisting">void MainWindow::showContextMenu(const QPoint &amp;pos)
{
  QMenu contextMenu;
  #ifdef Q_OS_WIN
  contextMenu.addAction(QString("Options"), this, SLOT(showPreference()));
  #elif defined(Q_OS_LINUX)
  contextMenu.addAction(QString("Profile"), this, SLOT(showPreference()));
  #else
  contextMenu.addAction(QString("Preference"), this, SLOT(showPreference()));
  #endif
  contextMenu.addAction(QString("Exit"), this, SLOT(close()));
  contextMenu.exec(mapToGlobal(pos));
}</pre></div><p class="calibre9">The preceding code shows you the new version of <code class="literal">showContextMenu</code>. The <code class="literal">Preference</code> menu entry will use different texts on different platforms, namely Windows, Linux, and Mac OS X. Change your <code class="literal">showContextMenu</code> function and run it again. You'll see <strong class="calibre10">Options</strong> on Windows, <strong class="calibre10">Profile</strong> on Linux, and <strong class="calibre10">Preference</strong> on Mac OS X. Below is a list concerning the platform-specific macros. You can get a full description, including other macros, functions, and types on the <code class="literal">QtGlobal</code> document.</p><div><table border="1" class="calibre28"><colgroup class="calibre29"><col class="calibre30"/><col class="calibre30"/></colgroup><thead class="calibre31"><tr class="calibre32"><th valign="bottom" class="calibre33">
<p class="calibre34">Macro</p>
</th><th valign="bottom" class="calibre33">
<p class="calibre34">Correspond Platform</p>
</th></tr></thead><tbody class="calibre35"><tr class="calibre36"><td class="calibre37">
<p class="calibre34">Q_OS_ANDROID</p>
</td><td class="calibre37">
<p class="calibre34">Android</p>
</td></tr><tr class="calibre38"><td class="calibre37">
<p class="calibre34">Q_OS_FREEBSD</p>
</td><td class="calibre37">
<p class="calibre34">FreeBSD</p>
</td></tr><tr class="calibre36"><td class="calibre37">
<p class="calibre34">Q_OS_LINUX</p>
</td><td class="calibre37">
<p class="calibre34">Linux</p>
</td></tr><tr class="calibre38"><td class="calibre37">
<p class="calibre34">Q_OS_IOS</p>
</td><td class="calibre37">
<p class="calibre34">iOS</p>
</td></tr><tr class="calibre36"><td class="calibre37">
<p class="calibre34">Q_OS_MAC</p>
</td><td class="calibre37">
<p class="calibre34">Mac OS X and iOS (Darwin-based)</p>
</td></tr><tr class="calibre38"><td class="calibre37">
<p class="calibre34">Q_OS_WIN</p>
</td><td class="calibre37">
<p class="calibre34">All Windows platforms, including Windows CE</p>
</td></tr><tr class="calibre36"><td class="calibre37">
<p class="calibre34">Q_OS_WINPHONE</p>
</td><td class="calibre37">
<p class="calibre34">Windows Phone 8</p>
</td></tr><tr class="calibre39"><td class="calibre37">
<p class="calibre34">Q_OS_WINRT</p>
</td><td class="calibre37">
<p class="calibre34">Windows Runtime on Windows 8. Windows RT and Windows Phone 8</p>
</td></tr></tbody></table></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch02lvl1sec19" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, information, including some tricks, about UI designing is included. Furthermore, there are basic yet useful cross-platform topics. Now, you're able to write an elegant Qt application in your favorite, and possibly already mastered, C++.</p><p class="calibre9">In the next chapter, we are going to learn how to write an application in Qt Quick. However, fear not; Qt Quick is even easier and, of course, quicker to develop.</p></div></div>



  </body></html>