- en: Chapter 6. Where to Go from Here
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finally reached the end of our journey for now, but there is far more
    to learn about game programming. Along the way, we learned how to begin building
    a game development framework to build on in the future, handle user input with
    DirectInput and XInput, render 2D graphics and tile-based worlds with Direct2D,
    add sound and music to our game worlds with DirectSound and XAudio2, and lastly,
    how to do basic 3D graphics rendering with Direct3D. So, in this chapter, we will
    take a look at where to go from here in expanding your game development knowledge
    as well as a handful of important topics that we covered briefly in this book
    and some that we didn't cover.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Clipping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial Intelligence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreaded programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Culling and clipping
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked briefly about this concept in the previous chapter while working on
    our *Cube* demo. **Culling** in 2D terms means removing or skipping objects that
    are not within the bounds of the screen rather than wasting time drawing things
    that aren't visible anyway. In 3D terms, the meaning is much the same, but it's
    obviously a bit more complicated since you have that third dimension to deal with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Clipping** is the removal of the portions of individual triangles of our
    game objects that are not seen fully on the screen. The part of the triangle that
    is off screen is removed. Direct3D handles clipping for us in its graphics pipeline,
    but the culling is left to us. Culling is the removal or skipping of entire objects
    in the scene that do not need to be drawn, since they are not currently visible.
    Direct3D can do backface culling for us though. This is the removal of the back
    face of a triangle that is facing away from the camera. We can''t see it, so we
    don''t need to draw it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Culling and clipping are used in most modern video games. It is a very important
    concept because it can give you significant performance gains. The more objects
    there are in your game world, the longer it will take the computer to loop through
    and draw every single one of them. So, clipping can save a lot of time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way of limiting what gets drawn in each frame though. There
    are other methods used in many games to make sure that objects are not drawn unnecessarily.
    For example, if there is a wall or other obstruction between the player and an
    object, we don't need to draw that object since the player can't see it anyway
    (unless, of course, there is a window or something). This is a little trickier
    to do. The point is that like with most things, there is more than one way to
    get the job done.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collision detection** is what it sounds like; detecting collisions of objects
    in your game world. In two dimensions, it''s relatively easy since everything
    generally has simple square shaped **bounding boxes**. A bounding box is an imaginary
    shape around the object that we use to detect collisions. You just test if the
    bounding boxes of two objects intersect each other, and if so, you know that they
    have collided. Of course, they are invisible to the player since we never draw
    our bounding boxes on the screen. However, it could be useful to add code to your
    game that lets you see the bounding boxes for debugging purposes, and verify that
    they are working as intended. Another good idea is to add a developer console
    to your game like those seen in many first-person-shooter games such as *Half-Life
    2*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞检测**正如其名；检测游戏世界中对象的碰撞。在二维空间中，由于一切通常都具有简单的方形**边界框**，所以相对容易。边界框是围绕对象的一个想象中的形状，我们用它来检测碰撞。你只需测试两个对象的边界框是否相交，如果是的话，你就知道它们已经发生了碰撞。当然，它们对玩家来说是不可见的，因为我们从未在屏幕上绘制我们的边界框。然而，为调试目的添加代码以让你看到边界框可能很有用，并验证它们是否按预期工作。另一个好主意是在你的游戏中添加一个开发者控制台，就像在许多第一人称射击游戏中看到的那样，例如*半条命2*。'
- en: In 3D, it gets more complicated. There are various types of bounding boxes that
    you can use. The commonly used ones are cubical or spherical bounding boxes. The
    cubic ones don't necessarily need to be perfect cubes. They can essentially be
    of any size, or have a longer width than height, for example. The spherical variety
    is usually a perfect sphere around an object but it, could be oblong though if
    the object is taller than it is wide. The spherical bounding boxes also behave
    a bit differently since you won't have cases where just the corners of two bounding
    boxes intersect, since spheres do not have corners like cubes do. You could also
    use different types of bounding boxes in 2D, of course.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维空间中，事情变得更加复杂。你可以使用各种类型的边界框。常用的有立方体或球形边界框。立方体不一定需要是完美的立方体。它们可以是任何大小，或者宽度比高度长，例如。球形边界框通常是一个围绕对象的完美球体，但如果对象的高度比宽度大，它也可能是细长的。球形边界框的行为也略有不同，因为你不会有两个边界框的角仅仅相交的情况，因为球体没有像立方体那样的角。当然，你也可以在二维中使用不同类型的边界框。
- en: Artificial Intelligence
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能
- en: '**Artificial Intelligence** (**AI**) refers to the intelligence that we code
    into the creatures in our game worlds. It is essentially the code that controls
    the actions of a creature. How smart this code is determines how smart our creature
    is. Of course, this concept is closely linked to **path finding** as well. Path
    finding is the process of finding a path that will allow the creature to reach
    its intended destination. One path finding algorithm is the `A*` algorithm (see
    [http://en.wikipedia.org/wiki/A*_search_algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）指的是我们编码到游戏世界中生物的智能。这本质上是指控制生物行为的代码。这段代码的智能程度决定了我们的生物的智能程度。当然，这个概念也与**路径查找**紧密相关。路径查找是寻找一条路径，使生物能够到达其目标位置的过程。一种路径查找算法是`A*`算法（见[http://en.wikipedia.org/wiki/A*_search_algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm)）。'
- en: Of course, we can't process this based on the geometry of the world. It would
    be too complicated and take too long. One way of doing this is using **waypoints**.
    Waypoints are essentially markers that are scattered about the world in strategic
    places. For example, an intersection in several paths will be a good place for
    a waypoint. The path-finding code simply finds the nearest waypoint to the creature's
    current position, and from there it finds a path from waypoint-to-waypoint that
    will get it to the desired destination. This is obviously much simpler and faster
    than trying to compute a path based on the actual geometry of the world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不能根据世界的几何形状来处理这个问题。这会太复杂，也太耗时。一种方法是用**航点**。航点本质上是在世界中的战略位置散布的标记。例如，几条路径的交汇处将是一个很好的航点位置。路径查找代码简单地找到生物当前位置最近的航点，然后从那里找到从航点到航点的路径，使其到达期望的目的地。这显然比尝试根据世界的实际几何形状计算路径要简单得多。
- en: Physics
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理
- en: Physics is closely tied in with collision detection since collision detection
    is integral to the physics of your game. If two objects collide, we need to detect
    this so that we can make them behave realistically. It will look pretty silly
    if they both just stopped in their tracks upon colliding, or just kept going as
    though they were both ghosts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Physics is a very complicated subject and relies heavily on mathematics. It
    is essentially just the use of mathematics to calculate the movement of objects
    in our game world. Of course, you can tweak your physics a bit if you want in
    order to achieve different effects. For example, you might make your physics work
    a little differently if your game has a cartoon-styled world as opposed to a realistic
    world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The bounding boxes that we talked about in the previous section are generally
    inside the physics system of a game since that's where they are used. The physics
    system in a game is generally responsible for simulating the physics of objects
    in the game world. It is also common to give objects a *sleep* state or *idle*
    state, as it is often called. When the object is in this state, the physics system
    will ignore the object, and not do any physics simulation for it. This allows
    you to have physics turned off for a given object until it's needed. This can
    bring huge performance benefits because physics, being full of mathematics, can
    be relatively slow to run. The performance benefits increase when you have more
    objects that are in this state (since they aren't moving or doing anything anyway),
    and so, you're effectively saving the physics system from doing a lot of unnecessary
    work. After all, there is no point in wasting time running the physics code on
    an object that is not moving or doing anything.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, a program has a single thread of execution. A thread is basically
    code that is being run by one of the cores in a system that has multi-core processors.
    Most modern processors have this feature, though it should be noted that you can
    still have multiple threads on a single-core CPU. I wanted to include this topic
    because multithreading is very useful in processor-intensive applications such
    as video games.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Basically, multithreading lets you have more than one point of execution running
    in your application at the same time. So, for example, you could have one thread
    doing some background work such as loading resources (graphics and sounds) in
    a large world similar to those found in *Minecraft*. As the player moves, the
    game has to load in the next chunks of the world, and unload the ones that are
    now too far behind the player. So, you could have one thread that handles loading
    new world chunks as the player moves around in the world, while the main thread
    keeps running the game code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you are not limited to just two threads either. It is common for
    applications to create a group of threads and assign jobs to them. This is handy
    if there are numerous tasks that need to be done. You just make a thread manager
    class, and pass in the function that you will call to do the job that needs to
    be done. The thread manager will look at its threads (collectively known as a
    **thread pool**) and find the one that is idle. If it finds an idle **worker thread**
    , it will start it by running the function you passed in. A worker thread is just
    a thread that is a member of a thread pool, and it gets its name since it does
    various jobs for us.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple bits of code simultaneously like this can obviously have significant
    performance benefits. However, multithreaded programming is also a rather tricky
    subject. You have to make sure that you don't have two threads accessing the same
    data at the same time, as this can cause big problems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Game design
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game design might seem fairly simple, but there is a lot more to it than most
    people think at first. Game design encompasses deciding on the style of your graphics,
    what the world will look like, the mood, designing the main gameplay mechanics
    of the game, the overall goal for the player, and the basic story idea. Of course,
    often there are graphic and sound artists who do the actual work of creating the
    graphics and sound for the game. But the graphics and sound styles first need
    to be specified in the game design, or the artists won't know what sort of graphics
    and sound to create.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most important thing about a game is that it is fun. If it is not
    fun, the players won't play it. However, it's not quite so simple because different
    players like different types of games. So, what is fun for one player may not
    be for another. So don't try to please everyone as this is generally not possible.
    If you do, you could easily find yourself chasing an unreachable goal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of game design, there can be arguments about the most important
    element. Some will say graphics, and others will say gameplay. However, in reality,
    they are both very important. Graphics make a game look good, but graphics don''t
    have to be realistic. They can be cartoony or have other styles that don''t look
    realistic. This doesn''t make a game bad by any means. A good example of this
    is Nintendo''s *The Legend of Zelda: The Wind Waker HD* that uses a graphical
    style known as **toon shading** to give its world a cartoony look.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The final experience that you get from a game is not down to just graphics,
    gameplay, or sound. It's a combination of all of the elements that come together
    to create the final game. Of course, controls are very important because they
    are the interface between the player and the game. If the interface is weird or
    doesn't work well, players probably won't play the game much. Sound effects and
    music set the mood for the game world, and the graphics provide the visuals and
    contribute to the mood as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你从游戏中获得的最终体验并不仅仅取决于图形、游戏玩法或音效。它是所有结合在一起创造最终游戏体验的元素的综合体。当然，控制非常重要，因为它们是玩家与游戏之间的接口。如果接口奇怪或者工作不顺畅，玩家可能不会玩很多游戏。音效和音乐为游戏世界设定了氛围，而图形则提供了视觉元素，并有助于营造氛围。
- en: Game difficulty
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏难度
- en: Probably one of the trickiest aspects of game design is the game difficulty.
    You don't want to make it too easy, or some players will get bored and quit. Likewise,
    if you make it too difficult, some players will rage quit. So, how do we deal
    with this issue? One way is to make your game have multiple difficulty levels
    so that the players can select the one they want. Most commonly, they are named
    `Easy`, `Normal`, `Hard`, and sometimes `Very Hard`. Another solution is known
    as **adaptive difficulty**. This is when a game looks at how well the player is
    doing, and adjusts the difficulty as needed. If the player is doing really well,
    it will increase the difficulty a bit, and if the player is having trouble, it
    would decrease it to some extent.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计中可能最棘手的一个方面就是游戏难度。你不想让它太简单，否则一些玩家会感到无聊并放弃。同样，如果你让它太难，一些玩家可能会愤怒地退出。那么，我们如何处理这个问题呢？一种方法是为你的游戏设置多个难度级别，让玩家可以选择他们想要的难度。最常见的难度级别是“简单”、“普通”、“困难”，有时还有“非常困难”。另一种解决方案被称为**自适应难度**。这意味着游戏会观察玩家的表现，并根据需要调整难度。如果玩家表现非常好，它会稍微提高难度，如果玩家遇到困难，它会适当地降低难度。
- en: Another aspect of difficulty is known as game **progression**. Progression refers
    to how the difficulty increases as you progress through the game. It should start
    out increasing slowly and then the rate of increase goes up faster as you move
    further and further into the game. So obviously, the difficulty should not suddenly
    shoot up by 100 percent from one level to the next as that will cause frustration
    in the players.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 难度的另一个方面被称为游戏**进度**。进度指的是随着你在游戏中前进，难度是如何增加的。它应该开始时缓慢增加，然后随着你进一步深入游戏，增加的速度会更快。因此，难度不应该从一个等级突然上升到下一个等级的100%，因为这会在玩家中引起挫败感。
- en: This brings us to the idea of challenges. Some games provide challenge levels
    for the hardcore players to enjoy. This is a good idea, but they shouldn't be
    so ridiculously hard that it takes forever to beat them. This is just my opinion,
    but a well-designed challenge should be one where the players can see themselves
    getting better as they keep making more attempts at it. If it's one of those levels
    where you just try 15 million times until you finally pull it off, sure it's hard,
    but its not a well-designed challenge because most players will probably give
    up long before they succeed. Why? It's because they will likely see it as a waste
    of time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了挑战的概念。一些游戏为硬核玩家提供了挑战级别以供享受。这是一个好主意，但它们不应该太难以至于需要花费很长时间才能击败。这只是我的个人观点，但一个设计良好的挑战应该是一个玩家在持续尝试中能够看到自己进步的地方。如果这是一个你需要尝试1500万次才能最终成功的等级，当然它很困难，但这不是一个设计良好的挑战，因为大多数玩家可能在他们成功之前就会放弃。为什么？因为他们可能会认为这是浪费时间。
- en: So what if you make a cool reward for beating it? Well, some players will try
    hard to get it then, but on the other hand, some players might not be able to
    get it even after countless tries, and they will be irritated that they can't
    get the unlockables. So, a challenge should be hard but reasonable. And as I said,
    the players should see their performance improving as they keep making more attempts.
    Seeing that improvement in their performance gives the players a sense of hope.
    As they do better and better with each attempt, they feel like their goal is getting
    ever closer. The players feel like they can do it if they just keep trying a little
    more. On the other hand, a level where you just have to retry 15 million times
    until you get lucky and pull it off has the opposite effect. If the players does
    not see any noticeable improvement in their attempts at the level, they will feel
    that they are not getting any better, and therefore, it is a waste of time to
    keep trying. The players will lose hope. It is OK to have some really tough challenges,
    but they should be optional and generally should not have unlockables for beating
    them. Again, this is just my opinion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果你为击败它设置了酷炫的奖励会怎样呢？嗯，一些玩家会努力去获得它，但另一方面，一些玩家可能尝试了无数次后仍然无法获得它，他们会因为无法解锁而感到恼火。所以，挑战应该是困难的但又是合理的。正如我所说的，玩家应该看到他们的表现随着他们不断尝试而提高。看到他们在表现上的进步给了玩家一种希望的感觉。随着他们每次尝试都做得更好，他们感觉他们的目标越来越近。玩家感觉只要他们再稍微努力一点就能做到。另一方面，一个你需要重试1500万次才能幸运地完成关卡的水平，会产生相反的效果。如果玩家在尝试这个关卡时看不到任何明显的进步，他们会觉得自己没有变得更好，因此，继续尝试是浪费时间。玩家会失去希望。有一些非常困难的挑战是可以的，但它们应该是可选的，并且通常不应该有击败它们后解锁的内容。再次强调，这只是我的观点。
- en: Manipulating the player's emotions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作玩家的情绪
- en: This brings us to another point that is sometimes a bit overlooked. If you think
    about it, one of the things that video games do at their core is manipulating
    the emotions of the player. If the players become mad, they may quit and maybe
    never play the game again. But beyond that kind of thing, manipulating the player's
    emotions goes much deeper. For example, games make players emotionally connected
    to certain characters, and make them hate others. Manipulating the player's emotions
    can be embedded in the basic gameplay mechanics as well. If the player earns rewards
    regularly, it makes them feel good and also gives them more reason to keep going.
    On the other hand, a deep and powerful story can do the same thing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个有时被忽视的观点。如果你仔细想想，电子游戏在其核心功能之一就是操纵玩家的情绪。如果玩家变得愤怒，他们可能会退出，也许永远不再玩这个游戏。但除此之外，操纵玩家的情绪要深入得多。例如，游戏让玩家与某些角色产生情感上的联系，并让他们讨厌其他人。操纵玩家的情绪可以嵌入到基本的游戏玩法机制中。如果玩家定期获得奖励，这会让他们感觉良好，并给他们更多继续前进的理由。另一方面，一个深刻而强大的故事也能达到同样的效果。
- en: So, as you can see, there are many tools and problems to overcome in the world
    of game design. But if you love video games and have a desire to create them,
    all the work is worth it in the end when you see your finished game in action,
    and hopefully get lots of good feedback from your fans.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所见，在游戏设计的世界中，有许多工具和问题需要克服。但如果你热爱电子游戏，并渴望创造它们，当你看到你的成品游戏在运行中，并且希望从你的粉丝那里得到很多积极的反馈时，所有的努力最终都是值得的。
- en: Lastly, one of the best tips for new game programmers is to start small. Don't
    get too ambitious because if you bite off more than you can chew, you will likely
    end up with a project that never gets finished. And those are definitely not the
    kind of projects we want to make!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于新游戏程序员来说，最好的建议之一是从小开始。不要过于雄心勃勃，因为如果你承担了超出你能力范围的工作，你很可能会结束一个永远无法完成的项目。那些绝对不是我们想要做的项目！
- en: If you do become an indie developer, congratulations are in order! In this case,
    you should try to communicate well with your fans. They will appreciate it a lot,
    and they are also a source of great ideas that you could potentially integrate
    into your games.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的成为了一名独立开发者，那么恭喜你！在这种情况下，你应该努力与你的粉丝进行良好的沟通。他们会非常感激，他们也是你可能会将它们整合到你的游戏中的伟大想法的来源。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier, don't forget to include error handling in your code. This
    is extremely important in case the user doesn't have a compatible sound card or
    video card installed for example. So, when you create your DirectSound / XAudio2
    or Direct3D / DirectInput device, make sure that it is not null right after creating
    it as this obviously won't work very well. Your program will probably crash.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some excellent books and websites if you are
    seriously interested in game programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Websites
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SlimDX website— [http://slimdx.org/](http://slimdx.org/)—has a documentation
    section where you can see all of the SlimDX classes and their members. Unfortunately,
    it is incomplete at the time of this writing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to the SlimDX website, you can go to the SharpDX website,
    [http://sharpdx.org/](http://sharpdx.org/). This site also has a documentation
    section, and it is currently more complete than SlimDX's documentation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the classes in SharpDX are the same as their SlimDX counterparts, but
    there are some differences between these two. SharpDX is just an alternative to
    SlimDX. So most of the time, you can look at their documentation for help with
    SlimDX, but sometimes, it might not be accurate with the documentation of SlimDX
    because of the differences between the two. It's a good resource nonetheless.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The GameDev.net website—[http://www.Gamedev.net](http://www.Gamedev.net)—is
    a great resource for game developers. If you get really stuck and need help with
    something in SlimDX, their forums are an excellent place to ask questions. They
    have a lot of articles on the site too.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This site encompasses much more than just game development with SlimDX and C#.
    They also have an archive of the older articles since restructuring the site,
    which can be found at [http://archive.gamedev.net/archive/reference/](http://archive.gamedev.net/archive/reference/)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The Stack Overflow website— [http://stackoverflow.com/](http:// http://stackoverflow.com/)—is
    a place to ask questions, and people can comment on them and help you solve an
    issue. In fact, I used this site to help me solve a particularly tricky problem
    that I ran into while creating [Chapter 5](ch05.html "Chapter 5. Rendering Simple
    3D Graphics"), *Rendering Simple 3D Graphics*, of this book!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The two websites, [http://braynzarsoft.net/index.php?p=DX11Lessons](http://braynzarsoft.net/index.php?p=DX11Lessons
    ) and [http://www.rastertek.com/tutdx11.html](http://www.rastertek.com/tutdx11.html),
    have a number of good Direct3D 11 tutorials on them. Just be aware that these
    tutorials use C++; so, you'll have to figure out how to write the same code in
    SlimDX. Most objects in SlimDX have the same names as their native C++ counterparts;
    so, in most cases, this process is fairly easy to carry out.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The Riemers XNA Tutorials website— [http://www.riemers.net/](http://www.riemers.net/)—has
    some very nice XNA tutorials for new game programmers, making it a great resource
    for those just getting into game programming to learn more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The ShaderX Books website— [http://tog.acm.org/resources/shaderx/](http://tog.acm.org/resources/shaderx/)—has
    a series of books called *ShaderX*, and several of them are available as free
    downloads!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The NVIDIA Developer Zone website's page— [http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html](http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html)—for
    the book, *GPU Gems*, has excerpts from the book to give you an idea of what's
    in it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Books
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to learn more about the underlying concepts such as how graphics
    are actually rendered at the lowest levels in game development, check out these
    two books by André LaMothe:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '*Tricks of the Windows Game Programming Gurus, André LaMothe, Sams Publishing*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tricks of the 3D Game Programming Gurus: Advanced Graphics and Rasterization,
    André LaMothe, Sams Publishing*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these books by André LaMothe are quite excellent. The first one focuses
    on 2D development, player input with DirectInput, basic AI, collision detection,
    and more. The second book provides a very nice primer on the mathematics of 3D
    video games and focuses on the realm of 3D graphics and much more.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I''d like to mention a book that I came in contact with in the beginning
    of this year (2013), and it turned out to be an excellent one: *Game Coding Complete:
    Fourth Edition, Mike McShaffry and David "Rez" Graham, Cengage Learning*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: This book is excellent because it covers many things that are left out in lots
    of books on DirectX. For example, many books teach you how to draw graphics on
    the screen, but they don't really teach you how to go about building a real game.
    This book covers many aspects of creating the various systems that are found in
    every video game. As such, this book is truly invaluable to any serious game programmer
    wanting to learn all this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The book *3D Math Primer for Graphics and Game Development*, *Fletcher Dunn*,
    *Ian Parberry*, *A K Peters/CRC Press* covers the mathematics of 3D games in great
    detail, and explains the theory behind the concepts as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a handful of miscellaneous topics that we skimmed
    over in this book. Most of them could fill a book on their own. We looked at clipping
    and why it's important, and then moved on to collision detection and physics.
    Then, we took a look at multithreaded programming and its advantages for video
    games. After that, we took a look at some of the problems and pitfalls of game
    design. And lastly, we looked at some further reading materials.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on completing the book! May you create many awesome games in
    the future, and thank you for taking the time to read this book. Good luck with
    your continuing adventures down the path of game design!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
