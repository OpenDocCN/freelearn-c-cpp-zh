- en: Chapter 6. Where to Go from Here
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 接下来去哪里
- en: We've finally reached the end of our journey for now, but there is far more
    to learn about game programming. Along the way, we learned how to begin building
    a game development framework to build on in the future, handle user input with
    DirectInput and XInput, render 2D graphics and tile-based worlds with Direct2D,
    add sound and music to our game worlds with DirectSound and XAudio2, and lastly,
    how to do basic 3D graphics rendering with Direct3D. So, in this chapter, we will
    take a look at where to go from here in expanding your game development knowledge
    as well as a handful of important topics that we covered briefly in this book
    and some that we didn't cover.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在终于到达了这段旅程的终点，但关于游戏编程的学习还有很多。在这个过程中，我们学习了如何开始构建一个游戏开发框架，以便在未来继续构建，使用DirectInput和XInput处理用户输入，使用Direct2D渲染2D图形和基于瓦片的宇宙，使用DirectSound和XAudio2为我们的游戏世界添加声音和音乐，最后，如何使用Direct3D进行基本的3D图形渲染。因此，在本章中，我们将探讨如何继续扩展你的游戏开发知识，以及一些我们在本书中简要介绍的一些重要主题，以及一些我们没有涉及的主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Clipping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪
- en: Collision detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Artificial Intelligence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能
- en: Physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理学
- en: Multithreaded programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程编程
- en: Game design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏设计
- en: Further reading
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Culling and clipping
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剔除和裁剪
- en: We talked briefly about this concept in the previous chapter while working on
    our *Cube* demo. **Culling** in 2D terms means removing or skipping objects that
    are not within the bounds of the screen rather than wasting time drawing things
    that aren't visible anyway. In 3D terms, the meaning is much the same, but it's
    obviously a bit more complicated since you have that third dimension to deal with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建*Cube*演示时，我们在上一章中简要讨论了这一概念。在2D术语中，**剔除**意味着移除或跳过屏幕边界之外的对象，而不是浪费时间绘制那些无论如何都不可见的东西。在3D术语中，意义大致相同，但由于需要处理第三个维度，所以显然要复杂一些。
- en: '**Clipping** is the removal of the portions of individual triangles of our
    game objects that are not seen fully on the screen. The part of the triangle that
    is off screen is removed. Direct3D handles clipping for us in its graphics pipeline,
    but the culling is left to us. Culling is the removal or skipping of entire objects
    in the scene that do not need to be drawn, since they are not currently visible.
    Direct3D can do backface culling for us though. This is the removal of the back
    face of a triangle that is facing away from the camera. We can''t see it, so we
    don''t need to draw it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**裁剪**是指移除游戏对象中那些在屏幕上无法完全看到的三角形部分。屏幕外的三角形部分会被移除。Direct3D在我们的图形管道中为我们处理裁剪，但剔除则留给了我们。剔除是指移除或跳过场景中那些不需要绘制、当前不可见的整个对象。尽管Direct3D可以为我们处理背面剔除。这是移除面向相机的三角形背面。由于我们看不到它，因此不需要绘制它。'
- en: Culling and clipping are used in most modern video games. It is a very important
    concept because it can give you significant performance gains. The more objects
    there are in your game world, the longer it will take the computer to loop through
    and draw every single one of them. So, clipping can save a lot of time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 剔除和裁剪在大多数现代视频游戏中都被使用。这是一个非常重要的概念，因为它可以给你带来显著的性能提升。你的游戏世界中对象越多，计算机循环遍历并绘制每一个对象所需的时间就越长。因此，裁剪可以节省很多时间。
- en: This is not the only way of limiting what gets drawn in each frame though. There
    are other methods used in many games to make sure that objects are not drawn unnecessarily.
    For example, if there is a wall or other obstruction between the player and an
    object, we don't need to draw that object since the player can't see it anyway
    (unless, of course, there is a window or something). This is a little trickier
    to do. The point is that like with most things, there is more than one way to
    get the job done.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是限制每帧绘制内容的唯一方法。许多游戏中使用了其他方法来确保对象不会被不必要地绘制。例如，如果玩家和对象之间有一堵墙或其他障碍物，我们不需要绘制那个对象，因为玩家无论如何都看不到它（除非，当然，有一个窗户或类似的东西）。这有点棘手。关键是，就像大多数事情一样，完成这项工作有不止一种方法。
- en: Collision detection
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: '**Collision detection** is what it sounds like; detecting collisions of objects
    in your game world. In two dimensions, it''s relatively easy since everything
    generally has simple square shaped **bounding boxes**. A bounding box is an imaginary
    shape around the object that we use to detect collisions. You just test if the
    bounding boxes of two objects intersect each other, and if so, you know that they
    have collided. Of course, they are invisible to the player since we never draw
    our bounding boxes on the screen. However, it could be useful to add code to your
    game that lets you see the bounding boxes for debugging purposes, and verify that
    they are working as intended. Another good idea is to add a developer console
    to your game like those seen in many first-person-shooter games such as *Half-Life
    2*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞检测**正如其名；检测游戏世界中对象的碰撞。在二维空间中，由于一切通常都具有简单的方形**边界框**，所以相对容易。边界框是围绕对象的一个想象中的形状，我们用它来检测碰撞。你只需测试两个对象的边界框是否相交，如果是的话，你就知道它们已经发生了碰撞。当然，它们对玩家来说是不可见的，因为我们从未在屏幕上绘制我们的边界框。然而，为调试目的添加代码以让你看到边界框可能很有用，并验证它们是否按预期工作。另一个好主意是在你的游戏中添加一个开发者控制台，就像在许多第一人称射击游戏中看到的那样，例如*半条命2*。'
- en: In 3D, it gets more complicated. There are various types of bounding boxes that
    you can use. The commonly used ones are cubical or spherical bounding boxes. The
    cubic ones don't necessarily need to be perfect cubes. They can essentially be
    of any size, or have a longer width than height, for example. The spherical variety
    is usually a perfect sphere around an object but it, could be oblong though if
    the object is taller than it is wide. The spherical bounding boxes also behave
    a bit differently since you won't have cases where just the corners of two bounding
    boxes intersect, since spheres do not have corners like cubes do. You could also
    use different types of bounding boxes in 2D, of course.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维空间中，事情变得更加复杂。你可以使用各种类型的边界框。常用的有立方体或球形边界框。立方体不一定需要是完美的立方体。它们可以是任何大小，或者宽度比高度长，例如。球形边界框通常是一个围绕对象的完美球体，但如果对象的高度比宽度大，它也可能是细长的。球形边界框的行为也略有不同，因为你不会有两个边界框的角仅仅相交的情况，因为球体没有像立方体那样的角。当然，你也可以在二维中使用不同类型的边界框。
- en: Artificial Intelligence
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能
- en: '**Artificial Intelligence** (**AI**) refers to the intelligence that we code
    into the creatures in our game worlds. It is essentially the code that controls
    the actions of a creature. How smart this code is determines how smart our creature
    is. Of course, this concept is closely linked to **path finding** as well. Path
    finding is the process of finding a path that will allow the creature to reach
    its intended destination. One path finding algorithm is the `A*` algorithm (see
    [http://en.wikipedia.org/wiki/A*_search_algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）指的是我们编码到游戏世界中生物的智能。这本质上是指控制生物行为的代码。这段代码的智能程度决定了我们的生物的智能程度。当然，这个概念也与**路径查找**紧密相关。路径查找是寻找一条路径，使生物能够到达其目标位置的过程。一种路径查找算法是`A*`算法（见[http://en.wikipedia.org/wiki/A*_search_algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm)）。'
- en: Of course, we can't process this based on the geometry of the world. It would
    be too complicated and take too long. One way of doing this is using **waypoints**.
    Waypoints are essentially markers that are scattered about the world in strategic
    places. For example, an intersection in several paths will be a good place for
    a waypoint. The path-finding code simply finds the nearest waypoint to the creature's
    current position, and from there it finds a path from waypoint-to-waypoint that
    will get it to the desired destination. This is obviously much simpler and faster
    than trying to compute a path based on the actual geometry of the world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不能根据世界的几何形状来处理这个问题。这会太复杂，也太耗时。一种方法是用**航点**。航点本质上是在世界中的战略位置散布的标记。例如，几条路径的交汇处将是一个很好的航点位置。路径查找代码简单地找到生物当前位置最近的航点，然后从那里找到从航点到航点的路径，使其到达期望的目的地。这显然比尝试根据世界的实际几何形状计算路径要简单得多。
- en: Physics
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理
- en: Physics is closely tied in with collision detection since collision detection
    is integral to the physics of your game. If two objects collide, we need to detect
    this so that we can make them behave realistically. It will look pretty silly
    if they both just stopped in their tracks upon colliding, or just kept going as
    though they were both ghosts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 物理与碰撞检测紧密相关，因为碰撞检测是游戏物理的核心。如果两个物体发生碰撞，我们需要检测这一点，以便让它们表现得更加真实。如果它们在碰撞时都突然停下来，或者像幽灵一样继续前进，看起来会很愚蠢。
- en: Physics is a very complicated subject and relies heavily on mathematics. It
    is essentially just the use of mathematics to calculate the movement of objects
    in our game world. Of course, you can tweak your physics a bit if you want in
    order to achieve different effects. For example, you might make your physics work
    a little differently if your game has a cartoon-styled world as opposed to a realistic
    world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学是一个非常复杂的学科，并且高度依赖于数学。它本质上只是使用数学来计算我们游戏世界中物体的运动。当然，如果你想达到不同的效果，你可以稍微调整一下你的物理设置。例如，如果你的游戏有一个卡通风格的世界而不是一个真实世界，你的物理可能就会有所不同。
- en: The bounding boxes that we talked about in the previous section are generally
    inside the physics system of a game since that's where they are used. The physics
    system in a game is generally responsible for simulating the physics of objects
    in the game world. It is also common to give objects a *sleep* state or *idle*
    state, as it is often called. When the object is in this state, the physics system
    will ignore the object, and not do any physics simulation for it. This allows
    you to have physics turned off for a given object until it's needed. This can
    bring huge performance benefits because physics, being full of mathematics, can
    be relatively slow to run. The performance benefits increase when you have more
    objects that are in this state (since they aren't moving or doing anything anyway),
    and so, you're effectively saving the physics system from doing a lot of unnecessary
    work. After all, there is no point in wasting time running the physics code on
    an object that is not moving or doing anything.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中提到的边界框通常位于游戏的物理系统中，因为它们在那里被使用。游戏中的物理系统通常负责模拟游戏世界中物体的物理。通常也会给物体一个*睡眠*状态或*空闲*状态，通常被称为。当物体处于这种状态时，物理系统会忽略该物体，不会对其进行任何物理模拟。这允许你在需要之前关闭特定物体的物理，这样可以带来巨大的性能提升，因为物理，充满了数学，可能运行起来相对较慢。当你有更多处于这种状态的物体时（因为它们本来就没有移动或做任何事情），性能提升会更大，因此，你实际上是在有效地节省物理系统进行大量不必要的计算。毕竟，对一个不移动或不做任何事情的对象运行物理代码是浪费时间的。
- en: Multithreaded programming
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程编程
- en: Normally, a program has a single thread of execution. A thread is basically
    code that is being run by one of the cores in a system that has multi-core processors.
    Most modern processors have this feature, though it should be noted that you can
    still have multiple threads on a single-core CPU. I wanted to include this topic
    because multithreading is very useful in processor-intensive applications such
    as video games.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个程序只有一个执行线程。线程基本上是正在由具有多核处理器的系统中的一个核心运行的代码。大多数现代处理器都有这个特性，尽管应该注意的是，即使在单核CPU上也可以有多个线程。我想包括这个主题，因为多线程在处理密集型应用，如视频游戏，中非常有用。
- en: Basically, multithreading lets you have more than one point of execution running
    in your application at the same time. So, for example, you could have one thread
    doing some background work such as loading resources (graphics and sounds) in
    a large world similar to those found in *Minecraft*. As the player moves, the
    game has to load in the next chunks of the world, and unload the ones that are
    now too far behind the player. So, you could have one thread that handles loading
    new world chunks as the player moves around in the world, while the main thread
    keeps running the game code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，多线程允许你在应用程序中同时运行多个执行点。例如，你可以有一个线程执行一些后台工作，比如在一个类似《我的世界》的大型世界中加载资源（图形和声音）。随着玩家的移动，游戏需要加载世界的下一部分，并卸载那些现在离玩家太远的部分。因此，你可以有一个线程在玩家在世界中移动时处理加载新的世界块，而主线程则继续运行游戏代码。
- en: Of course, you are not limited to just two threads either. It is common for
    applications to create a group of threads and assign jobs to them. This is handy
    if there are numerous tasks that need to be done. You just make a thread manager
    class, and pass in the function that you will call to do the job that needs to
    be done. The thread manager will look at its threads (collectively known as a
    **thread pool**) and find the one that is idle. If it finds an idle **worker thread**
    , it will start it by running the function you passed in. A worker thread is just
    a thread that is a member of a thread pool, and it gets its name since it does
    various jobs for us.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也不必局限于仅仅两个线程。应用程序通常创建一组线程并将任务分配给它们。如果有许多任务需要完成，这会很有用。你只需创建一个线程管理器类，并传入你将调用的函数来完成需要完成的任务。线程管理器会查看其线程（统称为**线程池**），并找到空闲的那个。如果它找到一个空闲的**工作线程**，它将通过运行你传入的函数来启动它。工作线程只是线程池中的一个线程，它之所以得名是因为它为我们做各种工作。
- en: Running multiple bits of code simultaneously like this can obviously have significant
    performance benefits. However, multithreaded programming is also a rather tricky
    subject. You have to make sure that you don't have two threads accessing the same
    data at the same time, as this can cause big problems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行多个代码片段显然可以带来显著的性能优势。然而，多线程编程也是一个相当棘手的话题。你必须确保不要有两个线程同时访问相同的数据，因为这可能会引起大问题。
- en: Game design
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计
- en: Game design might seem fairly simple, but there is a lot more to it than most
    people think at first. Game design encompasses deciding on the style of your graphics,
    what the world will look like, the mood, designing the main gameplay mechanics
    of the game, the overall goal for the player, and the basic story idea. Of course,
    often there are graphic and sound artists who do the actual work of creating the
    graphics and sound for the game. But the graphics and sound styles first need
    to be specified in the game design, or the artists won't know what sort of graphics
    and sound to create.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计可能看起来相当简单，但其中包含的远比大多数人最初想象的要多。游戏设计包括决定图形的风格、世界将是什么样子、氛围、设计游戏的主要游戏玩法机制、玩家的整体目标以及基本的故事想法。当然，通常会有图形和声音艺术家来完成游戏图形和声音的实际工作。但图形和声音的风格首先需要在游戏设计中指定，否则艺术家不知道要创建什么样的图形和声音。
- en: Probably the most important thing about a game is that it is fun. If it is not
    fun, the players won't play it. However, it's not quite so simple because different
    players like different types of games. So, what is fun for one player may not
    be for another. So don't try to please everyone as this is generally not possible.
    If you do, you could easily find yourself chasing an unreachable goal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏可能最关键的一点是它很有趣。如果不好玩，玩家就不会玩。然而，这并不那么简单，因为不同的玩家喜欢不同类型的游戏。所以，对某个玩家来说有趣的东西可能对另一个玩家来说就不一定有趣。所以不要试图取悦所有人，因为这通常是不可能的。如果你这样做，你可能会发现自己追逐一个无法达到的目标。
- en: 'In the world of game design, there can be arguments about the most important
    element. Some will say graphics, and others will say gameplay. However, in reality,
    they are both very important. Graphics make a game look good, but graphics don''t
    have to be realistic. They can be cartoony or have other styles that don''t look
    realistic. This doesn''t make a game bad by any means. A good example of this
    is Nintendo''s *The Legend of Zelda: The Wind Waker HD* that uses a graphical
    style known as **toon shading** to give its world a cartoony look.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏设计的世界里，可能会有人争论最重要的元素是什么。有些人会说图形，而有些人会说游戏玩法。然而，在现实中，它们都非常重要。图形可以让游戏看起来很好，但图形不一定要逼真。它们可以是卡通风格，或者有其他看起来不逼真的风格。这并不意味着游戏不好。一个很好的例子是任天堂的《塞尔达传说：时之笛
    HD》，它使用了一种名为**卡通渲染**的图形风格，使其世界看起来像卡通。
- en: The final experience that you get from a game is not down to just graphics,
    gameplay, or sound. It's a combination of all of the elements that come together
    to create the final game. Of course, controls are very important because they
    are the interface between the player and the game. If the interface is weird or
    doesn't work well, players probably won't play the game much. Sound effects and
    music set the mood for the game world, and the graphics provide the visuals and
    contribute to the mood as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你从游戏中获得的最终体验并不仅仅取决于图形、游戏玩法或音效。它是所有结合在一起创造最终游戏体验的元素的综合体。当然，控制非常重要，因为它们是玩家与游戏之间的接口。如果接口奇怪或者工作不顺畅，玩家可能不会玩很多游戏。音效和音乐为游戏世界设定了氛围，而图形则提供了视觉元素，并有助于营造氛围。
- en: Game difficulty
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏难度
- en: Probably one of the trickiest aspects of game design is the game difficulty.
    You don't want to make it too easy, or some players will get bored and quit. Likewise,
    if you make it too difficult, some players will rage quit. So, how do we deal
    with this issue? One way is to make your game have multiple difficulty levels
    so that the players can select the one they want. Most commonly, they are named
    `Easy`, `Normal`, `Hard`, and sometimes `Very Hard`. Another solution is known
    as **adaptive difficulty**. This is when a game looks at how well the player is
    doing, and adjusts the difficulty as needed. If the player is doing really well,
    it will increase the difficulty a bit, and if the player is having trouble, it
    would decrease it to some extent.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计中可能最棘手的一个方面就是游戏难度。你不想让它太简单，否则一些玩家会感到无聊并放弃。同样，如果你让它太难，一些玩家可能会愤怒地退出。那么，我们如何处理这个问题呢？一种方法是为你的游戏设置多个难度级别，让玩家可以选择他们想要的难度。最常见的难度级别是“简单”、“普通”、“困难”，有时还有“非常困难”。另一种解决方案被称为**自适应难度**。这意味着游戏会观察玩家的表现，并根据需要调整难度。如果玩家表现非常好，它会稍微提高难度，如果玩家遇到困难，它会适当地降低难度。
- en: Another aspect of difficulty is known as game **progression**. Progression refers
    to how the difficulty increases as you progress through the game. It should start
    out increasing slowly and then the rate of increase goes up faster as you move
    further and further into the game. So obviously, the difficulty should not suddenly
    shoot up by 100 percent from one level to the next as that will cause frustration
    in the players.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 难度的另一个方面被称为游戏**进度**。进度指的是随着你在游戏中前进，难度是如何增加的。它应该开始时缓慢增加，然后随着你进一步深入游戏，增加的速度会更快。因此，难度不应该从一个等级突然上升到下一个等级的100%，因为这会在玩家中引起挫败感。
- en: This brings us to the idea of challenges. Some games provide challenge levels
    for the hardcore players to enjoy. This is a good idea, but they shouldn't be
    so ridiculously hard that it takes forever to beat them. This is just my opinion,
    but a well-designed challenge should be one where the players can see themselves
    getting better as they keep making more attempts at it. If it's one of those levels
    where you just try 15 million times until you finally pull it off, sure it's hard,
    but its not a well-designed challenge because most players will probably give
    up long before they succeed. Why? It's because they will likely see it as a waste
    of time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了挑战的概念。一些游戏为硬核玩家提供了挑战级别以供享受。这是一个好主意，但它们不应该太难以至于需要花费很长时间才能击败。这只是我的个人观点，但一个设计良好的挑战应该是一个玩家在持续尝试中能够看到自己进步的地方。如果这是一个你需要尝试1500万次才能最终成功的等级，当然它很困难，但这不是一个设计良好的挑战，因为大多数玩家可能在他们成功之前就会放弃。为什么？因为他们可能会认为这是浪费时间。
- en: So what if you make a cool reward for beating it? Well, some players will try
    hard to get it then, but on the other hand, some players might not be able to
    get it even after countless tries, and they will be irritated that they can't
    get the unlockables. So, a challenge should be hard but reasonable. And as I said,
    the players should see their performance improving as they keep making more attempts.
    Seeing that improvement in their performance gives the players a sense of hope.
    As they do better and better with each attempt, they feel like their goal is getting
    ever closer. The players feel like they can do it if they just keep trying a little
    more. On the other hand, a level where you just have to retry 15 million times
    until you get lucky and pull it off has the opposite effect. If the players does
    not see any noticeable improvement in their attempts at the level, they will feel
    that they are not getting any better, and therefore, it is a waste of time to
    keep trying. The players will lose hope. It is OK to have some really tough challenges,
    but they should be optional and generally should not have unlockables for beating
    them. Again, this is just my opinion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果你为击败它设置了酷炫的奖励会怎样呢？嗯，一些玩家会努力去获得它，但另一方面，一些玩家可能尝试了无数次后仍然无法获得它，他们会因为无法解锁而感到恼火。所以，挑战应该是困难的但又是合理的。正如我所说的，玩家应该看到他们的表现随着他们不断尝试而提高。看到他们在表现上的进步给了玩家一种希望的感觉。随着他们每次尝试都做得更好，他们感觉他们的目标越来越近。玩家感觉只要他们再稍微努力一点就能做到。另一方面，一个你需要重试1500万次才能幸运地完成关卡的水平，会产生相反的效果。如果玩家在尝试这个关卡时看不到任何明显的进步，他们会觉得自己没有变得更好，因此，继续尝试是浪费时间。玩家会失去希望。有一些非常困难的挑战是可以的，但它们应该是可选的，并且通常不应该有击败它们后解锁的内容。再次强调，这只是我的观点。
- en: Manipulating the player's emotions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作玩家的情绪
- en: This brings us to another point that is sometimes a bit overlooked. If you think
    about it, one of the things that video games do at their core is manipulating
    the emotions of the player. If the players become mad, they may quit and maybe
    never play the game again. But beyond that kind of thing, manipulating the player's
    emotions goes much deeper. For example, games make players emotionally connected
    to certain characters, and make them hate others. Manipulating the player's emotions
    can be embedded in the basic gameplay mechanics as well. If the player earns rewards
    regularly, it makes them feel good and also gives them more reason to keep going.
    On the other hand, a deep and powerful story can do the same thing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个有时被忽视的观点。如果你仔细想想，电子游戏在其核心功能之一就是操纵玩家的情绪。如果玩家变得愤怒，他们可能会退出，也许永远不再玩这个游戏。但除此之外，操纵玩家的情绪要深入得多。例如，游戏让玩家与某些角色产生情感上的联系，并让他们讨厌其他人。操纵玩家的情绪可以嵌入到基本的游戏玩法机制中。如果玩家定期获得奖励，这会让他们感觉良好，并给他们更多继续前进的理由。另一方面，一个深刻而强大的故事也能达到同样的效果。
- en: So, as you can see, there are many tools and problems to overcome in the world
    of game design. But if you love video games and have a desire to create them,
    all the work is worth it in the end when you see your finished game in action,
    and hopefully get lots of good feedback from your fans.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所见，在游戏设计的世界中，有许多工具和问题需要克服。但如果你热爱电子游戏，并渴望创造它们，当你看到你的成品游戏在运行中，并且希望从你的粉丝那里得到很多积极的反馈时，所有的努力最终都是值得的。
- en: Lastly, one of the best tips for new game programmers is to start small. Don't
    get too ambitious because if you bite off more than you can chew, you will likely
    end up with a project that never gets finished. And those are definitely not the
    kind of projects we want to make!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于新游戏程序员来说，最好的建议之一是从小开始。不要过于雄心勃勃，因为如果你承担了超出你能力范围的工作，你很可能会结束一个永远无法完成的项目。那些绝对不是我们想要做的项目！
- en: If you do become an indie developer, congratulations are in order! In this case,
    you should try to communicate well with your fans. They will appreciate it a lot,
    and they are also a source of great ideas that you could potentially integrate
    into your games.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的成为了一名独立开发者，那么恭喜你！在这种情况下，你应该努力与你的粉丝进行良好的沟通。他们会非常感激，他们也是你可能会将它们整合到你的游戏中的伟大想法的来源。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier, don't forget to include error handling in your code. This
    is extremely important in case the user doesn't have a compatible sound card or
    video card installed for example. So, when you create your DirectSound / XAudio2
    or Direct3D / DirectInput device, make sure that it is not null right after creating
    it as this obviously won't work very well. Your program will probably crash.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不要忘记在你的代码中包含错误处理。例如，如果用户没有安装兼容的声卡或显卡，这一点尤为重要。因此，当你创建你的DirectSound / XAudio2或Direct3D
    / DirectInput设备时，确保它创建后不是null，因为这显然不会工作得很好。你的程序可能会崩溃。
- en: Further reading
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: In this section, we will look at some excellent books and websites if you are
    seriously interested in game programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些优秀的书籍和网站，如果你对游戏编程真正感兴趣的话。
- en: Websites
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网站
- en: The SlimDX website— [http://slimdx.org/](http://slimdx.org/)—has a documentation
    section where you can see all of the SlimDX classes and their members. Unfortunately,
    it is incomplete at the time of this writing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SlimDX网站—[http://slimdx.org/](http://slimdx.org/)—有一个文档部分，你可以看到所有的SlimDX类及其成员。不幸的是，在撰写本文时，它是不完整的。
- en: As an alternative to the SlimDX website, you can go to the SharpDX website,
    [http://sharpdx.org/](http://sharpdx.org/). This site also has a documentation
    section, and it is currently more complete than SlimDX's documentation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为SlimDX网站的替代，你可以访问SharpDX网站，[http://sharpdx.org/](http://sharpdx.org/)。这个网站也有一个文档部分，目前它比SlimDX的文档更完整。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Most of the classes in SharpDX are the same as their SlimDX counterparts, but
    there are some differences between these two. SharpDX is just an alternative to
    SlimDX. So most of the time, you can look at their documentation for help with
    SlimDX, but sometimes, it might not be accurate with the documentation of SlimDX
    because of the differences between the two. It's a good resource nonetheless.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SharpDX类与它们的SlimDX对应类相同，但这两者之间有一些差异。SharpDX只是SlimDX的一个替代品。所以，大多数时候，你可以查看它们的文档来帮助解决SlimDX的问题，但有时，由于两者之间的差异，它可能不会与SlimDX的文档完全准确。不过，它仍然是一个很好的资源。
- en: The GameDev.net website—[http://www.Gamedev.net](http://www.Gamedev.net)—is
    a great resource for game developers. If you get really stuck and need help with
    something in SlimDX, their forums are an excellent place to ask questions. They
    have a lot of articles on the site too.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GameDev.net网站—[http://www.Gamedev.net](http://www.Gamedev.net)—是游戏开发者的一大资源。如果你真的遇到了难题，需要帮助解决SlimDX中的某个问题，他们的论坛是提问的好地方。网站上也有很多文章。
- en: This site encompasses much more than just game development with SlimDX and C#.
    They also have an archive of the older articles since restructuring the site,
    which can be found at [http://archive.gamedev.net/archive/reference/](http://archive.gamedev.net/archive/reference/)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站不仅涵盖了使用SlimDX和C#进行游戏开发的内容，还有自网站重构以来的旧文章存档，可以在[http://archive.gamedev.net/archive/reference/](http://archive.gamedev.net/archive/reference/)找到。
- en: The Stack Overflow website— [http://stackoverflow.com/](http:// http://stackoverflow.com/)—is
    a place to ask questions, and people can comment on them and help you solve an
    issue. In fact, I used this site to help me solve a particularly tricky problem
    that I ran into while creating [Chapter 5](ch05.html "Chapter 5. Rendering Simple
    3D Graphics"), *Rendering Simple 3D Graphics*, of this book!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Stack Overflow网站—[http://stackoverflow.com/](http://http://stackoverflow.com/)—是一个提问的地方，人们可以对其评论并帮助你解决问题。实际上，我使用这个网站帮助我解决了一个我在创建本书[第5章](ch05.html
    "第5章。渲染简单的3D图形")时遇到的特别棘手的问题！
- en: The two websites, [http://braynzarsoft.net/index.php?p=DX11Lessons](http://braynzarsoft.net/index.php?p=DX11Lessons
    ) and [http://www.rastertek.com/tutdx11.html](http://www.rastertek.com/tutdx11.html),
    have a number of good Direct3D 11 tutorials on them. Just be aware that these
    tutorials use C++; so, you'll have to figure out how to write the same code in
    SlimDX. Most objects in SlimDX have the same names as their native C++ counterparts;
    so, in most cases, this process is fairly easy to carry out.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个网站，[http://braynzarsoft.net/index.php?p=DX11Lessons](http://braynzarsoft.net/index.php?p=DX11Lessons)和[http://www.rastertek.com/tutdx11.html](http://www.rastertek.com/tutdx11.html)，上有许多优秀的Direct3D
    11教程。只是要注意，这些教程使用的是C++；因此，你将不得不找出如何在SlimDX中编写相同的代码。SlimDX中的大多数对象与它们的原生C++版本有相同的名称；所以，在大多数情况下，这个过程相对容易执行。
- en: The Riemers XNA Tutorials website— [http://www.riemers.net/](http://www.riemers.net/)—has
    some very nice XNA tutorials for new game programmers, making it a great resource
    for those just getting into game programming to learn more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Riemers XNA教程网站— [http://www.riemers.net/](http://www.riemers.net/)—为新手游戏程序员提供了一些非常棒的XNA教程，对于刚开始接触游戏编程并想了解更多的人来说，这是一个极好的资源。
- en: The ShaderX Books website— [http://tog.acm.org/resources/shaderx/](http://tog.acm.org/resources/shaderx/)—has
    a series of books called *ShaderX*, and several of them are available as free
    downloads!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ShaderX书籍网站— [http://tog.acm.org/resources/shaderx/](http://tog.acm.org/resources/shaderx/)—有一系列名为*ShaderX*的书籍，其中几本可以免费下载！
- en: The NVIDIA Developer Zone website's page— [http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html](http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html)—for
    the book, *GPU Gems*, has excerpts from the book to give you an idea of what's
    in it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: NVIDIA开发者区域网站上的*GPU Gems*书籍页面— [http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html](http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html)—提供了书籍的摘录，以给你一个关于书中内容的想法。
- en: Books
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 书籍
- en: 'If you wish to learn more about the underlying concepts such as how graphics
    are actually rendered at the lowest levels in game development, check out these
    two books by André LaMothe:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于底层概念，例如在游戏开发中图形是如何在最低级别实际渲染的，可以查看安德烈·拉莫特（André LaMothe）的这两本书：
- en: '*Tricks of the Windows Game Programming Gurus, André LaMothe, Sams Publishing*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Windows游戏编程大师技巧，安德烈·拉莫特（André LaMothe），Sams Publishing》*'
- en: '*Tricks of the 3D Game Programming Gurus: Advanced Graphics and Rasterization,
    André LaMothe, Sams Publishing*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《3D游戏编程大师技巧：高级图形和光栅化，安德烈·拉莫特（André LaMothe），Sams Publishing》*'
- en: Both of these books by André LaMothe are quite excellent. The first one focuses
    on 2D development, player input with DirectInput, basic AI, collision detection,
    and more. The second book provides a very nice primer on the mathematics of 3D
    video games and focuses on the realm of 3D graphics and much more.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈·拉莫特（André LaMothe）的这两本书都非常优秀。第一本专注于2D开发，DirectInput的玩家输入，基本AI，碰撞检测等。第二本书提供了关于3D视频游戏数学的非常好的入门，并专注于3D图形领域以及更多内容。
- en: 'Next, I''d like to mention a book that I came in contact with in the beginning
    of this year (2013), and it turned out to be an excellent one: *Game Coding Complete:
    Fourth Edition, Mike McShaffry and David "Rez" Graham, Cengage Learning*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想提到一本我在今年（2013年）初接触到的书，结果证明它非常优秀：*《游戏编程完全指南：第四版，迈克·麦克沙弗里（Mike McShaffry）和大卫“Rez”格雷厄姆（David
    "Rez" Graham），Cengage Learning》*
- en: This book is excellent because it covers many things that are left out in lots
    of books on DirectX. For example, many books teach you how to draw graphics on
    the screen, but they don't really teach you how to go about building a real game.
    This book covers many aspects of creating the various systems that are found in
    every video game. As such, this book is truly invaluable to any serious game programmer
    wanting to learn all this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书非常优秀，因为它涵盖了众多DirectX书籍中遗漏的内容。例如，许多书籍教你如何在屏幕上绘制图形，但它们并没有真正教你如何构建一个真正的游戏。这本书涵盖了创建每个视频游戏中发现的各个系统的许多方面。因此，这本书对于任何想要学习所有这些内容的严肃游戏程序员来说，确实是极其宝贵的。
- en: The book *3D Math Primer for Graphics and Game Development*, *Fletcher Dunn*,
    *Ian Parberry*, *A K Peters/CRC Press* covers the mathematics of 3D games in great
    detail, and explains the theory behind the concepts as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍*《3D图形和游戏开发数学入门》，弗莱彻·邓恩（Fletcher Dunn），伊恩·帕伯里（Ian Parberry），A K Peters/CRC
    Press*详细介绍了3D游戏的数学，并解释了概念背后的理论。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a handful of miscellaneous topics that we skimmed
    over in this book. Most of them could fill a book on their own. We looked at clipping
    and why it's important, and then moved on to collision detection and physics.
    Then, we took a look at multithreaded programming and its advantages for video
    games. After that, we took a look at some of the problems and pitfalls of game
    design. And lastly, we looked at some further reading materials.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些在这本书中略过的杂项主题。其中许多主题本身就可以写成一本书。我们探讨了裁剪及其重要性，然后转向碰撞检测和物理。接着，我们探讨了多线程编程及其在视频游戏中的优势。之后，我们审视了一些游戏设计的问题和陷阱。最后，我们查看了一些进一步阅读的材料。
- en: Congratulations on completing the book! May you create many awesome games in
    the future, and thank you for taking the time to read this book. Good luck with
    your continuing adventures down the path of game design!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这本书！愿你在未来创造许多令人惊叹的游戏，并感谢你抽出时间阅读这本书。祝你在游戏设计之路上继续冒险好运！
