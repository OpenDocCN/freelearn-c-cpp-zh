- en: Chapter 6. Where to Go from Here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finally reached the end of our journey for now, but there is far more
    to learn about game programming. Along the way, we learned how to begin building
    a game development framework to build on in the future, handle user input with
    DirectInput and XInput, render 2D graphics and tile-based worlds with Direct2D,
    add sound and music to our game worlds with DirectSound and XAudio2, and lastly,
    how to do basic 3D graphics rendering with Direct3D. So, in this chapter, we will
    take a look at where to go from here in expanding your game development knowledge
    as well as a handful of important topics that we covered briefly in this book
    and some that we didn't cover.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Clipping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial Intelligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreaded programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Culling and clipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked briefly about this concept in the previous chapter while working on
    our *Cube* demo. **Culling** in 2D terms means removing or skipping objects that
    are not within the bounds of the screen rather than wasting time drawing things
    that aren't visible anyway. In 3D terms, the meaning is much the same, but it's
    obviously a bit more complicated since you have that third dimension to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clipping** is the removal of the portions of individual triangles of our
    game objects that are not seen fully on the screen. The part of the triangle that
    is off screen is removed. Direct3D handles clipping for us in its graphics pipeline,
    but the culling is left to us. Culling is the removal or skipping of entire objects
    in the scene that do not need to be drawn, since they are not currently visible.
    Direct3D can do backface culling for us though. This is the removal of the back
    face of a triangle that is facing away from the camera. We can''t see it, so we
    don''t need to draw it.'
  prefs: []
  type: TYPE_NORMAL
- en: Culling and clipping are used in most modern video games. It is a very important
    concept because it can give you significant performance gains. The more objects
    there are in your game world, the longer it will take the computer to loop through
    and draw every single one of them. So, clipping can save a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way of limiting what gets drawn in each frame though. There
    are other methods used in many games to make sure that objects are not drawn unnecessarily.
    For example, if there is a wall or other obstruction between the player and an
    object, we don't need to draw that object since the player can't see it anyway
    (unless, of course, there is a window or something). This is a little trickier
    to do. The point is that like with most things, there is more than one way to
    get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collision detection** is what it sounds like; detecting collisions of objects
    in your game world. In two dimensions, it''s relatively easy since everything
    generally has simple square shaped **bounding boxes**. A bounding box is an imaginary
    shape around the object that we use to detect collisions. You just test if the
    bounding boxes of two objects intersect each other, and if so, you know that they
    have collided. Of course, they are invisible to the player since we never draw
    our bounding boxes on the screen. However, it could be useful to add code to your
    game that lets you see the bounding boxes for debugging purposes, and verify that
    they are working as intended. Another good idea is to add a developer console
    to your game like those seen in many first-person-shooter games such as *Half-Life
    2*.'
  prefs: []
  type: TYPE_NORMAL
- en: In 3D, it gets more complicated. There are various types of bounding boxes that
    you can use. The commonly used ones are cubical or spherical bounding boxes. The
    cubic ones don't necessarily need to be perfect cubes. They can essentially be
    of any size, or have a longer width than height, for example. The spherical variety
    is usually a perfect sphere around an object but it, could be oblong though if
    the object is taller than it is wide. The spherical bounding boxes also behave
    a bit differently since you won't have cases where just the corners of two bounding
    boxes intersect, since spheres do not have corners like cubes do. You could also
    use different types of bounding boxes in 2D, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial Intelligence** (**AI**) refers to the intelligence that we code
    into the creatures in our game worlds. It is essentially the code that controls
    the actions of a creature. How smart this code is determines how smart our creature
    is. Of course, this concept is closely linked to **path finding** as well. Path
    finding is the process of finding a path that will allow the creature to reach
    its intended destination. One path finding algorithm is the `A*` algorithm (see
    [http://en.wikipedia.org/wiki/A*_search_algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm)).'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can't process this based on the geometry of the world. It would
    be too complicated and take too long. One way of doing this is using **waypoints**.
    Waypoints are essentially markers that are scattered about the world in strategic
    places. For example, an intersection in several paths will be a good place for
    a waypoint. The path-finding code simply finds the nearest waypoint to the creature's
    current position, and from there it finds a path from waypoint-to-waypoint that
    will get it to the desired destination. This is obviously much simpler and faster
    than trying to compute a path based on the actual geometry of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physics is closely tied in with collision detection since collision detection
    is integral to the physics of your game. If two objects collide, we need to detect
    this so that we can make them behave realistically. It will look pretty silly
    if they both just stopped in their tracks upon colliding, or just kept going as
    though they were both ghosts.
  prefs: []
  type: TYPE_NORMAL
- en: Physics is a very complicated subject and relies heavily on mathematics. It
    is essentially just the use of mathematics to calculate the movement of objects
    in our game world. Of course, you can tweak your physics a bit if you want in
    order to achieve different effects. For example, you might make your physics work
    a little differently if your game has a cartoon-styled world as opposed to a realistic
    world.
  prefs: []
  type: TYPE_NORMAL
- en: The bounding boxes that we talked about in the previous section are generally
    inside the physics system of a game since that's where they are used. The physics
    system in a game is generally responsible for simulating the physics of objects
    in the game world. It is also common to give objects a *sleep* state or *idle*
    state, as it is often called. When the object is in this state, the physics system
    will ignore the object, and not do any physics simulation for it. This allows
    you to have physics turned off for a given object until it's needed. This can
    bring huge performance benefits because physics, being full of mathematics, can
    be relatively slow to run. The performance benefits increase when you have more
    objects that are in this state (since they aren't moving or doing anything anyway),
    and so, you're effectively saving the physics system from doing a lot of unnecessary
    work. After all, there is no point in wasting time running the physics code on
    an object that is not moving or doing anything.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, a program has a single thread of execution. A thread is basically
    code that is being run by one of the cores in a system that has multi-core processors.
    Most modern processors have this feature, though it should be noted that you can
    still have multiple threads on a single-core CPU. I wanted to include this topic
    because multithreading is very useful in processor-intensive applications such
    as video games.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, multithreading lets you have more than one point of execution running
    in your application at the same time. So, for example, you could have one thread
    doing some background work such as loading resources (graphics and sounds) in
    a large world similar to those found in *Minecraft*. As the player moves, the
    game has to load in the next chunks of the world, and unload the ones that are
    now too far behind the player. So, you could have one thread that handles loading
    new world chunks as the player moves around in the world, while the main thread
    keeps running the game code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you are not limited to just two threads either. It is common for
    applications to create a group of threads and assign jobs to them. This is handy
    if there are numerous tasks that need to be done. You just make a thread manager
    class, and pass in the function that you will call to do the job that needs to
    be done. The thread manager will look at its threads (collectively known as a
    **thread pool**) and find the one that is idle. If it finds an idle **worker thread**
    , it will start it by running the function you passed in. A worker thread is just
    a thread that is a member of a thread pool, and it gets its name since it does
    various jobs for us.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple bits of code simultaneously like this can obviously have significant
    performance benefits. However, multithreaded programming is also a rather tricky
    subject. You have to make sure that you don't have two threads accessing the same
    data at the same time, as this can cause big problems.
  prefs: []
  type: TYPE_NORMAL
- en: Game design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game design might seem fairly simple, but there is a lot more to it than most
    people think at first. Game design encompasses deciding on the style of your graphics,
    what the world will look like, the mood, designing the main gameplay mechanics
    of the game, the overall goal for the player, and the basic story idea. Of course,
    often there are graphic and sound artists who do the actual work of creating the
    graphics and sound for the game. But the graphics and sound styles first need
    to be specified in the game design, or the artists won't know what sort of graphics
    and sound to create.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most important thing about a game is that it is fun. If it is not
    fun, the players won't play it. However, it's not quite so simple because different
    players like different types of games. So, what is fun for one player may not
    be for another. So don't try to please everyone as this is generally not possible.
    If you do, you could easily find yourself chasing an unreachable goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of game design, there can be arguments about the most important
    element. Some will say graphics, and others will say gameplay. However, in reality,
    they are both very important. Graphics make a game look good, but graphics don''t
    have to be realistic. They can be cartoony or have other styles that don''t look
    realistic. This doesn''t make a game bad by any means. A good example of this
    is Nintendo''s *The Legend of Zelda: The Wind Waker HD* that uses a graphical
    style known as **toon shading** to give its world a cartoony look.'
  prefs: []
  type: TYPE_NORMAL
- en: The final experience that you get from a game is not down to just graphics,
    gameplay, or sound. It's a combination of all of the elements that come together
    to create the final game. Of course, controls are very important because they
    are the interface between the player and the game. If the interface is weird or
    doesn't work well, players probably won't play the game much. Sound effects and
    music set the mood for the game world, and the graphics provide the visuals and
    contribute to the mood as well.
  prefs: []
  type: TYPE_NORMAL
- en: Game difficulty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably one of the trickiest aspects of game design is the game difficulty.
    You don't want to make it too easy, or some players will get bored and quit. Likewise,
    if you make it too difficult, some players will rage quit. So, how do we deal
    with this issue? One way is to make your game have multiple difficulty levels
    so that the players can select the one they want. Most commonly, they are named
    `Easy`, `Normal`, `Hard`, and sometimes `Very Hard`. Another solution is known
    as **adaptive difficulty**. This is when a game looks at how well the player is
    doing, and adjusts the difficulty as needed. If the player is doing really well,
    it will increase the difficulty a bit, and if the player is having trouble, it
    would decrease it to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of difficulty is known as game **progression**. Progression refers
    to how the difficulty increases as you progress through the game. It should start
    out increasing slowly and then the rate of increase goes up faster as you move
    further and further into the game. So obviously, the difficulty should not suddenly
    shoot up by 100 percent from one level to the next as that will cause frustration
    in the players.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the idea of challenges. Some games provide challenge levels
    for the hardcore players to enjoy. This is a good idea, but they shouldn't be
    so ridiculously hard that it takes forever to beat them. This is just my opinion,
    but a well-designed challenge should be one where the players can see themselves
    getting better as they keep making more attempts at it. If it's one of those levels
    where you just try 15 million times until you finally pull it off, sure it's hard,
    but its not a well-designed challenge because most players will probably give
    up long before they succeed. Why? It's because they will likely see it as a waste
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: So what if you make a cool reward for beating it? Well, some players will try
    hard to get it then, but on the other hand, some players might not be able to
    get it even after countless tries, and they will be irritated that they can't
    get the unlockables. So, a challenge should be hard but reasonable. And as I said,
    the players should see their performance improving as they keep making more attempts.
    Seeing that improvement in their performance gives the players a sense of hope.
    As they do better and better with each attempt, they feel like their goal is getting
    ever closer. The players feel like they can do it if they just keep trying a little
    more. On the other hand, a level where you just have to retry 15 million times
    until you get lucky and pull it off has the opposite effect. If the players does
    not see any noticeable improvement in their attempts at the level, they will feel
    that they are not getting any better, and therefore, it is a waste of time to
    keep trying. The players will lose hope. It is OK to have some really tough challenges,
    but they should be optional and generally should not have unlockables for beating
    them. Again, this is just my opinion.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the player's emotions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This brings us to another point that is sometimes a bit overlooked. If you think
    about it, one of the things that video games do at their core is manipulating
    the emotions of the player. If the players become mad, they may quit and maybe
    never play the game again. But beyond that kind of thing, manipulating the player's
    emotions goes much deeper. For example, games make players emotionally connected
    to certain characters, and make them hate others. Manipulating the player's emotions
    can be embedded in the basic gameplay mechanics as well. If the player earns rewards
    regularly, it makes them feel good and also gives them more reason to keep going.
    On the other hand, a deep and powerful story can do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, there are many tools and problems to overcome in the world
    of game design. But if you love video games and have a desire to create them,
    all the work is worth it in the end when you see your finished game in action,
    and hopefully get lots of good feedback from your fans.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, one of the best tips for new game programmers is to start small. Don't
    get too ambitious because if you bite off more than you can chew, you will likely
    end up with a project that never gets finished. And those are definitely not the
    kind of projects we want to make!
  prefs: []
  type: TYPE_NORMAL
- en: If you do become an indie developer, congratulations are in order! In this case,
    you should try to communicate well with your fans. They will appreciate it a lot,
    and they are also a source of great ideas that you could potentially integrate
    into your games.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, don't forget to include error handling in your code. This
    is extremely important in case the user doesn't have a compatible sound card or
    video card installed for example. So, when you create your DirectSound / XAudio2
    or Direct3D / DirectInput device, make sure that it is not null right after creating
    it as this obviously won't work very well. Your program will probably crash.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some excellent books and websites if you are
    seriously interested in game programming.
  prefs: []
  type: TYPE_NORMAL
- en: Websites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SlimDX website— [http://slimdx.org/](http://slimdx.org/)—has a documentation
    section where you can see all of the SlimDX classes and their members. Unfortunately,
    it is incomplete at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to the SlimDX website, you can go to the SharpDX website,
    [http://sharpdx.org/](http://sharpdx.org/). This site also has a documentation
    section, and it is currently more complete than SlimDX's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the classes in SharpDX are the same as their SlimDX counterparts, but
    there are some differences between these two. SharpDX is just an alternative to
    SlimDX. So most of the time, you can look at their documentation for help with
    SlimDX, but sometimes, it might not be accurate with the documentation of SlimDX
    because of the differences between the two. It's a good resource nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: The GameDev.net website—[http://www.Gamedev.net](http://www.Gamedev.net)—is
    a great resource for game developers. If you get really stuck and need help with
    something in SlimDX, their forums are an excellent place to ask questions. They
    have a lot of articles on the site too.
  prefs: []
  type: TYPE_NORMAL
- en: This site encompasses much more than just game development with SlimDX and C#.
    They also have an archive of the older articles since restructuring the site,
    which can be found at [http://archive.gamedev.net/archive/reference/](http://archive.gamedev.net/archive/reference/)
  prefs: []
  type: TYPE_NORMAL
- en: The Stack Overflow website— [http://stackoverflow.com/](http:// http://stackoverflow.com/)—is
    a place to ask questions, and people can comment on them and help you solve an
    issue. In fact, I used this site to help me solve a particularly tricky problem
    that I ran into while creating [Chapter 5](ch05.html "Chapter 5. Rendering Simple
    3D Graphics"), *Rendering Simple 3D Graphics*, of this book!
  prefs: []
  type: TYPE_NORMAL
- en: The two websites, [http://braynzarsoft.net/index.php?p=DX11Lessons](http://braynzarsoft.net/index.php?p=DX11Lessons
    ) and [http://www.rastertek.com/tutdx11.html](http://www.rastertek.com/tutdx11.html),
    have a number of good Direct3D 11 tutorials on them. Just be aware that these
    tutorials use C++; so, you'll have to figure out how to write the same code in
    SlimDX. Most objects in SlimDX have the same names as their native C++ counterparts;
    so, in most cases, this process is fairly easy to carry out.
  prefs: []
  type: TYPE_NORMAL
- en: The Riemers XNA Tutorials website— [http://www.riemers.net/](http://www.riemers.net/)—has
    some very nice XNA tutorials for new game programmers, making it a great resource
    for those just getting into game programming to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: The ShaderX Books website— [http://tog.acm.org/resources/shaderx/](http://tog.acm.org/resources/shaderx/)—has
    a series of books called *ShaderX*, and several of them are available as free
    downloads!
  prefs: []
  type: TYPE_NORMAL
- en: The NVIDIA Developer Zone website's page— [http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html](http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html)—for
    the book, *GPU Gems*, has excerpts from the book to give you an idea of what's
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to learn more about the underlying concepts such as how graphics
    are actually rendered at the lowest levels in game development, check out these
    two books by André LaMothe:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tricks of the Windows Game Programming Gurus, André LaMothe, Sams Publishing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tricks of the 3D Game Programming Gurus: Advanced Graphics and Rasterization,
    André LaMothe, Sams Publishing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these books by André LaMothe are quite excellent. The first one focuses
    on 2D development, player input with DirectInput, basic AI, collision detection,
    and more. The second book provides a very nice primer on the mathematics of 3D
    video games and focuses on the realm of 3D graphics and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I''d like to mention a book that I came in contact with in the beginning
    of this year (2013), and it turned out to be an excellent one: *Game Coding Complete:
    Fourth Edition, Mike McShaffry and David "Rez" Graham, Cengage Learning*'
  prefs: []
  type: TYPE_NORMAL
- en: This book is excellent because it covers many things that are left out in lots
    of books on DirectX. For example, many books teach you how to draw graphics on
    the screen, but they don't really teach you how to go about building a real game.
    This book covers many aspects of creating the various systems that are found in
    every video game. As such, this book is truly invaluable to any serious game programmer
    wanting to learn all this.
  prefs: []
  type: TYPE_NORMAL
- en: The book *3D Math Primer for Graphics and Game Development*, *Fletcher Dunn*,
    *Ian Parberry*, *A K Peters/CRC Press* covers the mathematics of 3D games in great
    detail, and explains the theory behind the concepts as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a handful of miscellaneous topics that we skimmed
    over in this book. Most of them could fill a book on their own. We looked at clipping
    and why it's important, and then moved on to collision detection and physics.
    Then, we took a look at multithreaded programming and its advantages for video
    games. After that, we took a look at some of the problems and pitfalls of game
    design. And lastly, we looked at some further reading materials.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on completing the book! May you create many awesome games in
    the future, and thank you for taking the time to read this book. Good luck with
    your continuing adventures down the path of game design!
  prefs: []
  type: TYPE_NORMAL
