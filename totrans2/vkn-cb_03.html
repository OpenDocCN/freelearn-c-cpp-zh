<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Command Buffers and Synchronization</h1>
            </header>

            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a command pool</li>
<li>Allocating command buffers</li>
<li>Beginning a command buffer recording operation</li>
<li>Ending a command buffer recording operation</li>
<li>Resetting a command buffer</li>
<li>Resetting a command pool</li>
<li>Creating a semaphore</li>
<li>Creating a fence</li>
<li>Waiting for fences</li>
<li>Resetting fences</li>
<li>Submitting command buffers to a queue</li>
<li>Synchronizing two command buffers</li>
<li>Checking if processing of a submitted command buffer has finished</li>
<li>Waiting until all commands submitted to a queue are finished</li>
<li>Waiting for all submitted commands to be finished</li>
<li>Destroying a fence</li>
<li>Destroying a semaphore</li>
<li>Freeing command buffers</li>
<li>Destroying a command pool</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction</h1>
            </header>

            <article>
                
<p>Low level APIs like Vulkan give us much more control over the hardware than higher level APIs similar to OpenGL. This control is achieved not only through resources we can create, manage, and operate on, but especially through communication and interaction with the hardware. The control Vulkan gives us is fine grained, because we explicitly specify which commands are sent to hardware, how and when. For this purpose <strong>command buffers</strong> have been introduced; these are one of the most important objects Vulkan API exposes to developers. They allow us to record operations and submit them to hardware, where they are processed or executed. And what's more important, we can record them in multiple threads, unlike in high level APIs like OpenGL, where not only are commands recorded in a single thread, but they are recorded implicitly by the driver and sent to hardware without any control from the developers. Vulkan also allows us to reuse existing command buffers, saving additional processing time. This all gives us much more flexibility, but also many more responsibilities.</p>
<p>Because of this, we need to control not only what operations we submit, but also when. Especially when some operations depend on the results of other operations, we need to take extra care and properly synchronize submitted commands. For this purpose, semaphores and fences have been introduced.</p>
<p>In this chapter we will learn how to allocate, record and submit command buffers, how to create synchronization primitives and use them to control the execution of submitted operations, how to synchronize command buffers internally, directly on the GPU, and  also how to synchronize applications with the work processed by the hardware.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a command pool</h1>
            </header>

            <article>
                
<p>Command pools are objects from which command buffers acquire their memory. Memory itself is allocated implicitly and dynamically, but without it command buffers wouldn't have any storage space to hold the recorded commands. That's why, before we can allocate command buffers, we first need to create a memory pool for them.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd> and initialize it with a handle of a created logical device.</li>
</ol>
<ol start="2">
<li>Take the index of one of the queue families requested for the logical device. Store this index in a variable of type <kbd>uint32_t</kbd> named <kbd>queue_family</kbd>.</li>
<li>Create a variable of type <kbd>VkCommandPoolCreateInfo</kbd> named <kbd>command_pool_create_info</kbd>. Use the following values for the members of this variable:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li>Bit field indicating selected parameters of type <kbd>VkCommandPoolCreateFlags</kbd> for <kbd>flags</kbd></li>
<li><kbd>queue_family</kbd> variable for <kbd>queueFamilyIndex</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkCommandPool</kbd> named <kbd>command_pool</kbd> in which command pool's handle will be stored.</li>
<li>Call <kbd>vkCreateCommandPool( logical_device, &amp;command_pool_create_info, nullptr, &amp;command_pool )</kbd> using the <kbd>logical_device</kbd> variable, a pointer to the <kbd>command_pool_create_info</kbd> variable, a <kbd>nullptr</kbd> value and a pointer to the <kbd>command_pool</kbd> variable.</li>
<li>Make sure the call returned a <kbd>VK_SUCCESS</kbd> value.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Command pools are used mainly as a source of memory for the command buffers, but this is not the only reason for which they are created. They inform the driver about the intended usage of command buffers allocated from them, and whether we must reset or free them in bulk, or if we can do it separately per each command buffer. These parameters are specified through a <kbd>flags</kbd> member (represented as follows by a <kbd>parameters</kbd> variable) of the variables of type <kbd>VkCommandPoolCreateInfo</kbd>, like this:</p>
<pre>
VkCommandPoolCreateInfo command_pool_create_info = { 
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, 
  nullptr, 
  parameters, 
  queue_family 
};
</pre>
<p>When we specify <kbd>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</kbd> bit, it means that the command buffers allocated from a given pool will live for a very short amount of time, they will be submitted very few times, and will be immediately reset or freed. When we use <kbd>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</kbd>, we can reset command buffers individually. Without this flag, we can do this only in groups - on all command buffers allocated from a given pool. Recording a command buffer implicitly resets it so, without this flag, we can record a command buffer only once. If we want to record it again, we need to reset the whole pool from which it was allocated.</p>
<p>Command pools also control the queues to which command buffers can be submitted. This is achieved through a queue family index, which we must provide during pool creation (only families requested during logical device creation can be provided). Command buffers that are allocated from a given pool can be submitted <em>only</em> to queues from the specified family.</p>
<p>To create a pool, we need to prepare the following code:</p>
<pre>
VkResult result = vkCreateCommandPool( logical_device, &amp;command_pool_create_info, nullptr, &amp;command_pool ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not create command pool." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<div class="packt_tip">Command pools cannot be accessed at the same time from multiple threads (command buffers from the same pool cannot be recorded on multiple threads at the same time). That's why each application thread on which a command buffer will be recorded should use separate command pools.</div>
<p>Now, we are ready to allocate command buffers.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Allocating command buffers</em></li>
<li><em>Resetting a command buffer</em></li>
<li><em>Resetting a command pool</em></li>
<li><em>Destroying a command pool</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Allocating command buffers</h1>
            </header>

            <article>
                
<p>Command buffers are used to store (record) commands that are later submitted to queues, where they are executed and processed by the hardware to give us results. When we have created a command pool, we can use it to allocate command buffers.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a created logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a command pool and use it to initialize a variable of type <kbd>VkCommandPool</kbd> named <kbd>command_pool</kbd>.</li>
<li>Create a variable of type <kbd>VkCommandBufferAllocateInfo</kbd> named <kbd>command_buffer_allocate_info</kbd> and use the following values for its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>command_pool</kbd> variable for <kbd>commandPool</kbd></li>
<li><kbd>VK_COMMAND_BUFFER_LEVEL_PRIMARY</kbd> value or a <kbd>VK_COMMAND_BUFFER_LEVEL_SECONDARY</kbd> value for <kbd>level</kbd></li>
<li>The number of command buffers we want to allocate for <kbd>commandBufferCount</kbd></li>
</ul>
</li>
<li>Create a vector of type <kbd>std::vector&lt;VkCommandBuffer&gt;</kbd> named <kbd>command_buffers</kbd>. Resize the vector to be able to hold the number of command buffers we want to create.</li>
<li>Call <kbd>vkAllocateCommandBuffers( logical_device, &amp;command_buffer_allocate_info, &amp;command_buffers[0] )</kbd> for which provide a handle of the logical device, a pointer to the <kbd>command_buffer_allocate_info</kbd> variable and a pointer to the first element of the <kbd>command_buffers</kbd> vector.</li>
<li>Upon success, indicated by the <kbd>VK_SUCCESS</kbd> value returned by the call, handles of all created command buffers will be stored in the <kbd>command_buffers</kbd> vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Command buffers are allocated from command pools. This allows us to control some of their properties in whole groups. First, we can submit command buffers only to queues from a family selected during command pool creation. Second, as command pools cannot be used concurrently, we should create separate command pools for each thread of our application in which we want to record commands, to minimize synchronization and improve performance.</p>
<p>But, command buffers also have their individual properties. Some of them are specified when we start recording operations, but we need to choose a very important parameter during command buffer allocation - whether we want to allocate <strong>primary</strong> or <strong>secondary</strong> command buffers:</p>
<ul>
<li>Primary command buffers can be directly submitted to queues. They can also execute (call) secondary command buffers.</li>
<li>Secondary command buffers can only be executed from primary command buffers, and we are not allowed to submit them.</li>
</ul>
<p>These parameters are specified through variables of type <kbd>VkCommandBufferAllocateInfo</kbd>, like this:</p>
<pre>
VkCommandBufferAllocateInfo command_buffer_allocate_info = { 
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, 
  nullptr, 
  command_pool, 
  level, 
  count 
};
</pre>
<p>Next, to allocate command buffers, we need the following code:</p>
<pre>
command_buffers.resize( count ); 

VkResult result = vkAllocateCommandBuffers( logical_device, &amp;command_buffer_allocate_info, &amp;command_buffers[0] ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not allocate command buffers." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>Now that we have allocated command buffers, we can use them in our application. To do this, we need to record operations in one or multiple command buffers and then submit them to a queue.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a command pool</em></li>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Ending a command buffer recording operation</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Freeing command buffers</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Beginning a command buffer recording operation</h1>
            </header>

            <article>
                
<p>When we want to perform operations using hardware, we need to record them and submit them to a queue. Commands are recorded into command buffers. So when we want to record them, we need to begin a recording operation of a selected command buffer, effectively setting it in the recording state.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol start="1">
<li>Take the handle of a command buffer, in which commands should be recorded, and store it in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>. Make sure the command buffer is allocated from a pool with a <kbd>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</kbd> flag set, or that it is in the initial state (it was reset).</li>
<li>Create a variable of a bit field type <kbd>VkCommandBufferUsageFlags</kbd> named <kbd>usage</kbd> and set the following bits depending on which conditions are met:
<ol>
<li>If the command buffer will be submitted only once and then reset or re-recorded, set the <kbd>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</kbd> bit.</li>
</ol>
<ol start="2">
<li>If it is the secondary command buffer and is considered to be entirely inside a render pass, set the <kbd>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</kbd> bit.</li>
<li>If the command buffer needs to be resubmitted to a queue while it is still being executed on a device (before the previous submission of this command buffer has ended), set the <kbd>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</kbd> bit.</li>
</ol>
</li>
</ol>
<ol start="3">
<li>Create a variable of type <kbd>VkCommandBufferInheritanceInfo *</kbd> named <kbd>secondary_command_buffer_info</kbd>. If it is a primary command buffer, initialize the variable with a <kbd>nullptr</kbd> value. If it is a secondary command buffer, initialize the variable with an address of a variable of type <kbd>VkCommandBufferInheritanceInfo</kbd> whose members are initialized with the following values:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO</kbd> value for <kbd>sType</kbd>.</li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd>.</li>
<li>For <kbd>renderPass</kbd> use a handle of a compatible render pass, in which the command buffer will be executed; if the command buffer won't be executed inside a render pass, this value is ignored (refer to <em>Creating a render pass</em> recipe from <a href="2de4339d-8912-440a-89a6-fd1f84961448.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Render Passes and Framebuffers</em>).</li>
<li>An index of a subpass within a render pass, in which the command buffer will be executed, for <kbd>subpass</kbd> (if the command buffer won't be executed inside a render pass, this value is ignored).</li>
<li>For <kbd>framebuffer,</kbd> use an optional handle of a framebuffer into which the command buffer will render, or a <kbd>VK_NULL_HANDLE</kbd> value if a framebuffer is not known or the command buffer won't be executed from within a render pass.</li>
<li>For <kbd>occlusionQueryEnable</kbd> member use a <kbd>VK_TRUE</kbd> value, if the command buffer can be executed while an occlusion query is active in the primary command buffer that executes this secondary command buffer. Otherwise, use a <kbd>VK_FALSE</kbd> value to indicate that the command buffer cannot be executed along with an enabled occlusion query.</li>
<li>A set of flags that can be used by an active occlusion query for <kbd>queryFlags</kbd>.</li>
<li>A set of statistics that can be counted by an active query for <kbd>pipelineStatistics</kbd>.</li>
</ul>
</li>
</ol>
<ol start="4">
<li>Create a variable of type <kbd>VkCommandBufferBeginInfo</kbd> named <kbd>command_buffer_begin_info</kbd>. Use the following values to initialize its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>usage</kbd> variable for <kbd>flags</kbd></li>
<li><kbd>secondary_command_buffer_info</kbd> variable for <kbd>pInheritanceInfo</kbd></li>
</ul>
</li>
<li>Call <kbd>vkBeginCommandBuffer( command_buffer, &amp;command_buffer_begin_info )</kbd> and provide the handle of the command buffer in the first parameter, and a pointer to the <kbd>command_buffer_begin_info</kbd> variable in the second parameter.</li>
<li>Make sure the call was successful by checking if the value returned by the call was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Recording command buffers is the most important operation we can do in Vulkan. This is the only way to tell the hardware what it should do and how. When we start recording command buffers, their state is undefined. In general, command buffers don't inherit any state (as opposed to an OpenGL, in which the current state is maintained). So when we record operations, we also need to remember to set the state that is relevant to these operations. An example of such a state is a drawing command, which uses vertex attributes and indices. Before we record a drawing operation, we need to bind appropriate buffers with vertex data and a buffer with vertex indices.</p>
<p>Primary command buffers can call (execute) commands recorded in the secondary command buffers. Executed secondary command buffers don't inherit the state from the primary command buffers that executed them. What's more, the state of the primary command buffer is also undefined after the execution of the secondary command buffer is recorded (when we record a primary command buffer, and execute a secondary command buffer in it, and we want to continue recording the primary command buffer, we need to set its state once again). There is only one exception to the state inheritance rule - when the primary command buffer is inside a render pass and we execute a secondary command buffer from it, the primary command buffer's render pass and subpass states are preserved.</p>
<p>Before we can begin a recording operation, we need to prepare a variable of type <kbd>VkCommandBufferBeginInfo</kbd>, through which we provide recording parameters:</p>
<pre>
VkCommandBufferBeginInfo command_buffer_begin_info = { 
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, 
  nullptr, 
  usage, 
  secondary_command_buffer_info 
};
</pre>
<div class="packt_tip">For performance reasons, we should avoid recording command buffers with a <kbd>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</kbd> flag.</div>
<p>Next, we can begin a recording operation:</p>
<pre>
VkResult result = vkBeginCommandBuffer( command_buffer, &amp;command_buffer_begin_info ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not begin command buffer recording operation." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>From now on, we can record selected operations into the command buffer. But how do we know which commands can be recorded into command buffers? The names of all such functions begin with a <kbd>vkCmd</kbd> prefix and their first parameter is always a command buffer (a variable of type <kbd>VkCommandBuffer</kbd>). But, we need to remember that not all commands can be recorded into both primary and secondary command buffers.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Allocating command buffers</em></li>
<li><em>Ending a command buffer recording operation</em></li>
<li><em>Resetting a command buffer</em></li>
<li><em>Resetting a command pool</em></li>
<li><em>Submitting command buffers to a queue</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Ending a command buffer recording operation</h1>
            </header>

            <article>
                
<p>When we don't want to record any more commands in a command buffer, we need to stop recording it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a command buffer that is in a recording state (for which a recording operation was started). Store the handle in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>.</li>
<li>Call <kbd>vkEndCommandBuffer( command_buffer )</kbd> and provide the <kbd>command_buffer</kbd> variable.</li>
<li>Make sure the recording operation was successful by checking whether the call returned a <kbd>VK_SUCCESS</kbd> value.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Commands are recorded into the command buffer between the <kbd>vkBeginCommandBuffer()</kbd> and <kbd>vkEndCommandBuffer()</kbd> function calls. We can't submit a command buffer until we stop recording it. In other words, when we finish recording a command buffer, it is said to be in the executable state and can be submitted.</p>
<p>For the recording operation to be as fast as possible and to have as small impact on the performance as possible, recorded commands don't report any errors. If any problems occur, they are reported by the <kbd>vkEndCommandBuffer()</kbd> function.</p>
<p>So when we stop recording a command buffer, we should make sure that the recording was successful. We can do that like this:</p>
<pre>
VkResult result = vkEndCommandBuffer( command_buffer ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Error occurred during command buffer recording." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>If there were errors during the recording operation (the value returned by the <kbd>vkEndCommandBuffer()</kbd> function is not equal to <kbd>VK_SUCCESS</kbd>), we can't submit such a command buffer and we need to reset it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Resetting a command buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Resetting a command buffer</h1>
            </header>

            <article>
                
<p>When a command buffer was previously recorded, or if there were errors during the recording operation, the command buffer must be reset before it can be rerecorded once again. We can do this implicitly, by beginning another record operation. But, we can also do it explicitly.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a command buffer allocated from a pool that was created with a <kbd>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</kbd> flag. Store the handle in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>.</li>
<li>Create a variable of type <kbd>VkCommandBufferResetFlags</kbd> named <kbd>release_resources</kbd>. In the variable, store a value of <kbd>VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT</kbd> if you want to release memory allocated by the buffer and give it back to the pool. Otherwise, store a <kbd>0</kbd> value in the variable.</li>
<li>Call <kbd>vkResetCommandBuffer( command_buffer, release_resources )</kbd> and provide the handle of the command buffer in the first parameter, and the <kbd>release_resources</kbd> variable in the second parameter.</li>
<li>Make sure the call was successful by checking if the returned value is equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Command buffers can be reset in bulk, by resetting a whole command pool, or individually. Separate resets can be performed only if a pool, from which the command buffers were allocated, was created with a <kbd>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</kbd> flag.</p>
<p>Resetting a command buffer is performed implicitly, when we start recording it, or explicitly by calling a <kbd>vkResetCommandBuffer()</kbd> function. Explicit reset gives us control over the memory allocated by the command buffer from its pool. During explicit reset, we can decide whether we want to return the memory to a pool, or if the command buffer should keep it and reuse it during the next command recording.</p>
<p>Individual command buffers are reset explicitly like this:</p>
<pre>
VkResult result = vkResetCommandBuffer( command_buffer, release_resources ? VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT : 0 ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Error occurred during command buffer reset." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a command pool</em></li>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Resetting a command pool</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Resetting a command pool</h1>
            </header>

            <article>
                
<p>When we don't want to reset command buffers individually, or if we created a pool without a <kbd>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</kbd> flag, we can reset all command buffers allocated from a given pool at once.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a created command pool. Use it to initialize a variable of type <kbd>VkCommandPool</kbd> named <kbd>command_pool</kbd>.</li>
<li>Create a variable of type <kbd>VkCommandPoolResetFlags</kbd> named <kbd>release_resources</kbd> and initialize it with a value of <kbd>VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT</kbd>, if memory reserved by all command buffers allocated from the command pool should be released and returned to the pool, or with a <kbd>0</kbd> value otherwise.</li>
<li>Call <kbd>vkResetCommandPool( logical_device, command_pool, release_resources )</kbd> and provide the <kbd>logical_device</kbd>, <kbd>command_pool</kbd> and <kbd>release_resources</kbd> variables.</li>
<li>Make sure the call returned a <kbd>VK_SUCCESS</kbd> value, which indicates it was successful.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Resetting a command pool causes all command buffers allocated from it to return to their initial state, as if they were never recorded. This is similar to resetting all command buffers separately, but is faster and we don't have to create a command pool with a <kbd>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</kbd> flag specified.</p>
<p>When command buffers are recorded, they take their memory from the pool. This is done automatically, without our control. When we reset the command pool, we can choose if command buffers should keep their memory for later use, or if it should be returned to the pool.</p>
<p>To reset all command buffers allocated from the specified pool at once, we need the following code:</p>
<pre>
VkResult result = vkResetCommandPool( logical_device, command_pool, release_resources ? VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT : 0 ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Error occurred during command pool reset." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a command pool</em></li>
<li><em>Allocating command buffers</em></li>
<li><em>Resetting a command buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a semaphore</h1>
            </header>

            <article>
                
<p>Before we can submit commands and utilize the device's processing power, we need to know how to synchronize operations. Semaphores are one of the primitives used for synchronization. They allow us to coordinate operations submitted to queues, not only within one queue, but also between different queues in one logical device.</p>
<p>Semaphores are used when we submit commands to queues. So before we can use them during the submission of command buffers, we need to create them.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a created logical device. Store the handle in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkSemaphoreCreateInfo</kbd> named <kbd>semaphore_create_info</kbd>. Use the following values to initialize its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkSemaphore</kbd> named <kbd>semaphore</kbd>. In this variable, a handle of a created semaphore will be stored.</li>
<li>Make the following function call: <kbd>vkCreateSemaphore( logical_device, &amp;semaphore_create_info, nullptr, &amp;semaphore )</kbd>. For this call use the <kbd>logical_device</kbd> variable, a pointer to the <kbd>semaphore_create_info</kbd> variable, a <kbd>nullptr</kbd> value and a pointer to the <kbd>semaphore</kbd> variable.</li>
<li>Make sure the semaphore creation was successful by checking if the returned value was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Semaphores, as synchronization primitives, have only two different states: signaled or un-signaled. Semaphores are used during command buffer submissions. When we provide them to a list of semaphores to be signaled, they change their state to signaled as soon as all work submitted within a given batch is finished. In a similar way, when we submit commands to queues, we can specify that submitted commands should wait until all semaphores from a specified list become signaled. This way, we can coordinate work submitted to queues and postpone processing of commands that depend on the results of other commands.</p>
<div class="packt_tip">When semaphores are signaled and all commands waiting for them are resumed, semaphores are automatically reset (they change their state to un-signaled) and can be reused.</div>
<p>Semaphores are also used when we acquire images from a swapchain. In this case, such semaphores must be used when we submit commands that reference acquired images. These commands should wait until swapchain images are no longer used by the presentation engine, which is indicated by the semaphore signal operation. This is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_03_001.png"/></div>
<p>Semaphores are created with a <kbd>vkCreateSemaphore()</kbd> function call. Parameters needed during the creation process are provided through a variable of type <kbd>VkSemaphoreCreateInfo</kbd>, like this:</p>
<pre>
VkSemaphoreCreateInfo semaphore_create_info = { 
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, 
  nullptr, 
  0 
};
</pre>
<p>To create a semaphore, we need to prepare a code similar to this one:</p>
<pre>
VkResult result = vkCreateSemaphore( logical_device, &amp;semaphore_create_info, nullptr, &amp;semaphore ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not create a semaphore." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>Semaphores can be used only to synchronize work submitted to queues, as they coordinate graphics hardware internally. The application doesn't have access to the state of the semaphores. If the application should be synchronized with the submitted commands, fences need to be used.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>In <a href="45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Image Presentation</em>, see the following recipes:</p>
<ul>
<li><em>Acquiring a swapchain image</em></li>
<li><em>Presenting an image</em></li>
</ul>
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a fence</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Synchronizing two command buffers</em></li>
<li><em>Destroying a semaphore</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a fence</h1>
            </header>

            <article>
                
<p>Fences, opposite to semaphores, are used to synchronize an application with commands submitted to the graphics hardware. They inform the application when the processing of a submitted work has been finished. But before we can use fences, we need to create them.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the created logical device and use its handle to initialize a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkFenceCreateInfo</kbd> named <kbd>fence_create_info</kbd>. Use the following values to initialize its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li>For <kbd>flags</kbd> use a <kbd>0</kbd> value if a created fence should be un-signaled, or a <kbd>VK_FENCE_CREATE_SIGNALED_BIT</kbd> value if a created fence should be signaled</li>
</ul>
</li>
<li>Create a variable of type <kbd>VkFence</kbd> named <kbd>fence</kbd> that will hold the handle of a created fence.</li>
<li>Call <kbd>vkCreateFence( logical_device, &amp;fence_create_info, nullptr, &amp;fence )</kbd> and provide the <kbd>logical_device</kbd> variable, a pointer to the <kbd>fence_create_info</kbd> variable, a <kbd>nullptr</kbd> value and a pointer to the <kbd>fence</kbd> variable.</li>
<li>Make sure the call was successful by comparing the returned value with a <kbd>VK_SUCCESS</kbd> enum.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Fences, similarly to other synchronization primitives, have only two states: signaled and un-signaled. They can be created in either of these two states, but they are reset by the application--this changes their state from signaled to un-signaled.</p>
<p>To signal a fence, we need to provide it during command buffer submission. Such a fence, similarly to semaphores, will become signaled as soon as all work submitted along with the fence is finished. But, fences can't be used to synchronize command buffers. Their state can be queried by the application and the application can wait on fences until they become signaled.</p>
<div class="packt_tip">Semaphores are used to synchronize submitted command buffers with each other. Fences are used to synchronize an application with submitted commands.</div>
<p>To create a fence, we need to prepare a variable of type <kbd>VkFenceCreateInfo</kbd>, in which we must choose whether we want the created fence to be already in a signaled state or if it should be un-signaled:</p>
<pre>
VkFenceCreateInfo fence_create_info = { 
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, 
  nullptr, 
  signaled ? VK_FENCE_CREATE_SIGNALED_BIT : 0 
};
</pre>
<p>Next, this structure is provided to the <kbd>vkCreateFence()</kbd> function, which creates a fence using specified parameters:</p>
<pre>
VkResult result = vkCreateFence( logical_device, &amp;fence_create_info, nullptr, &amp;fence ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not create a fence." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a semaphore</em></li>
<li><em>Waiting on fences</em></li>
<li><em>Resetting fences</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Checking if processing of a submitted command buffer has finished</em></li>
<li><em>Destroying a fence</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Waiting for fences</h1>
            </header>

            <article>
                
<p>When we want to know when the processing of submitted commands is finished, we need to use a fence and provide it during command buffer submission. Then, the application can check the fence's state and wait until it becomes signaled.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the created logical device and use its handle to initialize a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Create a list of fences on which the application should wait. Store the handles of all fences in a variable of type <kbd>std::vector&lt;VkFence&gt;</kbd> named <kbd>fences</kbd>.</li>
<li>Create a variable of type <kbd>VkBool32</kbd> named <kbd>wait_for_all</kbd>. Initialize it with a value of <kbd>VK_TRUE</kbd>, if the application should wait until all specified fences become signaled. If the application should wait until any of the fences becomes signaled (at least one of them), then initialize the variable with a <kbd>VK_FALSE</kbd> value.</li>
<li>Create a variable of type <kbd>uint64_t</kbd> named <kbd>timeout</kbd>. Initialize the variable with a value indicating how much time (in nanoseconds) the application should spend waiting.</li>
<li>Call <kbd>vkWaitForFences( logical_device, static_cast&lt;uint32_t&gt;(fences.size()), &amp;fences[0], wait_for_all, timeout )</kbd>. Provide a handle of the logical device, a number of elements in the <kbd>fences</kbd> vector, a pointer to the first element of the <kbd>fences</kbd> variable, the <kbd>wait_for_all</kbd> and the <kbd>timeout</kbd> variables.</li>
<li>Check the value returned by the call. If it was equal to <kbd>VK_SUCCESS</kbd> it means that the condition was satisfied--one or all fences (depending on the value of the <kbd>wait_for_all</kbd> variable) became signaled within the specified time. If the condition is not met, <kbd>VK_TIMEOUT</kbd> will be returned.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The <kbd>vkWaitForFences()</kbd> function blocks the application for a specified period of time or until the provided fences becomes signaled. This way, we can synchronize our application with work submitted to the device's queues. This is also the way for us to know when the processing of submitted commands is finished.</p>
<p>During the call we can provide multiple fences, not just one. We can also wait until all fences become signaled, or just any one of them. If the condition is not met within the specified period of time, the function returns a <kbd>VK_TIMEOUT</kbd> value. Otherwise, it returns <kbd>VK_SUCCESS</kbd>.</p>
<p>We can also check a fence's state by simply providing its handle to the function and specifying a timeout value of <kbd>0</kbd>. This way, the <kbd>vkWaitForFences()</kbd> function won't block and will immediately return the value indicating the current state of the provided fence - a <kbd>VK_TIMEOUT</kbd> value if the fence was un-signaled (though no real wait was performed) or a <kbd>VK_SUCCESS</kbd> value if the fence was already signaled.</p>
<p>The code that causes the application to wait may look like this:</p>
<pre>
if( fences.size() &gt; 0 ) { 
  VkResult result = vkWaitForFences( logical_device, static_cast&lt;uint32_t&gt;(fences.size()), &amp;fences[0], wait_for_all, timeout ); 
  if( VK_SUCCESS != result ) { 
    std::cout &lt;&lt; "Waiting on fence failed." &lt;&lt; std::endl; 
    return false; 
  } 
  return true; 
} 
return false;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a fence</em></li>
<li><em>Resetting fences</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Checking if processing of a submitted command buffer has finished</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Resetting fences</h1>
            </header>

            <article>
                
<p>Semaphores are automatically reset. But when a fence becomes signaled, it is the application's responsibility to reset the fence back to the un-signaled state.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Store the handle of a created logical device in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
</ol>
<ol start="2">
<li>Create a vector variable named <kbd>fences</kbd>. It should contain elements of type <kbd>VkFence</kbd>. In the variable, store the handles of all fences that should be reset.</li>
<li>Call <kbd>vkResetFences( logical_device, static_cast&lt;uint32_t&gt;(fences.size()), &amp;fences[0] )</kbd> and provide the <kbd>logical_device</kbd> variable, the number of elements in the <kbd>fences</kbd> vector and a pointer to the first element of the <kbd>fences</kbd> vector.</li>
<li>Make sure the function succeeded by checking if the value returned by the call was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>When we want to know when submitted commands are finished, we use a fence. But we can't provide a fence that was already signaled. We must first reset it, which means that we change its state from signaled to un-signaled. Fences are reset explicitly by the application, not automatically like semaphores. Resetting fences is done like this:</p>
<pre>
if( fences.size() &gt; 0 ) { 
  VkResult result = vkResetFences( logical_device, static_cast&lt;uint32_t&gt;(fences.size()), &amp;fences[0] ); 
  if( VK_SUCCESS != result ) { 
    std::cout &lt;&lt; "Error occurred when tried to reset fences." &lt;&lt; std::endl; 
    return false; 
  } 
  return VK_SUCCESS == result; 
} 
return false;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a fence</em></li>
<li><em>Waiting on fences</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Checking if processing of a submitted command buffer has finished</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Submitting command buffers to a queue</h1>
            </header>

            <article>
                
<p>We have recorded command buffers and we want to harness the graphics hardware's power to process the prepared operations. What to do next? We need to submit prepared work to a selected queue.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>In this recipe we will use variables of a custom <kbd>WaitSemaphoreInfo</kbd> type. It is defined as follows:</p>
<pre>
struct WaitSemaphoreInfo { 
  VkSemaphore           Semaphore; 
  VkPipelineStageFlags  WaitingStage; 
};
</pre>
<p>Through it, we provide a handle of a semaphore on which hardware should wait before processing the given <kbd>command buffer</kbd>, and we also specify in which pipeline stages the wait should occur.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a queue to which work should be submitted. Use the handle to initialize a variable of type <kbd>VkQueue</kbd> named <kbd>queue</kbd>.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkSemaphore&gt;</kbd> named <kbd>wait_semaphore_handles</kbd>. If submitted commands should wait for other commands to end, in the variable store the handles of all semaphores for which a given queue should wait before processing the submitted command buffers.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkPipelineStageFlags&gt;</kbd> named <kbd>wait_semaphore_stages</kbd>. If submitted commands should wait for other commands to end, initialize the vector with pipeline stages at which the queue should wait for a corresponding semaphore from the <kbd>wait_semaphore_handles</kbd> variable to become signaled.</li>
<li>Prepare a variable of type <kbd>std::vector&lt;VkCommandBuffer&gt;</kbd> named <kbd>command_buffers</kbd>. Store the handles of all recorded command buffers that should be submitted to the selected queue. Make sure that none of these command buffers is currently processed by the device, or were recorded with a <kbd>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</kbd> flag.</li>
</ol>
<ol start="5">
<li>Create a variable of type <kbd>std::vector&lt;VkSemaphore&gt;</kbd> named <kbd>signal_semaphores</kbd>. In this vector, store the handles of all semaphores that should be signaled when the processing of all command buffers, submitted in the <kbd>command_buffers</kbd> variable, is finished.</li>
<li>Create a variable of type <kbd>VkFence</kbd> named <kbd>fence</kbd>. If a fence should be signaled when the processing of all command buffers submitted in the <kbd>command_buffers</kbd> variable is finished, store the handle of this fence in the <kbd>fence</kbd> variable. Otherwise, initialize this variable with a <kbd>VK_NULL_HANDLE</kbd> value.</li>
<li>Create a variable of type <kbd>VkSubmitInfo</kbd> named <kbd>submit_info</kbd>. Use the following values to initialize its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_SUBMIT_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li>Number of elements in the <kbd>wait_semaphore_handles</kbd> vector for <kbd>waitSemaphoreCount</kbd></li>
<li>Pointer to the first element of the <kbd>wait_semaphore_handles</kbd> vector or a <kbd>nullptr</kbd> value, if the vector is empty, for <kbd>pWaitSemaphores</kbd></li>
<li>Pointer to the first element of the <kbd>wait_semaphore_stages</kbd> vector or a <kbd>nullptr</kbd> value, if the vector is empty, for <kbd>pWaitDstStageMask</kbd></li>
<li>Number of submitted command buffers (number of elements in the <kbd>command_buffers</kbd> vector) for <kbd>commandBufferCount</kbd></li>
<li>Pointer to the first element of the <kbd>command_buffers</kbd> vector or a <kbd>nullptr</kbd> value, if the vector is empty, for <kbd>pCommandBuffers</kbd></li>
<li>Number of elements in the <kbd>signal_semaphores</kbd> vector for <kbd>signalSemaphoreCount</kbd></li>
<li>Pointer to the first element of the <kbd>signal_semaphores</kbd> vector or a <kbd>nullptr</kbd> value, if the vector is empty, for <kbd>pSignalSemaphores</kbd></li>
</ul>
</li>
<li>Call <kbd>vkQueueSubmit( queue, 1, &amp;submit_info, fence )</kbd> and provide the handle of the queue to which work should be submitted, a <kbd>1</kbd> value, a pointer to the <kbd>submit_info</kbd> variable, and the <kbd>fence</kbd> variable.</li>
<li>Make sure the call was successful by checking whether it returned a <kbd>VK_SUCCESS</kbd> value.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>When we submit command buffers to the device's queue, they will be executed as soon as the processing of earlier commands submitted to the same queue is finished. From the application's perspective, we don't know when the commands are going to be executed. It may start immediately or after a while.</p>
<p>When we want to postpone the processing of submitted commands, we need to synchronize them by providing a list of semaphores on which a given queue should wait before the submitted command buffers are executed.</p>
<p>When we submit command buffers and provide a list of semaphores, each semaphore is associated with a pipeline stage. Commands are executed until they reach a specified pipeline stage, where they are paused and wait for the semaphore to become signaled.</p>
<p>During the submission, semaphores and pipeline stages are in separate arrays. So, we need to split the vector with elements of a custom type <kbd>WaitSemaphoreInfo</kbd> into two separate vectors:</p>
<pre>
std::vector&lt;VkSemaphore&gt;          wait_semaphore_handles; 
std::vector&lt;VkPipelineStageFlags&gt; wait_semaphore_stages; 

for( auto &amp; wait_semaphore_info : wait_semaphore_infos ) { 
  wait_semaphore_handles.emplace_back( wait_semaphore_info.Semaphore ); 
  wait_semaphore_stages.emplace_back( wait_semaphore_info.WaitingStage ); 
}
</pre>
<p>Now, we are ready for the usual submission. For the submission, semaphores on which command buffers should wait, pipeline stages at which the wait should be performed, command buffers and another list of semaphores that should be signaled, are all specified through a variable of type <kbd>VkSubmitInfo</kbd>:</p>
<pre>
VkSubmitInfo submit_info = { 
  VK_STRUCTURE_TYPE_SUBMIT_INFO, 
  nullptr, 
  static_cast&lt;uint32_t&gt;(wait_semaphore_infos.size()), 
  wait_semaphore_handles.size() &gt; 0 ? &amp;wait_semaphore_handles[0] : nullptr, 
  wait_semaphore_stages.size() &gt; 0 ? &amp;wait_semaphore_stages[0] : nullptr, 
  static_cast&lt;uint32_t&gt;(command_buffers.size()), 
  command_buffers.size() &gt; 0 ? &amp;command_buffers[0] : nullptr, 
  static_cast&lt;uint32_t&gt;(signal_semaphores.size()), 
  signal_semaphores.size() &gt; 0 ? &amp;signal_semaphores[0] : nullptr 
};
</pre>
<p>This batch of data is then submitted like this:</p>
<pre>
VkResult result = vkQueueSubmit( queue, 1, &amp;submit_info, fence ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Error occurred during command buffer submission." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>When we submit command buffers, the device will execute the recorded commands and produce the desired results, as an example it will draw a 3D scene on screen.</p>
<p>Here we submit just one batch of command buffers, but it is possible to submit multiple batches.</p>
<div class="packt_tip">For performance reasons, we should submit as many batches as possible in as few function calls as possible.</div>
<p>We shouldn't submit command buffers if they were already submitted and their execution hasn't ended yet. We can do this only when command buffers were recorded with a <kbd>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</kbd> flag, but we should avoid using this flag for performance reasons.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Ending a command buffer recording operation</em></li>
<li><em>Creating a semaphore</em></li>
<li><em>Creating a fence</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Synchronizing two command buffers</h1>
            </header>

            <article>
                
<p>We know how to prepare work and submit it to queues. We also know how to create semaphores. In this sample recipe, we will see how to use semaphores to synchronize two command buffers. More specifically, we will learn how to postpone the processing of a command buffer until the processing of another command buffer is finished.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>In this recipe we will use the <kbd>WaitSemaphoreInfo</kbd> structure introduced in the <em>Submitting command buffers to a queue</em> recipe. For reference, here is its definition:</p>
<pre>
struct WaitSemaphoreInfo { 
  VkSemaphore           Semaphore; 
  VkPipelineStageFlags  WaitingStage; 
};
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a queue to which the first batch of command buffers will be submitted. Store this handle in a variable of type <kbd>VkQueue</kbd> named <kbd>first_queue</kbd>.</li>
<li>Create semaphores that should be signaled when the processing of the first batch of command buffers is finished (refer to <em>Creating a semaphore</em> recipe). Store the semaphores in a variable of type <kbd>std::vector&lt;WaitSemaphoreInfo&gt;</kbd> named <kbd>synchronizing_semaphores</kbd>. Prepare a list of stages at which command buffers from the second batch should wait for each semaphore. Include these stages in the <kbd>synchronizing_semaphores</kbd> vector.</li>
<li>Prepare the first batch of command buffers and submit them to the queue represented by the <kbd>first_queue</kbd> variable. Include semaphores from the <kbd>synchronizing_semaphores</kbd> vector on a list of semaphores to signal (see <em>Submitting command buffers to a queue</em> recipe).</li>
<li>Take the handle of a queue, to which the second batch of command buffers will be submitted. Store this handle in a variable of type <kbd>VkQueue</kbd> named <kbd>second_queue</kbd>.</li>
<li>Prepare the second batch of command buffers and submit them to the queue, represented by the <kbd>second_queue</kbd> variable. Include semaphores and stages from the <kbd>synchronizing_semaphores</kbd> vector on a list of semaphores and stages to wait for (see <em>Submitting command buffers to a queue</em> recipe).</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>In this recipe we submit two batches of command buffers. When the first batch is processed by the hardware and finished, it signals all the semaphores included in the list of semaphores to be signaled. We take only the handles of semaphores, because pipeline stages are not required during the process of signaling the semaphores:</p>
<pre>
std::vector&lt;VkSemaphore&gt; first_signal_semaphores; 
for( auto &amp; semaphore_info : synchronizing_semaphores ) { 
  first_signal_semaphores.emplace_back( semaphore_info.Semaphore ); 
} 
if( !SubmitCommandBuffersToQueue( first_queue, first_wait_semaphore_infos, first_command_buffers, first_signal_semaphores, VK_NULL_HANDLE ) ) { 
  return false; 
}
</pre>
<p>Next, we take these same semaphores and use them when we submit the second batch of command buffers. This time, we use both handles and pipeline stages. The second batch will wait for all the provided semaphores at the specified pipeline stages. This means that some parts of the submitted command buffers may start being processed, but when they reach the provided stages processing is paused, as seen in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="214" src="assets/image_03_002.png" width="395"/></div>
<pre>
if( !SubmitCommandBuffersToQueue( second_queue, synchronizing_semaphores, second_command_buffers, second_signal_semaphores, second_fence ) ) { 
  return false; 
} 
return true;
</pre>
<p>This shows how to synchronize the work of multiple command buffers submitted to different queues from the same logical device. The processing of the command buffers from the second submission will be postponed until all commands from the first batch are finished.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a semaphore</em></li>
<li><em>Submitting command buffers to a queue</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Checking if processing of a submitted command buffer has finished</h1>
            </header>

            <article>
                
<p>When we use semaphores, the application is not involved in the process of synchronizing the command buffers. It doesn't know when the processing of submitted commands has finished and when other commands start being processed. It all takes place "behind the stage", and is transparent to the application.</p>
<p>But, when we want to know when the processing of a given command buffer has ended, we need to use fences. This way, we can check when a submitted command buffer is fully processed by the device.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create an un-signaled fence and store it in a variable of type <kbd>VkFence</kbd> named <kbd>fence</kbd>.</li>
<li>Prepare a batch of command buffers, semaphores to wait on submission and semaphores to signal after the submission is fully processed. Use the prepared data when submitting command buffers to the selected queue. Use the <kbd>fence</kbd> variable during the submission (refer to <em>Submitting command buffers to a queue</em> recipe).</li>
</ol>
<ol start="3">
<li>Wait on the created fence object by providing a handle of a logical device, from which all the utilized resources were created, the <kbd>fence</kbd> variable, <kbd>VK_FALSE</kbd> value for the parameter defining whether to wait on all provided fences, and a selected value for timeout (refer to the <em>Waiting for fences</em> recipe).</li>
<li>When the wait is finished and the <kbd>VK_SUCCESS</kbd> value was returned, it means that the processing of all command buffers submitted to the queue within the batch in which the <kbd>fence</kbd> variable was used, has been successfully finished.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Synchronizing the application with submitted command buffers is done in two steps. First we create a fence, prepare the command buffers and submit them to a queue. We need to remember to provide the created fence within the same submission:</p>
<pre>
if( !SubmitCommandBuffersToQueue( queue, wait_semaphore_infos, command_buffers, signal_semaphores, fence ) ) { 
  return false; 
}
</pre>
<p>Next, we just need to wait in our application, until the fence becomes signaled.</p>
<pre>
return WaitForFences( logical_device, { fence }, VK_FALSE, timeout );
</pre>
<p>This way, we are sure that the submitted command buffer has been successfully processed by the device.</p>
<p>But typical rendering scenarios should not cause our application to be fully paused, as this is just a waste of time. We should check if a fence becomes signaled. If it does not, we should spend the remaining time on other tasks, for example on improving the artificial intelligence or calculating physics more accurately, and check periodically the state of the fence. When the fence becomes signaled, we then perform the tasks that depended on the submitted commands.</p>
<p>Fences can also be used when we want to reuse command buffers. Before we can re-record them, we must be sure they are no longer executed by the device. We should have a number of command buffers recorded and submitted one after another. Only then, when we use all of them, do we start waiting on fences (each submitted batch should have an associated fence). The more separate batches of command buffers we have, the less time we spend on waiting for fences (refer to <em>Increasing the performance through increasing the number of separately rendered frames</em> recipe from <a href="0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Command Recording and Drawing</em>).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a fence</em></li>
<li><em>Waiting for fences</em></li>
<li><em>Resetting fences</em></li>
<li><em>Submitting command buffers to a queue</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Waiting until all commands submitted to a queue are finished</h1>
            </header>

            <article>
                
<p>When we want to synchronize the application with work submitted to a selected queue, we don't always have to use fences. It is possible for the application to wait until all tasks submitted to a selected queue are finished.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of the queue into which tasks were submitted. Store it in a variable of type <kbd>VkQueue</kbd> named <kbd>queue</kbd>.</li>
<li>Call <kbd>vkQueueWaitIdle( queue )</kbd> and provide the <kbd>queue</kbd> variable.</li>
<li>We can make sure that no errors occurred by checking if the value returned by the call is equal to a <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The <kbd>vkQueueWaitIdle()</kbd> function pauses the application until all work (processing of all command buffers) submitted to the given queue is finished. This way, we don't need to create fences.</p>
<p>But such synchronization should be performed only on very rare occasions. Graphics hardware (GPU) is usually much faster than the general processor (CPU), and may require work to be constantly submitted for the application to fully utilize its performance.</p>
<div class="packt_tip">Performing a wait on the application side may introduce stalls in the graphics hardware's pipeline, which causes the device to be inefficiently utilized.</div>
<p>To wait for the queue until it finishes all submitted work, we need to prepare the following code:</p>
<pre>
VkResult result = vkQueueWaitIdle( queue ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Waiting for all operations submitted to queue failed." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Waiting on fences</em></li>
<li><em>Submitting command buffers to a queue</em></li>
<li><em>Waiting for all commands to be finished</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Waiting for all submitted commands to be finished</h1>
            </header>

            <article>
                
<p>Sometimes we would like to wait until all the work submitted to all the logical devices' queues is finished. This type of wait is typically done before we close our application and we want to destroy all created or allocated resources.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a created logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
</ol>
<ol start="2">
<li>Make the following call: <kbd>vkDeviceWaitIdle( logical_device )</kbd>, for which provide the handle of the logical device.</li>
<li>You can check if there were no errors by comparing the returned value with a <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The <kbd>vkDeviceWaitIdle()</kbd> function causes our application to wait until a logical device is no longer busy. This is similar to waiting on all queues requested for a given device--until commands, which were submitted to all queues, are finished.</p>
<p>The above function is usually called just before the exit from our application. When we want to destroy resources, we must make sure they are no longer used by the logical device. This function guarantees we can safely perform such destruction.</p>
<p>Waiting for all commands submitted to the device is performed like this:</p>
<pre>
VkResult result = vkDeviceWaitIdle( logical_device ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Waiting on a device failed." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Waiting on fences</em></li>
<li><em>Waiting until all commands submitted to a queue are finished</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying a fence</h1>
            </header>

            <article>
                
<p>Fences can be reused multiple times. But when we don't need them anymore, typically just before we close our application, we should destroy them.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a fence that should be destroyed. Use the handle to initialize a variable of type <kbd>VkFence</kbd> named <kbd>fence</kbd>.</li>
<li>Call <kbd>vkDestroyFence( logical_device, fence, nullptr )</kbd> and provide the logical device's handle, the <kbd>fence</kbd> variable and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign the <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>fence</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Fences are destroyed using the <kbd>vkDestroyFence()</kbd> function, like this:</p>
<pre>
if( VK_NULL_HANDLE != fence ) { 
  vkDestroyFence( logical_device, fence, nullptr ); 
  fence = VK_NULL_HANDLE; 
}
</pre>
<p>We don't need to check if a value of the <kbd>fence</kbd> variable is not equal to the <kbd>VK_NULL_HANDLE</kbd> value because destruction of a null handle will be ignored by the driver. But, we do this to skip an unnecessary function call.</p>
<p>But, we can't destroy an invalid object - an object that wasn't created on a given logical device or that has already been destroyed. That's why we assign a <kbd>VK_NULL_HANDLE</kbd> value to the variable with the fence's handle.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>In this chapter, the recipe: <em>Creating a fence</em>.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying a semaphore</h1>
            </header>

            <article>
                
<p>Semaphores can be reused multiple times, so usually we don't need to delete them when the application is executing. But when we don't need a semaphore any more, and if we are sure it is not being used by the device (there are both no pending waits, and no pending signal operations), we can destroy it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a logical device. Store this handle in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Initialize a variable of type <kbd>VkSemaphore</kbd> named <kbd>semaphore</kbd> with a handle of the semaphore that should be destroyed. Make sure it is not referenced by any submissions.</li>
<li>Make the following call: <kbd>vkDestroySemaphore( logical_device, semaphore, nullptr )</kbd>, for which provide the logical device's handle, the handle of the semaphore and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>semaphore</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Deleting a semaphore is quite easy:</p>
<pre>
if( VK_NULL_HANDLE != semaphore ) { 
  vkDestroySemaphore( logical_device, semaphore, nullptr ); 
  semaphore = VK_NULL_HANDLE; 
}
</pre>
<div class="packt_tip">Before we can destroy a semaphore, we must make sure it is not referenced any more by any of the performed queue submissions.</div>
<p>If we performed a submission and provided a semaphore in the list of semaphores to be signaled, or in the list of the semaphores for which a given submission should wait, we must make sure the submitted commands have finished. For this purpose we need to use a fence on which the application should wait, or one of the functions waiting for all the operations to be submitted to a given queue or the whole device to be finished (refer to the <em>Waiting for fences</em>, <em>Waiting until all commands submitted to a queue are finished</em> and <em>Waiting for all submitted commands to be finished</em> recipes).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a semaphore</em></li>
<li><em>Waiting for fences</em></li>
<li><em>Waiting until all commands submitted to a queue are finished</em></li>
<li><em>Waiting for all submitted commands to be finished</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Freeing command buffers</h1>
            </header>

            <article>
                
<p>When command buffers are no longer necessary and when they are not pending for execution on a device, they can be freed.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a logical device and use it to initialize a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a command pool created from the logical device. Store this handle in a variable of type <kbd>VkCommandPool</kbd> named <kbd>command_pool</kbd>.</li>
<li>Create a vector variable with elements of type <kbd>VkCommandBuffer</kbd>, name the variable <kbd>command_buffers</kbd>. Resize the vector to be able to hold all command buffers that should be freed. Initialize the vector's elements with the handles of all the command buffers that should be freed.</li>
<li>Call <kbd>vkFreeCommandBuffers( logical_device, command_pool, static_cast&lt;uint32_t&gt;(command_buffers.size()), &amp;command_buffers[0] )</kbd>. During the call, provide the handles of the logical device and the command pool, provide the number of elements in the <kbd>command_buffers</kbd> vector (the number of command buffers to be freed) and a pointer to the first element of the <kbd>command_buffers</kbd> vector.</li>
<li>For safety reasons, clear the <kbd>command_buffers</kbd> vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Command buffers can be freed in groups, but during a single <kbd>vkFreeCommandBuffers()</kbd> function call we can only free command buffers from the same command pool. We can free any number of command buffers at once:</p>
<pre>
if( command_buffers.size() &gt; 0 ) { 
  vkFreeCommandBuffers( logical_device, command_pool, static_cast&lt;uint32_t&gt;(command_buffers.size()), &amp;command_buffers[0] ); 
  command_buffers.clear(); 
}
</pre>
<div class="packt_tip">Before we can free command buffers, we must make sure they are not referenced by the logical device, and that all submissions in which command buffers were provided have already finished.</div>
<p>Command buffers allocated from a given pool are implicitly freed when we destroy a command pool. So when we want to destroy a pool, we don't need to separately free all command buffers allocated from it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a command pool</em></li>
<li><em>Allocating command buffers</em></li>
<li><em>Waiting for fences</em></li>
<li><em>Waiting for all commands to be finished</em></li>
<li><em>Destroying a command pool</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying a command pool</h1>
            </header>

            <article>
                
<p>When all command buffers allocated from a given pool are not used any more, and we also don't need the pool, we can safely destroy it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a logical device and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Use a handle of the pool that should be destroyed to initialize a variable of type <kbd>VkCommandPool</kbd> named <kbd>command_pool</kbd>.</li>
<li>Call <kbd>vkDestroyCommandPool( logical_device, command_pool, nullptr )</kbd>, for which provide the handles of the logical device and the command pool, and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign the <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>command_pool</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The command pool is destroyed with the following code:</p>
<pre>
if( VK_NULL_HANDLE != command_pool ) { 
  vkDestroyCommandPool( logical_device, command_pool, nullptr ); 
  command_pool = VK_NULL_HANDLE; 
}
</pre>
<p>But, we can't destroy the pool until all command buffers allocated from it are not pending for execution on a device. To do that, we can wait on fences or use one of the functions that causes the application to wait until the selected queue stops processing commands, or while the whole device is busy (the work submitted to all queues from a given device is still being processed). Only then can we safely destroy the command pool.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a command pool</em></li>
<li><em>Waiting for all submitted commands to be finished</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>