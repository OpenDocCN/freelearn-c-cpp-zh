- en: Chapter 6. Graphics View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 图形视图
- en: '*Widgets are great for designing graphical user interfaces. However, you will
    run into problems if you wish to animate multiple widgets at the same time by
    constantly moving them around in the application. For these situations, or in
    general for frequently transforming 2D graphics, Qt offers you Graphics View.
    In this chapter, you will learn the basics of the Graphics View architecture and
    its items. You also will learn how to combine widgets with Graphics View items.
    Once you have acquired a basic understanding, we are next going to develop a simple
    jump-and-run game illustrating how to animate the items. Finally, we''ll look
    into some possibilities for optimizing Graphics View''s performance.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*小部件非常适合设计图形用户界面。然而，如果你希望在应用程序中同时通过不断移动它们来动画化多个小部件，你可能会遇到问题。在这些情况下，或者更一般地说，对于经常变换2D图形，Qt为你提供了图形视图。在本章中，你将学习图形视图架构及其项目的基本知识。你还将学习如何将小部件与图形视图项目结合使用。一旦你掌握了基础知识，我们接下来将开发一个简单的跳跃跑酷游戏，展示如何动画化项目。最后，我们将探讨一些优化图形视图性能的可能性。*'
- en: Graphics View architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形视图架构
- en: 'Three components form the core of Graphics View: an instance of `QGraphicsView`,
    which is referred to as **view**; an instance of `QGraphicsScene`, which is referred
    to as **scene**; and usually multiple instances of `QGraphicsItem`, which are
    referred to as **items**. The usual workflow is to first create a couple of items,
    then add them to a scene, and finally set that scene on a view.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 三个组件构成了图形视图的核心：一个`QGraphicsView`的实例，被称为**视图**；一个`QGraphicsScene`的实例，被称为**场景**；以及通常多个`QGraphicsItem`的实例，被称为**项目**。通常的工作流程是首先创建几个项目，然后将它们添加到场景中，最后将场景设置在视图上。
- en: In the following section, we will be discussing all three parts of the Graphics
    View architecture one after the other, beginning with the items, followed by the
    scene, and concluding with the view.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将依次讨论图形视图架构的三个部分，首先是项目，然后是场景，最后是视图。
- en: '![Graphics View architecture](img/8874OS_06_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图形视图架构](img/8874OS_06_01.jpg)'
- en: An illustration of Graphics View components
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图形视图组件的示例
- en: However, because it is not possible to deal with one component as entirely separate
    from the others, you need to get the big picture up front. This will help you
    to better understand the description of the three single parts. And do not worry
    if you do not understand all the details on their first occurrence. Be patient,
    work through the three parts, and all issues will hopefully become clear in the
    end.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于无法将一个组件完全独立于其他组件来处理，你需要一开始就了解整体情况。这将帮助你更好地理解三个单独部分的描述。如果你第一次出现时没有完全理解所有细节，请不要担心。要有耐心，完成这三个部分的工作，希望最终所有问题都会变得清晰。
- en: Think of the items as Post-it notes. You take a note and write a message on
    it, paint an image on it, both write and paint on it or, quite possibly, just
    leave it blank. This is equivalent to creating an item with a defined paint function,
    whether it is a default one or you have customized it. Since the items do not
    have a predetermined size, you define a bounding rectangle inside which all the
    painting of the item is done. As with a note, which does not care where it is
    positioned or from which angle it is being looked at, the item always draws its
    content as if it were in an untransformed state, where a length unit corresponds
    to 1 pixel. The item exists in its own coordinate system. Although you can apply
    various transformations to the item, such as rotating and scaling, it's not the
    job of the item's paint function to take that into account; that's the scene's
    job.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些项目想象成便利贴。你可以在上面写信息，画图像，或者两者都做，或者，很可能是直接留空。这相当于创建了一个具有定义的绘制函数的项目，无论是默认的函数还是你自定义的函数。由于项目没有预定的尺寸，你需要在其中完成所有绘制操作的定义边界矩形。就像便利贴一样，它不关心自己的位置或从哪个角度被观察，项目总是以未变换的状态绘制其内容，其中长度单位对应于1像素。项目存在于自己的坐标系中。尽管你可以对项目应用各种变换，如旋转和缩放，但这不是项目绘制函数的工作；那是场景的工作。
- en: What is the scene, then? Well, think of it as a larger sheet of paper onto which
    you attach your smaller Post-its, that is, the notes. On the scene, you can freely
    move the items around while applying funny transformations to them. It is the
    scene's responsibility to correctly display the items' position and any transformations
    applied to them. The scene further informs the items about any events that affect
    them and it has—as with the items—a bounding rectangle within which the items
    can be positioned.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，场景是什么呢？好吧，把它想象成一张更大的纸，你在上面贴上你的小便签，也就是笔记。在场景中，你可以自由地移动项目，并对它们应用有趣的变换。显示项目的位置和任何应用到的变换是场景的责任。场景还会通知项目任何影响它们的事件，并且它像项目一样有一个边界矩形，项目可以在这个矩形内定位。
- en: Last but not least, let's turn our attention to the view. Think of the view
    as an inspection window or a person who holds the paper with the notes in their
    hands. You can watch the paper as a whole or you can only look at specific parts.
    And as a person can rotate and shear the paper with their hands, so the view can
    rotate and shear the scene and do a lot more transformations with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们把注意力转向视图。把视图想象成一个检查窗口或者一个手里拿着带有笔记的纸张的人。你可以整体观察纸张，或者只看特定的部分。就像人可以用手旋转和剪切纸张一样，视图也可以旋转和剪切场景，并对它进行很多其他变换。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may look at the preceding diagram and be worried about all the items being
    outside the view. Aren't they wasting GPU render time? Don't you need to take
    care of them by adding a so-called "view frustum culling" mechanism (to detect
    which item not to draw/render because it is not visible)? Well, the short answer
    is "no" because Qt is already taking care of this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看前面的图并担心所有项目都在视图之外。它们不是在浪费GPU渲染时间吗？你不需要通过添加所谓的“视图视锥剔除”机制（检测哪些项目不可见，因此不需要绘制/渲染）来照顾它们吗？嗯，简短的答案是“不”，因为Qt已经处理了这一点。
- en: Items
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目
- en: So, let's look at the items. The most fundamental characteristic of items in
    Graphics View is their object-oriented approach. All items in the scene must inherit
    `QGraphicsItem`, which is an abstract class with—amongst numerous other public
    functions—two pure virtual functions called `boundingRect()` and `paint()`. Because
    of this simple and clear fact, there are principles which apply to each item.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看看这些项目。在图形视图中，项目的最基本特征是它们的面向对象方法。场景中的所有项目都必须继承自`QGraphicsItem`，这是一个具有众多其他公共函数的抽象类，其中包括两个纯虚函数，分别叫做`boundingRect()`和`paint()`。正因为这个简单而明确的事实，有一些原则适用于每个项目。
- en: Parent child relationship
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父子关系
- en: The constructor of `QGraphicsItem` takes a pointer to another item that is set
    as the item's parent. If the pointer is `0`, the item has no parent. This gives
    you the opportunity to organize items in a tree structure similar to the `QObject`
    object even though the `QGraphicsItem` element does not inherit from the `QObject`
    object. You can change the relationship of items at any given time by calling
    the `setParentItem()` function. It takes the new parent as an argument. If you
    want to remove a child item from its parent, simply call the `setParentItem(0)`
    function on the child. The following code illustrates both possibilities for creating
    a relationship between items. (Please note that this code will not compile since
    `QGraphicsItem` is an abstract class. Here, it is just for the purpose of illustration,
    but it will work with a real item class.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`的构造函数接受另一个项目的指针，该指针被设置为项目的父项。如果指针是`0`，则项目没有父项。这给了你机会以类似于`QObject`对象的结构来组织项目，尽管`QGraphicsItem`元素并不继承自`QObject`对象。你可以通过调用`setParentItem()`函数在任何给定时间改变项目之间的关系。如果你想从父项中移除子项目，只需在子项目上调用`setParentItem(0)`函数。以下代码说明了创建项目之间关系的两种可能性。（请注意，这段代码将无法编译，因为`QGraphicsItem`是一个抽象类。这里只是为了说明，但它将适用于真实的项目类。）'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First we create an item called `parentItem`, and since we do not use the constructor's
    argument, the item has no parent or child. Next, we create another item called
    `firstChildItem` and pass a pointer to the `parentItem` item as an argument. Thus,
    it has the `parentItem` item as its parent, and the `parentItem` item now has
    the `firstChildItem` item as its child. Next we create a third item called `secondChildItem`,
    but since we do not pass anything to its constructor, it has no parent at this
    point. In the next line, however, we change that by calling the `setParentItem()`
    function. Now it is also a child of the `parentItem` item.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`parentItem`的项，因为我们没有使用构造函数的参数，所以这个项没有父项或子项。接下来，我们创建另一个名为`firstChildItem`的项，并将`parentItem`项的指针作为参数传递。因此，它以`parentItem`项作为其父项，而`parentItem`项现在以`firstChildItem`项作为其子项。接下来，我们创建一个名为`secondChildItem`的第三项，但由于我们没有将其传递给构造函数，所以它目前没有父项。然而，在下一行中，我们通过调用`setParentItem()`函数来改变这一点。现在它也是`parentItem`项的子项。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can always check whether an item has a parent using the `parentItem()` function
    and check the returned `QGraphicsItem` pointer against `0`, which means that the
    item does not have a parent. To figure out if there are any children, call the
    `childItems()` function on the item. A `QList` method with the `QGraphicsItem`
    pointers to all child items is returned.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`parentItem()`函数始终检查一个项是否有父项，并将返回的`QGraphicsItem`指针与`0`进行比较，这意味着该项没有父项。要找出是否有任何子项，请在项上调用`childItems()`函数。它返回一个包含所有子项的`QList`方法。
- en: '![Parent child relationship](img/8874OS_06_21.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![父子关系](img/8874OS_06_21.jpg)'
- en: The parent-child relationship
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 父子关系
- en: The benefit of this parent-child relationship is that specific actions performed
    on a parent item also affect associated child items. For example, when you delete
    a parent item, all child items will also be deleted. For that reason, it is sufficient
    to delete the `parentItem` item in the preceding code. The destructors of the
    `firstChildItem` and `secondChildItem` items are called implicitly. The same applies
    when you add or remove a parent item from a scene. All child items will then get
    added or removed as well. The same applies when you hide a parent item or when
    you move a parent item. In both cases, the child items will behave the same way
    the parent does. Think of the earlier example of Post-it notes; they would behave
    the same. If you have a note with other notes attached to it, they will also move
    when you move the parent note.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种父子关系的优点是，在父项上执行的具体操作也会影响相关的子项。例如，当你删除父项时，所有子项也将被删除。因此，在前面代码中删除`parentItem`项就足够了。`firstChildItem`和`secondChildItem`项的析构函数将隐式调用。当你从场景中添加或删除父项时，也是如此。所有子项随后也将被添加或删除。当你隐藏父项或移动父项时，这也适用。在这两种情况下，子项的行为将与父项相同。想想之前提到的便利贴；它们会有相同的行为。如果你有一个带有其他便利贴附加的便签，当你移动父便签时，它们也会移动。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are not sure whether a function call on the parent item is propagated
    to its child items, you can always have a look at the sources. You will find them
    in your Qt installation if you checked the option to also install the sources
    at the time of installation. You can also find them online at [https://github.com/qtproject/qtbase](https://github.com/qtproject/qtbase).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定对父项的函数调用是否传播到其子项，你总是可以查看源代码。如果你在安装时选择了安装源代码的选项，你可以在你的Qt安装中找到它们。你也可以在网上找到它们，网址为[https://github.com/qtproject/qtbase](https://github.com/qtproject/qtbase)。
- en: 'Even if there isn''t a meaningful comment, you can spot the relevant code easily.
    Just look for a `children` variable addressed through the d-pointer. Inside the
    destructor of the `QGraphicsItem` item, the relevant code fragment is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有有意义的注释，你也容易找到相关的代码。只需寻找通过d-pointer访问的`children`变量。在`QGraphicsItem`项的析构函数中，相关的代码片段如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Appearance
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外观
- en: You are probably wondering what a `QGraphicsItem` item looks like. Well, since
    it is an abstract class (and unfortunately the paint function is a pure virtual
    one), it does not look like anything. You will have to do all the painting yourself.
    Luckily, since the paint function of the `QGraphicsItem` item offers you a technique
    you already know, the `QPainter` pointer, this is not very difficult.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道一个`QGraphicsItem`项看起来是什么样子。嗯，因为它是一个抽象类（而且不幸的是，绘制函数是一个纯虚函数），所以它看起来什么都没有。你将不得不自己完成所有的绘制工作。幸运的是，由于`QGraphicsItem`项的绘制函数为你提供了一个你已知的技巧，即`QPainter`指针，所以这并不困难。
- en: Don't panic! You don't have to draw all items yourself though. Qt offers a lot
    of standard shaped items you can use just out-of-the-box. You'll find them discussed
    in an upcoming section titled *Standard items*. However, since we need to draw
    a custom item once in a while, we go through this process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 别慌！你不必自己绘制所有项目。Qt 提供了许多标准形状的项目，你可以直接使用。你将在名为 *标准项目* 的下一节中找到它们的讨论。然而，由于我们偶尔需要绘制自定义项目，我们通过这个过程进行。
- en: Time for action – creating a black, rectangular item
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建一个黑色矩形项目
- en: 'As a first approach, let''s create an item that paints a black rectangle:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们创建一个绘制黑色矩形的项：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*What just happened?*'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: First, we subclass `QGraphicItem` and call the new class `BlackRectangle`. The
    class' constructor accepts a pointer to a `QGraphicItem` item. This pointer is
    then passed to the constructor of the `QGraphicItem` item. We do not have to worry
    about it; `QGraphicItem` will take care of it and establish the parent-child relationship
    for our item, among other things. Next, the virtual destructor makes sure that
    it gets called even if the class is getting deleted through a base class pointer.
    This is a crucial point, as you will learn later when we talk about the scene.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们继承 `QGraphicItem` 并将新类命名为 `BlackRectangle`。类的构造函数接受一个指向 `QGraphicItem`
    项目的指针。然后，这个指针被传递给 `QGraphicItem` 项目的构造函数。我们不必担心它；`QGraphicItem` 将会处理它，并为我们项目建立父子关系，以及其他事情。接下来，虚拟析构函数确保即使在通过基类指针删除类的情况下也会被调用。这是一个关键点，你将在我们讨论场景时学到这一点。
- en: Next, we define the `boundingRect()` function of our item, where we return a
    rectangle 75 pixels wide and 25 pixels high. This returned rectangle is the canvas
    for the `paint` method and simultaneously the promise to the scene that the item
    will only paint in this area. The scene relies on the correctness of that information,
    so you should strictly obey that promise. Otherwise, the scene will become cluttered
    up with relics of your drawing!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们项目的 `boundingRect()` 函数，其中我们返回一个宽度为 75 像素、高度为 25 像素的矩形。这个返回的矩形是 `paint`
    方法的画布，同时也是对场景的承诺，即项目将只在这个区域内绘制。场景依赖于该信息的正确性，因此你应该严格遵守这个承诺。否则，场景将充满你绘制的遗迹！
- en: Lastly, we do the actual painting from `QPainter` in conjunction with a `QWidget`
    item. There is nothing different here except that the painter is already initialized
    with the appropriate values given to us through the first argument. Even if it
    is not needed, I would suggest that the painter be kept in the same state at the
    end of the function as it was in the beginning. If you follow that advice, and
    if you only use custom items in the scene, you can later optimize the render speed
    enormously. This especially applies to scenes with many items. But let us go back
    to what we were actually doing. We have taken the painter and called the `fillRect()`
    function, which does not touch the painter's internal state. As arguments, we
    used the `boundingRect()` function, which defines the area to fill, and the `Qt::black`
    parameter, which defines the fill color. Thus, by only filling the bounding rectangle
    of the item, we obeyed the bounding rectangle promise.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从 `QPainter` 和 `QWidget` 项目结合进行实际绘画。这里没有其他不同之处，只是画家已经通过第一个参数给出的适当值初始化。即使不需要，我也建议在函数结束时保持画家处于与开始时相同的状态。如果你遵循这个建议，并且只使用场景中的自定义项目，你可以在以后极大地优化渲染速度。这尤其适用于项目众多的场景。但让我们回到我们实际上在做什么。我们已经取出了画家并调用了
    `fillRect()` 函数，这个函数不会影响画家的内部状态。作为参数，我们使用了 `boundingRect()` 函数，它定义了要填充的区域，以及 `Qt::black`
    参数，它定义了填充颜色。因此，通过只填充项目的边界矩形，我们遵守了边界矩形的承诺。
- en: In our example, we have not used the two other arguments of the `paint` function.
    To suppress the compiler warnings about unused variables, we used Qt's `Q_UNUSED`
    macro.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们没有使用 `paint` 函数的两个其他参数。为了抑制编译器关于未使用变量的警告，我们使用了 Qt 的 `Q_UNUSED` 宏。
- en: Time for action – reacting to an item's selection state
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 对项目选择状态的响应
- en: 'The assigned pointer to a `QStyleOptionGraphicsItem` item might become handy
    if you want to alter the appearance of the item related to its state. For example,
    say you want to fill the rectangle with red when it gets selected. To do so, you
    only have to type this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想改变与项目状态相关的项目的外观，分配给 `QStyleOptionGraphicsItem` 项目的指针可能会很有用。例如，假设你想在项目被选中时用红色填充矩形。为此，你只需输入以下内容：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*What just happened?*'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `state` variable is a bitmask holding the possible states of the item. You
    can check its value against the values of the `QStyle::StateFlag` parameter by
    using bitwise operators. In the preceding case, the `state` variable is checked
    against the `State_Selected` parameter. If this flag is set, the rectangle is
    painted red.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`state` 变量是一个位掩码，包含项目的可能状态。您可以使用位运算符将其值与 `QStyle::StateFlag` 参数的值进行比较。在前面的例子中，`state`
    变量被检查与 `State_Selected` 参数。如果此标志被设置，则矩形将被绘制为红色。'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The type of state is `QFlags<StateFlag>`. So, instead of using the bitwise
    operator to test if a flag is set, you can use the convenient function `testFlag()`.
    Used with the preceding example it would be as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的类型是 `QFlags<StateFlag>`。因此，您不需要使用位运算符来测试标志是否设置，而是可以使用方便的函数 `testFlag()`。使用前面的示例，它将是这样的：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The most important states you can use with items are described in the following
    table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用的项目最重要的状态在以下表中描述：
- en: '| State | Description |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 描述 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `State_Enabled` | Indicates that the item is enabled. If the item is disabled,
    you may want to draw it as grayed out. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `State_Enabled` | 表示项目处于启用状态。如果项目被禁用，您可能希望将其绘制为灰色。 |'
- en: '| `State_HasFocus` | Indicates that the item has the input focus. To receive
    this state, the item needs to have the `ItemIsFocusable` flag set. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `State_HasFocus` | 表示项目具有输入焦点。要接收此状态，项目需要将 `ItemIsFocusable` 标志设置为。 |'
- en: '| `State_MouseOver` | Indicates that the cursor is currently hovering over
    the item. To receive this state the item needs to have the `acceptHoverEvents`
    variable set to `true`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `State_MouseOver` | 表示光标当前悬停在项目上。要接收此状态，项目需要将 `acceptHoverEvents` 变量设置为 `true`。
    |'
- en: '| `State_Selected` | Indicates that the item is selected. To receive this state,
    the item needs to have the `ItemIsSelectable` flag set. The normal behavior would
    be to draw a dashed line around the item as a selection marker. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `State_Selected` | 表示项目被选中。要接收此状态，项目需要将 `ItemIsSelectable` 标志设置为。正常情况下，会绘制一个虚线围绕项目作为选择标记。
    |'
- en: Besides the state, `QStyleOptionGraphicsItem` offers much more information about
    the currently used style, such as the palette and the font used, accessible through
    the `QStyleOptionGraphicsItem::palette` and `QStyleOptionGraphicsItem::fontMetrics`
    parameters, respectively. If you aim for style-aware items, have a deeper look
    at this class in the documentation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了状态之外，`QStyleOptionGraphicsItem` 还提供了关于当前使用样式的更多信息，例如使用的调色板和字体，分别通过 `QStyleOptionGraphicsItem::palette`
    和 `QStyleOptionGraphicsItem::fontMetrics` 参数访问。如果您旨在实现样式感知的项目，请在文档中更深入地了解此类。
- en: Time for action – making the item's size definable
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使项目的大小可定义
- en: 'Let''s push the example of the black rectangle a step further. So far, `BlackRectangle`
    draws a fixed rectangle of size 75 x 25 pixels. It would be nice if one could
    define this size, so let us add the ability to define the size of the rectangle.
    Remember, only painting the rectangle larger does not help here because then you
    would break the promise regarding the bounding rectangle. So we need also to change
    the bounding rectangle as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把黑色矩形的例子再进一步。到目前为止，`BlackRectangle` 绘制了一个固定大小的 75 x 25 像素的矩形。如果能定义这个大小会很好，所以让我们添加定义矩形大小的功能。记住，仅仅将矩形画得更大在这里没有帮助，因为那样你会打破关于边界矩形的承诺。因此，我们还需要按照以下方式更改边界矩形：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Since the destructor and the `paint` function are unchanged, they are omitted.
    What exactly have we done here? First, we introduced a private member called `m_rect`
    to save the current rectangle's value. In the initialization list, we set `m_rect`
    to a default value of `QRectF(0, 0, 75, 25)` like we hard-coded it in the first
    example. Since the bounding rectangle should be the same as `m_rect`, we altered
    `boundingRect()` to return `m_rect`. The same value is returned by the getter
    function `rect()`. For now it seems redundant to have two functions returning
    the same value, but as soon as you draw a border around the rectangle, you need
    to return a different bounding rectangle. It needs to be increased by the used
    pen's width. Therefore, we leave this redundancy in place in order to make further
    improvements easier. The last new part is the setter function, which is pretty
    standard. We check if the value has changed, and if not we exit the function.
    Otherwise, we set a new value, but this has to happen after the `prepareGeometryChange()`
    call. This call is important to inform the scene about the coming geometry change.
    Then, the scene will ask the item to redraw itself. We do not need to handle that
    part.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于析构函数和 `paint` 函数没有变化，因此省略了它们。我们在这里到底做了什么？首先，我们引入了一个名为 `m_rect` 的私有成员，用于保存当前矩形的值。在初始化列表中，我们将
    `m_rect` 设置为默认值 `QRectF(0, 0, 75, 25)`，就像我们在第一个示例中硬编码的那样。由于边界矩形应该与 `m_rect` 相同，我们修改了
    `boundingRect()` 以返回 `m_rect`。获取器函数 `rect()` 也返回相同的值。目前，似乎有两个函数返回相同的值是多余的，但一旦您在矩形周围绘制边界，就需要返回一个不同的边界矩形。它需要增加所使用的笔的宽度。因此，我们保留这种冗余，以便于进一步改进。最后新的部分是设置函数，它相当标准。我们检查值是否已更改，如果没有，则退出函数。否则，我们设置一个新的值，但必须在
    `prepareGeometryChange()` 调用之后进行。这个调用很重要，因为它会通知场景即将发生几何变化。然后，场景会要求项目重新绘制自己。我们不需要处理这部分。
- en: Have a go hero – customizing the item
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 定制项目
- en: As an exercise, you can try to add an option to change the background color.
    You can also create a new item that allows you to set an image. If doing so, keep
    in mind that you have to change the item's bounding rectangle according to the
    size of the image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以尝试添加一个选项来更改背景颜色。您还可以创建一个新的项目，允许您设置一个图像。如果这样做，请记住，您必须根据图像的大小更改项目的边界矩形。
- en: Standard items
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准项目
- en: 'As you have seen, creating your own item involves some work, but overall it
    is not that difficult. A big advantage is that you can use `QPainter` to draw
    the item, the same technique you use to paint widgets. So there is nothing new
    you need to learn. Indeed, even if it is easy to draw filled rectangles or any
    other shape, it is a lot of work to subclass `QGraphicsItem` each time you need
    to create an item that does such basic tasks. And that''s the reason why Qt comes
    with the following standard items that make your life as a developer much easier:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，创建自己的项目需要一些工作，但总体来说并不困难。一个很大的优势是您可以使用 `QPainter` 来绘制项目，这与您用于绘制小部件的技术相同。因此，您不需要学习任何新的东西。确实，虽然绘制填充矩形或其他任何形状很容易，但每次需要创建执行此类基本任务的项目时，都要子类化
    `QGraphicsItem` 是一项大量工作。这就是为什么 Qt 提供以下标准项目，使您作为开发者的生活变得更加容易：
- en: '| Standard item | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 标准项目 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `QGraphicsLineItem` | Draws a simple line. You can define the line with `setLine(const
    QLineF&)`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsLineItem` | 绘制简单线条。您可以使用 `setLine(const QLineF&)` 定义线条。 |'
- en: '| `QGraphicsRectItem` | Draws a rectangle. You can define the rectangle''s
    geometry with `setRect(const QRectF&)`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsRectItem` | 绘制矩形。您可以使用 `setRect(const QRectF&)` 定义矩形的几何形状。 |'
- en: '| `QGraphicsEllipseItem` | Draws an ellipse. You can define the rectangle within
    which the ellipse is being drawn with `setRect(const QRectF&)`. Additionally,
    you can define whether only a segment of the ellipse should be drawn by calling
    `setStartAngle(int)` and `setSpanAngle(int)`. The arguments of both functions
    are in 16ths of a degree. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsEllipseItem` | 绘制椭圆。您可以使用 `setRect(const QRectF&)` 定义绘制椭圆的矩形。此外，您还可以通过调用
    `setStartAngle(int)` 和 `setSpanAngle(int)` 来定义是否只绘制椭圆的某一段。这两个函数的参数是以度数的十六分之一表示的。
    |'
- en: '| `QGraphicsPolygonItem` | Draws a polygon. You can define the polygon with
    `setPolygon(const QPolygonF&)`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsPolygonItem` | 绘制多边形。您可以使用 `setPolygon(const QPolygonF&)` 定义多边形。
    |'
- en: '| `QGraphicsPathItem` | Draws a path. You can define the path with `setPath(const
    QPainterPath&)`. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsPathItem` | 绘制路径。您可以使用 `setPath(const QPainterPath&)` 定义路径。 |'
- en: '| `QGraphicsSimpleTextItem` | Draws a simple text path. You can define the
    text with `setText(const QString&)` and the font with `setFont(const QFont&)`.
    This item is only for drawing *plain* text without any modification. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsSimpleTextItem` | 绘制简单的文本路径。您可以使用 `setText(const QString&)` 定义文本，并使用
    `setFont(const QFont&)` 定义字体。此项目仅用于绘制不带任何修改的 *纯文本*。 |'
- en: '| `QGraphicsTextItem` | Draws text. Unlike `QGraphicsSimpleTextItem`, this
    item can display HTML or render a `QTextDocument` element. You can set HTML with
    `setHtml(const QString&)` and the document with `setDocument(QTextDocument*)`.
    `QGraphicsTextItem` can even interact with the displayed text so that text editing
    or URL opening is possible. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsTextItem` | 绘制文本。与 `QGraphicsSimpleTextItem` 不同，此项目可以显示 HTML 或渲染
    `QTextDocument` 元素。您可以使用 `setHtml(const QString&)` 设置 HTML，并使用 `setDocument(QTextDocument*)`
    设置文档。`QGraphicsTextItem` 甚至可以与显示的文本进行交互，以便实现文本编辑或 URL 打开。 |'
- en: '| `QGraphicsPixmapItem` | Draws a pixmap. You can define the pixmap with `setPixmap(const
    QPixmap&)`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsPixmapItem` | 绘制位图。您可以使用 `setPixmap(const QPixmap&)` 定义位图。 |'
- en: Since the drawing of these items is done by a `QPainter` pointer you can also
    define which pen and which brush should be used. The pen is set with `setPen(const
    QPen&)` and the brush with `setBrush(const QBrush&)`. These two functions, however,
    do not exist for `QGraphicsTextItem` and `QGraphicsPixmapItem`. To define the
    appearance of a `QGraphicsTextItem` item you have to use `setDefaultTextColor()`
    or HTML tags supported by Qt. Note that pixmaps usually do not have a pen or a
    brush.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些项目的绘制是通过 `QPainter` 指针完成的，因此您也可以定义应该使用哪种笔和哪种刷子。笔是通过 `setPen(const QPen&)`
    设置的，刷是通过 `setBrush(const QBrush&)` 设置的。然而，这两个函数并不适用于 `QGraphicsTextItem` 和 `QGraphicsPixmapItem`。要定义
    `QGraphicsTextItem` 项目的外观，您必须使用 `setDefaultTextColor()` 或 Qt 支持的 HTML 标签。请注意，位图通常没有笔或刷。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `QGraphicsSimpleTextItem` wherever possible and try to avoid `QGraphicsTextItem`
    if it is not absolutely necessary. The reason is that `QGraphicsTextItem` lugs
    a `QTextDocument` object around and it is, besides being a subclass of `QGraphicsItem`,
    also a subclass of `QObject`. This is definitely too much overhead and has too
    high a performance cost for displaying simple text.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下使用 `QGraphicsSimpleTextItem`，并尽量在绝对必要时才使用 `QGraphicsTextItem`。原因是 `QGraphicsTextItem`
    带有一个 `QTextDocument` 对象，它不仅是 `QGraphicsItem` 的子类，也是 `QObject` 的子类。这无疑增加了太多的开销，并且对于显示简单文本来说性能成本过高。
- en: 'A word on how you set up items. Instead of writing two expressions, one for
    the initialization of the item and one for setting up its key information such
    as the rectangle for a `QGraphicsRextItem` item or the pixmap for a `QGraphicsPixmapItem`,
    almost all standard items offer you the option to pass that key information as
    a first argument to their constructors—besides the optional last argument for
    setting the item''s parent. Say you would have written the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何设置项目的说明。而不是写两个表达式，一个用于初始化项目，另一个用于设置其关键信息，例如 `QGraphicsRextItem` 项目的矩形或 `QGraphicsPixmapItem`
    项目的位图，几乎所有标准项目都提供了将关键信息作为第一个参数传递给其构造函数的选项——除了用于设置项目父级的可选最后一个参数。比如说，您可能会写出以下代码：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now simply write this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以简单地这样写：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can even just write this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以简单地这样写：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is very convenient, but keep in mind that compact code may be harder to
    maintain than code that sets all variables through setter methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，但请记住，紧凑的代码可能比通过设置器方法设置所有变量的代码更难维护。
- en: Coordinate system of the items
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的坐标系
- en: 'A last but very important note on the used coordinate system. Altogether, Graphics
    View deals with three different but connected coordinate systems. There is the
    item''s coordinate system, the scene''s coordinate system, and the view''s coordinate
    system. All three coordinate systems differ from the Cartesian coordinate systems
    regarding the *y* axis: in Graphics View, like in `QPainter` pointer''s coordinate
    system, the *y* axis is orientated and measured from the origin to the bottom.
    This means that a point below the origin has a positive *y* value. For now, we
    only care about the item''s coordinate system. Since Graphics View is for 2D graphics,
    we have an *x* coordinate and a *y* coordinate with the origin at (0, 0). All
    points, lines, rectangles, and so on are specified in the item''s own coordinate
    system. This applies to almost all occasions where you deal with values representing
    coordinates within the `QGraphicsItem` class or its derived classes. If you define,
    for example, the rectangle of a `QGraphicsRectItem` item, you use item coordinates.
    If an item receives a mouse press event, `QGraphicsSceneMouseEvent::pos()` is
    expressed in item coordinates. But there are some easy-to-identify exceptions
    to this statement. The return value of `scenePos()` and `sceneBoundingRect()`
    is expressed in scene coordinates. Pretty obvious, isn''t it? The one thing that
    is a little bit tricky to identify is the returned `QPointF` pointer of `pos()`.
    The coordinates of this point are expressed in the item''s parent coordinate system.
    This can be either the parent item''s coordinate system or, more likely, the scene''s
    coordinate system when the item does not have a parent item.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的一点是关于所使用的坐标系。总的来说，图形视图处理三个不同但相互关联的坐标系。这里有项目的坐标系、场景的坐标系和视图的坐标系。这三个坐标系在
    *y* 轴上与笛卡尔坐标系不同：在图形视图中，就像在 `QPainter` 指针的坐标系中，*y* 轴是从原点向底部测量的，并且是定向的。这意味着位于原点下方的点具有正的
    *y* 值。目前，我们只关心项目的坐标系。由于图形视图是用于二维图形的，我们有一个 *x* 坐标和一个 *y* 坐标，原点位于 (0, 0)。所有点、线、矩形等都在项目的自身坐标系中指定。这适用于处理
    `QGraphicsItem` 类及其派生类中代表坐标的值的几乎所有情况。例如，如果你定义一个 `QGraphicsRectItem` 项目的矩形，你将使用项目坐标。如果一个项目接收到鼠标按下事件，`QGraphicsSceneMouseEvent::pos()`
    将以项目坐标表示。但是，这个陈述有一些容易识别的例外。`scenePos()` 和 `sceneBoundingRect()` 的返回值以场景坐标表示。很明显，不是吗？有一点稍微有点难以识别的是
    `pos()` 返回的 `QPointF` 指针。这个点的坐标以项目的父坐标系表示。这可以是父项目的坐标系，或者更有可能的是，当项目没有父项目时，是场景的坐标系。
- en: 'For a better understanding of `pos()` and the involved coordinate systems,
    think of Post-it notes again. If you put a note on a larger sheet of paper and
    then had to determine its exact position, how would you do it? Probably somewhat
    like this: "The note''s upper left corner is positioned 3 cm to the right and
    5 cm to the bottom from the paper''s top left edge". In the Graphics View world,
    this would correspond to a parentless item whose `pos()` function returns a position
    in scene coordinates since the item''s origin is directly pinned to the scene.
    On the other hand, say you put a note A on top of a (larger) note B, which is
    already pinned on a paper, and you have to determine A''s position; how would
    you describe it this time? Probably by saying that note A is placed on top of
    note B or "2 cm to the right and 1 cm to the bottom from the top-left edge of
    note B". You most likely wouldn''t use the underlying paper as a reference since
    it is not the next point of reference. This is because, if you move note B, A''s
    position regarding the paper will change whereas A''s relative position to B still
    remains unchanged. To switch back to Graphics View, the equivalent situation is
    an item that has a parent item. In this case, the `pos()` function''s returned
    value is expressed in the coordinate system of its parent. So `setPos()` and `pos()`
    specify the position of the item''s origin in relation to the next (higher) point
    of reference. This could be the scene or the item''s parent item.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`pos()`和涉及的坐标系，再次想想便利贴。如果你在一块更大的纸上贴上一张便利贴，然后必须确定它的确切位置，你会怎么做？可能就像这样：“便利贴的左上角位于纸张左上角的右边3厘米和下面5厘米处”。在图形视图世界中，这对应于一个没有父项的项目，其`pos()`函数返回场景坐标中的位置，因为项目的原点直接固定到场景上。另一方面，假设你在已经贴在纸上的（更大的）便利贴B的上面贴上便利贴A，你必须确定A的位置；这次你会怎么描述它？可能你会说便利贴A放在便利贴B的上面，或者“从便利贴B的左上角右边2厘米和下面1厘米处”。你很可能不会使用底下的纸张作为参考，因为它不是下一个参考点。这是因为，如果你移动便利贴B，A相对于纸张的位置会改变，而A相对于B的相对位置仍然保持不变。为了回到图形视图，等效的情况是一个具有父项的项目。在这种情况下，`pos()`函数返回的值是在其父项的坐标系中表达的。所以`setPos()`和`pos()`指定了项目的原点相对于下一个（更高）参考点的位置。这可能是场景或项目的父项。
- en: Keep in mind, however, that changing an item's position does not affect the
    item's internal coordinate system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，改变项目的位置不会影响项目的内部坐标系。
- en: Time for action – creating items with different origins
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建具有不同来源的项目
- en: 'Let''s have a closer look at these three items defined by the following code
    snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看以下代码片段定义的这三个项目：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*What just happened?*'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: All three items are rectangles with a side length of 20 pixels. The difference
    between them is the position of their coordinate origin points. `itemA` has its
    origin in the center of the rectangle, `itemB` has its origin in the top-left
    corner of the rectangle, and `itemC` has its origin outside the drawn rectangle.
    In the following diagram, you see the origin points marked as red dots.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个项目都是边长为20像素的矩形。它们之间的区别在于它们的坐标原点位置。`itemA`的坐标原点位于矩形的中心，`itemB`的坐标原点位于矩形的左上角，而`itemC`的坐标原点位于绘制的矩形之外。在下面的图中，你可以看到原点被标记为红色圆点。
- en: '![What just happened?](img/8874OS_06_11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_06_11.jpg)'
- en: So what's the deal with these origin points? On the one hand, the origin point
    is used to create a relation between the item's coordinate system and the scene's
    coordinate system. As you will see later in more detail, if you set the position
    of the item on the scene, the position on the scene is the origin of the item.
    You can say scene *(x, y) = item(0, 0)*. On the other hand, the origin point is
    used as a center point for all transformations you can use with items, such as
    scaling, rotating, or adding a freely definable transformation matrix of `QTransform`
    type. As an additional feature, you always have the option to combine a new transformation
    with the already applied ones or to replace the old transformation(s) with a new
    one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些原点有什么作用呢？一方面，原点用于在项目的坐标系和场景坐标系之间建立关系。正如你将在后面更详细地看到的那样，如果你设置了项目在场景中的位置，场景中的位置就是项目的原点。你可以这样说：场景
    *(x, y) = 项目(0, 0)*。另一方面，原点用作所有可用于项目的变换的中心点，例如缩放、旋转或添加一个可自由定义的`QTransform`类型的变换矩阵。作为一个附加功能，你始终可以选择将新的变换与已应用的变换组合，或者用新的变换替换旧的变换。
- en: Time for action – rotating an item
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 旋转项目
- en: 'As an example, let''s rotate `itemB` and `itemC` by 45 degrees counter-clockwise.
    For `itemB`, the function call would look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将`itemB`和`itemC`逆时针旋转45度。对于`itemB`，函数调用将如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `setRotation()` function accepts `qreal` as the argument value, so you
    can set very precise values. The function interprets the number as degrees for
    a clockwise rotation around the *z* coordinate. If you set a negative value, a
    counter-clockwise rotation is performed. Even if it does not make much sense,
    you can rotate an item by 450 degrees, which would result in a rotation of 90
    degrees. Here is what the two items would look like after the rotation by 45 degrees
    counter-clockwise:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRotation()`函数接受`qreal`作为参数值，因此你可以设置非常精确的值。该函数将数字解释为围绕*z*坐标的顺时针旋转角度。如果你设置一个负值，则执行逆时针旋转。即使没有太多意义，你也可以将项目旋转450度，这将导致旋转90度。以下是逆时针旋转45度后的两个项目的外观：'
- en: '![Time for action – rotating an item](img/8874OS_06_14.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——旋转项目](img/8874OS_06_14.jpg)'
- en: '*What just happened?*'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'As you can see, the rotation has its center in the item''s origin point. Now
    you could run into the problem that you want to rotate the rectangle of `itemC`
    around its center point. In such a situation, you can use `setTransformOriginPoint()`.
    For the described problem, the relevant code would look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，旋转的中心在项目的原点。现在你可能遇到的问题是，你想要围绕`itemC`的矩形中心旋转。在这种情况下，你可以使用`setTransformOriginPoint()`。对于描述的问题，相关的代码将如下所示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let us take this opportunity to recapitulate the item's coordinate system. The
    item's origin point is in (0, 0). In the constructor of `QGraphicsRectItem`, you
    define that the rectangle should have its top-left corner at (10, 10). And since
    you gave the rectangle a width and a height of 20 pixels, its bottom-right corner
    is at (30, 30). This makes (20, 20) the center of the rectangle. After setting
    the transformation's origin point to (20, 20), you rotate the item around that
    point 45 degrees counter-clockwise. You will see the result in the following image,
    where the transformation's origin point is marked with a cross.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这个机会回顾一下项目的坐标系。项目的原点在(0, 0)。在`QGraphicsRectItem`的构造函数中，你定义矩形应将其左上角放在(10,
    10)。由于你给矩形设置了20像素的宽度和高度，其右下角在(30, 30)。这使得(20, 20)成为矩形的中心。在将变换的原点设置为(20, 20)后，你逆时针旋转45度。你将在以下图像中看到结果，其中变换的原点用十字标记。
- en: '![What just happened?](img/8874OS_06_15.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_06_15.jpg)'
- en: Even if you "change" the item's origin point by such a transformation, this
    does not affect the item's position on the scene. First, the scene positions the
    untransformed item with respect to its origin point and only then are all transformations
    applied to the item.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通过这样的变换“改变”了项目的原点，这也不会影响项目在场景中的位置。首先，场景根据其原点定位未变换的项目，然后才对所有变换应用于项目。
- en: Have a go hero – applying multiple transformations
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试吧英雄——应用多个变换
- en: To understand the concept of transformations and their origin point, go ahead
    and try it yourself. Apply `rotate()` and `scale()` sequentially to an item. Also,
    change the point of origin and see how the item will react. As a second step,
    use `QTransform` in conjunction with `setTransform()` to add a custom transformation
    to an item.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解变换的概念及其原点，请亲自尝试。对一个项目依次应用`rotate()`和`scale()`。同时，改变原点并观察项目如何反应。第二步，使用`QTransform`与`setTransform()`结合，为一个项目添加自定义变换。
- en: Scenes
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景
- en: Let us take a look at how we can improvise the scene.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何即兴发挥场景。
- en: Adding items to the scene
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向场景中添加项目
- en: At this point, you should have a basic understanding of items. The next question
    is what to do with them. As described earlier, you put the items on a `QGraphicsScene`
    method. This is done by calling `addItem(QGraphicsItem *item)`. Did you notice
    the type of the argument? It's a pointer to a `QGraphicsItem` method. Since all
    items on the scene must inherit `QGraphicsItem`, you can use this function with
    any item, be it a `QGraphicsRectItem` item or any custom item. If you have a look
    at the documentation of `QGraphicsScene`, you will notice that all functions returning
    items or dealing with them expect pointers to a `QGraphicsItem` item. This universal
    usability is a huge advantage of the object-orientated approach in Graphics View.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对项目有一个基本的了解。下一个问题是你要如何处理它们。如前所述，你通过调用 `addItem(QGraphicsItem *item)`
    方法将项目放置在 `QGraphicsScene` 上。这是通过调用 `addItem(QGraphicsItem *item)` 方法来完成的。你注意到参数的类型了吗？它是一个指向
    `QGraphicsItem` 的指针。由于场景上的所有项目都必须继承 `QGraphicsItem`，因此你可以使用这个函数与任何项目一起使用，无论是 `QGraphicsRectItem`
    项目还是任何自定义项目。如果你查看 `QGraphicsScene` 的文档，你会注意到所有返回项目或处理它们的函数都期望指向 `QGraphicsItem`
    项目的指针。这种通用可用性是图形视图面向对象方法的一个巨大优势。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have a pointer of the type `QGraphicsItem` pointing to an instance of
    a `QGraphicsRectItem` and you want to use a function of `QGraphicsRectItem`, use
    `qgraphicsitem_cast<>()` to cast the pointer. This is because it is safer and
    faster than using `static_cast<>()` or `dynamic_cast<>()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个指向 `QGraphicsItem` 类型的指针，它指向一个 `QGraphicsRectItem` 实例，并且你想使用 `QGraphicsRectItem`
    的一个函数，请使用 `qgraphicsitem_cast<>()` 来转换指针。这是因为它比使用 `static_cast<>()` 或 `dynamic_cast<>()`
    更安全、更快。
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that if you want to use `qgraphicsitem_cast<>()` with your own custom
    item, you have to make sure that `QGraphicsItem::type()` is reimplemented and
    that it returns a unique type for a particular item. To ensure a unique type,
    use `QGraphicsItem::UserType + x` as a return value where you count up `x` for
    every custom item you create.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你想使用 `qgraphicsitem_cast<>()` 与你自己的自定义项目，你必须确保 `QGraphicsItem::type()`
    被重新实现，并且它为特定项目返回一个唯一的类型。为了确保唯一类型，使用 `QGraphicsItem::UserType + x` 作为返回值，其中你为每个创建的自定义项目递增
    `x`。
- en: Time for action – adding an item to a scene
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——向场景添加项目
- en: 'Let''s have a first try and add an item to the scene:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，将一个项目添加到场景中：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Nothing complicated here. You create a scene, create an item of type `QGraphicsRectItem`,
    define the geometry of the item''s rectangle, and then set the item to the scene
    by calling `addItem()`. Pretty straightforward. But what you do not see here is
    what this implies for the scene. The scene is now responsible for the added item!
    First of all, the ownership of the item is transferred to the scene. For you,
    this means that you do not have to worry about freeing the item''s memory because
    deleting the scene also deletes all items associated with the scene. Now remember
    what we said about the destructor of a custom item: it must be virtual! `QGraphicsScene`
    operates with pointers to `QGraphicsItem`. Thus, when it deletes the assigned
    items, it does that by calling `delete` on the base class pointer. If you have
    not declared the destructor of the derived class virtual, it will not be executed,
    which may cause memory leaks. Therefore, form habit of declaring the destructor
    virtual.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有复杂的东西。你创建一个场景，创建一个类型为 `QGraphicsRectItem` 的项目，定义项目的矩形几何形状，然后通过调用 `addItem()`
    将项目添加到场景中。非常直接。但这里没有展示的是这给场景带来的影响。现在场景负责添加的项目！首先，项目的所有权被转移给了场景。对你来说，这意味着你不需要担心释放项目的内存，因为删除场景也会删除与场景关联的所有项目。现在记住我们之前提到的自定义项目的析构函数：它必须是虚拟的！`QGraphicsScene`
    使用指向 `QGraphicsItem` 的指针。因此，当它删除分配的项目时，它会通过在基类指针上调用 `delete` 来执行。如果你没有声明派生类的析构函数为虚拟的，它将不会执行，这可能会导致内存泄漏。因此，养成声明析构函数为虚拟的习惯。
- en: 'Transferring the ownership of the item to the scene also means that an item
    can only be added to one single scene. If the item was previously already added
    to another scene, it gets removed from there before it will be added to the new
    scene. The following code will demonstrate that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目的所有权转移到场景也意味着一个项目只能添加到一个场景中。如果项目之前已经被添加到另一个场景中，它会在被添加到新场景之前从那里移除。下面的代码将演示这一点：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After creating two scenes and one item, we add the item `item` to the scene
    `firstScene`. Then, with the debug message, we print out the number of associated
    items with that `firstScene` scene. For this, we call `items()` on the scene,
    which returns a `QList` list with pointers to all items of the scene. Calling
    `count()` on that list tells us the size of the list, which is equivalent to the
    number of added items. As you can see after adding the item on `secondScene`,
    the `firstScene` item count returns `0`. Before `item` was added to `secondScene`,
    it was first removed from `firstScene`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个场景和一个项目后，我们将项目`item`添加到场景`firstScene`中。然后，通过调试信息，我们打印出与该`firstScene`场景关联的项目数量。为此，我们在场景上调用`items()`，它返回一个包含指向场景中所有项目指针的`QList`列表。在该列表上调用`count()`告诉我们列表的大小，这相当于添加的项目数量。正如你在将项目添加到`secondScene`后所看到的，`firstScene`的项目计数返回`0`。在`item`被添加到`secondScene`之前，它首先从`firstScene`中移除。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to remove an item from a scene without setting it directly to another
    scene or without deleting it, you can call `removeItem()`, which takes a pointer
    for the item that should be removed. Be aware, however, that now it is your responsibility
    to delete the item in order to free the allocated memory!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从场景中移除一个项目，而不直接将其设置到另一个场景或删除它，你可以调用`removeItem()`，它需要一个指向要移除的项目指针。但是请注意，现在你有责任删除该项目以释放分配的内存！
- en: Interacting with items on the scene
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与场景中的项目交互
- en: When it takes ownership of an item, the scene also has to take care of a lot
    of other stuff. The scene has to make sure that events get delivered to the right
    items. If you click on a scene (to be precise, you click on a view that propagates
    the event to the scene), the scene receives the mouse press event and it then
    becomes the scene's responsibility to determine which item was meant by the click.
    In order to be able to do that, the scene always needs to know where all the items
    are. Therefore, the scene keeps track of the items in a Binary Space Partitioning
    tree.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景接管一个项目时，场景还必须注意很多其他事情。场景必须确保事件被传递到正确的项目。如果你点击场景（更准确地说，你点击一个将事件传播到场景的视图），场景会接收到鼠标按下事件，然后它就变成了场景的责任来确定点击的是哪个项目。为了能够做到这一点，场景始终需要知道所有项目的位置。因此，场景通过二叉空间划分树跟踪项目。
- en: 'You can benefit from this knowledge too! If you want to know which item is
    shown at a certain position, call `itemAt()` with `QPointF` as an argument. You
    will receive the topmost item at that position. If you want all items that are
    located at this position, say in cases where multiple items are on top of each
    other, call an overloaded function of `items()` (which takes a `QPointF` pointer
    as an argument). It will return a list of all items that the bounding rectangle
    contains that point. The `items()` function also accepts `QRectF`, `QPolygonF`,
    and `QPainterPath` as arguments if you need all visible items of an area. With
    the second argument of the type `Qt::ItemSelectionMode`, you can alter the mode
    for how the items in the area will be determined. The following table shows the
    different modes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从这项知识中受益！如果你想知道在某个位置显示的是哪个项目，请使用`QPointF`作为参数调用`itemAt()`。你将收到该位置上最顶部的项目。如果你想获取所有位于该位置的项目，例如多个项目重叠的情况，请调用`items()`的重载函数（它需要一个`QPointF`指针作为参数）。它将返回一个包含所有包含该点的边界矩形的项目的列表。`items()`函数还接受`QRectF`、`QPolygonF`和`QPainterPath`作为参数，如果你需要获取一个区域的全部可见项目。使用类型为`Qt::ItemSelectionMode`的第二个参数，你可以改变区域中项目的确定模式。以下表格显示了不同的模式：
- en: '| Mode | Meaning |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Qt::ContainsItemShape` | The item''s shape must be completely inside the
    selection area. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::ContainsItemShape` | 项目形状必须完全在选择区域内。 |'
- en: '| `Qt::IntersectsItemShape` | Similar to `Qt::ContainsItemShape` but also returns
    items whose shapes intersect with the selection area. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::IntersectsItemShape` | 与`Qt::ContainsItemShape`类似，但还返回形状与选择区域相交的项目。
    |'
- en: '| `Qt::ContainsItemBoundingRect` | The item''s bounding rectangle must be completely
    inside the selection area. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::ContainsItemBoundingRect` | 项目的边界矩形必须完全在选择区域内。 |'
- en: '| `Qt::IntersectsItemBoundingRect` | Similar to `Qt::ContainsItemBoundingRect`
    but also returns items whose bounding rectangles intersect with the selection
    area. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::IntersectsItemBoundingRect` | 与`Qt::ContainsItemBoundingRect`类似，但还返回边界矩形与选择区域相交的项目。
    |'
- en: The scene's responsibility for delivering events does not only apply to mouse
    events; it also applies to key events and all other sorts of events. The events
    that are passed to the items are subclasses of `QGraphicsSceneEvent`. Thus, an
    item does not get a `QMouseEvent` event like widgets; it gets a `QGraphicsSceneMouseEvent`
    event. In general, these scene events behave like normal events, but instead of
    say a `globalPos()` function you have `scenePos()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 场景负责传递事件的责任不仅适用于鼠标事件；它也适用于键盘事件和其他所有类型的事件。传递给项目的这些事件是 `QGraphicsSceneEvent` 的子类。因此，项目不会像小部件那样获得
    `QMouseEvent` 事件，而是获得 `QGraphicsSceneMouseEvent` 事件。通常，这些场景事件的行为类似于正常事件，但与 `globalPos()`
    函数不同，你有 `scenePos()`。
- en: The scene also handles the selection of items. To be selectable, an item must
    have the `QGraphicsItem::ItemIsSelectable` flag turned on. You can do that by
    calling `QGraphicsItem::setFlag()` with the flag and `true` as arguments. Besides
    that, there are different ways to select items. There is the item's `QGraphicsItem::setSelected()`
    function, which takes a `bool` value to toggle the selection state on or off,
    or you can call `QGraphicsScene::setSelectionArea()` on the scene, which takes
    a `QPainterPath` parameter as argument, in which case all items get selected.
    With the mouse, you can click on an item to select or deselect it or—if the view's
    rubber-band selection mode is enabled—you can select multiple items with that
    rubber band.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 场景还处理项目的选择。要可选中，项目必须将 `QGraphicsItem::ItemIsSelectable` 标志打开。你可以通过调用 `QGraphicsItem::setFlag()`
    并将标志和 `true` 作为参数来实现。除此之外，还有不同的方式来选择项目。有项目的 `QGraphicsItem::setSelected()` 函数，它接受一个
    `bool` 值来切换选择状态，或者你可以在场景上调用 `QGraphicsScene::setSelectionArea()`，它接受一个 `QPainterPath`
    参数作为参数，在这种情况下，所有项目都会被选中。使用鼠标，你可以点击一个项目来选中或取消选中它，或者如果视图的橡皮筋选择模式被启用，你可以使用该橡皮筋选择多个项目。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For activating the rubber band selection for the view, call `setDragMode` `(QGraphicsView::RubberBandDrag)`
    on the view. Then you can press the left mouse button and, while holding it down,
    move the mouse to define the selection area. The selection rectangle is then defined
    by the point of the first mouse press and the current mouse position.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活视图的橡皮筋选择，请在视图上调用 `setDragMode` `(QGraphicsView::RubberBandDrag)`。然后你可以按下鼠标左键，在按住鼠标的同时移动鼠标以定义选择区域。选择矩形由第一次鼠标点击的点和当前鼠标位置定义。
- en: With the scene's `QGraphicsScene::selectedItems()` function, you can query the
    actual selected items. The function returns a `QList` list holding `QGraphicsItem`
    pointers to selected items. For example, calling `QList::count()` on that list
    would give you the number of selected items. To clear the selection, call `QGraphicsScene::clearSelection()`.
    To query the selection state of an item, use `QGraphicsItem::isSelected()`, which
    returns `true` if the item is selected and `false` otherwise. If you write a customized
    `paint` function, do not forget to alter the item's appearance to indicate that
    it is selected. Otherwise, the user cannot know this. The determination inside
    the paint function is done by `QStyle::State_Selected`, as shown earlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景的 `QGraphicsScene::selectedItems()` 函数，你可以查询实际选中的项目。该函数返回一个包含指向选中项目的 `QGraphicsItem`
    指针的 `QList` 列表。例如，在该列表上调用 `QList::count()` 会给出选中项目的数量。要清除选择，请调用 `QGraphicsScene::clearSelection()`。要查询项目的选择状态，使用
    `QGraphicsItem::isSelected()`，如果项目被选中则返回 `true`，否则返回 `false`。如果你编写了一个自定义的 `paint`
    函数，不要忘记更改项目的外观以表明它已被选中。否则，用户将无法知道这一点。在 `paint` 函数内部的判断是通过 `QStyle::State_Selected`
    来完成的，如前所述。
- en: '![Interacting with items on the scene](img/8874OS_06_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![与场景中的项目交互](img/8874OS_06_10.jpg)'
- en: The standard items show a dashed rectangle around a selected item.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 标准项目在选中项目周围显示一个虚线矩形。
- en: The item's handling of focus is done in a similar way. To be focusable an item
    must have the `QGraphicsItem::ItemIsFocusable` flag enabled. Then, the item can
    be focused by a mouse click, through the item's `QGraphicsItem::setFocus()` function,
    or through the scene's `QGraphicsScene::setFocusItem()` function, which expects
    a pointer to the item you like to focus as a parameter. To determine if an item
    has focus, you again have two possibilities. One is that you can call `QGraphicsItem::hasFocus()`
    on an item, which returns `true` if the item has focus or `false` otherwise. Alternatively,
    you can get the actual focused item by calling the scene's `QGraphicsScene::focusItem()`
    method. On the other hand, if you call the item's `QGraphicsItem::focusItem()`
    function, the focused item is returned if the item itself or any descendant item
    has focus; otherwise, `0` is returned. To remove focus, call `clearFocus()` on
    the focused item or click somewhere in the scene's background or on an item that
    cannot get focus.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 项目处理焦点的方式也类似。要成为可聚焦的，项目必须启用`QGraphicsItem::ItemIsFocusable`标志。然后，可以通过鼠标点击、通过项目的`QGraphicsItem::setFocus()`函数，或者通过场景的`QGraphicsScene::setFocusItem()`函数来聚焦项目，该函数期望一个指向你想要聚焦的项目指针作为参数。要确定一个项目是否有焦点，你有两种可能性。一种是你可以对一个项目调用`QGraphicsItem::hasFocus()`，如果项目有焦点则返回`true`，否则返回`false`。或者，你可以通过调用场景的`QGraphicsScene::focusItem()`方法来获取实际聚焦的项目。另一方面，如果你调用项目的`QGraphicsItem::focusItem()`函数，如果项目本身或任何子项目有焦点，则返回聚焦的项目；否则，返回`0`。要移除焦点，请在聚焦的项目上调用`clearFocus()`或在场景的背景或无法获取焦点的项目上点击。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want a click on the scene's background not to cause the focused item
    to lose its focus, set the scene's `stickyFocus` property to `true`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望点击场景的背景不会导致焦点项目失去焦点，请将场景的`stickyFocus`属性设置为`true`。
- en: Rendering
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染
- en: It is also the scene's responsibility to render itself with all the assigned
    items.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是场景的责任，使用所有分配的项目渲染自己。
- en: Time for action – rendering the scene's content to an image
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间 – 将场景内容渲染为图像
- en: 'Let''s try to render a scene to an image. In order to do that, we take the
    following code snippet from our first example where we tried to put items on a
    scene:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将一个场景渲染成图像。为了做到这一点，我们从第一个示例中提取以下代码片段，在第一个示例中我们尝试将项目放置在场景中：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only change we make here is that we set a brush resulting in a green-filled
    rectangle with a red border, which was defined through `setBrush()` and `setPen()`.
    You can also define the thickness of the stroke by passing a `QPen` object with
    the corresponding arguments. To render the scene, you only need to call `render()`,
    which takes a pointer to a `QPainter` pointer. This way, the scene can render
    its contents to any paint device the painter is pointing to. For us, a simple
    PNG file will do the job.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的唯一改变是设置了一个画刷，它产生一个绿色填充、红色边框的矩形，这是通过`setBrush()`和`setPen()`定义的。你也可以通过传递一个带有相应参数的`QPen`对象来定义笔划的粗细。要渲染场景，你只需要调用`render()`，它接受一个指向`QPainter`指针的指针。这样，场景就可以将其内容渲染到画家指向的任何绘图设备上。对我们来说，一个简单的PNG文件就可以完成这项工作。
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Time for action – rendering the scene''s content to an image](img/8874OS_06_13.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![执行时间 – 将场景内容渲染为图像](img/8874OS_06_13.jpg)'
- en: Result of the rendering
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染结果
- en: '*What just happened?*'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: First you determined the rectangle of the scene with `sceneRect()`. Since this
    returns a `QRectF` parameter and `QImage` can only handle `QRect`, you transformed
    it on-the-fly by calling `toAlignedRect()`. The difference between the `toRect()`
    function and `toAlignedRect()` is that the former rounds to the nearest integer,
    which may result in a smaller rectangle whereas the latter expands to the smallest
    possible rectangle containing the original `QRectF` parameter. Then, you created
    a `QImage` file with the size of the aligned scene's rectangle. Because the image
    is created with uninitialized data, you need to call `fill()` with `Qt::transparent`
    to receive a transparent image. You can assign any color you like as an argument
    both a value of `Qt::GlobalColor` enumeration and an ordinary `QColor` object;
    `QColor(0, 0, 255)` would result in a blue background. Next, you create a `QPainter`
    object which points to the image. This painter object is now used in the scene's
    `render()` function to draw the scene. After that, all you have to do is to save
    the image to a place of your choice. The file name (which can also contain an
    absolute path such as `/path/to/image.png`) is given by the first argument whereas
    the second argument determines the format of the image. Here, we set the file
    name to `scene.png` and choose the PNG format. Since we haven't specified a path,
    the image will be saved in the application's current directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用 `sceneRect()` 确定了场景的矩形。由于这个函数返回一个 `QRectF` 参数，而 `QImage` 只能处理 `QRect`，所以你通过调用
    `toAlignedRect()` 在线转换它。`toRect()` 函数和 `toAlignedRect()` 之间的区别在于前者四舍五入到最接近的整数，这可能会导致矩形更小，而后者则扩展到包含原始
    `QRectF` 参数的最小可能矩形。然后，你创建了一个具有对齐场景矩形大小的 `QImage` 文件。因为图像是用未初始化的数据创建的，所以你需要使用 `Qt::transparent`
    调用 `fill()` 来接收一个透明图像。你可以将任何颜色作为参数分配，无论是 `Qt::GlobalColor` 枚举的值还是一个普通的 `QColor`
    对象；`QColor(0, 0, 255)` 将导致蓝色背景。接下来，你创建了一个指向图像的 `QPainter` 对象。这个绘图对象现在被用于场景的 `render()`
    函数来绘制场景。之后，你所要做的就是将图像保存到你选择的任何位置。文件名（也可以包含一个绝对路径，例如 `/path/to/image.png`）由第一个参数给出，而第二个参数确定图像的格式。在这里，我们将文件名设置为
    `scene.png` 并选择 PNG 格式。由于我们没有指定路径，图像将被保存在应用程序的当前目录中。
- en: Have a go hero – rendering only specific parts of a scene
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——仅渲染场景的特定部分
- en: This example draws the whole scene. Of course, you can also render only specific
    parts of the scene by using the other arguments of `render()`. We will not go
    into this here but you may want to try it as an exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例绘制了整个场景。当然，你也可以通过使用 `render()` 函数的其他参数来仅渲染场景的特定部分。这里我们不会深入探讨这一点，但你可能想作为一个练习尝试一下。
- en: Coordinate system of the scene
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的坐标系
- en: What is left is a look at the coordinate system of the scene. Like the items,
    the scene lives in its own coordinate system with the origin at (0, 0). Now when
    you add an item via `addItem()`, the item is positioned at the scene's (0, 0)
    coordinate. If you want to move the item to another position on the scene, call
    `setPos()` on the item.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是查看场景的坐标系了。和项目一样，场景也存在于自己的坐标系中，原点位于 (0, 0)。现在当你通过 `addItem()` 添加一个项目时，该项目就被定位在场景的
    (0, 0) 坐标上。如果你想将项目移动到场景上的另一个位置，请在项目上调用 `setPos()`。
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After creating the scene and the item, you add the item to the scene by calling
    `addItem()`. At this stage, the scene''s origin and the item''s origin are stacked
    on top of each other at (0, 0). By calling `setPos()`, you move the item 50 pixels
    right and down. Now the item''s origin is at (50, 50) in scene coordinates. If
    you need to know the position of the bottom-right corner of the item''s rectangle
    in scene coordinates, you have to do a quick calculation. In the item''s coordinate
    system, the bottom right corner is at (10, 10). The item''s origin point is (0,
    0) in the item''s coordinate system, which corresponds to the point (50, 50) in
    the scene''s coordinate system. So you just have to take (50, 50) and add (10,10)
    to get (60, 60) as the scene''s coordinates for the bottom-right corner of the
    item. This is an easy calculation, but it quickly gets complicated when you rotate,
    scale, and/or shear the item. Because of this, you should use one of the convenience
    functions provided by `QGraphicsItem`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建场景和项目后，您可以通过调用`addItem()`将项目添加到场景中。在这个阶段，场景的原点和项目的原点在(0, 0)处重叠。通过调用`setPos()`，您将项目向右和向下移动50像素。现在项目的原点在场景坐标中的位置是(50,
    50)。如果您需要知道项目矩形右下角在场景坐标中的位置，您需要进行快速计算。在项目的坐标系中，右下角位于(10, 10)。在项目的坐标系中，项目的原点是(0,
    0)，这对应于场景坐标系中的点(50, 50)。因此，您只需将(50, 50)和(10, 10)相加，得到(60, 60)作为项目右下角在场景坐标中的位置。这是一个简单的计算，但当您旋转、缩放和/或扭曲项目时，它会迅速变得复杂。正因为如此，您应该使用`QGraphicsItem`提供的便利函数之一：
- en: '| Function | Description |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mapToScene(const QPoint &point)` | Maps the point `point` that is in the
    item''s coordinate system to the corresponding point in the scene''s coordinate
    system. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `mapToScene(const QPoint &point)` | 将位于项目坐标系中的点`point`映射到场景坐标系中的对应点。|'
- en: '| `mapFromScene(const QPoint &point)` | Maps the point `point` that is in the
    scene''s coordinate system to the corresponding point in the item''s coordinate
    system. This function is the reverse function to `mapToScene()`. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `mapFromScene(const QPoint &point)` | 将位于场景坐标系中的点`point`映射到项目坐标系中的对应点。此函数是`mapToScene()`的逆函数。|'
- en: '| `mapToParent(const QPoint &point)` | Maps the point `point` that is in the
    item''s coordinate system to the corresponding point in the coordinate system
    of the item''s parent. If the item does not have a parent, this function behaves
    like `mapToScene()`; thus, it returns the corresponding point in the scene''s
    coordinate system. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `mapToParent(const QPoint &point)` | 将位于项目坐标系中的点`point`映射到项目父级坐标系中的对应点。如果项目没有父级，此函数的行为类似于`mapToScene()`；因此，它返回场景坐标系中的对应点。|'
- en: '| `mapFromParent(const QPoint &point)` | Maps the point `point` that is in
    the coordinate system of the item''s parent to the corresponding point in the
    item''s own coordinate system. This function is the reverse function to `mapToParent()`.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `mapFromParent(const QPoint &point)` | 将位于项目父级坐标系中的点`point`映射到项目自身坐标系中的对应点。此函数是`mapToParent()`的逆函数。|'
- en: '| `mapToItem(const QGraphicsItem *item, const QPointF &point)` | Maps the point
    `point` that is in the item''s own coordinate system to the corresponding point
    in the coordinate system of the item `item`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `mapToItem(const QGraphicsItem *item, const QPointF &point)` | 将位于项目自身坐标系中的点`point`映射到项目`item`的坐标系中的对应点。|'
- en: '| `mapFromItem(const QGraphicsItem *item, const QPointF &point)` | Maps the
    point `point` which is in the coordinate system of the item `item` to the corresponding
    point in the item''s own coordinate system. This function is the reverse function
    to `mapToItem()`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `mapFromItem(const QGraphicsItem *item, const QPointF &point)` | 将位于项目`item`坐标系中的点`point`映射到项目自身坐标系中的对应点。此函数是`mapToItem()`的逆函数。|'
- en: 'What is great about these functions is that they are not only available for
    `QPointF`. The same functions are also available for `QRectF`, `QPolygonF`, and
    `QPainterPath`. Not to mention that these are of course convenience functions:
    If you call these functions with two numbers of the type `qreal`, the numbers
    get interpreted as the *x* and *y* coordinates of a `QPointF` pointer; if you
    call the functions with four numbers, the numbers get interpreted as the *x* and
    *y* coordinates and the width and the height of a `QRectF` parameter.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的伟大之处在于它们不仅适用于 `QPointF`。同样的函数也适用于 `QRectF`、`QPolygonF` 和 `QPainterPath`。更不用说这些当然都是便利函数：如果你用两个
    `qreal` 类型的数字调用这些函数，数字会被解释为 `QPointF` 指针的 *x* 和 *y* 坐标；如果你用四个数字调用这些函数，数字会被解释为
    `QRectF` 参数的 *x* 和 *y* 坐标以及宽度和高度。
- en: Since the positioning of the items is done by the items themselves, it is possible
    that an item independently moves around. Do not worry; the scene will get notified
    about any item position change. And not only the scene! Remember the parent-child
    relationship of items and that parents delete their child items when they get
    destroyed themselves? It's the same with `setPos()`. If you move a parent, all
    child items get moved as well. This can be very useful if you have a bunch of
    items that should stay together. Instead of moving all items by themselves, you
    only have to move one item. Since transformations that you apply on a parent also
    affect the children, this might not be the best solution for grouping together
    equal items that should be independently transformable but also transformable
    altogether. The solution for such a case is `QGraphicsItemGroup`. It behaves like
    a parent in a parent-child relationship. The `QGraphicsItemGroup` is an invisible
    parent item so that you can alter the child items separately through their transformation
    functions or all together by invoking the transformation functions of `QGraphicsItemGroup`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目的定位是由项目本身完成的，因此一个项目可能会独立移动。不要担心；场景会通知任何项目位置的变化。而且不仅仅是场景！记得项目和它们之间的父子关系，当父项目被销毁时，它们会删除它们的子项目？这与
    `setPos()` 是一样的。如果你移动一个父项目，所有子项目也会被移动。如果你有一堆应该在一起的项目，这可以非常有用。你不需要移动所有项目，只需移动一个项目即可。由于应用于父项目的变换也会影响子项目，这可能不是将应该独立变换但也可以一起变换的相等项目分组在一起的最佳解决方案。这种情况的解决方案是
    `QGraphicsItemGroup`。它就像父子关系中的父项目一样表现。`QGraphicsItemGroup` 是一个不可见的父项目，这样你就可以通过它们的变换函数单独改变子项目，或者通过调用
    `QGraphicsItemGroup` 的变换函数一起改变所有子项目。
- en: Time for action – transforming parent items and child items
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——变换父项目和子项目
- en: 'Have a look at the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'After creating a scene, we create four rectangle items that are arranged in
    a 2 x 2 matrix. This is done with the calls of the `moveBy()` function, which
    interprets the first argument as a shift to the right or left when negative and
    the second argument as a shift to the bottom or top when negative. Then we create
    a new `QGraphicsItemGroup` item which, since it subclasses `QGraphicsItem`, is
    a regular item and can be used as such. By calling `addToGroup()`, we add the
    items that we want to position inside that group. If you''d like to remove an
    item from the group later on, simply call `removeFromGroup()` and pass the respective
    item. The `rectD` parameter is added to the group in a different way. By calling
    `setGroup()` on `rectD`, it gets assigned to `group`; this behavior is comparable
    to `setParent()`. If you want to check whether an item is assigned to a group,
    just call `group()` on it. It will return a pointer to the group or `0` if the
    item is not in a group. After adding the group to the scene, and thus also the
    items, we rotate the whole group by 70 degrees clockwise. Afterward, all items
    are separately rotated 25 degrees counter-clockwise around their top left corner.
    This will result in the following appearance:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建场景之后，我们创建了四个矩形元素，它们被排列成一个2 x 2的矩阵。这是通过调用`moveBy()`函数实现的，该函数将第一个参数解释为向右或向左的移动，当参数为负时，第二个参数解释为向上或向下的移动。然后我们创建了一个新的`QGraphicsItemGroup`元素，由于它继承自`QGraphicsItem`，因此它是一个常规元素，可以像这样使用。通过调用`addToGroup()`，我们将想要放置在该组内部的元素添加进去。如果你以后想从组中移除一个元素，只需调用`removeFromGroup()`并传递相应的元素即可。`rectD`参数以不同的方式添加到组中。通过在`rectD`上调用`setGroup()`，它被分配给`group`；这种行为与`setParent()`类似。如果你想检查一个元素是否分配给了组，只需调用它上的`group()`即可。它将返回指向组的指针或`0`，如果元素不在组中。在将组添加到场景中，从而也将元素添加到场景中之后，我们将整个组顺时针旋转70度。之后，所有元素分别绕其左上角逆时针旋转25度。这将导致以下外观：
- en: '![What just happened?](img/8874OS_06_09.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_06_09.jpg)'
- en: Here you see the initial state after moving the items, then after rotating the
    group by 70 degrees, and then after rotating each item by -25 degrees
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到移动元素后的初始状态，然后是旋转组70度后的状态，然后是每个元素旋转-25度后的状态
- en: 'If we were to rotate the items more, they would overlap each other. But which
    item would overlap which? This is defined by the item''s *z* value; you can define
    the value by using `QGraphicsItem::setZValue()` otherwise it is `0`. Based on
    that, the items get stacked. Items with a higher *z* value are displayed on top
    of items with lower *z* values. If items have the same *z* value, the order of
    insertion decides the placement: items added later overlap those added earlier.
    Also, negative values are possible.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续旋转这些元素，它们将相互重叠。但是哪个元素会覆盖哪个元素？这由元素的*z*值定义；你可以通过使用`QGraphicsItem::setZValue()`来定义这个值，否则它的值是`0`。基于这个值，元素被堆叠。具有更高*z*值的元素显示在具有较低*z*值的元素之上。如果元素具有相同的*z*值，则插入顺序决定放置：后来添加的元素会覆盖先添加的元素。此外，也可以使用负值。
- en: Have a go hero – playing with the z value
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的操作——玩转z值
- en: Take the item group from the example as a starting point and apply various transformations
    to it as well as different *z* values for the item. You will be astonished at
    what crazy geometrical figures you can create with these four items. Coding really
    is fun!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以示例中的元素组为起点，并对其应用各种变换，以及为元素设置不同的*z*值。你会发现你可以用这四个元素创造出多么疯狂的几何图形。编码真的很有趣！
- en: For the sake of completeness, a word on the scene's bounding rectangle is required
    (set through `setSceneRect()`). Just as the offset of an item's bounding rectangle
    affects its position on the scene, the offset of the scene's bounding rectangle
    affects the scene's position on the view. More importantly, however, the bounding
    rectangle is used for various internal computations, such as the calculation of
    the view's scroll bar value and position. Even if you do not have to set the scene's
    bounding rectangle, it is recommended that you do. This applies especially when
    your scene holds a lot of items. If you do not set a bounding rectangle, the scene
    calculates this itself by going through all the items, retrieving their positions
    and their bounding rectangles as well as their transformations to figure out the
    maximum occupied space. This calculation is done by the function `itemsBoundingRect()`.
    As you may imagine, this becomes increasingly resource-intensive the more items
    a scene has. Furthermore, if you do not set the scene's rectangle, the scene checks
    on each item's update if the item is still in the scene's rectangle. Otherwise,
    it enlarges the rectangle to hold the item inside the bounding rectangle. The
    downside to is that it will never adjust by shirking; it will only enlarge. Thus,
    when you move an item to the outside and then to the inside again, you will mess
    up the scroll bars.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，有必要对场景的边界矩形说一句话（通过 `setSceneRect()` 设置）。正如项目边界矩形的偏移量会影响其在场景中的位置一样，场景边界矩形的偏移量会影响场景在视图中的位置。然而，更重要的是，边界矩形被用于各种内部计算，例如计算视图滚动条的值和位置。即使你不需要设置场景的边界矩形，也建议你这样做。这尤其适用于你的场景包含大量项目时。如果你不设置边界矩形，场景将通过遍历所有项目，检索它们的位置和边界矩形以及它们的变换来自己计算最大占用空间。这个计算是通过函数
    `itemsBoundingRect()` 完成的。正如你可能想象的那样，随着场景中项目的增加，这个计算变得越来越资源密集。此外，如果你不设置场景的矩形，场景会在每个项目的更新时检查项目是否仍然在场景的矩形内。如果不是，它会扩大矩形以包含项目在边界矩形内。缺点是它永远不会通过缩小来调整；它只会扩大。因此，当你将一个项目移动到外面，然后再移动到里面时，你会搞乱滚动条。
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you do not want to calculate the size of your scene yourself, you can add
    all items to the scene and then call `setSceneRect()` with `itemsBoundingRect()`
    as an argument. With this, you stop the scene from checking and updating the maximum
    bounding rectangle on item updates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想自己计算场景的大小，你可以将所有项目添加到场景中，然后使用 `itemsBoundingRect()` 作为参数调用 `setSceneRect()`。这样，你就可以停止场景在项目更新时检查和更新最大边界矩形。
- en: View
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看
- en: With `QGraphicsView`, we are back in the world of widgets. Since `QGraphicsView`
    inherits `QWidget`, you can use the view like any other widget and place it into
    layouts for creating neat graphical user interfaces. For the Graphics View architecture,
    `QGraphicsView` provides an inspection window on a scene. With the view, you can
    display the whole scene or only part of it, and by using a transformation matrix
    you can manipulate the scene's coordinate system. Internally, the view uses `QGraphicsScene::render()`
    to visualize the scene. By default, the view uses a `QWidget` element as a painting
    device. Since `QGraphicsView` inherits `QAbstractScrollArea`, the widget is set
    as its viewport. Therefore, when the rendered scene exceeds the view's geometry,
    scroll bars are automatically shown.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QGraphicsView`，我们回到了小部件的世界。由于 `QGraphicsView` 继承自 `QWidget`，你可以像使用任何其他小部件一样使用视图，并将其放置到布局中，以创建整洁的图形用户界面。对于图形视图架构，`QGraphicsView`
    提供了一个场景的检查窗口。通过视图，你可以显示整个场景或其一部分，并且通过使用变换矩阵，你可以操纵场景的坐标系。内部，视图使用 `QGraphicsScene::render()`
    来可视化场景。默认情况下，视图使用一个 `QWidget` 元素作为绘图设备。由于 `QGraphicsView` 继承自 `QAbstractScrollArea`，该小部件被设置为它的视口。因此，当渲染的场景超出视图的几何形状时，会自动显示滚动条。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of using the default `QWidget` element as the viewport widget, you can
    set your own widget by calling `setViewport()` with the custom one as an argument.
    The view will then take ownership of the assigned widget, which is accessible
    by `viewport()`. This also gives you the opportunity to use OpenGL for rendering.
    Simply call `setViewport(new QGLWidget)`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用默认的 `QWidget` 元素作为视口小部件，你可以通过调用 `setViewport()` 并将自定义小部件作为参数来设置自己的小部件。然后视图将接管分配的小部件的所有权，这可以通过
    `viewport()` 访问。这也给你提供了使用 OpenGL 进行渲染的机会。只需调用 `setViewport(new QGLWidget)` 即可。
- en: Time for action – putting it all together!
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将所有这些放在一起！
- en: 'Before we go on, however, and after talking a lot about items and scenes, let''s
    see how the view, the scene, and the items all work together:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，然而，在大量讨论了项目和场景之后，让我们看看视图、场景和项目是如何一起工作的：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Build and run this example and you will see following image in the middle of
    the view:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行此示例，你将在视图中间看到以下图像：
- en: '![Time for action – putting it all together!](img/8874OS_06_06.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![时间行动 – 将所有内容组合在一起！](img/8874OS_06_06.jpg)'
- en: '*What just happened?*'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'What have we done here? On top, we included the needed headers and then wrote
    a normal main function and created a `QApplication` elment. Its event loop is
    started in the return statement on the bottom. In between, we created a scene
    and added the first item to it by calling `addEllipse()`. This function is one
    of the many convenience functions of Qt and is, in our case, equivalent to the
    following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了什么？在顶部，我们包含了所需的头文件，然后编写了一个正常的main函数并创建了一个`QApplication`元素。其事件循环在底部的返回语句中启动。在中间，我们创建了一个场景，并通过调用`addEllipse()`将其第一个项目添加到场景中。这个函数是Qt的许多便利函数之一，在我们的情况下，等同于以下代码：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We thus have put a circle with a radius of 50 pixels in the scene. The origins
    of the circle and of the scene are stacked on top of each other. Next, by calling
    `addLine()`, we add a blue line that goes through the center point of the circle,
    parallel to the scene's bottom line. The first two arguments are the *x* and *y*
    coordinates of the line's starting point and the second two arguments the *x*
    and *y* coordinates of the end point. With `addRect()`, we add a square with a
    25-pixel side at the top-left corner of the scene. This time, however, we fetch
    the pointer, which is then returned by these functions. This is because we want
    to move the rectangle to the center of the scene. In order to do that, we use
    `setPos()` and need to do some arithmetic. Why? Because of the relationship between
    the scene's and the item's coordinate systems. By simply calling `item->setPos(scene.sceneRect().center())`,
    the origin of the item (which is (0, 0) in the item's coordinates and thus the
    rectangle's top left corner) would be in the middle of the scene, not the red
    square itself. Thus we need to shift the rectangle back by half of its width and
    height. This is done by subtracting its center point from the scene's center point.
    As you probably have already guessed, `QRectF::center()` returns the center point
    of a rectangle as a `QPointF` pointer. Lastly, we create a view and declare that
    it should display the scene by calling `setScene()` with the scene as an argument.
    Then we show the view. That's all you need to do to show a scene with items.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在场景中放置了一个半径为50像素的圆。圆的起点和场景的起点是重叠的。接下来，通过调用`addLine()`，我们添加了一条通过圆中心点、与场景底部线平行的蓝色线。前两个参数是线的起始点的*x*和*y*坐标，后两个参数是终点的*x*和*y*坐标。使用`addRect()`，我们在场景的左上角添加了一个边长为25像素的正方形。然而，这次我们获取了指针，然后这些函数返回这个指针。这是因为我们想要将矩形移动到场景的中心。为了做到这一点，我们使用`setPos()`并需要进行一些算术运算。为什么？因为场景和项目坐标系统之间的关系。通过简单地调用`item->setPos(scene.sceneRect().center())`，项目的起点（在项目的坐标中是(0,
    0)，因此是矩形的左上角）就会位于场景的中间，而不是红色正方形本身。因此，我们需要将矩形向回移动其宽度和高度的一半。这是通过从场景的中心点减去其中心点来完成的。正如你可能已经猜到的，`QRectF::center()`返回一个矩形的中心点作为`QPointF`指针。最后，我们创建了一个视图，并通过调用`setScene()`并传入场景作为参数来声明它应该显示场景。然后我们显示了视图。这就是显示带有项目的场景所需做的全部工作。
- en: Two things you will probably notice if you have a look at the result are that
    the drawing looks pixelated and that it stays in the center of the view when you
    resize the view. The solution for the first problem you should already know from
    what you learned in the previous chapter. You have to turn on antialiasing. For
    the view, you do that with this line of code
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看结果，你可能会注意到两件事：绘图看起来是像素化的，并且在调整视图大小时它保持在视图的中心。对于第一个问题的解决方案，你应该已经从上一章学到了。你必须打开抗锯齿。对于视图，你可以用以下代码行来实现：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With `setRenderHint()`, you can set all hints you know from `QPainter` to the
    view. Before the view renders the scene on its viewport widget, it initializes
    the internally used `QPainter` element with these hints. With the antialiasing
    flag turned on, the painting is done much more smoothly. Unfortunately, the line
    is also painted antialiased (even though we do not want this since now the line
    looks washy). To prevent the line from getting drawn antialiased, you have to
    override the `paint()` function of the item and explicitly turn off antialiasing.
    However, you might want to have a line with aliasing somewhere, so there is another
    small and easy solution for that problem without the need for reimplementing the
    `paint` function. All you have to do is to shift the position by half of the pen''s
    width. For that, write the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setRenderHint()`，你可以将你知道的所有来自 `QPainter` 的提示设置到视图中。在视图在其视口小部件上渲染场景之前，它会使用这些提示初始化内部使用的
    `QPainter` 元素。当开启抗锯齿标志时，绘图会更加平滑。不幸的是，线条也被绘制成抗锯齿效果（尽管我们并不希望这样，因为现在线条看起来模糊）。为了防止线条被绘制成抗锯齿效果，你必须覆盖项目的
    `paint()` 函数并显式关闭抗锯齿。然而，你可能希望在某个地方有一条带有抗锯齿的线条，因此有一个小而简单的解决方案来解决这个问题，而不需要重新实现 `paint`
    函数。你所要做的就是将位置移动到笔宽的一半。为此，请编写以下代码：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By calling `pen()`, you get the pen that is used to draw the line. Then you
    determine its width by calling `widthF()` and dividing it by 2\. Then just move
    the line whereby the `moveBy()` function behaves as if we had called the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `pen()`，你可以获取用于绘制线条的笔。然后通过调用 `widthF()` 并将其除以 2 来确定其宽度。然后只需移动线条，其中 `moveBy()`
    函数的行为就像我们调用了以下代码：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To be pixel-perfect, you might need to alter the length of the line.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到像素级的精确，你可能需要改变线条的长度。
- en: The second "problem" was that the scene is always visualized in the center of
    the view, which is the default behavior of the view. You can change this setting
    with `setAlignment()`, which accepts `Qt::Alignment` flags as arguments. So, calling
    `view.setAlignment(Qt::AlignBottom | Qt::AlignRight)`; would result in the scene
    staying in the lower-right corner of the view.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个“问题”是场景总是可视化在视图的中心，这是视图的默认行为。你可以使用 `setAlignment()` 来更改此设置，它接受 `Qt::Alignment`
    标志作为参数。因此，调用 `view.setAlignment(Qt::AlignBottom | Qt::AlignRight)`；会导致场景保持在视图的右下角。
- en: Showing specific areas of the scene
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示场景的特定区域
- en: As soon as the scene's bounding rectangle exceeds the viewport's size, the view
    will show scroll bars. Besides using them with the mouse to navigate to a specific
    item or point on the scene, you can also access them by code. Since the view inherits
    `QAbstractScrollArea`, you can use all its functions for accessing the scroll
    bars. `horizontalScrollBar()` and `verticalScrollBar()` return a pointer to `QScrollBar`,
    and thus you can query their range with `minimum()` and `maximum()`. By invoking
    `value()` and `setValue()`, you get and can set the current value, which results
    in scrolling the scene.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景的边界矩形超过视口大小时，视图将显示滚动条。除了使用鼠标导航到场景中的特定项目或点之外，你还可以通过代码访问它们。由于视图继承自 `QAbstractScrollArea`，你可以使用所有其函数来访问滚动条。`horizontalScrollBar()`
    和 `verticalScrollBar()` 返回一个指向 `QScrollBar` 的指针，因此你可以使用 `minimum()` 和 `maximum()`
    查询它们的范围。通过调用 `value()` 和 `setValue()`，你可以获取并设置当前值，这将导致场景滚动。
- en: 'But normally, you do not need to control free scrolling inside the view from
    your source code. The normal task would be to scroll to a specific item. In order
    to do that, you do not need to do any calculations yourself; the view offers a
    pretty simple way to do that for you: `centerOn()`. With `centerOn()`, the view
    ensures that the item, which you have passed as an argument, is centered on the
    view unless it is too close to the scene''s border or even outside. Then, the
    view tries to move it as far as possible on the center. The `centerOn()` function
    does not only take a `QGraphicsItem` item as argument; you can also center on
    a `QPointF` pointer or as a convenience on an *x* and *y* coordinate.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常，你不需要从源代码中控制视图内的自由滚动。正常任务是将滚动到特定项目。为了做到这一点，你不需要自己进行任何计算；视图为你提供了一个相当简单的方法：`centerOn()`。使用
    `centerOn()`，视图确保你传递作为参数的项目在视图中居中，除非它太靠近场景的边缘甚至在外面。然后，视图尝试尽可能地将它移动到中心。`centerOn()`
    函数不仅接受 `QGraphicsItem` 项目作为参数；你也可以将其居中到一个 `QPointF` 指针，或者作为一个便利的 *x* 和 *y* 坐标。
- en: If you do not care where an item is shown, you can simply call `ensureVisible()`
    with the item as an argument. Then the view scrolls the scene as little as possible
    so that the item's center remains or becomes visible. As a second and third argument,
    you can define a horizontal and vertical margin, which are both the minimum space
    between the item's bounding rectangle and the view's border. Both values have
    50 pixels as their default value. Beside a `QGraphicsItem` item, you can also
    ensure the visibility of a `QRectF` element (of course, there is also the convenience
    function taking four `qreal` elements).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不关心项显示的位置，你可以直接调用 `ensureVisible()` 并将项作为参数。然后视图尽可能少地滚动场景，使得项的中心保持或变为可见。作为第二个和第三个参数，你可以定义水平和垂直边距，这两个边距都是项的边界矩形和视图边框之间的最小空间。这两个值的默认值都是
    50 像素。除了 `QGraphicsItem` 项之外，你也可以确保 `QRectF` 元素（当然，也有接受四个 `qreal` 元素作为参数的便利函数）的可见性。
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you like to ensure the entire visibility of an item (since `ensureVisible(item)`
    only takes the item's center into account) use `ensureVisible(item->boundingRect())`.
    Alternatively, you can use `ensureVisible(item)`, but then you have to set the
    margins at least to the item's half width or half height respectively.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望确保项的整个可见性（因为 `ensureVisible(item)` 只考虑项的中心），请使用 `ensureVisible(item->boundingRect())`。或者，你也可以使用
    `ensureVisible(item)`，但此时你必须将边距至少设置为项的一半宽度或高度。
- en: '`centerOn()` and `ensureVisible()` only scroll the scene but do not change
    its transformation state. If you absolutely want to ensure the visibility of an
    item or a rectangle that exceeds the size of the view, you have to transform the
    scene as well. With this task, again the view will help you. By calling `fitInView()`
    with `QGraphicsItem` or a `QRectF` element as argument, the view will scroll and
    scale the scene so that it fits in the viewport size. As a second argument, you
    can control how the scaling is done. You have the following options:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`centerOn()` 和 `ensureVisible()` 只会滚动场景，但不会改变其变换状态。如果你绝对想要确保超出视图大小的项或矩形的可见性，你必须变换场景。通过将
    `QGraphicsItem` 或 `QRectF` 元素作为参数调用 `fitInView()`，视图将滚动并缩放场景，使其适应视口大小。作为第二个参数，你可以控制缩放的方式。你有以下选项：'
- en: '| Value | Description |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Qt::IgnoreAspectRatio` | The scaling is done absolutely freely regardless
    of the item''s or rectangle''s aspect ratio. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::IgnoreAspectRatio` | 缩放是绝对自由进行的，不考虑项或矩形的宽高比。 |'
- en: '| `Qt::KeepAspectRatio` | The item''s or rectangle''s aspect ratio is taken
    into account while trying to expand as far as possible while respecting the viewport''s
    size. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::KeepAspectRatio` | 在尽可能扩展的同时，考虑项或矩形的宽高比，并尊重视口的尺寸。 |'
- en: '| `Qt::KeepAspectRatioByExpanding` | The item''s or rectangle''s aspect ratio
    is taken into account, but the view tries to fill the whole viewport''s size with
    the smallest overlap. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::KeepAspectRatioByExpanding` | 考虑项或矩形的宽高比，但视图尝试用最小的重叠填充整个视口的大小。 |'
- en: 'The `fitInView()` function does not only scale larger items down to fit the
    viewport, it also enlarges items to fill the whole viewport. The following picture
    illustrates the different scaling options for an item that is enlarged:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`fitInView()` 函数不仅将较大的项缩小以适应视口，还将项放大以填充整个视口。以下图片展示了放大项的不同缩放选项：'
- en: '![Showing specific areas of the scene](img/8874OS_06_02.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![显示场景的特定区域](img/8874OS_06_02.jpg)'
- en: The circle on the left is the original item. Then, from left to right it is
    `Qt::IgnoreAspectRatio`, `Qt::KeepAspectRatio`, and `Qt::KeepAspectRatioByExpanding`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的圆圈是原始项。然后，从左到右依次是 `Qt::IgnoreAspectRatio`、`Qt::KeepAspectRatio` 和 `Qt::KeepAspectRatioByExpanding`。
- en: Transforming the scene
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换场景
- en: In the view, you can transform the scene as you like. Besides the normal convenience
    functions, such as `rotate()`, `scale()`, `shear()`, and `translate()`, you can
    also apply a free definable `QTransform` parameter via `setTransform()`, where
    you also can decide if the transformation should be combined with existing ones
    or if it should replace them. As an example of probably the most used transformation
    on a view, let us have a look how you can scale and move the scene inside the
    view.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，你可以按需变换场景。除了 `rotate()`、`scale()`、`shear()` 和 `translate()` 等常规便利函数之外，你还可以通过
    `setTransform()` 应用自定义的 `QTransform` 参数，在那里你也可以决定变换是否应该与现有的变换组合，或者是否应该替换它们。作为一个可能是在视图中使用最多的变换示例，让我们看看如何缩放和移动视图内的场景。
- en: Time for action – creating an item where transformations can easily be seen
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建一个可以轻松看到变换的项目
- en: 'First we set up a playground. To do this, we subclass a `QGraphicsRectItem`
    item and customize its paint function as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置一个游乐场。为此，我们从一个 `QGraphicsRectItem` 项目派生并自定义其绘制函数，如下所示：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*What just happened?*'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'By using the `Q_UNUSED` macro, we simply suppress compiler warnings about unused
    variables. The macro expands to `(void)x;`, which does nothing. Then we cache
    the current pen for putting it back at the end of the function. This gives `painter`
    back unchanged. Of course, we could have called `save()` and `restore()` on the
    painter, but these functions save a lot of other properties we do not want to
    change, so simply saving and restoring the pen is much faster. Next, we draw four
    red rectangles at the corners of the bounding rectangle (`r`) by calling `fillRect()`,
    which does not change the painter state. Then we set a 1-pixel thick and solid
    black pen—because this changes the pen''s state, we have saved the old pen—and
    draw the bounding rectangle, the diagonals, and a centered rectangle, which is
    a quarter of the size of the bounding rectangle. This will give us the following
    item, which shows the transformations better than with a black-filled rectangle:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Q_UNUSED` 宏，我们简单地抑制了编译器关于未使用变量的警告。该宏展开为 `(void)x;`，这什么也不做。然后我们缓存当前的画笔，以便在函数末尾将其放回。这样，`painter`
    就保持不变了。当然，我们可以在画笔上调用 `save()` 和 `restore()`，但这些函数会保存很多我们不希望改变的属性，所以简单地保存和恢复画笔要快得多。接下来，我们通过调用
    `fillRect()` 在边界矩形的四个角绘制四个红色矩形，`fillRect()` 不会改变画笔状态。然后我们设置一个1像素粗细的实心黑色画笔——因为这将改变画笔的状态，所以我们保存了旧的画笔——并绘制边界矩形、对角线和中心矩形，中心矩形的尺寸是边界矩形尺寸的四分之一。这将给我们以下项目，它比用黑色填充的矩形更好地显示了变换：
- en: '![What just happened?](img/8874OS_06_16.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_06_16.jpg)'
- en: Time for action – implementing the ability to scale the scene
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现缩放场景的能力
- en: Let's do the scaling first. We add the item to a scene and put that scene on
    a custom view we have subclassed from `QGraphicsView`. In our customized view,
    we only need to reimplement `wheelEvent()` as we want to scale the view by using
    the mouse's scroll wheel.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先进行缩放操作。我们将项目添加到一个场景中，并将该场景放置在我们从 `QGraphicsView` 派生出的自定义视图中。在我们的自定义视图中，我们只需要重写
    `wheelEvent()` 方法，因为我们想通过鼠标的滚轮来缩放视图。
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened?*'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The `factor` parameter for the zooming can be freely defined. You can also create
    a getter and setter method for it. For us, 1.1 will do the work. With `event->angleDelta()`,
    you get the distance of the mouse's wheel rotation as a `QPoint` pointer. Since
    we only care about vertical scrolling, just the *y* axis is relevant for us. In
    our example, we also do not care about how far the wheel was turned because, normally,
    every step is delivered separately to `wheelEvent()`. But if you should need it,
    it's in eighths of a degree, and since a mouse works in general steps of 15 degrees,
    the value should be 120 or -120, depending on whether you move the wheel forward
    or backward. On a forward wheel move, if `y()` is greater than zero, we zoom in
    by using the built-in `scale()` function. It takes the scale factor for the *x*
    and the *y* coordinates. Otherwise, if the wheel was moved backwards, we zoom
    out. That's all there is to it. When you try this example, you will notice that,
    while zooming, the view zooms in and out on the center of the view, which is the
    default behavior for the view. You can change this behavior with `setTransformationAnchor()`.
    `QGraphicsView::AnchorViewCenter` is, as described, the default behavior. With
    `QGraphicsView::NoAnchor`, the zoom center is in the top-left corner of the view,
    and the value you probably want to use is `QGraphicsView::AnchorUnderMouse`. With
    that option, the point under the mouse builds the center of the zooming and thus
    stays at the same position inside the view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放的 `factor` 参数可以自由定义。你也可以为它创建一个获取器和设置器方法。对我们来说，1.1 就足够了。使用 `event->angleDelta()`，你可以得到鼠标滚轮旋转的距离，作为一个
    `QPoint` 指针。由于我们只关心垂直滚动，因此对我们来说，只有 *y* 轴是相关的。在我们的例子中，我们也不关心滚轮滚动的距离，因为通常，每一步都会单独传递给
    `wheelEvent()`。但是如果你需要它，它是以八分之一度为单位，并且由于鼠标通常以15度的步长工作，因此值应该是120或-120，具体取决于你是向前还是向后滚动滚轮。在向前滚动滚轮时，如果
    `y()` 大于零，我们使用内置的 `scale()` 函数进行缩放。它接受 *x* 和 *y* 坐标的缩放因子。否则，如果滚轮向后移动，我们进行缩放。就是这样。当你尝试这个例子时，你会注意到，在缩放时，视图在视图的中心进行缩放和缩小，这是视图的默认行为。你可以使用
    `setTransformationAnchor()` 来改变这种行为。`QGraphicsView::AnchorViewCenter` 正如描述的那样，是默认行为。使用
    `QGraphicsView::NoAnchor`，缩放中心位于视图的左上角，你可能想要使用的值是 `QGraphicsView::AnchorUnderMouse`。使用该选项，鼠标下的点构成缩放的中心，因此保持在视图内的同一位置。
- en: Time for action – implementing the ability to move the scene
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——实现移动场景的能力
- en: 'Next it would be good to move the scene around without the need of using the
    scroll bars. Let us add the functionality for pressing and holding the left mouse
    button. First, we add two private members to the view: the `m_pressed` parameter
    of type `bool` and the `m_lastMousePos` element of type `QPoint`. Then, we reimplement
    the `mousePressEvent()` and `mouseReleaseEvent()` functions as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们最好能够在不使用滚动条的情况下移动场景。让我们添加按下并保持左鼠标按钮的功能。首先，我们在视图中添加两个私有成员：类型为 `bool` 的
    `m_pressed` 参数和类型为 `QPoint` 的 `m_lastMousePos` 元素。然后，我们按照以下方式重新实现 `mousePressEvent()`
    和 `mouseReleaseEvent()` 函数：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*What just happened?*'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Within `mousePressEvent()`, we check whether the left mouse button was pressed.
    If it was `true`, we then set `m_pressed` to `true` and save the current mouse
    position in `m_lastMousePos`. Then we pass the event to the base class event handler.
    Within `mouseReleaseEvent()`, we set `m_pressed` to `false` if it was the left
    button; then we pass the event to the base class implementation. We do not need
    to alter `m_pressPoint` here. With `mouseMoveEvent()`, we can then react on the
    value of those two variables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mousePressEvent()` 函数中，我们检查是否按下了左鼠标按钮。如果是 `true`，则将 `m_pressed` 设置为 `true`
    并将当前鼠标位置保存到 `m_lastMousePos`。然后我们将事件传递给基类的处理程序。在 `mouseReleaseEvent()` 函数中，如果按的是左按钮，则将
    `m_pressed` 设置为 `false`；然后我们将事件传递给基类的实现。在这里我们不需要修改 `m_pressPoint`。使用 `mouseMoveEvent()`，我们就可以对这两个变量的值做出反应：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If `m_pressed` is `false`—this means the left button wasn''t pressed and held—we
    will be exiting the function while passing the event to the base class implementation.
    This is, by the way, important for getting unhandled events propagated to the
    scene correctly. If the button has been pressed, we first calculate the difference
    (`diff`) between the point where the mouse was pressed and the current position.
    Thus we know how far the mouse was moved. Now we simply move the scroll bars by
    that value. For the horizontal scroll bar, the pointer to it is received by calling
    `horizontalScrollBar()`. The encapsulation in an `if` clause is just a paranoid
    safety check to ensure that the pointer is not null. Normally, this should never
    happen. Through that pointer, we set a new value by adding the old value, received
    by `value()`, to the moved distance, `diff.x()`. We then do the same for the vertical
    scroll bar. Last, we save the current mouse position to `m_lastMousePos`. That''s
    all. Now you can move the scene around while holding the left mouse button down.
    The downside of this method is that the left mouse click does not reach the scene
    and, therefore, features such as item selection do not work. If you need that
    or a similar functionality on the scene, check for a keyboard modifier too. For
    example, if the *Shift* key must also be pressed to move the scene, additionally
    check the events `modifiers()` for whether `Qt::ShiftModifier` is set to activate
    the mouse-moving functionality:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_pressed`为`false`——这意味着左键没有被按下并保持——我们将传递事件到基类实现时退出函数。顺便说一下，这对于正确传播未处理的事件到场景中是很重要的。如果按钮已被按下，我们首先计算鼠标按下点和当前位置之间的差异（`diff`）。这样我们就知道鼠标移动了多少。现在我们只需通过该值移动滚动条。对于水平滚动条，通过调用`horizontalScrollBar()`接收其指针。在`if`子句中的封装只是一个偏执的安全检查，以确保指针不是null。通常，这种情况永远不会发生。通过该指针，我们将通过将`value()`接收到的旧值与移动距离`diff.x()`相加来设置新的值。然后我们对垂直滚动条做同样的操作。最后，我们将当前鼠标位置保存到`m_lastMousePos`。就是这样。现在您可以在按下左鼠标按钮的同时移动场景。这种方法的一个缺点是左鼠标点击不会到达场景，因此，如项目选择等功能不会工作。如果您需要在场景上实现类似的功能，请检查键盘修饰符。例如，如果必须按下*Shift*键才能移动场景，请还检查事件`modifiers()`以确定`Qt::ShiftModifier`是否被设置为激活鼠标移动功能：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Time for action – taking the zoom level into account
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑缩放级别进行操作
- en: 'As a last detail, I would like to mention that you can draw an item differently
    depending on its scale. To do that, the level of detail can be used. You use the
    passed pointer to `QStyleOptionGraphicsItem` of the item''s `paint` function and
    call `levelOfDetailFromTransform()` with the painter''s world transformation.
    We change the paint function of the `ScaleItem` item to the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的细节，我想提到的是，您可以根据项目的缩放比例以不同的方式绘制项目。为此，可以使用细节级别。您使用传递给项目`paint`函数的`QStyleOptionGraphicsItem`指针，并使用画家的世界变换调用`levelOfDetailFromTransform()`。我们将`ScaleItem`项目的`paint`函数更改为以下内容：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*What just happened?*'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `detail` parameter now contains the maximum width of unity square, which
    was mapped to the painter coordinate system via the painter's world transformation
    matrix. Based on that value, we set the fill color of the border rectangles to
    yellow or red. The expression `detail >= 5` will become `true` if the rectangle
    is displayed at least five times as large as in a normal state. The level of detail
    is helpful when you want to draw more detail on an item only if it is visible.
    By using the level of detail, you can control when a possibly resource-intensive
    drawing should be performed. It makes sense, for example, to make difficult drawings
    only when you can see them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`detail`参数现在包含单位正方形的最大宽度，该宽度通过画家的世界变换矩阵映射到画家坐标系。基于这个值，我们将边框矩形的填充颜色设置为黄色或红色。当矩形显示的尺寸至少是正常状态下的五倍时，表达式`detail
    >= 5`将变为`true`。当您只想在项目可见时绘制更多细节时，细节级别很有帮助。通过使用细节级别，您可以控制何时执行可能资源密集型的绘图。例如，只有在您可以看到它们时才进行困难绘图是有意义的。'
- en: 'When you zoom into the scene, the diagonal lines as well as the rectangle lines
    get zoomed. But you may want to leave the stroke the same regardless of the zoom
    level. Here Qt also has an easy approach to offer. In the paint function of the
    item we used earlier for exemplifying the zoom functionality, locate the following
    line of code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当您放大场景时，对角线和矩形线也会被放大。但您可能希望无论缩放级别如何，都保持笔触不变。Qt也提供了一个简单的方法来实现这一点。在之前用于演示缩放功能的项目的`paint`函数中，定位以下代码行：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Replace it with the following lines:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下行：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The important part is to make the painter cosmetic. Now, regardless of the zoom
    or any other transformation, the pen's width stays the same. This can be very
    helpful for drawing outlined shapes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要使画家外观美观。现在，无论放大或任何其他变换，笔的宽度都保持不变。这可以非常有助于绘制轮廓形状。
- en: Questions you should keep in mind
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该记住的问题
- en: 'Whenever you are going to use the Graphics View architecture, ask yourself
    these questions: Which standard items are suited for my specific needs? Am I reinventing
    the wheel over and over again? Do I need `QGraphicsTextItem` or is `QGraphicsSimpleTextItem`
    good enough? Do I need the items to inherit `QObject` or will plain items not
    suffice? (We will cover this topic in the next section.) Could I group items together
    for the sake of cleaner and leaner code? Is the parent-child relationship sufficient
    or do I need to use a `QGraphicsItemGroup` element?'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你准备使用图形视图架构时，问问自己这些问题：哪些标准项目适合我的特定需求？我是不是一次又一次地重新发明轮子？我需要`QGraphicsTextItem`还是`QGraphicsSimpleTextItem`就足够好了？我需要项目继承`QObject`还是普通的项就足够了？（我们将在下一节中讨论这个话题。）我能为了更干净和精简的代码将项目组合在一起吗？父子关系足够还是我需要使用`QGraphicsItemGroup`元素？
- en: Now you really know most of the functions of the Graphics View framework. With
    this knowledge, you can already do a lot of cool stuff. But for a game, it is
    still too static. We will change that next!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你真的已经了解了图形视图框架的大部分功能。有了这些知识，你现在已经可以做很多酷的事情。但对于一个游戏来说，它仍然太静态了。我们将在下一节中改变这一点！
- en: The jumping elephant or how to animate the scene
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃的大象或如何动画场景
- en: 'By now, you should have a good understanding about the items, the scene, and
    the view. With your knowledge of how to create items, standard and custom ones,
    of how to position them on the scene, and of how to set up the view to show the
    scene, you can make pretty awesome things. You even can zoom and move the scene
    with the mouse. That''s surely good, but for a game, one crucial point is still
    missing: you have to animate the items. Instead of going through all possibilities
    for how to animate a scene, let us develop a simple jump-and-run game where we
    recap parts of the previous topics and learn how to animate items on a screen.
    So let''s meet Benjamin, the elephant:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对项目、场景和视图有了很好的理解。凭借你如何创建项目（标准项目和自定义项目）、如何在场景中定位它们以及如何设置视图以显示场景的知识，你可以制作出相当酷的东西。你甚至可以用鼠标缩放和移动场景。这当然很好，但对于一个游戏来说，还有一个关键点仍然缺失：你必须对项目进行动画。而不是遍历所有动画场景的可能性，让我们开发一个简单的跳跃和奔跑游戏，其中我们回顾了前几个主题，并学习如何在屏幕上对项目进行动画。那么，让我们来认识本杰明，这只大象：
- en: '![The jumping elephant or how to animate the scene](img/8874OS_06_03.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![跳跃的大象或如何动画场景](img/8874OS_06_03.jpg)'
- en: The game play
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏玩法
- en: 'The goal of the game is for Benjamin to collect the coins that are placed all
    over the game field. Besides walking right and left, Benjamin can, of course,
    also jump. In the following screenshot, you see what this minimalistic game should
    look like in the end:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是让本杰明收集散布在游戏场上的硬币。除了左右走动，本杰明当然也可以跳跃。在下面的屏幕截图中，你可以看到这个简约游戏最终应该是什么样子：
- en: '![The game play](img/8874OS_06_12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![游戏玩法](img/8874OS_06_12.jpg)'
- en: The player item
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家项目
- en: Let's now look at how we can mobilize Benjamin.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何让本杰明动起来。
- en: Time for action – creating an item for Benjamin
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——为本杰明创建一个项目
- en: 'First we need a custom item class for Benjamin. We call the class `Player`
    and choose `QGraphicsPixmapItem` as the base class because Benjamin is a PNG image.
    In the item''s `Player` class, we further create a property of integer type and
    call it `m_direction`. Its value signifies in which direction Benjamin walks—left
    or right—or if he stands still. Of course, we use a getter and setter function
    for this property. Since the header file is simple, let''s have a look at the
    implementation right away (you will find the whole source code at the end of this
    book):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为本杰明创建一个自定义项目类。我们称这个类为`Player`，并选择`QGraphicsPixmapItem`作为基类，因为本杰明是一个PNG图像。在`Player`类的项目项中，我们进一步创建一个整型属性，并称其为`m_direction`。它的值表示本杰明走向哪个方向——左或右——或者如果他静止不动。当然，我们为这个属性使用获取器和设置器函数。由于头文件很简单，让我们直接看看实现（你将在本书末尾找到整个源代码）：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the constructor, we set `m_direction` to `0`, which means that Benjamin isn't
    moving at all. If `m_direction` is `1`, Benjamin moves right, and if the value
    is `-1`, he moves left. In the body of the constructor, we set the image for the
    item by calling `setPixmap()`. The image of Benjamin is stored in the Qt Resource
    System; thus, we access it through `QPixmap(":/elephant")` with `elephant` as
    the given alias for the actual image of Benjamin. Last, we set the point of origin
    for all transformations we are going to apply to the center of the item. This
    equals the center of the image.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将 `m_direction` 设置为 `0`，这意味着本杰明根本不会移动。如果 `m_direction` 为 `1`，本杰明向右移动，如果值为
    `-1`，则向左移动。在构造函数的主体中，我们通过调用 `setPixmap()` 来设置物品的图像。本杰明的图像存储在 Qt 资源系统中；因此，我们通过
    `QPixmap(":/elephant")` 来访问它，其中 `elephant` 是实际图像的本杰明的给定别名。最后，我们设置所有将要应用于物品的变换的原点，这等于图像的中心。
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `direction()` function is a standard getter function for `m_direction`
    returning its value. The next function of this class is much more important:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`direction()` 函数是 `m_direction` 的标准获取函数，返回其值。这个类中的下一个函数要重要得多：'
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*What just happened?*'
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: With `addDirection()`, one "sets" the direction of Benjamin's movement. "Set"
    is put in quotes because you do not set `m_direction` to the passed value; instead,
    you add the passed value to `m_direction`. This is done in the second line after
    we have ensured the correctness of `m_direction`. For that, we use `qBound()`,
    which returns a value that is bound by the first and last argument. The argument
    in the middle is the actual value that we want to get bound. So the possible values
    for `m_direction` are restricted to -1, 0, and 1\. If the property `direction`
    is 0, the player item does not move and the function exits.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `addDirection()`，可以“设置”本杰明的移动方向。“设置”这个词加上了引号，因为您不是将 `m_direction` 设置为传递的值；相反，您将传递的值添加到
    `m_direction` 中。这是在我们确保 `m_direction` 正确性之后在第二行完成的。为此，我们使用 `qBound()`，它返回一个由第一个和最后一个参数限制的值。中间的参数是我们想要获取限制的实际值。因此，`m_direction`
    的可能值被限制为 -1、0 和 1。如果 `direction` 属性为 0，玩家物品不会移动，函数将退出。
- en: 'If you haven''t already done so earlier, you might wonder by now why not simply
    set the value? Why that addition? Well, it is because of how we will use this
    function: Benjamin is moved by the left and right arrow key. If the right key
    is pressed, 1 is added; if it gets released, -1 is added. Think of it as an impulse
    to the right (1) and to the left (-1). The first accelerates the player and the
    second slows him down. The same applies for the left key, but only the other way
    around. As we do not allow multiple acceleration, we limit the value of `m_direction`
    to 1 and -1\. The addition of the value rather than setting it is now necessary
    because of the following situation: A user presses and holds the right key, and
    the value of `m_direction` is therefore 1\. Now, without releasing the right key,
    he also presses and holds the left key. Therefore, the value of `m_direction`
    is getting decreased by one; the value is now 0 and Benjamin stops. But remember,
    both keys are still being pressed. What happens when the left key is released?
    How would you know in this situation in which direction Benjamin should move?
    To achieve that, you would have to find out an additional bit of information:
    whether the right key is still pressed down or not. That seems too much trouble
    and overhead. In our implementation, when the left key is released, 1 is added
    and the value of `m_direction` becomes 1, making Benjamin move right. Voilà! All
    without any concern about what the state of the other button might be.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前还没有这样做，现在您可能会想知道为什么不直接设置值？为什么要这样做加法？好吧，这是因为我们将如何使用这个函数：本杰明通过左右箭头键移动。如果按下右键，则加
    1；如果它被释放，则加 -1。将其视为向右（1）和向左（-1）的脉冲。第一个会加速玩家，第二个会减慢他的速度。对于左键也是如此，但方向相反。由于我们不允许多次加速，我们限制
    `m_direction` 的值为 1 和 -1。现在，由于以下情况，需要添加值而不是设置它：用户按下并保持右键，因此 `m_direction` 的值因此为
    1。现在，在不释放右键的情况下，他也按下并保持左键。因此，`m_direction` 的值减少了一个；现在值为 0，本杰明停止。但请记住，两个键仍然被按下。当左键释放时会发生什么？在这种情况下，您如何知道本杰明应该向哪个方向移动？为了实现这一点，您需要找到一些额外的信息：右键是否仍然被按下。这似乎太麻烦，开销太大。在我们的实现中，当左键释放时，会添加
    1，使 `m_direction` 的值变为 1，使本杰明向右移动。哇！没有任何关于其他按钮状态的担忧。
- en: Lastly, we check in which direction Benjamin is moving. If he is moving left,
    we need to flip his image so that Benjamin looks to the left, the direction in
    which he is moving. Therefore, we apply a `QTransform` matrix, which flips the
    image vertically. If he is moving towards the right, we restore the normal state
    by assigning an empty `QTransform` object, which is an identity matrix.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查本杰明正在移动的方向。如果他正在向左移动，我们需要翻转他的图像，使本杰明看起来向左，即他移动的方向。因此，我们应用一个`QTransform`矩阵，该矩阵垂直翻转图像。如果他正在向右移动，我们通过分配一个空的`QTransform`对象来恢复正常状态，这是一个单位矩阵。
- en: So we now have our item of class `Player` for the game's character, which shows
    the image of Benjamin. The item also stores the current moving direction, and
    based on that information, the image is flipped vertically if needed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了游戏角色的`Player`类项，它显示了本杰明的图像。该项还存储当前的移动方向，并根据该信息，如果需要，垂直翻转图像。
- en: The playing field
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏场地
- en: To understand the following code, it might be good to know the composition of
    the environment in which our elephant will be walking and jumping. Overall, we
    have a view fixed in size holding a scene which is exactly as big as the view.
    We do not take size changes into account since they would complicate the example
    too much, and when you develop a game for a mobile device, you know the available
    size up front.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解以下代码，了解我们的象将在其中行走和跳跃的环境组成可能是有益的。总的来说，我们有一个固定大小的视图，其中包含一个场景，其大小正好与视图相同。我们不考虑大小变化，因为这会使示例过于复杂，并且当你为移动设备开发游戏时，你知道可用的尺寸。
- en: 'All animations inside the playing field are done by moving the items, not the
    scene. So we have to distinguish between the view''s, or rather the scene''s width
    and the width of the elephant''s virtual "world" in which he can move. The width
    of this virtual world is defined by `m_fieldWidth` and has no (direct) correlation
    with the scene. Within the range of `m_fieldWidth`, which is 500 pixels in the
    example, Benjamin or the graphics item can be moved from the minimum *x* coordinate,
    defined by `m_minX`, to the maximum *x* coordinate, defined by `m_maxX`. We keep
    track of his actual *x* position with the variable `m_realPos`. Next, the minimum
    *y* coordinate the item is allowed to have is defined by `m_groundLevel`. For
    `m_maxX` and `m_groundLevel`, we have to take into account that the position of
    the item is determined by its top-left corner. Lastly, what is left is the view,
    which has a fixed size defined by the scene''s bounding rectangle size, which
    is not as wide as `m_fieldWidth`. So the scene (and the view) follows the elephant
    while he walks through his virtual world of the length `m_fieldWidth`. Have a
    look at the picture to see the variables in their graphical representation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场地内的所有动画都是通过移动项来完成的，而不是场景。因此，我们必须区分视图的宽度，或者更确切地说，场景的宽度与象的虚拟“世界”的宽度，在这个虚拟世界中他可以移动。这个虚拟世界的宽度由`m_fieldWidth`定义，并且与场景没有（直接）关联。在`m_fieldWidth`的范围内，例如示例中的500像素，本杰明或图形项可以从由`m_minX`定义的最小*x*坐标移动到由`m_maxX`定义的最大*x*坐标。我们使用变量`m_realPos`跟踪他的实际*x*位置。接下来，项允许的最小*y*坐标由`m_groundLevel`定义。对于`m_maxX`和`m_groundLevel`，我们必须考虑到项的位置是由其左上角确定的。最后，剩下的是视图，它具有由场景边界矩形大小定义的固定大小，这并不像`m_fieldWidth`那么宽。因此，场景（和视图）跟随象穿过他的虚拟世界，该虚拟世界的长度为`m_fieldWidth`。请看图片以了解变量的图形表示：
- en: '![The playing field](img/8874OS_06_04.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![游戏场地](img/8874OS_06_04.jpg)'
- en: The scene
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景
- en: Since we will have to do some work on the scene, we subclass `QGraphicsScene`
    and name the new class `MyScene`. There we implement one part of the game logic.
    This is convenient since `QGraphicsScene` inherits `QObject` and thus we can use
    Qt's signal and slot mechanism. Also, for the next code of the scene, we only
    go through the implementation of the functions. For more information on the header,
    have a look at the sources bundled with this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在场景上做一些工作，我们子类化`QGraphicsScene`并将新类命名为`MyScene`。在那里我们实现游戏逻辑的一部分。这很方便，因为`QGraphicsScene`继承自`QObject`，因此我们可以使用Qt的信号和槽机制。此外，对于场景的下一部分代码，我们只通过函数的实现来处理。有关头文件的更多信息，请参阅本书附带源代码。
- en: Time for action – making Benjamin move
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 让本杰明移动
- en: 'The first thing we want to do is to make our elephant movable. In order to
    achieve that, we use a `QTimer` parameter called `m_timer`, which is a private
    member of `MyScene`. In the constructor we set up the timer with the following
    code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是使我们的象可移动。为了实现这一点，我们使用一个名为 `m_timer` 的 `QTimer` 参数，它是 `MyScene` 的私有成员。在构造函数中，我们使用以下代码设置定时器：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First we define that the timer emits a timeout signal every 30 milliseconds.
    Then we connect that signal to the scene''s slot called `movePlayer()`, but we
    do not start the timer yet. This is done by the arrow keys in a way we have already
    discussed when the `m_direction` variable of the class `Player` was introduced.
    Here is the implementation of what was described there:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义定时器每 30 毫秒发出一个超时信号。然后，我们将该信号连接到场景的 `movePlayer()` 插槽，但我们还没有启动定时器。这是通过箭头键完成的，我们已经在介绍
    `Player` 类的 `m_direction` 变量时讨论过了。以下是那里描述的实现：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a small side note, whenever code snippets in the following code passages
    are irrelevant for the actual detail, I am going to skip the code but will indicate
    missing code with `//...` so that you know it is not the entire code. We will
    cover the skipped parts later when it is more appropriate.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小插曲，在以下代码段中，如果代码片段与实际细节无关，我将跳过代码，但会用 `//...` 指示缺失的代码，这样你知道这不是完整的代码。我们将在更合适的时候覆盖跳过的部分。
- en: '*What just happened?*'
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the key press event handler, we first check if the key event was triggered
    because of an auto repeat. If this is the case, we exit the function because we
    only want to react on the first real key press event. We also do not call the
    base class implementation of that event handler since no item on the scene needs
    to get a key press event. If you do have items that could and should receive events,
    do not forget to forward them while reimplementing event handlers at the scene.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在按键事件处理程序中，我们首先检查按键事件是否由于自动重复而触发。如果是这种情况，我们退出函数，因为我们只想对第一次真正的按键事件做出反应。我们也没有调用该事件处理程序的基类实现，因为场景上的任何项目都不需要获得按键事件。如果你有可以并且应该接收事件的项目，请不要忘记在重新实现事件处理程序时转发它们。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you press and hold a key down, Qt will continuously deliver the key press
    event. To determine if it was the first real key press or an auto-generated event,
    use `QKeyEvent::isAutoRepeat()`. It returns `true` if the event was automatically
    generated. There is no easy way to turn off the auto repeat since it is platform-dependent
    and you have to use the platform API for that.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下并保持一个键，Qt 将持续传递按键事件。为了确定这是第一次真正的按键还是自动生成的事件，请使用 `QKeyEvent::isAutoRepeat()`。如果事件是自动生成的，它将返回
    `true`。由于它依赖于平台，并且你必须使用平台 API 来关闭自动重复，因此没有简单的方法来关闭自动重复。
- en: 'As soon as we know that the event was not delivered by an auto repeat, we react
    to the different key presses. If the left key was pressed, we decrease the direction
    property of the player item by one; if the right key was pressed, we increase
    it by one. The `m_player` element is our instance of the player item. After calling
    `addDirection()`, we call `checkTimer()` in both cases:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道事件不是由自动重复触发的，我们就对不同的按键做出反应。如果按下了左键，我们将玩家项的方向属性减少一个；如果按下了右键，我们将它增加一个。`m_player`
    元素是玩家项的实例。在两种情况下，调用 `addDirection()` 后，我们都调用 `checkTimer()`：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function first checks whether the player moves. If not, the timer is stopped
    because nothing has to be updated when our elephant stands still. Otherwise, the
    timer gets started, but only if it isn't already running. This we check by calling
    `isActive()` on the timer.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先检查玩家是否移动。如果没有移动，定时器将停止，因为当我们的象静止时，不需要更新任何内容。否则，定时器将启动，但只有当它尚未运行时。我们通过在定时器上调用
    `isActive()` 来检查这一点。
- en: 'When the user presses the right key, for example at the beginning of the game,
    `checkTimer()` will start `m_timer`. Since its time out signal was connected to
    `movePlayer()`, the slot will be called every 30 milliseconds till the key is
    released. Since the `move()` function is a bit longer, let''s go through it step-by-step:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下右键时，例如在游戏开始时，`checkTimer()` 将启动 `m_timer`。由于其超时信号已连接到 `movePlayer()`，插槽将每
    30 毫秒被调用一次，直到键被释放。由于 `move()` 函数有点长，让我们一步一步地过一遍：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we cache the player's current direction in a local variable to avoid
    multiple calls of `direction()`. Then we check whether the player is moving at
    all. If they aren't, we exit the function because there is nothing to animate.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将玩家的当前方向缓存到一个局部变量中，以避免多次调用`direction()`。然后我们检查玩家是否在移动。如果他们没有移动，我们就退出函数，因为没有东西要动画化。
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next we calculate the shift the player item should get and store it in `dx`.
    The distance the player should move every 30 milliseconds is defined by the member
    variable `m_velocity`, expressed in pixels. You can create setter and getter functions
    for that variable if you like. For us, the default value of 4 pixels will do the
    job. Multiplied by the direction (which could only be 1 or -1 at this point),
    we get a shift of the player by 4 pixels to the right or to the left. Based on
    this shift, we calculate the new *x* position of the player and store it in `newPos`.
    Next, we check whether that new position is inside the range of `m_minX` and `m_maxX`,
    two member variables that are already calculated and set up properly at this point.
    Next, if the new position is not equal to the actual position, which is stored
    in `m_realPos`, we proceed by assigning the new position as the current one. Otherwise,
    we exit the function since there is nothing to move.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算玩家物品应该获得的位移并将其存储在`dx`中。玩家每30毫秒应该移动的距离由成员变量`m_velocity`定义，以像素为单位。如果您喜欢，可以为该变量创建setter和getter函数。对我们来说，默认的4像素值就足够了。乘以方向（此时只能是1或-1），我们得到玩家向右或向左移动4像素的位移。基于这个位移，我们计算玩家的新*x*位置并将其存储在`newPos`中。接下来，我们检查这个新位置是否在`m_minX`和`m_maxX`的范围内，这两个成员变量已经在此点正确计算和设置。接下来，如果新位置不等于存储在`m_realPos`中的实际位置，我们就将新位置赋值为当前位置。否则，我们退出函数，因为没有东西要移动。
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next question to tackle is whether the view should always move when the
    elephant is moving, which means that the elephant would always stay say in the
    middle of the view. No, he shouldn''t stay at a specific point inside the view.
    Rather, the view should be fixed when the elephant is moving. Only if he reaches
    the borders should the view follow. The "non-movable" center is defined by `leftBorder`
    and `rightBorder`, which are related to the item''s position; thus we must subtract
    the item''s width from the `rightBorder` element. If we don''t take the item''s
    width into account, the right side of a player with a width of more than 150 pixels
    will disappear before the scrolling takes place. Please note that the values for
    `leftBorder` and `rightBorder` are randomly chosen. You can alter them as you
    like. Here we decided to set the border at 150 pixels. Of course, you can create
    a setter and getter for these parameters too:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要解决的问题是否在象移动时视图应该始终移动，这意味着象将始终保持在视图的中间。不，他不应该停留在视图内的一个特定点上。相反，当象移动时，视图应该是固定的。只有当它达到边界时，视图才应该跟随。这个“不可移动”的中心由`leftBorder`和`rightBorder`定义，它们与物品的位置相关；因此，我们必须从`rightBorder`元素中减去物品的宽度。如果我们不考虑物品的宽度，宽度超过150像素的玩家的右侧在滚动发生之前就会消失。请注意，`leftBorder`和`rightBorder`的值是随机选择的。您可以随意更改它们。在这里，我们决定将边界设置为150像素。当然，您也可以为这些参数创建setter和getter：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Ok, so what have we done here? Here we have calculated whether only the elephant
    moves or the view as well so that the elephant does not walk out of the screen.
    The `if` clause applies when the elephant is moving towards the right. For a better
    understanding, let''s begin at the end of this scope. There is a situation where
    we do not move the elephant but simply add the shift `dx` to a variable named
    `m_skippedMoving`. What does that mean? It means that the virtual "world" is moving
    but the elephant inside the view is not. This is the case when the elephant moves
    too far to the borders. In other words, you move the view with the elephant above
    the virtual world by `dx` to the left. Let''s take a look at the following figure:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么我们在这里做了什么？这里我们计算了是否只有象移动，或者视图也移动，这样象就不会走出屏幕。当象向右移动时，`if`子句适用。为了更好地理解，让我们从这个作用域的末尾开始。有一种情况是我们不移动象，而是简单地将位移`dx`添加到一个名为`m_skippedMoving`的变量中。这意味着什么？这意味着虚拟“世界”在移动，但视图中的象没有移动。这是象移动得太远到边界的情况。换句话说，你通过`dx`将视图向左移动，使象在虚拟世界中移动。让我们看看下面的图示：
- en: '![What just happened?](img/8874OS_06_05.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_06_05.jpg)'
- en: 'The `m_skippedMoving` element is the difference between the view''s *x* coordinate
    and the virtual world''s *x* coordinate. So the `if` clause `m_realPos - m_skippedMoving
    < rightBorder` reads: *If the position of the elephant in "view coordinates",
    calculated by* `m_realPos – m_skippedMoving` *, is smaller than* `rightBorder`
    *, then move the elephant by calling* `moveBy()` *since he is allowed to walk
    till* `rightBorder` *.* `m_realPos - m_skippedMoving` *is the same as* `m_player->pos().x()
    + dx` *.*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_skippedMoving`元素是视图的*x*坐标和虚拟世界的*x*坐标之间的差值。所以`if`子句`m_realPos - m_skippedMoving
    < rightBorder`读取为：*如果大象在“视图坐标”中的位置，通过*m_realPos – m_skippedMoving*计算，小于*`rightBorder`*，那么通过调用*`moveBy()`*移动大象，因为允许它走到*`rightBorder`*。*
    `m_realPos - m_skippedMoving`与`m_player->pos().x() + dx`相同。'
- en: 'Lastly, let''s turn to the first clause: `m_realPos > m_fieldWidth - (width()
    - rightBorder)`. This returns `true` when the actual position is behind the `rightBorder`
    element but the fictional world is moved to its maximum left. Then we also have
    to move the elephant so that he can reach `m_maxX`. The expression `width() -
    rightBorder` calculates the width between `rightBorder` and the scene''s right
    border.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们转向第一个子句：`m_realPos > m_fieldWidth - (width() - rightBorder)`。当实际位置在`rightBorder`元素之后，但虚构世界移动到最左边时，这个表达式返回`true`。然后我们还需要移动大象，以便它能够到达`m_maxX`。表达式`width()
    - rightBorder`计算了`rightBorder`和场景右侧边界的宽度。
- en: The same considerations and calculations apply for moving to the left, the other
    branch.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向左移动，其他分支也适用相同的考虑和计算。
- en: So far, we have accomplished two things. First, with a `QTimer` object, we trigger
    a slot that moves an item; thus, we have animated the scene. Second, we have determined
    the elephant's position in the virtual world. You might wonder why we have done
    this. To be able to do parallax scrolling!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了两件事。首先，使用`QTimer`对象，我们触发了一个移动项目的槽，因此我们已经动画化了场景。其次，我们已经确定了大象在虚拟世界中的位置。你可能想知道我们为什么要这样做。为了能够实现视差滚动！
- en: Parallax scrolling
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视差滚动
- en: 'Parallax scrolling is a trick to add an illusion of depth to the background
    of the game. This illusion occurs when the background has different layers which
    move at different speeds. The nearest background must move faster than the ones
    farther away. In our case, we have these four backgrounds ordered from the most
    distant to the nearest:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 视差滚动是一种在游戏背景中添加深度错觉的技巧。这种错觉发生在背景有不同层，并且以不同速度移动时。最近的背景必须比远离的背景移动得更快。在我们的例子中，我们有这些四个背景，从最远到最近排序：
- en: '![Parallax scrolling](img/8874OS_06_17.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![视差滚动](img/8874OS_06_17.jpg)'
- en: The sky
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 天空
- en: '![Parallax scrolling](img/8874OS_06_18.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![视差滚动](img/8874OS_06_18.jpg)'
- en: The trees
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 树木
- en: '![Parallax scrolling](img/8874OS_06_07.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![视差滚动](img/8874OS_06_07.jpg)'
- en: The grass
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 草地
- en: '![Parallax scrolling](img/8874OS_06_08.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![视差滚动](img/8874OS_06_08.jpg)'
- en: The ground
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 地面
- en: Time for action – moving the background
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 移动背景
- en: 'Now the question is how to move them at different speeds. The solution is quite
    simple: the slowest one, the sky, is the smallest image. The fastest background,
    the ground and the grass, are the largest images. Now when we have a look at the
    end of the `movePlayer()` function''s slot we see this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如何以不同的速度移动它们。解决方案相当简单：最慢的，天空，是最小的图像。最快的背景，地面和草地，是最大的图像。现在当我们查看`movePlayer()`函数槽的末尾时，我们看到这个：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*What just happened?*'
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'What are we doing here? At the beginning, the sky''s left border is the same
    as the view''s left border, both at point (0, 0). At the end, when Benjamin has
    walked to the maximum right, the sky''s right border should be the same as the
    view''s right border. So the distance we have to move the sky over time is the
    sky''s width (`m_sky->boundingRect().width()`) minus the width of the view (`width()`).
    The shift of the sky depends on the position of the player: If he is far to the
    left, the sky isn''t shifted, if the player is far to the right, the sky is maximally
    shifted. We thus have to multiply the sky''s maximum shift value with a factor
    based on the current position of the player. The relation to the player''s position
    is the reason why this is handled in the `movePlayer()` function. The factor we
    have to calculate has to be between 0 and 1\. So we get the minimum shift (0 *
    shift, which equals 0) and the maximum shift (1 * shift, which equals shift).
    This factor we name `ff`. The calculation reads: *If we subtract the width of
    the view (* `width()` *) from the virtual field''s width* `m_fieldWidth` *, we
    have the area where the player isn''t moved by (* `m_player->moveBy()` *) because
    in that range only the background should move.*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？一开始，天空的左边界与视图的左边界相同，都在点（0，0）。到结束时，当本杰明走到最右边时，天空的右边界应该与视图的右边界相同。因此，我们需要随时间移动天空的距离是天空的宽度（`m_sky->boundingRect().width()`）减去视图的宽度（`width()`）。天空的移动取决于玩家的位置：如果玩家在左边很远，天空不移动；如果玩家在右边很远，天空最大程度地移动。因此，我们必须将天空的最大移动值乘以一个基于玩家当前位置的系数。与玩家位置的关系是为什么这个处理在`movePlayer()`函数中。我们必须计算的系数必须在0到1之间。所以我们得到最小移动（0
    * 移动，等于0）和最大移动（1 * 移动，等于移动）。我们将这个系数命名为`ff`。计算公式如下：*如果我们从虚拟字段宽度（`m_fieldWidth`）中减去视图宽度（`width()`），我们就得到了玩家没有移动的区域（`m_player->moveBy()`），因为在这个范围内只有背景应该移动。*
- en: How often the moving of the player was skipped is saved in `m_skippedMoving`.
    So by dividing `m_skippedMoving` through `m_fieldWidth – width()`, we get the
    needed factor. It is 0 when the player is to the far left and 1 if they are to
    the far right. Then we simply have to multiply `ff` with the maximum shift of
    the sky. To avoid the backgrounds from being moved too far, we ensure through
    `qMin()` that the factor is always lesser than, or equal to, 1.0.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家移动被跳过的频率保存在`m_skippedMoving`中。所以通过将`m_skippedMoving`除以`m_fieldWidth – width()`，我们得到所需的系数。当玩家在左边很远时，它是0；如果他们在右边很远，它是1。然后我们只需将`ff`与天空的最大移动值相乘。为了避免背景移动得太远，我们通过`qMin()`确保系数始终小于或等于1.0。
- en: The same calculation is used for the other background items. The calculation
    also explains why a smaller image is moving slower. It's because the overlap of
    the smaller image is less than that of the larger one. And since the backgrounds
    are moved in the same time period, the larger has to move faster.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的计算也用于其他背景项目。这个计算也解释了为什么较小的图像移动较慢。这是因为较小图像的重叠小于较大图像的重叠。由于背景在同一时间段内移动，较大的图像必须移动得更快。
- en: Have a go hero – adding new background layers
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 - 添加新的背景层
- en: Try to add additional background layers to the game following the preceding
    example. As an idea, you can add a barn behind the trees or let an airplane fly
    through the sky.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的示例尝试向游戏中添加额外的背景层。作为一个想法，你可以在树后面添加一个谷仓或者让一架飞机飞过天空。
- en: QObject and items
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`QObject`和项目'
- en: The `QGraphicsItem` item and all standard items introduced so far don't inherit
    `QObject` and thus can't have slots or emit signals; they also don't benefit from
    the `QObject` property system. But we can make them use `QObject`!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`项目以及迄今为止引入的所有标准项目都不继承`QObject`，因此不能有槽或发出信号；它们也不从`QObject`属性系统中受益。但我们可以让它们使用`QObject`！'
- en: Time for action – using properties, signals, and slots with items
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用属性、信号和槽与项目一起使用
- en: 'So let''s alter the `Player` class to use `QObject`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改`Player`类以使用`QObject`：
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All you have to do is to add `QObject` as a base class and add the `Q_OBJECT`
    macro. Now you can use signals and slots with items too. Be aware that `QObject`
    must be the first base class of an item.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的只是将`QObject`作为基类，并添加`Q_OBJECT`宏。现在你可以在项目上使用信号和槽了。请注意，`QObject`必须是一个项目的第一个基类。
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want an item that inherits from `QObject` and `QGraphicsItem`, you can
    directly inherit `QGraphicsObject`. Moreover, this class defines and emits some
    useful signals such as `xChanged()` when the *x* coordinate of the item has changed
    or `scaleChanged()` when the item is scaled.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个继承自 `QObject` 和 `QGraphicsItem` 的项目，你可以直接继承 `QGraphicsObject`。此外，这个类定义并发出一些有用的信号，例如当项目的
    *x* 坐标发生变化时发出 `xChanged()` 信号，或者当项目缩放时发出 `scaleChanged()` 信号。
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A word of warning: Only use `QObject` with items if you really need its capabilities.
    `QObject` adds a lot of overhead to the item, which will have a noticeable impact
    on performance when you have many items. So use it wisely and not only because
    you can.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：只有在你确实需要其功能时才使用 `QObject` 与项目结合。`QObject` 为项目添加了很多开销，当你有很多项目时，这将对性能产生明显的影响。所以请明智地使用它，而不仅仅是因为你可以。
- en: 'Let us go back to our player item. After adding `QObject`, we define a property
    called `m_jumpFactor` with a getter, a setter, and a change signal. We need that
    property to make Benjamin jump, as we will see later on. In the header file, we
    define the property as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的玩家项目。在添加 `QObject` 之后，我们定义了一个名为 `m_jumpFactor` 的属性，它具有获取器、设置器和更改信号。我们需要这个属性来让本杰明跳跃，正如我们稍后将会看到的。在头文件中，我们定义属性如下：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The getter function `jumpFactor()` simply returns the private member `m_jumpFactor`,
    which is used to store the actual position. The implementation of the setter looks
    like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 获取函数 `jumpFactor()` 简单地返回私有成员 `m_jumpFactor`，该成员用于存储实际位置。设置器的实现如下：
- en: '[PRE45]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It is important to check if `pos` would change the current value of `m_jumpFactor`.
    If this is not the case, exit the function because, otherwise, a change signal
    will be emitted even if nothing has changed. Otherwise, we set `m_jumpFactor`
    to `pos` and emit the signal that informs about the chance.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 需要检查 `pos` 是否会改变 `m_jumpFactor` 的当前值。如果不是这种情况，则退出函数，因为否则即使没有变化，也会发出一个更改信号。否则，我们将
    `m_jumpFactor` 设置为 `pos` 并发出一个通知变化的信号。
- en: Property animations
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性动画
- en: The new `jumpFactor` property we use immediately with a `QPropertyAnimation`
    element, a second way to animate items.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新的 `jumpFactor` 属性与 `QPropertyAnimation` 元素立即结合，这是对项目进行动画处理的第二种方式。
- en: Time for action – using animations to move items smoothly
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画平滑移动项目的时间
- en: 'In order to use it, we add a new private member called `m_animation` of type
    `QPropertyAnimation` and initialize it in the constructor of `Player`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们在 `Player` 构造函数中添加了一个新的私有成员 `m_animation`，其类型为 `QPropertyAnimation`
    并对其进行初始化：
- en: '[PRE46]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'For the instance of `QPropertyAnimation` created here, we define the item as
    parent; thus, the animation will get deleted when the scene deletes the item and
    we don''t have to worry about freeing the used memory. Then we define the target
    of the animation—our `Player` class—and the property that should be animated—`jumpFactor`,
    in this case. Then we define the start and the end value of that property, and
    in addition to that we also define a value in between by setting `setKeyValueAt()`.
    The first argument of type `qreal` defines time inside the animation, where 0
    is the beginning and 1 the end, and the second argument defines the value that
    the animation should have at this time. So your `jumpFactor` element will get
    animated from 0 to 1 and back to 0 in 800 milliseconds. This was defined by `setDuration()`.
    Finally, we define how the interpolation between the start and end value should
    be done and call `setEasingCurve()` with `QEasingCurve::OutInQuad` as an argument.
    Qt defines up to 41 different easing curves for linear, quadratic, cubic, quartic,
    quintic, sinusoidal, exponential, circular, elastic, back easing, and bounce functions.
    These are too many to describe here. Instead, have a look at the documentation.
    Simply search for `QEasingCurve::Type`. In our case, `QEasingCurve::OutInQuad`
    makes sure that the jump speed of Benjamin looks like an actual jump: fast in
    the beginning, slow at the top, and fast at the end again. We start this animation
    with the jump function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在这里创建的`QPropertyAnimation`实例，我们将物品定义为父级；因此，当场景删除物品时，动画将被删除，我们不必担心释放使用的内存。然后我们定义动画的目标——我们的`Player`类——以及应该被动画化的属性——在这种情况下是`jumpFactor`。然后我们定义该属性的起始和结束值，并且除此之外，我们还通过设置`setKeyValueAt()`定义一个中间值。`qreal`类型的第一个参数定义动画中的时间，其中0是开始，1是结束，第二个参数定义动画在此时间应具有的值。所以你的`jumpFactor`元素将在800毫秒内从0动画到1，再从1动画回0。这是由`setDuration()`定义的。最后，我们定义起始值和结束值之间的插值方式，并通过将`QEasingCurve::OutInQuad`作为参数调用`setEasingCurve()`。Qt定义了多达41种不同的缓动曲线，用于线性、二次、三次、四次、五次、正弦、指数、圆形、弹性、回弹和弹跳函数。这里描述太多。相反，请查看文档。只需搜索`QEasingCurve::Type`。在我们的情况下，`QEasingCurve::OutInQuad`确保本杰明的跳跃速度看起来像真正的跳跃：开始时快，顶部慢，然后再次变快。我们通过跳跃函数开始这个动画：
- en: '[PRE47]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We only start the animation by calling `start()` when the animation isn''t
    running. Therefore, we check the animation''s state to see if it is stopped. Other
    states could be `Paused` or `Running`. We want this jump action to be activated
    whenever the player presses the Space key on their keyboard. Therefore, we expand
    the switch statement inside the key press event handler by using this code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在动画未运行时才通过调用`start()`来启动动画。因此，我们检查动画的状态以确定它是否已停止。其他状态可能是`Paused`或`Running`。我们希望当玩家按下键盘上的空格键时，这个跳跃动作被激活。因此，我们通过以下代码扩展了按键事件处理程序内的switch语句：
- en: '[PRE48]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now the property gets animated but Benjamin will still not jump yet. Therefore,
    we connect the `jumpFactorChange()` signal to a slot of the scene that handles
    the jump:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在属性开始动画化了，但本杰明仍然不会跳起来。因此，我们将`jumpFactorChange()`信号连接到处理跳跃的场景槽中：
- en: '[PRE49]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Inside that function, we calculate the *y* coordinate of the player item to
    respect the ground level defined by `m_groundLevel`. This is done by subtracting
    the item's height from the ground level's value since the item's origin point
    is the top-left corner. Then we subtract the maximum jump height, defined by `m_jumpHeight`,
    which is multiplied by the actual jump factor. Since the factor is in range from
    0 to 1, the new *y* coordinate stays inside the allowed jump height. Then we alter
    the player item's *y* position by calling `setPos()`, leaving the *x* coordinate
    the same. Et voilà, Benjamin is jumping!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数内部，我们计算玩家物品的*Y*坐标，以尊重由`m_groundLevel`定义的地平面。这是通过从地平面的值中减去物品的高度来完成的，因为物品的原始点是左上角。然后我们减去由`m_jumpHeight`定义的最大跳跃高度，该高度乘以实际的跳跃因子。由于该因子在0到1的范围内，新的*Y*坐标保持在允许的跳跃高度内。然后我们通过调用`setPos()`来改变玩家物品的*Y*位置，同时保持*X*坐标不变。就这样，本杰明跳起来了！
- en: Have a go hero – letting the scene handle Benjamin's jump
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——让场景处理本杰明的跳跃
- en: Of course, we could have done the property animation inside the scene's class
    without the need to extend `Player` by `QObject`. But this should be an example
    of how to do it. So try to put the logic of making Benjamin jump to the scene's
    class. This is, however, more consistent as we already move Benjamin left and
    right there. Or, also consistent, do it the other way around; move Benjamin's
    movement to the left and right also to the `Player` class.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在场景类内部进行属性动画，而不需要通过`QObject`扩展`Player`。但这是一个如何做的示例。所以尝试将使本杰明跳跃的逻辑放入场景类中。然而，这样做更一致，因为我们已经在那里移动本杰明了。或者，也可以反过来，将本杰明的左右移动也放到`Player`类中。
- en: Time for action – keeping multiple animations in sync
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 保持多个动画同步
- en: 'If you have a look at how the coins (their class being called `Coin`) are created,
    you see similar structures. They inherit from `QObject` and `QGraphicsEllipseItem`
    and define two properties: opacity of type `qreal` and `rect` of type `QRect`.
    This is done only by the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看硬币（其类名为`Coin`）的创建方式，你会看到类似的结构。它们从`QObject`和`QGraphicsEllipseItem`继承，并定义了两个属性：类型为`qreal`的不透明度和类型为`QRect`的`rect`。这是通过以下代码完成的：
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'No function or slot was added because we simply used built-in functions of
    `QGraphicsItem` and "redeclared" them as properties. Then, these two properties
    are animated by two `QPropertyAnimation` objects. One fades the coin out, while
    the other scales the coin in. To ensure that both animations get started at the
    same time, we use `QParallelAnimationGroup` as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 没有添加任何函数或槽，因为我们只是使用了`QGraphicsItem`的内置函数并将它们“重新声明”为属性。然后，这两个属性通过两个`QPropertyAnimation`对象进行动画处理。一个使硬币淡出，而另一个使硬币放大。为了确保两个动画同时开始，我们使用以下方式`QParallelAnimationGroup`：
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*What just happened?*'
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: After setting up each property animation, we add them to the group animation
    by calling `addAnimation()` on the group while passing a pointer to the animation
    we would like to add. Then, when we start the group, `QParallelAnimationGroup`
    makes sure that all assigned animations start at the same time.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完每个属性动画后，我们通过在组上调用`addAnimation()`并将我们想要添加的动画的指针传递给组，将它们添加到组动画中。然后，当我们开始组动画时，`QParallelAnimationGroup`确保所有分配的动画同时开始。
- en: The animations are set up for when the coin explodes. You may want to have a
    look at the `explode()` function of Coin in the sources. A coin should explode
    when Benjamin touches the coin.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当硬币爆炸时，动画被设置好了。你可能想看看源代码中硬币的`explode()`函数。当本杰明触摸硬币时，硬币应该爆炸。
- en: Tip
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to play animations one after the other you can use `QSequentialAnimationGroup`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个接一个地播放动画，你可以使用`QSequentialAnimationGroup`。
- en: Item collision detection
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物件碰撞检测
- en: Whether the player item collides with a coin is checked by the scene's `checkColliding()`
    function, which is called after the player item has moved (`movePlayer()`) or
    after Benjamin jumped (`jumpPlayer()`).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 检查玩家物件是否与硬币发生碰撞是通过场景的`checkColliding()`函数完成的，该函数在玩家物件移动后（`movePlayer()`）或本杰明跳跃后（`jumpPlayer()`）被调用。
- en: Time for action – making the coins explode
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使硬币爆炸
- en: 'The implementation of `checkColliding()` looks like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkColliding()`的实现如下：'
- en: '[PRE52]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*What just happened?*'
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: First we call the scene's `QGraphicsScene::collidingItems()` function, which
    takes the item for which colliding items should be detected as a first argument.
    With the second, optional argument, you could define how the collision should
    be detected. The type of that argument is `Qt::ItemSelectionMode`, which was explained
    earlier. In our case, a list of all the items that collide with `m_player` will
    be returned. So we loop through that list and check whether the current item is
    a `Coin` object. This is done by trying to cast the pointer to `Coin.` If it is
    successful, we explode the coin by calling `explode()`. Calling the `explode()`
    function multiple times is no problem since it will not allow more than one explosion.
    This is important since `checkColliding()` will be called after each movement
    of the player. So the first time the player hits a coin, the coin will explode,
    but this takes time. During this explosion, the player will most likely be moved
    again and thus collides with the coin once more. In such a case, `explode()` may
    be called for a second, third, xth time.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用场景的 `QGraphicsScene::collidingItems()` 函数，该函数接受一个参数，即需要检测碰撞项的第一个参数。通过第二个可选参数，你可以定义如何检测碰撞。该参数的类型是
    `Qt::ItemSelectionMode`，这在前面已经解释过。在我们的例子中，将返回与 `m_player` 碰撞的所有项的列表。因此，我们遍历这个列表，检查当前项是否是
    `Coin` 对象。这是通过尝试将指针转换为 `Coin.` 来实现的。如果成功，我们将通过调用 `explode()` 来爆炸硬币。多次调用 `explode()`
    函数没有问题，因为它不会允许发生多次爆炸。这很重要，因为 `checkColliding()` 将在玩家的每次移动后被调用。所以，当玩家第一次碰到硬币时，硬币会爆炸，但这需要时间。在爆炸期间，玩家很可能会再次移动，因此会再次与硬币碰撞。在这种情况下，`explode()`
    可能会被第二次、第三次、第x次调用。
- en: 'The `collidingItems()` function will always return the background items as
    well since the player item is above all of them most of the time. To avoid the
    continuous check if they actually are coins, we use a trick. In the used `BackgroundItem`
    class for the background items, implement the `QGraphicsItem` item''s virtual
    `shape()` function as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`collidingItems()` 函数总是会返回背景项，因为玩家项通常位于所有这些项之上。为了避免不断检查它们是否实际上是硬币，我们使用了一个技巧。在用于背景项的
    `BackgroundItem` 类中，实现 `QGraphicsItem` 项的虚拟 `shape()` 函数如下：'
- en: '[PRE53]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since the collision detection is done with the item's shape, the background
    items can't collide with any other item since their shape is permanently empty.
    `QPainterPath` itself is a class holding information about graphical shapes. For
    more information—since we do not need anything special for our game—have a look
    at the documentation. The class is pretty straightforward.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于碰撞检测是通过项的形状来完成的，背景项不能与其他任何项发生碰撞，因为它们的形状始终是空的。`QPainterPath` 本身是一个包含图形形状信息的类。有关更多信息——由于我们不需要为我们的游戏做任何特殊处理——请查看文档。这个类相当直观。
- en: Had we done the jumping logic inside `Player`, we could have implemented the
    item collision detection from within the item itself. `QGraphicsItem` also offers
    a `collidingItems()` function that checks against colliding items with itself.
    So `scene->collidingItems(item)` is equivalent to `item->collidingItems()`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `Player` 中实现跳跃逻辑，我们可以在项内部实现项碰撞检测。`QGraphicsItem` 还提供了一个 `collidingItems()`
    函数，用于检查与自身碰撞的项。所以 `scene->collidingItems(item)` 等同于 `item->collidingItems()`。
- en: If you are only interested in whether a item collides with another item, you
    can call `collidesWithItem()` on the item passing the other item as an argument.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只对项是否与另一个项发生碰撞感兴趣，你可以在项上调用 `collidesWithItem()`，并将另一个项作为参数传递。
- en: Setting up the playing field
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏场地
- en: 'The last function we have to discuss is the scene''s `initPlayField()` function
    where all is set up. Here we initialize the sky, trees, ground, and player item.
    Since there is nothing special, we skip that and look directly at how the coins
    get initialized:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须讨论的最后一个函数是场景的 `initPlayField()` 函数，在这里所有设置都已完成。在这里，我们初始化天空、树木、地面和玩家项。由于没有特殊之处，我们跳过这部分，直接看看硬币是如何初始化的：
- en: '[PRE54]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In total, we are adding 25 coins. First we calculate the width between `m_minX`
    and `m_maxX`. That is the space where Benjamin can move. To make it a little bit
    smaller, we only take 94 percent of that width. Then we set up an invisible item
    with the size of the virtual world called `m_coins`. This item should be the parent
    to all coins. Then, in the `for` loop we create a coin and randomly set its *x*
    and *y* position, ensuring that Benjamin can reach them by calculating the modulo
    of the available width and of the maximal jump height. After all 25 coins are
    added, we place the parent item holding all coins on the scene. Since most coins
    are outside the actual view''s rectangle, we also need to move the coins while
    Benjamin is moving. Therefore, `m_coins` must behave like any other background.
    For this, we simply add the following code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 总共，我们添加了25枚硬币。首先，我们计算 `m_minX` 和 `m_maxX` 之间的宽度。这是本杰明可以移动的空间。为了使其稍微小一点，我们只取94%的宽度。然后，我们设置一个大小为虚拟世界的不可见项目，称为
    `m_coins`。这个项目应该是所有硬币的父项目。然后，在 `for` 循环中，我们创建一个硬币并随机设置其 *x* 和 *y* 位置，确保通过计算可用宽度和最大跳跃高度的模数，本杰明可以到达它们。添加完所有25枚硬币后，我们将持有所有硬币的父项目放置在场景中。由于大多数硬币都在实际视图的矩形之外，我们还需要在移动本杰明时移动硬币。因此，`m_coins`
    必须像任何其他背景一样行为。为此，我们只需添加以下代码：
- en: '[PRE55]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We add the preceding code to the `movePlayer()` function where we also move
    the sky by the same pattern.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前面的代码添加到 `movePlayer()` 函数中，我们也会以相同的模式移动天空。
- en: Have a go hero – extending the game
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来吧，英雄——扩展游戏
- en: That is it. This is our little game. Of course, there is much room to improve
    and extend it. For example, you can add some barricades Benjamin has to jump over.
    Then, you would have to check if the player item collides with such a barricade
    item when moving forward, and if so, refuse movement. You have learned all the
    necessary techniques you need for that task, so try to implement some additional
    features to deepen your knowledge.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。这是我们的小游戏。当然，还有很多改进和扩展的空间。例如，你可以添加一些本杰明必须跳过的障碍物。然后，你必须检查当玩家项目向前移动时，玩家项目是否与这样的障碍物项目发生碰撞，如果是，则拒绝移动。你已经学会了完成这个任务所需的所有必要技术，所以尝试实现一些额外的功能来加深你的知识。
- en: A third way of animation
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画的第三种方法
- en: Besides `QTimer` and `QPropertyAnimation`, there is a third way to animate the
    scene. The scene provides a slot called `advance()`. If you call that slot, the
    scene will forward that call to all items it holds by calling `advance()` on each
    one. The scene does that twice. First, all item `advance()` functions are called
    with `0` as an argument. This means that the items are about to advance. Then
    in the second round, all items are called passing 1 to the item's `advance()`
    function. In that phase each item should advance, whatever that means; maybe moving,
    maybe a color change, and so on. The scene's slot advance is typically called
    by a `QTimeLine` element; with this, you can define how many times during a specific
    period of time the timeline should be triggered.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `QTimer` 和 `QPropertyAnimation`，还有第三种方法来动画化场景。场景提供了一个名为 `advance()` 的槽。如果你调用这个槽，场景会将这个调用转发给它持有的所有项目，通过在每个项目上调用
    `advance()` 来实现。场景会这样做两次。首先，所有项目的 `advance()` 函数都会以 `0` 作为参数被调用。这意味着项目即将前进。然后在第二轮中，所有项目都会被调用，将
    `1` 传递给项目的 `advance()` 函数。在这个阶段，每个项目都应该前进，无论这意味着什么；可能是移动，可能是颜色变化，等等。场景的 `advance`
    槽通常由 `QTimeLine` 元素调用；通过这个，你可以定义在特定时间段内时间线应该触发多少次。
- en: '[PRE56]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This timeline will emit the signal `frameChanged()` every 5 seconds for 10 times.
    All you have to do is to connect that signal to the scene's `advance()` slot and
    the scene will advance 10 times during 50 seconds. However, since all items receive
    two calls for each advance, this may not be the best animation solution for scenes
    with a lot of items where only a few should advance.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时间线将每5秒发出一次 `frameChanged()` 信号，共10次。你所要做的就是将这个信号连接到场景的 `advance()` 槽，这样场景将在50秒内前进10次。然而，由于每个项目都会为每次前进接收两次调用，这可能不是场景中只有少数项目应该前进的动画解决方案的最佳选择。
- en: Widgets inside Graphics View
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形视图内的小部件
- en: 'In order to show a neat feature of Graphics View, have a look at the following
    code snippet, which adds a widget to the scene:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示图形视图的一个整洁功能，请看以下代码片段，它向场景添加了一个小部件：
- en: '[PRE57]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First we create a `QSpinBox` and a `QGraphicsProxyWidget` element, which act
    as containers for widgets and indirectly inherit `QGraphicsItem.` Then we add
    the spin box to the the proxy widget by calling `addWidget()`. The ownership of
    the spin box isn''t transferred, but when `QGraphicsProxyWidget` gets deleted,
    it calls `delete` on all assigned widgets. We thus do not have to worry about
    that ourselves. The widget you add should be parentless and must not be shown
    elsewhere. After setting the widget to the proxy, you can treat the proxy widget
    like any other item. Next, we add it to the scene and apply a transformation for
    demonstration. As a result we get this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `QSpinBox` 和一个 `QGraphicsProxyWidget` 元素，它们作为小部件的容器并间接继承 `QGraphicsItem`。然后，我们通过调用
    `addWidget()` 将旋转框添加到代理小部件中。旋转框的所有权并未转移，但当 `QGraphicsProxyWidget` 被删除时，它会调用所有分配的小部件的
    `delete` 方法。因此，我们不必担心这一点。你添加的小部件应该是无父级的，并且不得在其他地方显示。在将小部件设置到代理后，你可以像对待任何其他项目一样对待代理小部件。接下来，我们将它添加到场景中，并应用一个变换以进行演示。结果如下：
- en: '![Widgets inside Graphics View](img/8874OS_06_19.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![Graphics View 中的小部件](img/8874OS_06_19.jpg)'
- en: A rotated and scaled spin box on a scene
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中旋转并缩放的旋转框
- en: Since it is a regular item, you can even animate it, for example, with a property
    animation. Nevertheless, be aware that, originally, Graphics View wasn't designed
    for holding widgets. So when you add a lot of widgets to the scene, you will quickly
    notice performance issues, but in most situations it should be fast enough.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个常规项目，你甚至可以为其添加动画，例如，使用属性动画。然而，请注意，最初，Graphics View 并未设计为容纳小部件。因此，当你向场景中添加大量小部件时，你将很快注意到性能问题，但在大多数情况下，它应该足够快。
- en: 'If you want to arrange some widgets in a layout, you can use `QGraphicsAnchorLayout`,
    `QGraphicsGridLayout`, or `QGraphicsLinearLayout`. Create all widgets, create
    a layout of your choice, add the widgets to that layout, and set the layout to
    a `QGraphicsWidget` element, which is the base class for all widgets and is easily
    spoken the `QWidget` equivalent for Graphics View by calling `setLayout()`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在布局中排列一些小部件，可以使用 `QGraphicsAnchorLayout`、`QGraphicsGridLayout` 或 `QGraphicsLinearLayout`。创建所有小部件，创建你选择的布局，将小部件添加到该布局中，并将布局设置到一个
    `QGraphicsWidget` 元素上，这是所有小部件的基类，并且可以通过调用 `setLayout()` 轻易地被认为是 Graphics View
    的 `QWidget` 等价物：
- en: '[PRE58]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The scene''s `addWidget()` function is a convenience function and behaves in
    the first usage for `QLineEdit`, as shown in the following code snippet:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的 `addWidget()` 函数是一个便利函数，在第一次使用 `QLineEdit` 时表现如下，如下代码片段所示：
- en: '[PRE59]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The item with the layout will look like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 带有布局的项目将看起来像这样：
- en: '![Widgets inside Graphics View](img/8874OS_06_20.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![Graphics View 中的小部件](img/8874OS_06_20.jpg)'
- en: Optimization
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Let us now take a look at some of the optimizations we can perform to speed
    up the scene.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们可以执行的一些优化，以加快场景的运行速度。
- en: A binary space partition tree
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉空间划分树
- en: The scene constantly keeps record of the position of the item in its internal
    binary space partition tree. Thus, on every move of an item, the scene has to
    update the tree, an operation that can become quite time-and memory-consuming.
    This is especially true of scenes with a large number of animated items. On the
    other hand, the tree enables you to find an item (for example, with `items()`
    or `itemAt()`) incredibly fast even if you have thousands of items.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 场景持续记录其内部二叉空间划分树中项目的位置。因此，每当移动一个项目时，场景都必须更新树，这个操作可能会变得非常耗时和消耗内存。这对于具有大量动画项目的场景尤其如此。另一方面，树允许你以极快的速度找到项目（例如，使用
    `items()` 或 `itemAt()`），即使你有成千上万的项。
- en: So when you do not need any positional information about the items—this also
    includes collision detection—you can disable the index function by calling `setItemIndexMethod(QGraphicsScene::NoIndex)`.
    Be aware, however, that a call to `items()` or `itemAt()` results in a loop through
    all items in order to do the collision detection, which can cause performance
    problems for scenes with many items. If you cannot relinquish the tree in total,
    you still can adjust the depth of the tree with `setBspTreeDepth()`, taking the
    depth as an argument. By default, the scene will guess a reasonable value after
    it takes several parameters, such as the size and the number of items, into account.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你不需要任何关于物品的位置信息时——这也包括碰撞检测——你可以通过调用 `setItemIndexMethod(QGraphicsScene::NoIndex)`
    来禁用索引函数。然而，请注意，调用 `items()` 或 `itemAt()` 会导致遍历所有物品以进行碰撞检测，这可能会对具有许多物品的场景造成性能问题。如果你不能完全放弃树，你仍然可以通过
    `setBspTreeDepth()` 调整树的深度，将深度作为参数。默认情况下，场景将在考虑了几个参数（如大小和物品数量）后猜测一个合理的值。
- en: Caching the item's paint function
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存物品的涂漆功能
- en: If you have items with a time-consuming paint function, you can change the item's
    cache mode. By default, no rendering is cached. With `setCacheMode()`, you can
    set the mode to either `ItemCoordinateCache` or to `DeviceCoordinateCache`. The
    former renders the the item in a cache of a given `QSize` element. The size of
    that cache can be controlled with the second argument of `setCacheMode()`. So
    the quality depends on how much space you assign. The cache is then used for every
    subsequent paint call. The cache is even used for applying transformations. If
    the quality deteriorates too much, just adjust the resolution by calling `setCacheMode()`
    again, but with a larger `QSize` element. `DeviceCoordinateCache`, on the other
    hand, does not cache the item on an item base but rather on a device level. This
    is therefore optimal for items that do not get transformed all the time, because
    every new transformation will cause a new caching. Moving the item, however, does
    not end in a new cache. If you use this cache mode, you do not have to define
    a resolution with the second argument. The caching is always performed at maximum
    quality.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些具有耗时涂漆功能的物品，你可以更改物品的缓存模式。默认情况下，没有渲染被缓存。使用 `setCacheMode()`，你可以将模式设置为 `ItemCoordinateCache`
    或 `DeviceCoordinateCache`。前者在给定 `QSize` 元素的缓存中渲染物品。该缓存的大小可以通过 `setCacheMode()`
    的第二个参数来控制。因此，质量取决于你分配的空间大小。缓存随后被用于每个后续的涂漆调用。缓存甚至用于应用变换。如果质量下降太多，只需通过再次调用 `setCacheMode()`
    并使用更大的 `QSize` 元素来调整分辨率即可。另一方面，`DeviceCoordinateCache` 不在物品级别上缓存物品，而是在设备级别上缓存。因此，对于不经常变换的物品来说，这是最优的，因为每次新的变换都会导致新的缓存。然而，移动物品并不会导致新的缓存。如果你使用这种缓存模式，你不需要使用第二个参数定义分辨率。缓存始终以最大质量执行。
- en: Optimizing the view
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化视图
- en: Since we are talking about the item's paint function, let's touch on something
    related. At the beginning, when we discussed the item's appearance and made a
    black rectangle item, I told you to return the painter as you get. If you have
    followed this advice, you can call `setOptimizationFlag(DontSavePainterState,
    true)` on the view. By default, the view ensures that the painter state is saved
    before calling the item's paint function and that the state gets restored afterward.
    This will end up saving and restoring the painter state say 50 times if you have
    a scene with 50 items. If you prevent automatic saving and restoring, keep in
    mind that now the standard items will alter the painter state. So if you use both
    standard and custom items, either stay with the default behavior or set `DontSavePainterState`,
    but then set up the pen and brush with a default value in each item's paint function.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论物品的涂漆功能，让我们谈谈相关的内容。一开始，当我们讨论物品的外观并创建了一个黑色矩形物品时，我告诉你要像得到画家一样返回。如果你遵循了这个建议，你可以在视图中调用
    `setOptimizationFlag(DontSavePainterState, true)`。默认情况下，视图确保在调用物品的涂漆功能之前保存画家状态，并在之后恢复状态。如果你有一个包含50个物品的场景，这将导致画家状态保存和恢复大约50次。如果你防止自动保存和恢复，请记住，现在标准物品将改变画家状态。所以如果你同时使用标准和自定义物品，要么保持默认行为，要么设置
    `DontSavePainterState`，然后在每个物品的涂漆函数中使用默认值设置笔和刷。
- en: Another flag that can be used with `setOptimizationFlag()` is `DontAdjustForAntialiasing`.
    By default, the view adjusts the painting area of each item by 2 pixels in all
    directions. This is useful because when one paints antialiased, one easily draws
    outside the bounding rectangle. Enable that optimization if you do not paint antialiased
    or if you are sure your painting will stay inside the bounding rectangle. If you
    enable this flag and spot painting artifacts on the view, you haven't respected
    the item's bounding rectangle!
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 可以与`setOptimizationFlag()`一起使用的另一个标志是`DontAdjustForAntialiasing`。默认情况下，视图会通过所有方向调整每个项目的绘制区域2个像素。这很有用，因为当绘制抗锯齿时，很容易画出边界矩形之外。如果你不绘制抗锯齿或者确定你的绘制将始终在边界矩形内，请启用此优化。如果你启用了此标志并在视图中发现绘画伪影，那么你没有尊重项目的边界矩形！
- en: As a further optimization, you can define how the view should update its viewport
    when the scene changes. You can set the different modes with `setViewportUpdateMode()`.
    By default (`QGraphicsView::MinimalViewportUpdate`), the view tries to determinate
    only those areas which need an update and repaints only these. However, sometimes
    it is more time-consuming to find all the areas that need a redraw than to just
    paint the entire viewport. This applies if you have many small updates. Then,
    `QGraphicsView::FullViewportUpdate` is the better choice since it simply repaints
    the whole viewport. A kind of combination of the last two modes is `QGraphicsView::BoundingRectViewportUpdate`.
    In this mode, Qt detects all areas that need a redraw and then it redraws a rectangle
    of the viewport that covers all areas affected by the change. If the optimal update
    mode changes over time, you can tell Qt to determine the best mode by using `QGraphicsView::SmartViewportUpdate`.
    The view then tries to find the best update mode.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的优化，你可以定义视图在场景变化时应如何更新其视口。你可以使用`setViewportUpdateMode()`设置不同的模式。默认情况下（`QGraphicsView::MinimalViewportUpdate`），视图试图确定需要更新的区域，并且只重新绘制这些区域。然而，有时找到所有需要重新绘制的区域比简单地绘制整个视口更耗时。如果你有很多小的更新，那么`QGraphicsView::FullViewportUpdate`是更好的选择，因为它简单地重新绘制整个视口。最后两种模式的组合是`QGraphicsView::BoundingRectViewportUpdate`。在此模式下，Qt检测所有需要重新绘制的区域，然后重新绘制覆盖所有受更改影响的区域的视口矩形。如果最佳更新模式随时间变化，你可以使用`QGraphicsView::SmartViewportUpdate`来告诉Qt确定最佳模式。然后，视图会尝试找到最佳的更新模式。
- en: As a last optimization, you can take advantage of OpenGL. Instead of using the
    default viewport based on `QWidget`, advise Graphics View to use an OpenGL widget.
    This way, you can use all the power that comes with OpenGL.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的优化，你可以利用OpenGL。而不是使用基于`QWidget`的默认视口，建议图形视图使用OpenGL小部件。这样，你可以使用OpenGL带来的所有功能。
- en: '[PRE60]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Unfortunately, you have to do a little more than just putting in this line,
    but that goes beyond the topic and scope of this chapter. You can, however, find
    more information about OpenGL and Graphics View in Qt's documentation example
    under "Boxes" as well as in Rødal's Qt Quarterly article–issue 26–which can be
    found online at [http://doc.qt.digia.com/qq/qq26-openglcanvas.html](http://doc.qt.digia.com/qq/qq26-openglcanvas.html).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不仅要输入这一行，还需要做更多的工作，但这超出了本章的主题和范围。然而，你可以在Qt的文档示例中找到更多关于OpenGL和图形视图的信息，在“盒子”部分以及Rødal的Qt季度文章中——第26期——可以在网上找到，网址为[http://doc.qt.digia.com/qq/qq26-openglcanvas.html](http://doc.qt.digia.com/qq/qq26-openglcanvas.html)。
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A general note on optimization: Unfortunately I can''t say that you have to
    do this or that to optimize Graphics View as it highly depends on your system
    and view/scene. What I can tell you, however, is how to proceed. Once you have
    finished your game based on Graphics View, measure the performance of your game
    using a profiler. Make an optimization you think may pay or simply guess and then
    profile your game again. If the results are better, keep the change; otherwise,
    reject it. This sounds simple and is the only way optimization can be done. There
    are no hidden tricks or deeper knowledge. With time, however, your forecasting
    will get better.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 关于优化的通用说明：不幸的是，我无法说你必须这样做或那样做来优化图形视图，因为这高度依赖于你的系统和视图/场景。然而，我可以告诉你如何进行。一旦你完成了基于图形视图的游戏，使用分析器测量你游戏的性能。进行你认为可能带来收益的优化，或者简单地猜测，然后再次分析你的游戏。如果结果更好，保留更改；否则，拒绝它。这听起来很简单，这是进行优化的唯一方法。然而，随着时间的推移，你的预测将变得更好。
- en: Pop quiz – mastering Graphics View
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验——掌握图形视图
- en: 'After studying this chapter, you should be able to answer these questions as
    they are important when it comes to designing the components of a game based on
    Graphics View:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章后，你应该能够回答这些问题，因为当涉及到基于图形视图设计游戏组件时，这些问题非常重要：
- en: Q1\. What standard items does Qt offer?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. Qt 提供哪些标准项目？
- en: Q2\. How is the coordinate system of an item related to the coordinate system
    of the scene? Next, how is the coordinate system of the scene related to the coordinate
    system of the view?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 项目的坐标系与场景的坐标系有何关联？接下来，场景的坐标系与视图的坐标系有何关联？
- en: Q3\. How can one extend items to use properties as well as signals and slots?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 如何扩展项目以使用属性以及信号和槽？
- en: Q4\. How can one create realistic movements with the help of animations?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 如何借助动画创建逼真的运动？
- en: Q5\. How can Graphics View's performance be improved?
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Q5. 如何提高图形视图的性能？
- en: Summary
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the first part of this chapter, you have learned how the Graphics View architecture
    works. First, we had a look at the items. There you learned how to create your
    own items by using `QPainter` and which kinds of standard item Qt has to offer.
    Later on, we also discussed how to transform these items and what the point of
    origin for that transformation has to do with it. Next we went through the coordinate
    system of the items, the scene, and the view. We also saw how these three parts
    work together, for example. how to put items on a scene. Lastly, we learned how
    to scale and move the scene inside the view. At the same time, you read about
    advanced topics, such as taking the zoom level into account when painting an item.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你学习了图形视图架构的工作原理。首先，我们查看了一些项目。在那里，你学习了如何使用 `QPainter` 创建自己的项目，以及 Qt
    提供哪些标准项目。随后，我们也讨论了如何转换这些项目，以及转换的原点与项目有何关联。接下来，我们了解了项目的坐标系、场景和视图的坐标系。我们还看到了这三个部分是如何协同工作的，例如如何将项目放置在场景中。最后，我们学习了如何在视图中缩放和移动场景。同时，你也阅读了关于高级主题的内容，例如在绘制项目时考虑缩放级别。
- en: In the second part you, deepened your knowledge about items, about the scene,
    and about the view. While developing the game, you became familiar with different
    approaches on how to animate items, and you were taught how to detect collisions.
    As an advanced topic, you were introduced to parallax scrolling.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，你深化了对项目、场景和视图的知识。在开发游戏的过程中，你熟悉了不同的动画项目方法，并学习了如何检测碰撞。作为一个高级主题，你被引入了视差滚动的概念。
- en: After having completed the entire chapter, you should now know almost everything
    about Graphics View. You are able to create complete custom items, you can alter
    or extend standard items, and with the information about the level of detail you
    even have the power to alter an item's appearance, depending on its zoom level.
    You can transform items and the scene, and you can animate items and, thus, the
    entire scene.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成整个章节后，你现在应该几乎了解关于图形视图的所有内容。你能够创建完整的自定义项目，你可以修改或扩展标准项目，并且根据细节级别信息，你甚至有能力根据缩放级别改变项目的外观。你可以转换项目和场景，并且可以动画化项目和整个场景。
- en: Furthermore, as you have seen while developing the game, your skills are good
    enough to develop a jump-and-run game with parallax scrolling as it is used in
    highly professional games. To keep your game fluid and highly responsive, finally
    we saw some tricks on how to get the most out of Graphics View.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你在开发游戏时所看到的，你的技能足够开发一个具有视差滚动的跳跃和跑酷游戏，这在高度专业的游戏中是常见的。为了保持游戏流畅和高度响应，我们最后看到了一些如何充分利用图形视图的技巧。
- en: In order to build a bridge to the world of widgets, you also learned how to
    incorporate items based on `QWidget` into Graphics View. With that knowledge,
    you can create modern, widget-based user interfaces.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搭建通往小部件世界的桥梁，你也学习了如何将基于 `QWidget` 的项目整合到图形视图中。有了这些知识，你可以创建现代的基于小部件的用户界面。
