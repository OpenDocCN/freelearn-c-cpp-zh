- en: Chapter 10. Inventory System and Pickup Items
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 背包系统和拾取物品
- en: We want our player to be able to pick up items from the game world. In this
    chapter, we will code and design a backpack for our player to store items. We
    will display what the player is carrying in the pack when the user presses the
    *I* key.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家能够从游戏世界中拾取物品。在本章中，我们将为玩家编写和设计一个背包来存储物品。当用户按下*I*键时，我们将显示背包中玩家所携带的物品。
- en: As a data representation, we can use the `TMap<FString, int>` items covered
    in the previous chapter to store our items. When the player picks up an item,
    we add it to the map. If the item is already in the map, we just increase its
    value by the quantity of the new items picked up.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据表示，我们可以使用上一章中介绍的`TMap<FString, int>`物品映射来存储我们的物品。当玩家拾取一个物品时，我们将其添加到映射中。如果该物品已经在映射中，我们只需将其数量增加新拾取的物品的数量。
- en: Declaring the backpack
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明背包
- en: 'We can represent the player''s backpack as a simple `TMap<FString, int>` item.
    To allow your player to gather items from the world, open the `Avatar.h` file
    and add the following `TMap` declaration:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将玩家的背包表示为一个简单的`TMap<FString, int>`物品映射。为了允许玩家从世界中收集物品，打开`Avatar.h`文件并添加以下`TMap`声明：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Forward declaration
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向声明
- en: Before `AAvatar` class, notice that we have a `class APickupItem` forward declaration.
    Forward declarations are needed in a code file when a class is mentioned (such
    as the `APickupItem::Pickup( APickupItem *item );` function prototype), but there
    is no code in the file actually using an object of that type inside the file.
    Since the `Avatar.h` header file does not contain executable code that uses an
    object of the type `APickupItem`, a forward declaration is what we need.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AAvatar`类之前，请注意我们有一个`class APickupItem`前向声明。当在代码文件中提及一个类时（例如，`APickupItem::Pickup(APickupItem
    *item);`函数原型），需要前向声明，但文件中实际上没有使用该类型的对象。由于`Avatar.h`头文件不包含使用`APickupItem`类型对象的可执行代码，因此我们需要前向声明。
- en: The absence of a forward declaration will give a compiler error, since the compiler
    won't have heard of `class APickupItem` before compiling the code in `class AAvatar`.
    The compiler error will come at the declaration of the `APickupItem::Pickup( APickupItem
    *item );` function prototype declaration.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有前向声明，将会出现编译错误，因为编译器在编译`class AAvatar`中的代码之前没有听说过`class APickupItem`。编译错误将在`APickupItem::Pickup(APickupItem
    *item);`函数原型声明时出现。
- en: 'We declared two `TMap` objects inside the `AAvatar` class. This is how the
    objects will look, as shown in the following table:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AAvatar`类内部声明了两个`TMap`对象。这些对象的外观如下表所示：
- en: '| `FString` (name) | `int` (quantity) | `UTexture2D*` (im) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `FString`（名称） | `int`（数量） | `UTexture2D*`（图像） |'
- en: '| --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GoldenEgg | 2 | ![Forward declaration](img/00142.jpeg) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 金蛋 | 2 | ![前向声明](img/00142.jpeg) |'
- en: '| MetalDonut | 1 | ![Forward declaration](img/00143.jpeg) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 金属甜甜圈 | 1 | ![前向声明](img/00143.jpeg) |'
- en: '| Cow | 2 | ![Forward declaration](img/00144.jpeg) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 牛 | 2 | ![前向声明](img/00144.jpeg) |'
- en: In the `TMap` backpack, we store the `FString` variable of the item that the
    player is holding. In the `Icons` map, we store a single reference to the image
    of the item the player is holding.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TMap`背包中，我们存储玩家持有的物品的`FString`变量。在`Icons`映射中，我们存储玩家持有的物品的图像的单个引用。
- en: 'At render time, we can use the two maps working together to look up both the
    quantity of an item that the player has (in his `Backpack` mapping) and the texture
    asset reference of that item (in the `Icons` map). The following screenshot shows
    how the rendering of the HUD will look:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时，我们可以使用两个映射协同工作来查找玩家拥有的物品数量（在他的`Backpack`映射中）以及该物品的纹理资产引用（在`Icons`映射中）。以下截图显示了HUD渲染的外观：
- en: '![Forward declaration](img/00145.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![前向声明](img/00145.jpeg)'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we can also use an array of `struct` with an `FString` variable and
    `UTexture2D*` in it instead of using two maps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以使用一个包含`FString`变量和`UTexture2D*`的`struct`数组来代替使用两个映射。
- en: 'For example, we can keep `TArray<Item> Backpack;` with a `struct` variable,
    as shown in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以保持`TArray<Item> Backpack;`与一个`struct`变量，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, as we pick up items, they will be added to the linear array. However,
    counting the number of each item we have in the backpack will require constant
    reevaluation by iterating through the array of items each time we want to see
    the count. For example, to see how many hairbrushes you have, you will need to
    make a pass through the whole array. This is not as efficient as using a map.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们拾取物品时，它们将被添加到线性数组中。然而，要计算背包中每种物品的数量，每次查看计数时都需要通过迭代数组中的物品进行重新评估。例如，要查看你有多少把梳子，你需要遍历整个数组。这不如使用映射高效。
- en: Importing assets
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入资源
- en: You might have noticed the **Cow** asset in the preceding screenshot, which
    is not a part of the standard set of assets that UE4 provides in a new project.
    In order to use the **Cow** asset, you need to import the cow from the **Content
    Examples** project. There is a standard importing procedure that UE4 uses.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了前一个屏幕截图中的 **Cow** 资源，它不是 UE4 在新项目中提供的标准资源集的一部分。为了使用 **Cow** 资源，你需要从
    **内容示例** 项目中导入牛。UE4 使用一个标准的导入过程。
- en: 'In the following screenshot, I have outlined the procedure for importing the
    **Cow** asset. Other assets will be imported from other projects in UE4 using
    the same method. Perform the following steps to import the **Cow** asset:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我概述了导入 **Cow** 资料的步骤。其他资源将以相同的方法从 UE4 的其他项目中导入。按照以下步骤导入 **Cow** 资料：
- en: Download and open UE4's **Content Examples** project:![Importing assets](img/00146.jpeg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并打开 UE4 的 **内容示例** 项目：![导入资源](img/00146.jpeg)
- en: After you have downloaded **Content Examples**, open it and click on **Create
    Project**:![Importing assets](img/00147.jpeg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完 **内容示例** 后，打开它并点击 **创建项目**：![导入资源](img/00147.jpeg)
- en: Next, name the folder in which you will put your `ContentExamples` and click
    on **Create**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，命名你将放置 `ContentExamples` 的文件夹，然后点击 **创建**。
- en: Open your `ContentExamples` project from the library. Browse the assets available
    in the project until you find one that you like. Searching for `SM_` will help
    since all static meshes usually begin with `SM_` by convention.![Importing assets](img/00148.jpeg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从库中打开你的 `ContentExamples` 项目。浏览项目中的资源，直到找到一个你喜欢的。由于所有静态网格通常以 `SM_` 开头，所以搜索 `SM_`
    会很有帮助。![导入资源](img/00148.jpeg)
- en: Lists of static meshes, all beginning with SM_
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以 SM_ 开头的静态网格列表
- en: When you find an asset that you like, import it into your project by right-clicking
    on the asset and then clicking on **Migrate...**:![Importing assets](img/00149.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你找到一个你喜欢的资源时，通过右键单击资源然后点击 **迁移...** 将其导入到你的项目中：![导入资源](img/00149.jpeg)
- en: Click on **OK** in the **Asset Report** dialog:![Importing assets](img/00150.jpeg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **资源报告** 对话框中点击 **确定**：![导入资源](img/00150.jpeg)
- en: Select the **Content** folder from your project that you want to add the **SM_Door**
    file to. For me, I want to add it to `Y:/Unreal Projects/GoldenEgg/Content`, as
    shown in the following screenshot:![Importing assets](img/00151.jpeg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的项目中选择你想要添加 **SM_Door** 文件的 **内容** 文件夹。对我来说，我想将其添加到 `Y:/Unreal Projects/GoldenEgg/Content`，如下截图所示：![导入资源](img/00151.jpeg)
- en: If the import was completed successfully, you will see a message as follows:![Importing
    assets](img/00152.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果导入成功，你将看到如下消息：![导入资源](img/00152.jpeg)
- en: Once you import your asset, you will see it show up in your asset browser inside
    your project:![Importing assets](img/00153.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你的资源后，你将看到它在你的项目资源浏览器中显示：![导入资源](img/00153.jpeg)
- en: You can then use the asset inside your project normally.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目中正常使用该资源。
- en: Attaching an action mapping to a key
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将动作映射附加到键上
- en: 'We need to attach a key to activate the display of the player''s inventory.
    Inside the UE4 editor, add an **Action Mappings +** called `Inventory` and assign
    it to the keyboard key *I*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一个键附加到激活玩家库存显示的功能。在 UE4 编辑器中，添加一个名为 `Inventory` 的 **动作映射 +** 并将其分配给键盘键
    *I*：
- en: '![Attaching an action mapping to a key](img/00154.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![将动作映射附加到键上](img/00154.jpeg)'
- en: 'In the `Avatar.h` file, add a member function to be run when the player''s
    inventory needs to be displayed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Avatar.h` 文件中，添加一个成员函数，当玩家的库存需要显示时运行：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `Avatar.cpp` file, implement the `ToggleInventory()` function, as shown
    in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Avatar.cpp` 文件中，实现 `ToggleInventory()` 函数，如下代码所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, connect the `"Inventory"` action to `AAvatar::ToggleInventory()` in `SetupPlayerInputComponent()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，在 `SetupPlayerInputComponent()` 中将 `"Inventory"` 动作连接到 `AAvatar::ToggleInventory()`:'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Base class PickupItem
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基类 PickupItem
- en: We need to define how a pickup item looks in code. Each pickup item will derive
    from a common base class. Let's construct the base class for a `PickupItem` class
    now.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在代码中定义拾取物品的外观。每个拾取物品都将从一个公共基类派生。现在让我们为 `PickupItem` 类构造一个基类。
- en: 'The `PickupItem` base class should inherit from the `AActor` class. Similar
    to how we created multiple NPC blueprints from the base NPC class, we can create
    multiple `PickupItem` blueprints from a single `PickupItem` base class, as shown
    in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickupItem` 基类应该继承自 `AActor` 类。类似于我们从基础 NPC 类创建多个 NPC 蓝图的方式，我们可以从一个单一的 `PickupItem`
    基类创建多个 `PickupItem` 蓝图，如下面的截图所示：'
- en: '![Base class PickupItem](img/00155.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![基类 PickupItem](img/00155.jpeg)'
- en: Once you have created the `PickupItem` class, open its code in Visual Studio.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `PickupItem` 类，就在 Visual Studio 中打开其代码。
- en: 'The `APickupItem` class will need quite a few members, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`APickupItem` 类将需要相当多的成员，如下所示：'
- en: An `FString` variable for the name of the item being picked up
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示拾取物品名称的 `FString` 变量
- en: An `int32` variable for the quantity of the item being picked up
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示拾取物品数量的 `int32` 变量
- en: A `USphereComponent` variable for the sphere that you will collide with for
    the item to be picked up
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与拾取物品发生碰撞的球体的 `USphereComponent` 变量
- en: A `UStaticMeshComponent` variable to hold the actual `Mesh`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于保存实际网格的 `UStaticMeshComponent` 变量
- en: A `UTexture2D` variable for the icon that represents the item
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示物品图标的 `UTexture2D` 变量
- en: A pointer for the HUD (which we will initialize later)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 HUD（我们将在稍后初始化）
- en: 'This is how the code in `PickupItem.h` looks:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `PickupItem.h` 中的代码看起来：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The point of all these `UPROPERTY()` declarations is to make `APickupItem`
    completely configurable by blueprints. For example, the items in the **Pickup**
    category will be displayed as follows in the blueprints editor:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 `UPROPERTY()` 声明的目的是使 `APickupItem` 可以通过蓝图完全配置。例如，**拾取** 类别的物品在蓝图编辑器中将显示如下：
- en: '![Base class PickupItem](img/00156.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![基类 PickupItem](img/00156.jpeg)'
- en: 'In the `PickupItem.cpp` file, we complete the constructor for the `APickupItem`
    class, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PickupItem.cpp` 文件中，我们完成了 `APickupItem` 类的构造函数，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first two lines, we perform an initialization of `Name` and `Quantity`
    to values that should stand out to the game designer as being uninitialized. I
    used block capitals so that the designer can clearly see that the variable has
    never been initialized before.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行中，我们对 `Name` 和 `Quantity` 进行了初始化，这些值应该对游戏设计师来说显得未初始化。我使用了大写字母块，以便设计师可以清楚地看到变量之前从未被初始化过。
- en: We then initialize the `ProxSphere` and `Mesh` components using `PCIP.CreateDefaultSubobject`.
    The freshly initialized objects might have some of their default values initialized,
    but `Mesh` will start out empty. You will have to load the actual mesh later,
    inside blueprints.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `PCIP.CreateDefaultSubobject` 初始化 `ProxSphere` 和 `Mesh` 组件。新初始化的对象可能有一些默认值被初始化，但
    `Mesh` 将从空开始。你必须在蓝图内部稍后加载实际的网格。
- en: For the mesh, we set it to simulate realistic physics so that pickup items will
    bounce and roll around if they are dropped or moved. Pay special attention to
    the line `ProxSphere->AttachTo( Mesh )`. This line tells you to make sure the
    pickup item's `ProxSphere` component is attached to the `Mesh` root component.
    This means that when the mesh moves in the level, `ProxSphere` follows. If you
    forget this step (or if you did it the other way around), then `ProxSphere` will
    not follow the mesh when it bounces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网格，我们将其设置为模拟真实物理，以便拾取物品在掉落或移动时可以弹跳和滚动。特别注意 `ProxSphere->AttachTo( Mesh )`
    这一行。这一行告诉你要确保拾取物品的 `ProxSphere` 组件附加到 `Mesh` 根组件上。这意味着当网格在级别中移动时，`ProxSphere`
    会跟随。如果你忘记了这个步骤（或者如果你是反过来的），那么当 `ProxSphere` 弹跳时，它将不会跟随网格。
- en: The root component
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根组件
- en: 'In the preceding code, we assigned `RootComponent` of `APickupItem` to the
    `Mesh` object. The `RootComponent` member is a part of the `AActor` base class,
    so every `AActor` and its derivatives has a root component. The root component
    is basically meant to be the core of the object, and also defines how you collide
    with the object. The `RootComponent` object is defined in the `Actor.h` file,
    as shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `APickupItem` 的 `RootComponent` 赋值给了 `Mesh` 对象。`RootComponent` 成员是
    `AActor` 基类的一部分，因此每个 `AActor` 及其派生类都有一个根组件。根组件基本上是对象的核心，并定义了如何与对象碰撞。`RootComponent`
    对象在 `Actor.h` 文件中定义，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So the UE4 creators intended `RootComponent` to always be a reference to the
    collision primitive. Sometimes the collision primitive can be capsule shaped,
    other times it can be spherical or even box shaped, or it can be arbitrarily shaped,
    as in our case, with the mesh. It's rare that a character should have a box-shaped
    root component, however, because the corners of the box can get caught on walls.
    Round shapes are usually preferred. The `RootComponent` property shows up in the
    blueprints, where you can see and manipulate it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，UE4的创建者打算让`RootComponent`始终是碰撞原语的引用。有时碰撞原语可以是胶囊形状，有时可以是球形，甚至可以是箱形，或者可以是任意形状，就像我们的情况一样，使用网格。然而，一个角色应该有一个箱形的根组件是很少见的，因为箱子的角可能会卡在墙上。圆形形状通常更受欢迎。`RootComponent`属性出现在蓝图中，在那里你可以看到并操作它。
- en: '![The root component](img/00157.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![根组件](img/00157.jpeg)'
- en: You can edit the ProxSphere root component from its blueprints once you create
    a blueprint based on the PickupItem class
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基于PickupItem类创建蓝图，你就可以从其蓝图编辑ProxSphere根组件
- en: 'Finally, the `Prox_Implementation` function gets implemented, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式实现`Prox_Implementation`函数：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A couple of tips here that are pretty important: first, we have to access a
    couple of *globals* to get the objects we need. There are three main objects we''ll
    be accessing through these functions that manipulate the HUD: the controller (`APlayerController`),
    the HUD (`AMyHUD`), and the player himself (`AAvatar`). There is only one of each
    of these three types of objects in the game instance. UE4 has made finding them
    easy.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些相当重要的提示：首先，我们必须访问一些*全局变量*来获取我们需要的对象。我们将通过这些函数访问三个主要对象，这些函数用于操作HUD：控制器（`APlayerController`）、HUD（`AMyHUD`）和玩家本人（`AAvatar`）。在游戏实例中，每种类型的对象只有一个。UE4已经使查找它们变得容易。
- en: Getting the avatar
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取头像
- en: 'The `player` class object can be found at any time from any place in the code
    by simply calling the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过简单地调用以下代码在任何代码位置找到`player`类对象：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We then pass him the item by calling the `AAvatar::Pickup()` function defined
    earlier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用之前定义的`AAvatar::Pickup()`函数将物品传递给他。
- en: Because the `PlayerPawn` object is really an `AAvatar` instance, we cast the
    result to the `AAvatar` class, using the `Cast<AAvatar>` command. The `UGameplayStatics`
    family of functions are accessible anywhere in your code—they are global functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`PlayerPawn`对象实际上是一个`AAvatar`实例，我们使用`Cast<AAvatar>`命令将其结果转换为`AAvatar`类。`UGameplayStatics`函数族可以在代码的任何地方访问——它们是全局函数。
- en: Getting the player controller
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取玩家控制器
- en: 'Retrieving the player controller is from a *superglobal* as well:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从*超级全局变量*中检索玩家控制器：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `GetWorld()` function is actually defined in the `UObject` base class. Since
    all UE4 objects derive from `UObject`, any object in the game actually has access
    to the `world` object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWorld()`函数实际上是在`UObject`基类中定义的。由于所有UE4对象都从`UObject`派生，游戏中的任何对象实际上都可以访问`world`对象。'
- en: Getting the HUD
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取HUD
- en: 'Although this organization might seem strange at first, the HUD is actually
    attached to the player''s controller. You can retrieve the HUD as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个组织一开始可能看起来很奇怪，但实际上HUD是附着在玩家控制器上的。你可以按照以下方式检索HUD：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We cast the HUD object since we previously set the HUD to being an `AMyHUD`
    instance in blueprints. Since we will be using the HUD often, we can actually
    store a permanent pointer to the HUD inside our `APickupItem` class. We will discuss
    this point later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前在蓝图中将HUD设置为`AMyHUD`实例，我们可以将HUD对象转换为类型。由于我们经常使用HUD，我们实际上可以在我们的`APickupItem`类中存储一个指向HUD的永久指针。我们将在稍后讨论这一点。
- en: 'Next, we implement `AAvatar::Pickup`, which adds an object of the type `APickupItem`
    to Avatar''s backpack:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`AAvatar::Pickup`，它将`APickupItem`类型的对象添加到头像的背包中：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we check whether the pickup item that the player just
    got is already in his pack. If it is, we increase its quantity. If it is not in
    his pack, we add it to both his pack and the `Icons` mapping.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检查玩家刚刚获得的拾取物品是否已经在他的背包中。如果是，我们增加其数量。如果没有在他的背包中，我们将其添加到他的背包和`Icons`映射中。
- en: 'To add the pickup items to the pack, use the following line of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要将拾取物品添加到背包中，请使用以下代码行：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `APickupItem::Prox_Implementation` is the way this member function will
    get called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`APickupItem::Prox_Implementation`是这个成员函数将被调用的方式。'
- en: Now, we need to display the contents of our backpack in the HUD when the player
    presses *I*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家按下*I*键时，我们需要在HUD中显示背包的内容。
- en: Drawing the player inventory
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制玩家库存
- en: An inventory screen in a game such as *Diablo* features a pop-up window, with
    the icons of the items you've picked up in the past arranged in a grid. We can
    achieve this type of behavior in UE4.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在像*Diablo*这样的游戏中，库存屏幕具有一个弹出窗口，过去捡到的物品图标以网格形式排列。我们可以在UE4中实现这种行为。
- en: 'There are a number of approaches to drawing a UI in UE4\. The most basic way
    is to simply use the `HUD::DrawTexture()` calls. Another way is to use Slate.
    Another way still is to use the newest UE4 UI functionality: **Unreal Motion Graphics**
    (**UMG**) Designer.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中绘制UI有几种方法。最基本的方法是简单地使用`HUD::DrawTexture()`调用。另一种方法是使用Slate。还有另一种方法是使用最新的UE4
    UI功能：**Unreal Motion Graphics**（**UMG**）设计器。
- en: Slate uses a declarative syntax to lay out UI elements in C++. Slate is best
    suited for menus and the like. UMG is new in UE 4.5 and uses a heavily blueprint-based
    workflow. Since our focus here is on exercises that use C++ code, we will stick
    to a `HUD::DrawTexture()` implementation. This means that we will have to manage
    all the data that deals with the inventory in our code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Slate使用声明性语法在C++中布局UI元素。Slate最适合菜单等。UMG是UE 4.5中引入的，它使用基于蓝图的工作流程。由于我们这里的重点是使用C++代码的练习，我们将坚持使用`HUD::DrawTexture()`实现。这意味着我们将在代码中管理所有与库存相关的数据。
- en: Using HUD::DrawTexture()
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`HUD::DrawTexture()`
- en: We will achieve this in two steps. The first step is to push the contents of
    our inventory to the HUD when the user presses the *I* key. The second step is
    to actually render the icons into the HUD in a grid-like fashion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步实现这一点。第一步是在用户按下*I*键时将我们的库存内容推送到HUD。第二步是以网格状方式将图标实际渲染到HUD上。
- en: To keep all the information about how a widget can be rendered, we declare a
    simple structure to keep the information concerning what icon it uses, its current
    position, and current size.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留有关如何渲染小部件的所有信息，我们声明一个简单的结构来保存有关它使用的图标、当前位置和当前大小的信息。
- en: 'This is how the `Icon` and `Widget` structures look:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Icon`和`Widget`结构体的样子：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can add these structure declarations to the top of `MyHUD.h`, or you can
    add them to a separate file and include that file everywhere those structures
    are used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些结构声明添加到`MyHUD.h`的顶部，或者将它们添加到单独的文件中，并在使用这些结构的地方包含该文件。
- en: Notice the four member functions on the `Widget` structure to get to the `left()`,
    `right()`, `top()`, and `bottom()` functions of the widget. We will use these
    later to determine whether a click point is inside the box.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Widget`结构体上的四个成员函数，通过这些函数可以访问小部件的`left()`、`right()`、`top()`和`bottom()`函数。我们稍后会使用这些函数来确定点击点是否在框内。
- en: 'Next, we declare the function that will render the widgets out on the screen
    in the `AMyHUD` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`AMyHUD`类中声明一个函数，该函数将在屏幕上渲染小部件：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A call to the `DrawWidgets()` function should be added to the `DrawHUD()` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应将`DrawWidgets()`函数的调用添加到`DrawHUD()`函数中：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will fill the `ToggleInventory()` function. This is the function that
    runs when the user presses *I*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将填充`ToggleInventory()`函数。这是当用户按下*I*键时运行的函数：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the preceding code to compile, we need to add a function to `AMyHUD`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码能够编译，我们需要在`AMyHUD`中添加一个函数：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We keep using the `Boolean` variable in `inventoryShowing` to tell us whether
    the inventory is currently displayed or not. When the inventory is shown, we also
    show the mouse so that the user knows what he''s clicking on. Also, when the inventory
    is displayed, free motion of the player is disabled. The easiest way to disable
    a player''s free motion is by simply returning from the movement functions before
    actually moving. The following code is an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用`Boolean`变量`inventoryShowing`来告诉我们库存是否当前显示。当库存显示时，我们也会显示鼠标，以便用户知道他在点击什么。此外，当库存显示时，玩家的自由移动被禁用。禁用玩家的自由移动的最简单方法是在实际移动之前从移动函数中返回。以下代码是一个示例：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exercise
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Check out each of the movement functions with the `if( inventoryShowing ) {
    return; }` short circuit return.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if( inventoryShowing ) { return; }`短路返回来检查每个移动函数。
- en: Detecting inventory item clicks
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测库存物品点击
- en: We can detect whether someone is clicking on one of our inventory items by doing
    a simple hit point-in-box hit. A point-in-box test is done by checking the point
    of the click against the contents of the box.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进行简单的点在框内碰撞检测来检测是否有人点击了我们的库存物品。点在框内测试是通过检查点击点与框内容的对比来完成的。
- en: 'Add the following member function to `struct Widget`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下成员函数添加到`struct Widget`中：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The point-in-box test is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 点在框内测试如下：
- en: '![Detecting inventory item clicks](img/00158.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![检测库存项目点击](img/00158.jpeg)'
- en: 'So, it is a hit if `p.X` is all of:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `p.X` 是以下所有情况，则视为命中：
- en: Right of `left() (p.X > left())`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧为 `left() (p.X > left())`
- en: Left of `right() (p.X < right())`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧为 `right() (p.X < right())`
- en: Below the `top() (p.Y > top())`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下 `top() (p.Y > top())`
- en: Above the `bottom() (p.Y < bottom())`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述 `bottom() (p.Y < bottom())`
- en: Remember that in UE4 (and UI rendering in general) the *y* axis is inverted.
    In other words, y goes down in UE4\. This means that `top()` is less than `bottom()`
    since the origin (the `(0, 0)` point) is at the top-left corner of the screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 UE4（以及一般 UI 渲染）中，*y* 轴是反转的。换句话说，在 UE4 中 y 是向下的。这意味着 `top()` 小于 `bottom()`，因为原点（`(0,
    0)` 点）位于屏幕的左上角。
- en: Dragging elements
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖动元素
- en: 'We can drag elements easily. The first step to enable dragging is to respond
    to the left mouse button click. First, we''ll write the function to execute when
    the left mouse button is clicked. In the `Avatar.h` file, add the following prototype
    to the class declaration:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地拖动元素。启用拖动的第一步是响应左鼠标按钮点击。首先，我们将编写当左鼠标按钮被点击时执行的函数。在 `Avatar.h` 文件中，向类声明中添加以下原型：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `Avatar.cpp` file, we can attach a function to execute on a mouse click
    and pass the click request to the HUD, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Avatar.cpp` 文件中，我们可以附加一个在鼠标点击时执行的函数，并将点击请求传递给 HUD，如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then in `AAvatar::SetupPlayerInputComponent`, we have to attach our responder:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `AAvatar::SetupPlayerInputComponent` 中，我们必须附加我们的响应者：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows how you can attach a render:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何附加渲染：
- en: '![Dragging elements](img/00159.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![拖动元素](img/00159.jpeg)'
- en: 'Add a member to the `AMyHUD` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `AMyHUD` 类添加一个成员：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, in `AMyHUD::MouseClicked()`, we start searching for the `Widget` hit:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `AMyHUD::MouseClicked()` 中，我们开始搜索被击中的 `Widget`：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `AMyHUD::MouseClicked` function, we loop through all the widgets that
    are on the screen and check for a hit with the current mouse position. You can
    get the current mouse position from the controller at any time by simply looking
    up `PController->GetMousePosition()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AMyHUD::MouseClicked` 函数中，我们遍历屏幕上的所有小部件，并检查与当前鼠标位置的碰撞。您可以通过简单地查找 `PController->GetMousePosition()`
    在任何时间从控制器中获取当前鼠标位置。
- en: Each widget is checked against the current mouse position, and the widget that
    got hit by the mouse click will be moved once a mouse is dragged. Once we have
    determined which widget got hit, we can stop checking, so we have a `return` value
    from the `MouseClicked()` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小部件都会与当前鼠标位置进行比对，一旦鼠标拖动，被鼠标点击的小部件将会移动。一旦我们确定了哪个小部件被点击，我们就可以停止检查，因此我们从 `MouseClicked()`
    函数中有一个 `return` 值。
- en: 'Hitting widget is not enough, though. We need to drag the widget that got hit
    when the mouse moves. For this, we need to implement a `MouseMoved()` function
    in `AMyHUD`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然击中小部件是不够的。我们需要在鼠标移动时拖动被击中的小部件。为此，我们需要在 `AMyHUD` 中实现一个 `MouseMoved()` 函数：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Don't forget to include a declaration in the `MyHUD.h` file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `MyHUD.h` 文件中包含声明。
- en: The drag function looks at the difference in the mouse position between the
    last frame and this frame and moves the selected widget by that amount. A `static`
    variable (global with local scope) is used to remember the `lastMouse` position
    between the calls for the `MouseMoved()` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动函数会查看鼠标位置在上一帧和当前帧之间的差异，并通过该量移动选定的小部件。一个 `static` 变量（具有局部作用域的全局变量）用于在 `MouseMoved()`
    函数调用之间记住 `lastMouse` 位置。
- en: 'How can we link the mouse''s motion to running the `MouseMoved()` function
    in `AMyHUD`? If you remember, we have already connected the mouse motion in the
    `Avatar` class. The two functions that we used were `AAvatar::Pitch()` (the y
    axis) and `AAvatar::Yaw()` (the x axis). Extending these functions will enable
    you to pass mouse inputs to the HUD. I will show you the `Yaw` function now, and
    you can extrapolate how `Pitch` will work from there:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将鼠标的运动与 `AMyHUD` 中的 `MouseMoved()` 函数运行联系起来？如果您记得，我们已经在 `Avatar` 类中连接了鼠标运动。我们使用的两个函数是
    `AAvatar::Pitch()`（y 轴）和 `AAvatar::Yaw()`（x 轴）。扩展这些函数将使您能够将鼠标输入传递到 HUD。我现在将向您展示
    `Yaw` 函数，然后您可以从那里推断出 `Pitch` 将如何工作：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `AAvatar::Yaw()` function first checks whether the inventory is showing
    or not. If it is showing, inputs are routed straight to the HUD, without affecting
    `Avatar`. If the HUD is not showing, inputs just go to `Avatar`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`AAvatar::Yaw()` 函数首先检查库存是否显示。如果显示，输入将直接路由到 HUD，而不会影响 `Avatar`。如果 HUD 不显示，输入仅发送到
    `Avatar`。'
- en: Exercises
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Complete the `AAvatar::Pitch()` function (y axis) to route inputs to the HUD
    instead of to `Avatar`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`AAvatar::Pitch()`函数（y轴）以将输入路由到HUD而不是`Avatar`。
- en: Make the NPC characters from [Chapter 8](part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d
    "Chapter 8. Actors and Pawns"), *Actors and Pawns*, give the player an item (such
    as `GoldenEgg`) when he goes near them.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[第8章](part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d "第8章。演员与棋子")中的NPC角色“演员与棋子”，在玩家靠近时给予玩家一个物品（例如`GoldenEgg`）。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to set up multiple pickup items for the player
    to see displayed in the level and also pick up. In the next chapter, we will introduce
    *Monsters* and the player will be able to defend himself against the monsters
    using magic spells.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何为玩家设置多个可拾取物品，以便在关卡中显示并拾取。在下一章中，我们将介绍“怪物”，玩家将能够使用魔法咒语来防御怪物。
