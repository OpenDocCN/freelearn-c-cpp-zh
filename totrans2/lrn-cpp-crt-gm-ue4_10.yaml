- en: Chapter 10. Inventory System and Pickup Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want our player to be able to pick up items from the game world. In this
    chapter, we will code and design a backpack for our player to store items. We
    will display what the player is carrying in the pack when the user presses the
    *I* key.
  prefs: []
  type: TYPE_NORMAL
- en: As a data representation, we can use the `TMap<FString, int>` items covered
    in the previous chapter to store our items. When the player picks up an item,
    we add it to the map. If the item is already in the map, we just increase its
    value by the quantity of the new items picked up.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the backpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can represent the player''s backpack as a simple `TMap<FString, int>` item.
    To allow your player to gather items from the world, open the `Avatar.h` file
    and add the following `TMap` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Forward declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before `AAvatar` class, notice that we have a `class APickupItem` forward declaration.
    Forward declarations are needed in a code file when a class is mentioned (such
    as the `APickupItem::Pickup( APickupItem *item );` function prototype), but there
    is no code in the file actually using an object of that type inside the file.
    Since the `Avatar.h` header file does not contain executable code that uses an
    object of the type `APickupItem`, a forward declaration is what we need.
  prefs: []
  type: TYPE_NORMAL
- en: The absence of a forward declaration will give a compiler error, since the compiler
    won't have heard of `class APickupItem` before compiling the code in `class AAvatar`.
    The compiler error will come at the declaration of the `APickupItem::Pickup( APickupItem
    *item );` function prototype declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declared two `TMap` objects inside the `AAvatar` class. This is how the
    objects will look, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `FString` (name) | `int` (quantity) | `UTexture2D*` (im) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GoldenEgg | 2 | ![Forward declaration](img/00142.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| MetalDonut | 1 | ![Forward declaration](img/00143.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| Cow | 2 | ![Forward declaration](img/00144.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: In the `TMap` backpack, we store the `FString` variable of the item that the
    player is holding. In the `Icons` map, we store a single reference to the image
    of the item the player is holding.
  prefs: []
  type: TYPE_NORMAL
- en: 'At render time, we can use the two maps working together to look up both the
    quantity of an item that the player has (in his `Backpack` mapping) and the texture
    asset reference of that item (in the `Icons` map). The following screenshot shows
    how the rendering of the HUD will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Forward declaration](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we can also use an array of `struct` with an `FString` variable and
    `UTexture2D*` in it instead of using two maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can keep `TArray<Item> Backpack;` with a `struct` variable,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, as we pick up items, they will be added to the linear array. However,
    counting the number of each item we have in the backpack will require constant
    reevaluation by iterating through the array of items each time we want to see
    the count. For example, to see how many hairbrushes you have, you will need to
    make a pass through the whole array. This is not as efficient as using a map.
  prefs: []
  type: TYPE_NORMAL
- en: Importing assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed the **Cow** asset in the preceding screenshot, which
    is not a part of the standard set of assets that UE4 provides in a new project.
    In order to use the **Cow** asset, you need to import the cow from the **Content
    Examples** project. There is a standard importing procedure that UE4 uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, I have outlined the procedure for importing the
    **Cow** asset. Other assets will be imported from other projects in UE4 using
    the same method. Perform the following steps to import the **Cow** asset:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and open UE4's **Content Examples** project:![Importing assets](img/00146.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have downloaded **Content Examples**, open it and click on **Create
    Project**:![Importing assets](img/00147.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, name the folder in which you will put your `ContentExamples` and click
    on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your `ContentExamples` project from the library. Browse the assets available
    in the project until you find one that you like. Searching for `SM_` will help
    since all static meshes usually begin with `SM_` by convention.![Importing assets](img/00148.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lists of static meshes, all beginning with SM_
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you find an asset that you like, import it into your project by right-clicking
    on the asset and then clicking on **Migrate...**:![Importing assets](img/00149.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** in the **Asset Report** dialog:![Importing assets](img/00150.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Content** folder from your project that you want to add the **SM_Door**
    file to. For me, I want to add it to `Y:/Unreal Projects/GoldenEgg/Content`, as
    shown in the following screenshot:![Importing assets](img/00151.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the import was completed successfully, you will see a message as follows:![Importing
    assets](img/00152.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you import your asset, you will see it show up in your asset browser inside
    your project:![Importing assets](img/00153.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then use the asset inside your project normally.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching an action mapping to a key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to attach a key to activate the display of the player''s inventory.
    Inside the UE4 editor, add an **Action Mappings +** called `Inventory` and assign
    it to the keyboard key *I*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching an action mapping to a key](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Avatar.h` file, add a member function to be run when the player''s
    inventory needs to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Avatar.cpp` file, implement the `ToggleInventory()` function, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, connect the `"Inventory"` action to `AAvatar::ToggleInventory()` in `SetupPlayerInputComponent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Base class PickupItem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to define how a pickup item looks in code. Each pickup item will derive
    from a common base class. Let's construct the base class for a `PickupItem` class
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PickupItem` base class should inherit from the `AActor` class. Similar
    to how we created multiple NPC blueprints from the base NPC class, we can create
    multiple `PickupItem` blueprints from a single `PickupItem` base class, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Base class PickupItem](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have created the `PickupItem` class, open its code in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `APickupItem` class will need quite a few members, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An `FString` variable for the name of the item being picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `int32` variable for the quantity of the item being picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `USphereComponent` variable for the sphere that you will collide with for
    the item to be picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UStaticMeshComponent` variable to hold the actual `Mesh`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UTexture2D` variable for the icon that represents the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer for the HUD (which we will initialize later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how the code in `PickupItem.h` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The point of all these `UPROPERTY()` declarations is to make `APickupItem`
    completely configurable by blueprints. For example, the items in the **Pickup**
    category will be displayed as follows in the blueprints editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Base class PickupItem](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `PickupItem.cpp` file, we complete the constructor for the `APickupItem`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first two lines, we perform an initialization of `Name` and `Quantity`
    to values that should stand out to the game designer as being uninitialized. I
    used block capitals so that the designer can clearly see that the variable has
    never been initialized before.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialize the `ProxSphere` and `Mesh` components using `PCIP.CreateDefaultSubobject`.
    The freshly initialized objects might have some of their default values initialized,
    but `Mesh` will start out empty. You will have to load the actual mesh later,
    inside blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: For the mesh, we set it to simulate realistic physics so that pickup items will
    bounce and roll around if they are dropped or moved. Pay special attention to
    the line `ProxSphere->AttachTo( Mesh )`. This line tells you to make sure the
    pickup item's `ProxSphere` component is attached to the `Mesh` root component.
    This means that when the mesh moves in the level, `ProxSphere` follows. If you
    forget this step (or if you did it the other way around), then `ProxSphere` will
    not follow the mesh when it bounces.
  prefs: []
  type: TYPE_NORMAL
- en: The root component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding code, we assigned `RootComponent` of `APickupItem` to the
    `Mesh` object. The `RootComponent` member is a part of the `AActor` base class,
    so every `AActor` and its derivatives has a root component. The root component
    is basically meant to be the core of the object, and also defines how you collide
    with the object. The `RootComponent` object is defined in the `Actor.h` file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So the UE4 creators intended `RootComponent` to always be a reference to the
    collision primitive. Sometimes the collision primitive can be capsule shaped,
    other times it can be spherical or even box shaped, or it can be arbitrarily shaped,
    as in our case, with the mesh. It's rare that a character should have a box-shaped
    root component, however, because the corners of the box can get caught on walls.
    Round shapes are usually preferred. The `RootComponent` property shows up in the
    blueprints, where you can see and manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: '![The root component](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can edit the ProxSphere root component from its blueprints once you create
    a blueprint based on the PickupItem class
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `Prox_Implementation` function gets implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of tips here that are pretty important: first, we have to access a
    couple of *globals* to get the objects we need. There are three main objects we''ll
    be accessing through these functions that manipulate the HUD: the controller (`APlayerController`),
    the HUD (`AMyHUD`), and the player himself (`AAvatar`). There is only one of each
    of these three types of objects in the game instance. UE4 has made finding them
    easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the avatar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `player` class object can be found at any time from any place in the code
    by simply calling the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We then pass him the item by calling the `AAvatar::Pickup()` function defined
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `PlayerPawn` object is really an `AAvatar` instance, we cast the
    result to the `AAvatar` class, using the `Cast<AAvatar>` command. The `UGameplayStatics`
    family of functions are accessible anywhere in your code—they are global functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the player controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Retrieving the player controller is from a *superglobal* as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `GetWorld()` function is actually defined in the `UObject` base class. Since
    all UE4 objects derive from `UObject`, any object in the game actually has access
    to the `world` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the HUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although this organization might seem strange at first, the HUD is actually
    attached to the player''s controller. You can retrieve the HUD as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We cast the HUD object since we previously set the HUD to being an `AMyHUD`
    instance in blueprints. Since we will be using the HUD often, we can actually
    store a permanent pointer to the HUD inside our `APickupItem` class. We will discuss
    this point later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement `AAvatar::Pickup`, which adds an object of the type `APickupItem`
    to Avatar''s backpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we check whether the pickup item that the player just
    got is already in his pack. If it is, we increase its quantity. If it is not in
    his pack, we add it to both his pack and the `Icons` mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the pickup items to the pack, use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `APickupItem::Prox_Implementation` is the way this member function will
    get called.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to display the contents of our backpack in the HUD when the player
    presses *I*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the player inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An inventory screen in a game such as *Diablo* features a pop-up window, with
    the icons of the items you've picked up in the past arranged in a grid. We can
    achieve this type of behavior in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of approaches to drawing a UI in UE4\. The most basic way
    is to simply use the `HUD::DrawTexture()` calls. Another way is to use Slate.
    Another way still is to use the newest UE4 UI functionality: **Unreal Motion Graphics**
    (**UMG**) Designer.'
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses a declarative syntax to lay out UI elements in C++. Slate is best
    suited for menus and the like. UMG is new in UE 4.5 and uses a heavily blueprint-based
    workflow. Since our focus here is on exercises that use C++ code, we will stick
    to a `HUD::DrawTexture()` implementation. This means that we will have to manage
    all the data that deals with the inventory in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using HUD::DrawTexture()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will achieve this in two steps. The first step is to push the contents of
    our inventory to the HUD when the user presses the *I* key. The second step is
    to actually render the icons into the HUD in a grid-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: To keep all the information about how a widget can be rendered, we declare a
    simple structure to keep the information concerning what icon it uses, its current
    position, and current size.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `Icon` and `Widget` structures look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can add these structure declarations to the top of `MyHUD.h`, or you can
    add them to a separate file and include that file everywhere those structures
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the four member functions on the `Widget` structure to get to the `left()`,
    `right()`, `top()`, and `bottom()` functions of the widget. We will use these
    later to determine whether a click point is inside the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the function that will render the widgets out on the screen
    in the `AMyHUD` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to the `DrawWidgets()` function should be added to the `DrawHUD()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will fill the `ToggleInventory()` function. This is the function that
    runs when the user presses *I*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding code to compile, we need to add a function to `AMyHUD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We keep using the `Boolean` variable in `inventoryShowing` to tell us whether
    the inventory is currently displayed or not. When the inventory is shown, we also
    show the mouse so that the user knows what he''s clicking on. Also, when the inventory
    is displayed, free motion of the player is disabled. The easiest way to disable
    a player''s free motion is by simply returning from the movement functions before
    actually moving. The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out each of the movement functions with the `if( inventoryShowing ) {
    return; }` short circuit return.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting inventory item clicks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can detect whether someone is clicking on one of our inventory items by doing
    a simple hit point-in-box hit. A point-in-box test is done by checking the point
    of the click against the contents of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member function to `struct Widget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The point-in-box test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting inventory item clicks](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, it is a hit if `p.X` is all of:'
  prefs: []
  type: TYPE_NORMAL
- en: Right of `left() (p.X > left())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left of `right() (p.X < right())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the `top() (p.Y > top())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above the `bottom() (p.Y < bottom())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that in UE4 (and UI rendering in general) the *y* axis is inverted.
    In other words, y goes down in UE4\. This means that `top()` is less than `bottom()`
    since the origin (the `(0, 0)` point) is at the top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Dragging elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can drag elements easily. The first step to enable dragging is to respond
    to the left mouse button click. First, we''ll write the function to execute when
    the left mouse button is clicked. In the `Avatar.h` file, add the following prototype
    to the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Avatar.cpp` file, we can attach a function to execute on a mouse click
    and pass the click request to the HUD, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in `AAvatar::SetupPlayerInputComponent`, we have to attach our responder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how you can attach a render:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dragging elements](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a member to the `AMyHUD` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `AMyHUD::MouseClicked()`, we start searching for the `Widget` hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `AMyHUD::MouseClicked` function, we loop through all the widgets that
    are on the screen and check for a hit with the current mouse position. You can
    get the current mouse position from the controller at any time by simply looking
    up `PController->GetMousePosition()`.
  prefs: []
  type: TYPE_NORMAL
- en: Each widget is checked against the current mouse position, and the widget that
    got hit by the mouse click will be moved once a mouse is dragged. Once we have
    determined which widget got hit, we can stop checking, so we have a `return` value
    from the `MouseClicked()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hitting widget is not enough, though. We need to drag the widget that got hit
    when the mouse moves. For this, we need to implement a `MouseMoved()` function
    in `AMyHUD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to include a declaration in the `MyHUD.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: The drag function looks at the difference in the mouse position between the
    last frame and this frame and moves the selected widget by that amount. A `static`
    variable (global with local scope) is used to remember the `lastMouse` position
    between the calls for the `MouseMoved()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we link the mouse''s motion to running the `MouseMoved()` function
    in `AMyHUD`? If you remember, we have already connected the mouse motion in the
    `Avatar` class. The two functions that we used were `AAvatar::Pitch()` (the y
    axis) and `AAvatar::Yaw()` (the x axis). Extending these functions will enable
    you to pass mouse inputs to the HUD. I will show you the `Yaw` function now, and
    you can extrapolate how `Pitch` will work from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `AAvatar::Yaw()` function first checks whether the inventory is showing
    or not. If it is showing, inputs are routed straight to the HUD, without affecting
    `Avatar`. If the HUD is not showing, inputs just go to `Avatar`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the `AAvatar::Pitch()` function (y axis) to route inputs to the HUD
    instead of to `Avatar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the NPC characters from [Chapter 8](part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d
    "Chapter 8. Actors and Pawns"), *Actors and Pawns*, give the player an item (such
    as `GoldenEgg`) when he goes near them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to set up multiple pickup items for the player
    to see displayed in the level and also pick up. In the next chapter, we will introduce
    *Monsters* and the player will be able to defend himself against the monsters
    using magic spells.
  prefs: []
  type: TYPE_NORMAL
