<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Adding Animation"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Adding Animation</h1></div></div></div><p>In this chapter, we will learn the techniques of animating 2D and 3D objects. We will introduce Cinder's features in this field, such as timeline <code class="literal">and math</code> functions.</p><p>The recipes in this chapter will cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Animating with the timeline</li><li class="listitem" style="list-style-type: disc">Creating animation sequences with the timeline</li><li class="listitem" style="list-style-type: disc">Animating along a path</li><li class="listitem" style="list-style-type: disc">Aligning camera motion to a path</li><li class="listitem" style="list-style-type: disc">Animating text – text as a mask for a movie</li><li class="listitem" style="list-style-type: disc">Animating text – scrolling text lines</li><li class="listitem" style="list-style-type: disc">Creating a flow field with Perlin noise</li><li class="listitem" style="list-style-type: disc">Creating an image gallery in 3D</li><li class="listitem" style="list-style-type: disc">Creating a spherical flow field with Perlin noise</li></ul></div><div class="section" title="Animating with the timeline"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Animating with the timeline</h1></div></div></div><p>In this recipe, we will learn how we can animate values using Cinder's new feature; the timeline.<a id="id553" class="indexterm"/></p><p>We animate the background color and a circle's position and radius whenever the user presses the mouse button.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec240"/>Getting ready</h2></div></div></div><p>Include the necessary files to use the timeline, generate random numbers, and draw using OpenGL. Add the following code snippet at the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Timeline.h"
#include "cinder/Rand.h"</pre></div><p>Also, add the following useful <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec241"/>How to do it…</h2></div></div></div><p>We will create several<a id="id554" class="indexterm"/> parameters that will be animated with the timeline. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare the following members to be animated:<div class="informalexample"><pre class="programlisting">Anim&lt;Color&gt; mBackgroundColor;
Anim&lt;Vec2f&gt; mCenter;
Anim&lt;float&gt; mRadius;</pre></div></li><li class="listitem">Initialize the parameters in the <code class="literal">setup</code> method.<div class="informalexample"><pre class="programlisting">mBackgroundColor = Color( CM_HSV, randFloat(), 1.0f, 1.0f );
mCenter = getWindowCenter();
mRadius = randFloat( 20.0f, 100.0f );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we need to clear the background using the color defined in <code class="literal">mBackgroundColor</code> and draw a circle at <code class="literal">mCenter</code> with <code class="literal">mRadius</code> as the radius.<div class="informalexample"><pre class="programlisting">gl::clear( mBackgroundColor.value() ); 
gl::drawSolidCircle( mCenter.value(), mRadius.value() );</pre></div></li><li class="listitem">To animate the values whenever the user presses the mouse button, we need to declare the <code class="literal">mouseDown</code> event handler.<div class="informalexample"><pre class="programlisting">void mouseDown( MouseEvent event );  </pre></div></li><li class="listitem">Let's implement the <code class="literal">mouseDown</code> event handler and add the animations to the main timeline. We will animate <code class="literal">mBackgroundColor</code> to a new random color, set <code class="literal">mCenter</code> to the mouse cursor's position, and set <code class="literal">mRadius</code> to a new random value.<div class="informalexample"><pre class="programlisting">Color backgroundColor( CM_HSV, randFloat(), 1.0f, 1.0f );
timeline().apply( &amp;mBackgroundColor, backgroundColor, 2.0f, EaseInCubic() );
timeline().apply( &amp;mCenter, (Vec2f)event.getPos(), 1.0f, EaseInCirc() );
timeline().apply( &amp;mRadius, randFloat( 20.0f, 100.0f ), 1.0f, EaseInQuad() );</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec242"/>How it works…</h2></div></div></div><p>The timeline is a new feature of Cinder introduced in version 0.8.4. It permits the user to animate parameters by<a id="id555" class="indexterm"/> adding them to the timeline once, and everything gets updated behind the scenes.</p><p>Animations must be objects of the template class <code class="literal">ci::Anim</code>. This class can be created using any template type that supports the <code class="literal">+</code> operator.</p><p>The main <code class="literal">ci::Timeline</code> object can be accessed by calling the <code class="literal">ci::app::App::timeline()</code> method. There is always a main timeline and the user can also create other <code class="literal">ci::Timeline</code> objects.</p><p>The fourth parameter in the <code class="literal">ci::Timeline::apply</code> method is a <code class="literal">functor</code> object that represents a Tween method. Cinder has several Tweens available that can be passed as a parameter to define the type of animation.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec243"/>There's more…</h2></div></div></div><p>The <code class="literal">ci::Timeline::apply</code> method<a id="id556" class="indexterm"/> used in the preceding example uses the initial value of the <code class="literal">ci::Anim</code> object, but it is also possible to create an animation where both the begining and end values are passed.</p><p>For example, if we wanted to animate <code class="literal">mRadius</code> from a starting value of 10.0 to the end value of 100.0 seconds, we would call the following method:</p><div class="informalexample"><pre class="programlisting">timeline().apply( &amp;mRadius, 10.0f, 100.0f 1.0f, EaseInQuad() );</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec244"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To see all the available easing functions, please refer to the Cinder documentation, located at <a class="ulink" href="http://libcinder.org/docs/v0.8.4/_easing_8h.html">http://libcinder.org/docs/v0.8.4/_easing_8h.html</a>.</li></ul></div></div></div></div>
<div class="section" title="Creating animation sequences with the timeline"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Creating animation sequences with the timeline</h1></div></div></div><p>In this recipe, we will learn how<a id="id557" class="indexterm"/> to use the powerful timeline features<a id="id558" class="indexterm"/> of Cinder to create sequences of animations. We will draw a circle and animate the radius and color in a sequenced manner.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec245"/>Getting ready</h2></div></div></div><p>Include the necessary files to use the timeline, draw in OpenGL, and generate random numbers.</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Timeline.h"
#include "cinder/Rand.h"</pre></div><p>Also, add the following useful <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec246"/>How to do it…</h2></div></div></div><p>We will animate several<a id="id559" class="indexterm"/> parameters sequentially<a id="id560" class="indexterm"/> using the timeline. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare the following members to define the circle's position, radius, and color:<div class="informalexample"><pre class="programlisting">Anim&lt;float&gt; mRadius;
Anim&lt;Color&gt; mColor;
Vec2f mPos;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, initialize the members. Set the position to be at the center of the window, the radius as 30, and a random color using the HSV color mode.<div class="informalexample"><pre class="programlisting">mPos = (Vec2f)getWindowCenter();
mRadius = 30.0f;
mColor = Color( CM_HSV, randFloat(), 1.0f, 1.0f );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will clear the background with black and draw the circle using the previously defined members.<div class="informalexample"><pre class="programlisting">gl::clear( Color::black() ); 
gl::color( mColor.value() );
gl::drawSolidCircle( mPos, mRadius.value() );</pre></div></li><li class="listitem">Declare the <code class="literal">mouseDown</code> event handler.<div class="informalexample"><pre class="programlisting">  void mouseDown( MouseEvent event );</pre></div></li><li class="listitem">In the implementation of <code class="literal">mouseDown</code>, we will apply the animations to the main timeline.<p>We will first animate <code class="literal">mRadius</code> from 30 to 200 and append another animation to <code class="literal">mRadius</code> from 200 to 30.</p><p>Add the following code snippet to the <code class="literal">mouseDown</code> method:</p><div class="informalexample"><pre class="programlisting">timeline().apply( &amp;mRadius, 30.0f, 200.0f, 2.0f, EaseInOutCubic() );
timeline().appendTo( &amp;mRadius, 200.0f, 30.0f, 1.0f, EaseInOutCubic() );</pre></div></li><li class="listitem">Let's create a random color using the HSV color mode and use it as the target color to animate <code class="literal">mColor</code> and then append this animation to <code class="literal">mRadius</code>.<p>Add the following code snippet inside the <code class="literal">mouseDown</code> method:</p><div class="informalexample"><pre class="programlisting">    Color targetColor = Color( CM_HSV, randFloat(), 1.0f, 1.0f );
timeline().apply( &amp;mColor, targetColor, 1.0f, EaseInQuad() ).appendTo( &amp;mRadius );</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec247"/>How it works…</h2></div></div></div><p>Appending animations<a id="id561" class="indexterm"/> is a powerful and easy way to<a id="id562" class="indexterm"/> create complex animation sequences.</p><p>In step 5 we append an animation to <code class="literal">mRadius</code> using the following line of code:</p><div class="informalexample"><pre class="programlisting">timeline().appendTo( &amp;mRadius, 200.0f, 30.0f, 1.0f, EaseInOutCubic() );</pre></div><p>This means this animation will only occur after the previous <code class="literal">mRadius</code> animation has finished.</p><p>In step 6 we append the <code class="literal">mColor</code> animation to <code class="literal">mRadius</code> using the following line of code:</p><div class="informalexample"><pre class="programlisting">timeline().apply( &amp;mColor, targetColor, 1.0f, EaseInQuad() ).appendTo( &amp;mRadius );</pre></div><p>This means the <code class="literal">mColor</code> animation will only occur when the previous <code class="literal">mRadius</code> animation has finished.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec248"/>There's more…</h2></div></div></div><p>When appending two different animations, it is possible to offset the start time by defining the offset seconds as a second parameter.</p><p>So, for example, change the line in step 6 to read the following:</p><div class="informalexample"><pre class="programlisting">timeline().apply( &amp;mColor, targetColor, 1.0f, EaseInQuad() ).appendTo( &amp;mRadius, -0.5f );</pre></div><p>This would mean that the <code class="literal">mColor</code> animation would begin 0.5 seconds before <code class="literal">mRadius</code> has finished.</p></div></div>
<div class="section" title="Animating along a path"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Animating along a path</h1></div></div></div><p>In this recipe, we will <a id="id563" class="indexterm"/>learn how to draw a smooth B-spline in the 3D space and animate the position of an object along the calculated B-spline.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec249"/>Getting ready</h2></div></div></div><p>To navigate in the 3D space, we will use <code class="literal">MayaCamUI</code> covered in the <span class="emphasis"><em>Using MayaCamUI</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec250"/>How to do it…</h2></div></div></div><p>We will create an example animation of an object moving along the spline. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include necessary header files.<div class="informalexample"><pre class="programlisting">#include "cinder/Rand.h"
#include "cinder/MayaCamUI.h"
#include "cinder/BSpline.h"</pre></div></li><li class="listitem">Begin with the declaration of member variables to keep the B-spline and current object's position.<div class="informalexample"><pre class="programlisting">Vec3f       mObjPosition;
BSpline3f   spline;</pre></div></li><li class="listitem">Inside the <code class="literal">setup</code> method prepare a random spline:<div class="informalexample"><pre class="programlisting">mObjPosition = Vec3f::zero();

vector&lt;Vec3f&gt; splinePoints;
float step = 0.5f;
float width = 20.f;
for (float t = 0.f; t &lt; width; t += step) {
 Vec3f pos = Vec3f(
  cos(t)*randFloat(0.f,2.f),
  sin(t)*0.3f,
  t - width*0.5f);
 splinePoints.push_back( pos );
}
spline = BSpline3f( splinePoints, 3, false, false );</pre></div></li><li class="listitem">Inside the <code class="literal">update</code> method, retrieve the position of the object moving along the spline.<div class="informalexample"><pre class="programlisting">float dist = math&lt;float&gt;::abs(sin( getElapsedSeconds()*0.2f ));
mObjPosition = spline.getPosition( dist );</pre></div></li><li class="listitem">The code snippet <a id="id564" class="indexterm"/>drawing our scene will look like the following:<div class="informalexample"><pre class="programlisting">gl::enableDepthRead();
gl::enableDepthWrite();
gl::enableAlphaBlending();
gl::clear( Color::white() );
gl::setViewport(getWindowBounds());
gl::setMatrices(mMayaCam.getCamera());

// draw dashed line
gl::color( ColorA(0.f, 0.f, 0.f, 0.8f) );
float step = 0.005f;
glBegin(GL_LINES);
for (float t = 0.f; t &lt;= 1.f; t += step) {
  gl::vertex(spline.getPosition(t));
}
glEnd();

// draw object
gl::color(Color(1.f,0.f,0.f));
gl::drawSphere(mObjPosition, 0.25f);</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec251"/>How it works…</h2></div></div></div><p>First, have a look at step 3 where we are calculating a B-spline through points with coordinates based on the sine and cosine functions and some random points on the x axis. The path is stored in the <code class="literal">spline</code> class member.</p><p>Then we can easily retrieve the position in 3D space at any distance of our path. We are doing this in step 4; using the <code class="literal">getPosition</code> method<a id="id565" class="indexterm"/> on the <code class="literal">spline</code> member. The distance on the path is been passed as a <code class="literal">float</code> value in the range of 0.0 to 1.0 where 0.0 means the beginning of the path and 1.0 means the end.</p><p>Finally, in step 5 we are drawing an animation as a red sphere traveling along our path, represented as a black dashed line, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8703OS_09_01.jpg" alt="How it works…"/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec252"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id566" class="indexterm"/><span class="emphasis"><em>Aligning camera motion to path</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Animating text around curves</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Using 2D Graphics">Chapter 7</a>, <span class="emphasis"><em>Using 2D Graphics</em></span></li></ul></div></div></div>
<div class="section" title="Aligning camera motion to a path"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Aligning camera motion to a path</h1></div></div></div><p>In this recipe we<a id="id567" class="indexterm"/> will <a id="id568" class="indexterm"/>learn how we can animate the camera position on our path, calculated as a B-spline.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec253"/>Getting ready</h2></div></div></div><p>In this example, we will use <code class="literal">MayaCamUI</code>, so please refer to the <span class="emphasis"><em>Using MayaCamUI</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec254"/>How to do it…</h2></div></div></div><p>We will create an application<a id="id569" class="indexterm"/> illustrating the mechanism.<a id="id570" class="indexterm"/> Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include necessary header files.<div class="informalexample"><pre class="programlisting">#include "cinder/Rand.h"
#include "cinder/MayaCamUI.h"
#include "cinder/BSpline.h"</pre></div></li><li class="listitem">Begin with the declaration of member variables.<div class="informalexample"><pre class="programlisting">MayaCamUI mMayaCam;
BSpline3f   spline;
CameraPersp mMovingCam;
Vec3f       mCamPosition;
vector&lt;Rectf&gt; mBoxes;</pre></div></li><li class="listitem">Set up the initial values of members.<div class="informalexample"><pre class="programlisting">setWindowSize(640*2, 480);
mCamPosition = Vec3f::zero();

CameraPersp  mSceneCam;
mSceneCam.setPerspective(45.0f, 640.f/480.f, 0.1, 10000);
mSceneCam.setEyePoint(Vec3f(7.f,7.f,7.f));
mSceneCam.setCenterOfInterestPoint(Vec3f::zero());
mMayaCam.setCurrentCam(mSceneCam);

mMovingCam.setPerspective(45.0f, 640.f/480.f, 0.1, 100.f);
mMovingCam.setCenterOfInterestPoint(Vec3f::zero());

vector&lt;Vec3f&gt; splinePoints;
float step = 0.5f;
float width = 20.f;
for (float t = 0.f; t &lt; width; t += step) {
 Vec3f pos = Vec3f( cos(t)*randFloat(0.8f,1.2f),
  0.5f+sin(t*0.5f)*0.5f,
  t - width*0.5f);
 splinePoints.push_back( pos );
}
spline = BSpline3f( splinePoints, 3, false, false );

for(int i = 0; i&lt;100; i++) {
 Vec2f pos = Vec2f(randFloat(-10.f,10.f), 
  randFloat(-10.f,10.f));
 float size = randFloat(0.1f,0.5f);
 mBoxes.push_back(Rectf(pos, pos+Vec2f(size,size*3.f)));
}</pre></div></li><li class="listitem">Inside the <code class="literal">update</code> method update the camera properties.<div class="informalexample"><pre class="programlisting">float step = 0.001f;
float pos = abs(sin( getElapsedSeconds()*0.05f ));
pos = min(0.99f, pos);
mCamPosition = spline.getPosition( pos );

mMovingCam.setEyePoint(mCamPosition);
mMovingCam.lookAt(spline.getPosition( pos+step ));</pre></div></li><li class="listitem">The whole <a id="id571" class="indexterm"/><code class="literal">draw</code> method now looks like the following <a id="id572" class="indexterm"/>code snippet:<div class="informalexample"><pre class="programlisting">gl::enableDepthRead();
gl::enableDepthWrite();
gl::enableAlphaBlending();
gl::clear( Color::white() );
gl::setViewport(getWindowBounds());
gl::setMatricesWindow(getWindowSize());

gl::color(ColorA(0.f,0.f,0.f, 1.f));
gl::drawLine(Vec2f(640.f,0.f), Vec2f(640.f,480.f));

gl::pushMatrices();
gl::setViewport(Area(0,0, 640,480));
gl::setMatrices(mMayaCam.getCamera());

drawScene();

// draw dashed line
gl::color( ColorA(0.f, 0.f, 0.f, 0.8f) );
float step = 0.005f;
glBegin(GL_LINES);
for (float t = 0.f; t &lt;= 1.f; t += step) {
  gl::vertex(spline.getPosition(t));
}
glEnd();

// draw object
gl::color(Color(0.f,0.f,1.f));
gl::drawFrustum(mMovingCam);

gl::popMatrices();

// -------------

gl::pushMatrices();
gl::setViewport(Area(640,0, 640*2,480));
gl::setMatrices(mMovingCam);
drawScene();
gl::popMatrices();</pre></div></li><li class="listitem">Now we <a id="id573" class="indexterm"/>have to<a id="id574" class="indexterm"/> implement the <code class="literal">drawScene</code> method, which actually draws our 3D scene.<div class="informalexample"><pre class="programlisting">GLfloat light0_position[] = { 1000.f, 500.f, -500.f, 0.1f };
GLfloat light1_position[] = { -1000.f, 100.f, 500.f, 0.1f };
GLfloat light1_color[] = { 1.f, 1.f, 1.f };

glLightfv( GL_LIGHT0, GL_POSITION, light0_position );
glLightfv( GL_LIGHT1, GL_POSITION, light1_position );
glLightfv( GL_LIGHT1, GL_DIFFUSE, light1_color );

glEnable( GL_LIGHTING );
glEnable( GL_LIGHT0 );
glEnable( GL_LIGHT1 );

ci::ColorA diffuseColor(0.9f, 0.2f, 0.f );
gl::color(diffuseColor);
glMaterialfv( GL_FRONT, GL_DIFFUSE,  diffuseColor );

vector&lt;Rectf&gt;::iterator it;
for(it = mBoxes.begin(); it != mBoxes.end(); ++it) {
 gl::pushMatrices();
 gl::translate(0.f, it-&gt;getHeight()*0.5f, 0.f);
 Vec2f center = it-&gt;getCenter();
 gl::drawCube(Vec3f(center.x, 0.f, center.y), 
  Vec3f(it-&gt;getWidth(),
 it-&gt;getHeight(), it-&gt;getWidth()));
 gl::popMatrices();
}

glDisable( GL_LIGHTING );
glDisable( GL_LIGHT0 );
glDisable( GL_LIGHT1 );

// draw grid
drawGrid(50.0f, 2.0f);</pre></div></li><li class="listitem">The last thing we need is the <code class="literal">drawGrid</code> method, the implementation of which can be found in the <span class="emphasis"><em>Using 3D space guides</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec255"/>How it works…</h2></div></div></div><p>In this example we <a id="id575" class="indexterm"/>are using a B-spline as a path that our camera is moving along. Please refer to the <span class="emphasis"><em>Animating along a path</em></span> recipe to see the basic implementation of an object <a id="id576" class="indexterm"/>animating on a path. As you can see in step 4 we are setting the camera position by invoking the <code class="literal">setEyePosition</code> method on the <code class="literal">mMovingCam</code> member, and we have to set the camera view direction. To do that we are taking the position of the next point on the path and passing it to the <code class="literal">lookAt</code> method.</p><p>We are drawing a split screen, where on the left-hand side is a preview of our scene, and on the right-hand side we can see what is in a frustum of the camera moving along the path.</p><div class="mediaobject"><img src="graphics/8703OS_09_02.jpg" alt="How it works…"/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec256"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Animating along a path</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using 3D space guides</em></span> recipe <a id="id577" class="indexterm"/>in <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using MayaCamUI</em></span> recipe<a id="id578" class="indexterm"/> in <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span></li></ul></div></div></div>
<div class="section" title="Animating text &#x2013; text as a mask for a movie"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Animating text – text as a mask for a movie</h1></div></div></div><p>In this recipe, we will<a id="id579" class="indexterm"/> learn how we can use text as a mask for a movie using a simple shader program.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec257"/>Getting ready</h2></div></div></div><p>In this example, we are using one of the amazing videos provided by NASA taken by an ISS crew that you can find at <a class="ulink" href="http://eol.jsc.nasa.gov/">http://eol.jsc.nasa.gov/</a>. Please download oneand save it as <code class="literal">video.mov</code> inside the <code class="literal">assets</code> folder.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec258"/>How to do it…</h2></div></div></div><p>We will create a sample Cinder application to illustrate the mechanism. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the necessary header files.<div class="informalexample"><pre class="programlisting">#include "cinder/gl/Texture.h"
#include "cinder/Text.h"
#include "cinder/Font.h"
#include "cinder/qtime/QuickTime.h"
#include "cinder/gl/GlslProg.h"</pre></div></li><li class="listitem">Declare the member variables.<div class="informalexample"><pre class="programlisting">qtime::MovieGl mMovie;
gl::Texture     mFrameTexture, mTextTexture;
gl::GlslProg  mMaskingShader;</pre></div></li><li class="listitem">Implement the <code class="literal">setup</code> method, as follows:<div class="informalexample"><pre class="programlisting">setWindowSize(854, 480);

TextLayout layout;
layout.clear( ColorA(0.f,0.f,0.f, 0.f) );
layout.setFont( Font("Arial Black", 96 ) );
layout.setColor( Color( 1, 1, 1 ) );
layout.addLine( "SPACE" );
Surface8u rendered = layout.render( true );

gl::Texture::Format format;
format.setTargetRect();
mTextTexture = gl::Texture( rendered, format );

try {
  mMovie = qtime::MovieGl( getAssetPath("video.mov") );
  mMovie.setLoop();
  mMovie.play();
} catch( ... ) {
  console() &lt;&lt;"Unable to load the movie."&lt;&lt;endl;
  mMovie.reset();
}

mMaskingShader = gl::GlslProg( loadAsset("passThru_vert.glsl"), loadAsset("masking_frag.glsl") );</pre></div></li><li class="listitem">Inside<a id="id580" class="indexterm"/> the <code class="literal">update</code> method we have to update our <code class="literal">mFrameTexture</code> where we are keeping the current movie frame.<div class="informalexample"><pre class="programlisting">if( mMovie ) mFrameTexture = mMovie.getTexture();</pre></div></li><li class="listitem">The <code class="literal">draw</code> method will look like the following code snippet:<div class="informalexample"><pre class="programlisting">gl::enableAlphaBlending();
gl::clear( Color::gray(0.05f) );
gl::setViewport(getWindowBounds());
gl::setMatricesWindow(getWindowSize());

gl::color(ColorA::white());
if(mFrameTexture) {
 Vec2f maskOffset = (mFrameTexture.getSize() 
  - mTextTexture.getSize() ) * 0.5f;
 mFrameTexture.bind(0);
 mTextTexture.bind(1);
 mMaskingShader.bind();
 mMaskingShader.uniform("sourceTexture", 0);
 mMaskingShader.uniform("maskTexture", 1);
 mMaskingShader.uniform("maskOffset", maskOffset);
 gl::pushMatrices();
 gl::translate(getWindowCenter()-mTextTexture.getSize()*0.5f);
 gl::drawSolidRect( mTextTexture.getBounds(), true );
 gl::popMatrices();
 mMaskingShader.unbind();
}</pre></div></li><li class="listitem">As you can see in the <code class="literal">setup</code> method we are loading a shader to do the masking. We have to pass through vertex shader inside the <code class="literal">assets</code> folder in a file named <code class="literal">passThru_vert.glsl</code>. You can find this in the <span class="emphasis"><em>Implementing 2D metaballs</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Using 2D Graphics">Chapter 7</a>, <span class="emphasis"><em>Using 2D Graphics</em></span>.</li><li class="listitem">Finally,<a id="id581" class="indexterm"/> the fragment shader program code will look like the following code snippet, and should also be inside the <code class="literal">assets</code> folder under the name <code class="literal">masking_frag.glsl</code>.<div class="informalexample"><pre class="programlisting">#extension GL_ARB_texture_rectangle : require

uniform sampler2DRect sourceTexture;
uniform sampler2DRect maskTexture;
uniform vec2 maskOffset;

void main() 
{ 
  vec2 texCoord = gl_TexCoord[0].st;  
    
  vec4 sourceColor = texture2DRect( sourceTexture, texCoord+maskOffset );   
  vec4 maskColor = texture2DRect( maskTexture, texCoord ); 
  
  vec4 color = sourceColor * maskColor;
  
  gl_FragColor = color;
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec259"/>How it works…</h2></div></div></div><p>Inside the <code class="literal">setup</code> method in step 3 we are rendering our text as <code class="literal">Surface</code> and then converting it to <code class="literal">gl::Texture</code> that we will use later as a masking texture. It is important here to set a rectangle format for masking texture while we are using it as a mask for a movie, because <code class="literal">qtime::MovieGl</code> is creating a texture with a frame that is rectangular. To do that we are defining the <code class="literal">gl::Texture::Format</code> object named <code class="literal">format</code> and invoking the <code class="literal">setTargetRect</code> method on it. While creating <code class="literal">gl::Texture</code> we have to pass <code class="literal">format</code> to the constructor as a second parameter.</p><p>To draw a movie frame we are using our masking shader program applied on the rectangle in step 5. We have to pass three parameters, which are the movie frame as <code class="literal">sourceTexture</code>, mask texture with text as <code class="literal">maskTexture</code>, and the position of the mask as <code class="literal">maskOffset</code>.</p><p>In step 7 you can see<a id="id582" class="indexterm"/> the fragment shader code, which simply multiplies the colors of the corresponding pixels from <code class="literal">sourceTexture</code> and <code class="literal">maskTexture</code>. Please notice that we are using <code class="literal">sampler2DRect</code> and <code class="literal">texture2DRect</code> to handle rectangular textures.</p><div class="mediaobject"><img src="graphics/8703OS_09_03.jpg" alt="How it works…"/></div></div></div>
<div class="section" title="Animating text &#x2013; scrolling text lines"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Animating text – scrolling text lines</h1></div></div></div><p>In this recipe we will<a id="id583" class="indexterm"/> learn how we can create text scrolling line-by-line.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec260"/>How to do it…</h2></div></div></div><p>We will now create an animation with scrolling text. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the necessary header files.<div class="informalexample"><pre class="programlisting">#include "cinder/gl/Texture.h"
#include "cinder/Text.h"
#include "cinder/Font.h"
#include "cinder/Utilities.h"</pre></div></li><li class="listitem">Add the member values.<div class="informalexample"><pre class="programlisting">vector&lt;gl::Texture&gt; mTextTextures;
Vec2f   mTextSize;</pre></div></li><li class="listitem">Inside <a id="id584" class="indexterm"/>the <code class="literal">setup</code> method we need to generate textures for each line of text.<div class="informalexample"><pre class="programlisting">setWindowSize(854, 480);
string font( "Times New Roman" );

mTextSize = Vec2f::zero();
į
for(int i = 0; i&lt;5; i++) {
   TextLayout layout;
   layout.clear( ColorA(0.f,0.f,0.f, 0.f) );
   layout.setFont( Font( font, 48 ) );
   layout.setColor( Color( 1, 1, 1 ) );
   layout.addLine( "Animating text " + toString(i) );
   Surface8u rendered = layout.render( true );
   gl::TexturetextTexture = gl::Texture( rendered );
   textTexture.setMagFilter(GL_NICEST);
   textTexture.setMinFilter(GL_NICEST);
   mTextTextures.push_back(textTexture);
   mTextSize.x = math&lt;float&gt;::max(mTextSize.x, 
    textTexture.getWidth());
   mTextSize.y = math&lt;float&gt;::max(mTextSize.y, 
    textTexture.getHeight());
}</pre></div></li><li class="listitem">The <code class="literal">draw</code> method for this example looks as follows:<div class="informalexample"><pre class="programlisting">gl::enableAlphaBlending();
gl::clear( Color::black() );
gl::setViewport(getWindowBounds());
gl::setMatricesWindowPersp(getWindowSize());

gl::color(ColorA::white());

float time = getElapsedSeconds()*0.5f;
float timeFloor = math&lt;float&gt;::floor( time );
inttexIdx = 1 + ( (int)timeFloor % (mTextTextures.size()-1) );
float step = time - timeFloor;

gl::pushMatrices();
gl::translate(getWindowCenter() - mTextSize*0.5f);

float radius = 30.f;
gl::color(ColorA(1.f,1.f,1.f, 1.f-step));
gl::pushMatrices();
gl::rotate( Vec3f(90.f*step,0.f,0.f) );
gl::translate(0.f,0.f,radius);
gl::draw(mTextTextures[texIdx-1], Vec2f(0.f, -mTextTextures[texIdx-1].getHeight()*0.5f) );
gl::popMatrices();

gl::color(ColorA(1.f,1.f,1.f, step));
gl::pushMatrices();
gl::rotate( Vec3f(-90.f + 90.f*step,0.f,0.f) );
gl::translate(0.f,0.f,radius);
gl::draw(mTextTextures[texIdx], Vec2f(0.f, -mTextTextures[texIdx].getHeight()*0.5f) );
gl::popMatrices();

gl::popMatrices();</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec261"/>How it works…</h2></div></div></div><p>What we are <a id="id585" class="indexterm"/>doing first inside the <code class="literal">setup</code> method in step 3 is generating a texture with rendered text for each line and pushing it to the vector structure <code class="literal">mTextTextures</code>.</p><p>In step 4 you can find the code for drawing current and previous text to build a continuous looped animation.</p><div class="mediaobject"><img src="graphics/8703OS_09_04.jpg" alt="How it works…"/></div></div></div>
<div class="section" title="Creating a flow field with Perlin noise"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Creating a flow field with Perlin noise</h1></div></div></div><p>In this recipe we will learn<a id="id586" class="indexterm"/> how we can animate objects using a flow field. Our flow field will be a two-dimensional grid of velocity vectors that will <a id="id587" class="indexterm"/>influence how objects move.</p><p>We will also animate the flow field using vectors calculated with Perlin noise.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec262"/>Getting ready</h2></div></div></div><p>Include the necessary files to work with OpenGL graphics, Perlin noise, random numbers, and Cinder's math utilities.</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Perlin.h"
#include "cinder/Rand.h"
#include "cinder/CinderMath.h"</pre></div><p>Also, add the following useful <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec263"/>How to do it…</h2></div></div></div><p>We will create an <a id="id588" class="indexterm"/>animation using the flow field.<a id="id589" class="indexterm"/> Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will begin by creating a <code class="literal">Follower</code> class to define the objects that will be influenced by the flow field.<p>Declare the following class before the main application class:</p><div class="informalexample"><pre class="programlisting">class Follower{
public:
 Follower( const Vec2f&amp; pos ){
  this-&gt;pos = pos;
 }
 void update( const Vec2f&amp; newVel ){
  vel += ( newVel - vel ) * 0.2f;
  pos += vel;
  if( pos.x &lt; 0.0f ){
   pos.x = (float)getWindowWidth();
   vel = Vec2f();
  }
  if( pos.x &gt; (float)getWindowWidth() ){
   pos.x = 0.0f;
   vel = Vec2f();
  }
  if( pos.y &lt; 0.0f ){
   pos.y = (float)getWindowHeight();
   vel = Vec2f();
  }
  if( pos.y &gt; (float)getWindowHeight() ){
   pos.y = 0.0f;
   vel = Vec2f();
  } 
 }
 void draw(){
  gl::drawSolidCircle( pos, 5.0f );
  gl::drawLine( pos, pos + ( vel * 20.0f ) );
 }
 Vec2f pos, vel;
};</pre></div></li><li class="listitem">Let's create the flow field. Declare a two-dimensional <code class="literal">std::vector</code> to define the <a id="id590" class="indexterm"/>flow field, and variables to define the gap between vectors and the number of rows and columns.<div class="informalexample"><pre class="programlisting">vector&lt; vector&lt; Vec2f&gt; &gt; mFlowField;
Vec2f mGap;
float mCounter;
int mRows, mColumns;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we will define the number of rows and columns, and calculate the gap between each vector.<div class="informalexample"><pre class="programlisting">mRows = 40;
mColumns = 40;
mGap.x = (float)getWindowWidth() / (mRows-1);
mGap.y = (float)getWindowHeight() / (mColumns-1);</pre></div></li><li class="listitem">Based on the number of rows and columns we can initialize <code class="literal">mFlowField</code>.<div class="informalexample"><pre class="programlisting">mFlowField.resize( mRows );
for( int i=0; i&lt;mRows; i++ ){
  mFlowField[i].resize( mColumns );</pre></div></li><li class="listitem">Let's animate the flow field using Perlin noise. To do so declare the following members:<div class="informalexample"><pre class="programlisting">  Perlin mPerlin;
float mCounter;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method initialize <code class="literal">mCounter</code> to zero.<div class="informalexample"><pre class="programlisting">  mCounter = 0.0f;
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method we will increment <code class="literal">mCounter</code> and iterate <code class="literal">mFlowField</code> using a nested <code class="literal">for</code> loop, and use <code class="literal">mPerlin</code> to animate the vectors.<div class="informalexample"><pre class="programlisting">for( int i=0; i&lt;mRows; i++ ){
 for( int j=0; j&lt;mColumns; j++ ){
  float angle= mPerlin.noise( ((float)i)*0.01f + mCounter,
   ((float)j)*0.01f ) * M_PI * 2.0f;
  mFlowField[i][j].x = cosf( angle );
  mFlowField[i][j].y = sinf( angle );
 } 
}</pre></div></li><li class="listitem">Now iterate over<a id="id591" class="indexterm"/> <code class="literal">mFlowField</code> and draw a line indicating the direction of the vectors.<p>Add the following code snippet inside the <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">for( int i=0 i&lt;mRows; i++ ){
 for( int j=0; j&lt;mColumns; j++ ){
  float x = (float)i*mGap.x;
  float y = (float)j*mGap.y;
  Vec2f begin( x, y );
  Vec2f end = begin + ( mFlowField[i][j] * 10.0f );
  gl::drawLine( begin, end );
 }
}</pre></div></li><li class="listitem">Let's add some <code class="literal">Followers</code>. Declare the following member:<div class="informalexample"><pre class="programlisting">vector&lt;shared_ptr&lt;Follower&gt;&gt; mFollowers;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we will initialize some followers and add them at random positions in the window.<div class="informalexample"><pre class="programlisting">int numFollowers = 50;
for( int i=0; i&lt;numFollowers; i++ ){
 Vec2f pos( randFloat( getWindowWidth() ), 
  randFloat(getWindowHeight() ) );
 mFollowers.push_back( 
  shared_ptr&lt;Follower&gt;( new Follower( pos ) ) );
}</pre></div></li><li class="listitem">In the update we will iterate <code class="literal">mFollowers</code> and calculate the corresponding vector in <code class="literal">mFlowField</code> based on its position.<p>We will then update the <code class="literal">Follower</code> class using that vector.</p><div class="informalexample"><pre class="programlisting">for( vector&lt;shared_ptr&lt;Follower&gt; &gt;::iterator it = 
 mFollowers.begin(); it != mFollowers.end(); ++it ){
 shared_ptr&lt;Follower&gt; follower = *it;
 int indexX= ci::math&lt;int&gt;::clamp(follower-&gt;pos.x / mGap.x,0,
  mRows-1 );
 int indexY= ci::math&lt;int&gt;::clamp(follower-&gt;pos.y / mGap.y,0, 
  mColumns-1 );
 Vec2f flow = mFlowField[ indexX ][ indexY ];
 follower-&gt;update( flow );
}</pre></div></li><li class="listitem">Finally, we just need to draw each <code class="literal">Follower</code> class.<p>Add the following code snippet inside the <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">for( vector&lt; shared_ptr&lt;Follower&gt; &gt;::iterator it = 
 mFollowers.begin(); it != mFollowers.end(); ++it ){
 (*it)-&gt;draw();
}</pre></div><p>The following is the result:</p></li></ol></div><div class="mediaobject"><img src="graphics/8703OS_09_05.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec264"/>How it works…</h2></div></div></div><p>The <code class="literal">Follower</code> class<a id="id592" class="indexterm"/> represents an agent that will follow the flow field. In the <code class="literal">Follower::update</code> method a new velocity vector is passed as a parameter. The <code class="literal">follower</code> object will interpolate its velocity into the passed value and use it to animate. The <code class="literal">Follower::update</code> method is also responsible for keeping each agent inside the window by warping its position whenever it is outside the window.</p><p>In step 11 we calculated the vector in the flow field that will influence the <code class="literal">Follower</code> object using it's position.</p></div></div>
<div class="section" title="Creating an image gallery in 3D"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Creating an image gallery in 3D</h1></div></div></div><p>In this recipe we will learn how <a id="id593" class="indexterm"/>we can create an image gallery in 3D. The images will be loaded from a folder selected by the user and displayed in a three-dimensional <a id="id594" class="indexterm"/>circular fashion. Using the keyboard, the user will be able to change the selected image.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec265"/>Getting ready</h2></div></div></div><p>When starting the application you will be asked to select a folder with images, so make sure you have one.</p><p>Also, in your code include the necessary files to use OpenGL drawing calls, textures, the timeline, and loading images.</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/gl/Texture.h"
#include "cinder/Timeline.h"
#include "cinder/ImageIo.h"</pre></div><p>Also, add the following useful <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec266"/>How to do it…</h2></div></div></div><p>We will display and animate images in 3D space. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will start by creating an <code class="literal">Image</code> class. Add the following code snippet before the main application class:<div class="informalexample"><pre class="programlisting">class Image{
public:
Image( gl::Texture texture, constRectf&amp; maxRect ){
 this-&gt;texture = texture;
 distance = 0.0f;
 angle = 0.0f;
 Vec2f size = Vec2f(texture.getWidth(), texture.getHeight());
 rect = Rectf(-size * 0.5f, size*0.5f).getCenteredFit( 
  maxRect, true );
}
void draw(){
 gl::pushMatrices();
 glRotatef( angle, 0.0f, 1.0f, 0.0f );
 gl::translate( 0.0f, 0.0f, distance );
 gl::draw( texture, rect );
 gl::popMatrices();
}
gl::Texture texture;
float distance;
float angle;
Rectfrect;
}</pre></div></li><li class="listitem">In the main application's class we will declare the following members:<div class="informalexample"><pre class="programlisting">vector&lt;shared_ptr&lt;Image&gt;&gt; mImages;
int mSelectedImageIndex;
Anim&lt;float&gt; mRotationOffset;</pre></div></li><li class="listitem">In the<a id="id595" class="indexterm"/> <code class="literal">setup</code> method we will ask the user to select a folder and then try to create a texture from each file in the folder. If a texture is successfully<a id="id596" class="indexterm"/> created, we will use it to create an <code class="literal">Image</code> object and add it to <code class="literal">mImages</code>.<div class="informalexample"><pre class="programlisting">fs::path imageFolder = getFolderPath( "" );
if( imageFolder.empty() == false ){
 for( fs::directory_iterator it( imageFolder ); it !=
  fs::directory_iterator(); ++it ){
  const fs::path&amp; file = it-&gt;path();
  gl::Texture texture;
  try {
   texture = loadImage( file );
  } catch ( ... ) { }
  if( texture ){
   Rectf maxRect(RectfmaxRect( Vec2f( -50.0f, -50.0f),
    Vec2f( 50.0f,50.0f ) );
   mImages.push_back( shared_ptr&lt;Image&gt;( 
    new Image( texture, maxRect) ) );
  } 
 }
}</pre></div></li><li class="listitem">We need to iterate over <code class="literal">mImages</code><a id="id597" class="indexterm"/> and define the angle and distance that each image will have from the center.<div class="informalexample"><pre class="programlisting">float angle = 0.0f;
float angleAdd = 360.0f / mImages.size();
float radius = 300.0f;
for( int i=0; i&lt;mImages.size(); i++ ){
 mImages[i]-&gt;angle = angle;
 mImages[i]-&gt;distance = radius;
 angle += angleAdd;
}</pre></div></li><li class="listitem">Now we can initialize the remaining members.<div class="informalexample"><pre class="programlisting">mSelectedImageIndex = 0;
mRotationOffset = 0.0f;</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will start by clearing the window, setting the window's matrices to support 3D, and enabling reading and writing in the depth buffer:<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div></li><li class="listitem">Next we<a id="id598" class="indexterm"/> will draw the images. Since all our images have been displayed around the origin, we must translate them to the center of the window. We will also rotate them around the y axis using the value in <code class="literal">mRotationOffset</code>. Everything will go in an <code class="literal">if</code> statement that will check if <code class="literal">mImages</code> contains any image, in case no image was generated during the setup.</li><li class="listitem">Add the following code snippet inside the <code class="literal">draw</code> method:<div class="informalexample"><pre class="programlisting">if( mImages.size() ){
 Vec2f center = (Vec2f)getWindowCenter();
 gl::pushMatrices();
 gl::translate( center.x, center.y, 0.0f );
 glRotatef( mRotationOffset, 0.0f, 1.0f, 0.0f );
 for(vector&lt;shared_ptr&lt;Image&gt; &gt;::iterator it=mImages.begin();
  it != mImages.end(); ++it ){
  (*it)-&gt;draw();
 }
 gl::popMatrices();
}</pre></div></li><li class="listitem">Since the user will be able to switch images using the keyboard, we must declare the <code class="literal">keyUp</code> event handler.<div class="informalexample"><pre class="programlisting">void keyUp( KeyEvent event );</pre></div></li><li class="listitem">In the implementation of <code class="literal">keyUp</code> we will move the images on to the left or right-hand side depending on whether the left or right key was released.<p>If the selected image was changed, we animate <code class="literal">mRotationOffset</code> to the correspondent <a id="id599" class="indexterm"/>value, so that the correct image is now facing the user.</p><p>Add the<a id="id600" class="indexterm"/> following code snippet inside the <code class="literal">keyUp</code> method:</p><div class="informalexample"><pre class="programlisting">bool imageChanged = false;
if( event.getCode() == KeyEvent::KEY_LEFT ){
 mSelectedImageIndex--;
 if( mSelectedImageIndex&lt; 0 ){
  mSelectedImageIndex = mImages.size()-1;
  mRotationOffset.value() += 360.0f;
 }
 imageChanged = true;
} else if( event.getCode() == KeyEvent::KEY_RIGHT ){
 mSelectedImageIndex++;
 if( mSelectedImageIndex&gt;mImages.size()-1 ){
  mSelectedImageIndex = 0;
  mRotationOffset.value() -= 360.0f;
 }
 imageChanged = true;
}
if( imageChanged ){
 timeline().apply( &amp;mRotationOffset, 
  mImages[ mSelectedImageIndex]-&gt;angle, 1.0f, 
  EaseOutElastic() );
}</pre></div></li><li class="listitem">Build and run the application. You will be prompted to select a folder containing images that will then be displayed in a circular fashion. Press the left or right key on the keyboard to change the selected image.<div class="mediaobject"><img src="graphics/8703OS_09_06.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec267"/>How it works…</h2></div></div></div><p>The <code class="literal">draw</code> method<a id="id601" class="indexterm"/> of the <code class="literal">Image</code> class rotates the coordinate system around the y axis and then translates the image drawing on the z axis. This will extrude the image<a id="id602" class="indexterm"/> from the center facing outwards on the given angle. It is an easy and convenient way of achieving the desired effect without dealing with coordinate transformations.</p><p>The <code class="literal">Image::rect</code> member is used to draw the texture and is calculated to fit inside the rectangle passed in the constructor.</p><p>When selecting the image to be displayed in front, the value of <code class="literal">mRotationOffset</code> will be the opposite of the image's angle, making it the image being drawn in front of the view.</p><p>In the <code class="literal">keyUp</code> event we check whether the left or right key was pressed and animate <code class="literal">mRotationOffset</code> to the desired value. <a id="id603" class="indexterm"/>We also take into account if the angle wraps around, as to avoid glitches in the animation.</p></div></div>
<div class="section" title="Creating a spherical flow field with Perlin noise"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Creating a spherical flow field with Perlin noise</h1></div></div></div><p>In this recipe we will learn how to use Perlin noise with a spherical flow field and animate objects in an organic way<a id="id604" class="indexterm"/> around a sphere.<a id="id605" class="indexterm"/></p><p>We will animate our objects using spherical coordinates and then transform them into Cartesian coordinates in order to draw them.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec268"/>Getting ready</h2></div></div></div><p>Add the necessary files to use Perlin noise and draw with OpenGL:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Perlin.h"
#include "cinder/Rand.h"</pre></div><p>Add the following useful <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec269"/>How to do it…</h2></div></div></div><p>We will create the <code class="literal">Follower</code> objects that move organically in a spherical flow field. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will start by creating a <code class="literal">Follower</code> class representing an object that will follow the spherical flow field.<p>Add the following code snippet before the application's class declaration:</p><div class="informalexample"><pre class="programlisting">class Follower{
public:
Follower(){
 theta = 0.0f;
 phi = 0.0f;
}
void moveTo( const Vec3f&amp; target ){
 prevPos = pos;
 pos += ( target - pos ) * 0.1f;
}
void draw(){
 gl::drawSphere( pos, 10.0f, 20 );
 Vec3f vel = pos - prevPos;
 gl::drawLine( pos, pos + ( vel * 5.0f ) );
}
Vec3f pos, prevPos;
float phi, theta;
};</pre></div></li><li class="listitem">We will be using spherical<a id="id606" class="indexterm"/> to Cartesian coordinates, so declare the following method in the application's class:<div class="informalexample"><pre class="programlisting">Vec3f sphericalToCartesians(sphericalToCartesians( float radius, float theta, float phi );</pre></div></li><li class="listitem">The implementation<a id="id607" class="indexterm"/> of this method is as follows:<div class="informalexample"><pre class="programlisting">float x = radius * sinf( theta ) * cosf( phi );
float y = radius * sinf( theta ) * sinf( phi );
float z = radius * cosf( theta );
return Vec3f( x, y, z );</pre></div></li><li class="listitem">Declare the following members in the application's class:<div class="informalexample"><pre class="programlisting">vector&lt;shared_ptr&lt; Follower &gt; &gt; mFollowers;
float mRadius;
float mCounter;
Perlin mPerlin;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we will begin by initializing <code class="literal">mRadius</code> and <code class="literal">mCounter</code>:<div class="informalexample"><pre class="programlisting">mRadius = 200.0f;
mCounter = 0.0f;</pre></div></li><li class="listitem">Now let's create 100 followers and add them to <code class="literal">mFollowers</code>. We will also attribute random values to the <code class="literal">phi</code> and <code class="literal">theta</code> variables of the <code class="literal">Follower</code> objects and set their initial positions:<div class="informalexample"><pre class="programlisting">int numFollowers = 100;
for( int i=0; i&lt;numFollowers; i++ ){
 shared_ptr&lt;Follower&gt; follower( new Follower() );
 follower-&gt;theta = randFloat( M_PI * 2.0f );
 follower-&gt;phi = randFloat( M_PI * 2.0f );
 follower-&gt;pos = sphericalToCartesian( mRadius, 
  follower-&gt;theta, follower-&gt;phi );
 mFollowers.push_back( follower );
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method we will animate our objects. Let's start by incrementing <code class="literal">mCounter</code>.<div class="informalexample"><pre class="programlisting">mCounter += 0.01f;</pre></div></li><li class="listitem">Now we will iterate over all the objects in <code class="literal">mFollowers</code> and use Perlin noise, based on the follower's position, to calculate how much it should move on spherical coordinates. <a id="id608" class="indexterm"/>We will then calculate <a id="id609" class="indexterm"/>the correspondent Cartesian coordinates and move the object.<p>Add the following code snippet inside the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">float resolution = 0.01f;
for( int i=0; i&lt;mFollowers.size(); i++ ){
 shared_ptr&lt;Follower&gt; follower = mFollowers[i];
 Vec3f pos = follower-&gt;pos;
 float thetaAdd = mPerlin.noise( pos.x * resolution, 
  pos.y * resolution, mCounter ) * 0.1f;
 float phiAdd = mPerlin.noise( pos.y * resolution, 
  pos.z * resolution, mCounter ) * 0.1f;
 follower-&gt;theta += thetaAdd;
 follower-&gt;phi += phiAdd;
 Vec3f targetPos = sphericalToCartesian( mRadius, 
  follower-&gt;theta, follower-&gt;phi );
 follower-&gt;moveTo( targetPos );
}</pre></div></li><li class="listitem">Let's move to the <code class="literal">draw</code> method and begin by clearing the background, setting the windows matrices, and enabling reading and writing in the depth buffer.<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div></li><li class="listitem">Since the followers are moving around the origin, we will draw them translated to the origin using a dark gray color. We will also draw a white sphere to get a better understanding of the movement.<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
Vec2f center = getWindowCenter();
gl::translate( center );
gl::color( Color( 0.2f, 0.2f, 0.2f ) );
for(vector&lt;shared_ptr&lt;Follower&gt; &gt;::iterator it = 
 mFollowers.begin(); it != mFollowers.end(); ++it ){
 (*it)-&gt;draw();
}
gl::color( Color::white() );
gl::drawSphere( Vec3f(), mRadius, 100 );
gl::popMatrices();</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec270"/>How it works...</h2></div></div></div><p>We use Perlin noise to<a id="id610" class="indexterm"/> calculate the change in the <code class="literal">theta</code> and <code class="literal">phi</code> members of the <code class="literal">Follower</code> objects. We use these, together with <code class="literal">mRadius</code>, to calculate<a id="id611" class="indexterm"/> the position of the objects using the standard spherical to Cartesian coordinate transformation. Since Perlin noise gives coherent values based on coordinates by using the current position of the <code class="literal">Follower</code> objects, we get the equivalent of a flow field. The <code class="literal">mCounter</code> variable is used to animate the flow field in the third dimension.</p><div class="mediaobject"><img src="graphics/8703OS_09_07.jpg" alt="How it works..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec271"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more about<a id="id612" class="indexterm"/> the Cartesian coordinate system, please refer to <a class="ulink" href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">http://en.wikipedia.org/wiki/Cartesian_coordinate_system</a></li><li class="listitem" style="list-style-type: disc">To learn <a id="id613" class="indexterm"/>more about the spherical coordinate system, please refer to <a class="ulink" href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">http://en.wikipedia.org/wiki/Spherical_coordinate_system</a></li><li class="listitem" style="list-style-type: disc">To learn more about spherical to Cartesian coordinate transformations, please refer to <a class="ulink" href="http://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_spherical_coordinate">http://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_spherical_coordinate</a></li></ul></div></div></div></body></html>