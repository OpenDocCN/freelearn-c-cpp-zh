<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Iostreams</h1>
                
            
            <article>
                
<p class="calibre2">So far, we've seen classical polymorphism in just a couple of places in the standard library. We just saw the classically polymorphic <kbd class="calibre12">std::pmr::memory_resource</kbd> in <a target="_blank" href="part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 8</a>, <em class="calibre22">Allocators</em>; and polymorphism is used "behind the scenes" in the type-erased types <kbd class="calibre12">std::any</kbd> and <kbd class="calibre12">std::function</kbd>, as detailed in <a target="_blank" href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>. However, by and large, the standard library gets by without classical polymorphism.</p>
<p class="calibre2">Two places in the standard library, however, make <em class="calibre22">massive</em> use of classical polymorphism. One is the standard exception hierarchy--for convenience, all exceptions thrown by the standard library are subclasses of <kbd class="calibre12">std::exception</kbd>. (We don't cover the exception hierarchy in this book.) The other is the contents of the standard <kbd class="calibre12">&lt;iostream&gt;</kbd> <span>header,</span> which we will cover in this chapter. However, we have a lot of background to cover before we get there!</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre14">
<li class="calibre15">The division of output into buffering and formatting; and of input into buffering, lexing, and parsing</li>
<li class="calibre15">The POSIX API for unformatted file I/O</li>
<li class="calibre15">The "C" API in <kbd class="calibre12">&lt;stdio.h&gt;</kbd><span>, which adds both buffering and formatting</span></li>
<li class="calibre15">The pros and cons of the classical <kbd class="calibre12">&lt;iostream&gt;</kbd> API</li>
<li class="calibre15">The dangers of <em class="calibre22">locale-dependent</em> formatting, and new C++17 features that can help avoid them</li>
<li class="calibre15">Many ways to convert numeric data to and from strings</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The trouble with I/O in C++</h1>
                
            
            <article>
                
<p class="calibre2">A common measure of a programming language's ease of use is what's called <strong class="calibre1">TTHW</strong>--"<strong class="calibre1">time to hello world</strong>." Many popular programming languages have a very low TTHW: in many scripting languages, such as Python and Perl, the "hello world" program is literally the single line: <kbd class="calibre12">print "hello world"</kbd>.</p>
<p class="calibre2">C++ and its ancestor C are systems programming languages, which is to say that their primary concerns are with "power": control over the machine, speed, and (in C++'s case) the ability to leverage the type system with generic algorithms. This is a mixture of concerns not suited to small "hello world" programs.</p>
<p class="calibre2">The canonical "hello world" program in C is as follows:</p>
<pre class="calibre23">    #include &lt;stdio.h&gt;<br class="title-page-name"/><br class="title-page-name"/>    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      puts("hello world");<br class="title-page-name"/>    }</pre>
<p class="calibre2">In C++, it is as follows:</p>
<pre class="calibre23">    #include &lt;iostream&gt;<br class="title-page-name"/><br class="title-page-name"/>    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::cout &lt;&lt; "hello world" &lt;&lt; std::endl;<br class="title-page-name"/>    }</pre>
<p class="calibre2">The canonical C++ source code is not much longer than the canonical C source code, but it has many more "parameters" or "knobs" that can be adjusted--knobs that the novice user must learn about even if all he learns is not to adjust them. For example, where, in C, we called a function named <kbd class="calibre12">puts</kbd> (informally, a "verb"), in C++, we apply an <em class="calibre22">operator</em> to an object named <kbd class="calibre12">std::cout</kbd> (so, informally, we have both a "verb" and an "indirect object"). In the C++ example, we also had to learn a special name for the end-of-line (newline) character--<kbd class="calibre12">std::endl</kbd>--a detail that C's <kbd class="calibre12">puts</kbd> function hid from us.</p>
<p class="calibre2">Sometimes, this complexity "turns off" newcomers to C++, especially if they're learning C++ in school and maybe aren't sure they want to be learning it in the first place. However, this is an unfortunate misunderstanding! You see, the preceding "C" source code (using <kbd class="calibre12">puts</kbd>) is also perfectly valid C++, and there is nothing wrong with using the facilities of the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> header. In fact, in this chapter, we'll explain the facilities of <kbd class="calibre12">&lt;stdio.h&gt;</kbd> before we even tackle the facilities of <kbd class="calibre12">&lt;iostream&gt;</kbd>. However, we'll see that C++14 and C++17 have introduced some little-known new features--in headers such as <kbd class="calibre12">&lt;string&gt;</kbd> and <kbd class="calibre12">&lt;utility&gt;</kbd>--that help with some common I/O tasks.</p>
<p class="calibre2">A note on header naming: I've been using the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> <span>name</span> for the header that contains "C-style" I/O facilities. Ever since C++03, there has been a similar standard header named <kbd class="calibre12">&lt;cstdio&gt;</kbd>. The only difference between <kbd class="calibre12">&lt;stdio.h&gt;</kbd> and <kbd class="calibre12">&lt;cstdio&gt;</kbd> is that in <kbd class="calibre12">&lt;stdio.h&gt;</kbd>, all of the facilities are guaranteed to be in the global namespace (for example, <kbd class="calibre12">::printf</kbd>) and may or may not be in the <kbd class="calibre12">std</kbd> namespace (for example, <kbd class="calibre12">std::printf</kbd>); whereas, in <kbd class="calibre12">&lt;cstdio&gt;</kbd>, they are guaranteed to be in <kbd class="calibre12">std</kbd> (for example, <kbd class="calibre12">std::printf</kbd>), but not necessarily in the global namespace (for example, <kbd class="calibre12">::printf</kbd>). In practice, there is no difference at all, because all major vendors put the facilities in both namespaces, no matter which header you include. My recommendation is merely to pick a style and stick with it. If your code base uses a lot of POSIX headers, such as <kbd class="calibre12">&lt;unistd.h&gt;</kbd>, which only ever have names with <kbd class="calibre12">.h</kbd>; it may be aesthetically preferable to stick with the <kbd class="calibre12">.h</kbd> names of the standard "C-style" headers as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Buffering versus formatting</h1>
                
            
            <article>
                
<p class="calibre2">It will be easier for you to understand both "C-style" I/O and "iostream-style" I/O if you remember that there are at least two fundamentally different things going on when you "output" some data (and likewise, in reverse, when you input some data). Just to have some sort of name for them, let's refer to them as <em class="calibre22">formatting</em> and <em class="calibre22">buffering:</em></p>
<ul class="calibre14">
<li class="calibre15"><em class="calibre22">Formatting</em> is the task of taking a bunch of strongly typed data values from the<br class="title-page-name"/>
program--ints, strings, floating-point numbers, user-defined class types--and translating or serializing them into "text." For example, when the number 42 is printed out as <kbd class="calibre12">"42"</kbd> (or <kbd class="calibre12">"+42"</kbd> or <kbd class="calibre12">"0x002A"</kbd>), that's <em class="calibre22">formatting</em>. Generally, a formatting library will have its own "mini-language" to describe how you want each value to be formatted.</li>
<li class="calibre15"><em class="calibre22">Buffering</em> is the task of taking a bunch of raw bytes from the program and sending them to some output device (on output), or collecting data from some input device and making it available to the program as a bunch of raw bytes (on input). The part of the library concerned with buffering may do things such as "collect 4096 bytes of data at a time, then flush"; or it might be concerned with <em class="calibre22">where</em> the data is going: to a file in the filesystem, a network socket, or an array of bytes in memory?</li>
</ul>
<p class="calibre2">Now, I deliberately said that the output of the <em class="calibre22">formatting</em> stage is "text" and the input to the <em class="calibre22">buffering</em> stage is "a bunch of bytes." On sensible operating systems, "text" and "bytes" are the same thing. However, if you're on one of those strange operating systems where newlines are encoded as two bytes, or where the expected encoding for text files is not UTF-8, then there must be some additional processing going on in one or both of these stages, or even further downstream (such as in the operating system syscall that writes the data to the file). We won't talk much more about that kind of thing, because my hope is that you're not using that kind of operating system (or locale) for actual production use. In production, you should <em class="calibre22">always</em> be using UTF-8 for character encoding, and UTC for your time zone, and <kbd class="calibre12">"C.UTF-8"</kbd> for your locale. So, for our purposes, we can pretend that "formatting" and "buffering" are the only pieces of the pipeline we need to worry about.</p>
<p class="calibre2">When we're doing input, we do the "buffering" first, to read some unformatted bytes from the input device; and then we do "formatting" to turn the bytes into strongly typed data values. The "formatting" stage for input may be subdivided further into <em class="calibre22">lexing</em> (to determine the length of an individual data item in the stream) and <em class="calibre22">parsing</em> (to determine the actual value of the item from those bytes). We'll talk more about lexing in <a href="part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 10</a>, <em class="calibre22">Regular Expressions</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the POSIX API</h1>
                
            
            <article>
                
<p class="calibre2">The most important thing to keep in mind whenever we're talking about file I/O is that everything I/O-related in C and C++ is built on top of the POSIX standard. POSIX is a very low-level specification, almost at the level of Linux system calls, that has quite a bit of overlap with the C and C++ standards for I/O; and, if you don't understand the gist of the POSIX layer, you'll have a very hard time understanding the concepts that come later.</p>
<p class="calibre2">Bear in mind that technically, <em class="calibre22">none</em> of what follows is standard C++! It is, rather, <em class="calibre22">valid</em> C++ that conforms to a <em class="calibre22">non-C++ standard</em>: the POSIX standard. In practice, this means that it'll work on any operating system except Windows, and may even work on modern Windows systems via the <strong class="calibre1">Windows Subsystem for Linux</strong> (<strong class="calibre1">WSL</strong>). Regardless, all the standard APIs (both <kbd class="calibre12">&lt;stdio.h&gt;</kbd> and <kbd class="calibre12">&lt;iostream&gt;</kbd>) are built on top of this model.</p>
<p class="calibre2">The non-standard headers that define most of what follows are <kbd class="calibre12">&lt;unistd.h&gt;</kbd> and <kbd class="calibre12">&lt;fcntl.h&gt;</kbd>.</p>
<p class="calibre2">In POSIX, the term <em class="calibre22">file</em> refers to an actual file on disk (or at least in some sort of <em class="calibre22">file system</em>; forgive me if I occasionally use the word "disk" to refer to the file system). Multiple programs can read or write the same file concurrently, via operating system resources known as <em class="calibre22">file descriptors</em>. In a C or C++ program, you'll never see a file descriptor object itself; all you'll see is a handle (or pointer) to a file descriptor. These handles (or pointers) present themselves not as pointer types, but as small integers--literally, values of type <kbd class="calibre12">int</kbd>. (The committee behind POSIX is not nearly as obsessed with type-safety as your average C++ programmer!)</p>
<p class="calibre2">To create a new file descriptor and get an integer handle to it, you use the <kbd class="calibre12">open</kbd> function; for example, <kbd class="calibre12">int fd = open("myfile.txt", O_RDONLY)</kbd>. The second argument is a bitmask, which may contain any of the following bit-flags, or'ed together:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Required</strong>: One and only one "access mode." The possible "access modes" are <kbd class="calibre12">O_RDONLY</kbd> (read only), <kbd class="calibre12">O_WRONLY</kbd> (write only), and <kbd class="calibre12">O_RDWR</kbd> (both read and write).</li>
<li class="calibre15"><span><strong class="calibre1">Optionally</strong>: Some "open-time flags," describing actions you want the system to take</span> at the time the file is opened. For example, <kbd class="calibre12">O_CREAT</kbd> means "if the named file doesn't exist, please create it for me" (as opposed to returning failure); and you can even add <kbd class="calibre12">O_EXCL</kbd>, which means "...and if the named file <em class="calibre22">does</em> exist already, then <em class="calibre22">do</em> return failure." The other important open-time flag is <kbd class="calibre12">O_TRUNC</kbd>, which means "truncate--clear out, empty, reset--the file after opening it."</li>
<li class="calibre15"><strong class="calibre1">Optionally</strong>: Some "operating modes," describing the manner in which I/O is to be<br class="title-page-name"/>
done via this file descriptor. The important one here is <kbd class="calibre12">O_APPEND</kbd>.</li>
</ul>
<p class="calibre2"><kbd class="calibre12">O_APPEND</kbd> indicates "append mode." When a file is in "append mode," you can seek around in it (as you'll see next) as usual, but every time you write to the file, your write is implicitly preceded by a seek to the end of the file (which means that after the write, your cursor will be located at the end of the file, even if you had just been reading from a different position). Opening a file descriptor in append mode is useful if you're using it for logging, especially if you're using it for logging from different threads. Some standard utility programs, such as <kbd class="calibre12">logrotate</kbd>, work best when the program doing the logging has correctly opened their log file in "append mode." In short, append mode is so broadly useful that we'll see it coming back again and again in every one of the higher-level APIs.</p>
<p class="calibre2">Now to explain "cursor" and "seek." Each POSIX file descriptor has some associated data--basically its "member variables." One of those pieces of associated data is the descriptor's current operating mode; another is the descriptor's current <em class="calibre22">file position indicator</em>, henceforth referred to as a "cursor." Like the cursor in a text editor, this cursor points to the place in the underlying file where the next read or write will take place. Using <kbd class="calibre12">read</kbd> or <kbd class="calibre12">write</kbd> on a descriptor advances its cursor. And, as described in the previous paragraph, using <kbd class="calibre12">write</kbd> on a file descriptor in "append mode" will reset the cursor to the very end of the file. Notice that there is only a single cursor per file descriptor! If you open a file descriptor with <kbd class="calibre12">O_RDWR</kbd>, you don't get a read cursor and a write cursor; you get just a single cursor that is advanced by reading <em class="calibre22">and</em> by writing.</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">read(fd, buffer, count)</kbd>: This reads raw bytes from the underlying file and stores them in the given buffer--up to <kbd class="calibre12">count</kbd> bytes, or until it encounters some sort of temporary or permanent error (for example, if we'd need to wait for more data over a network connection, or if someone unmounts the underlying filesystem in the middle of the read). It returns the number of bytes read; and remember, it advances the cursor.</li>
<li class="calibre15"><kbd class="calibre12">write(fd, buffer, count)</kbd>: This writes raw bytes from the given buffer into the underlying file--up to <kbd class="calibre12">count</kbd> bytes, or until it encounters some sort of temporary or permanent error. It returns the number of bytes written; and remember, it advances the cursor. (And <em class="calibre22">before</em> it writes any data, if the file descriptor is in append mode, it will seek to the end of the file.)</li>
<li class="calibre15"><kbd class="calibre12">lseek(fd, offset, SEEK_SET)</kbd>: This seeks (that is, moves the cursor) to the given offset from the start of the file, and returns that offset (or <kbd class="calibre12">-1</kbd> if the operation fails, for example, by running off the end of the file).</li>
<li class="calibre15"><kbd class="calibre12">lseek(fd, offset, SEEK_CUR)</kbd>: This seeks to the given offset relative to the <em class="calibre22">current</em> cursor. Relative movements like this generally aren't important, but the special case of <kbd class="calibre12">lseek(fd, 0, SEEK_CUR)</kbd> is very important because that's how you find out the current position of your cursor!</li>
<li class="calibre15"><kbd class="calibre12">lseek(fd, offset, SEEK_END)</kbd>: This seeks to the given offset relative to the end of the file. Again, this version is most useful when <kbd class="calibre12">offset</kbd> is zero.</li>
</ul>
<p class="calibre2">Incidentally, there is no way to "copy-construct" a POSIX file descriptor so that you can get a second cursor to the same file. If you want two cursors, you'll need to <kbd class="calibre12">open</kbd> the file twice. Confusingly, there <em class="calibre22">is</em> a POSIX function named <kbd class="calibre12">dup</kbd>, which takes an integer file descriptor handle and returns a different integer that can be used as a second handle to the <em class="calibre22">same</em> descriptor; this is a kind of primitive reference-counting.</p>
<p class="calibre2">When you're done with a file descriptor, you call <kbd class="calibre12">close(fd)</kbd> to release your handle; if this was the last handle to the descriptor (that is, if nobody has called <kbd class="calibre12">dup</kbd> on it in the meantime), then the file descriptor itself will be reclaimed by the operating system--which is to say, the underlying file will be "closed."</p>
<p class="calibre2">Putting it all together, we can write a simple program like this using the POSIX API to open, read, write, seek, and close file descriptors:</p>
<pre class="calibre23">    #include &lt;cassert&gt;<br class="title-page-name"/>    #include &lt;string&gt;<br class="title-page-name"/>    #include &lt;unistd.h&gt;<br class="title-page-name"/>    #include &lt;fcntl.h&gt;<br class="title-page-name"/><br class="title-page-name"/>    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      int fdw = open("myfile.txt", O_WRONLY | O_CREAT | O_TRUNC);<br class="title-page-name"/>      int fdr = open("myfile.txt", O_RDONLY);<br class="title-page-name"/>      if (fdw == -1 || fdr == -1)<br class="title-page-name"/>        return EXIT_FAILURE;<br class="title-page-name"/><br class="title-page-name"/>      write(fdw, "hello world", 11);<br class="title-page-name"/>      lseek(fdw, 6, SEEK_SET);<br class="title-page-name"/>      write(fdw, "neighbor", 8);<br class="title-page-name"/><br class="title-page-name"/>      std::string buffer(14, '\0');<br class="title-page-name"/>      int b = read(fdr, buffer.data(), 14);<br class="title-page-name"/>      assert(b == 14);<br class="title-page-name"/>      assert(buffer == "hello neighbor");<br class="title-page-name"/>      close(fdr);<br class="title-page-name"/>      close(fdw);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that the POSIX API doesn't bother with anything related to <em class="calibre22">formatting</em>. It is merely <span>concerned</span> with making sure that we can get raw bytes into and out of files on disk; that is, with about half of the <em class="calibre22">buffering</em> stage--the "where the data is going" half. POSIX doesn't bother with the "buffered output"; when you call <kbd class="calibre12">write</kbd>, your data will be written out. That is, it may still be sitting in a buffer at the OS level, or at the disk-controller level, or in the hardware, but as far as your program is concerned, the data is <em class="calibre22">on its way</em>. Any further delay in the output is out of your control and not your fault. This, in turn, means that if you need to write a lot of data efficiently using the POSIX API, your program must take charge of writing data to a buffer and then sending that whole buffer to <kbd class="calibre12">write</kbd> at once. A single 4096-byte <kbd class="calibre12">write</kbd> will be much faster than a 4,096 one-byte <kbd class="calibre12">write</kbd>!</p>
<p class="calibre2">Or, instead of writing your own buffer-management code, you could step up one level of abstraction and use the C API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the standard C API</h1>
                
            
            <article>
                
<p class="calibre2">This description is necessarily almost as brief and incomplete as our discussion of POSIX earlier. For a complete description of the facilities in <kbd class="calibre12">&lt;stdio.h&gt;</kbd>, you'll have to consult another source, such as <a href="https://cppreference.com" class="calibre4">cppreference.com</a> or your local <kbd class="calibre12">man</kbd> pages.</p>
<p class="calibre2">In the "C-style" API, POSIX <em class="calibre22">file descriptors</em> are given a new name: the thing corresponding to a file descriptor is called <kbd class="calibre12">FILE</kbd>, and the thing corresponding to an integer file descriptor handle is (naturally) called <kbd class="calibre12">FILE*</kbd>. Just as in the POSIX API, though, you'll never construct an instance of <kbd class="calibre12">FILE</kbd> yourself.</p>
<p class="calibre2">To create a new <kbd class="calibre12">FILE</kbd> object and get a pointer to it, you use the <kbd class="calibre12">fopen</kbd> function; for example, <kbd class="calibre12">FILE *fp = fopen("myfile.txt", "r")</kbd>. The second argument is a string (that is, a pointer to a null-terminated array of characters--generally, you'll just use a string literal, as I did here), which must be one of the following:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">"r"</kbd>: This is equivalent to POSIX <kbd class="calibre12">O_RDONLY</kbd>. Open for reading. Fail (that is, return <kbd class="calibre12">nullptr</kbd>) if the file doesn't exist.</li>
<li class="calibre15"><kbd class="calibre12">"w"</kbd>: <span>This is e</span>quivalent to POSIX <kbd class="calibre12">O_WRONLY | O_CREAT | O_TRUNC</kbd>. Open for writing. Create the file if it doesn't exist. Regardless, make the file empty before proceeding.</li>
<li class="calibre15"><kbd class="calibre12">"r+"</kbd>: <span>This is e</span>quivalent to POSIX <kbd class="calibre12">O_RDWR | O_CREAT</kbd>. Open for both reading <em class="calibre22">and</em> writing. Create the file empty if it doesn't exist.</li>
<li class="calibre15"><kbd class="calibre12">"w+"</kbd>: <span>This is e</span>quivalent to POSIX <kbd class="calibre12">O_RDWR | O_CREAT | O_TRUNC</kbd>.<br class="title-page-name"/>
Open for both reading and writing. Create the file if it doesn't exist. Regardless, make the file empty before proceeding.</li>
<li class="calibre15"><kbd class="calibre12">"a"</kbd>: <span>This is e</span>quivalent to POSIX <kbd class="calibre12">O_WRONLY | O_CREAT | O_APPEND</kbd>. Open for writing. Create the file empty if it doesn't exist. Enter append mode.</li>
<li class="calibre15"><kbd class="calibre12">"a+"</kbd>: <span>This is e</span>quivalent to POSIX <kbd class="calibre12">O_RDWR | O_CREAT | O_APPEND</kbd>. Open for both reading <em class="calibre22">and</em> writing. Create the file empty if it doesn't exist. Enter append mode.</li>
</ul>
<p class="calibre2">Notice that there is some pattern to the preceding strings--strings with <kbd class="calibre12">'+'</kbd> always map to <kbd class="calibre12">O_RDWR</kbd>, strings with <kbd class="calibre12">'w'</kbd> always map to <kbd class="calibre12">O_TRUNC</kbd>, and strings with <kbd class="calibre12">'a'</kbd> always map to <kbd class="calibre12">O_APPEND</kbd>; however, there is no perfectly regular pattern that describes the mapping from <kbd class="calibre12">fopen</kbd> mode strings into POSIX <kbd class="calibre12">open</kbd> flags.</p>
<p class="calibre2">Some platforms support appending additional characters to the mode string; for example, a common extension on POSIX platforms is that an added <kbd class="calibre12">'x'</kbd> means <kbd class="calibre12">O_EXCL</kbd>; on GNU platforms, an added <kbd class="calibre12">'e'</kbd> means <kbd class="calibre12">O_CLOEXEC</kbd>; and on Windows, a similar behavior can be gotten by adding a capital <kbd class="calibre12">'N'</kbd>.</p>
<p class="calibre2">The one character that can be appended to the mode string on any platform (that is, it's guaranteed by the C++ standard to be available everywhere) is <kbd class="calibre12">'b'</kbd>, for "binary." This matters only on Windows, where, if you do <em class="calibre22">not</em> specify this character, the library will automatically translate every <kbd class="calibre12">'\n'</kbd> byte you output into the Windows line terminator sequence, <kbd class="calibre12">'\r', '\n'</kbd>. If you specifically do want this translation when running on Windows, a useful convention is to add <kbd class="calibre12">'t'</kbd> to your mode string. All vendors' libraries will recognize and ignore this character; it merely serves as an indication to the human reader that indeed you meant to open the file in "text" mode, and didn't accidentally omit an intended <kbd class="calibre12">'b'</kbd>.</p>
<p class="calibre2">When you're done using a file, you must call <kbd class="calibre12">fclose(fp)</kbd>, which corresponds to calling <kbd class="calibre12">close(fd)</kbd> on the underlying file descriptor handle.</p>
<p class="calibre2">To deal with the bookkeeping on C-style <kbd class="calibre12">FILE</kbd> pointers, you may want to use the RAII smart pointers from <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>. You can write a "unique <kbd class="calibre12">FILE</kbd> pointer" like this:</p>
<pre class="calibre23">    struct fcloser {<br class="title-page-name"/>      void operator()(FILE *fp) const {<br class="title-page-name"/>        fclose(fp);<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      static auto open(const char *name, const char *mode) {<br class="title-page-name"/>        return std::unique_ptr&lt;FILE, fcloser&gt;(fopen(name, mode));<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      auto f = fcloser::open("test.txt", "w");<br class="title-page-name"/>      fprintf(f.get(), "hello world\n");<br class="title-page-name"/>        // f will be closed automatically<br class="title-page-name"/>    }</pre>
<p class="calibre2">Moreover, remember that you can always move <kbd class="calibre12">unique_ptr</kbd> into <kbd class="calibre12">shared_ptr</kbd> if you want the reference-counted, "last person out of the room turns out the lights" semantics:</p>
<pre class="calibre23">    auto f = fcloser::open("test.txt", "w");<br class="title-page-name"/>    std::shared_ptr&lt;FILE&gt; g1 = std::move(f);<br class="title-page-name"/>      // now f is empty and g1's use-count is 1<br class="title-page-name"/>    if (true) {<br class="title-page-name"/>      std::shared_ptr&lt;FILE&gt; g2 = g1;<br class="title-page-name"/>        // g1's use-count is now 2<br class="title-page-name"/>      fprintf(g2.get(), "hello ");<br class="title-page-name"/>        // g1's use-count drops back to 1<br class="title-page-name"/>    }<br class="title-page-name"/>    fprintf(g1.get(), "world\n");<br class="title-page-name"/>      // g1's use-count drops to 0; the file is closed</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Buffering in the standard C API</h1>
                
            
            <article>
                
<p class="calibre2">The standard C API offers a family of functions that look just like the POSIX functions,<br class="title-page-name"/>
but with the letter <kbd class="calibre12">f</kbd> on the front.</p>
<p class="calibre2">The <kbd class="calibre12">fread(buffer, 1, count, fp)</kbd> method reads raw bytes from the underlying file and stores them in the given buffer--up to <kbd class="calibre12">count</kbd> bytes, or until it encounters some sort of permanent error (for example, if someone unmounts the underlying filesystem in the middle of the read). It returns the number of bytes read and advances the cursor.</p>
<p class="calibre2">The literal <kbd class="calibre12">1</kbd> in that call is not a mistake! Technically, the function signature is <kbd class="calibre12">fread(buffer, k, count, fp)</kbd>. It reads up to <kbd class="calibre12">k * count</kbd> bytes, or until it encounters a permanent error and returns the number of bytes read divided by <kbd class="calibre12">k</kbd>. However, in your own code, <kbd class="calibre12">k</kbd> should always be the literal <kbd class="calibre12">1</kbd>; using anything else is a mistake, for at least two reasons. First, since the return value is always divided by <kbd class="calibre12">k</kbd>, and if <kbd class="calibre12">k</kbd> is anything but <kbd class="calibre12">1</kbd>, you will lose information. For example, if <kbd class="calibre12">k</kbd> is 8, a return value of 3 indicates that "somewhere between 24 and 31" bytes were read and stored into the buffer, but <kbd class="calibre12">buffer[3]</kbd> may now contain a partially written value--that is to say, garbage--and you have no way of detecting that. Second, since the library internally multiplies <kbd class="calibre12">k * count</kbd>, passing any <kbd class="calibre12">k</kbd> other than 1 runs the risk of overflow and an incorrectly computed buffer length. No popular implementation checks that multiplication for overflow; this is for performance reasons if nothing else. It doesn't make sense to spend CPU time on an expensive division operation if every programmer already knows never to pass any other value for <kbd class="calibre12">k</kbd> but 1!</p>
<p class="calibre2">The <kbd class="calibre12">fwrite(buffer, 1, count, fp)</kbd> method writes raw bytes from the given buffer into the underlying file--up to <kbd class="calibre12">count</kbd> bytes, or until it encounters some sort of permanent error. It returns the number of bytes written, and advances the cursor. (And <em class="calibre22">before</em> it writes any data, if the file descriptor is in append mode, it will seek to the end of the file.)</p>
<p class="calibre2">The <kbd class="calibre12">fseek(fp, offset, SEEK_SET)</kbd> method seeks (that is, moves the cursor) to the given offset from the start of the file; <kbd class="calibre12">fseek(fp, offset, SEEK_CUR)</kbd> seeks to the given offset relative to the <em class="calibre22">current</em> cursor; and <kbd class="calibre12">fseek(fp, offset, SEEK_END)</kbd> seeks to the given offset relative to the end of the file. Unlike the POSIX <kbd class="calibre12">lseek</kbd>, the standard C version <kbd class="calibre12">fseek</kbd> does <em class="calibre22">not</em> return the value of the current cursor; it merely returns <kbd class="calibre12">0</kbd> on success or <kbd class="calibre12">-1</kbd> on failure.</p>
<p class="calibre2">The <kbd class="calibre12">ftell(fp)</kbd> method returns the value of the current cursor; that is, it's equivalent to the underlying POSIX call <kbd class="calibre12">lseek(fd, 0, SEEK_CUR)</kbd>.</p>
<p class="calibre2">Speaking of underlying POSIX calls: if you are on a POSIX platform and need to do something non-portable with the POSIX file descriptor underlying a standard C <kbd class="calibre12">FILE *</kbd>, you can always retrieve the file descriptor by calling <kbd class="calibre12">fileno(fp)</kbd>. So, for example, we could express <kbd class="calibre12">ftell</kbd> as follows:</p>
<pre class="calibre23">    long ftell(FILE *fp)<br class="title-page-name"/>    {<br class="title-page-name"/>      int fd = fileno(fp);<br class="title-page-name"/>      return lseek(fd, 0, SEEK_CUR);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Working with <kbd class="calibre12">fread</kbd> and <kbd class="calibre12">fwrite</kbd> is quite possible, but it is not the most common way of using the C API. Many programs prefer to deal with input and output not in terms of large chunks of data but rather character by character, or byte by byte. The original "Unix philosophy" is oriented toward small simple command-line utilities that read and transform a "stream" of bytes; these small stream-oriented programs are known as "filters," and they really shine when you link them together with the Unix shell's pipes. For example, here is a tiny program that opens a file and counts the number of bytes, space-separated "words," and lines in that file using the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> API:</p>
<pre class="calibre23">    struct LWC {<br class="title-page-name"/>      int lines, words, chars;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    LWC word_count(FILE *fp)<br class="title-page-name"/>    {<br class="title-page-name"/>      LWC r {};<br class="title-page-name"/>      bool in_space = true;<br class="title-page-name"/>      while (true) {<br class="title-page-name"/>        int ch = getc(fp);<br class="title-page-name"/>        if (ch == EOF) break;<br class="title-page-name"/>        r.lines += (ch == '\n');<br class="title-page-name"/>        r.words += (in_space &amp;&amp; !isspace(ch));<br class="title-page-name"/>        r.chars += 1;<br class="title-page-name"/>        in_space = isspace(ch);<br class="title-page-name"/>      }<br class="title-page-name"/>      return r;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    int main(int argc, const char **argv)<br class="title-page-name"/>    {<br class="title-page-name"/>      FILE *fp = (argc &lt; 2) ? stdin : fopen(argv[1], "r");<br class="title-page-name"/>      auto [lines, words, chars] = word_count(fp);<br class="title-page-name"/>      printf("%8d %7d %7d\n", lines, words, chars);<br class="title-page-name"/>    }</pre>
<p class="calibre2">(Do you recognize it? This is the command-line utility <kbd class="calibre12">wc</kbd>.)</p>
<p class="calibre2">This program introduces two new ideas (besides the standard guarantee that all the <kbd class="calibre12">FILE</kbd> objects are implicitly closed at program exit so that it is safe for us to omit the <kbd class="calibre12">fclose</kbd> bookkeeping and save a few lines in this example). The first is the idea of <em class="calibre22">standard streams</em>. There are three standard streams in C and C++: <kbd class="calibre12">stdin</kbd>, <kbd class="calibre12">stdout</kbd>, and <kbd class="calibre12">stderr</kbd>. In our word-counting program, we follow the rule that if the command-line user has not explicitly told us any filename to read from, we'll read from <kbd class="calibre12">stdin</kbd>, the <em class="calibre22">standard input stream</em>, which is usually a synonym for the console (or terminal or keyboard--point is, it's the human being sitting there typing). Various mechanisms within the operating system and the command-line shell can be used to <em class="calibre22">redirect</em> the standard input stream from other inputs; these mechanisms (such as typing <kbd class="calibre12">wc &lt;myfile.txt</kbd> at the shell prompt) are far outside the scope of this book. The main things to remember about the three standard streams are that they are automatically available to you by name without having to <kbd class="calibre12">fopen</kbd> them; and that it is always an error to <kbd class="calibre12">fclose</kbd> any of them.</p>
<p class="calibre2">The second new idea introduced in our word-counting program is the <kbd class="calibre12">getc</kbd> <span>function. The</span> <kbd class="calibre12">getc(fp)</kbd> function reads a single byte from the given <kbd class="calibre12">FILE *</kbd> and returns the byte it read. If there was an error, or (more likely) if it hit end-of-file, it returns a special value named <kbd class="calibre12">EOF</kbd>. The numerical value of <kbd class="calibre12">EOF</kbd> is usually <kbd class="calibre12">-1;</kbd>, but the guaranteed thing about it is that it is completely different from any possible <em class="calibre22">valid</em> byte. For this reason, <kbd class="calibre12">getc(fp)</kbd> does not return its return value as <kbd class="calibre12">char</kbd>; it returns it as <kbd class="calibre12">int</kbd>, which is big enough to store any possible <kbd class="calibre12">char</kbd> and, in addition, big enough to store the value <kbd class="calibre12">EOF</kbd> distinct from any of those <kbd class="calibre12">char</kbd> values (if <kbd class="calibre12">char</kbd> is a signed type on your platform--as it is on many platforms--then <kbd class="calibre12">getc</kbd> will convert <kbd class="calibre12">char</kbd> it read into <kbd class="calibre12">unsigned char</kbd> before returning it; this ensures that if the <kbd class="calibre12">0xFF</kbd> <span>byte</span> appears in the input file, it will be returned as <kbd class="calibre12">255</kbd>, which is a different integer value than <kbd class="calibre12">-1</kbd> that represents <kbd class="calibre12">EOF</kbd>).</p>
<p class="calibre2">Now, for the crucial difference between <kbd class="calibre12">fread</kbd>/<kbd class="calibre12">fwrite</kbd> and <kbd class="calibre12">read</kbd>/<kbd class="calibre12">write</kbd>.<br class="title-page-name"/>
Recall that the POSIX API doesn't do any additional buffering of input or output bytes;<br class="title-page-name"/>
when you call <kbd class="calibre12">read</kbd>, you're going all the way to the operating system to retrieve the<br class="title-page-name"/>
next chunk of input bytes. If <kbd class="calibre12">getc(fp)</kbd> were implemented as <kbd class="calibre12">fread(&amp;ch, 1, 1, fp)</kbd>, and <kbd class="calibre12">fread(buf, 1, count, fp)</kbd> were implemented as <kbd class="calibre12">read(fileno(fp), buf, count)</kbd>, then our word-counting program would be horrendously inefficient--reading a file of a million bytes would result in a million system calls! So, when the C library wraps a file descriptor handle in a <kbd class="calibre12">FILE</kbd> object, it also adds one more feature: <em class="calibre22">buffering</em>.</p>
<p class="calibre2"><kbd class="calibre12">FILE</kbd> streams may be "unbuffered" (meaning that every <kbd class="calibre12">fread</kbd> really does correspond to <kbd class="calibre12">read</kbd>, and every <kbd class="calibre12">fwrite</kbd> to <kbd class="calibre12">write</kbd>); "fully buffered," also known as "block buffered" (meaning that writes will be accumulated into a private buffer that is sent to the underlying file descriptor only when it becomes full, and likewise, reads will be served from a private buffer that is refilled from the underlying file descriptor only when it becomes empty); or "line-buffered" (meaning that there is a private buffer just like the previous case, but writing <kbd class="calibre12">'\n'</kbd> causes a flush even if the buffer is not yet full). When the program starts up and opens its standard streams, <kbd class="calibre12">stdin</kbd> and <kbd class="calibre12">stdout</kbd> will be line-buffered, and <kbd class="calibre12">stderr</kbd> will be unbuffered. Any files you open yourself via <kbd class="calibre12">fopen</kbd> will generally be fully buffered, although the operating system may have something to say about that as well; for example, if the "file" you're opening is actually a terminal device, it may end up being line-buffered by default.</p>
<p class="calibre2">In the very rare case that you need to control the buffering mode of a <kbd class="calibre12">FILE</kbd> stream, you can do it via the standard <kbd class="calibre12">setvbuf</kbd> <span>function. Y</span>ou can also use <kbd class="calibre12">setvbuf</kbd> to provide your own buffer, as shown in the following example:</p>
<pre class="calibre23">FILE *fp = fopen("myfile.txt", "w");<br class="title-page-name"/>    int fd = fileno(fp);<br class="title-page-name"/>    char buffer[150];<br class="title-page-name"/>    setvbuf(fp, buffer, _IOFBF, 150);<br class="title-page-name"/>      // setvbuf returns 0 on success, or EOF on failure.<br class="title-page-name"/><br class="title-page-name"/>    std::string AAAA(160, 'A');<br class="title-page-name"/>    int bytes_written = fwrite(AAAA.data(), 1, 160, fp);<br class="title-page-name"/>      // This fills the buffer with 150 bytes, flushes it,<br class="title-page-name"/>      // and writes 10 more bytes into the buffer.<br class="title-page-name"/><br class="title-page-name"/>    assert(bytes_written == 160);<br class="title-page-name"/>    assert(lseek(fd, 0, SEEK_CUR) == 150);<br class="title-page-name"/>    assert(ftell(fp) == 160);</pre>
<p class="calibre2">Notice the discrepancy between <kbd class="calibre12">ftell(fp)</kbd> and <kbd class="calibre12">lseek(fd, 0, SEEK_CUR)</kbd> in the last line of the example. Ten bytes remain buffered in the buffer of <kbd class="calibre12">FILE</kbd>; so <kbd class="calibre12">FILE</kbd> reports that your cursor is currently at offset 160, but, in actuality, the underlying POSIX file descriptor's cursor is still at offset 150, and will remain there until the <kbd class="calibre12">FILE</kbd>'s buffer fills up and is flushed a second time--at which point the underlying POSIX file descriptor's cursor will jump to offset 300. This feels awkward, but it's actually exactly what we want! We <em class="calibre22">want</em> the efficiency that comes with writing the underlying file descriptor in large chunks. (Note that 150 bytes is not "large" in reality. A typical default file buffer size, if you don't use <kbd class="calibre12">setvbuf</kbd> at all, would be more like 4096 bytes.)</p>
<p class="calibre2">On some platforms, calling <kbd class="calibre12">ftell</kbd> will cause the buffer to be flushed as a side effect, since that makes the library's bookkeeping easier; the library doesn't like to be caught telling lies. (Calling <kbd class="calibre12">fseek</kbd> is also a likely way to cause a flush.) However, on other platforms, <kbd class="calibre12">ftell</kbd> and even <kbd class="calibre12">fseek</kbd> don't always flush the buffer. To make sure that your <kbd class="calibre12">FILE</kbd> stream's buffer has definitely been flushed to the underlying file, use <kbd class="calibre12">fflush</kbd>. Let's continue the previous example as follows:</p>
<pre class="calibre23">    // Flush the FILE's buffer by force.<br class="title-page-name"/>    fflush(fp);<br class="title-page-name"/>    // Now, fd and fp agree about the state of the file.<br class="title-page-name"/>    assert(lseek(fd, 0, SEEK_CUR) == 160);</pre>
<p class="calibre2">Putting it all together, we can rewrite our simple program from the <em class="calibre22">Using the POSIX API</em> <span>section</span> like this, using the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> API to open, read, write, seek, flush, and close file streams:</p>
<pre class="calibre23">    #include &lt;cassert&gt;<br class="title-page-name"/>    #include &lt;cstdio&gt;<br class="title-page-name"/>    #include &lt;string&gt;<br class="title-page-name"/><br class="title-page-name"/>    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      FILE *fpw = fopen("myfile.txt", "w");<br class="title-page-name"/>      FILE *fpr = fopen("myfile.txt", "r");<br class="title-page-name"/>      if (fpw == nullptr || fpr == nullptr)<br class="title-page-name"/>        return EXIT_FAILURE;<br class="title-page-name"/><br class="title-page-name"/>      fwrite("hello world", 1, 11, fpw);<br class="title-page-name"/>      fseek(fpw, 6, SEEK_SET);<br class="title-page-name"/>      fwrite("neighbor", 1, 8, fpw);<br class="title-page-name"/>      fflush(fpw);<br class="title-page-name"/><br class="title-page-name"/>      std::string buffer(14, '\0');<br class="title-page-name"/>      int b = fread(buffer.data(), 1, 14, fpr);<br class="title-page-name"/>      assert(b == 14 &amp;&amp; buffer == "hello neighbor");<br class="title-page-name"/>      fclose(fpr);<br class="title-page-name"/>      fclose(fpw);<br class="title-page-name"/>    }</pre>
<p class="calibre2">This concludes our exploration of the <em class="calibre22">buffering</em> capabilities of the standard <kbd class="calibre12">&lt;stdio.h&gt;</kbd> API; now, we move on to consider how <kbd class="calibre12">&lt;stdio.h&gt;</kbd> deals with <em class="calibre22">formatting</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Formatting with printf and snprintf</h1>
                
            
            <article>
                
<p class="calibre2">In the formatting stage, we start with the high-level data values that we want to print out; for example, we might want to print the number of piano tuners in Chicago, which our program has computed as 225. Printing out the <em class="calibre22">three-byte string</em> <kbd class="calibre12">"225"</kbd> is easy; we've solved that in the preceding sections. The task of <em class="calibre22">formatting</em> is to get us from the number 225 (an <kbd class="calibre12">int</kbd>, let's say) to that three-byte string <kbd class="calibre12">"225"</kbd>.</p>
<p class="calibre2">When printing numbers, we have many possible concerns: should the number be printed in base 10, base 16, base 8, base 2, or some other base? If the number is negative, presumably, we should prefix it with <kbd class="calibre12">-</kbd>; if it is positive, should we prefix it with <kbd class="calibre12">+</kbd>? Should we use thousands-separators, and if so, should we use commas, periods, or spaces? What about decimal points? Once we're talking about floating-point numbers, how many digits after the decimal point should we print? Or should we use scientific notation, and if so, to how many significant digits?</p>
<p class="calibre2">Then, there are concerns that extend even to non-numeric input. Should the printed value be aligned within a fixed-width column, and if so, should it be left-aligned, right-aligned, or even aligned in some other clever way? (And what character should we use to fill the unoccupied columns?) What if the value doesn't fit in the given column width--should it be truncated left or right or just overflow the column's bounds?</p>
<p class="calibre2">Similarly, when reading formatted input (that is, <em class="calibre22">parsing</em>), we have to answer many of the same questions about numerics: do we expect thousands-separators? Scientific notation? Leading <kbd class="calibre12">+</kbd> signs? What numeric base do we expect? And even for non-numerics: do we expect leading whitespace? If we're reading in a value of type "string," what indicates the end of the value other than <kbd class="calibre12">EOF</kbd>?</p>
<p class="calibre2">The standard C API provides a whole family of formatting functions with names ending in <kbd class="calibre12">printf</kbd>, and a matching family of parsing functions with names ending in <kbd class="calibre12">scanf</kbd>. A commonality of every function in this family is that it takes a variadic argument list (using C-style varargs, not C++ variadic templates) and, prior to the variadic arguments, a single "format string" that answers many of the above questions (but not all of them) for each argument to be formatted, and also provides a "shape" for the overall message, into which the library will insert the formatted arguments:</p>
<pre class="calibre23">    int tuners = 225;<br class="title-page-name"/>    const char *where = "Chicago";<br class="title-page-name"/>    printf("There are %d piano tuners in %s.\n", tuners, where);</pre>
<p class="calibre2">There is also <kbd class="calibre12">fprintf(fp, "format", args...)</kbd> to print to any arbitrary stream (not necessarily <kbd class="calibre12">stdout</kbd>); <kbd class="calibre12">snprintf(buf, n, "format", args...)</kbd> to write to a buffer, about which we'll discuss more in a moment; and a matching family of <kbd class="calibre12">vprintf</kbd>, <kbd class="calibre12">vfprintf</kbd>, and <kbd class="calibre12">vsnprintf</kbd> <span>functions</span> that are useful in building your own printf-like functions. As you've probably learned to expect in this chapter, a complete treatment of C-style format strings is out of the scope of this book. However, the C-style "format string language" is widely used even in languages that don't directly descend from C; for example, in Python 2, you can say:</p>
<pre class="calibre23">    tuners = 225<br class="title-page-name"/>    where = "Chicago"<br class="title-page-name"/>    print "There are %d piano tuners in %s." % (tuners, where)</pre>
<p class="calibre2">However, there are major differences between what's happening in C and what's happening in Python!</p>
<p class="calibre2">The biggest difference is that Python is dynamically typed, so if you write <kbd class="calibre12">"%s tuners" % (tuners)</kbd>, it will still be able to do the right thing. With C-style variadic argument lists, the original type of <kbd class="calibre12">tuners</kbd> is lost; if you use the <kbd class="calibre12">"%s"</kbd> format specifier (which expects a <kbd class="calibre12">const char *</kbd> argument) with an argument of type <kbd class="calibre12">int</kbd>, you'll get a friendly compiler warning at best and undefined behavior at worst. That is to say, when you use <kbd class="calibre12">&lt;stdio.h&gt;</kbd> formatting functions, the format string does double duty: it encodes not only <em class="calibre22">how to format</em> each data value, but also <em class="calibre22">the type of</em> each data value--and if you get one of those types wrong, such as by using <kbd class="calibre12">"%s"</kbd> when you meant <kbd class="calibre12">"%d"</kbd>, then your program will have a bug. Fortunately, all major compilers can detect and diagnose such mismatches these days, as long as your format string is passed directly to <kbd class="calibre12">printf</kbd> or to a function annotated with the (non-standard) <kbd class="calibre12">format</kbd> attribute, as demonstrated in the code sample we'll see shortly. Unfortunately, these diagnostics can be unreliable when you're dealing with typedefs for platform-dependent types; for example, some 64-bit compilers will not diagnose an attempt to format a <kbd class="calibre12">size_t</kbd> value with the <kbd class="calibre12">"%llu"</kbd> format specifier, even though the properly portable specifier would be <kbd class="calibre12">"%zu"</kbd>.</p>
<p class="calibre2">Another difference is that in C, <kbd class="calibre12">printf</kbd> is effectively writing directly to the standard output stream, <kbd class="calibre12">stdout</kbd>; the formatting of the data is interleaved with the buffering of the output bytes. In Python, the <kbd class="calibre12">"There are %d piano tuners in %s." % (tuners, where)</kbd> <span>construct</span> is actually an <em class="calibre22">expression</em> of type <kbd class="calibre12">str</kbd> (string); all of the formatting happens right there, producing a single string value with the proper bytes, before we decide that the string is to be printed to <kbd class="calibre12">stdout</kbd> at all.</p>
<p class="calibre2">To produce a formatted string using the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> API, we will use <kbd class="calibre12">snprintf</kbd>:</p>
<pre class="calibre23">    char buf[13];<br class="title-page-name"/>    int needed = snprintf(<br class="title-page-name"/>      buf, sizeof buf,<br class="title-page-name"/>      "There are %d piano tuners in %s", tuners, where<br class="title-page-name"/>    );<br class="title-page-name"/>    assert(needed == 37);<br class="title-page-name"/>    assert(std::string_view(buf) == "There are 22");</pre>
<p class="calibre2">Notice that <kbd class="calibre12">snprintf</kbd> always null-terminates its buffer, even if it means not writing the entire message into it; and it returns <kbd class="calibre12">strlen</kbd> of the message that it <em class="calibre22">wanted</em> to write. A common idiom to format an arbitrarily long message is to call <kbd class="calibre12">snprintf</kbd> first with <kbd class="calibre12">nullptr</kbd>, to learn the message's final size; and then call it a second time with a buffer of that size:</p>
<pre class="calibre23">    template&lt;class... Args&gt;<br class="title-page-name"/>    std::string format(const char *fmt, const Args&amp;... args)<br class="title-page-name"/>    {<br class="title-page-name"/>      int needed = snprintf(nullptr, 0, fmt, args...);<br class="title-page-name"/>      std::string s(needed + 1, '\0');<br class="title-page-name"/>      snprintf(s.data(), s.size(), fmt, args...);<br class="title-page-name"/>      s.pop_back(); // remove the written '\0'<br class="title-page-name"/>      return s;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()  <br class="title-page-name"/>    {<br class="title-page-name"/>      std::string s = format("There are %d piano tuners in %s", tuners, where);<br class="title-page-name"/>      assert(s == "There are 225 piano tuners in Chicago"); <br class="title-page-name"/>    } </pre>
<p class="calibre2">The preceding implementation of <kbd class="calibre12">format</kbd> uses a variadic function template, which will tend to produce a lot of similar copies of the code. A more efficient implementation (in terms of compile time and code bloat) would be to use a single (non-template) function with a C-style variadic argument list, and use <kbd class="calibre12">vsnprintf</kbd> for formatting. Sadly, further discussion of <kbd class="calibre12">va_list</kbd> and <kbd class="calibre12">vsnprintf</kbd> is far outside the scope of this book.</p>
<pre class="calibre23">    std::string better_format(const char *fmt, ...)<br class="title-page-name"/>    {<br class="title-page-name"/>      va_list ap;<br class="title-page-name"/>      va_start(ap, fmt);<br class="title-page-name"/>      int needed = vsnprintf(nullptr, 0, fmt, ap);<br class="title-page-name"/>      va_end(ap);<br class="title-page-name"/>      std::string s(needed + 1, '\0');<br class="title-page-name"/>      va_start(ap, fmt);<br class="title-page-name"/>      vsnprintf(s.data(), s.size(), fmt, ap);<br class="title-page-name"/>      va_end(ap);<br class="title-page-name"/>      s.pop_back(); // remove the written '\0'<br class="title-page-name"/>      return s;<br class="title-page-name"/>    }</pre>
<p class="calibre2">We'll defer the discussion of the <kbd class="calibre12">scanf</kbd> format strings until the <em class="calibre22">recipes</em> portion of this chapter. For a complete treatment of <kbd class="calibre12">scanf</kbd>, consult <a href="https://cppreference.com" class="calibre4">cppreference.com</a> or a book on the C standard library.</p>
<p class="calibre2">Having seen how both buffering and formatting (at least, output formatting) work in the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> regime, we now move on to the standard C++ <kbd class="calibre12">&lt;iostream&gt;</kbd> API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The classical iostreams hierarchy</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">&lt;stdio.h&gt;</kbd> API suffers from at least three problems. First, the formatting functionality is far from type-safe. Second, the buffering functionality is awkwardly split up into "buffering into a file stream" (<kbd class="calibre12">FILE *</kbd> and <kbd class="calibre12">fprintf</kbd>) and "buffering into a character buffer" (<kbd class="calibre12">snprintf</kbd>). (Okay, technically, the GNU C library provides <kbd class="calibre12">fopencookie</kbd> to construct <kbd class="calibre12">FILE *</kbd> that buffers into anything you want; but this is fairly obscure and extremely non-standard.) Third, there is no easy way to extend the formatting functionality for user-defined classes; I cannot even <kbd class="calibre12">printf</kbd> a <kbd class="calibre12">std::string</kbd>, let alone <kbd class="calibre12">my::Widget</kbd>!</p>
<p class="calibre2">When C++ was being developed in the mid-1980s, the designers felt a need for a type-safe, composable, and extensible I/O library. Thus was born the feature known as "iostreams," or simply as "C++ streams" (not to be confused with the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> streams we just finished talking about). The fundamental architecture of iostreams has not changed since the mid-1980s, which makes it very different from anything else in the standard library with the possible exception (no pun intended) of the <kbd class="calibre12">std::exception</kbd> hierarchy.</p>
<p class="calibre2">The C++ iostreams library consists of two major pieces: <em class="calibre22">streams</em>, which are concerned with formatting, and <kbd class="calibre12">streambufs</kbd>, which are concerned with buffering. The majority of C++ programmers will never interact with streambufs; only with streams. However, let's very quickly explain what a streambuf is.</p>
<p class="calibre2">A streambuf is very similar to <kbd class="calibre12">FILE</kbd> in the C API. It tells the program where the input (in the form of raw bytes) should come from, and where the output should go to. It also maintains a buffer of bytes to reduce the number of round-trips to those destinations (such as the POSIX <kbd class="calibre12">read</kbd> and <kbd class="calibre12">write</kbd> functions). In order to allow different kinds of streambufs with the same interface--well, remember my promise that we'd see classical polymorphism in this chapter? We've finally gotten to it!</p>
<p class="calibre2"><kbd class="calibre12">std::streambuf</kbd> (which is actually an alias for <kbd class="calibre12">std::basic_streambuf&lt;char, char_traits&lt;char&gt;&gt;</kbd>, but let's not make this any more complicated) is the base class of an inheritance hierarchy whose derived classes are <kbd class="calibre12">std::filebuf</kbd> and <kbd class="calibre12">std::stringbuf</kbd>. The virtual methods provided by the <kbd class="calibre12">streambuf</kbd> interface are too many to list, but they include <kbd class="calibre12">sb.setbuf(buf, n)</kbd> (corresponding to <kbd class="calibre12">setvbuf(fp, buf, _IO_FBF, n)</kbd>), <kbd class="calibre12">sb.overflow()</kbd> (corresponding to <kbd class="calibre12">fflush(fp)</kbd>), and <kbd class="calibre12">sb.seekpos(offset, whence)</kbd> (corresponding to <kbd class="calibre12">fseek(fp, offset, whence)</kbd>). When I say corresponding, I mean corresponding for <kbd class="calibre12">std::filebuf</kbd>, of course. These methods have implementation-defined (and in practice, non-portable) behavior when called on <kbd class="calibre12">std::stringbuf</kbd>.</p>
<p class="calibre2">Any <kbd class="calibre12">streambuf</kbd> derived class must also support some primitive operations to interact with its buffer (to put in and take out bytes). These primitive operations are not for use by normal programmers, though; they're for use by the <em class="calibre22">stream</em> object that wraps this streambuf and provides a more programmer-friendly interface.</p>
<p class="calibre2">A C++ <em class="calibre22">stream</em> encapsulates a streambuf and restricts the set of operations you can do on it. For example, notice that <kbd class="calibre12">streambuf</kbd> doesn't have any conception of "access mode": you can put bytes into it ("write") as easily as you can take bytes out ("read"). However, when we take that <kbd class="calibre12">streambuf</kbd> and wrap it in a <kbd class="calibre12">std::ostream</kbd>, the <kbd class="calibre12">ostream</kbd> object exposes only a <kbd class="calibre12">write</kbd> method; there is no <kbd class="calibre12">read</kbd> method on <kbd class="calibre12">ostream</kbd>.</p>
<p class="calibre2">The following diagram expresses the class hierarchy of streams and streambufs in C++17, as defined in the standard <kbd class="calibre12">&lt;iostream&gt;</kbd>, <kbd class="calibre12">&lt;fstream&gt;</kbd>, and/or <kbd class="calibre12">&lt;sstream&gt;</kbd> <span>headers.</span> The <kbd class="calibre12">streambuf</kbd>, <kbd class="calibre12">istream</kbd>, <kbd class="calibre12">ostream</kbd>, and <kbd class="calibre12">iostream</kbd> <span>base</span> classes are "abstract-ish": while they have no pure virtual methods, they contain only the <kbd class="calibre12">streambuf*</kbd> member variable inherited from <kbd class="calibre12">ios</kbd>. To protect you from accidentally constructing instances of these "abstract-ish" types, the standard library defines their constructors as <kbd class="calibre12">protected</kbd>. Contrariwise, the classes with names containing <kbd class="calibre12">stringstream</kbd> and <kbd class="calibre12">fstream</kbd> actually contain instances of <kbd class="calibre12">stringbuf</kbd> and <kbd class="calibre12">filebuf</kbd> respectively, to which their constructors initialize the inherited <kbd class="calibre12">streambuf*</kbd> member to point. Later in this chapter, in the <em class="calibre22">Solving the sticky-manipulator problem</em> <span>section,</span> we'll see how to construct an <kbd class="calibre12">ostream</kbd> object whose <kbd class="calibre12">streambuf*</kbd> member points to a streambuf instance not owned by <kbd class="calibre12">*this</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00024.jpeg" class="calibre46"/></div>
<p class="calibre2">The stream classes expose a motley collection of methods that correspond, more or less exactly, to the functions we've seen twice before. In particular, the <kbd class="calibre12">fstream</kbd> class wraps <kbd class="calibre12">filebuf</kbd> and, together, they behave a lot like <kbd class="calibre12">FILE</kbd> from the C API: <kbd class="calibre12">filebuf</kbd> has a "cursor" that you can manipulate with the <kbd class="calibre12">seekp</kbd> method of <kbd class="calibre12"><span>fstream</span></kbd>. (The name <kbd class="calibre12">seekp</kbd> is inherited from the <kbd class="calibre12">ostream</kbd> class. On <kbd class="calibre12">ifstream</kbd>, the method is named <kbd class="calibre12">seekg</kbd>: "g" for "get" and "p" for "put." On a full <kbd class="calibre12">fstream</kbd>, you can use either <kbd class="calibre12">seekg</kbd> or <kbd class="calibre12">seekp</kbd>; they are synonyms in that case. As always, remember that there is just a single cursor, even though the iostreams API has two different <em class="calibre22">names</em> for the cursor in this case!)</p>
<p class="calibre2">The constructor of <kbd class="calibre12">fstream</kbd> takes a bitmask or'ed together from the <kbd class="calibre12">std::ios_base::in</kbd>, <kbd class="calibre12">out</kbd>, <kbd class="calibre12">app</kbd> (for "append mode"), <kbd class="calibre12">trunc</kbd>, <kbd class="calibre12">ate</kbd>, and <kbd class="calibre12">binary</kbd> <span>flag values;</span> however, just as we saw with <kbd class="calibre12">fopen</kbd>, there is only a very small dash of rhyme and reason as to how those flags are translated into POSIX <kbd class="calibre12">open</kbd> flags:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">in</kbd>: This is equivalent to <kbd class="calibre12">fopen("r")</kbd>, or POSIX <kbd class="calibre12">O_RDONLY</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">out</kbd>: This is equivalent to <kbd class="calibre12">fopen("w")</kbd>, or POSIX <kbd class="calibre12">O_WRONLY | O_CREAT | O_TRUNC</kbd>. (Notice that <kbd class="calibre12">out</kbd> alone means <kbd class="calibre12">O_TRUNC</kbd> even if <kbd class="calibre12">trunc</kbd> was not passed!)</li>
<li class="calibre15"><kbd class="calibre12">in|out</kbd>: This is equivalent to <kbd class="calibre12">fopen("r+")</kbd>, or POSIX <kbd class="calibre12">O_RDWR | O_CREAT</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">in|out|trunc</kbd>: This is equivalent to <kbd class="calibre12">fopen("w+")</kbd>, or POSIX <kbd class="calibre12">O_RDWR | O_CREAT | O_TRUNC</kbd>. (Notice that the iostreams syntax makes more sense than the <kbd class="calibre12">fopen</kbd> syntax, in this case.)</li>
<li class="calibre15"><kbd class="calibre12">out|app</kbd>: This is equivalent to <kbd class="calibre12">fopen("a")</kbd>, or POSIX <kbd class="calibre12">O_WRONLY | O_CREAT | O_APPEND</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">in|out|app</kbd>: This is equivalent to <kbd class="calibre12">fopen("a+")</kbd>, or POSIX <kbd class="calibre12">O_RDWR | O_CREAT | O_APPEND</kbd>.</li>
</ul>
<p class="calibre2">Adding <kbd class="calibre12">binary</kbd> to the bitmask is just like adding <kbd class="calibre12">"b"</kbd> to <kbd class="calibre12">fopen</kbd>. Adding <kbd class="calibre12">ate</kbd> tells the stream to begin with a seek to the end of the file, even if the file is not being opened in <kbd class="calibre12">O_APPEND</kbd> mode.</p>
<p class="calibre2">Passing an unsupported set of flags, such as <kbd class="calibre12">app|trunc</kbd>, will still construct the stream object, but place it into the "fail" state, which we'll discuss soon. In general, you should design your own classes' constructors so that failure is indicated by an exception. That rule is broken here partly because this class hierarchy was designed almost forty years ago, and partly because we need a "failure" mechanism anyway, to deal with the relatively likely possibility that the named file cannot be opened (for example, if it doesn't exist).</p>
<p class="calibre2">Putting it all together, we can rewrite our simple program from "Using the POSIX API" like this, using the <kbd class="calibre12">&lt;fstream&gt;</kbd> API to open, read, write, seek, flush, and close file streams:</p>
<pre class="calibre23">    #include &lt;cassert&gt;<br class="title-page-name"/>    #include &lt;fstream&gt;<br class="title-page-name"/>    #include &lt;string&gt;<br class="title-page-name"/><br class="title-page-name"/>    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::fstream fsw("myfile.txt", std::ios_base::out);<br class="title-page-name"/>      std::fstream fsr("myfile.txt", std::ios_base::in);<br class="title-page-name"/>      if (fsw.fail() || fsr.fail())<br class="title-page-name"/>        return EXIT_FAILURE;<br class="title-page-name"/><br class="title-page-name"/>      fsw.write("hello world", 11);<br class="title-page-name"/>      fsw.seekp(6, std::ios_base::beg);<br class="title-page-name"/>      fsw.write("neighbor", 8);<br class="title-page-name"/>      fsw.flush();<br class="title-page-name"/><br class="title-page-name"/>      std::string buffer(14, '\0');<br class="title-page-name"/>      fsr.read(buffer.data(), 14);<br class="title-page-name"/>      assert(fsr.gcount() == 14 &amp;&amp; buffer == "hello neighbor");<br class="title-page-name"/>    }</pre>
<p class="calibre2">One odd thing about the preceding example is that <kbd class="calibre12">fsr.read(buffer.data(), 14)</kbd><br class="title-page-name"/>
does not return any indication of how many bytes were read! Instead, it stores the count of bytes read in a member variable, and you must retrieve the count yourself via the accessor <kbd class="calibre12">fsr.gcount()</kbd> <span>function.</span> And the <kbd class="calibre12">write</kbd> method doesn't even allow you to find out how many bytes were written. This may seem like a problem; but, in general, if a stream encounters an error on reading or writing, the error is often essentially "unrecoverable" anyway, due to the uncertain number of bytes <em class="calibre22">actually</em> read from or written to the underlying file descriptor and due to the several layers of buffers between the application program and hardware. When a read or write error is encountered, we pretty much have to give up on understanding the state of that stream at all--<em class="calibre22">except</em> in the special case of "end of file" on input. If we intended to read 100 bytes and instead hit "end of file," it is meaningful to ask, "How many bytes did we succeed at reading?" However, if we intended to <em class="calibre22">write</em> 100 bytes and instead received a network error, or a disk error, it's not so meaningful to ask, "How many bytes did we succeed at writing?" We simply cannot tell whether our "written" bytes managed to reach their destination or not.</p>
<p class="calibre2">If we asked for 100 bytes and only read 99 (or fewer) before hitting end-of-file, then not only will <kbd class="calibre12">fs.gcount()</kbd> report a number less than 100, but also the <em class="calibre22">eof indicator</em> will be set on the stream object's state. You can ask any stream about its current state with the accessor functions <kbd class="calibre12">fs.good()</kbd> (is it hunky-dory?), <kbd class="calibre12">fs.bad()</kbd> (did the underlying stream encounter an unrecoverable error?), <kbd class="calibre12">fs.eof()</kbd> (did the last input operation hit end-of-file?), and <kbd class="calibre12">fs.fail()</kbd> (did the last operation "fail" for any reason?). Notice that <kbd class="calibre12">fs.good()</kbd> is not the inverse of <kbd class="calibre12">fs.bad()</kbd>; it is possible for a stream to be in a state, such as <em class="calibre22">eof,</em> that is, <kbd class="calibre12">!good() &amp;&amp; !bad()</kbd>.</p>
<p class="calibre2">We have now seen the simplest, most primitive way to do buffered input and output using <kbd class="calibre12">fstream</kbd> streams. However, if you're using C++ streams like this, you may as well just be using <kbd class="calibre12">FILE *</kbd>, or even the POSIX API. The "new and (arguably) improved" thing about C++ streams is the way they handle <em class="calibre22">formatting</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Streaming and manipulators</h1>
                
            
            <article>
                
<p class="calibre2">Recall that with <kbd class="calibre12">printf</kbd>, the original types of the arguments are lost, and so the format string must do double duty, encoding not only <em class="calibre22">how to format</em> each data value, but also <em class="calibre22">the type of</em> each data value. When we use iostreams, this disadvantage goes away. Formatting with iostreams looks like this:</p>
<pre class="calibre23">    int tuners = 225;<br class="title-page-name"/>    const char *where = "Chicago";<br class="title-page-name"/>    std::cout &lt;&lt; "There are " &lt;&lt; tuners &lt;&lt; " piano tuners in " &lt;&lt; where &lt;&lt; "\n";</pre>
<p class="calibre2">Here, <kbd class="calibre12">std::cout</kbd> is a global variable of type <kbd class="calibre12">ostream</kbd>, corresponding to <kbd class="calibre12">stdout</kbd> or POSIX file descriptor 1. There's also <kbd class="calibre12">std::cerr</kbd>, corresponding to unbuffered <kbd class="calibre12">stderr</kbd> or POSIX file descriptor 2; <kbd class="calibre12">std::clog</kbd>, again corresponding to file descriptor 2 but fully buffered this time; and <kbd class="calibre12">std::cin</kbd>, a global variable of type <kbd class="calibre12">istream</kbd>, corresponding to <kbd class="calibre12">stdin</kbd> or POSIX file descriptor 0.</p>
<p class="calibre2">The standard <kbd class="calibre12">ostream</kbd> class, which, again, is really <kbd class="calibre12">basic_ostream&lt;char, char_traits&lt;char&gt;&gt;</kbd>, but let's ignore that) has many, many non-member overloads of <kbd class="calibre12">operator&lt;&lt;</kbd>. For example, here's the simplest possible overloaded <kbd class="calibre12">operator&lt;&lt;</kbd>:</p>
<pre class="calibre23">    namespace std {<br class="title-page-name"/>      ostream&amp; operator&lt;&lt; (ostream&amp; os, const string&amp; s)<br class="title-page-name"/>      {<br class="title-page-name"/>        os.write(s.data(), s.size());<br class="title-page-name"/>        return os;<br class="title-page-name"/>      }<br class="title-page-name"/>    } // namespace std</pre>
<p class="calibre2">As this function returns a reference to the same <kbd class="calibre12">os</kbd> it received, we can chain the <kbd class="calibre12">&lt;&lt;</kbd> operators together, as shown in the previous example. This allows us to format complicated messages.</p>
<p class="calibre2">Unfortunately, our simple <kbd class="calibre12">operator&lt;&lt;(ostream&amp;, const string&amp;)</kbd> is not nearly sufficient to satisfy the variety of formatting concerns described in the <em class="calibre22">Formatting with printf and snprintf</em> <span>section</span>. Suppose we wanted to print that left-aligned <span>string</span> in a column of width 7; how would we do that? The <kbd class="calibre12">operator&lt;&lt;</kbd> syntax doesn't allow us to pass any additional "formatting option" parameters, which means that we simply <em class="calibre22">cannot</em> do complicated formatting unless the formatting options are carried along in either the left-hand side of <kbd class="calibre12">&lt;&lt;</kbd> (the ostream object itself) or the right-hand side (the object to be formatted). The standard library uses a mix of both approaches. Generally, functionality that first appeared in the 1980s and 1990s carried its formatting options in the ostream object itself; and anything added later--not being able to add new member variables to <kbd class="calibre12">ostream</kbd> without breaking binary compatibility--has had to make do by fiddling with the right-hand side of the <kbd class="calibre12">&lt;&lt;</kbd> operator. Let's look at alignment within a column, as an example of the 1980s approach. This is a slightly more full-featured version of our <kbd class="calibre12">operator&lt;&lt;</kbd> for <kbd class="calibre12">std::string</kbd>:</p>
<pre class="calibre23">    void pad(std::ostream&amp; os, size_t from, size_t to)<br class="title-page-name"/>    {<br class="title-page-name"/>      char ch = os.fill();<br class="title-page-name"/>      for (auto i = from; i &lt; to; ++i) {<br class="title-page-name"/>        os.write(&amp;ch, 1);<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/> <br class="title-page-name"/>    std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const std::string&amp; s)<br class="title-page-name"/>    {<br class="title-page-name"/>      auto column_width = os.width();<br class="title-page-name"/>      auto padding = os.flags() &amp; std::ios_base::adjustfield;<br class="title-page-name"/><br class="title-page-name"/>      if (padding == std::ios_base::right) {<br class="title-page-name"/>        pad(os, s.size(), column_width);<br class="title-page-name"/>      }<br class="title-page-name"/>      os.write(s.data(), s.size());<br class="title-page-name"/>      if (padding == std::ios_base::left) {<br class="title-page-name"/>        pad(os, s.size(), column_width);<br class="title-page-name"/>      }<br class="title-page-name"/>      os.width(0); // reset "column width" to 0<br class="title-page-name"/>      return os;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Here, <kbd class="calibre12">os.width()</kbd>, <kbd class="calibre12">os.flags()</kbd>, and <kbd class="calibre12">os.fill()</kbd> are all built-in members of<br class="title-page-name"/>
the <kbd class="calibre12">std::ostream</kbd> class. There's also <kbd class="calibre12">os.precision()</kbd> for floating-point numbers,<br class="title-page-name"/>
and <kbd class="calibre12">os.flags()</kbd> can indicate the base-10, base-16, or base-8 output for some numeric types as well. You can set the "column width" state on a stream by calling <kbd class="calibre12">os.width(n)</kbd>; however, it would be quite painful (and silly!) if we had to set up by writing <kbd class="calibre12">std::cout.width(10)</kbd>, <kbd class="calibre12">std::cout.setfill('.')</kbd>, and so on, before each output operation. So, the iostreams library provides some standard <em class="calibre22">stream manipulators</em> that can be used to get the effect of these member functions but in a more "fluent" manner. These manipulators are generally defined in a standard header, <kbd class="calibre12">&lt;iomanip&gt;</kbd>, not in <kbd class="calibre12">&lt;iostream&gt;</kbd> proper. For example, here's a manipulator that sets the column width of a stream:</p>
<pre class="calibre23">    struct WidthSetter { int n; };<br class="title-page-name"/><br class="title-page-name"/>    auto&amp; operator&lt;&lt; (std::ostream&amp; os, WidthSetter w)<br class="title-page-name"/>    {<br class="title-page-name"/>      os.width(w.n);<br class="title-page-name"/>      return os;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    auto setw(int n) { return WidthSetter{n}; }</pre>
<p class="calibre2">And here are two more standard manipulators, one of which should look very familiar to you by now. The <kbd class="calibre12">std::endl</kbd> <span>manipulator</span> streams a newline to the output stream and then flushes it:</p>
<pre class="calibre23">    using Manip = std::ostream&amp; (*)(std::ostream&amp;);<br class="title-page-name"/><br class="title-page-name"/>    auto&amp; operator&lt;&lt; (std::ostream&amp; os, Manip f) {<br class="title-page-name"/>      return f(os);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    std::ostream&amp; flush(std::ostream&amp; os) {<br class="title-page-name"/>      return os.flush();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    std::ostream&amp; endl(std::ostream&amp; os) {<br class="title-page-name"/>      return os &lt;&lt; '\n' &lt;&lt; flush; <br class="title-page-name"/>    }</pre>
<p class="calibre2">Once we have <kbd class="calibre12">std::setw</kbd>; its friends, <kbd class="calibre12">std::left</kbd>, <kbd class="calibre12">std::right</kbd>, <kbd class="calibre12">std::hex</kbd>, <kbd class="calibre12">std::dec</kbd>, <kbd class="calibre12">std::oct</kbd>, <kbd class="calibre12">std::setfill</kbd>, and <kbd class="calibre12">std::precision</kbd>; and all the rest--I say once we have all these manipulators--, we can write iostreams code that looks almost natural, if extremely verbose. Compare these <kbd class="calibre12">&lt;stdio.h&gt;</kbd> and <kbd class="calibre12">&lt;iostream&gt;</kbd> snippets:</p>
<pre class="calibre23">    printf("%-10s.%6x\n", where, tuners);<br class="title-page-name"/>      // "Chicago . e1"<br class="title-page-name"/><br class="title-page-name"/>    std::cout &lt;&lt; std::setw(8) &lt;&lt; std::left &lt;&lt; where &lt;&lt; "."<br class="title-page-name"/>              &lt;&lt; std::setw(4) &lt;&lt; std::right &lt;&lt; std::hex<br class="title-page-name"/>              &lt;&lt; tuners &lt;&lt; "\n";<br class="title-page-name"/>      // "Chicago . e1"</pre>
<p class="calibre2">Bear in mind that every time we use one of these manipulators, we are imperatively affecting the state of the stream object itself; this effect may persist for longer than just the current output statement. For example, our preceding snippet may continue like this:</p>
<pre class="calibre23">    printf("%d\n", 42); // "42"<br class="title-page-name"/><br class="title-page-name"/>    std::cout &lt;&lt; 42 &lt;&lt; "\n"; // "2a" -- oops!</pre>
<p class="calibre2">The <kbd class="calibre12">std::hex</kbd> manipulator from the previous example set the mode of this stream to "hexadecimal output for numbers," and nothing ever set it back to the "default" decimal mode. So now we've unintentionally made everything later in the program also print in hex! This is a major disadvantage of the iostreams library (and of stateful, imperative programming in general).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Streaming and wrappers</h1>
                
            
            <article>
                
<p class="calibre2">The parameters provided by <kbd class="calibre12">std::ios_base</kbd> (<kbd class="calibre12">left</kbd>, <kbd class="calibre12">right</kbd>, <kbd class="calibre12">hex</kbd>, <kbd class="calibre12">width</kbd>, <kbd class="calibre12">precision</kbd>, and so on) are a closed set--a set defined in the mid-1980s and basically untouched since then. Since each manipulator modifies one of these parameters in the state of the stream, the set of manipulators is essentially closed as well. The modern way to affect the formatting of a particular data value is to wrap it in a <em class="calibre22">wrapper</em>. For example, suppose that we have written a generic algorithm for quoting values in a data file:</p>
<pre class="calibre23">    template&lt;class InputIt, class OutputIt&gt;<br class="title-page-name"/>    OutputIt do_quote(InputIt begin, InputIt end,<br class="title-page-name"/>      OutputIt dest)<br class="title-page-name"/>    {<br class="title-page-name"/>      *dest++ = '"';<br class="title-page-name"/>      while (begin != end) {<br class="title-page-name"/>        auto ch = *begin++;<br class="title-page-name"/>        if (ch == '"') {<br class="title-page-name"/>            *dest++ = '\\';<br class="title-page-name"/>        }<br class="title-page-name"/>        *dest++ = ch;<br class="title-page-name"/>      }<br class="title-page-name"/>      *dest++ = '"';<br class="title-page-name"/>      return dest;<br class="title-page-name"/>    }</pre>
<p class="calibre2">(This algorithm is not part of the standard library.) Having this algorithm in hand, we could easily construct a wrapper class, where the wrapper class' <kbd class="calibre12">operator&lt;&lt;</kbd> would invoke the following algorithm:</p>
<pre class="calibre23">    struct quoted {<br class="title-page-name"/>      std::string_view m_view;<br class="title-page-name"/>      quoted(const char *s) : m_view(s) {}<br class="title-page-name"/>      quoted(const std::string&amp; s) : m_view(s) {}<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const quoted&amp; q)<br class="title-page-name"/>    {<br class="title-page-name"/>      do_quote(<br class="title-page-name"/>        q.m_view.begin(),<br class="title-page-name"/>        q.m_view.end(),<br class="title-page-name"/>        std::ostreambuf_iterator&lt;char&gt;(os)<br class="title-page-name"/>      );<br class="title-page-name"/>      return os;<br class="title-page-name"/>    }</pre>
<p class="calibre2">(The <kbd class="calibre12">std::ostreambuf_iterator&lt;char&gt;</kbd> type is part of the standard library; it comes from the <kbd class="calibre12">&lt;iterator&gt;</kbd> header. We'll see its friend, <kbd class="calibre12">istream_iterator</kbd>, later in this chapter.) Then, having the wrapper class, we'd be able to write very reasonable-looking code to print quoted values to an output stream:</p>
<pre class="calibre23">    std::cout &lt;&lt; quoted("I said \"hello\".");</pre>
<p class="calibre2">The wrapper we just invented bears a deliberate resemblance to the <kbd class="calibre12">std::quoted</kbd> wrapper function found in the standard library's <kbd class="calibre12">&lt;iomanip&gt;</kbd> header. The major difference is that <kbd class="calibre12">std::quoted</kbd> doesn't use an iterator-based algorithm to produce its output; it constructs the entire output in a local <kbd class="calibre12">std::string</kbd> variable and then uses <kbd class="calibre12">os &lt;&lt; str</kbd> to print it out in one fell swoop. This means that <kbd class="calibre12">std::quoted</kbd> is <em class="calibre22">not allocator-aware</em> (see <a href="part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 8</a>, <em class="calibre22">Allocators</em>) and thus is not suitable for environments where heap allocation is forbidden. While the fine details may have been botched in this case,<br class="title-page-name"/>
the fundamental idea of using a wrapper function or class to adjust the formatting of a data value is a good one. You can see it taken to extremes in libraries like Boost.Format, where syntax like the following is legal:</p>
<pre class="calibre23">    std::cout &lt;&lt; boost::format("There are %d piano tuners in %s.") % tuners % where<br class="title-page-name"/>              &lt;&lt; std::endl;</pre>
<p class="calibre2">Prefer to use wrappers that describe self-contained formatting operations instead of manipulators, which "stickily" mutate the state of the stream. In the preceding code, we saw how an ill-placed <kbd class="calibre12">std::hex</kbd> can put a curse on everyone "downstream." Now, we'll look at two ways to solve that problem--and two new problems that crop up in its place!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Solving the sticky-manipulator problem</h1>
                
            
            <article>
                
<p class="calibre2">Our "sticky <kbd class="calibre12">std::hex</kbd>" problem can be solved by saving and restoring the state of the<br class="title-page-name"/>
ostream around each complicated output operation, or by creating a brand-new ostream each time we want to output something. An example of the former is as follows:</p>
<pre class="calibre23">    void test() {<br class="title-page-name"/>      std::ios old_state(nullptr);<br class="title-page-name"/>      old_state.copyfmt(std::cout);<br class="title-page-name"/>        std::cout &lt;&lt; std::hex &lt;&lt; 225; // "e1"<br class="title-page-name"/>      std::cout.copyfmt(old_state);<br class="title-page-name"/><br class="title-page-name"/>      std::cout &lt;&lt; 42; // "42"<br class="title-page-name"/>    }</pre>
<p class="calibre2">An example of the latter is as follows:</p>
<pre class="calibre23">    void test() {<br class="title-page-name"/>      std::ostream os(std::cout.rdbuf());<br class="title-page-name"/>      os &lt;&lt; std::hex &lt;&lt; 225; // "e1"<br class="title-page-name"/><br class="title-page-name"/>      std::cout &lt;&lt; 42; // "42"<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice how convenient it is that the iostreams library separates the idea of a "streambuf" from the idea of a "stream"; in the preceding example, we easily strip all the formatting-related fields away from a stream by extracting just its streambuf: <kbd class="calibre12">std::cout.rdbuf()</kbd>) and then layer a brand new stream (with its own formatting-related fields) on top of that same streambuf.</p>
<p class="calibre2">However, iostreams formatting has another major disadvantage. Each piece of our intended message is output "eagerly" as soon as its respective <kbd class="calibre12">operator&lt;&lt;</kbd> is reached--or, if you prefer, each piece of our intended message is computed "lazily" only when its respective <kbd class="calibre12">operator&lt;&lt;</kbd> is reached--so that we have the following piece of code:</p>
<pre class="calibre23">    void test() {<br class="title-page-name"/>      try {<br class="title-page-name"/>        std::cout &lt;&lt; "There are "<br class="title-page-name"/>                  &lt;&lt; computation_that_may_throw()<br class="title-page-name"/>                  &lt;&lt; "piano tuners here.\n";<br class="title-page-name"/>      } catch (...) {<br class="title-page-name"/>        std::cout &lt;&lt; "An exception was thrown";<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">We'll see the output <kbd class="calibre12">There are An exception was thrown</kbd> for the preceding piece of code.</p>
<p class="calibre2">Also, iostreams formatting is <em class="calibre22">intensely</em> disagreeable to internationalization ("i18n"), because the "shape" of the overall message is never present in the source code. Instead of a single string literal <kbd class="calibre12">"There are %d piano tuners here.\n"</kbd> representing a complete thought, which could be translated by a human and stored in an external file of translated messages; we have two sentence fragments: <kbd class="calibre12">"There are "</kbd> and <kbd class="calibre12">"piano tuners here.\n"</kbd>, neither of which can be translated in isolation.</p>
<p class="calibre2">For all these reasons, I strongly discourage you from attempting to use iostreams as the <em class="calibre22">foundation</em> of your codebase. Using <kbd class="calibre12">&lt;stdio.h&gt;</kbd> or a third-party library such as <kbd class="calibre12">fmt</kbd> for formatting is preferable. Boost.Format is also a possibility, although it tends to have very long compile times and poor runtime performance compared to either of the other two options. If you find yourself typing <kbd class="calibre12">&lt;&lt;</kbd>, <kbd class="calibre12">std::hex</kbd>, or <kbd class="calibre12">os.rdbuf()</kbd> more than once or twice a week, you're doing something wrong.</p>
<p class="calibre2">Yet the iostreams library still has some usable and even useful features! Let's look at one of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Formatting with ostringstream</h1>
                
            
            <article>
                
<p class="calibre2">So far, we've been talking mostly about <kbd class="calibre12">fstream</kbd>, which roughly corresponds to the <kbd class="calibre12">fprintf</kbd> and <kbd class="calibre12">vfprintf</kbd> <span>formatting functions</span> in the C API. There is also <kbd class="calibre12">stringstream</kbd>, which corresponds to <kbd class="calibre12">snprintf</kbd> and <kbd class="calibre12">vsnprintf</kbd>.</p>
<p class="calibre2">An <kbd class="calibre12">ostringstream</kbd> is just like <kbd class="calibre12">ostream</kbd>, exposing all the usual <kbd class="calibre12">operator&lt;&lt;</kbd> functionality; however, it is backed by <kbd class="calibre12">stringbuf</kbd> that writes not to a file descriptor but to a resizable character buffer--in practice, <kbd class="calibre12">std::string</kbd>! You can use the <kbd class="calibre12">oss.str()</kbd> <span>method</span> to get a copy of this string for your own use. This leads to the following idiom for, for example, "stringifying" an object of any type <kbd class="calibre12">T</kbd>:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    std::string to_string(T&amp;&amp; t)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::ostringstream oss;<br class="title-page-name"/>      oss &lt;&lt; std::forward&lt;T&gt;(t);<br class="title-page-name"/>      return oss.str();<br class="title-page-name"/>    }</pre>
<p class="calibre2">In C++17, you may even consider a multi-argument version of <kbd class="calibre12">to_string</kbd>:</p>
<pre class="calibre23">    template&lt;class... Ts&gt;<br class="title-page-name"/>    std::string to_string(Ts&amp;&amp;... ts)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::ostringstream oss;<br class="title-page-name"/>      (oss &lt;&lt; ... &lt;&lt; std::forward&lt;Ts&gt;(ts));<br class="title-page-name"/>      return oss.str();<br class="title-page-name"/>    }</pre>
<p class="calibre2">With this version, a call such as <kbd class="calibre12">to_string(a, " ", b)</kbd> or <kbd class="calibre12">to_string(std::hex, 42)</kbd> will have the appropriate semantics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A note on locales</h1>
                
            
            <article>
                
<p class="calibre2">There is still a pernicious pitfall to beware any time you use either <kbd class="calibre12">printf</kbd> or <kbd class="calibre12">ostream</kbd> for string formatting (or string parsing). That pitfall is <em class="calibre22">locales</em>. A full treatment of locales is out of the scope of this book; however, in short, the <em class="calibre22">locale</em> is "the subset of a user's environment that depends on language and cultural conventions." Locale information is exposed programmatically via the operating system, allowing a single program to adjust its behavior depending on the current user's preferred locale, for example, to control whether "á" is considered an alphabetic character, whether the week begins with Sunday or Monday, whether dates print as "23-01-2017" or "01-23-2017", and whether floating-point numbers print as "1234.56" or "1.234,56". Now, a programmer from the 21st century may look at all of those examples and say, "This is crazy! You mean, not one of these things is specified by a <em class="calibre22">standard</em>? It seems like this situation would inevitably lead to subtle and painful bugs!" And you'd be correct!</p>
<pre class="calibre23">    std::setlocale(LC_ALL, "C.UTF-8");<br class="title-page-name"/>    std::locale::global(std::locale("C.UTF-8"));<br class="title-page-name"/><br class="title-page-name"/>    auto json = to_string('[', 3.14, ']');<br class="title-page-name"/>    assert(json == "[3.14]"); // Success!<br class="title-page-name"/><br class="title-page-name"/>    std::setlocale(LC_ALL, "en_DK.UTF-8");<br class="title-page-name"/>    std::locale::global(std::locale("en_DK.UTF-8"));<br class="title-page-name"/><br class="title-page-name"/>    json = to_string('[', 3.14, ']');<br class="title-page-name"/>    assert(json == "[3,14]"); // Silent, abject failure!</pre>
<p class="calibre2">By changing the <em class="calibre22">global locale</em> to <kbd class="calibre12">"en_DK.UTF-8"</kbd>, we've made it so that none of our JSON printing works anymore. Woe betide the hapless user who attempts to run a web server or a database in any locale other than <kbd class="calibre12">"C.UTF-8"</kbd>!</p>
<p class="calibre2">Besides the correctness costs of locale-specific programming, we must also contend with the performance costs. Notice that "current locale" is a <em class="calibre22">global variable</em>, which means that every access to it must be guarded by either an atomic access or--worse--a global mutex lock. And, every call to <kbd class="calibre12">snprintf</kbd> or <kbd class="calibre12">operator&lt;&lt;(ostream&amp;, double)</kbd> must access the current locale. This is a horrendous performance cost, and, in certain scenarios, can actually be the performance bottleneck in multi-threaded code.</p>
<p class="calibre2">As an application programmer, for applications above a certain level of complexity, you should get in the habit of writing <kbd class="calibre12">std::locale::global(std::locale("C"))</kbd> as the first line of <kbd class="calibre12">main()</kbd>. (If you write only <kbd class="calibre12">setlocale(LC_ALL, "C")</kbd>, as you would in a C program, you'll make <kbd class="calibre12">&lt;stdio.h&gt;</kbd> work correctly but not affect the locale used by <kbd class="calibre12">&lt;iostream&gt;</kbd>. In other words, setting the C++ library's "global locale" also modifies the C library's "global locale," but not vice versa.)</p>
<div class="packt_tip">If you don't even trust your users to be using UTF-8, perhaps prefer the locale name <kbd class="calibre25">"C.UTF-8"</kbd> instead of just <kbd class="calibre25">"C"</kbd>; however, be aware that the name <kbd class="calibre25">"C.UTF-8"</kbd> has been around only since about 2015, and may not be available on older systems. In fact, the availability of <em class="calibre29">any</em> locale other than <kbd class="calibre25">"C"</kbd> depends on the user. Locales are similar to time zones in this way: there is only one locale and one timezone that is <em class="calibre29">guaranteed</em> to be available on any platform in the world, and not coincidentally, it's the one you should always be using.</div>
<p class="calibre2">As a programmer of third-party libraries, you have two possible paths. The easier path is to assume that your library will only ever be used in applications that have set their global locale to <kbd class="calibre12">"C"</kbd>, and so you don't need to worry about locales; go ahead and use <kbd class="calibre12">snprintf</kbd> and <kbd class="calibre12">operator&lt;&lt;</kbd> to your heart's content. (However, notice that this does not solve the performance problem associated with locale-aware programming. That global mutex lock will still be there, taking up valuable cycles.) The harder path--harder because it requires conscientious adherence to a subtle guideline--is to avoid all use of locale-aware formatting functions. This path has only really become feasible as of C++17, with some of the very newest library facilities, to which we will turn now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting numbers to strings</h1>
                
            
            <article>
                
<p class="calibre2">Consider the following declarations:</p>
<pre class="calibre23">    std::ostringstream oss;<br class="title-page-name"/>    std::string str;<br class="title-page-name"/>    char buffer[100];<br class="title-page-name"/>    int intvalue = 42;<br class="title-page-name"/>    float floatvalue = 3.14;<br class="title-page-name"/>    std::to_chars_result r;</pre>
<p class="calibre2">To convert the <kbd class="calibre12">intvalue</kbd> <span>integer</span> to a string of digits, C++17 offers us the following options:</p>
<pre class="calibre23">    snprintf(buffer, sizeof buffer, "%d", intvalue);<br class="title-page-name"/>      // available in &lt;stdio.h&gt;<br class="title-page-name"/>      // locale-independent (%d is unaffected by locales)<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // bases 8, 10, 16 only<br class="title-page-name"/><br class="title-page-name"/>    oss &lt;&lt; intvalue;<br class="title-page-name"/>    str = oss.str();<br class="title-page-name"/>      // available in &lt;sstream&gt;<br class="title-page-name"/>      // locale-problematic (thousands separator may be inserted)<br class="title-page-name"/>      // allocating; allocator-aware<br class="title-page-name"/>      // bases 8, 10, 16 only<br class="title-page-name"/><br class="title-page-name"/>    str = std::to_string(intvalue);<br class="title-page-name"/>      // available since C++11 in &lt;string&gt;<br class="title-page-name"/>      // locale-independent (equivalent to %d)<br class="title-page-name"/>      // allocating; NOT allocator-aware<br class="title-page-name"/>      // base 10 only<br class="title-page-name"/><br class="title-page-name"/>    r = std::to_chars(buffer, std::end(buffer), intvalue, 10);<br class="title-page-name"/>    *r.ptr = '\0';<br class="title-page-name"/>      // available since C++17 in &lt;charconv&gt;<br class="title-page-name"/>      // locale-independent by design<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // bases 2 through 36</pre>
<p class="calibre2">All four alternatives have their advantages. The main advantage of <kbd class="calibre12">std::to_string</kbd> is that it is conveniently composable into larger messages in a high-level code:</p>
<pre class="calibre23">    std::string response =<br class="title-page-name"/>      "Content-Length: " + std::to_string(body.size()) + "\r\n" +<br class="title-page-name"/>      "\r\n" +<br class="title-page-name"/>      body;</pre>
<p class="calibre2">The main advantages of <kbd class="calibre12">std::to_chars</kbd> are that it is locale-independent and that it can easily be composed in low-level code:</p>
<pre class="calibre23">    char *write_string(char *p, char *end, const char *from)  <br class="title-page-name"/>    {<br class="title-page-name"/>      while (p != end &amp;&amp; *from != '\0') *p++ = *from++;<br class="title-page-name"/>      return p;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    char *write_response_headers(char *p, char *end, std::string body)<br class="title-page-name"/>    {<br class="title-page-name"/>      p = write_string(p, end, "Content-Length: ");<br class="title-page-name"/>      p = std::to_chars(p, end, body.size(), 10).ptr;<br class="title-page-name"/>      p = write_string(p, end, "\r\n\r\n");<br class="title-page-name"/>      return p;<br class="title-page-name"/>    }</pre>
<p class="calibre2">The main disadvantage of <kbd class="calibre12">std::to_chars</kbd> is that it is a very new feature of C++17; as of this writing, the <kbd class="calibre12">&lt;charconv&gt;</kbd> header is not present in any major implementation of the standard library.</p>
<p class="calibre2">To convert the floating-point <kbd class="calibre12">floatvalue</kbd> <span>number</span> to a string of digits, C++17 offers us the following options:</p>
<pre class="calibre23">    snprintf(buffer, sizeof buffer, "%.6e", floatvalue);<br class="title-page-name"/>    snprintf(buffer, sizeof buffer, "%.6f", floatvalue);<br class="title-page-name"/>    snprintf(buffer, sizeof buffer, "%.6g", floatvalue);<br class="title-page-name"/>      // available in &lt;stdio.h&gt;<br class="title-page-name"/>      // locale-problematic (decimal point)<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/><br class="title-page-name"/>    oss &lt;&lt; floatvalue;<br class="title-page-name"/>    str = oss.str();<br class="title-page-name"/>      // available in &lt;sstream&gt;<br class="title-page-name"/>      // locale-problematic (decimal point)<br class="title-page-name"/>      // allocating; allocator-aware<br class="title-page-name"/><br class="title-page-name"/>    str = std::to_string(floatvalue);<br class="title-page-name"/>      // available since C++11 in &lt;string&gt;<br class="title-page-name"/>      // locale-problematic (equivalent to %f)<br class="title-page-name"/>      // allocating; NOT allocator-aware<br class="title-page-name"/>      // no way to adjust the formatting<br class="title-page-name"/><br class="title-page-name"/>    r = std::to_chars(buffer, std::end(buffer), floatvalue,<br class="title-page-name"/>                      std::chars_format::scientific, 6);<br class="title-page-name"/>    r = std::to_chars(buffer, std::end(buffer), floatvalue,<br class="title-page-name"/>                      std::chars_format::fixed, 6);<br class="title-page-name"/>    r = std::to_chars(buffer, std::end(buffer), floatvalue,<br class="title-page-name"/>                      std::chars_format::general, 6);<br class="title-page-name"/>    *r.ptr = '\0';<br class="title-page-name"/>      // available since C++17 in &lt;charconv&gt;<br class="title-page-name"/>      // locale-independent by design<br class="title-page-name"/>      // non-allocating</pre>
<p class="calibre2">Notice that when printing the floating-point, every method except <kbd class="calibre12">std::to_string</kbd> offers the possibility of adjusting the formatting; and every method except <kbd class="calibre12">std::to_chars</kbd> is locale-aware and thus problematic in a portable code. All of these methods are available for the <kbd class="calibre12">double</kbd> and <kbd class="calibre12">long double</kbd> data types, as well as for <kbd class="calibre12">float</kbd>. In any case, the same respective advantages and disadvantages apply for integer formatting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting strings to numbers</h1>
                
            
            <article>
                
<p class="calibre2">The reverse problem of formatting numbers for output is <em class="calibre22">parsing</em> numbers from the user's input. Parsing is intrinsically much more subtle and difficult than formatting, because we must account for the possibility of error. Every number can plausibly be turned into a string of digits, but not every string (or even every string of digits!) can plausibly be turned into a number. So, any function that purports to parse numbers must have some way of dealing with strings that do not represent valid numbers.</p>
<p class="calibre2">Consider the following declarations:</p>
<pre class="calibre23">    std::istringstream iss;<br class="title-page-name"/>    std::string str = "42";<br class="title-page-name"/>    char buffer[] = "42";<br class="title-page-name"/>    int intvalue;<br class="title-page-name"/>    float floatvalue;<br class="title-page-name"/>    int rc;<br class="title-page-name"/>    char *endptr;<br class="title-page-name"/>    size_t endidx;<br class="title-page-name"/>    std::from_chars_result r;</pre>
<p class="calibre2">To convert the string in <kbd class="calibre12">buffer</kbd> or <kbd class="calibre12">str</kbd> to an <kbd class="calibre12">intvalue</kbd> <span>integer,</span> C++17 offers us the following options:</p>
<pre class="calibre23">    intvalue = strtol(buffer, &amp;endptr, 10);<br class="title-page-name"/>      // saturates on overflow<br class="title-page-name"/>      // sets global "errno" on most errors<br class="title-page-name"/>      // sets endptr==buffer when input cannot be parsed<br class="title-page-name"/>      // available in &lt;stdlib.h&gt;<br class="title-page-name"/>      // locale-problematic, in theory<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // bases 0 and 2 through 36<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/>      // skips leading 0x for base 16<br class="title-page-name"/>      // recognizes upper and lower case<br class="title-page-name"/><br class="title-page-name"/>    rc = sscanf(buffer, "%d", &amp;intvalue);<br class="title-page-name"/>      // fails to detect overflow<br class="title-page-name"/>      // returns 0 (instead of 1) when input cannot be parsed<br class="title-page-name"/>      // available in &lt;stdio.h&gt;<br class="title-page-name"/>      // locale-problematic (equivalent to strtol)<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // bases 0, 8, 10, 16 only<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/>      // skips leading 0x for base 16<br class="title-page-name"/>      // recognizes upper and lower case<br class="title-page-name"/><br class="title-page-name"/>    intvalue = std::stoi(str, &amp;endidx, 10);<br class="title-page-name"/>      // throws on overflow or error<br class="title-page-name"/>      // available since C++11 in &lt;string&gt;<br class="title-page-name"/>      // locale-problematic (equivalent to strtol)<br class="title-page-name"/>      // NOT allocator-aware<br class="title-page-name"/>      // bases 0 and 2 through 36<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/>      // skips leading 0x for base 16<br class="title-page-name"/>      // recognizes upper and lower case<br class="title-page-name"/><br class="title-page-name"/>    iss.str("42");<br class="title-page-name"/>    iss &gt;&gt; intvalue;<br class="title-page-name"/>      // saturates on overflow<br class="title-page-name"/>      // sets iss.fail() on any error<br class="title-page-name"/>      // available in &lt;sstream&gt;<br class="title-page-name"/>      // locale-problematic<br class="title-page-name"/>      // allocating; allocator-aware<br class="title-page-name"/>      // bases 8, 10, 16 only<br class="title-page-name"/>      // skips leading 0x for base 16<br class="title-page-name"/>      // skips whitespace by default<br class="title-page-name"/><br class="title-page-name"/>    r = std::from_chars(buffer, buffer + 2, intvalue, 10);<br class="title-page-name"/>      // sets r.ec != 0 on any error<br class="title-page-name"/>      // available since C++17 in &lt;charconv&gt;<br class="title-page-name"/>      // locale-independent by design<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // bases 2 through 36<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/>      // recognizes lower case only</pre>
<p class="calibre2">There are more parsing methods here than there were formatting methods in the previous section; this is because the C standard library alone offers us three different methods: <kbd class="calibre12">atoi</kbd>, the oldest method, and the only one whose behavior on invalid input is <em class="calibre22">literally undefined</em>, so avoid it in production code; <kbd class="calibre12">strtol</kbd>, the standard replacement for <kbd class="calibre12">atoi</kbd>, it communicates overflow errors via the global variable <kbd class="calibre12">errno</kbd>, which may be inappropriate for threaded or high-performance code); and <kbd class="calibre12">sscanf</kbd>, a function in the same family as <kbd class="calibre12">snprintf</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::stoi</kbd> is a very good replacement for <kbd class="calibre12">atoi</kbd> in one-off parsing of user input, and a very bad option for high-performance work. It does a very good job of detecting errors--<kbd class="calibre12">std::stoi("2147483648")</kbd> throws <kbd class="calibre12">std::out_of_range</kbd> and <kbd class="calibre12">std::stoi("abc")</kbd> throws <kbd class="calibre12">std::invalid_argument</kbd>. (And, although <kbd class="calibre12">std::stoi("42abc")</kbd> returns 42 without complaint, the <kbd class="calibre12">std::stoi("42abc", &amp;endidx)</kbd> <span>invocation</span> will set <kbd class="calibre12">endidx</kbd> to 2 instead of 5, indicating that something may be amiss.) The major disadvantage of <kbd class="calibre12">std::stoi</kbd> is that it works only on the exact type <kbd class="calibre12">std::string</kbd>--there is no overload of <kbd class="calibre12">std::stoi</kbd> for <kbd class="calibre12">string_view</kbd>, no overload for <kbd class="calibre12">std::pmr::string</kbd>, and <em class="calibre22">certainly</em> no overload for <kbd class="calibre12">const char *</kbd>!</p>
<p class="calibre2"><kbd class="calibre12">std::from_chars</kbd> is the most modern and performant option to parse integers. Its main advantage is that unlike any of the other contenders, <kbd class="calibre12">from_chars</kbd> does not require its input buffer to be null-terminated--it takes a pair of <kbd class="calibre12">begin, end</kbd> <span>pointers</span> to indicate the range of characters to be parsed, and will never read past <kbd class="calibre12">end</kbd>. It still has some unfortunate limitations--for example, it cannot be taught not to skip whitespace, nor can it be taught to parse uppercase hexadecimal input. The idiom to test <kbd class="calibre12">r.ec</kbd> for error is shown near the beginning of <a href="part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 12</a>, <em class="calibre22">Filesystem</em>.</p>
<p class="calibre2">The <kbd class="calibre12">strtol</kbd>, <kbd class="calibre12">sscanf</kbd>, and <kbd class="calibre12">stoi</kbd> <span>functions</span> indicate that they recognize "base 0." This is a special-case syntax in the library, where passing a base of <kbd class="calibre12">0</kbd> (or, in the case of <kbd class="calibre12">sscanf</kbd>, a format specifier of <kbd class="calibre12">"%i"</kbd>) tells the library to parse the input as if it were a C integer literal: <kbd class="calibre12">0123</kbd> will parse as the octal representation of decimal 83, <kbd class="calibre12">0x123</kbd> will parse as the hexadecimal representation of 291, and <kbd class="calibre12">019</kbd> will parse as the octal representation of the integer 1, with the character <kbd class="calibre12">9</kbd> left unparsed because it is not a valid octal. "Base 0" is never an appropriate behavior for a computer program, and <kbd class="calibre12">from_chars</kbd> wisely chucks it to the trash can, where it belongs.</p>
<p class="calibre2">To convert a string to a floating-point <kbd class="calibre12">floatvalue</kbd>, C++17 offers the following options:</p>
<pre class="calibre23">    floatvalue = strtof(buffer, &amp;endptr);<br class="title-page-name"/>      // saturates on overflow<br class="title-page-name"/>      // sets global "errno" on most errors<br class="title-page-name"/>      // sets endptr==buffer when input cannot be parsed<br class="title-page-name"/>      // available in &lt;stdlib.h&gt;<br class="title-page-name"/>      // locale-problematic<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // base 10 or 16, auto-detected<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/><br class="title-page-name"/>    rc = sscanf(buffer, "%f", &amp;floatvalue);<br class="title-page-name"/>      // fails to detect overflow<br class="title-page-name"/>      // returns 0 (instead of 1) when input cannot be parsed<br class="title-page-name"/>      // available in &lt;stdio.h&gt;<br class="title-page-name"/>      // locale-problematic (equivalent to strtof)<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // base 10 or 16, auto-detected<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/><br class="title-page-name"/>    floatvalue = std::stof(str, &amp;endidx);<br class="title-page-name"/>      // throws on overflow or error<br class="title-page-name"/>      // available since C++11 in &lt;string&gt;<br class="title-page-name"/>      // locale-problematic (equivalent to strtol)<br class="title-page-name"/>      // NOT allocator-aware<br class="title-page-name"/>      // base 10 or 16, auto-detected<br class="title-page-name"/>      // always skips leading whitespace<br class="title-page-name"/><br class="title-page-name"/>    iss.str("3.14");<br class="title-page-name"/>    iss &gt;&gt; floatvalue;<br class="title-page-name"/>      // saturates on overflow<br class="title-page-name"/>      // sets iss.fail() on any error<br class="title-page-name"/>      // available in &lt;sstream&gt;<br class="title-page-name"/>      // locale-problematic<br class="title-page-name"/>      // allocating; allocator-aware<br class="title-page-name"/>      // base 10 or 16, auto-detected<br class="title-page-name"/>      // skips whitespace by default<br class="title-page-name"/>      // non-portable behavior on trailing text<br class="title-page-name"/><br class="title-page-name"/>    r = std::from_chars(buffer, buffer + 2, floatvalue,<br class="title-page-name"/>                        std::chars_format::general);<br class="title-page-name"/>      // sets r.ec != 0 on any error<br class="title-page-name"/>      // available since C++17 in &lt;charconv&gt;<br class="title-page-name"/>      // locale-independent by design<br class="title-page-name"/>      // non-allocating<br class="title-page-name"/>      // base 10 or 16, auto-detected<br class="title-page-name"/>      // always skips leading whitespace</pre>
<p class="calibre2">All of these parsers--even <kbd class="calibre12">std::from_chars</kbd>--accept input strings, <kbd class="calibre12">"Infinity"</kbd> and <kbd class="calibre12">"Nan"</kbd> (case-insensitively), and also accept "hex float" inputs so that, for example, <kbd class="calibre12">"0x1.c"</kbd> parses as the decimal number 1.75. All but <kbd class="calibre12">std::from_chars</kbd> are locale-aware, and thus problematic in portable code. Where the locale problems with integer parsing are largely theoretical, the widespread real-world use of locales where <kbd class="calibre12">.</kbd> is not the decimal separator means that it is very easy to run into cases where <kbd class="calibre12">std::stof</kbd> and <kbd class="calibre12">std::stod</kbd> don't work as expected:</p>
<pre class="calibre23">    std::setlocale(LC_ALL, "C.UTF-8");<br class="title-page-name"/>    assert(std::stod("3.14") == 3.14); // Success!<br class="title-page-name"/>    std::setlocale(LC_ALL, "en_DK.UTF-8");<br class="title-page-name"/>    assert(std::stod("3.14") == 3.00); // Silent, abject failure!</pre>
<p class="calibre2">Notice in passing the "non-portable behavior on trailing text" mentioned in connection with <kbd class="calibre12">istringstream</kbd>. Different library vendors do different things with stream input, and it's not always clear which should be considered "correct":</p>
<pre class="calibre23">    double d = 17;<br class="title-page-name"/>    std::istringstream iss("42abc");<br class="title-page-name"/>    iss &gt;&gt; d;<br class="title-page-name"/>    if (iss.good() &amp;&amp; d == 42) {<br class="title-page-name"/>      puts("Your library vendor is libstdc++");<br class="title-page-name"/>    } else if (iss.fail() &amp;&amp; d == 0) {<br class="title-page-name"/>      puts("Your library vendor is libc++");<br class="title-page-name"/>    }</pre>
<p class="calibre2">Because of these portability issues--symptoms of the subtle complexity of stream input in general--, I recommend you avoid using <kbd class="calibre12">istringstream</kbd> for input parsing, even though <kbd class="calibre12">ostringstream</kbd> may sometimes be the most appropriate choice for output formatting.</p>
<p class="calibre2">Another good rule of thumb is to separate the <em class="calibre22">validation</em> (or <em class="calibre22">lexing</em>) of input from the <em class="calibre22">parsing</em> of input. If you can validate beforehand that a certain string contains all digits, or matches the regular-expression syntax of a valid floating-point number, then you merely have to pick a parsing method that can detect overflow and/or trailing text; for example, <kbd class="calibre12">std::stof</kbd> or <kbd class="calibre12">std::from_chars</kbd>. For more on lexing input with regular expressions, see <a href="part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 10</a>, <em class="calibre22">Regular Expressions</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reading a line or word at a time</h1>
                
            
            <article>
                
<p class="calibre2">Reading from standard input one line at a time is a very common task in simple scripts, and most scripting languages make it a one-liner. For example, in Python:</p>
<pre class="calibre23">    for line in sys.stdin:<br class="title-page-name"/>    # preserves trailing newlines<br class="title-page-name"/>    process(line)</pre>
<p class="calibre2">And in Perl:</p>
<pre class="calibre23">    while (&lt;&gt;) {<br class="title-page-name"/>      # preserves trailing newlines<br class="title-page-name"/>      process($_);<br class="title-page-name"/>    }</pre>
<p class="calibre2">In C++, the task is almost as easy. Notice that C++'s <kbd class="calibre12">std::getline</kbd> function, unlike the other languages' idioms, removes the trailing newline (if any) from each line it reads:</p>
<pre class="calibre23">    std::string line;  <br class="title-page-name"/>    while (std::getline(std::cin, line)) {<br class="title-page-name"/>      // automatically chomps trailing newlines<br class="title-page-name"/>      process(line);<br class="title-page-name"/>    }</pre>
<p class="calibre2">In each of these cases, the entire input never lives in memory at once; we are indeed "streaming" the lines through our program in an efficient manner. (And the <kbd class="calibre12">std::getline</kbd> function is allocator-aware; if we absolutely need to avoid heap allocation, we can exchange <kbd class="calibre12">std::string line</kbd> for <kbd class="calibre12">std::pmr::string</kbd>.) The <kbd class="calibre12">process</kbd> function may take each line and use a regular expression (see <a href="part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 10</a>, <em class="calibre22">Regular Expressions</em>) to validate and split the line into fields for further parsing.</p>
<p class="calibre2">To read a word, instead of a line, at a time, we can use the following code snippet as our guide (as long as we trust the current locale's definition of <kbd class="calibre12">isspace</kbd> to separate words correctly, of course):</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    struct streamer {<br class="title-page-name"/>      std::istream&amp; m_in;<br class="title-page-name"/>      explicit streamer(std::istream&amp; in) : m_in(in) {}<br class="title-page-name"/>      auto begin() const<br class="title-page-name"/>        { return std::istream_iterator&lt;T&gt;(m_in); }<br class="title-page-name"/>      auto end() const<br class="title-page-name"/>        { return std::istream_iterator&lt;T&gt;{}; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      for (auto word : streamer&lt;std::string&gt;(std::cin)) {<br class="title-page-name"/>        process(word);<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2"/>
<p class="calibre2"><kbd class="calibre12">std::istream_iterator&lt;T&gt;</kbd> is a standard library type, defined in the <kbd class="calibre12">&lt;iterator&gt;</kbd> header, which wraps a pointer to <kbd class="calibre12">istream</kbd>. The iterator's <kbd class="calibre12">operator++</kbd> reads a value of type <kbd class="calibre12">T</kbd> from the istream, as if by <kbd class="calibre12">operator&gt;&gt;</kbd>, and that value is returned by the iterator's <kbd class="calibre12">operator*</kbd>. Putting it all together, this allows us to read a whole sequence of whitespace-delimited words from <kbd class="calibre12">std::cin</kbd> by relying on the fact that <kbd class="calibre12">std::istream::operator&gt;&gt;(std::string&amp;)</kbd> reads a single whitespace-delimited word.</p>
<p class="calibre2">We can reuse our <kbd class="calibre12">streamer</kbd> class template to read a whole sequence of integers from <kbd class="calibre12">std::cin</kbd> and do something with each of them:</p>
<pre class="calibre23">    // Double every int the user gives us<br class="title-page-name"/>    for (auto value : streamer&lt;int&gt;(std::cin)) {<br class="title-page-name"/>      printf("%d\n", 2*value);<br class="title-page-name"/>    }</pre>
<p class="calibre2">While the I/O facilities of C++ are certainly very complicated, as befits a system's programming language with its roots in the 1980s, we see from these last few examples that it is nonetheless possible to hide this complexity under a layer of abstraction and end up with code that looks almost as simple as Python.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2"><span>Data output can be divided roughly into <em class="calibre22">formatting</em> and <em class="calibre22">buffering</em>.</span> Data input can be divided just as roughly into <em class="calibre22">buffering</em> and <em class="calibre22">parsing</em>; although, the parsing step gets easier if you can put a <em class="calibre22">lexing</em> step in front. (We'll talk more about lexing in the very next chapter!)</p>
<p class="calibre2">The classical iostreams API is built on top of <kbd class="calibre12">&lt;stdio.h&gt;</kbd>, which in turn is built on top of the POSIX file-descriptor API. You can't understand the higher levels without a good understanding of the levels beneath it. In particular, the mess of <kbd class="calibre12">fopen</kbd> mode strings and <kbd class="calibre12">fstream</kbd> constructor flags can be understood only by reference to lookup tables mapping them onto the actual underlying POSIX <kbd class="calibre12">open</kbd> flags.</p>
<p class="calibre2">The POSIX API is concerned only with moving chunks of data to and from file descriptors; it does not "buffer" data in the naive sense. The <kbd class="calibre12">&lt;stdio.h&gt;</kbd> API adds a layer of buffering on top of POSIX; the C <kbd class="calibre12">FILE</kbd> may be fully buffered, line-buffered, or unbuffered. Furthermore, <kbd class="calibre12">&lt;stdio.h&gt;</kbd> provides performant (but locale-aware) formatting routines, of which the most important are <kbd class="calibre12">fprintf</kbd>, <kbd class="calibre12">snprintf</kbd>, and <kbd class="calibre12">sscanf</kbd>.</p>
<p class="calibre2">The <kbd class="calibre12">&lt;iostream&gt;</kbd> API separates the "streambuf", (which identifies the source or sink of raw bytes, and its buffering mode) from the "stream" (which holds the state related to formatting). The different kinds of streams (input or output? file or string?) form a classical polymorphic hierarchy with complicated and, at times, unintuitive inheritance relationships. Avoiding <kbd class="calibre12">&lt;iostream&gt;</kbd> in production code is preferable as it is slow and opaque compared to the <kbd class="calibre12">&lt;stdio.h&gt;</kbd> or POSIX interfaces. Either way, beware of locale-dependent formatting routines.</p>
<p class="calibre2">For one-off quick tasks, prefer parsing numbers via <kbd class="calibre12">std::stoi</kbd>, which detects and throws on error, and formatting with <kbd class="calibre12">std::to_string</kbd> or <kbd class="calibre12">snprintf</kbd>. For high-performance situations, parsing with <kbd class="calibre12">std::from_chars</kbd> and formatting with <kbd class="calibre12">std::to_chars</kbd> is preferable if you can find a library implementation that supports these brand new functions from the <kbd class="calibre12">&lt;charconv&gt;</kbd> header.</p>


            </article>

            
        </section>
    </body></html>