- en: Chapter 6. IR to Selection DAG phase
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the previous chapter, we saw how a frontend language can be converted
    to LLVM IR. We also saw how IR can be transformed into more optimized code. After
    a series of analysis and transformation passes, the final IR is the most optimized
    machine independent code. However, the IR is still an abstract representation
    of the actual machine code. The compiler has to generate target architecture code
    for execution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: LLVM uses DAG—a directed acyclic graph representation for code generation. The
    idea is to convert IR into a `SelectionDAG` and then go over a series of phases—DAG
    combine, legalization, instruction selection, instruction scheduling, etc—to finally
    allocate registers and emit machine code. Note that register allocation and instruction
    scheduling take place in an intertwined manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Converting IR to selectionDAG
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legalizing selectionDAG
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing selectionDAG
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instruction selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling and emitting machine instructions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register allocation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code emission
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting IR to selectionDAG
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IR instruction can be represented by an SDAG node. The whole set of instructions
    thus forms an interconnected directed acyclic graph, with each node corresponding
    to an IR instruction.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following LLVM IR:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'LLVM provides a `SelectionDAGBuilder` interface to create DAG nodes corresponding
    to IR instructions. Consider the binary operation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following function is called when the given IR is encountered:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Depending on the opcode—which is `Add` here—the corresponding visit function
    is invoked. In this case, `visitAdd()` is invoked, which further invokes the `visitBinary()`
    function. The `visitBinary()` function is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function takes two operands of the binary operator from IR and stores
    them into `SDValue` type. Then it invokes the `DAG.getNode()` function with opcode
    of the binary operator. This results in formation of a DAG node, which somewhat
    looks like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting IR to selectionDAG](img/00009.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: The operands `0` and `1` are load DAG nodes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the IR:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On encountering the `sdiv` instruction, the function `visitSDiv()` is invoked.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similar to `visitBinary()`, this function also stores the two operands into
    `SDValue` gets a DAG node with `ISD::SDIV` as its operator. The node looks like
    the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting IR to selectionDAG](img/00010.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: In our IR, the operand 0 is `%add`. Operand `1` is `%c`, which is passed as
    an argument to the function, which transforms to a load node when converting IR
    to `SelectionDAG`. For implementation of Load DAG node, go through the `visitLoad()`
    function in the `lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'After visiting all the IR instructions mentioned earlier, finally the IR is
    converted to `SelectionDAG` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting IR to selectionDAG](img/00011.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, note the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Black arrows mean data flow dependency
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red arrows mean glue dependency
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色箭头表示粘合依赖
- en: Blue dashed arrows mean chain dependency
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色虚线箭头表示链式依赖
- en: Glue prevents the two nodes from being broken up during scheduling. Chain dependencies
    prevent nodes with side effects. A data dependency indicates when an instruction
    depends on the result of a previous instruction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Glue 防止两个节点在调度过程中被拆分。链式依赖防止具有副作用节点。数据依赖表示指令依赖于先前指令的结果。
- en: Legalizing SelectionDAG
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合法化 SelectionDAG
- en: In the preceding topic, we saw how an IR is converted to `SelectionDAG`. The
    whole process didn't involve any knowledge of target architecture for which we
    are trying to generate code. A DAG node might be illegal for the given target
    architecture. For example, the X86 architecture doesn't support the `sdiv` instruction.
    Instead, it supports `sdivrem` instruction. This target specific information is
    conveyed to the `SelectionDAG` phase by the `TargetLowering` interface. Targets
    implement this interface to describe how LLVM IR instructions should be lowered
    to legal `SelectionDAG` operations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个主题中，我们看到了如何将 IR 转换为 `SelectionDAG`。整个过程没有涉及任何关于我们试图为其生成代码的目标架构的知识。DAG 节点可能对给定的目标架构是非法的。例如，X86
    架构不支持 `sdiv` 指令。相反，它支持 `sdivrem` 指令。这种特定于目标的信息通过 `TargetLowering` 接口传达给 `SelectionDAG`
    阶段。目标实现此接口来描述如何将 LLVM IR 指令降低为合法的 `SelectionDAG` 操作。
- en: In our IR case, we need to 'expand' the `sdiv` instruction to `'sdivrem'` instruction.
    In the function void `SelectionDAGLegalize::LegalizeOp(SDNode *Node)`, the `TargetLowering::Expand`
    case is encountered, which invokes the `ExpandNode()` function call on that particular
    node.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 IR 情况中，我们需要将 `sdiv` 指令扩展为 `'sdivrem'` 指令。在函数 `void SelectionDAGLegalize::LegalizeOp(SDNode
    *Node)` 中，遇到了 `TargetLowering::Expand` 情况，这会在该特定节点上调用 `ExpandNode()` 函数调用。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function expands SDIV into the SDIVREM node:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将 SDIV 扩展到 SDIVREM 节点：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, after legalization, the node becomes `ISD::SDIVREM`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在合法化之后，节点变为 `ISD::SDIVREM`：
- en: '![Legalizing SelectionDAG](img/00012.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![合法化 SelectionDAG](img/00012.jpeg)'
- en: Thus the above instruction has been '`legalized`' mapping to the instruction
    supported on the target architecture. What we saw above was an example of expand
    legalization. There are two other types of legalization—promotion and custom.
    A promotion promotes one type to a larger type. A custom legalization involves
    target-specific hook (maybe a custom operation—majorly seen with IR intrinsic).
    We leave it to the readers to explore these more in the `CodeGen` phase.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上述指令已被 `'legalized'` 映射到目标架构上支持的指令。我们上面看到的是一个扩展合法化的示例。还有两种其他类型的合法化——提升和自定义。提升将一种类型提升到更大的类型。自定义合法化涉及特定于目标的钩子（可能是一个自定义操作——通常与
    IR 内置函数一起看到）。我们将这些留给读者在 `CodeGen` 阶段进一步探索。
- en: Optimizing SelectionDAG
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 SelectionDAG
- en: After converting the IR into `SelectionDAG`, many opportunities may arise to
    optimize the DAG itself. These optimization takes place in the `DAGCombiner` phase.
    These opportunities may arise due to set of architecture specific instructions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 IR 转换为 `SelectionDAG` 之后，可能会出现许多优化 DAG 本身的机会。这些优化发生在 `DAGCombiner` 阶段。这些机会可能由于一组特定于架构的指令而出现。
- en: 'Let''s take an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding example in IR looks like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: IR 中的前一个示例看起来如下：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The example is basically extracting single element from a vector of `<4xi32>`
    and adding each element of the vector to give a scalar result.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例基本上是从 `<4xi32>` 向量中提取单个元素，并将向量的每个元素相加得到一个标量结果。
- en: Advanced architectures such as ARM has one single instruction to do the preceding
    operation—adding across single vector. The SDAG needs to be combined into a single
    DAG node by identifying the preceding pattern in `SelectionDAG`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 高级架构，如 ARM，有一个单独的指令来完成前面的操作——对单个向量进行加法。SDAG 需要通过在 `SelectionDAG` 中识别前面的模式来合并成一个
    DAG 节点。
- en: This can be done while selecting instruction in `AArch64DAGToDAGISel`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 `AArch64DAGToDAGISel` 中选择指令时完成。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We define the `SelectADDV()` function as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `SelectADDV()` 函数如下：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we have defined a helper function `checkVectorElemAdd()` earlier to
    check the chain of add selection DAG nodes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之前已经定义了一个辅助函数 `checkVectorElemAdd()` 来检查加法选择 DAG 节点的链。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s see how this affects the code generation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何影响代码生成：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before the preceding code, the final code generated will be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码之前，生成的最终代码将如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Clearly, the preceding code is a scalar code. After adding the preceding patch
    and compiling, the code generated will be as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instruction Selection
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SelectionDAG` at this phase is optimized and legalized. However, the instructions
    are still not in machine code form. These instructions need to be mapped to architecture-specific
    instructions in the `SelectionDAG` itself. The `TableGen` class helps select target-specific
    instructions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `CodeGenAndEmitDAG()` function calls the `DoInstructionSelection()` function
    that visits each DAG node and calls the Select() function for each node. The `Select()`
    function is the main hook targets implement to select a node. The `Select()` function
    is a virtual method to be implemented by the targets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: For consideration, assume our target architecture is X86\. The `X86DAGToDAGISel::Select()`
    function intercepts some nodes for manual matching, but delegates the bulk of
    the work to the `X86DAGToDAGISel::SelectCode()` function. The `X86DAGToDAGISel::SelectCode()`
    function is auto generated by `TableGen`. It contains the matcher table, followed
    by a call to the generic `SelectionDAGISel::SelectCodeCommon()` function, passing
    it the table.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, consider the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before instruction selection, the SDAG looks like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Instruction Selection](img/00013.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'After Instruction Selection, SDAG looks like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Instruction Selection](img/00014.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Scheduling and emitting machine instructions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been performing the operations on DAG. Now, for the machine
    to execute, we need to convert the DAGs into instruction that the machine can
    execute. One step towards it is emitting the list of instructions into `MachineBasicBlock`.
    This is done by the `Scheduler`, whose goal is to linearize the DAGs. The scheduling
    is dependent on the target architecture, as certain Targets will have target specific
    hooks which can affect the scheduling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The class `InstrEmitter::EmitMachineNode` takes `SDNode *Node` as one of the
    input parameters for which it will be emitting machine instructions of the class
    `MachineInstr`. These instructions are emitted into a `MachineBasicBlock`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The function calls `EmitSubregNode`, `EmitCopyToRegClassNode` and `EmitRegSequence`
    for the handling of `subreg` insert/extract, `COPY_TO_REGCLASS`, and `REG_SEQUENCE`
    respectively.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The call `MachineInstrBuilder` `MIB = BuildMI(*MF, Node->getDebugLoc(), II);`
    is used to build the Machine Instruction. The `CreateVirtualRegisters` function
    is called to add result register values created by this instruction.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop emits the operands of the instruction :'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It inserts the instruction into its position in the `MachineBasicBlock`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code marks unused registers as dead:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we had discussed earlier that the target specific hooks affect the scheduling,
    the code for that in this function is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `AdjustInstrPostInstrSelection` is a virtual function implemented by Targets.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example to see the machine instructions generated in this step.
    To do this, we need to pass the command-line option `-print-machineinstrs` to
    the `llc` tool. Let''s take the same testcode used earlier:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看这一步生成的机器指令。为此，我们需要将命令行选项`-print-machineinstrs`传递给`llc`工具。让我们使用之前相同的`testcode`：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, invoke the llc command and pass the `–print-machineinstrs` to it. Pass
    `test.ll` as the input file and store the output in the outfile:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用`llc`命令并将`–print-machineinstrs`传递给它。将`test.ll`作为输入文件，并将输出存储在输出文件中：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `outfile` is large, containing many other phases of code generation apart
    from scheduling. We need to look into the section after "`# After Instruction
    Selection:`" in the output file, which is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`outfile`很大，包含除调度之外许多其他代码生成阶段的输出。我们需要查看输出文件中`# After Instruction Selection:`后面的部分，如下所示：'
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see in the output that certain places being taken by physical registers
    and some by virtual registers. We can also see the machine instruction `IDIV32r`
    in the output. In the next section, we will see how physical registers are assigned
    to these virtual registers present in the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中看到某些位置被物理寄存器占用，而一些则由虚拟寄存器占用。我们还可以在输出中看到机器指令`IDIV32r`。在下一节中，我们将看到物理寄存器是如何分配给代码中存在的这些虚拟寄存器的。
- en: Register allocation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器分配
- en: The next step of the code generator is register allocation. As we saw in the
    previous example, some of the registers being used were virtual registers. Register
    allocation is the task of assigning physical registers to these virtual registers.
    In LLVM, the virtual registers can be infinite in number, but the numbers of physical
    registers are limited depending on the target. So, by register allocation, we
    aim at maximizing the number of physical registers being assigned to virtual registers.
    We must note that the physical registers are limited in number, so it is not always
    possible that all the virtual registers can be assigned a physical register. If
    there is no physical register available at some point and we need a physical register
    for a variable, we might move a variable that is present in physical register
    to main memory and thus assign the freed register to the variable we want. This
    process of moving a variable from physical register to memory is called **spilling**.
    There are various algorithms to calculate which variable should be spilled from
    register to memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器的下一步是寄存器分配。正如我们在前面的例子中所看到的，一些正在使用的寄存器是虚拟寄存器。寄存器分配是将物理寄存器分配给这些虚拟寄存器的任务。在LLVM中，虚拟寄存器的数量可以是无限的，但物理寄存器的数量取决于目标，是有限的。因此，通过寄存器分配，我们旨在最大化分配给虚拟寄存器的物理寄存器数量。我们必须注意，物理寄存器的数量是有限的，因此并不是所有的虚拟寄存器都可以分配到物理寄存器。如果在某个时刻没有可用的物理寄存器，而我们需要一个物理寄存器来存储变量，我们可能会将存在于物理寄存器中的变量移动到主存储器中，从而将释放的寄存器分配给我们要存储的变量。将变量从物理寄存器移动到内存的过程称为**溢出**。有各种算法来计算应该从寄存器溢出到内存中的变量。
- en: Another important role that the register allocator plays is SSA form deconstruction.
    The phi instructions present in the machine instruction till now need to be replaced
    with a regular instruction. The traditional way of doing so is to replace it with
    a copy instruction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器分配器扮演的另一个重要角色是SSA形式的分解。到目前为止，机器指令中存在的phi指令需要被替换为常规指令。传统的方法是将它替换为复制指令。
- en: It must be noted that some of the machine fragments have already registers assigned
    to them. This is due to target requirements where it wants certain registers fixed
    to certain operations. Apart from these fixed registers, the register allocator
    takes care of the rest of the non-fixed registers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，一些机器片段已经分配了寄存器。这是由于目标要求，它希望某些寄存器固定到某些操作上。除了这些固定的寄存器之外，寄存器分配器负责处理其余的非固定寄存器。
- en: 'Register allocation for mapping virtual registers to physical registers can
    be done in the following two ways:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟寄存器映射到物理寄存器的寄存器分配可以通过以下两种方式完成：
- en: '**Direct Mapping**: It makes use of the `TargetRegisterInfo` class and the
    `MachineOperand` class. The developer in this case needs to provide the location
    where load and store instructions are to be inserted to get values from the memory
    and store values in the memory.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接映射**：它使用`TargetRegisterInfo`类和`MachineOperand`类。在这种情况下，开发者需要提供插入加载和存储指令的位置，以从内存中获取值并将值存储在内存中。'
- en: '**Indirect Mapping**: In this, the `VirtRegMap` class takes care of inserting
    loads and stores. It also gets value from memory and stores value to memory. We
    need to use the `VirtRegMap::assignVirt2Phys(vreg, preg)` function for mapping
    virtual register to physical register.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LLVM has four register allocation techniques. We will briefly look what they
    are without going into the details of the algorithm. The four allocators are as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Register Allocator**: The most basic register allocation technique
    of all the techniques. It can serve as a starter for implementing other register
    allocation techniques. The algorithm makes use of spill weight for prioritizing
    the virtual registers. The virtual register with the least weight gets the register
    allocated to it. When no physical register is available, the virtual register
    is spilled to memory.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast Register Allocator**: This allocation is done at basic block level at
    a time and attempts to reuse values in registers by keeping them in registers
    for longer period of time.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PBQP Register Allocator**: As mentioned in the source code file for this
    register allocation(`llvm/lib/CodeGen/RegAllocPBQP.cpp`), this allocator works
    by representing the register allocator as a PBQP problem and then solving it using
    PBQP solver.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greedy Register Allocator**: This is one of the efficient allocator of LLVM
    and works across the functions. Its allocation is done using live range splitting
    and minimizing spill costs.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take an example to see the register allocation for the previous testcode
    `test.ll` and see how vregs are replaced with actual registers. Let's take the
    greedy allocator for allocation. You can choose any other allocator as well. The
    target machine used is x86-64 machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can see all the vregs present are gone now and have been replaced by actual
    registers. The machine used here was x86-64\. You can try out register allocation
    with `pbqp` allocator and see the difference in allocation. The `leal (%rdi,%rsi),
    %eax` instruction will be replaced with the following instructions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Code Emission
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started from LLVM IR in the first section and converted it to `SelectioDAG`
    and then to `MachineInstr`. Now, we need to emit this code. Currently, we have
    LLVM JIT and MC to do so. LLVM JIT is the traditional way of generating the object
    code for a target on the go directly in the memory. What we are more interested
    in is the LLVM MC layer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The MC layer is responsible for generation of assembly file/object file from
    the `MachineInstr` passed on to it from the previous step. In the MC Layer, the
    instructions are represented as `MCInst`, which are lightweight, as in they don't
    carry much information about the program as `MachineInstr`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The code emission starts with the `AsmPrinter` class, which is overloaded by
    the target specific `AsmPrinter` class. This class deals with general lowering
    process by converting the `MachineFunction` functions into MC label constructs
    by making use of the target specific `MCInstLowering` interface(for x86 it is
    `X86MCInstLower` class in the `lib/Target/x86/X86MCInstLower.cpp` file).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码发射从`AsmPrinter`类开始，该类被目标特定的`AsmPrinter`类重载。这个类通过使用目标特定的`MCInstLowering`接口（对于x86是`lib/Target/x86/X86MCInstLower.cpp`文件中的`X86MCInstLower`类）将`MachineFunction`函数转换为MC标签结构，处理一般的降低过程。
- en: Now, we have `MCInst` instructions that are passed to `MCStreamer` class for
    further step of generating either the assembly file or object code. Depending
    on the choice `MCStreamer` makes use of its subclass `MCAsmStreamer` to generate
    assembly code and `MCObjectStreamer` to generate the object code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了`MCInst`指令，这些指令被传递给`MCStreamer`类，以进行生成汇编文件或目标代码的下一步。根据`MCStreamer`的选择，它使用其子类`MCAsmStreamer`生成汇编代码，并使用`MCObjectStreamer`生成目标代码。
- en: The target specific `MCInstPrinter` is called by `MCAsmStreamer` to print the
    assembly instructions. To generate the binary code, the LLVM object code assembler
    is called by `MCObjectStreamer`. The assembler in turn calls the `MCCodeEmitter::EncodeInstruction()`
    to generate the binary instructions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目标特定的`MCInstPrinter`由`MCAsmStreamer`调用以打印汇编指令。要生成二进制代码，`MCObjectStreamer`通过`MCObjectStreamer`调用LLVM对象代码汇编器。汇编器反过来调用`MCCodeEmitter::EncodeInstruction()`以生成二进制指令。
- en: We must note that the MC Layer is one of the big difference between LLVM and
    GCC. GCC always outputs assembly and then needs an external assembler to transform
    this assembly into object files, whereas for LLVM using its own assembler we can
    easily print the instructions in binary and by putting some wraps around them
    can generate the object file directly. This not only guarantees that the output
    emitted in text or binary forms will be same but also saves time over GCC by removing
    the calls to external processes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，MC层是LLVM和GCC之间的一大区别。GCC总是输出汇编，然后需要一个外部汇编器将这个汇编转换成目标文件，而对于LLVM，使用它自己的汇编器，我们可以轻松地以二进制形式打印指令，并通过在它们周围添加一些包装来直接生成目标文件。这不仅保证了以文本或二进制形式输出的内容将相同，而且通过移除对外部过程的调用，比GCC节省了时间。
- en: Now, let's take an example to look at the MC Instruction corresponding to assembly
    using the `llc` tool. We make use of the same testcode `test.ll` file used earlier
    in the chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`llc`工具查看与汇编对应的MC指令的例子。我们使用本章前面使用的相同测试代码`test.ll`文件。
- en: To view the MC Instructions, we need to pass the command-line option `–asm-show-inst`
    option to `llc`. It will show the MC instructions as assembly file comments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看MC指令，我们需要将命令行选项`–asm-show-inst`传递给`llc`。它将以汇编文件注释的形式显示MC指令。
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We see the `MCInst` and `MCOperands` in the assembly comments. We can also view
    the binary encoding in assembly comments by passing the option `–show-mc-encoding`
    to `llc`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在汇编注释中看到`MCInst`和`MCOperands`。我们还可以通过将选项`–show-mc-encoding`传递给`llc`来在汇编注释中查看二进制编码。
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how LLVM IR is converted to `SelectionDAG`. The SDAG
    then goes through variety of transformation. The instructions are legalized, so
    are the data types. `SelectionDAG` also goes through the optimization phase where
    DAG nodes are combined to result in optimal nodes, which may be target-spacific.
    After DAG combine, it goes through instruction selection phase, where target architecture
    instructions are mapped to DAG nodes. After this, the DAGs are ordered in a linear
    order to facilitate execution by CPU, these DAGs are converted to `MachineInstr`
    and DAGs are destroyed. Assigning of physical register takes place in the next
    step to all the virtual registers present in the code. After this, the MC layer
    comes into picture and deals with the generation of Object and Assembly Code.
    Going ahead in the next chapter, we will see how to define a target; the various
    aspects of how a target is represented in LLVM by making use of Table Descriptor
    files and `TableGen`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何将 LLVM IR 转换为 `SelectionDAG`。然后 SDAG 会经历各种转换。指令被合法化，数据类型也是如此。`SelectionDAG`
    还会经过优化阶段，其中 DAG 节点被组合成最优节点，这些节点可能是特定于目标的。在 DAG 组合之后，它进入指令选择阶段，将目标架构指令映射到 DAG 节点。之后，DAGs
    以线性顺序排列，以便 CPU 执行，这些 DAGs 转换为 `MachineInstr`，并且 DAGs 被销毁。在下一步中，对代码中出现的所有虚拟寄存器进行物理寄存器的分配。之后，MC
    层出现并处理目标代码和汇编代码的生成。在下一章中，我们将看到如何定义一个目标；通过使用表描述文件和 `TableGen`，LLVM 如何表示目标的各个方面。
