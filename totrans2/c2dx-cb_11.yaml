- en: Chapter 11. Taking Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using encrypted sprite sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using encrypted zip files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using encrypted SQLite files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Observer Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking with HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have explained basic technical information in Cocos2d-x. It supports
    the development of games on a smartphone. Actually, you can create your original
    games using basic functions of Cocos2d-x. However, if your game is a major hit,
    cheaters might attempt to crack the code. Therefore, there are cases where encryption
    is needed to prevent unauthorized access to your game data. Encryption is an important
    aspect in game development because it helps you to protect your code and prevent
    people from ruining the overall experience of the game, and it also prevents illegal
    hacking of game. In this chapter, you will learn how to encrypt your game resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using encrypted sprite sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is pretty easy for a hacker to extract resource files from the application.
    This is a huge concern for copyright. Sprite sheets can be encrypted very easily
    using `TexturePacker`. In this recipe, you will learn how to encrypt your sprites
    to protect them from hackers and cheaters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To encrypt sprite sheets using `TexturePacker`, you need to set it on the left
    pane of `TexturePacker`. Then, you need to follow the steps written here to successfully
    encrypt your sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Change the Texture format to `zlib compr. PVR(.pvr.ccz, Ver.2)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **ContentProtection** icon, and you will see the additional window
    in which to set the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the encryption key in the text input area as shown in the following screenshot.
    You can type in your favorite key. However, it is difficult to type in 32 hex
    digits and thus, you can just click on the **Create new key** button. After clicking
    it, you will find that it automatically inputs the **Encryption key**.![How to
    do it...](img/B0561_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a note of this encryption key. This is the key you will need to decrypt
    the files that are encrypted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can publish the encrypted sprite sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's have a look on how to use these encrypted sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Add the encrypted sprite sheet to your project as shown in the following image:![How
    it works...](img/B0561_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the `ZipUtils` class in `HelloWorld.cpp` to decrypt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the encrypting key that is used for encryption by `TexturePacker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the sprite is created using the encrypted sprite sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application has a lot of sprite sheets normally. You can use each encryption
    key per sprite sheet. But this might create some confusion. You need to use the
    same key in all the sprite sheets in your application. The first time, you need
    to click on the **Create new key** button to create the encryption key. Then,
    you need to click on the **Save as global key** button to save the encryption
    key as the global key. Next time, when you create a new encrypted sprite sheet,
    you can set this encryption key as a global key by clicking on the **Use global
    key** button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will move on to understanding how to check the encrypted sprite sheets.
    The encrypted sprite sheet's extension is `.ccz`.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the encrypted file that has the `.ccz` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch Texture Packer and you will see the window where you need to enter the
    decryption key, as shown in the following screenshot:![There's more…](img/B0561_11_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the decryption key or click on the **Use global key** button. If you have
    saved the key as the global key, then click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the key is the correct key, you will see the sprite sheet as shown in the
    preceding screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using encrypted zip files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a smartphone, the game frequently downloads a `zip` file from the server
    to update resources. These assets are generally the main targets for hackers.
    They can decode these assets to manipulate information in a game system. Hence,
    security for these assets is very important. In this case, `zip` is encrypted
    to protect against cheaters. In this recipe, you will learn how to unzip an encrypted
    `zip` file with a password.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cocos2d-x has an unzip library. However, encryption/decryption is disabled in
    this library. That's why we have to enable the crypt option in `unzip.cpp`. This
    file's path is `cocos2d/external/unzip/unzip.cpp`. You will have to comment out
    line number 71 of `unzip.cpp` to enable the crypt option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we tried to build in Cocos2d-x version 3.7, an error occurred in `unzip.h`
    in line 46, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to edit the following code to remove this error, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, include the `unzip.h` file to use the unzip library in `HelloWorld.cpp`
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s try to unzip the encrypted zip file with the password. This can
    be done by adding the following code in `HelloWorld`.cpp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can unzip the encrypted zip file to use this method by specifying
    the password. If the password is `cocos2d-x`, you can unzip with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the encrypted zip file using the `unzOpen` function, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After opening it with the `unzOpen` function, open it again using the `unzOpenCurrentFilePassword`
    function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, you can continue in the same way that is used to unzip an unencrypted
    zip file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using encrypted SQLite files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often use SQLite to save the user data or game data. SQLite is a powerful
    and useful database. However, there is a database file in your game's sand box.
    Cheaters will get it from your game and they will edit it to cheat. In this recipe,
    you will learn how to encrypt your SQLite and prevent cheaters from editing it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the `wxSqlite` library to encrypt SQLite. This is free software.
    Firstly, you need to install `wxSqlite` in Cocos2d-x and edit some code and set
    files in Cocos2d-x.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `wxSqlite3` project''s zip file. Visit the following url: [http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download](http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the zip file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder called `wxsqlite` under `cocos2d/external`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `sqlite3/secure/src` after expanding the folder to `cocos2d/external/wxsqlite`
    as shown in the following screenshot:![Getting ready](img/B0561_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `sqlite3.h` and `sqlite3secure.c` in `wxsqlite/src` that you added in step
    4 to your project, as shown in the following screenshot:![Getting ready](img/B0561_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `-DSQLITE_HAS_CODEC` to `Other C Flags` in **Build Settings** of Xcode,
    as shown in the following screenshot:![Getting ready](img/B0561_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `Android.mk` in `cocos2d/external/wxsqlite`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `Android.mk` in `cocos2d/cocos/storage/local-storage`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Edit `LocalStorage.cpp` in `cocos2d/cocos/storage/local-storage`. Comment out
    line 33 and line 180, as shown in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LocalStorage.cpp` line33:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LocalStorage.cpp` line180:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `Android.mk` in `proj.andorid/jni`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, SQLite is encrypted and can be used in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have to include `sqlite3.h` to use SQLite APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the encrypted database, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the data from the encrypted database, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you have to create the encrypted database with the `pass` phrase.
    To create it, follow these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the database normally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set the pass phrase using the `sqlite3_key` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, execute sql to create tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, you will need the encrypted database file in the application. You
    can get it from the path that was printed by CCLOG.
  prefs: []
  type: TYPE_NORMAL
- en: To select data from there, the same method is used. You can get data from the
    encrypted database using the same pass phrase after opening the database.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must be wondering whether this database was really encrypted. So let''s
    check it. Open the database using the command line and executing the command as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the database is encrypted, you will not be able to open it and an error
    message will pop up, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event Dispatcher is a mechanism for responding to events such as touching screen,
    keyboard events and custom events. You can get an event using Event Dispatcher.
    In addition, you can create `Observer Pattern` in the design patterns using it.
    In this recipe, you will learn how to use Event Dispatcher and how to create Observer
    Pattern in Cocos2d-x.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we will go through the details of Observer Pattern. Observer Pattern
    is a design pattern. When an event occurs, Observer notifies the event about the
    subjects that are registered in Observer. It is mainly used to implement distributed
    event handling. Observer Pattern is also a key part in the MVC architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B0561_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a count up label per second in this recipe. When touching a screen,
    count up labels are created in this position, and then, count up per second using
    Observer Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `Count` class that is extended `Label` class as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, when touching a screen, this label will be created at the touching position
    and will call the `HelloWorld::countUp` method per second using a scheduler as
    the following code in `HelloWorld.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After building and running this project, when you touch the screen, it will
    create a count up label at the touching position, and then you will see that the
    labels are counting up per second at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the custom event called `TimeCount`. If `TimeCount` event occurred, then
    the `Count::countUp` method is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't forget that you need to remove the custom event from `EventDispatcher`
    when the instance of the `Count` class is removed. If you forget to do that, then
    the `zombie` instance will be called from `EventDispatcher` when the event occurs
    and your game will crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `HelloWorld.cpp`, call the `HelloWorld::countUp` method using the scheduler.
    The `HelloWorld::countUp` method calls the custom event called `TimeOut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And then, `EventDispatcher` will notify this event to the listed subjects. In
    this case, the `Count::countUp` method is called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `EventDispatcher`, labels count up at the same time. If you use Scheduler
    instead of `EventDispatcher`, you will notice something different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `Count::init` method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this code, use a scheduler by calling the `Count::countUp` method per second.
    You can see that the labels are not counting up at the same time in this way.
    Each label is counting up per second, however not at the same time. Using Observer
    Pattern, a lot of subjects can be called at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Networking with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent smartphone games, we normally use an Internet network to update data,
    download resources, and so on. There aren't any games developed without networking.
    In this recipe, you will learn how to use networking to download resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have to include the header file of `network/HttpClient` to use networking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you run it on Android devices, you need to edit `proj.android/AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following code, we will get the response from [http://google.com/](http://google.com/)
    and then, print the response data as a log.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, create an `HttpRequest` instance. The `HttpRequest` class does not
    have a `create` method. That's why you use `new` for creating the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Specify URL and the request type. In this case, set [http://google.com/](http://google.com/)
    as a request URL and set GET as a request type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set callback function to receive the data from the server. You can check its
    success using the `HttpResponse::isSucceed` method. And then you can get the response
    data using the `HttpResponse::getResponseData` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can request networking by calling the `HttpClient::send` method specifying
    the instance of the `HttpRequest` class. If you are getting a response via the
    network, then call the callback function as mentioned in Step3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you have to release the instance of `HttpRequest`. That's why you created
    it by using `new`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how you can get resources from the network using
    the `HttpRequest` class. In the following code, get the Google log from the network
    and display it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can see the following window after building and running this code.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B0561_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to save the original data in the sandbox. You can get the path of the
    sandbox using the `FileUtils::getWritablePath` method.
  prefs: []
  type: TYPE_NORMAL
