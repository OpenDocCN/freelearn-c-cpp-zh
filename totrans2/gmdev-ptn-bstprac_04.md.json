["```cpp\nenum State \n{ \n  Idle, \n  Follow, \n  Death \n}; \n\n```", "```cpp\nenum State{\n Idle, Follow, Death }; \n\n//!< Simple AI to Chase the Player \nclass ChasePlayerComponent : public M5Component \n{ \npublic: \n  ChasePlayerComponent(void); \n  virtual void Update(float dt); \n  virtual void FromFile(M5IniFile& iniFile); \n  virtual ChasePlayerComponent* Clone(void); \nprivate: \n  float m_speed; \n  float m_followDistance; \n float m_loseDistance; \n\n void FollowPlayer(); \n float GetDistanceFromPlayer(); \n State m_currentState; \n\n}; \n\n```", "```cpp\n/*************************************************************************/ \n/*!   \nMakes it so the enemy will move in the direction of the player \n*/ \n/*************************************************************************/ \nvoid ChasePlayerComponent::FollowPlayer() \n{ \n  std::vector<M5Object*> players; \n  M5ObjectManager::GetAllObjectsByType(AT_Player, players); \n  M5Vec2 dir; \n  M5Vec2::Sub(dir, players[0]->pos, m_pObj->pos); \n  m_pObj->rotation = std::atan2f(dir.y, dir.x); \n  dir.Normalize(); \n  dir *= m_speed; \n  m_pObj->vel = dir; \n} \n\n/*************************************************************************/ \n/*! \nReturns the distance of the object this is attached to the player \n*/ \n/*************************************************************************/ \nfloat ChasePlayerComponent::GetDistanceFromPlayer() \n{ \n  std::vector<M5Object*> players; \n  M5ObjectManager::GetAllObjectsByType(AT_Player, players); \n\n  return M5Vec2::Distance(m_pObj->pos, players[0]->pos); \n} \n\n```", "```cpp\n/*************************************************************************/ \n/*! \nSets component type and starting values for player \n*/   \n/*************************************************************************/ \nChasePlayerComponent::ChasePlayerComponent(void): \n  M5Component(CT_ChasePlayerComponent), \n  m_speed(1) \n  { \n    m_currentState = Idle; \n  } \n\n```", "```cpp\nvoid ChasePlayerComponent::FromFile(M5IniFile& iniFile) \n{ \n  iniFile.SetToSection(\"ChasePlayerComponent\"); \n  iniFile.GetValue(\"speed\", m_speed); \n iniFile.GetValue(\"followDistance\", m_followDistance); \n iniFile.GetValue(\"loseDistance\", m_loseDistance); \n\n} \n\n```", "```cpp\nM5Component* ChasePlayerComponent::Clone(void) \n{ \n  ChasePlayerComponent* pNew = new ChasePlayerComponent; \n  pNew->m_speed = m_speed; \n  pNew->m_followDistance = m_followDistance;\n pNew->m_loseDistance = m_loseDistance; \n  return pNew; \n} \n\n```", "```cpp\nposX   = 0 \nposY   = 0 \nvelX   = 0 \nvelY   = 0 \nscaleX = 10 \nscaleY = 10 \nrot    = 0 \nrotVel = 0 \ncomponents = GfxComponent ColliderComponent ChasePlayerComponent \n\n[GfxComponent] \ntexture = enemyBlack3.tga \ndrawSpace = world \n\n[ColliderComponent] \nradius = 5 \nisResizeable = 0 \n\n[ChasePlayerComponent] \nspeed = 40 \nfollowDistance = 50 \nloseDistance = 75 \n\n```", "```cpp\nArcheTypes = Player Raider \n\n[Player] \ncount = 1 \npos = 0 0 \n\n[Raider] \ncount = 1 \npos = 100 10 \n\n```", "```cpp\nvoid ChasePlayerComponent::Update(float) \n{ \n  // Depending on  what state we are in, do different things \n  switch (m_currentState) \n  { \n  case Idle: \n    // No longer move if we were \n    m_pObj->vel = M5Vec2(0, 0); \n\n    // If the player gets too close, the enemy notices them \n    if (GetDistanceFromPlayer() < m_followDistance) \n    { \n      // And will begin to give chase \n      m_currentState = Follow; \n    } \n\n    return; \n  case Follow: \n    // Follow the player \n    FollowPlayer(); \n\n    // If the player manages to get away from the enemy \n    if (GetDistanceFromPlayer() > m_loseDistance) \n    { \n      // Stop in your tracks \n      m_currentState = Idle; \n    } \n    break; \n  case Death: \n    // Set object for deletion \n    m_pObj->isDead = true; \n    break; \n  } \n\n} \n\n```", "```cpp\nvoid MinValue(int a, int b) \n{ \n  if (a < b) \n    return a; \n  else \n    return b; \n} \n\n// Could also be written in the following way: \nvoid MinValue(int a, int b) \n{ \n  return (a < b) ? a : b; \n} \n\n```", "```cpp\nvoid AttackPlayer(Weapon * weapon) \n  { \n    if (weapon.name == \"Bow\")     \n    { \n      ShootArrow(weapon); \n    } \n    else if (weapon.name == \"Sword\") \n    { \n      MeleeAttack(weapon); \n    } \n    else \n    { \n      IdleAnimation(weapon); \n    } \n} \n\n```", "```cpp\nvoid AttackPlayer(Weapon * weapon) \n{ \n// C++ doesn't support using string literals in switch  \n// statements so we have to use a different variable \n// type, such as an integer \n  switch (weapon.type) \n  { \n  case 0: \n    ShootArrow(weapon); \n    break; \n\n  case 1: \n    MeleeAttack(weapon); \n    break; \n\n  default: \n    IdleAnimation(weapon); \n\n  } \n\n} \n\n```", "```cpp\n  class Weapon \n  { \n  public: \n    virtual void Attack()  \n    { \n      // Do nothing \n    }; \n  }; \n\n  class Bow : Weapon \n  { \n  public: \n    virtual void Attack() \n    { \n      // Attack with Bow \n    }; \n  }; \n\n  void AttackPlayer(Weapon * weapon) \n  { \n    weapon->Attack(); \n  } \n\n```", "```cpp\nclass ChasePlayerComponent : public M5Component \n{ \npublic: \n  ChasePlayerComponent(void); \n  virtual void Update(float dt); \n  virtual void FromFile(M5IniFile& iniFile); \n  virtual M5Component* Clone(void); \n  virtual void EnterState(State state);\n virtual void UpdateState(State state, float dt);\n virtual void ExitState(State state); \n  virtual void SetNewState(State state, bool initialState = false); \nprivate: \n  float m_speed; \n  float m_followDistance; \n  float m_loseDistance; \n\n  void FollowPlayer(); \n  float GetDistanceFromPlayer(); \n  State m_currentState; \n\n}; \n\n```", "```cpp\nvoid ChasePlayerComponent::EnterState(State state) \n{ \n  // Depending on what state we are in, do different things \n  switch (state) \n  { \n  case Idle: \n    // No longer move if we were \n    if (m_pObj) \n    {   \n      m_pObj->vel = M5Vec2(0, 0); \n    } \n\n    M5DEBUG_PRINT(\"\\nIdle: Enter\"); \n    break; \n\n  case Follow: \n    M5DEBUG_PRINT(\"\\nFollow: Enter\"); \n    break; \n\n  case Death: \n    m_pObj->isDead = true; \n    M5DEBUG_PRINT(\"\\nDeath: Enter\"); \n    break; \n  } \n} \n\nvoid ChasePlayerComponent::UpdateState(State state, float) \n{ \n  // Depending on what state we are in, do different things \n  switch (state) \n  { \n  case Idle: \n    //M5DEBUG_PRINT(\"\\nIdle: Update\"); \n    // If the player gets too close, the enemy notices them \n    if (GetDistanceFromPlayer() < m_followDistance) \n    { \n      // And will begin to give chase \n      SetNewState(Follow); \n    } \n\n    break; \n\n  case Follow: \n    //M5DEBUG_PRINT(\"\\nFollow: Update\"); \n\n    // Follow the player \n    FollowPlayer(); \n\n    // If the player manages to get away from the enemy \n    if (GetDistanceFromPlayer() > m_loseDistance) \n    { \n      // Stop in your tracks \n      SetNewState(Idle); \n    } \n    break; \n  } \n} \n\nvoid ChasePlayerComponent::ExitState(State state) \n{ \n  // Depending on what state we are in, do different things \n  switch (state) \n  { \n  case Idle: \n    M5DEBUG_PRINT(\"\\nIdle: Exit\"); \n    break; \n\n  case Follow: \n    M5DEBUG_PRINT(\"\\nFollow: Exit\"); \n    break; \n  } \n} \n\n// initialState by default is false, so will only need to give \n// second parameter the first time it is called \nvoid ChasePlayerComponent::SetNewState(State state, bool initialState) \n{ \n  if (!initialState) \n  { \n    // Exit of our old state \n    ExitState(currentState); \n  } \n\n  // Then start up our new one \n  m_currentState = state; \n  EnterState(m_currentState); \n} \n\n```", "```cpp\nvoid ChasePlayerComponent::Update(float dt) \n{ \n  UpdateState(m_currentState, dt); \n} \n\n```", "```cpp\n/*************************************************************************/ \n/*! \nSets component type and starting values for player \n*/ \n/*************************************************************************/ \nChasePlayerComponent::ChasePlayerComponent(void): \n  M5Component(CT_ChasePlayerComponent), \n  m_speed(1) \n{ \n  SetNewState(Idle, true); \n} \n\n```", "```cpp\nSplashStage::~SplashStage(void) \n{ \n  //We are done this with ArcheType so lets get rid of it. \n  M5ObjectManager::RemoveArcheType(AT_Splash); \n  //M5DEBUG_DESTROY_CONSOLE(); \n} \n\n```", "```cpp\n#ifndef M5STATEMACNINE_H \n#define M5STATEMACNINE_H \n\n#include \"M5Component.h\" \n#include \"M5Vec2.h\" \n\n//! Base State for M5StateMachines \nclass M5State \n{ \npublic: \n  //! Empty virtual destructor \n  virtual ~M5State(void) {} \n  //! Called when we first enter a state \n  virtual void Enter(float dt)  = 0; \n  //! called once per frame \n  virtual void Update(float dt) = 0; \n  //! called before we exit a state \n  virtual void Exit(float dt)   = 0; \n}; \n\n//! Base class for Finite statemanchine component for AstroShot \nclass M5StateMachine : public M5Component \n{ \npublic: \n  M5StateMachine(M5ComponentTypes type); \n  virtual ~M5StateMachine(void); \n  virtual void Update(float dt); \n  void SetNextState(M5State* pNext); \nprivate: \n  M5State* m_pCurr; //!< a pointer to our current state to be updated \n}; \n\n#endif //M5STATEMACNINE_H \n\n```", "```cpp\n#include \"M5StateMachine.h\"\n\nM5StateMachine::M5StateMachine(M5ComponentTypes type):\n M5Component(type),\n m_pCurr(nullptr)\n{\n}\n\nM5StateMachine::~M5StateMachine(void)\n{\n}\n\nvoid M5StateMachine::Update(float dt)\n{\n m_pCurr->Update(dt);\n}\n\nvoid M5StateMachine::SetNextState(M5State* pNext)\n{\n if(m_pCurr)\n m_pCurr->Exit();\n\n m_pCurr = pNext;\n m_pCurr->Enter();\n}\n\n```", "```cpp\n#ifndef RANDOM_LOCATION_COMPONENT_H \n#define RANDOM_LOCATION_COMPONENT_H \n\n#include \"Core\\M5Component.h\" \n#include \"Core\\M5StateMachine.h\" \n#include \"Core\\M5Vec2.h\" \n\n//Forward declation \nclass RandomGoComponent; \n\nclass RLCFindState : public M5State \n{ \npublic: \n  RLCFindState(RandomGoComponent* parent); \n  void Enter(float dt); \n  void Update(float dt); \n  void Exit(float dt); \nprivate: \n  RandomGoComponent* m_parent; \n}; \nclass RLCRotateState : public M5State \n{ \npublic: \n  RLCRotateState(RandomGoComponent* parent); \n  void Enter(float dt); \n  void Update(float dt); \n  void Exit(float dt); \nprivate: \n  float m_targetRot; \n  M5Vec2 m_dir; \n  RandomGoComponent* m_parent; \n}; \nclass RLCGoState : public M5State \n{ \npublic: \n  RLCGoState(RandomGoComponent* parent); \n  void Enter(float dt); \n  void Update(float dt); \n  void Exit(float dt); \nprivate: \n  RandomGoComponent* m_parent; \n}; \n\nclass RandomGoComponent : public M5StateMachine \n{ \npublic: \n  RandomGoComponent(void); \n  virtual void FromFile(M5IniFile&); \n  virtual M5Component* Clone(void); \nprivate: \n  friend RLCFindState; \n  friend RLCGoState; \n  friend RLCRotateState; \n\n  float          m_speed; \n  float          m_rotateSpeed; \n  M5Vec2         m_target; \n  RLCFindState   m_findState; \n  RLCRotateState m_rotateState; \n  RLCGoState     m_goState; \n}; \n\n#endif // !RANDOM_LOCATION_COMPONENT_H \n\n```", "```cpp\n#include \"RandomGoStates.h\"\n#include \"RandomGoComponent.h\"\n\n#include \"Core\\M5Random.h\"\n#include \"Core\\M5Object.h\"\n#include \"Core\\M5Intersect.h\"\n#include \"Core\\M5Gfx.h\"\n#include \"Core\\M5Math.h\"\n#include <cmath>\n\nFindState::FindState(RandomGoComponent* parent): m_parent(parent)\n{\n}\nvoid FindState::Enter()\n{\n M5Vec2 botLeft;\n M5Vec2 topRight;\n M5Gfx::GetWorldBotLeft(botLeft);\n M5Gfx::GetWorldTopRight(topRight);\n\n M5Vec2 target;\n target.x = M5Random::GetFloat(botLeft.x, topRight.x);\n target.y = M5Random::GetFloat(botLeft.y, topRight.y);\n\n m_parent->SetTarget(target);\n\n}\nvoid FindState::Update(float)\n{\n m_parent->SetNextState(m_parent->GetState(RGS_ROTATE_STATE));\n}\nvoid FindState::Exit()\n{\n}\n\n```", "```cpp\nRotateState::RotateState(RandomGoComponent* parent): m_parent(parent)\n{\n}\nvoid RotateState::Enter()\n{\n M5Vec2 target = m_parent->GetTarget();\n\n M5Vec2::Sub(m_dir, target, m_parent->GetM5Object()->pos);\n\n m_targetRot = std::atan2f(m_dir.y, m_dir.x);\n m_targetRot = M5Math::Wrap(m_targetRot, 0.f, M5Math::TWO_PI);\n\n m_parent->GetM5Object()->rotationVel = m_parent->GetRotationSpeed();\n}\nvoid RotateState::Update(float)\n{\n m_parent->GetM5Object()->rotation = M5Math::Wrap(m_parent->GetM5Object()->rotation, 0.f, M5Math::TWO_PI);\n\n if (M5Math::IsInRange(m_parent->GetM5Object()->rotation, m_targetRot - .1f, m_targetRot + .1f))\n m_parent->SetNextState(m_parent->GetState(RGS_GO_STATE));\n}\nvoid RotateState::Exit()\n{\n m_parent->GetM5Object()->rotationVel = 0;\n\n m_dir.Normalize();\n M5Vec2::Scale(m_dir, m_dir, m_parent->GetSpeed());\n\n m_parent->GetM5Object()->vel = m_dir;\n}\n\n```", "```cpp\nGoState::GoState(RandomGoComponent* parent): m_parent(parent)\n{\n}\nvoid GoState::Enter()\n{\n}\nvoid GoState::Update(float)\n{\n M5Vec2 target = m_parent->GetTarget();\n if (M5Intersect::PointCircle(target, m_parent->GetM5Object()->pos, m_parent->GetM5Object()->scale.x))\n m_parent->SetNextState(m_parent->GetState(RGS_FIND_STATE));\n}\nvoid GoState::Exit()\n{\n m_parent->GetM5Object()->vel.Set(0, 0);\n}\n\n```", "```cpp\nRandomGoComponent::RandomGoComponent():\n M5StateMachine(CT_RandomGoComponent),\n m_speed(1),\n m_rotateSpeed(1),\n m_findState(this),\n m_rotateState(this),\n m_goState(this)\n{\n SetNextState(&m_findState);\n}\nvoid RandomGoComponent::FromFile(M5IniFile& iniFile)\n{\n iniFile.SetToSection(\"RandomGoComponent\");\n iniFile.GetValue(\"speed\", m_speed);\n iniFile.GetValue(\"rotationSpeed\", m_speed);\n}\nRandomGoComponent* RandomGoComponent::Clone(void) const\n{\n RandomGoComponent* pNew = new RandomGoComponent;\n pNew->m_speed = m_speed;\n pNew->m_rotateSpeed = m_rotateSpeed;\n return pNew;\n}\n\nM5State* RandomGoComponent::GetState(RandomGoStates state)\n{\n switch (state)\n {\n case RGS_FIND_STATE:\n return &m_findState;\n break;\n case RGS_ROTATE_STATE:\n return &m_rotateState;\n break;\n case RGS_GO_STATE:\n return &m_goState;\n break;\n }\n\n //In case somethings goes wrong \n return &m_findState;\n}\n\n```", "```cpp\nposX   = 0 \nposY   = 0 \nvelX   = 0 \nvelY   = 0 \nscaleX = 10 \nscaleY = 10 \nrot    = 0 \nrotVel = 0 \ncomponents = GfxComponent ColliderComponent RandomGoComponent \n\n[GfxComponent] \ntexture = enemyBlack3.tga \ndrawSpace = world \n\n[ColliderComponent] \nradius = 5 \nisResizeable = 0 \n\n[RandomGoComponent] \nspeed = 40 \nrotationSpeed = 40 \n\n```", "```cpp\nclass M5StageManager \n{ \npublic: \n  friend class M5App; \n\n  //Registers a GameStage and a builder with the the StageManger \n  static void AddStage(M5StageTypes type, M5StageBuilder* builder); \n  //Removes a Stage Builder from the Manager \n  static void RemoveStage(M5StageTypes type); \n  //Clears all stages from the StageManager \n  static void ClearStages(void); \n  //Sets the given stage ID to the starting stage of the game \n  static void SetStartStage(M5StageTypes startStage); \n  //Test if the game is quitting \n  static bool IsQuitting(void); \n  //Test stage is restarting \n  static bool IsRestarting(void); \n  //Gets the pointer to the users game specific data \n  static M5GameData& GetGameData(void); \n  //Sets the next stage for the game \n  static void SetNextStage(M5StageTypes nextStage); \n  // Pauses the current stage, so it can be resumed but changes stages \n  static void PauseAndSetNextStage(M5StageTypes nextStage); \n  // Resumes the previous stage \n  static void Resume(void); \n  //Tells the game to quit \n  static void Quit(void); \n  //Tells the stage to restart \n  static void Restart(void); \nprivate: \n  static void Init(const M5GameData& gameData, int framesPerSecond);\n  static void Update(void); \n  static void Shutdown(void); \n  static void InitStage(void); \n  static void ChangeStage(void); \n\n};//end M5StageManager \n\n```", "```cpp\nvoid M5StageManager::ChangeStage(void)\n{\n /*Only unload if we are not restarting*/\n if (s_isPausing)\n {\n   M5ObjectManager::Pause();\n   M5Phy::Pause();\n   M5Gfx::Pause(s_drawPaused);\n   PauseInfo pi(s_pStage, s_currStage);\n   s_pauseStack.push(pi);\n   s_isPausing = false;\n }\n else if (s_isResuming)\n {\n   /*Make sure to shutdown the stage*/\n   s_pStage->Shutdown();\n   delete s_pStage;\n   s_pStage = nullptr;\n }\n else if (!s_isRestarting) //Just changine the stage\n {\n   /*Make sure to shutdown the stage*/\n   s_pStage->Shutdown();\n   delete s_pStage;\n   s_pStage = nullptr;\n\n   //If we are setting the next state, that means we are ignore all\n   //paused states, so lets clear the pause stack\n   while (!s_pauseStack.empty())\n   {\n     M5Gfx::Resume();\n     M5Phy::Resume();\n     M5ObjectManager::Resume();\n     PauseInfo pi = s_pauseStack.top();\n     pi.pStage->Shutdown();\n     delete pi.pStage;\n     s_pauseStack.pop();\n   }\n\n }\n else if (s_isRestarting)\n {\n   /*Make sure to shutdown the stage*/\n   s_pStage->Shutdown();\n }\n\n s_currStage = s_nextStage;\n}\n\n```"]