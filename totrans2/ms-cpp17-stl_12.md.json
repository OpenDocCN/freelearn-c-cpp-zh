["```cpp\n    using namespace std::filesystem;\n\n    void foo(path p)\n    {\n      remove(p); // What function is this?\n    }\n```", "```cpp\n    namespace fs = std::filesystem;\n\n    void foo(fs::path p)\n    {\n      fs::remove(p); // Much clearer!\n    }\n```", "```cpp\n    #if USE_CXX17\n     #include <filesystem>\n     namespace fs = std::filesystem;\n    #elif USE_FILESYSTEM_TS\n     #include <experimental/filesystem>\n     namespace fs = std::experimental::filesystem;\n    #elif USE_BOOST\n     #include <boost/filesystem.hpp>\n     namespace fs = boost::filesystem;\n    #endif\n```", "```cpp\n    try {\n      f.open(\"hello.txt\");\n      // Opening succeeded.\n    } catch (const std::ios_base::failure&) {\n      // Opening failed.\n    }\n```", "```cpp\n    f.open(\"hello.txt\");\n    if (f.is_open()) {\n      // Opening succeeded.\n    } else {\n      // Opening failed.\n    }\n```", "```cpp\n    // Exception-throwing approach.\n    try {\n      int i = std::stoi(s);\n      // Parsing succeeded.\n    } catch (...) {\n      // Parsing failed.\n    }\n```", "```cpp\n    char *endptr = nullptr;\n    errno = 0;\n    long i = strtol(s, &endptr, 10);\n    if (endptr != s && !errno) {\n      // Parsing succeeded.\n    } else {\n      // Parsing failed.\n    }\n```", "```cpp\n    int i = 0;\n    auto [ptr, ec] = std::from_chars(s, end(s), i);\n    if (ec != std::errc{}) {\n      // Parsing succeeded.\n    } else {\n      // Parsing failed.\n    }\n```", "```cpp\n    uintmax_t file_size(const fs::path& p);\n\n    uintmax_t file_size(const fs::path& p,\n       std::error_code& ec) noexcept;\n```", "```cpp\n namespace std {\n   enum class errc {\n     // implicitly, \"0\" means \"no error\"\n     operation_not_permitted = EPERM,\n     no_such_file_or_directory = ENOENT,\n     no_such_process = ESRCH,\n     // ...\n     value_too_large = EOVERFLOW\n   };\n } // namespace std\n```", "```cpp\n namespace std {\n\n class error_category {\n public:\n   virtual const char *name() const noexcept = 0;\n   virtual std::string message(int err) const = 0;\n\n   // other virtual methods not shown\n\n   bool operator==(const std::error_category& rhs) const {\n     return this == &rhs;\n   }\n };\n\n } // namespace std\n```", "```cpp\n    namespace std {\n\n    class error_code {\n      const std::error_category *m_cat;\n      int m_err;\n    public:\n      const auto& category() const { return m_cat; }\n      int value() const { return m_err; }\n      std::string message() const { return m_cat->message(m_err); }\n      explicit operator bool() const { return m_err != 0; }\n\n      // other convenience methods not shown\n    };\n\n    } // namespace std\n```", "```cpp\n    namespace FinickyFS {\n\n    enum class Error : int {\n      success = 0,\n      forbidden_character = 1,\n      forbidden_word = 2,\n      too_many_characters = 3,\n    };\n\n    struct ErrorCategory : std::error_category\n    {\n      const char *name() const noexcept override {\n        return \"finicky filesystem\";\n      }\n\n      std::string message(int err) const override {\n        switch (err) {\n          case 0: return \"Success\";\n          case 1: return \"Invalid filename\";\n          case 2: return \"Bad word in filename\";\n          case 3: return \"Filename too long\";\n        }\n        throw Unreachable();\n      }\n\n      static ErrorCategory& instance() {\n        static ErrorCategory instance;\n        return instance;\n      }\n    };\n\n    std::error_code make_error_code(Error err) noexcept\n   {\n      return std::error_code(int(err), ErrorCategory::instance());\n    }\n\n    } // namespace FinickyFS\n```", "```cpp\n    // An error fits comfortably in a statically typed\n    // and value-semantic std::error_code object...\n    std::error_code ec =    \n      make_error_code(FinickyFS::Error::forbidden_word);\n\n    // ...Yet its \"what-string\" remains just as\n    // accessible as if it were a dynamically typed\n    // exception!\n    assert(ec.message() == \"Bad word in filename\");\n```", "```cpp\n    namespace std {\n    template<>\n    struct is_error_code_enum<::FinickyFS::Error> : true_type {};\n    } // namespace std\n```", "```cpp\n    class error_code {\n      // ...\n      template<\n        class E,\n        class = enable_if_t<is_error_code_enum_v<E>>\n      >\n      error_code(E err) noexcept {\n        *this = make_error_code(err);\n      }\n    };\n```", "```cpp\n    std::error_code ec = FinickyFS::Error::forbidden_character;\n\n      // Comparisons are strongly typed.\n    assert(ec == FinickyFS::Error::forbidden_character);\n    assert(ec != std::io_errc::stream);\n```", "```cpp\n    bool is_malformed_name(std::error_code ec) {\n      return (\n        ec == FinickyFS::Error::forbidden_character ||\n        ec == FinickyFS::Error::forbidden_word ||\n        ec == std::errc::illegal_byte_sequence);\n    }\n```", "```cpp\n    namespace FinickyFS {\n\n    enum class Condition : int {\n      success = 0,\n      malformed_name = 1,\n    };\n\n    struct ConditionCategory : std::error_category {\n      const char *name() const noexcept override {\n        return \"finicky filesystem\";\n      }\n      std::string message(int cond) const override {\n        switch (cond) {\n          case 0: return \"Success\";\n          case 1: return \"Malformed name\";\n        }\n        throw Unreachable();\n      }\n      bool equivalent(const std::error_code& ec, int cond) const  \n      noexcept override {\n        switch (cond) {\n          case 0: return !ec;\n          case 1: return is_malformed_name(ec);\n        }\n        throw Unreachable();\n      }\n      static ConditionCategory& instance() {\n        static ConditionCategory instance;\n        return instance;\n      }\n    };\n    std::error_condition make_error_condition(Condition cond) noexcept  \n    {\n      return std::error_condition(int(cond),  \n      ConditionCategory::instance());\n    }\n\n    } // namespace FinickyFS\n\n    namespace std {\n    template<>\n    struct is_error_condition_enum<::FinickyFS::Condition> : true_type  \n    {};\n    } // namespace std\n```", "```cpp\n    std::error_code ec = FinickyFS::Error::forbidden_word;\n\n      // RHS is implicitly converted to error_code\n    assert(ec == FinickyFS::Error::forbidden_word);\n\n      // RHS is implicitly converted to error_condition\n    assert(ec == FinickyFS::Condition::malformed_name);\n```", "```cpp\n    // The lower level is error_code-based.\n    uintmax_t file_size(const fs::path& p,\n        std::error_code& ec) noexcept;\n\n    // My level is throw-based.\n    uintmax_t file_size(const fs::path& p)\n    {\n      std::error_code ec;\n      uintmax_t size = file_size(p, ec);\n      if (ec) {\n        throw std::system_error(ec);\n      }\n      return size;\n    }\n```", "```cpp\n    // The lower level is throw-based.\n    uintmax_t file_size(const fs::path& p);\n\n    // My level is error_code-based.\n    uintmax_t file_size(const fs::path& p,\n        std::error_code& ec) noexcept\n    {\n      uintmax_t size = -1;\n      try {\n        size = file_size(p);\n      } catch (...) {\n        ec = current_exception_to_error_code();\n      }\n      return size;\n    }\ncurrent_exception_to_error_code(), which is a non-standard function you can write yourself. I recommend something along these lines:\n```", "```cpp\n namespace detail {\n\n enum Error : int {\n    success = 0,\n    bad_alloc_thrown = 1,\n    unknown_exception_thrown = 2,\n };\n struct ErrorCategory : std::error_category {\n    const char *name() const noexcept override;\n    std::string message(int err) const override;\n    static ErrorCategory& instance();\n };\n std::error_code make_error_code(Error err) noexcept {\n    return std::error_code(int(err), ErrorCategory::instance());\n }\n\n } // namespace detail\n\n std::error_code current_exception_to_error_code()\n {\n    try {\n        throw;\n    } catch (const std::system_error& e) {\n        // also catches std::ios_base::failure\n        // and fs::filesystem_error\n        return e.code();\n    } catch (const std::future_error& e) {\n        // catches the oddball\n        return e.code();\n    } catch (const std::bad_alloc&) {\n        // bad_alloc is often of special interest\n        return detail::bad_alloc_thrown;\n    } catch (...) {\n        return detail::unknown_exception_thrown;\n    }\n }\n```", "```cpp\n    class path {\n    public:\n      using value_type = std::conditional_t<\n        IsWindows, wchar_t, char\n      >;\n      using string_type = std::basic_string<value_type>;\n\n      const auto& native() const { return m_path; }\n      operator string_type() const { return m_path; }\n      auto c_str() const { return m_path.c_str(); }\n\n      // many constructors and accessors omitted\n    private:\n      string_type m_path;\n    };\n```", "```cpp\n    fs::path p(\"/foo/bar\");\n\n    const fs::path::value_type *a = p.c_str();\n      // Portable, for whatever that's worth.\n\n    const char *b = p.c_str();\n      // OK on POSIX; compilation error on Windows.\n\n    std::string s = p.u8string();\n    const char *c = s.c_str();\n      // OK on both POSIX and Windows.\n      // Performs 16-to-8 conversion on Windows.\n```", "```cpp\nx (except path itself) represents the return value of the member function path.x():\n```", "```cpp\n    assert(root_path == root_name / root_directory);\n    assert(path == root_name / root_directory / relative_path);\n    assert(path == root_path / relative_path);\n\n    assert(path == parent_path / filename);\n    assert(filename == stem + extension);\n\n    assert(is_absolute == !is_relative);\n    if (IsWindows) {\n      assert(is_relative == (root_name.empty() ||  \n    root_directory.empty()));\n    } else {\n      assert(is_relative == (root_name.empty() &&  \n    root_directory.empty()));\n    }\n```", "```cpp\noperator/ to concatenate paths. fs::path supports both operator/ and operator/= for this purpose, and they do almost exactly what you'd expect--concatenate two pieces of a path with a slash in between them. If you want to concatenate pieces of a path without adding that slash, use operator+=. Unfortunately, the C++17 standard library is missing operator+ for paths, but it's easy to add as a free function, as follows:\n```", "```cpp\n    static fs::path operator+(fs::path a, const fs::path& b)\n    {\n      a += b;\n      return a;\n    }\n```", "```cpp\n    fs::path p = \"/foo/bar/baz.txt\";\n    std::vector<fs::path> v(p.begin(), p.end());\n    assert((v == std::vector<fs::path>{\n      \"/\", \"foo\", \"bar\", \"baz.txt\"\n    }));\n```", "```cpp\n    fs::path p = \"/tmp/foo/bar.txt\";\n    fs::directory_entry entry(p);\n      // Here, we still have not touched the filesystem.\n\n    while (!entry.exists()) {\n       std::cout << entry.path() << \" does not exist yet\\n\";\n       std::this_thread::sleep_for(100ms);\n       entry.refresh();\n         // Without refresh(), this would loop forever.\n    }\n      // If the file is deleted right now, the following\n      // line might print stale cached values, or it\n      // might try to refresh the cache and throw.\n    std::cout << entry.path() << \" has size \"\n          << entry.file_size() << \"\\n\";\n```", "```cpp\n    fs::path p = fs::current_path();\n      // List the current directory.\n    for (fs::directory_entry entry : fs::directory_iterator(p)) {\n      std::cout << entry.path().string() << \": \"\n      << entry.file_size() << \" bytes\\n\";\n    }\n```", "```cpp\n    template<class F>\n    void walk_down(const fs::path& p, const F& callback)\n    {\n      for (auto entry : fs::directory_iterator(p)) {\n        if (entry.is_directory()) {\n          walk_down(entry.path(), callback);\n        } else {\n          callback(entry);\n        }\n      }\n    }\n```", "```cpp\n    template<class F>\n    void walk_down(const fs::path& p, const F& callback)\n    {\n      for (auto entry : fs::recursive_directory_iterator(p)) {\n        callback(entry);\n      }\n    }\n```", "```cpp\n struct space_info {\n    uintmax_t capacity;\n    uintmax_t free;\n    uintmax_t available;\n };\n```"]