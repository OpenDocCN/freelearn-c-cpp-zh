["```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"DrawFigure.h\" \n#include \"LineFigure.h\" \n#include \"ArrowFigure.h\" \n#include \"RectangleFigure.h\" \n#include \"EllipseFigure.h\" \n#include \"TextFigure.h\" \n#include \"DrawDocument.h\" \n\nvoid MainWindow(vector<String> /* argumentList */, \n                WindowShow windowShow) { \n  Application::ApplicationName() = TEXT(\"DrawFigure\"); \n  Application::MainWindowPtr() = new DrawDocument(windowShow); \n} \n\n```", "```cpp\nclass DrawDocument : public StandardDocument { \n  public: \n    DrawDocument(WindowShow windowShow); \n    ~DrawDocument(); \n\n```", "```cpp\n    void OnMouseDown(MouseButton mouseButtons, Point mousePoint, \n                     bool shiftPressed, bool controlPressed); \n    void OnMouseMove(MouseButton mouseButtons, Point mousePoint, \n                     bool shiftPressed, bool controlPressed); \n    void OnDoubleClick(MouseButton mouseButtons, Point mousePoint, \n                       bool shiftPressed, bool controlPressed); \n    void OnMouseUp(MouseButton mouseButtons, Point mousePoint, \n                   bool shiftPressed, bool controlPressed); \n\n```", "```cpp\n    void OnDraw(Graphics& graphics, DrawMode drawMode) const; \n\n```", "```cpp\n    void ClearDocument(); \n    bool WriteDocumentToStream(String name, ostream& outstream) \n                               const; \n\n```", "```cpp\n    bool ReadDocumentFromStream(String name, istream& instream); \n    DrawFigure* CreateFigure(FigureId figureId) const; \n\n```", "```cpp\n    bool IsCopyGenericReady(int /* format */) const; \n    void CopyGeneric(int format, InfoList& infoList) const; \n    void PasteGeneric(int format, InfoList& infoList); \n\n```", "```cpp\n    bool CopyEnable() const; \n    void OnDelete(); \n\n```", "```cpp\n    DEFINE_BOOL_LISTENER(DrawDocument, ModifyEnable) \n    DEFINE_BOOL_LISTENER(DrawDocument, ModifyRadio) \n    DEFINE_VOID_LISTENER(DrawDocument, OnModify) \n\n    DEFINE_BOOL_LISTENER(DrawDocument, ColorEnable) \n    DEFINE_VOID_LISTENER(DrawDocument, OnColor) \n\n    DEFINE_BOOL_LISTENER(DrawDocument, FillEnable)\n    DEFINE_BOOL_LISTENER(DrawDocument, FillCheck)\n    DEFINE_VOID_LISTENER(DrawDocument, OnFill) \n\n    DEFINE_BOOL_LISTENER(DrawDocument, LineEnable); \n    DEFINE_BOOL_LISTENER(DrawDocument, ArrowEnable); \n    DEFINE_BOOL_LISTENER(DrawDocument, RectangleEnable); \n    DEFINE_BOOL_LISTENER(DrawDocument, EllipseEnable); \n\n    DEFINE_BOOL_LISTENER(DrawDocument, LineRadio); \n    DEFINE_BOOL_LISTENER(DrawDocument, ArrowRadio); \n    DEFINE_BOOL_LISTENER(DrawDocument, RectangleRadio); \n    DEFINE_BOOL_LISTENER(DrawDocument, EllipseRadio); \n\n    DEFINE_VOID_LISTENER(DrawDocument, OnLine); \n    DEFINE_VOID_LISTENER(DrawDocument, OnArrow); \n    DEFINE_VOID_LISTENER(DrawDocument, OnRectangle); \n    DEFINE_VOID_LISTENER(DrawDocument, OnEllipse); \n\n```", "```cpp\n    void UpdateCursor(); \n\n```", "```cpp\n  private: \n    enum ApplicationMode {Idle, ModifySingle, \n                          MoveMultiple, ModifyRectangle}; \n    ApplicationMode applicationMode = Idle; \n\n```", "```cpp\n    enum ActionMode {Modify, Add}; \n    ActionMode actionMode = Add; \n    FigureId addFigureId = LineId; \n\n```", "```cpp\n    Color nextColor; \n    bool nextFill; \n\n```", "```cpp\n    Point prevMousePoint; \n\n```", "```cpp\n    Rect insideRectangle; \n\n```", "```cpp\n    static const unsigned int DrawFormat = 1000; \n\n```", "```cpp\n    DynamicList<DrawFigure*> figurePtrList; \n}; \n\n```", "```cpp\ntemplate <class Type> \nclass DynamicList { \n  public: \n\n```", "```cpp\n    typedef bool (*IfFuncPtr) (const Type& value, void* voidPtr); \n    typedef void (*DoFuncPtr) (Type& value, void* voidPtr); \n\n```", "```cpp\n    bool AnyOf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr) \n               const; \n\n```", "```cpp\n    bool FirstOf(IfFuncPtr ifFuncPtr,Type& value, \n                 void* ifVoidPtr = nullptr) const; \n\n```", "```cpp\n    void Apply(DoFuncPtr doFuncPtr, void* ifVoidPtr = nullptr); \n    void ApplyIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, \n                 void* ifVoidPtr = nullptr, \n                 void* doVoidPtr = nullptr); \n\n```", "```cpp\n    void CopyIf(IfFuncPtr ifFuncPtr, DynamicList& copyArray, \n                void* ifVoidPtr = nullptr) const; \n    void RemoveIf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr); \n\n```", "```cpp\n    void ApplyRemoveIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, \n              void* ifVoidPtr = nullptr, void* doVoidPtr=nullptr); \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"DrawFigure.h\" \n#include \"LineFigure.h\" \n#include \"ArrowFigure.h\" \n#include \"RectangleFigure.h\" \n#include \"EllipseFigure.h\" \n#include \"TextFigure.h\" \n#include \"DrawDocument.h\" \n\nDrawDocument::DrawDocument(WindowShow windowShow) \n :StandardDocument(LogicalWithScroll, USLetterPortrait, \n                   TEXT(\"Draw Files, drw\"), nullptr, \n                   OverlappedWindow, windowShow, \n                   {DrawFormat}, {DrawFormat}) { \n\n```", "```cpp\n  Menu menuBar(this); \n  menuBar.AddMenu(StandardFileMenu(false)); \n  menuBar.AddMenu(StandardEditMenu()); \n\n  Menu formatMenu(this, TEXT(\"F&ormat\")); \n  formatMenu.AddItem(TEXT(\"&Modify\\tCtrl+M\"), OnModify, \n                     ModifyEnable, nullptr, ModifyRadio); \n  formatMenu.AddItem(TEXT(\"&Color\\tAlt+C\"), OnColor, ColorEnable); \n  formatMenu.AddItem(TEXT(\"F&ill\\tCtrl+I\"), OnFill, FillEnable\n                     FillCheck, nullptr);\n  menuBar.AddMenu(formatMenu); \n\n```", "```cpp\n  Menu addMenu(this, TEXT(\"&Add\")); \n  addMenu.AddItem(TEXT(\"&Line\\tCtrl+L\"), OnLine, \n                  LineEnable, nullptr, LineRadio); \n  addMenu.AddItem(TEXT(\"&Arrow\\tAlt+A\"), OnArrow, \n                  ArrowEnable, nullptr, ArrowRadio); \n  addMenu.AddItem(TEXT(\"&Rectangle\\tCtrl+R\"), OnRectangle, \n                  RectangleEnable, nullptr, RectangleRadio); \n  addMenu.AddItem(TEXT(\"&Ellipse\\tCtrl+E\"), OnEllipse, \n                  EllipseEnable, nullptr, EllipseRadio); \n  menuBar.AddMenu(addMenu); \n\n  menuBar.AddMenu(StandardHelpMenu()); \n  SetMenuBar(menuBar); \n\n```", "```cpp\n  actionMode = (ActionMode) \n              Registry::ReadInteger(TEXT(\"actionMode\"), Modify); \n  addFigureId = (FigureId) \n              Registry::ReadInteger(TEXT(\"addFigureId\"), LineId); \n  nextColor.ReadColorFromRegistry(TEXT(\"nextColor\")); \n  nextFill = Registry::ReadBoolean(TEXT(\"nextFill\"), false); \n} \n\n```", "```cpp\nDrawDocument::~DrawDocument() { \n  Registry::WriteInteger(TEXT(\"actionMode\"), actionMode); \n  Registry::WriteInteger(TEXT(\"addFigureId \"), addFigureId); \n  nextColor.WriteColorToRegistry(TEXT(\"nextColor\")); \n  Registry::WriteBoolean(TEXT(\"nextFill\"), nextFill); \n} \n\n```", "```cpp\nauto IsFigureMarked = [](DrawFigure* const& figurePtr, \n                         void* /* voidPtr */) { \n  return figurePtr->IsMarked(); \n}; \n\nbool IsFigureClicked(DrawFigure* const& figurePtr, void* voidPtr) { \n  Point* mousePointPtr = (Point*) voidPtr; \n  return figurePtr->IsClick(*mousePointPtr); \n} \n\nvoid UnmarkFigure(DrawFigure*& figurePtr, void* /* voidPtr */) { \n  if (figurePtr->IsMarked()) { \n    figurePtr->Mark(false); \n  } \n} \n\n```", "```cpp\nvoid DrawDocument::OnMouseDown(MouseButton mouseButtons, \n                     Point mousePoint, bool shiftPressed, \n                     bool controlPressed) { \n  if (mouseButtons == LeftButton) { \n    prevMousePoint = mousePoint; \n\n```", "```cpp\n    switch (actionMode) { \n      case Modify: { \n          DrawFigure* topClickedFigurePtr; \n          if (figurePtrList.FirstOf(IsFigureClicked, \n                            topClickedFigurePtr, &mousePoint)) { \n\n```", "```cpp\n            if (!controlPressed) { \n              figurePtrList.ApplyIf(IsFigureMarked, UnmarkFigure); \n              topClickedFigurePtr->Mark(true); \n              applicationMode = ModifySingle; \n              int topFigureIndex = \n                figurePtrList.IndexOf(topClickedFigurePtr); \n              figurePtrList.Erase(topFigureIndex); \n              figurePtrList.PushFront(topClickedFigurePtr); \n            } \n\n```", "```cpp\n            else { \n              if (topClickedFigurePtr->IsMarked()) { \n                applicationMode = Idle; \n                topClickedFigurePtr->Mark(false); \n              } \n              else { \n                applicationMode = MoveMultiple; \n                topClickedFigurePtr->Mark(true); \n              } \n            } \n          } \n\n```", "```cpp\n          else { \n            figurePtrList.ApplyIf(IsFigureMarked, UnmarkFigure); \n            insideRectangle = Rect(mousePoint, mousePoint); \n            applicationMode = ModifyRectangle; \n          } \n        } \n        break; \n\n```", "```cpp\n      case Add: { \n          DrawFigure* newFigurePtr = CreateFigure(addFigureId); \n          newFigurePtr->SetColor(nextColor); \n          newFigurePtr->Fill(nextFill); \n          newFigurePtr->SetFirstPoint(mousePoint); \n          SetDirty(true); \n          figurePtrList.PushFront(newFigurePtr); \n          applicationMode = ModifySingle; \n        } \n        break; \n    } \n\n```", "```cpp\n    UpdateWindow(); \n    UpdateCursor(); \n  } \n} \n\n```", "```cpp\nvoid MoveMarkedFigure(DrawFigure*& figurePtr, void* voidPtr) { \n  if (figurePtr->IsMarked()) { \n    figurePtr->Invalidate(); \n    Size* distanzeSizePtr = (Size*) voidPtr; \n    figurePtr->Move(*distanzeSizePtr); \n    figurePtr->Invalidate(); \n  } \n} \n\n```", "```cpp\nvoid DrawDocument::OnMouseMove(MouseButton mouseButtons, \n                               Point mousePoint,bool shiftPressed, \n                               bool controlPressed) { \n  if (mouseButtons == LeftButton) { \n    Size distanceSize = mousePoint - prevMousePoint; \n    prevMousePoint = mousePoint; \n\n```", "```cpp\n    switch (applicationMode) { \n      case ModifySingle: \n        figurePtrList[0]->Modify(distanceSize); \n        SetDirty(true); \n        break; \n\n```", "```cpp\n      case MoveMultiple: \n        figurePtrList.Apply(MoveMarkedFigure, &distanceSize); \n        SetDirty(true); \n        break; \n\n```", "```cpp\n      case ModifyRectangle: \n        Invalidate(insideRectangle); \n        insideRectangle.SetBottomRight(mousePoint); \n        Invalidate(insideRectangle); \n        UpdateWindow(); \n        break; \n    } \n\n    UpdateWindow(); \n    UpdateCursor(); \n  } \n} \n\n```", "```cpp\nbool IsFigureInside(DrawFigure* const& figurePtr, void* voidPtr) { \n  Rect* insideRectanglePtr = (Rect*) voidPtr; \n  return figurePtr->IsInside(*insideRectanglePtr); \n} \n\nvoid MarkFigure(DrawFigure*& figurePtr, void* /* voidPtr */) { \n  figurePtr->Mark(true); \n} \n\n```", "```cpp\nvoid DrawDocument::OnMouseUp(MouseButton mouseButtons, \n                             Point mousePoint, bool shiftPressed, \n                             bool controlPressed) { \n  if (mouseButtons == LeftButton) { \n    switch (applicationMode) { \n      case ModifyRectangle: { \n          insideRectangle.Normalize();\n          DynamicList<DrawFigure*> insideList; \n          figurePtrList.CopyIf(IsFigureInside, insideList, \n                                 &insideRectangle); \n          figurePtrList.RemoveIf(IsFigureInside, \n                                 &insideRectangle); \n          figurePtrList.PushFront(insideList); \n          insideList.Apply(MarkFigure); \n          Invalidate(insideRectangle); \n          insideRectangle.Clear(); \n          UpdateWindow(); \n        } \n        break; \n    } \n\n```", "```cpp\n    applicationMode = Idle; \n  } \n} \n\n```", "```cpp\nvoid DrawDocument::OnDoubleClick(MouseButton mouseButtons, \n                           Point mousePoint, bool shiftPressed, \n                           bool controlPressed) { \n  if ((mouseButtons == LeftButton) && !controlPressed) { \n    DrawFigure* topClickedFigurePtr; \n\n    if (figurePtrList.FirstOf(IsFigureClicked,topClickedFigurePtr,  \n                              &mousePoint)) { \n      topClickedFigurePtr->DoubleClick(mousePoint); \n    } \n  } \n} \n\n```", "```cpp\nvoid DrawDocument::OnDraw(Graphics& graphics,\n                          DrawMode /* drawMode */) const {\n  int size = figurePtrList.Size();\n  for (int index = (size - 1); index >= 0; --index) {\n    DrawFigure* figurePtr := figurePtrList) {[index];\n    figurePtr->Draw(graphics);\n  }\n\n  if (applicationMode == ModifyRectangle) {\n    graphics.DrawRectangle(insideRectangle, Gray);\n  }\n}\n```", "```cpp\nvoid DrawDocument::ClearDocument() { \n  for (DrawFigure* figurePtr : figurePtrList) { \n    delete figurePtr; \n  } \n\n  figurePtrList.Clear(); \n} \n\n```", "```cpp\nbool DrawDocument::WriteDocumentToStream(String name, \n                                         ostream& outStream)const{ \n  int listSize = figurePtrList.Size(); \n  outStream.write((char*) &listSize, sizeof listSize); \n\n  for (DrawFigure* figurePtr : figurePtrList) { \n    FigureId figureId = figurePtr->GetId(); \n    outStream.write((char*) &figureId, sizeof figureId); \n    figurePtr->WriteFigureToStream(outStream); \n  } \n\n  return ((bool) outStream); \n} \n\n```", "```cpp\nbool DrawDocument::ReadDocumentFromStream(String name, \n                                          istream& inStream) { \n  int listSize; \n  inStream.read((char*) &listSize, sizeof listSize); \n\n  for (int index = 0; index < listSize; ++index) { \n    FigureId figureId; \n    inStream.read((char*) &figureId, sizeof figureId); \n\n    DrawFigure* figurePtr = CreateFigure(figureId); \n    figurePtr->ReadFigureFromStream(inStream); \n\n    figurePtrList.PushBack(figurePtr); \n  } \n\n  return ((bool) inStream); \n} \n\n```", "```cpp\nDrawFigure* DrawDocument::CreateFigure(FigureId figureId) const { \n  switch (figureId) { \n    case LineId: \n      return (new LineFigure(this)); \n\n    case ArrowId: \n      return (new ArrowFigure(this)); \n\n    case RectangleId: \n      return (new RectangleFigure(this)); \n\n    case EllipseId: \n      return (new EllipseFigure(this)); \n  } \n\n  return nullptr; \n} \n\n```", "```cpp\nbool DrawDocument::CopyEnable() const { \n  if (applicationMode == Idle) { \n    switch (actionMode) { \n      case Modify: \n        return figurePtrList.AnyOf(IsFigureMarked); \n\n      case Add: \n        return false; \n    } \n  } \n\n  return false; \n} \n\n```", "```cpp\nbool DrawDocument::IsCopyGenericReady(int /* format */) const { \n  return true; \n} \n\nvoid DrawDocument::CopyGeneric(int format, InfoList& infoList) \n                               const { \n  DynamicList<DrawFigure*> markedList; \n  figurePtrList.CopyIf(IsFigureMarked, markedList); \n  infoList.AddValue<int>(markedList.Size()); \n\n  for (DrawFigure* figurePtr : markedList) { \n    infoList.AddValue<FigureId>(figurePtr->GetId()); \n    figurePtr->WriteFigureToClipboard(infoList); \n  } \n} \n\n```", "```cpp\nvoid DrawDocument::PasteGeneric(int format, InfoList& infoList) { \n  figurePtrList.ApplyIf(IsFigureMarked, UnmarkFigure); \n\n  int pasteSize; \n  infoList.GetValue<int>(pasteSize); \n\n  for (int count = 0; count < pasteSize; ++count) { \n    FigureId figureId; \n    infoList.GetValue<FigureId>(figureId); \n\n    DrawFigure* figurePtr = CreateFigure(figureId); \n    figurePtr->ReadFigureFromClipboard(infoList); \n    figurePtr->Move(Size(1000, 1000)); \n    figurePtrList.PushBack(figurePtr); \n\n    figurePtr->Mark(true); \n  } \n\n  UpdateWindow(); \n} \n\n```", "```cpp\nvoid DeleteFigure(DrawFigure*& figurePtr, void* /* voidPtr */) { \n  figurePtr->Invalidate(); \n  delete figurePtr; \n} \n\nvoid DrawDocument::OnDelete() { \n  figurePtrList.ApplyRemoveIf(IsFigureMarked, DeleteFigure, \n                              nullptr, this); \n  UpdateWindow(); \n  SetDirty(true); \n} \n\n```", "```cpp\nbool DrawDocument::ModifyEnable() const { \n  return (applicationMode == Idle); \n} \n\nbool DrawDocument::ModifyRadio() const { \n  return ((applicationMode == Idle) && (actionMode == Modify)); \n} \n\nvoid DrawDocument::OnModify() { \n  actionMode = Modify; \n} \n\n```", "```cpp\nbool DrawDocument::ColorEnable() const { \n  if (applicationMode == Idle) { \n    switch (actionMode) { \n      case Modify: \n        return figurePtrList.AnyOf(IsFigureMarked);  \n      case Add: \n        return true; \n    } \n  }  \n  return false; \n} \n\n```", "```cpp\nvoid SetFigureColor(DrawFigure*& figurePtr, void* voidPtr) { \n  Color* colorPtr = (Color*) voidPtr; \n\n  if (figurePtr->IsMarked() && \n      (figurePtr->GetColor() != *colorPtr)) { \n    figurePtr->SetColor(*colorPtr); \n  } \n} \n\n```", "```cpp\nvoid DrawDocument::OnColor() { \n  switch (actionMode) { \n    case Modify: { \n        DynamicList<DrawFigure*> markedList; \n        figurePtrList.CopyIf(IsFigureMarked, markedList); \n        DrawFigure* topFigurePtr = markedList[0]; \n        Color topColor = topFigurePtr->GetColor(); \n\n        if (StandardDialog::ColorDialog(this, topColor)) { \n          nextColor = topColor; \n          figurePtrList.ApplyIf(IsFigureMarked, SetFigureColor, \n                                nullptr, &topColor); \n          UpdateWindow(); \n          SetDirty(true); \n        } \n      } \n      break; \n\n```", "```cpp\n    case Add: \n      StandardDialog::ColorDialog(this, nextColor); \n      break; \n  } \n} \n\n```", "```cpp\nbool IsFigureMarkedAndFilled(DrawFigure* const& figurePtr, \n                             void* /* voidPtr */) { \n  return (figurePtr->IsMarked() && figurePtr->IsFilled()); \n} \n\nbool DrawDocument::FillCheck() const { \n  if (applicationMode == Idle) { \n    switch (actionMode) { \n      case Modify: \n        return figurePtrList.AnyOf(IsFigureMarkedAndFilled); \n\n      case Add: \n        return nextFill; \n    } \n  } \n\n  return false; \n} \n\n```", "```cpp\nbool IsFigureMarkedAndFillable(DrawFigure* const& figurePtr, \n                               void* /* voidPtr */){ \n  return (figurePtr->IsMarked() && figurePtr->IsFillable()); \n} \n\nbool DrawDocument::FillEnable() const { \n  if (applicationMode == Idle) { \n    switch (actionMode) { \n      case Modify: \n        return figurePtrList.AnyOf(IsFigureMarkedAndFillable); \n\n```", "```cpp\n      case Add: { \n          DrawFigure* addFigurePtr = CreateFigure(addFigureId); \n          bool fillable = addFigurePtr->IsFillable(); \n          delete addFigurePtr; \n          return fillable; \n        } \n    } \n  } \n  return false; \n} \n\n```", "```cpp\nvoid InverseFill(DrawFigure*& figurePtr, void* /* voidPtr */) { \n  if (figurePtr->IsMarked()) { \n    figurePtr->Fill(!figurePtr->IsFilled()); \n  } \n} \n\nvoid DrawDocument::OnFill() { \n  switch (actionMode) { \n    case Modify: \n      figurePtrList.ApplyIf(IsFigureMarked, InverseFill); \n      UpdateWindow(); \n      break; \n\n    case Add: \n      nextFill = !nextFill; \n      break; \n  } \n} \n\n```", "```cpp\nbool DrawDocument::LineEnable() const { \n  return (applicationMode == Idle); \n} \nbool DrawDocument::ArrowEnable() const { \n  return (applicationMode == Idle); \n} \n\nbool DrawDocument::RectangleEnable() const { \n  return (applicationMode == Idle); \n} \n\nbool DrawDocument::EllipseEnable() const { \n  return (applicationMode == Idle); \n} \n\n```", "```cpp\nbool DrawDocument::LineRadio() const { \n  return ((actionMode == Add) && (addFigureId == LineId)); \n} \n\nbool DrawDocument::ArrowRadio() const { \n  return ((actionMode == Add) && (addFigureId == ArrowId)); \n} \n\nbool DrawDocument::RectangleRadio() const { \n  return ((actionMode == Add) && (addFigureId == RectangleId)); \n} \n\nbool DrawDocument::EllipseRadio() const { \n  return ((actionMode == Add) && (addFigureId == EllipseId)); \n} \n\n```", "```cpp\nvoid DrawDocument::OnLine() { \n  actionMode = Add; \n  addFigureId = LineId; \n} \n\nvoid DrawDocument::OnArrow() { \n  actionMode = Add; \n  addFigureId = ArrowId; \n} \nvoid DrawDocument::OnRectangle() { \n  actionMode = Add; \n  addFigureId = RectangleId; \n} \n\nvoid DrawDocument::OnEllipse() { \n  actionMode = Add; \n  addFigureId = EllipseId; \n} \n\n```", "```cpp\nvoid DrawDocument::UpdateCursor() { \n  switch (applicationMode) { \n    case Idle: \n      Cursor::Set(Cursor::Arrow); \n      break; \n\n    case ModifyRectangle: \n      Cursor::Set(Cursor::Crosshair); \n      break; \n\n    case MoveMultiple: \n      Cursor::Set(Cursor::SizeAll); \n      break; \n\n    case ModifySingle: \n      Cursor::Set(figurePtrList[0]->GetCursor()); \n      break; \n  } \n} \n\n```"]