- en: Chapter 8. Inventory Population and Item Use
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。库存填充和物品使用
- en: In the previous chapter, we learned how to add a shop, which holds items. In
    this chapter, we will go a step further by allowing a user to buy items from the
    shop and use those bought items in their dynamically populated inventory screen.
    Once done, we will use similar ideas to equip items to party members that will
    be used to increase the stats of the wearer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何添加一个商店，该商店持有物品。在本章中，我们将更进一步，允许用户从商店购买物品，并在他们的动态填充的库存屏幕中使用这些购买的物品。完成后，我们将使用类似的想法为将用于提高穿戴者统计数据的小组成员装备物品。
- en: By the end of this chapter, we will learn how to create logic in our **Shop**
    Widget Blueprint that populates the inventory Scroll Box in the **Shop** Widget
    Blueprint with the buttons created through the **Item** Data table from the **Item**
    Widget Blueprint. Now that we have the logic set up, we need to allow the user
    to interact with the buttons by being able to buy any item that they click on
    in the shop, so long as they have enough money. Since the issuer interacts with
    the dynamically populating buttons, it is important that we have our logic executed
    when the user presses a button, which is located in the **Item** Widget Blueprint.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习如何在**Shop**Widget蓝图中的**Shop**Widget蓝图创建逻辑，以填充库存滚动框中的按钮，这些按钮是通过**Item**Widget蓝图中的**Item**数据表创建的。现在我们已经设置了逻辑，我们需要允许用户通过能够购买他们在商店中点击的任何物品来与按钮交互，只要他们有足够的钱。由于发行者与动态填充的按钮交互，当用户按下按钮时执行我们的逻辑非常重要，该按钮位于**Item**Widget蓝图中。
- en: If you have any other Blueprints in your **Event Graph** that you may have put
    together earlier, you can ignore them since an interaction will allow us to start
    over using some different methodologies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在你的**事件图**中创建了其他蓝图，你可以忽略它们，因为交互将允许我们使用不同的方法重新开始。
- en: First, we must note that the **Item** Blueprint will house logic that should
    happen anytime a button from that Blueprint is clicked. So, at the moment, we
    are planning to have the button populate the shop, but in the player's inventory,
    the logic would need to be different, depending on which screen we are on. This
    means that we will first need to find out which screen the player is on, and then
    fire off a series of actions based on the screen they are on. It would be easy
    to do this with Booleans from the **OnClicked** event, which will check to see
    which menu the player is in and branch off different logic, depending on which
    menu the player is currently in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须注意，**Item**蓝图将包含在任何按钮从该蓝图被点击时应该发生的逻辑。因此，目前我们计划让按钮填充商店，但在玩家的库存中，逻辑需要根据我们在哪个屏幕上而有所不同。这意味着我们首先需要找出玩家在哪个屏幕上，然后根据他们所在的屏幕执行一系列动作。这可以通过**OnClicked**事件中的布尔值轻松完成，该事件将检查玩家在哪个菜单中，并根据当前菜单分支不同的逻辑。
- en: Since we are concerned with the difference between the behavior of the buttons
    in the **Pause_Inventory** screen versus the **Shop** screen, we must first create
    a Boolean that will stay active throughout the life of the character. In this
    case, we will use the Field Player to hold our important item variables.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注的是**Pause_Inventory**屏幕上的按钮与**Shop**屏幕上的按钮行为之间的差异，我们必须首先创建一个布尔值，该布尔值将在角色的整个生命周期中保持活跃。在这种情况下，我们将使用Field
    Player来保存我们的重要物品变量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the Field Player Booleans
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Field Player布尔值
- en: Determining whether the inventory screen is on or off
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定库存屏幕是开启还是关闭
- en: Logical difference between inventory and shop items
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存和商店物品之间的逻辑差异
- en: Finishing the inventory screen
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成库存屏幕
- en: Using the items
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物品
- en: Creating the FieldPlayer Booleans
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建FieldPlayer布尔值
- en: 'Go to the Field Player by navigating to **Content** | **Blueprints** | **Characters**,
    and select **FieldPlayer**. Open **FieldPlayer** and navigate to **Event Graph**:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到**内容** | **蓝图** | **角色**，转到Field Player。打开Field Player并导航到**事件图**：
- en: '![Creating the FieldPlayer Booleans](img/B04548_08_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![创建FieldPlayer布尔值](img/B04548_08_01.jpg)'
- en: 'Here, we create a new variable under the **Blueprint** tab by navigating to
    **+Add New** | **Variable**. Next, we create a new `inventoryScreen` Boolean.
    Then, we need to make the variable public. This Boolean will be responsible for
    keeping true or false values, depending on whether the player is on the inventory
    screen. We may need more variables like these in the figure, but for now, we will
    just use this variable:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过导航到**+添加新** | **变量**在**蓝图**选项卡下创建一个新的变量。接下来，我们创建一个新的`inventoryScreen`布尔值。然后，我们需要使变量公开。这个布尔值将负责根据玩家是否在库存屏幕上保持true或false值。我们可能需要在图中使用更多这样的变量，但现在我们只使用这个变量：
- en: '![Creating the FieldPlayer Booleans](img/B04548_08_59.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建FieldPlayer布尔值](img/B04548_08_59.jpg)'
- en: When you are finished creating the `inventoryScreen` variable, compile the Blueprint.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完成创建`inventoryScreen`变量后，编译蓝图。
- en: Determining whether the inventory screen is on or off
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定库存屏幕是否开启或关闭
- en: 'We will now set the `inventoryScreen` variable in its proper place. The best
    place to put this is when the inventory menu pops up. So, go to **Pause_Inventory**
    by navigating to **Content** | **Blueprints** | **UI**. In **Pause_Inventory**,
    locate the **Event Construct** in the Event Graph (if an **Event Construct** does
    not exist yet, create one), and from here, get every actor from the Field Player
    class by creating **Get All Actors of Class**, which is located under **Utilities**
    in the **Actions** menu:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置`inventoryScreen`变量到合适的位置。最好的地方是在库存菜单弹出时。因此，通过导航到**内容** | **蓝图** | **UI**，前往**Pause_Inventory**。在**Pause_Inventory**中，在事件图中定位**事件构造**（如果尚未存在，则创建一个），然后从这里，通过创建**获取所有类别的演员**来获取Field
    Player类中的每个演员，该功能位于**动作**菜单下的**实用工具**中：
- en: '![Determining whether the inventory screen is on or off](img/B04548_08_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![确定库存屏幕是否开启或关闭](img/B04548_08_03.jpg)'
- en: 'Under **Actor Class** in the **Get All Actors Of Class** function, change the
    actor to **Field Player**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在**获取所有类别的演员**函数的**演员类别**下，将演员更改为**Field Player**：
- en: '![Determining whether the inventory screen is on or off](img/B04548_08_04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![确定库存屏幕是否开启或关闭](img/B04548_08_04.jpg)'
- en: 'From the **Out Actors** pin, in the **Get All Actors Of Class** function, you
    will need to attach a **GET** function. This will take an array of all actors
    in your Field Player class and allow access to individual members of the class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从**输出演员**引脚，在**获取所有类别的演员**函数中，你需要附加一个**GET**函数。这将获取你的Field Player类中所有演员的数组，并允许访问类中的单个成员：
- en: '![Determining whether the inventory screen is on or off](img/B04548_08_05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![确定库存屏幕是否开启或关闭](img/B04548_08_05.jpg)'
- en: 'Lastly, open your all possible actions and uncheck **Context Sensitive**. Go
    to **Set Inventory Screen** by navigating to **Class** | **Field Player**:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开所有可能的行为并取消**上下文相关**的勾选。通过导航到**类** | **Field Player**，前往**设置库存屏幕**：
- en: '![Determining whether the inventory screen is on or off](img/B04548_08_06.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![确定库存屏幕是否开启或关闭](img/B04548_08_06.jpg)'
- en: 'Once done, connect the **Target** pin of your **Set Inventory Screen** to the
    right-hand side pin of **GET**. Also, make sure that the **Inventory Screen**
    is checked, which means that we set the **Inventory Screen** to true here. At
    this point, you can also link **Event Construct** to fire off **Get All Actors
    Of Class**, which will activate the **Set Inventory Screen**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将你的**设置库存屏幕**的**目标**引脚连接到**GET**的右侧引脚。同时，确保**库存屏幕**被勾选，这意味着我们在这里将**库存屏幕**设置为true。在这个时候，你还可以将**事件构造**链接到触发**获取所有类别的演员**，这将激活**设置库存屏幕**：
- en: '![Determining whether the inventory screen is on or off](img/B04548_08_07.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![确定库存屏幕是否开启或关闭](img/B04548_08_07.jpg)'
- en: 'We will also need to make sure that the Boolean is set to false when the player
    leaves the inventory screen, so clone another **Set Inventory Screen** Boolean,
    and set it to false. Link the **Target** pin back to the **GET** from **Get All
    Actors Of Class**, and activate it when the inventory window closes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保当玩家离开库存屏幕时布尔值设置为false，因此克隆另一个**设置库存屏幕**布尔值，并将其设置为false。将**目标**引脚重新链接到**获取所有类别的演员**的**GET**，并在库存窗口关闭时激活它：
- en: '![Determining whether the inventory screen is on or off](img/B04548_08_08.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![确定库存屏幕是否开启或关闭](img/B04548_08_08.jpg)'
- en: We will later come back to **Pause_Inventory** to add the button population
    logic, similar to the shop in the previous chapter. However, now that we have
    our Booleans set, we will be able to tell whether the player is viewing the inventory
    or is navigating the shop (if the Boolean is false).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在稍后回到**Pause_Inventory**以添加按钮填充逻辑，类似于前一章中的商店。然而，现在我们已经设置了布尔值，我们将能够判断玩家是查看库存还是正在导航商店（如果布尔值为假）。 '
- en: Logical difference between the inventory and shop items
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存和商店物品之间的逻辑差异
- en: 'Let''s now open the **Item** Widget Blueprint by navigating to **Content**
    | **Blueprints** | **UI**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过导航到**内容** | **蓝图** | **UI**来打开**Item**小部件蓝图：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_09.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_09.jpg)'
- en: 'At this point, we should not have any logic for the button, which is necessary
    because it gives us the actions that the button will perform in conjunction with
    the game. To add a functionality to the button, click on the button, navigate
    to **Details** | **Events** | **OnClicked**, and then click on **+**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们不应该为按钮设置任何逻辑，这是必要的，因为它会告诉我们按钮与游戏结合时将执行哪些操作。要为按钮添加功能，请点击按钮，导航到**详情**
    | **事件** | **OnClicked**，然后点击**+**：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_10.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_10.jpg)'
- en: 'Here, we will need to do a few things. Firstly, we know that this Blueprint
    will be responsible for all of the button mechanics regarding both the shops and
    the character''s inventory and the mechanics will be different since the character
    buys items from the shop and uses items from the inventory. Since these different
    game screens provide different actions, it would be wise to first check whether
    a user is in the shop or in their inventory. To do this, we should first bring
    in the **Get All Actors Of Class** function, and get all the actors from the Field
    Player class. Then, we need to link the **Out Actors** pin to **GET**. Finally,
    have the **OnClicked** event fire off **Get All Actors Of Class**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要做几件事情。首先，我们知道这个蓝图将负责所有与商店和角色库存相关的按钮机制，由于角色从商店购买物品并使用库存中的物品，所以机制将不同。由于这些不同的游戏屏幕提供不同的操作，因此首先检查用户是在商店还是在他们的库存中会是一个明智的选择。为此，我们应该首先引入**获取所有类演员**函数，并获取来自**Field
    Player**类的所有演员。然后，我们需要将**输出演员**引脚连接到**GET**。最后，让**OnClicked**事件触发**获取所有类演员**：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_11.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_11.jpg)'
- en: 'At this point, we can open our **Actions** window, and go to the **Get Inventory
    Screen** by navigating to **Class** | **Field Player**. You will need to uncheck
    **Context Sensitive** to see this option:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以打开我们的**动作**窗口，并通过导航到**类** | **Field Player**来访问**获取库存屏幕**。您需要取消选中**上下文相关**才能看到此选项：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_12.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_12.jpg)'
- en: 'You will then link the **Target** pin of the **Inventory Screen** node to the
    blue **GET** pin. This will allow us to access the **Inventory Screen** Boolean
    from the Field Player class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将把**库存屏幕**节点的**目标**引脚连接到蓝色的**GET**引脚。这将使我们能够从**Field Player**类访问**库存屏幕**布尔值：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_13.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_13.jpg)'
- en: 'It is now time to create a branching system that will perform logic, depending
    on whether the player is shopping or whether they are in their inventory. We will
    use our **Inventory Screen** Boolean for this. Let''s first bring in a branch
    by navigating to **Utilities** | **Flow Control** in the **Actions** menu:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一个分支系统，根据玩家是在购物还是在其库存中执行逻辑。我们将使用我们的**库存屏幕**布尔值来完成这个任务。让我们首先通过在**动作**菜单中导航到**实用工具**
    | **流程控制**来引入一个分支：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_14.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_14.jpg)'
- en: 'Here, we link the condition of your branch to the **Inventory Screen** condition.
    Then, have the **Get All Actions Of Class** function activate the branch. At this
    point, when the player clicks on the button, we will check to see whether the
    **Inventory Screen** is true (or if the player is on the inventory screen). If
    they are not on the inventory screen, then it means that the player is on some
    other screen; in our case, the shop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将分支的条件链接到**库存屏幕**条件。然后，让**获取所有类的动作**函数激活分支。此时，当玩家点击按钮时，我们将检查是否**库存屏幕**为真（或者玩家是否在库存屏幕上）。如果他们不在库存屏幕上，那么这意味着玩家在其他屏幕上；在我们的例子中，是商店：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_15.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_15.jpg)'
- en: 'Before we continue with the rest of the **Item** button logic, we need to think
    about our logical flow. If the user is in the shop, and the user clicks on an
    item to be purchased, then if that person has enough money to purchase the item,
    the item should be placed into some sort of a collection or array that can populate
    the user''s inventory screen. Because of this mechanic, we will need to seek some
    sort of global array that will be able to hold an array of items that the player
    has purchased. To do this, go to the **FieldPlayer** Event Graph and add a new
    text array named **arrayItem**. Also, make sure that this variable is set to public
    and is editable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理**物品**按钮的其他逻辑之前，我们需要考虑我们的逻辑流程。如果用户在商店，并且用户点击要购买的项目，那么如果那个人有足够的钱购买该项目，该项目应该被放入某种收集或数组中，以便填充用户的库存屏幕。由于这个机制，我们需要寻找某种全局数组，它将能够容纳玩家购买的项目数组。为此，转到**FieldPlayer**事件图，并添加一个名为**arrayItem**的新文本数组。同时，确保这个变量设置为公共且可编辑：
- en: '![Logical difference between the inventory and shop items](img/B04548_08_16.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![库存和商店物品之间的逻辑差异](img/B04548_08_16.jpg)'
- en: Finishing the inventory screen
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成库存屏幕
- en: 'Navigate to the **Pause_Inventory** Event Graph. While **Context Sensitive**
    is off, bring in the **Get Array Item** from the **Actions** window by navigating
    to **Class** | **Field Player**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**Pause_Inventory**事件图。当**上下文敏感**关闭时，通过导航到**类**|**Field Player**在**动作**窗口中引入**获取数组项**：
- en: '![Finishing the inventory screen](img/B04548_08_17.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕](img/B04548_08_17.jpg)'
- en: 'Once done, connect the **Target** pin of **Array Item** to **GET** so that
    you can get every item that is sent to that array once we populate the array in
    the **Items** Blueprint:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将**数组项**的**目标**引脚连接到**GET**，这样我们就可以在**物品**蓝图中将数组填充后获取发送到该数组的每个项目：
- en: '![Finishing the inventory screen](img/B04548_08_18.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕](img/B04548_08_18.jpg)'
- en: 'Now that we have the array of items in the player''s inventory, we will now
    loop through each element, and create an item from every element in the array.
    To do this, create a **ForEachLoop** by navigating to **Utilities** | **Array**.
    Link **Array Item** from your **arrayItem** variable to the **Array** tab in the
    **ForEachLoop**. Then, have **SET Inventory Screen** activate the **ForEachLoop**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了玩家库存中的项目数组，我们将遍历每个元素，并从数组中的每个元素创建一个项目。为此，通过导航到**实用工具**|**数组**创建一个**ForEachLoop**。然后，将您的**arrayItem**变量中的**数组项**链接到**ForEachLoop**的**数组**标签。然后，让**设置库存屏幕**激活**ForEachLoop**：
- en: '![Finishing the inventory screen](img/B04548_08_19.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕](img/B04548_08_19.jpg)'
- en: 'Just like what we did when populating the buttons for the shop, we would want
    this `for` loop to be responsible for adding buttons from the **Items** Widget
    Blueprint. So, in the body of the `for` loop, we need to create the **Item** widget
    by first navigating to **User Interface** | **Create Widget** in the **Actions**
    window:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在填充商店按钮时所做的，我们希望这个`for`循环负责添加来自**物品**小部件蓝图中的按钮。因此，在`for`循环体中，我们需要通过首先在**动作**窗口中导航到**用户界面**|**创建小部件**来创建**Item**小部件：
- en: '![Finishing the inventory screen](img/B04548_08_20.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕](img/B04548_08_20.jpg)'
- en: 'Then, we need to change the **Class** dropdown to **Item**, and link it to
    **Loop Body** in the **ForEachLoop**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将**类**下拉菜单更改为**Item**，并将其链接到**ForEachLoop**中的**循环体**：
- en: '![Finishing the inventory screen](img/B04548_08_22.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕](img/B04548_08_22.jpg)'
- en: You will then need to set the text for each element in the array. So, open the
    **Actions** window and with **Context Sensitive** off, bring in **Set Item** by
    navigating to **Class** | **Item**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要为数组中的每个元素设置文本。因此，打开**动作**窗口，关闭**上下文敏感**，通过导航到**类**|**Item**来引入**设置项目**：
- en: 'Link the **Item** pin to the **Array Element** pin from the **ForEachLoop**.
    Then, set the **Target** pin of **Set Item** to the **Return Value** of **Create
    Item Widget** and have **Create Item Widget** activate the **Set Item**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Item**引脚链接到**ForEachLoop**的**Array Element**引脚。然后，将**Set Item**的**Target**引脚设置为**Create
    Item Widget**的**Return Value**，并让**Create Item Widget**激活**Set Item**：
- en: '![Finishing the inventory screen](img/B04548_08_23.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕截图](img/B04548_08_23.jpg)'
- en: 'Lastly, we will need to add the **Item** widget to the Scroll Box that we created
    in **Pause_Inventory**. Simply create an **Add Child** node that is located at
    **Panels** under **Widget**. Then, link **ScrollBox_Inventory** from your variables
    to the **Target** pin of **Add Child** (if you do not see **ScrollBox_Inventory**
    as a default variable, make sure you go back into the Designer View of **Pause_Inventory**,
    select the **ScrollBox_Inventory**, and check **is variable**, then have the **Content**
    pin of **Add Child** be the **Return Value** of **Create Item Widget**). Finally,
    have the **Set Item** node start up the **Add Child** node:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将**Item**小部件添加到我们在**Pause_Inventory**中创建的滚动框中。只需创建一个位于**Widget**下**Panels**中的**Add
    Child**节点。然后，将你的变量中的**ScrollBox_Inventory**链接到**Add Child**的**Target**引脚（如果你看不到**ScrollBox_Inventory**作为默认变量，请确保你回到**Pause_Inventory**的设计视图，选择**ScrollBox_Inventory**，并检查**is
    variable**，然后让**Add Child**的**Content**引脚成为**Create Item Widget**的**Return Value**）。最后，让**Set
    Item**节点启动**Add Child**节点：
- en: '![Finishing the inventory screen](img/B04548_08_24.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕截图](img/B04548_08_24.jpg)'
- en: 'When you are done, your **Pause_Inventory** Blueprint will look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的**Pause_Inventory**蓝图将看起来像这样：
- en: '![Finishing the inventory screen](img/B04548_08_25.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![完成库存屏幕截图](img/B04548_08_25.jpg)'
- en: Buying items
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购买物品
- en: Head back into the **Item** Blueprint. Where we left off before, we allowed
    that upon clicking a button, we would get all actors from the Field Player class.
    Here, we set up a branch that checks whether the **Inventory Screen** Boolean
    is true or false (which means that we check whether the player is on the inventory
    screen; if they are not on the inventory screen, we will perform the buying logic
    in our shop).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到**Item**蓝图。在我们之前停止的地方，我们允许在点击按钮时获取来自**Field Player**类的所有演员。在这里，我们设置了一个分支，检查**Inventory
    Screen**布尔值是真是假（这意味着我们检查玩家是否在库存屏幕上；如果他们不在库存屏幕上，我们将在我们的商店中执行购买逻辑）。
- en: 'Let''s first bring in a **Get Data Table Row** function located under **Utilities**
    in the **Actions** window:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从**Actions**窗口中的**Utilities**下引入一个**Get Data Table Row**函数：
- en: '![Buying items](img/B04548_08_59.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品截图](img/B04548_08_59.jpg)'
- en: 'Then, set the Data Table to **Items_Shop**. This will allow us to get every
    row from the **Items_Shop** Data Table. Then, link the **False** pin from the
    branch that we created to the execution of **Get Data Table Row**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将数据表设置为**Items_Shop**。这将使我们能够从**Items_Shop**数据表中获取每一行。然后，将我们创建的分支中的**False**引脚链接到**Get
    Data Table Row**的执行：
- en: '![Buying items](img/B04548_08_26.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品截图](img/B04548_08_26.jpg)'
- en: 'You may have noticed that we can select any row name from the Data Table. In
    this case, we just need to get the row name of the item that is currently selected.
    To do this, bring in **Get** of the **Item** text variable that you created in
    the previous chapter in this class. You need to link it to **Row Name** in the
    **Get Data Table Row** function, but these pins are not compatible. So, you need
    to first convert the text item to a string by left-clicking and dragging it from
    the **Item** node and then navigating to **Utilities** | **String** | **To String
    (Text)**. This will create the first conversion you need:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们可以从数据表中选择任何行名。在这种情况下，我们只需要获取当前选中物品的行名。为此，将上一章在本课程中创建的**Item**文本变量的**Get**引入，并将其链接到**Get
    Data Table Row**函数中的**Row Name**，但这些引脚不兼容。因此，你需要首先通过左键单击并拖动它从**Item**节点，然后导航到**Utilities**
    | **String** | **To String (Text)**将文本项转换为字符串。这将创建你需要的第一个转换：
- en: '![Buying items](img/B04548_08_27.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品截图](img/B04548_08_27.jpg)'
- en: 'Lastly, you can just link this converted string to the **Row Name** pin in
    the **Get Data Table Row** function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需将这个转换后的字符串链接到**Get Data Table Row**函数中的**Row Name**引脚：
- en: '![Buying items](img/B04548_08_28.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品截图](img/B04548_08_28.jpg)'
- en: 'Once done, we have completed the logic for a specific item being selected in
    the shop. Now, we need to calculate the amount of gold that would be the *value*
    of each item and subtract it from our total gold. To do this, we must first get
    the RPG instance of the game so that we can call the game gold. However, since
    we will need this instance for a number of other variables in this Blueprint,
    we may want the game instance to be called part of our constructor. Create an
    **Event Construct** if you have not done so already. Next, link a **Cast To RPGGameInstance**
    object located at **Casting** under **Utilities**. Then, link the **Get Game Instance**
    object (located in the **Actions** window under **Game**) to the **Cast To RPGGameInstance**
    object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们已经完成了在商店中选择特定物品的逻辑。现在，我们需要计算每个物品的*价值*的金币数量，并从我们的总金币中减去。为此，我们必须首先获取游戏实例，以便我们可以调用游戏金币。然而，由于我们将在本蓝图中的许多其他变量中需要此实例，我们可能希望将游戏实例称为构造函数的一部分。如果你还没有这样做，创建一个**事件构造**。接下来，将位于**实用工具**下的**转换**中的**Cast
    To RPGGameInstance**对象链接。然后，将位于**游戏**下的**动作**窗口中的**获取游戏实例**对象链接到**Cast To RPGGameInstance**对象：
- en: '![Buying items](img/B04548_08_29.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_29.jpg)'
- en: 'Since we will eventually need to access character parameters, such as HP and
    MP, when applying our items to the player, we will need to get all the party members,
    and set a Character Target similar to what we did in previous chapters. To do
    this, create a new variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最终需要访问角色参数，例如HP和MP，在将物品应用到玩家时，我们需要获取所有队伍成员，并设置一个类似于前几章中做的角色目标。为此，创建一个新的变量：
- en: '![Buying items](img/B04548_08_30.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_30.jpg)'
- en: 'Then, go to **Details** | **Variable**, call the **Character Target** variable,
    and change its type to **Game Character**, which will reference our game character
    within the party:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到**详细信息** | **变量**，调用**角色目标**变量，将其类型更改为**游戏角色**，这将引用我们队伍中的游戏角色：
- en: '![Buying items](img/B04548_08_31.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_31.jpg)'
- en: 'Then, from the **As RPGGame Instance** pin, drag out a line, and pick the **Get
    Party Members** variable by navigating to **Variables** | **Game Data**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从**As RPGGame Instance**引脚拖出一条线，并通过导航到**变量** | **游戏数据**选择**Get Party Members**变量：
- en: '![Buying items](img/B04548_08_32.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_32.jpg)'
- en: 'To the **Party Members** array, link a **GET** function. You need to link **GET**
    to the Character Target. So, bring in a **SET** version of the new Character Target
    variable that you created, and link the **GET** function to the **Character Target**
    pin in **SET Character Target**. Lastly, have the **Cast To RPGGameInstance**
    execute **SET Character Target**. When you are finished setting up the reference
    to the game instance and game characters, your constructor will look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个**GET**函数链接到**队伍成员**数组。你需要将**GET**链接到角色目标。所以，引入你创建的新角色目标的**SET**版本，并将**GET**函数链接到**SET角色目标**中的**角色目标**引脚。最后，让**转换为RPGGameInstance**执行**SET角色目标**。当你完成设置游戏实例和游戏角色的引用后，你的构造函数将看起来像这样：
- en: '![Buying items](img/B04548_08_33.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_33.jpg)'
- en: 'Now that we have set a reference to our current game instance, we can manipulate
    the gold. The next thing you need to do is navigate to your **Get Data Table Row**
    function. Here, left-click and drag the **Out Row** pin within the function, which
    will give you some limited options; one of these options is to create **Break
    ItemsData**. This will allow you to access all of the data for each item. Once
    done, you will have a box that shows all of the data that we created in our **Items_Shop**
    Data Table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为当前游戏实例设置了引用，我们可以操作金币。接下来你需要做的是导航到你的**获取数据表行**函数。在这里，左键单击并拖动函数内的**输出行**引脚，这将给你一些有限的选择；其中之一是创建**Break
    ItemsData**。这将允许你访问每个物品的所有数据。一旦完成，你将看到一个显示我们在**Items_Shop**数据表中创建的所有数据的框：
- en: '![Buying items](img/B04548_08_34.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_34.jpg)'
- en: The logic is very simple. Basically, if the user has enough money, allow them
    to purchase an item and subtract the cost of the item by their game gold. If they
    do not have enough money, do not let them purchase the item.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非常简单。基本上，如果用户有足够的钱，允许他们购买物品，并通过他们的游戏金币减去物品的成本。如果他们没有足够的钱，则不允许他们购买物品。
- en: 'To do this, we will create a **Get Game Gold** reference. This can be found
    by navigating to **Class** | **RPGGame Instance** if **Context Sensitive** is
    unchecked:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们将创建一个**获取游戏金币**引用。这可以通过导航到**类** | **RPGGame Instance**来实现，如果未勾选**上下文相关**：
- en: '![Buying items](img/B04548_08_35.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_35.jpg)'
- en: 'Once it is created, link the reference to **As RPGGame Instance** in the **Cast
    To RPGGame Instance**. You may also notice a **SET** pin that sets **HP** to **5**
    in the following screenshot; you may add one or leave it alone. This will just
    indicate that the player starts with 5 HP; this is being done for testing purposes
    when we test the player consuming a potion; if you decide to use **Set HP** for
    testing purposes, remember to remove it when you finish play testing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，将引用链接到**投射到RPG游戏实例**中的**As RPGGame Instance**。您还可能注意到在下图中有一个将**HP**设置为**5**的**SET**引脚；您可以添加一个或让它保持原样。这将仅表示玩家开始时有5点HP；这是在测试玩家消耗药水时进行的测试目的；如果您决定为了测试目的使用**Set
    HP**，请记住在完成游戏测试后将其删除：
- en: '![Buying items](img/B04548_08_36.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_36.jpg)'
- en: 'Now, we will subtract the game gold from the cost of the item being purchased.
    So, simply create a math function that subtracts an integer from an integer. This
    math function can be found by navigating to **Math** | **Integer**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从购买物品的成本中减去游戏金币。因此，只需创建一个从整数减去整数的数学函数。您可以通过导航到**数学** | **整数**来找到此数学函数：
- en: '![Buying items](img/B04548_08_37.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_37.jpg)'
- en: 'To do the math correctly, we will need to link the game gold to the top pin
    of the minus function and the gold from **ItemsData** to the lower pin. This will
    subtract our game gold from the cost of the item:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确进行数学运算，我们需要将游戏金币链接到减法函数的顶部引脚，并将**ItemsData**中的金币链接到底部引脚。这将从物品的成本中减去我们的游戏金币：
- en: '![Buying items](img/B04548_08_38.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_38.jpg)'
- en: 'Here, we need to check whether the player has enough money to purchase the
    item. So, we will check whether the final product is less than 0\. If it is, we
    will not allow the player to make the purchase. To make this check, simply use
    another math function, named **Integer < Integer**, located at **Integer** under
    **Math**. You will then compare the final product of the subtraction with 0, as
    shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要检查玩家是否有足够的钱购买物品。因此，我们将检查最终产品是否小于0。如果是，则不允许玩家进行购买。为此检查，只需使用另一个名为**整数
    < 整数**的数学函数，位于**数学**下的**整数**。然后，将减法最终产品与0进行比较，如下所示：
- en: '![Buying items](img/B04548_08_39.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_39.jpg)'
- en: 'Next, create a branch by navigating to **Utilities** | **Flow Control**, and
    link the condition to the condition of the **Integer < Integer** function you
    just created. Then, link the **Row Found** pin from the **Get Data Table Row**
    to execute the branch so that if a row is found, the math can occur:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过导航到**实用工具** | **流程控制**创建一个分支，并将条件链接到您刚刚创建的**整数 < 整数**函数的条件。然后，将**获取数据表行**的**行找到**引脚链接到执行分支，以便如果找到行，则可以进行数学运算：
- en: '![Buying items](img/B04548_08_40.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_40.jpg)'
- en: 'If the final result is not less than 0, then we need to set the game gold to
    the subtraction product. To do this, bring in the **SET Game Gold** function by
    navigating to **Class** | **RPGGame Instance** in the **Actions** window with
    **Context Sensitive** off:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最终结果不小于0，则需要将游戏金币设置为减法结果。为此，在**动作**窗口中，通过导航到**类** | **RPG游戏实例**并关闭**上下文相关**，引入**SET游戏金币**函数：
- en: '![Buying items](img/B04548_08_41.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_41.jpg)'
- en: 'Link the **Target** pin of **Set Game Gold** to the **As RPGGame Instance**
    pin from the **Cast to RPGGame Instance** function. Then, link the **Game Gold**
    pin to the final product of the subtraction operation to get the remaining game
    gold:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将**游戏金**的**目标**引脚连接到**作为RPG游戏实例**的引脚，从**投射到RPG游戏实例**功能开始。然后，将**游戏金币**引脚连接到减法操作的最终产品，以获取剩余的游戏金币：
- en: '![Buying items](img/B04548_08_42.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_42.jpg)'
- en: 'The last thing we need to do is link everything correctly. The remaining link
    is from the branch; if the less than condition returns false, then it means that
    we have enough money to buy the product, and we can change the game gold. So,
    next, link the **False** pin from the branch to execute **SET Game Gold**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要正确地链接所有内容。剩余的链接来自分支；如果小于条件返回false，则表示我们有足够的钱购买产品，并且可以更改游戏金币。因此，接下来，将分支的**False**引脚链接到执行**SET游戏金币**：
- en: '![Buying items](img/B04548_08_43.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_43.jpg)'
- en: 'If you were to test this now, you would notice that items can be purchased
    flawlessly from the shop. However, the problem is that the items are never being
    populated from the shop to the player''s inventory. This is a simple fix. Earlier
    in this chapter, we already set our inventory screen to be able to get an array
    that can be stored in the Field Player. We will simply use this array to add the
    items that we buy to the array, and then, retrieve these items when we open our
    inventory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试这个程序，你会注意到物品可以从商店无缝购买。然而，问题是物品从未从商店填充到玩家的库存中。这是一个简单的修复。在本章的早期，我们已经设置了我们的库存屏幕，使其能够获取一个可以存储在**玩家字段**中的数组。我们将简单地使用这个数组来添加我们购买的物品到数组中，然后，在我们打开我们的库存时检索这些物品：
- en: '![Buying items](img/B04548_08_44.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_44.jpg)'
- en: Since we already have a way to gather variables from the Field Player, we will
    bring in the **Get Array Item** variable by navigating to **Class** | **Field
    Player**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一种从**玩家字段**收集变量的方法，我们将通过导航到**类**|**玩家字段**来引入**获取数组项**变量。
- en: 'We will link the **Target** pin of **Array Item** to the **GET** of the **Get
    All Actors Of Class** function so that we have full access over the `arrayItem`
    variable. We will then bring in an **Add** function by navigating to **Utilities**
    | **Array** in the **Actions** window:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将链接**数组项**的**目标**引脚到**获取所有类别的演员**函数的**GET**，以便我们能够完全访问`arrayItem`变量。然后，我们将在**动作**窗口中导航到**实用工具**|**数组**来引入一个**添加**函数：
- en: '![Buying items](img/B04548_08_45.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_45.jpg)'
- en: 'The **Add** function will allow you to add elements to an array while dynamically
    increasing its size (such as a list). To use this, you will link the array that
    you want to populate; in this case, **Array Item**. Then, you will need to link
    the item that you want to add to the array; in this case, **Item**. Lastly, you
    will need to execute **Add**. We will execute it after the **Gold** value is set.
    In essence, after the player buys the item, the item will then be added to their
    inventory:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加**函数将允许你在动态增加其大小（例如列表）的同时向数组中添加元素。要使用此功能，你需要链接你想要填充的数组；在这种情况下，**数组项**。然后，你需要链接你想要添加到数组中的项目；在这种情况下，**项目**。最后，你需要执行**添加**操作。我们将在设置**黄金**值之后执行它。本质上，在玩家购买物品后，该物品将被添加到他们的库存中：'
- en: '![Buying items](img/B04548_08_46.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品](img/B04548_08_46.jpg)'
- en: Your buying mechanics are now complete, and you can now test your shop. You
    will notice that items can be purchased and these purchased items populate your
    inventory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你的购买机制现在已经完成，你现在可以测试你的商店了。你会注意到物品可以被购买，并且这些购买的物品填充了你的库存。
- en: Using items
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用物品
- en: Now that you have allowed items to populate the inventory, it is now time to
    make these items work. At this moment, you should still have a branch at the beginning
    of your item's **onClicked** button. So far, your branch just goes through a false
    routine because this routine indicates that the player is interacting with the
    buttons if they are in the shop. It is now time to create a routine for when the
    **Inventory Screen** Boolean is true, which means that the player is on the inventory
    screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经允许物品填充库存，现在是时候让这些物品发挥作用了。此时，你应该仍然在你的物品的**onClicked**按钮的起始位置有一个分支。到目前为止，你的分支只是通过一个错误的程序，因为这个程序表示如果玩家在商店中，他们正在与按钮交互。现在是时候为当**库存屏幕**布尔值为真时创建一个程序，这意味着玩家正在库存屏幕上。
- en: 'The initial steps between where we created a **Get Data Table Row** function
    and set it to the **Item_Shop** Data Table (which takes an item row name and breaks
    the items into item data) are identical to our previous steps. So, we can simply
    copy and paste those portions from our previous steps into an empty area in this
    Blueprint:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建**获取数据表行**函数并将其设置为**商店项目**数据表（该数据表接受项目行名称并将项目分解为项目数据）之间的初始步骤与我们的先前步骤相同。因此，我们可以简单地从我们的先前步骤中复制并粘贴这些部分到这个蓝图中的空白区域：
- en: '![Using items](img/B04548_08_47.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_47.jpg)'
- en: 'Next, we will link the **True** pin from our initial branch (that is activated
    by the **Get All Actors Of Class** function) to execute the **Get Data Table Row**
    function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从我们的初始分支（由**获取所有类别的演员**函数激活）链接**True**引脚以执行**获取数据表行**函数：
- en: '![Using items](img/B04548_08_48.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_48.jpg)'
- en: 'We will implement logic that is very similar to the logic that we implemented
    when purchasing items; but this time, we want to make sure that the user gets
    the correct amount set to them when using an item. Let''s first start with the
    potion. The potion only uses the HP data. So, what we will need to do is add the
    HP data from the potion to the character''s current HP. To do this, we will first
    need a Character Target variable. So, bring in a **Get Character Target** function
    from your **Variable** list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现与购买物品时实现的逻辑非常相似的逻辑；但这次，我们想确保用户在使用物品时得到正确的数量设置。让我们首先从药水开始。药水只使用HP数据。因此，我们需要做的是将药水的HP数据添加到角色的当前HP中。为此，我们首先需要一个角色目标变量。所以，从你的**变量**列表中引入一个**获取角色目标**函数：
- en: '![Using items](img/B04548_08_49.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_49.jpg)'
- en: 'Once you do this, link the **Character Target** variable to **Get HP**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，将**角色目标**变量连接到**获取HP**：
- en: '![Using items](img/B04548_08_50.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_50.jpg)'
- en: 'Now that you have access to the current player''s HP, you can bring in the
    **Integer + Integer** function by navigating to **Math** | **Integer**. Simply
    link the **HP** pin from the **Break ItemsData** node to the top pin in the **Integer
    + Integer** function, and link the character HP to the bottom pin of the **Integer
    + Integer** node:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以访问当前玩家的HP，可以通过导航到**数学** | **整数**引入**整数 + 整数**函数。只需将**Break ItemsData**节点中的**HP**引脚连接到**整数
    + 整数**函数的顶部引脚，并将角色HP连接到**整数 + 整数**节点的底部引脚：
- en: '![Using items](img/B04548_08_51.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_51.jpg)'
- en: 'Here, we need to check whether the product of the addition is less than the
    character''s maximum HP. If it is, we can use the potion. If it is not, we cannot
    use the potion. So, let''s first bring in the **Get MHP** variable from **Character
    Target**, which shows what the character''s maximum HP is like:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要检查加法的结果是否小于角色的最大HP。如果是，我们可以使用药水。如果不是，我们不能使用药水。所以，让我们首先从**角色目标**中引入**Get
    MHP**变量，它显示了角色的最大HP是什么样的：
- en: '![Using items](img/B04548_08_52.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_52.jpg)'
- en: 'Now, we will need to bring in a condition that checks whether an integer is
    less than another integer. This can be found in the **Actions** window by navigating
    to **Math** | **Integer**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要引入一个检查一个整数是否小于另一个整数的条件。这可以在**动作**窗口中通过导航到**数学** | **整数**找到：
- en: '![Using items](img/B04548_08_53.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_53.jpg)'
- en: 'Next, link the final addition product to the upper pin of the **Integer < Integer**
    condition, and link **MHP** to the lower pin:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将最终加法结果连接到**整数 < 整数**条件的上部引脚，并将**MHP**连接到下部引脚：
- en: '![Using items](img/B04548_08_54.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_54.jpg)'
- en: 'We will now make a branch that checks our condition. This branch should be
    activated only if a row is found (or if the user clicks on an actual item):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个检查我们条件的分支。这个分支应该只在找到行（或用户点击实际物品）时激活：
- en: '![Using items](img/B04548_08_55.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_55.jpg)'
- en: 'If the total HP is less than the maximum HP, then this would mean that the
    condition is true, and we need to remove the item from the inventory using the
    **Remove from Parent** function located under **Widget**. Then, we need to use
    the **SET HP** function by navigating to **Class** | **Game Character** and making
    it equal to the addition of the product item HP and character HP. We will also
    need to link the **Target** pin of the **SET HP** function to the reference to
    **Character Target**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总HP小于最大HP，那么这意味着条件为真，我们需要使用位于**小部件**下的**从父级移除**函数从库存中移除物品。然后，我们需要使用**SET HP**函数，通过导航到**类**
    | **游戏角色**并使其等于产品物品HP和角色HP的总和。我们还需要将**SET HP**函数的**目标**引脚连接到**角色目标**的引用：
- en: '![Using items](img/B04548_08_56.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_56.jpg)'
- en: 'If you test this now, the character will be able to use potions, and the potions
    will be removed on use, but the user won''t be able to fully heal because we are
    only testing to see whether the product of our addition is more than the maximum
    HP, which only accounts for situations where a potion''s healing properties are
    not fully used. Therefore, the character may never be able to be 100% recovered.
    To fix this, we will simply create a routine for the **False** branch that will
    remove the item from the parent, and then, automatically set the HP to the maximum
    HP. This will solve our problem of not being able to heal our character all the
    way to their maximum health:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试这个，角色将能够使用药水，并且使用后药水会被移除，但用户无法完全恢复生命值，因为我们只是测试我们的添加是否超过了最大生命值，这仅适用于药水的治疗属性未完全使用的情况。因此，角色可能永远无法恢复到100%。为了解决这个问题，我们将简单地创建一个用于**False**分支的例程，该例程将从父项中移除物品，然后自动将生命值设置为最大生命值。这将解决我们无法将角色恢复到最大健康值的问题：
- en: '![Using items](img/B04548_08_57.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_57.jpg)'
- en: 'When you are done with this, your HP-based items'' Blueprint will look like
    this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这个任务后，你的基于HP的物品蓝图将看起来像这样：
- en: '![Using items](img/B04548_08_58.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用物品](img/B04548_08_58.jpg)'
- en: If you test this now, you will notice that all of your potions work perfectly
    in your inventory. The last potion that we did not finish is the ether, but the
    ether logic is exactly the same as the potion logic, though instead of checking
    the effects of HP, you are checking the effects of MP. Note that this logic is
    not specific to any one item, it is dynamic to the point where any item that affects
    these stats will run using this logic. So, if later on you have a mega potion,
    you will not have to redo any logic or add new logic, the mega potion is still
    considered an item and will apply the correct amount of HP that was given to it
    through the Data Table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试这个，你会注意到你的所有药水在你的库存中工作得非常完美。我们未完成的最后一种药水是以太，但以太的逻辑与药水逻辑完全相同，尽管你检查的是MP的效果而不是HP的效果。请注意，这种逻辑并不特定于任何单个物品，它是动态的，任何影响这些属性的物品都会使用这种逻辑。所以，如果你以后有一个超级药水，你不需要重做任何逻辑或添加新逻辑，超级药水仍然被视为一个物品，并且会应用通过数据表给予的正确数量的HP。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At this point, you now have your currency system that interacts with an NPC.
    You are able to buy items from the NPC and stock as many items as you want in
    your inventory, and then correctly use them. Using this knowledge, you should
    easily be able to create more items throughout the game using the same strategies
    that we covered in the last couple of chapters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你现在有了与NPC交互的货币系统。你能够从NPC那里购买物品，并在你的库存中存放尽可能多的物品，然后正确地使用它们。利用这些知识，你应该能够轻松地在游戏中创建更多物品，使用我们在上一章中讨论的策略。
- en: In the next chapter, we will dig deeper into useable items and work with equipping
    weapons and armor, which will temporarily change the stats of a player.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨可使用物品，并处理装备武器和盔甲，这将暂时改变玩家的属性。
