["```cpp\n#include <boost/predef.h> // Tools to identify the OS.\n\n// We need this to enable cancelling of I/O operations on\n// Windows XP, Windows Server 2003 and earlier.\n// Refer to \"http://www.boost.org/doc/libs/1_58_0/\n// doc/html/boost_asio/reference/basic_stream_socket/\n// cancel/overload1.html\" for details.\n#ifdef BOOST_OS_WINDOWS\n#define _WIN32_WINNT 0x0501\n\n#if _WIN32_WINNT <= 0x0502 // Windows Server 2003 or earlier.\n#define BOOST_ASIO_DISABLE_IOCP\n#define BOOST_ASIO_ENABLE_CANCELIO  \n#endif\n#endif\n```", "```cpp\n#include <boost/asio.hpp>\n\n#include <thread>\n#include <mutex>\n#include <memory>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nnamespace http_errors {\n  enum http_error_codes\n  {\n    invalid_response = 1\n  };\n```", "```cpp\n  class http_errors_category\n    : public boost::system::error_category\n  {\n  public:\n    const char* name() const BOOST_SYSTEM_NOEXCEPT \n    { return \"http_errors\"; }\n\n    std::string message(int e) const {\n      switch (e) {\n      case invalid_response:\n        return \"Server response cannot be parsed.\";\n        break;\n      default:\n        return \"Unknown error.\";\n        break;\n      }\n    }\n  };\n```", "```cpp\nconst boost::system::error_category&\nget_http_errors_category()\n{\n    static http_errors_category cat;\n    return cat;\n  }\n\n  boost::system::error_code\n    make_error_code(http_error_codes e)\n  {\n    return boost::system::error_code(\n      static_cast<int>(e), get_http_errors_category());\n  }\n} // namespace http_errors\n```", "```cpp\nnamespace boost {\n  namespace system {\n    template<>\nstruct is_error_code_enum\n<http_errors::http_error_codes>\n{\n      BOOST_STATIC_CONSTANT(bool, value = true);\n    };\n  } // namespace system\n} // namespace boost\n```", "```cpp\nclass HTTPClient;\nclass HTTPRequest;\nclass HTTPResponse;\n\ntypedef void(*Callback) (const HTTPRequest& request,\n  const HTTPResponse& response,\n  const system::error_code& ec);\n```", "```cpp\nclass HTTPResponse {\n  friend class HTTPRequest;\n  HTTPResponse() : \n    m_response_stream(&m_response_buf)\n  {}\npublic:\n\n  unsigned int get_status_code() const {\n    return m_status_code;\n  }\n\n  const std::string& get_status_message() const {\n    return m_status_message;\n  }\n\n  const std::map<std::string, std::string>& get_headers() {\n    return m_headers;\n  }\n\n  const std::istream& get_response() const {\n    return m_response_stream;\n  }\n\nprivate:\n  asio::streambuf& get_response_buf() {\n    return m_response_buf;\n  }\n\n  void set_status_code(unsigned int status_code) {\n    m_status_code = status_code;\n  }\n\n  void set_status_message(const std::string& status_message) {\n    m_status_message = status_message;\n  }\n\n  void add_header(const std::string& name, \n  const std::string& value) \n  {\n    m_headers[name] = value;\n  }\n\nprivate:\n  unsigned int m_status_code; // HTTP status code.\n  std::string m_status_message; // HTTP status message.\n\n  // Response headers.\n  std::map<std::string, std::string> m_headers;\n  asio::streambuf m_response_buf;\n  std::istream m_response_stream;\n};\n```", "```cpp\nclass HTTPRequest {\n  friend class HTTPClient;\n\n  static const unsigned int DEFAULT_PORT = 80;\n\n  HTTPRequest(asio::io_service& ios, unsigned int id) :\n    m_port(DEFAULT_PORT),\n    m_id(id),\n    m_callback(nullptr),\n    m_sock(ios),\n    m_resolver(ios),\n    m_was_cancelled(false),\n    m_ios(ios)  \n{}\n```", "```cpp\npublic:\n  void set_host(const std::string& host) {\n    m_host = host;\n  }\n\n  void set_port(unsigned int port) {\n    m_port = port;\n  }\n\n  void set_uri(const std::string& uri) {\n    m_uri = uri;\n  }\n\n  void set_callback(Callback callback) {\n    m_callback = callback;\n  }\n\n  std::string get_host() const {\n    return m_host;\n  }\n\n  unsigned int get_port() const {\n    return m_port;\n  }\n\n  const std::string& get_uri() const {\n    return m_uri;\n  }\n\n  unsigned int get_id() const {\n    return m_id;\n  }\n\n  void execute() {\n    // Ensure that precorditions hold.\n    assert(m_port > 0);\n    assert(m_host.length() > 0);\n    assert(m_uri.length() > 0);\n    assert(m_callback != nullptr);\n\n    // Prepare the resolving query.\n    asio::ip::tcp::resolver::query resolver_query(m_host,\n      std::to_string(m_port), \n      asio::ip::tcp::resolver::query::numeric_service);\n\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    if (m_was_cancelled) {\n      cancel_lock.unlock();\n      on_finish(boost::system::error_code(\n      asio::error::operation_aborted));\n      return;\n    }\n\n    // Resolve the host name.\n    m_resolver.async_resolve(resolver_query,\n      [this](const boost::system::error_code& ec,\n      asio::ip::tcp::resolver::iterator iterator)\n    {\n      on_host_name_resolved(ec, iterator);\n    });\n  }\n\n  void cancel() {\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    m_was_cancelled = true;\n\n    m_resolver.cancel();\n\n    if (m_sock.is_open()) {\n      m_sock.cancel();\n    }  \n}\n```", "```cpp\nprivate:\n  void on_host_name_resolved(\n    const boost::system::error_code& ec,\n    asio::ip::tcp::resolver::iterator iterator) \n{\n    if (ec != 0) {\n      on_finish(ec);\n      return;\n    }\n\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    if (m_was_cancelled) {\n      cancel_lock.unlock();\n      on_finish(boost::system::error_code(\n      asio::error::operation_aborted));\n      return;\n    }\n\n    // Connect to the host.\n    asio::async_connect(m_sock,\n      iterator,\n      [this](const boost::system::error_code& ec,\n      asio::ip::tcp::resolver::iterator iterator)\n    {\n      on_connection_established(ec, iterator);\n    });\n\n  }\n```", "```cpp\n  void on_connection_established(\n    const boost::system::error_code& ec,\n    asio::ip::tcp::resolver::iterator iterator) \n{\n    if (ec != 0) {\n      on_finish(ec);\n      return;\n    }\n\n    // Compose the request message.\n    m_request_buf += \"GET \" + m_uri + \" HTTP/1.1\\r\\n\";\n\n    // Add mandatory header.\n    m_request_buf += \"Host: \" + m_host + \"\\r\\n\";\n\n    m_request_buf += \"\\r\\n\";\n\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    if (m_was_cancelled) {\n      cancel_lock.unlock();\n      on_finish(boost::system::error_code(\n      asio::error::operation_aborted));\n      return;\n    }\n\n    // Send the request message.\n    asio::async_write(m_sock,\n      asio::buffer(m_request_buf),\n      [this](const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_request_sent(ec, bytes_transferred);\n    });\n  }\n```", "```cpp\n  void on_request_sent(const boost::system::error_code& ec,\n    std::size_t bytes_transferred) \n{\n    if (ec != 0) {\n      on_finish(ec);\n      return;\n    }\n\n    m_sock.shutdown(asio::ip::tcp::socket::shutdown_send);\n\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    if (m_was_cancelled) {\n      cancel_lock.unlock();\n      on_finish(boost::system::error_code(\n      asio::error::operation_aborted));\n      return;\n    }\n\n    // Read the status line.\n    asio::async_read_until(m_sock,\n      m_response.get_response_buf(),\n      \"\\r\\n\",\n      [this](const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_status_line_received(ec, bytes_transferred);\n    });\n  }\n```", "```cpp\n  void on_status_line_received(\n    const boost::system::error_code& ec,\n    std::size_t bytes_transferred)\n  {\n    if (ec != 0) {\n      on_finish(ec);\n      return;\n    }\n\n    // Parse the status line.\n    std::string http_version;\n    std::string str_status_code;\n    std::string status_message;\n\n    std::istream response_stream(\n    &m_response.get_response_buf());\n    response_stream >> http_version;\n\n    if (http_version != \"HTTP/1.1\"){\n      // Response is incorrect.\n      on_finish(http_errors::invalid_response);\n      return;\n    }\n\n    response_stream >> str_status_code;\n\n    // Convert status code to integer.\n    unsigned int status_code = 200;\n\n    try {\n      status_code = std::stoul(str_status_code);\n    }\n    catch (std::logic_error&) {\n      // Response is incorrect.\n      on_finish(http_errors::invalid_response);\n      return;\n    }\n\n    std::getline(response_stream, status_message, '\\r');\n    // Remove symbol '\\n' from the buffer.\n    response_stream.get();\n\n    m_response.set_status_code(status_code);\n    m_response.set_status_message(status_message);\n\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    if (m_was_cancelled) {\n      cancel_lock.unlock();\n      on_finish(boost::system::error_code(\n      asio::error::operation_aborted));\n      return;\n    }\n\n    // At this point the status line is successfully\n    // received and parsed.\n    // Now read the response headers.\n    asio::async_read_until(m_sock,\n      m_response.get_response_buf(),\n      \"\\r\\n\\r\\n\",\n      [this](\n      const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_headers_received(ec,\n        bytes_transferred);\n    });\n  }\n```", "```cpp\n  void on_headers_received(const boost::system::error_code& ec,\n    std::size_t bytes_transferred) \n{\n    if (ec != 0) {\n      on_finish(ec);\n      return;\n    }\n\n    // Parse and store headers.\n    std::string header, header_name, header_value;\n    std::istream response_stream(\n    &m_response.get_response_buf());\n\n    while (true) {\n      std::getline(response_stream, header, '\\r');\n\n      // Remove \\n symbol from the stream.\n      response_stream.get();\n\n      if (header == \"\")\n        break;\n\n      size_t separator_pos = header.find(':');\n      if (separator_pos != std::string::npos) {\n        header_name = header.substr(0,\n        separator_pos);\n\n        if (separator_pos < header.length() - 1)\n          header_value =\n          header.substr(separator_pos + 1);\n        else\n          header_value = \"\";\n\n        m_response.add_header(header_name,\n        header_value);\n      }\n    }\n\n    std::unique_lock<std::mutex>\n      cancel_lock(m_cancel_mux);\n\n    if (m_was_cancelled) {\n      cancel_lock.unlock();\n      on_finish(boost::system::error_code(\n      asio::error::operation_aborted));\n      return;\n    }\n\n    // Now we want to read the response body.\n    asio::async_read(m_sock,\n      m_response.get_response_buf(),\n      [this](\n      const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_response_body_received(ec,\n        bytes_transferred);\n    });\n\n    return;\n  }\n```", "```cpp\nvoid on_response_body_received(\nconst boost::system::error_code& ec,\n    std::size_t bytes_transferred) \n{\n    if (ec == asio::error::eof)\n      on_finish(boost::system::error_code());\n    else\n      on_finish(ec);  \n}\n```", "```cpp\n  void on_finish(const boost::system::error_code& ec) \n{\n    if (ec != 0) {\n      std::cout << \"Error occured! Error code = \"\n        << ec.value()\n        << \". Message: \" << ec.message();\n    }\n\n    m_callback(*this, m_response, ec);\n\n    return;\n  }\n```", "```cpp\nprivate:\n  // Request parameters. \n  std::string m_host;\n  unsigned int m_port;\n  std::string m_uri;\n\n  // Object unique identifier. \n  unsigned int m_id;\n\n  // Callback to be called when request completes. \n  Callback m_callback;\n\n  // Buffer containing the request line.\n  std::string m_request_buf;\n\n  asio::ip::tcp::socket m_sock;  \n  asio::ip::tcp::resolver m_resolver;\n\n  HTTPResponse m_response;\n\n  bool m_was_cancelled;\n  std::mutex m_cancel_mux;\n\n  asio::io_service& m_ios;\n```", "```cpp\n};\n```", "```cpp\nclass HTTPClient {\npublic:\n  HTTPClient(){\n    m_work.reset(new boost::asio::io_service::work(m_ios));\n\n    m_thread.reset(new std::thread([this](){\n      m_ios.run();\n    }));\n  }\n\n  std::shared_ptr<HTTPRequest>\n  create_request(unsigned int id) \n  {\n    return std::shared_ptr<HTTPRequest>(\n    new HTTPRequest(m_ios, id));\n  }\n\n  void close() {\n    // Destroy the work object. \n    m_work.reset(NULL);\n\n    // Waiting for the I/O thread to exit.\n    m_thread->join();\n  }\n\nprivate:\n  asio::io_service m_ios;\n  std::unique_ptr<boost::asio::io_service::work> m_work;\n  std::unique_ptr<std::thread> m_thread;\n};\n```", "```cpp\nvoid handler(const HTTPRequest& request,\n  const HTTPResponse& response,\n  const system::error_code& ec)\n{\n  if (ec == 0) {\n    std::cout << \"Request #\" << request.get_id()\n      << \" has completed. Response: \"\n      << response.get_response().rdbuf();\n  }\n  else if (ec == asio::error::operation_aborted) {\n    std::cout << \"Request #\" << request.get_id()\n      << \" has been cancelled by the user.\" \n      << std::endl;\n  }\n  else {\n    std::cout << \"Request #\" << request.get_id()\n      << \" failed! Error code = \" << ec.value()\n      << \". Error message = \" << ec.message() \n    << std::endl;\n  }\n\n  return;\n}\n```", "```cpp\nint main()\n{\n  try {\n    HTTPClient client;\n\n    std::shared_ptr<HTTPRequest> request_one =\n      client.create_request(1);\n\n    request_one->set_host(\"localhost\");\n    request_one->set_uri(\"/index.html\");\n    request_one->set_port(3333);\n    request_one->set_callback(handler);\n\n    request_one->execute();\n\n    std::shared_ptr<HTTPRequest> request_two =\n      client.create_request(1);\n\n    request_two->set_host(\"localhost\");\n    request_two->set_uri(\"/example.html\");\n    request_two->set_port(3333);\n    request_two->set_callback(handler);\n\n    request_two->execute();\n\n    request_two->cancel();\n\n    // Do nothing for 15 seconds, letting the\n    // request complete.\n    std::this_thread::sleep_for(std::chrono::seconds(15));\n\n    // Closing the client and exiting the application.\n    client.close();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n};\n```", "```cpp\n      std::string m_host;\n      unsigned int m_port;\n      std::string m_uri;\n    ```", "```cpp\n      unsigned int m_id;\n    ```", "```cpp\n      Callback m_callback;\n    ```", "```cpp\n      std::string m_request_buf;\n    ```", "```cpp\n      asio::ip::tcp::socket m_sock;\n    ```", "```cpp\n      asio::ip::tcp::resolver m_resolver;\n    ```", "```cpp\n      HTTPResponse m_response;\n    ```", "```cpp\n      bool m_was_cancelled;\n      std::mutex m_cancel_mux;\n    ```", "```cpp\n      asio::io_service& m_ios;\n    ```", "```cpp\n#include <boost/asio.hpp>\n#include <boost/filesystem.hpp>\n\n#include <fstream>\n#include <atomic>\n#include <thread>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nclass Service {\n  static const std::map<unsigned int, std::string>\nhttp_status_table;\n```", "```cpp\npublic:\n  Service(std::shared_ptr<boost::asio::ip::tcp::socket> sock) :\n    m_sock(sock),\n    m_request(4096),\n    m_response_status_code(200), // Assume success.\n    m_resource_size_bytes(0)\n  {};\n```", "```cpp\n  void start_handling() {\n    asio::async_read_until(*m_sock.get(),\n      m_request,\n      \"\\r\\n\",\n      [this](\n      const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_request_line_received(ec,\n        bytes_transferred);\n    });\n  }\n```", "```cpp\nprivate:\n  void on_request_line_received(\n    const boost::system::error_code& ec,\n    std::size_t bytes_transferred) \n{\n    if (ec != 0) {\n      std::cout << \"Error occured! Error code = \"\n        << ec.value()\n        << \". Message: \" << ec.message();\n\n      if (ec == asio::error::not_found) {\n        // No delimiter has been found in the\n        // request message.\n\n        m_response_status_code = 413;\n        send_response();\n\n        return;\n      }\n      else {\n        // In case of any other error –\n        // close the socket and clean up.\n        on_finish();\n        return;\n      }\n    }\n\n    // Parse the request line.\n    std::string request_line;\n    std::istream request_stream(&m_request);\n    std::getline(request_stream, request_line, '\\r');\n    // Remove symbol '\\n' from the buffer.\n    request_stream.get();\n\n    // Parse the request line.\n    std::string request_method;\n    std::istringstream request_line_stream(request_line);\n    request_line_stream >> request_method;\n\n    // We only support GET method.\n    if (request_method.compare(\"GET\") != 0) {\n      // Unsupported method.\n      m_response_status_code = 501;\n      send_response();\n\n      return;\n    }\n\n    request_line_stream >> m_requested_resource;\n\n    std::string request_http_version;\n    request_line_stream >> request_http_version;\n\n    if (request_http_version.compare(\"HTTP/1.1\") != 0) {\n      // Unsupported HTTP version or bad request.\n      m_response_status_code = 505;\n      send_response();\n\n      return;\n    }\n\n    // At this point the request line is successfully\n    // received and parsed. Now read the request headers.\n    asio::async_read_until(*m_sock.get(),\n      m_request,\n      \"\\r\\n\\r\\n\",\n      [this](\n      const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_headers_received(ec,\n        bytes_transferred);\n    });\n\n    return;\n  }\n```", "```cpp\n  void on_headers_received(const boost::system::error_code& ec,\n    std::size_t bytes_transferred)  \n  {\n    if (ec != 0) {\n      std::cout << \"Error occured! Error code = \"\n        << ec.value()\n        << \". Message: \" << ec.message();\n\n      if (ec == asio::error::not_found) {\n        // No delimiter has been fonud in the\n        // request message.\n\n        m_response_status_code = 413;\n        send_response();\n        return;\n      }\n      else {\n        // In case of any other error - close the\n        // socket and clean up.\n        on_finish();\n        return;\n      }\n    }\n\n    // Parse and store headers.\n    std::istream request_stream(&m_request);\n    std::string header_name, header_value;\n\n    while (!request_stream.eof()) {\n      std::getline(request_stream, header_name, ':');\n      if (!request_stream.eof()) {\n        std::getline(request_stream, \n        header_value, \n      '\\r');\n\n        // Remove symbol \\n from the stream.\n        request_stream.get();\n        m_request_headers[header_name] =\n        header_value;\n      }\n    }\n\n    // Now we have all we need to process the request.\n    process_request();\n    send_response();\n\n    return;\n  }\n```", "```cpp\n  void process_request() {\n    // Read file.\n    std::string resource_file_path =\n    std::string(\"D:\\\\http_root\") +\n    m_requested_resource;\n\n    if (!boost::filesystem::exists(resource_file_path)) {\n      // Resource not found.\n      m_response_status_code = 404;\n\n      return;\n    }\n\n    std::ifstream resource_fstream(\n    resource_file_path, \n    std::ifstream::binary);\n\n    if (!resource_fstream.is_open()) {\n      // Could not open file. \n      // Something bad has happened.\n      m_response_status_code = 500;\n\n      return;\n    }\n\n    // Find out file size.\n    resource_fstream.seekg(0, std::ifstream::end);\n    m_resource_size_bytes =\n    static_cast<std::size_t>(\n    resource_fstream.tellg());\n\n    m_resource_buffer.reset(\n    new char[m_resource_size_bytes]);\n\n    resource_fstream.seekg(std::ifstream::beg);\n    resource_fstream.read(m_resource_buffer.get(),\n    m_resource_size_bytes);\n\n    m_response_headers += std::string(\"content-length\") +\n      \": \" +\n      std::to_string(m_resource_size_bytes) +\n      \"\\r\\n\";\n  }\n```", "```cpp\n  void send_response()  {\n    m_sock->shutdown(\n    asio::ip::tcp::socket::shutdown_receive);\n\n    auto status_line =\n      http_status_table.at(m_response_status_code);\n\n    m_response_status_line = std::string(\"HTTP/1.1 \") +\n      status_line +\n      \"\\r\\n\";\n\n    m_response_headers += \"\\r\\n\";\n\n    std::vector<asio::const_buffer> response_buffers;\n    response_buffers.push_back(\n    asio::buffer(m_response_status_line));\n\n    if (m_response_headers.length() > 0) {\n      response_buffers.push_back(\n      asio::buffer(m_response_headers));\n    }\n\n    if (m_resource_size_bytes > 0) {\n      response_buffers.push_back(\n      asio::buffer(m_resource_buffer.get(),\n      m_resource_size_bytes));\n    }\n\n    // Initiate asynchronous write operation.\n    asio::async_write(*m_sock.get(),\n      response_buffers,\n      [this](\n      const boost::system::error_code& ec,\n      std::size_t bytes_transferred)\n    {\n      on_response_sent(ec,\n        bytes_transferred);\n    });\n  }\n```", "```cpp\n  void on_response_sent(const boost::system::error_code& ec,\n    std::size_t bytes_transferred) \n{\n    if (ec != 0) {\n      std::cout << \"Error occured! Error code = \"\n        << ec.value()\n        << \". Message: \" << ec.message();\n    }\n\n    m_sock->shutdown(asio::ip::tcp::socket::shutdown_both);\n\n    on_finish();\n  }\n```", "```cpp\n  // Here we perform the cleanup.\n  void on_finish() {\n    delete this;\n  }\n```", "```cpp\nprivate:\n  std::shared_ptr<boost::asio::ip::tcp::socket> m_sock;\n  boost::asio::streambuf m_request;\n  std::map<std::string, std::string> m_request_headers;\n  std::string m_requested_resource;\n\n  std::unique_ptr<char[]> m_resource_buffer;  \n  unsigned int m_response_status_code;\n  std::size_t m_resource_size_bytes;\n  std::string m_response_headers;\n  std::string m_response_status_line;\n};\n```", "```cpp\nconst std::map<unsigned int, std::string>\n  Service::http_status_table = \n{\n  { 200, \"200 OK\" },\n  { 404, \"404 Not Found\" },\n  { 413, \"413 Request Entity Too Large\" },\n  { 500, \"500 Server Error\" },\n  { 501, \"501 Not Implemented\" },\n  { 505, \"505 HTTP Version Not Supported\" }\n};\n```", "```cpp\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nclass SyncSSLClient {\npublic:\n  SyncSSLClient(const std::string& raw_ip_address,\n    unsigned short port_num) :\n    m_ep(asio::ip::address::from_string(raw_ip_address),\n    port_num),\n    m_ssl_context(asio::ssl::context::sslv3_client),    \n    m_ssl_stream(m_ios, m_ssl_context)\n  {\n // Set verification mode and designate that \n // we want to perform verification.\n m_ssl_stream.set_verify_mode(asio::ssl::verify_peer);\n\n // Set verification callback. \n m_ssl_stream.set_verify_callback([this](\n bool preverified,\n asio::ssl::verify_context& context)->bool{\n return on_peer_verify(preverified, context);\n });  \n  }\n\n  void connect() {\n // Connect the TCP socket.\n m_ssl_stream.lowest_layer().connect(m_ep);\n\n // Perform the SSL handshake.\n m_ssl_stream.handshake(asio::ssl::stream_base::client);\n  }\n\n  void close() {\n    // We ignore any errors that might occur\n // during shutdown as we anyway can't\n // do anything about them.\n boost::system::error_code ec;\n\n m_ssl_stream.shutdown(ec); // Shutdown SSL.\n\n // Shut down the socket.\n m_ssl_stream.lowest_layer().shutdown(\n boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n m_ssl_stream.lowest_layer().close(ec);\n  }\n\n  std::string emulate_long_computation_op(\n    unsigned int duration_sec) {\n\n    std::string request = \"EMULATE_LONG_COMP_OP \"\n      + std::to_string(duration_sec)\n      + \"\\n\";\n\n    send_request(request);\n    return receive_response();\n  };\n\nprivate:\n  bool on_peer_verify(bool preverified,\n asio::ssl::verify_context& context) \n {\n // Here the certificate should be verified and the\n // verification result should be returned.\n return true;\n }\n\n  void send_request(const std::string& request) {\n    asio::write(m_ssl_stream, asio::buffer(request));\n  }\n\n  std::string receive_response() {\n    asio::streambuf buf;\n    asio::read_until(m_ssl_stream, buf, '\\n');\n\n    std::string response;\n    std::istream input(&buf);\n    std::getline(input, response);\n\n    return response;\n  }\n\nprivate:\n  asio::io_service m_ios;\n  asio::ip::tcp::endpoint m_ep;\n\n  asio::ssl::context m_ssl_context;\n asio::ssl::stream<asio::ip::tcp::socket>m_ssl_stream;\n};\n```", "```cpp\nint main()\n{\n  const std::string raw_ip_address = \"127.0.0.1\";\n  const unsigned short port_num = 3333;\n\n  try {\n    SyncSSLClient client(raw_ip_address, port_num);\n\n    // Sync connect.\n    client.connect();\n\n    std::cout << \"Sending request to the server... \"\n      << std::endl;\n\n    std::string response =\n      client.emulate_long_computation_op(10);\n\n    std::cout << \"Response received: \" << response\n      << std::endl;\n\n    // Close the connection and free resources.\n    client.close();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n// Connect the TCP socket.\nm_ssl_stream.lowest_layer().connect(m_ep);\n\n```", "```cpp\n// Perform the SSL handshake.\nm_ssl_stream.handshake(asio::ssl::stream_base::client);\n\n```", "```cpp\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n\n#include <thread>\n#include <atomic>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nclass Service {\npublic:\n  Service(){}\n\n  void handle_client(\n  asio::ssl::stream<asio::ip::tcp::socket>& ssl_stream) \n  {\n    try {\n      // Blocks until the handshake completes.\n ssl_stream.handshake(\n asio::ssl::stream_base::server);\n\n      asio::streambuf request;\n      asio::read_until(ssl_stream, request, '\\n');\n\n      // Emulate request processing.\n      int i = 0;\n      while (i != 1000000)\n        i++;\n      std::this_thread::sleep_for(\n        std::chrono::milliseconds(500));\n\n      // Sending response.\n      std::string response = \"Response\\n\";\n      asio::write(ssl_stream, asio::buffer(response));\n    }\n    catch (system::system_error &e) {\n      std::cout << \"Error occured! Error code = \"\n        << e.code() << \". Message: \"\n        << e.what();\n    }\n  }\n};\n```", "```cpp\nclass Acceptor {\npublic:\n  Acceptor(asio::io_service& ios, unsigned short port_num) :\n    m_ios(ios),\n    m_acceptor(m_ios,\n    asio::ip::tcp::endpoint(\n    asio::ip::address_v4::any(),\n    port_num)),\n    m_ssl_context(asio::ssl::context::sslv23_server)\n  {\n    // Setting up the context.\n m_ssl_context.set_options(\n boost::asio::ssl::context::default_workarounds\n | boost::asio::ssl::context::no_sslv2\n | boost::asio::ssl::context::single_dh_use);\n\n m_ssl_context.set_password_callback(\n [this](std::size_t max_length,\n asio::ssl::context::password_purpose purpose)\n -> std::string \n {return get_password(max_length, purpose);}\n );\n\n m_ssl_context.use_certificate_chain_file(\"server.crt\");\n m_ssl_context.use_private_key_file(\"server.key\",\n boost::asio::ssl::context::pem);\n m_ssl_context.use_tmp_dh_file(\"dhparams.pem\");\n\n    // Start listening for incoming connection requests.\n    m_acceptor.listen();\n  }\n\n  void accept() {\n    asio::ssl::stream<asio::ip::tcp::socket>\n ssl_stream(m_ios, m_ssl_context);\n\n    m_acceptor.accept(ssl_stream.lowest_layer());\n\n    Service svc;\n    svc.handle_client(ssl_stream);\n  }\n\nprivate:\n  std::string get_password(std::size_t max_length,\n asio::ssl::context::password_purpose purpose) const\n {\n return \"pass\";\n }\n\nprivate:\n  asio::io_service& m_ios;\n  asio::ip::tcp::acceptor m_acceptor;\n\n  asio::ssl::context m_ssl_context;\n};\n```", "```cpp\nclass Server {\npublic:\n  Server() : m_stop(false) {}\n\n  void start(unsigned short port_num) {\n    m_thread.reset(new std::thread([this, port_num]() {\n      run(port_num);\n    }));\n  }\n\n  void stop() {\n    m_stop.store(true);\n    m_thread->join();\n  }\n\nprivate:\n  void run(unsigned short port_num) {\n    Acceptor acc(m_ios, port_num);\n\n    while (!m_stop.load()) {\n      acc.accept();\n    }\n  }\n\n  std::unique_ptr<std::thread> m_thread;\n  std::atomic<bool> m_stop;\n  asio::io_service m_ios;\n};\n```", "```cpp\nint main()\n{\n  unsigned short port_num = 3333;\n\n  try {\n    Server srv;\n    srv.start(port_num);\n\n    std::this_thread::sleep_for(std::chrono::seconds(60));\n\n    srv.stop();\n  }\n  catch (system::system_error &e) {\n    std::cout   << \"Error occured! Error code = \" \n    << e.code() << \". Message: \"\n        << e.what();\n  }\n\n  return 0;\n}\n```"]