- en: Chapter 6. Other Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。其他主题
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using composite buffers for scatter/gather operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复合缓冲区进行散射/收集操作
- en: Using timers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定时器
- en: Getting and setting socket options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置套接字选项
- en: Performing a stream-based I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行基于流的I/O
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This final chapter includes four recipes that stand somewhat apart from those
    in previous chapters that demonstrate the core Boost.Asio concepts, covering the
    majority of typical use cases. However, it does not mean that recipes demonstrated
    in this chapter are less important. On the contrary, they are very important and
    even critical to specific cases. However, they will be required less often in
    typical distributed applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含四个食谱，这些食谱与之前章节中展示的核心Boost.Asio概念略有不同，涵盖了大多数典型用例。但这并不意味着本章中展示的食谱不重要。相反，它们非常重要，甚至在某些特定情况下是关键的。然而，在典型的分布式应用程序中，它们的使用频率较低。
- en: Though most applications will not require scatter/gather I/O operations and
    composite buffers, for some, which keep different parts of messages in separate
    buffers, such facilities may turn out to be very usable and convenient.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数应用程序可能不需要散射/收集I/O操作和复合缓冲区，但对于某些将消息的不同部分保存在单独缓冲区中的应用程序来说，这些功能可能非常实用和方便。
- en: The Boost.Asio timer is a powerful instrument that allows measuring time intervals.
    Often, this is used to set deadlines for the operations that may last unpredictably
    long and to interrupt those operations if they do not complete after running for
    a certain period of time. For many distributed applications, such an instrument
    is critical, taking into account the fact that Boost.Asio does not provide a way
    to specify a timeout for potentially long-running operations. In addition to this,
    timers provided by Boost.Asio can be used to solve other tasks that are not related
    to network communication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio定时器是一个强大的工具，允许测量时间间隔。通常，这用于为可能持续很长时间的操作设置截止日期，并在运行一定时间后未完成这些操作时中断它们。考虑到Boost.Asio不提供为可能长时间运行的操作指定超时的方式，这种工具对于许多分布式应用程序来说是至关重要的。此外，Boost.Asio提供的定时器还可以用于解决与网络通信无关的其他任务。
- en: Tools that allow getting and setting socket options are quite important as well.
    When developing a simple network application, the developer may be fully satisfied
    with the socket equipped with default values of the options that are automatically
    set during instantiation of the socket object. However, in more sophisticated
    cases, it may be absolutely necessary to reconfigure the socket by customizing
    the values of its options.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 允许获取和设置套接字选项的工具同样非常重要。在开发简单的网络应用程序时，开发者可能对套接字配备的默认选项值感到非常满意，这些选项值在套接字对象实例化时自动设置。然而，在更复杂的情况下，可能绝对有必要通过自定义选项值来重新配置套接字。
- en: Boost.Asio classes that wrap the socket and provide a stream-like interface
    to it allow us to create simple and elegant distributed applications. And simplicity
    is known to be one of the key characteristics of a good software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio类封装了套接字并提供了一个类似流的接口，这使得我们能够创建简单而优雅的分布式应用程序。而且，简单性被认为是优秀软件的关键特征之一。
- en: Now, let's move on to a detailed consideration of the mentioned topics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细考虑所提到的主题。
- en: Using composite buffers for scatter/gather operations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复合缓冲区进行散射/收集操作
- en: The *Using fixed-length I/O buffers* recipe in [Chapter 2](ch02.html "Chapter 2. I/O
    Operations"), *I/O Operations*, introduces simple I/O buffers, but only slightly
    touches upon scatter/gather operations and composite buffers. In this recipe,
    we are going to consider this topic in more detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。I/O操作")中“使用固定长度I/O缓冲区”的食谱介绍了简单的I/O缓冲区，但只是略微触及了散射/收集操作和复合缓冲区。在本食谱中，我们将更详细地考虑这个主题。'
- en: A composite buffer is basically a complex buffer that consists of two or more
    simple buffers (contiguous blocks of memory) distributed over the process' address
    space. Such buffers become especially handy in two situations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 复合缓冲区基本上是一个复杂的缓冲区，由两个或更多简单缓冲区（内存的连续块）组成，这些缓冲区分布在进程的地址空间中。这种缓冲区在两种情况下特别有用。
- en: The first situation is when the application needs a buffer either to store the
    message before sending it to the remote application or to receive the message
    sent by the remote application. The problem is that the size of the message is
    so big that allocating a single contiguous buffer that is sufficient to store
    it may fail due to the process' address space fragmentation. In this case, allocating
    multiple smaller buffers, whose sizes when summed would be enough to store the
    data, and combining them in a single composite buffer is a good solution to the
    problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是当应用程序需要缓冲区来存储在将其发送到远程应用程序之前的消息，或者接收远程应用程序发送的消息。问题是消息的大小如此之大，以至于可能由于进程地址空间碎片化而无法分配足够存储它的单个连续缓冲区。在这种情况下，分配多个较小的缓冲区，其总大小足以存储数据，并将它们组合成一个复合缓冲区是解决问题的良好方法。
- en: Another situation is actually the first one inverted. Due to specificity of
    the design of the application, the message to be sent to the remote application
    is broken into several parts and stored in different buffers, or if the message
    to be received from the remote application needs to be broken into several parts,
    each of which should be stored in a separate buffer for further processing. In
    both the cases, combining several buffers into one composite buffer and then using
    scatter send or gather receive operations would be a good approach to the problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况实际上是第一种情况的反转。由于应用程序设计的特定性，要发送到远程应用程序的消息被分成几个部分并存储在不同的缓冲区中，或者如果需要将接收自远程应用程序的消息分成几个部分，每个部分都应该存储在单独的缓冲区中以供进一步处理。在这两种情况下，将几个缓冲区组合成一个复合缓冲区，然后使用分散发送或收集接收操作将是解决问题的良好方法。
- en: In this recipe, we will see how to create composite buffers and use them in
    scatter/gather I/O operations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何创建复合缓冲区并在分散/收集I/O操作中使用它们。
- en: Getting ready…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: To understand the content presented in this recipe, it is desirable to be familiar
    with the content of the *Using fixed-length I/O buffers* recipe in [Chapter 2](ch02.html
    "Chapter 2. I/O Operations"), *I/O Operations*, that provides a general overview
    of Boost.Asio's fixed length I/O buffers. Therefore, it is recommended to get
    acquainted with the *Using fixed-length I/O buffers* recipe before proceeding
    with this one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解本菜谱中呈现的内容，熟悉[第2章](ch02.html "第2章。I/O操作")中“使用固定长度I/O缓冲区”菜谱的内容是有益的，该菜谱提供了Boost.Asio固定长度I/O缓冲区的一般概述。因此，建议在继续进行此菜谱之前熟悉“使用固定长度I/O缓冲区”菜谱。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's consider two algorithms and corresponding code samples that describe how
    to create and prepare a composite buffer that is to be used with Boost.Asio I/O
    operations. The first algorithm deals with the composite buffer intended for use
    in gather output operations and the second one for scatter input operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个算法和相应的代码示例，描述了如何创建和准备用于Boost.Asio I/O操作的复合缓冲区。第一个算法处理用于收集输出操作的复合缓冲区，第二个算法用于分散输入操作。
- en: Preparing a composite buffer for gather output operations
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备用于收集输出操作的复合缓冲区
- en: 'The following is the algorithm and corresponding code sample that describe
    how to prepare the composite buffer that is to be used with the socket''s method
    that performs output operations such as `asio::ip::tcp::socket::send()` or a free
    function such as `asio::write()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个算法和相应的代码示例，描述了如何准备用于与套接字方法（如`asio::ip::tcp::socket::send()`或自由函数如`asio::write()`）执行输出操作的复合缓冲区：
- en: Allocate as many memory buffers as needed to perform the task at hand. Note
    that this step does not involve any functionality or data types from Boost.Asio.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配所需数量的内存缓冲区以执行当前任务。请注意，此步骤不涉及任何来自Boost.Asio的功能或数据类型。
- en: Fill the buffers with data to be output.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用要输出的数据填充缓冲区。
- en: Create an instance of a class that satisfies the `ConstBufferSequence` or `MultipleBufferSequence`
    concept's requirements, representing a composite buffer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个满足`ConstBufferSequence`或`MultipleBufferSequence`概念要求的类的实例，代表一个复合缓冲区。
- en: Add simple buffers to the composite buffer. Each simple buffer should be represented
    as an instance of the `asio::const_buffer` or `asio::mutable_buffer` classes.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将简单缓冲区添加到复合缓冲区中。每个简单缓冲区应表示为`asio::const_buffer`或`asio::mutable_buffer`类的实例。
- en: The composite buffer is ready to be used with Boost.Asio output functions.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复合缓冲区已准备好与Boost.Asio输出函数一起使用。
- en: 'Let''s say we want to send a string `Hello my friend!` to the remote application,
    but our message was broken into three parts and each part was stored in a separate
    buffer. What we can do is represent our three buffers as a composite buffer, and
    then, use it in the output operation. This is how we will do it in the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将字符串`Hello my friend!`发送到远程应用程序，但我们的消息被分割成了三部分，并且每一部分都存储在单独的缓冲区中。我们可以做的是将我们的三个缓冲区表示为一个复合缓冲区，然后，在输出操作中使用它。以下是如何在以下代码中实现它的方法：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Preparing a composite buffer for an input operation
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备用于输入操作的复合缓冲区
- en: 'The following is the algorithm and corresponding code sample that describe
    how to prepare the composite buffer that is to be used with the `socket''s` method
    that performs an input operation such as `asio::ip::tcp::socket::receive()` or
    a free function such as `asio::read()`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个算法和相应的代码示例，描述了如何准备用于`socket`方法（如`asio::ip::tcp::socket::receive()`或自由函数如`asio::read()`）输入操作的复合缓冲区：
- en: Allocate as many memory buffers as required to perform the task at hand. The
    sum of the sizes of the buffers must be equal to or greater than the size of the
    expected message to be received in these buffers. Note that this step does not
    involve any functionalities or data types from Boost.Asio.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配所需的内存缓冲区数量以执行当前任务。缓冲区大小的总和必须等于或大于预期接收到的消息的大小。请注意，此步骤不涉及任何Boost.Asio的功能或数据类型。
- en: Create an instance of a class that satisfies the `MutableBufferSequence` concept's
    requirements that represents a composite buffer.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个满足`MutableBufferSequence`概念要求的类的实例，该类表示一个复合缓冲区。
- en: Add simple buffers to the composite buffer. Each simple buffer should be represented
    as an instance of the `asio::mutable_buffer` class.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将简单缓冲区添加到复合缓冲区中。每个简单缓冲区应表示为`asio::mutable_buffer`类的实例。
- en: The composite buffer is ready to be used with Boost.Asio input operations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复合缓冲区已准备好用于Boost.Asio输入操作。
- en: 'Let''s imagine a hypothetical situation, where we want to receive 16 bytes
    long messages from the server. However, we do not have a buffer that can fit the
    entire message. Instead, we have three buffers: 6, 3, and 7 bytes long. To create
    a buffer in which we can receive 16 bytes of data, we can join our three small
    buffers into a composite one. This is how we do it in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个假设的情况，我们想要从服务器接收16字节长的消息。然而，我们没有可以容纳整个消息的缓冲区。相反，我们有三个缓冲区：6字节、3字节和7字节长。为了创建一个可以接收16字节数据的缓冲区，我们可以将我们的三个小缓冲区合并成一个复合缓冲区。以下是如何在以下代码中实现它的方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's see how the first sample works. It starts with allocating three read-only
    buffers that are filled with parts of the message string `Hello my friend!`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个示例是如何工作的。它从分配三个只读缓冲区开始，这些缓冲区填充了消息字符串`Hello my friend!`的部分。
- en: In the next step, an instance of the `std::vector<asio::const_buffer>` class
    is created, which is the embodiment of the composite buffer. The instance is given
    the corresponding name, `composite_buffer`. Because the `std::vector<asio::const_buffer>`
    class satisfies the requirements of `ConstBufferSequence`, its objects can be
    used as composite buffers and can be passed to Boost.Asio gather output functions
    and methods as arguments that represent the data source.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，创建了一个`std::vector<asio::const_buffer>`类的实例，这是复合缓冲区的具体体现。这个实例被赋予了相应的名称，`composite_buffer`。因为`std::vector<asio::const_buffer>`类满足`ConstBufferSequence`的要求，所以它的对象可以用作复合缓冲区，并且可以作为表示数据源的参数传递给Boost.Asio的聚集输出函数和方法。
- en: In step 4, each of our three buffers is represented as an instance of the `asio::const_buffer`
    class and added to the composite buffer. Because all Boost.Asio output functions
    and methods that work with fixed-sized buffers are designed to work with composite
    buffers as well, our `composite_buffer` object can be used with them like a simple
    buffer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们的三个缓冲区中的每一个都被表示为`asio::const_buffer`类的实例，并添加到复合缓冲区中。因为所有与固定大小缓冲区一起工作的Boost.Asio输出函数和方法都设计为也可以与复合缓冲区一起工作，所以我们的`composite_buffer`对象可以像简单缓冲区一样使用。
- en: The second sample works quite similar to the first one. The only difference
    is that because the composite buffer created in this sample is intended to be
    used as a data destination (rather than a data source as it is in the first sample),
    the three simple buffers added to it are created as writable ones and are represented
    as instances of the `asio::mutable_buffer` class when added to the composite buffer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note about the second sample is that because the composite
    buffer created in this sample is composed of mutable buffers, it can be used in
    both gather output and scatter input operations. In this particular sample, the
    initial buffers (`part1`, `part2`, and `part3`) are not filled with any data and
    they contain garbage; and therefore, using them in output operations is senseless
    unless they are filled with meaningful data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using fixed-length I/O buffers* recipe in [Chapter 2](ch02.html "Chapter 2. I/O
    Operations"), *I/O Operations*, provides more information on fixed size simple
    buffers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using extensible stream-oriented I/O buffers* recipe in Chapter 2, *I/O
    Operations*, demonstrates how to use classes provided by Boost.Asio, representing
    different types of buffers—extensible buffers
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using timers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timing is a very important aspect of software systems in general and distributed
    applications in particular. Therefore a hardware timer—a device used to measure
    time intervals—is essential component of any computer and all modern operating
    systems provide interface allowing applications to use it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: There are two typical use cases related to the timer. The first one assumes
    that the application wants to know the current time and asks the operating system
    to find it out. The second use case is when the application asks the operating
    system to notify it (usually, by means of invoking a callback) when a certain
    amount of time elapses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The second use case is particularly important when it comes to developing distributed
    applications with Boost.Asio because a timer is the only way to implement the
    timeout mechanism for asynchronous operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The Boost.Asio library includes several classes that implement timers, which
    we will consider in this recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boost.Asio library provides two template classes that implement timers.
    One of them is `asio::basic_deadline_timer<>`, which was the only one available
    before Boost.Asio 1.49 version was released. In version 1.49, the second timer
    `asio::basic_waitable_timer<>` class template was introduced.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The `asio::basic_deadline_timer<>` class template was designed to be compatible
    with the Boost.Chrono library and internally relies on the functionality it provides.
    This template class is somewhat outdated and provides a limited functionality.
    Therefore, we will not consider it in this recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'On the contrary, a newer `asio::basic_waitable_timer<>` class template, which
    is compatible with the C++11 `chrono` library is more flexible and provides more
    functionalities. Boost.Asio includes three `typedefs` for classes that are generically
    derived from the `asio::basic_waitable_timer<>` template class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个较新的 `asio::basic_waitable_timer<>` 类模板，与C++11 `chrono` 库兼容，更加灵活，并提供了更多功能。Boost.Asio包括三个
    `typedefs`，用于从 `asio::basic_waitable_timer<>` 模板类泛型派生的类：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `asio::system_timer` class is based on the `std::chrono::system_clock` class,
    which represents a system-wide real-time clock. This clock (and so is the timer)
    is influenced by external changes of the current system time. Therefore, the `asio::system_timer`
    class is a good choice when we need to set up a timer that will notify us when
    a certain absolute time point is reached (for instance, 13h:15m:45s), taking into
    account the system clock shifts made after the timer was set up. However, this
    timer is not good at measuring time intervals (for instance, 35 seconds from now)
    because the system clock shifts may result in the timer expiring sooner or later
    than the actual interval elapses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::system_timer` 类基于 `std::chrono::system_clock` 类，它代表一个系统范围内的实时时钟。这个时钟（以及相应的计时器）会受到当前系统时间外部变化的影响。因此，当我们需要设置一个在某个绝对时间点（例如，13小时15分钟45秒）通知我们的计时器时，`asio::system_timer`
    类是一个好选择，考虑到计时器设置后系统时钟的偏移。然而，这个计时器在测量时间间隔（例如，从现在起35秒）方面并不擅长，因为系统时钟的偏移可能会导致计时器比实际间隔早或晚到期。'
- en: The `asio::steady_timer` class is based on the `std::chrono::steady_clock` class,
    which represents a steady clock that is not influenced by the system clock changes.
    It means that `asio::steady_timer` is a good choice to measure intervals.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::steady_timer` 类基于 `std::chrono::steady_clock` 类，它代表一个不受系统时钟变化影响的稳定时钟。这意味着
    `asio::steady_timer` 是测量间隔的一个好选择。'
- en: The last timer `asio::high_resolution_timer` class is based on the `std::chrono::high_resolution_clock`
    class, which represents a high-resolution system clock. It can be used in cases
    when high precision in time measurement is required.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个计时器类 `asio::high_resolution_timer` 是基于 `std::chrono::high_resolution_clock`
    类，它代表一个高精度系统时钟。在需要高精度时间测量的情况下可以使用它。
- en: In distributed applications implemented with the Boost.Asio library, timers
    are usually used to implement timeout periods for asynchronous operations. Just
    after the asynchronous operation starts (for example, `asio::async_read()`), the
    application will start a timer set up to expire after a certain period of time,
    *a timeout period*. When the timer expires, the application checks whether the
    asynchronous operation has completed and if it has not, the operation is considered
    timed out and is canceled.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Boost.Asio库实现的分布式应用程序中，计时器通常用于实现异步操作的超时周期。异步操作开始后（例如，`asio::async_read()`），应用程序将启动一个计时器，该计时器在一段时间后到期，即“超时周期”。当计时器到期时，应用程序检查异步操作是否已完成，如果没有完成，则认为操作超时，并将其取消。
- en: Because a steady timer is not influenced by the system clock shifts, it is the
    best fit to implement the timeout mechanism.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于稳定计时器不受系统时钟偏移的影响，它是实现超时机制的最佳选择。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that on some platforms, steady clocks are not available and the corresponding
    class that represents a `std::chrono::steady_clock` exhibits behavior that is
    identical to that of `std::chrono::stystem_clock`, which means that just like
    the latter, it is influenced by the changes of the system clock. It is advised
    to refer to the documentation of the platform and corresponding C++ standard library
    implementation to find out whether the steady clock is actually *steady*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些平台上，稳定的时钟不可用，代表 `std::chrono::steady_clock` 的相应类表现出与 `std::chrono::system_clock`
    相同的行为，这意味着它就像后者一样，会受到系统时钟变化的影响。建议参考平台和相应的C++标准库实现文档，以了解稳定的时钟是否真正是“稳定的”。
- en: Let's consider a somewhat unrealistic but representative sample application
    that demonstrates how to create, start, and cancel Boost.Asio timers. In our sample,
    we will create and start two steady timers one by one. When the first timer expires,
    we will cancel the second one, before it has a chance to expire.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个多少有些不切实际但具有代表性的示例应用程序，该应用程序演示了如何创建、启动和取消Boost.Asio计时器。在我们的示例中，我们将逐一创建和启动两个稳定的计时器。当第一个计时器到期时，我们将取消第二个计时器，在它有机会到期之前。
- en: 'We begin our sample application with including the necessary Boost.Asio headers
    and the `using` directive:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包含必要的 Boost.Asio 头文件和 `using` 指令开始我们的示例应用程序：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we define the only component in our application: the `main()` entry point
    function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们应用程序中唯一的组件：`main()` 入口点函数：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Like almost any nontrivial Boost.Asio application, we need an instance of the
    `asio::io_service` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像几乎所有的非平凡 Boost.Asio 应用程序一样，我们需要一个 `asio::io_service` 类的实例：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we create and start the first `t1` timer, which is set up to expire in
    2 seconds:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建并启动第一个 `t1` 定时器，该定时器被设置为在 2 秒后过期：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we create and start the second `t2` timer, which is set up to expire
    in 5 seconds. It should definitely expire later than the first timer:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建并启动第二个 `t2` 定时器，该定时器被设置为在 5 秒后过期。它应该肯定比第一个定时器晚过期：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we define and set a callback function that is to be called when the first
    timer expires:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义并设置一个回调函数，当第一个定时器过期时将被调用：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we define and set another callback function that is to be called when
    the second timer expires:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义并设置另一个回调函数，当第二个定时器过期时将被调用：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the last step, we call the `run()` method on the instance of the `asio::io_service`
    class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们在 `asio::io_service` 类的实例上调用 `run()` 方法：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, our sample application is ready.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的示例应用程序已经准备好了。
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now, let's track the application's execution path to better understand how it
    works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跟踪应用程序的执行路径，以更好地理解它是如何工作的。
- en: The `main()` function begins with creating an instance of the `asio::io_service`
    class. We need it because just like sockets, acceptors, resolvers, and other components
    defined by the Boost.Asio library, which use operating system services, timers
    require an instance of the `asio::io_service` class as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数从创建 `asio::io_service` 类的实例开始。我们需要它，因为就像套接字、接受者、解析器以及由 Boost.Asio
    库定义的其他使用操作系统服务的组件一样，定时器也需要 `asio::io_service` 类的实例。'
- en: In the next step, the first timer named `t1` is instantiated and then the `expires_from_now()`
    method is called on it. This method switches the timer to a non-expired state
    and starts it. It accepts an argument that represents the duration of the time
    interval, after which the timer should expire. In our sample, we pass an argument
    that represents the duration of 2 seconds, which means that in 2 seconds, from
    the moment when the timer starts, it will expire and all those who are waiting
    for this timer's expiration event will be notified.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们实例化了第一个定时器 `t1`，然后对其调用 `expires_from_now()` 方法。此方法将定时器切换到非过期状态并启动它。它接受一个表示定时器应在之后过期的时距的参数。在我们的示例中，我们传递一个表示
    2 秒时距的参数，这意味着从定时器开始的那一刻起，2 秒后定时器将过期，所有等待此定时器过期事件的等待者都将被通知。
- en: Next, the second timer named `t2` is created, which is then started and set
    up to expire in 5 seconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建第二个名为 `t2` 的定时器，然后启动它并设置为在 5 秒后过期。
- en: 'When both the timers are started, we asynchronously wait for the timers'' expiration
    events. In other words, we register callbacks on each of the two timers, which
    will be invoked when the corresponding timers expire. To do this, we call the
    timer''s `async_wait()` method and pass the pointer to the callback function as
    an argument. The `async_wait()` method expects its argument to be a pointer to
    the function that has the following signature:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个定时器都启动后，我们异步等待定时器的过期事件。换句话说，我们在每个定时器上注册回调函数，这些回调函数将在相应的定时器过期时被调用。为此，我们调用定时器的
    `async_wait()` 方法，并将回调函数的指针作为参数传递。`async_wait()` 方法期望其参数是一个具有以下签名的函数的指针：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The callback function accepts a single `ec` argument, which designates the wait
    completion status. In our sample application, we use lambda functions as expiration
    callbacks for both the timers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接受一个单个的 `ec` 参数，它指定了等待完成的状况。在我们的示例应用程序中，我们使用 lambda 函数作为两个定时器的过期回调。
- en: When both timer expiration callbacks are set, the `run()` method is called on
    the `ios` object. The method blocks until both the timers expire. The thread,
    in the context of which the method `run()` is invoked, will be used to invoke
    the expiration callbacks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个定时器的过期回调都设置好后，在 `ios` 对象上调用 `run()` 方法。该方法会阻塞，直到两个定时器都过期。在调用 `run()` 方法的线程上下文中，将使用该线程来调用过期回调。
- en: When the first timer expires, the corresponding callback function is invoked.
    It checks the wait completion status and outputs corresponding messages to the
    standard output stream. And then it cancels the second timer by calling the `cancel()`
    method on the `t2` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个计时器到期时，相应的回调函数被调用。它检查等待完成状态，并向标准输出流输出相应的消息。然后通过在`t2`对象上调用`cancel()`方法取消第二个计时器。
- en: The canceling of the second timer leads to the expiration callback being called
    with the status code, notifying that the timer was canceled before expiration.
    The expiration callback of the second timer checks the expiration status and outputs
    corresponding messages to the standard output stream and returns.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 取消第二个计时器导致到期回调以状态码调用，通知计时器在到期之前被取消。第二个计时器的到期回调检查到期状态，并向标准输出流输出相应的消息，然后返回。
- en: When both callbacks are completed, the `run()` method returns and the execution
    of the `main()` function runs to the end. This is when the execution of the application
    is completed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个回调都完成后，`run()`方法返回，`main()`函数的执行继续到末尾。这是应用程序执行完成的时候。
- en: Getting and setting socket options
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置套接字选项
- en: The socket's properties and its behavior can be configured by changing the values
    of its various options. When the socket object is instantiated, its options have
    default values. In many cases, the socket configured by default is a perfect fit,
    whereas in others, it may be needed to fine tune the socket by changing values
    of its options so that it meets the requirements of the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更改其各种选项的值来配置套接字的属性及其行为。当套接字对象被实例化时，其选项具有默认值。在许多情况下，默认配置的套接字是完美的选择，而在其他情况下，可能需要通过更改其选项的值来微调套接字，以便满足应用程序的要求。
- en: In this recipe, we will see how to get and set socket options with Boost.Asio.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将了解如何使用Boost.Asio获取和设置套接字选项。
- en: Getting ready…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: This recipe assumes familiarity with the content provided in [Chapter 1](ch01.html
    "Chapter 1. The Basics"), *The Basics*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设熟悉[第1章](ch01.html "第1章。基础知识")中提供的内容，*基础知识*。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Each socket option, whose value can be set or obtained by means of a functionality
    provided by Boost.Asio, is represented by a separate class. The complete list
    of classes that represent setting or getting socket options, which are supported
    by Boost.Asio, can be found on this Boost.Asio documentation page at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/socket_base.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/socket_base.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可以通过Boost.Asio提供的功能设置或获取其值的套接字选项都由一个单独的类表示。支持Boost.Asio设置或获取套接字选项的类的完整列表可以在Boost.Asio文档页面上找到，网址为[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/socket_base.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/socket_base.html)。
- en: Note that there are fewer classes that represent socket options listed on this
    page than the options that can be set or obtained from a native socket (an object
    of the underlying operating system). This is because Boost.Asio supports only
    a limited amount of socket options. To set or obtain values of other socket options,
    developers may need to extend the Boost.Asio library by adding classes that represent
    the required options. However, the topic on the extension of the Boost.Asio library
    is beyond the scope of this book. We will focus on how to work with socket options
    that are supported by the library out of the box.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此页面上列出的表示套接字选项的类比可以从本地套接字（底层操作系统的对象）设置或获取的选项要少。这是因为Boost.Asio仅支持有限数量的套接字选项。为了设置或获取其他套接字选项的值，开发者可能需要通过添加表示所需选项的类来扩展Boost.Asio库。然而，关于扩展Boost.Asio库的主题超出了本书的范围。我们将专注于如何使用库中开箱即用的套接字选项进行操作。
- en: Let's consider a hypothetical situation where we want to make the size of the
    socket's receive buffer two times bigger than whatever its size is now. To do
    this, we first need to get the current size of the buffer, then multiply it by
    two, and finally, set the value obtained after multiplication as the new receive
    buffer size.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个假设的情况，我们希望将套接字接收缓冲区的大小增加到现在的两倍。为此，我们首先需要获取缓冲区的当前大小，然后将其乘以二，最后将乘法后的值设置为新的接收缓冲区大小。
- en: 'The following sample demonstrates how to do this in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在以下代码中执行此操作：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our sample consists of a single component: the `main()` entry point function.
    This function begins with creating an instance of the `asio::io_service` class.
    This instance is then used to create an object that represents a TCP socket.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例由一个单一组件组成：`main()`入口点函数。这个函数从创建一个`asio::io_service`类的实例开始。然后，使用这个实例创建一个代表TCP套接字的对象。
- en: Note the usage of the socket class constructor, which creates and *opens* the
    socket. Before we can get or set options on a particular socket object, the corresponding
    socket must be opened. This is because before the Boost.Asio socket object is
    opened, the underlying native *socket* object of the corresponding operating system
    is not yet allocated, and there is nothing to set the options on or get them from.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意套接字类构造函数的使用，它创建并*打开*了套接字。在我们能够获取或设置特定套接字对象上的选项之前，相应的套接字必须被打开。这是因为，在Boost.Asio套接字对象打开之前，相应操作系统的底层*套接字*对象尚未分配，因此没有可以设置选项或从中获取选项的对象。
- en: Next, an instance of the `asio::socket_base::receive_buffer_size` class is instantiated.
    This class represents an option that controls the size of the socket's receive
    buffer. To obtain the current value of the option, the `get_option()` method is
    called on the socket object and the reference to the option object is passed to
    it as an argument.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实例化了一个`asio::socket_base::receive_buffer_size`类的实例。这个类代表了一个控制套接字接收缓冲区大小的选项。为了获取该选项的当前值，需要在套接字对象上调用`get_option()`方法，并将选项对象的引用作为参数传递给它。
- en: The `get_option()` method deduces the option that is requested by the type of
    the argument passed to it. Then, it stores the corresponding option's value in
    the option object and returns. The value of the option can be obtained from the
    object that represents the corresponding option by invoking the object's `value()`
    method, which returns the value of the option.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_option()`方法通过传递给它的参数类型推断出请求的选项。然后，它将相应的选项值存储在选项对象中并返回。可以通过调用表示相应选项的对象的`value()`方法来从对象中获取选项的值，该方法返回选项的值。'
- en: After the current value of receive buffer size option is obtained and output
    to the standard output stream, in order to set the new value of this option, the
    `main()` function proceeds with creating one more instance of the `asio::socket_base::receive_buffer_size`
    class named `new_buf_size`. This instance represents the same option as the first
    instance, `cur_buf_size`, but this one contains the new value. The new option
    value is passed to the option object as an argument of its constructor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取接收缓冲区大小选项的当前值并将其输出到标准输出流之后，为了设置该选项的新值，`main()`函数继续创建一个名为`new_buf_size`的`asio::socket_base::receive_buffer_size`类的新实例。这个实例与第一个实例`cur_buf_size`具有相同的选项，但包含新值。新的选项值作为构造函数的参数传递给选项对象。
- en: After the option object that contains the new receive buffer size option value
    is constructed, the reference to it is passed as an argument to the socket's `set_option()`
    method. Like `get_option()`, this method deduces the option to be set by the type
    of the argument passed to it, and then, sets the corresponding option value, making
    the new value equal to the one stored in the option object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造包含新的接收缓冲区大小选项值的选项对象之后，将对该对象的引用作为参数传递给套接字的`set_option()`方法。与`get_option()`类似，这个方法通过传递给它的参数类型推断出要设置的选项，然后设置相应的选项值，使新值等于存储在选项对象中的值。
- en: In the last step, the new option's value is output to the standard output stream.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，新的选项值被输出到标准输出流。
- en: Performing a stream-based I/O
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行基于流的I/O
- en: The concepts of a stream and stream-based I/O are powerful in their expressiveness
    and elegance when used properly. Sometimes, most of the application's source code
    consists of stream-based I/O operations. The source code readability and maintainability
    of such an application would be increased if network communication modules were
    implemented by means of stream-based operations as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，流和基于流的I/O的概念在表达力和优雅性方面非常强大。有时，应用程序的大部分源代码可能由基于流的I/O操作组成。如果通过网络通信模块通过基于流的操作实现，此类应用程序的源代码可读性和可维护性将会提高。
- en: Fortunately, Boost.Asio provides tools that allow us to implement inter-process
    communication in a stream-based fashion. In this recipe, we will see how to use
    them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Boost.Asio提供了允许我们以基于流的方式实现进程间通信的工具。在本例中，我们将看到如何使用它们。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The Boost.Asio library contains the `asio::ip::tcp::iostream` wrapper class
    that provides an I/O stream-like interface to the TCP socket objects, which allows
    us to express inter-process communication operations in terms of stream-based
    operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio 库包含 `asio::ip::tcp::iostream` 封装类，它为 TCP 套接字对象提供类似 I/O 流的接口，这使得我们可以用基于流的操作来表示进程间通信操作。
- en: 'Let''s consider a TCP client application, which takes advantage of a stream-based
    I/O provided by Boost.Asio. When using this approach, the TCP client application
    becomes as simple as the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个利用 Boost.Asio 提供的基于流的 I/O 的 TCP 客户端应用程序。当使用这种方法时，TCP 客户端应用程序变得像以下代码一样简单：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The sample TCP client is quite simple and consists of a single component: the
    `main()` entry point function. The `main()` function begins with creating an instance
    of the `asio::ip::tcp::iostream` class, which wraps a TCP socket and provides
    an I/O stream-like interface to it.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 TCP 客户端非常简单，仅由一个组件组成：`main()` 入口点函数。`main()` 函数从创建 `asio::ip::tcp::iostream`
    类的实例开始，该实例封装了一个 TCP 套接字，并为它提供了一个类似 I/O 流的接口。
- en: The `stream` object is constructed with a constructor that accepts a server
    DNS name and a protocol port number and automatically tries to resolve the DNS
    name and then tries to connect to that server. Note that the port number is represented
    as a string rather than an integer. This is because both arguments passed to this
    constructor are directly used to create the resolver query, which requires the
    port number to be represented as a string (it should be expressed as a service
    name such as `http`, `ftp`, and so on or a port number that is represented as
    a string such as "`80`", "`8081`", "`3333`", and so on).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream` 对象使用接受服务器 DNS 名称和协议端口号的构造函数构建，并自动尝试解析 DNS 名称，然后尝试连接到该服务器。请注意，端口号以字符串形式表示，而不是整数。这是因为传递给此构造函数的两个参数都直接用于创建解析器查询，该查询需要端口号以字符串形式表示（它应该表示为服务名称，如
    `http`、`ftp` 等，或者表示为字符串的端口号，如 "`80`"、"`8081`"、"`3333`" 等）。'
- en: Alternatively, we can construct the `stream` object using the default constructor,
    which does not perform the DNS name resolution and connection. Then, when the
    object is constructed, we can call the `connect()` method on it by specifying
    the DNS name and protocol port number in order to perform the resolution and connect
    the socket.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用默认构造函数来构建 `stream` 对象，该构造函数不执行 DNS 名称解析和连接。然后，当对象被构建时，我们可以通过指定 DNS
    名称和协议端口号来调用其上的 `connect()` 方法，以执行解析并连接套接字。
- en: Next, the state of the stream object is tested to find out whether the connection
    has succeeded. And if the stream object is in a bad or erroneous state, the appropriate
    message is output to the standard output stream and the application exits. The
    `error()` method of the `asio::ip::tcp::iostream` class returns an instance of
    the `boost::system::error_code` class, which provides the information about the
    last error that occurred in the stream.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，测试流对象的当前状态，以确定连接是否成功。如果流对象处于不良或错误状态，则将适当的消息输出到标准输出流，并退出应用程序。`asio::ip::tcp::iostream`
    类的 `error()` 方法返回 `boost::system::error_code` 类的实例，该实例提供了关于流中发生的最后错误的详细信息。
- en: However, if the stream has been successfully connected to the server, the output
    operation is performed on it, which sends the string `Request`, to the server.
    After this, the `flush()` method is called on the stream object to make sure that
    all the buffered data is pushed to the server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果流已成功连接到服务器，则在其上执行输出操作，向服务器发送字符串 `Request`。之后，在流对象上调用 `flush()` 方法，以确保所有缓冲数据都推送到服务器。
- en: In the last step, the input operation is performed on the stream to read all
    the data that was received from the server as a response. The received message
    is output to the standard output stream. After this, the `main()` function returns
    and the application exits.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，对流执行输入操作，以读取从服务器接收的所有数据作为响应。接收到的消息输出到标准输出流。之后，`main()` 函数返回，应用程序退出。
- en: There's more…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Not only can we implement the client-side I/O in a stream-oriented fashion using
    the `asio::ip::tcp::iostream` class, we can also perform I/O operations on the
    server side as well. In addition to this, this class allows us to specify timeouts
    for operations, which makes a stream-based I/O more advantageous than a normal
    synchronous I/O. Let's take a look at how this is done.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以使用`asio::ip::tcp::iostream`类以流式方式实现客户端的I/O，还可以在服务器端执行I/O操作。此外，这个类允许我们为操作指定超时时间，这使得基于流的I/O比正常的同步I/O更有优势。让我们看看这是如何实现的。
- en: Implementing a server-side I/O
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现服务器端I/O
- en: 'The following code snippet demonstrates how to implement a simple server that
    performs a stream-based I/O using the `asio::ip::tcp::iostream` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用`asio::ip::tcp::iostream`类实现一个简单的基于流的I/O服务器：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code snippet demonstrates a piece of source code of a simple server application.
    It creates instances of acceptors and the `asio::ip::tcp::iostream` classes. And
    then, the interesting thing happens.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段演示了一个简单服务器应用程序的源代码片段。它创建了接受者和`asio::ip::tcp::iostream`类的实例。然后，有趣的事情发生了。
- en: 'The `accept()` method is invoked on the `acceptor` object. As an argument,
    this method is passed an object, a pointer to which is returned by the `rdbuf()`
    method called on the `stream` object. The `rdbuf()` method of the `stream` object
    returns a pointer to the stream buffer object. This stream buffer object is an
    instance of a class, which is inherited from the `asio::ip::tcp::socket` class,
    which means that the stream buffer used by objects of the `asio::ip::tcp ::iostream`
    class plays two roles: one of a stream buffer and another of a socket. Therefore,
    this `twofold` stream buffer/socket object can be used as a normal active socket
    to connect and communicate with the client application.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`acceptor`对象上调用`accept()`方法。该方法传递一个对象作为参数，该参数是通过在`stream`对象上调用`rdbuf()`方法返回的指针。`stream`对象的`rdbuf()`方法返回指向流缓冲区对象的指针。这个流缓冲区对象是一个从`asio::ip::tcp::socket`类继承的类的实例，这意味着`asio::ip::tcp::iostream`类对象使用的流缓冲区扮演两个角色：一个是流缓冲区，另一个是套接字。因此，这个“双重”流缓冲区/套接字对象可以用作正常的活动套接字来连接和与客户端应用程序通信。
- en: When the connection request is accepted and the connection is established, further
    communication with the client is done in a stream-fashioned style just like it
    is done in the client application, as demonstrated earlier in this recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接请求被接受并且建立了连接后，与客户端的进一步通信将以流式风格进行，就像在客户端应用程序中执行的那样，正如在之前的菜谱中所示。
- en: Setting timeout intervals
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置超时间隔
- en: Because I/O operations are provided by the `asio::ip::tcp::stream` class block
    the thread of execution, and they potentially may run for a substantial amount
    of time, the class provides a way to set a timeout period that, when it runs out,
    leads to the interruption of the operation that currently blocks the thread, if
    any.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`asio::ip::tcp::stream`类提供的I/O操作会阻塞执行线程，并且它们可能需要运行相当长的时间，所以该类提供了一种设置超时时间的方法。当超时时间耗尽时，如果当前有操作正在阻塞线程，则会中断该操作。
- en: The timeout interval can be set by the `expires_from_now()` method of the `asio::ip::tcp::stream`
    class. This method accepts the duration of the timeout interval as an input parameter
    and starts the internal timer. If at the moment, when the timer expires, an I/O
    operation is still in progress, that operation is considered timed out and is,
    therefore, forcefully interrupted.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 超时间隔可以通过`asio::ip::tcp::stream`类的`expires_from_now()`方法设置。此方法接受超时间隔的持续时间作为输入参数并启动内部计时器。如果在计时器到期时I/O操作仍在进行中，则该操作被视为超时，因此被强制中断。
