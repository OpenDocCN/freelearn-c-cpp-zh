["```cpp\nstruct EntitySnapshot{\n    std::string m_type;\n    sf::Vector2f m_position;\n    sf::Int32 m_elevation;\n    sf::Vector2f m_velocity;\n    sf::Vector2f m_acceleration;\n    sf::Uint8 m_direction;\n    sf::Uint8 m_state;\n    sf::Uint8 m_health;\n    std::string m_name;\n};\n```", "```cpp\nsf::Packet& operator <<(sf::Packet& l_packet, \n    const EntitySnapshot& l_snapshot);\nsf::Packet& operator >>(sf::Packet& l_packet, \n    EntitySnapshot& l_snapshot);\n```", "```cpp\nsf::Packet& operator <<(sf::Packet& l_packet, \n   const EntitySnapshot& l_snapshot)\n{\n   return l_packet << l_snapshot.m_type << l_snapshot.m_name \n      << l_snapshot.m_position.x << l_snapshot.m_position.y \n      << l_snapshot.m_elevation << l_snapshot.m_velocity.x \n      << l_snapshot.m_velocity.y << l_snapshot.m_acceleration.x\n      << l_snapshot.m_acceleration.y << l_snapshot.m_direction \n      << l_snapshot.m_state << l_snapshot.m_health;\n}\n\nsf::Packet& operator >>(sf::Packet& l_packet, \n   EntitySnapshot& l_snapshot)\n{\n   return l_packet >> l_snapshot.m_type >> l_snapshot.m_name \n      >> l_snapshot.m_position.x >> l_snapshot.m_position.y \n      >> l_snapshot.m_elevation >> l_snapshot.m_velocity.x \n      >> l_snapshot.m_velocity.y >> l_snapshot.m_acceleration.x\n      >> l_snapshot.m_acceleration.y >> l_snapshot.m_direction \n      >> l_snapshot.m_state >> l_snapshot.m_health;\n}\n```", "```cpp\nenum class Network{\n  HighestTimestamp = 2147483647, ClientTimeout = 10000,\n  ServerPort = 5600, NullID = -1, PlayerUpdateDelim = -1\n};\n```", "```cpp\nclass C_Client : public C_Base{\npublic:\n  C_Client(): C_Base(Component::Client),\n    m_clientID((ClientID)Network::NullID){}\n  void ReadIn(std::stringstream& l_stream){}\n\n  ClientID GetClientID()const{ return m_clientID; }\n  void SetClientID(const ClientID& l_id){ m_clientID = l_id; }\nprivate:\n  ClientID m_clientID;\n};\n```", "```cpp\nclass C_Name : public C_Base{\npublic:\n  C_Name() : C_Base(Component::Name){}\n  void ReadIn(std::stringstream& l_stream){ l_stream >> m_name; }\n  const std::string& GetName()const{ return m_name; }\n  void SetName(const std::string& l_name){ m_name = l_name; }\nprivate:\n  std::string m_name;\n};\n```", "```cpp\nclass C_TimedComponentBase : public C_Base{\npublic:\n  C_TimedComponentBase(const Component& l_type)\n    : C_Base(l_type), m_duration(sf::milliseconds(0)){}\n  virtual ~C_TimedComponentBase(){}\n\n  const sf::Time& GetTimer()const{ return m_duration; }\n  void SetTimer(const sf::Time& l_time){ m_duration = l_time; }\n  void AddToTimer(const sf::Time& l_time){ m_duration += l_time; }\n\n  void Reset(){ m_duration = sf::milliseconds(0); }\nprotected:\n  sf::Time m_duration;\n};\n```", "```cpp\nusing Health = unsigned int;\n\nclass C_Health : public C_TimedComponentBase{\npublic:\n  C_Health(): C_TimedComponentBase(Component::Health), \n    m_hurtDuration(0), m_deathDuration(0){}\n  void ReadIn(std::stringstream& l_stream){\n    l_stream >> m_maxHealth >> m_hurtDuration >> m_deathDuration;\n    m_health = m_maxHealth;\n  }\n  Health GetHealth()const{ return m_health; }\n  Health GetMaxHealth()const{ return m_maxHealth; }\n  void SetHealth(const Health& l_health){ m_health = l_health; }\n  void ResetHealth(){ m_health = m_maxHealth; }\n\n  sf::Uint32 GetHurtDuration(){ return m_hurtDuration; }\n  sf::Uint32 GetDeathDuration(){ return m_deathDuration; }\nprivate:\n  Health m_health;\n  Health m_maxHealth;\n  sf::Uint32 m_hurtDuration;\n  sf::Uint32 m_deathDuration;\n};\n```", "```cpp\nenum class EntityMessage{\n  Move, Is_Moving, Frame_Change, State_Changed,\n  Direction_Changed, Switch_State, Attack,\n Being_Attacked, Hurt, Die, Respawn, Removed_Entity\n};\nenum class EntityEvent{\n  Spawned, Despawned, Colliding_X, Colliding_Y,\n  Moving_Left, Moving_Right, Moving_Up, Moving_Down,\n  Elevation_Change, Became_Idle, Began_Moving, Began_Attacking\n};\n```", "```cpp\nint EntityManager::AddEntity(const Bitmask& l_mask, int l_id){\n    ...\n    m_systems->EntityModified(entity,l_mask);\n    m_systems->AddEvent(entity, (EventID)EntityEvent::Spawned);\n    return entity;\n}\n\nbool EntityManager::RemoveEntity(const EntityId& l_id){\n    ...\n    Message msg((MessageType)EntityMessage::Removed_Entity);\n    msg.m_receiver = l_id;\n    msg.m_int = l_id;\n    m_systems->GetMessageHandler()->Dispatch(msg);\n    ... // Removing all components.\n}\n```", "```cpp\n#define SNAPSHOT_INTERVAL 100\n```", "```cpp\nclass C_Attacker : public C_TimedComponentBase{\npublic:\n  C_Attacker(): C_TimedComponentBase(Component::Attacker), \n    m_attacked(false), m_knockback(0.f), m_attackDuration(0){}\n  void ReadIn(std::stringstream& l_stream){\n    l_stream >> m_offset.x >> m_offset.y \n      >> m_attackArea.width >> m_attackArea.height \n      >> m_knockback >> m_attackDuration;\n  }\n\n  void SetAreaPosition(const sf::Vector2f& l_pos){\n    m_attackArea.left = l_pos.x;\n    m_attackArea.top = l_pos.y;\n  }\n\n  const sf::FloatRect& GetAreaOfAttack(){ return m_attackArea; }\n  const sf::Vector2f& GetOffset(){ return m_offset; }\n  bool HasAttacked(){ return m_attacked; }\n  void SetAttacked(bool l_attacked){ m_attacked = l_attacked; }\n  float GetKnockback(){ return m_knockback; }\n  sf::Uint32 GetAttackDuration(){ return m_attackDuration; }\nprivate:\n  sf::FloatRect m_attackArea;\n  sf::Vector2f m_offset;\n  bool m_attacked;\n  float m_knockback;\n  sf::Uint32 m_attackDuration;\n};\n```", "```cpp\nvoid S_Collision::EntityCollisions(){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for (auto itr = m_entities.begin();\n    itr != m_entities.end(); ++itr)\n  {\n    for (auto itr2 = std::next(itr);\n      itr2 != m_entities.end(); ++itr2)\n    {\n      ...\n      C_Attacker* attacker1 = entities->\n        GetComponent<C_Attacker>(*itr, Component::Attacker);\n      C_Attacker* attacker2 = entities->\n        GetComponent<C_Attacker>(*itr2, Component::Attacker);\n      if (!attacker1 && !attacker2){ continue; }\n      Message msg((MessageType)EntityMessage::Being_Attacked);\n      if (attacker1){\n        if (attacker1->GetAreaOfAttack().intersects(\n          collidable2->GetCollidable()))\n        {\n          // Attacker-on-entity collision!\n          msg.m_receiver = *itr2;\n          msg.m_sender = *itr;\n          m_systemManager->GetMessageHandler()->Dispatch(msg);\n        }\n      }\n      if (attacker2){\n        if (attacker2->GetAreaOfAttack().intersects(\n          collidable1->GetCollidable()))\n        {\n          // Attacker-on-entity collision!\n          msg.m_receiver = *itr;\n          msg.m_sender = *itr2;\n          m_systemManager->GetMessageHandler()->Dispatch(msg);\n        }\n      }\n    }\n  }\n}\n```", "```cpp\nS_Combat::S_Combat(SystemManager* l_systemMgr)\n  : S_Base(System::Combat, l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::Movable);\n  req.TurnOnBit((unsigned int)Component::State);\n  req.TurnOnBit((unsigned int)Component::Health);\n  m_requiredComponents.push_back(req);\n  req.ClearBit((unsigned int)Component::Health);\n  req.TurnOnBit((unsigned int)Component::Attacker);\n  m_requiredComponents.push_back(req);\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Being_Attacked, this);\n}\n```", "```cpp\nvoid S_Combat::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for (auto &entity : m_entities){\n    C_Attacker* attack = entities->\n      GetComponent<C_Attacker>(entity, Component::Attacker);\n    if (!attack){ continue; }\n    sf::Vector2f offset = attack->GetOffset();\n    sf::FloatRect AoA = attack->GetAreaOfAttack();\n    Direction dir = entities->GetComponent<C_Movable>\n      (entity, Component::Movable)->GetDirection();\n    sf::Vector2f position = entities->GetComponent<C_Position>\n      (entity, Component::Position)->GetPosition();\n    if (dir == Direction::Left){ offset.x -= AoA.width / 2; }\n    else if (dir == Direction::Right){offset.x += AoA.width / 2; }\n    else if (dir == Direction::Up){offset.y -= AoA.height / 2; }\n    else if (dir == Direction::Down){offset.y += AoA.height / 2; }\n    position -= sf::Vector2f(AoA.width / 2, AoA.height / 2);\n    attack->SetAreaPosition(position + offset);\n  }\n}\n```", "```cpp\nvoid S_Combat::Notify(const Message& l_message){\n  if (!HasEntity(l_message.m_receiver) ||\n    !HasEntity(l_message.m_sender))\n  {\n    return;\n  }\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  EntityMessage m = (EntityMessage)l_message.m_type;\n  switch (m){\n  case EntityMessage::Being_Attacked:\n    C_Health* victim = entities->GetComponent<C_Health>\n      (l_message.m_receiver, Component::Health);\n    C_Attacker* attacker = entities->GetComponent<C_Attacker>\n      (l_message.m_sender, Component::Attacker);\n    if (!victim || !attacker){ return; }\n    S_State* StateSystem = m_systemManager->\n      GetSystem<S_State>(System::State);\n    if (StateSystem->GetState(l_message.m_sender) !=\n      EntityState::Attacking)\n    {\n      return;\n    }\n    if (attacker->HasAttacked()){ return; }\n    // Begin attacking.\n    victim->SetHealth((victim->GetHealth() > 1 ?\n      victim->GetHealth() - 1 : 0));\n    attacker->SetAttacked(true);\n    if (!victim->GetHealth()){\n      StateSystem->ChangeState(l_message.m_receiver,\n        EntityState::Dying, true);\n    } else {\n      Message msg((MessageType)EntityMessage::Hurt);\n      msg.m_receiver = l_message.m_receiver;\n      m_systemManager->GetMessageHandler()->Dispatch(msg);\n    }\n\n    // Knockback.\n    Direction attackerDirection =entities->GetComponent<C_Movable>\n      (l_message.m_sender, Component::Movable)->GetDirection();\n    float Knockback = attacker->GetKnockback();\n    sf::Vector2f KnockbackVelocity;\n    if (attackerDirection == Direction::Left ||\n      attackerDirection == Direction::Up)\n    {\n      Knockback = -Knockback;\n    }\n    if (attackerDirection == Direction::Left ||\n      attackerDirection == Direction::Right)\n    {\n      KnockbackVelocity.x = Knockback;\n    }\n    else{ KnockbackVelocity.y = Knockback; }\n    entities->GetComponent<C_Movable>\n      (l_message.m_receiver, Component::Movable)->\n      SetVelocity(KnockbackVelocity);\n    break;\n  }\n}\n```", "```cpp\nS_Timers::S_Timers(SystemManager* l_systemMgr)\n  : S_Base(System::Timers, l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::State);\n  req.TurnOnBit((unsigned int)Component::Attacker);\n  m_requiredComponents.push_back(req);\n  req.ClearBit((unsigned int)Component::Attacker);\n  req.TurnOnBit((unsigned int)Component::Health);\n  m_requiredComponents.push_back(req);\n}\n```", "```cpp\nvoid S_Timers::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for (auto &entity : m_entities){\n    EntityState state = entities->GetComponent<C_State>\n      (entity, Component::State)->GetState();\n    if (state == EntityState::Attacking){\n      C_Attacker* attack = entities->GetComponent<C_Attacker>\n        (entity, Component::Attacker);\n      attack->AddToTimer(sf::seconds(l_dT));\n      if (attack->GetTimer().asMilliseconds() <\n        attack->GetAttackDuration())\n      {\n        continue;\n      }\n      attack->Reset();\n      attack->SetAttacked(false);\n    } else if (state == EntityState::Hurt ||\n      state == EntityState::Dying)\n    {\n      C_Health* health = entities->\n        GetComponent<C_Health>(entity, Component::Health);\n      health->AddToTimer(sf::seconds(l_dT));\n      if ((state == EntityState::Hurt && \n        health->GetTimer().asMilliseconds() <\n        health->GetHurtDuration()) ||\n        (state == EntityState::Dying && \n        health->GetTimer().asMilliseconds() <\n        health->GetDeathDuration()))\n      {\n        continue;\n      }\n\n      health->Reset();\n      if (state == EntityState::Dying){\n        Message msg((MessageType)EntityMessage::Respawn);\n        msg.m_receiver = entity;\n        m_systemManager->GetMessageHandler()->Dispatch(msg);\n        health->ResetHealth();\n      }\n    } else { continue; }\n    m_systemManager->GetSystem<S_State>(System::State)->\n      ChangeState(entity, EntityState::Idle, true);\n  }\n}\n```", "```cpp\nstruct PlayerInput{\n    int m_movedX;\n    int m_movedY;\n    bool m_attacking;\n    PlayerInput() : m_movedX(0), m_movedY(0), m_attacking(false){}\n};\n\nusing PlayerInputContainer = std::unordered_map<EntityId, \n  PlayerInput>;\n```", "```cpp\nclass S_Network : public S_Base{\npublic:\n  S_Network(SystemManager* l_systemMgr);\n  ~S_Network();\n\n  void Update(float l_dT);\n  void HandleEvent(const EntityId& l_entity,\n    const EntityEvent& l_event);\n  void Notify(const Message& l_message);\n\n  bool RegisterClientID(const EntityId& l_entity,\n    const ClientID& l_client);\n  void RegisterServer(Server* l_server);\n  ClientID GetClientID(const EntityId& l_entity);\n  EntityId GetEntityID(const ClientID& l_client);\n\n  void CreateSnapshot(sf::Packet& l_packet);\n  void UpdatePlayer(sf::Packet& l_packet, const ClientID& l_cid);\nprivate:\n  PlayerInputContainer m_playerInput;\n  Server* m_server;\n};\n```", "```cpp\nS_Network::S_Network(SystemManager* l_systemMgr)\n  : S_Base(System::Network, l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Client);\n  m_requiredComponents.push_back(req);\n\n  MessageHandler* messageHandler = \n    m_systemManager->GetMessageHandler();\n  messageHandler->Subscribe(EntityMessage::Removed_Entity, this);\n  messageHandler->Subscribe(EntityMessage::Hurt, this);\n  messageHandler->Subscribe(EntityMessage::Respawn, this);\n}\n```", "```cpp\nvoid S_Network::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for (auto &entity : m_entities){\n    auto& player = m_playerInput[entity];\n    if (player.m_movedX || player.m_movedY){\n      if (player.m_movedX){\n        Message msg((MessageType)EntityMessage::Move);\n        msg.m_receiver = entity;\n        if (player.m_movedX > 0){msg.m_int=(int)Direction::Right;}\n        else { msg.m_int = (int)Direction::Left; }\n        m_systemManager->GetMessageHandler()->Dispatch(msg);\n      }\n\n      if (player.m_movedY){\n        Message msg((MessageType)EntityMessage::Move);\n        msg.m_receiver = entity;\n        if (player.m_movedY > 0){msg.m_int=(int)Direction::Down;}\n        else { msg.m_int = (int)Direction::Up; }\n        m_systemManager->GetMessageHandler()->Dispatch(msg);\n      }\n    }\n    if (player.m_attacking){\n      Message msg((MessageType)EntityMessage::Attack);\n      msg.m_receiver = entity;\n      m_systemManager->GetMessageHandler()->Dispatch(msg);\n    }\n  }\n}\n```", "```cpp\nvoid S_Network::Notify(const Message& l_message){\n  if (!HasEntity(l_message.m_receiver)){ return; }\n  EntityMessage m = EntityMessage(l_message.m_type);\n  if (m == EntityMessage::Removed_Entity){\n    m_playerInput.erase(l_message.m_receiver);\n    return;\n  }\n  if (m == EntityMessage::Hurt){\n    sf::Packet packet;\n    StampPacket(PacketType::Hurt, packet);\n    packet << l_message.m_receiver;\n    m_server->Broadcast(packet);\n    return;\n  }\n  if (m == EntityMessage::Respawn){\n    C_Position* position = m_systemManager->GetEntityManager()->\n      GetComponent<C_Position>(l_message.m_receiver,\n      Component::Position);\n    if (!position){ return; }\n    position->SetPosition(64.f, 64.f);\n    position->SetElevation(1);\n  }\n}\n```", "```cpp\nbool S_Network::RegisterClientID(const EntityId& l_entity,\n  const ClientID& l_client)\n   {\n  if (!HasEntity(l_entity)){ return false; }\n  m_systemManager->GetEntityManager()->GetComponent<C_Client>\n    (l_entity, Component::Client)->SetClientID(l_client);\n  return true;\n}\n```", "```cpp\nvoid S_Network::RegisterServer(Server* l_server){\n    m_server = l_server;\n}\n```", "```cpp\nClientID S_Network::GetClientID(const EntityId& l_entity){\n  if (!HasEntity(l_entity)){ return (ClientID)Network::NullID; }\n  return m_systemManager->GetEntityManager()->\n    GetComponent<C_Client>(l_entity, Component::Client)->\n    GetClientID();\n}\nEntityId S_Network::GetEntityID(const ClientID& l_client){\n  EntityManager* e = m_systemManager->GetEntityManager();\n  auto entity = std::find_if(m_entities.begin(), m_entities.end(),\n    [&e, &l_client](EntityId& id){\n      return e->GetComponent<C_Client>\n        (id, Component::Client)->GetClientID() == l_client;\n  });\n  return(entity != m_entities.end() ?\n    *entity : (EntityId)Network::NullID);\n}\n```", "```cpp\nvoid S_Network::CreateSnapshot(sf::Packet& l_packet){\n  sf::Lock lock(m_server->GetMutex());\n  ServerEntityManager* e =\n    (ServerEntityManager*)m_systemManager->GetEntityManager();\n  StampPacket(PacketType::Snapshot, l_packet);\n  l_packet << sf::Int32(e->GetEntityCount());\n  if (e->GetEntityCount()){\n    e->DumpEntityInfo(l_packet);\n  }\n}\n```", "```cpp\nvoid S_Network::UpdatePlayer(sf::Packet& l_packet,\n  const ClientID& l_cid)\n{\n  sf::Lock lock(m_server->GetMutex());\n  EntityId eid = GetEntityID(l_cid);\n  if (eid == -1){ return; }\n  if (!HasEntity(eid)){ return; }\n  sf::Int8 entity_message;\n  m_playerInput[eid].m_attacking = false;\n  while (l_packet >> entity_message){\n    switch (entity_message){\n    case sf::Int8(EntityMessage::Move):\n    {\n      sf::Int32 x = 0, y = 0;\n      l_packet >> x >> y;\n      m_playerInput[eid].m_movedX = x;\n      m_playerInput[eid].m_movedY = y;\n      break;\n    }\n    case sf::Int8(EntityMessage::Attack):\n    {\n      sf::Int8 attackState;\n      l_packet >> attackState;\n      if (attackState){ m_playerInput[eid].m_attacking = true; }\n      break;\n    }\n    }\n    sf::Int8 delim = 0;\n    if (!(l_packet >> delim) || delim !=\n      (sf::Int8)Network::PlayerUpdateDelim)\n    {\n      std::cout << \"Faulty update!\" << std::endl; \n      break;\n    }\n  }\n}\n```", "```cpp\nServerEntityManager::ServerEntityManager(SystemManager* l_sysMgr)\n  : EntityManager(l_sysMgr)\n{\n  AddComponentType<C_Position>(Component::Position);\n  AddComponentType<C_State>(Component::State);\n  AddComponentType<C_Movable>(Component::Movable);\n  AddComponentType<C_Controller>(Component::Controller);\n  AddComponentType<C_Collidable>(Component::Collidable);\n  AddComponentType<C_Client>(Component::Client);\n  AddComponentType<C_Health>(Component::Health);\n  AddComponentType<C_Name>(Component::Name);\n  AddComponentType<C_Attacker>(Component::Attacker);\n}\n```", "```cpp\nvoid ServerEntityManager::DumpEntityInfo(sf::Packet& l_packet){\n  for (auto &entity : m_entities){\n    l_packet << sf::Int32(entity.first);\n    EntitySnapshot snapshot;\n    snapshot.m_type = entity.second.m_type;\n    const auto& mask = entity.second.m_bitmask;\n    if (mask.GetBit((unsigned int)Component::Position)){\n      C_Position* p = GetComponent<C_Position>(entity.first,\n        Component::Position);\n      snapshot.m_position = p->GetPosition();\n      snapshot.m_elevation = p->GetElevation();\n    }\n    if (mask.GetBit((unsigned int)Component::Movable)){\n      C_Movable* m = GetComponent<C_Movable>(entity.first,\n        Component::Movable);\n      snapshot.m_velocity = m->GetVelocity();\n      snapshot.m_acceleration = m->GetAcceleration();\n      snapshot.m_direction = sf::Uint8(m->GetDirection());\n    }\n    if (mask.GetBit((unsigned int)Component::State)){\n      C_State* s = GetComponent<C_State>(entity.first,\n        Component::State);\n      snapshot.m_state = sf::Uint8(s->GetState());\n    }\n    if (mask.GetBit((unsigned int)Component::Health)){\n      C_Health* h = GetComponent<C_Health>(entity.first,\n        Component::Health);\n      snapshot.m_health = h->GetHealth();\n    }\n    if (mask.GetBit((unsigned int)Component::Name)){\n      C_Name* n = GetComponent<C_Name>(entity.first,\n        Component::Name);\n      snapshot.m_name = n->GetName();\n    }\n    l_packet << snapshot;\n  }\n}\n```", "```cpp\nServerSystemManager::ServerSystemManager(){\n  AddSystem<S_Network>(System::Network);\n  AddSystem<S_State>(System::State);\n  AddSystem<S_Control>(System::Control);\n  AddSystem<S_Movement>(System::Movement);\n  AddSystem<S_Timers>(System::Timers);\n  AddSystem<S_Collision>(System::Collision);\n  AddSystem<S_Combat>(System::Combat);\n}\n```", "```cpp\nclass World{\npublic:\n    World();\n    ~World();\n\n    void Update(const sf::Time& l_time);\n    void HandlePacket(sf::IpAddress& l_ip, \n      const PortNumber& l_port, const PacketID& l_id, \n     sf::Packet& l_packet, Server* l_server);\n    void ClientLeave(const ClientID& l_client);\n    void CommandLine();\n\n    bool IsRunning();\nprivate:\n    sf::Time m_tpsTime;\n    sf::Time m_serverTime;\n    sf::Time m_snapshotTimer;\n    sf::Thread m_commandThread;\n    Server m_server;\n    ServerSystemManager m_systems;\n    ServerEntityManager m_entities;\n    bool m_running;\n\n    Map m_map;\n    unsigned int m_tick;\n    unsigned int m_tps;\n};\n```", "```cpp\nWorld::World(): m_server(&World::HandlePacket, this),\n  m_commandThread(&World::CommandLine, this), m_entities(nullptr),\n  m_map(&m_entities), m_tick(0), m_tps(0), m_running(false)\n{\n  if (!m_server.Start()){ return; }\n  m_running = true;\n  m_systems.SetEntityManager(&m_entities);\n  m_entities.SetSystemManager(&m_systems);\n  m_map.LoadMap(\"media/Maps/map1.map\");\n  m_systems.GetSystem<S_Collision>(System::Collision)->\n    SetMap(&m_map);\n  m_systems.GetSystem<S_Movement>(System::Movement)->\n    SetMap(&m_map);\n  m_systems.GetSystem<S_Network>(System::Network)->\n    RegisterServer(&m_server);\n  m_server.BindTimeoutHandler(&World::ClientLeave, this);\n  m_commandThread.launch();\n}\n\nWorld::~World(){ m_entities.SetSystemManager(nullptr); }\n```", "```cpp\nvoid World::Update(const sf::Time& l_time){\n  if (!m_server.IsRunning()){ m_running = false; return; }\n  m_serverTime += l_time;\n  m_snapshotTimer += l_time;\n  m_tpsTime += l_time;\n  m_server.Update(l_time);\n  m_server.GetMutex().lock();\n  m_systems.Update(l_time.asSeconds());\n  m_server.GetMutex().unlock();\n  if (m_snapshotTimer.asMilliseconds() >= SNAPSHOT_INTERVAL){\n    sf::Packet snapshot;\n    m_systems.GetSystem<S_Network>(System::Network)->\n      CreateSnapshot(snapshot);\n    m_server.Broadcast(snapshot);\n    m_snapshotTimer = sf::milliseconds(0);\n  }\n  if (m_tpsTime >= sf::milliseconds(1000)){\n    m_tps = m_tick;\n    m_tick = 0;\n    m_tpsTime = sf::milliseconds(0);\n  } else {\n    ++m_tick;\n  }\n}\n```", "```cpp\nvoid World::HandlePacket(sf::IpAddress& l_ip,\n  const PortNumber& l_port, const PacketID& l_id,\n  sf::Packet& l_packet, Server* l_server)\n{\n  ClientID id = l_server->GetClientID(l_ip, l_port);\n  PacketType type = (PacketType)l_id;\n  if (id >= 0){\n    if (type == PacketType::Disconnect){\n      ClientLeave(id);\n      l_server->RemoveClient(l_ip, l_port);\n    } else if (type == PacketType::Message){\n      // ...\n    } else if (type == PacketType::PlayerUpdate){\n      m_systems.GetSystem<S_Network>(System::Network)->\n        UpdatePlayer(l_packet, id);\n    }\n  } else {\n    if (type != PacketType::Connect){ return; }\n    std::string nickname;\n    if (!(l_packet >> nickname)){ return; }\n    ClientID cid = l_server->AddClient(l_ip, l_port);\n    if (cid == -1){\n      sf::Packet packet;\n      StampPacket(PacketType::Disconnect, packet);\n      l_server->Send(l_ip, l_port, packet);\n      return;\n    }\n    sf::Lock lock(m_server.GetMutex());\n    sf::Int32 eid = m_entities.AddEntity(\"Player\");\n    if (eid == -1){ return; }\n    m_systems.GetSystem<S_Network>(System::Network)->\n      RegisterClientID(eid, cid);\n    C_Position* pos = m_entities.GetComponent<C_Position>\n      (eid, Component::Position);\n    pos->SetPosition(64.f, 64.f);\n    m_entities.GetComponent<C_Name>(eid, Component::Name)->\n      SetName(nickname);\n    sf::Packet packet;\n    StampPacket(PacketType::Connect, packet);\n    packet << eid;\n    packet << pos->GetPosition().x << pos->GetPosition().y;\n    if (!l_server->Send(cid, packet)){\n      std::cout << \"Unable to respond to connect packet!\"\n        << std::endl;\n      return;\n    }\n  }\n}\n```", "```cpp\nvoid World::ClientLeave(const ClientID& l_client){\n    sf::Lock lock(m_server.GetMutex());\n    S_Network* network = m_systems.\n     GetSystem<S_Network>(System::Network);\n    m_entities.RemoveEntity(network->GetEntityID(l_client));\n}\n```", "```cpp\nvoid World::CommandLine(){\n   while (m_server.IsRunning()){\n      std::string str;\n      std::getline(std::cin, str);\n      if (str == \"terminate\"){\n         m_server.Stop();\n         m_running = false;\n         break;\n      } else if (str == \"disconnectall\"){\n         std::cout << \"Disconnecting all clients...\" << std::endl;\n         m_server.DisconnectAll();\n         sf::Lock lock(m_server.GetMutex());\n         m_entities.Purge();\n      } else if (str.find(\"tps\") != std::string::npos){\n         std::cout << \"TPS: \" << m_tps << std::endl;\n      } else if (str == \"clients\"){\n         std::cout << m_server.GetClientCount() \n            << \" clients online:\" << std::endl;\n         std::cout << m_server.GetClientList() \n            << std::endl;\n      } else if (str == \"entities\"){\n         std::cout << \"Current entity count: \" \n            << m_entities.GetEntityCount() << std::endl;\n      }\n   }\n}\n```", "```cpp\nbool World::IsRunning(){ return m_running; }\n```", "```cpp\n#include \"World.h\"\n\nint main(){\n    World world;\n    sf::Clock clock;\n    clock.restart();\n\n    while (world.IsRunning()){\n        world.Update(clock.restart());\n    }\n     return 0;\n}\n```", "```cpp\n#define NET_RENDER_DELAY 100 // ms.\n#define PLAYER_UPDATE_INTERVAL 50 // ms\n```", "```cpp\nclass C_UI_Element : public C_Base{\npublic:\n  C_UI_Element() : C_Base(Component::UI_Element),\n    m_showHealth(false), m_showName(false){}\n  void ReadIn(std::stringstream& l_stream){\n    l_stream >> m_offset.x >> m_offset.y;\n  }\n\n  const sf::Vector2f& GetOffset(){ return m_offset; }\n  void SetOffset(const sf::Vector2f& l_offset){ m_offset = l_offset; }\n\n  void SetShowHealth(bool l_show){ m_showHealth = l_show; }\n  void SetShowName(bool l_show){ m_showName = l_show; }\n  bool ShowHealth(){ return m_showHealth; }\n  bool ShowName(){ return m_showName; }\nprivate:\n  sf::Vector2f m_offset;\n  bool m_showHealth;\n  bool m_showName;\n};\n```", "```cpp\nclass S_CharacterUI : public S_Base{\npublic:\n    S_CharacterUI(SystemManager* l_systemMgr);\n    ~S_CharacterUI();\n\n    void Update(float l_dT);\n    void HandleEvent(const EntityId& l_entity, \n      const EntityEvent& l_event);\n    void Notify(const Message& l_message);\n\n    void Render(Window* l_wind);\nprivate:\n    sf::Sprite m_heartBar;\n    sf::Text m_nickname;\n    sf::RectangleShape m_nickbg;\n    sf::Vector2u m_heartBarSize;\n};\n```", "```cpp\nS_CharacterUI::S_CharacterUI(SystemManager* l_systemMgr)\n  : S_Base(System::Character_UI, l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::UI_Element);\n  req.TurnOnBit((unsigned int)Component::Health);\n  m_requiredComponents.push_back(req);\n  req.ClearBit((unsigned int)Component::Health);\n  req.TurnOnBit((unsigned int)Component::Name);\n  m_requiredComponents.push_back(req);\n\n  ClientSystemManager* mgr =(ClientSystemManager*)m_systemManager;\n  mgr->GetTextureManager()->RequireResource(\"HeartBar\");\n  mgr->GetFontManager()->RequireResource(\"Main\");\n  sf::Texture* txtr = mgr->GetTextureManager()->\n    GetResource(\"HeartBar\");\n  txtr->setRepeated(true);\n  m_heartBarSize = txtr->getSize();\n  m_heartBar.setTexture(*txtr);\n  m_heartBar.setScale(0.5f, 0.5f);\n  m_heartBar.setOrigin(m_heartBarSize.x / 2, m_heartBarSize.y);\n  m_nickname.setFont(*mgr->GetFontManager()->GetResource(\"Main\"));\n  m_nickname.setCharacterSize(9);\n  m_nickname.setColor(sf::Color::White);\n  m_nickbg.setFillColor(sf::Color(100, 100, 100, 100));\n}\n```", "```cpp\nS_CharacterUI::~S_CharacterUI(){\n    ClientSystemManager* mgr =\n     (ClientSystemManager*)m_systemManager;\n    mgr->GetTextureManager()->ReleaseResource(\"HeartBar\");\n    mgr->GetFontManager()->ReleaseResource(\"Main\");\n}\n```", "```cpp\nvoid S_CharacterUI::Render(Window* l_wind){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for (auto &entity : m_entities){\n    C_Health* health = entities->\n      GetComponent<C_Health>(entity, Component::Health);\n    C_Name* name = entities->\n      GetComponent<C_Name>(entity, Component::Name);\n    C_Position* pos = entities->\n      GetComponent<C_Position>(entity, Component::Position);\n    C_UI_Element* ui = entities->\n      GetComponent<C_UI_Element>(entity, Component::UI_Element);\n    if (health){\n      m_heartBar.setTextureRect(sf::IntRect(0, 0,\n        m_heartBarSize.x * health->GetHealth(),\n        m_heartBarSize.y));\n      m_heartBar.setOrigin((\n        m_heartBarSize.x * health->GetHealth())/2,\n        m_heartBarSize.y);\n      m_heartBar.setPosition(pos->GetPosition() +ui->GetOffset());\n      l_wind->GetRenderWindow()->draw(m_heartBar);\n    }\n    if (name){\n      m_nickname.setString(name->GetName());\n      m_nickname.setOrigin(m_nickname.getLocalBounds().width / 2,\n        m_nickname.getLocalBounds().height / 2);\n      if (health){\n        m_nickname.setPosition(m_heartBar.getPosition().x,\n          m_heartBar.getPosition().y - (m_heartBarSize.y));\n      } else {\n        m_nickname.setPosition(pos->GetPosition() +\n          ui->GetOffset());\n      }\n      m_nickbg.setSize(sf::Vector2f(\n        m_nickname.getGlobalBounds().width + 2,\n        m_nickname.getCharacterSize() + 1));\n      m_nickbg.setOrigin(m_nickbg.getSize().x / 2,\n        m_nickbg.getSize().y / 2);\n      m_nickbg.setPosition(m_nickname.getPosition().x + 1,\n        m_nickname.getPosition().y + 1);\n      l_wind->GetRenderWindow()->draw(m_nickbg);\n      l_wind->GetRenderWindow()->draw(m_nickname);\n    }\n  }\n}\n```", "```cpp\ntemplate<class T>\ninline T Interpolate(const sf::Int32& T1, const sf::Int32& T2,\n  const T& T1_val, const T& T2_val, const sf::Int32& T_X)\n{\n  return (((T2_val - T1_val) / (T2 - T1)) * (T_X - T1)) + T1_val;\n}\n```", "```cpp\nvoid InterpolateSnapshot(const EntitySnapshot& l_s1, \n  const sf::Int32& T1, const EntitySnapshot& l_s2, \n  const sf::Int32& T2, EntitySnapshot& l_target, \n  const sf::Int32& T_X);\n\nbool CompareSnapshots(const EntitySnapshot& l_s1, \n  const EntitySnapshot& l_s2, bool l_position = true, \n  bool l_physics = true, bool l_state = true);\n```", "```cpp\nusing SnapshotMap = std::unordered_map<EntityId, EntitySnapshot>;\nstruct SnapshotDetails{\n  SnapshotMap m_snapshots;\n};\nusing SnapshotContainer = std::map<sf::Int32, SnapshotDetails>;\nusing OutgoingMessages = std::unordered_map<EntityMessage,\n  std::vector<Message>>;\n```", "```cpp\nclass S_Network : public S_Base{\npublic:\n  S_Network(SystemManager* l_systemMgr);\n  ~S_Network();\n\n  void Update(float l_dT);\n  void HandleEvent(const EntityId& l_entity,\n    const EntityEvent& l_event);\n  void Notify(const Message& l_message);\n\n  void SetClient(Client* m_client);\n  void SetPlayerID(const EntityId& l_entity);\n\n  void AddSnapshot(const EntityId& l_entity, \n    const sf::Int32& l_timestamp, \n    EntitySnapshot& l_snapshot);\n  void SendPlayerOutgoing();\n  void ClearSnapshots();\nprivate:\n  void ApplyEntitySnapshot(const EntityId& l_entity,\n    const EntitySnapshot& l_snapshot,\n    bool l_applyPhysics);\n\n  void PerformInterpolation();\n  SnapshotContainer m_entitySnapshots;\n  EntityId m_player;\n  OutgoingMessages m_outgoing;\n  Client* m_client;\n  sf::Time m_playerUpdateTimer;\n};\n```", "```cpp\nvoid InterpolateSnapshot(const EntitySnapshot& l_s1,\n  const sf::Int32& T1, const EntitySnapshot& l_s2,\n  const sf::Int32& T2, EntitySnapshot& l_target,\n  const sf::Int32& T_X)\n{\n  l_target.m_direction = l_s2.m_direction;\n  l_target.m_health = l_s2.m_health;\n  l_target.m_name = l_s2.m_name;\n  l_target.m_state = l_s1.m_state;\n  l_target.m_elevation = l_s1.m_elevation;\n\n  l_target.m_position.x = Interpolate<float>(\n    T1, T2, l_s1.m_position.x, l_s2.m_position.x, T_X);\n  l_target.m_position.y = Interpolate<float>(\n    T1, T2, l_s1.m_position.y, l_s2.m_position.y, T_X);\n\n  l_target.m_velocity.x = Interpolate<float>(\n    T1, T2, l_s1.m_velocity.x, l_s2.m_velocity.x, T_X);\n  l_target.m_velocity.y = Interpolate<float>(\n    T1, T2, l_s1.m_velocity.y, l_s2.m_velocity.y, T_X);\n\n  l_target.m_acceleration.x = Interpolate<float>(\n    T1, T2, l_s1.m_acceleration.x, l_s2.m_acceleration.x, T_X);\n  l_target.m_acceleration.y = Interpolate<float>(\n    T1, T2, l_s1.m_acceleration.y, l_s2.m_acceleration.y, T_X);\n}\n```", "```cpp\nbool CompareSnapshots(const EntitySnapshot& l_s1,\n  const EntitySnapshot& l_s2, bool l_position,\n  bool l_physics, bool l_state)\n{\n  if (l_position && (l_s1.m_position != l_s2.m_position || \n    l_s1.m_elevation != l_s2.m_elevation))\n  { return false; }\n  if (l_physics && (l_s1.m_velocity != l_s2.m_velocity ||\n    l_s1.m_acceleration != l_s2.m_acceleration ||\n    l_s1.m_direction != l_s2.m_direction))\n  { return false; }\n  if (l_state && (l_s1.m_state != l_s2.m_state))\n  { return false; }\n  return true;\n}\n```", "```cpp\nS_Network::S_Network(SystemManager* l_systemMgr)\n  : S_Base(System::Network, l_systemMgr), m_client(nullptr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Client);\n  m_requiredComponents.push_back(req);\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Move, this);\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Attack, this);\n  m_playerUpdateTimer = sf::milliseconds(0);\n}\n```", "```cpp\nvoid S_Network::Update(float l_dT){\n  if (!m_client){ return; }\n  sf::Lock lock(m_client->GetMutex());\n  m_playerUpdateTimer += sf::seconds(l_dT);\n  if (m_playerUpdateTimer.asMilliseconds() >=\n    PLAYER_UPDATE_INTERVAL)\n  {\n    SendPlayerOutgoing();\n    m_playerUpdateTimer = sf::milliseconds(0);\n  }\n  PerformInterpolation();\n}\n```", "```cpp\nvoid S_Network::Notify(const Message& l_message){\n  if (!HasEntity(l_message.m_receiver) ||\n    l_message.m_receiver != m_player)\n  {\n    return;\n  }\n  if (l_message.m_type == (MessageType)EntityMessage::Attack &&\n    m_outgoing.find(EntityMessage::Attack) != m_outgoing.end())\n  {\n    return;\n  }\n  m_outgoing[(EntityMessage)l_message.m_type].\n    emplace_back(l_message);\n}\n```", "```cpp\nvoid S_Network::SetClient(Client* l_client){m_client = l_client;}\nvoid S_Network::SetPlayerID(const EntityId& l_entity){\n  m_player = l_entity;\n}\nvoid S_Network::AddSnapshot(const EntityId& l_entity, \n  const sf::Int32& l_timestamp, EntitySnapshot& l_snapshot)\n{\n  sf::Lock lock(m_client->GetMutex());\n  auto i = m_entitySnapshots.emplace(l_timestamp,\n    SnapshotDetails());\n  i.first->second.m_snapshots.emplace(l_entity, l_snapshot);\n}\n```", "```cpp\nvoid S_Network::ApplyEntitySnapshot(const EntityId& l_entity, \n  const EntitySnapshot& l_snapshot, bool l_applyPhysics)\n{\n  ClientEntityManager* entities =\n    (ClientEntityManager*)m_systemManager->GetEntityManager();\n  C_Position* position = nullptr;\n  C_Movable* movable = nullptr;\n  S_Movement* movement_s = nullptr;\n  S_State* state_s = nullptr;\n  C_Health* health = nullptr;\n  C_Name* name = nullptr;\n  sf::Lock lock(m_client->GetMutex());\n  if (position = entities->GetComponent<C_Position>(l_entity,\n    Component::Position))\n  {\n    position->SetPosition(l_snapshot.m_position);\n    position->SetElevation(l_snapshot.m_elevation);\n  }\n  if (l_applyPhysics){\n    if (movable = entities->GetComponent<C_Movable>(l_entity,\n      Component::Movable))\n    {\n      movable->SetVelocity(l_snapshot.m_velocity);\n      movable->SetAcceleration(l_snapshot.m_acceleration);\n    }\n  }\n  if (movement_s = m_systemManager->\n    GetSystem<S_Movement>(System::Movement))\n  {\n    movement_s->SetDirection(l_entity,\n      (Direction)l_snapshot.m_direction);\n  }\n  if (state_s = m_systemManager->\n    GetSystem<S_State>(System::State))\n  {\n    state_s->ChangeState(l_entity,\n      (EntityState)l_snapshot.m_state,true);\n  }\n  if (health = entities->GetComponent<C_Health>(l_entity,\n    Component::Health))\n  {\n    health->SetHealth(l_snapshot.m_health);\n  }\n  if (name = entities->GetComponent<C_Name>(l_entity,\n    Component::Name))\n  {\n    name->SetName(l_snapshot.m_name);\n  }\n}\n```", "```cpp\nvoid S_Network::SendPlayerOutgoing(){\n  sf::Int32 p_x = 0, p_y = 0;\n  sf::Int8 p_a = 0;\n\n  for (auto &itr : m_outgoing){\n    if (itr.first == EntityMessage::Move){\n      sf::Int32 x = 0, y = 0;\n      for (auto &message : itr.second){\n        if (message.m_int == (int)Direction::Up){ --y; }\n        else if (message.m_int == (int)Direction::Down){ ++y; }\n        else if (message.m_int == (int)Direction::Left){ --x; }\n        else if (message.m_int == (int)Direction::Right){ ++x; }\n      }\n      if (!x && !y){ continue; }\n      p_x = x; p_y = y;\n    } else if (itr.first == EntityMessage::Attack){ p_a = 1; }\n  }\n\n  sf::Packet packet;\n  StampPacket(PacketType::PlayerUpdate, packet);\n  packet << sf::Int8(EntityMessage::Move)\n    << p_x << p_y << sf::Int8(Network::PlayerUpdateDelim);\n  packet << sf::Int8(EntityMessage::Attack)\n    << p_a << sf::Int8(Network::PlayerUpdateDelim);\n  m_client->Send(packet);\n  m_outgoing.clear();\n}\n```", "```cpp\nvoid S_Network::PerformInterpolation(){\n  if (m_entitySnapshots.empty()){ return; }\n  ClientEntityManager* entities =\n    (ClientEntityManager*)m_systemManager->GetEntityManager();\n  sf::Time t = m_client->GetTime();\n  auto itr = ++m_entitySnapshots.begin();\n  while (itr != m_entitySnapshots.end()){\n    if (m_entitySnapshots.begin()->first <=\n      t.asMilliseconds() - NET_RENDER_DELAY &&\n      itr->first >= t.asMilliseconds() - NET_RENDER_DELAY)\n    {\n      auto Snapshot1 = m_entitySnapshots.begin();\n      auto Snapshot2 = itr;\n      bool SortDrawables = false;\n      for (auto snap = Snapshot1->second.m_snapshots.begin();\n        snap != Snapshot1->second.m_snapshots.end();)\n      {\n        if (!entities->HasEntity(snap->first)){\n          if (entities->AddEntity(snap->second.m_type,\n            snap->first) == (int)Network::NullID)\n          {\n            std::cout << \"Failed adding entity type: \"\n              << snap->second.m_type << std::endl;\n            continue;\n          }\n          ApplyEntitySnapshot(snap->first, snap->second, true);\n          ++snap;\n          continue;\n        }\n        auto snap2 =Snapshot2->second.m_snapshots.find(\n          snap->first);\n        if (snap2 == Snapshot2->second.m_snapshots.end()){\n          sf::Lock lock(m_client->GetMutex());\n          entities->RemoveEntity(snap->first);\n          snap = Snapshot1->second.m_snapshots.erase(snap);\n          continue;\n        }\n\n        EntitySnapshot i_snapshot;\n        InterpolateSnapshot(snap->second, Snapshot1->first,\n          snap2->second, Snapshot2->first,\n          i_snapshot, t.asMilliseconds() - NET_RENDER_DELAY);\n        ApplyEntitySnapshot(snap->first, i_snapshot, true);\n        if (!CompareSnapshots(snap->second, snap2->second,\n          true, false, false))\n        {\n          SortDrawables = true;\n        }\n        ++snap;\n      }\n      if (SortDrawables){\n        m_systemManager->GetSystem<S_Renderer>\n          (System::Renderer)->SortDrawables();\n      }\n      return;\n    }\n    m_entitySnapshots.erase(m_entitySnapshots.begin());\n    itr = ++m_entitySnapshots.begin();\n  }\n}\n```", "```cpp\nClientEntityManager::ClientEntityManager(SystemManager* l_sysMgr, \n  TextureManager* l_textureMgr): EntityManager(l_sysMgr),\n  m_textureManager(l_textureMgr)\n{\n  AddComponentType<C_Position>(Component::Position);\n  AddComponentType<C_State>(Component::State);\n  AddComponentType<C_Movable>(Component::Movable);\n  AddComponentType<C_Controller>(Component::Controller);\n  AddComponentType<C_Collidable>(Component::Collidable);\n  AddComponentType<C_SpriteSheet>(Component::SpriteSheet);\n  AddComponentType<C_SoundEmitter>(Component::SoundEmitter);\n  AddComponentType<C_SoundListener>(Component::SoundListener);\n  AddComponentType<C_Client>(Component::Client);\n  AddComponentType<C_Health>(Component::Health);\n  AddComponentType<C_Name>(Component::Name);\n  AddComponentType<C_UI_Element>(Component::UI_Element);\n}\n```", "```cpp\nint ClientEntityManager::AddEntity(\n  const std::string& l_entityFile, int l_id)\n{\n  ...\n  while (std::getline(file, line)){\n    ...\n    } else if (type == \"Component\"){\n      ...\n      keystream >> *component;\n      if (component->GetType() == Component::SpriteSheet){\n        C_SpriteSheet* sheet = (C_SpriteSheet*)component;\n        sheet->Create(m_textureManager);\n      }\n    }\n  }\n  ...\n}\n```", "```cpp\nclass ClientSystemManager : public SystemManager{\npublic:\n    ClientSystemManager(TextureManager* l_textureMgr,\n      FontManager* l_fontMgr);\n    ~ClientSystemManager();\n\n    TextureManager* GetTextureManager();\n    FontManager* GetFontManager();\n    void Draw(Window* l_wind, unsigned int l_elevation);\nprivate:\n    TextureManager* m_textureMgr;\n    FontManager* m_fontMgr;\n};\n```", "```cpp\nClientSystemManager::ClientSystemManager(\n  TextureManager* l_textureMgr, FontManager* l_fontMgr)\n  : m_textureMgr(l_textureMgr), m_fontMgr(l_fontMgr)\n{\n  AddSystem<S_State>(System::State);\n  AddSystem<S_Control>(System::Control);\n  AddSystem<S_Movement>(System::Movement);\n  AddSystem<S_Collision>(System::Collision);\n  AddSystem<S_SheetAnimation>(System::SheetAnimation);\n  AddSystem<S_Network>(System::Network);\n  AddSystem<S_Sound>(System::Sound);\n  AddSystem<S_Renderer>(System::Renderer);\n  AddSystem<S_CharacterUI>(System::Character_UI);\n}\n```", "```cpp\nTextureManager* ClientSystemManager::GetTextureManager(){\n    return m_textureMgr;\n}\nFontManager* ClientSystemManager::GetFontManager(){\n    return m_fontMgr;\n}\n```", "```cpp\nvoid ClientSystemManager::Draw(Window* l_wind,\n  unsigned int l_elevation)\n{\n  auto itr = m_systems.find(System::Renderer);\n  if(itr != m_systems.end()){\n    S_Renderer* system = (S_Renderer*)itr->second;\n    system->Render(l_wind, l_elevation);\n  }\n  itr = m_systems.find(System::Character_UI);\n  if (itr != m_systems.end()){\n    S_CharacterUI* ui = (S_CharacterUI*)itr->second;\n    ui->Render(l_wind);\n  }\n}\n```", "```cpp\nclass State_Game : public BaseState{\n    ...\nprivate:\n    Map* m_gameMap;\n    int m_player;\n   Client* m_client;\n};\n```", "```cpp\nvoid State_Game::HandlePacket(const PacketID& l_id,\n  sf::Packet& l_packet, Client* l_client)\n{\n  ClientEntityManager* emgr = m_stateMgr->\n    GetContext()->m_entityManager;\n  PacketType type = (PacketType)l_id;\n  if (type == PacketType::Connect){\n    sf::Int32 eid;\n    sf::Vector2f pos;\n    if (!(l_packet >> eid) || !(l_packet >> pos.x) ||\n      !(l_packet >> pos.y))\n    {\n      std::cout << \"Faulty CONNECT response!\" << std::endl;\n      return;\n    }\n    std::cout << \"Adding entity: \" << eid << std::endl;\n    m_client->GetMutex().lock();\n    emgr->AddEntity(\"Player\", eid);\n    emgr->GetComponent<C_Position>\n      (eid, Component::Position)->SetPosition(pos);\n    m_client->GetMutex().unlock();\n    m_player = eid;\n    m_stateMgr->GetContext()->m_systemManager->\n     GetSystem<S_Network>(System::Network)->SetPlayerID(m_player);\n    emgr->AddComponent(eid, Component::SoundListener);\n    return;\n  }\n\n  if (!m_client->IsConnected()){ return; }\n  switch (type){\n  case PacketType::Snapshot:\n  {\n    sf::Int32 entityCount = 0;\n    if (!(l_packet >> entityCount)){\n      std::cout << \"Snapshot extraction failed.\"\n        << std::endl;\n      return;\n    }\n    sf::Lock lock(m_client->GetMutex());\n    sf::Int32 t = m_client->GetTime().asMilliseconds();\n    for (unsigned int i = 0; i < entityCount; ++i){\n      sf::Int32 eid;\n      EntitySnapshot snapshot;\n      if (!(l_packet >> eid) || !(l_packet >> snapshot)){\n        std::cout << \"Snapshot extraction failed.\"\n          << std::endl;\n        return;\n      }\n      m_stateMgr->GetContext()->m_systemManager->\n        GetSystem<S_Network>(System::Network)->\n          AddSnapshot(eid, t, snapshot);\n    }\n    break;\n  }\n  case PacketType::Disconnect:\n  {\n    m_stateMgr->Remove(StateType::Game);\n    m_stateMgr->SwitchTo(StateType::MainMenu);\n    std::cout << \"Disconnected by server!\" << std::endl;\n    break;\n  }\n  case PacketType::Hurt:\n  {\n    EntityId id;\n    if (!(l_packet >> id)){ return; }\n    Message msg((MessageType)EntityMessage::Hurt);\n    msg.m_receiver = id;\n    m_stateMgr->GetContext()->m_systemManager->\n      GetMessageHandler()->Dispatch(msg);\n    break;\n  }\n  }\n}\n```", "```cpp\nvoid State_Game::OnCreate(){\n  m_client->Setup(&State_Game::HandlePacket, this);\n  if (m_client->Connect()){\n    m_stateMgr->GetContext()->m_systemManager->\n      GetSystem<S_Network>(System::Network)->SetClient(m_client);\n    ...\n    evMgr->AddCallback(StateType::Game, \"Player_Attack\",\n      &State_Game::PlayerAttack, this);\n    ...\n  } else {\n    std::cout << \"Failed to connect to the game server!\"\n      << std::endl;\n    m_stateMgr->Remove(StateType::Game);\n    m_stateMgr->SwitchTo(StateType::MainMenu);\n  }\n}\n```", "```cpp\nvoid State_Game::OnDestroy(){\n  m_client->Disconnect();\n  m_client->UnregisterPacketHandler();\n  S_Network* net = m_stateMgr->GetContext()->\n    m_systemManager->GetSystem<S_Network>(System::Network);\n  net->ClearSnapshots();\n  net->SetClient(nullptr);\n  net->SetPlayerID((int)Network::NullID);\n  ...\n  evMgr->RemoveCallback(StateType::Game, \"Player_Attack\");\n  ...\n}\n```", "```cpp\nvoid State_Game::Update(const sf::Time& l_time){\n  if (!m_client->IsConnected()){\n    m_stateMgr->Remove(StateType::Game);\n    m_stateMgr->SwitchTo(StateType::MainMenu);\n    return;\n  }\n  SharedContext* context = m_stateMgr->GetContext();\n  UpdateCamera();\n  m_gameMap->Update(l_time.asSeconds());\n  {\n    sf::Lock lock(m_client->GetMutex());\n    context->m_systemManager->Update(l_time.asSeconds());\n  }\n}\n```", "```cpp\nvoid State_Game::Draw(){\n  if (!m_gameMap){ return; }\n  sf::Lock lock(m_client->GetMutex());\n  for (int i = 0; i < Sheet::Num_Layers; ++i){\n    m_gameMap->Draw(i);\n    m_stateMgr->GetContext()->m_systemManager->\n      Draw(m_stateMgr->GetContext()->m_wind, i);\n  }\n}\n```", "```cpp\nvoid State_Game::PlayerAttack(EventDetails* l_details){\n  Message msg((MessageType)EntityMessage::Attack);\n  msg.m_receiver = m_player;\n  m_stateMgr->GetContext()->m_systemManager->\n    GetMessageHandler()->Dispatch(msg);\n}\n```", "```cpp\nInterface MainMenu MainMenu.style 0 0 Immovable NoTitle \"Main menu\"\nElement Label Title 100 0 MainMenuTitle.style \"Main menu:\"\nElement Label IpLabel 0 32 DefaultLabel.style \"IP:\"\nElement TextField IP 18 32 MainMenuTextfield.style \"127.0.0.1\"\nElement Label PortLabel 150 32 DefaultLabel.style \"Port:\"\nElement TextField PORT 175 32 MainMenuTextfield.style \"5600\"\nElement Label NameLabel 50 56 DefaultLabel.style \"Nickname:\"\nElement TextField Nickname 105 56 MainMenuTextfield.style \"Player\"\nElement Label Play 0 80 MainMenuLabel.style \"CONNECT\"\nElement Label Disconnect 0 116 MainMenuLabel.style \"DISCONNECT\"\nElement Label Credits 0 152 MainMenuLabel.style \"CREDITS\"\nElement Label Quit 0 188 MainMenuLabel.style \"EXIT\"\n```", "```cpp\nvoid State_MainMenu::OnCreate(){\n  SetTransparent(true); // Transparent for rendering.\n  SetTranscendent(true); // Transcendent for updating.\n  ...\n  eMgr->AddCallback(StateType::MainMenu, \"MainMenu_Play\",\n    &State_MainMenu::Play, this);\n  eMgr->AddCallback(StateType::MainMenu, \"MainMenu_Disconnect\",\n    &State_MainMenu::Disconnect, this);\n  eMgr->AddCallback(StateType::MainMenu, \"MainMenu_Quit\",\n    &State_MainMenu::Quit, this);\n}\n\nvoid State_MainMenu::OnDestroy(){\n  ...\n  gui->RemoveInterface(StateType::MainMenu, \"MainMenu\");\n  eMgr->RemoveCallback(StateType::MainMenu, \"MainMenu_Play\");\n  eMgr->RemoveCallback(StateType::MainMenu,\"MainMenu_Disconnect\");\n  eMgr->RemoveCallback(StateType::MainMenu, \"MainMenu_Quit\");\n}\n```", "```cpp\nvoid State_MainMenu::Activate(){\n  GUI_Interface* menu = m_stateMgr->GetContext()->\n    m_guiManager->GetInterface(StateType::MainMenu, \"MainMenu\");\n  if(m_stateMgr->HasState(StateType::Game)){\n    // Resume\n    menu->GetElement(\"Play\")->SetText(\"Resume\");\n    menu->GetElement(\"Disconnect\")->SetActive(true);\n    menu->GetElement(\"IP\")->SetActive(false);\n    menu->GetElement(\"PORT\")->SetActive(false);\n    menu->GetElement(\"IpLabel\")->SetActive(false);\n    menu->GetElement(\"PortLabel\")->SetActive(false);\n    menu->GetElement(\"NameLabel\")->SetActive(false);\n    menu->GetElement(\"Nickname\")->SetActive(false);\n  } else {\n    // Play\n    menu->GetElement(\"Play\")->SetText(\"CONNECT\");\n    menu->GetElement(\"Disconnect\")->SetActive(false);\n    menu->GetElement(\"IP\")->SetActive(true);\n    menu->GetElement(\"PORT\")->SetActive(true);\n    menu->GetElement(\"IpLabel\")->SetActive(true);\n    menu->GetElement(\"PortLabel\")->SetActive(true);\n    menu->GetElement(\"NameLabel\")->SetActive(true);\n    menu->GetElement(\"Nickname\")->SetActive(true);\n  }\n}\n```", "```cpp\nvoid State_MainMenu::Play(EventDetails* l_details){\n  if (!m_stateMgr->HasState(StateType::Game)){\n    GUI_Interface* menu = m_stateMgr->GetContext()->\n      m_guiManager->GetInterface(StateType::MainMenu, \"MainMenu\");\n    std::string ip = menu->GetElement(\"IP\")->GetText();\n    PortNumber port = std::atoi(\n      menu->GetElement(\"PORT\")->GetText().c_str());\n    std::string name = menu->GetElement(\"Nickname\")->GetText();\n    m_stateMgr->GetContext()->m_client->\n      SetServerInformation(ip, port);\n    m_stateMgr->GetContext()->m_client->SetPlayerName(name);\n  }\n  m_stateMgr->SwitchTo(StateType::Game);\n}\n\nvoid State_MainMenu::Disconnect(EventDetails* l_details){\n  m_stateMgr->GetContext()->m_client->Disconnect();\n}\n```"]