["```cpp\n#include <SPI.h>         \n#include <Ethernet.h>\n#include <EthernetUdp.h>\n```", "```cpp\n#include <SPI.h>\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n\n// Switch & LED stuff\nconst int switchPin = 2;     // switch pin\nconst int ledPin =  13;      // built-in LED pin\nint switchState = 0;         // storage variable for current switch state\nint lastSwitchState = LOW;\nlong lastDebounceTime = 0;\nlong debounceDelay = 50;\n\n// Network related stuff\n\n// a MAC address, an IP address and a port for the Arduino\nbyte mac[] = { \n  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\nIPAddress ipArduino(192, 168, 1, 123);\nunsigned int ArduinoPort = 9999;\n\n// an IP address and a UDP port for the Computer\n// modify these according to your configuration\nIPAddress ipComputer(192, 168, 1, 222);\nunsigned int ComputerPort = 10000;\n\n// Send/receive buffer\nchar packetBuffer[UDP_TX_PACKET_MAX_SIZE]; //buffer for incoming packets\n\n// Instantiate EthernetUDP instance to send/receive packets over UDP\nEthernetUDP Udp;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output\n  pinMode(switchPin, INPUT); // the switch pin is setup as an input\n\n  // start Ethernet and UDP:\n  Ethernet.begin(mac,ipArduino);\n  Udp.begin(ArduinoPort);\n}\n\nvoid loop(){\n\n  // if a packet has been received read a packet into packetBufffer\n  if (Udp.parsePacket()) Udp.read(packetBuffer,UDP_TX_PACKET_MAX_SIZE);\n  if (packetBuffer == \"Light\") digitalWrite(ledPin, HIGH);\n  else if (packetBuffer == \"Dark\") digitalWrite(ledPin, LOW);\n\n  // read the state of the digital pin\n  int readInput = digitalRead(switchPin);\n  if (readInput != lastSwitchState)\n  {\n    lastDebounceTime = millis(); \n  }\n\n  if ( (millis() - lastDebounceTime) > debounceDelay )\n  { \n    switchState = readInput; \n  }\n\n  lastSwitchState = readInput;\n  if (switchState == HIGH)\n  {\n    // If switch is pushed, a packet is sent to Processing\n    Udp.beginPacket(ipComputer, ComputerPort);\n    Udp.write('Pushed');\n    Udp.endPacket();\n  }\n  else\n  {\n    // If switch is pushed, a packet is sent to Processing\n    Udp.beginPacket(ipComputer, ComputerPort);\n    Udp.write('Released');\n    Udp.endPacket();\n  }\n\n  delay(10);\n}\n```", "```cpp\nimport hypermedia.net.*;\n\nUDP udp;  // define the UDP object\nString currentMessage;\n\nString ip       = \"192.168.1.123\"; // the Arduino IP address\nint port        = 9999;        // the Arduino UDP port\n\nvoid setup() {\n  size(700, 700);\n  noStroke();\n  fill(0);\n\n  udp = new UDP( this, 10000 );  // create UDP socket\n  udp.listen( true );           // wait for incoming message\n}\n\nvoid draw()\n{\n  ellipse(width/2, height/2, 230, 230);\n}\n\nvoid receive( byte[] data ) {\n\n  // if the message could be \"Pushed\" or \"Released\"\n  if ( data.length == 6 || data.length == 8 ) \n  {\n    for (int i=0; i < data.length; i++) \n    { \n      currentMessage += data[i];\n    }\n\n    // if the message is really Pushed\n    // then answer back by sending \"Light\"\n    if (currentMessage == \"Pushed\")\n    {\n      udp.send(\"Light\", ip, port );\n      fill(255);\n    }\n    else if (currentMessage == \"Released\")\n    {\n      udp.send(\"Dark\", ip, port );\n      fill(0);\n    }\n  }\n}\n```", "```cpp\n// LED stuff\nconst int ledPin =  13;      // pin of the board built-in LED\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output\n\n  Serial.begin(9600);       // start serial communication at 9600bps\n}\n\nvoid loop()\n{\n  if (Serial.available() > 0) {\n\n    incomingByte = Serial.read();\n\n    if (incomingByte == 1) digitalWrite(ledPin, HIGH);\n    else if (incomingByte == 0) digitalWrite(ledPin, LOW);\n  }\n}\n```", "```cpp\nimport processing.serial.*;\nSerial port;\n\nint bgcolor, fgcolor;\n\nvoid setup() {\n  size(700, 700);\n  background(0);\n  stroke(255);\n  bgcolor = 0;\n  fgcolor = 255;\n\n  println(Serial.list()); \n  port = new Serial(this, Serial.list()[2], 9600);\n\n}\nvoid draw() {\n  background(bgcolor);\n  stroke(fgcolor);\n  fill(fgcolor);\n  rect(100, 100, 500, 500);\n}\n\nvoid mousePressed() {\n  if (mouseX > 100 && mouseX < 600 && mouseY > 100 && mouseY < 600)\n  {\n      bgcolor = 255;\n      fgcolor = 0;\n      port.write('1');\n  }\n}\n\nvoid mouseReleased() {\n\n      bgcolor = 0;\n      fgcolor = 255;\n      port.write('0');\n}\n```", "```cpp\nport = new Serial(this, Serial.list()[2], 9600);\n```", "```cpp\n#include <WiFi.h>\n\nchar ssid[] = \"yourNetwork\";     // the name of your network\nint status = WL_IDLE_STATUS;     // the Wifi radio's status\n\nvoid setup() {\n  //Initialize serial and wait for port to open:\n  Serial.begin(9600); \n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\"); \n    // don't continue:\n    while(true)\ndelay(30) ;\n  } \n\n  // attempt to connect to Wifi network:\n  while ( status != WL_CONNECTED) { \n    Serial.print(\"Attempting to connect to open SSID: \");\n    Serial.println(ssid);\n    status = WiFi.begin(ssid);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  }\n\n  // you're connected now, so print out the data:\n  Serial.print(\"You're connected to the network\");\n  printCurrentNet();\n  printWifiData();\n}\n\nvoid loop() {\n  // check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();\n}\n\nvoid printWifiData() {\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];  \n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  Serial.print(mac[5],HEX);\n  Serial.print(\":\");\n  Serial.print(mac[4],HEX);\n  Serial.print(\":\");\n  Serial.print(mac[3],HEX);\n  Serial.print(\":\");\n  Serial.print(mac[2],HEX);\n  Serial.print(\":\");\n  Serial.print(mac[1],HEX);\n  Serial.print(\":\");\n  Serial.println(mac[0],HEX);\n\n  // print your subnet mask:\n  IPAddress subnet = WiFi.subnetMask();\n  Serial.print(\"NetMask: \");\n  Serial.println(subnet);\n\n  // print your gateway address:\n  IPAddress gateway = WiFi.gatewayIP();\n  Serial.print(\"Gateway: \");\n  Serial.println(gateway);\n}\n\nvoid printCurrentNet() {\n  // print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);    \n  Serial.print(\"BSSID: \");\n  Serial.print(bssid[5],HEX);\n  Serial.print(\":\");\n  Serial.print(bssid[4],HEX);\n  Serial.print(\":\");\n  Serial.print(bssid[3],HEX);\n  Serial.print(\":\");\n  Serial.print(bssid[2],HEX);\n  Serial.print(\":\");\n  Serial.print(bssid[1],HEX);\n  Serial.print(\":\");\n  Serial.println(bssid[0],HEX);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption,HEX);\n}\n```", "```cpp\n#include <WiFi.h>\n\nchar ssid[] = \"yourNetwork\";      //  your network SSID (name) \nchar pass[] = \"secretPassword\";   // your network password\nint keyIndex = 0;                 // your network key Index number (needed only for WEP)\n\nint status = WL_IDLE_STATUS;\n\nWiFiServer server(80);\n\nvoid setup() {\n  //Initialize serial and wait for port to open:\n  Serial.begin(9600); \n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for Leonardo only\n  }\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\"); \n    // don't continue:\n    while(true);\n  } \n\n  // attempt to connect to Wifi network:\n  while ( status != WL_CONNECTED) { \n    Serial.print(\"Attempting to connect to SSID: \");\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:    \n    status = WiFi.begin(ssid, pass);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  } \n  server.begin();\n  // you're connected now, so print out the status:\n  printWifiStatus();\n}\n\nvoid loop() {\n  // listen for incoming clients\n  WiFiClient client = server.available();\n  if (client) {\n    Serial.println(\"new client\");\n    // an http request ends with a blank line\n    boolean currentLineIsBlank = true;\n    while (client.connected()) {\n      if (client.available()) {\n        char c = client.read();\n        Serial.write(c);\n        // if you've gotten to the end of the line (received a newline\n        // character) and the line is blank, the http request has ended,\n        // so you can send a reply\n        if (c == '\\n' && currentLineIsBlank) {\n          // send a standard http response header\n          client.println(\"HTTP/1.1 200 OK\");\n          client.println(\"Content-Type: text/html\");\n          client.println(\"Connnection: close\");\n          client.println();\n          client.println(\"<!DOCTYPE HTML>\");\n          client.println(\"<html>\");\n          // add a meta refresh tag, so the browser pulls again every 5 seconds:\n          client.println(\"<meta http-equiv=\\\"refresh\\\" content=\\\"5\\\">\");\n          // output the value of each analog input pin\n          for (int analogChannel = 0; analogChannel < 6; analogChannel++) {\n            int sensorReading = analogRead(analogChannel);\n            client.print(\"analog input \");\n            client.print(analogChannel);\n            client.print(\" is \");\n            client.print(sensorReading);\n            client.println(\"<br />\");       \n          }\n          client.println(\"</html>\");\n           break;\n        }\n        if (c == '\\n') {\n          // you're starting a new line\n          currentLineIsBlank = true;\n        } \n        else if (c != '\\r') {\n          // you've gotten a character on the current line\n          currentLineIsBlank = false;\n        }\n      }\n    }\n    // give the web browser time to receive the data\n    delay(1);\n      // close the connection:\n      client.stop();\n      Serial.println(\"client disonnected\");\n  }\n}\n\nvoid printWifiStatus() {\n  // print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");\n}\n```", "```cpp\n#include <SPI.h>\n#include <Ethernet.h>\n#include <sha1.h>\n#include <Time.h>\n#include <EEPROM.h>\n#include <Twitter.h>\n\n// Switch \nconst int switchPin = 2;     \nint switchState = 0;        \nint lastSwitchState = LOW;\nlong lastDebounceTime = 0;\nlong debounceDelay = 50;\n\n// Local network configuration\nuint8_t mac[6] =     {\n  0xc4, 0x2c, 0x03, 0x0a, 0x3b, 0xb5};    // USE YOUR MAC ADDRESS\nIPAddress ip(192, 168, 1, 43);            // USE IP ON YOUR NETWORK\nIPAddress gateway(192, 168, 1, 1);        // USE YOUR GATWEWAY IP ADDRESS\nIPAddress subnet(255, 255, 255, 0);       // USE YOUR SUBNET MASK\n\n// IP address to Twitter\nIPAddress twitter_ip(199, 59, 149, 232);\nuint16_t twitter_port = 80;\n\nunsigned long last_tweet = 0;\n#define TWEET_DELTA (60L * 60L)\n\n// Store the credentials\nconst static char consumer_key[] PROGMEM = \"xxxxxxxxxxxxx\";\nconst static char consumer_secret[] PROGMEM\n= \"yyyyyyyyyyyyy\";\n\n#DEFINE ALREADY_TOKENS 0 ; // Change it at 1 when you put your tokens\n\nchar buffer[512];\nTwitter twitter(buffer, sizeof(buffer));\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Arduino Twitter demo\");\n\n  // the switch pin is setup as an input\n  pinMode(switchPin, INPUT); \n\n  // start the network connection\n  Ethernet.begin(mac, ip, dns, gateway, subnet);\n\n  // define twitter entry point\n  twitter.set_twitter_endpoint(PSTR(\"api.twitter.com\"),\n  PSTR(\"/1/statuses/update.json\"),\n  twitter_ip, twitter_port, false);\n  twitter.set_client_id(consumer_key, consumer_secret);\n\n  // Store or read credentials in EEPROM part of the board\n#if ALREADY_TOKENS\n  /* Read OAuth account identification from EEPROM. */\n  twitter.set_account_id(256, 384);\n#else\n  /* Set OAuth account identification from program memory. */\n  twitter.set_account_id(PSTR(\"*** set account access token here ***\"),\n  PSTR(\"*** set account token secret here ***\"));\n#endif\n\n  delay(500);\n}\n\nvoid loop() {\n  if (twitter.is_ready()) // if the twitter connection is okay\n  {\n    unsigned long now = twitter.get_time();\n    if (last_tweet == 0) last_tweet = now - TWEET_DELTA + 15L;\n\n    // read the state of the digital pin\n    int readInput = digitalRead(switchPin);\n    if (readInput != lastSwitchState)\n    {\n      lastDebounceTime = millis(); \n    }\n\n    if ( (millis() - lastDebounceTime) > debounceDelay )\n    { \n      switchState = readInput; \n    }\n\n    lastSwitchState = readInput;\n    if (switchState == HIGH)  // if you push the button\n    {\n      if (now > last_tweet + TWEET_DELTA) // if you didn't tweet for a while\n      {\n\n        char msg[32];\n        sprintf(msg, \"Tweeting from #arduino by pushing a button is cool, thanks to @julienbayle\");\n\n        // feedback to serial monitor\n        Serial.print(\"Posting to Twitter: \");\n        Serial.println(msg);\n\n        last_tweet = now;\n\n        if (twitter.post_status(msg))\n          Serial.println(\"Status updated\");\n        else\n          Serial.println(\"Update failed\");\n      }\n      else Serial.println(\"Wait a bit before pushing it again!\");\n    }\n  }\n  delay(5000); // waiting a bit, just in case\n}\n```"]