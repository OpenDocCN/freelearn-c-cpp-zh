["```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Timeline.h\"\n#include \"cinder/Rand.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    Anim<Color> mBackgroundColor;\n    Anim<Vec2f> mCenter;\n    Anim<float> mRadius;\n    ```", "```cpp\n    mBackgroundColor = Color( CM_HSV, randFloat(), 1.0f, 1.0f );\n    mCenter = getWindowCenter();\n    mRadius = randFloat( 20.0f, 100.0f );\n    ```", "```cpp\n    gl::clear( mBackgroundColor.value() ); \n    gl::drawSolidCircle( mCenter.value(), mRadius.value() );\n    ```", "```cpp\n    void mouseDown( MouseEvent event );  \n    ```", "```cpp\n    Color backgroundColor( CM_HSV, randFloat(), 1.0f, 1.0f );\n    timeline().apply( &mBackgroundColor, backgroundColor, 2.0f, EaseInCubic() );\n    timeline().apply( &mCenter, (Vec2f)event.getPos(), 1.0f, EaseInCirc() );\n    timeline().apply( &mRadius, randFloat( 20.0f, 100.0f ), 1.0f, EaseInQuad() );\n    ```", "```cpp\ntimeline().apply( &mRadius, 10.0f, 100.0f 1.0f, EaseInQuad() );\n```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Timeline.h\"\n#include \"cinder/Rand.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    Anim<float> mRadius;\n    Anim<Color> mColor;\n    Vec2f mPos;\n    ```", "```cpp\n    mPos = (Vec2f)getWindowCenter();\n    mRadius = 30.0f;\n    mColor = Color( CM_HSV, randFloat(), 1.0f, 1.0f );\n    ```", "```cpp\n    gl::clear( Color::black() ); \n    gl::color( mColor.value() );\n    gl::drawSolidCircle( mPos, mRadius.value() );\n    ```", "```cpp\n      void mouseDown( MouseEvent event );\n    ```", "```cpp\n    timeline().apply( &mRadius, 30.0f, 200.0f, 2.0f, EaseInOutCubic() );\n    timeline().appendTo( &mRadius, 200.0f, 30.0f, 1.0f, EaseInOutCubic() );\n    ```", "```cpp\n        Color targetColor = Color( CM_HSV, randFloat(), 1.0f, 1.0f );\n    timeline().apply( &mColor, targetColor, 1.0f, EaseInQuad() ).appendTo( &mRadius );\n    ```", "```cpp\ntimeline().appendTo( &mRadius, 200.0f, 30.0f, 1.0f, EaseInOutCubic() );\n```", "```cpp\ntimeline().apply( &mColor, targetColor, 1.0f, EaseInQuad() ).appendTo( &mRadius );\n```", "```cpp\ntimeline().apply( &mColor, targetColor, 1.0f, EaseInQuad() ).appendTo( &mRadius, -0.5f );\n```", "```cpp\n    #include \"cinder/Rand.h\"\n    #include \"cinder/MayaCamUI.h\"\n    #include \"cinder/BSpline.h\"\n    ```", "```cpp\n    Vec3f       mObjPosition;\n    BSpline3f   spline;\n    ```", "```cpp\n    mObjPosition = Vec3f::zero();\n\n    vector<Vec3f> splinePoints;\n    float step = 0.5f;\n    float width = 20.f;\n    for (float t = 0.f; t < width; t += step) {\n     Vec3f pos = Vec3f(\n      cos(t)*randFloat(0.f,2.f),\n      sin(t)*0.3f,\n      t - width*0.5f);\n     splinePoints.push_back( pos );\n    }\n    spline = BSpline3f( splinePoints, 3, false, false );\n    ```", "```cpp\n    float dist = math<float>::abs(sin( getElapsedSeconds()*0.2f ));\n    mObjPosition = spline.getPosition( dist );\n    ```", "```cpp\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    gl::enableAlphaBlending();\n    gl::clear( Color::white() );\n    gl::setViewport(getWindowBounds());\n    gl::setMatrices(mMayaCam.getCamera());\n\n    // draw dashed line\n    gl::color( ColorA(0.f, 0.f, 0.f, 0.8f) );\n    float step = 0.005f;\n    glBegin(GL_LINES);\n    for (float t = 0.f; t <= 1.f; t += step) {\n      gl::vertex(spline.getPosition(t));\n    }\n    glEnd();\n\n    // draw object\n    gl::color(Color(1.f,0.f,0.f));\n    gl::drawSphere(mObjPosition, 0.25f);\n    ```", "```cpp\n    #include \"cinder/Rand.h\"\n    #include \"cinder/MayaCamUI.h\"\n    #include \"cinder/BSpline.h\"\n    ```", "```cpp\n    MayaCamUI mMayaCam;\n    BSpline3f   spline;\n    CameraPersp mMovingCam;\n    Vec3f       mCamPosition;\n    vector<Rectf> mBoxes;\n    ```", "```cpp\n    setWindowSize(640*2, 480);\n    mCamPosition = Vec3f::zero();\n\n    CameraPersp  mSceneCam;\n    mSceneCam.setPerspective(45.0f, 640.f/480.f, 0.1, 10000);\n    mSceneCam.setEyePoint(Vec3f(7.f,7.f,7.f));\n    mSceneCam.setCenterOfInterestPoint(Vec3f::zero());\n    mMayaCam.setCurrentCam(mSceneCam);\n\n    mMovingCam.setPerspective(45.0f, 640.f/480.f, 0.1, 100.f);\n    mMovingCam.setCenterOfInterestPoint(Vec3f::zero());\n\n    vector<Vec3f> splinePoints;\n    float step = 0.5f;\n    float width = 20.f;\n    for (float t = 0.f; t < width; t += step) {\n     Vec3f pos = Vec3f( cos(t)*randFloat(0.8f,1.2f),\n      0.5f+sin(t*0.5f)*0.5f,\n      t - width*0.5f);\n     splinePoints.push_back( pos );\n    }\n    spline = BSpline3f( splinePoints, 3, false, false );\n\n    for(int i = 0; i<100; i++) {\n     Vec2f pos = Vec2f(randFloat(-10.f,10.f), \n      randFloat(-10.f,10.f));\n     float size = randFloat(0.1f,0.5f);\n     mBoxes.push_back(Rectf(pos, pos+Vec2f(size,size*3.f)));\n    }\n    ```", "```cpp\n    float step = 0.001f;\n    float pos = abs(sin( getElapsedSeconds()*0.05f ));\n    pos = min(0.99f, pos);\n    mCamPosition = spline.getPosition( pos );\n\n    mMovingCam.setEyePoint(mCamPosition);\n    mMovingCam.lookAt(spline.getPosition( pos+step ));\n    ```", "```cpp\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    gl::enableAlphaBlending();\n    gl::clear( Color::white() );\n    gl::setViewport(getWindowBounds());\n    gl::setMatricesWindow(getWindowSize());\n\n    gl::color(ColorA(0.f,0.f,0.f, 1.f));\n    gl::drawLine(Vec2f(640.f,0.f), Vec2f(640.f,480.f));\n\n    gl::pushMatrices();\n    gl::setViewport(Area(0,0, 640,480));\n    gl::setMatrices(mMayaCam.getCamera());\n\n    drawScene();\n\n    // draw dashed line\n    gl::color( ColorA(0.f, 0.f, 0.f, 0.8f) );\n    float step = 0.005f;\n    glBegin(GL_LINES);\n    for (float t = 0.f; t <= 1.f; t += step) {\n      gl::vertex(spline.getPosition(t));\n    }\n    glEnd();\n\n    // draw object\n    gl::color(Color(0.f,0.f,1.f));\n    gl::drawFrustum(mMovingCam);\n\n    gl::popMatrices();\n\n    // -------------\n\n    gl::pushMatrices();\n    gl::setViewport(Area(640,0, 640*2,480));\n    gl::setMatrices(mMovingCam);\n    drawScene();\n    gl::popMatrices();\n    ```", "```cpp\n    GLfloat light0_position[] = { 1000.f, 500.f, -500.f, 0.1f };\n    GLfloat light1_position[] = { -1000.f, 100.f, 500.f, 0.1f };\n    GLfloat light1_color[] = { 1.f, 1.f, 1.f };\n\n    glLightfv( GL_LIGHT0, GL_POSITION, light0_position );\n    glLightfv( GL_LIGHT1, GL_POSITION, light1_position );\n    glLightfv( GL_LIGHT1, GL_DIFFUSE, light1_color );\n\n    glEnable( GL_LIGHTING );\n    glEnable( GL_LIGHT0 );\n    glEnable( GL_LIGHT1 );\n\n    ci::ColorA diffuseColor(0.9f, 0.2f, 0.f );\n    gl::color(diffuseColor);\n    glMaterialfv( GL_FRONT, GL_DIFFUSE,  diffuseColor );\n\n    vector<Rectf>::iterator it;\n    for(it = mBoxes.begin(); it != mBoxes.end(); ++it) {\n     gl::pushMatrices();\n     gl::translate(0.f, it->getHeight()*0.5f, 0.f);\n     Vec2f center = it->getCenter();\n     gl::drawCube(Vec3f(center.x, 0.f, center.y), \n      Vec3f(it->getWidth(),\n     it->getHeight(), it->getWidth()));\n     gl::popMatrices();\n    }\n\n    glDisable( GL_LIGHTING );\n    glDisable( GL_LIGHT0 );\n    glDisable( GL_LIGHT1 );\n\n    // draw grid\n    drawGrid(50.0f, 2.0f);\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Text.h\"\n    #include \"cinder/Font.h\"\n    #include \"cinder/qtime/QuickTime.h\"\n    #include \"cinder/gl/GlslProg.h\"\n    ```", "```cpp\n    qtime::MovieGl mMovie;\n    gl::Texture     mFrameTexture, mTextTexture;\n    gl::GlslProg  mMaskingShader;\n    ```", "```cpp\n    setWindowSize(854, 480);\n\n    TextLayout layout;\n    layout.clear( ColorA(0.f,0.f,0.f, 0.f) );\n    layout.setFont( Font(\"Arial Black\", 96 ) );\n    layout.setColor( Color( 1, 1, 1 ) );\n    layout.addLine( \"SPACE\" );\n    Surface8u rendered = layout.render( true );\n\n    gl::Texture::Format format;\n    format.setTargetRect();\n    mTextTexture = gl::Texture( rendered, format );\n\n    try {\n      mMovie = qtime::MovieGl( getAssetPath(\"video.mov\") );\n      mMovie.setLoop();\n      mMovie.play();\n    } catch( ... ) {\n      console() <<\"Unable to load the movie.\"<<endl;\n      mMovie.reset();\n    }\n\n    mMaskingShader = gl::GlslProg( loadAsset(\"passThru_vert.glsl\"), loadAsset(\"masking_frag.glsl\") );\n    ```", "```cpp\n    if( mMovie ) mFrameTexture = mMovie.getTexture();\n    ```", "```cpp\n    gl::enableAlphaBlending();\n    gl::clear( Color::gray(0.05f) );\n    gl::setViewport(getWindowBounds());\n    gl::setMatricesWindow(getWindowSize());\n\n    gl::color(ColorA::white());\n    if(mFrameTexture) {\n     Vec2f maskOffset = (mFrameTexture.getSize() \n      - mTextTexture.getSize() ) * 0.5f;\n     mFrameTexture.bind(0);\n     mTextTexture.bind(1);\n     mMaskingShader.bind();\n     mMaskingShader.uniform(\"sourceTexture\", 0);\n     mMaskingShader.uniform(\"maskTexture\", 1);\n     mMaskingShader.uniform(\"maskOffset\", maskOffset);\n     gl::pushMatrices();\n     gl::translate(getWindowCenter()-mTextTexture.getSize()*0.5f);\n     gl::drawSolidRect( mTextTexture.getBounds(), true );\n     gl::popMatrices();\n     mMaskingShader.unbind();\n    }\n    ```", "```cpp\n    #extension GL_ARB_texture_rectangle : require\n\n    uniform sampler2DRect sourceTexture;\n    uniform sampler2DRect maskTexture;\n    uniform vec2 maskOffset;\n\n    void main() \n    { \n      vec2 texCoord = gl_TexCoord[0].st;  \n\n      vec4 sourceColor = texture2DRect( sourceTexture, texCoord+maskOffset );   \n      vec4 maskColor = texture2DRect( maskTexture, texCoord ); \n\n      vec4 color = sourceColor * maskColor;\n\n      gl_FragColor = color;\n    }\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Text.h\"\n    #include \"cinder/Font.h\"\n    #include \"cinder/Utilities.h\"\n    ```", "```cpp\n    vector<gl::Texture> mTextTextures;\n    Vec2f   mTextSize;\n    ```", "```cpp\n    setWindowSize(854, 480);\n    string font( \"Times New Roman\" );\n\n    mTextSize = Vec2f::zero();\n    į\n    for(int i = 0; i<5; i++) {\n       TextLayout layout;\n       layout.clear( ColorA(0.f,0.f,0.f, 0.f) );\n       layout.setFont( Font( font, 48 ) );\n       layout.setColor( Color( 1, 1, 1 ) );\n       layout.addLine( \"Animating text \" + toString(i) );\n       Surface8u rendered = layout.render( true );\n       gl::TexturetextTexture = gl::Texture( rendered );\n       textTexture.setMagFilter(GL_NICEST);\n       textTexture.setMinFilter(GL_NICEST);\n       mTextTextures.push_back(textTexture);\n       mTextSize.x = math<float>::max(mTextSize.x, \n        textTexture.getWidth());\n       mTextSize.y = math<float>::max(mTextSize.y, \n        textTexture.getHeight());\n    }\n    ```", "```cpp\n    gl::enableAlphaBlending();\n    gl::clear( Color::black() );\n    gl::setViewport(getWindowBounds());\n    gl::setMatricesWindowPersp(getWindowSize());\n\n    gl::color(ColorA::white());\n\n    float time = getElapsedSeconds()*0.5f;\n    float timeFloor = math<float>::floor( time );\n    inttexIdx = 1 + ( (int)timeFloor % (mTextTextures.size()-1) );\n    float step = time - timeFloor;\n\n    gl::pushMatrices();\n    gl::translate(getWindowCenter() - mTextSize*0.5f);\n\n    float radius = 30.f;\n    gl::color(ColorA(1.f,1.f,1.f, 1.f-step));\n    gl::pushMatrices();\n    gl::rotate( Vec3f(90.f*step,0.f,0.f) );\n    gl::translate(0.f,0.f,radius);\n    gl::draw(mTextTextures[texIdx-1], Vec2f(0.f, -mTextTextures[texIdx-1].getHeight()*0.5f) );\n    gl::popMatrices();\n\n    gl::color(ColorA(1.f,1.f,1.f, step));\n    gl::pushMatrices();\n    gl::rotate( Vec3f(-90.f + 90.f*step,0.f,0.f) );\n    gl::translate(0.f,0.f,radius);\n    gl::draw(mTextTextures[texIdx], Vec2f(0.f, -mTextTextures[texIdx].getHeight()*0.5f) );\n    gl::popMatrices();\n\n    gl::popMatrices();\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Perlin.h\"\n#include \"cinder/Rand.h\"\n#include \"cinder/CinderMath.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    class Follower{\n    public:\n     Follower( const Vec2f& pos ){\n      this->pos = pos;\n     }\n     void update( const Vec2f& newVel ){\n      vel += ( newVel - vel ) * 0.2f;\n      pos += vel;\n      if( pos.x < 0.0f ){\n       pos.x = (float)getWindowWidth();\n       vel = Vec2f();\n      }\n      if( pos.x > (float)getWindowWidth() ){\n       pos.x = 0.0f;\n       vel = Vec2f();\n      }\n      if( pos.y < 0.0f ){\n       pos.y = (float)getWindowHeight();\n       vel = Vec2f();\n      }\n      if( pos.y > (float)getWindowHeight() ){\n       pos.y = 0.0f;\n       vel = Vec2f();\n      } \n     }\n     void draw(){\n      gl::drawSolidCircle( pos, 5.0f );\n      gl::drawLine( pos, pos + ( vel * 20.0f ) );\n     }\n     Vec2f pos, vel;\n    };\n    ```", "```cpp\n    vector< vector< Vec2f> > mFlowField;\n    Vec2f mGap;\n    float mCounter;\n    int mRows, mColumns;\n    ```", "```cpp\n    mRows = 40;\n    mColumns = 40;\n    mGap.x = (float)getWindowWidth() / (mRows-1);\n    mGap.y = (float)getWindowHeight() / (mColumns-1);\n    ```", "```cpp\n    mFlowField.resize( mRows );\n    for( int i=0; i<mRows; i++ ){\n      mFlowField[i].resize( mColumns );\n    ```", "```cpp\n      Perlin mPerlin;\n    float mCounter;\n    ```", "```cpp\n      mCounter = 0.0f;\n    }\n    ```", "```cpp\n    for( int i=0; i<mRows; i++ ){\n     for( int j=0; j<mColumns; j++ ){\n      float angle= mPerlin.noise( ((float)i)*0.01f + mCounter,\n       ((float)j)*0.01f ) * M_PI * 2.0f;\n      mFlowField[i][j].x = cosf( angle );\n      mFlowField[i][j].y = sinf( angle );\n     } \n    }\n    ```", "```cpp\n    for( int i=0 i<mRows; i++ ){\n     for( int j=0; j<mColumns; j++ ){\n      float x = (float)i*mGap.x;\n      float y = (float)j*mGap.y;\n      Vec2f begin( x, y );\n      Vec2f end = begin + ( mFlowField[i][j] * 10.0f );\n      gl::drawLine( begin, end );\n     }\n    }\n    ```", "```cpp\n    vector<shared_ptr<Follower>> mFollowers;\n    ```", "```cpp\n    int numFollowers = 50;\n    for( int i=0; i<numFollowers; i++ ){\n     Vec2f pos( randFloat( getWindowWidth() ), \n      randFloat(getWindowHeight() ) );\n     mFollowers.push_back( \n      shared_ptr<Follower>( new Follower( pos ) ) );\n    }\n    ```", "```cpp\n    for( vector<shared_ptr<Follower> >::iterator it = \n     mFollowers.begin(); it != mFollowers.end(); ++it ){\n     shared_ptr<Follower> follower = *it;\n     int indexX= ci::math<int>::clamp(follower->pos.x / mGap.x,0,\n      mRows-1 );\n     int indexY= ci::math<int>::clamp(follower->pos.y / mGap.y,0, \n      mColumns-1 );\n     Vec2f flow = mFlowField[ indexX ][ indexY ];\n     follower->update( flow );\n    }\n    ```", "```cpp\n    for( vector< shared_ptr<Follower> >::iterator it = \n     mFollowers.begin(); it != mFollowers.end(); ++it ){\n     (*it)->draw();\n    }\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/gl/Texture.h\"\n#include \"cinder/Timeline.h\"\n#include \"cinder/ImageIo.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    class Image{\n    public:\n    Image( gl::Texture texture, constRectf& maxRect ){\n     this->texture = texture;\n     distance = 0.0f;\n     angle = 0.0f;\n     Vec2f size = Vec2f(texture.getWidth(), texture.getHeight());\n     rect = Rectf(-size * 0.5f, size*0.5f).getCenteredFit( \n      maxRect, true );\n    }\n    void draw(){\n     gl::pushMatrices();\n     glRotatef( angle, 0.0f, 1.0f, 0.0f );\n     gl::translate( 0.0f, 0.0f, distance );\n     gl::draw( texture, rect );\n     gl::popMatrices();\n    }\n    gl::Texture texture;\n    float distance;\n    float angle;\n    Rectfrect;\n    }\n    ```", "```cpp\n    vector<shared_ptr<Image>> mImages;\n    int mSelectedImageIndex;\n    Anim<float> mRotationOffset;\n    ```", "```cpp\n    fs::path imageFolder = getFolderPath( \"\" );\n    if( imageFolder.empty() == false ){\n     for( fs::directory_iterator it( imageFolder ); it !=\n      fs::directory_iterator(); ++it ){\n      const fs::path& file = it->path();\n      gl::Texture texture;\n      try {\n       texture = loadImage( file );\n      } catch ( ... ) { }\n      if( texture ){\n       Rectf maxRect(RectfmaxRect( Vec2f( -50.0f, -50.0f),\n        Vec2f( 50.0f,50.0f ) );\n       mImages.push_back( shared_ptr<Image>( \n        new Image( texture, maxRect) ) );\n      } \n     }\n    }\n    ```", "```cpp\n    float angle = 0.0f;\n    float angleAdd = 360.0f / mImages.size();\n    float radius = 300.0f;\n    for( int i=0; i<mImages.size(); i++ ){\n     mImages[i]->angle = angle;\n     mImages[i]->distance = radius;\n     angle += angleAdd;\n    }\n    ```", "```cpp\n    mSelectedImageIndex = 0;\n    mRotationOffset = 0.0f;\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    if( mImages.size() ){\n     Vec2f center = (Vec2f)getWindowCenter();\n     gl::pushMatrices();\n     gl::translate( center.x, center.y, 0.0f );\n     glRotatef( mRotationOffset, 0.0f, 1.0f, 0.0f );\n     for(vector<shared_ptr<Image> >::iterator it=mImages.begin();\n      it != mImages.end(); ++it ){\n      (*it)->draw();\n     }\n     gl::popMatrices();\n    }\n    ```", "```cpp\n    void keyUp( KeyEvent event );\n    ```", "```cpp\n    bool imageChanged = false;\n    if( event.getCode() == KeyEvent::KEY_LEFT ){\n     mSelectedImageIndex--;\n     if( mSelectedImageIndex< 0 ){\n      mSelectedImageIndex = mImages.size()-1;\n      mRotationOffset.value() += 360.0f;\n     }\n     imageChanged = true;\n    } else if( event.getCode() == KeyEvent::KEY_RIGHT ){\n     mSelectedImageIndex++;\n     if( mSelectedImageIndex>mImages.size()-1 ){\n      mSelectedImageIndex = 0;\n      mRotationOffset.value() -= 360.0f;\n     }\n     imageChanged = true;\n    }\n    if( imageChanged ){\n     timeline().apply( &mRotationOffset, \n      mImages[ mSelectedImageIndex]->angle, 1.0f, \n      EaseOutElastic() );\n    }\n    ```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/Perlin.h\"\n#include \"cinder/Rand.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    class Follower{\n    public:\n    Follower(){\n     theta = 0.0f;\n     phi = 0.0f;\n    }\n    void moveTo( const Vec3f& target ){\n     prevPos = pos;\n     pos += ( target - pos ) * 0.1f;\n    }\n    void draw(){\n     gl::drawSphere( pos, 10.0f, 20 );\n     Vec3f vel = pos - prevPos;\n     gl::drawLine( pos, pos + ( vel * 5.0f ) );\n    }\n    Vec3f pos, prevPos;\n    float phi, theta;\n    };\n    ```", "```cpp\n    Vec3f sphericalToCartesians(sphericalToCartesians( float radius, float theta, float phi );\n    ```", "```cpp\n    float x = radius * sinf( theta ) * cosf( phi );\n    float y = radius * sinf( theta ) * sinf( phi );\n    float z = radius * cosf( theta );\n    return Vec3f( x, y, z );\n    ```", "```cpp\n    vector<shared_ptr< Follower > > mFollowers;\n    float mRadius;\n    float mCounter;\n    Perlin mPerlin;\n    ```", "```cpp\n    mRadius = 200.0f;\n    mCounter = 0.0f;\n    ```", "```cpp\n    int numFollowers = 100;\n    for( int i=0; i<numFollowers; i++ ){\n     shared_ptr<Follower> follower( new Follower() );\n     follower->theta = randFloat( M_PI * 2.0f );\n     follower->phi = randFloat( M_PI * 2.0f );\n     follower->pos = sphericalToCartesian( mRadius, \n      follower->theta, follower->phi );\n     mFollowers.push_back( follower );\n    }\n    ```", "```cpp\n    mCounter += 0.01f;\n    ```", "```cpp\n    float resolution = 0.01f;\n    for( int i=0; i<mFollowers.size(); i++ ){\n     shared_ptr<Follower> follower = mFollowers[i];\n     Vec3f pos = follower->pos;\n     float thetaAdd = mPerlin.noise( pos.x * resolution, \n      pos.y * resolution, mCounter ) * 0.1f;\n     float phiAdd = mPerlin.noise( pos.y * resolution, \n      pos.z * resolution, mCounter ) * 0.1f;\n     follower->theta += thetaAdd;\n     follower->phi += phiAdd;\n     Vec3f targetPos = sphericalToCartesian( mRadius, \n      follower->theta, follower->phi );\n     follower->moveTo( targetPos );\n    }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n    ```", "```cpp\n    gl::pushMatrices();\n    Vec2f center = getWindowCenter();\n    gl::translate( center );\n    gl::color( Color( 0.2f, 0.2f, 0.2f ) );\n    for(vector<shared_ptr<Follower> >::iterator it = \n     mFollowers.begin(); it != mFollowers.end(); ++it ){\n     (*it)->draw();\n    }\n    gl::color( Color::white() );\n    gl::drawSphere( Vec3f(), mRadius, 100 );\n    gl::popMatrices();\n    ```"]