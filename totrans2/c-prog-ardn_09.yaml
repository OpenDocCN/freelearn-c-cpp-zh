- en: Chapter 9. Making Things Move and Creating Sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the Arduino board can listen and feel with sensors, it can also react by
    making things move.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the movement concept, I mean both of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Object movements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Air movements producing sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to learn how we can control small motors named **servo**, and how
    we can deal with high-current control by using transistors.
  prefs: []
  type: TYPE_NORMAL
- en: Then we'll start talking about the basics of sound generation. This is a requirement
    before trying to produce any sounds, even the simplest ones. This is the part
    where we'll describe analog and digital concepts.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we'll design a very basic random synthesizer controllable using MIDI.
    We'll also introduce a very nice library called **PCM** that provides a simple
    way to add sample playing features to your 8-bit microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Making things vibrate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest projects we can introduce here is the use of a small piezoelectric
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first basic tangible action we design here. Of course, we already
    designed many of the visual feedback, but this is our first real-world object
    that moves the firmware.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of feedback can be very useful in nonvisual contexts. I designed a
    small project for a person who wanted to send a feedback to visitors in his reactive
    installation. The visitor had to put on a t-shirt that included some electronics
    attached, such as a LilyPad and some piezoelectric sensors. The LED feedback wasn't
    the solution we used before to send feedback to the wearer, and we decided to
    send a vibration. These piezoelectric sensors were distributed on each side of
    the t-shirt to produce different feedback in response to different interactions.
  prefs: []
  type: TYPE_NORMAL
- en: But wouldn't I have made a mistake talking about sensors vibrating?
  prefs: []
  type: TYPE_NORMAL
- en: The piezoelectric sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A piezoelectric sensor is a component that uses the piezoelectric effect.
  prefs: []
  type: TYPE_NORMAL
- en: This effect is defined as the linear electromechanical interaction between the
    mechanical and electrical state in some specific materials.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a mechanical action on this device generates electricity, making
    it usable for movement and vibration detection. But the nice thing here is that
    the effect is reciprocal—if you apply a current to it, it will vibrate.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we are using a piezoelectric sensor here. We are using it as a vibration
    generator.
  prefs: []
  type: TYPE_NORMAL
- en: Piezoelectric sensors are also often used as a tone generator. We will dig deeper
    into the relationship between air vibrations and sound a bit later, but it is
    important to mention it here too.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a vibration motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Piezoelectric sensors usually consume around 10 mA to 15 mA, which is very small.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you need to check the proper datasheet of the device you are going
    to use. I have had good results with the one from **Sparkfun** ([https://www.sparkfun.com/products/10293](https://www.sparkfun.com/products/10293)).
    The wiring could not be simpler—there are only two legs. The following image shows
    how the piezoelectric sensor/vibrator is wired to Arduino via a PWM-capable digital
    pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a vibration motor](img/7584_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please note that I have wired the piezoelectric device to a PWM-capable digital
    pin. I explained PWM in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the circuit schematic. This piezoelectric component is displayed as
    a small buzzer/speaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a vibration motor](img/7584_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, since we are going to use PWM, it means that we are going to simulate
    an analog output current. Considering the duty-cycle concept, we can feed the
    piezoelectric device using the `analogWrite()` function and then feed it with
    different voltages.
  prefs: []
  type: TYPE_NORMAL
- en: Firmware generating vibrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check the firmware. It is also available in the `Chapter09/vibrations/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `analogWrite()` function here again. This function takes the
    digital pin as an argument and value. This value from 0 to 255 is the duty cycle.
    It basically simulates an analog output.
  prefs: []
  type: TYPE_NORMAL
- en: We use it the usual way with the `incdec` (stands for increment-decrement) parameter.
    We store the increment value we want to use at each `loop()` execution.
  prefs: []
  type: TYPE_NORMAL
- en: This increment changes when the value reaches its boundaries, 0 or 255, and
    is inverted, providing a cheap way to make a cycle from 0 to 255, then to 0, then
    to 255, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This firmware makes the piezoelectric device vibrate cyclically from a low rate
    to a higher rate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's control bigger motors now.
  prefs: []
  type: TYPE_NORMAL
- en: Higher current driving and transistors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about transistors in the previous chapter. We used them as digital
    switches. They can also be used as amplifiers, voltage stabilizers, and many other
    related applications.
  prefs: []
  type: TYPE_NORMAL
- en: You can find transistors almost everywhere and they are quite cheap. You can
    find the complete datasheet at [http://www.fairchildsemi.com/ds/BC/BC547.pdf](http://www.fairchildsemi.com/ds/BC/BC547.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a basic diagram explaining how transistors work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Higher current driving and transistors](img/7584_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The transistor used as a digital switch in logical circuits
  prefs: []
  type: TYPE_NORMAL
- en: 'A transistor has the following legs:'
  prefs: []
  type: TYPE_NORMAL
- en: The collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The emitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we saturate the base by applying a 5 V power supply to it, all the current
    coming from the collector will be transmitted through the emitter.
  prefs: []
  type: TYPE_NORMAL
- en: When used like this, the NPN transistor is a nice way to switch on/off high
    current that Arduino wouldn't have been able to drive by itself. By the way, this
    switch is controllable with Arduino because it only requires a very small amount
    of current to be provided to the base of the transistor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sending 5 V to the transistor base closes the circuit. Putting the transistor
    base to ground opens the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, where you need to have an external power supply to drive motors,
    we use this kind of design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now learn about small current servos and then move further using transistors.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling a servo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **servomotor** is also defined as a rotary actuator that allows for very fine
    control of angular positions.
  prefs: []
  type: TYPE_NORMAL
- en: Many servos are widely available and quite cheap. I have had nice results with
    a 43 R servo, by Spring Model Electronics. You can find the datasheet at [http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf](http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Servos can drive a great amount of current. This means that you wouldn't be
    able to use more than one or two on your Arduino board without using an external
    source of power.
  prefs: []
  type: TYPE_NORMAL
- en: When do we need servos?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we need a way to control a position related to a rotation angle, we
    can use servos.
  prefs: []
  type: TYPE_NORMAL
- en: Servos can not only be used to move small parts and make objects rotate, but
    can also be used to move the object including them. Robots work in this fashion,
    and there are many Arduino-related robot projects on the Web that are very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of robots, the servo device case is fixed to a part of an arm, for
    instance, and the other part of the arm is fixed to the rotating part of the servo.
  prefs: []
  type: TYPE_NORMAL
- en: How to control servos with Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a nice library that should be used at first, named `Servo`.
  prefs: []
  type: TYPE_NORMAL
- en: This library supports up to 12 motors on most Arduino boards and 48 on the Arduino
    Mega.
  prefs: []
  type: TYPE_NORMAL
- en: By using other Arduino boards over Mega, we can figure out some software limitations.
    For instance, pins 9 and 10 cannot be used for PWM's `analogWrite()`method ([http://arduino.cc/en/Reference/analogWrite](http://arduino.cc/en/Reference/analogWrite)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Servos are provided in three-pin packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulse; that is, control pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, the power supply can be easily provided by an external battery, and
    the pulse still remains the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the basic wiring.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring one servo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram is that of a servo wired to an Arduino for both power
    supply and control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring one servo](img/7584_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding circuit diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring one servo](img/7584_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One servo and Arduino
  prefs: []
  type: TYPE_NORMAL
- en: We are basically in a very common digital output-based control pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the code now.
  prefs: []
  type: TYPE_NORMAL
- en: Firmware controlling one servo using the Servo library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a firmware that provides a cyclic movement from 0 degrees to 180 degrees.
    It is also available in the `Chapter09/OneServo/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We first include the `Servo` library header.
  prefs: []
  type: TYPE_NORMAL
- en: Then we instantiate a `Servo` object instance named `myServo`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `setup()` block, we have to make something special. We attach pin 9 to
    the `myServo` object. This explicitly defines the pin as the control pin for the
    `Servo` instance `myServo`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `loop()` block, we have two `for()` loops, and it looks like the previous
    example with the piezoelectric device. We define a cycle, progressively incrementing
    the angle variable from 0 to 180 and then decrementing it from 180 to 0, and each
    time we pause for 20 ms.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a function not used here that I want to mention, `Servo.read()`.
  prefs: []
  type: TYPE_NORMAL
- en: This function reads the current angle of the servo (that is, the value passed
    to the last call to `write()`). This can be useful if we are making some dynamic
    stuff without storing it at each turn.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple servos with external power supply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine we need three servos. As explained before, servos are motors,
    and motors convert current into movement, driving more current than other kinds
    of devices such as LEDs or sensors.
  prefs: []
  type: TYPE_NORMAL
- en: If your Arduino project requires a computer, you can supply power to it with
    the USB as long as you don't go beyond the 500 mA limit. Beyond this, you'd need
    to use an external power supply for some or all parts of your circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it goes with three servos.
  prefs: []
  type: TYPE_NORMAL
- en: Three servos and an external power supply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An external power supply can be batteries or a wall adapter power supply.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use basic AA batteries here. This is also a way to supply Arduino
    if you don't need a computer and want Arduino to be autonomous. We will consider
    this option in the third part of this book about more advanced concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the wiring for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three servos and an external power supply](img/7584_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Three servos wired to an Arduino, and power supplied by two AA batteries
  prefs: []
  type: TYPE_NORMAL
- en: In cases like this, we have to wire the grounds together. Of course, there is
    only one current source supply for the servos—the two AA batteries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the circuit diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three servos and an external power supply](img/7584_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Three servos, two AA batteries, and an Arduino
  prefs: []
  type: TYPE_NORMAL
- en: Driving three servos with firmware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of firmware for driving three servos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This very minimal firmware is also available in the `Chapter09/Servos/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We first instantiate our three servos and attach one pin for each in the `setup()`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: In `loop()`, we play with angles. As a new approach for generative creation,
    I defined one variable only for the angle. This variable cyclically goes from
    0 to 180 in each `loop()` turn.
  prefs: []
  type: TYPE_NORMAL
- en: The servo attached to pin 9 is driven with the angle value itself.
  prefs: []
  type: TYPE_NORMAL
- en: The servo attached to pin 10 is driven with the value [135-(angle/2)], varying
    itself from 135 to 45.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the servo attached to pin 11 is driven with the value [180-angle], which
    is the opposite movement of the servo attached to pin 9.
  prefs: []
  type: TYPE_NORMAL
- en: This is also an example to show you how we can easily control one variable only,
    and program variations around this variable each time; here, we are making angles
    vary and we are combining the angle variable in different expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could control the servo position by using an external parameter,
    such as a potentiometer position or distance measured. This will combine concepts
    taught here with those in [Chapter 5](ch05.html "Chapter 5. Sensing with Digital
    Inputs"), *Sensing with Digital Inputs*, and [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Sensing the World–Feeling with Analog
    Inputs*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn a bit more about step motors.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling stepper motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stepper motor** is the common name for a **step motor**. They are motors
    that are controllable using small steps.'
  prefs: []
  type: TYPE_NORMAL
- en: The full rotation is divided into a number of equal steps and the motors' positions
    can be controlled to move and hold at one of these steps easily with a high degree
    of accuracy, without any feedback mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: There are a series of electromagnetic coils that can be charged positively or
    negatively in a specific sequence. Controlling the sequence provides control about
    the movement, forward or backward in small steps.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can do that using Arduino boards.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to examine the unipolar stepper here.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a unipolar stepper to Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unipolar steppers usually consist of a center shaft part and four electromagnetic
    coils. We call them unipolar because power comes in through one pole. We can draw
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a unipolar stepper to Arduino](img/7584_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A six-pin unipolar step motor
  prefs: []
  type: TYPE_NORMAL
- en: Let's check how it can be wired to our Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: We need to supply power to the stepper from an external source. One of the best
    practices here is the use of a wall adapter. Pins 5 and 6 have to be fed a source
    of current.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to control each pin from 1 to 4 with the Arduino. This will be
    done using the sink current system ULN2004, which is very similar to ULN2003 which
    we used in the previous chapter with our LED matrix. ULN2004 is suited for voltage
    from 6 V to 15 V. When ULN2003 is 5 V, the stepper datasheet shows that we have
    to use this system instead of ULN2003.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a unipolar stepper to Arduino](img/7584_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A unipolar stepper connected to Arduino through the Darlington transistor array,
    ULN2004
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the corresponding circuit diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a unipolar stepper to Arduino](img/7584_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A circuit diagram showing Arduino, the ULN2004 Darlington transistors array,
    and the stepper
  prefs: []
  type: TYPE_NORMAL
- en: We are using an external power supply here again. All the grounds are wired
    together too.
  prefs: []
  type: TYPE_NORMAL
- en: Please notice that the **COM** pin (pin number 9) has to be wired to the power
    supply source (+V).
  prefs: []
  type: TYPE_NORMAL
- en: If you remember correctly from the previous chapter, when we fed an input of
    the ULN200x Darlington Transistor array, the corresponding output sinks the current
    to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: In our case here, each pin of Arduino connected to the ULN2004 shift register
    can commute each pin of the stepper to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Let's design firmware for stepper control.
  prefs: []
  type: TYPE_NORMAL
- en: Firmware controlling the stepper motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a very nice library that can save us from providing sequences of the
    HIGH and LOW pins, considering the movements we want to drive.
  prefs: []
  type: TYPE_NORMAL
- en: In order to control precise movements, we normally have to deal with specific
    sequences. These sequences are usually described in the datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the one available at [http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf](http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Sparkfun Electronics provides it for a model designed by Robotics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a table similar to the following one, named **Drive Sequence Model**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| STEP | A | B | C | D |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | HIGH | HIGH | LOW | LOW |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | LOW | HIGH | HIGH | LOW |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | LOW | LOW | HIGH | HIGH |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | HIGH | LOW | LOW | HIGH |'
  prefs: []
  type: TYPE_TB
- en: If you want to make a clockwise rotation, you should generate a sequence from
    1 to 4, then 1, and so on, cyclically. Counterclockwise rotations require generating
    sequences from 4 to 1 and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing a lot of sequences like these, with some function, we can
    directly use the library named `Stepper`, which is now included in Arduino Core.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the code, followed by the discussion. It is also available in the `Chapter09/StepperMotor/`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We first include the `Stepper` library.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define the number of steps that are equivalent to one whole turn. In
    our datasheet, we can see that the first step is an angle of 1.8 degrees, with
    a 5 percent error room. We won't consider that error; we will take 1.8 degrees.
    This means we need 200 steps (200 * 1.8 = 360°) in order to make a whole turn.
  prefs: []
  type: TYPE_NORMAL
- en: We then instantiate a `Stepper` object by pushing five arguments, which are
    the step numbers for a whole turn, and the four pins of the Arduino wired to the
    stepper.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare two helper variables for tracing and, sometimes, changing the
    rotation direction.
  prefs: []
  type: TYPE_NORMAL
- en: In the `setup()` block, we usually define the speed of the current instance
    handling the stepper. Here, I have set `30` (which stands for 30 rounds per minute).
    This can also be changed in the `loop()` block, considering specific conditions
    or whatever.
  prefs: []
  type: TYPE_NORMAL
- en: At last, in the `loop()` block, we move the stepper to an amount equal to the
    multiplier value, which is initially `1`. This means that at each run of the `loop()`
    method, the stepper rotates from step 1 (that is, 1.8 degrees) in the clockwise
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: I added a logic test, which checks each time if the counter has completed the
    number of steps required to make a whole turn. If it hasn't, I increment it; otherwise,
    as soon as it reaches the limit (that is, the motor makes a whole turn since the
    beginning of the program execution), I reset the counter and invert the multiplier
    in order to make the stepper continue its walk, but in the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: This is another pattern that you should keep in mind. These are all small patterns
    that will give you a lot of cheap and efficient ideas to use in each one of your
    future projects.
  prefs: []
  type: TYPE_NORMAL
- en: With servos and steppers, we can now make things move.
  prefs: []
  type: TYPE_NORMAL
- en: In some of my projects, I used two steppers, with one string bound to each and
    both these strings bound to a hanging pencil. We can draw on a wall by controlling
    the amount of string hanging on each side.
  prefs: []
  type: TYPE_NORMAL
- en: Air movement and sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making the air move can generate nice audible sounds, and we are going learn
    a bit more about this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: If you can make things move with Arduino, you will probably be able to make
    the air move too.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we have already done this, but we probably didn't move it enough to
    produce a sound.
  prefs: []
  type: TYPE_NORMAL
- en: This part is just a short introduction to some definitions and not a complete
    course about sound synthesis. These are the basic elements that we will use in
    the next few sections of the book, and as far as possible there will be references
    of websites or books provided that you can refer to if you are interested in learning
    more about those specific parts.
  prefs: []
  type: TYPE_NORMAL
- en: What is sound actually?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sound can be defined as a mechanical wave. This wave is an oscillation of pressure
    and can be transmitted through solid, liquid, or gas. By extension, we can define
    sound as the audible result of these oscillations on our ear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our ear, combined with further brain processes, is an amazing air-pressure
    sensor. It is able to evaluate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amplitude of a sound (related to the amount of air moving)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency of a sound (related to the air oscillation amount)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, all these processes are real time, assuming higher or lower frequencies
    mix at this particular moment.
  prefs: []
  type: TYPE_NORMAL
- en: I'd really suggest that you read the amazing and efficient introduction to *How
    Digital Audio Works?*, by cycling 74, the maker of the Max 6 framework. You can
    read it online at [http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio](http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio).
  prefs: []
  type: TYPE_NORMAL
- en: A sound can contain more than one frequency, and it is generally a combination
    of the frequency content and the global perception of each frequency amplitude
    that gives the feeling of what we call the timbre of a sound. Psychoacoustics
    studies the perception of sound.
  prefs: []
  type: TYPE_NORMAL
- en: How to describe sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can describe sound in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, there are two representations of sound:'
  prefs: []
  type: TYPE_NORMAL
- en: Variation of the amplitude over time. This description can be put on a graph
    and defined as a time-domain representation of sounds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variation of the amplitude depending on the frequency content. This is called
    the frequency-domain representation of sounds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a mathematical operation that provides an easy way to pass from one
    to the other, known as the Fourier transform ([http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)).
    Many implementations of this operation are available on computers, in the form
    of the **Fast Fourier Transform** (**FFT**), which is an efficient method that
    provides fast approximate calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a sinusoidal variation of air pressure. This is one of the most
    simple sound waves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two representations in the two domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to describe sound](img/7584_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two representations of the same elementary sound produced by a sinusoidal variation
    of air pressure
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe the two graphs of the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: In the time-domain representation, we can see a cyclical variation with a period.
    The period is the time equivalent of the spatial wavelength.
  prefs: []
  type: TYPE_NORMAL
- en: The period is the time needed to complete a complete vibrational cycle. Basically,
    if you can describe the variation over a period, you are able to totally draw
    the representation of the sound in time. Here, it is a bit obvious because we
    are watching a pure sine-based sound.
  prefs: []
  type: TYPE_NORMAL
- en: If you draw and observe a sound produced by a source, the amplitude variation
    over time will correspond directly to a variation of air pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the orientation of the axis, we first have what we call a high-pressure
    front. This is the part of the curve above zero (represented by the time axis).
    This means that the pressure is high and our tympanum is pushed a bit more inside
    our ear.
  prefs: []
  type: TYPE_NORMAL
- en: Then, after a semi-period, the curve crosses zero and goes below, meaning that
    the air pressure is lower than the normal atmospheric pressure. Our tympanum also
    feels this variation. It is pulled a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the frequency-domain representation, there is only a vertical line. This
    pulse-like graph in the previous figure represents the unique frequency contained
    in this sine-based sound. It is directly related to its period by a mathematical
    equation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to describe sound](img/7584_09_inline01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `T` is the period in seconds and `f` is the frequency in Hertz.
  prefs: []
  type: TYPE_NORMAL
- en: The higher the frequency, the more the sound is felt as high-pitched. The lesser
    it is, the more the sound is felt as low-pitched.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a high frequency means a short period and faster oscillations over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: These are the basic steps in understanding how sound can be represented and
    felt.
  prefs: []
  type: TYPE_NORMAL
- en: Microphones and speakers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microphones are devices that are sensitive to the subtle variation of air pressure.
    Yes, they are sensors. They can translate air-pressure variations into voltage
    variations.
  prefs: []
  type: TYPE_NORMAL
- en: Speakers are devices that implement a part that can move, pushing and pulling
    masses of air, making it vibrate and produce sounds. The movement is induced by
    voltage variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both these cases, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: A membrane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An electrical transducer system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the microphone case, we change the air pressure and that produces an electrical
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: In the speaker case, we change the electrical signal and that produces an air
    pressure variation.
  prefs: []
  type: TYPE_NORMAL
- en: In each case, we have analog signals.
  prefs: []
  type: TYPE_NORMAL
- en: Digital and analog domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sounds sources can be very different. If you knock on a table, you'll hear a
    sound. This is a basic analog- and physical-based sound. Here, you physically
    make the table vibrate a bit, pushing and pulling air around it; and because you
    are near it, your tympanum feels these subtle variations.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we talk about digital equipment, we have some limitations considering
    storage and memory. Even if these are large and sufficient now, they aren't infinite.
  prefs: []
  type: TYPE_NORMAL
- en: And how can we describe something analog in that case? We already spoke about
    this situation when we described analog and digital input and output pins of Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: How to digitalize sound
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a system that could sample the voltage variation of your microphones
    periodically. A sampling concept usually used is sample and hold.
  prefs: []
  type: TYPE_NORMAL
- en: The system is able to read the analog value at regular intervals of time. It
    takes a value, holds it as a constant until the next value, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We are talking about the sampling rate to define the sampling frequency. If
    the sampling rate is low, we will have a lower approximation of the analog signal
    than if what we would have had if the sampling rate was high.
  prefs: []
  type: TYPE_NORMAL
- en: A mathematical theorem provides us a limit that we have to keep in mind—the
    Nyquist frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep our sampling system process a safe artifact induced by the
    system itself, we have to sample at a minimum of two times the higher frequency
    in our original analog signal.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to digitalize sound](img/7584_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example illustrating the sampling rate while sampling a sine wave
  prefs: []
  type: TYPE_NORMAL
- en: A higher sampling rate not only means more precision and fidelity to the original
    analog wave, but also more points to store in the digital system. The result would
    be a heavier file, in terms of disks and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Another element to keep in mind while sampling is the bit depth.
  prefs: []
  type: TYPE_NORMAL
- en: I voluntarily omitted it in the previous figure in order to not overload the
    drawings.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, we sampled a value over time, but how can you represent the value itself,
    the amplitude I mean? We use a bit-based coding system, as usual, with the digital
    equipment.
  prefs: []
  type: TYPE_NORMAL
- en: The **bit depth** is the resolution of the amplitude values from `-1` (the minimum
    possible) to `1` (the maximum possible).
  prefs: []
  type: TYPE_NORMAL
- en: The higher the bit depth, the more the subtle variations we can encode and record
    into our digital systems. Conversely, if we have a very low bit-depth sampler
    and we make a progressively decreasing amplitude variation, the sound will decrease
    considerably in a manner similar to the Doppler effect. For instance, we wouldn't
    be able to distinguish values from `0.5` to `0.6`; everything would only be `0.5`
    or `0.7` but never `0.6`. The sound would lose subtlety.
  prefs: []
  type: TYPE_NORMAL
- en: Usual sampling rates and bit depth depends on the purpose of the final rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two commonly used quality standards:'
  prefs: []
  type: TYPE_NORMAL
- en: CD quality is 44.1 kHz and 16-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DAT quality is 48 kHz and 16-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some recording and mastering studios use audio interfaces and internal processing
    at 96 kHz and 24 bits. Some people who love old-school sound engines still use
    lo-fi systems to produce their own sound and music at 16 kHz and 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The process from analog to digital conversion is handled by the **analog to
    digital converter** (**ADC**). Its quality is the key to achieving good conversion.
    This process is similar to the one involved in Arduino when we use an analog input.
    Its ADC is 10 bits and it can read a value once every 111 microseconds, which
    is a sampling rate frequency of 9 kHz.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers are used to smoothly process times and make things smoother in time.
  prefs: []
  type: TYPE_NORMAL
- en: How to play digital bits as sounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also convert digital encoded sounds into analog sounds. This process
    is achieved by the **digital to analog converter** (**DAC**).
  prefs: []
  type: TYPE_NORMAL
- en: If the processor sends bits of data from the encoded sound to the DAC as a continuous
    flow of discrete values, the DAC takes all these values and converts them as an
    analog electrical signal. It interpolates values between each digital value, which
    often involves some processes (for example, low-pass filtering), in order to remove
    some artifacts such as harmonics above the Nyquist frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of digital audio, DAC power and quality is one of the most important
    aspects of our audio workstation. They have to provide high resolutions, a high
    sampling rate, a small total harmonic distortion and noise, and a great dynamic
    range.
  prefs: []
  type: TYPE_NORMAL
- en: How Arduino helps produce sounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's come back to Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino can read and write digital signals. It can also read analog signals
    and simulate analog output signals through PWM.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be able to produce and even listen to sounds? Of course it would.
  prefs: []
  type: TYPE_NORMAL
- en: We can even use some dedicated components to make things better. For instance,
    we can use an ADC with a higher sampling rate in order to store sounds and a high-quality
    DAC too, if required. Today, we often use electronic hardware equipment to control
    software. We can, for instance, build a device based on Arduino, full of knobs
    and buttons and interface it with a software on the computer. This has to be mentioned
    here.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use Arduino as a sound trigger. Indeed, it is quite easy to turn
    it into a small sequencer, popping out specific MIDI or OSC messages to an external
    synthesizer, for instance. Let's move further and go deeper into audio concepts
    specifically with the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: Playing basic sound bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing a sound requires a sound source and a speaker. Of course, it also requires
    a listener who is able to hear sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Natively, Arduino is able to produce 8 kHz and 8-bit audio playback sounds on
    small PC speakers.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the `tone()` function available natively in the Arduino
    Core. As written at [http://arduino.cc/en/Reference/Tone](http://arduino.cc/en/Reference/Tone),
    we have to take care of the pins used when using this function, because it will
    interfere with PWM output on pins 3 and 11 (except for the Arduino MEGA).
  prefs: []
  type: TYPE_NORMAL
- en: This technique is also named **bit-banging**. It is based on I/O pin toggling
    at a specific frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the cheapest sound circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to design the cheapest sound generator ever with a small 8-ohm
    speaker, a resistor, and an Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the cheapest sound circuit](img/7584_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A small sound generator
  prefs: []
  type: TYPE_NORMAL
- en: The connections made here ensure an audible sound. Let's program the chip now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding circuit diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the cheapest sound circuit](img/7584_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The diagram of the sound generator
  prefs: []
  type: TYPE_NORMAL
- en: Playing random tones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a digital artist and specifically as an electronic musician, I like to be
    free of the notes. I often use frequencies instead of notes; if you are interested,
    you can read about the microtonal concept at [http://en.wikipedia.org/wiki/Microtonal_music](http://en.wikipedia.org/wiki/Microtonal_music).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we don't use notes but frequencies to define and trigger our
    electronic music.
  prefs: []
  type: TYPE_NORMAL
- en: The code is also available in the `Chapter09/ ToneGenerator/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We initialize the pseudorandom number generator at first by reading the analog
    input `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the loop, we generate two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: The pitch is a number from 30 to 4,999; this is the frequency of the sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration is a number from 1 ms to 1 s; this is the duration of the sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two arguments are required by the `tone()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `tone()`. The first argument is the pin where you feed the speaker.
  prefs: []
  type: TYPE_NORMAL
- en: The `tone()` function generates a square wave of the specified frequency on
    a pin as explained in its reference page at [http://arduino.cc/en/Reference/Tone](http://arduino.cc/en/Reference/Tone).
  prefs: []
  type: TYPE_NORMAL
- en: If we don't provide a duration, the sound continues until the `noTone()` function
    is called. The latter takes an argument that was used by the pin as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, listen to and enjoy this microtonal pseudorandom melody coming from your
    8-bit chip.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the sound engine with Mozzi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bit-banging technique is very cheap and it''s nice to learn how it works.
    However, I can quote some annoying things here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No pure sound**: Square waves are a sum of all odd harmonics at the fundamental
    frequency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No amplitude control available**: Each note sounds at the same volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use a very nice library called Mozzi, by Tim Barrass. The official
    website is directly hosted on GitHub at [http://sensorium.github.com/Mozzi/](http://sensorium.github.com/Mozzi/).
    It includes the `TimerOne` library, a very fast timer handler.
  prefs: []
  type: TYPE_NORMAL
- en: Mozzi provides a very nice 16,384 kHz, 8-bit audio output. There is also a nice
    basic audio toolkit containing oscillators, samples, lines and envelopes, and
    filtering too.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is available without external hardware and by only using two pins
    of the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to design a small sound engine based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a circuit and Mozzi library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up the circuit is easy; it is the same as the latest one except that
    pin 9 has to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mozzi''s documentation says:'
  prefs: []
  type: TYPE_NORMAL
- en: To hear Mozzi, connect a 3.5 mm audio jack with the centre wire to the PWM output
    on Digital Pin 9* on Arduino, and the black ground to the Ground on the Arduino.
    Use this as a line out which you can plug into your computer and listen to with
    a sound program like Audacity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is really easy to set up the hardware. You can find many 3.5 mm audio jack
    connector like that all over the Internet. In the following circuit diagram, I
    put a speaker instead of a jack connector but it works exactly the same with a
    jack connector, that latter having 2 pins, one ground and one signal related.
    Ground has to be connected to the Arduino's ground and the other pin to the digital
    pin 9 of the Arduino.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Then we have to install the library itself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Download it from their website: [http://sensorium.github.com/Mozzi](http://sensorium.github.com/Mozzi)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unzip it and rename the folder as Mozzi.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then put it as usual in the place you put your libraries; in my case it is:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: /Users/julien/Documents/Arduino/libraries/
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Restart or just start your Arduino IDE and you'll be able to see the library
    in the IDE.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is provided with a bunch of examples.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We are going to use the one about the sine wave.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is what the Mozzi library looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a circuit and Mozzi library](img/7584_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Mozzi installation revealing a lot of examples
  prefs: []
  type: TYPE_NORMAL
- en: An example sine wave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any library, we have to learn how to use the sine wave.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of examples, and these are useful to learn how to design our
    own firmware step-by-step. Obviously, I won't describe all these examples, but
    only those in which I'll grab elements to make your own sound generator.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the sine wave example. It is also available in the `Chapter09/ MozziSoundGenerator/`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At first, some inclusions are done.
  prefs: []
  type: TYPE_NORMAL
- en: '`MozziGuts.h` is the basic header to include in any case.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Oscil.h` is the header to use if you need an oscillator.'
  prefs: []
  type: TYPE_NORMAL
- en: We then include a wave table (sine wave).
  prefs: []
  type: TYPE_NORMAL
- en: Oscillators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the sound synthesis world, an **oscillator** is a basic unit that is capable
    of producing oscillations. It is often used not only for direct sound generation
    with frequencies varying from 20 Hz to 20 kHz (audible spectrum), but also as
    a modulator (usually with frequencies lower than 50 Hz). It has been used as the
    latter in this case. An oscillator is usually called a **Low Frequency Oscillator**
    (**LFO**).
  prefs: []
  type: TYPE_NORMAL
- en: Wavetables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **wavetable** is a very nice and efficient way to store whole pieces of sounds,
    generally cyclical or looped sounds.
  prefs: []
  type: TYPE_NORMAL
- en: We basically used this as a lookup table. Do you remember using it?
  prefs: []
  type: TYPE_NORMAL
- en: Instead of calculating our sine value over time in real time, we basically precalculate
    each value of a whole period, and then add the results into a table; each time
    we need it, we just have to scan the table from the beginning to the end to retrieve
    each value.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this IS definitely an approximation. But it saves a lot of CPU work.
  prefs: []
  type: TYPE_NORMAL
- en: A wavetable is defined by its size, the sample rate related, and of course the
    whole values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check what we can find in the `sin2048_int8.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wavetables](img/7584_09_016revised.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can indeed find the number of cells: 2048 (that is, there are 2048 values
    in the table). Then, the sample rate is defined as 2048.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the example.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the Oscil object that creates an oscillator.
  prefs: []
  type: TYPE_NORMAL
- en: After the second `define` keyword related to the variable update frequency,
    we have the usual structure of `setup()` and `loop()`.
  prefs: []
  type: TYPE_NORMAL
- en: We also have `updateControl()` and `updateAudio()` and those aren't defined
    in the code. Indeed, they are related to Mozzi and are defined in the library
    files themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `setup()` block starts the Mozzi library at the specific control rate defined
    before. Then, we set up the oscillator defined before at a frequency of 440 Hz.
    440 Hz is the frequency of the universal A note. In this context, it can be thought
    of as the audio equivalent of the Hello World example.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing more about `updateControl()` here.
  prefs: []
  type: TYPE_NORMAL
- en: We return `aSin.next()` in `updateAudio()`. It reads and returns the next sample,
    which is understood as the next element, which is the next bit of sound.
  prefs: []
  type: TYPE_NORMAL
- en: In `loop()`, we call the `audioHook()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The global pattern is usual. Even if you use another library related to sound,
    inside or outside the Arduino world, you''ll have to deal with this kind of pattern
    in four steps (generally, but it may differ):'
  prefs: []
  type: TYPE_NORMAL
- en: Definitions in the header with some inclusions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start of the audio engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permanent loop of a hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating functions for rendering things before a commit, then in the hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you upload this, you'll hear a nice A440 note, which may make you hum a little.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency modulation of a sine wave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now merge some concepts—sine wave generation, modulation, and input reading.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use two oscillators, one modulating the frequency of the other.
  prefs: []
  type: TYPE_NORMAL
- en: With a potentiometer, we can control the frequency of the modulating oscillator.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first improve the circuit by adding a potentiometer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following circuit diagram, we have added a potentiometer in the sound
    generator circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a pot](img/7584_09_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The circuit diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a pot](img/7584_09_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Improving the sound generator
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the firmware for input handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is also available in the `Chapter09/MozziFMOnePot/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use two oscillators, both based on a cosine wavetable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aCos` stands for the sound itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aVibrato` is the modulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we have a potentiometer here, we need to scale things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: '`intensityMax` is the maximum intensity of the modulation effect. I chose 500
    after testing it myself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We often use the following technique to scale things: use a constant (or even
    a "real" variable) and then multiply it by the value you can vary. This can be
    done in one pass by using the `map()` function. We already used it in [Chapter
    6](ch06.html "Chapter 6. Sensing the World – Feeling with Analog Inputs"), *Sensing
    the World–Feeling with Analog Inputs*, for the same purpose—scaling an analog
    input value.'
  prefs: []
  type: TYPE_NORMAL
- en: In that case, at the maximum value, your potentiometer (more generally your
    input) changes the parameter you want to alter to its maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue the review of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We define the potentiometer pin n and the variable `potPin`. We also define
    `potValue` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `setup()` block, we start Mozzi. We define the frequency of the oscillator
    as `aCos`. The frequency itself is the result of the `mtof()` function. `mtof`
    stands for **MIDI to Frequency**.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to describe it a bit later, MIDI protocol codes many bytes of
    values, including the pitch of notes it uses to transport from sequencers to instruments.
    Each MIDI note fits with real note values in the real world, and each note fits
    with a particular frequency. There are tables that show the frequency of each
    MIDI note, and Mozzi includes that for us.
  prefs: []
  type: TYPE_NORMAL
- en: We can pass a MIDI note pitch as argument to the `mtof()` function, and it will
    return the right frequency. Here, we use the `random(21,80)` function to generate
    a MIDI note pitch from 21 to 79, which means from A0 to A5.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this use case is a pretext to begin introducing MIDI. We could have
    directly used a `random()` function to generate a frequency.
  prefs: []
  type: TYPE_NORMAL
- en: We then read the current value of the analog input A0 and use it to calculate
    a scaled value of the frequency of the modulating oscillator, `aVibrato`. This
    is only to provide more randomness and weirdness. Indeed, if your pot isn't at
    the same place each time you restart Arduino, you'll have a different modulation
    frequency.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` block then executes the `audioHook()` method constantly to produce
    audio.
  prefs: []
  type: TYPE_NORMAL
- en: And the smart thing here is the `updateControl()` method. We add the `analogRead()`
    function that reads the value of the analog input. Doing this in `updateControl()`
    is better, considering the purpose of this function. Indeed, the Mozzi framework
    separates the audio rendering time-critical tasks from the control (especially
    human control) pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: You'll come across this situation very often in many frameworks, and it can
    confuse you the first time. It is all about the task and its scheduling. Without
    reverse-engineering the Mozzi concepts here, I would like to say only that time-critical
    events have to be handled more carefully than human actions.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, even if it seems as if we can be very fast at turning a knob, it is
    really slow compared to the sample rate of Mozzi, for instance (16,384 kHz). This
    means we cannot stop the whole process only to test and check, if we change the
    value of this potentiometer constantly. Things are separated; keep this in mind
    and use the framework carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we read the value in `updateControl()` and store it in the `potValue`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in `updateAudio()`, we calculate the vibrato value as the value of `potValue`
    scaled from `0` to the value of `intensityMax`, multiplied by the next value of
    the oscillator in its wavetable.
  prefs: []
  type: TYPE_NORMAL
- en: This value is then used in a new method named `phMod`. This method applies a
    phase modulation to the oscillator for which it is called. This modulation is
    a nice way to produce a frequency modulation effect.
  prefs: []
  type: TYPE_NORMAL
- en: Now, upload the firmware, add the earphone, and turn the potentiometer. You
    should be able to hear the effect and control it with the potentiometer.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the sound using envelopes and MIDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now okay to design small bits of a sound engine using Mozzi. There are
    other libraries around, and what we learned will be used with those two. Indeed,
    these are patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check how we can control our Arduino-based sound engine using a standard
    protocol from a computer or other device. Indeed, it would be interesting to be
    able to trigger notes to change sound parameters using a computer, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Both are protocols used in the music and new media related projects and works.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of MIDI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MIDI** is short for **Musical Instrument Digital Interface**. It is a specification
    standard that enables digital music instruments, computers, and all required devices
    to connect and communicate with one another. It was introduced in 1983, and at
    the time of writing has just celebrated its 30th anniversary. The reference website
    is [http://www.midi.org](http://www.midi.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'MIDI can transport the following data over a basic serial link:'
  prefs: []
  type: TYPE_NORMAL
- en: Notes (on/off, after touch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter changes (control change, program change)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time messages (clock, transport state such as start/stop/continue)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System exclusives, allowing manufacturers to create their message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A new protocol appeared and is used very widely today: OSC. It isn''t a proper
    protocol, by the way.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OSC** stands for **Open Sound Control** and is a content format developed
    by two people at the **Center for New Music and Audio Technologies** (**CNMAT**)
    at University of Berkeley, California. It was originally intended for sharing
    gestures, parameters, and sequences of notes during musical performances. It is
    very widely used as a replacement for MIDI today, providing a higher resolution
    and faster transfer. Its main feature is the native network transport possibility.
    OSC can be transported over UDP or TCP in an IP environment, making it easy to
    be used over Wi-Fi networks and even over the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: MIDI and OSC libraries for Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'd suggest two libraries here. I tested them myself and they are stable and
    efficient. You can check the one about MIDI at [http://sourceforge.net/projects/arduinomidilib](http://sourceforge.net/projects/arduinomidilib).
    You can check this one about OSC at [https://github.com/recotana/ArdOSC](https://github.com/recotana/ArdOSC).
    You shouldn't have too many difficulties installing them now. Let's install at
    least MIDI, and restart the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Generating envelopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the audio field, an **envelope** is a shape used to modify something. For
    instance, imagine an amplitude envelope shaping a waveform.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have a waveform first. I generated this sine with Operator synthesizer
    in Ableton Live ([https://www.ableton.com](https://www.ableton.com)), the famous
    digital audio workstation. Here is a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating envelopes](img/7584_09_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A basic sine wave generated by an operator in Ableton Live's Operator FM synth
  prefs: []
  type: TYPE_NORMAL
- en: 'The sine doesn''t show very well due to aliasing; here is another screenshot,
    which is the same wave but more zoomed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating envelopes](img/7584_09_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sine wave
  prefs: []
  type: TYPE_NORMAL
- en: This sine wave has a global constant amplitude. Of course, the air pressure
    push and pull constantly, but the global maximums and minimums are constant over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Musicians always want to make their sounds evolve over time, subtly or harshly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply an envelope to this same wave that will make it increase the global
    volume progressively, then decrease it a bit, and then decrease quickly to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating envelopes](img/7584_09_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sine wave altered by an envelope with a long attack
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result with another envelope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating envelopes](img/7584_09_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sine wave altered by an envelope with a very short attack
  prefs: []
  type: TYPE_NORMAL
- en: Basically, an envelope is a series of points in time. At each moment, we multiply
    the value of the original signal by the value of the envelope.
  prefs: []
  type: TYPE_NORMAL
- en: This produces a sound evolution over time.
  prefs: []
  type: TYPE_NORMAL
- en: We can use envelopes in many cases because they can modulate amplitude, as we
    just learned. We can also use them to alter the pitch (that is, the frequency)
    of a sound.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, envelopes are triggered (that is, applied to the sound) at the same
    time the sound is triggered, but of course we can use the offset retrigger feature
    to retrigger the envelope during the same triggered sound and do much more.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a last example showing a pitch envelope. The envelope makes the frequency
    of the sound decrease. As you can see, the waves are tighter on the left than
    on the right. The sound changes from high-pitched to low-pitched.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating envelopes](img/7584_09_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An envelope modulating the pitch of a sound
  prefs: []
  type: TYPE_NORMAL
- en: Implementing envelopes and MIDI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to design a very cheap sound synthesizer that will be able to trigger
    notes when it receives a MIDI note message and alter the sound when it receives
    a particular MIDI Control Change message.
  prefs: []
  type: TYPE_NORMAL
- en: The MIDI part will be handled by the library and the envelope will be explicated
    and coded.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the following code. This code is also available in the `Chapter09/MozziMIDI/`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At first, we include the MIDI library. Then we include the Mozzi library.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the right bits of Mozzi to include are a bit different for each project.
    Studying examples helps to understand what goes where. Here, we not only need
    Oscil for the basic features of the oscillator, but also need Line. Line is related
    to interpolation functions in Mozzi. Generating an envelope deals with this. Basically,
    we choose two values and a time duration, and it starts from the first one and
    reaches the second one in the time duration you choose.
  prefs: []
  type: TYPE_NORMAL
- en: We also include the wavetable related to a sine.
  prefs: []
  type: TYPE_NORMAL
- en: We define a control rate higher than before, at 128\. That means the `updateControl()`
    function is called 128 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define the oscillator as `aSin`.
  prefs: []
  type: TYPE_NORMAL
- en: After these bits, we define an envelope by declaring an instance of the Line
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We define two variables that store the release part of the envelope duration,
    one for the control part in one second (that is, the number of steps will be the
    value of `CONTROL_RATE`) and one for the audio part in one second too (that is,
    16,384 steps). Lastly, a variable named `fade_counter` is defined.
  prefs: []
  type: TYPE_NORMAL
- en: '`HandleControlChange()` is a function that is called when a MIDI Control Change
    message is sent to Arduino. The message comes with these bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: MIDI channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CC number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These arguments are passed to the `HandleControlChange()` function, and you
    can access them directly in your code.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common way to use event handlers. Almost all event listener frameworks
    are made like this. You have some function and you can use them and put whatever
    you want inside them. The framework itself handles the functions that have to
    be called, saving as much CPU time as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we add a `switch` statement with only one case over the `CCNumber` variable.
  prefs: []
  type: TYPE_NORMAL
- en: This means if you send a MIDI Control Change 100 message, this case being matched,
    the value of `CC` will be processed and the `vol` variable will be altered and
    modified. This Control Change will control the master output volume of the synth.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, `HandleNoteOn()` and `HandleNoteOff()` handle MIDI note messages.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a MIDI Note On message is sent when you push a key on your MIDI keyboard.
    As soon as you release that key, a MIDI Note Off message pops out.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two functions handling these messages.
  prefs: []
  type: TYPE_NORMAL
- en: '`HandleNoteOn()` parses the message, takes the velocity part, bit shifts it
    on the left to 8 bits, and passes it to `aGain` through the `set()` method. When
    a MIDI Note On message is received, the envelope `aGain` is triggered to its maximum
    value. When a MIDI Note Off message is received, the envelope is triggered to
    reach 0 in one second via the number of audio steps discussed before. The `fade`
    counter is also reset to its maximum value at the moment the key is released.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we have a system responding to the MIDI Note On and MIDI Note Off
    messages. When we push a key, a sound is produced until we release the key. When
    we release it, the sound decreases linearly to 0, taking one second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setup()` method includes the setup of the MIDI library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MIDI.begin()` instantiates the communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MIDI.setHandleControlChange()` lets you define the name of the function called
    when a control change message is coming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MIDI.setHandleNoteOn()` lets you define the name of the function called when
    a Note On message is coming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MIDI.setHandleNoteOff()` lets you define the name of the function called when
    a Note Off message is coming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also includes the setup of Mozzi.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` function is quite familiar now.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateControl()` function does not contain the time-critical part of the
    sound generator. It doesn't mean this function is called rarely; it is called
    less than `updateAudio()`—128 times per second for control and 16,384 per second
    for audio, as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: This is the perfect place to read our MIDI flow, with the `MIDI.read()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we can trigger our decreasing envelope to 0 as soon as the `fade`
    counter reaches 0 and not before, making the sound in one second, as we checked
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `updateAudio()` function returns the value of the oscillator multiplied
    by the envelope value too. This is the purpose of the envelope. Then, `vol` multiplies
    the first result in order to add a key to control the master output volume.
  prefs: []
  type: TYPE_NORMAL
- en: The `<<8` and `>>8` expressions here are for setting a high-resolution linear
    fade on Note Off, and this is a nice trick provided by Tim Barrass himself.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a MIDI connector to Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This schematic is based on the MIDI electrical specification diagram at [http://www.midi.org/techspecs/electrispec.php](http://www.midi.org/techspecs/electrispec.php).
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a MIDI connector to Arduino](img/7584_09_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MIDI-featured sound generator based on Arduino
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding circuit diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a MIDI connector to Arduino](img/7584_09_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MIDI connector wired to the Arduino-based sound generator
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the digital pin 0 (serial input) is involved. This means we
    won't be able to use the serial communication over USB. In fact, we want to use
    our MIDI interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's upload the code and start this small sequencer in Max 6.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a MIDI connector to Arduino](img/7584_09_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *cheap sequencer for chips* fires MIDI notes and MIDI control changes
  prefs: []
  type: TYPE_NORMAL
- en: The sequencer is quite self-explanatory. Toggle on the toggle button at the
    top-left and it starts the sequencer, reading each step in the multislider object.
    The higher a slider is, the higher the pitch of this note into that step will
    be.
  prefs: []
  type: TYPE_NORMAL
- en: You can click on the button under the multislider on the left, and it will generate
    a random sequence of 16 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Choose the correct MIDI output bus from the list menu on the top-right.
  prefs: []
  type: TYPE_NORMAL
- en: Connect your Arduino circuit and your MIDI interface with a MIDI cable, and
    listen to the music. Change the multislider content and the sequence played. If
    you turn the dial, the volume will change.
  prefs: []
  type: TYPE_NORMAL
- en: Everything here is transmitted by MIDI. The computer is a sequencer and a remote
    controller and the Arduino is the synthesizer.
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio files with the PCM library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to play sounds is by reading already digitalized sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Audio samples define digital content, often stored as files on filesystems that
    can be read and converted into audible sound.
  prefs: []
  type: TYPE_NORMAL
- en: Samples can be very heavy from the memory size point of view.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the PCM library set up by David A. Mellis from MIT. Like
    other collaborators, he is happy to be a part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The reference page is [http://hlt.media.mit.edu/?p=1963](http://hlt.media.mit.edu/?p=1963).
  prefs: []
  type: TYPE_NORMAL
- en: Download the library and install it.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have enough space in the Arduino memory spaces. How can we do
    the installation if we want to convert a sample on our disks as a C-compatible
    structure?
  prefs: []
  type: TYPE_NORMAL
- en: The PCM library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check this code. It is also available in the `Chapter09/PCMreader/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![The PCM library](img/7584_09_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our PCM reader
  prefs: []
  type: TYPE_NORMAL
- en: There is an array of `unsigned char` datatypes declared as `const`, and especially
    with the `PROGMEM` keyword named `sample`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PROGMEM` forces this constant to be put in the program space instead of RAM,
    because the latter is much smaller. Basically, this is the sample. The `startPlayback()`
    function is able to play a sample from an array. The `sizeof()` method calculates
    the size of the memory of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: WAV2C – converting your own sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have already played with wavetable, and this is what we will be doing
    hereafter, we can store our sample waveforms in the Arduino code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Even if dynamic reading of the audio file from an SD card would seem smarter,
    PCM provides an even easier way to proceed—directly reading an analog conversion
    of an array while storing a waveform into a sound.
  prefs: []
  type: TYPE_NORMAL
- en: We first have to transform a sample as C data.
  prefs: []
  type: TYPE_NORMAL
- en: David Ellis made an open source, small processing-based program that provides
    a way to do this; it can be found at [https://github.com/damellis/EncodeAudio](https://github.com/damellis/EncodeAudio).
  prefs: []
  type: TYPE_NORMAL
- en: You can download it from the reference project page directly compiled for your
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: Launch it, choose a WAV file (PCM-based encoded sample), and then it will copy
    something huge in your clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you only have to copy-paste this content into the array defined before.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to correctly paste it between the curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content copied from the clipboard after converting a `wav` sample
    that I made myself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WAV2C – converting your own sample](img/7584_09_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A huge amount of data to paste in a C array
  prefs: []
  type: TYPE_NORMAL
- en: In the same folder, I have put a `.wav` file I designed. It is a short rhythm
    recorded in 16 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The circuit is similar to the one in the *Playing basic sound bits* section,
    except that we have to use the digital pin 11 here. And we cannot use PWM on pins
    3, 9, and 10 because the timers involved in the library consume them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the circuit](img/7584_09_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wiring our PCM reader
  prefs: []
  type: TYPE_NORMAL
- en: The circuit diagram is easy too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the circuit](img/7584_09_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don't forget to use pin 11 with the PCM library
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's play the music.
  prefs: []
  type: TYPE_NORMAL
- en: Other reader libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also other libraries providing ways to read and decode the MP3 format
    or other formats.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a lot on the Internet; but be careful as some of them require some
    shields, like the one on the Sparkfun website at [https://www.sparkfun.com/products/10628](https://www.sparkfun.com/products/10628).
  prefs: []
  type: TYPE_NORMAL
- en: This provides a shield with an SD Card reader, a 3.5 mm stereo headphone jack,
    a VS1053 shift register, and very versatile decoder chips for MP3, WMA, AAC, and
    other formats.
  prefs: []
  type: TYPE_NORMAL
- en: It is a very dedicated solution and we only have to interface the shield with
    Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino only sends and receives bits from the shield, which takes care of the
    decoding of the encoded files, the conversion to analog signals, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: I'd really suggest testing it. There are many examples on the Sparkfun website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned how to make things move right here with Arduino. In particular,
    we learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving solid things with motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving air with sound generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, unfortunately, I cannot describe more on how to make things move.
  prefs: []
  type: TYPE_NORMAL
- en: If you need help with sound, please contact me at `<[book@cprogrammingforarduino.com](mailto:book@cprogrammingforarduino.com)>`.
    I will be a happy to help you with sound inputs too, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of the second part of the book. We discovered a lot of concepts
    together. And now we are going to dig into some more advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: We are able to understand firmware design and inputs and outputs, so let's move
    further.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to dig deeper into precise examples with I2C/SPI communication
    to use GPS modules, 7-segment LED systems, and more. We are also going to dig
    into Max 6, and especially how we can use Arduino to control some OpenGL visuals
    on the computer. We'll discover network protocols and how to use Arduino even
    without any network cables, with Wi-Fi. At last, we'll design a small library
    together and check some nice tips and tricks to improve our C code.
  prefs: []
  type: TYPE_NORMAL
