- en: Chapter 9. Making Things Move and Creating Sounds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 使物体移动和创造声音
- en: If the Arduino board can listen and feel with sensors, it can also react by
    making things move.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Arduino板可以通过传感器来监听和感受，它也可以通过使物体移动来做出反应。
- en: 'By the movement concept, I mean both of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运动概念，我指的是以下两个方面：
- en: Object movements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物体运动
- en: Air movements producing sounds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生声音的空气运动
- en: We are going to learn how we can control small motors named **servo**, and how
    we can deal with high-current control by using transistors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何控制名为**伺服**的小型电机，以及如何通过使用晶体管来处理高电流控制。
- en: Then we'll start talking about the basics of sound generation. This is a requirement
    before trying to produce any sounds, even the simplest ones. This is the part
    where we'll describe analog and digital concepts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开始谈论声音产生的基础知识。这是尝试产生任何声音，即使是简单的声音之前的一个要求。这是我们将描述模拟和数字概念的部分。
- en: At last, we'll design a very basic random synthesizer controllable using MIDI.
    We'll also introduce a very nice library called **PCM** that provides a simple
    way to add sample playing features to your 8-bit microcontroller.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设计一个非常基本的随机合成器，可以通过MIDI进行控制。我们还将介绍一个非常棒的库，称为**PCM**，它提供了一种简单的方法，可以将样本播放功能添加到你的8位微控制器中。
- en: Making things vibrate
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使物体振动
- en: One of the simplest projects we can introduce here is the use of a small piezoelectric
    sensor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里介绍的最简单的项目之一就是使用一个小型的压电传感器。
- en: This is the first basic tangible action we design here. Of course, we already
    designed many of the visual feedback, but this is our first real-world object
    that moves the firmware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在设计中设计的第一个基本可感知的动作。当然，我们之前已经设计了许多视觉反馈，但这是我们第一个真正影响固件的现实世界对象。
- en: This kind of feedback can be very useful in nonvisual contexts. I designed a
    small project for a person who wanted to send a feedback to visitors in his reactive
    installation. The visitor had to put on a t-shirt that included some electronics
    attached, such as a LilyPad and some piezoelectric sensors. The LED feedback wasn't
    the solution we used before to send feedback to the wearer, and we decided to
    send a vibration. These piezoelectric sensors were distributed on each side of
    the t-shirt to produce different feedback in response to different interactions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的反馈在非视觉环境中非常有用。我为一个人设计了一个小项目，他想在他的反应式装置中向参观者发送反馈。参观者必须穿上一件包含一些电子组件的T恤，例如LilyPad和一些压电传感器。LED反馈不是我们之前用来向穿戴者发送反馈的解决方案，我们决定发送振动。这些压电传感器分布在T恤的两侧，以产生不同的反馈，以响应不同的交互。
- en: But wouldn't I have made a mistake talking about sensors vibrating?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不是在谈论传感器振动时犯了一个错误吗？
- en: The piezoelectric sensor
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压电传感器
- en: A piezoelectric sensor is a component that uses the piezoelectric effect.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 马达式传感器是一种利用压电效应的组件。
- en: This effect is defined as the linear electromechanical interaction between the
    mechanical and electrical state in some specific materials.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效应被定义为某些特定材料中机械状态和电状态之间的线性机电相互作用。
- en: Basically, a mechanical action on this device generates electricity, making
    it usable for movement and vibration detection. But the nice thing here is that
    the effect is reciprocal—if you apply a current to it, it will vibrate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个设备上的机械动作会产生电能，使其可用于运动和振动检测。但这里的好之处在于效果是相互的——如果你给它施加电流，它就会振动。
- en: This is why we are using a piezoelectric sensor here. We are using it as a vibration
    generator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在这里使用压电传感器的原因。我们将其用作振动发生器。
- en: Piezoelectric sensors are also often used as a tone generator. We will dig deeper
    into the relationship between air vibrations and sound a bit later, but it is
    important to mention it here too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 压电传感器也常被用作音调发生器。我们将在稍后更深入地探讨空气振动和声音之间的关系，但在这里提一下也很重要。
- en: Wiring a vibration motor
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接振动电机
- en: Piezoelectric sensors usually consume around 10 mA to 15 mA, which is very small.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 压电传感器通常消耗大约10 mA到15 mA的电流，这非常小。
- en: 'Of course, you need to check the proper datasheet of the device you are going
    to use. I have had good results with the one from **Sparkfun** ([https://www.sparkfun.com/products/10293](https://www.sparkfun.com/products/10293)).
    The wiring could not be simpler—there are only two legs. The following image shows
    how the piezoelectric sensor/vibrator is wired to Arduino via a PWM-capable digital
    pin:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要检查你将要使用的设备的正确数据表。我使用**Sparkfun**（[https://www.sparkfun.com/products/10293](https://www.sparkfun.com/products/10293)）的设备取得了很好的效果。布线非常简单——只有两个引脚。以下图像显示了压电传感器/振动器如何通过具有PWM功能的数字引脚连接到Arduino：
- en: '![Wiring a vibration motor](img/7584_09_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![连接振动电机](img/7584_09_001.jpg)'
- en: Please note that I have wired the piezoelectric device to a PWM-capable digital
    pin. I explained PWM in the previous chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经将压电器件连接到一个具有PWM功能的数字引脚。我在上一章中解释了PWM。
- en: 'Here is the circuit schematic. This piezoelectric component is displayed as
    a small buzzer/speaker:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是电路原理图。这个压电元件显示为一个小的蜂鸣器/扬声器：
- en: '![Wiring a vibration motor](img/7584_09_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![连接振动电机](img/7584_09_002.jpg)'
- en: Of course, since we are going to use PWM, it means that we are going to simulate
    an analog output current. Considering the duty-cycle concept, we can feed the
    piezoelectric device using the `analogWrite()` function and then feed it with
    different voltages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们将使用PWM，这意味着我们将模拟模拟输出电流。考虑到占空比的概念，我们可以使用`analogWrite()`函数给压电器件供电，然后以不同的电压供电。
- en: Firmware generating vibrations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成振动的固件
- en: Check the firmware. It is also available in the `Chapter09/vibrations/` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 检查固件。它也位于`Chapter09/vibrations/`文件夹中。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are using the `analogWrite()` function here again. This function takes the
    digital pin as an argument and value. This value from 0 to 255 is the duty cycle.
    It basically simulates an analog output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里再次使用`analogWrite()`函数。这个函数将数字引脚作为参数和值。这个值从0到255是占空比。它基本上模拟了模拟输出。
- en: We use it the usual way with the `incdec` (stands for increment-decrement) parameter.
    We store the increment value we want to use at each `loop()` execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`incdec`（表示递增-递减）参数的常规方式。我们在每次`loop()`执行时存储我们想要使用的增量值。
- en: This increment changes when the value reaches its boundaries, 0 or 255, and
    is inverted, providing a cheap way to make a cycle from 0 to 255, then to 0, then
    to 255, and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当值达到边界，即0或255时，这个增量会改变，并发生反转，提供了一种从0到255，然后到0，然后到255，依此类推的循环的廉价方法。
- en: This firmware makes the piezoelectric device vibrate cyclically from a low rate
    to a higher rate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个固件使压电器件从低频率到高频率循环振动。
- en: Let's control bigger motors now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们控制更大的电机。
- en: Higher current driving and transistors
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高电流驱动和晶体管
- en: We talked about transistors in the previous chapter. We used them as digital
    switches. They can also be used as amplifiers, voltage stabilizers, and many other
    related applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章讨论了晶体管。我们将其用作数字开关。它们也可以用作放大器、电压稳定器和许多其他相关应用。
- en: You can find transistors almost everywhere and they are quite cheap. You can
    find the complete datasheet at [http://www.fairchildsemi.com/ds/BC/BC547.pdf](http://www.fairchildsemi.com/ds/BC/BC547.pdf).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在任何地方找到晶体管，而且它们相当便宜。你可以在[http://www.fairchildsemi.com/ds/BC/BC547.pdf](http://www.fairchildsemi.com/ds/BC/BC547.pdf)找到完整的数据表。
- en: 'The following is a basic diagram explaining how transistors work:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基本图解，解释了晶体管的工作原理：
- en: '![Higher current driving and transistors](img/7584_09_003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![高电流驱动和晶体管](img/7584_09_003.jpg)'
- en: The transistor used as a digital switch in logical circuits
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑电路中用作数字开关的晶体管
- en: 'A transistor has the following legs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管有以下引脚：
- en: The collector
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集极
- en: The base
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基极
- en: The emitter
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射极
- en: If we saturate the base by applying a 5 V power supply to it, all the current
    coming from the collector will be transmitted through the emitter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过向其施加5 V电源来饱和基极，那么来自收集器的所有电流都将通过发射极传输。
- en: When used like this, the NPN transistor is a nice way to switch on/off high
    current that Arduino wouldn't have been able to drive by itself. By the way, this
    switch is controllable with Arduino because it only requires a very small amount
    of current to be provided to the base of the transistor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样使用时，NPN晶体管是一种很好的开关高电流的方法，Arduino本身无法驱动。顺便说一句，这个开关可以用Arduino控制，因为它只需要向晶体管的基极提供非常小的电流。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sending 5 V to the transistor base closes the circuit. Putting the transistor
    base to ground opens the circuit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 向晶体管基极发送5 V电压会闭合电路。将晶体管基极接地会打开电路。
- en: In any case, where you need to have an external power supply to drive motors,
    we use this kind of design pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何需要外部电源来驱动电机的情况下，我们使用这种设计模式。
- en: Let's now learn about small current servos and then move further using transistors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在学习小型电流伺服电机，然后进一步使用晶体管。
- en: Controlling a servo
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制伺服电机
- en: A **servomotor** is also defined as a rotary actuator that allows for very fine
    control of angular positions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**伺服电机**也被定义为一种允许对角位置进行非常精细控制的旋转执行器。'
- en: Many servos are widely available and quite cheap. I have had nice results with
    a 43 R servo, by Spring Model Electronics. You can find the datasheet at [http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf](http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多伺服电机都很常见且价格低廉。我使用Spring Model Electronics的43 R伺服电机取得了很好的效果。你可以在[http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf](http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf)找到数据表。
- en: Servos can drive a great amount of current. This means that you wouldn't be
    able to use more than one or two on your Arduino board without using an external
    source of power.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机可以驱动大量的电流。这意味着在没有使用外部电源的情况下，你无法在Arduino板上使用超过一个或两个伺服电机。
- en: When do we need servos?
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们什么时候需要伺服电机？
- en: Whenever we need a way to control a position related to a rotation angle, we
    can use servos.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要一种控制与旋转角度相关的位置的方法时，我们都可以使用伺服电机。
- en: Servos can not only be used to move small parts and make objects rotate, but
    can also be used to move the object including them. Robots work in this fashion,
    and there are many Arduino-related robot projects on the Web that are very interesting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机不仅可以用来移动小部件和使物体旋转，还可以用来移动包括在内的物体。机器人就是这样工作的，网上有很多有趣的Arduino相关机器人项目。
- en: In the case of robots, the servo device case is fixed to a part of an arm, for
    instance, and the other part of the arm is fixed to the rotating part of the servo.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人的情况下，伺服电机外壳固定在机械臂的一部分，而机械臂的另一部分则固定在伺服电机的旋转部分。
- en: How to control servos with Arduino
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用Arduino控制伺服电机
- en: There is a nice library that should be used at first, named `Servo`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常好的库应该首先使用，名为`Servo`。
- en: This library supports up to 12 motors on most Arduino boards and 48 on the Arduino
    Mega.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库在大多数Arduino板上支持多达12个电机，在Arduino Mega上支持多达48个。
- en: By using other Arduino boards over Mega, we can figure out some software limitations.
    For instance, pins 9 and 10 cannot be used for PWM's `analogWrite()`method ([http://arduino.cc/en/Reference/analogWrite](http://arduino.cc/en/Reference/analogWrite)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Mega以外的其他Arduino板，我们可以找出一些软件限制。例如，引脚9和10不能用于PWM的`analogWrite()`方法([http://arduino.cc/en/Reference/analogWrite](http://arduino.cc/en/Reference/analogWrite))。
- en: 'Servos are provided in three-pin packages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机提供的是三引脚封装：
- en: 5 V
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 V
- en: Ground
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地线
- en: Pulse; that is, control pin
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脉冲；即控制引脚
- en: Basically, the power supply can be easily provided by an external battery, and
    the pulse still remains the Arduino board.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，电源可以很容易地由外部电池提供，而脉冲仍然保持在Arduino板上。
- en: Let's check the basic wiring.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查基本的接线。
- en: Wiring one servo
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接线一个伺服电机
- en: 'The following diagram is that of a servo wired to an Arduino for both power
    supply and control:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将伺服电机连接到Arduino板以供电和控制的双向电路图：
- en: '![Wiring one servo](img/7584_09_004.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![接线一个伺服电机](img/7584_09_004.jpg)'
- en: 'The corresponding circuit diagram is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的电路图如下：
- en: '![Wiring one servo](img/7584_09_005.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![接线一个伺服电机](img/7584_09_005.jpg)'
- en: One servo and Arduino
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个伺服电机和Arduino
- en: We are basically in a very common digital output-based control pattern.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上处于一个非常常见的基于数字输出的控制模式。
- en: Let's check the code now.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查代码。
- en: Firmware controlling one servo using the Servo library
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Servo库控制一个伺服电机的固件
- en: Here is a firmware that provides a cyclic movement from 0 degrees to 180 degrees.
    It is also available in the `Chapter09/OneServo/` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个提供从0度到180度循环运动的固件。它也位于`Chapter09/OneServo/`文件夹中。
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first include the `Servo` library header.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含`Servo`库头文件。
- en: Then we instantiate a `Servo` object instance named `myServo`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实例化一个名为`myServo`的`Servo`对象实例。
- en: In the `setup()` block, we have to make something special. We attach pin 9 to
    the `myServo` object. This explicitly defines the pin as the control pin for the
    `Servo` instance `myServo`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`块中，我们必须做一些特别的事情。我们将引脚9连接到`myServo`对象。这明确地将引脚定义为`Servo`实例`myServo`的控制引脚。
- en: In the `loop()` block, we have two `for()` loops, and it looks like the previous
    example with the piezoelectric device. We define a cycle, progressively incrementing
    the angle variable from 0 to 180 and then decrementing it from 180 to 0, and each
    time we pause for 20 ms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`块中，我们有两个`for()`循环，看起来和之前的压电设备示例类似。我们定义一个循环，逐步增加角度变量从0到180，然后从180递减到0，每次我们暂停20毫秒。
- en: There is also a function not used here that I want to mention, `Servo.read()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个未使用的函数，我想提一下，`Servo.read()`。
- en: This function reads the current angle of the servo (that is, the value passed
    to the last call to `write()`). This can be useful if we are making some dynamic
    stuff without storing it at each turn.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数读取伺服电机的当前角度（即传递给`write()`的最后一个调用值）。如果我们不希望在每个循环中存储动态内容，这可能很有用。
- en: Multiple servos with external power supply
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部电源的多伺服电机
- en: Let's imagine we need three servos. As explained before, servos are motors,
    and motors convert current into movement, driving more current than other kinds
    of devices such as LEDs or sensors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们需要三个伺服电机。正如之前解释的，伺服电机是电机，电机将电流转换为运动，驱动比LED或传感器等其他设备更多的电流。
- en: If your Arduino project requires a computer, you can supply power to it with
    the USB as long as you don't go beyond the 500 mA limit. Beyond this, you'd need
    to use an external power supply for some or all parts of your circuit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Arduino项目需要电脑，你可以通过USB为其供电，只要不超过500 mA的限制。超过这个限制，你需要为电路的某些部分或全部使用外部电源。
- en: Let's see how it goes with three servos.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用三个伺服电机的情况。
- en: Three servos and an external power supply
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三个伺服电机和外部电源
- en: An external power supply can be batteries or a wall adapter power supply.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 外部电源可以是电池或墙壁适配器电源。
- en: We are going to use basic AA batteries here. This is also a way to supply Arduino
    if you don't need a computer and want Arduino to be autonomous. We will consider
    this option in the third part of this book about more advanced concepts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用基本的AA电池。这也是在没有电脑的情况下为Arduino供电的一种方式，如果你不需要电脑，想让Arduino独立运行。我们将在本书关于更高级概念的第三部分考虑这个选项。
- en: 'Let''s check the wiring for now:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们先检查一下接线：
- en: '![Three servos and an external power supply](img/7584_09_006.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![三个伺服电机和外部电源](img/7584_09_006.jpg)'
- en: Three servos wired to an Arduino, and power supplied by two AA batteries
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Arduino的三个伺服电机，并由两节AA电池供电
- en: In cases like this, we have to wire the grounds together. Of course, there is
    only one current source supply for the servos—the two AA batteries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须将地线连接在一起。当然，伺服电机只有一个电流源供应——两节AA电池。
- en: 'Let''s check the circuit diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下电路图：
- en: '![Three servos and an external power supply](img/7584_09_007.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![三个伺服电机和外部电源](img/7584_09_007.jpg)'
- en: Three servos, two AA batteries, and an Arduino
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 三个伺服电机，两节AA电池，和一个Arduino
- en: Driving three servos with firmware
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固件驱动三个伺服电机
- en: 'Here is an example of firmware for driving three servos:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是驱动三个伺服电机的固件示例：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This very minimal firmware is also available in the `Chapter09/Servos/` folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常基础的固件也位于`Chapter09/Servos/`文件夹中。
- en: We first instantiate our three servos and attach one pin for each in the `setup()`
    block.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实例化我们的三个伺服电机，并在`setup()`块中为每个电机连接一个引脚。
- en: In `loop()`, we play with angles. As a new approach for generative creation,
    I defined one variable only for the angle. This variable cyclically goes from
    0 to 180 in each `loop()` turn.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`函数中，我们玩转角度。作为一种新的生成性创作方法，我只为角度定义了一个变量。这个变量在每个`loop()`循环中循环地从0到180。
- en: The servo attached to pin 9 is driven with the angle value itself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到9号引脚的伺服电机使用角度值本身驱动。
- en: The servo attached to pin 10 is driven with the value [135-(angle/2)], varying
    itself from 135 to 45.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到10号引脚的伺服电机使用[135-（角度/2）]的值驱动，其值从135变化到45。
- en: Then, the servo attached to pin 11 is driven with the value [180-angle], which
    is the opposite movement of the servo attached to pin 9.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，连接到11号引脚的伺服电机使用[180-角度]的值驱动，这是连接到9号引脚的伺服电机的相反运动。
- en: This is also an example to show you how we can easily control one variable only,
    and program variations around this variable each time; here, we are making angles
    vary and we are combining the angle variable in different expressions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个示例，展示了我们如何轻松地只控制一个变量，并在每次编程时围绕这个变量进行变化；在这里，我们使角度变化，并将角度变量组合到不同的表达式中。
- en: Of course, we could control the servo position by using an external parameter,
    such as a potentiometer position or distance measured. This will combine concepts
    taught here with those in [Chapter 5](ch05.html "Chapter 5. Sensing with Digital
    Inputs"), *Sensing with Digital Inputs*, and [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Sensing the World–Feeling with Analog
    Inputs*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过使用外部参数来控制伺服位置，例如电位器位置或测量的距离。这将结合在这里教授的概念与第5章中教授的概念，*使用数字输入进行感应*，以及第6章中教授的概念，*通过模拟输入感知世界*。
- en: Let's learn a bit more about step motors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解步进电机。
- en: Controlling stepper motors
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制步进电机
- en: '**Stepper motor** is the common name for a **step motor**. They are motors
    that are controllable using small steps.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**步进电机**是**步进电机**的常用名称。它们是可以使用小步进行控制的电机。'
- en: The full rotation is divided into a number of equal steps and the motors' positions
    can be controlled to move and hold at one of these steps easily with a high degree
    of accuracy, without any feedback mechanism.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的旋转被分成多个相等的步，电机的位置可以很容易地控制，在其中一个步骤移动并保持，具有高精度，无需任何反馈机制。
- en: There are a series of electromagnetic coils that can be charged positively or
    negatively in a specific sequence. Controlling the sequence provides control about
    the movement, forward or backward in small steps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列电磁线圈，可以在特定顺序中充电为正或负。控制顺序提供了对运动，向前或向后以小步的控制。
- en: Of course, we can do that using Arduino boards.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用Arduino板来做这件事。
- en: We are going to examine the unipolar stepper here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里检查单极步进电机。
- en: Wiring a unipolar stepper to Arduino
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单极步进电机连接到Arduino
- en: 'Unipolar steppers usually consist of a center shaft part and four electromagnetic
    coils. We call them unipolar because power comes in through one pole. We can draw
    it as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单极步进电机通常由一个中心轴部分和四个电磁线圈组成。我们称其为单极，因为电源通过一个极进入。我们可以如下绘制：
- en: '![Wiring a unipolar stepper to Arduino](img/7584_09_010.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![将单极步进电机连接到Arduino的接线图](img/7584_09_010.jpg)'
- en: A six-pin unipolar step motor
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个六引脚单极步进电机
- en: Let's check how it can be wired to our Arduino.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它如何连接到我们的Arduino。
- en: We need to supply power to the stepper from an external source. One of the best
    practices here is the use of a wall adapter. Pins 5 and 6 have to be fed a source
    of current.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从外部电源为步进电机供电。这里的一个最佳实践是使用电源适配器。引脚5和6必须提供电流源。
- en: Then, we need to control each pin from 1 to 4 with the Arduino. This will be
    done using the sink current system ULN2004, which is very similar to ULN2003 which
    we used in the previous chapter with our LED matrix. ULN2004 is suited for voltage
    from 6 V to 15 V. When ULN2003 is 5 V, the stepper datasheet shows that we have
    to use this system instead of ULN2003.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用Arduino控制从1到4的每个引脚。这将通过ULN2004吸收电流系统来完成，它与我们在上一章中用于LED矩阵的ULN2003非常相似。ULN2004适用于6
    V至15 V的电压。当ULN2003为5 V时，步进电机数据表显示我们必须使用此系统而不是ULN2003。
- en: '![Wiring a unipolar stepper to Arduino](img/7584_09_008.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![将单极步进电机连接到Arduino的接线图](img/7584_09_008.jpg)'
- en: A unipolar stepper connected to Arduino through the Darlington transistor array,
    ULN2004
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过达林顿晶体管阵列ULN2004连接到Arduino的单极步进电机
- en: 'Let''s check the corresponding circuit diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查相应的电路图：
- en: '![Wiring a unipolar stepper to Arduino](img/7584_09_009.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![将单极步进电机连接到Arduino的接线图](img/7584_09_009.jpg)'
- en: A circuit diagram showing Arduino, the ULN2004 Darlington transistors array,
    and the stepper
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个电路图，显示了Arduino、ULN2004达林顿晶体管阵列和步进电机
- en: We are using an external power supply here again. All the grounds are wired
    together too.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里再次使用外部电源。所有地线也都连接在一起。
- en: Please notice that the **COM** pin (pin number 9) has to be wired to the power
    supply source (+V).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**COM**引脚（引脚编号9）必须连接到电源源（+V）。
- en: If you remember correctly from the previous chapter, when we fed an input of
    the ULN200x Darlington Transistor array, the corresponding output sinks the current
    to the ground.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能正确回忆起上一章的内容，当我们向ULN200x达林顿晶体管阵列输入时，相应的输出将电流吸收到地。
- en: In our case here, each pin of Arduino connected to the ULN2004 shift register
    can commute each pin of the stepper to the ground.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里，Arduino连接到ULN2004移位寄存器的每个引脚都可以使步进电机的每个引脚通向地。
- en: Let's design firmware for stepper control.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为步进电机控制设计固件。
- en: Firmware controlling the stepper motor
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制步进电机的固件
- en: There is a very nice library that can save us from providing sequences of the
    HIGH and LOW pins, considering the movements we want to drive.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常棒的库可以避免我们提供想要驱动的运动的 HIGH 和 LOW 引脚的序列。
- en: In order to control precise movements, we normally have to deal with specific
    sequences. These sequences are usually described in the datasheet.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制精确的运动，我们通常必须处理特定的序列。这些序列通常在数据表中描述。
- en: Let's check the one available at [http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf](http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个可用的 [http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf](http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf)。
- en: Sparkfun Electronics provides it for a model designed by Robotics.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Sparkfun 电子公司为机器人设计的模型提供了它。
- en: 'We can see a table similar to the following one, named **Drive Sequence Model**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个类似于以下表格的表格，命名为 **驱动序列模型**：
- en: '| STEP | A | B | C | D |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| STEP | A | B | C | D |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | HIGH | HIGH | LOW | LOW |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 1 | HIGH | HIGH | LOW | LOW |'
- en: '| 2 | LOW | HIGH | HIGH | LOW |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 2 | LOW | HIGH | HIGH | LOW |'
- en: '| 3 | LOW | LOW | HIGH | HIGH |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 3 | LOW | LOW | HIGH | HIGH |'
- en: '| 4 | HIGH | LOW | LOW | HIGH |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 4 | HIGH | LOW | LOW | HIGH |'
- en: If you want to make a clockwise rotation, you should generate a sequence from
    1 to 4, then 1, and so on, cyclically. Counterclockwise rotations require generating
    sequences from 4 to 1 and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进行顺时针旋转，你应该生成从 1 到 4 的序列，然后是 1，并循环。逆时针旋转需要生成从 4 到 1 的序列等。
- en: Instead of writing a lot of sequences like these, with some function, we can
    directly use the library named `Stepper`, which is now included in Arduino Core.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免编写大量这样的序列，我们可以使用一个函数，直接使用名为 `Stepper` 的库，该库现在包含在 Arduino 核心中。
- en: Here is the code, followed by the discussion. It is also available in the `Chapter09/StepperMotor/`
    folder.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码，后面是讨论。它也位于 `Chapter09/StepperMotor/` 文件夹中。
- en: '[PRE3]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We first include the `Stepper` library.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含 `Stepper` 库。
- en: Then we define the number of steps that are equivalent to one whole turn. In
    our datasheet, we can see that the first step is an angle of 1.8 degrees, with
    a 5 percent error room. We won't consider that error; we will take 1.8 degrees.
    This means we need 200 steps (200 * 1.8 = 360°) in order to make a whole turn.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义相当于一整圈的步数。在我们的数据表中，我们可以看到第一步的角度是 1.8 度，有 5% 的误差范围。我们不会考虑这个误差；我们将采用 1.8
    度。这意味着我们需要 200 步（200 * 1.8 = 360°）才能完成一整圈。
- en: We then instantiate a `Stepper` object by pushing five arguments, which are
    the step numbers for a whole turn, and the four pins of the Arduino wired to the
    stepper.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过推送五个参数实例化一个 `Stepper` 对象，这些参数是一个整圈的步数，以及连接到步进电机的 Arduino 的四个引脚。
- en: We then declare two helper variables for tracing and, sometimes, changing the
    rotation direction.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明两个辅助变量用于跟踪和有时改变旋转方向。
- en: In the `setup()` block, we usually define the speed of the current instance
    handling the stepper. Here, I have set `30` (which stands for 30 rounds per minute).
    This can also be changed in the `loop()` block, considering specific conditions
    or whatever.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 块中，我们通常定义当前实例处理步进电机的速度。这里，我设置为 `30`（代表每分钟30圈）。这也可以在 `loop()` 块中根据特定条件或任何其他情况更改。
- en: At last, in the `loop()` block, we move the stepper to an amount equal to the
    multiplier value, which is initially `1`. This means that at each run of the `loop()`
    method, the stepper rotates from step 1 (that is, 1.8 degrees) in the clockwise
    direction.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `loop()` 块中，我们将步进电机移动到乘数值相等的量，这个值最初是 `1`。这意味着在每次 `loop()` 方法的运行中，步进电机从顺时针方向的步
    1（即，1.8 度）开始旋转。
- en: I added a logic test, which checks each time if the counter has completed the
    number of steps required to make a whole turn. If it hasn't, I increment it; otherwise,
    as soon as it reaches the limit (that is, the motor makes a whole turn since the
    beginning of the program execution), I reset the counter and invert the multiplier
    in order to make the stepper continue its walk, but in the other direction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个逻辑测试，每次检查计数器是否完成了完成一整圈所需的步数。如果没有，我增加它；否则，一旦它达到限制（即，电机从程序执行开始以来完成了一整圈），我重置计数器并反转乘数，以便步进电机继续行走，但方向相反。
- en: This is another pattern that you should keep in mind. These are all small patterns
    that will give you a lot of cheap and efficient ideas to use in each one of your
    future projects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你应该记住的另一个模式。这些都是小模式，将为你提供很多便宜且高效的想法，可以在你未来的每个项目中使用。
- en: With servos and steppers, we can now make things move.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过伺服电机和步进电机，我们现在可以使物体移动。
- en: In some of my projects, I used two steppers, with one string bound to each and
    both these strings bound to a hanging pencil. We can draw on a wall by controlling
    the amount of string hanging on each side.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的某些项目中，我使用了两个步进电机，每个电机连接一根线，这两根线都连接到一个悬挂的铅笔上。我们可以通过控制每边的线悬挂量在墙上作画。
- en: Air movement and sounds
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空气运动和声音
- en: Making the air move can generate nice audible sounds, and we are going learn
    a bit more about this in the following sections.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使空气移动可以产生美妙的声音，我们将在接下来的几节中了解更多关于这方面的内容。
- en: If you can make things move with Arduino, you will probably be able to make
    the air move too.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够用Arduino控制物体移动，你很可能也能让空气移动。
- en: In fact, we have already done this, but we probably didn't move it enough to
    produce a sound.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们已经这样做了，但我们可能没有移动得足够多以产生声音。
- en: This part is just a short introduction to some definitions and not a complete
    course about sound synthesis. These are the basic elements that we will use in
    the next few sections of the book, and as far as possible there will be references
    of websites or books provided that you can refer to if you are interested in learning
    more about those specific parts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分只是对一些定义的简要介绍，而不是关于声音合成的完整课程。这些是我们将在本书的下一部分使用的基本元素，尽可能提供网站或书籍的参考，如果你对这部分内容感兴趣，可以进一步学习。
- en: What is sound actually?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音实际上是什么？
- en: Sound can be defined as a mechanical wave. This wave is an oscillation of pressure
    and can be transmitted through solid, liquid, or gas. By extension, we can define
    sound as the audible result of these oscillations on our ear.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 声音可以被定义为一种机械波。这种波是压力的振荡，可以通过固体、液体或气体传播。通过扩展，我们可以将声音定义为这些振荡在我们耳朵中可听到的结果。
- en: 'Our ear, combined with further brain processes, is an amazing air-pressure
    sensor. It is able to evaluate the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的耳朵，结合进一步的脑部处理，是一个惊人的空气压力传感器。它能够评估以下内容：
- en: Amplitude of a sound (related to the amount of air moving)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音的幅度（与空气移动量相关）
- en: Frequency of a sound (related to the air oscillation amount)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音的频率（与空气振荡量相关）
- en: Of course, all these processes are real time, assuming higher or lower frequencies
    mix at this particular moment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些过程都是实时的，假设更高或更低的频率在此时混合。
- en: I'd really suggest that you read the amazing and efficient introduction to *How
    Digital Audio Works?*, by cycling 74, the maker of the Max 6 framework. You can
    read it online at [http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio](http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的建议你阅读由Max 6框架的制作者cycling 74提供的令人惊叹且高效的介绍*数字音频是如何工作的？*，你可以在线阅读[http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio](http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio)。
- en: A sound can contain more than one frequency, and it is generally a combination
    of the frequency content and the global perception of each frequency amplitude
    that gives the feeling of what we call the timbre of a sound. Psychoacoustics
    studies the perception of sound.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个声音可以包含多个频率，通常是由频率内容以及每个频率振幅的总体感知组合，给我们带来我们称之为声音音色的感觉。心理声学研究声音的感知。
- en: How to describe sound
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何描述声音
- en: We can describe sound in many ways.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用许多方式描述声音。
- en: 'Usually, there are two representations of sound:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，声音有两种表示：
- en: Variation of the amplitude over time. This description can be put on a graph
    and defined as a time-domain representation of sounds.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时间变化的幅度。这种描述可以放在图表上，并定义为声音的时间域表示。
- en: Variation of the amplitude depending on the frequency content. This is called
    the frequency-domain representation of sounds.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幅度随频率内容的变化。这被称为声音的频域表示。
- en: There is a mathematical operation that provides an easy way to pass from one
    to the other, known as the Fourier transform ([http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)).
    Many implementations of this operation are available on computers, in the form
    of the **Fast Fourier Transform** (**FFT**), which is an efficient method that
    provides fast approximate calculations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种数学运算，提供了一种从一种表示转换到另一种表示的简单方法，称为傅里叶变换（[http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)）。计算机上有许多这种运算的实现，形式为**快速傅里叶变换**（**FFT**），这是一种高效的方法，可以提供快速的近似计算。
- en: Let's consider a sinusoidal variation of air pressure. This is one of the most
    simple sound waves.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑空气压力的正弦变化。这是最简单的声波之一。
- en: 'Here are the two representations in the two domains:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两个域中的两种表示：
- en: '![How to describe sound](img/7584_09_011.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![如何描述声音](img/7584_09_011.jpg)'
- en: Two representations of the same elementary sound produced by a sinusoidal variation
    of air pressure
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由空气压力的正弦变化产生的相同基本声音的两种表示。
- en: Let's describe the two graphs of the preceding image.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述前一张图像的两个图表。
- en: In the time-domain representation, we can see a cyclical variation with a period.
    The period is the time equivalent of the spatial wavelength.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在时域表示中，我们可以看到一个具有周期的周期性变化。周期是空间波长的等效时间。
- en: The period is the time needed to complete a complete vibrational cycle. Basically,
    if you can describe the variation over a period, you are able to totally draw
    the representation of the sound in time. Here, it is a bit obvious because we
    are watching a pure sine-based sound.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 周期是完成一个完整的振动周期所需的时间。基本上，如果你能描述一个周期内的变化，你就能完全绘制出声音在时间上的表示。在这里，这一点很明显，因为我们正在观察一个基于纯正弦的声音。
- en: If you draw and observe a sound produced by a source, the amplitude variation
    over time will correspond directly to a variation of air pressure.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绘制并观察由一个源产生的声音，时间上的振幅变化将直接对应于空气压力的变化。
- en: Considering the orientation of the axis, we first have what we call a high-pressure
    front. This is the part of the curve above zero (represented by the time axis).
    This means that the pressure is high and our tympanum is pushed a bit more inside
    our ear.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到轴的方向，我们首先有我们称之为高压前沿的部分。这是曲线在零点以上的部分（由时间轴表示）。这意味着压力高，我们的鼓膜在我们的耳朵内部被推得更多一些。
- en: Then, after a semi-period, the curve crosses zero and goes below, meaning that
    the air pressure is lower than the normal atmospheric pressure. Our tympanum also
    feels this variation. It is pulled a little bit.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在半周期之后，曲线穿过零点并下降，这意味着空气压力低于正常大气压力。我们的鼓膜也感受到了这种变化。它被稍微拉扯了一下。
- en: 'In the frequency-domain representation, there is only a vertical line. This
    pulse-like graph in the previous figure represents the unique frequency contained
    in this sine-based sound. It is directly related to its period by a mathematical
    equation, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在频域表示中，只有一条垂直线。前图中这种脉冲状的图形代表了基于正弦波的声音中包含的唯一频率。它通过一个数学方程与周期直接相关，如下所示：
- en: '![How to describe sound](img/7584_09_inline01.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![如何描述声音](img/7584_09_inline01.jpg)'
- en: Here, `T` is the period in seconds and `f` is the frequency in Hertz.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`T` 是秒内的周期，`f` 是赫兹内的频率。
- en: The higher the frequency, the more the sound is felt as high-pitched. The lesser
    it is, the more the sound is felt as low-pitched.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 频率越高，声音听起来越尖锐。频率越低，声音听起来越低沉。
- en: Of course, a high frequency means a short period and faster oscillations over
    time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，高频意味着短周期和随时间更快地振荡。
- en: These are the basic steps in understanding how sound can be represented and
    felt.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是理解声音如何被表示和感知的基本步骤。
- en: Microphones and speakers
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 麦克风和扬声器
- en: Microphones are devices that are sensitive to the subtle variation of air pressure.
    Yes, they are sensors. They can translate air-pressure variations into voltage
    variations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 麦克风是敏感于空气压力微妙变化的设备。是的，它们是传感器。它们可以将空气压力的变化转换为电压的变化。
- en: Speakers are devices that implement a part that can move, pushing and pulling
    masses of air, making it vibrate and produce sounds. The movement is induced by
    voltage variations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 扬声器是实施可以移动的部分的设备，推动和拉动空气的质量，使其振动并产生声音。这种运动是由电压变化引起的。
- en: 'In both these cases, we have:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们有：
- en: A membrane
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 膜
- en: An electrical transducer system
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电气传感器系统
- en: In the microphone case, we change the air pressure and that produces an electrical
    signal.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在麦克风的情况下，我们改变空气压力，这会产生一个电信号。
- en: In the speaker case, we change the electrical signal and that produces an air
    pressure variation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在扬声器的情况下，我们改变电信号，这会产生空气压力的变化。
- en: In each case, we have analog signals.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们都有模拟信号。
- en: Digital and analog domains
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字和模拟域
- en: Sounds sources can be very different. If you knock on a table, you'll hear a
    sound. This is a basic analog- and physical-based sound. Here, you physically
    make the table vibrate a bit, pushing and pulling air around it; and because you
    are near it, your tympanum feels these subtle variations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 声音源可以非常不同。如果你敲击桌子，你会听到声音。这是一种基于模拟和物理的声音。在这里，你使桌子稍微振动一下，推动和拉动周围的空气；因为你靠近它，你的鼓膜会感受到这些细微的变化。
- en: As soon as we talk about digital equipment, we have some limitations considering
    storage and memory. Even if these are large and sufficient now, they aren't infinite.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一提到数字设备，我们就必须考虑到存储和内存的限制。即使现在这些设备很大且足够，它们也不是无限的。
- en: And how can we describe something analog in that case? We already spoke about
    this situation when we described analog and digital input and output pins of Arduino.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那在这种情况下我们如何描述模拟的东西呢？当我们描述Arduino的模拟和数字输入输出引脚时，我们已经讨论了这种情况。
- en: How to digitalize sound
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何数字化声音
- en: Imagine a system that could sample the voltage variation of your microphones
    periodically. A sampling concept usually used is sample and hold.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个可以定期采样麦克风电压变化的系统。通常使用的采样概念是采样保持。
- en: The system is able to read the analog value at regular intervals of time. It
    takes a value, holds it as a constant until the next value, and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 系统能够在固定的时间间隔内读取模拟值。它取一个值，将其保持为常数，直到下一个值，依此类推。
- en: We are talking about the sampling rate to define the sampling frequency. If
    the sampling rate is low, we will have a lower approximation of the analog signal
    than if what we would have had if the sampling rate was high.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论采样率来定义采样频率。如果采样率低，我们将对模拟信号的近似将低于如果采样率高的话。
- en: A mathematical theorem provides us a limit that we have to keep in mind—the
    Nyquist frequency.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数学定理为我们提供了一个我们必须记住的限制——奈奎斯特频率。
- en: In order to keep our sampling system process a safe artifact induced by the
    system itself, we have to sample at a minimum of two times the higher frequency
    in our original analog signal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的采样系统处理由系统本身引起的最小安全文物，我们必须以至少是我们原始模拟信号中最高频率的两倍进行采样。
- en: '![How to digitalize sound](img/7584_09_012.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![如何数字化声音](img/7584_09_012.jpg)'
- en: Example illustrating the sampling rate while sampling a sine wave
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 采样正弦波时的采样率示例
- en: A higher sampling rate not only means more precision and fidelity to the original
    analog wave, but also more points to store in the digital system. The result would
    be a heavier file, in terms of disks and filesystems.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的采样率不仅意味着对原始模拟波的更高精度和保真度，而且意味着在数字系统中存储更多的点。结果将是文件更重，从磁盘和文件系统来看。
- en: Another element to keep in mind while sampling is the bit depth.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在采样时，还需要注意的一个要素是位深度。
- en: I voluntarily omitted it in the previous figure in order to not overload the
    drawings.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的图中自愿省略了它，以免使绘图过载。
- en: Indeed, we sampled a value over time, but how can you represent the value itself,
    the amplitude I mean? We use a bit-based coding system, as usual, with the digital
    equipment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在一段时间内采样了一个值，但如何表示这个值本身，我的意思是振幅呢？我们通常使用基于位的编码系统，使用数字设备。
- en: The **bit depth** is the resolution of the amplitude values from `-1` (the minimum
    possible) to `1` (the maximum possible).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**位深度**是幅度值的分辨率，从`-1`（可能的最小值）到`1`（可能的最大值）。'
- en: The higher the bit depth, the more the subtle variations we can encode and record
    into our digital systems. Conversely, if we have a very low bit-depth sampler
    and we make a progressively decreasing amplitude variation, the sound will decrease
    considerably in a manner similar to the Doppler effect. For instance, we wouldn't
    be able to distinguish values from `0.5` to `0.6`; everything would only be `0.5`
    or `0.7` but never `0.6`. The sound would lose subtlety.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 位深度越高，我们能够编码和记录到数字系统中的细微变化就越多。相反，如果我们有一个位深度非常低的采样器，并且我们进行逐渐减少的幅度变化，声音将显著减小，类似于多普勒效应。例如，我们无法区分`0.5`到`0.6`的值；一切都将只有`0.5`或`0.7`，但永远不会是`0.6`。声音将失去细微之处。
- en: Usual sampling rates and bit depth depends on the purpose of the final rendering.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的采样率和位深度取决于最终渲染的目的。
- en: 'Here are two commonly used quality standards:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个常用的质量标准：
- en: CD quality is 44.1 kHz and 16-bit
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD质量为44.1 kHz和16位
- en: DAT quality is 48 kHz and 16-bit
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAT质量为48 kHz和16位
- en: Some recording and mastering studios use audio interfaces and internal processing
    at 96 kHz and 24 bits. Some people who love old-school sound engines still use
    lo-fi systems to produce their own sound and music at 16 kHz and 8 bits.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一些录音和母带工作室使用 96 kHz 和 24 位的音频接口和内部处理。一些热爱复古音效引擎的人仍然使用低保真系统，以 16 kHz 和 8 位产生自己的声音和音乐。
- en: The process from analog to digital conversion is handled by the **analog to
    digital converter** (**ADC**). Its quality is the key to achieving good conversion.
    This process is similar to the one involved in Arduino when we use an analog input.
    Its ADC is 10 bits and it can read a value once every 111 microseconds, which
    is a sampling rate frequency of 9 kHz.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从模拟到数字转换的过程由**模拟到数字转换器**（**ADC**）处理。其质量是实现良好转换的关键。这个过程与我们在 Arduino 中使用模拟输入时涉及的过程类似。它的
    ADC 是 10 位，它可以每 111 微秒读取一个值，这相当于 9 kHz 的采样率频率。
- en: Buffers are used to smoothly process times and make things smoother in time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区用于平滑处理时间，使事物在时间上更加平滑。
- en: How to play digital bits as sounds
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何将数字比特作为声音播放
- en: We can also convert digital encoded sounds into analog sounds. This process
    is achieved by the **digital to analog converter** (**DAC**).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数字编码的声音转换为模拟声音。这个过程是通过**数字到模拟转换器**（**DAC**）实现的。
- en: If the processor sends bits of data from the encoded sound to the DAC as a continuous
    flow of discrete values, the DAC takes all these values and converts them as an
    analog electrical signal. It interpolates values between each digital value, which
    often involves some processes (for example, low-pass filtering), in order to remove
    some artifacts such as harmonics above the Nyquist frequency.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理器将编码声音的比特数据以连续的离散值流的形式发送到 DAC，那么 DAC 就会接收所有这些值并将它们转换为模拟电信号。它会在每个数字值之间插值，这通常涉及一些过程（例如，低通滤波），以消除一些如奈奎斯特频率以上的谐波等伪影。
- en: In the world of digital audio, DAC power and quality is one of the most important
    aspects of our audio workstation. They have to provide high resolutions, a high
    sampling rate, a small total harmonic distortion and noise, and a great dynamic
    range.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字音频的世界里，DAC 的功率和质量是我们音频工作站最重要的方面之一。它们必须提供高分辨率、高采样率、小的总谐波失真和噪声，以及极大的动态范围。
- en: How Arduino helps produce sounds
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino 如何帮助产生声音
- en: Let's come back to Arduino.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Arduino。
- en: Arduino can read and write digital signals. It can also read analog signals
    and simulate analog output signals through PWM.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 可以读取和写入数字信号。它还可以读取模拟信号，并通过 PWM 模拟模拟输出信号。
- en: Wouldn't it be able to produce and even listen to sounds? Of course it would.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它难道不能产生甚至听到声音吗？当然可以。
- en: We can even use some dedicated components to make things better. For instance,
    we can use an ADC with a higher sampling rate in order to store sounds and a high-quality
    DAC too, if required. Today, we often use electronic hardware equipment to control
    software. We can, for instance, build a device based on Arduino, full of knobs
    and buttons and interface it with a software on the computer. This has to be mentioned
    here.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用一些专用组件来改善事情。例如，我们可以使用采样率更高的 ADC 来存储声音，如果需要的话，还可以使用高质量的 DAC。今天，我们经常使用电子硬件设备来控制软件。例如，我们可以基于
    Arduino 构建一个设备，里面充满了旋钮和按钮，并将其与计算机上的软件接口。这一点必须在此提及。
- en: We can also use Arduino as a sound trigger. Indeed, it is quite easy to turn
    it into a small sequencer, popping out specific MIDI or OSC messages to an external
    synthesizer, for instance. Let's move further and go deeper into audio concepts
    specifically with the Arduino board.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 Arduino 用作声音触发器。实际上，将其转变为一个小型序列器相当简单，可以向外部合成器等设备发送特定的 MIDI 或 OSC 消息。让我们进一步深入，具体探讨
    Arduino 板的音频概念。
- en: Playing basic sound bits
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放基本声音片段
- en: Playing a sound requires a sound source and a speaker. Of course, it also requires
    a listener who is able to hear sounds.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 播放声音需要一个声音源和扬声器。当然，还需要一个能够听到声音的听众。
- en: Natively, Arduino is able to produce 8 kHz and 8-bit audio playback sounds on
    small PC speakers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 本地能够在小型电脑扬声器上产生 8 kHz 和 8 位音频回放声音。
- en: We are going to use the `tone()` function available natively in the Arduino
    Core. As written at [http://arduino.cc/en/Reference/Tone](http://arduino.cc/en/Reference/Tone),
    we have to take care of the pins used when using this function, because it will
    interfere with PWM output on pins 3 and 11 (except for the Arduino MEGA).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Arduino 内置的`tone()`函数。正如[http://arduino.cc/en/Reference/Tone](http://arduino.cc/en/Reference/Tone)中所述，在使用此函数时，我们必须注意所使用的引脚，因为它将干扰引脚
    3 和 11 上的 PWM 输出（Arduino MEGA 除外）。
- en: This technique is also named **bit-banging**. It is based on I/O pin toggling
    at a specific frequency.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也被称为**位打点**。它基于特定频率的 I/O 引脚切换。
- en: Wiring the cheapest sound circuit
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接最经济的音响电路
- en: We are going to design the cheapest sound generator ever with a small 8-ohm
    speaker, a resistor, and an Arduino board.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个使用小型 8 欧姆扬声器、电阻和 Arduino 板的史上最经济的声音发生器。
- en: '![Wiring the cheapest sound circuit](img/7584_09_013.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![连接最经济的音响电路](img/7584_09_013.jpg)'
- en: A small sound generator
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小型的声音发生器
- en: The connections made here ensure an audible sound. Let's program the chip now.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所做的连接确保了声音的可听性。现在让我们编程芯片。
- en: 'The corresponding circuit diagram is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电路图如下：
- en: '![Wiring the cheapest sound circuit](img/7584_09_014.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![连接最经济的音响电路](img/7584_09_014.jpg)'
- en: The diagram of the sound generator
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 声音发生器的示意图
- en: Playing random tones
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放随机音调
- en: As a digital artist and specifically as an electronic musician, I like to be
    free of the notes. I often use frequencies instead of notes; if you are interested,
    you can read about the microtonal concept at [http://en.wikipedia.org/wiki/Microtonal_music](http://en.wikipedia.org/wiki/Microtonal_music).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位数字艺术家，尤其是电子音乐家，我喜欢摆脱音符的束缚。我经常使用频率而不是音符；如果你感兴趣，可以阅读有关微音概念的资料[http://en.wikipedia.org/wiki/Microtonal_music](http://en.wikipedia.org/wiki/Microtonal_music)。
- en: In this example, we don't use notes but frequencies to define and trigger our
    electronic music.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不使用音符，而是使用频率来定义和触发我们的电子音乐。
- en: The code is also available in the `Chapter09/ ToneGenerator/` folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 代码也位于`Chapter09/ ToneGenerator/`文件夹中。
- en: '[PRE4]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We initialize the pseudorandom number generator at first by reading the analog
    input `0`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过读取模拟输入`0`来初始化伪随机数生成器。
- en: 'In the loop, we generate two numbers:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们生成两个数字：
- en: The pitch is a number from 30 to 4,999; this is the frequency of the sound
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音高是一个从 30 到 4,999 的数字；这是声音的频率
- en: The duration is a number from 1 ms to 1 s; this is the duration of the sound
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间是 1 毫秒到 1 秒之间的数字；这是声音的持续时间
- en: These two arguments are required by the `tone()` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数是`tone()`函数所必需的。
- en: Then, we call `tone()`. The first argument is the pin where you feed the speaker.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`tone()`。第一个参数是你给扬声器供电的引脚。
- en: The `tone()` function generates a square wave of the specified frequency on
    a pin as explained in its reference page at [http://arduino.cc/en/Reference/Tone](http://arduino.cc/en/Reference/Tone).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`tone()`函数在引脚上生成指定频率的方波，如其在[http://arduino.cc/en/Reference/Tone](http://arduino.cc/en/Reference/Tone)的参考页面中所述。'
- en: If we don't provide a duration, the sound continues until the `noTone()` function
    is called. The latter takes an argument that was used by the pin as well.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供持续时间，声音将继续播放，直到调用`noTone()`函数。后者接受一个与引脚相同的参数。
- en: Now, listen to and enjoy this microtonal pseudorandom melody coming from your
    8-bit chip.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请聆听并享受从你的 8 位芯片传来的微音伪随机旋律。
- en: Improving the sound engine with Mozzi
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mozzi 改进声音引擎
- en: 'The bit-banging technique is very cheap and it''s nice to learn how it works.
    However, I can quote some annoying things here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 位打点技术非常经济，学习它是件好事。然而，我这里可以引用一些令人烦恼的事情：
- en: '**No pure sound**: Square waves are a sum of all odd harmonics at the fundamental
    frequency'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有纯音**：方波是基频下所有奇次谐波的总和'
- en: '**No amplitude control available**: Each note sounds at the same volume'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有幅度控制可用**：每个音符都以相同的音量播放'
- en: We are going to use a very nice library called Mozzi, by Tim Barrass. The official
    website is directly hosted on GitHub at [http://sensorium.github.com/Mozzi/](http://sensorium.github.com/Mozzi/).
    It includes the `TimerOne` library, a very fast timer handler.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 Mozzi 的非常棒的库，由 Tim Barrass 编写。官方网站直接托管在 GitHub 上[http://sensorium.github.com/Mozzi/](http://sensorium.github.com/Mozzi/)。它包括`TimerOne`库，一个非常快速的定时器处理器。
- en: Mozzi provides a very nice 16,384 kHz, 8-bit audio output. There is also a nice
    basic audio toolkit containing oscillators, samples, lines and envelopes, and
    filtering too.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Mozzi 提供了一个非常棒的 16,384 kHz，8 位音频输出。它还包含一个很好的基本音频工具包，包括振荡器、样本、线条和包络，以及滤波器。
- en: Everything is available without external hardware and by only using two pins
    of the Arduino.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的内容都可以在没有外部硬件的情况下，仅使用Arduino的两个引脚获得。
- en: We are going to design a small sound engine based on it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于它设计一个小型声音引擎。
- en: Setting up a circuit and Mozzi library
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置电路和Mozzi库
- en: Setting up the circuit is easy; it is the same as the latest one except that
    pin 9 has to be used.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设置电路很简单；它与最新的电路相同，只是需要使用引脚9。
- en: 'Mozzi''s documentation says:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Mozzi的文档说明如下：
- en: To hear Mozzi, connect a 3.5 mm audio jack with the centre wire to the PWM output
    on Digital Pin 9* on Arduino, and the black ground to the Ground on the Arduino.
    Use this as a line out which you can plug into your computer and listen to with
    a sound program like Audacity.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要听Mozzi，将3.5毫米音频插头的中线连接到Arduino数字引脚9*上的PWM输出，将黑色地线连接到Arduino的地线。将其用作线路输出，您可以将其插入电脑并使用Audacity等声音程序进行收听。
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is really easy to set up the hardware. You can find many 3.5 mm audio jack
    connector like that all over the Internet. In the following circuit diagram, I
    put a speaker instead of a jack connector but it works exactly the same with a
    jack connector, that latter having 2 pins, one ground and one signal related.
    Ground has to be connected to the Arduino's ground and the other pin to the digital
    pin 9 of the Arduino.
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 硬件设置非常简单。您可以在互联网上找到许多类似的3.5毫米音频插头连接器。在下面的电路图中，我使用了一个扬声器而不是插头连接器，但使用插头连接器时效果完全相同，后者有2个引脚，一个地线和与信号相关的引脚。地线必须连接到Arduino的地线，另一个引脚连接到Arduino的数字引脚9。
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Then we have to install the library itself.
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后我们必须安装库本身。
- en: ''
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Download it from their website: [http://sensorium.github.com/Mozzi](http://sensorium.github.com/Mozzi)'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从他们的网站下载它：[http://sensorium.github.com/Mozzi](http://sensorium.github.com/Mozzi)
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unzip it and rename the folder as Mozzi.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解压它并将文件夹重命名为Mozzi。
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then put it as usual in the place you put your libraries; in my case it is:'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后将它放在通常放置库的位置；在我的情况下是：
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: /Users/julien/Documents/Arduino/libraries/
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: /Users/julien/Documents/Arduino/libraries/
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Restart or just start your Arduino IDE and you'll be able to see the library
    in the IDE.
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重新启动或仅启动Arduino IDE，您将能够在IDE中看到库。
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is provided with a bunch of examples.
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它提供了一系列示例。
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We are going to use the one about the sine wave.
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将使用正弦波相关的示例。
- en: 'This is what the Mozzi library looks like:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Mozzi库的外观：
- en: '![Setting up a circuit and Mozzi library](img/7584_09_015.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![设置电路和Mozzi库](img/7584_09_015.jpg)'
- en: A Mozzi installation revealing a lot of examples
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 展示大量示例的Mozzi安装
- en: An example sine wave
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个正弦波示例
- en: As with any library, we have to learn how to use the sine wave.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何库一样，我们必须学习如何使用正弦波。
- en: There are a lot of examples, and these are useful to learn how to design our
    own firmware step-by-step. Obviously, I won't describe all these examples, but
    only those in which I'll grab elements to make your own sound generator.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多示例，这些示例有助于我们逐步学习如何设计自己的固件。显然，我不会描述所有这些示例，但只会描述那些我将从中提取元素以制作您自己的声音发生器的示例。
- en: Let's check the sine wave example. It is also available in the `Chapter09/ MozziSoundGenerator/`
    folder.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下正弦波示例。它也位于`Chapter09/MozziSoundGenerator/`文件夹中。
- en: '[PRE5]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At first, some inclusions are done.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一些包含操作。
- en: '`MozziGuts.h` is the basic header to include in any case.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`MozziGuts.h` 是在任何情况下都应该包含的基本头文件。'
- en: '`Oscil.h` is the header to use if you need an oscillator.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Oscil.h` 是需要使用振荡器时应该使用的头文件。'
- en: We then include a wave table (sine wave).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们包含一个波表（正弦波）。
- en: Oscillators
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 振荡器
- en: In the sound synthesis world, an **oscillator** is a basic unit that is capable
    of producing oscillations. It is often used not only for direct sound generation
    with frequencies varying from 20 Hz to 20 kHz (audible spectrum), but also as
    a modulator (usually with frequencies lower than 50 Hz). It has been used as the
    latter in this case. An oscillator is usually called a **Low Frequency Oscillator**
    (**LFO**).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在声音合成领域，**振荡器**是一个能够产生振荡的基本单元。它不仅常用于直接生成频率从20 Hz到20 kHz（可听频谱）的声音，而且还作为调制器（通常频率低于50
    Hz）。在本例中，它被用作后者。振荡器通常被称为**低频振荡器**（**LFO**）。
- en: Wavetables
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 波表
- en: A **wavetable** is a very nice and efficient way to store whole pieces of sounds,
    generally cyclical or looped sounds.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**波表**是一种非常不错且高效的存储整个声音片段的方法，通常是循环或循环的声音。'
- en: We basically used this as a lookup table. Do you remember using it?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上将其用作查找表。你还记得使用它吗？
- en: Instead of calculating our sine value over time in real time, we basically precalculate
    each value of a whole period, and then add the results into a table; each time
    we need it, we just have to scan the table from the beginning to the end to retrieve
    each value.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在实时中计算正弦值，而是基本上预先计算整个周期的每个值，然后将结果添加到表中；每次需要时，我们只需从表头扫描到表尾以检索每个值。
- en: Of course, this IS definitely an approximation. But it saves a lot of CPU work.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这确实是一个近似值。但它节省了很多CPU工作。
- en: A wavetable is defined by its size, the sample rate related, and of course the
    whole values.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 波表由其大小、相关的采样率和当然整个值定义。
- en: 'Let''s check what we can find in the `sin2048_int8.h` file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`sin2048_int8.h`文件中我们可以找到什么：
- en: '![Wavetables](img/7584_09_016revised.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![波表](img/7584_09_016revised.jpg)'
- en: 'We can indeed find the number of cells: 2048 (that is, there are 2048 values
    in the table). Then, the sample rate is defined as 2048.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实可以找到单元格的数量：2048（即表中包含2048个值）。然后，采样率被定义为2048。
- en: Let's go back to the example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到例子。
- en: We then define the Oscil object that creates an oscillator.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义Oscil对象，它创建一个振荡器。
- en: After the second `define` keyword related to the variable update frequency,
    we have the usual structure of `setup()` and `loop()`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在与变量更新频率相关的第二个`define`关键字之后，我们有`setup()`和`loop()`的常规结构。
- en: We also have `updateControl()` and `updateAudio()` and those aren't defined
    in the code. Indeed, they are related to Mozzi and are defined in the library
    files themselves.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`updateControl()`和`updateAudio()`，这些在代码中未定义。实际上，它们与Mozzi相关，并在库文件中定义。
- en: The `setup()` block starts the Mozzi library at the specific control rate defined
    before. Then, we set up the oscillator defined before at a frequency of 440 Hz.
    440 Hz is the frequency of the universal A note. In this context, it can be thought
    of as the audio equivalent of the Hello World example.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`块在之前定义的特定控制率下启动Mozzi库。然后，我们将之前定义的振荡器设置为440 Hz的频率。440 Hz是通用A音符的频率。在这个上下文中，它可以被认为是音频的Hello
    World示例。'
- en: Nothing more about `updateControl()` here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`updateControl()`这里没有更多内容。
- en: We return `aSin.next()` in `updateAudio()`. It reads and returns the next sample,
    which is understood as the next element, which is the next bit of sound.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateAudio()`中返回`aSin.next()`。它读取并返回下一个样本，这被理解为下一个元素，也就是下一个声音片段。
- en: In `loop()`, we call the `audioHook()` function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`中，我们调用`audioHook()`函数。
- en: 'The global pattern is usual. Even if you use another library related to sound,
    inside or outside the Arduino world, you''ll have to deal with this kind of pattern
    in four steps (generally, but it may differ):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 全局模式是常规的。即使你使用与声音相关的另一个库，无论是Arduino世界内部还是外部，你也必须以四个步骤（通常如此，但可能有所不同）来处理这种模式：
- en: Definitions in the header with some inclusions
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标题中定义的带有一些包含的定义
- en: Start of the audio engine
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频引擎的开始
- en: Permanent loop of a hook
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子的永久循环
- en: Updating functions for rendering things before a commit, then in the hook
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交前更新渲染事物的函数，然后在钩子中
- en: If you upload this, you'll hear a nice A440 note, which may make you hum a little.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传这个，你会听到一个很棒的A440音符，这可能会让你哼唱起来。
- en: Frequency modulation of a sine wave
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正弦波的频率调制
- en: Let's now merge some concepts—sine wave generation, modulation, and input reading.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们合并一些概念——正弦波生成、调制和输入读取。
- en: We are going to use two oscillators, one modulating the frequency of the other.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个振荡器，一个调制另一个的频率。
- en: With a potentiometer, we can control the frequency of the modulating oscillator.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用电位器，我们可以控制调制振荡器的频率。
- en: Let's first improve the circuit by adding a potentiometer.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过添加电位器来改进电路。
- en: Adding a pot
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个电位器
- en: 'In the following circuit diagram, we have added a potentiometer in the sound
    generator circuit:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下电路图中，我们在声音发生器电路中添加了一个电位器：
- en: '![Adding a pot](img/7584_09_017.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个电位器](img/7584_09_017.jpg)'
- en: 'The circuit diagram is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图如下：
- en: '![Adding a pot](img/7584_09_018.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个电位器](img/7584_09_018.jpg)'
- en: Improving the sound generator
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 改进声音发生器
- en: Upgrading the firmware for input handling
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级固件以处理输入
- en: This code is also available in the `Chapter09/MozziFMOnePot/` folder.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码也位于`Chapter09/MozziFMOnePot/`文件夹中。
- en: '[PRE6]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we use two oscillators, both based on a cosine wavetable:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用两个振荡器，它们都基于余弦波表：
- en: '`aCos` stands for the sound itself'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aCos`代表声音本身'
- en: '`aVibrato` is the modulator'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aVibrato`是调制器'
- en: Since we have a potentiometer here, we need to scale things a bit.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们这里有一个电位器，我们需要稍微调整一下。
- en: '`intensityMax` is the maximum intensity of the modulation effect. I chose 500
    after testing it myself.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`intensityMax`是调制效果的强度最大值。我在测试后选择了500。'
- en: 'We often use the following technique to scale things: use a constant (or even
    a "real" variable) and then multiply it by the value you can vary. This can be
    done in one pass by using the `map()` function. We already used it in [Chapter
    6](ch06.html "Chapter 6. Sensing the World – Feeling with Analog Inputs"), *Sensing
    the World–Feeling with Analog Inputs*, for the same purpose—scaling an analog
    input value.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用以下技术来缩放事物：使用一个常数（甚至是一个“真实”变量），然后乘以你可以改变的价值。这可以通过使用`map()`函数在一遍中完成。我们已经在[第6章](ch06.html
    "第6章. 感知世界 – 使用模拟输入感受")，*感知世界 – 使用模拟输入感受*中为了同样的目的使用过它——缩放模拟输入值。
- en: In that case, at the maximum value, your potentiometer (more generally your
    input) changes the parameter you want to alter to its maximum value.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，在最大值时，你的电位器（更普遍地说，你的输入）将你想要改变的参数改变到最大值。
- en: Let's continue the review of the code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续审查代码。
- en: We define the potentiometer pin n and the variable `potPin`. We also define
    `potValue` to `0`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了电位器引脚n和变量`potPin`。我们还定义了`potValue`为`0`。
- en: In the `setup()` block, we start Mozzi. We define the frequency of the oscillator
    as `aCos`. The frequency itself is the result of the `mtof()` function. `mtof`
    stands for **MIDI to Frequency**.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`块中，我们启动Mozzi。我们将振荡器的频率定义为`aCos`。频率本身是`mtof()`函数的结果。`mtof`代表**MIDI
    to Frequency**。
- en: As we are going to describe it a bit later, MIDI protocol codes many bytes of
    values, including the pitch of notes it uses to transport from sequencers to instruments.
    Each MIDI note fits with real note values in the real world, and each note fits
    with a particular frequency. There are tables that show the frequency of each
    MIDI note, and Mozzi includes that for us.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要描述的，MIDI协议编码了许多字节的值，包括它用于从序列器传输到乐器所使用的音符音高。每个MIDI音符与真实世界中的实际音符值相对应，每个音符对应一个特定的频率。有一些表格显示了每个MIDI音符的频率，Mozzi为我们提供了这些信息。
- en: We can pass a MIDI note pitch as argument to the `mtof()` function, and it will
    return the right frequency. Here, we use the `random(21,80)` function to generate
    a MIDI note pitch from 21 to 79, which means from A0 to A5.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将MIDI音符的音高作为`mtof()`函数的参数传递，它将返回正确的频率。在这里，我们使用`random(21,80)`函数生成一个从21到79的MIDI音符音高，这意味着从A0到A5。
- en: Of course, this use case is a pretext to begin introducing MIDI. We could have
    directly used a `random()` function to generate a frequency.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个用例是开始介绍MIDI的一个前奏。我们本可以直接使用`random()`函数来生成频率。
- en: We then read the current value of the analog input A0 and use it to calculate
    a scaled value of the frequency of the modulating oscillator, `aVibrato`. This
    is only to provide more randomness and weirdness. Indeed, if your pot isn't at
    the same place each time you restart Arduino, you'll have a different modulation
    frequency.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们读取模拟输入A0的当前值，并使用它来计算调制振荡器频率的缩放值，即`aVibrato`。这只是为了提供更多的随机性和奇特感。实际上，如果你每次重启Arduino时电位器不在相同的位置，你将会有不同的调制频率。
- en: The `loop()` block then executes the `audioHook()` method constantly to produce
    audio.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`loop()`块会持续执行`audioHook()`方法以产生音频。
- en: And the smart thing here is the `updateControl()` method. We add the `analogRead()`
    function that reads the value of the analog input. Doing this in `updateControl()`
    is better, considering the purpose of this function. Indeed, the Mozzi framework
    separates the audio rendering time-critical tasks from the control (especially
    human control) pieces of code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 而这里聪明的地方在于`updateControl()`方法。我们添加了`analogRead()`函数来读取模拟输入的值。考虑到这个函数的目的，这样做更好。实际上，Mozzi框架将音频渲染时间关键任务与控制（特别是人类控制）代码部分分开。
- en: You'll come across this situation very often in many frameworks, and it can
    confuse you the first time. It is all about the task and its scheduling. Without
    reverse-engineering the Mozzi concepts here, I would like to say only that time-critical
    events have to be handled more carefully than human actions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多框架中，你经常会遇到这种情况，第一次可能会让你感到困惑。这全部关乎任务及其调度。在这里不逆向工程Mozzi的概念，我想说的是，时间关键事件必须比人类行为更加小心地处理。
- en: Indeed, even if it seems as if we can be very fast at turning a knob, it is
    really slow compared to the sample rate of Mozzi, for instance (16,384 kHz). This
    means we cannot stop the whole process only to test and check, if we change the
    value of this potentiometer constantly. Things are separated; keep this in mind
    and use the framework carefully.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使我们看起来可以非常快地转动旋钮，与Mozzi的采样率（16,384 kHz）相比，这实际上是非常慢的。这意味着我们不能只为测试和检查而停止整个过程，如果不断改变这个电位计的值。事情是分开的；请记住这一点并小心使用框架。
- en: Here, we read the value in `updateControl()` and store it in the `potValue`
    variable.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`updateControl()`中读取值并将其存储在`potValue`变量中。
- en: Then, in `updateAudio()`, we calculate the vibrato value as the value of `potValue`
    scaled from `0` to the value of `intensityMax`, multiplied by the next value of
    the oscillator in its wavetable.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`updateAudio()`中，我们计算颤音值，它是`potValue`的值从`0`到`intensityMax`的值缩放，乘以振荡器在其波形表中的下一个值。
- en: This value is then used in a new method named `phMod`. This method applies a
    phase modulation to the oscillator for which it is called. This modulation is
    a nice way to produce a frequency modulation effect.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值随后被用于一个名为`phMod`的新方法。此方法对其调用的振荡器应用相位调制。这种调制是产生频率调制效果的好方法。
- en: Now, upload the firmware, add the earphone, and turn the potentiometer. You
    should be able to hear the effect and control it with the potentiometer.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上传固件，添加耳机，转动电位计。你应该能够听到效果并用电位计控制它。
- en: Controlling the sound using envelopes and MIDI
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包络和MIDI控制声音
- en: We are now okay to design small bits of a sound engine using Mozzi. There are
    other libraries around, and what we learned will be used with those two. Indeed,
    these are patterns.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设计使用Mozzi的小部分声音引擎。还有其他库，我们学到的知识将用于这两个库。确实，这些是模式。
- en: Let's check how we can control our Arduino-based sound engine using a standard
    protocol from a computer or other device. Indeed, it would be interesting to be
    able to trigger notes to change sound parameters using a computer, for instance.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查如何使用来自计算机或其他设备的标准协议来控制基于Arduino的声音引擎。确实，能够使用计算机触发音符以改变声音参数将是非常有趣的，例如。
- en: Both are protocols used in the music and new media related projects and works.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是用于音乐和新媒体相关项目和作品中的协议。
- en: An overview of MIDI
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIDI概述
- en: '**MIDI** is short for **Musical Instrument Digital Interface**. It is a specification
    standard that enables digital music instruments, computers, and all required devices
    to connect and communicate with one another. It was introduced in 1983, and at
    the time of writing has just celebrated its 30th anniversary. The reference website
    is [http://www.midi.org](http://www.midi.org).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**MIDI**代表**Musical Instrument Digital Interface**。这是一个规范标准，它使数字音乐乐器、计算机和所有必需的设备能够相互连接和通信。它在1983年推出，在撰写本文时刚刚庆祝了它的30周年。参考网站是[http://www.midi.org](http://www.midi.org)。'
- en: 'MIDI can transport the following data over a basic serial link:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI可以通过基本串行链路传输以下数据：
- en: Notes (on/off, after touch)
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音符（开启/关闭、后触）
- en: Parameter changes (control change, program change)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数更改（控制更改、程序更改）
- en: Real-time messages (clock, transport state such as start/stop/continue)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时消息（时钟、传输状态如开始/停止/继续）
- en: System exclusives, allowing manufacturers to create their message
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统专用，允许制造商创建他们的消息
- en: 'A new protocol appeared and is used very widely today: OSC. It isn''t a proper
    protocol, by the way.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的协议出现了，并且现在被广泛使用：OSC。顺便说一下，它不是一个真正的协议。
- en: '**OSC** stands for **Open Sound Control** and is a content format developed
    by two people at the **Center for New Music and Audio Technologies** (**CNMAT**)
    at University of Berkeley, California. It was originally intended for sharing
    gestures, parameters, and sequences of notes during musical performances. It is
    very widely used as a replacement for MIDI today, providing a higher resolution
    and faster transfer. Its main feature is the native network transport possibility.
    OSC can be transported over UDP or TCP in an IP environment, making it easy to
    be used over Wi-Fi networks and even over the Internet.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**OSC**代表**Open Sound Control**，是由加州伯克利大学**新音乐与音频技术中心**（**CNMAT**）的两个人开发的内容格式。它最初是为了在音乐表演期间共享手势、参数和音符序列而设计的。它现在非常广泛地用作MIDI的替代品，提供更高的分辨率和更快的传输。其主要特点是本地的网络传输能力。OSC可以在IP环境中通过UDP或TCP传输，这使得它很容易在Wi-Fi网络上甚至通过互联网使用。'
- en: MIDI and OSC libraries for Arduino
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIDI和OSC库用于Arduino
- en: I'd suggest two libraries here. I tested them myself and they are stable and
    efficient. You can check the one about MIDI at [http://sourceforge.net/projects/arduinomidilib](http://sourceforge.net/projects/arduinomidilib).
    You can check this one about OSC at [https://github.com/recotana/ArdOSC](https://github.com/recotana/ArdOSC).
    You shouldn't have too many difficulties installing them now. Let's install at
    least MIDI, and restart the IDE.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在这里使用两个库。我自己测试过它们，它们是稳定且高效的。您可以在[http://sourceforge.net/projects/arduinomidilib](http://sourceforge.net/projects/arduinomidilib)上查看关于MIDI的库。您可以在[https://github.com/recotana/ArdOSC](https://github.com/recotana/ArdOSC)上查看关于OSC的库。现在安装它们应该不会太难。让我们至少安装MIDI，并重新启动IDE。
- en: Generating envelopes
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成包络
- en: In the audio field, an **envelope** is a shape used to modify something. For
    instance, imagine an amplitude envelope shaping a waveform.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在音频领域，**包络**是用来修改某物形状的一种。例如，想象一个振幅包络塑造波形。
- en: 'You have a waveform first. I generated this sine with Operator synthesizer
    in Ableton Live ([https://www.ableton.com](https://www.ableton.com)), the famous
    digital audio workstation. Here is a screenshot:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先有一个波形。我在Ableton Live的Operator合成器中生成这个正弦波（[https://www.ableton.com](https://www.ableton.com)），这是著名的数字音频工作站。以下是截图：
- en: '![Generating envelopes](img/7584_09_019.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![生成包络](img/7584_09_019.jpg)'
- en: A basic sine wave generated by an operator in Ableton Live's Operator FM synth
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由Ableton Live的Operator FM合成器中的运算符生成的基本正弦波
- en: 'The sine doesn''t show very well due to aliasing; here is another screenshot,
    which is the same wave but more zoomed in:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于混叠，正弦波显示得不是很好；这里还有另一个截图，这是相同的波形但放大了：
- en: '![Generating envelopes](img/7584_09_020.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![生成包络](img/7584_09_020.jpg)'
- en: A sine wave
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正弦波
- en: This sine wave has a global constant amplitude. Of course, the air pressure
    push and pull constantly, but the global maximums and minimums are constant over
    time.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正弦波具有全局恒定的振幅。当然，空气压力的推拉是不断变化的，但全局的最大值和最小值随时间保持恒定。
- en: Musicians always want to make their sounds evolve over time, subtly or harshly.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐家总是希望他们的声音随时间演变，无论是微妙还是强烈。
- en: 'Let''s apply an envelope to this same wave that will make it increase the global
    volume progressively, then decrease it a bit, and then decrease quickly to zero:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个包络应用到这个相同的波形上，使其全局音量逐渐增加，然后稍微减少，然后迅速减少到零：
- en: '![Generating envelopes](img/7584_09_021.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![生成包络](img/7584_09_021.jpg)'
- en: A sine wave altered by an envelope with a long attack
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由具有长攻击时间的包络改变的正弦波
- en: 'Here is the result with another envelope:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用另一个包络的结果：
- en: '![Generating envelopes](img/7584_09_022.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![生成包络](img/7584_09_022.jpg)'
- en: A sine wave altered by an envelope with a very short attack
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 由具有非常短攻击时间的包络改变的正弦波
- en: Basically, an envelope is a series of points in time. At each moment, we multiply
    the value of the original signal by the value of the envelope.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，包络是一系列时间点。在每一个时刻，我们将原始信号的值乘以包络的值。
- en: This produces a sound evolution over time.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了随时间变化的声音演变。
- en: We can use envelopes in many cases because they can modulate amplitude, as we
    just learned. We can also use them to alter the pitch (that is, the frequency)
    of a sound.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在许多情况下使用包络，因为它们可以调制振幅，正如我们刚刚学到的。我们还可以使用它们来改变声音的音高（即频率）。
- en: Usually, envelopes are triggered (that is, applied to the sound) at the same
    time the sound is triggered, but of course we can use the offset retrigger feature
    to retrigger the envelope during the same triggered sound and do much more.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，包络是在声音触发（即应用于声音）的同时触发的，但当然我们可以使用偏移重新触发功能在同一个触发声音期间重新触发包络，并做更多的事情。
- en: Here is a last example showing a pitch envelope. The envelope makes the frequency
    of the sound decrease. As you can see, the waves are tighter on the left than
    on the right. The sound changes from high-pitched to low-pitched.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最后的例子，展示了音高包络。包络使声音的频率降低。如您所见，左边的波比右边的波更紧密。声音从高音变为低音。
- en: '![Generating envelopes](img/7584_09_023.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![生成包络](img/7584_09_023.jpg)'
- en: An envelope modulating the pitch of a sound
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 调制声音音高的包络
- en: Implementing envelopes and MIDI
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现包络和MIDI
- en: We are going to design a very cheap sound synthesizer that will be able to trigger
    notes when it receives a MIDI note message and alter the sound when it receives
    a particular MIDI Control Change message.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要设计一个非常便宜的声音合成器，当它接收到MIDI音符消息时能够触发音符，并在接收到特定的MIDI控制更改消息时改变声音。
- en: The MIDI part will be handled by the library and the envelope will be explicated
    and coded.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI部分将由库处理，包络将被详细说明并编码。
- en: You can check the following code. This code is also available in the `Chapter09/MozziMIDI/`
    folder.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查以下代码。此代码也位于 `Chapter09/MozziMIDI/` 文件夹中。
- en: '[PRE7]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first, we include the MIDI library. Then we include the Mozzi library.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含MIDI库。然后我们包含Mozzi库。
- en: Of course, the right bits of Mozzi to include are a bit different for each project.
    Studying examples helps to understand what goes where. Here, we not only need
    Oscil for the basic features of the oscillator, but also need Line. Line is related
    to interpolation functions in Mozzi. Generating an envelope deals with this. Basically,
    we choose two values and a time duration, and it starts from the first one and
    reaches the second one in the time duration you choose.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个项目中需要包含的Mozzi的正确位略有不同。研究示例有助于理解它们的位置。在这里，我们不仅需要Oscil来提供振荡器的基本功能，还需要Line。Line与Mozzi中的插值函数相关。生成包络处理这个问题。基本上，我们选择两个值和一个时间持续时间，然后从第一个值开始，在所选的时间内达到第二个值。
- en: We also include the wavetable related to a sine.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了与正弦波相关的wavetable。
- en: We define a control rate higher than before, at 128\. That means the `updateControl()`
    function is called 128 times per second.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个比之前更高的控制速率，为128。这意味着 `updateControl()` 函数每秒被调用128次。
- en: Then we define the oscillator as `aSin`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将振荡器定义为 `aSin`。
- en: After these bits, we define an envelope by declaring an instance of the Line
    object.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些位之后，我们通过声明Line对象的实例来定义一个包络。
- en: We define two variables that store the release part of the envelope duration,
    one for the control part in one second (that is, the number of steps will be the
    value of `CONTROL_RATE`) and one for the audio part in one second too (that is,
    16,384 steps). Lastly, a variable named `fade_counter` is defined.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个变量来存储包络持续时间的释放部分，一个用于一秒内的控制部分（即步骤数将是 `CONTROL_RATE` 的值），另一个用于一秒内的音频部分（即16,384步）。最后，定义了一个名为
    `fade_counter` 的变量。
- en: '`HandleControlChange()` is a function that is called when a MIDI Control Change
    message is sent to Arduino. The message comes with these bytes:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleControlChange()` 是一个在向Arduino发送MIDI控制更改消息时被调用的函数。消息包含以下字节：'
- en: MIDI channel
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIDI通道
- en: CC number
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CC编号
- en: Value
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值
- en: These arguments are passed to the `HandleControlChange()` function, and you
    can access them directly in your code.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数传递给 `HandleControlChange()` 函数，你可以在你的代码中直接访问它们。
- en: This is a very common way to use event handlers. Almost all event listener frameworks
    are made like this. You have some function and you can use them and put whatever
    you want inside them. The framework itself handles the functions that have to
    be called, saving as much CPU time as possible.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常常见的使用事件处理程序的方式。几乎所有的事件监听器框架都是这样构建的。你有一些函数，你可以使用它们，并在其中放入你想要的任何内容。框架本身处理必须调用的函数，以尽可能节省CPU时间。
- en: Here, we add a `switch` statement with only one case over the `CCNumber` variable.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `CCNumber` 变量上添加一个只有一个情况的 `switch` 语句。
- en: This means if you send a MIDI Control Change 100 message, this case being matched,
    the value of `CC` will be processed and the `vol` variable will be altered and
    modified. This Control Change will control the master output volume of the synth.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你发送一个MIDI控制更改100消息，这个情况匹配，`CC` 的值将被处理，`vol` 变量将被更改和修改。这个控制更改将控制合成器的主输出音量。
- en: In the same way, `HandleNoteOn()` and `HandleNoteOff()` handle MIDI note messages.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`HandleNoteOn()` 和 `HandleNoteOff()` 处理MIDI音符消息。
- en: Basically, a MIDI Note On message is sent when you push a key on your MIDI keyboard.
    As soon as you release that key, a MIDI Note Off message pops out.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当你按下MIDI键盘上的键时，会发送一个MIDI音符开启消息。当你释放那个键时，就会弹出一个MIDI音符关闭消息。
- en: Here, we have two functions handling these messages.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个函数处理这些消息。
- en: '`HandleNoteOn()` parses the message, takes the velocity part, bit shifts it
    on the left to 8 bits, and passes it to `aGain` through the `set()` method. When
    a MIDI Note On message is received, the envelope `aGain` is triggered to its maximum
    value. When a MIDI Note Off message is received, the envelope is triggered to
    reach 0 in one second via the number of audio steps discussed before. The `fade`
    counter is also reset to its maximum value at the moment the key is released.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleNoteOn()` 解析消息，获取速度部分，将其左移8位，并通过 `set()` 方法传递给 `aGain`。当接收到MIDI音符开启消息时，包络
    `aGain` 被触发到最大值。当接收到MIDI音符关闭消息时，包络被触发在之前讨论的音频步骤数内达到0，耗时一秒。当键释放时，`fade` 计数器也会重置到最大值。'
- en: In this way, we have a system responding to the MIDI Note On and MIDI Note Off
    messages. When we push a key, a sound is produced until we release the key. When
    we release it, the sound decreases linearly to 0, taking one second.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有一个响应MIDI Note On和MIDI Note Off消息的系统。当我们按下键时，会产生声音，直到我们释放键。当我们释放它时，声音会线性衰减到0，耗时一秒。
- en: 'The `setup()` method includes the setup of the MIDI library:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`方法包括MIDI库的设置：'
- en: '`MIDI.begin()` instantiates the communication'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIDI.begin()`实例化通信'
- en: '`MIDI.setHandleControlChange()` lets you define the name of the function called
    when a control change message is coming'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIDI.setHandleControlChange()`允许您定义当控制变化消息到来时调用的函数名称'
- en: '`MIDI.setHandleNoteOn()` lets you define the name of the function called when
    a Note On message is coming'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIDI.setHandleNoteOn()`允许您定义当Note On消息到来时调用的函数名称'
- en: '`MIDI.setHandleNoteOff()` lets you define the name of the function called when
    a Note Off message is coming'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIDI.setHandleNoteOff()`允许您定义当Note Off消息到来时调用的函数名称'
- en: It also includes the setup of Mozzi.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括Mozzi的设置。
- en: The `loop()` function is quite familiar now.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数现在相当熟悉了。'
- en: The `updateControl()` function does not contain the time-critical part of the
    sound generator. It doesn't mean this function is called rarely; it is called
    less than `updateAudio()`—128 times per second for control and 16,384 per second
    for audio, as we have seen before.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateControl()`函数不包含声音生成器的关键部分。这并不意味着这个函数很少被调用；它调用次数少于`updateAudio()`——每秒控制128次，音频每秒16,384次，正如我们之前看到的。'
- en: This is the perfect place to read our MIDI flow, with the `MIDI.read()` function.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是阅读我们的MIDI流程的完美地方，使用`MIDI.read()`函数。
- en: This is where we can trigger our decreasing envelope to 0 as soon as the `fade`
    counter reaches 0 and not before, making the sound in one second, as we checked
    before.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以在`fade`计数器达到0时立即触发我们的衰减包络到0的地方，而不是在此之前，这样声音在一秒内就会像我们之前检查的那样。
- en: Lastly, the `updateAudio()` function returns the value of the oscillator multiplied
    by the envelope value too. This is the purpose of the envelope. Then, `vol` multiplies
    the first result in order to add a key to control the master output volume.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`updateAudio()`函数返回振荡器乘以包络值的值。这就是包络的目的。然后，`vol`乘以第一个结果，以便添加一个键来控制主输出音量。
- en: The `<<8` and `>>8` expressions here are for setting a high-resolution linear
    fade on Note Off, and this is a nice trick provided by Tim Barrass himself.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`<<8`和`>>8`表达式用于在Note Off时设置高分辨率线性淡入，这是Tim Barrass自己提供的一个好技巧。
- en: Wiring a MIDI connector to Arduino
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MIDI连接器连接到Arduino
- en: This schematic is based on the MIDI electrical specification diagram at [http://www.midi.org/techspecs/electrispec.php](http://www.midi.org/techspecs/electrispec.php).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原理图基于[MIDI电气规范图](http://www.midi.org/techspecs/electrispec.php)。
- en: '![Wiring a MIDI connector to Arduino](img/7584_09_024.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![将MIDI连接器连接到Arduino](img/7584_09_024.jpg)'
- en: The MIDI-featured sound generator based on Arduino
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Arduino的具有MIDI功能的音效生成器
- en: 'The corresponding circuit diagram is as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电路图如下：
- en: '![Wiring a MIDI connector to Arduino](img/7584_09_025.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![将MIDI连接器连接到Arduino](img/7584_09_025.jpg)'
- en: The MIDI connector wired to the Arduino-based sound generator
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到基于Arduino的音效生成器的MIDI连接器
- en: As you can see, the digital pin 0 (serial input) is involved. This means we
    won't be able to use the serial communication over USB. In fact, we want to use
    our MIDI interface.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数字引脚0（串行输入）被涉及。这意味着我们无法使用USB上的串行通信。实际上，我们想使用我们的MIDI接口。
- en: Let's upload the code and start this small sequencer in Max 6.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们上传代码，并在Max 6中启动这个小序列发生器。
- en: '![Wiring a MIDI connector to Arduino](img/7584_09_026.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![将MIDI连接器连接到Arduino](img/7584_09_026.jpg)'
- en: The *cheap sequencer for chips* fires MIDI notes and MIDI control changes
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '*芯片上的廉价序列发生器*可以触发MIDI音符和MIDI控制变化'
- en: The sequencer is quite self-explanatory. Toggle on the toggle button at the
    top-left and it starts the sequencer, reading each step in the multislider object.
    The higher a slider is, the higher the pitch of this note into that step will
    be.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 序列发生器相当直观。在左上角切换开切换按钮，它就会启动序列发生器，读取multislider对象中的每个步骤。滑块越高，这个音符进入该步骤的音高就越高。
- en: You can click on the button under the multislider on the left, and it will generate
    a random sequence of 16 elements.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以点击左侧multislider下的按钮，它将生成一个包含16个元素的随机序列。
- en: Choose the correct MIDI output bus from the list menu on the top-right.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 从右上角列表菜单中选择正确的MIDI输出总线。
- en: Connect your Arduino circuit and your MIDI interface with a MIDI cable, and
    listen to the music. Change the multislider content and the sequence played. If
    you turn the dial, the volume will change.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MIDI线将您的Arduino电路和MIDI接口连接起来，并聆听音乐。更改multislider内容以及播放的序列。如果您转动旋钮，音量将改变。
- en: Everything here is transmitted by MIDI. The computer is a sequencer and a remote
    controller and the Arduino is the synthesizer.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一切都是通过MIDI传输的。计算机是序列器和远程控制器，Arduino是合成器。
- en: Playing audio files with the PCM library
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PCM库播放音频文件
- en: Another way to play sounds is by reading already digitalized sounds.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种播放声音的方法是读取已经数字化的声音。
- en: Audio samples define digital content, often stored as files on filesystems that
    can be read and converted into audible sound.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 音频样本定义了数字内容，通常存储在可以读取和转换为可听声音的文件系统上。
- en: Samples can be very heavy from the memory size point of view.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存大小来看，样本可能非常庞大。
- en: We are going to use the PCM library set up by David A. Mellis from MIT. Like
    other collaborators, he is happy to be a part of this book.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由麻省理工学院的大卫·A·梅利斯（David A. Mellis）设置的PCM库。像其他合作者一样，他很高兴成为本书的一部分。
- en: The reference page is [http://hlt.media.mit.edu/?p=1963](http://hlt.media.mit.edu/?p=1963).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 参考页面是[http://hlt.media.mit.edu/?p=1963](http://hlt.media.mit.edu/?p=1963)。
- en: Download the library and install it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 下载库并安装它。
- en: Imagine that we have enough space in the Arduino memory spaces. How can we do
    the installation if we want to convert a sample on our disks as a C-compatible
    structure?
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在Arduino内存空间中有足够的空间。如果我们想在磁盘上以C兼容的结构转换样本，我们应该如何进行安装？
- en: The PCM library
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCM库
- en: Check this code. It is also available in the `Chapter09/PCMreader/` folder.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码。它也位于`Chapter09/PCMreader/`文件夹中。
- en: '![The PCM library](img/7584_09_027.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![PCM库](img/7584_09_027.jpg)'
- en: Our PCM reader
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的PCM读取器
- en: There is an array of `unsigned char` datatypes declared as `const`, and especially
    with the `PROGMEM` keyword named `sample`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个`unsigned char`数据类型的数组，被命名为`const`，特别是带有`PROGMEM`关键字的`sample`。
- en: '`PROGMEM` forces this constant to be put in the program space instead of RAM,
    because the latter is much smaller. Basically, this is the sample. The `startPlayback()`
    function is able to play a sample from an array. The `sizeof()` method calculates
    the size of the memory of the array.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROGMEM`强制将此常量放入程序空间而不是RAM中，因为后者要小得多。基本上，这就是样本。`startPlayback()`函数能够从数组中播放样本。`sizeof()`方法计算数组内存的大小。'
- en: WAV2C – converting your own sample
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WAV2C – 转换您的样本
- en: Since we have already played with wavetable, and this is what we will be doing
    hereafter, we can store our sample waveforms in the Arduino code directly.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经玩过wavetable，并且这是我们接下来要做的，我们可以直接在Arduino代码中存储我们的样本波形。
- en: Even if dynamic reading of the audio file from an SD card would seem smarter,
    PCM provides an even easier way to proceed—directly reading an analog conversion
    of an array while storing a waveform into a sound.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从SD卡动态读取音频文件看起来更智能，PCM提供了一种更简单的方法来处理——直接读取数组的模拟转换，并将波形存储到声音中。
- en: We first have to transform a sample as C data.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须将样本转换为C数据。
- en: David Ellis made an open source, small processing-based program that provides
    a way to do this; it can be found at [https://github.com/damellis/EncodeAudio](https://github.com/damellis/EncodeAudio).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·埃利斯（David Ellis）开发了一个开源的小型基于Processing的程序，提供了一种实现此功能的方法；它可以在[https://github.com/damellis/EncodeAudio](https://github.com/damellis/EncodeAudio)找到。
- en: You can download it from the reference project page directly compiled for your
    OS.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接从针对您的操作系统编译的参考项目页面下载它。
- en: Launch it, choose a WAV file (PCM-based encoded sample), and then it will copy
    something huge in your clipboard.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 启动它，选择一个WAV文件（基于PCM编码的样本），然后它将在您的剪贴板中复制大量内容。
- en: Then, you only have to copy-paste this content into the array defined before.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需将此内容复制粘贴到之前定义的数组中。
- en: Be careful to correctly paste it between the curly brackets.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 注意正确地将它粘贴在花括号之间。
- en: 'Here is the content copied from the clipboard after converting a `wav` sample
    that I made myself:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从我制作的`wav`样本转换后复制到剪贴板的内容：
- en: '![WAV2C – converting your own sample](img/7584_09_028.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![WAV2C – 转换您的样本](img/7584_09_028.jpg)'
- en: A huge amount of data to paste in a C array
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 要粘贴到C数组中的大量数据
- en: In the same folder, I have put a `.wav` file I designed. It is a short rhythm
    recorded in 16 bits.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹中，我放置了一个我设计的`.wav`文件。它是一个16位记录的简短节奏。
- en: Wiring the circuit
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布线电路
- en: The circuit is similar to the one in the *Playing basic sound bits* section,
    except that we have to use the digital pin 11 here. And we cannot use PWM on pins
    3, 9, and 10 because the timers involved in the library consume them.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 电路与“播放基本声音片段”部分中的电路类似，但在这里我们必须使用数字引脚11。而且我们不能在引脚3、9和10上使用PWM，因为库中涉及的定时器消耗了这些引脚。
- en: '![Wiring the circuit](img/7584_09_029.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![连接电路](img/7584_09_029.jpg)'
- en: Wiring our PCM reader
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 连接我们的PCM读取器
- en: The circuit diagram is easy too.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图也很简单。
- en: '![Wiring the circuit](img/7584_09_030.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![连接电路](img/7584_09_030.jpg)'
- en: Don't forget to use pin 11 with the PCM library
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用PCM库中的引脚11
- en: Now, let's play the music.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们播放音乐。
- en: Other reader libraries
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他读取库
- en: There are also other libraries providing ways to read and decode the MP3 format
    or other formats.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他库提供了读取和解码MP3格式或其他格式的途径。
- en: You can find a lot on the Internet; but be careful as some of them require some
    shields, like the one on the Sparkfun website at [https://www.sparkfun.com/products/10628](https://www.sparkfun.com/products/10628).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在互联网上找到很多；但请注意，其中一些需要一些保护罩，比如Sparkfun网站上的[https://www.sparkfun.com/products/10628](https://www.sparkfun.com/products/10628)。
- en: This provides a shield with an SD Card reader, a 3.5 mm stereo headphone jack,
    a VS1053 shift register, and very versatile decoder chips for MP3, WMA, AAC, and
    other formats.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个带有SD卡读取器、3.5毫米立体声耳机插孔、VS1053移位寄存器和非常通用的解码器芯片（用于MP3、WMA、AAC和其他格式）的保护罩。
- en: It is a very dedicated solution and we only have to interface the shield with
    Arduino.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常专业的解决方案，我们只需要将保护罩与Arduino连接即可。
- en: Arduino only sends and receives bits from the shield, which takes care of the
    decoding of the encoded files, the conversion to analog signals, and so on.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino只从保护罩发送和接收位，保护罩负责解码编码文件、转换为模拟信号等。
- en: I'd really suggest testing it. There are many examples on the Sparkfun website.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的建议你测试一下。Sparkfun网站上有很多示例。
- en: Summary
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We learned how to make things move right here with Arduino. In particular,
    we learned about:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里学习了如何使用Arduino让物体移动。特别是，我们学习了以下内容：
- en: Moving solid things with motors
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电机移动固体物体
- en: Moving air with sound generators
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声音发生器移动空气
- en: Of course, unfortunately, I cannot describe more on how to make things move.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，遗憾的是，我无法更多地描述如何让物体移动。
- en: If you need help with sound, please contact me at `<[book@cprogrammingforarduino.com](mailto:book@cprogrammingforarduino.com)>`.
    I will be a happy to help you with sound inputs too, for instance.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于声音的帮助，请通过电子邮件[book@cprogrammingforarduino.com](mailto:book@cprogrammingforarduino.com)联系我。我很乐意帮助你处理声音输入，例如。
- en: This is the end of the second part of the book. We discovered a lot of concepts
    together. And now we are going to dig into some more advanced topics.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书第二部分的结束。我们一起发现了许多概念。现在我们将深入研究一些更高级的主题。
- en: We are able to understand firmware design and inputs and outputs, so let's move
    further.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够理解固件设计和输入输出，所以让我们继续前进。
- en: We are going to dig deeper into precise examples with I2C/SPI communication
    to use GPS modules, 7-segment LED systems, and more. We are also going to dig
    into Max 6, and especially how we can use Arduino to control some OpenGL visuals
    on the computer. We'll discover network protocols and how to use Arduino even
    without any network cables, with Wi-Fi. At last, we'll design a small library
    together and check some nice tips and tricks to improve our C code.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地探讨使用I2C/SPI通信的精确示例，以使用GPS模块、7段LED系统等。我们还将深入研究Max 6，特别是如何使用Arduino控制计算机上的某些OpenGL视觉。我们将发现网络协议，以及如何使用Wi-Fi在没有网络线的情况下使用Arduino。最后，我们将一起设计一个小型库，并检查一些不错的技巧和窍门来改进我们的C代码。
