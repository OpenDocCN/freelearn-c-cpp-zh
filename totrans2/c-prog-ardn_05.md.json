["```cpp\n// some declarations / definitions\nint particlesNumber = 80;    // particles number\nfloat[] positionsX = new float[particlesNumber]; // store particles X-coordinates float[] positionsY = new float[particlesNumber]; // store particles Y-coordinates\nfloat[] radii = new float[particlesNumber];      // store particles radii\nfloat[] easings = new float[particlesNumber];    // store particles easing amount\n\n// setup is run one time at the beginning\nvoid setup() {\n  size(600, 600); // define the playground\n  noStroke();     // define no stroke for all shapes drawn\n\n  // for loop initializing easings & radii for all particles\n  for (int i=0 ; i < particlesNumber ; i++)\n  {\n    easings[i] = 0.04 * i / particlesNumber;  // filling the easing array\n    radii[i] = 30 * i / particlesNumber ;     // filling the radii array\n  }\n}\n\n// draw is run infinitely\nvoid draw() {\n  background(34);  // define the background color of the playground\n\n  // let's store the current mouse position\n  float targetX = mouseX;  \n  float targetY = mouseY;\n\n  // for loop across all particles\n  for (int i=0 ; i < particlesNumber ; i++)\n  {\n\n    float dx = targetX - positionsX[i];  // calculate X distance mouse / particle\n    if (abs(dx) > 1) {                   // if distance > 1, update position\n      positionsX[i] += dx * easings[i];\n    }\n\n    float dy = targetY - positionsY[i];    // same for Y\n    if (abs(dy) > 1) {\n      positionsY[i] += dy * easings[i];\n    }\n    // change the color of the pencil for the particle i\n    fill(255 * i / particlesNumber);\n\n    // draw the particle i\n    ellipse(positionsX[i], positionsY[i], radii[i], radii[i]);\n  }\n}\n```", "```cpp\nconst int switchPin = 2;     // pin of the digital input related to the switch\nconst int ledPin =  13;      // pin of the board built-in LED\n\nint switchState = 0;         // storage variable for current switch state\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output\n  pinMode(switchPin, INPUT); // the switch pin is setup as an input\n}\n\nvoid loop(){\n  switchState = digitalRead(switchPin);  // read the state of the digital pin 2\n\n  if (switchState == HIGH) {     // test if the switch is pushed or not\n\n    digitalWrite(ledPin, HIGH);  // turn the LED ON if it is currently pushed\n  }\n  else {\n    digitalWrite(ledPin, LOW);   // turn the LED OFF if it is currently pushed\n  }\n}\n```", "```cpp\nimport processing.serial.*;\n\nSerial theSerialPort;            // create the serial port object\nint[] serialBytesArray = new int[2];  // array storing current message\nint switchState;                 // current switch state\nint switchID;                    // index of the switch\nint bytesCount = 0;              // current number of bytes relative to messages\nboolean init = false;            // init state\nint fillColor = 40;              // defining the initial fill color\n\nvoid setup(){\n\n  // define some canvas and drawing parameters\n  size(500,500);\n  background(70);\n  noStroke();\n\n  // printing the list of all serial devices (debug purpose)\n  println(Serial.list());\n\n  // On osx, the Arduino port is the first into the list\n  String thePortName = Serial.list()[0];\n\n  // Instantate the Serial Communication\n  theSerialPort = new Serial(this, thePortName, 9600);\n}\n\nvoid draw(){\n\n  // set the fill color\n  fill(fillColor);\n\n  // draw a circle in the middle of the screen\n  ellipse(width/2, height/2, 230, 230);\n}\n\nvoid serialEvent(Serial myPort) {\n\n  // read a byte from the serial port\n  int inByte = myPort.read();\n\n  if (init == false) {         // if there wasn't the first hello\n    if (inByte == 'Z') {       // if the byte read is Z\n      myPort.clear();          // clear the serial port buffer\n      init = true;             // store the fact we had the first hello\n      myPort.write('Z');       // tell the Arduino to send more !\n    } \n  } \n  else {                       // if there already was the first hello\n\n    // Add the latest byte from the serial port to array\n    serialBytesArray[bytesCount] = inByte;\n    bytesCount++;\n\n    // if the messages is 2 bytes length\n    if (bytesCount > 1 ) {\n      switchID = serialBytesArray[0]; // store the ID of the switch\n      switchState = serialBytesArray[1]; // store the state of the switch\n\n      // print the values (for debugging purposes):\n      println(switchID + \"\\t\" + switchState);\n\n      // alter the fill color according to the message received from Arduino\n      if (switchState == 0) fillColor = 40;\n      else fillColor = 255;\n\n      // Send a capital Z to request new sensor readings\n      myPort.write('Z');\n\n      // Reset bytesCount:\n      bytesCount = 0;\n    }\n  }\n}\n```", "```cpp\nswitchID = serialBytesArray[0]; \nswitchState = serialBytesArray[1];\n```", "```cpp\nconst int switchPin = 2;     // pin of the digital input related to the switch\nint switchState = 0;         // storage variable for current switch state\n\nvoid setup() {\n  pinMode(switchPin, INPUT); // the switch pin is setup as an input\n}\n\nvoid loop(){\n    switchState = digitalRead(switchPin); \n}\n```", "```cpp\nconst int switchPin = 2;     // pin of the digital input related to the switch\nint switchState = 0;         // storage variable for current switch state\nint inByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(switchPin, INPUT); // the switch pin is setup as an input\n  sayHello();\n}\n\nvoid loop(){\n\n  // if a valid byte is received from processing, read the digital in.\n  if (Serial.available() > 0) {\n    // get incoming byte:\n    inByte = Serial.read();\n    switchState = digitalRead(switchPin); \n\n    // send switch state to Arduino\n    Serial.write(\"0\");\n    Serial.write(switchState);\n  }\n}\n\nvoid sayHello() {\n  while (Serial.available() <= 0) {\n    Serial.print('Z');   // send a capital Z to Arduino to say \"HELLO!\"\n    delay(200);\n  }\n}\n```", "```cpp\n#define switchesNumber 3             // define the number of switches as a constant\n\nint switchesStates[switchesNumber] ; // array storing current switches states\nint inByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n\n  // initiating each pins as input and filling switchesStates with zeroes\n  for(int i = 0 ; i < switchesNumber ; i++)\n  {\n// BE CAREFUL TO THAT INDEX\npinMode(i + 2, INPUT); // the switch pin is setup as an input\n\n    switchesStates[i] = 0 ;\n  }\n\n  sayHello(); // waiting for the processing program hello answer\n}\n\nvoid loop(){\n\n  // if a valid byte is received from processing, read all digital inputs.\n  if (Serial.available() > 0) {\n\n    // get incoming byte\n    inByte = Serial.read();\n\n    for(int i = 0 ; i < switchesNumber ; i++)\n    {\n      switchesStates[i] = digitalRead(i+2); // BE CAREFUL TO THAT INDEX\n   // WE ARE STARTING FROM PIN 2 !\n      Serial.write(i);                 // 1st byte = switch number (0 to 2)\n      Serial.write(switchesStates[i]); // 2nd byte = the switch i state\n    }\n  }\n}\n\nvoid sayHello() {\n  while (Serial.available() <= 0) {\n    Serial.print('Z');   // send a capital Z to Arduino to say \"HELLO!\"\n    delay(200);\n  }\n}\n```", "```cpp\nimport processing.serial.*;\n\nint switchesNumber = 2;\n\nSerial theSerialPort;                 // create the serial port object\nint[] serialBytesArray = new int[2];  // array storing current message\nint switchID;                         // index of the switch\nint[] switchesStates = new int[switchesNumber]; // current switch state\nint bytesCount = 0; // current number of bytes relative to messages\nboolean init = false;                 // init state\nint fillColor = 40;                   // defining the initial fill color\n\n// circles display stuff\nint distanceCircles ;\nint radii;\n\nvoid setup() {\n\n  // define some canvas and drawing parameters\n  size(500, 500);\n  background(70);\n  noStroke();\n  distanceCircles = width / switchesNumber;\n  radii = distanceCircles/2;\n\n  // printing the list of all serial devices (debug purpose)\n  println(Serial.list());\n\n  // On osx, the Arduino port is the first into the list\n  String thePortName = Serial.list()[0];\n\n  // Instantate the Serial Communication\n  theSerialPort = new Serial(this, thePortName, 9600);\n\n  for (int i = 0 ; i < switchesNumber ; i++)\n  {\n    switchesStates[i] = 0;\n  }\n}\n\nvoid draw() {\n\n  for (int i = 0 ; i < switchesNumber ; i++)\n  {\n    if (switchesStates[i] == 0) fill(0);\n    else fill(255);\n\n    // draw a circle in the middle of the screen\n    ellipse(distanceCircles * (i + 1) - radii, height/2, radii, radii);\n  }\n}\n\nvoid serialEvent(Serial myPort) {\n\n  // read a byte from the serial port\n  int inByte = myPort.read();\n\n  if (init == false) {         // if this is the first hello\n    if (inByte == 'Z') {       // if the byte read is Z\n      myPort.clear();          // clear the serial port buffer\n      init = true;             // store the fact we had the first hello\n      myPort.write('Z');       // tell the Arduino to send more !\n    }\n  }\n  else {                       // if there already was the first hello\n\n    // Add the latest byte from the serial port to array\n    serialBytesArray[bytesCount] = inByte;\n    bytesCount++;\n\n    // if the messages is 2 bytes length\n    if (bytesCount > 1 ) {\n      switchID = serialBytesArray[0];      // store the ID of the switch\n      switchesStates[switchID] = serialBytesArray[1]; // store state of the switch\n\n      // print the values (for debugging purposes):\n      println(switchID + \"\\t\" + switchesStates[switchID]);\n      // Send a capital Z to request new sensor readings\n      myPort.write('Z');\n\n      // Reset bytesCount:\n      bytesCount = 0;\n    }\n  }\n}\n```", "```cpp\nconst int switchPin = 2;     // pin of the digital input related to the switch\nconst int ledPin =  13;      // pin of the board built-in LED\n\nint switchState = 0;         // storage variable for current switch state\nint lastSwitchState= LOW;\n\n// variables related to the debouncing system\nlong lastDebounceTime = 0;\nlong debounceDelay = 50;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output\n  pinMode(switchPin, INPUT); // the switch pin is setup as an input\n}\n\nvoid loop(){\n\n  // read the state of the digital pin\n  int readInput = digitalRead(switchPin);\n\n  // if freshly read state is different than the last debounced value\n  if (readInput != lastSwitchState){\n   // reset the debounce counter by storing the current uptime ms\n   lastDebounceTime = millis();\n  }\n\n  // if the time since the last debounce is greater than the debounce delay\n  if ( (millis() - lastDebounceTime) > debounceDelay ){\n   // store the value because it is a debounced one and we are safe\n   switchState = readInput;\n  }\n\n  // store the last read state for the next loop comparison purpose\n  lastSwitchState = readInput;\n\n  // modify the LED state according to the switch state\n  if (switchState == HIGH)\n  {     // test if the switch is pushed or not\n\n    digitalWrite(ledPin, HIGH);  // turn the LED ON if it is currently pushed\n  }\n  else\n  {\n    digitalWrite(ledPin, LOW);   // turn the LED OFF if it is currently pushed\n  }\n}\n```"]