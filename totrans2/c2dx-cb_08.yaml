- en: Chapter 8. Working with Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the processing using the platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the acceleration sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the screen on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting dpi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the maximum texture size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d-x has a lot of APIs. However, there are no APIs that we need, for example,
    In-App purchase, push notification, and so on. In this case, we have to create
    original APIs and need to write Objective-C code for iOS or Java code for Android.
    In addition, we want to get the device information that it is running on. When
    we want to adjust for each device, we have to get the device information such
    as the running application version, device name, dpi on device, and so on. However,
    doing so is very difficult and confusing. In this chapter, you can write the native
    code for iOS or Android and get the device information.
  prefs: []
  type: TYPE_NORMAL
- en: Using native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Cocos2d-x, you can write one source for the cross platform. However, you
    have to write an Objective-C function or a Java function for the dependency process
    such as a purchase or push notification. If you want to call Java for Android
    from C++, you have to use **JNI** (**Java Native Interface**). In particular,
    JNI is very confusing. To call Java from C++, you have to use JNI. In this recipe,
    we will explain how to call an Objective-C function or a Java function from C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we will make a new class called `Platform`. You can get the application
    version by using this class. Before writing code, you will make three files called
    **Platform.h**, **Platform.mm**, and **Platform.cpp** in your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B0561_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important that you don't add `Platform.cpp` to **Compile Sources** in
    Xcode. That's why `Platform.cpp` is for an Android target and doesn't need to
    be built for iOS. If you added it to **Compile Sources**, you have to remove it
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B0561_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you have to make a header file called `Platform.h` by using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have to make an execution file called `Platform.mm` for iOS. This code is
    in Objective-C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You have to make an execution file called `Platform.cpp` for Android. The following
    code is in C++ and uses Java through JNI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have to edit `proj.android/jni/Android.mk` to build for Android when you
    added a new class file in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, you have to write Java code in `AppActivity.java`. This file is named
    `pro.android/src/org/cocos2dx/cpp/AppActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can get a version of your game by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we will look at it for iOS. You will be able to get a version of your
    game by using Objective-C in `Platform.mm`. You can write C++ and Objective-C
    in the `.mm` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will look for Android. When you call `Platform::getAppversion` on Android
    devices, the method in `Platform.cpp` is executed. In this method, you can call
    the `getAppVersionInJava` method in `AppActivity.java`. by using JNI. C++ can
    connect Java via JNI. That's why you can only get the application version by using
    Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java, you can get the version of your application by using the `onCreate`
    method. You can set it to a static variable and then, get it from the `getAppVersionInJava`
    method in Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use JNI easily by using the `JniHelper` class in Cocos2d-x. How this
    class manages typos from C++ and creates a bridge between C++ and Java has already
    been explained. You can use the `JniHelper` class by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can get the information about the Java method by using `JniHelper::getStaticMethodInfo`.
    The first argument is a variable of `JniMethodInfo`. The second argument is the
    name of the class that has the method you want to call. The third argument is
    the method name. The last argument is the parameter of this method. This parameter
    is decided by the return value and the arguments. The characters in the bracket
    are the parameters for the Java method. In this case, this method has no parameters.
    The characters after the bracket are the return value. `Ljava/lang/String` means
    that the return value is a string. If you get this parameter easily, you should
    use the command called `javap`. As the following result will be generated by using
    this command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From the above result, you can see that the parameter for the `getAppVersionInJava`
    method is `()Ljava/lang/String`;
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, you can get the information of the Java method as a `t`
    variable. So, you can call the Java method by using this variable and the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Changing the processing using the platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can make the program run on specific parts of the source code for each OS.
    For example, you will change the file name, the file path, or the image scale
    by the platform. In this recipe, we will introduce the branching code based on
    the platform of choice in the case of a complication.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can change the processing by using the preprocessor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cocos2d-x defined the `CC_TARGET_PLATFORM` value in `CCPlatformConfig.h`. If
    your game is compiled for Android devices, `CC_TARGET_PLATFORM` is equal to `CC_PLATFORM_ANDROID`.
    If it is compiled for iOS devices, `CC_TARGET_PLATFORM` is equal to `CC_PLATFORM_IOS`.
    Needless to say, there are other values besides Android and iOS. Please check
    `CCPlatformConfig.h`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code that was used in the preprocessor is difficult to read on an editor.
    Further, you cannot notice the error before compiling your code. You should define
    a constant value that can be changed by the preprocessor, but you should change
    the processing by using code as much as possible. You can check the platform by
    using the `Application` class in Cocos2d-x as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can get the value of the platform by using the `Application::getTargetPlatform`
    method. You will be able to check, not just for iPhone or iPad, but also IOS by
    using this method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the acceleration sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using an acceleration sensor on the device, we can make the game more engrossing,
    by using operations such as shaking and tilting the device. For example, move
    the ball by tilting the screen, the maze game that aims at the goal, and the skinny
    panda trying to go on a diet, wherein the players shake the device to play the
    game. You can get the tilt value and the moving speed of the device by using the
    accelerometer. If you can use it, your game becomes more unique. In this recipe,
    we learn how to use the acceleration sensor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can get the x, y, and z axis values from the acceleration sensor by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you enable the acceleration sensor by using the `Device::setAccelerometerEnable`
    method. The methods in the `Device` class are static methods. So, you can directly
    call a method without an instance like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You set the event listener for getting the value from the acceleration sensor.
    In this case, you can get these values by using the lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you set the event listener in the event dispatcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can get the value of the x, y, and z axes from the acceleration sensor,
    if you run this code on the real device. The x axis is the left and the right
    of the slope. The y axis is before and after of the slope. The z axis is the vertical
    motion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The acceleration sensor uses more battery power. When you use it, you set an
    appropriate interval for when the event occurred. The following code sets the
    interval as one second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the interval is higher, we might miss some tilt inputs. However, if we use
    a low interval, we will drain a lot of battery.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the screen on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have to keep the device from entering into the sleep mode while playing
    your game. For example, in your game, the player can control the game and keep
    the game going by using the accelerometer. The problem is that if the player does
    not touch the screen while playing with the accelerometer, the device goes to
    sleep and enters background mode. In this recipe, you can keep the screen on easily.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can keep the screen on if you set it to `true` by using the `Device::setKeepScreenOn`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a different way for each platform to prevent a device from entering
    the sleep mode. However, Cocos2d-x can do it for every platform. You can use this
    method without executing a platform. In the iOS platform, the `setKeepScreenOn`
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Android platform, the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Getting dpi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of **dpi** (**dots per inch**) variations for each device. You
    can prepare several kinds of images by resolution. You might want to change an
    image by the dpi running on the device. In this recipe, if you would like to get
    the dpi that your game is running on, you need to use the Cocos2d-x function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can get dpi of the device game is executing on, by using the `Device::getDPI`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In fact, we checked the dpi of some devices. To use the dpi information, you
    can further adjust the multiscreen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '| Device | Dpi |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 6 Plus | 489 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 6 | 326 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 5s | 326 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 4s | 326 |'
  prefs: []
  type: TYPE_TB
- en: '| iPad Air | 264 |'
  prefs: []
  type: TYPE_TB
- en: '| iPad 2 | 132 |'
  prefs: []
  type: TYPE_TB
- en: '| Nexus 5 | 480 |'
  prefs: []
  type: TYPE_TB
- en: Getting the maximum texture size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The maximum texture size that can be used is different for each device. In particular,
    when you use the texture atlas, you should be careful. That's why a texture atlas
    that has a lot of images is too large in size. You can't use a texture that is
    over the maximum size. If you use it, your game will crash. In this recipe, you
    can get the maximum texture size.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can get the max texture size easily by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Configuration class is a singleton class. This class has some OpenGL variables.
    OpenGL is a multiplatform API for rendering 2D and 3D vector graphics. It is pretty
    difficult to use. Cocos2d-x wraps it and makes it easy to use. OpenGL has a lot
    of information for graphics. The max texture size is one of the variables providing
    this information. You can get the max texture size of the device that your application
    is running on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get other OpenGL variables. If you want to check the variables that
    `Configuration` has, you will use the `Configuration::getInfo` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the log on iPhone 6 Plus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you get each variable, and you check the source code of the `Configuration`
    class, you can understand them easily.
  prefs: []
  type: TYPE_NORMAL
