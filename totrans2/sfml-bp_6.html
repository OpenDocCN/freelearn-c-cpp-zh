<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Boost Your Code Using Multithreading"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Boost Your Code Using Multithreading</h1></div></div></div><p>In this chapter, we will gain skills about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to run multiple parts of your program in parallel</li><li class="listitem" style="list-style-type: disc">How to protect memory access to avoid data race</li><li class="listitem" style="list-style-type: disc">How to incorporate those functionalities into Gravitris</li></ul></div><p>At the end of this chapter, you will be able to use all the power offered by the CPU of the computer, by paralyzing your code in a smart way. But first, let's describe the theory.</p><div class="section" title="What is multithreading?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>What is multithreading?</h1></div></div></div><p>In computer science, a<a id="id359" class="indexterm"/> software can be seen as a stream with a start and exit point. Each software starts its life with the <code class="literal">main()</code> function in C/C++. This is the entry point of your program. Until this point, you are able to do whatever you want; including creating new routine streams, cloning the entire software, and starting another program. The common point with all these examples is that another stream is created and has its own life, but they are not equivalent.</p><div class="section" title="The fork() function"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>The fork() function</h2></div></div></div><p>This functionality is pretty simple. Calling <code class="literal">fork()</code> will duplicate your entire running process to a new one. The new<a id="id360" class="indexterm"/> process that is created is totally separated from its parent (new PID, new memory area as the exact copy of its parent), and will<a id="id361" class="indexterm"/> start just after the <code class="literal">fork()</code> call. The return value of the <code class="literal">fork()</code> function is the only difference between the two executions.</p><p>Following is an example of the <code class="literal">fork()</code> function:</p><div class="informalexample"><pre class="programlisting">int main()
{
  int pid = fork();
  if(pid == -1)
    std::cerr&lt;&lt;"Error when calling fork()"&lt;&lt;std::endl;
  else if (pid == 0)
    std::cout&lt;&lt;"I'm the child process"&lt;&lt;std::endl;
  else
    std::cout&lt;&lt;"I'm the parent process"&lt;&lt;std::endl;
  return 0;
}</pre></div><p>As you can see, it is very simple to use, but there are also some limitations with this use. The most important <a id="id362" class="indexterm"/>one concerns the sharing of memory. Because each process has its own memory area, you are not able to share some variables between them. A solution to this is to use files as sockets, pipes, and so on. Moreover, if the parent process dies, the child will still continue its own life without paying attention to its <a id="id363" class="indexterm"/>parent.</p><p>So this solution is interesting only when you don't want to share anything between your different executions, even their states.</p></div><div class="section" title="The exec() family functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>The exec() family functions</h2></div></div></div><p>The <code class="literal">exec()</code> family functions (<code class="literal">execl()</code>, <code class="literal">execlp()</code>, <code class="literal">execle()</code>, <code class="literal">execv()</code>, <code class="literal">execvp()</code>, <code class="literal">execvpe()</code>) will replace the <a id="id364" class="indexterm"/>entire running program with another one. When paired with <code class="literal">fork()</code>, these functions become very powerful. Following is an example<a id="id365" class="indexterm"/> of these functions:</p><div class="informalexample"><pre class="programlisting">int main()
{
  int pid = fork();
  if(pid == -1)
  =  std::cerr&lt;&lt;"Error when calling fork()"&lt;&lt;std::endl;
  else if (pid == 0) {
    std::cout&lt;&lt;"I'm the child process"&lt;&lt;std::endl;
  }
  else {
    std::cout&lt;&lt;"I'm the parent process"&lt;&lt;std::endl;
    execlp("Gravitris", "Gravitris", "arg 1", "arg 2",NULL);
    std::cout&lt;&lt;"This message will never be print, except if execl() fail"&lt;&lt;std::endl;
  }
  return 0;
}</pre></div><p>This little code snippet will create two different processes as previously mentioned. Then, the child process will be replaced by an instance of Gravitris. As a call of any of the <code class="literal">exec()</code> family functions replace the entire running stream with a new one, all the code under the <code class="literal">exec</code> call will not be <a id="id366" class="indexterm"/>executed, except if an error occurs.</p></div></div></div>
<div class="section" title="Thread functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Thread functionality</h1></div></div></div><p>Now, we will speak about threads. The threads' functionalities are very close to the fork ones, but with some important differences. A thread will create a new stream to your running process. Its starting point is a function that is specified as a parameter. A thread will also be executed in the same <a id="id367" class="indexterm"/>context as its parent. The main implication is that the memory is the same, but it's not the only one. If the parent process dies, all its threads will die too.</p><p>These two points can be a problem if you don't know how to deal with them. Let's take an example of the concurrent memory access.</p><p>Let's say that you have a global variable in your program named <code class="literal">var</code>. The main process will then create a thread. This thread will then write into <code class="literal">var</code> and at the same time, the main process can write in it too. This will result in an undefined behavior. There are different solutions to avoid this behavior and the common one is to lock the access to this variable with a mutex.</p><p>To put it simply, a mutex is a token. We can try to take (lock) it or release it (unlock). If more than one process wants to lock it at the same time, the first one will effectively lock it and the second process will be waiting until the unlock function is called on the mutex by the first one. To sum up, if you want to access to a shared variable by more than one thread, you have to create a mutex for it. Then, each time you want to access it, lock the mutex, access the variable, and finally unlock the mutex. With this solution, you are sure that you don't make any data corrupt.</p><p>The second problem concerns the synchronization of the end of the execution of your thread with the main process. In fact, there is a simple solution for this. At the end of the main stream, you need to wait until the end of all the running threads. The stream will be blocked as long as any threads remain alive and consequently will not die.</p><p>Here is an example of usage of a thread's functionality:</p><div class="informalexample"><pre class="programlisting">#include &lt;SFML/System.hpp&gt;
static sf::Mutex mutex;
static int i = 0;

void f()
{
  sf::Lock guard(mutex);
  std::cout&lt;&lt;"Hello world"&lt;&lt;std::endl;
  std::cout&lt;&lt;"The value of i is "&lt;&lt;(++i)&lt;&lt;" from f()"&lt;&lt;std::endl;
}

int main()
{
  sf::Thread thread(f);
  thread.launch();
  mutex.lock();
  std::cout&lt;&lt;"The value of i is "&lt;&lt;(++i)&lt;&lt;" from main"&lt;&lt;std::endl;
  mutex.unlock();
  thread.wait();
  return 0;
}</pre></div><p>Now that the theory has been explained, let's explain what is the motivation to use multithreading.</p><div class="section" title="Why do we need to use the thread functionality?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Why do we need to use the thread functionality?</h2></div></div></div><p>Nowadays, computers in<a id="id368" class="indexterm"/> general have a CPU that is able to deal with several threads at the same time. Most of the time 4-12 calculation units are present in a CPU. Each of these units are able to do a task<a id="id369" class="indexterm"/> independently from the others.</p><p>Let's pretend that your CPU has only four calculation units.</p><p>If you take the example of our previous games, all the work was done in a single thread. So only one core is used over the four present. This is a shame, because all the work is done by only one component, and the others are simply not used. We can make it better by splitting our code into several parts. Each of these parts will be executed into a different thread, and the job will be shared between them. Then, the different threads will be executed into a different core (with a maximum of four in our case). So the work is now done in parallel.</p><p>Creating several threads offers you the possibility to exploit all the power offered by the computer, allowing you to spend more time on some functionalities such as artificial intelligence.</p><p>Another way of usage is when you use some blocking functions such as waiting for a message from the network, playing music, and so on. The problem here is that the running process will be in wait for something, and can't continue its execution. To deal with this, you can simply create a thread and delegate a job to it. This is exactly how <code class="literal">sf::Music</code> works. There is an internal thread that is used to play music. This is the reason why our games do not freeze when we play a sound or music. Each time a thread is created for this task, it appears transparent to the user. Now that the theory has been explained, let's use it in practice.</p></div><div class="section" title="Using threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Using threads</h2></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Playing with Physics">Chapter 4</a>, <span class="emphasis"><em>Playing with Physics</em></span>, we have introduced physics to our game. For this functionality, we have created two game loops: one for logic and another one for physics. Until now, the executions of the physics loop and the other one were made in the same process. Now, it's time to separate<a id="id370" class="indexterm"/> their execution into distinct threads.</p><p>We will need to create a thread, and protect our variables using a <code class="literal">Mutex</code> class. There are two options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using object from the standard library</li><li class="listitem" style="list-style-type: disc">Using object from the SFML library</li></ul></div><p>Here is a table that summarizes the functionalities needed and the conversion from a standard C++ library to SFML.</p><p>The <code class="literal">thread</code> class:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Library</p>
</th><th style="text-align: left" valign="bottom">
<p>Header</p>
</th><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Start</p>
</th><th style="text-align: left" valign="bottom">
<p>Wait</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>C++</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;thread&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">std::thread</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Directly after construction</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::join()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SFML</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;SFML/System.hpp&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Thread</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::launch()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::wait()</code>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">mutex</code> class:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Library</p>
</th><th style="text-align: left" valign="bottom">
<p>Header</p>
</th><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Lock</p>
</th><th style="text-align: left" valign="bottom">
<p>Unlock</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>C++</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;mutex&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">std::mutex</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::lock()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::unlock()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SFML</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;SFML/System.hpp&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Mutex</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::lock()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">::unlock()</code>
</p>
</td></tr></tbody></table></div><p>There is a third class that can be used. It automatically calls <code class="literal">mutex::lock()</code> on construction and <code class="literal">mutex::unlock()</code> on destruction, in respect of the RAII idiom. This class is called a lock or guard. Its use is simple, construct it with mutex as a parameter and it will automatically lock/unlock it. Following table explains the details of this class:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Library</p>
</th><th style="text-align: left" valign="bottom">
<p>Header</p>
</th><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Constructor</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>C++</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;mutex&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">std::lock_guard</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">std::lock_guard(std::mutex&amp;)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SFML</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;SFML/System.hpp&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Lock</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Lock(sf::Mutex&amp;)</code>
</p>
</td></tr></tbody></table></div><p>As you can see both libraries offer the same functionalities. The API changed a bit for the <code class="literal">thread</code> class, but nothing really important.</p><p>In this book, I will use the SFML library. There is no real reason for this choice, except that it allows me to show you a bit more of the SFML possibilities.</p><p>Now that the class has<a id="id371" class="indexterm"/> been introduced, let's get back to the previous example to apply our new skills as follows:</p><div class="informalexample"><pre class="programlisting">#include &lt;SFML/System.hpp&gt;
static sf::Mutex mutex;
static int i = 0;

void f()
{
  sf::Lock guard(mutex);
  std::cout&lt;&lt;"Hello world"&lt;&lt;std::endl;
  std::cout&lt;&lt;"The value of i is "&lt;&lt;(++i)&lt;&lt;" from f()"&lt;&lt;std::endl;
}

int main()
{
  sf::Thread thread(f);
  thread.launch();
  mutex.lock();
  std::cout&lt;&lt;"The value of i is "&lt;&lt;(++i)&lt;&lt;" from main"&lt;&lt;std::endl;
  mutex.unlock();
  thread.wait();
  return 0;
}</pre></div><p>There are several parts in this simple example. The first part initializes the global variables. Then, we create a function named <code class="literal">f()</code> that prints <span class="strong"><strong>"Hello world"</strong></span> and then prints another message. In the <code class="literal">main()</code> function, we create a thread attached to the <code class="literal">f()</code> function, we launch it, and print the value of <code class="literal">i</code>. Each time, we protect the access of the shared variable with a mutex (the two different approaches are used).</p><p>The print message from the <code class="literal">f()</code> function is unpredictable. It could be <span class="strong"><strong>"The value of i is 1 from f()"</strong></span> or <span class="strong"><strong>"The value of i is 2 from f()"</strong></span>. We are not able to say which one of the <code class="literal">f()</code> or <code class="literal">main()</code> prints will be made first, so we don't know the value that will be printed. The only point that we are sure of is that there is no concurrent access to <code class="literal">i</code> and the thread will be ended before the <code class="literal">main()</code> function, thanks to the <code class="literal">thread.wait()</code> call.</p><p>Now that the class that we needed have been explained and shown, let's modify our games to use them.</p></div></div>
<div class="section" title="Adding multithreading to our games"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Adding multithreading to our games</h1></div></div></div><p>We will now modify <a id="id372" class="indexterm"/>our Gravitris to paralyze the physics calculations from the rest of the program. We will need to change only two files: <code class="literal">Game.hpp</code> and <code class="literal">Game.cpp</code>.</p><p>In the header file, we will not only need to add the required header, but also change the prototype of the <code class="literal">update_physics()</code> function and finally add some attributes to the class. So here are the different steps to follow:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add <code class="literal">#include &lt;SFML/System.hpp&gt;</code>, this will allow us to have access to all the classes needed.</li><li class="listitem">Then, change the following code snippet:<div class="informalexample"><pre class="programlisting">void updatePhysics(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame);</pre></div><p>to:</p><div class="informalexample"><pre class="programlisting">void updatePhysics();</pre></div><p>The reason is that a thread is not able to pass any parameters to its wrapped function so we will use another solution: member variables.</p></li><li class="listitem">Add the following variables into the <code class="literal">Game</code> class as private:<div class="informalexample"><pre class="programlisting">sf::Thread _physicsThread;
sf::Mutex _mutex;
bool _isRunning;
int _physicsFramePerSeconds;</pre></div><p>All these variables will be used by the physics thread, and the <code class="literal">_mutex</code> variable will ensure that no concurrent access to one of those variables is made. We will also need to protect the access to the <code class="literal">_world</code> variable for the same reasons.</p></li><li class="listitem">Now that the header contains all the requirements, let's turn to the implementation.</li><li class="listitem">First of all, we will not only need to update our constructor to initialize the <code class="literal">_physicsThread</code> and <code class="literal">_isRunning</code> variables, but also protect the access to <code class="literal">_world</code>.<div class="informalexample"><pre class="programlisting">Game::Game(int X, int Y,int word_x,int word_y) : ActionTarget(Configuration::player_inputs), _window(sf::VideoMode(X,Y),"06_Multithreading"), _current_piece(nullptr), _world(word_x,word_y), _mainMenu(_window),_configurationMenu(_window), _pauseMenu(_window), _status(Status::StatusMainMenu), _physicsThread(&amp;Game::update_physics,this), _isRunning(true)
{
  bind(Configuration::PlayerInputs::HardDrop,[this](const sf::Event&amp;){
      sf::Lock lock(_mutex);
      _current_piece = _world.newPiece();
      timeSinceLastFall = sf::Time::Zero;
  });
}</pre></div></li><li class="listitem">In the constructor, we will not only initialize the new member variables, but also protect our <code class="literal">_world</code> variable used in one of the callbacks. This lock is important to be sure that no data race occurs randomly during the execution.</li><li class="listitem">Now that the <a id="id373" class="indexterm"/>constructor has been updated, we need to change the <code class="literal">run()</code> function. The goal is to run the physics thread. There are not a lot of changes to make. See it by yourself:<div class="informalexample"><pre class="programlisting">void Game::run(int minimum_frame_per_seconds, int physics_frame_per_seconds)
{
  sf::Clock clock;
  const sf::Time timePerFrame = sf::seconds(1.f/minimum_frame_per_seconds);
  const sf::Time timePerFramePhysics = sf::seconds(1.f/physics_frame_per_seconds);
  _physics_frame_per_seconds = physics_frame_per_seconds;
  _physicsThread.launch();

  while (_window.isOpen())
  {
    sf::Time time = clock.restart();
    processEvents();
    if(_status == StatusGame and not _stats.isGameOver()){
      updatePhysics(time,timePerFramePhysics);
      update(time,timePerFrame);
    }
    render();
  }
  _isRunning = false;
  _physicsThread.wait();
}</pre></div></li><li class="listitem">Now that the main game loop has been updated, we need to make a small change in the <code class="literal">update()</code> method to protect the member <code class="literal">_world</code> variable.<div class="informalexample"><pre class="programlisting">void Game::update(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame)
{
  static sf::Time timeSinceLastUpdate = sf::Time::Zero;
  timeSinceLastUpdate+=deltaTime;
  timeSinceLastFall+=deltaTime;
  if(timeSinceLastUpdate &gt; timePerFrame)
  {
    sf::Lock lock(_mutex);
    if(_current_piece != nullptr)
    {
      _currentPiece-&gt;rotate(_rotateDirection*3000);
      _currentPiece-&gt;moveX(_moveDirection*5000);
      bool new_piece;
      {
        int old_level =_stats.getLevel();
        _stats.addLines(_world.clearLines(new_piece,*_currentPiece));
        if(_stats.getLevel() != old_level)
        _world.add(Configuration::Sounds::LevelUp);
      }
      if(new_piece or timeSinceLastFall.asSeconds() &gt; std::max(1.0,10-_stats.getLevel()*0.2))
      {
        _current_piece = _world.newPiece();
        timeSinceLastFall = sf::Time::Zero;
      }
    }
    _world.update(timePerFrame);
    _stats.setGameOver(_world.isGameOver());
    timeSinceLastUpdate = sf::Time::Zero;
  }
  _rotateDirection=0;
  _moveDirection=0;
}</pre></div></li><li class="listitem">As you can see there is only one modification. We just need to protect the access to the <code class="literal">_world</code><a id="id374" class="indexterm"/> variable, that's it. Now, we need to change the <code class="literal">updatePhysics()</code> function. This one will be changed a lot as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">void Game::updatePhysics(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame)
void Game::updatePhysics()
{
  sf::Clock clock;
  const sf::Time timePerFrame = sf::seconds(1.f/_physics_frame_per_seconds);
  static sf::Time timeSinceLastUpdate = sf::Time::Zero;

  while (_isRunning)
  {
    sf::Lock lock(_mutex);
    timeSinceLastUpdate+=deltaTime;
    timeSinceLastUpdate+= clock.restart();
    _world.updateGravity(_stats.getLevel());

    while (timeSinceLastUpdate &gt; timePerFrame)
    {
      if(_status == StatusGame and not _stats.isGameOver())
      _world.update_physics(timePerFrame);
      timeSinceLastUpdate -= timePerFrame;
    }
  }
}</pre></div><p>We need to change the signature of this function because we are not able to give it some parameters through the thread. So we add an internal clock for this function, with its own loop. The rest of the function follows the logic developed in the <code class="literal">update()</code> method. Of course, we also use the mutex to protect the access to all the variables used. Now, the physics is able to be updated independently from the rest of the game.</p></li><li class="listitem">There are now little<a id="id375" class="indexterm"/> changes to be made in other functions where <code class="literal">_world</code> is used such as <code class="literal">initGame()</code> and <code class="literal">render()</code>. Each time, we will need to lock the access of this variable using the mutex.</li><li class="listitem">The changes are as follows concerning the <code class="literal">initGame()</code> function:<div class="informalexample"><pre class="programlisting">void Game::initGame()
{
  sf::Lock lock(_mutex);
  timeSinceLastFall = sf::Time::Zero;
  _stats.reset();
  _world.reset();
  _current_piece = _world.newPiece();
}</pre></div></li><li class="listitem">And now take a look at the <code class="literal">render()</code> function after it is updated:<div class="informalexample"><pre class="programlisting">void Game::render()
{
  _window.clear();
  switch(_status)
  {
    case StatusMainMenu:
    {
      _window.draw(_mainMenu);
    }break;
    case StatusGame :
    {
      if(not _stats.isGameOver())
      {
        sf::Lock lock(_mutex);
        _window.draw(_world);
      }
      _window.draw(_stats);
    }break;
    case StatusConfiguration:
    {
      _sfg_desktop.Update(0.0);
      _sfgui.Display(_window);
      _window.draw(_configurationMenu);
    }break;
    case StatusPaused :
    {
      if(not _stats.isGameOver())
      {
        sf::Lock lock(_mutex);
        _window.draw(_world);
      }
      _window.draw(_pauseMenu);
    }break;
    default : break;
  }
  _window.display();
}</pre></div></li><li class="listitem">As you can see, the<a id="id376" class="indexterm"/> changes made were really minimalistic, but required to avoid any race conditions.</li></ol></div><p>Now that all the changes have been made in the code, you should be able to compile the project and test it. The graphical result will stay unchanged, but the usage of the different cores of your CPU has changed. Now, the project uses two threads instead of only one. The first one used for the physics and another one for the rest of the game.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we covered the use of multithreading and applied it to our existing Gravitris project. We have learned the reason for this, the different possible uses, and the protection of the shared variables.</p><p>In our actual game, multithreading is a bit overkill, but in a bigger one for instance with hundreds of players, networking, and real-time strategies; it becomes a <span class="emphasis"><em>must have</em></span>.</p><p>In the next chapter, we will build an entire new game and introduce new things such as the isometric view, component system, path finding, and more.</p></div></body></html>