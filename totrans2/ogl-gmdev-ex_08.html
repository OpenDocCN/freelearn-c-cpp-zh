<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Expanding Your Horizons"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Expanding Your Horizons</h1></div></div></div><p>Until this point, we have limited our coding to two dimensions. Now, it is time to expand to the third dimension. In many ways, this will not be as intimidating as it sounds. After all, instead of specifying a position using two coordinates (<span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>), we will now simply add a third coordinate (<span class="emphasis"><em>z</em></span>). However, there are some areas where the third dimension will add considerable complexity, and it is my job to help you master that complexity. In this chapter, we will start with the basic understanding of placing an object in a 3D world, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>3D coordinate systems</strong></span>: You already mastered the Cartesian coordinate system (<span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates). We will discuss how to expand this into a third axis.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>3D cameras</strong></span>: The camera in a 2D game is pretty much fixed while the objects move past it. In 3D game programming, we often move the camera forward, backward, side-to-side, or even in circles around the objects in the game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>3D views</strong></span>: How exactly does a 2D computer screen represent 3D games? You will learn the basics of how 3D gets transformed by the graphics pipeline.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>3D transformations</strong></span>: Moving around in 3D space is quite a bit more complicated than moving in 2D space. In fact, we use a whole new form of mathematics to do so. You will learn the basics of matrices, and how they can be used to move, rotate, and change the size of 3D objects.</li></ul></div><div class="section" title="Into the third dimension!"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Into the third dimension!</h1></div></div></div><p>You already live<a id="id444" class="indexterm"/> in a world with three dimensions. You can walk forward and backward, side to side, and jump up or duck. The reality of three dimensions becomes even more apparent if you are flying or even swimming.</p><p>Most 2D games operate by allowing the player to move left and right, or jump up or down. This is what<a id="id445" class="indexterm"/> we did when we created RoboRacer2D. In this type of 2D game, the missing dimension is depth. Our Robot could not move further away from us or closer to us. Considering that we were drawing him on a flat screen, it shouldn't be too surprising that he was limited to two dimensions.</p><div class="section" title="Simulating 3D"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Simulating 3D</h2></div></div></div><p>Of course, artists found a way around this limitation hundreds of years ago by observing that as an <a id="id446" class="indexterm"/>object gets farther away from us, it gets smaller, and as it gets closer to us it gets larger. So, a simple way to represent 3D in a 2D world is to simply draw the more distant objects as smaller objects. 2D games learned this trick early on and used it to simulate 3D:</p><div class="mediaobject"><img src="graphics/8199OS_08_01.jpg" alt="Simulating 3D"/></div><p>In the preceding image, the larger tank appears to be closer than the smaller tank.</p><p>Another important <a id="id447" class="indexterm"/>aspect of depth is <span class="strong"><strong>perspective</strong></span>. Artists learned that parallel lines appear to converge toward the center as they move farther away. The point <a id="id448" class="indexterm"/>where they seem to converge is known as the <span class="strong"><strong>vanishing point</strong></span>:</p><div class="mediaobject"><img src="graphics/8199OS_08_02.jpg" alt="Simulating 3D"/></div><p>In the preceding<a id="id449" class="indexterm"/> image, the walls and floor panels are all parallel, but they appear to converge inward toward the center of the image.</p><p>A third aspect of 3D motion is that objects that are farther away appear to travel more slowly than objects that are closer. Thus, when you are driving, the telephone poles pass you by much faster than the distant mountains. Some 2D games take advantage of this phenomenon, called <a id="id450" class="indexterm"/>
<span class="strong"><strong>parallax</strong></span>, by creating a background layer in the game that moves much slower than the foreground. In fact, this is exactly what we did in RoboRacer2D because the Robot in the foreground moves more quickly than the objects in the background.</p><p>2D games have used all of these features—size, perspective, and parallax—to simulate 3D long before we ever had hardware and graphics cards to do them for us. One of the first games to do this in a convincing way was Pole Position. The game that really blew everyone away was Doom, which was probably the first game that allowed the player to freely move in a 3D world.</p></div><div class="section" title="Real 3D"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec119"/>Real 3D</h2></div></div></div><p>Modern 3D games take the idea of simulating 3D to the next level. In the simulating 3D section that we<a id="id451" class="indexterm"/> just discussed, it is the programmers' task to <a id="id452" class="indexterm"/>scale the image so that it appears smaller as it gets further away, take care of perspective, and handle parallax. This is now handled by the 3D graphics card.</p><div class="mediaobject"><img src="graphics/8199OS_08_03.jpg" alt="Real 3D"/></div><p>The preceding<a id="id453" class="indexterm"/> image shows a 3D <span class="strong"><strong>model</strong></span> of a tank. These models are<a id="id454" class="indexterm"/> created using special software, such as Maya or 3ds Max. This <a id="id455" class="indexterm"/>model is fundamentally different than the 2D tank image we showed you previously because it represents the tank in three dimensions.</p><p>We will discuss 3D modeling in more detail in a future chapter. For now, the important concept is that the data for a 3D tank is sent to the graphics card, and the graphics card takes care of size, perspective, and parallax as the tank is positioned in a 3D space. This takes a lot of the load off the programmer!</p></div><div class="section" title="3D Coordinate Systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec120"/>3D Coordinate Systems</h2></div></div></div><p>Now that <a id="id456" class="indexterm"/>you have a fundamental idea of how the<a id="id457" class="indexterm"/> illusion of 3D is created on a 2D screen, let's learn how adding another dimension affects our coordinate system.</p><p>In <a class="link" href="ch02.html" title="Chapter 2. Your Point of View">Chapter 2</a>, <span class="emphasis"><em>Your Point of View</em></span> I introduced you to the 2D coordinate system that is used by many game systems.</p><div class="mediaobject"><img src="graphics/8199OS_08_04.jpg" alt="3D Coordinate Systems"/></div><p>The preceding <a id="id458" class="indexterm"/>diagram shows a car placed at <a id="id459" class="indexterm"/>coordinate position (<span class="strong"><strong>5, 5</strong></span>). Let's add the third dimension and see how it compares:</p><div class="mediaobject"><img src="graphics/8199OS_08_05.jpg" alt="3D Coordinate Systems"/></div><p>Notice that we<a id="id460" class="indexterm"/> added a third axis and labeled it <a id="id461" class="indexterm"/>as the Z-axis. Positive values on the Z-axis are closer to us, while negative values on the Z-axis are farther away. The car is now placed at coordinate (<span class="strong"><strong>5, 5, -5</strong></span>) in 3D space. As the car is farther away, it also appears smaller than it did in the previous 2D image (you can think of 2D space as a space where all of the <span class="emphasis"><em>z</em></span> coordinates are 0).</p><p>The preceding diagram shows the Z-axis at an angle, but it is important to understand that the Z-axis is actually perpendicular to the plane of the computer screen.</p><div class="mediaobject"><img src="graphics/8199OS_08_06.jpg" alt="3D Coordinate Systems"/></div><p>Think of the<a id="id462" class="indexterm"/> Z-axis as a line the pierces through <a id="id463" class="indexterm"/>the center of the monitor from the front and travels out the back!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip53"/>Tip</h3><p>There are actually many ways to represent the axes in a 3D world. One distinction between OpenGL and DirectX is the Z-axis. In OpenGL, positive <span class="emphasis"><em>z</em></span> values are closer to the player. In DirectX, Microsoft's 3D rendering engine, negative z values are closer to the player. It's just a good thing to know because you will very likely work with both systems. OpenGL is known as a <span class="strong"><strong>right-hand</strong></span> coordinate<a id="id464" class="indexterm"/> system, while DirectX is a <span class="strong"><strong>left-hand</strong></span> coordinate<a id="id465" class="indexterm"/> system. It's a little hard to explain how they got these names, so perform an Internet search if you would like to learn more!</p></div></div></div></div></div>
<div class="section" title="The camera"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>The camera</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Your Point of View">Chapter 2</a>, <span class="emphasis"><em>Your Point of View</em></span> we compared creating games to making a video recording. Your video camera captures a part of the view in front of you. If objects move into or out of that field of view, they<a id="id466" class="indexterm"/> are no longer in the video recording.</p><p>3D games use a camera as well. OpenGL allows you to move the game camera on six axes: up, down, left, right, in, and out. As you move the game camera, the objects that are in its view change.</p><p>Let's say that you center the camera on the car in the scene and pan to the left or right. The car will move in and out of the field of view. Of course the same occurs if you pan the camera up or down. Move back (or zoom out) and the car appears smaller. Move forward (or zoom in) and the car appears larger. Tilt the camera and the car will appear to be going uphill, downhill, or even appear upside down!</p><div class="section" title="Remember those home movies?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec121"/>Remember those home movies?</h2></div></div></div><p>Remember those home movies where the whole scene would jump around as the camera moved? Obviously, the position and movement of the camera has a lot to do with the appearance<a id="id467" class="indexterm"/> of the car. The same is true in the game world.</p><p>OpenGL uses the concept of a camera to determine exactly what shows up on the screen, and how it shows up. You have the ability to move the camera up or down, and left or right. You can rotate or tilt the camera. You have complete control!</p></div><div class="section" title="Steady as she goes!"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec122"/>Steady as she goes!</h2></div></div></div><p>Although you have complete control over moving the camera, some games simply place the camera at a particular spot and then leave it fixed. This is similar to taking your home video camera and attaching it to a tripod.</p><p>Many 2D games <a id="id468" class="indexterm"/>use a fixed camera, and this is exactly what we <a id="id469" class="indexterm"/>did in RoboRacer2D. All of the motion in the game came from changing the position of the objects in the game, not from changing the position of the camera.</p><p>In 3D games, it is very common to move both the camera and objects in the game. Imagine that we have a 3D scene with a moving car. If the camera remained fixed, the car would eventually move out of the scene. In order to keep the car in the scene, we need to move the camera so that it follows the car. Both the car and the camera need to move.</p></div><div class="section" title="The viewport"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec123"/>The viewport</h2></div></div></div><p>In game<a id="id470" class="indexterm"/> terminology, the area that can be seen by the camera at any time is<a id="id471" class="indexterm"/> called the <span class="strong"><strong>viewport</strong></span>. The viewport defines the area of the game world that the camera can see:</p><div class="mediaobject"><img src="graphics/8199OS_08_07.jpg" alt="The viewport"/></div><p>The preceding illustration shows a viewport with a certain width and height. If the car moves outside of these boundaries, it will no longer be visible. In a 3D world, we must also define the depth of the image that we want to capture.</p><div class="mediaobject"><img src="graphics/8199OS_08_08.jpg" alt="The viewport"/></div><p>The preceding<a id="id472" class="indexterm"/> image shows how the 3D viewport is defined:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The front <a id="id473" class="indexterm"/>clipping plane defines how close things can get to the camera. Anything closer than the front clipping plane will not be rendered on the screen.</li><li class="listitem" style="list-style-type: disc">The rear clipping plane defines how far things can get from the camera. Anything beyond the rear clipping plane will not be rendered on the screen.</li><li class="listitem" style="list-style-type: disc">The area between the front and back clipping planes is called the frustum. Objects inside the frustum will be rendered to the screen.</li><li class="listitem" style="list-style-type: disc">The field of view determines how tall and wide the angle of view is from the camera. A wide field of view will render more area, while a narrow field of view will render less area. A wider angle will also introduce more distortion to the image.</li></ul></div></div></div>
<div class="section" title="Entering the matrix"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Entering the matrix</h1></div></div></div><p>Now for the topic that strikes fear into the heart of all new game programmers: <span class="strong"><strong>matrices</strong></span>. Matrices are a <a id="id474" class="indexterm"/>mathematical device (part of linear algebra) that makes it easier to work with large sets of related numbers.</p><p>In its simplest form, a <span class="strong"><strong>matrix</strong></span> is a table of numbers. Let's say that I wanted to represent a coordinate in space. I could write its value down as follows:</p><div class="mediaobject"><img src="graphics/8199OS_08_entering_the_matrix.jpg" alt="Entering the matrix"/></div><div class="section" title="Vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec124"/>Vectors</h2></div></div></div><p>A single row or<a id="id475" class="indexterm"/> single column of a matrix is called a <span class="strong"><strong>vector</strong></span>. Vectors are<a id="id476" class="indexterm"/> important because they can be used to both position things and move things.</p><p>The typical matrix used in games contains four values: <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>z</em></span>, and <span class="emphasis"><em>w</em></span>. These <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> components typically refer to a position in the 3D coordinate system, while the <span class="emphasis"><em>w</em></span> is a switch:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The value 1 means that this vector is a position</li><li class="listitem" style="list-style-type: disc">The value 0 means that this vector is a velocity</li></ul></div><p>Here's an example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The vector, (<code class="literal">1, 5, 10, 1</code>), represents a point at x = <code class="literal">1</code>, y = <code class="literal">5</code>, and z = <code class="literal">10</code> in a 3D coordinate system.</li><li class="listitem" style="list-style-type: disc">The vector, (<code class="literal">1, 5, 10, 0</code>), is a point that moves 1 unit in the <span class="emphasis"><em>x</em></span> direction, 5 units in the <span class="emphasis"><em>y</em></span> direction, and 10 units in the <span class="emphasis"><em>z</em></span> direction</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>Notice that <a id="id477" class="indexterm"/>vectors can be represented as a series of numbers inside <a id="id478" class="indexterm"/>of a parenthesis. This is much easier than having to draw a table every time you need to write down a vector!</p></div></div></div><div class="section" title="Combining vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec125"/>Combining vectors</h2></div></div></div><p>The real<a id="id479" class="indexterm"/> power of vectors comes when they are combined. The <a id="id480" class="indexterm"/>most common way to combine vectors is to multiply them. Look at the following example:</p><div class="mediaobject"><img src="graphics/8199OS_08_combining_vectors.jpg" alt="Combining vectors"/></div><p>The matrix on the left is known as<a id="id481" class="indexterm"/> a <span class="strong"><strong>translation matrix</strong></span> because when you multiply it by a positional vector, the result will be a new position (moving things in a 3D space is known<a id="id482" class="indexterm"/> as <span class="strong"><strong>translation</strong></span>). In this case, the point at (<span class="strong"><strong>2, 1, 0</strong></span>) has been translated to a new position at (<span class="strong"><strong>3, 6, 6</strong></span>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip55"/>Tip</h3><p>Remember: the last <span class="strong"><strong>1</strong></span> in (<span class="strong"><strong>1, 5, 6, 1</strong></span>) and (<span class="strong"><strong>2, 1, 0, 1</strong></span>) is the <span class="emphasis"><em>w</em></span> value that simply tells us we are working with a position. Notice that the <span class="emphasis"><em>w</em></span> value remained <span class="strong"><strong>1</strong></span> in the final result as well!</p></div></div><p>If you are paying attention, you must be wondering how we got the third matrix! It turns out that multiplying two matrices is actually more complex that it seems. In order to multiply the two matrices shown earlier, the following operations had to occur:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">(1 * 2) + (0 * 1) + (0 * 0) + (1 * 1) = 3</li><li class="listitem" style="list-style-type: disc">(0 * 2) + (1 * 1) + (0 * 0) + (5 * 1) = 6</li><li class="listitem" style="list-style-type: disc">(0 * 2) + (0 * 1) + (1 * 0) + (6 * 1) = 6</li><li class="listitem" style="list-style-type: disc">(0 * 2) + (0 * 1) + (0 * 0) + (1 * 1) = 1</li></ul></div><p>Each cell in each row of the first matrix is multiplied by each cell in each column of the second matrix.</p><p>This might seem like a lot of trouble just to move a point, but when it comes to quickly moving 3D objects around in a game, matrix math is much faster than other techniques.</p><p>Don't worry! This is about all we are going to say about matrices and vectors. You should know that <a id="id483" class="indexterm"/>OpenGL <a id="id484" class="indexterm"/>uses matrices to <a id="id485" class="indexterm"/>calculate <span class="strong"><strong>transformations</strong></span>, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moving</li><li class="listitem" style="list-style-type: disc">Scaling</li><li class="listitem" style="list-style-type: disc">Rotating</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip56"/>Tip</h3><p>If you ever work with both OpenGL and DirectX, you will need to be aware that there is a difference in the way they handle matrices. OpenGL uses a <span class="strong"><strong>row major</strong></span> order, while DirectX users a <span class="strong"><strong>column major order</strong></span>. In a row major matrix, all of the cells <a id="id486" class="indexterm"/>in the first column are adjacent, followed by all of the<a id="id487" class="indexterm"/> cells in the next row, and so<a id="id488" class="indexterm"/> forth. In a column major matrix, all of the cells in the <a id="id489" class="indexterm"/>first column are adjacent, followed by all of the cells in the next column, and so forth. This makes a huge difference in how you manipulate and calculate the matrices!</p></div></div></div><div class="section" title="Identity matrix"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec126"/>Identity matrix</h2></div></div></div><p>I will mention<a id="id490" class="indexterm"/> one more special matrix:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr></tbody></table></div><p>The preceding<a id="id491" class="indexterm"/> matrix is known as an identity matrix. If you multiply any matrix by an identity matrix, the result is the original matrix (just like multiplying any number by 1 results in the original number). Whenever we want to initialize a matrix, we set it to an identity matrix.</p><p>There are special matrices in OpenGL, and you will be introduced to some of them in the next code.</p></div></div>
<div class="section" title="Coding in 3D"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Coding in 3D</h1></div></div></div><p>It's time for us to put our theory into practice and create our first 3D scene. To keep things simple, we <a id="id492" class="indexterm"/>will go through the steps of placing a cube in 3D space. This is also going to be the start of our 3D game, so let's start by creating a brand new project in Visual Studio.</p><div class="section" title="Creating the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec127"/>Creating the project</h2></div></div></div><p>When we <a id="id493" class="indexterm"/>created a project for our 2D game, we started with a standard Windows project and then removed (or ignored) the items that we didn't need to use. In fact, the standard Windows project has a lot of overhead that we don't need. This is because the Windows project template assumes that Windows is going to be in charge of rendering and processing. This came in useful for our 2D project, but just adds a lot of extra code that we don't need.</p><p>For this project, we will start with a blank Windows project and then add the necessary code to initialize and create an OpenGL window. Then, we will work our way up from there:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Begin by opening Visual Studio.</li><li class="listitem">Once Visual Studio is open, create a new project by clicking on <span class="strong"><strong>File</strong></span>, <span class="strong"><strong>New</strong></span>, <span class="strong"><strong>Project</strong></span>. From the <span class="strong"><strong>Visual C++</strong></span> branch choose <span class="strong"><strong>Empty Project</strong></span>.<div class="mediaobject"><img src="graphics/8199OS_08_09.jpg" alt="Creating the project"/></div></li><li class="listitem"><span class="strong"><strong>Name</strong></span> the project <code class="literal">SpaceRacer3D</code>, place it in the location of your choice, and click <span class="strong"><strong>OK</strong></span>. The result is a project that has no code. Let's solve that problem by creating our main game file.</li><li class="listitem">Right-click <a id="id494" class="indexterm"/>on the <span class="strong"><strong>Source Files</strong></span> folder in the <span class="strong"><strong>Solution Explorer</strong></span> panel.</li><li class="listitem">Choose <span class="strong"><strong>Add</strong></span>, <span class="strong"><strong>New Item…</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>C++ File (.cpp)</strong></span>.</li><li class="listitem">Type <code class="literal">SpaceRacer3D.cpp</code> for <span class="strong"><strong>Name</strong></span> and click <span class="strong"><strong>Add</strong></span>.<div class="mediaobject"><img src="graphics/8199OS_08_10.jpg" alt="Creating the project"/></div></li></ol></div></div><div class="section" title="Retrieving OpenGL files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec128"/>Retrieving OpenGL files</h2></div></div></div><p>The standard <a id="id495" class="indexterm"/>OpenGL library is already installed <a id="id496" class="indexterm"/>when you install Visual Studio. However, the OpenGL utilities library may not be. To make things simple, we will simply copy the files that we need from our RoboRacer2D project.</p><p>Open the <span class="strong"><strong>RoboRacer2D</strong></span> project folder and select the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glut.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">glut32.dll</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">glut32.lib</code></li></ul></div><p>Now copy these files into the <span class="strong"><strong>SpaceRacer3D</strong></span> source folder. This will be the same folder that your <code class="literal">SpaceRacer3D.cpp</code> file is located.</p></div><div class="section" title="Linking projects to OpenGL libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec129"/>Linking projects to OpenGL libraries</h2></div></div></div><p>Now that<a id="id497" class="indexterm"/> we have a project and the relevant <a id="id498" class="indexterm"/>OpenGL files, we need to link to the OpenGL libraries. This is done by accessing the project properties.</p><p>In the <span class="strong"><strong>Solution Explorer</strong></span> panel perform the following actions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the project name (not the solution), and choose <span class="strong"><strong>Properties</strong></span>.</li><li class="listitem">Open the <span class="strong"><strong>Linker</strong></span> branch under <span class="strong"><strong>Configuration Properties</strong></span>, and select <span class="strong"><strong>Input</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Additional Dependencies</strong></span> and then click the drop-down arrow that appears.</li><li class="listitem">Click on <span class="strong"><strong>&lt;Edit…&gt;</strong></span>.</li><li class="listitem">Add <code class="literal">OpenGL32.lib</code> and <code class="literal">GLu32.lib</code> in the <span class="strong"><strong>Additional Dependencies</strong></span> dialog window.<div class="mediaobject"><img src="graphics/8199OS_08_11.jpg" alt="Linking projects to OpenGL libraries"/></div></li></ol></div></div></div>
<div class="section" title="Setting up the OpenGL window"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Setting up the OpenGL window</h1></div></div></div><p>We are <a id="id499" class="indexterm"/>now going to add the code required to create an OpenGL window. We did this once for RoboRacer2D, but now, we are creating a 3D game and there will be some differences. Here's a look at what we need to do:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include header files.</li><li class="listitem">Define global variables.</li><li class="listitem">Create the OpenGL window.</li><li class="listitem">Initialize the OpenGL window.</li><li class="listitem">Size the OpenGL window.</li><li class="listitem">Remove the OpenGL window.</li><li class="listitem">Create the Windows event handler.</li><li class="listitem">Create the <code class="literal">WinMain</code> function.</li></ol></div><p>Notice that we <a id="id500" class="indexterm"/>still have to create some code to satisfy Windows. We need an event handler to process Windows events, and we still need a main function to serve as the program entry point and run the main program loop. Everything else in this list is used to set up the OpenGL environment.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/>Tip</h3><p>I listed the functions tasks that we need in an order that makes logical sense. When we actually implement the code, we will create things in a slightly different order. This is because some functions require another function to already be defined. For example, the function to create the OpenGL window calls the function to initialize the OpenGL window, so the initialize function is coded first.</p></div></div><div class="section" title="Including header files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec130"/>Including header files</h2></div></div></div><p>The first step<a id="id501" class="indexterm"/> is to in include the appropriate headers. Add the following headers at the top of <code class="literal">SpaceRacer3D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;windows.h&gt;
#include &lt;gl\GL.h&gt;
#include &lt;gl\GLU.h&gt;
#include "glut.h"</pre></div><p>These are the same files that we used in the 2D project, but here is a quick description of each one so that you don't have to flip back:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are still running in Windows, so we must include <code class="literal">windows.h</code></li><li class="listitem" style="list-style-type: disc">The core header for OpenGL is <code class="literal">GL.h</code></li><li class="listitem" style="list-style-type: disc">There are some great utilities to make our lives easier in <code class="literal">GLU.h</code></li><li class="listitem" style="list-style-type: disc">There are also useful utilities in <code class="literal">glut.h</code></li></ul></div></div><div class="section" title="Defining global variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec131"/>Defining global variables</h2></div></div></div><p>We need<a id="id502" class="indexterm"/> some global variables to hold onto references to Windows and OpenGL objects. Add the following lines of code just under the header lines:</p><div class="informalexample"><pre class="programlisting">HINSTANCE hInstance = NULL;
HDC hDC = NULL;
HGLRC hRC = NULL;
HWND hWnd = NULL;
bool fullscreen = false;</pre></div><p>Here is a quick list of what these variables are for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hInstance</code>: This holds a reference to this instance of the application</li><li class="listitem" style="list-style-type: disc"><code class="literal">hDC</code>: This holds a reference to the GDI device context which is used for drawing in native Windows</li><li class="listitem" style="list-style-type: disc"><code class="literal">hRC</code>: This holds a reference to the OpenGL rendering context, used for rendering 3D</li><li class="listitem" style="list-style-type: disc"><code class="literal">hWnd</code>: This holds a reference to the actual window the application is running in</li></ul></div><p>We have also included a global <code class="literal">fullscreen</code> variable. If you set this to <code class="literal">true</code>, the game will run in <code class="literal">fullscreen</code> mode. If you set this to <code class="literal">false</code>, the game will run in windowed mode.</p></div><div class="section" title="Creating a function to create the OpenGL window"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec132"/>Creating a function to create the OpenGL window</h2></div></div></div><p>We will<a id="id503" class="indexterm"/> also include a forward reference to the Windows event handler. Add the following line of code:</p><div class="informalexample"><pre class="programlisting">LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);</pre></div><p>A forward reference allows us to define a function whose actual implementation will appear later in the code. The code for <code class="literal">WndProc</code> will be added later.</p></div><div class="section" title="Sizing the OpenGL window"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec133"/>Sizing the OpenGL window</h2></div></div></div><p>Next, we will <a id="id504" class="indexterm"/>create the function to size the OpenGL window. This function is called when the program starts as well as any time the window that the application is running in is resized. Add the following code:</p><div class="informalexample"><pre class="programlisting">void ReSizeGLScene(const GLsizei p_width, const GLsizei p_height)
{
  GLsizei h = p_height;
  GLsizei w = p_width;
  if (h == 0)
  {
    h = 1;
  }
  glViewport(0, 0, w, h);
  
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f, (GLfloat)w / (GLfloat)h, 0.1f, 100.0f);
  
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
}</pre></div><p>This code<a id="id505" class="indexterm"/> sets the size of the OpenGL window and prepares the window for rendering in 3D:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we take the width and height (ensuring that the height is never equal to 0), and use them to define the size viewport using the <code class="literal">glViewport</code> function. The first two parameters are the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> value of the lower left-hand corner of the viewport, followed by the width and the height. These four parameters define the size and location of the viewport.</li><li class="listitem" style="list-style-type: disc">Next, we have to define the frustum. After telling OpenGL to use the projection matrix, we use the <code class="literal">gluPerspective</code> function, which takes four parameters: the field of view (in degrees, not radians), the aspect ratio, the distance of the front clipping plane, and the distance of the rear clipping plane. The field of view is the angle from the center of the camera. The aspect ratio is the width divided by the height. These four parameters define the size of the frustum.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip58"/>Tip</h3><p>After you complete this chapter, you may try playing with the values of this function to see how it changes the rendering.</p></div></div></li><li class="listitem" style="list-style-type: disc">Finally, we tell OpenGL to use the model view from this point forward.</li></ul></div><p>If you compare this function to the <code class="literal">GLSize</code> function that we used in RoboRacer2D, you will note one significant difference: we do not make a call to <code class="literal">glOrtho</code>. Remember, RoboRacer2D was a 2D game. 2D games <a id="id506" class="indexterm"/>use an <span class="strong"><strong>orthographic projection</strong></span> that removes perspective when the scene is rendered. You don't need perspective in a 2D game. Most 3D games use a <span class="strong"><strong>perspective projection</strong></span>, which is defined by<a id="id507" class="indexterm"/> the <code class="literal">gluPerspective</code> call.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>
<span class="strong"><strong>OpenGL Matrices</strong></span>
</p><p>Just before the <code class="literal">gluPerspective</code> call, you will notice two functions: <code class="literal">glMatrixMode</code>, and <code class="literal">glLoadIdentity</code>. Remember from our discussion of matrices that a<a id="id508" class="indexterm"/> matrix is used to hold a set of values. OpenGL has many standard matrices, and one of them is the projection matrix, which is <a id="id509" class="indexterm"/>used to define the view frustum.</p><p>If we want to set the values of a matrix, we must first tell OpenGL that we want to work with this matrix. Next, we typically initialize the matrix, and finally, we make a call that sets the values of the matrix.</p><p>Looking at the code to set the view frustum, this is exactly what we do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glMatrixMode(GL_PROJECTION)</code>: This tells OpenGL that we want to work with the projection matrix. Any matrix operations after this call will be applied to the projection matrix.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glLoadIdentity()</code>: This sets the projection matrix to an identity matrix, thus, clearing any previous values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">gluPerspective(45.0f, (GLfloat)w / (GLfloat)h, 0.1f, 100.0f)</code>: This sets the values of the projection matrix.</li></ul></div><p>You should get used to this pattern because it is used often in OpenGL: set a matrix to work with, initialize the matrix, then set the values of the matrix. For example, at the end of this function we tell OpenGL to use the model view matrix and initialize it. Any operations after this will affect the model view.</p></div></div></div><div class="section" title="Initializing the OpenGL window"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec134"/>Initializing the OpenGL window</h2></div></div></div><p>Add the<a id="id510" class="indexterm"/> following code to initialize OpenGL:</p><div class="informalexample"><pre class="programlisting">const bool InitGL()
{
  glShadeModel(GL_SMOOTH);
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
  glClearDepth(1.0f);
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LEQUAL);
  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
  return true;
}</pre></div><p>This function initializes OpenGL by defining important settings that determine how a scene will be<a id="id511" class="indexterm"/> rendered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glShadeModel</code>: This tells OpenGL that we want it to smooth the edges of the vertices. This greatly improves the look of our images.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glClearColor</code>: This sets the color that is used each time <code class="literal">glClear</code> is called to clear out the rendering buffer. It is also the default color that will show in the scene.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glClearDepth(1.0f)</code>: This tells OpenGL that we want the entire depth buffer cleared each time <code class="literal">glClear</code> is called. Remember, we are working in 3D now, and the depth buffer is roughly synonymous with the Z-axis.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glEnable(GL_DEPTH_TEST)</code>: This turns on depth checking. Depth checking is used to determine if a particular piece of data will be rendered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glDepthFunc(GL_LEQUAL)</code>: This tells OpenGL how you want to perform the depth test. <code class="literal">LEQUAL</code> tells OpenGL to write the data only if the z value of the incoming data is less than or equal to the z value of the existing data.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glHint((GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST))</code>: This is an interesting function. <code class="literal">glHint</code> means that this function is going to suggest that OpenGL use the settings passed as parameters. However, as there are many different types of devices, there is no guarantee that these settings will actually be enforced. The <code class="literal">GL_PERSPECTIVE</code> hint tells OpenGL to use the highest quality when rendering perspective, while <code class="literal">GL_NICEST</code> means focus on rendering quality rather than speed.</li></ul></div></div><div class="section" title="Creating a function to remove the OpenGL window"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec135"/>Creating a function to remove the OpenGL window</h2></div></div></div><p>Eventually, we will <a id="id512" class="indexterm"/>want to shut things down. Good programming dictates that we release the resources that were being used by the OpenGL window. Add the following function to our code:</p><div class="informalexample"><pre class="programlisting">GLvoid KillGLWindow(GLvoid)
{
  if (fullscreen)
  {
    ChangeDisplaySettings(NULL, 0);
    ShowCursor(TRUE);
  }
  if (hRC)
  {
    wglMakeCurrent(NULL, NULL);
    wglDeleteContext(hRC);
    hRC = NULL;
  }
  if (hDC)
  {
    ReleaseDC(hWnd, hDC)
    hDC = NULL;
  }
  
  if (hWnd)
  {
    DestroyWindow(hWnd);
    hWnd = NULL;
  }
  UnregisterClass("OpenGL", hInstance)
  hInstance = NULL;
}</pre></div><p>First, we tell <a id="id513" class="indexterm"/>Windows to exit fullscreen mode (if we were running fullscreen) and turn the cursor back on. Then, we check each object that had a resource attached, release that object, then set it to null. The objects that need to be released are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hRC</code>: This is the OpenGL rendering context</li><li class="listitem" style="list-style-type: disc"><code class="literal">hDC</code>: This is the Windows device context</li><li class="listitem" style="list-style-type: disc"><code class="literal">hWnd</code>: This is the handle to the Window</li><li class="listitem" style="list-style-type: disc"><code class="literal">hInstance</code>: This is the handle to the application</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip59"/>Tip</h3><p>You may notice the two functions that start with <code class="literal">wgl</code> (<code class="literal">wglMakeCurrent</code> and <code class="literal">wglDeleteContext)</code>. This stands for Windows GL and these are special OpenGL functions that only work in Windows.</p></div></div></div><div class="section" title="Creating the OpenGL window"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec136"/>Creating the OpenGL window</h2></div></div></div><p>Now that we<a id="id514" class="indexterm"/> have the other OpenGL support functions defined, we can add the function to actually create the OpenGL window. Add the following code:</p><div class="informalexample"><pre class="programlisting">const bool CreateGLWindow(const char* p_title, const int p_width, const int p_height, const int p_bits, const bool p_fullscreenflag)
{
  GLuint  PixelFormat;
  WNDCLASS wc;
  DWORD  dwExStyle;
  DWORD  dwStyle;
  RECT  WindowRect;
  WindowRect.left = (long)0;
  WindowRect.right = (long)p_width;
  WindowRect.top = (long)0;
  WindowRect.bottom = (long)p_height;
  
  fullscreen = p_fullscreenflag;
  GLfloat screen_height = (GLfloat)p_height;
  GLfloat screen_width = (GLfloat)p_width;
  
  hInstance = GetModuleHandle(NULL);
  wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
  wc.lpfnWndProc = (WNDPROC)WndProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = hInstance;
  wc.hIcon = LoadIcon(NULL, IDI_WINLOGO);
  wc.hCursor = LoadCursor(NULL, IDC_ARROW);
  wc.hbrBackground = NULL;
  wc.lpszMenuName = NULL;
  wc.lpszClassName = "OpenGL";
  
  RegisterClass(&amp;wc);
  
  if (fullscreen)
  {
    DEVMODE dmScreenSettings;
    memset(&amp;dmScreenSettings, 0, sizeof(dmScreenSettings));
    dmScreenSettings.dmSize = sizeof(dmScreenSettings);
    dmScreenSettings.dmPelsWidth = p_width;
    dmScreenSettings.dmPelsHeight = p_height;
    dmScreenSettings.dmBitsPerPel = p_bits;
    dmScreenSettings.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
    
    ChangeDisplaySettings(&amp;dmScreenSettings, CDS_FULLSCREEN);
  }
  
  if (fullscreen)
  {
    dwExStyle = WS_EX_APPWINDOW;
    dwStyle = WS_POPUP;
    ShowCursor(false);
  }
  else
  {
    dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
    dwStyle = WS_OVERLAPPEDWINDOW;
  }
  
  AdjustWindowRectEx(&amp;WindowRect, dwStyle, FALSE, dwExStyle);
  
  hWnd = CreateWindowEx(dwExStyle,"OpenGL", p_title,
  dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
  0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top,
  NULL, NULL, hInstance, NULL);
  
  static PIXELFORMATDESCRIPTOR pfd =
  {
    sizeof(PIXELFORMATDESCRIPTOR),
    1,
    PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
    PFD_TYPE_RGBA, p_bits,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    16, 0, 0,
    PFD_MAIN_PLANE,
    0, 0, 0, 0
  };
  
  hDC = GetDC(hWnd);
  PixelFormat = ChoosePixelFormat(hDC, &amp;pfd);
  SetPixelFormat(hDC, PixelFormat, &amp;pfd);
  hRC = wglCreateContext(hDC);
  wglMakeCurrent(hDC, hRC);
  ShowWindow(hWnd, SW_SHOW);
  SetForegroundWindow(hWnd);
  SetFocus(hWnd);
  ReSizeGLScene(p_width, p_height);
  InitGL();
  return true;
}</pre></div><p>The purpose of <code class="literal">CreateGLWindow</code> is to create a window with settings that allow it to work with <a id="id515" class="indexterm"/>OpenGL. The main tasks accomplished by this function are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set the window properties</li><li class="listitem" style="list-style-type: disc">Register the application with Windows—<code class="literal">RegisterClass</code></li><li class="listitem" style="list-style-type: disc">Set up full screen mode if required—<code class="literal">ChangeDisplaySettings</code></li><li class="listitem" style="list-style-type: disc">Create the Window—<code class="literal">CreateWindowEx</code></li><li class="listitem" style="list-style-type: disc">Get a Windows device context—<code class="literal">GetDC</code></li><li class="listitem" style="list-style-type: disc">Set the OpenGL pixel format—<code class="literal">SetPixelFormat</code></li><li class="listitem" style="list-style-type: disc">Create an OpenGL rendering context—<code class="literal">wglCreateContext</code></li><li class="listitem" style="list-style-type: disc">Bind the Windows device context and OpenGL rendering context together—<code class="literal">wglMakeCurrent</code></li><li class="listitem" style="list-style-type: disc">Show the window—<code class="literal">ShowWindow</code>, <code class="literal">SetForegroundWindow(hWnd)</code>, and <code class="literal">SetFocus(hWnd)</code></li><li class="listitem" style="list-style-type: disc">Initialize the OpenGL Window—<code class="literal">ReSizeGLScene</code>, <code class="literal">InitGL</code>; create the <code class="literal">WinMain</code> function</li></ul></div><p>The <code class="literal">WinMain</code> function is the entry point for the application. Add the following code:</p><div class="informalexample"><pre class="programlisting">int APIENTRY WinMain(_In_ HINSTANCE hInstance,
_In_opt_ HINSTANCE hPrevInstance,
_In_ LPTSTR    lpCmdLine,
_In_ int       nCmdShow)
{
  MSG msg;
  bool done = false;
  if (!CreateGLWindow("SpaceRacer3D", 800, 600, 16, false))
  {
    return false;
  }
  StartGame();
  int previousTime = glutGet(GLUT_ELAPSED_TIME);
  while (!done)
  {
    if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
    {
      if (msg.message == WM_QUIT)
      {
        done = true;
      }
      else
      {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
      }
    }
    else
    {
      int currentTime = glutGet(GLUT_ELAPSED_TIME);
      float deltaTime = (float)(currentTime - previousTime) / 1000;
      previousTime = currentTime;
      GameLoop(deltaTime);
    }
  }
  EndGame();
  return (int)msg.wParam;
}</pre></div><p>It calls all<a id="id516" class="indexterm"/> of the other functions to initialize Windows, and OpenGL then starts the main message loop, which we hijack and adapt to be our game loop. As we explained all of this code in <a class="link" href="ch01.html" title="Chapter 1. Building the Foundation">Chapter 1</a>, <span class="emphasis"><em>Building the Foundation</em></span> we won't do it again here.</p></div><div class="section" title="Creating the Windows event handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec137"/>Creating the Windows event handler</h2></div></div></div><p>Finally, we have to have an event handler to receive events from Windows and process them. We<a id="id517" class="indexterm"/> created the forward declaration at the top of the code, and now we will actually implement the handler. Add the following code:</p><div class="informalexample"><pre class="programlisting">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
  {
    case WM_DESTROY:
    PostQuitMessage(0);
    break;
    case WM_SIZE:
    ReSizeGLScene(LOWORD(lParam), HIWORD(lParam));
    return 0;
    default:
    return DefWindowProc(hWnd, message, wParam, lParam);
  }
  return false;
}</pre></div><p>This function <a id="id518" class="indexterm"/>will be called any time Windows sends an event to our program. We handle two events: <code class="literal">WM_DESTROY</code> and <code class="literal">WM_SIZE</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">WM_DESTROY</code> is triggered when the window is closed. When this happens we use <code class="literal">PostQuitMessage</code> to tell our main game loop that it is time to stop.</li><li class="listitem" style="list-style-type: disc"><code class="literal">WM_SIZE</code> is triggered when the window is resized. When this happens, we call <code class="literal">ReSizeGLScene</code>.</li></ul></div></div><div class="section" title="The Game loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec138"/>The Game loop</h2></div></div></div><p>We still need to<a id="id519" class="indexterm"/> add some stub functions for our game functions: <code class="literal">StartGame</code>, <code class="literal">Update</code>, <code class="literal">Render</code>, <code class="literal">EndGame</code>, and <code class="literal">GameLoop</code>. Add the following code before the <code class="literal">WinMain</code> function:</p><div class="informalexample"><pre class="programlisting">void StartGame()
{
  
}

void Update(const float p_deltaTime)
{
}

void Render()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  DrawCube();
  SwapBuffers(hDC);
}

void EndGame()
{
}

void GameLoop(const float p_deltatTime)
{
  Update(p_deltatTime);
  Render();
}</pre></div><p>These<a id="id520" class="indexterm"/> functions serve the same purpose that they did in RoboRacer2D. <code class="literal">GameLoop</code> is called from the Windows main loop, and in turn calls <code class="literal">Update</code> and <code class="literal">Render</code>. <code class="literal">StartGame</code> is called before the Windows main loop, and <code class="literal">EndGame</code> is called when the game ends.</p></div><div class="section" title="The finale"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec139"/>The finale</h2></div></div></div><p>If you run the <a id="id521" class="indexterm"/>game right now, you will see a nice black window. This is because we haven't told the program to draw anything yet! It seemed unfair to do all this work and get a black screen, so if you want to do a little extra work, add the following code just before the <code class="literal">StartGame</code> function:</p><div class="informalexample"><pre class="programlisting">void DrawCube()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glTranslatef(0.0f, 0.0f, -7.0f);
  glRotatef(fRotate, 1.0f, 1.0f, 1.0f);
  glBegin(GL_QUADS);
  glColor3f(0.0f, 1.0f, 0.0f);
  glVertex3f(1.0f, 1.0f, -1.0f); glVertex3f(-1.0f, 1.0f, -1.0f);
  glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f(1.0f, 1.0f, 1.0f);
  glColor3f(1.0f, 0.5f, 0.0f);
  glVertex3f(1.0f, -1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, 1.0f);
  glVertex3f(-1.0f, -1.0f, -1.0f); glVertex3f(1.0f, -1.0f, -1.0f);
  glColor3f(1.0f, 0.0f, 0.0f);
  glVertex3f(1.0f, 1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
  glVertex3f(-1.0f, -1.0f, 1.0f); glVertex3f(1.0f, -1.0f, 1.0f);
  glColor3f(1.0f, 1.0f, 0.0f);
  glVertex3f(1.0f, -1.0f, -1.0f); glVertex3f(-1.0f, -1.0f, -1.0f);
  glVertex3f(-1.0f, 1.0f, -1.0f); glVertex3f(1.0f, 1.0f, -1.0f);
  glColor3f(0.0f, 0.0f, 1.0f);
  glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f);
  glVertex3f(-1.0f, -1.0f, -1.0f); glVertex3f(-1.0f, -1.0f, 1.0f);
  glColor3f(1.0f, 0.0f, 1.0f);
  glVertex3f(1.0f, 1.0f, -1.0f); glVertex3f(1.0f, 1.0f, 1.0f);
  glVertex3f(1.0f, -1.0f, 1.0f); glVertex3f(1.0f, -1.0f, -1.0f);
  glEnd();
  fRotate -= 0.05f;
  
}</pre></div><p>Also, you need to make sure to declare the following global variable:</p><div class="informalexample"><pre class="programlisting">float frotate = 1.0f;</pre></div><p>Now run the <a id="id522" class="indexterm"/>program, and you should see a colorful rotating cube. Don't worry about how this works yet—we will learn that in the next chapter.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we covered a lot of new material related to creating a 3D game. You learned how the game camera worked just like a video camera. Anything in the camera's frustum will be rendered to the screen. You also learned about the 3D coordinate system that is used to place objects in a 3D world. Finally, you learned about matrices and vectors, which form the underpinning of how 3D objects are manipulated.</p><p>Finally, we started with a blank project and walked through all of the code required to set up a 3D game that will use OpenGL to render. Remember, you will never have to memorize this code! But, it is important that you have a basic understanding of what purpose each line of code serves.</p><p>In the next chapter, you will learn to create and load 3D models from modeling program.</p></div></body></html>