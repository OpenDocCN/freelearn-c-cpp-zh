<html><head></head><body>
<div class="book" title="Chapter&#xA0;11.&#xA0;Monsters" id="28FAO1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Monsters</h1></div></div></div><p class="calibre9">We'll add in a bunch of opponents for the player.</p><p class="calibre9">What I've done in this chapter is added a landscape to the example. The player will walk along the path sculpted out for him and then he will encounter an army. There is an NPC before he reaches the army that will offer advice.</p><div class="mediaobject"><img src="../images/00160.jpeg" alt="Monsters" class="calibre11"/><div class="caption"><p class="calibre16">The scene: starting to look like a game</p></div></div><p class="calibre12"> </p></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Monsters" id="28FAO1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Landscape"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec75" class="calibre1"/>Landscape</h1></div></div></div><p class="calibre9">We haven't covered how to<a id="id511" class="calibre1"/> sculpt the landscape in this book yet, but we'll do that here. First, you must have a landscape to work with. Start a new file by navigating to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span>. You can choose an empty level or a level with a sky. I chose the one without the sky in this example.</p><p class="calibre9">To create a <a id="id512" class="calibre1"/>landscape, we have to work from the <span class="strong"><strong class="calibre2">Modes</strong></span> panel. Make sure that the <span class="strong"><strong class="calibre2">Modes</strong></span> panel is displayed by navigating to <span class="strong"><strong class="calibre2">Window</strong></span> | <span class="strong"><strong class="calibre2">Modes</strong></span>:</p><div class="mediaobject"><img src="../images/00161.jpeg" alt="Landscape" class="calibre11"/><div class="caption"><p class="calibre16">Displaying the modes panel</p></div></div><p class="calibre12"> </p><p class="calibre9">A landscape can be created in three steps, which are shown in the following screenshot, followed by the corresponding steps:</p><div class="mediaobject"><img src="../images/00162.jpeg" alt="Landscape" class="calibre11"/></div><p class="calibre12"> </p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Click <a id="id513" class="calibre1"/>on the landscape icon (the picture of the mountains) in the <span class="strong"><strong class="calibre2">Modes</strong></span> panel.</li><li class="listitem" value="2">Click on the <span class="strong"><strong class="calibre2">Manage</strong></span> button.</li><li class="listitem" value="3">Next, click on the <span class="strong"><strong class="calibre2">Create</strong></span> button in the lower right-hand corner of the screen.</li></ol><div class="calibre14"/></div><p class="calibre9">You should now have a landscape to work with. It will appear as a gray, tiled area in the main window:</p><div class="mediaobject"><img src="../images/00163.jpeg" alt="Landscape" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The first thing <a id="id514" class="calibre1"/>you will want to do with your landscape scene is add some color to it. What's a landscape without colors? Right-click anywhere on your gray, tiled landscape object. In the <span class="strong"><strong class="calibre2">Details</strong></span> panel at the right, you will see that it is populated with information, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00164.jpeg" alt="Landscape" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Scroll down until you see the <span class="strong"><strong class="calibre2">Landscape Material</strong></span> property. You can select the <span class="strong"><strong class="calibre2">M_Ground_Grass</strong></span> material for a realistic-looking ground.</p><p class="calibre9">Next, add a light to the scene. You should probably use a directional light so that all of the ground has some light on it.</p></div></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Monsters" id="28FAO1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Landscape">
<div class="book" title="Sculpting the landscape"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec115" class="calibre1"/>Sculpting the landscape</h2></div></div></div><p class="calibre9">A flat landscape can be boring. We will at <a id="id515" class="calibre1"/>least add some curves and hills to the place. To do so, click on the <span class="strong"><strong class="calibre2">Sculpt</strong></span> button in the <span class="strong"><strong class="calibre2">Modes</strong></span> panel:</p><div class="mediaobject"><img src="../images/00165.jpeg" alt="Sculpting the landscape" class="calibre11"/><div class="caption"><p class="calibre16">To change the landscape, click on the Sculpt button</p></div></div><p class="calibre12"> </p><p class="calibre9">The strength and size of <a id="id516" class="calibre1"/>your brush are determined by the <span class="strong"><strong class="calibre2">Brush Size</strong></span> and <span class="strong"><strong class="calibre2">Tool Strength</strong></span> parameters in the <span class="strong"><strong class="calibre2">Modes</strong></span> window.</p><p class="calibre9">Click on your landscape and drag the mouse to change the height of the turf. Once you're happy with what you've got, click on the <span class="strong"><strong class="calibre2">Play</strong></span> button to try it out. The resultant output can be seen in the following screenshot:</p><div class="mediaobject"><img src="../images/00166.jpeg" alt="Sculpting the landscape" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Play around with your landscape and create a scene. What I did was lower the landscape around a flat ground plane, so the player has a well-defined flat area to walk on, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00167.jpeg" alt="Sculpting the landscape" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Feel free to do whatever <a id="id517" class="calibre1"/>you like with your landscape. You can use what I'm doing here as inspiration, if you like. I will recommend that you import assets from <span class="strong"><strong class="calibre2">ContentExamples</strong></span> or from <span class="strong"><strong class="calibre2">StrategyGame</strong></span> in order to use them inside your game. To do this, refer to the <span class="strong"><em class="calibre10">Importing assets</em></span> section in <a class="calibre1" title="Chapter 10. Inventory System and Pickup Items" href="part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d">Chapter 10</a>, <span class="strong"><em class="calibre10">Inventory System and Pickup Items</em></span>. When you're done importing assets, we can proceed to bring monsters into your world.</p></div></div></div>

<div class="book" title="Monsters"><div class="book" id="29DRA2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec76" class="calibre1"/>Monsters</h1></div></div></div><p class="calibre9">We'll start programming <a id="id518" class="calibre1"/>monsters in the same way we programmed NPCs and <code class="email">PickupItem</code>. First, we'll write a base class (by deriving from character) to represent the <code class="email">Monster</code> class. Then, we'll derive a bunch of blueprints for each monster type. Every monster will have a couple of properties in common that determine its behavior. These are the common properties:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A <code class="email">float</code> variable for speed.</li><li class="listitem">A <code class="email">float</code> variable for the <code class="email">HitPoints</code> value (I usually use floats for HP, so we can easily model HP leeching effects such as walking through a pool of lava).</li><li class="listitem">An <code class="email">int32</code> variable for the experience gained in defeating the monster.</li><li class="listitem">A <code class="email">UClass</code> function for the loot dropped by the monster.</li><li class="listitem">A <code class="email">float</code> variable for <code class="email">BaseAttackDamage</code> done on each attack.</li><li class="listitem">A <code class="email">float</code> variable for <code class="email">AttackTimeout</code>, which is the amount of time for which the monster rests between attacking.</li><li class="listitem">Two <code class="email">USphereComponents</code> object: One of them is <code class="email">SightSphere</code>—how far he can see. The other is <code class="email">AttackRangeSphere</code>, which is how far his attack reaches. The <code class="email">AttackRangeSphere</code> object is always smaller than <code class="email">SightSphere</code>.</li></ul></div><p class="calibre9">Derive from<a id="id519" class="calibre1"/> the <code class="email">Character</code> class to create your class for <code class="email">Monster</code>. You can do this in UE4 by going to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">Add Code To Project...</strong></span> and then selecting the <span class="strong"><strong class="calibre2">Character</strong></span> option from the menu for your base class.</p><p class="calibre9">Fill out the <code class="email">Monster</code> class with the base properties. Make sure that you declare <code class="email">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MonsterProperties)</code> so that the properties of the monsters can be changed in the blueprints:</p><div class="note"><pre class="programlisting">UCLASS()
class GOLDENEGG_API AMonster : public ACharacter
{
  GENERATED_UCLASS_BODY()

  // How fast he is
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
  float Speed;

  // The hitpoints the monster has
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
  float HitPoints;

  // Experience gained for defeating
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
  int32 Experience;

  // Blueprint of the type of item dropped by the monster
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
  UClass* BPLoot;

  // The amount of damage attacks do
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
  float BaseAttackDamage;

  // Amount of time the monster needs to rest in seconds
  // between attacking
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
  float AttackTimeout;

  // Time since monster's last strike, readable in blueprints
  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =  MonsterProperties)
  float TimeSinceLastStrike;

  // Range for his sight
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)
  USphereComponent* SightSphere;

  // Range for his attack. Visualizes as a sphere in editor,
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)
  USphereComponent* AttackRangeSphere;
};</pre></div><p class="calibre9">You will need some <a id="id520" class="calibre1"/>bare minimum code in your <code class="email">Monster</code> constructor to get the monster's properties initialized. Use the following code in the <code class="email">Monster.cpp</code> file:</p><div class="note"><pre class="programlisting">AMonster::AMonster(const class FObjectInitializer&amp; PCIP) : Super(PCIP)
{
  Speed = 20;
  HitPoints = 20;
  Experience = 0;
  BPLoot = NULL;
  BaseAttackDamage = 1;
  AttackTimeout = 1.5f;
  TimeSinceLastStrike = 0;

  SightSphere = PCIP.CreateDefaultSubobject&lt;USphereComponent&gt; (this, TEXT("SightSphere"));
  SightSphere-&gt;AttachTo( RootComponent );

  AttackRangeSphere = PCIP.CreateDefaultSubobject &lt;USphereComponent&gt;(this, TEXT("AttackRangeSphere"));
  AttackRangeSphere-&gt;AttachTo( RootComponent );
}</pre></div><p class="calibre9">Compile and run the code. Open Unreal Editor and derive a blueprint based on your <code class="email">Monster</code> class (call it <code class="email">BP_Monster</code>). Now we can start configuring your monster's <code class="email">Monster</code> properties.</p><p class="calibre9">For the skeletal mesh, we won't use the <code class="email">HeroTPP</code> model for the monster because we need the monster to be able to do melee attacks and the <code class="email">HeroTPP</code> model does not come with a melee attack. However, some of the models in the <span class="strong"><strong class="calibre2">Mixamo Animation Pack</strong></span> file have melee attack animations. So download the <span class="strong"><strong class="calibre2">Mixamo Animation Pack</strong></span> file from the UE4 marketplace (free).</p><div class="mediaobject"><img src="../images/00168.jpeg" alt="Monsters" class="calibre11"/><div class="caption"><p class="calibre16">Inside the pack are some pretty gross models that I'd avoid, but others are quite good</p></div></div><p class="calibre12"> </p><p class="calibre9">Next, you should<a id="id521" class="calibre1"/> add the <span class="strong"><strong class="calibre2">Mixamo Animation Pack</strong></span> file to your project, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00169.jpeg" alt="Monsters" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Now, create a blueprint called <code class="email">BP_Monster</code> based on your <code class="email">Monster</code> class. Edit the blueprint's class properties and select <span class="strong"><strong class="calibre2">Mixamo_Adam</strong></span> (it is actually typed as <span class="strong"><strong class="calibre2">Maximo_Adam</strong></span> in the current issue of the package) as the skeletal mesh. Also, select <span class="strong"><strong class="calibre2">MixamoAnimBP_Adam</strong></span> as the animation blueprint.</p><div class="mediaobject"><img src="../images/00170.jpeg" alt="Monsters" class="calibre11"/><div class="caption"><p class="calibre16">Select the Maximo_Adam Skeletal Mesh and MixamoAnimBP_Adam for Anim Blueprint Generated Class</p></div></div><p class="calibre12"> </p><p class="calibre9">We will modify the <a id="id522" class="calibre1"/>animation blueprint to correctly incorporate the melee attack animation later.</p><p class="calibre9">While you're editing your <code class="email">BP_Monster</code> blueprint, change the sizes of the <code class="email">SightSphere</code> and <code class="email">AttackRangeSphere</code> objects to values that make sense to you. I made my monster's <code class="email">AttackRangeSphere</code> object just big enough to be about an arm's reach (60 units) and his <code class="email">SightSphere</code> object to be 25 times bigger than that (about 1,500 units).</p><p class="calibre9">Remember that the monster will start moving towards the player once the player enters the monster's <code class="email">SightSphere</code>, and the monster will start attacking the player once the player is inside the monster's <code class="email">AttackRangeSphere</code> object.</p><div class="mediaobject"><img src="../images/00171.jpeg" alt="Monsters" class="calibre11"/><div class="caption"><p class="calibre16">Mixamo Adam with his AttackRangeSphere object highlighted in orange</p></div></div><p class="calibre12"> </p><p class="calibre9">Place a few of your<a id="id523" class="calibre1"/> <span class="strong"><strong class="calibre2">BP_Monster</strong></span> instances inside your game; compile and run. Without any code to drive the <code class="email">Monster</code> character to move, your monsters should just stand there idly.</p></div>

<div class="book" title="Monsters">
<div class="book" title="Basic monster intelligence"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec116" class="calibre1"/>Basic monster intelligence</h2></div></div></div><p class="calibre9">In our game, we will add only a<a id="id524" class="calibre1"/> basic intelligence to the <code class="email">Monster</code> characters. The monsters will know how to do two basic things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Track the player and follow him</li><li class="listitem">Attack the player</li></ul></div><p class="calibre9">The monster will not do anything else. You can have the monster taunt the player when the player is first seen as well, but we'll leave that as an exercise for you.</p><div class="book" title="Moving the monster – steering behavior"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec43" class="calibre1"/>Moving the monster – steering behavior</h3></div></div></div><p class="calibre9">Monsters in very <a id="id525" class="calibre1"/>basic games don't usually have complex motion behaviors. Usually they just walk towards the target and attack it. We'll program that type of monster in this game, but mind you, you can get more interesting play with monsters that position themselves advantageously on the terrain to perform ranged attacks and so on. We're not going to program that here, but it's something to think about.</p><p class="calibre9">In order to get the <code class="email">Monster</code> character to move towards the player, we need to dynamically update the direction of the <code class="email">Monster</code> character moving in each frame. To update the direction that the monster is facing, we write code in the <code class="email">Monster::Tick()</code> method.</p><p class="calibre9">The <code class="email">Tick</code> function runs in every frame of the game. The signature of the <code class="email">Tick</code> function is:</p><div class="note"><pre class="programlisting">virtual void Tick(float DeltaSeconds) override;</pre></div><p class="calibre9">You need to add this function's prototype to your <code class="email">AMonster</code> class in your <code class="email">Monster.h</code> file. If we override <code class="email">Tick</code>, we can place our own custom behavior that the <code class="email">Monster</code> character should do in each frame. Here's some basic code that will move the monster toward the player during each frame:</p><div class="note"><pre class="programlisting">void AMonster::Tick(float DeltaSeconds)
{
  Super::Tick( DeltaSeconds );

  // basic intel: move the monster towards the player
  AAvatar *avatar = Cast&lt;AAvatar&gt;(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );
  if( !avatar ) return;

  FVector toPlayer = avatar-&gt;GetActorLocation() -  GetActorLocation();
  toPlayer.Normalize();	// reduce to unit vector

  // Actually move the monster towards the player a bit
  AddMovementInput(toPlayer, Speed*DeltaSeconds);

  // At least face the target
  // Gets you the rotator to turn something
  // that looks in the `toPlayer` direction
  FRotator toPlayerRotation = toPlayer.Rotation();
  toPlayerRotation.Pitch = 0; // 0 off the pitch
  RootComponent-&gt;SetWorldRotation( toPlayerRotation );
}</pre></div><p class="calibre9">For <code class="email">AddMovementInput</code> to <a id="id526" class="calibre1"/>work, you must have a controller selected under the <span class="strong"><strong class="calibre2">AIController Class</strong></span> panel in your blueprint, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00172.jpeg" alt="Moving the monster – steering behavior" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">If you have selected <code class="email">None</code>, calls to <code class="email">AddMovementInput</code> won't have any effect. To prevent this, select either the <code class="email">AIController</code> class or the <code class="email">PlayerController</code> class as your <span class="strong"><strong class="calibre2">AIController Class</strong></span>.</p><p class="calibre9">The preceding code is very simple. It comprises the most basic form of enemy intelligence: simply move toward the player by an incrementally small amount in each frame.</p><div class="mediaobject"><img src="../images/00173.jpeg" alt="Moving the monster – steering behavior" class="calibre11"/><div class="caption"><p class="calibre16">Our not-so-intelligent army of monsters chasing the player</p></div></div><p class="calibre12"> </p><p class="calibre9">The result in a series <a id="id527" class="calibre1"/>of frames will be that the monster tracks and follows the player around the level. To understand how this works, you must remember that the <code class="email">Tick</code> function is called on average about 60 times per second. What this means is that in each frame, the monster moves a tiny bit closer to the player. Since the monster moves in very small steps, his action looks smooth and continuous (while in reality, he is making small jumps and leaps in each frame).</p><div class="mediaobject"><img src="../images/00174.jpeg" alt="Moving the monster – steering behavior" class="calibre11"/><div class="caption"><p class="calibre16">Discrete nature of tracking: a monster's motion over three superimposed frames</p></div></div><p class="calibre12"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip55" class="calibre1"/>Tip</h3><p class="calibre9">The reason<a id="id528" class="calibre1"/> why the monster moves about 60 times a second is because of a hardware constraint. The refresh rate of a typical monitor is 60 Hz, so it acts as a practical limiter on how many updates per second are useful. Updating at a frame rate faster than the refresh rate is possible, but it is not necessarily useful for games since you will only see a new picture once every 1/60 of a second on most hardware. Some advanced physics modeling simulations do almost 1,000 updates a second, but arguably, you don't need that kind of resolution for a game and you should reserve the extra CPU time for something that the player will enjoy instead, such as better AI algorithms. Some newer hardware boasts of a refresh rate up to 120 Hz (look up gaming monitors, but don't tell your parents I asked you to blow all your money on one).</p></div></div><div class="book" title="The discrete nature of monster motion"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec44" class="calibre1"/>The discrete nature of monster motion</h3></div></div></div><p class="calibre9">Computer games <a id="id529" class="calibre1"/>are discrete in nature. In the preceding screenshot of superimposed sequences of frames, the player is seen as moving straight up the screen, in tiny steps. The motion of the monster is also in small steps. In each frame, the monster takes one small discrete step towards the player. The monster is following an apparently curved path as he moves directly toward where the player is in each frame.</p><p class="calibre9">To move the monster toward the player, we first have to get the player's position. Since the player is accessible in a global function, <code class="email">UGameplayStatics::GetPlayerPawn</code>, we simply retrieve our pointer to the player using this function. Next we find the vector pointing from the <code class="email">Monster</code> (<code class="email">GetActorLocation()</code>) function that points to the player (<code class="email">avatar-&gt;GetActorLocation()</code>). We need to find the vector that points from the monster to the avatar. To do this, you have to subtract the location of the monster from the location of the avatar, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00175.jpeg" alt="The discrete nature of monster motion" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">It's a simple math <a id="id530" class="calibre1"/>rule to remember but often easy to get wrong. To get the right vector, always subtract the source (the starting point) vector from the target (the terminal point) vector. In our system, we have to subtract the <code class="email">Monster</code> vector from the <code class="email">Avatar</code> vector. This works because subtracting the <code class="email">Monster</code> vector from the system moves the <code class="email">Monster</code> vector to the origin and the <code class="email">Avatar</code> vector will be to the lower left-hand side of the <code class="email">Monster</code> vector:</p><div class="mediaobject"><img src="../images/00176.jpeg" alt="The discrete nature of monster motion" class="calibre11"/><div class="caption"><p class="calibre16">Subtracting the Monster vector from the system moves the Monster vector to (0,0)</p></div></div><p class="calibre12"> </p><p class="calibre9">Be sure to try out your <a id="id531" class="calibre1"/>code. At this point, the monsters will be running toward your player and crowding around him. With the preceding code that is outlined, they won't attack; they'll just follow him around, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00177.jpeg" alt="The discrete nature of monster motion" class="calibre11"/></div><p class="calibre12"> </p></div><div class="book" title="Monster SightSphere"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec45" class="calibre1"/>Monster SightSphere</h3></div></div></div><p class="calibre9">Right now, the<a id="id532" class="calibre1"/> monsters are not paying attention to the <code class="email">SightSphere</code> <a id="id533" class="calibre1"/>component. That is, wherever the player is in the world, the monsters will move toward him in the current setup. We want to change that now.</p><p class="calibre9">To do so, all we have to do is have <code class="email">Monster</code> respect the <code class="email">SightSphere</code> restriction. If the player is inside the monster's <code class="email">SightSphere</code> object, the monster will give chase. Otherwise, the monsters will be oblivious to the player's location and not chase the player.</p><p class="calibre9">Checking to see if an object is inside a sphere is simple. In the following screenshot, the point <span class="strong"><strong class="calibre2">p</strong></span> is inside the sphere if the distance <span class="strong"><strong class="calibre2">d</strong></span> between <span class="strong"><strong class="calibre2">p</strong></span> and the centroid <span class="strong"><strong class="calibre2">c</strong></span> is less than the sphere radius, <span class="strong"><strong class="calibre2">r</strong></span>:</p><div class="mediaobject"><img src="../images/00178.jpeg" alt="Monster SightSphere" class="calibre11"/><div class="caption"><p class="calibre16">P is inside the sphere when d is less than r</p></div></div><p class="calibre12"> </p><p class="calibre9">So, in our code, the <a id="id534" class="calibre1"/>preceding screenshot translates to the following <a id="id535" class="calibre1"/>code:</p><div class="note"><pre class="programlisting">void AMonster::Tick(float DeltaSeconds)
{
  Super::Tick( DeltaSeconds );
  AAvatar *avatar = Cast&lt;AAvatar&gt;(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );
  if( !avatar ) return;
    FVector toPlayer = avatar-&gt;GetActorLocation() -  GetActorLocation();
  float distanceToPlayer = toPlayer.Size();
  // If the player is not in the SightSphere of the monster,
  // go back
  if( distanceToPlayer &gt; SightSphere-&gt;GetScaledSphereRadius() )
  {
    // If the player is out of sight,
    // then the enemy cannot chase
    return;
  }

  toPlayer /= distanceToPlayer;  // normalizes the vector
  // Actually move the monster towards the player a bit
  AddMovementInput(toPlayer, Speed*DeltaSeconds);
  // (rest of function same as before (rotation))
}</pre></div><p class="calibre9">The preceding code adds additional intelligence to the <code class="email">Monster</code> character. The <code class="email">Monster</code> character can now stop chasing the player if the player is outside the monster's <code class="email">SightSphere</code> object. This is how the result will look:</p><div class="mediaobject"><img src="../images/00179.jpeg" alt="Monster SightSphere" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">A good thing to do here <a id="id536" class="calibre1"/>will be to wrap up the distance comparison into a <a id="id537" class="calibre1"/>simple inline function. We can provide these two inline member functions in the <code class="email">Monster</code> header as follows:</p><div class="note"><pre class="programlisting">inline bool isInSightRange( float d )
{ return d &lt; SightSphere-&gt;GetScaledSphereRadius(); }
inline bool isInAttackRange( float d )
{ return d &lt; AttackRangeSphere-&gt;GetScaledSphereRadius(); }</pre></div><p class="calibre9">These functions return the value <code class="email">true</code> when the passed parameter, <code class="email">d</code>, is inside the spheres in question.</p><div class="note" title="Note"><h3 class="title2"><a id="tip56" class="calibre1"/>Tip</h3><p class="calibre9">An <code class="email">inline</code> function means that the function is more like a macro than a function. Macros are copied and pasted to the calling location, while functions are jumped to by C++ and executed at their location. Inline functions are good because they give good performance while keeping the code easy to read and they are reusable.</p></div></div></div></div>

<div class="book" title="Monster attacks on the player"><div class="book" id="2ACBS2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec77" class="calibre1"/>Monster attacks on the player</h1></div></div></div><p class="calibre9">There are a few<a id="id538" class="calibre1"/> different types of attacks that monsters can do. Depending on the type of the <code class="email">Monster</code> character, a monster's attack might be melee (close range) or ranged (projectile weapon).</p><p class="calibre9">The <code class="email">Monster</code> character will attack the player whenever the player is in his <code class="email">AttackRangeSphere</code>. If the player is out of the range of the monster's <code class="email">AttackRangeSphere</code> but the player is in the <code class="email">SightSphere</code> object of the monster, then the monster will move closer to the player until the player is in the monster's <code class="email">AttackRangeSphere</code>.</p></div>

<div class="book" title="Monster attacks on the player">
<div class="book" title="Melee attacks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec117" class="calibre1"/>Melee attacks</h2></div></div></div><p class="calibre9">The <a id="id539" class="calibre1"/>dictionary definition <a id="id540" class="calibre1"/>of <span class="strong"><em class="calibre10">melee</em></span> is a confused mass of people. A melee attack is one that is done at a close range. Picture a bunch of <span class="strong"><em class="calibre10">zerglings</em></span> battling it out with a bunch of <span class="strong"><em class="calibre10">ultralisks</em></span> (if you're a <span class="strong"><em class="calibre10">StarCraft</em></span> player, you'll know that both zerglings and ultralisks are melee units). Melee attacks are basically close range, hand-to-hand combat. To do a melee attack, you need a melee attack animation that turns on when the monster begins his melee attack. To do this, you need to edit the animation blueprint in <span class="strong"><em class="calibre10">Persona</em></span>, UE4's animation editor.</p><div class="note" title="Note"><h3 class="title2"><a id="tip57" class="calibre1"/>Tip</h3><p class="calibre9">Zak Parrish's <span class="strong"><em class="calibre10">Persona</em></span> series is an excellent place to get started with in order to program animations in blueprints: <a class="calibre1" href="https://www.youtube.com/watch?v=AqYmC2wn7Cg&amp;list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&amp;index=8">https://www.youtube.com/watch?v=AqYmC2wn7Cg&amp;list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&amp;index=8</a>.</p></div><p class="calibre9">For now, we will just program the melee attack and then worry about modifying the animation in blueprints later.</p><div class="book" title="Defining a melee weapon"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec46" class="calibre1"/>Defining a melee weapon</h3></div></div></div><p class="calibre9">There are going to be<a id="id541" class="calibre1"/> three parts to defining our melee weapon. The<a id="id542" class="calibre1"/> first part is the C++ code that represents it. The second is the model, and the third is to connect the code and model together using a UE4 blueprint.</p><div class="book" title="Coding for a melee weapon in C++"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec05" class="calibre1"/>Coding for a melee weapon in C++</h4></div></div></div><p class="calibre9">We will define a <a id="id543" class="calibre1"/>new class, <code class="email">AMeleeWeapon</code> (derived from <code class="email">AActor</code>), to represent hand-held combat weapons. I will attach a couple of blueprint-editable properties to the <code class="email">AMeleeWeapon</code> class, and the <code class="email">AMeleeWeapon</code> class will look as shown in the following code:</p><div class="note"><pre class="programlisting">class AMonster;

UCLASS()
class GOLDENEGG_API AMeleeWeapon : public AActor
{
  GENERATED_UCLASS_BODY()

  // The amount of damage attacks by this weapon do
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MeleeWeapon)
  float AttackDamage;

  // A list of things the melee weapon already hit this swing
  // Ensures each thing sword passes thru only gets hit once
  TArray&lt;AActor*&gt; ThingsHit;

  // prevents damage from occurring in frames where
  // the sword is not swinging
  bool Swinging;

  // "Stop hitting yourself" - used to check if the 
  // actor holding the weapon is hitting himself
  AMonster *WeaponHolder;

  // bounding box that determines when melee weapon hit
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  MeleeWeapon)
  UBoxComponent* ProxBox;

  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  MeleeWeapon)
  UStaticMeshComponent* Mesh;

  UFUNCTION(BlueprintNativeEvent, Category = Collision)
  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;  SweepResult );
  void Swing();
  void Rest();
};</pre></div><p class="calibre9">Notice how I used a <a id="id544" class="calibre1"/>bounding box for <code class="email">ProxBox</code>, and not a bounding sphere. This is because swords and axes will be better approximated by boxes rather than spheres. There are two member functions, <code class="email">Rest()</code> and <code class="email">Swing()</code>, which let <code class="email">MeleeWeapon</code> know what state the actor is in (resting or swinging). There's also a <code class="email">TArray&lt;AActor*&gt; ThingsHit</code> property inside this class that keeps track of the actors hit by this melee weapon on each swing. We are programming it so that the weapon can only hit each thing once per swing.</p><p class="calibre9">The <code class="email">AMeleeWeapon.cpp</code> file will <a id="id545" class="calibre1"/>contain just a basic constructor and some simple code to send damages to <code class="email">OtherActor</code> when our sword hits him. We will also implement the <code class="email">Rest()</code> and <code class="email">Swing()</code> functions to clear the list of things hit. The <code class="email">MeleeWeapon.cpp</code> file has the following code:</p><div class="note"><pre class="programlisting">AMeleeWeapon::AMeleeWeapon(const class FObjectInitializer&amp; PCIP) :  Super(PCIP)
{
  AttackDamage = 1;
  Swinging = false;
  WeaponHolder = NULL;

  Mesh = PCIP.CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(this,  TEXT("Mesh"));
  RootComponent = Mesh;

  ProxBox = PCIP.CreateDefaultSubobject&lt;UBoxComponent&gt;(this,  TEXT("ProxBox"));
  ProxBox-&gt;OnComponentBeginOverlap.AddDynamic( this,  &amp;AMeleeWeapon::Prox );
  ProxBox-&gt;AttachTo( RootComponent );
}

void AMeleeWeapon::Prox_Implementation( AActor* OtherActor,  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool  bFromSweep, const FHitResult &amp; SweepResult )
{
  // don't hit non root components
  if( OtherComp != OtherActor-&gt;GetRootComponent() )
  {
    return;
  }

  // avoid hitting things while sword isn't swinging,
  // avoid hitting yourself, and
  // avoid hitting the same OtherActor twice
  if( Swinging &amp;&amp; OtherActor != WeaponHolder &amp;&amp;  !ThingsHit.Contains(OtherActor) )
  {
    OtherActor-&gt;TakeDamage( AttackDamage + WeaponHolder- &gt;BaseAttackDamage, FDamageEvent(), NULL, this );
    ThingsHit.Add( OtherActor );
  }
}
void AMeleeWeapon::Swing()
{
  ThingsHit.Empty();  // empty the list
  Swinging = true;
}
void AMeleeWeapon::Rest()
{
  ThingsHit.Empty();
  Swinging = false;
}</pre></div></div><div class="book" title="Downloading a sword"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec06" class="calibre1"/>Downloading a sword</h4></div></div></div><p class="calibre9">To complete this<a id="id546" class="calibre1"/> exercise, we need a sword to put into the model's hand. I added a sword to the project called <span class="strong"><em class="calibre10">Kilic</em></span> from <a class="calibre1" href="http://tf3dm.com/3d-model/sword-95782.html">http://tf3dm.com/3d-model/sword-95782.html</a> by Kaan Gülhan. The following is a list of other places where you will get free models:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="http://www.turbosquid.com/">http://www.turbosquid.com/</a></li><li class="listitem"><a class="calibre1" href="http://tf3dm.com/">http://tf3dm.com/</a></li><li class="listitem"><a class="calibre1" href="http://archive3d.net/">http://archive3d.net/</a></li><li class="listitem"><a class="calibre1" href="http://www.3dtotal.com/">http://www.3dtotal.com/</a></li></ul></div><div class="note" title="Note"><h3 class="title2"><a id="tip58" class="calibre1"/>Tip</h3><p class="calibre9">
<span class="strong"><strong class="calibre2">Secret tip</strong></span>
</p><p class="calibre9">It might appear at first on <a class="calibre1" href="http://TurboSquid.com">TurboSquid.com</a> that there are no free models. In fact, the secret is that you have to search in the price range $0-$0 to find them. $0 means free.</p></div><div class="mediaobject"><img src="../images/00180.jpeg" alt="Downloading a sword" class="calibre11"/><div class="caption"><p class="calibre16">TurboSquid's search for free swords</p></div></div><p class="calibre12"> </p><p class="calibre9">I had to edit the <span class="strong"><em class="calibre10">kilic</em></span> sword mesh slightly to fix the initial sizing and rotation. You can import any mesh in the <span class="strong"><strong class="calibre2">Filmbox</strong></span> (<span class="strong"><strong class="calibre2">FBX</strong></span>) format into your game. The kilic sword model is in the sample code package for <a class="calibre1" title="Chapter 11. Monsters" href="part0076_split_000.html#28FAO1-dd4a3f777fc247568443d5ffb917736d">Chapter 11</a>, <span class="strong"><em class="calibre10">Monsters</em></span>.</p><p class="calibre9">To import your<a id="id547" class="calibre1"/> sword into the UE4 editor, right-click on any folder you want to add the model to. Navigate to <span class="strong"><strong class="calibre2">New Asset</strong></span> | <span class="strong"><strong class="calibre2">Import to </strong></span>| <span class="strong"><strong class="calibre2">Game</strong></span> | <span class="strong"><strong class="calibre2">Models...</strong></span>, and from the file explorer that pops up, select the new asset you want to import. If a <span class="strong"><strong class="calibre2">Models</strong></span> folder doesn't exist, you can create one by simply right-clicking on the tree view at the left and selecting <span class="strong"><strong class="calibre2">New Folder</strong></span> in the pane on the left-hand side of the <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab. I selected the <code class="email">kilic.fbx</code> asset from my desktop.</p><div class="mediaobject"><img src="../images/00181.jpeg" alt="Downloading a sword" class="calibre11"/><div class="caption"><p class="calibre16">Importing to your project</p></div></div><p class="calibre12"> </p></div><div class="book" title="Creating a blueprint for your melee weapon"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec07" class="calibre1"/>Creating a blueprint for your melee weapon</h4></div></div></div><p class="calibre9">Inside the<a id="id548" class="calibre1"/> UE4 editor, create a blueprint based off of <code class="email">AMeleeWeapon</code> called <code class="email">BP_MeleeSword</code>. Configure <code class="email">BP_MeleeSword</code> to use the <span class="strong"><em class="calibre10">kilic</em></span> blade model (or any blade model you choose), as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00182.jpeg" alt="Creating a blueprint for your melee weapon" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The <code class="email">ProxBox</code> class <a id="id549" class="calibre1"/>will determine whether something was hit by the weapon, so we will modify the <code class="email">ProxBox</code> class such that it just encloses the blade of the sword, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00183.jpeg" alt="Creating a blueprint for your melee weapon" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Also, under the <a id="id550" class="calibre1"/>
<span class="strong"><strong class="calibre2">Collision Presets</strong></span> panel, it is important to select the <span class="strong"><strong class="calibre2">NoCollision</strong></span> option for the mesh (not <span class="strong"><strong class="calibre2">BlockAll</strong></span>). This is illustrated in the following screenshot:</p><div class="mediaobject"><img src="../images/00184.jpeg" alt="Creating a blueprint for your melee weapon" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">If you select <a id="id551" class="calibre1"/>
<span class="strong"><strong class="calibre2">BlockAll</strong></span>, then the game engine will automatically resolve all the interpenetration between the sword and the characters by pushing away things that the sword touches whenever it is swung. The result is that your characters will appear to go flying whenever a sword is swung.</p></div></div></div></div>

<div class="book" title="Monster attacks on the player">
<div class="book" title="Sockets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec118" class="calibre1"/>Sockets</h2></div></div></div><p class="calibre9">A socket in UE4 is <a id="id552" class="calibre1"/>a receptacle on one skeletal mesh for <a id="id553" class="calibre1"/>another <code class="email">Actor</code>. You can place a socket anywhere on a skeletal mesh body. After you have correctly placed the socket, you can attach another <code class="email">Actor</code> to this socket in UE4 code.</p><p class="calibre9">For example, if we want to put a sword in our monster's hand, we'd just have to create a socket in our monster's hand. We can attach a helmet to the player by creating a socket on his head.</p><div class="book" title="Creating a skeletal mesh socket in the monster's hand"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec47" class="calibre1"/>Creating a skeletal mesh socket in the monster's hand</h3></div></div></div><p class="calibre9">To attach a socket to the<a id="id554" class="calibre1"/> monster's hand, we have to edit the skeletal mesh that the monster is using. Since we used the <code class="email">Mixamo_Adam</code> skeletal mesh for the monster, we have to open and edit this skeletal mesh.</p><p class="calibre9">To do so, double-click on the <span class="strong"><strong class="calibre2">Mixamo_Adam</strong></span> skeletal mesh in the <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab (this will appear as the T-pose) to open the skeletal mesh editor. If you don't see <span class="strong"><strong class="calibre2">Mixamo Adam</strong></span> in your <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab, make sure that you have imported the <span class="strong"><strong class="calibre2">Mixamo Animation Pack</strong></span> file into your project from the Unreal Launcher app.</p><div class="mediaobject"><img src="../images/00185.jpeg" alt="Creating a skeletal mesh socket in the monster's hand" class="calibre11"/><div class="caption"><p class="calibre16">Edit the Maximo_Adam mesh by double-clicking on the Maximo_Adam skeletal mesh object</p></div></div><p class="calibre12"> </p><p class="calibre9">Click on <span class="strong"><strong class="calibre2">Skeleton</strong></span> at the top-right corner of the screen. Scroll down the tree of bones in the left-hand side panel until you find the <span class="strong"><strong class="calibre2">RightHand</strong></span> bone. We will attach a socket to this bone. Right-click on the <span class="strong"><strong class="calibre2">RightHand</strong></span> bone and select <span class="strong"><strong class="calibre2">Add Socket</strong></span>, as shown in the following <a id="id555" class="calibre1"/>screenshot:</p><div class="mediaobject"><img src="../images/00186.jpeg" alt="Creating a skeletal mesh socket in the monster's hand" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">You can leave the default name (<span class="strong"><strong class="calibre2">RightHandSocket</strong></span>) or rename the socket if you like, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00187.jpeg" alt="Creating a skeletal mesh socket in the monster's hand" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Next, we need to add a sword to the actor's hand.</p></div><div class="book" title="Attaching the sword to the model"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec48" class="calibre1"/>Attaching the sword to the model</h3></div></div></div><p class="calibre9">With the Adam<a id="id556" class="calibre1"/> skeletal mesh open, find the <span class="strong"><strong class="calibre2">RightHandSocket</strong></span> option in the tree view. Since Adam swings with his right hand, you should attach the sword to his right hand. Drag and drop your sword model into the <span class="strong"><strong class="calibre2">RightHandSocket</strong></span> option. You should see Adam grip the sword in the image of the model at the right-hand side of the following screenshot:</p><div class="mediaobject"><img src="../images/00188.jpeg" alt="Attaching the sword to the model" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Now, click on <a id="id557" class="calibre1"/>
<span class="strong"><strong class="calibre2">RightHandSocket</strong></span> and zoom in on Adam's hand. We need to adjust the positioning of the socket in the preview so that the sword fits in it correctly. Use the move and rotate manipulators to line the sword up so that it fits in his hand correctly.</p><div class="mediaobject"><img src="../images/00189.jpeg" alt="Attaching the sword to the model" class="calibre11"/><div class="caption"><p class="calibre16">Positioning the socket in the right hand so that the sword rests correctly</p></div></div><p class="calibre12"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip59" class="calibre1"/>Tip</h3><p class="calibre9">
<span class="strong"><strong class="calibre2">A real-world tip</strong></span>
</p><p class="calibre9">If you have several sword models that you want to switch in and out of the same <span class="strong"><strong class="calibre2">RightHandSocket</strong></span>, you will need to ensure quite a bit of uniformity (lack of anomalies) between the different swords that are supposed to go in that same socket.</p></div><p class="calibre9">You can preview <a id="id558" class="calibre1"/>your animations with the sword in the hand by going to the <span class="strong"><strong class="calibre2">Animation</strong></span> tab in the top-right corner of the screen.</p><div class="mediaobject"><img src="../images/00190.jpeg" alt="Attaching the sword to the model" class="calibre11"/><div class="caption"><p class="calibre16">Equipping the model with a sword</p></div></div><p class="calibre12"> </p><p class="calibre9">However, if you launch your game, Adam won't be holding a sword. That's because adding the sword to the socket in <span class="strong"><em class="calibre10">Persona</em></span> is for preview purposes only.</p></div><div class="book" title="Code to equip the player with a sword"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec49" class="calibre1"/>Code to equip the player with a sword</h3></div></div></div><p class="calibre9">To equip your <a id="id559" class="calibre1"/>player with a sword from the code and permanently bind it to the actor, instantiate an <code class="email">AMeleeWeapon</code> instance and attach it to <code class="email">RightHandSocket</code> after the monster instance is initialized. We do this in <code class="email">PostInitializeComponents()</code> since in this function the <code class="email">Mesh</code> object will have been fully initialized already.</p><p class="calibre9">In the <code class="email">Monster.h</code> file, add a hook to select the <span class="strong"><strong class="calibre2">Blueprint</strong></span> class name (<code class="email">UClass</code>) of a melee weapon to use. Also add a hook for a variable to actually store the <code class="email">MeleeWeapon</code> instance using the following code:</p><div class="note"><pre class="programlisting">// The MeleeWeapon class the monster uses
// If this is not set, he uses a melee attack
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
UClass* BPMeleeWeapon;

// The MeleeWeapon instance (set if the character is using
// a melee weapon)
AActor* MeleeWeapon;</pre></div><p class="calibre9">Now, select the <code class="email">BP_MeleeSword</code> blueprint in your monster's blueprint class.</p><p class="calibre9">In the C++ code, you need to instantiate the weapon. To do so, we need to declare and implement a <code class="email">PostInitializeComponents</code> function for the <code class="email">Monster</code> class. In <code class="email">Monster.h</code>, add a prototype declaration:</p><div class="note"><pre class="programlisting">virtual void PostInitializeComponents() override;</pre></div><p class="calibre9">
<code class="email">PostInitializeComponents</code> runs after the monster object's constructor has completed and all the <a id="id560" class="calibre1"/>components of the object are initialized (including the blueprint construction). So it is the perfect time to check whether the monster has a <code class="email">MeleeWeapon</code> blueprint attached to it or not and to instantiate this weapon if it does. The following code is added to instantiate the weapon in the <code class="email">Monster.cpp</code> implementation of <code class="email">AMonster::PostInitializeComponents()</code>:</p><div class="note"><pre class="programlisting">void AMonster::PostInitializeComponents()
{
  Super::PostInitializeComponents();

  // instantiate the melee weapon if a bp was selected
  if( BPMeleeWeapon )
  {
    MeleeWeapon = GetWorld()-&gt;SpawnActor&lt;AMeleeWeapon&gt;(
      BPMeleeWeapon, FVector(), FRotator() );

    if( MeleeWeapon )
    {
      const USkeletalMeshSocket *socket = Mesh-&gt;GetSocketByName(  "RightHandSocket" ); // be sure to use correct
                           // socket name!
      socket-&gt;AttachActor( MeleeWeapon, Mesh );
    }
  }
}</pre></div><p class="calibre9">The monsters will now start with  swords in hand if <code class="email">BPMeleeWeapon</code> is selected for that monster's blueprint.</p><div class="mediaobject"><img src="../images/00191.jpeg" alt="Code to equip the player with a sword" class="calibre11"/><div class="caption"><p class="calibre16">Monsters holding weapons</p></div></div><p class="calibre12"> </p></div><div class="book" title="Triggering the attack animation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec50" class="calibre1"/>Triggering the attack animation</h3></div></div></div><p class="calibre9">By default, there is no <a id="id561" class="calibre1"/>connection between our C++ <code class="email">Monster</code> class <a id="id562" class="calibre1"/>and triggering the attack animation; in other words, the <code class="email">MixamoAnimBP_Adam</code> class has no way of knowing when the monster is in the attack state.</p><p class="calibre9">Therefore, we need to update the animation blueprint of the Adam skeleton (<code class="email">MixamoAnimBP_Adam</code>) to include a query in the <code class="email">Monster</code> class variable listing and check whether the monster is in an attacking state. We haven't worked with animation blueprints (or blueprints in general) in this book before, but follow it step by step and you should see it come together.</p><div class="note" title="Note"><h3 class="title2"><a id="tip60" class="calibre1"/>Tip</h3><p class="calibre9">I will introduce blueprints terminology gently here, but I will encourage you to have a look at Zak Parrish's tutorial series at <a class="calibre1" href="https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH">https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH</a> for your first introduction to blueprints.</p></div><div class="book" title="Blueprint basics"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec08" class="calibre1"/>Blueprint basics</h4></div></div></div><p class="calibre9">A UE4 blueprint<a id="id563" class="calibre1"/> is a visual <a id="id564" class="calibre1"/>realization of the code (not to be confused with how sometimes people say that a C++ class is a metaphorical blueprint of a class instance). In UE4 blueprints, instead of actually writing code, you drag and drop elements onto a graph and connect them to achieve desired play. By connecting the right nodes to the right elements, you can program anything you want in your game.</p><div class="note" title="Note"><h3 class="title2"><a id="tip61" class="calibre1"/>Tip</h3><p class="calibre9">This book does not encourage the use of blueprints since we are trying to encourage you to write your own code instead. Animations, however, are best worked with blueprints, because that is what artists and designers will know.</p></div><p class="calibre9">Let's start writing a sample blueprint to get a feel how they work. First, click on the blueprint menu bar at the top and select <span class="strong"><strong class="calibre2">Open Level Blueprint</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00192.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The <span class="strong"><strong class="calibre2">Level Blueprint</strong></span> option executes automatically when you begin the level. Once you open this window, you should see a blank slate to create your gameplay on, as shown here:</p><div class="mediaobject"><img src="../images/00193.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Right-click anywhere on the graph paper. Start typing <code class="email">begin</code> and click on the <span class="strong"><strong class="calibre2">Event Begin Play</strong></span> option from the drop-down list that appears. Ensure that the <span class="strong"><strong class="calibre2">Context Sensitive</strong></span> checkbox is checked, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00194.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Immediately after you click on the <span class="strong"><strong class="calibre2">Event Begin Play</strong></span> option, a red box will appear on your screen. It has a single white pin at the right-hand side. This is called the execution pin, as shown here:</p><div class="mediaobject"><img src="../images/00195.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The first thing that you need to know about animation blueprints is the white pin execution path (the white line). If you've seen a blueprint graph before, you must have noticed a white line going through the graph, as shown in the following diagram:</p><div class="mediaobject"><img src="../images/00196.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The white pin execution path is pretty much equivalent to having lines of code lined up and run one after the other. The white line determines which nodes will get executed and in what order. If a node does not have a white execution pin attached to it, then that node will not get executed at all.</p><p class="calibre9">Drag off the white execution pin from <span class="strong"><strong class="calibre2">Event Begin Play</strong></span>. Start by typing <code class="email">draw debug box</code> in the <span class="strong"><strong class="calibre2">Executable actions</strong></span> dialog. Select the first thing that pops up (<span class="strong"><strong class="calibre2">f</strong></span> <span class="strong"><strong class="calibre2">Draw Debug Box</strong></span>), as shown here:</p><div class="mediaobject"><img src="../images/00197.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Fill in some details for how you want the box to look. Here, I selected the color blue for the box, the center of the box at (0, 0, 100), the size of the box to be (200, 200, 200), and a duration of 180 seconds (be sure to enter a duration that is long enough to see the result), as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00198.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Now click on the <span class="strong"><strong class="calibre2">Play</strong></span> button to realize the graph. Remember that you have to find the world's origin to see the debug box.</p><p class="calibre9">Find the world's origin by placing a golden egg at (0, 0, (some z value)), as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00199.jpeg" alt="Blueprint basics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">This is how the box will look in the level:</p><div class="mediaobject"><img src="../images/00200.jpeg" alt="Blueprint basics" class="calibre11"/><div class="caption"><p class="calibre16">A debug box rendered at the origin</p></div></div><p class="calibre12"> </p></div><div class="book" title="Modifying the animation blueprint for Mixamo Adam"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec09" class="calibre1"/>Modifying the animation blueprint for Mixamo Adam</h4></div></div></div><p class="calibre9">To<a id="id565" class="calibre1"/> integrate our attack animation, we have to modify the blueprint. Under <span class="strong"><strong class="calibre2">Content Browser</strong></span>, open up <code class="email">MixamoAnimBP_Adam</code>.</p><p class="calibre9">The first thing you'll notice is that the graph has two sections: a top section and a bottom section. The top section is marked "<span class="strong"><strong class="calibre2">Basic Character movement</strong></span>...," while the bottom section says "<span class="strong"><strong class="calibre2">Mixamo Example Character Animation</strong></span>...." Basic character movement is in charge of the walking and running movements of the model. We will be working in the <span class="strong"><strong class="calibre2">Mixamo Example Character Animation with Attack and Jump</strong></span> section, which is responsible for the attack animation. We will be working in the latter section of the graph, shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00201.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">When you first open the graph, it starts out by zooming in on a section near the bottom. To scroll up, right-click the mouse and drag it upwards. You can also zoom out using the mouse wheel or by holding down the <span class="strong"><em class="calibre10">Alt</em></span> key and the right mouse button while moving the mouse up.</p><p class="calibre9">Before proceeding, you might want to duplicate the <span class="strong"><strong class="calibre2">MixamoAnimBP_Adam</strong></span> resource so that you don't damage the original, in case you need to go back and change something later. This allows you to easily go back and correct things if you find that you've made a mistake in one of your modifications, without having to reinstall a fresh copy of the whole animation package into your project.</p><div class="mediaobject"><img src="../images/00202.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/><div class="caption"><p class="calibre16">Making a duplicate of the MixamoAnimBP_Adam resource to avoid damaging the original asset</p></div></div><p class="calibre12"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip62" class="calibre1"/>Tip</h3><p class="calibre9">When assets are added to a project from the Unreal Launcher, a copy of the original asset is made, so you can modify <span class="strong"><strong class="calibre2">MixamoAnimBP_Adam</strong></span> in your project now and get a fresh copy of the original assets in a new project later.</p></div><p class="calibre9">We're going <a id="id566" class="calibre1"/>to do only a few things to make Adam swing the sword when he is attacking. Let's do it in order.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Deleting the node that says <span class="strong"><strong class="calibre2">Attacking?</strong></span>:<div class="mediaobject"><img src="../images/00203.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Rearrange the nodes, as follows, with the <span class="strong"><strong class="calibre2">Enable Attack</strong></span> node by itself at the bottom:<div class="mediaobject"><img src="../images/00204.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Next we're <a id="id567" class="calibre1"/>going to handle the monster that this animation is animating. Scroll up the graph a bit and drag the blue dot marked as <span class="strong"><strong class="calibre2">Return Value</strong></span> in the <span class="strong"><strong class="calibre2">Try Get Pawn Owner</strong></span> dialog. Drop it into your graph, and when the pop-up menu appears, select <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> (ensure that <span class="strong"><strong class="calibre2">Context Sensitive</strong></span> is checked, or the <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> option will not appear). The <span class="strong"><strong class="calibre2">Try Get Pawn Owner</strong></span> option gets the <code class="email">Monster</code> instance that owns the animation, which is just the <code class="email">AMonster</code> class object, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00205.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Click on <span class="strong"><strong class="calibre2">+</strong></span> in<a id="id568" class="calibre1"/> the <span class="strong"><strong class="calibre2">Sequence</strong></span> dialog and drag another execution pin from the <span class="strong"><strong class="calibre2">Sequence</strong></span> group to the <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> node instance, as shown in the following screenshot. This ensures that the <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> instance actually gets executed.<div class="mediaobject"><img src="../images/00206.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">The next<a id="id569" class="calibre1"/> step is to pull out the pin from the <span class="strong"><strong class="calibre2">As Monster</strong></span> terminal of the <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> node and look for the <span class="strong"><strong class="calibre2">Is in Attack Range Of Player</strong></span> property:<div class="mediaobject"><img src="../images/00207.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">Take the white execution pin from the <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> node at the left-hand side and drop it into the <span class="strong"><strong class="calibre2">Is in Attack Range Of Player</strong></span> node at the right-hand side:<div class="mediaobject"><img src="../images/00208.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p><p class="calibre26">This<a id="id570" class="calibre1"/> ensures a transfer of control from the <span class="strong"><strong class="calibre2">Cast to Monster</strong></span> operation to the <span class="strong"><strong class="calibre2">Is in Attack Range Of Player</strong></span> node.</p></li><li class="listitem" value="7">Pull the white and red pins over to the <span class="strong"><strong class="calibre2">SET</strong></span> node, as shown here:<div class="mediaobject"><img src="../images/00209.jpeg" alt="Modifying the animation blueprint for Mixamo Adam" class="calibre11"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div><div class="note" title="Note"><h3 class="title2"><a id="tip63" class="calibre1"/>Tip</h3><p class="calibre9">The equivalent pseudocode of the preceding blueprint is something similar to the following:</p><div class="note"><pre class="programlisting">if( Monster.isInAttackRangeOfPlayer() )
{
  Monster.Animation = The Attack Animation;
}</pre></div></div><p class="calibre9">Test your animation. The monster should swing only when he is within the player's range.</p></div><div class="book" title="Code to swing the sword"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec10" class="calibre1"/>Code to swing the sword</h4></div></div></div><p class="calibre9">We want to add an <a id="id571" class="calibre1"/>animation notify event when the sword is swung. First, declare and add a blueprint callable C++ function to your <code class="email">Monster</code> class:</p><div class="note"><pre class="programlisting">// in Monster.h:
UFUNCTION( BlueprintCallable, Category = Collision )
void SwordSwung();</pre></div><p class="calibre9">The <code class="email">BlueprintCallable</code> statement means that it will be possible to call this function from blueprints. In other words, <code class="email">SwordSwung()</code> will be a C++ function that we can invoke from a blueprints node, as shown here:</p><div class="note"><pre class="programlisting">// in Monster.cpp
void AMonster::SwordSwung()
{
  if( MeleeWeapon )
  {
    MeleeWeapon-&gt;Swing();
  }
}</pre></div><p class="calibre9">Next open the <span class="strong"><strong class="calibre2">Mixamo_Adam_Sword_Slash</strong></span> animation by double-clicking on it from your <span class="strong"><strong class="calibre2">Content Browser</strong></span> (it should be in <span class="strong"><strong class="calibre2">MixamoAnimPack/Mixamo_Adam/Anims/Mixamo_Adam_Sword_Slash</strong></span>). Scrub the animation to the point where Adam starts swinging his sword. Right-click on the animation bar and select <span class="strong"><strong class="calibre2">New Notify</strong></span> under <span class="strong"><strong class="calibre2">Add Notify...</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00210.jpeg" alt="Code to swing the sword" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Name the<a id="id572" class="calibre1"/> notification <code class="email">SwordSwung</code>:</p><div class="mediaobject"><img src="../images/00211.jpeg" alt="Code to swing the sword" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The notification name should appear in your animation's timeline, shown as follows:</p><div class="mediaobject"><img src="../images/00212.jpeg" alt="Code to swing the sword" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Save the animation and then open up your version of <span class="strong"><strong class="calibre2">MixamoAnimBP_Adam</strong></span> again. Underneath the <span class="strong"><strong class="calibre2">SET</strong></span> group of nodes, create the following graph:</p><div class="mediaobject"><img src="../images/00213.jpeg" alt="Code to swing the sword" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The <span class="strong"><strong class="calibre2">AnimNotify_SwordSwung</strong></span> node appears when you right-click in the graph (with <span class="strong"><strong class="calibre2">Context Sensitive</strong></span> turned on) and start typing <code class="email">SwordSwung</code>. The <span class="strong"><strong class="calibre2">Cast To Monster</strong></span> node is again fed in from the <span class="strong"><strong class="calibre2">Try Get Pawn Owner</strong></span> node as in step 2 of the <span class="strong"><em class="calibre10">Modifying the animation blueprint for Mixamo Adam</em></span> section. Finally, <span class="strong"><strong class="calibre2">Sword Swung</strong></span> is our blueprint-callable C++ function in the <code class="email">AMonster</code> class.</p><p class="calibre9">If you start <a id="id573" class="calibre1"/>the game now, your monsters will execute their attack animation whenever they actually attack. When the sword's bounding box comes in contact with you, you should see your HP bar go down a bit (recall that the HP bar was added at the end of <a class="calibre1" title="Chapter 8. Actors and Pawns" href="part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d">Chapter 8</a>, <span class="strong"><em class="calibre10">Actors and Pawns</em></span>, as an exercise).</p><div class="mediaobject"><img src="../images/00214.jpeg" alt="Code to swing the sword" class="calibre11"/><div class="caption"><p class="calibre16">Monsters attacking the player</p></div></div><p class="calibre12"> </p></div></div></div></div>

<div class="book" title="Monster attacks on the player">
<div class="book" title="Projectile or ranged attacks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec119" class="calibre1"/>Projectile or ranged attacks</h2></div></div></div><p class="calibre9">Ranged attacks<a id="id574" class="calibre1"/> usually <a id="id575" class="calibre1"/>involve a projectile of some sort. Projectiles<a id="id576" class="calibre1"/> are things such as bullets, but they can also include things such as lightning magic attacks or<a id="id577" class="calibre1"/> fireball attacks. To program a projectile attack, you should spawn a new object and only apply the damage to the player if the projectile reaches the player.</p><p class="calibre9">To implement a basic bullet in UE4, we should derive a new object type. I derived a <code class="email">ABullet</code> class from the <code class="email">AActor</code> class, as shown in the following code:</p><div class="note"><pre class="programlisting">UCLASS()
class GOLDENEGG_API ABullet : public AActor
{
  GENERATED_UCLASS_BODY()

  // How much damage the bullet does.
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  Properties)
  float Damage;

  // The visible Mesh for the component, so we can see
  // the shooting object
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)
  UStaticMeshComponent* Mesh;

  // the sphere you collide with to do impact damage
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)
  USphereComponent* ProxSphere;

  UFUNCTION(BlueprintNativeEvent, Category = Collision)
  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;  SweepResult );
};</pre></div><p class="calibre9">The <code class="email">ABullet</code> class has a couple of important members in it, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A <code class="email">float</code> variable for the damage that a bullet does on contact</li><li class="listitem">A <code class="email">Mesh</code> variable for the body of the bullet</li><li class="listitem">A <code class="email">ProxSphere</code> variable to detect when the bullet finally hits something</li><li class="listitem">A function to be run when <code class="email">Prox</code> near an object is detected</li></ul></div><p class="calibre9">The constructor for the <code class="email">ABullet</code> class should have the initialization of the <code class="email">Mesh</code> and <code class="email">ProxSphere</code> variables. In the constructor, we set <code class="email">RootComponent</code> to being the <code class="email">Mesh</code> variable and then attach the <code class="email">ProxSphere</code> variable to the <code class="email">Mesh</code> variable. The <code class="email">ProxSphere</code> variable will be used for collision checking, and collision checking for the <code class="email">Mesh</code> variable should be turned off, as shown in the following code:</p><div class="note"><pre class="programlisting">ABullet::ABullet(const class FObjectInitializer&amp; PCIP) : Super(PCIP)
{
  Mesh = PCIP.CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(this,  TEXT("Mesh"));
  RootComponent = Mesh;

  ProxSphere = PCIP.CreateDefaultSubobject&lt;USphereComponent&gt;(this,  TEXT("ProxSphere"));
  ProxSphere-&gt;AttachTo( RootComponent );

  ProxSphere-&gt;OnComponentBeginOverlap.AddDynamic( this,  &amp;ABullet::Prox );
  Damage = 1;
}</pre></div><p class="calibre9">We initialized<a id="id578" class="calibre1"/> the <code class="email">Damage</code> variable to <code class="email">1</code> in the constructor, but this can be <a id="id579" class="calibre1"/>changed in the UE4 editor once we create a <a id="id580" class="calibre1"/>blueprint out of the <code class="email">ABullet</code> class. Next, the <code class="email">ABullet::Prox_Implementation()</code> function should deal damages to the actor hit if <a id="id581" class="calibre1"/>we collide with the other actor's <code class="email">RootComponent</code>, using the following code:</p><div class="note"><pre class="programlisting">void ABullet::Prox_Implementation( AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp; SweepResult )
{
  if( OtherComp != OtherActor-&gt;GetRootComponent() )
  {
    // don't collide w/ anything other than
    // the actor's root component
    return;
  }

  OtherActor-&gt;TakeDamage( Damage, FDamageEvent(), NULL, this );
  Destroy();
}</pre></div><div class="book" title="Bullet physics"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec51" class="calibre1"/>Bullet physics</h3></div></div></div><p class="calibre9">To make bullets fly<a id="id582" class="calibre1"/> through the level, you can use UE4's physics engine.</p><p class="calibre9">Create a blueprint based on the <code class="email">ABullet</code> class. I selected <span class="strong"><strong class="calibre2">Shape_Sphere</strong></span> for the mesh. The bullet's mesh should not have collision physics enabled; instead we'll enable physics on the bullet's bounding sphere.</p><p class="calibre9">Configuring the bullet to behave properly is mildly tricky, so we'll cover this in four steps, as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Select <span class="strong"><strong class="calibre2">[ROOT] ProxSphere</strong></span> in the <span class="strong"><strong class="calibre2">Components</strong></span> tab. The <code class="email">ProxSphere</code> variable should be the root component and should appear at the top of the hierarchy.</li><li class="listitem" value="2">In the <span class="strong"><strong class="calibre2">Details</strong></span> tab, check both <span class="strong"><strong class="calibre2">Simulate Physics</strong></span> and <span class="strong"><strong class="calibre2">Simulation Generates Hit Events</strong></span>.</li><li class="listitem" value="3">From the <span class="strong"><strong class="calibre2">Collision Presets</strong></span> dropdown, select <span class="strong"><strong class="calibre2">Custom…</strong></span>.</li><li class="listitem" value="4">Check the <span class="strong"><strong class="calibre2">Collision Responses</strong></span> boxes as shown; check <span class="strong"><strong class="calibre2">Block</strong></span> for most types (<span class="strong"><strong class="calibre2">WorldStatic</strong></span>, <span class="strong"><strong class="calibre2">WorldDynamic</strong></span>, and so on) and check <span class="strong"><strong class="calibre2">Overlap</strong></span> only for <span class="strong"><strong class="calibre2">Pawn</strong></span>:<div class="mediaobject"><img src="../images/00215.jpeg" alt="Bullet physics" class="calibre11"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div><p class="calibre9">The <a id="id583" class="calibre1"/>
<span class="strong"><strong class="calibre2">Simulate Physics</strong></span> checkbox makes the <code class="email">ProxSphere</code> property experience gravity and the impulse forces exerted on it. An impulse is a momentary thrust of force, which we'll use to drive the shot of the bullet. If you do not check the <span class="strong"><strong class="calibre2">Simulation Generate Hit Events</strong></span> checkbox, then the ball will drop on the floor. What <span class="strong"><strong class="calibre2">BlockAll Collision Preset</strong></span> does is ensure that the ball can't pass through anything.</p><p class="calibre9">If you drag and drop a couple of these <code class="email">BP_Bullet</code> objects from the <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab directly into the world now, they will simply fall to the floor. You can kick them once they are on the the floor. The following screenshot shows the ball object on the floor:</p><div class="mediaobject"><img src="../images/00216.jpeg" alt="Bullet physics" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">However, we don't want our bullets falling on the floor. We want them to be shot. So let's put our bullets in the <code class="email">Monster</code> class.</p></div><div class="book" title="Adding bullets to the monster class"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec52" class="calibre1"/>Adding bullets to the monster class</h3></div></div></div><p class="calibre9">Add a member to the <code class="email">Monster</code> class<a id="id584" class="calibre1"/> that receives a blueprint instance<a id="id585" class="calibre1"/> reference. That's what the <code class="email">UClass</code> object type is for. Also, add a blueprint configurable float property to adjust the force that shoots the bullet, as shown in the following code:</p><div class="note"><pre class="programlisting">// The blueprint of the bullet class the monster uses
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
UClass* BPBullet;
// Thrust behind bullet launches
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)
float BulletLaunchImpulse;</pre></div><p class="calibre9">Compile and run the C++ project and open your <code class="email">BP_Monster</code> blueprint. You can now select a blueprint class under <code class="email">BPBullet</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00217.jpeg" alt="Adding bullets to the monster class" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Once you've selected a blueprint class type to instantiate when the monster shoots, you have to program the monster to shoot when the player is in his range.</p><p class="calibre9">Where does the <a id="id586" class="calibre1"/>monster shoot from? Actually, he should shoot <a id="id587" class="calibre1"/>from a bone. If you're not familiar with the terminology, bones are just reference points in the model mesh. A model mesh is usually made up of many "bones." To see some bones, open up the <span class="strong"><strong class="calibre2">Mixamo_Adam</strong></span> mesh by double-clicking on the asset in the <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00218.jpeg" alt="Adding bullets to the monster class" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Go to the <span class="strong"><strong class="calibre2">Skeleton</strong></span> tab and you will see all the monster's bones in a tree view list in the left-hand side. What we want to do is select a bone from which bullets will be emitted. Here I've selected the <code class="email">LeftHand</code> option.</p><div class="note" title="Note"><h3 class="title2"><a id="tip64" class="calibre1"/>Tip</h3><p class="calibre9">An artist will normally insert an additional bone into the model mesh to emit the particle, which is likely to be on the tip of the nozzle of a gun.</p></div><p class="calibre9">Working from<a id="id588" class="calibre1"/> the base model mesh, we can get the <code class="email">Mesh</code> bone's<a id="id589" class="calibre1"/> location and have the monster emit the <code class="email">Bullet</code> instances from that bone in the code.</p><p class="calibre9">The complete monster <code class="email">Tick</code> and <code class="email">Attack</code> functions can be obtained using the following code:</p><div class="note"><pre class="programlisting">void AMonster::Tick(float DeltaSeconds)
{
  Super::Tick( DeltaSeconds );

  // move the monster towards the player
  AAvatar *avatar = Cast&lt;AAvatar&gt;(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );
  if( !avatar ) return;

  FVector playerPos = avatar-&gt;GetActorLocation();
  FVector toPlayer = playerPos - GetActorLocation();
  float distanceToPlayer = toPlayer.Size();

  // If the player is not the SightSphere of the monster,
  // go back
  if( distanceToPlayer &gt; SightSphere-&gt;GetScaledSphereRadius() )
  {
    // If the player is OS, then the enemy cannot chase
    return;
  }

  toPlayer /= distanceToPlayer;  // normalizes the vector

  // At least face the target
  // Gets you the rotator to turn something
  // that looks in the `toPlayer` direction
  FRotator toPlayerRotation = toPlayer.Rotation();
  toPlayerRotation.Pitch = 0; // 0 off the pitch
  RootComponent-&gt;SetWorldRotation( toPlayerRotation );

  if( isInAttackRange(distanceToPlayer) )
  {
    // Perform the attack
    if( !TimeSinceLastStrike )
    {
      Attack(avatar);
    }

    TimeSinceLastStrike += DeltaSeconds;
    if( TimeSinceLastStrike &gt; AttackTimeout )
    {
      TimeSinceLastStrike = 0;
    }

    return;  // nothing else to do
  }
  else
  {
    // not in attack range, so walk towards player
    AddMovementInput(toPlayer, Speed*DeltaSeconds);
  }
}</pre></div><p class="calibre9">The <code class="email">AMonster::Attack</code> function is relatively simple. Of course, we first need to add a prototype <a id="id590" class="calibre1"/>declaration in the <code class="email">Monster.h</code> file in order to write <a id="id591" class="calibre1"/>our function in the <code class="email">.cpp</code> file:</p><div class="note"><pre class="programlisting">void AMonster::Attack(AActor* thing);</pre></div><p class="calibre9">In <code class="email">Monster.cpp</code>, we implement the <code class="email">Attack</code> function, as follows:</p><div class="note"><pre class="programlisting">void AMonster::Attack(AActor* thing)
{
  if( MeleeWeapon )
  {
    // code for the melee weapon swing, if 
    // a melee weapon is used
    MeleeWeapon-&gt;Swing();
  }
  else if( BPBullet )
  {
    // If a blueprint for a bullet to use was assigned,
    // then use that. Note we wouldn't execute this code
    // bullet firing code if a MeleeWeapon was equipped
    FVector fwd = GetActorForwardVector();
    FVector nozzle = GetMesh()-&gt;GetBoneLocation( "RightHand" );
    nozzle += fwd * 155;// move it fwd of the monster so it  doesn't
    // collide with the monster model
    FVector toOpponent = thing-&gt;GetActorLocation() - nozzle;
    toOpponent.Normalize();
    ABullet *bullet = GetWorld()-&gt;SpawnActor&lt;ABullet&gt;(  BPBullet, nozzle, RootComponent-&gt;GetComponentRotation());

    if( bullet )
    {
      bullet-&gt;Firer = this;
      bullet-&gt;ProxSphere-&gt;AddImpulse( 
        fwd*BulletLaunchImpulse );
    }
    else
    {
      GEngine-&gt;AddOnScreenDebugMessage( 0, 5.f, 
      FColor::Yellow, "monster: no bullet actor could be spawned.  is the bullet overlapping something?" );
    }
  }
}</pre></div><p class="calibre9">We leave the <a id="id592" class="calibre1"/>code that implements the melee attack as it is. Assuming<a id="id593" class="calibre1"/> that the monster is not holding a melee weapon, we then check whether the <code class="email">BPBullet</code> member is set. If the <code class="email">BPBullet</code> member is set, it means that the monster will create and fire an instance of the <code class="email">BPBullet</code> blueprinted class.</p><p class="calibre9">Pay special attention to the following line:</p><div class="note"><pre class="programlisting">ABullet *bullet = GetWorld()-&gt;SpawnActor&lt;ABullet&gt;(BPBullet,  nozzle, RootComponent-&gt;GetComponentRotation() );</pre></div><p class="calibre9">This is how we add a new actor to the world. The <code class="email">SpawnActor()</code> function puts an instance of <code class="email">UCLASS</code> that you pass, at <code class="email">spawnLoc</code>, with some initial orientation.</p><p class="calibre9">After we spawn the bullet, we call the <code class="email">AddImpulse()</code> function on its <code class="email">ProxSphere</code> variable to rocket it forward.</p></div></div></div>

<div class="book" title="Monster attacks on the player">
<div class="book" title="Player knockback"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec120" class="calibre1"/>Player knockback</h2></div></div></div><p class="calibre9">To add a<a id="id594" class="calibre1"/> knockback<a id="id595" class="calibre1"/> to the <a id="id596" class="calibre1"/>player, I added a member variable to the <code class="email">Avatar</code> class called <code class="email">knockback</code>. A knockback happens whenever the avatar gets hurt:</p><div class="note"><pre class="programlisting">FVector knockback; // in class AAvatar</pre></div><p class="calibre9">In order to figure out the direction to knock the player back when he gets hit, we need to add some code to <code class="email">AAvatar::TakeDamage</code>. Compute the direction vector from the attacker towards the player and store this vector in the <code class="email">knockback</code> variable:</p><div class="note"><pre class="programlisting">float AAvatar::TakeDamage(float Damage, struct FDamageEvent const&amp;  DamageEvent, AController* EventInstigator, AActor* DamageCauser)
{
  // add some knockback that gets applied over a few frames
  knockback = GetActorLocation() - DamageCauser- &gt;GetActorLocation();
  knockback.Normalize();
  knockback *= Damage * 500; // knockback proportional to damage
}</pre></div><p class="calibre9">In <code class="email">AAvatar::Tick</code>, we apply<a id="id597" class="calibre1"/> the <a id="id598" class="calibre1"/>knockback <a id="id599" class="calibre1"/>to the avatar's position:</p><div class="note"><pre class="programlisting">void AAvatar::Tick( float DeltaSeconds )
{
  Super::Tick( DeltaSeconds );

  // apply knockback vector
  AddMovementInput( knockback, 1.f );

  // half the size of the knockback each frame
  knockback *= 0.5f;
}</pre></div><p class="calibre9">Since the knockback vector reduces in size with each frame, it becomes weaker over time, unless the knockback vector gets renewed with another hit.</p></div></div>
<div class="book" title="Summary" id="2BASE1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec78" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we explored how to instantiate monsters on the screen that run after the player and attack him. In the next chapter, we will give the player the ability to defend himself by allowing him to cast spells that damage the monsters.</p></div></body></html>