- en: Chapter 7. Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In this chapter, you will be taught how to communicate with the Internet servers
    and with sockets in general. First, we will have a look at `QNetworkAccessManager`,
    which makes sending network requests and receiving replies really easy. Building
    on this basic knowledge, we are then going to use Google''s Distance API to get
    information about the distance between two locations and how long it would take
    to get from one to the other. This technique and the respective knowledge can
    also be used to include Facebook or Twitter in your application via their respective
    APIs. Then, we will have a look at Qt''s Bearer API, which provides information
    on a device''s connectivity state. In the last section, you will learn how to
    use sockets to create your own server and clients using TCP or UDP as the network
    protocol.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: QNetworkAccessManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to access files on the Internet is to use Qt's Network Access
    API. This API is centered on `QNetworkAccessManager`, which handles the complete
    communication between your game and the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: When we now develop and test a network-enabled application, it is recommended
    that you use a private, local network if feasible. This way, it is possible to
    debug both ends of the connection and errors will not expose sensitive data. If
    you are not familiar with setting up a web server locally on your machine, there
    are luckily a number of all-in-one installers that are freely available. These
    will automatically configure Apache2, MySQL (or MariaDB), PHP, and many more on
    your system. On Windows, for example, you could use XAMPP ([http://www.apachefriends.org](http://www.apachefriends.org))
    or the Uniform Server ([http://www.uniformserver.com](http://www.uniformserver.com));
    on Apple computers, there is MAMP ([http://www.mamp.info](http://www.mamp.info));
    and on Linux you normally don't have to do anything since there is already a localhost.
    If not, open your preferred package manager, search for a package called `Apache2`
    or a similar one, and install it. Alternatively, have a look at your distribution's
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Before you install Apache on your machine, think about using a virtual machine
    such as VirtualBox ([http://www.virtualbox.org](http://www.virtualbox.org)) for
    this task. This way, you keep your machine clean and you can easily try different
    settings for your test server. With multiple virtual machines, you can even test
    the interaction between different instances of your game. If you are on Unix,
    Docker ([http://www.docker.com](http://www.docker.com)) might be worth having
    a look at.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading files over HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, first try to set up a local server and create a file called `version.txt`
    in the root directory of the installed server. This file should contain a small
    piece of text such as "I am a file on localhost" or something similar. To test
    whether the server and the file are correctly setup, start a web browser and open
    `http://localhost/version.txt`. You should then see the file's content. Of course,
    if you have access to a domain, you can also use that. Just alter the URL used
    in the example correspondingly. If this fails, it may be the case that your server
    does not allow you to display text files. Instead of getting lost in the server's
    configuration, just rename the file to `version.html`. This should do the trick!
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading files over HTTP](img/8874OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Result of requesting http://localhost/version.txt on a browser
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed, because of the file name a real-life scenario could
    be to check whether there is an updated version of your game or application on
    the server. To get the content of a file, only five lines of code are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – downloading a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, create an instance of `QNetworkAccessManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since `QNetworkAccessManager` inherits `QObject`, it takes a pointer to `QObject`,
    which is used as a parent. Thus, you do not have to take care of deleting the
    manager later on. Furthermore, one single instance of `QNetworkAccessManager`
    is enough for an entire application. So, either pass a pointer to the network
    access manager in your game or, for ease of use, create a singleton pattern and
    access the manager through that.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A singleton pattern ensures that a class is instantiated only once. The pattern
    is useful for accessing application-wide configurations or—as in our case—an instance
    of `QNetworkAccessManager`. On the wiki pages for [http://www.qtcentre.org](http://www.qtcentre.org)
    and [http://www.qt-project.org](http://www.qt-project.org), you will find examples
    for different singleton patterns. A simple template-based approach would look
    like this (as a header file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the source code, you will include that header file and acquire a singleton
    of a class called `MyClass` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Qt Quick—it will be explained in [Chapter 9](ch09.html "Chapter 9. Qt
    Quick Basics"), *Qt Quick Basics*—with `QQuickView`, you can directly use the
    view''s instance of `QNetworkAccessManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, we connect the manager''s `finished()` signal to a slot of our choice;
    for example, in our class, we have a slot called `downloadFinished()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Thirdly, we actually request the `version.txt` file from localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With `get()`, a request to get the contents of the file, specified by the URL,
    is posted. The function expects `QNetworkRequest`, which defines all the information
    needed to send a request over the network. The main information for such a request
    is naturally the URL of the file. This is the reason why `QNetworkRequest` takes
    `QUrl` as an argument in its constructor. You can also set the URL with `setUrl()`
    to a request. If you wish to define some additional headers, you can either use
    `setHeader()` for the most common header or use `setRawHeader()` to be fully flexible.
    If you want to set, for example, a custom user agent to the request, the call
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setHeader()` function takes two arguments, the first is a value of the
    `QNetworkRequest::KnownHeaders` enumeration, which holds the most common—self-explanatory—headers
    such as `LastModifiedHeader` or `ContentTypeHeader`, and the second is the actual
    value. You could also write the header using `setRawHeader()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you use `setRawHeader()`, you have to write the header field names yourself.
    Besides this, it behaves like `setHeader()`. A list of all the available headers
    for the HTTP protocol Version 1.1 can be found in section 14 of RFC 2616 ([http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our example: with the `get()` function, we requested the `version.txt`
    file from the localhost. All we have to do from now on is to wait for the server
    to reply. As soon as the server''s reply is finished, the `downloadFinished()`
    slot will be called that was defined by the preceding connection statement. As
    an argument, a reply of the `QNetworkReply` type is transferred to the slot, and
    we can read the reply''s data and set it to `m_edit`, an instance of `QPlainTextEdit`,
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since `QNetworkReply` inherits `QIODevice`, there are also other possibilities
    to read the contents of the reply including `QDataStream` or `QTextStream` to
    either read and interpret binary data or textual data. Here, as the fourth command,
    `QIODevice::readAll()` is used to get the full content of the requested file in
    `QByteArray`. The responsibility for the transferred pointer to the corresponding
    `QNetworkReply` lies with us, so we need to delete it at the end of the slot.
    This would be the fifth line of code that is needed to download a file with Qt.
    However, be careful and do not call delete on the reply directly. Always use `deleteLater()`,
    as the documentation suggests!
  prefs: []
  type: TYPE_NORMAL
- en: 'The full source code can be found in the **FileDownload** example bundled with
    this book. If you start the small demo application and click on the **Load File**
    button you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – downloading a file](img/8874OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero – extending the basic file downloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't set up a localhost, just alter the URL in the source code to
    download another file. Of course, having to alter the source code in order to
    download another file is far from an ideal approach. So, try to extend the dialog
    by adding a line edit in which you can specify the URL you want to download. Also,
    you can offer a file dialog to choose the location to where the downloaded file
    will be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not see the content of the file, something went wrong. Just as in
    real life, this can often happen. So, we need to make sure that there is a good
    error handling mechanism in such cases to inform the user about what is going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying a proper error message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, `QNetworkReply` offers several possibilities to do this. In the
    slot called `downloadFinished()`, we first want to check whether an error occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QNetworkReply::error()` function returns the error that occurred while
    handling the request. The error is encoded as a value of the `QNetworkReply::NetworkError`
    type. The two most common errors are probably these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Error code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ContentNotFoundError` | This error indicates that the URL of the request
    could not be found. It is similar to the HTTP error code 404. |'
  prefs: []
  type: TYPE_TB
- en: '| `ContentAccessDenied` | This error indicates that you do not have the permission
    to access the requested file. It is similar to the HTTP error code 401. |'
  prefs: []
  type: TYPE_TB
- en: You can look up the other 23 error codes in the documentation. But normally,
    you do not need to know exactly what went wrong. You only need to know whether
    everything worked out—`QNetworkReply::NoError` would be the return value in this
    case—or if something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `QNetworkReply::NoError` has the value `0`, you can shorten the test
    phrase to check whether an error occurred to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide the user with a meaningful error description, you can use `QIODevice::errorString()`.
    The text is already set up with the corresponding error message and we only have
    to display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, assuming we made an error in the URL and wrote `versions.txt`
    by mistake, the application would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – displaying a proper error message](img/8874OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the request was an HTTP request and the status code is of interest, it could
    be retrieved by `QNetworkReply::attribute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since it returns `QVariant`, you can either use `QVariant::toInt()` to get the
    code as an integer or `QVariant::toString()` to get the number as `QString`. Beside
    the HTTP status code, you can query a lot of other information through `attribute()`.
    Have a look at the description of the `QNetworkRequest::Attribute` enumeration
    in the documentation. There, you will also find `QNetworkRequest::HttpReasonPhraseAttribute`,
    which holds a human-readable reason phrase for the HTTP status code. For example,
    "Not Found" if an HTTP error 404 has occurred. The value of this attribute is
    used to set the error text for `QIODevice::errorString()`. So, you can either
    use the default error description provided by `errorString()` or compose your
    own by interpreting the reply's attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a download failed and you want to resume it or if you only want to download
    a specific part of a file, you can use the `Range` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, only the bytes from `300` to `500` would be downloaded. However,
    the server must support this.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading files over FTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Downloading a file over FTP is as simple as downloading files over HTTP. If
    it is an anonymous FTP server for which you do not need an authentication, just
    use the URL like we did before. Assuming that there is again a file called `version.txt`
    on the FTP server on the localhost, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all, everything else stays the same. If the FTP server requires an
    authentication, you''ll get an error, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading files over FTP](img/8874OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting the username and password to access an FTP server is likewise easy:
    either write it in the URL, or use the `setUserName()` and `setPassword()` functions
    of `QUrl`. If the server does not use a standard port, you can set the port explicitly
    with `QUrl::setPort()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To upload a file to an FTP server, use `QNetworkAccessManager::put()`, which
    takes `QNetworkRequest` as its first argument, calling a URL that defines the
    name of the new file on the server, and the actual data as its second argument,
    which should be uploaded. For small uploads, you can pass the content as `QByteArray`.
    For larger content, it's better to use a pointer to `QIODevice`. Make sure that
    the device is open and stays available until the upload is done.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading files in parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very important note on `QNetworkAccessManager`: it works asynchronously.
    This means that you can post a network request without blocking the main event
    loop, and this is what keeps the GUI responsive. If you post more than one request,
    they are put on the manager''s queue. Depending on the protocol used, they get
    processed in parallel. If you are sending HTTP requests, normally up to six requests
    will be handled at a time. This will not block the application. Therefore, there
    is really no need to encapsulate `QNetworkAccessManager` in a thread; however,
    unfortunately, this unnecessary approach is frequently recommended all over the
    Internet. `QNetworkAccessManager` already threads internally. Really, don''t move
    `QNetworkAccessManager` to a thread unless you know exactly what you are doing.'
  prefs: []
  type: TYPE_NORMAL
- en: If you send multiple requests, the slot connected to the manager's `finished()`
    signal is called in an arbitrary order depending on how quickly a request gets
    a reply from the server. This is why you need to know to which request a reply
    belongs. This is one reason why every `QNetworkReply` carries its related `QNetworkRequest`.
    It can be accessed through `QNetworkReply::request()`.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the determination of the replies and their purpose may work for a small
    application in a single slot, it will quickly get large and confusing if you send
    a lot of requests. This problem is aggravated by the fact that all replies are
    delivered to only one slot. Since most probably there are different types of replies
    that need different treatments, it would be better to bundle them in specific
    slots that are specialized for a given task. Fortunately, this can be achieved
    very easily. `QNetworkAccessManager::get()` returns a pointer to `QNetworkReply`,
    which will get all information about the request that you post with `get()`. By
    using this pointer, you can then connect specific slots to the reply's signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have several URLs and you want to save all linked images
    from these sites to your hard drive, then you request all web pages via `QNetworkAccessManager::get()`
    and connect their replies to a slot specialized for parsing the received HTML.
    If links to the images are found, this slot will request them again with `get()`.
    However, this time the replies to these requests will be connected to a second
    slot, which is designed for saving the images to the disk. Thus, you can separate
    the two tasks: parsing HTML and saving data to a local drive.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important signals of `QNetworkReply` are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: The finished signal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `finished()` signal is an equivalent of the `QNetworkAccessManager::finished()`
    signal that we used earlier. It is triggered as soon as a reply is returned—successfully
    or not. After this signal is emitted, neither the reply's data nor its metadata
    will be altered anymore. With this signal, you are now able to connect a reply
    to a specific slot. This way, you can realize the scenario the scenario on saving
    images that was outlined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one problem remains: if you post simultaneous requests, you do not
    know which one has finished and thus called the connected slot. Unlike `QNetworkAccessManager::finished()`,
    `QNetworkReply::finished()` does not pass a pointer to `QNetworkReply`; this would
    actually be a pointer to itself in this case. A quick solution to solve this problem
    is to use `sender()`. It returns a pointer to the `QObject` instance that has
    called the slot. Since we know that it was `QNetworkReply`, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This was done by casting `sender()` to a pointer of the `QNetworkReply` type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you're casting classes that inherit `QObject`, use `qobject_cast`.
    Unlike `dynamic_cast`, it does not use RTTI and works across the dynamic library
    boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can be pretty confident that the cast will work, do not forget to
    check whether the pointer is valid. If it is a null pointer, exit the slot.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing the OOP conform code using QSignalMapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more elegant way that does not rely on `sender()` would be to use `QSignalMapper`
    and a local hash, in which all replies that are connected to that slot are stored.
    So, whenever you call `QNetworkAccessManager::get()`, store the returned pointer
    in a member variable of the `QHash<int, QNetworkReply*>` type and set up the mapper.
    Let''s assume that we have the following member variables and that they are set
    up properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you connect the `finished()` signal of a reply this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we posted the request and fetched the pointer to `QNetworkReply` with
    reply. Then, we connected the reply''s finished signal to the mapper''s slot `map()`.
    Next, we found a unique ID, which must not already be in use in the `m_replies`
    variable. You can use random numbers generated with `qrand()` and fetch numbers
    as long as they are not unique. To determine whether a key is already in use,
    call `QHash::contains()`. It takes the key as an argument against which it should
    be checked. Or even simpler, count up another private member variable. Once we
    have a unique ID, we insert the pointer to `QNetworkReply` in the hash using the
    ID as a key. Last, with `setMapping()`, we set up the mapper''s mapping: the ID''s
    value corresponds to the actual reply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a prominent place, most likely the constructor of the class, we already
    have connected the mappers `map()` signal to a custom slot. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `downloadFinished()` slot is called, we can get the corresponding
    reply with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`QSignalMapper` also allows you to map with `QString` as an identifier instead
    of an integer as used in the preceding code. So, you could rewrite the example
    and use the URL to identify the corresponding `QNetworkReply`, at least as long
    as the URLs are unique.'
  prefs: []
  type: TYPE_NORMAL
- en: The error signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you download files sequentially, you can swap the error handling out. Instead
    of dealing with errors in the slot connected to the `finished()` signal, you can
    use the reply's `error()` signal, which passes the error of the `QNetworkReply::NetworkError`
    type to the slot. After the `error()` signal has been emitted, the `finished()`
    signal will most likely also be emitted shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The readyRead signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we have used the slot connected to the `finished()` signal to get
    the reply''s content. This works perfectly if you deal with small files. However,
    this approach is unsuitable when dealing with large files, as they would unnecessarily
    bind too many resources. For larger files, it is better to read and save the transferred
    data as soon as it is available. We are informed by `QIODevice::readyRead()` whenever
    new data is available to be read. So, for large files you should use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will help you connect the reply''s `readyRead()` signal to a slot, set
    up `QFile`, and open it. In the connected slot, type in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can fetch the content, which has been transferred so far, and save
    it to the (already opened) file. This way, the resources needed are minimized.
    Don't forget to close the file after the `finished()` signal is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, it would be helpful if you knew upfront the size of the file
    you want to download. Therefore, we can use `QNetworkAccessManager::head()`. It
    behaves like the `get()` function, but does not transfer the content of the file.
    Only the headers are transferred. And if we are lucky, the server sends the "Content-Length"
    header, which holds the file size in bytes. To get that information, we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this information, we can also check upfront whether there is enough space
    left on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: The downloadProgress method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Especially when a big file is downloaded, the user usually wants to know how
    much data has already been downloaded and approximately how long it will take
    for the download to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – showing the download progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to achieve this, we can use the reply''s `downloadProgress()` signal.
    As the first argument, it passes the information on how many bytes have already
    been received and as the second argument, how many bytes there are in total. This
    gives us the possibility to indicate the progress of the download with `QProgressBar`.
    As the passed arguments are of the `qint64` type, we can''t use them directly
    with `QProgressBar`, as it only accepts `int`. So, in the connected slot, we first
    calculate the percentage of the download progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the percentage, we set the new value for the progress bar where `progressBar`
    is the pointer to this bar. However, what value will `progressBar->maximum()`
    have and where do we set the range for the progress bar? What is nice is that
    you do not have to set it for every new download. It is only done once, for example,
    in the constructor of the class containing the bar. As range values, I would recommend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that if you take, for example, a range of 0 to 100 and the progress
    bar is 500 pixels wide, the bar would jump 5 pixels forward for every value change.
    This will look ugly. To get a smooth progression where the bar expands by 1 pixel
    at a time, a range of 0 to 99.999.999 would surely work, but would be highly inefficient.
    This is because the current value of the bar would change a lot without any graphical
    depiction. So, the best value for the range would be 0 to the actual bar's width
    in pixels. Unfortunately, the width of the bar can change depending on the actual
    widget width, and frequently querying the actual size of the bar every time the
    value changes is also not a good solution. Why `2048`, then? The idea behind this
    value is the resolution of the screen. Full HD monitors normally have a width
    of 1920 pixels, thus taking 2^11 (2048) ensures that the progress bar runs smoothly,
    even if it is fully expanded. So, 2048 isn't the perfect number but is a fairly
    good compromise. If you are targeting smaller devices, choose a smaller, more
    appropriate number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to calculate the remaining time for the download to finish, you
    have to start a timer. In this case, use `QElapsedTimer`. After posting the request
    with `QNetworkAccessManager::get()`, start the timer by calling `QElapsedTimer::start()`.
    Assuming that the timer is called `m_timer`, the calculation will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`QElapsedTimer::elapsed()` returns the milliseconds that are counted from the
    moment when the timer is started. This value divided by the progress equals the
    estimated total download time. If you subtract the elapsed time and divide the
    result by 1,000, you''ll get the remaining time in seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you like to use a proxy, you first have to set up `QNetworkProxy`. You have
    to define the type of the proxy with `setType()`. As arguments, you will most
    likely want to pass `QNetworkProxy::Socks5Proxy` or `QNetworkProxy::HttpProxy`.
    Then, set up the hostname with `setHostName()`, the username with `setUserName()`,
    and the password with `setPassword()`. The last two properties are, of course,
    only needed if the proxy requires an authentication. Once the proxy is set up,
    you can set it to the access manager via `QNetworkAccessManager::setProxy()`.
    Now, all new requests will use this proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Google, Facebook, Twitter, and co.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we discussed `QNetworkAccessManager`, you now have the knowledge you need
    to integrate Facebook, Twitter, or similar sites into your application. They all
    use the HTTP protocol and simple requests in order to retrieve data from them.
    For Facebook, you have to use the so-called Graph API. It describes which interfaces
    are available and what options they offer. If you want to search for users who
    are called "Helena", you have to request [https://graph.facebook.com/search?q=helena&type=user](https://graph.facebook.com/search?q=helena&type=user).
    Of course, you can do this with `QNetworkManager`. You will find more information
    about the possible requests to Facebook at [http://developers.facebook.com/docs/graph-api](http://developers.facebook.com/docs/graph-api).
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to display tweets in your game, you have to use Twitter's REST or
    Search API. Assuming that you know the ID of a tweet you would like to display,
    then you can get it through [https://api.twitter.com/1.1/statuses/show.json?id=12345](https://api.twitter.com/1.1/statuses/show.json?id=12345),
    where `12345` is the actual ID for the tweet. If you would like to find tweets
    mentioning `#Helena`, you would write [https://api.twitter.com/1.1/search/tweets.json?q=%23Helena](https://api.twitter.com/1.1/search/tweets.json?q=%23Helena).
    You can find more information about the parameters and the other possibilities
    of Twitter's API at [https://dev.twitter.com/docs/api](https://dev.twitter.com/docs/api).
  prefs: []
  type: TYPE_NORMAL
- en: Since both Facebook and Twitter need an authentication to use their APIs, we
    will have a look at Google instead. Let's use Google's Distance Matrix API in
    order to get information about how long it would take for us to get from one city
    to another. The technical documentation for the API we are going to use can be
    found at [https://developers.google.com/maps/documentation/distancematrix](https://developers.google.com/maps/documentation/distancematrix).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using Google's Distance Matrix API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GUI for this example is kept simple—the source code is attached with the
    book. It consists of two line edits (`ui->from` and `ui->to`) that allow you to
    enter the origin and destination of the journey. It also provides you with a combo
    box (`ui->vehicle`) that allows you to choose a mode of transportation—whether
    you want to drive a car, ride a bicycle, or walk—a push button (`ui->search`)
    to start the request, and a text edit or (`ui->result`) to show the results. The
    result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – using Google''s Distance Matrix API](img/8874OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`MainWindow`—a subclass of `QMainWindow`—is the application''s main class that
    holds two private members: `m_nam`, which is a pointer to `QNetworkAccessManager`,
    and `m_reply`, which is a pointer to `QNetworkReply`.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – constructing the query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever the button is pressed, the `sendRequest()` slot is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this slot, we first check whether there is an old request, which was stored
    in `m_reply`, and if it is still running. If that is `true`, we abort the old
    request as we are about to schedule a new one. Then, we also wipe out the result
    of the last request by calling `QPlainTextEdit::clear()` on the text edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will construct the URL for the request. We can do this by composing
    the string by hand where we add the query parameters to the base URL similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the problem that this quickly becomes hard to read when we include
    multiple parameters, it is also rather error-prone. The values of the line edits
    have to be encoded to fit the criteria for a valid URL. For every user value,
    we therefore have to call `QUrl::toPercentEncoding()` explicitly. A much better
    approach, which is easier to read and less error-prone, is to use `QUrlQuery`.
    It circumvents the problem that may result from you forgetting to encode the data.
    So, we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is pretty clear: we create an instance and then add the query parameters
    with `addQueryItem()`. The first argument is taken as the key and the second as
    the value resulting in a string such as "key=value". The value will be automatically
    encoded when we use `QUrlQuery` in conjunction with `QUrl`. Other benefits of
    using `QUrlQuery` are that we can check whether we have already set a key with
    `hasQueryItem()`, taking the key as an argument, or removed a previous set key
    by calling `removeQueryItem()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real situation, we would, of course, wrap all the preceding literals in
    `QStringLiteral`, but this is omitted here in favor of a better reading. So, let''s
    review which parameters we have set. The `sensor` key is set to `false` as we
    are not using a GPS device to locate our position. The `language` key is set to
    `English`, and for units, we favor metric over imperial. Then, the search-related
    parameters are set. The `origins` key holds the places we want to start from.
    As its value, the text of the `ui->from` line edit is chosen. If you want to query
    multiple starting positions, you just have to combine them using `|`. Equivalent
    to the origins, we set up the value for destinations. Last, we pass the value
    of the combo box to mode, which defines whether we want to go by a car, bicycle,
    or whether we want to walk, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create `QUrl` that contains the address to which the query should be
    posted. By including "json" at the end, we define that the server should transfer
    its reply using the JSON format. Google also provides the option for us to get
    the result as XML. To achieve this, simply replace "json" with "xml". However,
    since the APIs of Facebook and Twitter return JSON, we will use this format.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set the previous constructed `query` to the URL by calling `QUrl::setQuery()`.
    This automatically encodes the values so we do not have to worry about that. Last,
    we post the request by calling the `get()` function and store the returned `QNetworkReply`
    in `m_reply`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – parsing the server's reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the constructor, we have connected the manager''s `finish()` signal to the
    `finished()` slot of the `MainWindow` class. It will thus be called after the
    request has been posted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check whether the reply that was passed is the one that we have requested
    through `m_nam`. If this is not the case, we delete `reply` and exit the function.
    This can happen if a reply was aborted by the `sendRequest()` slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are now sure that it is our request, we set `m_reply` to null because
    we have handled it and do not need this information anymore. Next we check whether
    an error occurred, and if it did, we put the reply''s error string in the text
    edit, delete reply, and exit the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With `readAll()`, we get the content of the server''s reply. Since the transferred
    data is not large, we do not need to use partial reading with `readyRead()`. The
    content is then converted to `QJsonDocument` using the `QJsonDocument::fromJson()`
    static function, which takes `QByteArray` as an argument and parses its data.
    If the document is null, the server''s reply wasn''t valid, and then, we show
    an error message on the text edit, delete the reply, and exit the function. We
    do the same if the document does not contain an object, as the API call should
    respond with a single object, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we now made sure that there is an object, we store it in `obj`. Furthermore,
    due to the API, we also know that the object holds the `origin_addresses` and
    `destination_addresses` keys. Both values are arrays that hold the requested origins
    and destinations. From this point on, we will skip any tests if the values exist
    and are valid since we trust the API. The object also holds a key called `status`,
    whose'' value can be used to check whether the query may have failed and if yes,
    why? The last two lines of the source code store the origins and destinations
    in two variant lists. With `obj.value("origin_addresses")`, we get `QJsonValue`
    that holds the value of the pair specified by the `origin_addresses` key. `QJsonValue::toArray()`
    converts this value to `QJsonArray`, which then is converted to `QVariantList`
    using `QJsonArray::toVariantList()`. The returned JSON file for a search requesting
    the distance from Warsaw or Erlangen to Birmingham will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rows` key holds the actual results as an array. The first object in this
    array belongs to the first origin, the second object to the second origin, and
    so on. Each object holds a key named `elements`, whose'' value is also an array
    of objects that belong to the corresponding destinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Each JSON object for an origin-destination pair (`{...}` in the preceding example)
    consists of two pairs with the distance and duration keys. Both the values of
    these keys are arrays that hold the `text` and `value` keys, where `text` is a
    human-readable phrase for `value`. The object for the Warsaw-Birmingham search
    looks as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the value of `value` for distance is the distance expressed
    in meters—since we have used `units=metric` in the request—and the value of `text`
    is value transformed into kilometers with the post fix "km". The same applies
    to duration. Here, value is expressed in seconds and text is value converted into
    hours and minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how the returned JSON is structured, we display the value
    of each origin-destination pair in the text edit. Therefore, we loop through each
    possible pairing using `QVariantLists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This scope will be reached for each combination. Think of the transferred result
    as a table where the origins are rows and the destinations are columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We cache the constructed text in a local variable called output. First, we
    add the string "From:" and the current origin to output. To make it look at least
    a little bit nicer, we call `leftJustified()`. It causes "From:" to be filled
    with spaces until the size of the entire string is `10`. The output will then
    be aligned. The value of the current origin is normally accessed through `QList::at()`,
    and since it is `QVariantList`, we need to convert the returned `QVariant` to
    `QString`. Thus, we call `toString()`. The same is done for the destination, which
    results in the following as the value for output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will read duration and distance from the corresponding `QJsonObject`
    from where we call `data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting at the reply''s root object, we fetch the value of rows and convert
    it to an array (`obj.value("rows").toArray()`). Then, we fetch the value of the
    current row (`.at(i)`), convert it to a JSON object, and fetch its elements key
    (`.toObject().value("elements")`). Since this value is also an array—the columns
    of the row—we convert it to an array, fetch the current column (`.toArray().at(j)`),
    and convert it to an object. This is the object that contains the distance and
    duration for an origin-destination pair in the cell (`i;j`). Beside these two
    keys, the object also holds a key called `status`. Its value indicates whether
    the search was successful (`OK`), whether the origin or destination could not
    be found (`NOT_FOUND`), or whether the search could not find a route between the
    origin and destination (`ZERO_RESULTS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the value of status in a local variable that is also named status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, we then add `distance` and `duration` to the output and also
    align the labels as we did before using `leftJustified()`. For distance, we want
    to show the phrased result. Therefore, we first get the JSON value of the distance
    key (`data.value("distance")`), convert it to an object, and request the value
    for the text key (`.toObject().value("text")`). Lastly, we convert `QJsonValue`
    to `QString` using `toString()`. The same applies for duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the API returns errors, we set an appropriate error text as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add a line consisting of `35` equals signs (`fill('=', 35)`) to
    separate the result in one cell from the other cells. The output is then placed
    at the end of the text edit. This is done by moving the cursor to the end of the
    edit, by calling `moveCursor(QTextCursor::End)`, and inserting output into the
    edit with `insertPlainText(output)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the loops finish, we must not forget to delete the reply. The actual result
    then looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – parsing the server''s reply](img/8874OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero – choosing XML as the reply's format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To hone your XML skills, you can use [http://maps.googleapis.com/maps/api/distancematrix/xml](http://maps.googleapis.com/maps/api/distancematrix/xml)
    as a URL to which you send the requests. Then, you can parse the XML file as we
    did with JSON and display the retrieved data likewise.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the connectivity state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a matter of fact, you can only use `QNetworkAccessManager` if you have an
    active connection to the Internet. Since you cannot theoretically know the connectivity
    state, you have to check this at the runtime of the application. With the help
    of the Bearer API, you can check whether the computer, mobile device, or tablet
    is online and you can even start a new connection—if the operating system supports
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The Bearer API mainly consists of four classes. `QNetworkConfigurationManager`
    is the base and starting point. It holds all network configurations available
    on the system. Furthermore, it provides information about the network capabilities,
    for example, whether you can start and stop interfaces. The network configurations
    found by it are stored as `QNetworkConfiguration` classes. `QNetworkConfiguration`
    holds all information about an access point but not about a network interface,
    as an interface can provide multiple access points. This class also provides only
    the information about network configurations. You can't configure an access point
    or a network interface through `QNetworkConfiguration`. The network configuration
    is up to the operating system, and therefore, `QNetworkConfiguration` is a read-only
    class. With `QNetworkConfiguration`, however, you can determine whether the type
    of connection is an Ethernet, WLAN, or 2G connection. This may influence what
    kind of data and, more importantly, what size of data you are going to download.
    With `QNetworkSession`, you can then start or stop system network interfaces,
    which are defined by the configurations. This way, you gain control over an access
    point. `QNetworkSession` also provides session management that is useful when
    a system's access point is used by more than one application. The session ensures
    that the underlying interface only gets terminated after the last session has
    been closed. Lastly, `QNetworkInterface` provides classic information such as
    the hardware address or interface name.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkConfigurationManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QNetworkConfigurationManager` manages all network configurations that are
    available on a system. You can access these configurations by calling `allConfigurations()`.
    Of course, you have to create an instance of the manager first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The configurations are returned as a list. The default behavior of `allConfigurations()`
    is to return all possible configurations. However, you can also retrieve a filtered
    list. If you pass `QNetworkConfiguration::Active` as an argument, the list only
    contains configurations that have at least one active session. If you create a
    new session based on such a configuration, it will be active and connected. By
    passing `QNetworkConfiguration::Discovered` as an argument, you will get a list
    with configurations that can be used to immediately start a session. Note, however,
    that at this point, you cannot be sure whether the underlying interface can be
    started. The last important argument is `QNetworkConfiguration::Defined`. With
    this argument, `allConfigurations()` returns a list of configurations that are
    known to the system but are not usable right now. This may be a previously used
    WLAN hotspot, which is currently out of range.
  prefs: []
  type: TYPE_NORMAL
- en: You will be notified whenever the configurations change. If a new configuration
    becomes available, the manager emits the `configurationAdded()` signal. This may
    happen, for example, if mobile data transmission becomes available or if the user
    turns his/her device's WLAN adapter on. If a configuration is removed, for example,
    if the WLAN adapter is turned off, `configurationRemoved()` is emitted. Lastly,
    when a configuration gets changed, you will be notified by the `configurationChanged()`
    signal. All three signals pass a constant reference to the configuration about
    what was added, removed, or changed. The configuration passed by the `configurationRemoved()`
    signal is, of course, invalid. It still contains, the name and identifier of the
    removed configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To find out whether any network interface of the system is active, call `isOnline()`.
    If you want to be notified about a mode change, track the `onlineStateChanged()`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since a WLAN scan takes a certain amount of time, `allConfigurations()` may
    not return all the available configurations. To ensure that configurations are
    completely populated, call `updateConfigurations()` first. Due to the long time
    it may take to gather all of the information about the system's network configurations,
    this call is asynchronous. Wait for the `updateCompleted()` signal and only then,
    call `allConfigurations()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkConfigurationManager` also informs you about the Bearer API''s capabilities.
    The `capabilities()` function returns a flag of the `QNetworkConfigurationManager::Capabilities`
    type and describes the available possibilities that are platform-specific. The
    values you may be most interested in are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CanStartAndStopInterfaces` | This means that you can start and stop access
    points. |'
  prefs: []
  type: TYPE_TB
- en: '| `ApplicationLevelRoaming` | This indicates that the system will inform you
    if a more suitable access point is available, and that you can actively change
    the access point if you think there is a better one available. |'
  prefs: []
  type: TYPE_TB
- en: '| `DataStatistics` | With this capability, `QNetworkSession` contains information
    about the transmitted and received data. |'
  prefs: []
  type: TYPE_TB
- en: QNetworkConfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration` holds, as mentioned earlier, information about an access
    point. With `name()`, you get the user-visible name for a configuration, and with
    `identifier()`you get a unique, system-specific identifier. If you develop games
    for mobile devices, it may be of advantage to you to know which type of connection
    is being used. This might influence the data that you request; for example, the
    quality and thus, the size of a video. With `bearerType()`, the type of bearer
    used by a configuration is returned. The returned enumeration values are rather
    self-explanatory: `BearerEthernet`, `BearerWLAN`, `Bearer2G`, `BearerCDMA2000`,
    `BearerWCDMA`, `BearerHSPA`, `BearerBluetooth`, `BearerWiMAX`, and so on. You
    can look up the full-value list in the documentation for `QNetworkConfiguration::BearerType`.'
  prefs: []
  type: TYPE_NORMAL
- en: With `purpose()`, you get the purpose of the configuration, for example, whether
    it is suitable to access a private network (`QNetworkConfiguration::PrivatePurpose`)
    or to access a public network (`QNetworkConfiguration::PublicPurpose`). The state
    of the configuration, if it is defined, discovered or active, as previously described,
    can be accessed through `state()`.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkSession
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start a network interface or to tell the system to keep an interface connected
    for as long as you need it, you have to start a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A session is based on a configuration. When there is more than one session
    and you are not sure which one to use, use `QNetworkConfigurationManager::defaultConfiguration()`.
    It returns the system''s default configuration. Based on this, you can create
    an instance of `QNetworkSession`. The first argument, the configuration, is required.
    The second is optional but is recommended since it sets a parent and we do not
    have to take care of the deletion. You may want to check whether the configuration
    is valid (`QNetworkConfiguration::isValid()`) first. Calling `open()` will start
    the session and connect the interface if needed and supported. Since `open()`
    can take some time, the call is asynchronous. So, either listen to the `opened()`
    signal, which is emitted as soon as the session is open, or to the `error()` signal
    if an error happened. The error is of the `QNetworkSession::SessionError` type.
    Alternatively, instead of checking the `opened()` signal, you can also watch the
    `stateChanged()` signal. The possible states for a session can be: `Invalid`,
    `NotAvailable`, `Connecting`, `Connected`, `Closing`, `Disconnected`, and `Roaming`.
    If you want to make `open()` synchronous, call `waitForOpened()` right after calling
    `open()`. It will block the event loop till the session is open. This function
    will return `true` on success and `false` otherwise. To limit the waiting time,
    you can define a time-out. Just pass the milliseconds that you are willing to
    wait as an argument to `waitForOpened()`. To check whether a session is open,
    use `isOpen()`.'
  prefs: []
  type: TYPE_NORMAL
- en: To close the session, call `close()`. If no session is left on the interface,
    it will be shot down. To force an interface to disconnect, call `stop()`. This
    call will invalidate all the sessions that are based on that interface.
  prefs: []
  type: TYPE_NORMAL
- en: You may receive the `preferredConfigurationChanged()` signal, which indicates
    that the preferred configuration, that is, for example, the preferred access point,
    has changed. This may be the case if a WLAN network is now in range and you do
    not have to use 2G anymore. The new configuration is passed as the first argument
    and the second one indicates whether changing the new access point will also alter
    the IP address. Besides checking for the signal, you can also inquire whether
    roaming is available for a configuration by calling `QNetworkConfiguration::isRoamingAvailable()`.
    If roaming is available, you have to decide to either reject the offer by calling
    `ignore()` or to accept it by calling `migrate()`. If you accept roaming, it will
    emit `newConfigurationActivated()` when the session is roamed. After you have
    checked the new connection, you can either accept the new access point or reject
    it. The latter means that you will return to the previous access point. If you
    accept the new access point, the previous one will be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkInterface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the interface that is used by a session, call `QNetworkSession::interface()`.
    It will return the `QNetworkInterface` object, which describes the interface.
    With `hardwareAddress()`, you get the low-level hardware address of the interface
    that is normally the MAC address. The name of the interface can be obtained by
    `name()`, which is a string such as "eth0" or "wlan0". A list of IP addresses
    as well as their netmasks and broadcast addresses registered with the interface
    is returned by `addressEntries()`. Furthermore, information about whether the
    interface is a loopback or whether it supports multicasting can be queried with
    `flags()`. The returned bitmask is a combination of these values: `IsUp`, `IsRunning`,
    `CanBroadcast`, `IsLoopBack`, `IsPointToPoint`, and `CanMulticast`.'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating between games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having discussed Qt's high-level network classes such as `QNetworkAccessManager`
    and `QNetworkConfigurationManager`, we will now have a look at a lower-level network
    classes and see how Qt supports you when it comes to implementing TCP or UDP servers
    and clients. This becomes relevant when you plan to extend your game by including
    a multiplayer mode. For such a task, Qt offers `QTcpSocket`, `QUdpSocket`, and
    `QTcpServer`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – realizing a simple chat program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get familiar with `QTcpServer` and `QTcpSocket`, let''s develop a simple
    chat program. This example will teach you the basic knowledge of network handling
    in Qt so that you can use this skill later to connect two or more copies of a
    game. At the end of this exercise, we want to see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – realizing a simple chat program](img/8874OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On both the left-hand side and the right-hand side of the preceding figure,
    you can see a client, whereas the server is in the middle. We'll start by taking
    a closer look at the server.
  prefs: []
  type: TYPE_NORMAL
- en: The server – QTcpServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a protocol for communication, we will use **Transmission Control Protocol**
    (**TCP**). You may know this network protocol from the two most popular Internet
    protocols: HTTP and FTP. Both use TCP for their communication and so do the globally
    used protocols for e-mail traffic: SMTP, POP3, and IMAP. The main advantage of
    TCP, however, is its reliability and connection-based architecture. Data transferred
    by TCP is guaranteed to be complete, ordered, and without any duplicates. The
    protocol is furthermore stream orientated, which allows us to use `QDataStream`
    or `QTextStream`. A downside to TCP is its speed. This is because the missing
    data has to be retransmitted until the receiver fully receives it. By default,
    this causes a retransmission of all the data that was transmitted after the missing
    part. So, you should only choose TCP as a protocol if speed is not your top priority,
    but rather the completeness and correctness of the transmitted data. This applies
    if you send unique nonrepetitive data.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A look at the server''s GUI shows us that it principally consists of `QPlainTextEdit`
    (`ui->log`) that is used to display system messages and a button (`ui->disconnectClients`),
    which allows us to disconnect all the current connected clients. On top, next
    to the button, the server''s address and port are displayed (`ui->address` and
    `ui->port`). After setting up the user interface in the constructor of the server''s
    class `TcpServer`, we initiate the internally used `QTcpServer`, which is stored
    in the `m_server` private member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `QTcpServer::listen()`, we defined that the server should listen to the
    localhost and the `52693` port for new incoming connections. The value used here,
    `QHostAddress::LocalHost` of the `QHostAddress::SpecialAddress` enumeration, will
    resolve to `127.0.0.1`. If you instead pass `QHostAddress::Any`, the server will
    listen to all IPv4 interfaces as well as to IPv6 interfaces. If you only want
    to listen to a specific address, just pass this address as `QHostAddress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will behave like the one in the preceding code only in that the server
    will now listen to a port that will be chosen automatically. On success, `listen()`
    will return as `true`. So, if something goes wrong in the example it will show
    an error message on the text edit and exit the function. To compose the error
    message, we are using `QTcpServer::errorString()`, which holds a human-readable
    error phrase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the error in your game''s code, the error string is not suitable.
    In any case where you need to know the exact error, use `QTcpServer::serverError()`,
    which returns the enumeration value of `QAbstractSocket::SocketError`. Based on
    this, you know exactly what went wrong, for example, `QAbstractSocket::HostNotFoundError`.
    If `listen()` was successful, we connect the server''s `newConnection()` signal
    to the class''s `newConnection()` slot. The signal will be emitted every time
    a new connection is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we show the server's address a port number that can be accessed through
    `serverAddress()` and `serverPort()`. This information is needed by the clients
    so that they are able to connect to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – reacting on a new pending connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As soon as a client tries to connect to the server, the `newConnection()` slot
    will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since more than one connection may be pending, we use `hasPendingConnections()`
    to determine whether there is at least one more pending connection. Each one is
    then handled inside the `while` loop. To get a pending connection of the `QTcpSocket`
    type, we call `nextPendingConnection()` and add this connection to a private list
    called `m_clients`, which holds all active connections. In the next line, as there
    is now at least one connection, we enable the button that allows all connections
    to be closed. Therefore, the slot connected to the button's `click()` signal will
    call `QTcpSocket::close()` on each single connection. When a connection is closed,
    its socket emits a `disconnected()` signal. We connect this signal to our `removeConnection()`
    slot. With the last connection, we react to the socket's `readyRead()` signal,
    which indicates that new data is available. In such a situation, our `newMessage()`
    slot is called. Lastly, we print a system message that a new connection has been
    established. The address and port of the connecting client and peer can be retrieved
    by the socket's `peerAddress()` and `peerPort()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a new connection can't be accepted, the `acceptError()` signal is emitted
    instead of `newConnection()`. It passes the reason for the failure of the `QAbstractSocket::SocketError`
    type as an argument. If you want to temporarily decline new connections, call
    `pauseAccepting()` on `QTcpServer`. To resume accepting new connections, call
    `resumeAccepting()`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – forwarding a new message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a connected client sends a new chat message, the underlying socket—since
    it inherits `QIODevice`—emits `readyRead()`, and thus, our `newMessage()` slot
    will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Before we have a look at this slot, there is something important that you need
    to keep in mind. Even though TCP is ordered and without any duplicates, this does
    not mean that all the data is delivered in one big chunk. So, before processing
    the received data, we need to make sure that we get the entire message. Unfortunately,
    there is neither an easy way to detect whether all data was transmitted nor a
    globally usable method for such a task. Therefore, it is up to you to solve this
    problem, as it depends on the use case. Two common solutions, however, are to
    either send magic tokens to indicate the start and the end of a message, for example,
    single characters or XML tags, or you can send the size of the message upfront.
    The second solution is shown in the Qt documentation where the length is put in
    a `quint16` in front of the message. We, on the other hand, will look at an approach
    that uses a simple magic token to handle the messages correctly. As a delimiter,
    we use the "End of Transmission Block" character–ASCII code 23–to indicate the
    end of a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the processing of received data is quite complex, we will go through
    the code step by step this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To determine which socket called the slot, we use `sender()`. If the cast to
    `QTcpSocket` is successful, we enter the `if` scope and read the transferred—potentially
    fragmentary—message with `readAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that `sender()` is used for simplicity. If you write real-life code,
    it is better to use `QSignalMapper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` data is then concatenated with the previously received data that
    is stored in the `QHash` private member called `m_receivedData`, where the socket
    is used as a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we check whether the received data contains our special token, the "End
    of Transmission Block". Otherwise, we exit and wait for the further data to arrive,
    which then gets appended to the string. As soon as we have at least one special
    token, we proceed by splitting the data into single messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The received data contains exactly one single message for which the "End of
    Transmission Block" token is the last character, and thus, the messages list has
    two elements: the first one with the actual message and the last one without any
    content. This way, `m_receivedData[con]` is reset. What if `QChar(23)` is not
    the last character of the received text? Then, the last element is the beginning
    of the next, which is not yet complete, message. So, we store that message in
    `m_receivedData[con]`. This guarantees that no data will be lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we do not know how many messages we will get with the last read from
    the socket, we need to go through the list of messages. For every message, we
    display a short notice on the server''s log and then send it to the other clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Before sending the message, we append `QChar(23)` to indicate the end of the
    message, of course, and then send it to all the connected clients, except the
    one who sent it in the first place, by simply calling write on the socket. Since
    the socket inherits `QIODevice`, you can use most of the functions that you know
    from `QFile`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – using QSignalMapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed earlier, using `sender()` is a convenient, but not an object-orientated,
    approach. Thus, try to use `QSignalMapper` instead to determine which socket called
    the slot. To achieve this, you have to connect the socket's `readyRead()` signal
    to a mapper and the slot directly. All the signal-mapper-related code will go
    into the `newConnection()` slot.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to the connection to the `removeConnection()` slot. Let's have
    a look at it next.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – detecting a disconnect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a client terminates the connection, we have to delete the socket from
    the local `m_clients` list. Therefore, we have to connected the socket''s `disconnected()`
    signal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After getting the socket that emitted the call through `sender()`, we post the
    information that a socket is being removed. Then, we remove the socket from `m_clients`
    and call `deleteLater()` on it. Do not use delete. Lastly, if no client is left,
    the disconnect button is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first part. Now let's have a look at the client.
  prefs: []
  type: TYPE_NORMAL
- en: The client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The graphical user interface of the client (`TcpClient`) is pretty simple. It
    has three input fields to define the server's address (`ui->address`), the server's
    port (`ui->port`), and a username (`ui->user`). Of course, there is also a button
    to connect to (`ui->connect`) and disconnect from (`ui->disconnect`) the server.
    Finally, the GUI has a text edit that holds the received messages (`ui->chat`)
    and a line edit (`ui->text`) to send messages.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user has provided the server''s address and port and has chosen a
    username, he/she can connect to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The private member variable `m_socket` holds an instance of `QTcpSocket`. If
    this socket is already connected, nothing happens. Otherwise, the socket is connected
    to the given address and port by calling `connectToHost()`. Besides the obligatory
    server address and port number, you can pass a third argument to define the mode
    in which the socket will be opened. For possible values, you can use `OpenMode`
    just like we did for `QIODevice`. Since this call is asynchronous, we print a
    notification to the chat, so that the user is informed that the application is
    currently trying to connect to the server. When the connection is established,
    the socket sends the `connected()` signal that prints "Connected to server" on
    the chat to indicate that we have connected to a slot. Besides the messages in
    the chat, we also updated the GUI by, for example, disabling the connect button,
    but this is all basic stuff. You won't have any trouble understanding this if
    you have had a look at the sources. So, these details are left out here.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, something could go wrong when trying to connect to a server, but
    luckily, we are informed about a failure as well through the `error()` signal
    passing a description of error in the form of `QAbstractSocket::SocketError`.
    The most frequent errors will probably be `QAbstractSocket::ConnectionRefusedError`
    if the peer refused the connection or `QAbstractSocket::HostNotFoundError` if
    the host address could not be found. If the connection, however, was successfully
    established, it should be closed later on. You can either call `abort()` to immediately
    close the socket, whereas `disconnectFromHost()` will wait until all pending data
    has been written.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – receiving text messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the constructor, we have connected the socket''s `readyRead()` signal to
    a local slot. So, whenever the server sends a message through `QTcpSocket::write()`,
    we read the data and display it in the chat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you already know, `QTcpSocket` inherits `QIODevice`, so we use `QIODevice::readAll()`
    to get the entire text that was sent. Next, we store the received data and determine
    whether the message was transmitted completely. This approach is the same as we
    used previously for the server. Lastly, in the `for` loop, we add the messages
    to the chat window.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sending text messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is left is now is to describe how to send a chat massage. On hitting return
    inside the line edit, a local slot will be called that checks whether there is
    actual text to send and whether `m_socket` is still connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If so, a message is composed that contains the self-given username, a colon,
    and the text of the line edit. To send this string to the peer, the `QTcpSocket::write()`
    server is called. Since `write()` only accepts const `char*` or `QByteArray`,
    we use `QString::toLocal8Bit()` to get `QByteArray` that we can send over the
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: That's all. It's like writing and reading from a file. For the complete example,
    have a look at the sources bundled with this book and run the server and several
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – extending the chat with a user list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example has shown us how to send a simple text. If you now go on and define
    a schema for how the communication should work, you can use it as a base for more
    complex communication. For instance, if you want to enable the client to receive
    a list of all other clients (and their usernames), you need to define that the
    server will return such a list if it gets a message such as `rq:allClients` from
    a client. Therefore, you have to parse all messages received by the server before
    forwarding them to all the connected clients. Go ahead and try to implement such
    a requirement yourself. By now, it is possible that multiple users have chosen
    the same username. With the new functionality of getting a user list, you can
    prevent this from happening. Therefore, you have to send the username to the server
    that keeps track of them.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example we explained uses a nonblocking, asynchronous approach. For example,
    after asynchronous calls such as `connectToHost()`, we do not block the thread
    until we get a result, but instead, we connect to the socket's signals to proceed.
    On the Internet as well as Qt's documentation, on the other hand, you will find
    dozens of examples explaining the blocking and the synchronous approaches. You
    will easily spot them by their use of `waitFor...()` functions. These functions
    block the current thread until a function such as `connectToHost()` has a result—the
    time `connected()` or `error()` will be emitted. The corresponding blocking function
    to `connectToHost()` is `waitForConnected()`. The other blocking functions that
    can be used are `waitForReadyRead()`, which waits until new data is available
    on a socket for reading; `waitForBytesWritten()`, which waits until the data has
    been written to the socket; and `waitForDisconnected()`, which waits until the
    connection has been closed.
  prefs: []
  type: TYPE_NORMAL
- en: Look out; even if Qt offers these `waitFor...()` functions, do not use them!
    The synchronous approach is not the smartest one since it will freeze your game's
    GUI. A frozen GUI is the worst thing that can happen in your game and it will
    annoy every user. So, when working inside the GUI thread, you are better to react
    to the `QIODevice::readyRead()`, `QIODevice::bytesWritten()`, `QAbstractSocket::connected()`,
    and `QAbstractSocket::disconnected()` corresponding signals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`QAbstractSocket` is the base class of `QTcpSocket` as well as of `QUdpSocket`.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the asynchronous approach shown, the application will only become
    unresponsive while both reading and writing to the socket as well as during determining
    whether a message is complete. The optimum, however, would be to move the entire
    socket handling to an extra thread. Then, the GUI thread would only get signals,
    passing the new messages, and to send, it would simply pass `QString` to the worker
    thread. This way, you will get a super fluent velvet GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Using UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In contrast to TCP, UDP is unreliable and connectionless. Neither the order
    of packets, nor their delivery is guaranteed. UDP, however, is very fast. So,
    if you have frequent data, which does not necessarily need to be received by the
    peer, use UDP. This data could, for example, be real-time positions of a player
    that get updated frequently or live video/audio streaming. Since `QUdpSocket`
    is mostly the same as `QTcpSocket`—both inherit `QAbstractSocket`—there is not
    much to explain. The main difference between them is that TCP is stream-orientated,
    whereas UDP is datagram-orientated. This means that the data is sent in small
    packages, containing among the actual content, the sender''s as well as the receiver''s
    IP address and port number. Due to the lack of `QUdpServer`, you have to use `QAbstractSocket::bind()`
    instead of `QTcpServer::listen()`. Like `listen()`, `bind()` takes the addresses
    and ports that are allowed to send datagrams as arguments. Whenever a new package
    arrives, the `QIODevice::readyRead()` signal is emitted. To read the data, use
    the `readDatagram()` function, which takes four parameters. The first one of the
    `char*` type is used to write the data in, the second specifies the amount of
    bytes to be written, and the last two parameters of the `QHostAddress*` and `quint16*`
    types are used to store the sender''s IP address and port number. Sending data
    works likewise: `writeDatagram()` sends the first argument''s data of the `char*`
    type to the host, which is defined by the third (address) and fourth (port number)
    argument. With the second parameter, you can limit the amount of data to be sent.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sending a text via UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, let''s assume that we have two sockets of the `QUpSocket` type.
    We will call the first one `socketA` and the other `socketB`. Both are bound to
    the localhost, `socketA` to the `52000` port and `socketB` to the `52001` port.
    So, if we want to send the string "Hello!" from `socketA` to `socketB`, we have
    to write in the application that is holding `socketA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used the convenient function of `writeDatagram()`, which takes
    `QByteArray` instead of const `char*` and `qint64`. The class that holds `socketB`
    must have the socket''s `readyRead()` signal connected to a slot. This slot will
    then be called because of our `writeDatagram()` call, assuming that the datagram
    is not lost! In the slots, we read the datagram and the sender''s address and
    port number with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As long as there are pending datagrams—this is checked by `hasPendingDatagrams()`,
    which returns `true` as long as there are pending datagrams—we read them. This
    is done by creating `QByteArray`, which is used to store the transferred datagram.
    To be able to hold the entire transmitted data, it is resized to the length of
    the pending datagram. This information is retrieved by `pendingDatagramSize()`.
    Next we create `QHostAddress` and `quint16` so that `readDatagram()` can store
    the sender's address and port number in these variables. Now, all is set up to
    call `readDatagram()` so that we get the datagram.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – connecting players of the Benjamin game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this introductory knowledge, you can go ahead and try some stuff by yourself.
    For example, you can take the game Benjamin the elephant and send Benjamin's current
    position from one client to another. This way, you can either clone the screen
    from one client to the other or both clients can play the game and additionally
    can see where the elephant of the other player currently is. For such a task,
    you would use UDP, as it is important that the position is updated very fast while
    it isn't a disaster when one position gets lost.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Which three (main) classes do you need to download a file?
  prefs: []
  type: TYPE_NORMAL
- en: Q2\. How can you download only the first 100 bytes of a file?
  prefs: []
  type: TYPE_NORMAL
- en: Q3\. If you need to extend a URL by parameters with special characters, you
    need to escape them with `QUrl::toPercentEncoding()`. Which other, more convenient,
    option does Qt offer?
  prefs: []
  type: TYPE_NORMAL
- en: Q4\. How do you delete `QNetworkReply` received from `QNetworkAccessManager`?
  prefs: []
  type: TYPE_NORMAL
- en: Q5\. What is the type hierarchy of `QTcpSocket` and `QUdpSocket` and what's
    the big advantage of this hierarchy?
  prefs: []
  type: TYPE_NORMAL
- en: Q6\. The `readDatagram()` function belongs to `QTcpSocket` or `QUdpSocket`?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of this chapter, you familiarized yourself with `QNetworkAccessManager`.
    This class is at the heart of your code whenever you want to download or upload
    files to the Internet. After having gone through the different signals that you
    can use to fetch errors, to get notified about new data or to show the progress,
    you should now know everything you need on that topic.
  prefs: []
  type: TYPE_NORMAL
- en: The example about the Distance Matrix API depended your knowledge of `QNetworkAccessManager`,
    and it shows you a real-life application case for it. Dealing with JSON as the
    server's reply format was a recapitulation of [Chapter 4](ch04.html "Chapter 4. Qt
    Core Essentials"), *Qt Core Essentials*, but was highly needed since Facebook
    or Twitter only use JSON to format their network replies.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, you learned how to set up your own TCP server and clients.
    This enables you to connect different instances of a game to provide the multiplayer
    functionality. Alternatively, you were taught how to use UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that we only scratched the surface of this topic due to
    its complexity. Covering it fully would have exceeded this beginner's guide. For
    a real game, which uses a network, you should learn more about Qt's possibilities
    for establishing a secure connection via SSL or some other mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to extend your game with a scripting engine.
    This allows you to, for example, easily change various aspects of your game without
    the need for recompiling it.
  prefs: []
  type: TYPE_NORMAL
