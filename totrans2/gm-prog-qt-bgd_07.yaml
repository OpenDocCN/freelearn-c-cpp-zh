- en: Chapter 7. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 网络编程
- en: '*In this chapter, you will be taught how to communicate with the Internet servers
    and with sockets in general. First, we will have a look at `QNetworkAccessManager`,
    which makes sending network requests and receiving replies really easy. Building
    on this basic knowledge, we are then going to use Google''s Distance API to get
    information about the distance between two locations and how long it would take
    to get from one to the other. This technique and the respective knowledge can
    also be used to include Facebook or Twitter in your application via their respective
    APIs. Then, we will have a look at Qt''s Bearer API, which provides information
    on a device''s connectivity state. In the last section, you will learn how to
    use sockets to create your own server and clients using TCP or UDP as the network
    protocol.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在本章中，您将学习如何与互联网服务器以及一般套接字进行通信。首先，我们将查看`QNetworkAccessManager`，它使得发送网络请求和接收回复变得非常简单。基于这些基本知识，我们将使用谷歌的距离API来获取两个位置之间的距离以及从一个位置到另一个位置所需的时间。这种技术和相应的知识也可以用来通过各自的API将Facebook或Twitter集成到您的应用程序中。然后，我们将查看Qt的Bearer
    API，它提供了设备连接状态的信息。在最后一节中，您将学习如何使用套接字创建自己的服务器和客户端，使用TCP或UDP作为网络协议。*'
- en: QNetworkAccessManager
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkAccessManager
- en: The easiest way to access files on the Internet is to use Qt's Network Access
    API. This API is centered on `QNetworkAccessManager`, which handles the complete
    communication between your game and the Internet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 访问互联网上的文件最简单的方法是使用Qt的网络访问API。此API以`QNetworkAccessManager`为中心，它处理您游戏与互联网之间的完整通信。
- en: When we now develop and test a network-enabled application, it is recommended
    that you use a private, local network if feasible. This way, it is possible to
    debug both ends of the connection and errors will not expose sensitive data. If
    you are not familiar with setting up a web server locally on your machine, there
    are luckily a number of all-in-one installers that are freely available. These
    will automatically configure Apache2, MySQL (or MariaDB), PHP, and many more on
    your system. On Windows, for example, you could use XAMPP ([http://www.apachefriends.org](http://www.apachefriends.org))
    or the Uniform Server ([http://www.uniformserver.com](http://www.uniformserver.com));
    on Apple computers, there is MAMP ([http://www.mamp.info](http://www.mamp.info));
    and on Linux you normally don't have to do anything since there is already a localhost.
    If not, open your preferred package manager, search for a package called `Apache2`
    or a similar one, and install it. Alternatively, have a look at your distribution's
    documentation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在开发和测试一个网络启用应用程序时，如果可行，建议您使用一个私有、本地的网络。这样，您可以调试连接的两端，并且错误不会暴露敏感数据。如果您不熟悉在您的机器上本地设置Web服务器，幸运的是，有许多免费的全能安装程序可供使用。这些程序将自动在您的系统上配置Apache2、MySQL（或MariaDB）、PHP以及更多。例如，在Windows上，您可以使用XAMPP
    ([http://www.apachefriends.org](http://www.apachefriends.org)) 或Uniform Server
    ([http://www.uniformserver.com](http://www.uniformserver.com))；在苹果电脑上，有MAMP ([http://www.mamp.info](http://www.mamp.info))；而在Linux上，通常您不需要做任何事情，因为已经存在localhost。如果不是这样，请打开您首选的包管理器，搜索名为`Apache2`或类似名称的包，并安装它。或者，查看您发行版的文档。
- en: Before you install Apache on your machine, think about using a virtual machine
    such as VirtualBox ([http://www.virtualbox.org](http://www.virtualbox.org)) for
    this task. This way, you keep your machine clean and you can easily try different
    settings for your test server. With multiple virtual machines, you can even test
    the interaction between different instances of your game. If you are on Unix,
    Docker ([http://www.docker.com](http://www.docker.com)) might be worth having
    a look at.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在机器上安装Apache之前，考虑使用虚拟机，如VirtualBox ([http://www.virtualbox.org](http://www.virtualbox.org))
    来完成这项任务。这样，您可以保持机器的整洁，并且可以轻松尝试为测试服务器设置不同的配置。使用多个虚拟机，您甚至可以测试您游戏的不同实例之间的交互。如果您使用Unix，那么Docker
    ([http://www.docker.com](http://www.docker.com)) 可能值得一看。
- en: Downloading files over HTTP
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过HTTP下载文件
- en: For this, first try to set up a local server and create a file called `version.txt`
    in the root directory of the installed server. This file should contain a small
    piece of text such as "I am a file on localhost" or something similar. To test
    whether the server and the file are correctly setup, start a web browser and open
    `http://localhost/version.txt`. You should then see the file's content. Of course,
    if you have access to a domain, you can also use that. Just alter the URL used
    in the example correspondingly. If this fails, it may be the case that your server
    does not allow you to display text files. Instead of getting lost in the server's
    configuration, just rename the file to `version.html`. This should do the trick!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先尝试设置一个本地服务器并在已安装服务器的根目录下创建一个名为`version.txt`的文件。这个文件应该包含一小段文本，例如“我是一个在localhost上的文件”或类似的内容。为了测试服务器和文件是否正确设置，启动一个网页浏览器并打开`http://localhost/version.txt`。你应该会看到文件的内容。当然，如果你有访问域名的权限，你也可以使用它。只需相应地更改示例中使用的URL。如果这失败了，可能是因为你的服务器不允许你显示文本文件。与其在服务器的配置中迷失方向，不如将文件重命名为`version.html`。这应该会解决问题！
- en: '![Downloading files over HTTP](img/8874OS_07_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![通过HTTP下载文件](img/8874OS_07_01.jpg)'
- en: Result of requesting http://localhost/version.txt on a browser
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上请求http://localhost/version.txt的结果
- en: As you might have guessed, because of the file name a real-life scenario could
    be to check whether there is an updated version of your game or application on
    the server. To get the content of a file, only five lines of code are needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，由于文件名，实际场景可能是检查服务器上是否有你游戏或应用的更新版本。要获取文件的内容，只需要五行代码。
- en: Time for action – downloading a file
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——下载文件
- en: 'First, create an instance of `QNetworkAccessManager`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个`QNetworkAccessManager`的实例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since `QNetworkAccessManager` inherits `QObject`, it takes a pointer to `QObject`,
    which is used as a parent. Thus, you do not have to take care of deleting the
    manager later on. Furthermore, one single instance of `QNetworkAccessManager`
    is enough for an entire application. So, either pass a pointer to the network
    access manager in your game or, for ease of use, create a singleton pattern and
    access the manager through that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QNetworkAccessManager`继承自`QObject`，它需要一个指向`QObject`的指针，该指针用作父对象。因此，你不必担心稍后删除管理器。此外，一个`QNetworkAccessManager`的单例就足够整个应用程序使用。所以，要么在你的游戏中传递网络访问管理器的指针，要么为了方便使用，创建一个单例模式并通过它访问管理器。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A singleton pattern ensures that a class is instantiated only once. The pattern
    is useful for accessing application-wide configurations or—as in our case—an instance
    of `QNetworkAccessManager`. On the wiki pages for [http://www.qtcentre.org](http://www.qtcentre.org)
    and [http://www.qt-project.org](http://www.qt-project.org), you will find examples
    for different singleton patterns. A simple template-based approach would look
    like this (as a header file):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式确保一个类只被实例化一次。这种模式对于访问应用程序的全局配置或——在我们的例子中——`QNetworkAccessManager`的一个实例非常有用。在[http://www.qtcentre.org](http://www.qtcentre.org)和[http://www.qt-project.org](http://www.qt-project.org)的维基页面上，你可以找到不同单例模式的示例。一个简单的基于模板的方法可能看起来像这样（作为一个头文件）：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the source code, you will include that header file and acquire a singleton
    of a class called `MyClass` with:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，你将包含那个头文件，并使用以下方式获取名为`MyClass`的类的单例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you are using Qt Quick—it will be explained in [Chapter 9](ch09.html "Chapter 9. Qt
    Quick Basics"), *Qt Quick Basics*—with `QQuickView`, you can directly use the
    view''s instance of `QNetworkAccessManager`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Qt Quick——它将在第9章（[ch09.html](ch09.html "第9章。Qt Quick基础知识")，“Qt Quick基础知识”）中解释——并且使用`QQuickView`，你可以直接使用视图的`QNetworkAccessManager`实例：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Secondly, we connect the manager''s `finished()` signal to a slot of our choice;
    for example, in our class, we have a slot called `downloadFinished()`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将管理器的`finished()`信号连接到我们选择的槽；例如，在我们的类中，我们有一个名为`downloadFinished()`的槽：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Thirdly, we actually request the `version.txt` file from localhost:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们实际上是从本地主机请求`version.txt`文件：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With `get()`, a request to get the contents of the file, specified by the URL,
    is posted. The function expects `QNetworkRequest`, which defines all the information
    needed to send a request over the network. The main information for such a request
    is naturally the URL of the file. This is the reason why `QNetworkRequest` takes
    `QUrl` as an argument in its constructor. You can also set the URL with `setUrl()`
    to a request. If you wish to define some additional headers, you can either use
    `setHeader()` for the most common header or use `setRawHeader()` to be fully flexible.
    If you want to set, for example, a custom user agent to the request, the call
    will look like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `get()`，会发布一个获取指定 URL 文件内容的请求。该函数期望 `QNetworkRequest`，它定义了发送网络请求所需的所有信息。此类请求的主要信息自然是文件
    URL。这就是为什么 `QNetworkRequest` 在其构造函数中将 `QUrl` 作为参数的原因。你也可以使用 `setUrl()` 将 URL 设置到请求中。如果你想要定义一些额外的头部，你可以使用
    `setHeader()` 来设置最常见的头部，或者使用 `setRawHeader()` 来获得完全的灵活性。如果你想设置一个自定义的用户代理到请求中，调用将看起来像：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `setHeader()` function takes two arguments, the first is a value of the
    `QNetworkRequest::KnownHeaders` enumeration, which holds the most common—self-explanatory—headers
    such as `LastModifiedHeader` or `ContentTypeHeader`, and the second is the actual
    value. You could also write the header using `setRawHeader()`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`setHeader()` 函数接受两个参数，第一个是 `QNetworkRequest::KnownHeaders` 枚举的值，它包含最常见的——自解释的——头部，例如
    `LastModifiedHeader` 或 `ContentTypeHeader`，第二个是实际值。你也可以使用 `setRawHeader()` 编写头部：'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you use `setRawHeader()`, you have to write the header field names yourself.
    Besides this, it behaves like `setHeader()`. A list of all the available headers
    for the HTTP protocol Version 1.1 can be found in section 14 of RFC 2616 ([http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `setRawHeader()` 时，你必须自己编写头部字段名称。除此之外，它表现得像 `setHeader()`。所有 HTTP 协议版本
    1.1 中可用的头部列表可以在 RFC 2616 的第 14 节中找到（[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14)）。
- en: 'Back to our example: with the `get()` function, we requested the `version.txt`
    file from the localhost. All we have to do from now on is to wait for the server
    to reply. As soon as the server''s reply is finished, the `downloadFinished()`
    slot will be called that was defined by the preceding connection statement. As
    an argument, a reply of the `QNetworkReply` type is transferred to the slot, and
    we can read the reply''s data and set it to `m_edit`, an instance of `QPlainTextEdit`,
    with:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子：使用 `get()` 函数，我们从本机请求了 `version.txt` 文件。从现在开始，我们只需要等待服务器回复。一旦服务器的回复完成，之前连接语句中定义的
    `downloadFinished()` 插槽将被调用。作为参数，一个 `QNetworkReply` 类型的回复被传递到插槽中，我们可以读取回复的数据并将其设置到
    `m_edit`，一个 `QPlainTextEdit` 的实例，使用以下方式：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since `QNetworkReply` inherits `QIODevice`, there are also other possibilities
    to read the contents of the reply including `QDataStream` or `QTextStream` to
    either read and interpret binary data or textual data. Here, as the fourth command,
    `QIODevice::readAll()` is used to get the full content of the requested file in
    `QByteArray`. The responsibility for the transferred pointer to the corresponding
    `QNetworkReply` lies with us, so we need to delete it at the end of the slot.
    This would be the fifth line of code that is needed to download a file with Qt.
    However, be careful and do not call delete on the reply directly. Always use `deleteLater()`,
    as the documentation suggests!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `QNetworkReply` 继承了 `QIODevice`，因此还有其他读取回复内容的方法，包括 `QDataStream` 或 `QTextStream`，用于读取和解释二进制数据或文本数据。在这里，作为第四个命令，使用
    `QIODevice::readAll()` 获取请求文件的完整内容到 `QByteArray`。转移给相应 `QNetworkReply` 的指针的责任在我们这里，因此我们需要在插槽的末尾删除它。这将是需要下载文件时
    Qt 的第五行代码。然而，请注意，不要直接调用 `delete`。始终使用 `deleteLater()`，如文档中建议的那样！
- en: 'The full source code can be found in the **FileDownload** example bundled with
    this book. If you start the small demo application and click on the **Load File**
    button you should see:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在本书附带捆绑的 **FileDownload** 示例中找到。如果你启动这个小型的演示应用程序并点击 **Load File** 按钮，你应该会看到：
- en: '![Time for action – downloading a file](img/8874OS_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 下载文件](img/8874OS_07_02.jpg)'
- en: Have a go hero – extending the basic file downloader
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 扩展基本文件下载器
- en: If you haven't set up a localhost, just alter the URL in the source code to
    download another file. Of course, having to alter the source code in order to
    download another file is far from an ideal approach. So, try to extend the dialog
    by adding a line edit in which you can specify the URL you want to download. Also,
    you can offer a file dialog to choose the location to where the downloaded file
    will be saved.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有设置本地主机，只需将源代码中的URL更改为下载另一个文件。当然，为了下载另一个文件而不得不更改源代码远非理想的方法。因此，尝试通过添加一行编辑框来扩展对话框，以便您可以指定要下载的URL。此外，您还可以提供一个文件对话框来选择下载文件将保存的位置。
- en: Error handling
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: If you do not see the content of the file, something went wrong. Just as in
    real life, this can often happen. So, we need to make sure that there is a good
    error handling mechanism in such cases to inform the user about what is going
    on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到文件的内容，可能出了问题。就像现实生活中一样，这种情况经常发生。因此，我们需要确保在这种情况下有一个良好的错误处理机制来通知用户发生了什么。
- en: Time for action – displaying a proper error message
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 显示适当的错误消息
- en: 'Fortunately, `QNetworkReply` offers several possibilities to do this. In the
    slot called `downloadFinished()`, we first want to check whether an error occurred:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`QNetworkReply`提供了几种处理错误的方法。在名为`downloadFinished()`的槽中，我们首先想要检查是否发生了错误：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `QNetworkReply::error()` function returns the error that occurred while
    handling the request. The error is encoded as a value of the `QNetworkReply::NetworkError`
    type. The two most common errors are probably these:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkReply::error()`函数返回处理请求时发生的错误。错误被编码为`QNetworkReply::NetworkError`类型的值。最常见的前两个错误可能是这些：'
- en: '| Error code | Meaning |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 错误代码 | 含义 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ContentNotFoundError` | This error indicates that the URL of the request
    could not be found. It is similar to the HTTP error code 404. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `ContentNotFoundError` | 此错误表示请求的URL无法找到。它类似于HTTP错误代码404。|'
- en: '| `ContentAccessDenied` | This error indicates that you do not have the permission
    to access the requested file. It is similar to the HTTP error code 401. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `ContentAccessDenied` | 此错误表示您没有权限访问请求的文件。它类似于HTTP错误代码401。|'
- en: You can look up the other 23 error codes in the documentation. But normally,
    you do not need to know exactly what went wrong. You only need to know whether
    everything worked out—`QNetworkReply::NoError` would be the return value in this
    case—or if something went wrong.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文档中查找其他23个错误代码。但通常，您不需要确切知道发生了什么错误。您只需要知道一切是否顺利——在这种情况下，`QNetworkReply::NoError`将是返回值——或者是否出现了错误。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Since `QNetworkReply::NoError` has the value `0`, you can shorten the test
    phrase to check whether an error occurred to be:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QNetworkReply::NoError`的值为`0`，您可以将测试语句缩短以检查是否发生了错误：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To provide the user with a meaningful error description, you can use `QIODevice::errorString()`.
    The text is already set up with the corresponding error message and we only have
    to display it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户提供有意义的错误描述，您可以使用`QIODevice::errorString()`。文本已经设置了相应的错误消息，我们只需显示它：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our example, assuming we made an error in the URL and wrote `versions.txt`
    by mistake, the application would look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，假设我们在URL中犯了错误，错误地写成了`versions.txt`，应用程序将看起来像这样：
- en: '![Time for action – displaying a proper error message](img/8874OS_07_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 – 显示适当的错误消息](img/8874OS_07_03.jpg)'
- en: 'If the request was an HTTP request and the status code is of interest, it could
    be retrieved by `QNetworkReply::attribute()`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求是HTTP请求并且您对状态码感兴趣，可以通过`QNetworkReply::attribute()`获取：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since it returns `QVariant`, you can either use `QVariant::toInt()` to get the
    code as an integer or `QVariant::toString()` to get the number as `QString`. Beside
    the HTTP status code, you can query a lot of other information through `attribute()`.
    Have a look at the description of the `QNetworkRequest::Attribute` enumeration
    in the documentation. There, you will also find `QNetworkRequest::HttpReasonPhraseAttribute`,
    which holds a human-readable reason phrase for the HTTP status code. For example,
    "Not Found" if an HTTP error 404 has occurred. The value of this attribute is
    used to set the error text for `QIODevice::errorString()`. So, you can either
    use the default error description provided by `errorString()` or compose your
    own by interpreting the reply's attributes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它返回`QVariant`，你可以使用`QVariant::toInt()`将代码作为整数获取，或者使用`QVariant::toString()`将数字作为`QString`获取。除了HTTP状态码外，你还可以通过`attribute()`查询很多其他信息。查看文档中`QNetworkRequest::Attribute`枚举的描述。在那里，你还可以找到`QNetworkRequest::HttpReasonPhraseAttribute`，它包含HTTP状态码的可读原因短语。例如，如果发生HTTP错误404，则为“未找到”。此属性的值用于设置`QIODevice::errorString()`的错误文本。因此，你可以使用`errorString()`提供的默认错误描述，或者通过解释回复的属性来创建自己的描述。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If a download failed and you want to resume it or if you only want to download
    a specific part of a file, you can use the `Range` header:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下载失败并且你想恢复它，或者如果你只想下载文件的一部分，你可以使用`Range`头：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, only the bytes from `300` to `500` would be downloaded. However,
    the server must support this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，只会下载从`300`到`500`的字节。然而，服务器必须支持这一点。
- en: Downloading files over FTP
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过FTP下载文件
- en: 'Downloading a file over FTP is as simple as downloading files over HTTP. If
    it is an anonymous FTP server for which you do not need an authentication, just
    use the URL like we did before. Assuming that there is again a file called `version.txt`
    on the FTP server on the localhost, type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过FTP下载文件与通过HTTP下载文件一样简单。如果是一个不需要认证的匿名FTP服务器，只需使用我们之前使用的URL即可。假设在本地主机的FTP服务器上再次有一个名为`version.txt`的文件，输入：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That is all, everything else stays the same. If the FTP server requires an
    authentication, you''ll get an error, for example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，其他一切保持不变。如果FTP服务器需要认证，你会得到一个错误，例如：
- en: '![Downloading files over FTP](img/8874OS_07_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![通过FTP下载文件](img/8874OS_07_04.jpg)'
- en: 'Setting the username and password to access an FTP server is likewise easy:
    either write it in the URL, or use the `setUserName()` and `setPassword()` functions
    of `QUrl`. If the server does not use a standard port, you can set the port explicitly
    with `QUrl::setPort()`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户名和密码以访问FTP服务器同样简单：要么将其写入URL中，要么使用`QUrl`的`setUserName()`和`setPassword()`函数。如果服务器不使用标准端口，你可以使用`QUrl::setPort()`显式设置端口。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To upload a file to an FTP server, use `QNetworkAccessManager::put()`, which
    takes `QNetworkRequest` as its first argument, calling a URL that defines the
    name of the new file on the server, and the actual data as its second argument,
    which should be uploaded. For small uploads, you can pass the content as `QByteArray`.
    For larger content, it's better to use a pointer to `QIODevice`. Make sure that
    the device is open and stays available until the upload is done.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件上传到FTP服务器，使用`QNetworkAccessManager::put()`，它以`QNetworkRequest`作为其第一个参数，调用一个URL来定义服务器上新文件的名字，以及实际数据作为其第二个参数，该数据应该被上传。对于小文件上传，你可以将内容作为`QByteArray`传递。对于更大的内容，最好使用`QIODevice`的指针。确保设备在上传完成前保持打开和可用。
- en: Downloading files in parallel
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行下载文件
- en: 'A very important note on `QNetworkAccessManager`: it works asynchronously.
    This means that you can post a network request without blocking the main event
    loop, and this is what keeps the GUI responsive. If you post more than one request,
    they are put on the manager''s queue. Depending on the protocol used, they get
    processed in parallel. If you are sending HTTP requests, normally up to six requests
    will be handled at a time. This will not block the application. Therefore, there
    is really no need to encapsulate `QNetworkAccessManager` in a thread; however,
    unfortunately, this unnecessary approach is frequently recommended all over the
    Internet. `QNetworkAccessManager` already threads internally. Really, don''t move
    `QNetworkAccessManager` to a thread unless you know exactly what you are doing.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `QNetworkAccessManager` 的一个非常重要的注意事项：它是异步工作的。这意味着您可以在不阻塞主事件循环的情况下发布网络请求，这正是保持
    GUI 响应的原因。如果您发布多个请求，它们将被放入管理器的队列中。根据使用的协议，它们将并行处理。如果您正在发送 HTTP 请求，通常一次最多处理六个请求。这不会阻塞应用程序。因此，实际上没有必要在线程中封装
    `QNetworkAccessManager`；然而，遗憾的是，这种不必要的做法在互联网上被频繁推荐。`QNetworkAccessManager` 已经内部线程化。实际上，除非您确切知道自己在做什么，否则不要将
    `QNetworkAccessManager` 移到线程中。
- en: If you send multiple requests, the slot connected to the manager's `finished()`
    signal is called in an arbitrary order depending on how quickly a request gets
    a reply from the server. This is why you need to know to which request a reply
    belongs. This is one reason why every `QNetworkReply` carries its related `QNetworkRequest`.
    It can be accessed through `QNetworkReply::request()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发送多个请求，连接到管理器 `finished()` 信号的槽位将根据请求从服务器获得回复的速度以任意顺序被调用。这就是为什么您需要知道回复属于哪个请求的原因。这也是每个
    `QNetworkReply` 都携带其相关 `QNetworkRequest` 的原因之一。它可以通过 `QNetworkReply::request()`
    访问。
- en: Even if the determination of the replies and their purpose may work for a small
    application in a single slot, it will quickly get large and confusing if you send
    a lot of requests. This problem is aggravated by the fact that all replies are
    delivered to only one slot. Since most probably there are different types of replies
    that need different treatments, it would be better to bundle them in specific
    slots that are specialized for a given task. Fortunately, this can be achieved
    very easily. `QNetworkAccessManager::get()` returns a pointer to `QNetworkReply`,
    which will get all information about the request that you post with `get()`. By
    using this pointer, you can then connect specific slots to the reply's signals.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使确定回复及其目的可能适用于单个槽位的小型应用，但如果发送大量请求，问题会迅速变得庞大且混乱。由于所有回复都只发送到单个槽位，这个问题变得更加严重。由于很可能存在需要不同处理的多种回复类型，因此将它们捆绑在特定槽位中会更好，这些槽位专门用于特定任务。幸运的是，这可以非常容易地实现。`QNetworkAccessManager::get()`
    返回一个指向 `QNetworkReply` 的指针，该指针将获取您使用 `get()` 发送的请求的所有信息。通过使用此指针，您可以将特定槽位连接到回复的信号。
- en: 'For example, if you have several URLs and you want to save all linked images
    from these sites to your hard drive, then you request all web pages via `QNetworkAccessManager::get()`
    and connect their replies to a slot specialized for parsing the received HTML.
    If links to the images are found, this slot will request them again with `get()`.
    However, this time the replies to these requests will be connected to a second
    slot, which is designed for saving the images to the disk. Thus, you can separate
    the two tasks: parsing HTML and saving data to a local drive.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有多个 URL 并且想要将这些网站的所有链接图片保存到您的硬盘上，那么您可以通过 `QNetworkAccessManager::get()`
    请求所有网页，并将它们的回复连接到一个专门用于解析接收到的 HTML 的槽位。如果找到图片链接，此槽位将再次使用 `get()` 请求它们。然而，这次对这些请求的回复将连接到第二个槽位，该槽位设计用于将图片保存到磁盘。因此，您可以分离这两个任务：解析
    HTML 和将数据保存到本地驱动器。
- en: The most important signals of `QNetworkReply` are discussed next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论 `QNetworkReply` 的最重要信号。
- en: The finished signal
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成信号
- en: The `finished()` signal is an equivalent of the `QNetworkAccessManager::finished()`
    signal that we used earlier. It is triggered as soon as a reply is returned—successfully
    or not. After this signal is emitted, neither the reply's data nor its metadata
    will be altered anymore. With this signal, you are now able to connect a reply
    to a specific slot. This way, you can realize the scenario the scenario on saving
    images that was outlined in the previous section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`finished()` 信号是我们之前使用的 `QNetworkAccessManager::finished()` 信号的等价物。一旦回复返回（无论成功与否），就会触发此信号。在此信号发出后，回复的数据及其元数据将不再被更改。通过此信号，你现在可以将一个回复连接到特定的槽。这样，你可以实现上一节中概述的保存图像的场景。'
- en: 'However, one problem remains: if you post simultaneous requests, you do not
    know which one has finished and thus called the connected slot. Unlike `QNetworkAccessManager::finished()`,
    `QNetworkReply::finished()` does not pass a pointer to `QNetworkReply`; this would
    actually be a pointer to itself in this case. A quick solution to solve this problem
    is to use `sender()`. It returns a pointer to the `QObject` instance that has
    called the slot. Since we know that it was `QNetworkReply`, we can write:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个问题仍然存在：如果你同时发送请求，你不知道哪个请求已经完成并因此调用了连接的槽。与 `QNetworkAccessManager::finished()`
    不同，`QNetworkReply::finished()` 不会传递一个指向 `QNetworkReply` 的指针；在这种情况下，这实际上是指向它自己的指针。一个快速解决这个问题的方法就是使用
    `sender()`。它返回调用槽的 `QObject` 实例的指针。由于我们知道它是 `QNetworkReply`，我们可以编写：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This was done by casting `sender()` to a pointer of the `QNetworkReply` type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将 `sender()` 强制转换为 `QNetworkReply` 类型的指针来实现的。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever you're casting classes that inherit `QObject`, use `qobject_cast`.
    Unlike `dynamic_cast`, it does not use RTTI and works across the dynamic library
    boundaries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将继承自 `QObject` 的类进行强制类型转换时，请使用 `qobject_cast`。与 `dynamic_cast` 不同，它不使用 RTTI，并且可以在动态库边界之间工作。
- en: Although we can be pretty confident that the cast will work, do not forget to
    check whether the pointer is valid. If it is a null pointer, exit the slot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以相当确信强制类型转换将成功，但不要忘记检查指针是否有效。如果是空指针，则退出槽。
- en: Time for action – writing the OOP conform code using QSignalMapper
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 – 使用 QSignalMapper 编写符合 OOP 代码
- en: 'A more elegant way that does not rely on `sender()` would be to use `QSignalMapper`
    and a local hash, in which all replies that are connected to that slot are stored.
    So, whenever you call `QNetworkAccessManager::get()`, store the returned pointer
    in a member variable of the `QHash<int, QNetworkReply*>` type and set up the mapper.
    Let''s assume that we have the following member variables and that they are set
    up properly:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不依赖于 `sender()` 的更优雅的方法是使用 `QSignalMapper` 和一个局部哈希，其中存储了连接到该槽的所有回复。所以，每次你调用
    `QNetworkAccessManager::get()` 时，将返回的指针存储在 `QHash<int, QNetworkReply*>` 类型的成员变量中，并设置映射器。假设我们有以下成员变量，并且它们已经正确设置：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, you connect the `finished()` signal of a reply this way:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你这样连接一个回复的 `finished()` 信号：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*What just happened?*'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'First, we posted the request and fetched the pointer to `QNetworkReply` with
    reply. Then, we connected the reply''s finished signal to the mapper''s slot `map()`.
    Next, we found a unique ID, which must not already be in use in the `m_replies`
    variable. You can use random numbers generated with `qrand()` and fetch numbers
    as long as they are not unique. To determine whether a key is already in use,
    call `QHash::contains()`. It takes the key as an argument against which it should
    be checked. Or even simpler, count up another private member variable. Once we
    have a unique ID, we insert the pointer to `QNetworkReply` in the hash using the
    ID as a key. Last, with `setMapping()`, we set up the mapper''s mapping: the ID''s
    value corresponds to the actual reply.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们发送了请求并使用 `reply` 获取了 `QNetworkReply` 的指针。然后，我们将回复的 `finished` 信号连接到映射器的槽
    `map()`。接下来，我们找到了一个唯一的 ID，这个 ID 必须不在 `m_replies` 变量中使用。你可以使用 `qrand()` 生成的随机数，只要它们是唯一的就可以。为了确定一个键是否已被使用，调用
    `QHash::contains()`。它接受一个键作为参数，该参数应与之进行比较。或者甚至更简单，增加另一个私有成员变量。一旦我们有了唯一的 ID，我们就可以使用
    ID 作为键将 `QNetworkReply` 的指针插入到哈希中。最后，使用 `setMapping()`，我们设置映射器的映射：ID 的值对应于实际的回复。
- en: 'In a prominent place, most likely the constructor of the class, we already
    have connected the mappers `map()` signal to a custom slot. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个显眼的位置，很可能是类的构造函数中，我们已将 `map()` 信号连接到自定义槽。例如：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the `downloadFinished()` slot is called, we can get the corresponding
    reply with:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `downloadFinished()` 插槽时，我们可以通过以下方式获取相应的回复：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`QSignalMapper` also allows you to map with `QString` as an identifier instead
    of an integer as used in the preceding code. So, you could rewrite the example
    and use the URL to identify the corresponding `QNetworkReply`, at least as long
    as the URLs are unique.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSignalMapper` 还允许您使用 `QString` 作为标识符而不是使用前面代码中使用的整数。因此，您可以重写示例并使用 URL 来识别相应的
    `QNetworkReply`，至少在 URL 是唯一的情况下。'
- en: The error signal
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误信号
- en: If you download files sequentially, you can swap the error handling out. Instead
    of dealing with errors in the slot connected to the `finished()` signal, you can
    use the reply's `error()` signal, which passes the error of the `QNetworkReply::NetworkError`
    type to the slot. After the `error()` signal has been emitted, the `finished()`
    signal will most likely also be emitted shortly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按顺序下载文件，您可以替换错误处理。您不需要在连接到 `finished()` 信号的槽中处理错误，而是可以使用回复的 `error()` 信号，它将
    `QNetworkReply::NetworkError` 类型的错误传递到槽中。在 `error()` 信号发出后，`finished()` 信号很可能会很快发出。
- en: The readyRead signal
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: readyRead 信号
- en: 'Until now, we have used the slot connected to the `finished()` signal to get
    the reply''s content. This works perfectly if you deal with small files. However,
    this approach is unsuitable when dealing with large files, as they would unnecessarily
    bind too many resources. For larger files, it is better to read and save the transferred
    data as soon as it is available. We are informed by `QIODevice::readyRead()` whenever
    new data is available to be read. So, for large files you should use the following
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用连接到 `finished()` 信号的槽来获取回复的内容。如果您处理的是小文件，这工作得很好。然而，当处理大文件时，这种方法不适用，因为它们会不必要地绑定太多资源。对于大文件，最好在数据可用时立即读取并保存传输的数据。每当有新数据可供读取时，`QIODevice::readyRead()`
    会通知我们。因此，对于大文件，您应该使用以下代码：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will help you connect the reply''s `readyRead()` signal to a slot, set
    up `QFile`, and open it. In the connected slot, type in the following snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您将回复的 `readyRead()` 信号连接到一个槽，设置 `QFile` 并打开它。在连接的槽中，输入以下代码片段：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, you can fetch the content, which has been transferred so far, and save
    it to the (already opened) file. This way, the resources needed are minimized.
    Don't forget to close the file after the `finished()` signal is emitted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以获取已传输的内容，并将其保存到（已打开的）文件中。这样，所需资源最小化。在 `finished()` 信号发出后，别忘了关闭文件。
- en: 'In this context, it would be helpful if you knew upfront the size of the file
    you want to download. Therefore, we can use `QNetworkAccessManager::head()`. It
    behaves like the `get()` function, but does not transfer the content of the file.
    Only the headers are transferred. And if we are lucky, the server sends the "Content-Length"
    header, which holds the file size in bytes. To get that information, we type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，如果您事先知道要下载的文件大小，这将很有帮助。因此，我们可以使用 `QNetworkAccessManager::head()`。它类似于
    `get()` 函数，但不传输文件内容。只传输头部信息。如果我们幸运的话，服务器会发送 "Content-Length" 头部，其中包含字节数的文件大小。为了获取这些信息，我们输入：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this information, we can also check upfront whether there is enough space
    left on the disk.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，我们还可以提前检查磁盘上是否有足够的空间。
- en: The downloadProgress method
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载进度方法
- en: Especially when a big file is downloaded, the user usually wants to know how
    much data has already been downloaded and approximately how long it will take
    for the download to finish.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在下载大文件时，用户通常想知道已经下载了多少数据以及下载完成大约需要多长时间。
- en: Time for action – showing the download progress
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示下载进度的时机
- en: 'In order to achieve this, we can use the reply''s `downloadProgress()` signal.
    As the first argument, it passes the information on how many bytes have already
    been received and as the second argument, how many bytes there are in total. This
    gives us the possibility to indicate the progress of the download with `QProgressBar`.
    As the passed arguments are of the `qint64` type, we can''t use them directly
    with `QProgressBar`, as it only accepts `int`. So, in the connected slot, we first
    calculate the percentage of the download progress:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用回复的 `downloadProgress()` 信号。作为第一个参数，它传递了已接收的字节数信息，作为第二个参数，传递了总字节数。这使我们能够使用
    `QProgressBar` 来指示下载进度。由于传递的参数是 `qint64` 类型，我们不能直接使用 `QProgressBar`，因为它只接受 `int`。因此，在连接的槽中，我们首先计算下载进度的百分比：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*What just happened?*'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'With the percentage, we set the new value for the progress bar where `progressBar`
    is the pointer to this bar. However, what value will `progressBar->maximum()`
    have and where do we set the range for the progress bar? What is nice is that
    you do not have to set it for every new download. It is only done once, for example,
    in the constructor of the class containing the bar. As range values, I would recommend:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用百分比，我们为进度条设置新的值，其中`progressBar`是指向此进度条的指针。然而，`progressBar->maximum()`将会有什么值，我们在哪里设置进度条的取值范围？令人高兴的是，你不必为每个新的下载设置它。它只需要设置一次，例如，在包含进度条的类的构造函数中。作为取值范围，我建议：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reason is that if you take, for example, a range of 0 to 100 and the progress
    bar is 500 pixels wide, the bar would jump 5 pixels forward for every value change.
    This will look ugly. To get a smooth progression where the bar expands by 1 pixel
    at a time, a range of 0 to 99.999.999 would surely work, but would be highly inefficient.
    This is because the current value of the bar would change a lot without any graphical
    depiction. So, the best value for the range would be 0 to the actual bar's width
    in pixels. Unfortunately, the width of the bar can change depending on the actual
    widget width, and frequently querying the actual size of the bar every time the
    value changes is also not a good solution. Why `2048`, then? The idea behind this
    value is the resolution of the screen. Full HD monitors normally have a width
    of 1920 pixels, thus taking 2^11 (2048) ensures that the progress bar runs smoothly,
    even if it is fully expanded. So, 2048 isn't the perfect number but is a fairly
    good compromise. If you are targeting smaller devices, choose a smaller, more
    appropriate number.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，如果你以0到100的范围为例，并且进度条宽度为500像素，每次值的变化都会使进度条前进5像素。这看起来会很丑。为了得到平滑的进度，每次进度条只扩展1像素，范围应该是0到99.999.999，这当然可以工作，但效率会很高。这是因为进度条的当前值会变化很多，而没有任何图形表示。因此，最佳的范围值应该是0到实际进度条宽度的像素数。不幸的是，进度条的宽度可能会根据实际小部件的宽度而变化，每次值变化时频繁查询实际大小也不是一个好的解决方案。那么为什么是`2048`呢？这个值背后的想法是屏幕的分辨率。全高清显示器通常宽度为1920像素，因此使用2^11（2048）确保进度条即使在完全展开的情况下也能平滑运行。所以，2048不是一个完美的数字，但是一个相当好的折衷方案。如果你针对的是较小的设备，选择一个更小、更合适的数字。
- en: 'To be able to calculate the remaining time for the download to finish, you
    have to start a timer. In this case, use `QElapsedTimer`. After posting the request
    with `QNetworkAccessManager::get()`, start the timer by calling `QElapsedTimer::start()`.
    Assuming that the timer is called `m_timer`, the calculation will be:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够计算下载完成剩余时间，你必须启动一个计时器。在这种情况下，使用`QElapsedTimer`。在通过`QNetworkAccessManager::get()`发送请求后，通过调用`QElapsedTimer::start()`来启动计时器。假设计时器被命名为`m_timer`，计算将是：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`QElapsedTimer::elapsed()` returns the milliseconds that are counted from the
    moment when the timer is started. This value divided by the progress equals the
    estimated total download time. If you subtract the elapsed time and divide the
    result by 1,000, you''ll get the remaining time in seconds.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`QElapsedTimer::elapsed()`返回从计时器开始计数的毫秒数。这个值除以进度等于估计的总下载时间。如果你从已过的时间中减去，然后除以1000，你将得到剩余时间的秒数。'
- en: Using a proxy
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代理
- en: If you like to use a proxy, you first have to set up `QNetworkProxy`. You have
    to define the type of the proxy with `setType()`. As arguments, you will most
    likely want to pass `QNetworkProxy::Socks5Proxy` or `QNetworkProxy::HttpProxy`.
    Then, set up the hostname with `setHostName()`, the username with `setUserName()`,
    and the password with `setPassword()`. The last two properties are, of course,
    only needed if the proxy requires an authentication. Once the proxy is set up,
    you can set it to the access manager via `QNetworkAccessManager::setProxy()`.
    Now, all new requests will use this proxy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用代理，你首先必须设置`QNetworkProxy`。你必须使用`setType()`定义代理的类型。作为参数，你很可能会传递`QNetworkProxy::Socks5Proxy`或`QNetworkProxy::HttpProxy`。然后，使用`setHostName()`设置主机名，使用`setUserName()`设置用户名，使用`setPassword()`设置密码。最后两个属性当然只在代理需要认证时才需要。一旦代理设置好，你可以通过`QNetworkAccessManager::setProxy()`将其设置到访问管理器中。现在，所有新的请求都将使用此代理。
- en: Connecting to Google, Facebook, Twitter, and co.
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到Google、Facebook、Twitter等
- en: Since we discussed `QNetworkAccessManager`, you now have the knowledge you need
    to integrate Facebook, Twitter, or similar sites into your application. They all
    use the HTTP protocol and simple requests in order to retrieve data from them.
    For Facebook, you have to use the so-called Graph API. It describes which interfaces
    are available and what options they offer. If you want to search for users who
    are called "Helena", you have to request [https://graph.facebook.com/search?q=helena&type=user](https://graph.facebook.com/search?q=helena&type=user).
    Of course, you can do this with `QNetworkManager`. You will find more information
    about the possible requests to Facebook at [http://developers.facebook.com/docs/graph-api](http://developers.facebook.com/docs/graph-api).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讨论了 `QNetworkAccessManager`，你现在拥有了将 Facebook、Twitter 或类似网站集成到你的应用程序所需的知识。它们都使用
    HTTP 协议和简单的请求来从它们那里检索数据。对于 Facebook，你必须使用所谓的 Graph API。它描述了哪些接口可用以及它们提供了哪些选项。如果你想搜索名为
    "Helena" 的用户，你必须请求 [https://graph.facebook.com/search?q=helena&type=user](https://graph.facebook.com/search?q=helena&type=user)。当然，你可以使用
    `QNetworkManager` 来做这件事。你可以在 [http://developers.facebook.com/docs/graph-api](http://developers.facebook.com/docs/graph-api)
    找到有关 Facebook 可能请求的更多信息。
- en: If you wish to display tweets in your game, you have to use Twitter's REST or
    Search API. Assuming that you know the ID of a tweet you would like to display,
    then you can get it through [https://api.twitter.com/1.1/statuses/show.json?id=12345](https://api.twitter.com/1.1/statuses/show.json?id=12345),
    where `12345` is the actual ID for the tweet. If you would like to find tweets
    mentioning `#Helena`, you would write [https://api.twitter.com/1.1/search/tweets.json?q=%23Helena](https://api.twitter.com/1.1/search/tweets.json?q=%23Helena).
    You can find more information about the parameters and the other possibilities
    of Twitter's API at [https://dev.twitter.com/docs/api](https://dev.twitter.com/docs/api).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在游戏中显示推文，你必须使用 Twitter 的 REST 或搜索 API。假设你知道你想要显示的推文的 ID，那么你可以通过 [https://api.twitter.com/1.1/statuses/show.json?id=12345](https://api.twitter.com/1.1/statuses/show.json?id=12345)
    获取它，其中 `12345` 是推文的实际 ID。如果你想找到提到 `#Helena` 的推文，你可以写 [https://api.twitter.com/1.1/search/tweets.json?q=%23Helena](https://api.twitter.com/1.1/search/tweets.json?q=%23Helena)。你可以在
    [https://dev.twitter.com/docs/api](https://dev.twitter.com/docs/api) 找到有关 Twitter
    API 参数和其他可能性的更多信息。
- en: Since both Facebook and Twitter need an authentication to use their APIs, we
    will have a look at Google instead. Let's use Google's Distance Matrix API in
    order to get information about how long it would take for us to get from one city
    to another. The technical documentation for the API we are going to use can be
    found at [https://developers.google.com/maps/documentation/distancematrix](https://developers.google.com/maps/documentation/distancematrix).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Facebook 和 Twitter 使用它们的 API 都需要认证，我们将转向 Google。让我们使用 Google 的距离矩阵 API 来获取从一个城市到另一个城市所需时间的信息。我们将使用的
    API 的技术文档可以在 [https://developers.google.com/maps/documentation/distancematrix](https://developers.google.com/maps/documentation/distancematrix)
    找到。
- en: Time for action – using Google's Distance Matrix API
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用 Google 的距离矩阵 API
- en: 'The GUI for this example is kept simple—the source code is attached with the
    book. It consists of two line edits (`ui->from` and `ui->to`) that allow you to
    enter the origin and destination of the journey. It also provides you with a combo
    box (`ui->vehicle`) that allows you to choose a mode of transportation—whether
    you want to drive a car, ride a bicycle, or walk—a push button (`ui->search`)
    to start the request, and a text edit or (`ui->result`) to show the results. The
    result will look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的 GUI 保持简单——源代码附在书中。它由两个行编辑（`ui->from` 和 `ui->to`）组成，允许你输入旅行的起点和终点。它还提供了一个组合框（`ui->vehicle`），允许你选择一种交通方式——无论是开车、骑自行车还是步行——一个按钮（`ui->search`）来启动请求，以及一个文本编辑器（`ui->result`）来显示结果。结果将看起来像这样：
- en: '![Time for action – using Google''s Distance Matrix API](img/8874OS_07_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 使用 Google 的距离矩阵 API](img/8874OS_07_05.jpg)'
- en: '`MainWindow`—a subclass of `QMainWindow`—is the application''s main class that
    holds two private members: `m_nam`, which is a pointer to `QNetworkAccessManager`,
    and `m_reply`, which is a pointer to `QNetworkReply`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow`——`QMainWindow` 的子类——是应用程序的主要类，它包含两个私有成员：`m_nam`，它是一个指向 `QNetworkAccessManager`
    的指针，以及 `m_reply`，它是一个指向 `QNetworkReply` 的指针。'
- en: Time for action – constructing the query
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 构建查询
- en: 'Whenever the button is pressed, the `sendRequest()` slot is called:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每次按钮被按下时，都会调用 `sendRequest()` 槽：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this slot, we first check whether there is an old request, which was stored
    in `m_reply`, and if it is still running. If that is `true`, we abort the old
    request as we are about to schedule a new one. Then, we also wipe out the result
    of the last request by calling `QPlainTextEdit::clear()` on the text edit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个槽中，我们首先检查是否有一个旧请求，它存储在 `m_reply` 中，并且它仍在运行。如果是 `true`，我们将终止旧请求，因为我们即将安排一个新的请求。然后，我们通过在文本编辑器上调用
    `QPlainTextEdit::clear()` 来清除上一次请求的结果。
- en: 'Next, we will construct the URL for the request. We can do this by composing
    the string by hand where we add the query parameters to the base URL similar to:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建请求的 URL。我们可以通过手动组合字符串来完成此操作，我们将查询参数添加到基本 URL 中，类似于以下内容：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Besides the problem that this quickly becomes hard to read when we include
    multiple parameters, it is also rather error-prone. The values of the line edits
    have to be encoded to fit the criteria for a valid URL. For every user value,
    we therefore have to call `QUrl::toPercentEncoding()` explicitly. A much better
    approach, which is easier to read and less error-prone, is to use `QUrlQuery`.
    It circumvents the problem that may result from you forgetting to encode the data.
    So, we do this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当我们包含多个参数时这很快变得难以阅读的问题之外，它还相当容易出错。行编辑器的值必须进行编码以符合有效 URL 的标准。因此，对于每个用户值，我们都必须显式调用
    `QUrl::toPercentEncoding()`。一个更好的方法，它更容易阅读且错误更少，是使用 `QUrlQuery`。它避免了由于忘记编码数据而可能产生的问题。因此，我们这样做：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The usage is pretty clear: we create an instance and then add the query parameters
    with `addQueryItem()`. The first argument is taken as the key and the second as
    the value resulting in a string such as "key=value". The value will be automatically
    encoded when we use `QUrlQuery` in conjunction with `QUrl`. Other benefits of
    using `QUrlQuery` are that we can check whether we have already set a key with
    `hasQueryItem()`, taking the key as an argument, or removed a previous set key
    by calling `removeQueryItem()`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法非常清晰：我们创建一个实例，然后使用 `addQueryItem()` 添加查询参数。第一个参数被视为键，第二个参数被视为值，结果是一个如 "key=value"
    的字符串。当我们将 `QUrlQuery` 与 `QUrl` 一起使用时，值将被自动编码。使用 `QUrlQuery` 的其他好处是，我们可以使用 `hasQueryItem()`
    检查是否已经设置了键，将键作为参数传递，或者通过调用 `removeQueryItem()` 删除之前设置的键。
- en: 'In a real situation, we would, of course, wrap all the preceding literals in
    `QStringLiteral`, but this is omitted here in favor of a better reading. So, let''s
    review which parameters we have set. The `sensor` key is set to `false` as we
    are not using a GPS device to locate our position. The `language` key is set to
    `English`, and for units, we favor metric over imperial. Then, the search-related
    parameters are set. The `origins` key holds the places we want to start from.
    As its value, the text of the `ui->from` line edit is chosen. If you want to query
    multiple starting positions, you just have to combine them using `|`. Equivalent
    to the origins, we set up the value for destinations. Last, we pass the value
    of the combo box to mode, which defines whether we want to go by a car, bicycle,
    or whether we want to walk, as shown in the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下，我们当然会使用 `QStringLiteral` 将所有前面的字面量包装起来，但在这里我们为了更好的可读性而省略了它。因此，让我们回顾一下我们设置了哪些参数。`sensor`
    键设置为 `false`，因为我们没有使用 GPS 设备来定位我们的位置。`language` 键设置为 `English`，对于单位，我们更喜欢公制而不是英制。然后，我们设置了与搜索相关的参数。`origins`
    键包含我们想要开始的地点。其值是 `ui->from` 行编辑器的文本。如果您想查询多个起始位置，只需使用 `|` 将它们组合即可。与 `origins`
    相似，我们为目的地设置了值。最后，我们将组合框的值传递给 `mode`，它定义了我们想要开车、骑自行车还是步行，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we create `QUrl` that contains the address to which the query should be
    posted. By including "json" at the end, we define that the server should transfer
    its reply using the JSON format. Google also provides the option for us to get
    the result as XML. To achieve this, simply replace "json" with "xml". However,
    since the APIs of Facebook and Twitter return JSON, we will use this format.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个包含查询应提交的地址的 `QUrl`。通过在末尾包含 "json"，我们定义服务器应使用 JSON 格式传输其回复。Google 还为我们提供了将结果获取为
    XML 的选项。要实现这一点，只需将 "json" 替换为 "xml"。然而，由于 Facebook 和 Twitter 的 API 返回 JSON，我们将使用此格式。
- en: Then, we set the previous constructed `query` to the URL by calling `QUrl::setQuery()`.
    This automatically encodes the values so we do not have to worry about that. Last,
    we post the request by calling the `get()` function and store the returned `QNetworkReply`
    in `m_reply`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `QUrl::setQuery()` 将先前构建的 `query` 设置到 URL 中。这会自动编码值，所以我们不需要担心这一点。最后，我们通过调用
    `get()` 函数发送请求，并将返回的 `QNetworkReply` 存储在 `m_reply` 中。
- en: Time for action – parsing the server's reply
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 解析服务器的回复
- en: 'In the constructor, we have connected the manager''s `finish()` signal to the
    `finished()` slot of the `MainWindow` class. It will thus be called after the
    request has been posted:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将管理器的 `finish()` 信号连接到 `MainWindow` 类的 `finished()` 槽。因此，它将在请求发送后调用：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, we check whether the reply that was passed is the one that we have requested
    through `m_nam`. If this is not the case, we delete `reply` and exit the function.
    This can happen if a reply was aborted by the `sendRequest()` slot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查传递的回复是否是我们通过 `m_nam` 请求的那个。如果不是这种情况，我们删除 `reply` 并退出函数。这可能会发生在 `sendRequest()`
    槽取消回复的情况下：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we are now sure that it is our request, we set `m_reply` to null because
    we have handled it and do not need this information anymore. Next we check whether
    an error occurred, and if it did, we put the reply''s error string in the text
    edit, delete reply, and exit the function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在确定这是我们请求的，我们将 `m_reply` 设置为 null，因为我们已经处理了它，不再需要这个信息。接下来我们检查是否发生了错误，如果发生了，我们将回复的错误字符串放入文本编辑器中，删除回复，并退出函数：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With `readAll()`, we get the content of the server''s reply. Since the transferred
    data is not large, we do not need to use partial reading with `readyRead()`. The
    content is then converted to `QJsonDocument` using the `QJsonDocument::fromJson()`
    static function, which takes `QByteArray` as an argument and parses its data.
    If the document is null, the server''s reply wasn''t valid, and then, we show
    an error message on the text edit, delete the reply, and exit the function. We
    do the same if the document does not contain an object, as the API call should
    respond with a single object, as shown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readAll()`，我们获取服务器的回复内容。由于传输的数据量不大，我们不需要使用 `readyRead()` 进行部分读取。然后，使用 `QJsonDocument::fromJson()`
    静态函数将内容转换为 `QJsonDocument`，该函数接受 `QByteArray` 作为参数并解析其数据。如果文档为空，则表示服务器的回复无效，然后我们在文本编辑器上显示错误消息，删除回复，并退出函数。如果文档不包含对象，我们也会这样做，因为
    API 调用应该只响应一个对象，如下所示：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we now made sure that there is an object, we store it in `obj`. Furthermore,
    due to the API, we also know that the object holds the `origin_addresses` and
    `destination_addresses` keys. Both values are arrays that hold the requested origins
    and destinations. From this point on, we will skip any tests if the values exist
    and are valid since we trust the API. The object also holds a key called `status`,
    whose'' value can be used to check whether the query may have failed and if yes,
    why? The last two lines of the source code store the origins and destinations
    in two variant lists. With `obj.value("origin_addresses")`, we get `QJsonValue`
    that holds the value of the pair specified by the `origin_addresses` key. `QJsonValue::toArray()`
    converts this value to `QJsonArray`, which then is converted to `QVariantList`
    using `QJsonArray::toVariantList()`. The returned JSON file for a search requesting
    the distance from Warsaw or Erlangen to Birmingham will look like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经确认存在一个对象，我们将其存储在 `obj` 中。此外，由于 API，我们还知道该对象包含 `origin_addresses` 和 `destination_addresses`
    键。这两个值都是数组，包含请求的起点和终点。从这一点开始，如果值存在且有效，我们将跳过任何测试，因为我们信任 API。该对象还包含一个名为 `status`
    的键，其值可以用来检查查询是否可能失败，如果是，原因是什么？源代码的最后两行将起点和终点存储在两个变体列表中。通过 `obj.value("origin_addresses")`，我们获取包含
    `origin_addresses` 键指定的值对的 `QJsonValue`。`QJsonValue::toArray()` 将此值转换为 `QJsonArray`，然后使用
    `QJsonArray::toVariantList()` 转换为 `QVariantList`。对于请求从华沙或埃尔兰根到伯明翰的距离的搜索，返回的 JSON
    文件将如下所示：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `rows` key holds the actual results as an array. The first object in this
    array belongs to the first origin, the second object to the second origin, and
    so on. Each object holds a key named `elements`, whose'' value is also an array
    of objects that belong to the corresponding destinations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`rows` 键持有实际结果作为数组。该数组中的第一个对象属于第一个起点，第二个对象属于第二个起点，依此类推。每个对象都包含一个名为 `elements`
    的键，其值也是一个对象数组，属于相应的目的地：'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Each JSON object for an origin-destination pair (`{...}` in the preceding example)
    consists of two pairs with the distance and duration keys. Both the values of
    these keys are arrays that hold the `text` and `value` keys, where `text` is a
    human-readable phrase for `value`. The object for the Warsaw-Birmingham search
    looks as shown in the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个起点-终点对（前一个示例中的 `{...}`）的 JSON 对象由两个键值对组成，分别是距离和持续时间键。这两个键的值都是数组，包含 `text`
    和 `value` 键，其中 `text` 是 `value` 的人类可读短语。Warsaw-Birmingham 搜索的对象如下所示：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the value of `value` for distance is the distance expressed
    in meters—since we have used `units=metric` in the request—and the value of `text`
    is value transformed into kilometers with the post fix "km". The same applies
    to duration. Here, value is expressed in seconds and text is value converted into
    hours and minutes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，距离的 `value` 是以米为单位的距离——因为我们已经在请求中使用了 `units=metric`——而 `text` 的值是将值转换为带有后缀
    "km" 的千米。同样的情况也适用于持续时间。在这里，值以秒为单位表示，而 `text` 是将值转换为小时和分钟的表示。
- en: 'Now that we know how the returned JSON is structured, we display the value
    of each origin-destination pair in the text edit. Therefore, we loop through each
    possible pairing using `QVariantLists`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了返回的 JSON 的结构，我们将在文本编辑器中显示每个起点-终点对的值。因此，我们使用 `QVariantLists` 遍历每个可能的配对：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This scope will be reached for each combination. Think of the transferred result
    as a table where the origins are rows and the destinations are columns:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个作用域将针对每种组合被访问。想象一下传递的结果就像一个表格，其中起点是行，目的地是列：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We cache the constructed text in a local variable called output. First, we
    add the string "From:" and the current origin to output. To make it look at least
    a little bit nicer, we call `leftJustified()`. It causes "From:" to be filled
    with spaces until the size of the entire string is `10`. The output will then
    be aligned. The value of the current origin is normally accessed through `QList::at()`,
    and since it is `QVariantList`, we need to convert the returned `QVariant` to
    `QString`. Thus, we call `toString()`. The same is done for the destination, which
    results in the following as the value for output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的文本缓存到一个名为 output 的局部变量中。首先，我们在 output 中添加字符串 "From:" 和当前源地址。为了让它看起来至少稍微美观一些，我们调用
    `leftJustified()`。这会导致 "From:" 被填充空格直到整个字符串的大小为 `10`。然后输出将被对齐。当前源地址的值通常通过 `QList::at()`
    访问，由于它是 `QVariantList`，我们需要将返回的 `QVariant` 转换为 `QString`。因此，我们调用 `toString()`。同样的操作也应用于目的地，结果如下所示，这是
    output 的值：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will read duration and distance from the corresponding `QJsonObject`
    from where we call `data`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从我们调用 `data` 的相应 `QJsonObject` 中读取持续时间和距离：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Starting at the reply''s root object, we fetch the value of rows and convert
    it to an array (`obj.value("rows").toArray()`). Then, we fetch the value of the
    current row (`.at(i)`), convert it to a JSON object, and fetch its elements key
    (`.toObject().value("elements")`). Since this value is also an array—the columns
    of the row—we convert it to an array, fetch the current column (`.toArray().at(j)`),
    and convert it to an object. This is the object that contains the distance and
    duration for an origin-destination pair in the cell (`i;j`). Beside these two
    keys, the object also holds a key called `status`. Its value indicates whether
    the search was successful (`OK`), whether the origin or destination could not
    be found (`NOT_FOUND`), or whether the search could not find a route between the
    origin and destination (`ZERO_RESULTS`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从回复的根对象开始，我们获取行值并将其转换为数组（`obj.value("rows").toArray()`）。然后，我们获取当前行的值（`.at(i)`），将其转换为
    JSON 对象，并获取其元素键（`.toObject().value("elements")`）。由于这个值也是一个数组——行的列——我们将其转换为数组，获取当前列（`.toArray().at(j)`），并将其转换为对象。这就是包含起点-终点对单元格（`i;j`）中的距离和持续时间的对象。除了这两个键之外，该对象还包含一个名为
    `status` 的键。它的值表示搜索是否成功（`OK`），起点或目的地是否找不到（`NOT_FOUND`），或者搜索是否无法在起点和目的地之间找到路线（`ZERO_RESULTS`）：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We store the value of status in a local variable that is also named status:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将状态值存储在一个也命名为 status 的局部变量中：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If all goes well, we then add `distance` and `duration` to the output and also
    align the labels as we did before using `leftJustified()`. For distance, we want
    to show the phrased result. Therefore, we first get the JSON value of the distance
    key (`data.value("distance")`), convert it to an object, and request the value
    for the text key (`.toObject().value("text")`). Lastly, we convert `QJsonValue`
    to `QString` using `toString()`. The same applies for duration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们接着将`distance`和`duration`添加到输出中，并且像之前使用`leftJustified()`一样对标签进行对齐。对于距离，我们希望显示短语化的结果。因此，我们首先获取距离键的JSON值(`data.value("distance")`)，将其转换为对象，并请求文本键的值(`.toObject().value("text")`)。最后，我们使用`toString()`将`QJsonValue`转换为`QString`。对于持续时间也是如此：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the API returns errors, we set an appropriate error text as output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API返回错误，我们将设置适当的错误文本作为输出：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we add a line consisting of `35` equals signs (`fill('=', 35)`) to
    separate the result in one cell from the other cells. The output is then placed
    at the end of the text edit. This is done by moving the cursor to the end of the
    edit, by calling `moveCursor(QTextCursor::End)`, and inserting output into the
    edit with `insertPlainText(output)`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一行由`35`个等号(`fill('=', 35)`)组成的线，以将结果单元格与其他单元格分开。然后将输出放置在文本编辑的末尾。这是通过将光标移动到编辑的末尾，调用`moveCursor(QTextCursor::End)`，并使用`insertPlainText(output)`将输出插入到编辑中完成的。
- en: 'When the loops finish, we must not forget to delete the reply. The actual result
    then looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，我们一定不要忘记删除回复。实际结果如下所示：
- en: '![Time for action – parsing the server''s reply](img/8874OS_07_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 解析服务器的回复](img/8874OS_07_06.jpg)'
- en: Have a go hero – choosing XML as the reply's format
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 选择XML作为回复的格式
- en: To hone your XML skills, you can use [http://maps.googleapis.com/maps/api/distancematrix/xml](http://maps.googleapis.com/maps/api/distancematrix/xml)
    as a URL to which you send the requests. Then, you can parse the XML file as we
    did with JSON and display the retrieved data likewise.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了磨练你的XML技能，你可以使用[http://maps.googleapis.com/maps/api/distancematrix/xml](http://maps.googleapis.com/maps/api/distancematrix/xml)作为URL，向其发送请求。然后，你可以像处理JSON一样解析XML文件，并同样显示检索到的数据。
- en: Controlling the connectivity state
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制连接状态
- en: As a matter of fact, you can only use `QNetworkAccessManager` if you have an
    active connection to the Internet. Since you cannot theoretically know the connectivity
    state, you have to check this at the runtime of the application. With the help
    of the Bearer API, you can check whether the computer, mobile device, or tablet
    is online and you can even start a new connection—if the operating system supports
    it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只有在你有活跃的互联网连接时才能使用`QNetworkAccessManager`。由于理论上你无法知道连接状态，你必须在应用程序运行时进行检查。借助Bearer
    API，你可以检查计算机、移动设备或平板电脑是否在线，甚至可以启动一个新的连接——如果操作系统支持的话。
- en: The Bearer API mainly consists of four classes. `QNetworkConfigurationManager`
    is the base and starting point. It holds all network configurations available
    on the system. Furthermore, it provides information about the network capabilities,
    for example, whether you can start and stop interfaces. The network configurations
    found by it are stored as `QNetworkConfiguration` classes. `QNetworkConfiguration`
    holds all information about an access point but not about a network interface,
    as an interface can provide multiple access points. This class also provides only
    the information about network configurations. You can't configure an access point
    or a network interface through `QNetworkConfiguration`. The network configuration
    is up to the operating system, and therefore, `QNetworkConfiguration` is a read-only
    class. With `QNetworkConfiguration`, however, you can determine whether the type
    of connection is an Ethernet, WLAN, or 2G connection. This may influence what
    kind of data and, more importantly, what size of data you are going to download.
    With `QNetworkSession`, you can then start or stop system network interfaces,
    which are defined by the configurations. This way, you gain control over an access
    point. `QNetworkSession` also provides session management that is useful when
    a system's access point is used by more than one application. The session ensures
    that the underlying interface only gets terminated after the last session has
    been closed. Lastly, `QNetworkInterface` provides classic information such as
    the hardware address or interface name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkConfigurationManager
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QNetworkConfigurationManager` manages all network configurations that are
    available on a system. You can access these configurations by calling `allConfigurations()`.
    Of course, you have to create an instance of the manager first:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The configurations are returned as a list. The default behavior of `allConfigurations()`
    is to return all possible configurations. However, you can also retrieve a filtered
    list. If you pass `QNetworkConfiguration::Active` as an argument, the list only
    contains configurations that have at least one active session. If you create a
    new session based on such a configuration, it will be active and connected. By
    passing `QNetworkConfiguration::Discovered` as an argument, you will get a list
    with configurations that can be used to immediately start a session. Note, however,
    that at this point, you cannot be sure whether the underlying interface can be
    started. The last important argument is `QNetworkConfiguration::Defined`. With
    this argument, `allConfigurations()` returns a list of configurations that are
    known to the system but are not usable right now. This may be a previously used
    WLAN hotspot, which is currently out of range.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: You will be notified whenever the configurations change. If a new configuration
    becomes available, the manager emits the `configurationAdded()` signal. This may
    happen, for example, if mobile data transmission becomes available or if the user
    turns his/her device's WLAN adapter on. If a configuration is removed, for example,
    if the WLAN adapter is turned off, `configurationRemoved()` is emitted. Lastly,
    when a configuration gets changed, you will be notified by the `configurationChanged()`
    signal. All three signals pass a constant reference to the configuration about
    what was added, removed, or changed. The configuration passed by the `configurationRemoved()`
    signal is, of course, invalid. It still contains, the name and identifier of the
    removed configuration.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置更改时，您将收到通知。如果出现新的配置，则管理器会发出 `configurationAdded()` 信号。例如，这可能发生在移动数据传输变得可用或用户打开其设备的
    WLAN 适配器时。如果移除配置，例如关闭 WLAN 适配器，则发出 `configurationRemoved()`。最后，当配置更改时，您将通过 `configurationChanged()`
    信号收到通知。所有三个信号都传递对配置的常量引用，说明添加、移除或更改的内容。通过 `configurationRemoved()` 信号传递的配置当然无效。它仍然包含已移除配置的名称和标识符。
- en: To find out whether any network interface of the system is active, call `isOnline()`.
    If you want to be notified about a mode change, track the `onlineStateChanged()`
    signal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定系统中的任何网络接口是否处于活动状态，请调用 `isOnline()`。如果您想被通知模式更改，请跟踪 `onlineStateChanged()`
    信号。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since a WLAN scan takes a certain amount of time, `allConfigurations()` may
    not return all the available configurations. To ensure that configurations are
    completely populated, call `updateConfigurations()` first. Due to the long time
    it may take to gather all of the information about the system's network configurations,
    this call is asynchronous. Wait for the `updateCompleted()` signal and only then,
    call `allConfigurations()`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WLAN 扫描需要一定的时间，`allConfigurations()` 可能不会返回所有可用的配置。为确保配置完全填充，请先调用 `updateConfigurations()`。由于收集系统网络配置的所有信息可能需要很长时间，此调用是异步的。等待
    `updateCompleted()` 信号，然后才能调用 `allConfigurations()`。
- en: '`QNetworkConfigurationManager` also informs you about the Bearer API''s capabilities.
    The `capabilities()` function returns a flag of the `QNetworkConfigurationManager::Capabilities`
    type and describes the available possibilities that are platform-specific. The
    values you may be most interested in are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfigurationManager` 还会通知您 Bearer API 的功能。`capabilities()` 函数返回 `QNetworkConfigurationManager::Capabilities`
    类型的标志，并描述了特定平台的可用可能性。您可能最感兴趣的值如下：'
- en: '| Value | Meaning |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CanStartAndStopInterfaces` | This means that you can start and stop access
    points. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `CanStartAndStopInterfaces` | 这表示您可以启动和停止接入点。 |'
- en: '| `ApplicationLevelRoaming` | This indicates that the system will inform you
    if a more suitable access point is available, and that you can actively change
    the access point if you think there is a better one available. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `ApplicationLevelRoaming` | 这表示系统会通知您是否有更合适的接入点可用，并且如果您认为有更好的接入点，您可以主动更改接入点。
    |'
- en: '| `DataStatistics` | With this capability, `QNetworkSession` contains information
    about the transmitted and received data. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `DataStatistics` | 使用此功能，`QNetworkSession` 包含有关传输和接收的数据信息。 |'
- en: QNetworkConfiguration
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QNetworkConfiguration
- en: '`QNetworkConfiguration` holds, as mentioned earlier, information about an access
    point. With `name()`, you get the user-visible name for a configuration, and with
    `identifier()`you get a unique, system-specific identifier. If you develop games
    for mobile devices, it may be of advantage to you to know which type of connection
    is being used. This might influence the data that you request; for example, the
    quality and thus, the size of a video. With `bearerType()`, the type of bearer
    used by a configuration is returned. The returned enumeration values are rather
    self-explanatory: `BearerEthernet`, `BearerWLAN`, `Bearer2G`, `BearerCDMA2000`,
    `BearerWCDMA`, `BearerHSPA`, `BearerBluetooth`, `BearerWiMAX`, and so on. You
    can look up the full-value list in the documentation for `QNetworkConfiguration::BearerType`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration` 如前所述，包含有关接入点的信息。使用 `name()`，您可以获取配置的用户可见名称，而使用 `identifier()`，您可以获取一个唯一的、系统特定的标识符。如果您为移动设备开发游戏，了解正在使用哪种类型的连接可能对您有利。这可能会影响您请求的数据；例如，视频的质量及其大小。使用
    `bearerType()`，将返回配置使用的承载类型。返回的枚举值相当直观：`BearerEthernet`、`BearerWLAN`、`Bearer2G`、`BearerCDMA2000`、`BearerWCDMA`、`BearerHSPA`、`BearerBluetooth`、`BearerWiMAX`
    等。您可以在 `QNetworkConfiguration::BearerType` 的文档中查找完整的值列表。'
- en: With `purpose()`, you get the purpose of the configuration, for example, whether
    it is suitable to access a private network (`QNetworkConfiguration::PrivatePurpose`)
    or to access a public network (`QNetworkConfiguration::PublicPurpose`). The state
    of the configuration, if it is defined, discovered or active, as previously described,
    can be accessed through `state()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `purpose()`，您可以获取配置的目的，例如，它是否适合访问私有网络（`QNetworkConfiguration::PrivatePurpose`）或访问公共网络（`QNetworkConfiguration::PublicPurpose`）。如果已定义、发现或激活，配置的状态，如前所述，可以通过
    `state()` 访问。
- en: QNetworkSession
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QNetworkSession
- en: 'To start a network interface or to tell the system to keep an interface connected
    for as long as you need it, you have to start a session:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动网络接口或告诉系统保持接口连接以满足您的需求，您必须启动一个会话：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A session is based on a configuration. When there is more than one session
    and you are not sure which one to use, use `QNetworkConfigurationManager::defaultConfiguration()`.
    It returns the system''s default configuration. Based on this, you can create
    an instance of `QNetworkSession`. The first argument, the configuration, is required.
    The second is optional but is recommended since it sets a parent and we do not
    have to take care of the deletion. You may want to check whether the configuration
    is valid (`QNetworkConfiguration::isValid()`) first. Calling `open()` will start
    the session and connect the interface if needed and supported. Since `open()`
    can take some time, the call is asynchronous. So, either listen to the `opened()`
    signal, which is emitted as soon as the session is open, or to the `error()` signal
    if an error happened. The error is of the `QNetworkSession::SessionError` type.
    Alternatively, instead of checking the `opened()` signal, you can also watch the
    `stateChanged()` signal. The possible states for a session can be: `Invalid`,
    `NotAvailable`, `Connecting`, `Connected`, `Closing`, `Disconnected`, and `Roaming`.
    If you want to make `open()` synchronous, call `waitForOpened()` right after calling
    `open()`. It will block the event loop till the session is open. This function
    will return `true` on success and `false` otherwise. To limit the waiting time,
    you can define a time-out. Just pass the milliseconds that you are willing to
    wait as an argument to `waitForOpened()`. To check whether a session is open,
    use `isOpen()`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 会话基于配置。当存在多个会话且您不确定使用哪个时，请使用 `QNetworkConfigurationManager::defaultConfiguration()`。它返回系统的默认配置。基于此，您可以创建
    `QNetworkSession` 的一个实例。第一个参数，即配置，是必需的。第二个参数是可选的，但建议使用，因为它设置了一个父对象，我们不需要处理删除。您可能想先检查配置是否有效（`QNetworkConfiguration::isValid()`）。调用
    `open()` 将启动会话并在需要和受支持的情况下连接接口。由于 `open()` 可能需要一些时间，该调用是异步的。因此，您可以监听 `opened()`
    信号，该信号在会话打开时立即发出，或者监听 `error()` 信号，如果发生错误。错误类型为 `QNetworkSession::SessionError`。或者，您也可以监听
    `stateChanged()` 信号。会话的可能状态可以是：`Invalid`（无效）、`NotAvailable`（不可用）、`Connecting`（连接中）、`Connected`（已连接）、`Closing`（关闭中）、`Disconnected`（断开连接）和
    `Roaming`（漫游）。如果您想使 `open()` 同步，请在调用 `open()` 后立即调用 `waitForOpened()`。它将阻塞事件循环，直到会话打开。此函数在成功时返回
    `true`，否则返回 `false`。为了限制等待时间，您可以定义一个超时。只需将您愿意等待的毫秒数作为参数传递给 `waitForOpened()`。要检查会话是否打开，请使用
    `isOpen()`。
- en: To close the session, call `close()`. If no session is left on the interface,
    it will be shot down. To force an interface to disconnect, call `stop()`. This
    call will invalidate all the sessions that are based on that interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭会话，请调用 `close()`。如果界面上没有剩余的会话，它将被关闭。要强制断开接口，请调用 `stop()`。此调用将使基于该接口的所有会话无效。
- en: You may receive the `preferredConfigurationChanged()` signal, which indicates
    that the preferred configuration, that is, for example, the preferred access point,
    has changed. This may be the case if a WLAN network is now in range and you do
    not have to use 2G anymore. The new configuration is passed as the first argument
    and the second one indicates whether changing the new access point will also alter
    the IP address. Besides checking for the signal, you can also inquire whether
    roaming is available for a configuration by calling `QNetworkConfiguration::isRoamingAvailable()`.
    If roaming is available, you have to decide to either reject the offer by calling
    `ignore()` or to accept it by calling `migrate()`. If you accept roaming, it will
    emit `newConfigurationActivated()` when the session is roamed. After you have
    checked the new connection, you can either accept the new access point or reject
    it. The latter means that you will return to the previous access point. If you
    accept the new access point, the previous one will be terminated.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到 `preferredConfigurationChanged()` 信号，这表示首选配置，即例如首选接入点已更改。这可能是在现在有 WLAN
    网络范围内，您不再需要使用 2G 的情况下。新的配置作为第一个参数传递，第二个参数指示更改新的接入点是否会同时更改 IP 地址。除了检查信号外，您还可以通过调用
    `QNetworkConfiguration::isRoamingAvailable()` 来查询配置是否支持漫游。如果漫游可用，您必须决定通过调用 `ignore()`
    拒绝提议，或者通过调用 `migrate()` 接受它。如果您接受漫游，当会话漫游时将发出 `newConfigurationActivated()`。在检查新的连接后，您可以选择接受新的接入点或拒绝它。后者意味着您将返回到以前的接入点。如果您接受新的接入点，以前的接入点将被终止。
- en: QNetworkInterface
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QNetworkInterface
- en: 'To get the interface that is used by a session, call `QNetworkSession::interface()`.
    It will return the `QNetworkInterface` object, which describes the interface.
    With `hardwareAddress()`, you get the low-level hardware address of the interface
    that is normally the MAC address. The name of the interface can be obtained by
    `name()`, which is a string such as "eth0" or "wlan0". A list of IP addresses
    as well as their netmasks and broadcast addresses registered with the interface
    is returned by `addressEntries()`. Furthermore, information about whether the
    interface is a loopback or whether it supports multicasting can be queried with
    `flags()`. The returned bitmask is a combination of these values: `IsUp`, `IsRunning`,
    `CanBroadcast`, `IsLoopBack`, `IsPointToPoint`, and `CanMulticast`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取会话使用的接口，请调用 `QNetworkSession::interface()`。它将返回 `QNetworkInterface` 对象，该对象描述了接口。通过
    `hardwareAddress()`，您可以得到接口的低级硬件地址，通常是 MAC 地址。接口的名称可以通过 `name()` 获取，它是一个如 "eth0"
    或 "wlan0" 的字符串。`addressEntries()` 返回与接口注册的 IP 地址列表以及它们的子网掩码和广播地址。此外，您可以通过 `flags()`
    查询接口是否是环回或是否支持多播。返回的位掩码是这些值的组合：`IsUp`、`IsRunning`、`CanBroadcast`、`IsLoopBack`、`IsPointToPoint`
    和 `CanMulticast`。
- en: Communicating between games
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏间的通信
- en: After having discussed Qt's high-level network classes such as `QNetworkAccessManager`
    and `QNetworkConfigurationManager`, we will now have a look at a lower-level network
    classes and see how Qt supports you when it comes to implementing TCP or UDP servers
    and clients. This becomes relevant when you plan to extend your game by including
    a multiplayer mode. For such a task, Qt offers `QTcpSocket`, `QUdpSocket`, and
    `QTcpServer`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了 Qt 的高级网络类，如 `QNetworkAccessManager` 和 `QNetworkConfigurationManager` 之后，我们现在将查看较低级别的网络类，并了解
    Qt 在实现 TCP 或 UDP 服务器和客户端时如何支持您。当您计划通过包括多人模式来扩展游戏时，这一点变得相关。为此类任务，Qt 提供 `QTcpSocket`、`QUdpSocket`
    和 `QTcpServer`。
- en: Time for action – realizing a simple chat program
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单聊天程序的时间
- en: 'To get familiar with `QTcpServer` and `QTcpSocket`, let''s develop a simple
    chat program. This example will teach you the basic knowledge of network handling
    in Qt so that you can use this skill later to connect two or more copies of a
    game. At the end of this exercise, we want to see something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉 `QTcpServer` 和 `QTcpSocket`，让我们开发一个简单的聊天程序。这个例子将教会您 Qt 中网络处理的基本知识，以便您以后可以使用这项技能连接两个或更多个游戏副本。在这个练习结束时，我们希望看到如下内容：
- en: '![Time for action – realizing a simple chat program](img/8874OS_07_07.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![实现简单聊天程序的时间 - 实现一个简单的聊天程序](img/8874OS_07_07.jpg)'
- en: On both the left-hand side and the right-hand side of the preceding figure,
    you can see a client, whereas the server is in the middle. We'll start by taking
    a closer look at the server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图例的左侧和右侧，你可以看到一个客户端，而服务器位于中间。我们将首先仔细看看服务器。
- en: The server – QTcpServer
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器 – QTcpServer
- en: 'As a protocol for communication, we will use **Transmission Control Protocol**
    (**TCP**). You may know this network protocol from the two most popular Internet
    protocols: HTTP and FTP. Both use TCP for their communication and so do the globally
    used protocols for e-mail traffic: SMTP, POP3, and IMAP. The main advantage of
    TCP, however, is its reliability and connection-based architecture. Data transferred
    by TCP is guaranteed to be complete, ordered, and without any duplicates. The
    protocol is furthermore stream orientated, which allows us to use `QDataStream`
    or `QTextStream`. A downside to TCP is its speed. This is because the missing
    data has to be retransmitted until the receiver fully receives it. By default,
    this causes a retransmission of all the data that was transmitted after the missing
    part. So, you should only choose TCP as a protocol if speed is not your top priority,
    but rather the completeness and correctness of the transmitted data. This applies
    if you send unique nonrepetitive data.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为通信协议，我们将使用 **传输控制协议**（**TCP**）。你可能从两个最流行的互联网协议 HTTP 和 FTP 中了解到这个网络协议。这两个协议都使用
    TCP 进行通信，全球使用的电子邮件流量协议也是如此：SMTP、POP3 和 IMAP。然而，TCP 的主要优势是其可靠性和基于连接的架构。通过 TCP 传输的数据保证是完整、有序且无重复的。此外，该协议是面向流的，这允许我们使用
    `QDataStream` 或 `QTextStream`。TCP 的缺点是速度较慢。这是因为丢失的数据必须重新传输，直到接收方完全接收为止。默认情况下，这会导致丢失部分之后传输的所有数据重新传输。因此，你应该只在速度不是首要考虑的情况下选择
    TCP 作为协议，而是数据的完整性和正确性。如果你发送的是唯一非重复数据，这也适用。
- en: Time for action – setting up the server
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 设置服务器
- en: 'A look at the server''s GUI shows us that it principally consists of `QPlainTextEdit`
    (`ui->log`) that is used to display system messages and a button (`ui->disconnectClients`),
    which allows us to disconnect all the current connected clients. On top, next
    to the button, the server''s address and port are displayed (`ui->address` and
    `ui->port`). After setting up the user interface in the constructor of the server''s
    class `TcpServer`, we initiate the internally used `QTcpServer`, which is stored
    in the `m_server` private member variable:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器 GUI 的外观显示，它基本上由 `QPlainTextEdit` (`ui->log`) 组成，用于显示系统消息，以及一个按钮（`ui->disconnectClients`），允许我们断开所有当前连接的客户端。在按钮旁边，显示服务器的地址和端口（`ui->address`
    和 `ui->port`）。在服务器类的构造函数中设置用户界面后，我们初始化内部使用的 `QTcpServer`，它存储在 `m_server` 私有成员变量中：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*What just happened?*'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'With `QTcpServer::listen()`, we defined that the server should listen to the
    localhost and the `52693` port for new incoming connections. The value used here,
    `QHostAddress::LocalHost` of the `QHostAddress::SpecialAddress` enumeration, will
    resolve to `127.0.0.1`. If you instead pass `QHostAddress::Any`, the server will
    listen to all IPv4 interfaces as well as to IPv6 interfaces. If you only want
    to listen to a specific address, just pass this address as `QHostAddress`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QTcpServer::listen()`，我们定义服务器应监听本地的 `52693` 端口以接收新的连接。这里使用的值，`QHostAddress::LocalHost`
    来自 `QHostAddress::SpecialAddress` 枚举，将解析为 `127.0.0.1`。如果你传递 `QHostAddress::Any`，服务器将监听所有
    IPv4 接口以及 IPv6 接口。如果你只想监听特定的地址，只需将此地址作为 `QHostAddress` 传递：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will behave like the one in the preceding code only in that the server
    will now listen to a port that will be chosen automatically. On success, `listen()`
    will return as `true`. So, if something goes wrong in the example it will show
    an error message on the text edit and exit the function. To compose the error
    message, we are using `QTcpServer::errorString()`, which holds a human-readable
    error phrase.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表现得像前面代码中的那个，只是现在服务器将监听一个自动选择的端口。如果成功，`listen()` 将返回 `true`。因此，如果示例中出现问题，它将在文本编辑器上显示错误消息并退出函数。为了组成错误消息，我们使用
    `QTcpServer::errorString()`，它包含一个可读的错误短语。
- en: 'To handle the error in your game''s code, the error string is not suitable.
    In any case where you need to know the exact error, use `QTcpServer::serverError()`,
    which returns the enumeration value of `QAbstractSocket::SocketError`. Based on
    this, you know exactly what went wrong, for example, `QAbstractSocket::HostNotFoundError`.
    If `listen()` was successful, we connect the server''s `newConnection()` signal
    to the class''s `newConnection()` slot. The signal will be emitted every time
    a new connection is available:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理游戏中代码的错误，错误字符串并不适用。在任何需要知道确切错误的情况下，使用 `QTcpServer::serverError()`，它返回 `QAbstractSocket::SocketError`
    的枚举值。基于此，你可以确切地知道出了什么问题，例如，`QAbstractSocket::HostNotFoundError`。如果 `listen()`
    成功，我们将服务器的 `newConnection()` 信号连接到类的 `newConnection()` 槽。每当有新的连接可用时，该信号将被触发：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Lastly, we show the server's address a port number that can be accessed through
    `serverAddress()` and `serverPort()`. This information is needed by the clients
    so that they are able to connect to the server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了可以通过 `serverAddress()` 和 `serverPort()` 获取的服务器地址和端口号。这些信息对于客户端来说是必要的，以便它们能够连接到服务器。
- en: Time for action – reacting on a new pending connection
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 对新挂起连接做出反应
- en: 'As soon as a client tries to connect to the server, the `newConnection()` slot
    will be called:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端尝试连接到服务器，`newConnection()` 槽将被调用：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*What just happened?*'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Since more than one connection may be pending, we use `hasPendingConnections()`
    to determine whether there is at least one more pending connection. Each one is
    then handled inside the `while` loop. To get a pending connection of the `QTcpSocket`
    type, we call `nextPendingConnection()` and add this connection to a private list
    called `m_clients`, which holds all active connections. In the next line, as there
    is now at least one connection, we enable the button that allows all connections
    to be closed. Therefore, the slot connected to the button's `click()` signal will
    call `QTcpSocket::close()` on each single connection. When a connection is closed,
    its socket emits a `disconnected()` signal. We connect this signal to our `removeConnection()`
    slot. With the last connection, we react to the socket's `readyRead()` signal,
    which indicates that new data is available. In such a situation, our `newMessage()`
    slot is called. Lastly, we print a system message that a new connection has been
    established. The address and port of the connecting client and peer can be retrieved
    by the socket's `peerAddress()` and `peerPort()` functions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能有多个挂起的连接，我们使用 `hasPendingConnections()` 来确定是否至少还有一个挂起的连接。然后在 `while` 循环内部处理每一个连接。要获取
    `QTcpSocket` 类型的挂起连接，我们调用 `nextPendingConnection()` 并将此连接添加到名为 `m_clients` 的私有列表中，该列表包含所有活动连接。在下一行，由于现在至少有一个连接，我们启用了允许关闭所有连接的按钮。因此，连接到按钮
    `click()` 信号的槽将调用每个单独连接的 `QTcpSocket::close()`。当连接关闭时，其套接字发出 `disconnected()`
    信号。我们将此信号连接到我们的 `removeConnection()` 槽。对于最后一个连接，我们响应套接字的 `readyRead()` 信号，这表示有新数据可用。在这种情况下，我们的
    `newMessage()` 槽将被调用。最后，我们打印一条系统消息，表明已建立新的连接。连接客户端和对方的地址和端口号可以通过套接字的 `peerAddress()`
    和 `peerPort()` 函数获取。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If a new connection can't be accepted, the `acceptError()` signal is emitted
    instead of `newConnection()`. It passes the reason for the failure of the `QAbstractSocket::SocketError`
    type as an argument. If you want to temporarily decline new connections, call
    `pauseAccepting()` on `QTcpServer`. To resume accepting new connections, call
    `resumeAccepting()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法接受新的连接，将发出 `acceptError()` 信号而不是 `newConnection()`。它将 `QAbstractSocket::SocketError`
    类型的失败原因作为参数传递。如果您想暂时拒绝新的连接，请在 `QTcpServer` 上调用 `pauseAccepting()`。要恢复接受新的连接，请调用
    `resumeAccepting()`。
- en: Time for action – forwarding a new message
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 转发新消息
- en: When a connected client sends a new chat message, the underlying socket—since
    it inherits `QIODevice`—emits `readyRead()`, and thus, our `newMessage()` slot
    will be called.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接的客户端发送新的聊天消息时，由于它继承自 `QIODevice`，底层的套接字会发出 `readyRead()` 信号，因此我们的 `newMessage()`
    槽将被调用。
- en: Before we have a look at this slot, there is something important that you need
    to keep in mind. Even though TCP is ordered and without any duplicates, this does
    not mean that all the data is delivered in one big chunk. So, before processing
    the received data, we need to make sure that we get the entire message. Unfortunately,
    there is neither an easy way to detect whether all data was transmitted nor a
    globally usable method for such a task. Therefore, it is up to you to solve this
    problem, as it depends on the use case. Two common solutions, however, are to
    either send magic tokens to indicate the start and the end of a message, for example,
    single characters or XML tags, or you can send the size of the message upfront.
    The second solution is shown in the Qt documentation where the length is put in
    a `quint16` in front of the message. We, on the other hand, will look at an approach
    that uses a simple magic token to handle the messages correctly. As a delimiter,
    we use the "End of Transmission Block" character–ASCII code 23–to indicate the
    end of a message.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这个槽之前，有一些重要的事情需要你记住。尽管 TCP 是有序的且没有重复，但这并不意味着所有数据都作为一个大块传输。因此，在处理接收到的数据之前，我们需要确保我们得到了整个消息。不幸的是，没有简单的方法来检测是否所有数据都已传输，也没有一个通用的方法来完成这项任务。因此，这个问题取决于你的用例。然而，两种常见的解决方案是发送魔法令牌来指示消息的开始和结束，例如单个字符或
    XML 标签，或者你可以提前发送消息的大小。第二种解决方案在 Qt 文档中显示，其中消息长度放在消息前面的 `quint16` 中。另一方面，我们将探讨一种使用简单魔法令牌正确处理消息的方法。作为分隔符，我们使用“传输结束块”字符——ASCII
    码 23——来指示消息的结束。
- en: 'Since the processing of received data is quite complex, we will go through
    the code step by step this time:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收数据的处理相当复杂，我们这次将逐步解释代码：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To determine which socket called the slot, we use `sender()`. If the cast to
    `QTcpSocket` is successful, we enter the `if` scope and read the transferred—potentially
    fragmentary—message with `readAll()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定哪个套接字调用了槽，我们使用 `sender()`。如果将 `QTcpSocket` 强制转换为成功，我们进入 `if` 范围，并使用 `readAll()`
    读取传输的——可能是片段化的——消息。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that `sender()` is used for simplicity. If you write real-life code,
    it is better to use `QSignalMapper`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sender()` 用于简化。如果你编写实际的代码，最好使用 `QSignalMapper`。
- en: 'The `read` data is then concatenated with the previously received data that
    is stored in the `QHash` private member called `m_receivedData`, where the socket
    is used as a key:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`read` 数据将与存储在名为 `m_receivedData` 的 `QHash` 私有成员中的先前接收到的数据连接起来，其中套接字用作键：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here we check whether the received data contains our special token, the "End
    of Transmission Block". Otherwise, we exit and wait for the further data to arrive,
    which then gets appended to the string. As soon as we have at least one special
    token, we proceed by splitting the data into single messages:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查接收到的数据是否包含我们的特殊令牌，“传输结束块”。否则，我们退出并等待更多数据的到来，这些数据随后被附加到字符串上。一旦我们至少有一个特殊令牌，我们就通过分割数据为单个消息来继续操作：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The received data contains exactly one single message for which the "End of
    Transmission Block" token is the last character, and thus, the messages list has
    two elements: the first one with the actual message and the last one without any
    content. This way, `m_receivedData[con]` is reset. What if `QChar(23)` is not
    the last character of the received text? Then, the last element is the beginning
    of the next, which is not yet complete, message. So, we store that message in
    `m_receivedData[con]`. This guarantees that no data will be lost:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的数据恰好包含一条消息，其中“传输结束块”令牌是最后一个字符，因此消息列表有两个元素：第一个是实际的消息，最后一个是没有内容的。这样，`m_receivedData[con]`
    就被重置了。如果 `QChar(23)` 不是接收文本的最后一个字符怎么办？那么，最后一个元素是下一个尚未完成的，消息的开始。因此，我们将该消息存储在 `m_receivedData[con]`
    中。这保证了不会丢失任何数据：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Since we do not know how many messages we will get with the last read from
    the socket, we need to go through the list of messages. For every message, we
    display a short notice on the server''s log and then send it to the other clients:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道从套接字最后读取将得到多少消息，我们需要遍历消息列表。对于每条消息，我们在服务器的日志上显示一条简短的通知，然后将其发送给其他客户端：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Before sending the message, we append `QChar(23)` to indicate the end of the
    message, of course, and then send it to all the connected clients, except the
    one who sent it in the first place, by simply calling write on the socket. Since
    the socket inherits `QIODevice`, you can use most of the functions that you know
    from `QFile`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送消息之前，我们添加 `QChar(23)` 来表示消息的结束，当然，然后通过在套接字上调用 write 简单地将它发送到所有已连接的客户端，除了最初发送它的那个客户端。由于套接字继承了
    `QIODevice`，你可以使用从 `QFile` 知道的多数函数。
- en: Have a go hero – using QSignalMapper
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——使用 QSignalMapper
- en: As discussed earlier, using `sender()` is a convenient, but not an object-orientated,
    approach. Thus, try to use `QSignalMapper` instead to determine which socket called
    the slot. To achieve this, you have to connect the socket's `readyRead()` signal
    to a mapper and the slot directly. All the signal-mapper-related code will go
    into the `newConnection()` slot.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 `sender()` 是一种方便的方法，但不是面向对象的方法。因此，尝试使用 `QSignalMapper` 来确定哪个套接字调用了槽。为了实现这一点，你必须将套接字的
    `readyRead()` 信号连接到一个映射器，并将槽直接连接。所有与信号-映射器相关的代码都将放入 `newConnection()` 槽中。
- en: The same applies to the connection to the `removeConnection()` slot. Let's have
    a look at it next.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于连接到 `removeConnection()` 槽。让我们接下来看看它。
- en: Time for action – detecting a disconnect
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——检测断开连接
- en: 'When a client terminates the connection, we have to delete the socket from
    the local `m_clients` list. Therefore, we have to connected the socket''s `disconnected()`
    signal to:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端终止连接时，我们必须从本地的 `m_clients` 列表中删除套接字。因此，我们必须将套接字的 `disconnected()` 信号连接到：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*What just happened?*'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: After getting the socket that emitted the call through `sender()`, we post the
    information that a socket is being removed. Then, we remove the socket from `m_clients`
    and call `deleteLater()` on it. Do not use delete. Lastly, if no client is left,
    the disconnect button is disabled.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 `sender()` 获取发出调用的套接字后，我们发布一个信息，表明套接字正在被移除。然后，我们将套接字从 `m_clients` 中移除，并在其上调用
    `deleteLater()`。不要使用 delete。最后，如果没有客户端剩下，断开连接按钮将被禁用。
- en: This is the first part. Now let's have a look at the client.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一部分。现在让我们看看客户端。
- en: The client
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: The graphical user interface of the client (`TcpClient`) is pretty simple. It
    has three input fields to define the server's address (`ui->address`), the server's
    port (`ui->port`), and a username (`ui->user`). Of course, there is also a button
    to connect to (`ui->connect`) and disconnect from (`ui->disconnect`) the server.
    Finally, the GUI has a text edit that holds the received messages (`ui->chat`)
    and a line edit (`ui->text`) to send messages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的图形用户界面 (`TcpClient`) 非常简单。它有三个输入字段来定义服务器的地址 (`ui->address`)、服务器的端口 (`ui->port`)
    和一个用户名 (`ui->user`)。当然，还有一个按钮来连接到 (`ui->connect`) 和从服务器断开连接 (`ui->disconnect`)。最后，GUI
    有一个文本编辑器来保存接收到的消息 (`ui->chat`) 和一个行编辑器 (`ui->text`) 来发送消息。
- en: Time for action – setting up the client
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——设置客户端
- en: 'When the user has provided the server''s address and port and has chosen a
    username, he/she can connect to the server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提供了服务器的地址和端口，并选择了一个用户名后，他/她可以连接到服务器：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*What just happened?*'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The private member variable `m_socket` holds an instance of `QTcpSocket`. If
    this socket is already connected, nothing happens. Otherwise, the socket is connected
    to the given address and port by calling `connectToHost()`. Besides the obligatory
    server address and port number, you can pass a third argument to define the mode
    in which the socket will be opened. For possible values, you can use `OpenMode`
    just like we did for `QIODevice`. Since this call is asynchronous, we print a
    notification to the chat, so that the user is informed that the application is
    currently trying to connect to the server. When the connection is established,
    the socket sends the `connected()` signal that prints "Connected to server" on
    the chat to indicate that we have connected to a slot. Besides the messages in
    the chat, we also updated the GUI by, for example, disabling the connect button,
    but this is all basic stuff. You won't have any trouble understanding this if
    you have had a look at the sources. So, these details are left out here.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 私有成员变量 `m_socket` 持有 `QTcpSocket` 的一个实例。如果此套接字已经连接，则不会发生任何事情。否则，通过调用 `connectToHost()`
    将套接字连接到给定的地址和端口。除了必需的服务器地址和端口号之外，您还可以传递第三个参数来定义套接字将打开的模式。对于可能的值，您可以使用 `OpenMode`，就像我们为
    `QIODevice` 所做的那样。由于此调用是异步的，我们在聊天中打印一条通知，以便用户得知应用程序目前正在尝试连接到服务器。当连接建立时，套接字发送 `connected()`
    信号，在聊天中打印 "Connected to server"，以指示我们已经连接到槽。除了聊天中的消息外，我们还通过例如禁用连接按钮等方式更新了 GUI，但这都是基本操作。如果您已经查看过源代码，那么您不会对此有任何困难。因此，这些细节在这里被省略了。
- en: Of course, something could go wrong when trying to connect to a server, but
    luckily, we are informed about a failure as well through the `error()` signal
    passing a description of error in the form of `QAbstractSocket::SocketError`.
    The most frequent errors will probably be `QAbstractSocket::ConnectionRefusedError`
    if the peer refused the connection or `QAbstractSocket::HostNotFoundError` if
    the host address could not be found. If the connection, however, was successfully
    established, it should be closed later on. You can either call `abort()` to immediately
    close the socket, whereas `disconnectFromHost()` will wait until all pending data
    has been written.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在尝试连接到服务器时可能会出错，但幸运的是，我们也可以通过 `error()` 信号得知失败，该信号通过 `QAbstractSocket::SocketError`
    形式传递错误描述。最频繁的错误可能是 `QAbstractSocket::ConnectionRefusedError`，如果对端拒绝连接，或者 `QAbstractSocket::HostNotFoundError`，如果找不到主机地址。然而，如果连接成功建立，则稍后应该关闭它。您可以调用
    `abort()` 立即关闭套接字，而 `disconnectFromHost()` 将等待所有挂起数据被写入。
- en: Time for action – receiving text messages
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 接收短信
- en: 'In the constructor, we have connected the socket''s `readyRead()` signal to
    a local slot. So, whenever the server sends a message through `QTcpSocket::write()`,
    we read the data and display it in the chat window:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将套接字的 `readyRead()` 信号连接到了一个本地槽。因此，每当服务器通过 `QTcpSocket::write()` 发送消息时，我们读取数据并在聊天窗口中显示它：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you already know, `QTcpSocket` inherits `QIODevice`, so we use `QIODevice::readAll()`
    to get the entire text that was sent. Next, we store the received data and determine
    whether the message was transmitted completely. This approach is the same as we
    used previously for the server. Lastly, in the `for` loop, we add the messages
    to the chat window.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，`QTcpSocket` 继承了 `QIODevice`，因此我们使用 `QIODevice::readAll()` 来获取发送的整个文本。接下来，我们存储接收到的数据并确定消息是否已完全传输。这种方法与我们之前用于服务器的方法相同。最后，在
    `for` 循环中，我们将消息添加到聊天窗口中。
- en: Time for action – sending text messages
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 发送短信
- en: 'What is left is now is to describe how to send a chat massage. On hitting return
    inside the line edit, a local slot will be called that checks whether there is
    actual text to send and whether `m_socket` is still connected:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是描述如何发送聊天消息。在行编辑中按回车键时，将调用一个本地槽，该槽检查是否有实际要发送的文本以及 `m_socket` 是否仍然连接：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If so, a message is composed that contains the self-given username, a colon,
    and the text of the line edit. To send this string to the peer, the `QTcpSocket::write()`
    server is called. Since `write()` only accepts const `char*` or `QByteArray`,
    we use `QString::toLocal8Bit()` to get `QByteArray` that we can send over the
    socket.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，将组成一条包含自给用户名、冒号和行编辑文本的消息。要将此字符串发送到对等方，需要调用 `QTcpSocket::write()` 服务器。由于
    `write()` 只接受 `const char*` 或 `QByteArray`，我们使用 `QString::toLocal8Bit()` 来获取可以发送到套接字的
    `QByteArray`。
- en: That's all. It's like writing and reading from a file. For the complete example,
    have a look at the sources bundled with this book and run the server and several
    clients.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。这就像是从文件中写入和读取一样。对于完整的示例，请查看本书附带源代码，并运行服务器和几个客户端。
- en: Have a go hero – extending the chat with a user list
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试扩展聊天功能，添加用户列表
- en: This example has shown us how to send a simple text. If you now go on and define
    a schema for how the communication should work, you can use it as a base for more
    complex communication. For instance, if you want to enable the client to receive
    a list of all other clients (and their usernames), you need to define that the
    server will return such a list if it gets a message such as `rq:allClients` from
    a client. Therefore, you have to parse all messages received by the server before
    forwarding them to all the connected clients. Go ahead and try to implement such
    a requirement yourself. By now, it is possible that multiple users have chosen
    the same username. With the new functionality of getting a user list, you can
    prevent this from happening. Therefore, you have to send the username to the server
    that keeps track of them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了如何发送简单的文本。如果你现在继续定义一个通信应该如何工作的模式，你可以将其作为更复杂通信的基础。例如，如果你想使客户端能够接收所有其他客户端（及其用户名）的列表，你需要定义服务器在接收到来自客户端的类似
    `rq:allClients` 的消息时将返回这样一个列表。因此，你必须在将消息转发给所有已连接的客户端之前解析服务器接收到的所有消息。现在就尝试自己实现这样的要求。到目前为止，可能有多位用户选择了相同的用户名。通过获取用户列表的新功能，你可以防止这种情况发生。因此，你必须将用户名发送到跟踪它们的服务器。
- en: Improvements
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进
- en: The example we explained uses a nonblocking, asynchronous approach. For example,
    after asynchronous calls such as `connectToHost()`, we do not block the thread
    until we get a result, but instead, we connect to the socket's signals to proceed.
    On the Internet as well as Qt's documentation, on the other hand, you will find
    dozens of examples explaining the blocking and the synchronous approaches. You
    will easily spot them by their use of `waitFor...()` functions. These functions
    block the current thread until a function such as `connectToHost()` has a result—the
    time `connected()` or `error()` will be emitted. The corresponding blocking function
    to `connectToHost()` is `waitForConnected()`. The other blocking functions that
    can be used are `waitForReadyRead()`, which waits until new data is available
    on a socket for reading; `waitForBytesWritten()`, which waits until the data has
    been written to the socket; and `waitForDisconnected()`, which waits until the
    connection has been closed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所解释的示例使用的是非阻塞、异步方法。例如，在异步调用如 `connectToHost()` 之后，我们不会阻塞线程直到我们得到结果，而是连接到套接字的信号以继续。另一方面，在互联网以及
    Qt 的文档中，你会找到许多解释阻塞和同步方法的示例。你将很容易通过它们使用 `waitFor...()` 函数来识别。这些函数会阻塞当前线程，直到 `connectToHost()`
    等函数有结果——即 `connected()` 或 `error()` 信号被发射。`connectToHost()` 的对应阻塞函数是 `waitForConnected()`。其他可以使用的阻塞函数包括
    `waitForReadyRead()`，它等待直到套接字上有新数据可供读取；`waitForBytesWritten()`，它等待直到数据已写入套接字；以及
    `waitForDisconnected()`，它等待直到连接被关闭。
- en: Look out; even if Qt offers these `waitFor...()` functions, do not use them!
    The synchronous approach is not the smartest one since it will freeze your game's
    GUI. A frozen GUI is the worst thing that can happen in your game and it will
    annoy every user. So, when working inside the GUI thread, you are better to react
    to the `QIODevice::readyRead()`, `QIODevice::bytesWritten()`, `QAbstractSocket::connected()`,
    and `QAbstractSocket::disconnected()` corresponding signals.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意；即使 Qt 提供了这些 `waitFor...()` 函数，也不要使用它们！同步方法并不是最聪明的选择，因为它会冻结你的游戏 GUI。冻结的 GUI
    是游戏中可能发生的最糟糕的事情，并且会令每个用户感到烦恼。所以，当在 GUI 线程内工作时，你最好是对应地响应 `QIODevice::readyRead()`、`QIODevice::bytesWritten()`、`QAbstractSocket::connected()`
    和 `QAbstractSocket::disconnected()` 信号。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`QAbstractSocket` is the base class of `QTcpSocket` as well as of `QUdpSocket`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAbstractSocket` 是 `QTcpSocket` 以及 `QUdpSocket` 的基类。'
- en: Following the asynchronous approach shown, the application will only become
    unresponsive while both reading and writing to the socket as well as during determining
    whether a message is complete. The optimum, however, would be to move the entire
    socket handling to an extra thread. Then, the GUI thread would only get signals,
    passing the new messages, and to send, it would simply pass `QString` to the worker
    thread. This way, you will get a super fluent velvet GUI.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按照异步方法进行，应用程序只有在同时读取和写入套接字以及确定消息是否完整时才会变得无响应。然而，最佳做法是将整个套接字处理移动到额外的线程。这样，GUI线程只会接收信号，传递新消息，发送时只需将`QString`传递给工作线程。这样，你将得到一个超级流畅的绒毛GUI。
- en: Using UDP
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UDP
- en: 'In contrast to TCP, UDP is unreliable and connectionless. Neither the order
    of packets, nor their delivery is guaranteed. UDP, however, is very fast. So,
    if you have frequent data, which does not necessarily need to be received by the
    peer, use UDP. This data could, for example, be real-time positions of a player
    that get updated frequently or live video/audio streaming. Since `QUdpSocket`
    is mostly the same as `QTcpSocket`—both inherit `QAbstractSocket`—there is not
    much to explain. The main difference between them is that TCP is stream-orientated,
    whereas UDP is datagram-orientated. This means that the data is sent in small
    packages, containing among the actual content, the sender''s as well as the receiver''s
    IP address and port number. Due to the lack of `QUdpServer`, you have to use `QAbstractSocket::bind()`
    instead of `QTcpServer::listen()`. Like `listen()`, `bind()` takes the addresses
    and ports that are allowed to send datagrams as arguments. Whenever a new package
    arrives, the `QIODevice::readyRead()` signal is emitted. To read the data, use
    the `readDatagram()` function, which takes four parameters. The first one of the
    `char*` type is used to write the data in, the second specifies the amount of
    bytes to be written, and the last two parameters of the `QHostAddress*` and `quint16*`
    types are used to store the sender''s IP address and port number. Sending data
    works likewise: `writeDatagram()` sends the first argument''s data of the `char*`
    type to the host, which is defined by the third (address) and fourth (port number)
    argument. With the second parameter, you can limit the amount of data to be sent.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP相比，UDP是不可靠的，无连接的。既不能保证数据包的顺序，也不能保证它们的交付。然而，UDP非常快。所以，如果你有频繁的数据，这些数据不一定需要被对端接收，可以使用UDP。这些数据可以是玩家实时位置，这些位置会频繁更新，或者实时视频/音频流。由于缺少`QUdpSocket`，你必须使用`QAbstractSocket::bind()`而不是`QTcpServer::listen()`。与`listen()`类似，`bind()`接受允许发送数据报的地址和端口作为参数。每当一个新的数据包到达时，`QIODevice::readyRead()`信号就会被发射。要读取数据，请使用`readDatagram()`函数，它接受四个参数。第一个参数是`char*`类型，用于写入数据，第二个参数指定要写入的字节数，最后两个参数是`QHostAddress*`和`quint16*`类型，用于存储发送者的IP地址和端口号。由于缺少`QUdpServer`，你必须使用`QAbstractSocket::bind()`而不是`QTcpServer::listen()`。与`listen()`类似，`bind()`接受允许发送数据报的地址和端口作为参数。每当一个新的数据包到达时，`QIODevice::readyRead()`信号就会被发射。要读取数据，请使用`readDatagram()`函数，它接受四个参数。第一个参数是`char*`类型，用于写入数据，第二个参数指定要写入的字节数，最后两个参数是`QHostAddress*`和`quint16*`类型，用于存储发送者的IP地址和端口号。发送数据的工作方式类似：`writeDatagram()`将第一个参数的`char*`类型数据发送到由第三个（地址）和第四个（端口号）参数定义的主机。通过第二个参数，你可以限制要发送的数据量。
- en: Time for action – sending a text via UDP
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 通过UDP发送文本
- en: 'As an example, let''s assume that we have two sockets of the `QUpSocket` type.
    We will call the first one `socketA` and the other `socketB`. Both are bound to
    the localhost, `socketA` to the `52000` port and `socketB` to the `52001` port.
    So, if we want to send the string "Hello!" from `socketA` to `socketB`, we have
    to write in the application that is holding `socketA`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个`QUpSocket`类型的套接字。我们将第一个称为`socketA`，另一个称为`socketB`。它们都绑定到本地主机，`socketA`绑定到`52000`端口，而`socketB`绑定到`52001`端口。因此，如果我们想从`socketA`向`socketB`发送字符串"Hello!"，我们必须在持有`socketA`的应用程序中编写：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, we have used the convenient function of `writeDatagram()`, which takes
    `QByteArray` instead of const `char*` and `qint64`. The class that holds `socketB`
    must have the socket''s `readyRead()` signal connected to a slot. This slot will
    then be called because of our `writeDatagram()` call, assuming that the datagram
    is not lost! In the slots, we read the datagram and the sender''s address and
    port number with:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`writeDatagram()`函数的便利功能，它接受`QByteArray`而不是`const char*`和`qint64`。持有`socketB`的类必须将套接字的`readyRead()`信号连接到一个槽。然后，由于我们的`writeDatagram()`调用，该槽将被调用，假设数据报没有丢失！在槽中，我们使用以下方式读取数据报和发送者的地址和端口号：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As long as there are pending datagrams—this is checked by `hasPendingDatagrams()`,
    which returns `true` as long as there are pending datagrams—we read them. This
    is done by creating `QByteArray`, which is used to store the transferred datagram.
    To be able to hold the entire transmitted data, it is resized to the length of
    the pending datagram. This information is retrieved by `pendingDatagramSize()`.
    Next we create `QHostAddress` and `quint16` so that `readDatagram()` can store
    the sender's address and port number in these variables. Now, all is set up to
    call `readDatagram()` so that we get the datagram.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 只要还有挂起的报文 - 这通过 `hasPendingDatagrams()` 检查，只要还有挂起的报文就返回 `true` - 我们就读取它们。这是通过创建
    `QByteArray` 来完成的，它用于存储传输的报文。为了能够容纳整个传输数据，它的大小被调整到挂起的报文长度。这个信息是通过 `pendingDatagramSize()`
    获取的。接下来，我们创建 `QHostAddress` 和 `quint16`，这样 `readDatagram()` 就可以将发送者的地址和端口号存储在这些变量中。现在，所有设置都已就绪，可以调用
    `readDatagram()` 来获取报文。
- en: Have a go hero – connecting players of the Benjamin game
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 连接本杰明游戏的玩家
- en: With this introductory knowledge, you can go ahead and try some stuff by yourself.
    For example, you can take the game Benjamin the elephant and send Benjamin's current
    position from one client to another. This way, you can either clone the screen
    from one client to the other or both clients can play the game and additionally
    can see where the elephant of the other player currently is. For such a task,
    you would use UDP, as it is important that the position is updated very fast while
    it isn't a disaster when one position gets lost.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些基础知识之后，你可以尝试自己做一些事情。例如，你可以玩本杰明大象游戏，并将本杰明的当前位置从一个客户端发送到另一个客户端。这样，你既可以克隆一个客户端的屏幕到另一个客户端，或者两个客户端都可以玩游戏，并且还可以看到其他玩家的大象当前的位置。对于这样的任务，你会使用UDP，因为位置需要非常快地更新，而丢失一个位置并不是灾难性的。
- en: Pop quiz – test your knowledge
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验 - 测试你的知识
- en: Q1\. Which three (main) classes do you need to download a file?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 你需要哪三个（主要）类来下载文件？
- en: Q2\. How can you download only the first 100 bytes of a file?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 你如何只下载文件的前100个字节？
- en: Q3\. If you need to extend a URL by parameters with special characters, you
    need to escape them with `QUrl::toPercentEncoding()`. Which other, more convenient,
    option does Qt offer?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 如果你需要通过参数扩展URL并包含特殊字符，你需要使用 `QUrl::toPercentEncoding()` 来转义它们。Qt还提供了哪些其他更方便的选项？
- en: Q4\. How do you delete `QNetworkReply` received from `QNetworkAccessManager`?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 你如何删除从 `QNetworkAccessManager` 接收到的 `QNetworkReply`？
- en: Q5\. What is the type hierarchy of `QTcpSocket` and `QUdpSocket` and what's
    the big advantage of this hierarchy?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Q5. `QTcpSocket` 和 `QUdpSocket` 的类型层次结构是什么？这个层次结构有什么重大优势？
- en: Q6\. The `readDatagram()` function belongs to `QTcpSocket` or `QUdpSocket`?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Q6. `readDatagram()` 函数属于 `QTcpSocket` 还是 `QUdpSocket`？
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the first part of this chapter, you familiarized yourself with `QNetworkAccessManager`.
    This class is at the heart of your code whenever you want to download or upload
    files to the Internet. After having gone through the different signals that you
    can use to fetch errors, to get notified about new data or to show the progress,
    you should now know everything you need on that topic.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你熟悉了 `QNetworkAccessManager`。每当你要在互联网上下载或上传文件时，这个类就是你的代码的核心。在了解了你可以用来获取错误、接收新数据通知或显示进度的不同信号之后，你现在应该知道你需要了解的所有关于这个主题的内容。
- en: The example about the Distance Matrix API depended your knowledge of `QNetworkAccessManager`,
    and it shows you a real-life application case for it. Dealing with JSON as the
    server's reply format was a recapitulation of [Chapter 4](ch04.html "Chapter 4. Qt
    Core Essentials"), *Qt Core Essentials*, but was highly needed since Facebook
    or Twitter only use JSON to format their network replies.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 关于距离矩阵API的例子依赖于你对 `QNetworkAccessManager` 的了解，并且展示了它的实际应用案例。处理作为服务器响应格式的JSON是一个对[第4章](ch04.html
    "第4章。Qt核心基础")，*Qt核心基础*的回顾，但这是高度必要的，因为Facebook或Twitter只使用JSON来格式化它们的网络响应。
- en: In the last section, you learned how to set up your own TCP server and clients.
    This enables you to connect different instances of a game to provide the multiplayer
    functionality. Alternatively, you were taught how to use UDP.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，你学习了如何设置自己的TCP服务器和客户端。这使你能够连接不同实例的游戏以提供多人游戏功能。或者，你被教导如何使用UDP。
- en: Please keep in mind that we only scratched the surface of this topic due to
    its complexity. Covering it fully would have exceeded this beginner's guide. For
    a real game, which uses a network, you should learn more about Qt's possibilities
    for establishing a secure connection via SSL or some other mechanism.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于这个主题的复杂性，我们只是触及了表面。全面覆盖它将超出这本入门指南的范围。对于真正使用网络的实时游戏，你应该了解 Qt 通过 SSL 或其他机制建立安全连接的可能性。
- en: In the next chapter, you'll learn how to extend your game with a scripting engine.
    This allows you to, for example, easily change various aspects of your game without
    the need for recompiling it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用脚本引擎扩展你的游戏。这允许你，例如，轻松更改游戏的各种方面，而无需重新编译它。
