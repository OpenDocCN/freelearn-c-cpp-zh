<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Exploring Movement and Input Handling</h1></div></div></div><p>We have already covered drawing to the screen and how to handle objects but we have not had anything moving around very much yet. Getting input from the user and then controlling our game objects is one of the most important topics in game development. It can decide the feel and responsiveness of your game and is something that a user can really pick up on. In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cartesian coordinate systems</li><li class="listitem" style="list-style-type: disc">2D vectors</li><li class="listitem" style="list-style-type: disc">Creating variables to control the movement of a game object</li><li class="listitem" style="list-style-type: disc">Setting up a simple movement system</li><li class="listitem" style="list-style-type: disc">Setting up input handling from joysticks, keyboard, and mouse</li><li class="listitem" style="list-style-type: disc">Creating a fixed frame rate</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Setting up game objects for movement</h1></div></div></div><p>In the previous chapter, <a class="indexterm" id="id188"/>we gave our objects x and y values which we could then use to pass into our drawing code. The x and y values we used can be represented using a Cartesian coordinate system.</p><div><img alt="Setting up game objects for movement" src="img/6821OT_04_01.jpg"/></div><p>The above figure shows a <a class="indexterm" id="id189"/>Cartesian coordinate system (flipped on the Y axis) with two coordinates. Representing them as (x,y) gives us position 1 as (3,3) and position 2 as (7,4). These values can be used to represent a position in 2D space. Imagine this figure as a zoomed in image of the top-left corner of our game window, with each of the grid squares representing one pixel of our game window. With this in mind, we can see how to use these values to draw things to the screen in the correct position. We now need a way to update these position values so that we can move our objects around. For this we will look at 2D vectors.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>What is a vector?</h2></div></div></div><p>A <strong>vector</strong> can be<a class="indexterm" id="id190"/> described as an entity with a direction and a magnitude. We can use them<a class="indexterm" id="id191"/> to represent aspects of our game objects, for example, velocity and acceleration, that can be used to create movement. Taking velocity as an example,<a class="indexterm" id="id192"/> to fully represent<a class="indexterm" id="id193"/> the velocity of our objects, we need the direction in which they are travelling and also the amount (or magnitude) by which they are heading in that direction.</p><div><img alt="What is a vector?" src="img/6821OT_04_02.jpg"/></div><p>Let's define a couple of things about how we <a class="indexterm" id="id194"/>will use vectors:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will represent a vector as v(x,y)<p>We can get the length of a vector using the following equation:</p><div><img alt="What is a vector?" src="img/6821OT_04_03.jpg"/></div></li></ul></div><p>The preceding figure shows the vector v1(3,-2) which will have a length of √(32+(-22)). We can use the x and y components of a vector to represent our object's position in 2D space. We can then use some common vector operations to move our objects. Before we move onto these operations let's create a vector class called <code class="literal">Vector2D</code> in the project. We can then look at each operation we will need and add them to the class.</p><div><pre class="programlisting">#include&lt;math.h&gt;
class Vector2D
{
public:
  Vector2D(float x, float y): m_x(x), m_y(y) {}

  float getX() { return m_x; }
  float getY() { return m_y; }

  void setX(float x) { m_x = x; }
  void setY(float y) { m_y = y; }
private:

  float m_x;
  float m_y;
};</pre></div><p>You can see that the <code class="literal">Vector2D</code> class is very simple at this point. We have our x and y values and a <a class="indexterm" id="id195"/>way to get and set them. We already know how to get the length of a vector, so let's create a function for this purpose:</p><div><pre class="programlisting">float length() { return sqrt(m_x * m_x + m_y * m_y); }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Some common operations</h2></div></div></div><p>Now since we have our basic class in place, we can start to gradually add some operations.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Addition of two vectors</h3></div></div></div><p>The first<a class="indexterm" id="id196"/> operation we will look at is the addition of two vectors. For this we simply add together the individual components of each vector.</p><div><img alt="Addition of two vectors" src="img/6821OT_04_04.jpg"/></div><p>Let's make use of overloaded operators to make it easy for us to add two vectors together:</p><div><pre class="programlisting">Vector2D operator+(const Vector2D&amp; v2) const
{
  return Vector2D(m_x + v2.m_x, m_y + v2.m_y);
}

friend Vector2D&amp; operator+=(Vector2D&amp; v1, const Vector2D&amp; v2)
{
  v1.m_x += v2.m_x;
  v1.m_y += v2.m_y;

  return v1;
}</pre></div><p>With these <a class="indexterm" id="id197"/>functions we can add two vectors together using the standard addition operators, for example:</p><div><pre class="programlisting">Vector2D v1(10, 11);
Vector2D v2(35,25);
v1 += v2;
Vector2D v3 = v1 + v2;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Multiply by a scalar number</h3></div></div></div><p>Another operation <a class="indexterm" id="id198"/>is to multiply a vector by a regular scalar number. For this operation we multiply each component of the vector by the scalar number:</p><div><img alt="Multiply by a scalar number" src="img/6821OT_04_05.jpg"/></div><p>We can again use overloaded operators to create these functions:</p><div><pre class="programlisting">Vector2D operator*(float scalar)
{
  return Vector2D(m_x * scalar, m_y * scalar);
}

Vector2D&amp; operator*=(float scalar)
{
  m_x *= scalar;
  m_y *= scalar;

  return *this;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Subtraction of two vectors</h3></div></div></div><p>Subtraction is <a class="indexterm" id="id199"/>very similar to addition.</p><div><img alt="Subtraction of two vectors" src="img/6821OT_04_06.jpg"/></div><p>Let's create some functions to do this for us:</p><div><pre class="programlisting">Vector2D operator-(const Vector2D&amp; v2) const
{ 
  return Vector2D(m_x - v2.m_x, m_y - v2.m_y); 
}

friend Vector2D&amp; operator-=(Vector2D&amp; v1, const Vector2D&amp; v2)
{
  v1.m_x -= v2.m_x;
  v1.m_y -= v2.m_y;

  return v1;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Divide by a scalar number</h3></div></div></div><p>By now I am <a class="indexterm" id="id200"/>sure you have noticed a pattern emerging and can guess how dividing a vector by a scalar will work, but we will cover it anyway.</p><div><img alt="Divide by a scalar number" src="img/6821OT_04_07.jpg"/></div><p>And our functions:</p><div><pre class="programlisting">Vector2D operator/(float scalar)    
{
  return Vector2D(m_x / scalar, m_y / scalar);
}

Vector2D&amp; operator/=(float scalar)
{
  m_x /= scalar;
  m_y /= scalar;

  return *this;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Normalizing a vector</h3></div></div></div><p>We need another<a class="indexterm" id="id201"/> very important operation and that is the ability to normalize a vector. Normalizing a vector makes its length equal to 1. Vectors with a length (magnitude) of 1 are known as unit vectors and are useful to represent just a direction, such as the facing direction of an object. To normalize a vector we multiply it by the inverse of its length.</p><div><img alt="Normalizing a vector" src="img/6821OT_04_08.jpg"/></div><p>We can create a new member function to normalize our vectors:</p><div><pre class="programlisting">void normalize()
{
  float l = length();
  if ( l &gt; 0) // we never want to attempt to divide by 0
  {
    (*this) *= 1 / l;
  }
}
</pre></div><p>Now that we have a few basic functions in place, let's start to use these vectors in our <code class="literal">SDLGameObject</code> class.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Adding the Vector2D class</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open<a class="indexterm" id="id202"/> up <code class="literal">SDLGameObject.h</code> and we can begin implementing the vectors. First we need to include the new <code class="literal">Vector2D</code> class.<div><pre class="programlisting">#include "Vector2D.h"</pre></div></li><li class="listitem">We also need to remove the previous <code class="literal">m_x</code> and <code class="literal">m_y</code> values and replace them with <code class="literal">Vector2D</code>.<div><pre class="programlisting">Vector2D m_position;</pre></div></li><li class="listitem">Now we can move to the <code class="literal">SDLGameObject.cpp</code> file and update the constructor.<div><pre class="programlisting">SDLGameObject::SDLGameObject(const LoaderParams* pParams) : GameObject(pParams), m_position(pParams-&gt;getX(), pParams-&gt;getY())
{
  m_width = pParams-&gt;getWidth();
  m_height = pParams-&gt;getHeight();
  m_textureID = pParams-&gt;getTextureID();

  m_currentRow = 1;
  m_currentFrame = 1;
}</pre></div></li><li class="listitem">We <a class="indexterm" id="id203"/>now construct the <code class="literal">m_position</code> vector using the member initialization list and we must also use the <code class="literal">m_position</code> vector in our draw function.<div><pre class="programlisting">void SDLGameObject::draw()
{
  TextureManager::Instance()-&gt;drawFrame(m_textureID, 
  (int)m_position.getX(), (int)m_position.getY(), m_width, 
  m_height, m_currentRow, m_currentFrame, 
  TheGame::Instance()-&gt;getRenderer());
}</pre></div></li><li class="listitem">One last thing before we test is to use our vector in the <code class="literal">Enemy::update</code> function.<div><pre class="programlisting">void Enemy::update()
{
  m_position.setX(m_position.getX() + 1);
  m_position.setY(m_position.getY() + 1);
}</pre></div></li></ol></div><p>This function will use vector addition very soon, but for now we just add <code class="literal">1</code> to the current position to get the same behavior we already had. We can now run the game and we will see that we have implemented a very basic vector system. Go ahead and play around with the <code class="literal">Vector2D</code> functions.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Adding velocity</h2></div></div></div><p>We previously had to <a class="indexterm" id="id204"/>separately set the <code class="literal">x</code> and <code class="literal">y</code> values of our objects, but now that our position is a vector, we have the ability to add a new vector to it to update our movement. We will call this vector the velocity vector and we can think of it as the amount we want our object to move in a specific direction:</p><div><ol class="orderedlist arabic"><li class="listitem">The velocity vector can be represented as follows:<div><img alt="Adding velocity" src="img/6821OT_04_09.jpg"/></div></li><li class="listitem">We can add this to our <code class="literal">SDLGameObject</code> update function as this is the way we update all derived objects. So first let's create the velocity member variable.<div><pre class="programlisting">Vector2D m_velocity;</pre></div></li><li class="listitem">We will construct it in the member initialization list as 0,0.<div><pre class="programlisting">SDLGameObject::SDLGameObject(const LoaderParams* pParams) : GameObject(pParams), m_position(pParams-&gt;getX(), pParams-&gt;getY()), m_velocity(0,0)</pre></div></li><li class="listitem">And now we will move to the <code class="literal">SDLGameObject::update</code> function.<div><pre class="programlisting">void SDLGameObject::update()
{
  m_position += m_velocity;
}</pre></div></li><li class="listitem">We can test this out in one of our derived classes. Move to <code class="literal">Player.cpp</code> and add the following:<div><pre class="programlisting">void Player::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));

  m_velocity.setX(1);

  SDLGameObject::update();
}</pre></div></li></ol></div><p>We set the <code class="literal">m_velocity</code> x value to 1. This means that we will add <code class="literal">1</code> to our <code class="literal">m_position</code> x value<a class="indexterm" id="id205"/> each time the update function is called. Now we can run this to see our object move using the new velocity vector.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Adding acceleration</h2></div></div></div><p>Not all of our objects <a class="indexterm" id="id206"/>will move along at a constant velocity. Some games will require that we gradually increase the velocity of our object using acceleration. A car or a spaceship are good examples. No one would expect these objects to hit their top speed instantaneously. We are going to need a new vector for acceleration, so let's add this into our <code class="literal">SDLGameObject.h</code> file.</p><div><pre class="programlisting">Vector2D m_acceleration;</pre></div><p>Then we can add it to our <code class="literal">update</code> function.</p><div><pre class="programlisting">void SDLGameObject::update()
{
  m_velocity += m_acceleration;
  m_position += m_velocity;
}</pre></div><p>Now alter our <code class="literal">Player::update</code> function to set the acceleration rather than the velocity.</p><div><pre class="programlisting">void Player::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));

  m_acceleration.setX(1);

  SDLGameObject::update();
}</pre></div><p>After running our game you will see that the object gradually picks up speed.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Creating fixed frames per second</h1></div></div></div><p>Earlier in the book we put in an <code class="literal">SDL_Delay</code> function to slow everything down and ensure that our objects weren't moving too fast. We will now expand upon that by making our game run at a fixed frame rate. Fixed frames per second (FPS) is not necessarily always a good<a class="indexterm" id="id207"/> option, especially when your game includes more advanced physics. It is worth bearing this in mind when you move on from this book and start developing your own games. Fixed FPS will, however, be fine for the small 2D games, which <a class="indexterm" id="id208"/>we will work towards in this book. </p><p>With that said, let's move on to the code:</p><div><ol class="orderedlist arabic"><li class="listitem">Open up <code class="literal">main.cpp</code> and we will create a few constant variables.<div><pre class="programlisting">const int FPS = 60;
const int DELAY_TIME = 1000.0f / FPS;

int main()
{</pre></div></li><li class="listitem">Here we define how many frames per second we want our game to run at. A frame rate of 60 frames per second is a good starting point as this is essentially synced up to the refresh rate of most modern monitors and TVs. We can then divide this by the number of milliseconds in a second, giving us the amount of time we need to delay the game between loops to keep our constant frame rate. We need another two variables at the top of our main function; these will be used in our calculations.<div><pre class="programlisting">int main()
{
    Uint32 frameStart, frameTime;</pre></div></li><li class="listitem">We can now implement our fixed frame rate in our main loop.<div><pre class="programlisting">while(TheGame::Instance()-&gt;running())
{
  frameStart = SDL_GetTicks();

  TheGame::Instance()-&gt;handleEvents();
  TheGame::Instance()-&gt;update();
  TheGame::Instance()-&gt;render();

  frameTime = SDL_GetTicks() - frameStart;

  if(frameTime&lt; DELAY_TIME)
  {
    SDL_Delay((int)(DELAY_TIME - frameTime));
  }
}</pre></div></li></ol></div><p>First we get the time at the start of our loop and store it in <code class="literal">frameStart</code>. For this we use <code class="literal">SDL_GetTicks</code> which returns the amount of milliseconds since we called <code class="literal">SDL_Init</code>. We then run our game loop and store how long it took to run by subtracting the time our frame started from the current time. If it is less than the time we want a frame to take, we call <code class="literal">SDL_Delay</code> and make<a class="indexterm" id="id209"/> our loop wait for the amount of time we want it to, subtracting how long the loop already took to complete.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Input handling</h1></div></div></div><p>We have now got our objects moving based on velocity and acceleration, so next we must introduce some way of controlling this movement through user input. SDL supports a number of different<a class="indexterm" id="id210"/> types of user interface devices including joysticks, gamepads, mouse, and keyboard, all of which will be covered in this chapter, along with how to add them into our framework implementation.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Creating our input handler class</h2></div></div></div><p>We will create a class<a class="indexterm" id="id211"/> that handles all device input, whether it is from controllers, keyboard, or mouse. Let's start with a basic class and build from there. First we need a header file, <code class="literal">InputHandler.h</code>.</p><div><pre class="programlisting">#include "SDL.h"
class InputHandler
{
public:
  static InputHandler* Instance()
  {
    if(s_pInstance == 0)
    {
      s_pInstance = new InputHandler();
    }

    return s_pInstance;
  }

  void update();
  void clean();

private:

  InputHandler();
  ~InputHandler() {}

  static InputHandler* s_pInstance;
};
typedef InputHandler TheInputHandler;</pre></div><p>This is our singleton <code class="literal">InputHandler</code>. So far we have an <code class="literal">update</code> function which will poll for events and<a class="indexterm" id="id212"/> update our <code class="literal">InputHandler</code> accordingly, and a clean function which will clear any devices we have initialized. As we start adding device support we will flesh this out a lot more.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Handling joystick/gamepad input</h2></div></div></div><p>There are tons of joysticks and gamepads out there, often with different amounts of buttons and <a class="indexterm" id="id213"/>analog sticks amongst other things. PC game developers have a lot to do when trying to support all of these different gamepads. SDL has good support for<a class="indexterm" id="id214"/> joysticks and gamepads, so we should be able to come up with a system that would not be difficult to extend for different gamepad support.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>SDL joystick events</h3></div></div></div><p>There are a <a class="indexterm" id="id215"/>few different structures for handling joystick events in SDL. The table below lists each one and their purpose.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SDL joystick event</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyAxisEvent</code>
<a class="indexterm" id="id216"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Axis motion information<a class="indexterm" id="id217"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyButtonEvent</code>
<a class="indexterm" id="id218"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Button press and release information<a class="indexterm" id="id219"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyBallEvent</code>
<a class="indexterm" id="id220"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Trackball event motion<a class="indexterm" id="id221"/> information</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyHatEvent</code>
<a class="indexterm" id="id222"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Joystick hat position change<a class="indexterm" id="id223"/>
</p>
</td></tr></tbody></table></div><p>The events we are <a class="indexterm" id="id224"/>most interested in are the axis motion and the button press events. Each of these events also has an enumerated type that we can check for in our event loop to ensure we are only handling the events we want to handle. The table below shows the type value for each of the above events.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SDL joystick event</p>
</th><th style="text-align: left" valign="bottom">
<p>Type value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyAxisEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JOYAXISMOTION</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyButtonEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JOYBUTTONDOWN</code> or <code class="literal">SDL_JOYBUTTONUP</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyBallEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JOYBALLMOTION</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JoyHatEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_JOYHATMOTION</code>
</p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>It's a good idea to use the <strong>Joystick Control Panel</strong> property<a class="indexterm" id="id225"/> in Windows or <strong>JoystickShow</strong> on OSX to find out which button numbers you will need to use in SDL for a specific button. These applications are invaluable for finding out things about your joystick/gamepad so you can support them properly.</p></div></div><p>The code we <a class="indexterm" id="id226"/>will put in place will assume we are using a Microsoft Xbox 360 controller (which can be used on PC or OSX), as this is an extremely popular controller for PC gaming. Other controllers, such as the PS3 controller, could possibly have different values for buttons and axes. The <a class="indexterm" id="id227"/>Xbox 360 controller consists of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two analog sticks</li><li class="listitem" style="list-style-type: disc">Analog sticks press as buttons</li><li class="listitem" style="list-style-type: disc">Start and Select buttons</li><li class="listitem" style="list-style-type: disc">Four face buttons: A, B, X, and Y</li><li class="listitem" style="list-style-type: disc">Four triggers: two digital and two analog</li><li class="listitem" style="list-style-type: disc">A digital directional pad</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Initializing joysticks</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">To use gamepads and joysticks in SDL we first need to initialize them. We are going<a class="indexterm" id="id228"/> to add a new public function to the <code class="literal">InputHandler</code> class. This function will find out how many joysticks SDL has access to and then initialize them.<div><pre class="programlisting">void initialiseJoysticks();
bool joysticksInitialised() { 
return m_bJoysticksInitialised; }</pre></div></li><li class="listitem">We will also declare some private member variables that we will need.<div><pre class="programlisting">std::vector&lt;SDL_Joystick*&gt; m_joysticks;
bool m_bJoysticksInitialised;</pre></div></li><li class="listitem">The <code class="literal">SDL_Joystick*</code> is a pointer to the joystick we will be initializing. We won't actually need these pointers when using the joysticks, but we do need to close them after we are done, so it is helpful for us to keep a list of them for later access. We will now define our <code class="literal">initialiseJoysticks</code> function and then go through it.<div><pre class="programlisting">void InputHandler::initialiseJoysticks()
{
  if(SDL_WasInit(SDL_INIT_JOYSTICK) == 0)
  {
    SDL_InitSubSystem(SDL_INIT_JOYSTICK);
  }

  if(SDL_NumJoysticks() &gt; 0)
  {
    for(int i = 0; i &lt; SDL_NumJoysticks(); i++)
    {
      SDL_Joystick* joy = SDL_JoystickOpen(i);
      if(SDL_JoystickOpened(i) == 1)
      {
        m_joysticks.push_back(joy);
      }
      else
      {
        std::cout &lt;&lt; SDL_GetError();
      }
    }
    SDL_JoystickEventState(SDL_ENABLE);
    m_bJoysticksInitialised = true;

    std::cout &lt;&lt; "Initialised "&lt;&lt; m_joysticks.size() &lt;&lt; " 
    joystick(s)";
  }
  else
  {
    m_bJoysticksInitialised = false;
  }
}</pre></div></li><li class="listitem">Let's go through<a class="indexterm" id="id229"/> this line-by-line. First we check whether the joystick subsystem has been initialized using <code class="literal">SDL_WasInit</code>. If it has not been initialized we then initialize it using <code class="literal">SDL_InitSubSystem</code>.<div><pre class="programlisting">if(SDL_WasInit(SDL_INIT_JOYSTICK) == 0)
{
  SDL_InitSubSystem(SDL_INIT_JOYSTICK);
}</pre></div></li><li class="listitem">Next is the opening of each available joystick. Before we attempt to open the objects, we use <code class="literal">SDL_NumJoysticks</code> to make sure there are some joysticks available. We can then<a class="indexterm" id="id230"/> loop through the number of joysticks, opening them in turn with <code class="literal">SDL_JoystickOpen</code>. They can then be pushed into our array for closing later.<div><pre class="programlisting">if(SDL_NumJoysticks() &gt; 0)
{
  for(int i = 0; i &lt; SDL_NumJoysticks(); i++)
  {
    SDL_Joystick* joy = SDL_JoystickOpen(i);
    if(SDL_JoystickOpened(i))
    {
      m_joysticks.push_back(joy);
    }
    else
    {
      std::cout &lt;&lt; SDL_GetError();
    }
  }
}</pre></div></li><li class="listitem">Finally, we tell SDL to start listening for joystick events by enabling <code class="literal">SDL_JoystickEventState</code>. We also set our <code class="literal">m_bJoysticksEnabled</code> member variable according to how our initialization went.<div><pre class="programlisting">SDL_JoystickEventState(SDL_ENABLE);
m_bJoysticksInitialised = true;

std::cout &lt;&lt; "Initialised " &lt;&lt; m_joysticks.size() &lt;&lt; " joystick(s)";

}
else
{
  m_bJoysticksInitialised = false;
}</pre></div></li><li class="listitem">So, we now have a way to initialize our joysticks. We have two other functions to define, the <code class="literal">update</code> and <code class="literal">clean</code> functions. The <code class="literal">clean</code> function will loop through our <code class="literal">SDL_Joystick*</code> array and call <code class="literal">SDL_JoystickClose</code> on each iteration.<div><pre class="programlisting">void InputHandler::clean()
{
  if(m_bJoysticksInitialised)
  {
    for(unsigned int i = 0; i &lt; SDL_NumJoysticks(); i++)
    {
      SDL_JoystickClose(m_joysticks[i]);
    }
  }
}</pre></div></li><li class="listitem">The <code class="literal">update</code> function <a class="indexterm" id="id231"/>will be called in each frame in the main game loop to update the event state. For now though it will simply listen for a quit event and call the game's <a class="indexterm" id="id232"/><code class="literal">quit</code> function (this function simply calls <code class="literal">SDL_Quit()</code>).<div><pre class="programlisting">void InputHandler::update()
{
  SDL_Event event;
  while(SDL_PollEvent(&amp;event))
  {
    if(event.type == SDL_QUIT)
    {
      TheGame::Instance()-&gt;quit();
    }
  }
}</pre></div></li><li class="listitem">Now we will use this <code class="literal">InputHandler</code> in our <code class="literal">Game</code> class functions. First we call <code class="literal">initialiseJoysticks</code> in<a class="indexterm" id="id233"/> the <code class="literal">Game::init</code> function.<div><pre class="programlisting">TheInputHandler::Instance()-&gt;initialiseJoysticks();</pre></div><p>And we will update it in the <code class="literal">Game::handleEvents</code> function, clearing out anything we had before:</p><div><pre class="programlisting">void Game::handleEvents()
{
  TheInputHandler::Instance()-&gt;update();
}</pre></div></li><li class="listitem">The <code class="literal">clean</code> function can also be added to our <code class="literal">Game::clean</code> function.<div><pre class="programlisting">TheInputHandler::Instance()-&gt;clean();</pre></div></li><li class="listitem">We can now plug in a pad or joystick and run the build. If everything is working according to plan we should get the following output, with <code class="literal">x</code> being the number of joysticks you have plugged in:<div><pre class="programlisting">Initialised x joystick(s)</pre></div></li><li class="listitem">Ideally we<a class="indexterm" id="id234"/> want to easily use one or more controllers with no change to our code. We already have a way to load in and open as many controllers that are plugged in, but we need to know which event corresponds to which controller; we do this using some information stored in the event. Each joystick event will have a <code class="literal">which</code> variable stored within it. Using this will allow us to find out which joystick the event came from.<div><pre class="programlisting">if(event.type == SDL_JOYAXISMOTION) // check the type value
{
  int whichOne = event.jaxis.which; // get which controller</pre></div></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Listening for and handling axis movement</h2></div></div></div><p>We are not going to handle the analog sticks in an analog way. Instead they will be handled as digital information, that is,<a class="indexterm" id="id235"/> they are either on or off. Our controller has four axes of motion, two for the left analog stick and two for the right. </p><p>We will make the following assumptions about our controller (you can use an external application to find out the specific values for your controller):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Left and right movement on stick one is axis 0</li><li class="listitem" style="list-style-type: disc">Up and down movement on stick one is axis 1</li><li class="listitem" style="list-style-type: disc">Left and right movement on stick two is axis 3</li><li class="listitem" style="list-style-type: disc">Up and down movement on stick two is axis 4</li></ul></div><p>The Xbox 360 controller uses axes 2 and 5 for the analog triggers. To handle multiple controllers with multiple axes we will create a vector of pairs of <code class="literal">Vector2D*</code>, one for each stick.</p><div><pre class="programlisting">std::vector&lt;std::pair&lt;Vector2D*, Vector2D*&gt;&gt; m_joystickValues;</pre></div><p>We use the <code class="literal">Vector2D</code> values to set whether a stick has moved up, down, left, or right. Now when we initialize our joysticks we need to create a pair of <code class="literal">Vector2D*</code> in the <code class="literal">m_joystickValues</code> array.</p><div><pre class="programlisting">for(int i = 0; i &lt; SDL_NumJoysticks(); i++)
{
  SDL_Joystick* joy = SDL_JoystickOpen(i);
  if(SDL_JoystickOpened(i))
  {
    m_joysticks.push_back(joy);
    m_joystickValues.push_back(std::make_pair(new 
    Vector2D(0,0),new Vector2D(0,0))); // add our pair
  }
  else
  {
    std::cout &lt;&lt; SDL_GetError();
  }
}</pre></div><p>We need a way <a class="indexterm" id="id236"/>to grab the values we need from this array of pairs; we will declare two new functions to the <code class="literal">InputHandler</code> class:</p><div><pre class="programlisting">int xvalue(int joy, int stick);
int yvalue(int joy, int stick);</pre></div><p>The <code class="literal">joy</code> parameter<a class="indexterm" id="id237"/> is the identifier (ID) of the joystick we want to use, and the stick is 1 for the left stick and 2 for the right stick. Let's define these functions:</p><div><pre class="programlisting">int InputHandler::xvalue(int joy, int stick);
{
  if(m_joystickValues.size() &gt; 0)
  {
    if(stick == 1)
    {
      return m_joystickValues[joy].first-&gt;getX();
    }
    else if(stick == 2)
    {
      return m_joystickValues[joy].second-&gt;getX();
    }
  }
  return 0;
}

int InputHandler::yvalue(int joy, int stick)
{
  if(m_joystickValues.size() &gt; 0)
  {
    if(stick == 1)
    {
      return m_joystickValues[joy].first-&gt;getY();
    }
    else if(stick == 2)
    {
      return m_joystickValues[joy].second-&gt;getY();
    }
  }
  return 0;
}</pre></div><p>So we grab the x or y value based on the parameters passed to each function. The <code class="literal">first</code> and <code class="literal">second</code> values<a class="indexterm" id="id238"/> are the first or second objects of the pair in the array, with <code class="literal">joy</code> being the index of the array. We can now set these values accordingly in the event loop.</p><div><pre class="programlisting">SDL_Event event;
while(SDL_PollEvent(&amp;event))
{
  if(event.type == SDL_QUIT)
  {
    TheGame::Instance()-&gt;quit();
  }

  if(event.type == SDL_JOYAXISMOTION)
  {
    int whichOne = event.jaxis.which;

    // left stick move left or right
    if(event.jaxis.axis == 0)
    {
      if (event.jaxis.value &gt; m_joystickDeadZone)
      {
        m_joystickValues[whichOne].first-&gt;setX(1);
      }
      else if(event.jaxis.value &lt; -m_joystickDeadZone)
      {
        m_joystickValues[whichOne].first-&gt;setX(-1);
      }
      else
      {
        m_joystickValues[whichOne].first-&gt;setX(0);
      }
    }

    // left stick move up or down
    if(event.jaxis.axis == 1)
    {
      if (event.jaxis.value &gt; m_joystickDeadZone)
      {
        m_joystickValues[whichOne].first-&gt;setY(1);
      }
      else if(event.jaxis.value &lt; -m_joystickDeadZone)
      {
        m_joystickValues[whichOne].first-&gt;setY(-1);
      }
      else
      {
        m_joystickValues[whichOne].first-&gt;setY(0);
      }
    }

    // right stick move left or right
    if(event.jaxis.axis == 3)
    {
      if (event.jaxis.value &gt; m_joystickDeadZone)
      {
        m_joystickValues[whichOne].second-&gt;setX(1);
      }
      else if(event.jaxis.value &lt; -m_joystickDeadZone)
      {
        m_joystickValues[whichOne].second-&gt;setX(-1);
      }
      else
      {
        m_joystickValues[whichOne].second-&gt;setX(0);
      }
    }

    // right stick move up or down
    if(event.jaxis.axis == 4)
    {
      if (event.jaxis.value &gt; m_joystickDeadZone)
      {
        m_joystickValues[whichOne].second-&gt;setY(1);
      }
      else if(event.jaxis.value &lt; -m_joystickDeadZone)
      {
        m_joystickValues[whichOne].second-&gt;setY(-1);
      }
      else
      {
        m_joystickValues[whichOne].second-&gt;setY(0);
      }
    }
  }
}</pre></div><p>That is a big function! It is, however, <a class="indexterm" id="id239"/>relatively straightforward. We first check for an <a class="indexterm" id="id240"/>
<code class="literal">SDL_JOYAXISMOTION</code> event and we then find out which controller the event came from using the <code class="literal">which</code> value.</p><div><pre class="programlisting">int whichOne = event.jaxis.which;</pre></div><p>From this we know which joystick the event came from and can set a value in the array accordingly; for example:</p><div><pre class="programlisting">m_joystickValues[whichOne]</pre></div><p>First we check the axis the event came from:</p><div><pre class="programlisting">if(event.jaxis.axis == 0) // …1,3,4</pre></div><p>If the axis is 0 or 1, it is the left stick, and if it is 3 or 4, it is the right stick. We use <code class="literal">first</code> or <code class="literal">second</code> of the pair to set the left or right stick. You may also have noticed the <code class="literal">m_joystickDeadZone</code> variable. We use this to account for the sensitivity of a controller. We can set this as a constant variable in the <code class="literal">InputHandler</code> header file:</p><div><pre class="programlisting">const int m_joystickDeadZone = 10000;</pre></div><p>The value <code class="literal">10000</code> may seem like a big value to use for a stick at rest, but the sensitivity of a controller can be very high and so requires a value as large as this. Change this value accordingly for your own controllers.</p><p>Just to solidify what we are doing here, let's look closely at one scenario.</p><div><pre class="programlisting">// left stick move left or right
{
  if (event.jaxis.value &gt; m_joystickDeadZone)
  {
    m_joystickValues[whichOne].first-&gt;setX(1);
  }
  else if(event.jaxis.value &lt; -m_joystickDeadZone)
  {
    m_joystickValues[whichOne].first-&gt;setX(-1);
  }
  else
  {
    m_joystickValues[whichOne].first-&gt;setX(0);
  }
}</pre></div><p>If we get to the <a class="indexterm" id="id241"/>second if statement, we know that we are dealing with a left or right movement event on the left stick due to the axis being 0. We have already set which controller the event was from and adjusted <code class="literal">whichOne</code> to the correct value. We also want <code class="literal">first</code> of the pair to be the left stick. So if the axis is 0, we use the <code class="literal">first</code> object of the array and set its x value, as we are dealing with an x movement event. So why do we set the value to 1 or -1? We will answer this by starting to move our <code class="literal">Player</code> object.</p><p>Open up <code class="literal">Player.h</code> and we can start to use our <code class="literal">InputHandler</code> to get events. First we will declare a new private function:</p><div><pre class="programlisting">private:

void handleInput();</pre></div><p>Now in our <code class="literal">Player.cpp</code> file we can define this function to work with the <code class="literal">InputHandler</code>.</p><div><pre class="programlisting">void Player::handleInput()
{
  if(TheInputHandler::Instance()-&gt;joysticksInitialised())
  {
    if(TheInputHandler::Instance()-&gt;xvalue(0, 1) &gt; 0 || 
    TheInputHandler::Instance()-&gt;xvalue(0, 1) &lt; 0)
    {
      m_velocity.setX(1 * TheInputHandler::Instance()-&gt;xvalue(0, 
      1));
    }

    if(TheInputHandler::Instance()-&gt;yvalue(0, 1) &gt; 0 || 
    TheInputHandler::Instance()-&gt;yvalue(0, 1) &lt; 0)
    {
      m_velocity.setY(1 * TheInputHandler::Instance()-&gt;yvalue(0, 
      1));
    }

    if(TheInputHandler::Instance()-&gt;xvalue(0, 2) &gt; 0 || 
    TheInputHandler::Instance()-&gt;xvalue(0, 2) &lt; 0)
    {
      m_velocity.setX(1 * TheInputHandler::Instance()-&gt;xvalue(0, 
      2));
    }

    if(TheInputHandler::Instance()-&gt;yvalue(0, 2) &gt; 0 || 
    TheInputHandler::Instance()-&gt;yvalue(0, 2) &lt; 0)
    {
      m_velocity.setY(1 * TheInputHandler::Instance()-&gt;yvalue(0, 
      2));
    }

  }
}</pre></div><p>Then we can<a class="indexterm" id="id242"/> call this function in the <code class="literal">Player::update</code> function.<a class="indexterm" id="id243"/>
</p><div><pre class="programlisting">void Player::update()
{
  m_velocity.setX(0);
  m_velocity.setY(0);

  handleInput(); // add our function

  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));

  SDLGameObject::update();
}</pre></div><p>Everything is in place now, but first let's go through how we are setting our movement.</p><div><pre class="programlisting">if(TheInputHandler::Instance()-&gt;xvalue(0, 1) &gt; 0 || TheInputHandler::Instance()-&gt;xvalue(0, 1) &lt; 0)
{
  m_velocity.setX(1 * TheInputHandler::Instance()-&gt;xvalue(0, 1));
}</pre></div><p>Here, we first check whether <code class="literal">xvalue</code> of the left stick is more than 0 (that it has moved). If so, we set our <code class="literal">Player</code> x velocity to be the speed we want multiplied by <code class="literal">xvalue</code> of the left stick, and we know this is either 1 or -1. As you will know, multiplying a positive number by a negative number results in a negative number, so multiplying the speed we want by -1 will mean we are setting our x velocity to a minus value (move left). We do the same for the other stick and also the y values. Build the project and start moving your <code class="literal">Player</code> object with a gamepad. You could also plug in another controller and update the <code class="literal">Enemy</code> class to use it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Dealing with joystick button input</h2></div></div></div><p>Our next step is to implement a way to handle button input from our controllers. This is actually a lot simpler<a class="indexterm" id="id244"/> than handling axes. We need to know the current state of each button so that we can check whenever one <a class="indexterm" id="id245"/>has been pressed or released. To do this, we will declare an array of Boolean values, so each controller (the first index into the array) will have an array of Boolean values, one for each button on the controller.</p><div><pre class="programlisting">std::vector&lt;std::vector&lt;bool&gt;&gt; m_buttonStates;</pre></div><p>We can grab the current button state with a function that looks up the correct button from the correct joystick.</p><div><pre class="programlisting">bool getButtonState(int joy, int buttonNumber)
{
  return m_buttonStates[joy][buttonNumber];
}</pre></div><p>The first parameter is the index into the array (the joystick ID), and the second is the index into the buttons. Next we are going to have to initialize this array for each controller and each of its buttons. We will do this in the <code class="literal">initialiseJoysticks</code> function.</p><div><pre class="programlisting">for(int i = 0; i &lt; SDL_NumJoysticks(); i++)
{
  SDL_Joystick* joy = SDL_JoystickOpen(i);
  if(SDL_JoystickOpened(i))
  {
    m_joysticks.push_back(joy);
    m_joystickValues.push_back(std::make_pair(new 
    Vector2D(0,0),new Vector2D(0,0)));

    std::vector&lt;bool&gt; tempButtons;

    for(int j = 0; j &lt; SDL_JoystickNumButtons(joy); j++)
    {
      tempButtons.push_back(false);
    }

    m_buttonStates.push_back(tempButtons);
  }
}</pre></div><p>We use <code class="literal">SDL_JoystickNumButtons</code> to get the number of buttons for each of our joysticks. We then push a value for each of these buttons into an array. We push <code class="literal">false</code> to start, as no buttons are pressed. This array is then pushed into <code class="literal">our m_buttonStates</code> array to be used<a class="indexterm" id="id246"/> with the <code class="literal">getButtonState</code>
<a class="indexterm" id="id247"/> function. Now we must listen for button events and set the value in the array accordingly.</p><div><pre class="programlisting">if(event.type == SDL_JOYBUTTONDOWN)  
{
  int whichOne = event.jaxis.which;

  m_buttonStates[whichOne][event.jbutton.button] = true;
}

if(event.type == SDL_JOYBUTTONUP)
{
  int whichOne = event.jaxis.which;

  m_buttonStates[whichOne][event.jbutton.button] = false;
}</pre></div><p>When a button is pressed (<code class="literal">SDL_JOYBUTTONDOWN</code>) we get to know which controller it was pressed on and use this as an index into the <code class="literal">m_buttonStates</code> array. We then use the button number (<code class="literal">event.jbutton.button</code>) to set the correct button to <code class="literal">true</code>; the same applies when a button is released (<code class="literal">SDL_JOYBUTTONUP</code>). That is pretty much it for button handling. Let's test it out in our Player class.</p><div><pre class="programlisting">if(TheInputHandler::Instance()-&gt;getButtonState(0, 3))
{
  m_velocity.setX(1);
}</pre></div><p>Here we are checking if button 3 has been pressed (Yellow or Y on an Xbox controller) and setting our velocity if it has. That is everything we will cover about joysticks in this book. You will realize that supporting many joysticks is very tricky and requires a lot of tweaking to ensure each one is handled correctly. However, there are ways through which you can start to have support for many joysticks; for example, through a configuration file or even by<a class="indexterm" id="id248"/> the use of inheritance for different joystick types.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Handling mouse events</h2></div></div></div><p>Unlike joysticks, we do not have to initialize the mouse. We can also safely assume that there will only be one<a class="indexterm" id="id249"/> mouse plugged in at a time, so <a class="indexterm" id="id250"/>we will not need to handle multiple mouse devices. We can start by looking at the available mouse events that SDL covers:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SDL Mouse Event</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MouseButtonEvent</code>
<a class="indexterm" id="id251"/>
</p>
</td><td style="text-align: left" valign="top">
<p>A button on the mouse has been pressed or released<a class="indexterm" id="id252"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MouseMotionEvent</code>
<a class="indexterm" id="id253"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse has been moved<a class="indexterm" id="id254"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MouseWheelEvent</code>
<a class="indexterm" id="id255"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse wheel has moved<a class="indexterm" id="id256"/>
</p>
</td></tr></tbody></table></div><p>Just like the joystick events, each mouse event has a type value; the following table shows each of these values:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SDL Mouse Event</p>
</th><th style="text-align: left" valign="bottom">
<p>Type Value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MouseButtonEvent</code>
<a class="indexterm" id="id257"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MOUSEBUTTONDOWN</code> or <code class="literal">SDL_MOUSEBUTTONUP</code>
<a class="indexterm" id="id258"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MouseMotionEvent</code>
<a class="indexterm" id="id259"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MOUSEMOTION</code>
<a class="indexterm" id="id260"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MouseWheelEvent</code>
<a class="indexterm" id="id261"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_MOUSEWHEEL</code>
<a class="indexterm" id="id262"/>
</p>
</td></tr></tbody></table></div><p>We will not implement any mouse wheel movement events as most games will not use them.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Using mouse button events</h3></div></div></div><p>Implementing mouse button events is as straightforward as joystick events, more so even as we have only three buttons to choose from: left, right, and middle. SDL numbers these as 0 for left, 1 for middle, <a class="indexterm" id="id263"/>and 2 for right. In our <code class="literal">InputHandler</code> header, let's declare a similar array to the joystick buttons, but this time a one-dimensional array, as we won't handle multiple mouse devices.</p><div><pre class="programlisting">std::vector&lt;bool&gt; m_mouseButtonStates;</pre></div><p>Then in the constructor of our <code class="literal">InputHandler</code> we can push our three mouse button states (defaulted to <code class="literal">false</code>) into the array:</p><div><pre class="programlisting">for(int i = 0; i &lt; 3; i++)
{
  m_mouseButtonStates.push_back(false);
}</pre></div><p>Back in our header file, let's create an <a class="indexterm" id="id264"/>
<code class="literal">enum</code> attribute to help us with the values of the mouse buttons. Put this above the class so that other files that include our <code class="literal">InputHandler.h</code> header can use it too.</p><div><pre class="programlisting">enum mouse_buttons
{
    LEFT = 0,
    MIDDLE = 1,
    RIGHT = 2
};</pre></div><p>Now let's <a class="indexterm" id="id265"/>handle mouse events in our event loop:</p><div><pre class="programlisting">if(event.type == SDL_MOUSEBUTTONDOWN)
{
  if(event.button.button == SDL_BUTTON_LEFT)
  {
    m_mouseButtonStates[LEFT] = true;
  }

  if(event.button.button == SDL_BUTTON_MIDDLE)
  {
    m_mouseButtonStates[MIDDLE] = true;
  }

  if(event.button.button == SDL_BUTTON_RIGHT)
  {
    m_mouseButtonStates[RIGHT] = true;
  }
}

if(event.type == SDL_MOUSEBUTTONUP)
{
  if(event.button.button == SDL_BUTTON_LEFT)
  {
    m_mouseButtonStates[LEFT] = false;
  }

  if(event.button.button == SDL_BUTTON_MIDDLE)
  {
    m_mouseButtonStates[MIDDLE] = false;
  }

  if(event.button.button == SDL_BUTTON_RIGHT)
  {
    m_mouseButtonStates[RIGHT] = false;
  }
}</pre></div><p>We also need a function<a class="indexterm" id="id266"/> to access our mouse button states. Let's add this public function to the <code class="literal">InputHandler</code> header file:</p><div><pre class="programlisting">bool getMouseButtonState(int buttonNumber)
{
  return m_mouseButtonStates[buttonNumber];
}</pre></div><p>That is everything we need for mouse button events. We can now test it in our <code class="literal">Player</code> class.</p><div><pre class="programlisting">if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT))
{
  m_velocity.setX(1);
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Handling mouse motion events</h3></div></div></div><p>Mouse motion events are very important, especially in big 3D first or third person action titles. For our 2D games, we might want our character to follow the mouse as a way to control our objects,<a class="indexterm" id="id267"/> or we might want objects to move to where the mouse was clicked (for a strategy game perhaps). We may even just want to know where the mouse was clicked so that we can use it for menus. Fortunately for us, mouse motion events are relatively simple. We will start by creating a private <code class="literal">Vector2D*</code> in the header file to use as the position variable for our mouse:</p><div><pre class="programlisting">Vector2D* m_mousePosition;</pre></div><p>Next, we need a public accessor for this:</p><div><pre class="programlisting">Vector2D* getMousePosition()
{
  return m_mousePosition;
}</pre></div><p>And we can now handle this in our event loop:</p><div><pre class="programlisting">if(event.type == SDL_MOUSEMOTION)
{
  m_mousePosition-&gt;setX(event.motion.x);
  m_mousePosition-&gt;setY(event.motion.y);
}</pre></div><p>That is all we need for<a class="indexterm" id="id268"/> mouse motion. So let's make our <code class="literal">Player</code> function follow the mouse position to test this feature:</p><div><pre class="programlisting">Vector2D* vec = TheInputHandler::Instance()-&gt;getMousePosition();

m_velocity = (*vec - m_position) / 100;</pre></div><p>Here we have set our velocity to a vector from the player's current position to the mouse position. You can get this vector by subtracting the desired location from the current location; we already have a vector subtract overloaded operator so this is easy for us. We also divide the vector by 100; this just dampens the speed slightly so that we can see it following rather than just sticking to the mouse position. Remove the <code class="literal">/</code> to have your object follow the mouse exactly.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Implementing keyboard input</h2></div></div></div><p>Our final method of input, and the simplest of the three, is keyboard input. We don't have to handle any motion<a class="indexterm" id="id269"/> events, we just want the state of each button. We aren't going to declare an array here because SDL has a built-in function that will give us an array with the state of every key; 1 being pressed and 0 not pressed.</p><div><pre class="programlisting">SDL_GetKeyboardState(int* numkeys)</pre></div><p>The <code class="literal">numkeys</code> parameter will return the number of keys available on the keyboard (the length of the <code class="literal">keystate</code> array). So in our <code class="literal">InputHandler</code> header we can declare a pointer to the array that will be returned from <code class="literal">SDL_GetKeyboardState</code>.</p><div><pre class="programlisting">Uint8* m_keystate;</pre></div><p>When we update our event handler we can also update the state of the keys; put this at the top of our event loop.</p><div><pre class="programlisting">m_keystates = SDL_GetKeyboardState(0);</pre></div><p>We will now need to create a simple function that checks whether a key is down or not.</p><div><pre class="programlisting">bool InputHandler::isKeyDown(SDL_Scancode key)
{
  if(m_keystates != 0)
  {
    if(m_keystates[key] == 1)
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  return false;
}</pre></div><p>This function takes <code class="literal">SDL_SCANCODE</code> as a parameter. The full list of <code class="literal">SDL_SCANCODE</code> values can be found in<a class="indexterm" id="id270"/> the SDL documentation at <a class="ulink" href="http://wiki.libsdl.org/moin.cgi">http://wiki.libsdl.org/moin.cgi</a>.</p><p>We can test the keys in our <code class="literal">Player</code> class. We will use the arrow keys to move our player.</p><div><pre class="programlisting">if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_RIGHT))
{
  m_velocity.setX(2);
}

if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_LEFT))
{
  m_velocity.setX(-2);
}

if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_UP))
{
  m_velocity.setY(-2);
}

if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_DOWN))
{
  m_velocity.setY(2);
}</pre></div><p>We now have key handling in place. Test as many keys as you can and look up the <code class="literal">SDL_Scancode</code> for the keys you are most likely to want to use.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Wrapping things up</h2></div></div></div><p>We have now implemented <a class="indexterm" id="id271"/>all of the devices we are going to handle, but at the moment our event loop is in a bit of a mess. We need to break it up into more manageable chunks. We will do this with the use of a switch statement for event types and some private functions, within our <code class="literal">InputHandler</code>. First let's declare our functions in the header file:</p><div><pre class="programlisting">// private functions to handle different event types

// handle keyboard events
void onKeyDown();
void onKeyUp();

// handle mouse events
void onMouseMove(SDL_Event&amp; event);
void onMouseButtonDown(SDL_Event&amp; event);
void onMouseButtonUp(SDL_Event&amp; event);

// handle joysticks events
void onJoystickAxisMove(SDL_Event&amp; event);
void onJoystickButtonDown(SDL_Event&amp; event);
void onJoystickButtonUp(SDL_Event&amp; event);</pre></div><p>We pass in the event from the event loop into each function (apart from keys) so that we can handle them accordingly. We now need to create our switch statement in the event loop.</p><div><pre class="programlisting">void InputHandler::update()
{
  SDL_Event event;
  while(SDL_PollEvent(&amp;event))
  {
    switch (event.type)
    {
    case SDL_QUIT:
      TheGame::Instance()-&gt;quit();
    break;

    case SDL_JOYAXISMOTION:
      onJoystickAxisMove(event);
    break;

    case SDL_JOYBUTTONDOWN:
      onJoystickButtonDown(event);
    break;

    case SDL_JOYBUTTONUP:
      onJoystickButtonUp(event);
    break;

    case SDL_MOUSEMOTION:
      onMouseMove(event);
    break;

    case SDL_MOUSEBUTTONDOWN:
      onMouseButtonDown(event);
    break;

    case SDL_MOUSEBUTTONUP:
      onMouseButtonUp(event);
    break;

    case SDL_KEYDOWN:
      onKeyDown();
    break;

    case SDL_KEYUP:
      onKeyUp();
    break;

    default:
    break;
    }
  }
}</pre></div><p>As you can see, we<a class="indexterm" id="id272"/> now break up our event loop and call the associated function depending on the type of the event. We can now split all our previous work into these functions; for example, we can put all of our mouse button down handling<a class="indexterm" id="id273"/> code into the <code class="literal">onMouseButtonDown</code> function.</p><div><pre class="programlisting">void InputHandler::onMouseButtonDown(SDL_Event&amp; event)
{
  if(event.button.button == SDL_BUTTON_LEFT)
  {
    m_mouseButtonStates[LEFT] = true;
  }

  if(event.button.button == SDL_BUTTON_MIDDLE)
  {
    m_mouseButtonStates[MIDDLE] = true;
  }

  if(event.button.button == SDL_BUTTON_RIGHT)
  {
    m_mouseButtonStates[RIGHT] = true;
  }
}</pre></div><p>The rest of the code for the <code class="literal">InputHandler</code> is available within the source code downloads.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Summary</h1></div></div></div><p>We have covered some complicated material in this chapter. We have looked at a small amount of vector mathematics and how we can use it to move our game objects. We've also covered the initialization and the use of multiple joysticks and axes and the use of a mouse and a keyboard. Finally, we wrapped everything up with a tidy way to handle our events.</p></div></body></html>