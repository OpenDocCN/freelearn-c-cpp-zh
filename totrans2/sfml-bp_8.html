<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Build a Real-time Tower Defense Game from Scratch &#x2013; Part 2, Networking"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Build a Real-time Tower Defense Game from Scratch – Part 2, Networking</h1></div></div></div><p>In the previous chapter, we built a complete game from scratch. The only limitation we encountered was that we didn't have real enemies to defeat. We will solve this limitation in the present chapter by adding networking to our game to allow it to interact with players other than you. At the end of this chapter, you will be able to play this game with some friends. This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network architectures</li><li class="listitem" style="list-style-type: disc">Network communication using sockets</li><li class="listitem" style="list-style-type: disc">Creating a communication protocol</li><li class="listitem" style="list-style-type: disc">Modifying our game by applying the client-server concept</li><li class="listitem" style="list-style-type: disc">Saving and loading our game</li></ul></div><p>Now let's dive into this pretty complicated chapter.</p><div class="section" title="Network architectures"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Network architectures</h1></div></div></div><p>Before constructing our architecture, we need some information about what kind of network architectures are<a id="id465" class="indexterm"/> commonly used in a game, and their specificities. There are different types of architectures used in game programming. They greatly depend on the game and the needs of the developer. We<a id="id466" class="indexterm"/> will see two common architectures: peer-to-peer (P2P) and client-server. Both of them have their strengths and weaknesses. Let's analyze them individually.</p><div class="section" title="Peer-to-peer architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec86"/>Peer-to-peer architecture</h2></div></div></div><p>This architecture was widely<a id="id467" class="indexterm"/> used in the past, and is still used today. In this architecture, players know the addresses of each other and directly communicate with each other without any intermediary. For<a id="id468" class="indexterm"/> example, for a game with four different players, the network can be represented as the following chart: </p><div class="mediaobject"><img src="graphics/8477OS_08_02.jpg" alt="Peer-to-peer architecture"/></div><p>This organization allows a player to directly interact with any or all of the other players. When a client does something, it notifies the others of this action, and they update the simulation (game) consequently.</p><p>This approach is efficient for communications, but comes with some limitations that can't be ignored. The main one is that there is no way to avoid cheating. A client can do whatever it wants by notifying the other of that action, even if it's impossible, such as teleporting itself by sending an arbitrary position. A possible result is that the fun of the game is completely destroyed for the other players.</p><p>To avoid this kind of cheating, we have to change the architecture to be able to have a kind of referee that can decide if an action is legal.</p></div><div class="section" title="Client-server architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec87"/>Client-server architecture</h2></div></div></div><p>In game programming, avoiding cheating<a id="id469" class="indexterm"/> is very important, because it can completely destroy the experience of the game for the player. To be able to reduce the possibility of cheating, the architecture used<a id="id470" class="indexterm"/> can help. With client-server architecture, a game can detect the major part of these exploits. This is one reason that justifies the importance of this part. One other point is that this is the architecture that will be used for our game. Instead of having the players communicating between each other, they will only communicate with a single host called the server. Because all other players will also do the same, we will be able to communicate with them, but with an intermediary. </p><p>Moreover, this intermediary will act as a judge that will decide if an action is legal. Instead of having a full simulation on all the different players' computers, the real simulation is made by<a id="id471" class="indexterm"/> the server. It holds the real game states that have to be taken into account; the client is just a kind of display that we can interact with. The following chart<a id="id472" class="indexterm"/> represents the architecture:</p><div class="mediaobject"><img src="graphics/8477OS_08_03.jpg" alt="Client-server architecture"/></div><p>As you can see, we now need to pass through the server to propagate any kind of actions to the other players.</p><p>Its main drawback is that the server has to be reactive for all the players (clients), and if your game has a great number of players, this can become hard. Splitting the tasks on different threads is very important to ensure the reactivity of the server.</p><p>Some games require so many resources that it can't handle only a limited amount of players, the result is that you have to manage multiple server for one game; for instance, one for logging, another for chatting, another one for a specific area of the map, and so on. We will now see how to use this architecture for our game.</p><p>When creating a multiplayer architecture, the first thing to have in mind is that we will have to split our game in two distinct programs: a client and a server. We will have one server hosting several game instances and any number of clients, possibly on different matches.</p><p>To be able to have this kind of result, let's first think about what is needed by each part.</p><div class="section" title="Client"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec23"/>Client</h3></div></div></div><p>Each player must start a client program to be able to start a match. This program will have to do the<a id="id473" class="indexterm"/> following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Display the game state</li><li class="listitem" style="list-style-type: disc">Handle the different user inputs</li><li class="listitem" style="list-style-type: disc">Play effects (sounds, bloodshed, and so on)</li><li class="listitem" style="list-style-type: disc">Update its game status according to the information received from the server</li><li class="listitem" style="list-style-type: disc">Send requests to the server (build, destroy)</li></ul></div><p>These different features are already present in our actual game, so we will need to adapt them; but there are also some new features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Request the creation of a new match</li><li class="listitem" style="list-style-type: disc">Request to join a match</li></ul></div><p>Here I use the word <span class="emphasis"><em>request</em></span> because that's what it really is. As a player will not handle the game in totality, it can only send requests to the server to take action. The server will then judge them and react as a consequence. Now let's take a look at the server.</p></div><div class="section" title="Server"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec24"/>Server</h3></div></div></div><p>On the other hand, the<a id="id474" class="indexterm"/> server will need to be launched only once, and will have to manage the following functionalities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Store all the different matches</li><li class="listitem" style="list-style-type: disc">Process each game's steps</li><li class="listitem" style="list-style-type: disc">Send updates of the game to players</li><li class="listitem" style="list-style-type: disc">Handle player requests</li></ul></div><p>But a server also has to take care of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing connection/disconnection</li><li class="listitem" style="list-style-type: disc">Game creation</li><li class="listitem" style="list-style-type: disc">Adding a player as a controller for a team</li></ul></div><p>As you can see, there is no need for any kind of display, so the server output will be in console only. It will also have to judge all the different requests coming from the client. In a distributed environment, also true for web development, remember this rule: <span class="emphasis"><em>don't trust user inputs</em></span>.</p><p>If you keep this in mind, it will save you a lot of trouble and a lot of time in debugging. Some users, even if it's a very small number of users, can send you random data such as cheats or anything else that you're not supposed to receive. So don't take the inputs at face value.</p><p>Now that the functionalities have been exposed, we need a way to communicate between a client and the server. This is<a id="id475" class="indexterm"/> the topic that we will now speak about.</p></div></div></div></div>
<div class="section" title="Network communication using sockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Network communication using sockets</h1></div></div></div><p>To be able to interact with other players, we will need a way to communicate with them, regardless of the architecture used. To be able to communicate with any computer, we have to use sockets. In short, a socket <a id="id476" class="indexterm"/>enables communication with other processes/computers through the network as long as there is an existing way between both sides (LAN or Internet). There are two main<a id="id477" class="indexterm"/> kinds of sockets: non-connected (UDP) or connected (TCP). Both these need an IP address and a port number to communicate with their destination.</p><p>Notice that the number of available ports on a computer is contained between 0 and 65535. A piece of advice is to avoid the use of ports with a number lesser than 1024. The reason is that most of them are reserved by the system or used by common applications, such as 80 for a web browser, 21 for FTP, and so on. You also have to ensure that both sides of the communication use the same port number to be able to exchange data. Let's now see in detail the two kinds of socket previously introduced.</p><div class="section" title="UDP"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec88"/>UDP</h2></div></div></div><p>As already said, <span class="strong"><strong>User Datagram Protocol</strong></span> (<span class="strong"><strong>UDP</strong></span>) is a way of sending data through the network without<a id="id478" class="indexterm"/> connections. We can visualize the communication achieved by this protocol, such as sending letters. Each time you want to send a message to someone, you have to specify the <a id="id479" class="indexterm"/>destination address (IP and port). The message can then be sent, but you don't know if it really arrives at its destination. This kind of communication is really quick, but comes with some limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You don't even know<a id="id480" class="indexterm"/> if the message has arrived at its destination</li><li class="listitem" style="list-style-type: disc">A message can be lost</li><li class="listitem" style="list-style-type: disc">A big message will be split in smaller messages</li><li class="listitem" style="list-style-type: disc">Messages can be received in a different order than the original order</li><li class="listitem" style="list-style-type: disc">A message can be duplicated</li></ul></div><p>Because of these limitations, the messages can't be exploited as soon as they are received. There is a need for verification. A simple way to resolve a majority of these troubles is to add to your data a small header containing a unique message identifier. This identifier will allow us to identify precisely a message, remove possible duplication, and treat each in the correct order. You can also ensure that your message is not too big to avoid splitting and losing a part of the data.</p><p>SFML provides<a id="id481" class="indexterm"/> us the <code class="literal">sf::UdpSocket</code> class to communicate using the UDP protocol. This chapter will not cover this kind of socket, but if you are interested in it, take <a id="id482" class="indexterm"/>a look at the SFML tutorial on the official website (<a class="ulink" href="http://www.sfml-dev.org">www.sfml-dev.org</a>).</p></div><div class="section" title="TCP"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec89"/>TCP</h2></div></div></div><p>
<span class="strong"><strong>Transmission Control Protocol</strong></span> (<span class="strong"><strong>TCP</strong></span>) is a connected protocol. This can be compared to a phone conversation. There<a id="id483" class="indexterm"/> are some steps to follow to <a id="id484" class="indexterm"/>understand this protocol:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ask for a connection to an address (phone is ringing)</li><li class="listitem" style="list-style-type: disc">Accept the connection (pick up the phone)</li><li class="listitem" style="list-style-type: disc">Exchange data (talk)</li><li class="listitem" style="list-style-type: disc">Stop the conversation (hang up)</li></ul></div><p>As the protocol is connected, it ensures that the data arrived at the destination is in the same ordering, structure, and consistency as at its source. By the way, we need to specify the destination address only once during the connection. Moreover, if the connection breaks (the problem is on the other side, for example), we can detect it as soon as it happens. The downside of this protocol is that the communication speed is reduced.</p><p>SFML provides us the <code class="literal">sf::TcpSocket</code> class to deal with the TCP protocol easily. This is the one that we will use in our project. I will discuss its usage in the next section.</p></div><div class="section" title="Selector"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec90"/>Selector</h2></div></div></div><p>SFML provides us<a id="id485" class="indexterm"/> with another utility class: <code class="literal">sf::SocketSelector</code>. This class works like an observer on any <a id="id486" class="indexterm"/>kind of socket and holds a pointer to managed sockets, as explained in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">sf::SocketSelector::add(sf::Socket)</code> method to add a socket to observe.</li><li class="listitem">Then, when one or more of the observed sockets receive data, the <code class="literal">sf::SocketSelector::wait()function</code> return. Finally, using <code class="literal">sf::SocketSelector::isReady(sf::Socket)</code>, we can identify which one of the sockets<a id="id487" class="indexterm"/> received data. This allows us to avoid pooling and use real-time reaction.</li></ol></div><p>We will use this <a id="id488" class="indexterm"/>class in this chapter paired with <code class="literal">sf::TcpSocket</code>.</p></div><div class="section" title="The Connection class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec91"/>The Connection class</h2></div></div></div><p>Now that all the basic network bricks have been introduced, it's time for us to think about our game. We need to<a id="id489" class="indexterm"/> decide the way in which our game will exchange data with another player. We will need to send and receive data. To achieve this, we<a id="id490" class="indexterm"/> will use the <code class="literal">sf::TcpSocket</code> class. As each action on the socket will block the execution of our game, we will need to create a system to disable the blocking. SFML provides a <code class="literal">sf::Socket::setBlocking()</code> function, but our solution will use a different method.</p><div class="section" title="The goal of the Connection class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec25"/>The goal of the Connection class</h3></div></div></div><p>If you remember, in <a class="link" href="ch06.html" title="Chapter 6. Boost Your Code Using Multithreading">Chapter 6</a>, <span class="emphasis"><em>Boost Your Code Using Multithreading</em></span>, I told you that networking is mostly managed in a dedicated thread. Our solution will follow this path; the idea is to have an object that<a id="id491" class="indexterm"/> internally manages a thread as transparently as possible to the user. Moreover, we will design the API to be similar to SFML event management from the <code class="literal">sf::Window</code> class. The result of these constraints is the construction of a <code class="literal">Connection</code> class. This class will then be specialized by the architecture that we will choose (described in the next section).</p><p>Let's now take a look at the header of this new class:</p><div class="informalexample"><pre class="programlisting">class Connection
{
  public:
  Connection();
  virtual ~Connection();

  void run();
  void stop();
  void wait();

  bool pollEvent(sf::Packet&amp; event);
  bool pollEvent(packet::NetworkEvent*&amp; event);

  void send(sf::Packet&amp; packet);
  void disconnect();
  int id()const;
  virtual sf::IpAddress getRemoteAddress()const = 0;

  protected:
  sf::TcpSocket _sockIn;
  sf::TcpSocket _sockOut;

  private:
  bool _isRunning;

  void _receive();
  sf::Thread _receiveThread;
  sf::Mutex _receiveMutex;
  std::queue&lt;sf::Packet&gt; _incoming;

  void _send();
  sf::Thread _sendThread;
  sf::Mutex _sendMutex;
  std::queue&lt;sf::Packet&gt; _outgoing;

  static int _numberOfCreations;
  const int _id;
};</pre></div><p>Let's explain this class step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by defining a constructor and a destructor. Notice that the destructor is set to virtual because the class will be specialized.</li><li class="listitem">Then we define<a id="id492" class="indexterm"/> some common functions to deal with the internal thread for synchronization issues.</li><li class="listitem">Some methods to deal with events are then defined. We build two methods to deal with incoming events and one to deal with outgoing messages. The overload on the <code class="literal">pollEvent()</code> function allows us to use raw or parsed data. The <code class="literal">packet::NetworkEvent</code> class will be described later in this chapter. For now, take it as a message similar to <code class="literal">sf::Event</code> with type and data, but coming from the network.</li><li class="listitem">We define a function to close the communication properly.</li><li class="listitem">Finally, we define some functions to get information on the connection.</li></ol></div><p>To be able to work, all these functions require some objects. Moreover, to be as responsive as possible, we will use two sockets: one for incoming messages and the other for outgoing messages. This will allow us to send and receive data at the same time and accelerate the responsiveness of the game. Because of this choice, we will need to duplicate all the other requirements (thread, mutex, queue, and so on). Let's discuss the goal of each one:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sf::TcpSocket</code>: It handles the<a id="id493" class="indexterm"/> communication between the two sides.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sf::Thread</code>: It allows<a id="id494" class="indexterm"/> us to be non-blocking as previously exposed. It will remain alive as long as the connection instance.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sf::Mutex</code>: It protects<a id="id495" class="indexterm"/> the queue of data to avoid data race or use them afterwards for free.</li><li class="listitem" style="list-style-type: disc"><code class="literal">std::queue&lt;sf::Packet&gt;</code>: This is<a id="id496" class="indexterm"/> the queue of events to processes. Each time it is accessed, the associated mutex is locked.</li></ul></div><p>Now that the different objects have been explained, we can continue with the implementation of the class, as follows:</p><div class="informalexample"><pre class="programlisting">Connection::Connection() :_isRunning(false), _receiveThread(&amp;Connection::_receive,this), _sendThread(&amp;Connection::_send,this),_id(++_numberOfCreations) {}
Connection::~Connection() {}</pre></div><p>The constructor doesn't have any function in particular. It simply initializes with the correct value without<a id="id497" class="indexterm"/> launching a different thread. We have a function for that, which is as follows:</p><div class="informalexample"><pre class="programlisting">void Connection::run()
{
  _isRunning = true;
  _receiveThread.launch();
  _sendThread.launch();
}

void Connection::stop() {_isRunning  = false;}

void Connection::wait()
{
  _receiveThread.wait();
  _sendThread.wait();
}</pre></div><p>These three functions manage the lifetime of the different threads by launching, stopping, or keeping them waiting. Notice that a mutex to protect <code class="literal">_isRunning</code> is not necessary because we don't write in it outside of those functions.</p><div class="informalexample"><pre class="programlisting">int Connection::id()const {return _id;}

bool Connection::pollEvent(sf::Packet&amp; event)
{
  bool res = false;
  sf::Lock guard(_receiveMutex);
  if(_incoming.size() &gt; 0)
  {
    std::swap(event,_incoming.front());
    _incoming.pop();
    res = true;
  }
  return res;
}

bool Connection::pollEvent(packet::NetworkEvent*&amp; event)
{
  bool res = false;
  sf::Packet msg;
  if(Connection::pollEvent(msg))
  {
    event = packet::NetworkEvent::makeFromPacket(msg);
    if(event != nullptr)
      res = true;
  }
  return res;
}</pre></div><p>These two functions are important and copy the behavior of the <code class="literal">sf::Window::pollEvent()</code> function, so their usage will not surprise you. What we do here is that we pick up an event from the incoming queue if there is one enabled. The second function also parses the receiving message to a <code class="literal">NetworkEvent</code> function. Most often, we will prefer to use the second method in our code, because all the verifications are already made to be able to exploit the event. This function just adds a packet to the outgoing queue. The job is then done by the <code class="literal">_sendThread</code> object, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Connection::send(sf::Packet&amp; packet)
{
  sf::Lock guard(_sendMutex);
  _outgoing.emplace(packet);
}</pre></div><p>This function<a id="id498" class="indexterm"/> closes the different sockets used. Because we used a connected protocol, the other side of the communication will be able to detect it and manage this at its convenience.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> Connection::disconnect()
{
  _sockIn.disconnect();
  _sockOut.disconnect();
}</pre></div><p>This function is one of the two most important ones. It is run into its own thread—this is the reason for the loop. Moreover, we use the <code class="literal">sf::SocketSelector</code> function to observe our socket. Using this, we avoid useless operations that consume CPU power. Instead, we lock the thread until a message is received on the incoming socket. We also add a timeout of one second to avoid a deadlock, as seen in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Connection::_receive()
{
  sf::SocketSelector selector;
  selector.add(_sockIn);
  while(_isRunning)
  {
if(not selector.wait(sf::seconds(1)))
  continue;
if(not selector.isReady(_sockIn))
  continue;
    sf::Packet packet;
    sf::Socket::Status status = _sockIn.receive(packet);
    if(status == sf::Socket::Done)
    {
      sf::Lock guard(_receiveMutex);
      _incoming.emplace(std::move(packet));
    }
    else if (status == sf::Socket::Disconnected)
    {
      packet.clear();
      packet&lt;&lt;packet::Disconnected();
      sf::Lock guard(_receiveMutex);
      _incoming.emplace(std::move(packet));
      stop();
    }
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>A deadlock is a situation encountered in multithreaded programs where two threads wait indefinitely because they are both waiting for a resource that only the other thread can free up. The most common is a double lock on the same mutex in the same thread, with a recursive call, for example. In the present case, imagine that you use the<a id="id499" class="indexterm"/> <code class="literal">stop()</code> function. The thread is not aware of this change, and will still be waiting for data, maybe forever, because no new data will be received on the socket. An easy solution is to add a timeout to not wait forever, but only a small amount of time that allows us to recheck the loop condition and get out if necessary.</p></div></div><p>Once a packet is<a id="id500" class="indexterm"/> received, or a disconnection is detected, we add the corresponding packet to the queue. The user will then be able to pool in from its own thread and treat it as he wants. The disconnection shows you a specific <code class="literal">NetworkEvent</code> : <code class="literal">Disconnected</code> function. Later in the chapter, I will explain in detail the logic behind this.</p><div class="informalexample"><pre class="programlisting">void Connection::_send()
{
  while(_isRunning)
  {
    _sendMutex.lock();
    if(_outgoing.size() &gt; 0)
    {
      sf::Packet packet = _outgoing.front();
      _outgoing.pop();
      _sendMutex.unlock();
      _sockOut.send(packet);
    }
    else
    {
      _sendMutex.unlock();
    }
  }
}</pre></div><p>This function complements the previous one. It picks up events from the outgoing queue and sends it through the network using its socket.</p><p>As you can see, with the use of classes, we can send and receive data very easily in a multi-threaded environment. Moreover, the disconnection is managed like any other event and doesn't require any special case for the user. Another strength of this class is that it's very <a id="id501" class="indexterm"/>generic and can be used in a lot of cases, including on client and server sides.</p><p>To sum it up, we can visualize the usage of this class as shown in the following chart:</p><div class="mediaobject"><img src="graphics/8477OS_08_01.jpg" alt="The goal of the Connection class"/></div><p>Now that we have designed a class to manage the different messages, let's build our custom protocol.</p></div></div></div>
<div class="section" title="Creating a communication protocol"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Creating a communication protocol</h1></div></div></div><p>It's now time for us to <a id="id502" class="indexterm"/>create our own custom protocol. We will use an SFML class <code class="literal">sf::Packet</code> to transport our data, but we have to define their shapes. Let's first focus on the <code class="literal">sf::Packet</code> class and then<a id="id503" class="indexterm"/> on the shapes.</p><div class="section" title="Using the sf::Packet class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec92"/>Using the sf::Packet class</h2></div></div></div><p>The <code class="literal">sf::Packet</code> class is like a buffer that <a id="id504" class="indexterm"/>contains our data. It comes with already-made functions that allow us to serialize primitive types. I don't know if you are familiar with the internal memory storage of computers, but keep in mind that the arrangement is not the same everywhere. This is called endianness. You can see it like reading from the right or from the left. When you send data over the network, you don't know the endianness of the destination. Because of this, the convention is to send data as<a id="id505" class="indexterm"/> a big-endian arrangement over the network. I suggest you to take a look at the Wikipedia page (<a class="ulink" href="https://en.wikipedia.org/wiki/Endianness">https://en.wikipedia.org/wiki/Endianness</a>) for more details.</p><p>Thanks to SFML, there are some pre-existing functions that make the job easy for us. The only inconvenience is that we have to use SFML types instead of the primitive types. Following is<a id="id506" class="indexterm"/> a table that shows you the primitive types, and the corresponding type to use with <code class="literal">sf::Packet</code>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Primitive</p>
</th><th style="text-align: left" valign="bottom">
<p>SFML overload</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">char</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Int8</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned char</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Uint8</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">short int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Int16</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned short int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Uint16</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::int32</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">sf::Uint32</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float</code> 
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">float</code> 
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">double</code> 
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">double</code> 
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">char*</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">char*</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">std::string</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">std:string</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bool</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">bool</code>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">sf::Packet</code> class is used like the standard c++ I/O streams using the <code class="literal">&gt;&gt;</code> and <code class="literal">&lt;&lt;</code> operators to extract and insert data. Following is an example taken directly from the SFML documentation of the <code class="literal">sf::Packet</code> class that shows you how simple it is in terms of usage:</p><div class="informalexample"><pre class="programlisting">void sendDatas(sf::Socket&amp; socket)
{
  sf::Uint32 x = 24;
  std::string s = "hello";
  double d = 5.89;
  // Group the variables to send into a packet
  sf::Packet packet;
  packet &lt;&lt; x &lt;&lt; s &lt;&lt; d;
  // Send it over the network (socket is a valid sf::TcpSocket)
  socket.send(packet);
}

void receiveDatas(sf::Socket&amp; socket)
{
  sf::Packet packet;
  socket.receive(packet);
  // Extract the variables contained in the packet
  sf::Uint32 x;
  std::string s;
  double d;
  if (packet &gt;&gt; x &gt;&gt; s &gt;&gt; d)
  {
    // Data extracted successfully...
  }
}</pre></div><p>Even if this use is pretty simple, there is another way to send data like structure/class more easily, using the <a id="id507" class="indexterm"/>operator overload. This is the technique that we will use to send/receive data, an example of which is as follows:</p><div class="informalexample"><pre class="programlisting">struct MyStruct
{
  float number;
  sf::Int8 integer;
  std::string str;
};

sf::Packet&amp; operator &lt;&lt;(sf::Packet&amp; packet, const MyStruct&amp; m){
  return packet &lt;&lt; m.number &lt;&lt; m.integer &lt;&lt; m.str;
}

sf::Packet&amp; operator &gt;&gt;(sf::Packet&amp; packet, MyStruct&amp; m){
  return packet &gt;&gt; m.number &gt;&gt; m.integer &gt;&gt; m.str;
}

int main()
{
  MyStruct toSend;
  toSend.number = 18.45f;
  toSend.integer = 42;
  toSend.str = "Hello world!";

  sf::Packet packet;
  packet &lt;&lt; toSend;

  // create a socket

  socket.send(packet);
  //...
}</pre></div><p>With this technique, there are two operators to overload, and the serialization/unserialization is then transparent for the user. Moreover, if the structure changes, there is only one place to update: the operators.</p><p>Now that we have<a id="id508" class="indexterm"/> seen the system to transport our data, let's think about a way to construct it so that it is as generic as possible.</p></div><div class="section" title="RPC-like protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec93"/>RPC-like protocol</h2></div></div></div><p>We now need to think exactly about our needs concerning the data to send. We have already pretty much completed<a id="id509" class="indexterm"/> the job in the first part of this chapter by separating the tasks of the client and the server, but it's not sufficient. We now need a list of all the different possibilities, which have been enlisted here.</p><p>Both sides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connection</li><li class="listitem" style="list-style-type: disc">Disconnection</li><li class="listitem" style="list-style-type: disc">Client event</li></ul></div><p>Log out</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get game list</li><li class="listitem" style="list-style-type: disc">Request for the creation of a game (match)</li><li class="listitem" style="list-style-type: disc">Request to join the game</li><li class="listitem" style="list-style-type: disc">Request to create an entity</li><li class="listitem" style="list-style-type: disc">Request to destroy an entity</li></ul></div><p>Server events</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Entity update</li><li class="listitem" style="list-style-type: disc">Entity's events (onHit, onHitted, onSpawn)</li><li class="listitem" style="list-style-type: disc">Update team (gold, game over)</li><li class="listitem" style="list-style-type: disc">Respond to client events</li></ul></div><p>The good news is that there aren't too many kinds of events; the bad news is that these events don't require the same information, so we can't build only one event, but instead, as many events as the number of possible actions, with their own data.</p><p>But there is now another trouble. How do we recognize which one to use? Well, we need an identifier that allows this. An <code class="literal">enum</code> function will do the job perfectly, as follows:</p><div class="informalexample"><pre class="programlisting">namespace FuncIds{
  enum FUNCIDS {
    //both side
    IdHandler = 0, IdDisconnected, IdLogOut,
    //client
    IdGetListGame, IdCreateGame, IdJoinGame,IdRequestCreateEntity, IdRequestDestroyEntity,
    //server events
    IdSetListGame, IdJoinGameConfirmation, IdJoinGameReject, IdDestroyEntity, IdCreateEntity,  IdUpdateEntity, IdOnHittedEntity, IdOnHitEntity,  IdOnSpawnEntity, IdUpdateTeam
  };
}</pre></div><p>Now that we have a way to differ the actions, we have to send a packet with a common part for all these actions. This part (header) will contain the identifier of the action. Then all actions will add their own data. This is exactly the way that <code class="literal">sf::Event</code> works with the <code class="literal">sf::Event::type</code> attribute.</p><p>We will copy this mechanism to our own system, by building a new class called <code class="literal">NetworkEvent</code>. This <a id="id510" class="indexterm"/>class works as <code class="literal">sf::Event</code> does, except that it also adds serialization/unserialization with the <code class="literal">sf::Packet</code> class, allowing us to send that data across the network easily. Let's now take a look at this new class.</p></div><div class="section" title="The NetworkEvent class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec94"/>The NetworkEvent class</h2></div></div></div><p>The<a id="id511" class="indexterm"/> <code class="literal">NetworkEvent</code> class is built inside the <code class="literal">book::packet</code> namespace. Now that we have an idea of the global<a id="id512" class="indexterm"/> shape of our data to send, it's time for us to build some classes that will help us to deal with them.</p><p>We will build one class for each event, with a common parent, the <code class="literal">NetworkEvent</code> class. This class will allow us to use polymorphism. Following is its header:</p><div class="informalexample"><pre class="programlisting">class NetworkEvent
{
  public:
  NetworkEvent(FuncIds::FUNCIDS type);
  virtual ~NetworkEvent();

  FuncIds::FUNCIDS type()const;
  static NetworkEvent* makeFromPacket(sf::Packet&amp; packet);

  friend sf::Packet&amp; operator&gt;&gt;(sf::Packet&amp;, NetworkEvent&amp; self);
  friend sf::Packet&amp; operator&lt;&lt;(sf::Packet&amp;, const NetworkEvent&amp; self);

  protected:
  const FuncIds::FUNCIDS _type;
};</pre></div><p>As you can see, this class is very short and only contains its type. The reason is that it's the only common point with all the different events. It also contains some default operator and an<a id="id513" class="indexterm"/> important function: <code class="literal">makeFromPacket()</code>. This function, as you will see, constructs the <a id="id514" class="indexterm"/>correct events depending on the data stored inside the <code class="literal">sf::Packet</code> received as<a id="id515" class="indexterm"/> parameter. Now take a look at the implementation:</p><div class="informalexample"><pre class="programlisting">NetworkEvent::NetworkEvent(FuncIds::FUNCIDS type) : _type(type){}
NetworkEvent::~NetworkEvent(){}</pre></div><p>As usual, the constructor and the destructor are very simple and should be familiar:</p><div class="informalexample"><pre class="programlisting">NetworkEvent* NetworkEvent::makeFromPacket(sf::Packet&amp; packet)
{
  sf::Uint8 type;
  NetworkEvent* res = nullptr;
  packet&gt;&gt;type;
  switch(type)
  {
    case FuncIds::IdDisconnected :
    {
      res = new Disconnected();
      packet&gt;&gt;(*static_cast&lt;Disconnected*&gt;(res));
    }break;

    //... test all the different  FuncIds

    case FuncIds::IdUpdateTeam :
    {
      res = new UpdateTeam();
      packet&gt;&gt;(*static_cast&lt;UpdateTeam*&gt;(res));
    }break;
  }
return res;
}</pre></div><p>The preceding function is very important. This is the one that will parse data received from the network to an instance of <code class="literal">NetworkEvent</code> with respect to the type received. The programmer will then use this instance instead of <code class="literal">sf::Packet</code>. Notice that an allocation is made inside this function, so a delete has to be made on the returned object after use:</p><div class="informalexample"><pre class="programlisting">FuncIds::FUNCIDS NetworkEvent::type()const {return _type;}</pre></div><p>The previous function return the type associated to the <code class="literal">NetworkEvent</code>. It allows the programmer to cast the instance into the correct class.</p><div class="informalexample"><pre class="programlisting">sf::Packet&amp; operator&gt;&gt;(sf::Packet&amp; packet, NetworkEvent&amp; self)
{
    return packet;
}

sf::Packet&amp; operator&lt;&lt;(sf::Packet&amp; packet, const NetworkEvent&amp; 
  self)
{
  packet&lt;&lt;sf::Uint8(self._type);
  return packet;
}</pre></div><p>These two functions are in charge of the serialization/unserialization functionality. Because the unserialization function (<code class="literal">&gt;&gt;</code> operator) is only called inside the <code class="literal">makeFromPacket()</code> function and the type has already been extracted, this one does nothing. On the other hand, the serialization function (<code class="literal">&lt;&lt;</code> operator) adds the type of the event to the <a id="id516" class="indexterm"/>packet, as there is no other data.</p><p>I will now show you one of the event classes. All the others are built on the same logic, and I'm sure that you already understand how it is done.</p><p>Let's take the <code class="literal">RequestCreateEntity</code> class. This class contains the different data to request the creation of an entity on the battlefield:</p><div class="informalexample"><pre class="programlisting">namespace EntityType {
  enum TYPES {IdMain = 0,IdEye,IdWormEgg,IdWorm,IdCarnivor,};
}

class RequestCreateEntity : public NetworkEvent
{
  public :
  RequestCreateEntity();
  RequestCreateEntity(short int type,const sf::Vector2i&amp; coord);

  short int getType()const;
  const sf::Vector2i&amp; getCoord()const;

  friend sf::Packet&amp; operator&gt;&gt;(sf::Packet&amp;, RequestCreateEntity&amp; self);
  friend sf::Packet&amp; operator&lt;&lt;(sf::Packet&amp;, const RequestCreateEntity&amp; self);

  private:
  short int _entitytype;
  sf::Vector2i _coord;
};</pre></div><p>First of all, we define an <code class="literal">enum</code> function that will contain all the identifiers for the entities, and then the class that requests their construction. The <code class="literal">RequestCreateEntity</code> class inherits from the previous <code class="literal">NetworkEvent</code> class and defines the same functions, plus those specific to the event. Notice that there are two constructors. The default is used in the <code class="literal">makeFromPacket()</code> function, and the other by the programmer to send an event. Take a look now at the following implementation:</p><div class="informalexample"><pre class="programlisting">RequestCreateEntity::RequestCreateEntity() : NetworkEvent(FuncIds::IdRequestCreateEntity){}

RequestCreateEntity::RequestCreateEntity(short int type,const sf::Vector2i&amp; coord) : NetworkEvent(FuncIds::IdRequestCreateEntity), _entitytype(type), _coord(coord) {}

short int RequestCreateEntity::getType()const
{
    return _entitytype;
}

const sf::Vector2i&amp; RequestCreateEntity::getCoord()const {return _coord;}

sf::Packet&amp; operator&gt;&gt;(sf::Packet&amp; packet, RequestCreateEntity&amp; self)
{
  sf::Int8 type;
  sf::Int32 x,y;
  packet&gt;&gt;type&gt;&gt;x&gt;&gt;y;

  self._entitytype = type;
  self._coord.x = x;
  self._coord.y = y;
  return packet;
}</pre></div><p>This function unpacks the different data specific to the event and stores them internally. That's all:</p><div class="informalexample"><pre class="programlisting">sf::Packet&amp; operator&lt;&lt;(sf::Packet&amp; packet, const RequestCreateEntity&amp; self)
{
  packet&lt;&lt;sf::Uint8(self._type)
  &lt;&lt;sf::Int8(self._entitytype)
  &lt;&lt;sf::Int32(self._coord.x)
  &lt;&lt;sf::Int32(self._coord.y);
  return packet;
}</pre></div><p>This function serializes the different data using the SFML object corresponding to the primitive types used.</p><p>As you can see, creating an event is really simple with this system. It only requires an identifier for its<a id="id517" class="indexterm"/> class along with some parsing functions. All the other events are built on the same model as this one, so I will not explain them. To see the complete code, you can take a look at the <code class="literal">include/SFML-Book/common/Packet.hpp</code> file if you want.</p><p>Now that we have all<a id="id518" class="indexterm"/> the keys in hand to build the multiplayer part, it's time for us to modify our game.</p></div></div>
<div class="section" title="Modifying our game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Modifying our game</h1></div></div></div><p>To add this functionality to our<a id="id519" class="indexterm"/> game, we will need to rethink the internal structure a bit. First of all, we need to split our code to build two different programs. All the common classes (such as those used for communication) will be put into a common directory. All the other functionalities will be put into the server or client folder with respect to their usage. Let's start with the most complicated part: the server.</p><div class="section" title="Server"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec95"/>Server</h2></div></div></div><p>The server will be in charge of all the simulation. In fact, all our game will reside in the server. Moreover, it will have to ensure the possibility of having multiple matches running at the same time. It will also<a id="id520" class="indexterm"/> have to deal with connections/disconnections and player events.</p><p>Because the server will not render anything, we don't need any graphic class anymore on this side. So the <code class="literal">AnimatedSprite</code> function in the <code class="literal">CompSkin</code> component will have to be removed, as will the <code class="literal">sf::RectangleShape</code> component in the <code class="literal">CompHp</code> function.</p><p>Because the positions of the entities were stored by the <code class="literal">CompSkin</code> component (more precisely <code class="literal">_sprite</code>), we have to add an <code class="literal">sf::Vector2f</code> function in each entity that will store its position.</p><p>The main loop will also be changed a lot. Remember that we need to manage multiple clients and matches and listen for a new connection on a specific port. So to be able to do this, we will build a <code class="literal">Server</code> class, and each match will have its own game instance running in its own thread. So let's do this:</p><div class="section" title="Building the Server entry point"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec26"/>Building the Server entry point</h3></div></div></div><p>The server class will be in charge to manage new clients, to create new matches and to add clients to existing matches. This class can be seen like the main menu of the game. By the way the corresponding display on the player screen will be as follows:</p><div class="mediaobject"><img src="graphics/8477OS_08_04.jpg" alt="Building the Server entry point"/></div><p>So, we will need to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Store the running match (games)</li><li class="listitem" style="list-style-type: disc">Store the new clients</li><li class="listitem" style="list-style-type: disc">Listen for new clients</li><li class="listitem" style="list-style-type: disc">Respond to some request (create a new match, joint a match, get the list of running match)</li></ul></div><p>Let's now build the server class.</p><div class="informalexample"><pre class="programlisting">class Server
{
    public:
        Server(int port);
        ~Server();
        void run(); 
    private:
        const unsigned int _port;
        void runGame();
        void listen();

        sf::Thread _gameThread;
        sf::Mutex _gameMutex;
        std::vector&lt;std::shared_ptr&lt;Game&gt;&gt; _games;

        sf::Mutex _clientMutex;
        std::vector&lt;std::shared_ptr&lt;Client&gt;&gt; _clients;

        sf::Thread _listenThread;
        sf::TcpListener _socketListener;
        std::shared_ptr&lt;Client&gt; _currentClient;
};</pre></div><p>This class handle all the information describe above, and some threads to run separated functionalities independently (logging and request). Now take a look to its implementation:</p><p>First of all we need to declare some global variable and function as followed:</p><div class="informalexample"><pre class="programlisting">sig_atomic_t stop = false;
void signalHandler(int sig) {stop = true;}</pre></div><p>The previous function will be call when the user will ask to stop the server by pressing the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> key. This mechanism is initialized in the <code class="literal">Server::run()</code> function as you will see in a moment..</p><div class="informalexample"><pre class="programlisting">Server::Server(int port) : 
  _port(port),_gameThread(&amp;Server::runGame,this),_listenThread(&amp;Server::listen,this)
{
  rand_init();
  _currentClient = nullptr;
}</pre></div><p>The previous function initialize the different threads, and the random function.</p><div class="informalexample"><pre class="programlisting">Server::~Server()
{
  _gameMutex.lock();
  for(Game* game : _games)
  game-&gt;stop()
  _gameMutex.unlock();
  _clientMutex.lock();
  for(Client* client : _clients)
  client-&gt;stop();
  _clientMutex.unlock();
}</pre></div><p>Here, we destroy all the running matches and clients to stop the server properly.</p><div class="informalexample"><pre class="programlisting">void Server::run()
{
  std::signal(SIGINT,signalHandler);
  _gameThread.launch();
  _listenThread.launch();
  _gameThread.wait();
  _listenThread.terminate();
}</pre></div><p>This function start the<a id="id521" class="indexterm"/> server that is blocked until the <code class="literal">SIGINT</code> (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>c</em></span>) signal is sent to it:</p><div class="informalexample"><pre class="programlisting">void Server::runGame()
{
  while(!stop)
  {
    sf::Lock guard(_clientMutex);
    for(auto it = _clients.begin(); it != _clients.end();++it)//loop on clients
    {
      std::shared_ptr&lt;Client&gt; client = *it; //get iteration current client
      packet::NetworkEvent* msg;
      while(client and client-&gt;pollEvent(msg)) //some events incomings
      {
        switch(msg-&gt;type()) //check the type
        {
          case FuncIds::IdGetListGame :
          {
            sf::Packet response;
            packet::SetListGame list;
            sf::Lock guard(_gameMutex);
            for(Game* game : _games) { //send match informations
            list.add(game-&gt;id(),game-&gt;getPlayersCount(),game-&gt;getTeamCount());
          }
          response&lt;&lt;list;
          client-&gt;send(response);
        }break;
        case FuncIds::IdCreateGame :
        {
          sf::Packet response;
          packet::SetListGame list;
          sf::Lock guard(_gameMutex);
          _games.emplace_back(new Game("./media/map.json")); //create a new match
          for(Game* game : _games){ //send match informations
          list.add(game-&gt;id(),game-&gt;getPlayersCount(),game-&gt;getTeamCount());
        }
        //callback when a client exit a match
        _games.back()-&gt;onLogOut = [this](std::shared_ptr&lt;Client&gt; client){
          _clients.emplace_back(client);
        };
        _games.back()-&gt;run(); //start the match
        response&lt;&lt;list;
        for(auto it2 = _clients.begin(); it2 != _clients.end();++it2){ //send to all client
        (*it2)-&gt;send(response);
      }
    }break;
    case FuncIds::IdJoinGame :
    {
      int gameId = static_cast&lt;packet::JoinGame*&gt;(msg)-&gt;gameId()
      sf::Lock guard(_gameMutex); 
      //check if the player can really join the match
      for(auto game : _games) {
        if(game-&gt;id() == gameId) {
          if(game-&gt;addClient(client)){ //yes he can
          client = nullptr;
          it = _clients.erase(it); //stop to manage the client here. Now the game do it
          --it;
        }
        break;
      }
    }
  }break;
  case FuncIds::IdDisconnected : //Oups, the client leave the game
  {
    it = _clients.erase(it);
    --it;
    client = nullptr;
  }break;
  default : break;
}
delete msg;
}</pre></div><p>This function is the server's most important function. This is the one that handles all the events coming from players. For each client, we check if there is an event waiting to be processed, and then, depending on its type, we take different actions. Thanks to our <code class="literal">NetworkEvent</code> class, the<a id="id522" class="indexterm"/> parsing on the event is easy, and we can reduce the code to the functionalities only:</p><div class="informalexample"><pre class="programlisting">void Server::listen()
{
  if(_socketListener.listen(_port) != sf::Socket::Done) {
    stop = true;
    return;
  }
  _currentClient =   new Client;
  while(!stop)
  {
    if (_socketListener.accept(_currentClient-&gt;getSockIn()) == sf::Socket::Done) {
      if(_currentClient-&gt;connect()) {
        sf::Lock guard(_clientMutex);
        _clients.emplace_back(_currentClient);
        _currentClient-&gt;run();
        _currentClient = new Client;
      }
      else {
        _currentClient-&gt;disconnect();
      }
    }
  }
}</pre></div><p>This function is the final function of the server. Its job is to wait for a new connection, initialize the client, and add it to the list managed by the previous function.</p><p>Nothing else has to be done in this class since as soon as the client joins a match, it's the match and no more the <code class="literal">Server</code> class that will have to deal with it. Each match is managed by a <code class="literal">Game</code> instance. Let's now take a look at it.</p></div><div class="section" title="Reacting to players' actions during a match"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec27"/>Reacting to players' actions during a match</h3></div></div></div><p>The <code class="literal">Game</code> class hasn't <a id="id523" class="indexterm"/>changed a lot. The event processing has changed, but is still very similar to the original system. Instead of using <code class="literal">sf::Event</code>, we now use <code class="literal">NetworkEvent</code>. And because the API is very close, it should not disturb you too much.</p><p>The first function that interacts with a player is the one that receives the match information. For example, we need to send it to the map file and all the different entities. This task is<a id="id524" class="indexterm"/> created by the <code class="literal">Game::addClient()</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">bool Game::addClient(Client* client)
{
    sf::Lock guard(_teamMutex);
    Team* clientTeam = nullptr;
    for(Team* team : _teams)
    {
        // is there any team for the player
        if(team-&gt;getClients().size() == 0 and team-&gt;isGameOver())
        { //find it
            clientTeam = team;
            break;
        }
    }

    sf::Packet response;
    if(clientTeam != nullptr)
    {
        //send map informations
        std::ifstream file(_mapFileName);
        //get file content to as std::string
        std::string content((std::istreambuf_iterator&lt;char&gt;(file)),(std::istreambuf_iterator&lt;char&gt;()));

        packet::JoinGameConfirmation conf(content,clientTeam-&gt;id());//send confirmation

        for(Team* team : _teams)
        { //send team datas
            packet::JoinGameConfirmation::Data data;
            data.team = team-&gt;id();
            data.gold = team-&gt;getGold();
            data.color = team-&gt;getColor();
            conf.addTeam(std::move(data));
        }

        response&lt;&lt;conf;
        client-&gt;send(response);
        {
            //send initial content
            response.clear();
            sf::Lock gameGuard(_gameMutex);
            packet::CreateEntity datas; //entites informations
            for(auto id : entities)
                addCreate(datas,id);
            response&lt;&lt;datas;
            client-&gt;send(response);
        }

        client-&gt;setTeam(clientTeam);
        sf::Lock guardClients(_clientsMutex);
        _clients.emplace_back(client);
    }
    else
    { //Oups, someone the match is already full
        response&lt;&lt;packet::JoinGameReject(_id);
        client-&gt;send(response);
    }
    return clientTeam != nullptr;
}</pre></div><p>This function is separated into four parts:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Checking if we can add a new player to the match.</li><li class="listitem">Sending map data.</li><li class="listitem">Sending entity informations.</li><li class="listitem">Adding the client to the team.</li><li class="listitem">Once a client has been added to the game, we have to manage its incoming events. This<a id="id525" class="indexterm"/> task is made by the new function <code class="literal">processNetworkEvents()</code>. It works exactly as the old <code class="literal">processEvents()</code> function, but with <code class="literal">NetworkEvent</code> instead of <code class="literal">sf::Events</code>:<div class="informalexample"><pre class="programlisting">void Game::processNetworkEvents()
{
    sf::Lock guard(_clientsMutex);
     for(auto it = _clients.begin(); it != _clients.end();++it)
    {
         auto client = *it;
         packet::NetworkEvent* msg;
          while(client and client-&gt;pollEvent(msg))
         {
              switch(msg-&gt;type())
              {
                   case FuncIds::IdDisconnected :
                   {
                       it = _clients.erase(it);
                       --it;
                       delete client;
                       client = nullptr;
                   }break;

                   case FuncIds::IdLogOut :
                   {
                       it = _clients.erase(it);
                       --it;
                       client-&gt;getTeam()-&gt;remove(client);
                       onLogOut(client); //callback to the server
                        client = nullptr;
                   }break;

                   case FuncIds::IdRequestCreateEntity :
                   {
                       packet::RequestCreateEntity* event = static_cast&lt;packet::RequestCreateEntity*&gt;(msg);
                       sf::Lock gameGuard(_teamMutex);
                        // create the entity is the team as enough money
                   }break;

                   case FuncIds::IdRequestDestroyEntity :
                   {
                       packet::RequestDestroyEntity* event = static_cast&lt;packet::RequestDestroyEntity*&gt;(msg);
                       // destroy the entity if it shares the same team as the client
                   }break;
                    default : break;
               } //end switch           } //end while       } //end for 
}</pre></div></li></ol></div><p>There's no surprise here. We have to deal with the possible client disconnection/logout, and then with all the different events. I don't have to put the entire code of the different events, as there is nothing complicated there. But if you are interested, take a look at the <code class="literal">src/SFML-Book/server/Game.cpp</code> file.</p><p>Notice that we <a id="id526" class="indexterm"/>never send any confirmation to the client for any request. The synchronization of the game will ensure this.</p></div><div class="section" title="Synchronization between clients and the server"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec28"/>Synchronization between clients and the server</h3></div></div></div><p>A big change in the <code class="literal">Game</code> class is the way to manage the synchronization between the clients and the<a id="id527" class="indexterm"/> server. In the previous chapter, only one client received data. Now we have some of the clients, and the logic changes. To ensure synchronization, we have to send updates to clients.</p><p>To be able to send the updates, we have to keep in memory each change during the game loop, and then send them to all the players. Because a request will change the game, it will be included in the updates. This is why in the previous points we don't send any response to the player for the requests. In the game, we will need to keep track of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Entity creation</li><li class="listitem" style="list-style-type: disc">Entity destruction</li><li class="listitem" style="list-style-type: disc">Entity updates </li><li class="listitem" style="list-style-type: disc">Entity events (onHitted, onHit, onSpawn)</li><li class="listitem" style="list-style-type: disc">Update of team status, gold amount, and so on</li></ul></div><p>Most of these events only require the entity ID without any other information (destruction entity events). For other events, some extra data is required, but the logic is still the same: add the information to a container.</p><p>Then, in the <code class="literal">Game::update()</code> function, we have to send the updates to all the players. To do this, we add to a queue the outgoing events (exactly as in the <code class="literal">Connection</code> class). Another thread will be in charge of their propagation.</p><p>Here is a code snippet that makes the destruction event:</p><div class="informalexample"><pre class="programlisting">if(_destroyEntityId.size() &gt; 0)
{
  packet::DestroyEntity update;
  for(auto id : _destroyEntityId)
  update.add(id);
  sf::Packet packet;
  packet&lt;&lt;update;
  sendToAll(packet);
  _destroyEntityId.clear();
}</pre></div><p>As you can see, there is no complexity here, and all the magic is done by the <code class="literal">sendToAll()</code> function. As you can suppose, its aim is to broadcast the message to all the different players by adding the packet to the outgoing queue. Another thread will then enter that queue to broadcast the message.</p><p>In terms of the game's<a id="id528" class="indexterm"/> logic, nothing else has changed. We still use the entity system and the map to manage the level. Only the graphical elements have been deleted. It is the client's job to display on the screen the game state to the player, speaking of which, let's now look into this part in detail.</p></div></div><div class="section" title="The Client class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec96"/>The Client class</h2></div></div></div><p>This is the final part of this chapter. The client is even simpler than the server, since it only has one player to manage but is still a bit complex. The client will have a graphical rendering but no more game logic. The only job made by the client is handling player inputs and updating the game states with the incoming network events.</p><p>Because starting a client is now<a id="id529" class="indexterm"/> not sufficient to start a match, we have to communicate with the server to initialize a game, or even create a new<a id="id530" class="indexterm"/> match. In fact, a client is composed of two main components: the connection menu and the game. The client game class has changed a lot to handle the new functionalities, which is why I will now show you the new <code class="literal">Game</code> header before continuing the explanation:</p><div class="informalexample"><pre class="programlisting">class Game
{
  public:
  Game(int x=1600, int y=900);
  ~Game();
  bool connect(const sf::IpAddress&amp; ip, unsigned short port,sf::Time timeout=sf::Time::Zero);
  void run(int frame_per_seconds=60);
  private:
  void processEvents();
  void processNetworkEvents();
  void update(sf::Time deltaTime);
  void render();
  bool _asFocus; 
  sf::RenderWindow _window;
  sf::Sprite _cursor;
  Client _client;
  bool _isConnected;
  enum Status {StatusMainMenu,StatusInGame, StatusDisconnected} _status;
  MainMenu _mainMenu;
  GameMenu _gameMenu;
  Level* _level;
  Level::FuncType _onPickup;
  int _team;
};</pre></div><p>As you can see, there are some new functions to manage the network, and the GUI has been separated in other classes (<code class="literal">MainMenu</code>, <code class="literal">GameMenu</code>). On the other hand, some classes such as <code class="literal">Level</code> haven't changed.</p><p>Now let's take a<a id="id531" class="indexterm"/> look at the main menu.</p><div class="section" title="Connection with the server"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec29"/>Connection with the server</h3></div></div></div><p>Before starting a match, a connection to the server is required, following which we have to choose which match we want to play. The connection is achieved exactly as in the server, but in the reverse order (changing received to send, and vice versa).</p><p>The choice of the<a id="id532" class="indexterm"/> match is then made by the player. He has to be able to create a new match and join it as well. To simplify this, we will use our GUI by creating a <code class="literal">MainMenu</code> class:</p><div class="informalexample"><pre class="programlisting">class MainMenu : public sfutils::Frame
{
  public:
  MainMenu(sf::RenderWindow&amp; window,Client&amp; client);
  void fill(packet::SetListGame&amp; list);
  private:
  Client&amp; _client;
};</pre></div><p>This class is very small. It's a frame with several buttons, as you can see in the following image:</p><div class="mediaobject"><img src="graphics/8477OS_08_04.jpg" alt="Connection with the server"/></div><p>The implementation of<a id="id533" class="indexterm"/> this class is not too complicated; rather much more consequential:</p><div class="informalexample"><pre class="programlisting">MainMenu::MainMenu(sf::RenderWindow&amp; window,Client&amp; client) : sfutils::Frame(window,Configuration::guiInputs), _client(client)
{
        setLayout(new sfutils::Vlayout);
}
                                                                                                                               
void MainMenu::fill(packet::SetListGame&amp; list)
{
    clear();
    sfutils::VLayout* layout = static_cast&lt;sfutils::VLayout*&gt;(Frame::getLayout());
    {
        sfutils::TextButton* button = new sfutils::TextButton("Create game");
        button-&gt;setCharacterSize(20);
        button-&gt;setOutlineThickness(1);
        button-&gt;setFillColor(sf::Color(48,80,197));
        button-&gt;on_click = [this](const sf::Event&amp;, sfutils::Button&amp; button){
            sf::Packet event;
            event&lt;&lt;packet::CreateGame();
            _client.send(event);
        };
        layout-&gt;add(button);
    }

    {
        sfutils::TextButton* button = new sfutils::TextButton("Refresh");
        button-&gt;setCharacterSize(20);
        button-&gt;setOutlineThickness(1);
        button-&gt;setFillColor(sf::Color(0,88,17));
        button-&gt;on_click = [this](const sf::Event&amp;, sfutils::Button&amp; button){
            sf::Packet event;
            event&lt;&lt;packet::GetListGame();
            _client.send(event);
        };
        layout-&gt;add(button);
    }

    for(const autoe&amp; game : list.list())
    {
        std::stringstream ss;
        ss&lt;&lt;"Game ["&lt;&lt;game.id&lt;&lt;"] Players: "&lt;&lt;game.nbPlayers&lt;&lt;"/"&lt;&lt;game.nbTeams;
        sfutils::TextButton* button = new sfutils::TextButton(ss.str());
        button-&gt;setCharacterSize(20);
        button-&gt;setOutlineThickness(1);
        button-&gt;on_click = [this,game](const sf::Event&amp;, sfutils::Button&amp; button){
            sf::Packet event;
            event&lt;&lt;packet::JoinGame(game.id);
            _client.send(event);
        };
        layout-&gt;add(button);
    } //end for
}</pre></div><p>All the logic of the class is coded within the <code class="literal">fill()</code> function. This function receives the list of running matches on the server and displays them as buttons to the player. The player can then press one of the buttons to join the match or request the creation of a game.</p><p>When the player<a id="id534" class="indexterm"/> requests to join the game, if all is good on the server side, the client receives a <code class="literal">JoinGameConfirmation</code> event with the data to initialize its level (remember the <code class="literal">addClient()</code> function in the server):</p><div class="informalexample"><pre class="programlisting">void Game::processNetworkEvents()
{
  packet::NetworkEvent* msg;
  while(_client.pollEvent(msg))
  {
    if(msg-&gt;type() == FuncIds::IdDisconnected) {
      _isConnected = false;
      _status = StatusDisconnected;
    }
    else
    {
      switch(_status)
      {
        case StatusMainMenu:
        {
          switch(msg-&gt;type())
          {
            case FuncIds::IdSetListGame :
            {
              packet::SetListGame* event = static_cast&lt;packet::SetListGame*&gt;(msg);
              _mainMenu.fill(*event);
            }break;
            case FuncIds::IdJoinGameConfirmation :
            {
              packet::JoinGameConfirmation* event = static_cast&lt;packet::JoinGameConfirmation*&gt;(msg);
              // create the level from event
              if(_level != nullptr) {
                _team = event-&gt;getTeamId();
                // initialize the team menu
                _status = StatusInGame;
              }
            }break;
            case FuncIds::IdJoinGameReject :
            {
              //...
            }break;
            default : break;
          }
        }break;
        case StatusInGame :
        {
          _gameMenu.processNetworkEvent(msg);
          _level-&gt;processNetworkEvent(msg);
        }break;
        case StatusDisconnected :
        {
          // ...
                }break;
            } //end switch
        } //end else
        delete msg;
    } //end while
}</pre></div><p>This function handles the events coming from the server and dispatches them depending on the internal states. As you can see, a <code class="literal">JoinGameConfirmation</code> event launches the creation of the<a id="id535" class="indexterm"/> level, and a change of the internal state, which shows by displaying the game to the player.</p></div><div class="section" title="The Level class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec30"/>The Level class</h3></div></div></div><p>Some additions have been<a id="id536" class="indexterm"/> made to the <code class="literal">Level</code> class to handle network events. We still have to deal with construction/destruction requests, but now we also have to manage events coming from the server, such as position update, entity creation/destruction, and entity events.</p><p>This management is very important because this is the place that adds dynamism to our game to<a id="id537" class="indexterm"/> synchronize it with the server. Take a look at the following function:</p><div class="informalexample"><pre class="programlisting">void Level::processNetworkEvent(packet::NetworkEvent* msg)
{
  switch(msg-&gt;type())
  {
    case FuncIds::IdDestroyEntity :
    {//need to destroy an entity
      packet::DestroyEntity* event = static_cast&lt;packet::DestroyEntity*&gt;(msg);
         for(auto id : event-&gt;getDestroy())
           {
                destroyEntity(id);
            }
    }break;
    case FuncIds::IdCreateEntity :
    {//need to create an entity
      packet::CreateEntity* event = static_cast&lt;packet::CreateEntity*&gt;(msg);
      for(const autoa&amp; data : event-&gt;getCreates())
      {
        Entity&amp; e = createEntity(data.entityId,data.coord); //create the entity
        makeAs(data.entityType,e,&amp;_teamInfo.at(data.entityTeam),*this,data); //add the components
      }
    }break;
    case FuncIds::IdUpdateEntity :
    {//an entity has changed
      packet::UpdateEntity* event = static_cast&lt;packet::UpdateEntity*&gt;(msg);
      for(const auto&amp; data : event-&gt;getUpdates())
      {
        if(entities.isValid(data.entityId)) //the entity is still here, so we have to update it
        {
          CompSkin::Handle skin = entities.getComponent&lt;CompSkin&gt;(data.entityId);
          CompHp::Handle hp = entities.getComponent&lt;CompHp&gt;(data.entityId);
          //... and other updates
          hp-&gt;_hp = data.hp;
        }
      }
    }break;
    case FuncIds::IdOnHittedEntity :
    {//entity event to launch
      packet::OnHittedEntity* event = static_cast&lt;packet::OnHittedEntity*&gt;(msg);
      for(const auto&amp; data : event-&gt;getHitted())
      {
        if(entities.isValid(data.entityId))
        {
          Entity&amp; e = entities.get(data.entityId);
          if(e.onHitted and entities.isValid(data.enemyId)) //to avoid invalid datas
          {
            Entity&amp; enemy = entities.get(data.enemyId);
            //call the callback
            e.onHitted(e,_map-&gt;mapPixelToCoords(e.getPosition()), enemy, _map-&gt;mapPixelToCoords(enemy.getPosition()),*this);
          }
        }
      }
    }break;
    case FuncIds::IdOnHitEntity :
    {//another event
      //same has previous with e.onHit callback
    }break;
    case FuncIds::IdOnSpawnEntity :
    { //other event
      packet::OnSpawnEntity* event = static_cast&lt;packet::OnSpawnEntity*&gt;(msg);
      for(auto id : event-&gt;getSpawn())
      {
        if(entities.isValid(id))
        {
          Entity&amp; e = entities.get(id);
          CompAISpawner::Handle spawn = entities.getComponent&lt;CompAISpawner&gt;(id);
          if(spawn.isValid() and spawn-&gt;_onSpawn) //check data validity
          {//ok, call the call back
            spawn-&gt;_onSpawn(*this,_map-&gt;mapPixelToCoords(e.getPosition()));
          }
        }
      }
    }break;
    default : break;
  }
}</pre></div><p>As you can see, this function is a bit long. This is because we have to manage six different types of events. The destruction and the creation of entities are easy to make because the major part of the job is done by the <code class="literal">EntityManager</code> function. The updates are another piece of cake. We have to change each value to the new one, one by one, or activate the callbacks for the entity events with all the necessary verifications; remember <span class="emphasis"><em>don't trust user inputs</em></span>, even if they come from the server.</p><p>Now that the major part of the game has been made, we just have to clean all the unnecessary components from the client to only have <code class="literal">CompTeam</code>, <code class="literal">CompHp</code>, and <code class="literal">CompSkin</code>. All the others are only used by the server for the entities' behavior.</p><p>The final result of this<a id="id538" class="indexterm"/> chapter will not change a lot from the previous one, but you will now be able to play with friends, and the game will become interesting to play because the difficulties are now real:</p><div class="mediaobject"><img src="graphics/8477OS_08_05.jpg" alt="The Level class"/></div></div></div></div>
<div class="section" title="Adding data persistence to the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Adding data persistence to the game</h1></div></div></div><p>If, like me, you can't imagine a game without a save option, this part couldn't interest you more. In this<a id="id539" class="indexterm"/> final part of the book, I will introduce you to the persistence of data. Data persistence is the ability of a program to save its internal state for future restoration. This is exactly what a save option<a id="id540" class="indexterm"/> does in a game. In our particular case, because the client received data directly from the server, all the jobs have to be done on the server part. First of all, let's think a bit about what we need to save:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The entities and their components</li><li class="listitem" style="list-style-type: disc">The teams</li><li class="listitem" style="list-style-type: disc">The games</li></ul></div><p>We then need a way to store that data to be able to restore it later. The solution is to use files or something else that can grow with time, as easy to copy. For this functionality, I've made the choice of using <a id="id541" class="indexterm"/>
<code class="literal">Sqlite</code>. This is a database engine available as library. More information can be found on the website at <a class="ulink" href="https://sqlite.org/">https://sqlite.org/</a>.</p><p>The usage of a database engine is a bit of overkill for our project, but the goal here is to show you its usage in our actual game. Then you will be able to use it for more complex projects of your creation. The persistence data will be stored in a database that is a single file, which can easily be copied or modified using some GUI for <code class="literal">Sqlite</code>.</p><p>The only drawback of this solution is that some knowledge on the SQL language is required. Because<a id="id542" class="indexterm"/> this book doesn't aim to cover that topic, I propose to you an alternative usage: <span class="strong"><strong>Object-relational Mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>).</p><div class="section" title="What is ORM?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec97"/>What is ORM?</h2></div></div></div><p>To say as simply<a id="id543" class="indexterm"/> as possible, an ORM is between the database engine and the API of the program and automatically<a id="id544" class="indexterm"/> makes the SQL query when it's needed without the need to write it by hand. Moreover, most of them support multiple database engines, allowing you to change the engine with only one or two lines of code.</p><p>Following is an example that will help illustrate my words (in pseudo code). First, using a standard library:</p><div class="informalexample"><pre class="programlisting">String sql = "SELECT * from Entity WHERE id = 10"
SqlQuery query(sql);
SqlResults res = query.execute();
Entity e;
e.color = res["color"];
//.. other initializations</pre></div><p>And now using an ORM:</p><div class="informalexample"><pre class="programlisting">Entity e = Entity::get(10);
// color is already load and set</pre></div><p>As you can see, all is made by the ORM without the need to write anything. This remains exactly the same when it comes to saving data. Just use the <code class="literal">save()</code> method, and that's it.</p></div><div class="section" title="Using cpp-ORM"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec98"/>Using cpp-ORM</h2></div></div></div><p>We will use the <code class="literal">cpp-ORM</code> library <a id="id545" class="indexterm"/>which was written by me, so there is no<a id="id546" class="indexterm"/> trouble to use it in our project. It can be found at <a class="ulink" href="https://github.com/Krozark/cpp-ORM">https://github.com/Krozark/cpp-ORM</a>.</p><p>To be able to work, the<a id="id547" class="indexterm"/> library needs some information on your class; this is why some custom types have to be used for the data that you want to save.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>ORM types</p>
</th><th style="text-align: left" valign="bottom">
<p>C++ types</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>orm::BooleanField </p>
</td><td style="text-align: left" valign="top">
<p> bool</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::CharField&lt;N&gt; </p>
</td><td style="text-align: left" valign="top">
<p>std::string (of length N)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::DateTimeField </p>
</td><td rowspan="3" style="text-align: left" valign="top">
<p>struct tm</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::AutoDateTimeField </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::AutoNowDateTimeField</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::IntegerField </p>
</td><td style="text-align: left" valign="top">
<p>int</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::FloatField </p>
</td><td style="text-align: left" valign="top">
<p>float</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::DoubleField </p>
</td><td style="text-align: left" valign="top">
<p>double</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::TextField </p>
</td><td style="text-align: left" valign="top">
<p>std::string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::UnsignedIntegerField </p>
</td><td style="text-align: left" valign="top">
<p>unsigned int</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::FK&lt;T,NULLABLE=true&gt;</p>
</td><td style="text-align: left" valign="top">
<p>std::shared_ptr&lt;T&gt; NULLABLE specify if T can be null</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>orm::ManyToMany&lt;T,U&gt;</p>
</td><td style="text-align: left" valign="top">
<p>std::vector&lt;std::shared_ptr&lt;U&gt;&gt; Use it when T need to keep an unknown number of reference of U class</p>
</td></tr></tbody></table></div><p>Moreover, your class will need to have a default constructor with no parameters, and extends from  <a id="id548" class="indexterm"/>
<code class="literal">orm::SqlObject&lt;T&gt;</code> where <code class="literal">T</code> is your class name. To<a id="id549" class="indexterm"/> understand well, let's build a component as persistent, such as <code class="literal">CompHp</code>:</p><div class="informalexample"><pre class="programlisting">class CompHp : public sfutils::Component&lt;CompHp,Entity&gt;, public orm::SqlObject&lt;CompHp&gt;
{
  public:
  CompHp(); //default constructor
  explicit CompHp(int hp);
  orm::IntegerField _hp; //change the type to be persistent
  orm::IntegerField _maxHp; //here again
  //create column for the query ability (same name as your attributes)
  MAKE_STATIC_COLUMN(_hp,_maxHp); 
};</pre></div><p>There is not much to explain. We just add <code class="literal">orm::SqlObject&lt;CompHp&gt;</code> as the parent class and change <code class="literal">int</code> to <code class="literal">orm::IntegerField</code>. The <code class="literal">MAKE_STATIC_COLUMN</code> is used to create some additional fields that will contain the column name of each field in the database. With regards to the implementation, there is another macro to avoid repetitive work: <code class="literal">REGISTER_AND_CONSTRUCT</code>. Its usage is as follows:</p><div class="informalexample"><pre class="programlisting">REGISTER_AND_CONSTRUCT(CompHp,"CompHp",\
_hp,"hp",\
_maxHp,"maxHp")</pre></div><p>This macro will construct the entire default constructor implementation. Then, in your code, use the field as <a id="id550" class="indexterm"/>usual. There is no need to change anything concerning your class. </p><p>The last requirement is to reference the default database to use. In our case, we will use the <code class="literal">Sqlite3</code> engine, so we need to create it somewhere, for example, in the <code class="literal">main.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">#include &lt;ORM/backends/Sqlite3.hpp&gt;
orm::Sqlite3DB def("./08_dataPersistence.sqlite"); //create the database (need to be include before file that use SqlObject)
orm::DB&amp; orm::DB::Default = def;//set the default connection (multi connection is possible)
#include &lt;ORM/core/Tables.hpp&gt;
#include &lt;SFML-Book/server/Server.hpp&gt;
int main(int argc, char* argv[])
{
  // get port parameter
  orm::DB::Default.connect(); //connect to the database
  orm::Tables::create(); //create all the tables if needed
  book::Server server(port);
  server.run();
  orm::DB::Default.disconnect(); //disconnect the database
  return 0;
}</pre></div><p>In this short example, the database is created and the connection connected to it. It's important to keep in mind that all the access to the database will use the default connection by default. </p></div><div class="section" title="Turning our object persistent"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec99"/>Turning our object persistent</h2></div></div></div><p>Now that the database is created, we don't need to touch it anymore. Now let's interest ourselves with how to save our objects in the database or restore them.</p><div class="section" title="Saving an object in a database"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec31"/>Saving an object in a database</h3></div></div></div><p>This functionality is very simple thanks to the entity system<a id="id551" class="indexterm"/>. Let's take our previous <code class="literal">CompHp</code> class. Create an instance of it and call the <code class="literal">.save()</code> method on it. If you want to update an object already stored in the database, use <code class="literal">save()</code> as well. Only the field that changes will be updated:</p><div class="informalexample"><pre class="programlisting">CompHp chp;
chp._hp = 42;
chp.save();
//oups I've forgotten the other field
chp._maxHp = 42;
chp.save();
std::cout&lt;&lt;"My id is now "&lt;&lt;chp.getPk()&lt;&lt;std::endl;</pre></div><p>Now let's move<a id="id552" class="indexterm"/> on to the object loading.</p></div><div class="section" title="Loading an object from the database"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec32"/>Loading an object from the database</h3></div></div></div><p>There are basically two ways<a id="id553" class="indexterm"/> to load an object. The first one is when you know its primary key (identifier), and the second one is to search all the objects corresponding to a specific criterion:</p><div class="informalexample"><pre class="programlisting">CompHp::type_ptr chp = CompHp::get(10); //load from database
//chp.getPk() = -1 on error, but chp is a valid object so you can use it
std::cout&lt;&lt;"My id is "&lt;&lt;chp-&gt;getPk()&lt;&lt;" And my content is "&lt;&lt;*chp&lt;&lt;std::endl;</pre></div><p>These two lines of code load an object from the database and then display its content to the console output. On the other hand, if you don't know the identifier value but you have a specific criterion, you can also load objects in the following manner:</p><div class="informalexample"><pre class="programlisting">CompHp::result_type res;
CompHp::query()
.filter(
  orm::Q&lt;CompHp&gt;(25,orm::op::gt,CompHp::$_hp)
  and orm::Q&lt;CompHp&gt;(228,orm::op::lte,CompHp::$_maxHp)
  or (orm::Q&lt;CompHp&gt;(12,orm::op::gt,CompHp::$_hp) and orm::Q&lt;CompHp&gt;(25,orm::op::exact,CompHp::$_maxHp))
)// (_hp &gt; 25) and (_maxHp &lt;= 228) or (_hp &gt; 12 and _maxHp ==25 )
. orderBy(CompHp::$_hp,'+')// could be +,-,?
.limit(12) //only the first 12 objects
.get(res);
for(auto chp : res)
std::cout&lt;&lt;"My id is "&lt;&lt;chp-&gt;getPk()&lt;&lt;" And my content is "&lt;&lt;*chp&lt;&lt;std::endl;</pre></div><p>In this example, we get the entire <code class="literal">CompHp</code> component through a complex query and then display the content to the console output.</p><p>Now you have all the keys in hand to add loading/saving into our actual game without too much pain, so I will not enter further into the implementation details.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Summary</h1></div></div></div><p>In this final chapter, you have learned how to add basic networking using sockets, selectors, and even creating a custom protocol. You have integrated this new knowledge to the previous game and turned it into a multiplayer game in real time.</p><p>You have also learned how to add persistence to your data using an ORM, and how to add a save/load option to the game. By now you have seen many aspects of game programming, and you now have all the keys in hand to build every kind of game you want in 2D.</p><p>I hope that this book gives you useful tools. If you want to reuse some part of the framework made across this book, the code is available on GitHub at <a class="ulink" href="https://github.com/Krozark/SFML-utils">https://github.com/Krozark/SFML-utils</a>.</p><p>I hope you have enjoyed reading this book, and developed the games well. I wish you good luck for your future games!</p></div></body></html>