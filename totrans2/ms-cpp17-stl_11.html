<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Random Numbers</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, you learned about regular expressions, a feature that has been part of the C++ standard library since C++11, but which is still little-known by many programmers. You saw that regular expressions are useful in two situations at the opposite ends of the C++ spectrum--in complex programs requiring bulletproof parsing of complicated input formats, and in trivial scripts where the important things are readability and speed of development.</p>
<p class="calibre2">Another library feature that lands squarely in both of these categories is <em class="calibre22">random number generation</em>. Many scripting programs require a little bit of randomness here and there, but C++ programmers have been taught for decades that the classic libc <kbd class="calibre12">rand()</kbd> function is pass√©. At the other end of the spectrum, <kbd class="calibre12">rand()</kbd> is spectacularly inappropriate, both for cryptography and for complicated numerical simulations. The C++11 <kbd class="calibre12">&lt;random&gt;</kbd> library, however, manages to hit all three of these targets.</p>
<p class="calibre2">In this chapter, we'll cover the following topics:</p>
<ul class="calibre14">
<li class="calibre15">The difference between truly random and pseudo-random number sequences</li>
<li class="calibre15">The difference between a <em class="calibre22">generator</em> of random bits and a <em class="calibre22">distribution</em> that produces data values</li>
<li class="calibre15">Three strategies to seed a random number generator</li>
<li class="calibre15">Several standard library generators and distributions, and their use cases</li>
<li class="calibre15">How to shuffle a deck of cards in C++17</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Random numbers versus pseudo-random numbers</h1>
                
            
            <article>
                
<p class="calibre2">When talking about random numbers in the context of computer programming, we must be careful to distinguish between truly random numbers, which come from a physically non-deterministic source, and <em class="calibre22">pseudo-random</em> numbers, which come from an algorithm that deterministically produces a stream of "random-looking" numbers. Such an algorithm is called a <strong class="calibre1">pseudo-random number generator</strong> (<strong class="calibre1">PRNG</strong>). Every PRNG conceptually works the same way--it has some internal <em class="calibre22">state</em>, and it has some way for the user to ask for the <em class="calibre22">next output</em>. Every time we ask for the next output, the PRNG scrambles its internal state according to some deterministic algorithm and returns some piece of that state. Here's an example:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    class SimplePRNG {<br class="title-page-name"/>      uint32_t state = 1;<br class="title-page-name"/>    public:<br class="title-page-name"/>      static constexpr T min() { return 0; }<br class="title-page-name"/>      static constexpr T max() { return 0x7FFF; }<br class="title-page-name"/><br class="title-page-name"/>      T operator()() {<br class="title-page-name"/>        state = state * 1103515245 + 12345;<br class="title-page-name"/>        return (state &gt;&gt; 16) &amp; 0x7FFF;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">This <kbd class="calibre12">SimplePRNG</kbd> class implements a <em class="calibre22">linear congruential generator</em>, which is likely very similar to your standard library's implementation of <kbd class="calibre12">rand()</kbd>. Notice that <kbd class="calibre12">SimplePRNG::operator()</kbd> produces integers in the <kbd class="calibre12">[0, 32767]</kbd> <span>15-bit range,</span> but its internal <kbd class="calibre12">state</kbd> has a 32-bit range. This pattern is true in real-world PRNGs as well.<br class="title-page-name"/>
For example, the standard Mersenne Twister algorithm keeps almost 20 kilobytes of state! Keeping so much internal state means that there are lots of bits to scramble, and only a small fraction of the PRNG's internal state leaks out at each generation. This makes it difficult for a human (or a computer) to predict the PRNG's next output, given only a few of the preceding outputs. The difficulty of predicting its outputs leads us to call this thing a <em class="calibre22">pseudo-random</em> number generator. If its output was full of obvious patterns and easy to predict, we'd probably call it a <em class="calibre22">non-random</em> number generator!</p>
<p class="calibre2">Despite its pseudo-random qualities, a PRNG's behavior is always perfectly <em class="calibre22">deterministic</em>; it follows exactly the algorithm it was coded to follow. If we take a program that uses a PRNG and run it several times in a row, we expect to get the exact same sequence of pseudo-random numbers each time. Its strict determinism leads us to call this thing a <em class="calibre22">pseudo</em>-random number generator.</p>
<p class="calibre2">Another aspect of <em class="calibre22">pseudo-random</em> number generators is that two generators running the exact same algorithm, but with tiny variations in their initial states, will rapidly magnify these variations, <em class="calibre22">diverge</em> from each other, and produce completely different-looking output sequences--just as two drops of water placed in slightly different spots on the back of your hand will run off in completely divergent directions. This means that if we want a different sequence of pseudo-random numbers each time we run our program, all we have to do is make sure that we use a different <em class="calibre22">initial state</em> for our PRNG. Setting a PRNG's initial state is called <em class="calibre22">seeding</em> the PRNG.</p>
<p class="calibre2">We have at least three strategies for seeding our PRNG:</p>
<ul class="calibre14">
<li class="calibre15"><span>Using a seed supplied</span> <em class="calibre22">from outside--</em><span>from the caller or end user.</span> This is the most appropriate for anything that needs reproducibility, such as Monte Carlo simulations or anything that you'll unit test.</li>
<li class="calibre15">Using a predictable but variable seed, such as the current timestamp. Prior to C++11, this was the most common strategy, because the C standard library provides a portable and convenient <kbd class="calibre12">time</kbd> function, but does not provide any portable source of truly random bits. Seeding based on something as predictable as <kbd class="calibre12">time</kbd> is not suitable for anything security-related. As of C++11, you shouldn't ever use this strategy.</li>
<li class="calibre15">Using a <em class="calibre22">truly random</em> seed obtained directly from some platform-specific source of "truly random" bits.</li>
</ul>
<p class="calibre2"><em class="calibre22">Truly random</em> bits are collected by the operating system based on all sorts of random events; a classic approach is for every system call to collect the low-order bits of the hardware cycle counter and XOR them into the operating system's <em class="calibre22">entropy pool</em>. A PRNG deep inside the kernel is periodically reseeded with bits from the entropy pool; the output sequence of that PRNG is exposed to application programmers. On Linux, the raw entropy pool is exposed as <kbd class="calibre12">/dev/random</kbd> and the PRNG's output sequence is exposed as <kbd class="calibre12">/dev/urandom</kbd>. Fortunately, you'll never need to deal with either of those devices directly; the C++ standard library has you covered. Read on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The problem with rand()</h1>
                
            
            <article>
                
<p class="calibre2">The old school C way of generating <em class="calibre22">random</em> numbers is to call <kbd class="calibre12">rand()</kbd>. The <kbd class="calibre12">rand()</kbd> function, which is still part of C++, takes no arguments and produces a single, uniformly distributed integer in the <kbd class="calibre12">[0, RAND_MAX]</kbd> <span>range.</span> The internal state can be <em class="calibre22">seeded</em> by calling the library function, <kbd class="calibre12">srand(seed_value)</kbd>.</p>
<p class="calibre2">The classic code to generate a <em class="calibre22">random</em> number in the <kbd class="calibre12">[0, x)</kbd> <span>range</span> hasn't changed since the 1980s, shown here:</p>
<pre class="calibre23">    #include &lt;stdlib.h&gt;<br class="title-page-name"/><br class="title-page-name"/>    int randint0(int x) {<br class="title-page-name"/>      return rand() % x;<br class="title-page-name"/>    }</pre>
<p class="calibre2">However, this code has several problems. The first and most obvious problem is that it doesn't generate all <kbd class="calibre12">x</kbd> outputs with equal likelihood. Suppose, for the sake of argument, <kbd class="calibre12">rand()</kbd> returns a uniformly distributed value in the <kbd class="calibre12">[0, 32767]</kbd> <span>range,</span> then <kbd class="calibre12">randint0(10)</kbd> will return each value in the <kbd class="calibre12">[0, 7]</kbd> <span>range</span> one-3276th more often than it returns either <kbd class="calibre12">8</kbd> or <kbd class="calibre12">9</kbd>.</p>
<p class="calibre2">The second problem is that <kbd class="calibre12">rand()</kbd> accesses global state; the same random number generator is shared by every thread in your C++ program. This isn't a thread-safety concern--<kbd class="calibre12">rand()</kbd> has been guaranteed to be thread-safe since C++11. However, it is a problem for performance (because each call to <kbd class="calibre12">rand()</kbd> must take a global mutex lock), and it is a problem for reproducibility (because if you use <kbd class="calibre12">rand()</kbd> from multiple threads concurrently, different runs of the program may yield different answers).</p>
<p class="calibre2">A third and related problem with the global-statefulness of <kbd class="calibre12">rand()</kbd> is that any function anywhere in the program can modify that state just by calling <kbd class="calibre12">rand()</kbd>. This makes it effectively impossible to use <kbd class="calibre12">rand()</kbd> in a unit-test-driven environment. Consider the following code snippet:</p>
<pre class="calibre23">    int heads(int n) {<br class="title-page-name"/>      DEBUG_LOG("heads");<br class="title-page-name"/>      int result = 0;<br class="title-page-name"/>      for (int i = 0; i &lt; n; ++i) {<br class="title-page-name"/>        result += (rand() % 2);<br class="title-page-name"/>      }<br class="title-page-name"/>      return result;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test_heads() {<br class="title-page-name"/>      srand(17); // nail down the seed<br class="title-page-name"/>      int result = heads(42);<br class="title-page-name"/>      assert(result == 27);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Clearly, the unit test, <kbd class="calibre12">test_heads</kbd>, will break as soon as we start parallelizing our unit tests (because a call to <kbd class="calibre12">rand()</kbd> from some other thread will interfere with the delicate workings of this test). However, more subtly, it can also break simply because someone changed the implementation of <kbd class="calibre12">DEBUG_LOG</kbd> to add or remove a call to <kbd class="calibre12">rand()</kbd>! This kind of <em class="calibre22">spooky action at a distance</em> is a problem any time your architecture depends on global variables. We saw a similar danger with <kbd class="calibre12">std::pmr::get_default_resource()</kbd> in <a target="_blank" href="part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 8</a>, <em class="calibre22">Allocators</em>. In every case, my strongly recommended remedy is the same--<em class="calibre22">Don't use global variables. Don't use global state.</em></p>
<p class="calibre2">So, the C library has two problems--it provides no way to generate a truly uniform distribution of pseudo-random numbers, and it fundamentally depends on global variables. Let's see how the C++ standard library's <kbd class="calibre12">&lt;random&gt;</kbd> header fixed both of these problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Solving problems with &lt;random&gt;</h1>
                
            
            <article>
                
<p class="calibre2">There are two core concepts provided by the <kbd class="calibre12">&lt;random&gt;</kbd> header--the <em class="calibre22">generator</em> and the <em class="calibre22">distribution</em>. A <em class="calibre22">generator</em> (a class modeling the <kbd class="calibre12">UniformRandomBitGenerator</kbd> concept) encapsulates the internal state of a PRNG into a C++ object, and provides a next output member function in the form of the function-call operator, <kbd class="calibre12">operator()(void)</kbd>. A <em class="calibre22">distribution</em> (a class modeling <kbd class="calibre12">RandomNumberDistribution</kbd>) is a kind of filter you can place over the output of a generator so that instead of getting uniformly distributed random bits, as you do from <kbd class="calibre12">rand()</kbd>, you get actual data values distributed according to a specified mathematical distribution and constrained to a specific range, such as <kbd class="calibre12">rand() % n</kbd>, but more mathematically appropriate and vastly more flexible.</p>
<p class="calibre2">The <kbd class="calibre12">&lt;random&gt;</kbd> header contains a total of seven <em class="calibre22">generator</em> types and twenty <em class="calibre22">distribution</em> types. Most of them are templates taking lots of parameters. The majority of these generators are more historically interesting than practically useful, and the vast majority of these distributions are of interest only to mathematicians. So, in this chapter, we'll concentrate on just a few standard generators and distributions, each of which illustrates something interesting about the standard library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dealing with generators</h1>
                
            
            <article>
                
<p class="calibre2">Given any <em class="calibre22">generator</em> object <kbd class="calibre12">g</kbd>, you can perform the following operations on it:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">g()</kbd>: This scrambles the internal state of the generator and yields its next output.</li>
<li class="calibre15"><kbd class="calibre12">g.min()</kbd><span>: This</span> tells you the smallest possible output of <kbd class="calibre12">g()</kbd> (typically <kbd class="calibre12">0</kbd>).</li>
<li class="calibre15"><kbd class="calibre12">g.max()</kbd><span>: This</span> tells you the largest possible output of <kbd class="calibre12">g()</kbd>. That is, the range of<br class="title-page-name"/>
possible outputs of <kbd class="calibre12">g()</kbd> is <kbd class="calibre12">g.min()</kbd> to <kbd class="calibre12">g.max()</kbd> inclusive.</li>
<li class="calibre15"><kbd class="calibre12">g.discard(n)</kbd><span>: This</span> effectively makes <kbd class="calibre12">n</kbd> calls to <kbd class="calibre12">g()</kbd> and discards the<br class="title-page-name"/>
results. In a good library implementation, you'll pay for scrambling the generator's internal state <kbd class="calibre12">n</kbd> times, but save any cost associated with computing the next outputs from the state.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Truly random bits with std::random_device</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">std::random_device</kbd> is a <em class="calibre22">generator</em>. Its interface is incredibly simple; it's not even a class template, just a plain old class. Once you've constructed an instance of <kbd class="calibre12">std::random_device</kbd> using its default constructor, you can use its overloaded call operator to fetch values of type <kbd class="calibre12">unsigned int</kbd> that are uniformly distributed in the closed <kbd class="calibre12">[rd.min(), rd.max()]</kbd> <span>range.</span></p>
<p class="calibre2">One caveat--<kbd class="calibre12">std::random_device</kbd> doesn't fully model the <kbd class="calibre12">UniformRandomBitGenerator</kbd> concept. Most importantly, it is neither copyable nor moveable. This isn't much of a problem in practice, because you generally don't keep a <em class="calibre22">truly</em> random generator around for very long. Instead, you'll use a very short-lived instance of <kbd class="calibre12">std::random_device</kbd> to generate a <em class="calibre22">seed</em> for a long-lived pseudo-random generator of some other type, like this:</p>
<pre class="calibre23">    std::random_device rd;<br class="title-page-name"/>    unsigned int seed = rd();<br class="title-page-name"/>    assert(rd.min() &lt;= seed &amp;&amp; seed &lt;= rd.max());</pre>
<p class="calibre2">Now let's look at the only pseudo-random generator you'll ever need to know.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pseudo-random bits with std::mt19937</h1>
                
            
            <article>
                
<p class="calibre2">The only pseudo-random generator you'll ever need to know is called the <em class="calibre22">Mersenne Twister</em> algorithm. This algorithm has been known since 1997, and high-quality implementations in any programming language are easy to find. Technically speaking, the Mersenne Twister algorithm defines a whole family of related PRNGs--it's the algorithmic equivalent of a C++ template--but the most commonly used member of the family is known as <strong class="calibre1">MT19937</strong>. That string of digits might look like a timestamp, but it's not; it's the size in bits of the Twister's internal state. Because the Mersenne Twister's next output function scrambles its state so perfectly that it will eventually reach every possible state (but one) before looping back around to the beginning--the <em class="calibre22">period</em> of the MT19937 generator is 2<sup class="calibre26">19937</sup>-1. Compare this to our <kbd class="calibre12">SimplePRNG</kbd> from the beginning of this chapter, which has an internal state of only 32 bits and a period of 2<sup class="calibre26">31</sup>. (Our <kbd class="calibre12">SimplePRNG</kbd> generator has 2<sup class="calibre26">32</sup> possible internal states, but only half of them are reached before it loops around again. For example, <kbd class="calibre12">state=3</kbd> is not reachable from the initial <kbd class="calibre12">state=1</kbd>.)</p>
<p class="calibre2">Enough theory. Let's see the Mersenne Twister in action! The C++ class template corresponding to the Mersenne Twister <em class="calibre22">algorithm template</em> is <kbd class="calibre12">std::mersenne_twister_engine&lt;...&gt;</kbd>, but you won't use it directly; you'll use the convenience typedef <kbd class="calibre12">std::mt19937</kbd>, as shown here:</p>
<pre class="calibre23">    std::mt19937 g;<br class="title-page-name"/>    assert(g.min() == 0 &amp;&amp; g.max() == 4294967295);<br class="title-page-name"/><br class="title-page-name"/>    assert(g() == 3499211612);<br class="title-page-name"/>    assert(g() == 581869302);<br class="title-page-name"/>    assert(g() == 3890346734);</pre>
<p class="calibre2">The default constructor for <kbd class="calibre12">std::mt19937</kbd> sets its internal state to a well-known standard value. This ensures that the output sequence you get from a default-constructed <kbd class="calibre12">mt19937</kbd> object will be identical across all platforms--as opposed to <kbd class="calibre12">rand()</kbd>, which tends to give different output sequences on different platforms.</p>
<p class="calibre2">To get a different output sequence, you need to provide a <em class="calibre22">seed</em> to the constructor of <kbd class="calibre12">std::mt19937</kbd>. There are two ways to do this in C++17--the tedious way and the simple way. The tedious way is to construct a truly random 19937-bit seed and copy it into the <kbd class="calibre12">std::mt19937</kbd> object via a <em class="calibre22">seed sequence</em>, as shown here:</p>
<pre class="calibre23">    std::random_device rd;<br class="title-page-name"/><br class="title-page-name"/>    uint32_t numbers[624];<br class="title-page-name"/>    std::generate(numbers, std::end(numbers), std::ref(rd));<br class="title-page-name"/>      // Generate initial state.<br class="title-page-name"/><br class="title-page-name"/>    SeedSeq sseq(numbers, std::end(numbers));<br class="title-page-name"/>      // Copy our state into a heap-allocated "seed sequence".<br class="title-page-name"/><br class="title-page-name"/>    std::mt19937 g(sseq);<br class="title-page-name"/>      // Initialize a mt19937 generator with our state.</pre>
<p class="calibre2">Here, the <kbd class="calibre12">SeedSeq</kbd> <span>type</span> can be either <kbd class="calibre12">std::seed_seq</kbd> (a glorified <kbd class="calibre12">std::vector</kbd>; it uses heap allocation) or a properly handwritten "seed sequence" class, such as the following piece of code:</p>
<pre class="calibre23">    template&lt;class It&gt;<br class="title-page-name"/>    struct SeedSeq {<br class="title-page-name"/>      It begin_;<br class="title-page-name"/>      It end_;<br class="title-page-name"/>    public:<br class="title-page-name"/>      SeedSeq(It begin, It end) : begin_(begin), end_(end) {}<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class It2&gt;<br class="title-page-name"/>      void generate(It2 b, It2 e) {<br class="title-page-name"/>        assert((e - b) &lt;= (end_ - begin_));<br class="title-page-name"/>        std::copy(begin_, begin_ + (e - b), b);<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Of course, this is quite a bit of code to write just to construct a single PRNG object! (I told you, this was the <em class="calibre22">tedious</em> way.) The simple way, and the way you'll see being used in practice, is to seed MT19937 with a single, truly random <em class="calibre22">32-bit integer</em>, as follows:</p>
<pre class="calibre23">    std::random_device rd;<br class="title-page-name"/><br class="title-page-name"/>    std::mt19937 g(rd());<br class="title-page-name"/>      // 32 bits of randomness ought to be enough for anyone!<br class="title-page-name"/>      // ...Right?</pre>
<p class="calibre2">Beware! 32 is a much, much smaller number than 19937! This simple method of seeding is capable of producing only four billion different output sequences, <em class="calibre22">ever</em>; this means that if you run your program over and over with random seeds, you can expect to see some repetitions after only a few hundred thousand runs. (This is an application of the famous <em class="calibre22">Birthday Paradox</em>.) However, if this level of predictability is important to you, you should probably also be aware that the Mersenne Twister is <em class="calibre22">not cryptographically secure</em>. This means that even if you initialize it with a truly random 19937-bit seed sequence, a malicious attacker can reverse-engineer all 19937 bits of your original seed and predict every subsequent output with perfect accuracy after seeing only a few hundred terms of the output sequence. If you need a <strong class="calibre1">cryptographically secure pseudo-random number generator</strong> (<strong class="calibre1">CSPRNG</strong>), you should be using something like AES-CTR or ISAAC, neither of which is provided by the C++ standard library. You should still wrap your CSPRNG implementation in a class modeling <kbd class="calibre12">UniformRandomBitGenerator</kbd> so that it can be used with standard algorithms, which we'll get to at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Filtering generator outputs with adaptors</h1>
                
            
            <article>
                
<p class="calibre2">We've mentioned that the raw output of a <em class="calibre22">generator</em> is usually filtered through a single <em class="calibre22">distribution</em> in order to convert the generator's raw bits into usable data values. Interestingly, it is also possible to send a generator's output through a <em class="calibre22">generator adaptor</em>, which can reformat the raw bits in various, perhaps useful ways. The standard library provides three adaptors--<kbd class="calibre12">std::discard_block_engine</kbd>, <kbd class="calibre12">std::shuffle_order_engine</kbd>, and <kbd class="calibre12">std::independent_bits_engine</kbd>. These adaptor types work just like the <em class="calibre22">container adaptors</em> (such as <kbd class="calibre12">std::stack</kbd>) we discussed in <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo--</em>they provide a certain interface but delegate most of their implementation details to some other class.</p>
<p class="calibre2">An instance of <kbd class="calibre12">std::discard_block_engine&lt;Gen, p, r&gt;</kbd> keeps an <em class="calibre22">underlying generator</em> of type <kbd class="calibre12">Gen</kbd>, and delegates all its operations to that underlying generator, except that <kbd class="calibre12">discard_block_engine::operator()</kbd> will return only the first <kbd class="calibre12">r</kbd> of every <kbd class="calibre12">p</kbd> outputs from the underlying generator. For example, consider the following example:</p>
<pre class="calibre23">    std::vector&lt;uint32_t&gt; raw(10), filtered(10);<br class="title-page-name"/><br class="title-page-name"/>    std::discard_block_engine&lt;std::mt19937, 3, 2&gt; g2;<br class="title-page-name"/>    std::mt19937 g1 = g2.base();<br class="title-page-name"/><br class="title-page-name"/>    std::generate(raw.begin(), raw.end(), g1);<br class="title-page-name"/>    std::generate(filtered.begin(), filtered.end(), g2);<br class="title-page-name"/><br class="title-page-name"/>    assert(raw[0] == filtered[0]);<br class="title-page-name"/>    assert(raw[1] == filtered[1]);<br class="title-page-name"/>      // raw[2] doesn't appear in filtered[]<br class="title-page-name"/>    assert(raw[3] == filtered[2]);<br class="title-page-name"/>    assert(raw[4] == filtered[3]);<br class="title-page-name"/>      // raw[5] doesn't appear in filtered[]</pre>
<p class="calibre2">Notice that a reference to the underlying generator can be retrieved via <kbd class="calibre12">g2.base()</kbd>. In the preceding example, <kbd class="calibre12">g1</kbd> is initialized as a copy of <kbd class="calibre12">g2.base()</kbd>; this explains how calling <kbd class="calibre12">g1()</kbd> doesn't affect the state of <kbd class="calibre12">g2</kbd>, and vice versa.</p>
<p class="calibre2">An instance of <kbd class="calibre12">std::shuffle_order_engine&lt;Gen, k&gt;</kbd> keeps a buffer of the last <em class="calibre22">k</em> outputs from its underlying generator, and an additional integer <kbd class="calibre12">Y</kbd>. Each call to<br class="title-page-name"/>
<kbd class="calibre12">shuffle_order_engine::operator()</kbd> sets <kbd class="calibre12">Y = buffer[Y % k]</kbd>, then sets <kbd class="calibre12">buffer[Y] = base()()</kbd>. (The formula to compute the buffer index from <kbd class="calibre12">Y</kbd> is actually more complicated than a simple modulus, but it basically <span>has</span> the same effect.) Notably, <kbd class="calibre12">std::shuffle_order_engine</kbd> does <em class="calibre22">not</em> use <kbd class="calibre12">std::uniform_int_distribution</kbd> to map <kbd class="calibre12">Y</kbd> onto the <kbd class="calibre12">[0, k)</kbd> <span>range.</span> This doesn't affect the <em class="calibre22">randomness</em> of the generator's output--if the underlying generator is already pseudo-random, shuffling its outputs a little bit won't make them any more or less random, no matter what algorithm we use to do the shuffling. Therefore, the algorithm used by <kbd class="calibre12">shuffle_order_engine</kbd> was picked specifically for its historical interest--it is a building block for a classic algorithm described in Donald Knuth's <em class="calibre22">The Art of Computer Programming</em>:</p>
<pre class="calibre23">    using knuth_b = std::shuffle_order_engine&lt;<br class="title-page-name"/>      std::linear_congruential_engine&lt;<br class="title-page-name"/>        uint_fast32_t, 16807, 0, 2147483647<br class="title-page-name"/>      &gt;,<br class="title-page-name"/>      256<br class="title-page-name"/>    &gt;;</pre>
<p class="calibre2">An instance of <kbd class="calibre12">std::independent_bits_engine&lt;Gen, w, T&gt;</kbd> keeps no state other than its underlying generator of type <kbd class="calibre12">Gen</kbd>. The <kbd class="calibre12">independent_bits_engine::operator()</kbd> function calls <kbd class="calibre12">base()()</kbd> just enough times to compute at least <kbd class="calibre12">w</kbd> random bits; then, it pastes together exactly <kbd class="calibre12">w</kbd> of those bits (via an algorithm of more historical than practical interest) and serves them up as an unsigned integer of type <kbd class="calibre12">T</kbd>. (It is an error if <kbd class="calibre12">T</kbd> is not an unsigned integer type, or if <kbd class="calibre12">T</kbd> has fewer than <kbd class="calibre12">w</kbd> bits.)</p>
<p class="calibre2">Here is an example of <kbd class="calibre12">independent_bits_engine</kbd> pasting together bits from multiple calls to <kbd class="calibre12">base()()</kbd>:</p>
<pre class="calibre23">    std::independent_bits_engine&lt;std::mt19937, 40, uint64_t&gt; g2;<br class="title-page-name"/>    std::mt19937 g1 = g2.base();<br class="title-page-name"/><br class="title-page-name"/>    assert(g1() == 0xd09'1bb5c); // Take "1bb5c"...<br class="title-page-name"/>    assert(g1() == 0x22a'e9ef6); // and "e9ef6"...<br class="title-page-name"/>    assert(g2() == 0x1bb5c'e9ef6); // Paste and serve!</pre>
<p class="calibre2">And here is an example of using <kbd class="calibre12">independent_bits_engine</kbd> to chop off all but the least significant digit from the output of <kbd class="calibre12">mt19937</kbd> (creating a <em class="calibre22">coin flipper</em> generator), and then, pasting together 32 of this generator's outputs to build back up to a 32-bit generator:</p>
<pre class="calibre23">    using coinflipper = std::independent_bits_engine&lt;<br class="title-page-name"/>      std::mt19937, 1, uint8_t&gt;;<br class="title-page-name"/><br class="title-page-name"/>    coinflipper onecoin;<br class="title-page-name"/>    std::array&lt;int, 64&gt; results;<br class="title-page-name"/>    std::generate(results.begin(), results.end(), onecoin);<br class="title-page-name"/>    assert((results == std::array&lt;int, 64&gt;{{<br class="title-page-name"/>      0,0,0,1, 0,1,1,1, 0,1,1,1, 0,0,1,0,<br class="title-page-name"/>      1,0,1,0, 1,1,1,1, 0,0,0,1, 0,1,0,1,<br class="title-page-name"/>      1,0,0,1, 1,1,1,0, 0,0,1,0, 1,0,1,0,<br class="title-page-name"/>      1,0,0,1, 0,0,0,0, 0,1,0,0, 1,1,0,0,<br class="title-page-name"/>    }}));<br class="title-page-name"/><br class="title-page-name"/>    std::independent_bits_engine&lt;coinflipper, 32, uint32_t&gt; manycoins;<br class="title-page-name"/>    assert(manycoins() == 0x1772af15);<br class="title-page-name"/>    assert(manycoins() == 0x9e2a904c);</pre>
<p class="calibre2">Notice that <kbd class="calibre12">independent_bits_engine</kbd> does <em class="calibre22">not</em> perform any complicated operation on the bits of its underlying generator; in particular, it assumes that its underlying generator has no bias. If the <kbd class="calibre12">WeightedCoin</kbd> <span>generator</span> has a bias toward even numbers. You'll see that bias show up in the output of <kbd class="calibre12">independent_bits_engine&lt;WeightedCoin, w, T&gt;</kbd> as well.</p>
<p class="calibre2">Despite our spending several pages talking about these generators, remember that there is no reason to use any of these obscure classes in your own code! If you need a PRNG, use <kbd class="calibre12">std::mt19937</kbd>; if you need a cryptographically secure PRNG, use something like AES-CTR, or ISAAC; and, if you need a relatively small number of true random bits, to seed your PRNG; use <kbd class="calibre12">std::random_device</kbd>. These are the only generators that you will ever use in practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dealing with distributions</h1>
                
            
            <article>
                
<p class="calibre2">Now that we've seen how to generate random bits on demand, let's look at how to convert those random bits to numeric values matching a particular <em class="calibre22">distribution</em>. This two-step process--generate raw bits, and then format them into data values--is very similar to the two-step process of buffering and parsing we covered in <a target="_blank" href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>. First, get the raw bits and bytes, then perform some kind of operation to convert those bits and bytes into typed data values.</p>
<p class="calibre2">Given any distribution object <kbd class="calibre12">dist</kbd>, you can perform the following operations on it:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">dist(g)</kbd>: This yields the next output according to the appropriate mathematical distribution. It may require several calls to <kbd class="calibre12">g()</kbd>, or none at all, depending on the internal state of the <kbd class="calibre12">dist</kbd> object.</li>
<li class="calibre15"><kbd class="calibre12">dist.reset()</kbd>: This clears the internal state of the <kbd class="calibre12">dist</kbd> object, if any. You'll never need to use this member function.</li>
<li class="calibre15"><kbd class="calibre12">dist.min()</kbd> and <kbd class="calibre12">dist.max()</kbd>: These tell you the smallest and largest possible outputs of <kbd class="calibre12">dist(g)</kbd> for any random bit generator <kbd class="calibre12">g</kbd>. Generally, these values are either self-evident or meaningless; for example, <kbd class="calibre12">std::normal_distribution&lt;float&gt;().max()</kbd> is <kbd class="calibre12">INFINITY</kbd>.</li>
</ul>
<p class="calibre2">Let's see a few distribution types in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rolling dice with uniform_int_distribution</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">std::uniform_int_distribution</kbd> method is the simplest distribution type in the standard library. It performs the same operation we tried to perform with <kbd class="calibre12">randint0</kbd> earlier in this chapter--map a random unsigned integer into a given range--, but it does it without any bias. The simplest implementation of <kbd class="calibre12">uniform_int_distribution</kbd> looks something like this:</p>
<pre class="calibre23">    template&lt;class Int&gt;<br class="title-page-name"/>    class uniform_int_distribution {<br class="title-page-name"/>      using UInt = std::make_unsigned_t&lt;Int&gt;;<br class="title-page-name"/>      UInt m_min, m_max;<br class="title-page-name"/>    public:<br class="title-page-name"/>      uniform_int_distribution(Int a, Int b) :<br class="title-page-name"/>        m_min(a), m_max(b) {}<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class Gen&gt;<br class="title-page-name"/>      Int operator()(Gen&amp; g) {<br class="title-page-name"/>        UInt range = (m_max - m_min);<br class="title-page-name"/>        assert(g.max() - g.min() &gt;= range);<br class="title-page-name"/>        while (true) {<br class="title-page-name"/>          UInt r = g() - g.min();<br class="title-page-name"/>          if (r &lt;= range) {<br class="title-page-name"/>            return Int(m_min + r);<br class="title-page-name"/>          }<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">The actual standard library implementation has to do something to get rid of that <kbd class="calibre12">assert</kbd>. Typically, they'll use something like <kbd class="calibre12">independent_bits_engine</kbd> to generate exactly <kbd class="calibre12">ceil(log2(range))</kbd> random bits at a time, minimizing the number of times the <kbd class="calibre12">while</kbd> loop needs to run.</p>
<p class="calibre2">As implied in the preceding example, <kbd class="calibre12">uniform_int_distribution</kbd> is stateless (although this is not <em class="calibre22">technically</em> guaranteed), and so the most common way to use it is to create a new distribution object every time you generate a number. So, we can implement our <kbd class="calibre12">randint0</kbd> function like this:</p>
<pre class="calibre23">    int randint0(int x) {<br class="title-page-name"/>      static std::mt19937 g;<br class="title-page-name"/>      return std::uniform_int_distribution&lt;int&gt;(0, x-1)(g);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Now will probably be a good time to remark on an oddity of the <kbd class="calibre12">&lt;random&gt;</kbd> facilities. As a general rule, any time you supply an <em class="calibre22">integral numeric range</em> to one of these functions or constructors, it is treated as a <em class="calibre22">closed</em> range. This is in stark contrast to how ranges usually work in C and C++; we even saw in <a target="_blank" href="part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 3</a>, <em class="calibre22">The Iterator-Pair Algorithms</em>, how deviating from the <em class="calibre22">half-open range</em> rule was usually the sign of buggy code. However, in the case of C++'s random-number facilities, there is a new rule--<em class="calibre22">the closed range</em> rule. Why?</p>
<p class="calibre2">Well, the key advantage of the half-open range is that it can easily represent an <em class="calibre22">empty range</em>. On the other hand, half-open ranges cannot represent a <em class="calibre22">completely full range</em>, that is, a range that covers the entire domain. (We saw this difficulty pop up in <a target="_blank" href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>, in the implementation of <kbd class="calibre12">std::list&lt;T&gt;::end()</kbd>.) Suppose we want to express the idea of a uniform distribution over the entire range of <kbd class="calibre12">long long</kbd>. We can't express that as the half-open range <kbd class="calibre12">[LLONG_MIN, LLONG_MAX+1)</kbd> because <kbd class="calibre12">LLONG_MAX+1</kbd> will overflow. However, we <em class="calibre22">can</em> express it as the closed range <kbd class="calibre12">[LLONG_MIN, LLONG_MAX]</kbd>--and so, that's what the <kbd class="calibre12">&lt;random&gt;</kbd> library's functions and classes (such as <kbd class="calibre12">uniform_int_distribution</kbd>) do. The <kbd class="calibre12">uniform_int_distribution&lt;int&gt;(0,6)</kbd> method is a distribution over the seven-number range <kbd class="calibre12">[0,6]</kbd>, and <kbd class="calibre12">uniform_int_distribution&lt;int&gt;(42,42)</kbd> is a perfectly valid distribution that invariably returns <kbd class="calibre12">42</kbd>.</p>
<p class="calibre2">On the other hand, <kbd class="calibre12">std::uniform_real_distribution&lt;double&gt;(a, b)</kbd> <em class="calibre22">does</em> operate on a half-open range! The <kbd class="calibre12">std::uniform_real_distribution&lt;double&gt;(0, 1)</kbd> method yields values of type <kbd class="calibre12">double</kbd>, uniformly distributed in the <kbd class="calibre12">[0, 1)</kbd> <span>range.</span> In the floating-point domain, there's no problem with overflow--a half-open range of <kbd class="calibre12">[0, INFINITY)</kbd> is <span>actually</span> expressible, although, of course, there's no such thing as a <em class="calibre22">uniform distribution</em> over an infinite range. Floating-point also makes it difficult to say the difference between a half-open range and a closed range; for example, <kbd class="calibre12">std::uniform_real_distribution&lt;float&gt;(0, 1)(g)</kbd> can legitimately return <kbd class="calibre12">float(1.0)</kbd> any time it generates a random real number close enough to 1 that it rounds up about one in every 2<sup class="calibre26">25</sup> results. (At press time, libc++ behaves as described here. GNU's libstdc++ applies a patch that makes close-to-1 real numbers round down instead of up so that the floating-point number just below 1.0 appears marginally more often than chance would predict.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generating populations with normal_distribution</h1>
                
            
            <article>
                
<p class="calibre2">The most useful example of a real-valued distribution is probably the <em class="calibre22">normal distribution</em>, also known as the <strong class="calibre1">bell curve</strong>. In the real world, normal distributions show up all over the place, particularly in the distribution of physical traits in a population. For example, a histogram of adult human heights will tend to look like a normal distribution--lots of individuals clustered around the average height, and others tailing off to each side. Flip this around, and it means that you might want to use a normal distribution to assign heights, weights, and so on, to the simulated individuals in a game.</p>
<p class="calibre2">The <kbd class="calibre12">std::normal_distribution&lt;double&gt;(m, sd)</kbd> method constructs an instance of <kbd class="calibre12">normal_distribution&lt;double&gt;</kbd> with mean (<kbd class="calibre12">m</kbd>) and standard deviation (<kbd class="calibre12">sd</kbd>). (These parameters default to <kbd class="calibre12">m=0</kbd> and <kbd class="calibre12">sd=1</kbd> if you don't provide them, so watch out for typos!) Here's an example of using <kbd class="calibre12">normal_distribution</kbd> to create a "population" of 10,000 normally distributed samples, and then verifying their distribution mathematically:</p>
<pre class="calibre23">    double mean = 161.8;<br class="title-page-name"/>    double stddev = 6.8;<br class="title-page-name"/>    std::normal_distribution&lt;double&gt; dist(mean, stddev);<br class="title-page-name"/><br class="title-page-name"/>      // Initialize our generator.<br class="title-page-name"/>    std::mt19937 g(std::random_device{}());<br class="title-page-name"/><br class="title-page-name"/>      // Fill a vector with 10,000 samples.<br class="title-page-name"/>    std::vector&lt;double&gt; v;<br class="title-page-name"/>    for (int i=0; i &lt; 10000; ++i) {<br class="title-page-name"/>      v.push_back( dist(g) );<br class="title-page-name"/>    }<br class="title-page-name"/>    std::sort(v.begin(), v.end());<br class="title-page-name"/><br class="title-page-name"/>      // Compare expectations with reality.<br class="title-page-name"/>    auto square = [](auto x) { return x*x; };<br class="title-page-name"/>    double mean_of_values = std::accumulate(<br class="title-page-name"/>      v.begin(), v.end(), 0.0) / v.size();<br class="title-page-name"/>    double mean_of_squares = std::inner_product(<br class="title-page-name"/>      v.begin(), v.end(), v.begin(), 0.0) / v.size();<br class="title-page-name"/>    double actual_stddev =<br class="title-page-name"/>      std::sqrt(mean_of_squares - square(mean_of_values));<br class="title-page-name"/>    printf("Expected mean and stddev: %g, %g\n", mean, stddev);<br class="title-page-name"/>    printf("Actual mean and stddev: %g, %g\n",<br class="title-page-name"/>           mean_of_values, actual_stddev);</pre>
<p class="calibre2">Unlike the other distributions we've seen in this chapter (or will see), <kbd class="calibre12">std::normal_distribution</kbd> is stateful. While it is okay to construct a new instance of <kbd class="calibre12">std::normal_distribution</kbd> for each value you generate, if you do that, you're effectively halving the efficiency of your program. This is because the most popular algorithm to generate normally distributed values produces two independent values per step; <kbd class="calibre12">std::normal_distribution</kbd> can't give you both values at once, so it hangs onto one of them in a member variable to give it to you the next time you ask. The <kbd class="calibre12">dist.reset()</kbd> <span>member function</span> can be used to clear out this saved state, not that you'd ever want to do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making weighted choices with discrete_distribution</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">std::discrete_distribution&lt;int&gt;(wbegin, wend)</kbd> method constructs a discrete, or weighted, distribution over the integers in the half-open <kbd class="calibre12">[0, wend - wbegin)</kbd> <span>range.</span> This is easiest to explain with the following example:</p>
<pre class="calibre23">    template&lt;class Values, class Weights, class Gen&gt;<br class="title-page-name"/>    auto weighted_choice(const Values&amp; v, const Weights&amp; w, Gen&amp; g)<br class="title-page-name"/>    {<br class="title-page-name"/>      auto dist = std::discrete_distribution&lt;int&gt;(<br class="title-page-name"/>        std::begin(w), std::end(w));<br class="title-page-name"/>      int index = dist(g);<br class="title-page-name"/>      return v[index];<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      auto g = std::mt19937(std::random_device{}());<br class="title-page-name"/>      std::vector&lt;std::string&gt; choices =<br class="title-page-name"/>        { "quick", "brown", "fox" };<br class="title-page-name"/>      std::vector&lt;int&gt; weights = { 1, 7, 2 };<br class="title-page-name"/>      std::string word = weighted_choice(choices, weights, g);<br class="title-page-name"/>        // 7/10 of the time, we expect word=="brown".<br class="title-page-name"/>    }</pre>
<p class="calibre2">The <kbd class="calibre12">std::discrete_distribution&lt;int&gt;</kbd> method makes its own internal copy of the weights you pass in, in a private member variable of type <kbd class="calibre12">std::vector&lt;double&gt;</kbd> (and as usual for <kbd class="calibre12">&lt;random&gt;</kbd>, it's not allocator-aware). You can get a copy of this vector by calling <kbd class="calibre12">dist.probabilities()</kbd> as follows:</p>
<pre class="calibre23">    int w[] = { 1, 0, 2, 1 };<br class="title-page-name"/>    std::discrete_distribution&lt;int&gt; dist(w, w+4);<br class="title-page-name"/>    std::vector&lt;double&gt; v = dist.probabilities();<br class="title-page-name"/>    assert((v == std::vector{ 0.25, 0.0, 0.50, 0.25 }));</pre>
<p class="calibre2">You probably don't want to use <kbd class="calibre12">discrete_distribution</kbd> directly in your own code; at best, you'll want to encapsulate its use in something like the preceding <kbd class="calibre12">weighted_choice</kbd> function. However, if you need to avoid heap allocation or floating-point math, it might pay to use a simpler, non-allocating function, such as the following:</p>
<pre class="calibre23">    template&lt;class Values, class Gen&gt;<br class="title-page-name"/>    auto weighted_choice(<br class="title-page-name"/>      const Values&amp; v, const std::vector&lt;int&gt;&amp; w,<br class="title-page-name"/>      Gen&amp; g)<br class="title-page-name"/>    {<br class="title-page-name"/>      int sum = std::accumulate(w.begin(), w.end(), 0);<br class="title-page-name"/>      int cutoff = std::uniform_int_distribution&lt;int&gt;(0, sum - 1)(g);<br class="title-page-name"/>      auto vi = v.begin();<br class="title-page-name"/>      auto wi = w.begin();<br class="title-page-name"/>      while (cutoff &gt; *wi) {<br class="title-page-name"/>        cutoff -= *wi++;<br class="title-page-name"/>        ++vi;<br class="title-page-name"/>      }<br class="title-page-name"/>      return *vi;<br class="title-page-name"/>    }</pre>
<p class="calibre2">However, there's a reason the <em class="calibre22">default</em> library implementation of <kbd class="calibre12">discrete_distribution</kbd> does all its math as floating-point: it saves you from having to worry about integer overflow. The preceding code will have bad behavior if <kbd class="calibre12">sum</kbd> overflows the range of <kbd class="calibre12">int</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Shuffling cards with std::shuffle</h1>
                
            
            <article>
                
<p class="calibre2">Let's close this chapter by looking at <kbd class="calibre12">std::shuffle(a,b,g)</kbd>, the one standard algorithm that takes a random number generator as input. It's a <em class="calibre22">permutative algorithm</em> by the definitions of <a target="_blank" href="part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 3</a>, <em class="calibre22">The Iterator Pair-Algorithms</em>--it takes a range of elements <kbd class="calibre12">[a,b)</kbd> and shuffles them around, preserving their values but not their positions.</p>
<p class="calibre2">The <kbd class="calibre12">std::shuffle(a,b,g)</kbd> method was introduced in C++11 to replace the older <kbd class="calibre12">std::random_shuffle(a,b)</kbd> <span>algorithm.</span> That older algorithm "randomly" shuffled the <kbd class="calibre12">[a,b)</kbd> <span>range,</span> but without specifying the source of the randomness; in practice, this meant that it would use the global C library's <kbd class="calibre12">rand()</kbd> with all its attendant problems. As soon as C++11 introduced a standardized way of talking about random number generators with <kbd class="calibre12">&lt;random&gt;</kbd>, it was time to get rid of the old <kbd class="calibre12">rand()</kbd> based <kbd class="calibre12">random_shuffle</kbd>; and, as of C++17, <kbd class="calibre12">std::random_shuffle(a,b)</kbd> is no longer part of the C++ standard library.</p>
<p class="calibre2"><span>Here's how we can use C++11's <kbd class="calibre12">std::shuffle</kbd> to shuffle a deck of playing cards:</span></p>
<pre class="calibre23">    std::vector&lt;int&gt; deck(52);<br class="title-page-name"/>    std::iota(deck.begin(), deck.end(), 1);<br class="title-page-name"/>      // deck now contains ints from 1 to 52.<br class="title-page-name"/><br class="title-page-name"/>    std::mt19937 g(std::random_device{}());<br class="title-page-name"/>    std::shuffle(deck.begin(), deck.end(), g);<br class="title-page-name"/>      // The deck is now randomly shuffled.</pre>
<p class="calibre2">Recall that every <em class="calibre22">generator</em> in <kbd class="calibre12">&lt;random&gt;</kbd> is completely specified so that, for example, an instance of <kbd class="calibre12">std::mt19937</kbd> seeded with a fixed value will produce exactly the same outputs on every platform. The same is <em class="calibre22">not</em> true of <em class="calibre22">distributions</em> such as <kbd class="calibre12">uniform_real_distribution</kbd>, nor is it true of the <kbd class="calibre12">shuffle</kbd> algorithm. Switching from libc++ to libstdc++, or even just upgrading your compiler, may cause changes in the behavior of your <kbd class="calibre12">std::shuffle</kbd>.</p>
<p class="calibre2">Notice that the preceding code snippet uses the "simple" method of seeding its Mersenne Twister, which means that it can only ever produce about 4 <span>√ó</span> 10<sup class="calibre26">9</sup> different shuffles--out of the 8 <span>√ó</span> 10<sup class="calibre26">67</sup> ways, you can shuffle a deck of cards by hand! If you were shuffling cards for a real casino game, you'd certainly want to use the "tedious" method of seeding, described earlier in this chapter, or--simpler, if performance isn't a concern--just use <kbd class="calibre12">std::random_device</kbd> directly:</p>
<pre class="calibre23">    std::random_device rd;<br class="title-page-name"/>    std::shuffle(deck.begin(), deck.end(), rd);<br class="title-page-name"/>    // The deck is now TRULY randomly shuffled.</pre>
<p class="calibre2">Whatever generator and seeding method you use, you'll be able to plug it right into <kbd class="calibre12">std::shuffle</kbd>. This is the benefit of the standard library's composable approach to random number generation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">The standard library provides two random-number-related concepts--<em class="calibre22">generator</em> and <em class="calibre22">distribution</em>. Generators are stateful, must be seeded, and produce unsigned integer outputs (raw bits) via <kbd class="calibre12">operator()(void)</kbd>. The two important generator types are <kbd class="calibre12">std::random_device</kbd>, which produces truly random bits, and <kbd class="calibre12">std::mt19937</kbd>, which produces pseudo-random bits.</p>
<p class="calibre2">Distributions are <em class="calibre22">usually</em> stateless, and produce numeric data values via <kbd class="calibre12">operator()(Gen&amp;)</kbd>. The most important distribution type for most programmers will be <kbd class="calibre12">std::uniform_int_distribution&lt;int&gt;(a,b)</kbd>, which produces integers in the closed range <kbd class="calibre12">[a,b]</kbd>. The standard library provides other distributions, such as <kbd class="calibre12">std::uniform_real_distribution</kbd>, <kbd class="calibre12">std::normal_distribution</kbd>, and <kbd class="calibre12">std::discrete_distribution</kbd>, as well as many arcane distributions useful to mathematicians and statisticians.</p>
<p class="calibre2">The one standard algorithm that uses randomness is <kbd class="calibre12">std::shuffle</kbd>, which replaces the old-style <kbd class="calibre12">std::random_shuffle</kbd>. Don't use <kbd class="calibre12">random_shuffle</kbd> in the new code.</p>
<p class="calibre2">Be aware that <kbd class="calibre12">std::mt19937</kbd> has exactly the same behavior on every platform, but the same is not true of any <em class="calibre22">distribution</em> type, nor of <kbd class="calibre12">std::shuffle</kbd>.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>