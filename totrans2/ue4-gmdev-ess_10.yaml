- en: Chapter 10. Introduction to Unreal C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Blueprints"), *Blueprints*, you learned
    about Blueprints, the visual scripting language of Unreal Engine 4\. Now you will
    learn about C++, which can be used to create base classes for Blueprints. In this
    chapter, you will learn how to create a C++ project (we will use the **Third Person
    Template**) and modify it to add support for health and health regeneration for
    our character. You will also learn how to expose variables and functions to Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be focused on writing C++ code using Visual Studio 2015 in
    Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Visual Studio 2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Unreal Engine 4.10, you will need Visual Studio 2015 to compile C++ for
    your projects. There are three editions of Visual Studio available. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Community edition**: This is free for any individual and nonenterprise organizations
    for up to five users. For this book, I will be using this edition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Professional edition**: This is a paid version and is useful for small teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise edition**: This is for large teams working on projects of any
    size and complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the Visual Studio 2015 community edition from [https://www.visualstudio.com/downloads/download-visual-studio-vs](https://www.visualstudio.com/downloads/download-visual-studio-vs)
  prefs: []
  type: TYPE_NORMAL
- en: 'After visiting the above link, select **Community 2015** and choose your format
    to download. You can either download the web installer or the offline installer.
    To download the offline installer, select the **ISO** format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Visual Studio 2015](img/B03950_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After downloading the setup, double-click on **vs_community.exe** to run the
    setup and install Visual Studio 2015.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before installing Visual Studio 2015, make sure you select **Visual C++** under
    the **Programming Languages** section. This is required to work with Unreal Engine
    4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Visual Studio 2015](img/B03950_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the installation is complete, the setup will prompt you to restart your
    computer. Do this, and you are good to go with Unreal Engine 4 C++.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some recommended settings for Visual Studio 2015 to work with Unreal
    Engine 4 that improves the overall user experience for developers. Some of them
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn off **Show Inactive Blocks**. If you do not, many chunks of code may appear
    grayed out in the text editor. (**Tools** | **Options** | **Text Editor** | **C/C++**
    | **View**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Disable External Dependencies Folders** to **True** to hide unneeded folders
    in the **Solution Explorer**. (**Tools** | **Options** | **Text Editor** | **C/C++**
    | **Advanced**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off **Edit & Continue** features. (**Tools** | **Options** | **Debugging**
    | **Edit** and click on **Continue**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on **IntelliSense**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a C++ project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Visual Studio installed, let''s create a project that includes
    C++ code. In this project, we will extend the Third Person Template that comes
    with Unreal Engine 4 and add support for health (including health regeneration):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a C++ project](img/B03950_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start Unreal Engine 4 and when the project browser dialog appears:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **New Project** tab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **C++** sub tab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Third Person**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Create Project**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you click on **Create Project**, Unreal Engine 4 will create all the base
    classes required and will compile the project for you. This might take a minute
    or so. Once this is completed, the solution file (Visual Studio file) for your
    project will be automatically opened along with the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is opened, one main change you might notice is the new **Compile**
    button that appears on the **Toolbar**. This will only appear if your project
    is a code project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a C++ project](img/B03950_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is used to recompile the code changes and reload them on the fly, even
    when you are playing the game! This system is called **Hot Reloading**. As a programmer,
    you will make use of this feature extensively.
  prefs: []
  type: TYPE_NORMAL
- en: The character class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, we have a character class and a game mode class already available.
    Let's take a quick look at how the character class is made.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, what we have is a source file (with the extension `.cpp`) and a header
    file (`.h`). In a nutshell, a header file contains all the declarations, and the
    source file contains the definitions of those declarations. To access a specific
    method (or a function) in another file, we use `# include` `ExampleHeader.h`.
    This way, we will have access to all functions declared in that header file.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing declarations on another header file are based on access specifiers.
    We will learn more about them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the source file (`.cpp`) and header file (`.h`) from Unreal Engine
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Browser**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to **C++ Classes**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select your project name folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-click on your character class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will open both source file (`.cpp`) and header file (`.h`) in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The character class](img/B03950_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the header file of our character class. Let's
    analyze it line by line.
  prefs: []
  type: TYPE_NORMAL
- en: '`#pragma once`: Any line that is preceded by a hash (`#`) sign is called a
    preprocessor directive. Think of it as instruction to the compiler to run before
    any actual code is compiled. They start with the hash (`#`) sign and usually ends
    with a new line. You can have multi-line by using the backslash (`\`) sign. In
    this case, `#pragma once` is a preprocessor and its job is to protect against
    multiple includes. `#pragma once` is known as header guard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include`: In this file, we see two include files. One is `Character.h` from
    the `GameFramework` folder (which is in the `UE4` directory) and the other is
    a `generated.h` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Character.h`: This file is included because our character class is inherited
    from the `ACharacter` class that comes with Unreal Engine 4\. This include is
    required to access all the declarations in the `Character` class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generated.h`: This is automatically generated for you by **Unreal Header Tool**
    (**UHT**). These are generated whenever you have a `USTRUCT()`or `UCLASS()` macro
    declared. They contain the details of type declarations in your header file. This
    should be the last include file in your header.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Macros`: `Macros` are also preprocessor-directive, which starts with `#define`.
    Right before the compile time, the compiler copies and pastes the actual values
    anywhere this macro is used. For example, if you create a macro like this: `#define
    MyMacro 3.14`, then `3.14` will be copied and pasted everywhere that `MyMacro`
    is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UCLASS(config=game)`: This is an Unreal macro that makes the editor aware
    of the new class. Inside the parentheses, you specify the class specifiers and
    metadata. In this example, we specify the config specifier. This indicates that
    this class is allowed to store data in the given configuration file. In this case,
    the name of your config file will be `YourGameNameGame.ini`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class APACKT_CPPCharacter`: `public ACharacter`: This indicates the class
    name and shows you which class we inherited this from. For this class, we inherited
    it from the `Character` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GENERATED_BODY()`: This is a macro that must be placed at the very beginning
    of the class body. When compiling, Unreal will replace it with all the boilerplate
    code that is necessary. This means that, right before compile time, `GENERATED_BODY()`
    is replaced by the actual code. Since this chunk of code is required to compile
    the class, Epic has made it easier for us by creating this macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`, `public`, and `protected`: These are called access specifiers. Access
    specifiers let you decide whether a method can be accessed by other files or not.
    There are three types of access specifiers. They are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: This means you can access the members only in this class. In this
    example, `CameraBoom` and `FollowCamera` are set as private properties. That means,
    you can access them `only` inside this class. If you create a new class deriving
    from this class, you cannot access them.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: This means all the members can be accessed from any other class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: This means all the members can be accessed from this class and
    any class that is derived from this class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPROPERTY()`: This defines the property metadata and specifiers. These are
    used on properties to serialize, replicate, and expose them to Blueprints. There
    are a number of `UPROPERTY ()` specifiers that you can use. To see the full list,
    visit this link: [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void`: This means it''s a function that does not return any data type. A function
    can return any type of data such as `float`, `int`, `bool`, or even objects, but
    doesn''t require a data type all the time. In such cases, you would use the void
    return type to indicate that this method does not return any type of data. This
    will also prevent overriding the function in any child classes. If you want to
    override a function in child classes, then you need to make it a virtual void.
    When you create a virtual void, it means child classes can override this function,
    implement their own logic, and optionally call the parent class function using
    the keyword `Super`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the preceding things (preprocessors, macros, access specifiers,
    and so on) will help a lot as you work in Unreal C++.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that is worth mentioning is the use of double colons (`::`), hyphen
    arrows (`->`), and periods (`.`). Understanding what they are and how to use them
    is crucial. Out of these, mostly we use the hyphen arrow (`->`) symbol. Let's
    see what they are.
  prefs: []
  type: TYPE_NORMAL
- en: '**Double colons** (`::`): When using this symbol, it means you are accessing
    a method from a specific namespace or scope. For example, you will use this symbol
    when you want to call static methods from other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyphen arrow** (`->`): This is used when you are pointing to some data that
    might or might not exist somewhere in the memory. Using this symbol means you
    are trying to access a pointer. A pointer points to a location somewhere in the
    memory where the actual data of that pointer is stored. Before accessing a pointer,
    it is always a good idea to check them and make sure they are valid. Pointers
    are one of the most important part in Unreal C++ so I''d highly recommend to read
    this article provided by Nathan Iyer (Rama): [https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers](https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Period** (.): This is used to access the data itself. For example, you will
    use this to access the data inside a struct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the health system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know about the `Character` class, let''s begin by modifying our
    character to add support for the health and health regeneration system. Before
    we begin, let''s see a quick breakdown of what we will be doing. In this system:'
  prefs: []
  type: TYPE_NORMAL
- en: A `float` variable that holds the current health of the player when the game
    begins. We will make sure that the player has maximum health when the player is
    initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override the default function `TakeDamage ()` of the `Actor` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player is taking damage, we will check how much damage was taken and
    subtract that amount from the health. We will then start a timer that will execute
    an event that regenerates health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a health variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So let''s get started. Open up your character source file and add the following
    code under private access specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare a `Health` variable with the data type `float`. We also added
    `UPROPERTY` to our `float` variable and added the specifiers `EditAnywhere`, `BlueprintReadWrite`,
    and `Category`. The `EditAnywhere` specifier lets you edit this property in the
    **Details** panel. `BlueprintReadWrite` allows you to get or set this value in
    Blueprint. Whatever name you write as the category will appear in the **Details**
    panel. If you compile and start your game and look at the **Details** panel of
    the **ThirdPersonCharacter** Blueprint (in **ThirdPersonCPP/Blueprints**) you
    will see our new property exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a health variable](img/B03950_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a value of `0.0` doesn''t make sense to `Health`. So what we
    will do is open the source file of our character class and type the following
    line under the class `constructor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `constructor` class is usually the first definition in a source file. It
    looks like `YourClassName::YourClassName()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any line preceded by `//` (double slash) is a comment and is ignored by the
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` class is basically where we set the default values of our
    class. In this case, we want the default value of our player health to be `100`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you press the **Compile** button in Unreal Engine editor, the editor
    will compile the new changes and hot reload it when it's finished. When the compilation
    is finished, you should see the new value (which is **100**) as the default value
    for `health`.
  prefs: []
  type: TYPE_NORMAL
- en: Taking damage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that our health is set, we can access it and change it in our `character`
    class. We now need to update this value whenever our player is taking damage.
    Since our character is an `Actor` class, we can use the `TakeDamage()` function
    to update the health. To do so, add the following code to your character header
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TakeDamage` is a virtual function that already exists in the `Actor` class.
    So when you want to have custom logic inside virtual functions, make sure you
    include an override keyword for them. This way you are telling the compiler to
    look in the parent class for a definition of this function. In case if the base
    class definition could not be found or has been changed then the compiler will
    throw an error. Keep in mind that if the override keyword is not there then the
    compiler will treat this as a new definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TakeDamage` function takes some parameters and returns a `float` value,
    which is the actual damage applied. In this function, we will first check whether
    our health value is larger than `0`. If it is, we decrease the `Health` value
    by the `Damage` value. If not, then we simply return `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see the use of comments and how it can help
    when reading the code later. `TakeDamage` function first calls the parent class
    function which returns the actual damage to apply. We will save this value to
    a local variable called `ActualDamage`. We then check whether the `health` value
    is greater than `0.0` and if it is then `health` value is reduced by the `ActualDamage`
    float variable and return that value. Whenever you override a virtual function
    and implement your custom logic, you use `Super::FunctionName()` to inherit the
    basic functionality of the parent class. Since the `TakeDamage()` function is
    virtual, and we override that function, we use `Super::TakeDamage()` to call the
    actual function defined in the parent class, which does the logic of applying
    damage to the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Health regeneration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that our character can take damage, we will modify this system further and
    add health regeneration. Our health regeneration system will regenerate health
    based on a `float` variable that is by default set to `1.0` every 1 second, which
    is also set to a `float` variable. These settings will be exposed to the Blueprint
    editor, so we can change them later without compiling the game again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the health regeneration system:'
  prefs: []
  type: TYPE_NORMAL
- en: We use a timer to regenerate health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player takes damage, we clear this timer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After taking damage, we set the timer to restart after 2 seconds. The timer
    will call a custom function that will regenerate health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the timer finishes, it will call the custom event which will add 1 health.
    This timer will continue to run until the player reaches maximum health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So the first thing we need is a `TimerHandle`. This helps in identifying `Timers`
    that have identical methods bound to them. To declare a `TimerHandle`, open up
    the character header file and add the following line under `GENERATED_BODY ()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use any name for `TimerHandle`. Here, the use of `TimerHandle`_ before
    `HealthRegen` is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we now know that we will be using timers, let''s add two new `float`
    variables that will act as the time to activate the `RegenerateHealth` function:'
  prefs: []
  type: TYPE_NORMAL
- en: We will call the first `float` variable `InitialDelay`. This is used to call
    `RegenerateHealth` after taking damage. We will set the default value to `2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will call the second `float` variable `RegenDelay`. When regenerating starts
    from the `TakeDamage` function, we use this `RegenDelay` time to call the `RegenerateHealth`
    function again. We will set the default value to `0.5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a new property called `RegenerateAmount` and expose it to
    the Blueprint editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `RegenerateAmount` variable you can see a new meta specifier called
    `AllowPrivateAccess`. This is used when you want a variable in private access
    specifier but you need it in Blueprint as well (`BlueprintReadOnly` or `BlueprintReadWrite`).
    Without `AllowPrivateAccess` compiler will throw an error when you use `BlueprintReadWrite`
    or `BlueprintReadOnly` on a variable under private access specifier. Finally,
    we will add a new function called `RegenerateHealth` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For now, we are done with the header file. Let's open the character source file
    and inside the class constructor (remember the class constructor is `YourClassName::YourClassName()`),
    add the default value for `RegenerateAmount` as `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `constructor` class is not construction script in Blueprints. If you want
    construction script behavior in C++, then you need to override the `OnConstruction`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also add the `RegenerateHealth` function into our source file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this function, we will write our code that will add the `RegenerateAmount`
    value to our existing health. So let''s modify it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's analyze that code. The first thing we do inside this function is
    to check whether our `Health` is greater than or equal to our default `Health`.
    If it is, we simply set the health value to the default value (which is what we
    set in the constructor). If it's not, we add `RegenerateAmount` to our existing
    health and rerun this function using a timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we modify the `TakeDamage` function to add `HealthRegeneration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we first check if our health is less than or equal to `0.0`.
    If it is then we know the player has no health so we simply return `0.0`. Otherwise
    we reduce our `health` value and check if health is less than or equal to `0`.
    We clear the timer if health is `0` otherwise we check if health regeneration
    is currently active. If it is not active then we create a new timer to run the
    `RegenerateHealth` function and lastly we return the `ActualDamage` applied.
  prefs: []
  type: TYPE_NORMAL
- en: C++ to Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a health and health regeneration system in our character class.
    One problem with our current system is that we have not yet defined what happens
    to our character after the health reaches 0\. In this section, we will create
    an event that we will implement in Blueprint. This event will be called when the
    player''s health reaches 0.0\. To create this Blueprint event, open our character
    header file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we added a normal function called `PlayerHealthIsZero()`. To
    make this available in Blueprint, we added a `UFUNCTION` specifier and inside
    that we added `BlueprintImplementableEvent`. This means C++ can call this function
    and it will execute inside Blueprint but we cannot add a definition for this in
    our character source file. Instead, we will just call it inside the source file
    whenever we want. In this example, we will call it inside our `TakeDamage` event
    if the player''s health is `0`. So let''s modify our `TakeDamage` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we call PlayerHealthIsZero right after clearing the regen
    timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to compile and run the project. In Visual Studio, press *F5*
    to compile and launch the project. Once the project is loaded, open our character
    Blueprint and you will see our new variables exposed in the **Details** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C++ to Blueprint](img/B03950_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, you can open the Blueprint graph and add our **Player Health Is
    Zero** event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C++ to Blueprint](img/B03950_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this event, you can program your logic to play a death animation, show some
    UI screen, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal C++ is easy to learn compared to actual C++. This is because the programming
    wizards at Epic Games implemented so many features that makes writing Unreal C++
    fun! You can extend what you learned from this chapter by including Armor system,
    Stamina system, and so on for your character. By incorporating UMG and Blueprints,
    you can show a HUD that shows player health and maybe a small warning system that
    pops up when the player's health goes below 50\. In the next chapter, you will
    learn how to package a project for shipping.
  prefs: []
  type: TYPE_NORMAL
