<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Templates and Commonly Used Containers" id="1UU541-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Templates and Commonly Used Containers</h1></div></div></div><p class="calibre9">In <a class="calibre1" title="Chapter 7. Dynamic Memory Allocation" href="part0051_split_000.html#1GKCM1-dd4a3f777fc247568443d5ffb917736d">Chapter 7</a>, <span class="strong"><em class="calibre10">Dynamic Memory Allocation</em></span>, we spoke about how you will use dynamic memory allocation if you want to create a new array whose size isn't known at compile time. Dynamic memory allocations are of the form <code class="email">int * array = new int[ number_of_elements ]</code>.</p><p class="calibre9">You also saw that dynamic allocations using the <code class="email">new[]</code> keyword require you to call <code class="email">delete[]</code> on the array later, otherwise you'd have a memory leak. Having to manage memory this way is hard work.</p><p class="calibre9">Is there a way to create an array of dynamic size and have the memory automatically managed for you by C++? The answer is yes. There are C++ object types (commonly called containers) that handle dynamic memory allocations and deallocations automatically. UE4 provides a couple of container types to store your data in dynamically resizable collections.</p><p class="calibre9">There are two different groups of template containers. There is the UE4 family of containers (beginning with <code class="email">T*</code>) and the <a id="id408" class="calibre1"/>C++ <span class="strong"><strong class="calibre2">Standard Template Library</strong></span> (<span class="strong"><strong class="calibre2">STL</strong></span>) family of containers. There are some differences between the UE4 containers and the C++ STL containers, but the differences are not major. UE4 containers sets are written with game performance in mind. C++ STL containers also perform well, and their interfaces are a little more consistent (consistency in an API is something that you'd prefer). Which container set you use is up to you. However, it is recommended that you use the UE4 container set since it guarantees that you won't have cross-platform issues when you try to compile your code.</p></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Templates and Commonly Used Containers" id="1UU541-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Debugging the output in UE4"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec64" class="calibre1"/>Debugging the output in UE4</h1></div></div></div><p class="calibre9">All of the code<a id="id409" class="calibre1"/> in this chapter (as well as in the later chapters) will require you to work in a UE4 project. For the purpose of testing <code class="email">TArray</code>, I created a basic code project called <code class="email">TArrays</code>. In the <code class="email">ATArraysGameMode::ATArraysGameMode</code> constructor, I am using the debug output feature to print text to the console.</p><p class="calibre9">Here's how the code will look:</p><div class="note"><pre class="programlisting">ATArraysGameMode::ATArraysGameMode(const class FPostConstructInitializeProperties&amp; PCIP) : Super(PCIP)
{
  if( GEngine )
  {
    GEngine-&gt;AddOnScreenDebugMessage( 0, 30.f, FColor::Red,  "Hello!" );
  }
}</pre></div><p class="calibre9">If you compile <a id="id410" class="calibre1"/>and run this project, you will see the debug text in the top-left corner of your game window when you start the game. You can use a debug output to see the internals of your program at any time. Just make sure that the <code class="email">GEngine</code> object exists at the time of debugging the output. The output of the preceding code is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00133.jpeg" alt="Debugging the output in UE4" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="UE4's TArray&lt;T&gt;"><div class="book" id="1VSLM2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec65" class="calibre1"/>UE4's TArray&lt;T&gt;</h1></div></div></div><p class="calibre9">TArrays <a id="id411" class="calibre1"/>are UE4's <a id="id412" class="calibre1"/>version of a dynamic array. To understand what a <code class="email">TArray&lt;T&gt;</code> variable is, you first have to know what the <code class="email">&lt;T&gt;</code> option between angle brackets stands for. The <code class="email">&lt;T&gt;</code> option means that the type of data stored in the array is a variable. Do you want an array of <code class="email">int</code>? Then create a <code class="email">TArray&lt;int&gt;</code> variable. A<a id="id413" class="calibre1"/> <code class="email">TArray</code> variable of <code class="email">double</code>? Create a <code class="email">TArray&lt;double&gt;</code> variable.</p><p class="calibre9">So, in general, wherever a <code class="email">&lt;T&gt;</code> appears, you can plug in a C++ type of your choice. Let's move on and show this with an example.</p></div>

<div class="book" title="UE4's TArray&lt;T&gt;">
<div class="book" title="An example that uses TArray&lt;T&gt;"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec98" class="calibre1"/>An example that uses TArray&lt;T&gt;</h2></div></div></div><p class="calibre9">A <a id="id414" class="calibre1"/>
<code class="email">TArray&lt;int&gt;</code> variable<a id="id415" class="calibre1"/> is just an array of <code class="email">int</code>. A <code class="email">TArray&lt;Player*&gt;</code> variable will be an array of <code class="email">Player*</code> pointers. An array is dynamically resizable, and elements can be added at the end of the array after its creation.</p><p class="calibre9">To create a <code class="email">TArray&lt;int&gt;</code> variable, all you have to do is use the normal variable allocation syntax:</p><div class="note"><pre class="programlisting">TArray&lt;int&gt; array;</pre></div><p class="calibre9">Changes to the <code class="email">TArray</code> variable are done using member functions. There are a couple of member functions that you can use on a <code class="email">TArray</code> variable. The first member function that you need to know about is the way you add a value to the array, as shown in the following code:</p><div class="note"><pre class="programlisting">array.Add( 1 );
array.Add( 10 );
array.Add( 5 );
array.Add( 20 );</pre></div><p class="calibre9">These four lines of code will produce the array value in memory, as shown in the following figure:</p><div class="mediaobject"><img src="../images/00134.jpeg" alt="An example that uses TArray&lt;T&gt;" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">When you call <code class="email">array.Add( number )</code>, the new number goes to the end of the array. Since we added the numbers <span class="strong"><strong class="calibre2">1</strong></span>, <span class="strong"><strong class="calibre2">10</strong></span>, <span class="strong"><strong class="calibre2">5</strong></span>, and <span class="strong"><strong class="calibre2">20</strong></span> to the array, in this order, that is the order in which they will go into the array.</p><p class="calibre9">If you want to insert a number in the front or middle of the array, it is also possible. All you have to do is use the <code class="email">array.Insert(value, index)</code> function, as shown in the following line of code:</p><div class="note"><pre class="programlisting">array.Insert( 9, 0 );</pre></div><p class="calibre9">This function <a id="id416" class="calibre1"/>will push the number <span class="strong"><strong class="calibre2">9</strong></span> into the position <span class="strong"><strong class="calibre2">0</strong></span> of the array (at the front). This means that the rest of the array elements will be offset to the right, as shown in the following figure:</p><div class="mediaobject"><img src="../images/00135.jpeg" alt="An example that uses TArray&lt;T&gt;" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">We can insert <a id="id417" class="calibre1"/>another element into position <span class="strong"><strong class="calibre2">2</strong></span> of the array using the following line of code:</p><div class="note"><pre class="programlisting">array.Insert( 30, 2 );</pre></div><p class="calibre9">This function will rearrange the array as shown in the following figure:</p><div class="mediaobject"><img src="../images/00136.jpeg" alt="An example that uses TArray&lt;T&gt;" class="calibre11"/></div><p class="calibre12"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip53" class="calibre1"/>Tip</h3><p class="calibre9">If you insert a number into a position in the array that is out of bounds, UE4 will crash. So be careful not to do that.</p></div></div></div>

<div class="book" title="UE4's TArray&lt;T&gt;">
<div class="book" title="Iterating a TArray"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec99" class="calibre1"/>Iterating a TArray</h2></div></div></div><p class="calibre9">You <a id="id418" class="calibre1"/>can iterate (walk over) the elements of a <code class="email">TArray</code> variable in two ways: either<a id="id419" class="calibre1"/> using integer-based indexing or using an iterator. I will show you both the ways here.</p><div class="book" title="The vanilla for loop and square brackets notation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl4sec03" class="calibre1"/>The vanilla for loop and square brackets notation</h3></div></div></div><p class="calibre9">Using<a id="id420" class="calibre1"/> integers to index the elements of an array is sometimes called a "vanilla" <code class="email">for</code> loop. The elements of the array can be accessed using <code class="email">array[ index ]</code>, where <code class="email">index</code> is the numerical position of the element in the array:</p><div class="note"><pre class="programlisting">for( int index = 0; index &lt; array.Num(); index++ )
{
  // print the array element to the screen using debug message
  GEngine-&gt;AddOnScreenDebugMessage( index, 30.f, FColor::Red,  FString::FromInt( array[ index ] ) );
}</pre></div></div><div class="book" title="Iterators"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl4sec04" class="calibre1"/>Iterators</h3></div></div></div><p class="calibre9">You can <a id="id421" class="calibre1"/>also use an iterator to walk over the elements <a id="id422" class="calibre1"/>of the array one by one, as shown in the following code:</p><div class="note"><pre class="programlisting">int count = 0;	// keep track of numerical index in array
for( TArray&lt;int&gt;::TIterator it = array.CreateIterator(); it; ++it  )
{
  GEngine-&gt;AddOnScreenDebugMessage( count++, 30.f, FColor::Red,  FString::FromInt( *it ) );
}</pre></div><p class="calibre9">Iterators are pointers into the array. Iterators can be used to inspect or change values inside the array. An example of an iterator is shown in the following figure:</p><div class="mediaobject"><img src="../images/00137.jpeg" alt="Iterators" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The <a id="id423" class="calibre1"/>concept<a id="id424" class="calibre1"/> of an iterator: it is an external object that can look into and inspect the values of an array. Doing ++ it moves the iterator to examine the next element.</p><p class="calibre9">An iterator must be suitable for the collection it is walking through. To walk through a <code class="email">TArray&lt;int&gt;</code> variable, you need a <code class="email">TArray&lt;int&gt;::TIterator</code> type iterator.</p><p class="calibre9">We use <code class="email">*</code> to look at the value behind an iterator. In the preceding code, we used <code class="email">(*it)</code> to get the integer value from the iterator. This is called dereferencing. To dereference an iterator means to look at its value.</p><p class="calibre9">The <code class="email">++it</code> operation that happens at the end of each iteration of the <code class="email">for</code> loop increments the iterator, moving it on to point to the next element in the list.</p><p class="calibre9">Insert the code into the program and try it out now. Here's the example program we have created so far using <code class="email">TArray</code> (all in the <code class="email">ATArraysGameMode::ATArraysGameMode()</code> constructor):</p><div class="note"><pre class="programlisting">ATArraysGameMode::ATArraysGameMode(const class FPostConstructInitializeProperties&amp; PCIP) : Super(PCIP)
{
  TArray&lt;int&gt; array;
  array.Add( 1 );
  array.Add( 10 );
  array.Add( 5 );
  array.Add( 20 );
  array.Insert( 9, 0 );// put a 9 in the front
  array.Insert( 30, 2 );// put a 30 at index 2
  if( GEngine )
  {
    for( int index = 0; index &lt; array.Num(); index++ )
    {
      GEngine-&gt;AddOnScreenDebugMessage( index, 30.f, FColor::Red,  FString::FromInt( array[ index ] ) );
    }
  }
}</pre></div><p class="calibre9">The <a id="id425" class="calibre1"/>output <a id="id426" class="calibre1"/>of the preceding code is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00138.jpeg" alt="Iterators" class="calibre11"/></div><p class="calibre12"> </p></div></div></div>

<div class="book" title="UE4's TArray&lt;T&gt;">
<div class="book" title="Finding whether an element is in the TArray"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec100" class="calibre1"/>Finding whether an element is in the TArray</h2></div></div></div><p class="calibre9">Searching out UE4 containers is easy. It is commonly done using the <code class="email">Find</code> member function. Using the array we created previously, we can find the index of the value <code class="email">10</code> by typing the following line of code:</p><div class="note"><pre class="programlisting">int index = array.Find( 10 ); // would be index 3 in image above</pre></div></div></div>

<div class="book" title="TSet&lt;T&gt;" id="20R681-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec66" class="calibre1"/>TSet&lt;T&gt;</h1></div></div></div><p class="calibre9">A <code class="email">TSet&lt;int&gt;</code> variable <a id="id427" class="calibre1"/>stores a <a id="id428" class="calibre1"/>set of integers. A <code class="email">TSet&lt;FString&gt;</code> variable. stores a set of strings. The main difference between <code class="email">TSet</code> and <code class="email">TArray</code> is that <code class="email">TSet</code> does not allow duplicates—all the elements inside a <code class="email">TSet</code> are guaranteed to be unique. A <code class="email">TArray</code> variable does not mind duplicates of the same elements.</p><p class="calibre9">To add numbers to <code class="email">TSet</code>, simply call <code class="email">Add</code>. Take an example of the following declaration:</p><div class="note"><pre class="programlisting">TSet&lt;int&gt; set;
set.Add( 1 );
set.Add( 2 );
set.Add( 3 );
set.Add( 1 );// duplicate! won't be added
set.Add( 1 );// duplicate! won't be added</pre></div><p class="calibre9">This is <a id="id429" class="calibre1"/>how <code class="email">TSet</code> will look, as shown in the following figure:</p><div class="mediaobject"><img src="../images/00139.jpeg" alt="TSet&lt;T&gt;" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Duplicate entries of the same value in the <code class="email">TSet</code> will not be allowed. Notice how the entries in a <code class="email">TSet</code> aren't numbered, as they were in a <code class="email">TArray</code>: you can't use square brackets to access an entry in <code class="email">TSet</code> arrays.</p></div>

<div class="book" title="TSet&lt;T&gt;" id="20R681-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Iterating a TSet"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec101" class="calibre1"/>Iterating a TSet</h2></div></div></div><p class="calibre9">In <a id="id430" class="calibre1"/>order to look into a <code class="email">TSet</code> array, you must use an iterator. You can't use square brackets notation to access the elements of a <code class="email">TSet</code>:</p><div class="note"><pre class="programlisting">int count = 0;	// keep track of numerical index in set
for( TSet&lt;int&gt;::TIterator it = set.CreateIterator(); it; ++it )
{
  GEngine-&gt;AddOnScreenDebugMessage( count++, 30.f, FColor::Red,  FString::FromInt( *it ) );
}</pre></div></div></div>

<div class="book" title="TSet&lt;T&gt;" id="20R681-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Intersecting TSet"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec102" class="calibre1"/>Intersecting TSet</h2></div></div></div><p class="calibre9">The <code class="email">TSet</code>array<a id="id431" class="calibre1"/> has two special functions that the <code class="email">TArray</code> variable does not. The intersection of two <code class="email">TSet</code> arrays is basically the elements they have in common. If we have two <code class="email">TSet</code> arrays such as <code class="email">X</code> and <code class="email">Y</code> and we intersect them, the result will be a third, new<a id="id432" class="calibre1"/> <code class="email">TSet</code> array that contains only the elements common between them. Look at the following example:</p><div class="note"><pre class="programlisting">TSet&lt;int&gt; X;
X.Add( 1 );
X.Add( 2 );
X.Add( 3 );
TSet&lt;int&gt; Y;
Y.Add( 2 );
Y.Add( 4 );
Y.Add( 8 );
TSet&lt;int&gt; common = X.Intersect(Y); // 2</pre></div><p class="calibre9">The common elements between <code class="email">X</code> and <code class="email">Y</code> will then just be the element <code class="email">2</code>.</p></div></div>

<div class="book" title="TSet&lt;T&gt;" id="20R681-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Unioning TSet"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec103" class="calibre1"/>Unioning TSet</h2></div></div></div><p class="calibre9">Mathematically, the <a id="id433" class="calibre1"/>union of two sets is when you basically insert all the elements into the same set. Since we are talking about sets here, there won't be any duplicates.</p><p class="calibre9">If we take the <code class="email">X</code> and <code class="email">Y</code> sets from the previous example and create a union, we will get a new set, as follows:</p><div class="note"><pre class="programlisting">TSet&lt;int&gt; uni = X.Union(Y); // 1, 2, 3, 4, 8</pre></div></div></div>

<div class="book" title="TSet&lt;T&gt;" id="20R681-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Finding TSet"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec104" class="calibre1"/>Finding TSet</h2></div></div></div><p class="calibre9">You can<a id="id434" class="calibre1"/> determine whether an element is inside a <code class="email">TSet</code> or not by using the <code class="email">Find()</code> member function on the set. The <code class="email">TSet</code> will return a pointer to the entry in the <code class="email">TSet</code> that matches your query if the element exists in the <code class="email">TSet</code>, or it will return <code class="email">NULL</code> if the element you're asking for does not exist in the <code class="email">TSet</code>.</p></div></div>

<div class="book" title="TMap&lt;T, S&gt;" id="21PMQ1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>TMap&lt;T, S&gt;</h1></div></div></div><p class="calibre9">A <code class="email">TMap&lt;T, S&gt;</code>
<a id="id435" class="calibre1"/> creates<a id="id436" class="calibre1"/> a table of sorts in the RAM. A <code class="email">TMap</code> represents a mapping of the keys at the left to the values on the right-hand side. You can visualize a <code class="email">TMap</code> as a two-column table, with keys in the left column and values in the right column.</p></div>

<div class="book" title="TMap&lt;T, S&gt;" id="21PMQ1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="A list of items for the player's inventory"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec105" class="calibre1"/>A list of items for the player's inventory</h2></div></div></div><p class="calibre9">For<a id="id437" class="calibre1"/> example, say we wanted to create a C++ data structure in order to store a list of items for the player's inventory. On the left-hand side of the table (the keys), we'd have an <code class="email">FString</code> for the item's name. On the right-hand side (the values), we'd have an <code class="email">int</code> for the quantity of that item.</p><div class="note"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Item (Key)</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Quantity (Value)</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">apples</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">donuts</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">12</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">swords</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">1</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">shields</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">2</p>
</td></tr></tbody></table></div><p class="calibre9">To do this in code, we'd simply use the following:</p><div class="note"><pre class="programlisting">TMap&lt;FString, int&gt; items;
items.Add( "apples", 4 );
items.Add( "donuts", 12 );
items.Add( "swords", 1 );
items.Add( "shields", 2 );</pre></div><p class="calibre9">Once you have created your <code class="email">TMap</code>, you can access values inside the <code class="email">TMap</code> using square brackets and by passing a key between the brackets. For example, in the <code class="email">items</code> map in the preceding code, <code class="email">items[ "apples" ]</code> is 4.</p><div class="note" title="Note"><h3 class="title2"><a id="tip54" class="calibre1"/>Tip</h3><p class="calibre9">UE4 will crash if you use square brackets to access a key that doesn't exist in the map yet, so be careful! The C++ STL does not crash if you do this.</p></div></div></div>

<div class="book" title="TMap&lt;T, S&gt;" id="21PMQ1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Iterating a TMap"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec106" class="calibre1"/>Iterating a TMap</h2></div></div></div><p class="calibre9">In order<a id="id438" class="calibre1"/> to iterate a <code class="email">TMap</code>, you use an iterator as well:</p><div class="note"><pre class="programlisting">for( TMap&lt;FString, int&gt;::TIterator it = items.CreateIterator(); it; ++it )
{
  GEngine-&gt;AddOnScreenDebugMessage( count++, 30.f, FColor::Red,
  it-&gt;Key + FString(": ") + FString::FromInt( it-&gt;Value ) );
}</pre></div><p class="calibre9">
<code class="email">TMap</code> iterators are slightly different from <code class="email">TArray</code> or <code class="email">TSet</code> iterators. A <code class="email">TMap</code> iterator contains both a <code class="email">Key</code> and a <code class="email">Value</code>. We can access the key inside with <code class="email">it-&gt;Key</code> and the value inside<a id="id439" class="calibre1"/> the <code class="email">TMap</code> with <code class="email">it-&gt;Value</code>.</p><div class="mediaobject"><img src="../images/00140.jpeg" alt="Iterating a TMap" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="C++ STL versions of commonly used containers" id="22O7C1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec68" class="calibre1"/>C++ STL versions of commonly used containers</h1></div></div></div><p class="calibre9">I want to<a id="id440" class="calibre1"/> cover the C++ STL versions of a couple of containers. STL is the standard template library, which is shipped with most C++ compilers. The reason why I want to cover these STL versions is that they behave somewhat differently than the UE4 versions of the same containers. In some ways, their behavior is very good, but game programmers often complain of STL having performance issues. In particular, I want to cover STL's <code class="email">set</code> and <code class="email">map</code> containers.</p><div class="note" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre9">If you like STL's interface but want better performance, there is a well-known reimplementation of the STL library by Electronic Arts called EASTL, which you can use. It provides the same functionality as STL but is implemented with better performance (basically by doing things such as eliminating bounds checking). It is available <a id="id441" class="calibre1"/>on GitHub at <a class="calibre1" href="https://github.com/paulhodge/EASTL">https://github.com/paulhodge/EASTL</a>.</p></div></div>

<div class="book" title="C++ STL versions of commonly used containers" id="22O7C1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="C++ STL set"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec107" class="calibre1"/>C++ STL set</h2></div></div></div><p class="calibre9">A <a id="id442" class="calibre1"/>C++ set<a id="id443" class="calibre1"/> is a bunch of items that are unique and sorted. The good feature about the STL <code class="email">set</code> is that it keeps the set elements sorted. A quick and dirty way to sort a bunch of values is actually to just shove them into the same <code class="email">set</code>. The <code class="email">set</code> will take care of the sorting for you.</p><p class="calibre9">We can return to a simple C++ console application for the usage of sets. To use the C++ STL set you need to include <code class="email">&lt;set&gt;</code>, as shown here:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;set&gt;
using namespace std;

int main()
{
  set&lt;int&gt; intSet;
  intSet.insert( 7 );
  intSet.insert( 7 );
  intSet.insert( 8 );
  intSet.insert( 1 );

  for( set&lt;int&gt;::iterator it = intSet.begin(); it != intSet.end();  ++it )
  {
    cout &lt;&lt; *it &lt;&lt; endl;
  }
}</pre></div><p class="calibre9">The following is the output of the preceding code:</p><div class="note"><pre class="programlisting">1
7
8</pre></div><p class="calibre9">The duplicate <code class="email">7</code> is filtered out, and the elements are kept in increasing order inside the <code class="email">set</code>. The way we<a id="id444" class="calibre1"/> iterate over the<a id="id445" class="calibre1"/> elements of an STL container is similar to UE4's <code class="email">TSet</code> array. The <code class="email">intSet.begin()</code> function returns an iterator that points to the head of the <code class="email">intSet</code>. </p><p class="calibre9">The condition to stop iterating is when <code class="email">it</code> becomes <code class="email">intSet.end()</code>. <code class="email">intSet.end()</code> is actually one position past the end of the <code class="email">set</code>, as shown in the following figure:</p><div class="mediaobject"><img src="../images/00141.jpeg" alt="C++ STL set" class="calibre11"/></div><p class="calibre12"> </p><div class="book" title="Finding an element in a &lt;set&gt;"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec31" class="calibre1"/>Finding an element in a &lt;set&gt;</h3></div></div></div><p class="calibre9">To find <a id="id446" class="calibre1"/>an element inside an STL <code class="email">set</code>, we can use the <code class="email">find()</code> member function. If the item we're looking for turns up in the <code class="email">set</code>, we get an iterator that points to the element we were searching for. If the item that we were looking for is not in the <code class="email">set</code>, we get back <code class="email">set.end()</code>instead, as shown here:</p><div class="note"><pre class="programlisting">set&lt;int&gt;::iterator it = intSet.find( 7 );
if( it != intSet.end() )
{
  //  7  was inside intSet, and *it has its value
  cout &lt;&lt; "Found " &lt;&lt; *it &lt;&lt; endl;
}</pre></div></div><div class="book" title="Exercise"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec32" class="calibre1"/>Exercise</h3></div></div></div><p class="calibre9">Ask <a id="id447" class="calibre1"/>the user for a set of three unique names. Take each name in, one by one, and then print them in a sorted order. If the user repeats a name, then ask them for another one until you get to three.</p></div><div class="book" title="Solution"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec33" class="calibre1"/>Solution</h3></div></div></div><p class="calibre9">The <a id="id448" class="calibre1"/>solution of the preceding exercise can be found using the following code:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
using namespace std;
int main()
{
  set&lt;string&gt; names;
  // so long as we don't have 3 names yet, keep looping,
  while( names.size() &lt; 3 )
  {
    cout &lt;&lt; names.size() &lt;&lt; " names so far. Enter a name" &lt;&lt; endl;
    string name;
    cin &gt;&gt; name;
    names.insert( name ); // won't insert if already there,
  }
  // now print the names. the set will have kept order
  for( set&lt;string&gt;::iterator it = names.begin(); it !=  names.end(); ++it )
  {
    cout &lt;&lt; *it &lt;&lt; endl;
  }
}</pre></div></div></div></div>

<div class="book" title="C++ STL versions of commonly used containers" id="22O7C1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="C++ STL map"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec108" class="calibre1"/>C++ STL map</h2></div></div></div><p class="calibre9">The <a id="id449" class="calibre1"/>C++ STL <code class="email">map</code> object<a id="id450" class="calibre1"/> is a lot like UE4's <code class="email">TMap</code> object. The one thing it does that <code class="email">TMap</code> does not is to maintain a sorted order inside the map as well. Sorting introduces an additional cost, but if you want your map to be sorted, opting for the STL version might be a good choice.</p><p class="calibre9">To use the C++ STL <code class="email">map</code> object, we include <code class="email">&lt;map&gt;</code>. In the following example program, we populate a map of items with some key-value pairs:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
int main()
{
  map&lt;string, int&gt; items;
  items.insert( make_pair( "apple", 12 ) );
  items.insert( make_pair( "orange", 1 ) );
  items.insert( make_pair( "banana", 3 ) );
  // can also use square brackets to insert into an STL map
  items[ "kiwis" ] = 44;

  for( map&lt;string, int&gt;::iterator it = items.begin(); it !=  items.end(); ++it )
  {
    cout &lt;&lt; "items[ " &lt;&lt; it-&gt;first &lt;&lt; " ] = " &lt;&lt; it-&gt;second &lt;&lt;  endl;
  }
}</pre></div><p class="calibre9">This is<a id="id451" class="calibre1"/> the<a id="id452" class="calibre1"/> output of the preceding program:</p><div class="note"><pre class="programlisting">items[ apple ] = 12
items[ banana ] = 3
items[ kiwis ] = 44
items[ orange ] = 1</pre></div><p class="calibre9">Notice how the iterator's syntax for an STL map is slightly different than that of <code class="email">TMap</code>: we access the key using <code class="email">it-&gt;first</code> and the value using <code class="email">it-&gt;second</code>.</p><p class="calibre9">Notice how C++ STL also offers a bit of syntactic sugar over <code class="email">TMap</code>; you can use square brackets to insert into the C++ STL <code class="email">map</code>. You cannot use square brackets to insert into a <code class="email">TMap</code>.</p><div class="book" title="Finding an element in a &lt;map&gt;"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec34" class="calibre1"/>Finding an element in a &lt;map&gt;</h3></div></div></div><p class="calibre9">You<a id="id453" class="calibre1"/> can search a map for a &lt;<code class="email">key</code>, <code class="email">value</code>&gt; pair using the STL map's <code class="email">find</code> member function.</p></div><div class="book" title="Exercise"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec35" class="calibre1"/>Exercise</h3></div></div></div><p class="calibre9">Ask the <a id="id454" class="calibre1"/>user to enter five items and their quantities into an empty <code class="email">map</code>. Print the results in sorted order.</p></div><div class="book" title="Solution"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec36" class="calibre1"/>Solution</h3></div></div></div><p class="calibre9">The solution of the preceding exercise uses the following code:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
int main()
{
  map&lt;string, int&gt; items;
  cout &lt;&lt; "Enter 5 items, and their quantities" &lt;&lt; endl;
  while( items.size() &lt; 5 )
  {
    cout &lt;&lt; "Enter item" &lt;&lt; endl;
    string item;
    cin &gt;&gt; item;
    cout &lt;&lt; "Enter quantity" &lt;&lt; endl;
    int qty;
    cin &gt;&gt; qty;
    items[ item ] = qty; // save in map, square brackets
    // notation
  }

  for( map&lt;string, int&gt;::iterator it = items.begin(); it !=  items.end(); ++it )
  {
    cout &lt;&lt; "items[ " &lt;&lt; it-&gt;first &lt;&lt; " ] = " &lt;&lt; it-&gt;second &lt;&lt;  endl;
  }
}</pre></div><p class="calibre9">In this solution code, we <a id="id455" class="calibre1"/>start by creating <code class="email">map&lt;string, int&gt; items</code> to store all the items we're going to take in. Ask the user for an item and a quantity; then we save the <code class="email">item</code> in the <code class="email">items</code> map using square brackets notation.</p></div></div></div>
<div class="book" title="Summary" id="23MNU1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec69" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">UE4's containers and the C++ STL family of containers are both excellent for storing game data. Often, a programming problem can be simplified many times by selecting the right type of data container.</p><p class="calibre9">In the next chapter, we will actually get to programming the beginning of our game by keeping track of what the player is carrying and storing that information in a <code class="email">TMap</code> object.</p></div></body></html>