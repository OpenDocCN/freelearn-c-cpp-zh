<html><head></head><body>
<div class="book" title="Chapter&#xA0;12.&#xA0;Spell Book"><div class="book" id="2C9D02-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12" class="calibre1"/>Chapter 12. Spell Book</h1></div></div></div><p class="calibre9">The player does not yet have a means to defend himself. We will equip the player with a very useful and interesting way, of doing so called magic spells. Magic spells will be used by the player to affect monsters nearby.</p><p class="calibre9">Practically, spells <a id="id600" class="calibre1"/>will be a combination of a particle system with an area of effect represented by a bounding volume. The bounding volume is checked for contained actors in each frame. When an actor is within the bounding volume of a spell, then that actor is affected by that spell.</p><p class="calibre9">The following is a screenshot of the blizzard and force field spells, with their bounding volumes highlighted in orange:</p><div class="mediaobject"><img src="../images/00219.jpeg" alt="Spell Book" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Visualization of the blizzard spell<a id="id601" class="calibre1"/> can be seen at the right, with a long, box-shaped bounding volume. Visualization of the force field spell, with a spherical bounding volume, for pushing monsters away, is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00220.jpeg" alt="Spell Book" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">In each frame, the bounding volume is checked for contained actors. Any actor contained in the spell's bounding volume is going to be affected by that spell for that frame only. If the actor moves outside  the spell's bounding volume, the actor will no longer be affected by that spell. Remember, the spell's particle system is a visualization only; the particles themselves are not what will affect game actors. The <code class="email">PickupItem</code> class we created in <a class="calibre1" title="Chapter 8. Actors and Pawns" href="part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d">Chapter 8</a>, <span class="strong"><em class="calibre10">Actors and Pawns</em></span> can be used to allow the player to pick up items representing the spells. We will extend the <code class="email">PickupItem</code> class and attach the blueprint of a spell to cast  each <code class="email">PickupItem</code>. Clicking on a spell's widget from the HUD will cast it. The interface will look something like this:</p><div class="mediaobject"><img src="../images/00221.jpeg" alt="Spell Book" class="calibre11"/><div class="caption"><p class="calibre16">Items the player has picked up, including four different spells</p></div></div><p class="calibre12"> </p><p class="calibre9">We'll begin the chapter by describing how to create our own particle systems. We'll then move on to wrap up the particle emitter into a <code class="email">Spell</code> class, and write a <code class="email">CastSpell()</code> function for the avatar to be able to actually cast spells.</p></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Spell Book">
<div class="book" title="The particle systems"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch12lvl1sec79" class="calibre1"/>The particle systems</h1></div></div></div><p class="calibre9">First, we need a <a id="id602" class="calibre1"/>place to put all  our snazzy effects. In your <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab, right-click on the <span class="strong"><strong class="calibre2">Game</strong></span> root and create a new folder called <span class="strong"><strong class="calibre2">ParticleSystems</strong></span>. Right-click on that new folder, and select <span class="strong"><strong class="calibre2">New Asset</strong></span> | <span class="strong"><strong class="calibre2">Particle System</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00222.jpeg" alt="The particle systems" class="calibre11"/></div><p class="calibre12"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip65" class="calibre1"/>Tip</h3><p class="calibre9">See this Unreal Engine 4 Particle Systems guide for information on how unreal particle emitters<a id="id603" class="calibre1"/> work: <a class="calibre1" href="https://www.youtube.com/watch?v=OXK2Xbd7D9w&amp;index=1&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t">https://www.youtube.com/watch?v=OXK2Xbd7D9w&amp;index=1&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t</a>.</p></div><p class="calibre9">Double-click on the <a id="id604" class="calibre1"/>
<span class="strong"><strong class="calibre2">NewParticleSystem</strong></span> icon that appears, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00223.jpeg" alt="The particle systems" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">You will be in Cascade, the particle editor. A description of the environment is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00224.jpeg" alt="The particle systems" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">There are several <a id="id605" class="calibre1"/>different panes here, each of which shows different information. They are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">At the top left is the <span class="strong"><strong class="calibre2">Viewport</strong></span> pane. This shows you an animation of the current emitter as its currently working.</li><li class="listitem">At the right is the <span class="strong"><strong class="calibre2">Emitters</strong></span> pane. Inside it, you can see a single object called <span class="strong"><strong class="calibre2">Particle Emitter</strong></span> (you can have more than one emitter in your particle system, but we don't want that now). The listing of modules of <span class="strong"><strong class="calibre2">Particle Emitter</strong></span> appears listed under it. From the preceding screenshot, we have the <span class="strong"><strong class="calibre2">Required</strong></span>, <span class="strong"><strong class="calibre2">Spawn</strong></span>, <span class="strong"><strong class="calibre2">Lifetime</strong></span>, <span class="strong"><strong class="calibre2">Initial Size</strong></span>, <span class="strong"><strong class="calibre2">Initial Velocity</strong></span>, and <span class="strong"><strong class="calibre2">Color Over Life</strong></span> modules.</li></ul></div></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Spell Book">
<div class="book" title="The particle systems">
<div class="book" title="Changing particle properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec121" class="calibre1"/>Changing particle properties</h2></div></div></div><p class="calibre9">The default <a id="id606" class="calibre1"/>particle emitter emits crosshair-like shapes. We want to change that to something more interesting. Click on the yellow <span class="strong"><strong class="calibre2">Required</strong></span> box under <span class="strong"><strong class="calibre2">Emitters</strong></span> panel, then under <span class="strong"><strong class="calibre2">Material</strong></span> in the <span class="strong"><strong class="calibre2">Details</strong></span> panel, type <code class="email">particles</code>. A list of all the available particle materials will pop up. Choose <span class="strong"><strong class="calibre2">m_flare_01</strong></span> option to create our first particle system, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00225.jpeg" alt="Changing particle properties" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Now, let's change the behavior of the particle system. Click on the <span class="strong"><strong class="calibre2">Color Over Life</strong></span> entry under the <span class="strong"><strong class="calibre2">Emitters</strong></span> pane. The <span class="strong"><strong class="calibre2">Details</strong></span> pane at the bottom shows the information about the different parameters, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00226.jpeg" alt="Changing particle properties" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">In the<a id="id607" class="calibre1"/> <span class="strong"><strong class="calibre2">Details</strong></span> pane of <span class="strong"><strong class="calibre2">Color Over Life</strong></span> entry, I increased <span class="strong"><strong class="calibre2">X</strong></span>, but not <span class="strong"><strong class="calibre2">Y</strong></span> and not <span class="strong"><strong class="calibre2">Z</strong></span>. This gives the particle system a reddish glow. (<span class="strong"><strong class="calibre2">X</strong></span> is red, <span class="strong"><strong class="calibre2">Y</strong></span> is green, and <span class="strong"><strong class="calibre2">Z</strong></span> is blue).</p><p class="calibre9">Instead of editing the raw numbers, however, you can actually change the particle color more visually. If you click on the greenish zigzag button beside the <span class="strong"><strong class="calibre2">Color Over Life</strong></span> entry, you will see the graph for <span class="strong"><strong class="calibre2">Color Over Life</strong></span> displayed in the <span class="strong"><strong class="calibre2">Curve Editor</strong></span> tab, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00227.jpeg" alt="Changing particle properties" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">We can now change the<a id="id608" class="calibre1"/> <span class="strong"><strong class="calibre2">Color Over Life</strong></span> parameters. The graph in the <span class="strong"><strong class="calibre2">Curve Editor</strong></span> tab displays the emitted color versus the amount of time the particle has been alive. You can adjust the values by dragging the points around. Pressing <span class="strong"><em class="calibre10">Ctrl</em></span> + left mouse button adds a new point to a line:</p><div class="mediaobject"><img src="../images/00228.jpeg" alt="Changing particle properties" class="calibre11"/><div class="caption"><p class="calibre16">Ctrl + click adds points to lines.</p></div></div><p class="calibre12"> </p><p class="calibre9">You can play around <a id="id609" class="calibre1"/>with the particle emitter settings to create your own spell visualizations.</p></div></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Spell Book">
<div class="book" title="The particle systems">
<div class="book" title="Settings for the blizzard spell"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec122" class="calibre1"/>Settings for the blizzard spell</h2></div></div></div><p class="calibre9">At this point, we should rename our<a id="id610" class="calibre1"/> particle system, from <span class="strong"><strong class="calibre2">NewParticle System</strong></span> to something more descriptive. Let's rename it <span class="strong"><strong class="calibre2">P_Blizzard</strong></span>. You can rename your particle system by simply clicking on it and pressing <span class="strong"><em class="calibre10">F2</em></span>.</p><div class="mediaobject"><img src="../images/00229.jpeg" alt="Settings for the blizzard spell" class="calibre11"/><div class="caption"><p class="calibre16">Press <span class="strong"><em class="calibre10">F2</em></span> on an object in the Content Browser to rename it</p></div></div><p class="calibre12"> </p><div class="mediaobject"><img src="../images/00230.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">We will tweak some of the settings<a id="id611" class="calibre1"/> to get a blizzard particle effect spell. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Under the <span class="strong"><strong class="calibre2">Emitters</strong></span> tab, click on the <span class="strong"><strong class="calibre2">Required</strong></span> box. In the <span class="strong"><strong class="calibre2">Details</strong></span> pane, change the <span class="strong"><strong class="calibre2">Emitter</strong></span> material to <span class="strong"><strong class="calibre2">m_flare_01</strong></span> as shown:<div class="mediaobject"><img src="../images/00231.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Under the <span class="strong"><strong class="calibre2">Spawn</strong></span> module, change the spawn rate to 200. This increases the density of the visualization, as shown:<div class="mediaobject"><img src="../images/00232.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Under the <span class="strong"><strong class="calibre2">Lifetime</strong></span> <a id="id612" class="calibre1"/>module, increase the <span class="strong"><strong class="calibre2">Max</strong></span> property from 1.0 to 2.0. This introduces some variation to the length of time a particle will live, with some of the emitted particles living longer than others.<div class="mediaobject"><img src="../images/00233.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Under the <span class="strong"><strong class="calibre2">Initial Size</strong></span><a id="id613" class="calibre1"/> module, change the <span class="strong"><strong class="calibre2">Min</strong></span> property size to 12.5 in <span class="strong"><strong class="calibre2">X</strong></span>, <span class="strong"><strong class="calibre2">Y</strong></span>, and <span class="strong"><strong class="calibre2">Z</strong></span>:<div class="mediaobject"><img src="../images/00234.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">Under the <span class="strong"><strong class="calibre2">Initial Velocity</strong></span> module, change the <span class="strong"><strong class="calibre2">Min</strong></span>/<span class="strong"><strong class="calibre2">Max</strong></span> values to the values shown:<div class="mediaobject"><img src="../images/00235.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">The reason we're <a id="id614" class="calibre1"/>having the blizzard blow in +X is because the player's forward direction starts out in +X. Since the spell will come from the player's hands, we want the spell to point in the same direction as the player.</li><li class="listitem" value="7">Under the <span class="strong"><strong class="calibre2">Color Over Life</strong></span> menu, change the blue (<span class="strong"><strong class="calibre2">Z</strong></span>) value to 100.0. You will see an instant change to a blue glow:<div class="mediaobject"><img src="../images/00236.jpeg" alt="Settings for the blizzard spell" class="calibre11"/><div class="caption"><p class="calibre16">Now it's starting to look magical!</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="8">Right-click on the <a id="id615" class="calibre1"/>blackish area below the <span class="strong"><strong class="calibre2">Color Over Life</strong></span> module. Choose <span class="strong"><strong class="calibre2">Location</strong></span> | <span class="strong"><strong class="calibre2">Initial Location</strong></span>:<div class="mediaobject"><img src="../images/00237.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="9">Enter values under<a id="id616" class="calibre1"/> <span class="strong"><strong class="calibre2">Start Location</strong></span> | <span class="strong"><strong class="calibre2">Distribution</strong></span> as shown below:<div class="mediaobject"><img src="../images/00238.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="10">You should have a blizzard that looks like this:<div class="mediaobject"><img src="../images/00239.jpeg" alt="Settings for the blizzard spell" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="11">Move the camera to <a id="id617" class="calibre1"/>a position you like, then click on the <span class="strong"><strong class="calibre2">Thumbnail</strong></span> option in the top menu bar. This will generate a thumbnail icon for your particle system in the <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab.<div class="mediaobject"><img src="../images/00240.jpeg" alt="Settings for the blizzard spell" class="calibre11"/><div class="caption"><p class="calibre16">Clicking Thumbnail at the top menu bar will generate a mini icon for your particle system</p></div></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div></div>

<div class="book" title="Spell class actor"><div class="book" id="2D7TI2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec80" class="calibre1"/>Spell class actor</h1></div></div></div><p class="calibre9">The <code class="email">Spell</code> class <a id="id618" class="calibre1"/>will ultimately do damage to all the monsters. Towards that end, we need to contain both a particle system and a bounding box inside the <code class="email">Spell</code> class actor. When a <code class="email">Spell</code> class is cast by the avatar, the <code class="email">Spell</code> object will be instantiated into the level and start <code class="email">Tick()</code> functioning. On every <code class="email">Tick()</code> of the <code class="email">Spell</code> object, any monster contained inside the spell's bounding volume will be affected by that <code class="email">Spell</code>.</p><p class="calibre9">The <code class="email">Spell</code> class should look something like the following code:</p><div class="note"><pre class="programlisting">UCLASS()
class GOLDENEGG_API ASpell : public AActor
{
  GENERATED_UCLASS_BODY()

  // box defining volume of damage
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Spell)
  TSubobjectPtr&lt;UBoxComponent&gt; ProxBox;

  // the particle visualization of the spell
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Spell)
  TSubobjectPtr&lt;UParticleSystemComponent&gt; Particles;

  // How much damage the spell does per second
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Spell)
  float DamagePerSecond;

  // How long the spell lasts
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Spell)
  float Duration;

  // Length of time the spell has been alive in the level
  float TimeAlive;

  // The original caster of the spell (so player doesn't
  // hit self)
  AActor* Caster;

  // Parents this spell to a caster actor
  void SetCaster( AActor* caster );

  // Runs each frame. override the Tick function to deal damage 
  // to anything in ProxBox each frame.
  virtual void Tick( float DeltaSeconds ) override;
};</pre></div><p class="calibre9">There are only three functions we need to worry about implementing, namely the <code class="email">ASpell::ASpell()</code> constructor, the <code class="email">ASpell::SetCaster()</code> function, and the <code class="email">ASpell::Tick()</code> function.</p><p class="calibre9">Open the <code class="email">Spell.cpp</code> file. Add a line to include the <code class="email">Monster.h</code> file, so we can access the definition of <code class="email">Monster</code> objects inside the <code class="email">Spell.cpp</code> file, as shown in the following line of code:</p><div class="note"><pre class="programlisting">#include "Monster.h"</pre></div><p class="calibre9">First, the<a id="id619" class="calibre1"/> constructor, which sets up the spell and initializes all components is shown in the following code:</p><div class="note"><pre class="programlisting">ASpell::ASpell(const class FPostConstructInitializeProperties&amp;  PCIP) : Super(PCIP)
{
  ProxBox = PCIP.CreateDefaultSubobject&lt;UBoxComponent&gt;(this,  TEXT("ProxBox"));
  Particles = PCIP.CreateDefaultSubobject&lt;UParticleSystemComponent&gt;(this,  TEXT("ParticleSystem"));

  // The Particles are the root component, and the ProxBox
  // is a child of the Particle system.
  // If it were the other way around, scaling the ProxBox
  // would also scale the Particles, which we don't want
  RootComponent = Particles;
  ProxBox-&gt;AttachTo( RootComponent );

  Duration = 3;
  DamagePerSecond = 1;
  TimeAlive = 0;

  PrimaryActorTick.bCanEverTick = true;//required for spells to 
  // tick!
}</pre></div><p class="calibre9">Of particular importance is the last line here, <code class="email">PrimaryActorTick.bCanEverTick = true</code>. If you don't set that, your <code class="email">Spell</code> objects won't ever have <code class="email">Tick()</code> called.</p><p class="calibre9">Next, we have the <code class="email">SetCaster()</code> method. This is called so that the person who casts the spell is known to the <code class="email">Spell</code> object.  We can ensure that the caster can't hurt himself with his own spells by using the following code:</p><div class="note"><pre class="programlisting">void ASpell::SetCaster( AActor *caster )
{
  Caster = caster;
  AttachRootComponentTo( caster-&gt;GetRootComponent() );
}</pre></div><p class="calibre9">Finally, we <a id="id620" class="calibre1"/>have the <code class="email">ASpell::Tick()</code> method, which actually deals damage to all contained actors, as shown in the following code:</p><div class="note"><pre class="programlisting">void ASpell::Tick( float DeltaSeconds )
{
  Super::Tick( DeltaSeconds );

  // search the proxbox for all actors in the volume.
  TArray&lt;AActor*&gt; actors;
  ProxBox-&gt;GetOverlappingActors( actors );

  // damage each actor the box overlaps
  for( int c = 0; c &lt; actors.Num(); c++ )
  {
    // don't damage the spell caster
    if( actors[ c ] != Caster )
    {
      // Only apply the damage if the box is overlapping
      // the actors ROOT component.
      // This way damage doesn't get applied for simply 
      // overlapping the SightSphere of a monster
      AMonster *monster = Cast&lt;AMonster&gt;( actors[c] );

      if( monster &amp;&amp; ProxBox-&gt;IsOverlappingComponent( monster- &gt;CapsuleComponent ) )
      {
        monster-&gt;TakeDamage( DamagePerSecond*DeltaSeconds,  FDamageEvent(), 0, this );
      }

      // to damage other class types, try a checked cast 
      // here..
    }
  }

  TimeAlive += DeltaSeconds;
  if( TimeAlive &gt; Duration )
  {
    Destroy();
  }
}</pre></div><p class="calibre9">The <code class="email">ASpell::Tick()</code> function does a number of things, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Gets all actors overlapping <code class="email">ProxBox</code>. Any actor that is not the caster gets damaged if the component overlapped is the root component of that object. The reason we have to check for overlapping with the root component is because if we don't, the spell might overlap the monster's <code class="email">SightSphere</code>, which means we will get hits from very far away, which we don't want.</li><li class="listitem">Notices that if we had another class of thing that should get damaged, we would have to attempt a cast to each object type specifically. Each class type might have a different type of bounding volume that should be collided with, other types might not even have <code class="email">CapsuleComponent</code> (they might have <code class="email">ProxBox</code> or <code class="email">ProxSphere</code>).</li><li class="listitem">Increases the amount of time the spell has been alive for. If the spell exceeds the duration it is allotted to be cast for, it is removed from the level.</li></ul></div><p class="calibre9">Now, let's focus on <a id="id621" class="calibre1"/>how the player can acquire spells, by creating an individual <code class="email">PickupItem</code> for each spell object that the player can pick up.</p></div>

<div class="book" title="Spell class actor">
<div class="book" title="Blueprinting our spells"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec123" class="calibre1"/>Blueprinting our spells</h2></div></div></div><p class="calibre9">Compile and run your <a id="id622" class="calibre1"/>C++ project with the <code class="email">Spell</code> class that we just added. We need to create blueprints for each of the spells we want to be able to cast. In the <span class="strong"><strong class="calibre2">Class Viewer</strong></span> tab, start to type <code class="email">Spell</code>, and you should see your <code class="email">Spell</code> class appear. Right-click on <span class="strong"><strong class="calibre2">Spell</strong></span>, and create a blueprint called <span class="strong"><strong class="calibre2">BP_Spell_Blizzard</strong></span>, and then double-click to open it, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00241.jpeg" alt="Blueprinting our spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Inside the spell's properties, choose the <span class="strong"><strong class="calibre2">P_Blizzard</strong></span> spell for the particle emitter, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00242.jpeg" alt="Blueprinting our spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Scroll down until you reach the <span class="strong"><strong class="calibre2">Spell</strong></span> category, and update the <span class="strong"><strong class="calibre2">Damage Per Second</strong></span> and <span class="strong"><strong class="calibre2">Duration</strong></span> parameters to values you like. Here, the blizzard spell will last 3.0 seconds, and do 16.0 damage total per second. After three seconds, the blizzard will disappear.</p><div class="mediaobject"><img src="../images/00243.jpeg" alt="Blueprinting our spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">After you have <a id="id623" class="calibre1"/>configured the <span class="strong"><strong class="calibre2">Default</strong></span> properties, switch over to the <span class="strong"><strong class="calibre2">Components</strong></span> tab to make some further modifications. Click on and change the shape of <code class="email">ProxBox</code> so that its shape makes sense. The box should wrap the most intense part of the particle system, but don't get carried away in expanding its size. The <code class="email">ProxBox</code> object shouldn't be too big, because then your blizzard spell would affect things that aren't even being touched by the blizzard. As shown in the following screenshot, a couple of outliers are ok.</p><div class="mediaobject"><img src="../images/00244.jpeg" alt="Blueprinting our spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Your blizzard spell is now blueprinted and ready to be used by the player.</p></div></div>

<div class="book" title="Spell class actor">
<div class="book" title="Picking up spells"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec124" class="calibre1"/>Picking up spells</h2></div></div></div><p class="calibre9">Recall that we<a id="id624" class="calibre1"/> previously programmed our inventory to display the number of pickup items the player has when the user presses <span class="strong"><em class="calibre10">I</em></span>. We want to do more than that, however.</p><div class="mediaobject"><img src="../images/00245.jpeg" alt="Picking up spells" class="calibre11"/><div class="caption"><p class="calibre16">Items displayed when the user presses <span class="strong"><em class="calibre10">I</em></span>
</p></div></div><p class="calibre12"> </p><p class="calibre9">To allow the player to pick up spells, we'll modify the <code class="email">PickupItem</code> class to include a slot for a blueprint of the spell the player casts by using the following code:</p><div class="note"><pre class="programlisting">// inside class APickupItem:
// If this item casts a spell when used, set it here
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
UClass* Spell;</pre></div><p class="calibre9">Once you've added the <code class="email">UClass* Spell</code> property to the <code class="email">APickupItem</code> class, recompile and rerun your C++ project. Now, you can proceed to make blueprints of <code class="email">PickupItem</code> instances for your <code class="email">Spell</code> objects.</p><div class="book" title="Creating blueprints for PickupItems that cast spells"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec53" class="calibre1"/>Creating blueprints for PickupItems that cast spells</h3></div></div></div><p class="calibre9">Create a <a id="id625" class="calibre1"/>
<span class="strong"><strong class="calibre2">PickupItem</strong></span> blueprint called <span class="strong"><strong class="calibre2">BP_Pickup_Spell_Blizzard</strong></span>. Double-click on it to edit its properties, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00246.jpeg" alt="Creating blueprints for PickupItems that cast spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">I set the blizzard item's pickup properties as follows: </p><p class="calibre9">The name of the item is <span class="strong"><strong class="calibre2">Blizzard Spell</strong></span>, and five are in each package. I took a screenshot of the blizzard particle system and imported it to the project, so the <span class="strong"><strong class="calibre2">Icon</strong></span> is selected as that<a id="id626" class="calibre1"/> image. Under spell, I selected <span class="strong"><strong class="calibre2">BP_Spell_Blizzard</strong></span> as the name of the spell to be cast (not <span class="strong"><strong class="calibre2">BP_Pickup_Spell_Blizzard</strong></span>), as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00247.jpeg" alt="Creating blueprints for PickupItems that cast spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">I selected a blue sphere for the <code class="email">Mesh</code> class of the <code class="email">PickupItem</code> class. For <span class="strong"><strong class="calibre2">Icon</strong></span>, I took a screenshot of the blizzard spell in the particle viewer preview, saved it to disk, and imported that image to the project (see the images folder in the <span class="strong"><strong class="calibre2">Content Browser</strong></span> tab of the sample project).</p><div class="mediaobject"><img src="../images/00248.jpeg" alt="Creating blueprints for PickupItems that cast spells" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Place a few <a id="id627" class="calibre1"/>of these <code class="email">PickupItem</code> in your level. If we pick them up, we will have some blizzard spells in our inventory.</p><div class="mediaobject"><img src="../images/00249.jpeg" alt="Creating blueprints for PickupItems that cast spells" class="calibre11"/><div class="caption"><p class="calibre16">Left: Blizzard spell pickup items in game world. Right: Blizzard spell pickup item in inventory.</p></div></div><p class="calibre12"> </p><p class="calibre9">Now we need to activate the blizzard. Since we already attached the left mouse click in <a class="calibre1" title="Chapter 10. Inventory System and Pickup Items" href="part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d">Chapter 10</a>, <span class="strong"><em class="calibre10">Inventory System and Pickup Items</em></span> to dragging the icons around, let's attach the right mouse click to casting the spell.</p></div></div></div>

<div class="book" title="Attaching right mouse click to cast spell"><div class="book" id="2E6E42-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec81" class="calibre1"/>Attaching right mouse click to cast spell</h1></div></div></div><p class="calibre9">The <a id="id628" class="calibre1"/>right mouse click will have to go through<a id="id629" class="calibre1"/> quite a few function calls before calling the avatar's <code class="email">CastSpell</code> method. The call graph would look something like the following screenshot:</p><div class="mediaobject"><img src="../images/00250.jpeg" alt="Attaching right mouse click to cast spell" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">A few things happen between right click and spell cast. They are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">As we saw before, all user mouse and keyboard interactions are routed through the <code class="email">Avatar</code> object. When the <code class="email">Avatar</code> object detects a right-click, it will pass the click event to <code class="email">HUD</code> through <code class="email">AAvatar::MouseRightClicked()</code>.</li><li class="listitem">Recall from <a class="calibre1" title="Chapter 10. Inventory System and Pickup Items" href="part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d">Chapter 10</a>, <span class="strong"><em class="calibre10">Inventory System and Pickup Items</em></span> where  we used a <code class="email">struct Widget</code> class to keep track of the items the player had picked up. <code class="email">struct Widget</code> only had three members:<div class="note"><pre class="programlisting">struct Widget
{
  Icon icon;
  FVector2D pos, size;
  ///.. and some member functions
};</pre></div><p class="calibre26">We will need to add an extra property for <code class="email">struct Widget</code> class to remember the spell it casts.</p><p class="calibre26">The <code class="email">HUD</code> will determine if the click event was inside  <code class="email">Widget</code> in <code class="email">AMyHUD::MouseRightClicked()</code>.</p></li><li class="listitem">If the click was on the <code class="email">Widget</code> that casts a spell, the <code class="email">HUD</code> then calls the avatar back with the request to cast  that spell, by calling <code class="email">AAvatar::CastSpell()</code>.</li></ul></div></div>

<div class="book" title="Attaching right mouse click to cast spell">
<div class="book" title="Writing the avatar's CastSpell function"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec125" class="calibre1"/>Writing the avatar's CastSpell function</h2></div></div></div><p class="calibre9">We will implement<a id="id630" class="calibre1"/> the preceding call graph in reverse. We will start by writing the function that actually casts spells in the game, <code class="email">AAvatar::CastSpell()</code>, as shown in the following code:</p><div class="note"><pre class="programlisting">void AAvatar::CastSpell( UClass* bpSpell )
{
  // instantiate the spell and attach to character
  ASpell *spell = GetWorld()-&gt;SpawnActor&lt;ASpell&gt;(bpSpell,  FVector(0), FRotator(0) );

  if( spell )
  {
    spell-&gt;SetCaster( this );
  }
  else
  {
    GEngine-&gt;AddOnScreenDebugMessage( 1, 5.f, FColor::Yellow,  FString("can't cast ") + bpSpell-&gt;GetName() );
  }
}</pre></div><p class="calibre9">You might find that actually calling a spell is remarkably simple. There are two basic steps to casting the spell:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Instantiate the spell object using the world object's <code class="email">SpawnActor</code> function</li><li class="listitem">Attach it to the avatar</li></ul></div><p class="calibre9">Once the <code class="email">Spell</code> object is instantiated, its <code class="email">Tick()</code> function will run each frame when that spell is in the level. On each <code class="email">Tick()</code>, the <code class="email">Spell</code> object will automatically feel out monsters within the level and damage them. A lot happens with each line of code mentioned previously, so let's discuss each line separately.</p><div class="book" title="Instantiating the spell – GetWorld()-&gt;SpawnActor()"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec54" class="calibre1"/>Instantiating the spell – GetWorld()-&gt;SpawnActor()</h3></div></div></div><p class="calibre9">To create <a id="id631" class="calibre1"/>the <code class="email">Spell</code> object from the blueprint, we need to call the <code class="email">SpawnActor()</code> function from <a id="id632" class="calibre1"/>the <code class="email">World</code> object. The <code class="email">SpawnActor()</code> function can take any blueprint and instantiate it within the level. Fortunately, the <code class="email">Avatar</code> object (and indeed any <code class="email">Actor</code> object) can get a handle to the <code class="email">World</code> object at any time by simply calling the <code class="email">GetWorld()</code> member function.</p><p class="calibre9">The line of code that brings the <code class="email">Spell</code> object into the level is as follows:</p><div class="note"><pre class="programlisting">ASpell *spell = GetWorld()-&gt;SpawnActor&lt;ASpell&gt;( bpSpell,  FVector(0), FRotator(0) );
</pre></div><p class="calibre9">There are a couple of things to note about the preceding line of code:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">bpSpell</code> must be the blueprint of a <code class="email">Spell</code> object to create. The <code class="email">&lt;ASpell&gt;</code> object in angle brackets indicates that expectation.</li><li class="listitem">The new <code class="email">Spell</code> object<a id="id633" class="calibre1"/> starts out at the origin (0, 0, 0), and with no<a id="id634" class="calibre1"/> additional rotation applied to it. This is because we will attach the <code class="email">Spell</code> object to the <code class="email">Avatar</code> object, which will supply translation and direction components for the <code class="email">Spell</code> object.</li></ul></div></div><div class="book" title="if(spell)"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec55" class="calibre1"/>if(spell)</h3></div></div></div><p class="calibre9">We always <a id="id635" class="calibre1"/>test if the call to <code class="email">SpawnActor&lt;ASpell&gt;()</code> succeeds by checking <code class="email">if( spell )</code>. If the blueprint passed to the <code class="email">CastSpell</code> object is not actually a blueprint based on the <code class="email">ASpell</code> class, then the <code class="email">SpawnActor()</code> function returns a <code class="email">NULL</code> pointer instead of a <code class="email">Spell</code> object. If that happens, we print an error message to the screen indicating that something went wrong during spell casting.</p></div><div class="book" title="spell-&gt;SetCaster(this)"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec56" class="calibre1"/>spell-&gt;SetCaster(this)</h3></div></div></div><p class="calibre9">When instantiating, if the <a id="id636" class="calibre1"/>spell does succeed, we attach the spell to the <code class="email">Avatar</code> object by calling <code class="email">spell-&gt;SetCaster( this )</code>. Remember, in the context of programming within the <code class="email">Avatar</code> class, the <code class="email">this</code> method is a reference to the <code class="email">Avatar</code> object.</p><p class="calibre9">Now, how do we actually connect spell casting from UI inputs, to call <code class="email">AAvatar::CastSpell()</code> function in the first place? We need to do some <code class="email">HUD</code> programming again.</p></div></div></div>

<div class="book" title="Attaching right mouse click to cast spell">
<div class="book" title="Writing AMyHUD::MouseRightClicked()"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec126" class="calibre1"/>Writing AMyHUD::MouseRightClicked()</h2></div></div></div><p class="calibre9">The spell cast commands will ultimately come from the HUD. We need to write a C++ function that will walk through all the <a id="id637" class="calibre1"/>HUD widgets and test to see if a click is on any one of them. If the click is on a <code class="email">widget</code> object, then that <code class="email">widget</code> object should respond by casting its spell, if it has one assigned.</p><p class="calibre9">We have to extend our <code class="email">Widget</code> object to have a variable to hold the blueprint of the spell to cast. Add a member to your <code class="email">struct Widget</code> object by using the following code:</p><div class="note"><pre class="programlisting">struct Widget
{
  Icon icon;
  // bpSpell is the blueprint of the spell this widget casts
  UClass *bpSpell;
  FVector2D pos, size;
  Widget(Icon iicon, UClass *iClassName)
}</pre></div><p class="calibre9">Now, recall that our <code class="email">PickupItem</code> had the blueprint of the spell it casts attached to it previously. However,  when the <code class="email">PickupItem</code> class is picked up from the level by the player, then the <code class="email">PickupItem</code> class is destroyed.</p><div class="note"><pre class="programlisting">// From APickupItem::Prox_Implementation():
avatar-&gt;Pickup( this ); // give this item to the avatar
// delete the pickup item from the level once it is picked up
Destroy();</pre></div><p class="calibre9">So, we need to retain the information of what spell each <code class="email">PickupItem</code> casts. We can do that when that <code class="email">PickupItem</code> is first picked up.</p><p class="calibre9">Inside the <code class="email">AAvatar</code> class, add an extra map to remember the blueprint of the spell that an item casts, by item name:</p><div class="note"><pre class="programlisting">// Put this in Avatar.h
TMap&lt;FString, UClass*&gt; Spells;</pre></div><p class="calibre9">Now in <code class="email">AAvatar::Pickup()</code>, remember the class of spell the <code class="email">PickupItem</code> class instantiates with the following line of code:</p><div class="note"><pre class="programlisting">// the spell associated with the item
Spells.Add(item-&gt;Name, item-&gt;Spell);</pre></div><p class="calibre9">Now, in <code class="email">AAvatar::ToggleInventory()</code>, we can have the <code class="email">Widget</code> object that displays on the screen. Remember <a id="id638" class="calibre1"/>what spell it is supposed to cast by looking up the <code class="email">Spells</code> map.</p><p class="calibre9">Find the line where we create the widget, and just under it, add assignment of the <code class="email">bpSpell</code> objects that the <code class="email">Widget</code> casts:</p><div class="note"><pre class="programlisting">// In AAvatar::ToggleInventory()
Widget w( Icon( fs, tex ) );
w.bpSpell = Spells[it-&gt;Key];</pre></div><p class="calibre9">Add the following function to <code class="email">AMyHUD</code>, which we will set to run whenever the right mouse button is clicked on the icon:</p><div class="note"><pre class="programlisting">void AMyHUD::MouseRightClicked()
{
  FVector2D mouse;
  APlayerController *PController = GetWorld()- &gt;GetFirstPlayerController();
  PController-&gt;GetMousePosition( mouse.X, mouse.Y );
  for( int c = 0; c &lt; widgets.Num(); c++ )
  {
    if( widgets[c].hit( mouse ) )
    {
      AAvatar *avatar = Cast&lt;AAvatar&gt;(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );
      if( widgets[c].spellName )
        avatar-&gt;CastSpell( widgets[c].spellName );
    }
  }
}</pre></div><p class="calibre9">This is very similar to <a id="id639" class="calibre1"/>our left mouse click function. We simply check the click position against all  the widgets. If any <code class="email">Widget</code> was hit by the right-click, and that <code class="email">Widget</code> has a <code class="email">Spell</code> object associated with it, then a spell will be cast by calling the avatar's <code class="email">CastSpell()</code> method.</p><div class="book" title="Activating right mouse button clicks"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec57" class="calibre1"/>Activating right mouse button clicks</h3></div></div></div><p class="calibre9">To connect this <a id="id640" class="calibre1"/>HUD function to run, we need to attach an event handler to the mouse right-click. We can do so by going to <span class="strong"><strong class="calibre2">Settings</strong></span> | <span class="strong"><strong class="calibre2">Project Settings</strong></span>, and from the dialog that pops up, adding an <span class="strong"><strong class="calibre2">Input</strong></span> option for <span class="strong"><strong class="calibre2">Right Mouse Button</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00251.jpeg" alt="Activating right mouse button clicks" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Declare a function in <code class="email">Avatar.h</code>/<code class="email">Avatar.cpp</code> called <code class="email">MouseRightClicked()</code> with the following code:</p><div class="note"><pre class="programlisting">void AAvatar::MouseRightClicked()
{
  if( inventoryShowing )
  {
    APlayerController* PController = GetWorld()- &gt;GetFirstPlayerController();
    AMyHUD* hud = Cast&lt;AMyHUD&gt;( PController-&gt;GetHUD() );
    hud-&gt;MouseRightClicked();
  }
}</pre></div><p class="calibre9">Then, in <code class="email">AAvatar::SetupPlayerInputComponent()</code>, we should attach <code class="email">MouseClickedRMB</code> event to that <code class="email">MouseRightClicked()</code> function:</p><div class="note"><pre class="programlisting">// In AAvatar::SetupPlayerInputComponent():
InputComponent-&gt;BindAction( "MouseClickedRMB", IE_Pressed, this,  &amp;AAvatar::MouseRightClicked );</pre></div><p class="calibre9">We have finally <a id="id641" class="calibre1"/>hooked up spell casting. Try it out, the gameplay is pretty cool, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00252.jpeg" alt="Activating right mouse button clicks" class="calibre11"/></div><p class="calibre12"> </p></div></div></div>

<div class="book" title="Creating other spells" id="2F4UM1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec82" class="calibre1"/>Creating other spells</h1></div></div></div><p class="calibre9">By playing around <a id="id642" class="calibre1"/>with particle systems, you can create a variety of different spells that do different effects.</p></div>

<div class="book" title="Creating other spells" id="2F4UM1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="The fire spell"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec127" class="calibre1"/>The fire spell</h2></div></div></div><p class="calibre9">You can <a id="id643" class="calibre1"/>easily create a fire variant of our blizzard spell by changing the color of the particle system to red:</p><div class="mediaobject"><img src="../images/00253.jpeg" alt="The fire spell" class="calibre11"/><div class="caption"><p class="calibre16">The out val of the color changed to red</p></div></div><p class="calibre12"> </p></div></div>

<div class="book" title="Creating other spells" id="2F4UM1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Exercises"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec128" class="calibre1"/>Exercises</h2></div></div></div><p class="calibre9">Try the following exercises:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1"><span class="strong"><strong class="calibre2">Lightning spell</strong></span>: Create a lightning spell by using the beam particle. Follow Zak's tutorial for an example of how beams are created and shot in a direction, at <a class="calibre1" href="https://www.youtube.com/watch?v=ywd3lFOuMV8&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&amp;index=7">https://www.youtube.com/watch?v=ywd3lFOuMV8&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&amp;index=7</a>.</li><li class="listitem" value="2"><span class="strong"><strong class="calibre2">Forcefield spell</strong></span>: A forcefield will deflect attacks. It is essential for any player. Suggested implementation: Derive a subclass of <code class="email">ASpell</code> called <code class="email">ASpellForceField</code>. Add a bounding sphere to the class, and use that in the <code class="email">ASpellForceField::Tick()</code> function to push the monsters out.</li></ol><div class="calibre14"/></div><p class="calibre9">What's next? I would highly recommend that you expand on our little game here. Here are some ideas for expansion:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Create more environments, expand the terrain, add in more houses and buildings</li><li class="listitem">Add quests that come from NPCs</li><li class="listitem">Define more melee weapons such as, swords</li><li class="listitem">Define armor for the player, such as shields</li><li class="listitem">Add shops that sell weapons to the player</li><li class="listitem">Add more monster types</li><li class="listitem">Implement loot drops for monsters</li></ul></div><p class="calibre9">You have literally thousands of hours of work ahead of you. If you happen to be a solo programmer, form working relationships with other souls. You cannot survive in the game marketplace on your own.</p><p class="calibre9">It's dangerous to go alone—Take a friend.</p></div></div>
<div class="book" title="Summary" id="2G3F81-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec83" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This concludes this chapter. You have come a long way. From not knowing anything about C++ programming at all, to hopefully being able to string together a basic game program in UE4.</p></div></body></html>