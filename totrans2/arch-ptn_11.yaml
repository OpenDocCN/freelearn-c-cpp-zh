- en: Software-Defined Clouds - the Architecture and Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件定义云 - 架构和设计模式
- en: The cloud paradigm is on the fast track. There are a number of game-changing
    advancements in the cloud space, and hence the adoption rate of the cloud concept
    is consistently on the rise. Legacy applications are being accordingly modified
    and migrated to cloud environments (private, public, and hybrid). There is a bevy
    of enabling tools for cloud migration, integration, orchestration, brokerage,
    deployment, delivery, and management propping up the strategically relevant cloud
    journey. There are integrated processes, best practices, key guidelines, evaluation
    metrics, highly synchronized platforms, and so on to make the cloud idea penetrative,
    participative, and pervasive. Furthermore, there is a growing family of architectural
    and design patterns for producing optimized cloud environments and applications.
    This chapter is specially prepared for throwing sufficient light on the patterns
    emerging and evolving in the cloud landscape. How those patterns are being used
    in order to simplify and streamline the cloud adoption will be articulated in
    this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 云范式正在快速发展。云计算领域有许多颠覆性的进步，因此云概念的采用率持续上升。传统应用程序正相应地修改并迁移到云环境（私有、公共和混合）。云迁移、集成、编排、经纪、部署、交付和管理等方面涌现出大量支持工具，推动战略相关的云之旅。有集成流程、最佳实践、关键指南、评估指标、高度同步的平台等，使云理念深入人心、参与广泛、无处不在。此外，还有不断增长的架构和设计模式家族，用于生成优化的云环境和应用程序。本章专门准备，以充分阐明在云领域中出现的和演变的模式。本章将阐述这些模式如何被用来简化并简化云的采用。
- en: Reflecting the cloud journey
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反映云之旅
- en: With the evolutionary and revolutionary traits of cloud computing, there is
    a major awareness on the charter of data center optimization and transformation.
    The acts of simplification and standardization for achieving IT industrialization
    are garnering a lot of attention these days. The various IT resources, such as
    memory, disk storage, processing power, and I/O consumption are critically and
    cognitively monitored, measured, and managed towards their utmost utilization.
    The pooling and sharing of IT solutions and services are being given paramount
    importance towards the strategic IT optimization. Also, having a dynamic pool
    of computing, storage, and network resources enable IT service providers, as well
    as enterprise IT teams to meet any kinds of spikes and emergencies in resource
    needs for their customers and users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的演变和革命性特征，数据中心优化和转型的章程已成为主要关注点。为了实现IT工业化，简化标准化措施正受到越来越多的关注。各种IT资源，如内存、磁盘存储、处理能力和I/O消耗，正被关键性地、认知性地监控、测量和管理，以实现其最大程度的利用。IT解决方案和服务的池化和共享在战略IT优化中占据着至关重要的地位。同时，拥有动态的计算、存储和网络资源池，使IT服务提供商以及企业IT团队能够满足客户和用户在资源需求方面的任何波动和紧急情况。
- en: The mesmerizing cloud paradigm has, therefore, become the mainstream concept
    in IT today. And its primary and ancillary technologies are simply flourishing
    due to the overwhelming acceptance and adoption of cloud theory. The cloudification
    movement has blossomed these days and most of the IT infrastructures and platforms,
    along with business applications, are being methodically remedied to be cloud-ready
    in order to reap all the originally envisaged benefits of the cloud idea. The
    new buzzword of **Cloud Enablement** has caught up fast and there are collaborative
    and concerted initiatives to unearth techniques, best practices, patterns, metrics,
    products and other enablers to understand the cloud fitment and to modernize IT
    assets and software applications to be cloud-oriented for the ensuing era of knowledge.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，迷人的云范式已成为当今IT的主流概念。由于其云理论的广泛接受和采用，其核心和辅助技术正蓬勃发展。云化运动如今正蓬勃发展，大多数IT基础设施和平台，以及商业应用程序，正被系统地修复，以云就绪，以便充分利用云理念的最初预期好处。新的热门词汇**云赋能**迅速流行起来，有协作和协调的举措来挖掘技术、最佳实践、模式、指标、产品和其他使能器，以了解云的适用性，并使IT资产和软件应用程序适应即将到来的知识时代。
- en: Even with all the unprecedented advancements in the cloud landscape, there are
    a plenty of futuristic and fulsome opportunities and possibilities for IT professors
    and professionals to take the cloud idea to the next level in its long journey.
    Therefore, the concept of **software-defined cloud environments** (**SDCEs**)
    is gaining a lot of accreditation these days. Product vendors, cloud service providers,
    system integrators, and other principal stakeholders are keen to have such advanced
    and acclaimed environments for their clients, customers, and consumers. The right
    and relevant technologies for the realization and sustenance of software-defined
    cloud environments are fast maturing and stabilizing, and hence the days of SDCEs
    are not too far away.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在云领域取得了前所未有的进步，对于IT教授和专业人士来说，在漫长的旅程中将云概念提升到下一个层次，仍然充满了未来和丰富的机会与可能性。因此，**软件定义云环境**（**SDCEs**）的概念在当今时代获得了广泛的认可。产品供应商、云服务提供商、系统集成商和其他主要利益相关者都热衷于为他们的客户、顾客和消费者提供这样先进和备受赞誉的环境。实现和维持软件定义云环境的正确和相关的技术正在迅速成熟和稳定，因此SDCEs的日子不会太远。
- en: In conclusion, the various technological evolutions and revolutions are remarkably
    enhancing the quality of human lives across the world. Carefully choosing and
    smartly leveraging the fully matured and stabilized technological solutions and
    services towards the much-anticipated and acclaimed digital transformation is
    necessary for a safe, smarter, and sustainable planet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，各种技术演变和革命在世界范围内显著提升了人类生活的质量。精心选择并巧妙利用成熟稳定的技术解决方案和服务，以实现备受期待和赞誉的数字化转型，对于构建一个安全、智能和可持续的地球是必要的。
- en: Traditional application architecture versus cloud application architecture
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统应用架构与云应用架构
- en: As articulated previously, we are heading towards SDCEs that comprise **software-defined
    compute** (**SDC**), **software-defined storage** (**SDS**), and **software-defined
    networking** (**SDN**). The virtualization and containerization enable software-defined
    clouds towards workload-aware and elastic infrastructures. The maneuverability
    or programmability, consumability, accessibility, sustainability, and simplicity
    of software-defined clouds are greater compared to the inflexible infrastructures.
    There are new patterns (architecture and design) being introduced for cloud infrastructures
    and applications. The emergence of the cloud idea has brought in telling impacts
    on the application architectures. In this section, we will discuss how cloud application
    architectures differ from the legacy application architectures.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正朝着包含**软件定义计算**（**SDC**）、**软件定义存储**（**SDS**）和**软件定义网络**（**SDN**）的SDCEs（软件定义云环境）迈进。虚拟化和容器化使得软件定义云能够实现工作负载感知和弹性基础设施。与僵化的基础设施相比，软件定义云的可操纵性或可编程性、可消费性、可访问性、可持续性和简单性都更优越。云基础设施和应用正在引入新的模式（架构和设计）。云概念的兴起对应用架构产生了显著影响。在本节中，我们将讨论云应用架构与传统的应用架构有何不同。
- en: The traditional application architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统应用架构
- en: Most of the traditional applications were built using the matured three-tier
    application architecture patterns (presentation tier, middle tier, and data tier).
    Each tier runs on a dedicated server and is statically configured with the hostnames
    and IP addresses of the servers of the other tiers it depends on. These applications
    have very little knowledge of the infrastructure they run on. If the infrastructure
    changes or fails, these applications also fail. Therefore, these applications
    are mandated to be hosted on highly reliable and resilient networks and servers.
    When the load (user and/or data) gets increased, these applications could not
    automatically scale up or scale out. Scaling is instead done manually through
    the purchase and installation of additional server machines. This is a time-consuming
    process, aggravating the complexity. Load balancers are being put up in front
    of web and application servers in order to bring in the much-needed auto-scaling.
    However, with the conventional application architecture, the real scalability
    could not be achieved.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传统应用都是使用成熟的分层应用架构模式（表示层、中间层和数据层）构建的。每一层都运行在专用的服务器上，并且静态配置了它所依赖的其他层服务器的主机名和IP地址。这些应用对它们运行的基础设施了解甚少。如果基础设施发生变化或失败，这些应用也会失败。因此，这些应用必须托管在高度可靠和弹性的网络和服务器上。当负载（用户和/或数据）增加时，这些应用无法自动扩展或扩展。扩展是通过购买和安装额外的服务器机器手动完成的，这是一个耗时且复杂的过程。在Web和应用服务器前面设置了负载均衡器，以引入所需的自动扩展。然而，在传统的应用架构中，真正的可扩展性并没有得到实现。
- en: The cloud architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云架构
- en: As articulated previously, the concept of virtualization has brought in a programmable
    infrastructure. That is, the scalability of applications is being achieved through
    the inherent elasticity of infrastructural components. The resource utilization
    with the conscious adoption of virtualized infrastructures has gone up significantly.
    The virtualization idea has penetrated into every infrastructural module these
    days creating waves of innovations, disruption, transformations, and optimizations
    for IT environments. That is not only server virtualization, but also network
    virtualization, storage virtualization, service virtualization, database virtualization,
    and so on, are being systematically realized in order to bring the originally
    envisaged virtual, open, flexible, and adaptive IT infrastructures that are intrinsically
    ready to anticipate and act upon business changes and challenges. The smart usage
    of cloud technologies, tools, and tips are resulting in business-aware IT infrastructures.
    The tool ecosystem is steadily growing in order to automate tasks, such as resource
    provisioning, software deployment, infrastructure monitoring, measurement and
    management, orchestration, security, governance, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，虚拟化的概念引入了可编程的基础设施。也就是说，应用的扩展性是通过基础设施组件的内在弹性来实现的。通过有意识地采用虚拟化基础设施，资源利用率显著提高。虚拟化理念如今已经渗透到每个基础设施模块，为IT环境带来了创新、颠覆、转型和优化的浪潮。这不仅包括服务器虚拟化，还包括网络虚拟化、存储虚拟化、服务虚拟化、数据库虚拟化等等，这些正在系统地实现，以带来原本预期的虚拟、开放、灵活和自适应的IT基础设施，这些基础设施本质上能够预见并应对业务变化和挑战。云技术、工具和技巧的智能使用正在导致业务感知的IT基础设施。工具生态系统正在稳步增长，以自动化诸如资源分配、软件部署、基础设施监控、测量和管理、编排、安全、治理等任务。
- en: The cloud management layer also provides user interfaces for developers and
    architects to programmatically design and build the infrastructure they need to
    run their applications. The cloud APIs provided by the cloud management layer
    also allows applications to take control of the infrastructure they run on. The
    cloud applications can dynamically scale up or scale down, deploying or removing
    application components on the infrastructure. The game-changing concept of virtualization
    and containerization has made it possible to have programmable infrastructures.
    That is, hardware modules are being expressed as services to be found, used, and
    even composed. The hardware programming is becoming real these days with the cloud
    movement. Such a scenario is enabling the days of flexible and maneuverable infrastructures
    that guarantee workload-awareness, productivity, and high utilization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 云管理层还为开发人员和架构师提供了用户界面，以便通过编程设计并构建他们运行应用程序所需的基础设施。云管理层提供的云API还允许应用程序控制其运行的基础设施。云应用程序可以动态地扩展或缩减，在基础设施上部署或移除应用程序组件。虚拟化和容器化的颠覆性概念使得可编程基础设施成为可能。也就是说，硬件模块正被表达为可被发现、使用甚至组合的服务。随着云运动的推进，硬件编程正变得日益真实。这样的场景正在使灵活和可操纵的基础设施时代成为可能，这些基础设施保证了工作负载感知、生产力和高利用率。
- en: The cloud application architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云应用程序架构
- en: As indicated previously, the traditional applications need to be accordingly
    modernized in order to reap the cloud benefits. The scalability and other requirements
    of modern applications need to be inscribed within the application. There are
    certain programming languages and architectural patterns in order to attach **non-functional
    requirements** (**NFRs**) into applications. The traditional applications typically
    use a single database to store all the application information. This database
    provides the information stored in it to various application clients (users as
    well as other application components) on a need basis. However, with the data
    explosion, the conventional databases could be scaled up.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了获得云的好处，传统应用程序需要相应地进行现代化。现代应用程序的可扩展性和其他需求需要被嵌入到应用程序中。存在某些编程语言和架构模式，以便将**非功能性需求**（**NFRs**）附加到应用程序中。传统应用程序通常使用单个数据库来存储所有应用程序信息。该数据库根据需要向各种应用程序客户端（用户以及其他应用程序组件）提供存储在其内的信息。然而，随着数据的爆炸性增长，传统的数据库可能需要扩展。
- en: 'The scale-out (horizontal scalability) of SQL databases is beset with a lot
    of challenges. However, due to the massiveness of cloud infrastructures, cloud
    databases have to be designed and developed using new database types, such as
    NoSQL, NewSQL, in-memory, and in-database databases for data storage and analytics.
    The object storage is very popular in the cloud era. Every cloud service provider
    is betting and banking on cloud storage to meet the fast-rising storage needs.
    Apart from databases, there are enterprise-grade data warehouses and data lakes.
    Data storage options are on the rise. Cache storage is one such which is garnering
    a lot of support. Furthermore, there are distributed filesystems, such as HDFS
    for big data storage and analytics. There are database abstractions on filesystems
    in order to provide several possibilities for developers, database administers,
    and businesses. Besides, there are backup and archival options for data in order
    to ensure data and **disaster recovery** (**DR**). The following diagram vividly
    illustrates where and how cloud application architecture deviates and differs
    from traditional applications. With multi-channel, device, media, and modal clients,
    cloud applications are being methodically advanced:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库的横向扩展（可扩展性）面临着许多挑战。然而，由于云基础设施的规模庞大，云数据库必须使用新的数据库类型进行设计和开发，例如NoSQL、NewSQL、内存数据库和数据库内数据库，用于数据存储和分析。对象存储在云时代非常流行。每个云服务提供商都在押注和投资云存储以满足不断增长的存储需求。除了数据库之外，还有企业级的数据仓库和数据湖。数据存储选项正在增加。缓存存储就是这样一种受到大量支持的选择。此外，还有分布式文件系统，如HDFS用于大数据存储和分析。在文件系统上存在数据库抽象，以便为开发人员、数据库管理员和业务提供多种可能性。此外，还有数据备份和归档选项，以确保数据和**灾难恢复**（**DR**）。以下图表生动地说明了云应用程序架构与传统应用程序在何处以及如何偏离和不同。随着多渠道、设备、媒体和模式客户端的出现，云应用程序正在有条不紊地进步：
- en: '![](img/7e360909-28c4-4e51-8a80-60d31b30a95c.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e360909-28c4-4e51-8a80-60d31b30a95c.jpg)'
- en: Cloud applications are distinctively different. Increasingly, applications are
    service-oriented with the faster maturity and stability of service-oriented applications.
    In the recent past, there have been further refinements and optimizations in order
    to tackle newer requirements. Polyglot programming is picking up. That is, there
    are several programming and script languages to bring forth cloud applications
    as a dynamic collection of microservices. In addition, there is a myriad of database
    management systems. Each database type is appropriate for certain application
    needs. Thus, the flexibility of linking multiple technologies, tools, and techniques
    for bringing forth cloud applications is being facilitated by the most popular
    **microservices architecture** (**MSA**). With the widespread adoption of containers
    (Docker) as the highly optimized application holder and runtime environment, there
    is a sharp convergence of multiple technologies in order to enable agile and accelerated
    software engineering, deployment, delivery, and management. Multi-container and
    multi-host cloud applications spearheaded and shepherded by the containerization
    movement is the talk of the town.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用具有独特的差异。随着面向服务的应用成熟度和稳定性的提高，越来越多的应用正趋向于服务导向。在最近过去，为了应对新的需求，已经进行了进一步的改进和优化。多语言编程正在兴起。也就是说，有几种编程和脚本语言可以构建动态的微服务集合作为云应用。此外，还有大量的数据库管理系统。每种数据库类型都适用于某些应用需求。因此，通过最流行的**微服务架构**（**MSA**）促进多种技术、工具和技术链接以构建云应用的灵活性正在得到提升。随着容器（Docker）作为高度优化的应用程序承载和运行环境的广泛应用，多种技术正在迅速汇聚，以实现敏捷和加速的软件工程、部署、交付和管理。由容器化运动引领和引导的多容器和多主机云应用成为了热门话题。
- en: In short, with the cloud embarkation, the widely deliberated **quality of service**
    (**QoS**) and **quality of experience** (**QoE**) factors and facets of next-generation
    applications are being accurately accomplished. The cloud infrastructures are
    being astutely tweaked in order to tackle brewing challenges at the infrastructure
    level. Another prominent design requirement is to design cloud applications to
    handle the latency issue. That is, fault tolerance is one such important factor
    for cloud applications, platforms, and infrastructures. The cascading effect of
    failures and bugs needs to be arrested in the budding stage itself. As clouds
    are being built on commodity servers, the failure rate is quite high. Besides,
    there can be network congestion/outages, resource conflicts, request contentions,
    and IOPS challenges for storage systems. Furthermore, there can be hardware and
    software failures. Cloud environments are becoming hugely complicated, and hence
    viable complexity mitigation and moderation techniques need to be in place. Systems
    have to come out gracefully from any kind of constricting and cascading issues
    and limitations. A popular design pattern to address latency and failure is the
    request/response queue, where requests and responses are stored in queues. Also,
    cloud and application interfaces have to be highly intuitive, informative, and
    instructive. The user experience has to be maintained even if cloud resources
    and assets are not responsive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，随着云迁移，下一代应用广泛讨论的**服务质量**（**QoS**）和**用户体验质量**（**QoE**）因素和方面正在被精确实现。云基础设施正在被巧妙地调整，以应对基础设施层面的潜在挑战。另一个突出的设计要求是设计云应用以处理延迟问题。也就是说，容错性是云应用、平台和基础设施的一个重要因素。需要从萌芽阶段开始阻止故障和错误的级联效应。由于云是基于通用服务器构建的，其故障率相当高。此外，还可能出现网络拥塞/中断、资源冲突、请求竞争和存储系统的IOPS挑战。此外，还可能出现硬件和软件故障。云环境正变得越来越复杂，因此需要实施可行的复杂度缓解和调节技术。系统必须优雅地应对任何类型的约束和级联问题和限制。解决延迟和故障的一个流行设计模式是请求/响应队列，其中请求和响应存储在队列中。此外，云和应用程序接口必须高度直观、信息丰富和指导性强。即使云资源和资产不响应，用户体验也必须得到保持。
- en: Cloud integration patterns
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云集成模式
- en: There are a number of noteworthy advancements happening in the field of cloud
    computing. Patterns are of much use for the complicated and growing subject of
    cloud computing. Patterns are being unearthed with the aim of simplifying the
    deeper understanding and adoption of the cloud paradigm. A number of prospective
    areas, such as **Infrastructure as a Service** (**IaaS**), **Platform as a Service**
    (**PaaS**), **Software as a Service** (**SaaS**), **Business Process as a Service**
    (**BPaaS**), and so on, in the cloud space are being revisited to bring forth
    fresh and competent patterns. There are special patterns being readied for cloud
    application development. There are cloud integration platforms (**Integration
    Platform as a Service** (**IPaaS**)) for enabling a kind of seamless and spontaneous
    integration among different and distributed cloud applications and data sources.
    Therefore, integration-specific patterns are being formed and articulated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算领域，正在发生许多值得注意的进步。模式对于复杂且不断发展的云计算主题非常有用。正在挖掘模式，目的是简化对云范式的深入理解和采用。在云空间中，许多潜在领域，如**基础设施即服务**（**IaaS**）、**平台即服务**（**PaaS**）、**软件即服务**（**SaaS**）、**业务流程即服务**（**BPaaS**）等，正在被重新审视，以提出新鲜和有能力的模式。正在为云应用开发准备特殊的模式。存在云集成平台（**集成平台即服务**（**IPaaS**）），用于实现不同和分布式云应用及数据源之间的一种无缝和自发的集成。因此，正在形成和阐述特定的集成模式。
- en: These days, the cloud concept has matured and stabilized beautifully in order
    to give hundreds of novel services for business houses and individuals. On the
    data services side, we have a **Database as a Service** (**DBaaS**), **Data Warehouse
    as a Service** (**DWaaS**), **Data Lake as a Service** (**DLaaS**), and so on.
    Newer databases have emerged in order to tackle a different set of requirements.
    We all hear, read, and even experience NoSQL and NewSQL databases. Then there
    are in-memory databases and **in-memory data grids** (**IMDGs**). Data analytics
    happens within the database itself, and hence we read about in-database analytics.
    Similarly, the cloud environments are being prescribed as the best-in-class for
    various other application domains. All kinds of operational, transactional, and
    analytical applications are being hosted, managed, and delivered through cloud
    infrastructures and platforms. Then there are new-generation web, mobile, gaming,
    wearable, embedded, enterprise, IoT, and blockchain applications getting developed,
    deployed, and delivered through cloud infrastructures and instances. Everything
    is being expressed and exposed as a service, and undoubtedly, clouds are the elegant,
    enabling, and execution environments. In the recent past, we have heard more about
    cloud orchestration, configuration, deployment, migration, governance, and brokerage
    services. **DevOps** is another buzzword in the cloud landscape. With such a legion
    of cloud services, there is a need expressed widely by many and a collective call
    to create beneficial cloud-centric patterns for fulfilling various IT and business
    capabilities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，云概念已经成熟并稳定下来，为企业和个人提供了数百种新颖的服务。在数据服务方面，我们有**数据库即服务**（**DBaaS**）、**数据仓库即服务**（**DWaaS**）、**数据湖即服务**（**DLaaS**）等。出现了新的数据库，以应对不同的需求。我们都听说过、阅读过，甚至体验过NoSQL和NewSQL数据库。然后还有内存数据库和**内存数据网格**（**IMDGs**）。数据分析在数据库内部进行，因此我们了解到数据库内分析。同样，云环境被指定为各种其他应用领域的最佳环境。各种操作、事务和分析应用都通过云基础设施和平台托管、管理和交付。然后还有新一代的Web、移动、游戏、可穿戴、嵌入式、企业、物联网和区块链应用正在通过云基础设施和实例开发和交付。一切都被表达和暴露为服务，毫无疑问，云是优雅的、启用的和执行环境。在最近过去，我们听到了更多关于云编排、配置、部署、迁移、治理和经纪服务。**DevOps**是云景观中的另一个热门词汇。随着如此众多的云服务，许多人和集体呼吁创建有益的云中心模式，以满足各种IT和业务能力。
- en: Tier/Layer-based decomposition
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于层级的分解
- en: The complex functionality of this application is divided into multiple discrete,
    easily manageable, and loosely-coupled components. Each component is ordained
    to do one task well. This partition or componentization of application functionality
    results in a logical decomposition of the original application. These logically
    separated components run in multiple tiers of a server cluster, and this kind
    of segmentation is done at the infrastructure level.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的复杂功能被划分为多个离散的、易于管理和松散耦合的组件。每个组件都被指定执行一项任务。这种应用程序功能的分区或组件化导致了原始应用程序的逻辑分解。这些逻辑上分离的组件在服务器集群的多个层级上运行，这种分割是在基础设施级别进行的。
- en: Process-based decomposition
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于过程的分解
- en: The next is process-based decomposition. Enterprise-grade and complicated applications
    are typically process-centric. Herein, we can bring in process-based decomposition.
    Each process internally comprises many tasks that need to be performed in a certain
    sequence. Each task is done separately and aggregated in the desired order to
    get the application functionality. There are plenty of automated tools for enabling
    such decomposition, automation, and finally, orchestration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个是基于过程的分解。企业级和复杂的应用程序通常是过程中心的。在这里，我们可以引入基于过程的分解。每个过程内部包含许多需要按一定顺序执行的任务。每个任务单独完成，并按所需顺序聚合以获得应用程序功能。有许多自动化工具可以启用这种分解、自动化，最终实现编排。
- en: Pipes-and-filters-based decomposition
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于“管道-过滤器”的分解
- en: The third decomposition type is pipes-and-filters-based decomposition, that
    focuses on the data-centric processing of an application. Each filter provides
    a certain function that is performed on input data and produces output data after
    processing. Multiple filters are interconnected with pipes, that is, through messaging.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种分解类型是基于“管道-过滤器”的分解，它侧重于应用程序的数据中心处理。每个过滤器提供一种在输入数据上执行并在处理后产生输出数据的函数。多个过滤器通过管道相互连接，即通过消息传递。
- en: These layering and decomposition patterns aptly decompose the application into
    logical layers, enabling independent deployment and horizontal scalability. The
    layering of application and cloud infrastructures is being touted as the most
    vital need for developing, deploying, and delivering next-generation distributed
    applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分层和分解模式恰当地将应用程序分解为逻辑层，使得独立部署和水平扩展成为可能。应用程序和云基础设施的分层正在被吹捧为开发、部署和交付下一代分布式应用的最重要需求。
- en: Service messaging pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务消息模式
- en: '**Messages as the unifying mechanism**: Messages are the most unifying factor
    among disparate and distributed cloud services. The goals of cloud service integration
    get accomplished through message passing. The following section lists and details
    the various service message patterns. Service messages can be authenticated, routed,
    enriched, filtered, secured, and composed in order to fulfill the expectations
    of federated clouds. Cloud intermediation and remediation can be performed through
    smart messaging. Path-breaking and hitherto unknown services can be built and
    deployed through the innovative usage of service messages.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息作为统一机制**：消息是不同且分布式的云服务中最统一的因素。云服务集成的目标通过消息传递来实现。下文将列出并详细说明各种服务消息模式。服务消息可以通过认证、路由、丰富、过滤、安全化和组合来满足联邦云的期望。云中介和修复可以通过智能消息传递来完成。通过创新地使用服务消息，可以构建和部署具有突破性和以前未知的服务。'
- en: How do different distributed and decentralized cloud services find, bind, access,
    and collaborate with one another in a loosely coupled as well as decoupled manner?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的分布式和去中心化的云服务如何以松散耦合和去耦合的方式找到、绑定、访问和协作？
- en: '| **Problem** | Services can be run on one virtual machine or in different
    virtual machines within a cloud environment. Services can even be run on geographically
    distributed clouds. There are public, private, and hybrid clouds and there are
    a few communication protocols. The conventional protocols induce a possibility
    of tight coupling between services. These, in turn, impose certain restrictions
    on service reusability, testability, and modifiability. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 服务可以在一个虚拟机上运行，或者在云环境中的不同虚拟机上运行。服务甚至可以在地理上分布的云上运行。有公共、私有和混合云，还有一些通信协议。传统的协议可能导致服务之间紧密耦合的可能性。这些反过来又对服务的可重用性、可测试性和可修改性施加了某些限制。
    |'
- en: '| **Solution** | Going forward, loose coupling and decoupling are the viable
    and valuable solution approaches. As even loose coupling has some constraints,
    decoupling among services is being touted as the most promising solution, and
    messaging is the way forward for establishing decoupled communication, which in
    turn eliminates the drawbacks of traditional communication methods |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 从现在开始，松耦合和解耦是可行且有价值的解决方案方法。即使松耦合也有一些限制，服务之间的解耦被吹捧为最有希望的解决方案，而消息是建立解耦通信的方式，这反过来又消除了传统通信方法的缺点|'
- en: '| **Impacts** | Messaging technology brings a few QoS concerns, such as reliable
    delivery, security, performance, and transactions. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 消息技术带来了一些QoS问题，如可靠交付、安全性、性能和事务。|'
- en: '**Problem**: Different applications usually use different languages, data formats,
    and technology platforms. When one application (component) needs to exchange information
    with another one, the format of the target application has to be respected. Sending
    messages directly to the target application results in a tight coupling of sender
    and receiver since format changes directly affect both implementations. Also,
    direct sending tightly couples the applications regarding the addresses by which
    they can be reached.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：不同的应用程序通常使用不同的语言、数据格式和技术平台。当一个应用程序（组件）需要与另一个应用程序交换信息时，必须尊重目标应用程序的格式。直接向目标应用程序发送消息会导致发送者和接收者之间紧密耦合，因为格式变化直接影响两者实现。此外，直接发送还紧密耦合了应用程序，使其可以通过地址到达。'
- en: Cloud applications and services communicate using a variety of protocols. **Remote
    procedure call** (**RPC**), **remote method invocation** (**RMI**), **Windows
    Communication Framework** (**WCF**), and service protocols (SOAP and REST over
    HTTP) are some of the leading mechanisms for cloud resources to connect and collaborate
    purposefully. However, all these lead to a kind of tight coupling, which in turn
    becomes a hitch or hurdle for services to seamlessly and spontaneously cooperate
    to achieve bigger and better things. The urgent requirements are therefore loose
    coupling and decoupling. How can cloud application services communicate remotely
    through messages while being loosely coupled regarding their location and message
    format? Another brewing requirement is to enable complete decoupling among services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用程序和服务使用各种协议进行通信。**远程过程调用**（**RPC**）、**远程方法调用**（**RMI**）、**Windows Communication
    Framework**（**WCF**）以及服务协议（HTTP上的SOAP和REST）是云资源连接和协作的一些主要机制。然而，所有这些都导致了一种紧密耦合，这反过来又成为服务无缝和自发合作以实现更大更好事物的障碍。因此，迫切需要松耦合和解耦。云应用程序服务如何在位置和消息格式上松耦合的情况下通过消息进行远程通信？另一个正在酝酿的要求是使服务之间实现完全解耦。
- en: '**Solution**: The context is that distributed applications or their service
    components exchange information using messaging. Messaging comes as a viable alternative
    communication scheme that does not rely on persistent connections. Instead, messages
    are being transmitted as independent units of communication routed through the
    underlying infrastructure. That is, simply connect applications through an intermediary;
    the message-oriented middleware hides the complexity of addressing and availability
    of communication partners as well as supports transformation of different message
    formats.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：背景是分布式应用程序或其服务组件通过消息交换信息。消息作为可行的替代通信方案，不依赖于持久连接。相反，消息作为独立的通信单元被传输，通过底层基础设施路由。也就是说，只需通过一个中介连接应用程序；面向消息的中间件隐藏了通信伙伴的寻址和可用性的复杂性，并支持不同消息格式的转换。'
- en: Communication partners can now communicate through messages without the need
    to know the message format used by the communication partner or the address by
    which it can be reached. The message-oriented middleware provides message channels
    (also referred to as **queues**). Messages can be written to these queues or read
    from them. Additionally, the message-oriented middleware contains components that
    route messages between channels to intended receivers, as well as handle message
    format transformation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通信伙伴现在可以通过消息进行通信，而无需知道通信伙伴使用的消息格式或其可到达的地址。面向消息的中间件提供消息通道（也称为**队列**）。消息可以写入这些队列或从中读取。此外，面向消息的中间件包含组件，这些组件在通道之间路由消息到目标接收者，并处理消息格式的转换。
- en: 'The messaging framework must have the following capabilities:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框架必须具备以下能力：
- en: Guaranteeing the delivery of each message or guaranteeing a notification of
    failed deliveries
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证每条消息的投递或保证失败投递的通知
- en: Securing message contents beyond the transport
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传输之外保护消息内容
- en: Managing state and context data across a service activity
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务活动之间管理状态和上下文数据
- en: Transmitting messages efficiently as part of real-time interactions
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息高效地作为实时交互的一部分进行传输
- en: Coordinating cross-service transactions
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调跨服务事务
- en: Without these types of extensions in place, the availability, reliability, and
    reusability of services will impose limitations that can undermine the strategic
    goals associated with cloud-hosted services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些类型的扩展，服务的可用性、可靠性和可重用性将施加限制，可能会损害与云托管服务相关的战略目标。
- en: Messaging metadata pattern
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息元数据模式
- en: '| **Problem** | Services generally work in a stateless fashion. That is, they
    do not store any state data in order to facilitate the next course of action.
    As the message is the intermediary in order to empower different and distributed
    services to interact together towards accomplishing business transactions and
    operations, they need to have or carry all the state data (metadata). |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 服务通常以无状态方式工作。也就是说，它们不存储任何状态数据以方便后续操作。由于消息是中介，以便不同的和分布式的服务能够共同交互以完成业务交易和操作，它们需要拥有或携带所有状态数据（元数据）。|'
- en: '| **Solution** | The content encapsulated within the message envelope, therefore,
    has to be supplemented with activity-specific metadata that can be interpreted
    and processed separately at runtime. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 因此，消息信封内封装的内容必须补充以活动特定的元数据，这些元数据可以在运行时单独解释和处理。|'
- en: '| **Impacts** | The interpretation and processing of messaging metadata adds
    to runtime performance overhead and increases service activity design complexity.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 对消息元数据的解释和处理会增加运行时性能开销，并增加服务活动设计复杂性。|'
- en: '**Problem**: In the traditional method, the state and context data about the
    current service interaction are placed in the memory. However, in a service environment,
    services are being designed, developed, and deployed as stateless resources to
    be highly reusable. Therefore, the messages that are being transmitted among services
    are being mandated to carry the right and relevant data to initiate the correct
    actions sequentially to accomplish the business process tasks.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：在传统方法中，当前服务交互的状态和上下文数据被放置在内存中。然而，在服务环境中，服务被设计、开发和部署为无状态资源，以实现高度可重用性。因此，在服务之间传输的消息必须携带正确和相关的数据，以依次启动正确的操作，从而完成业务流程任务。'
- en: '**Solution**: As messages carry the state data, business rules, and even processing
    instructions, services can be designed in a very generic manner. The service complexity
    will come down, the reusability level will go up, modifiability will be easier,
    enrichment will be quicker, and so on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：由于消息携带状态数据、业务规则甚至处理指令，服务可以以非常通用的方式设计。服务复杂性将降低，可重用性水平将提高，可修改性将更容易，丰富性将更快，等等。'
- en: Though the overall memory consumption is reduced by avoiding a persistent binary
    connection, the performance demands are increased by the requirement for services
    to interpret and process metadata at runtime. Agnostic services especially can
    impose more runtime cycles, as they may need to be outfitted with highly generic
    routines capable of interpreting and processing different types of messaging headers
    so as to participate effectively in multiple composition activities. Due to the
    prevalence and range of technology standards that intrinsically support and are
    based on messaging metadata, a wide variety of sophisticated message exchanges
    can be designed. This can lead to overly creative and complex message paths that
    may be difficult to govern and evolve.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过避免持久二进制连接减少了整体内存消耗，但服务在运行时解释和处理元数据的要求增加了性能需求。特别是无状态服务可能会施加更多的运行周期，因为它们可能需要配备高度通用的例程，能够解释和处理不同类型的消息头，以便有效地参与多个组合活动。由于存在广泛的技术标准，这些标准本质上支持并基于消息元数据，因此可以设计出各种复杂的消息交换。这可能导致过于创新和复杂的消息路径，可能难以管理和演变。
- en: Service agent pattern
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务代理模式
- en: How can event capturing and processing logic be separated and governed independently?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将事件捕获和处理逻辑分离并独立管理？
- en: '| **Problem** | Service composition (orchestration and choreography) can become
    large and inefficient, especially when required to invoke granular capabilities
    across multiple services. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 服务组合（编排和协调）可能会变得庞大且效率低下，尤其是在需要调用多个服务中的细粒度能力时。 |'
- en: '| **Solution** | Event-driven service composition is emerging as an important
    factor for crafting composite services. Event-driven logic can be easily deferred
    to event-driven programs that don''t require explicit invocation, thereby reducing
    the size and performance strain of service composition. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 事件驱动的服务组合正成为构建复合服务的一个重要因素。事件驱动的逻辑可以轻松地延迟到不需要显式调用的事件驱动程序中，从而减少服务组合的大小和性能压力。
    |'
- en: '| **Impacts** | The complexity of composition logic increases when it is distributed
    across services, and event-driven agents and reliance on service agents can further
    tie inventory architecture to proprietary vendor technology. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 当组合逻辑分布在服务中时，其复杂性会增加，并且事件驱动代理和依赖服务代理可以进一步将库存架构绑定到专有供应商技术。 |'
- en: '**Problem**: Decomposition and composition are the highly successful methods
    for simplifying and streamlining software engineering. In a service environment,
    applications are built by assembling a variety of services. In software engineering,
    the application to be realized is to start with a series of business processes
    (simple and compound) and each process, in turn, gets implemented by leveraging
    a number of services (process elements). That is, applications are decomposed
    into a collection of interoperable and interactive services and services are smartly
    composed to form next-generation applications.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：分解和组合是简化并简化软件工程的非常成功的方法。在服务环境中，应用程序是通过组装各种服务来构建的。在软件工程中，要实现的应用程序是从一系列业务流程（简单和复合）开始的，每个流程反过来又通过利用多个服务（流程元素）来实现。也就是说，应用程序被分解为一系列互操作和交互式服务，并且服务被智能地组合成下一代应用程序。'
- en: Service composition logic consists of a series of service invocations, and each
    invocation enlists a service to carry out a segment of the overall parent business
    process logic. Larger business processes can be enormously complex, especially
    when having to incorporate numerous *what if* conditions through compensation
    and exception handling subprocesses. Therefore, service composition can grow correspondingly
    large. Furthermore, each service invocation comes with a performance hit resulting
    from having to explicitly invoke and communicate with the service itself. The
    performance of larger compositions can suffer from the collective overhead of
    having to invoke multiple services to automate a single task.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务组合逻辑由一系列服务调用组成，每个调用都要求一个服务执行整体父业务流程逻辑的一部分。较大的业务流程可能非常复杂，尤其是在需要通过补偿和异常处理子流程包含许多“如果...怎么办？”条件时。因此，服务组合可以相应地变得很大。此外，每个服务调用都会带来性能损失，这是由于必须显式调用并与服务本身进行通信。较大的组合可能会因为需要调用多个服务来自动化单个任务而产生的总体开销而受到影响。
- en: '**Solution**: *Separation of concerns* has been an interesting technique in
    software engineering. Service logic that is triggered by a predictable event can
    be isolated into a separate program specially designed for automatic invocation
    upon the occurrence of the event. This reduces the amount of composition logic
    that needs to reside within services and further decreases the number of service
    invocations required for a given composition.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：*关注点分离*是软件工程中的一个有趣技术。由可预测事件触发的服务逻辑可以被隔离到专门为事件发生时自动调用而设计的独立程序中。这减少了需要在服务中驻留的组成逻辑的数量，并进一步减少了给定组合所需的服务调用次数。'
- en: Event-driven agents provide yet another layer of abstraction to which multiple
    service compositions can form dependencies. Although the perceived size of the
    composition may be reduced, the actual complexity of the composition itself does
    not decrease. Composition logic is simply more decentralized as it now also encompasses
    service agents that automatically perform portions of the overall task.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动代理为多个服务组合形成依赖关系提供了另一层抽象。尽管感知到的组合大小可能减少，但组合本身的实际复杂性并没有减少。组合逻辑只是更加分散，因为它现在还涵盖了自动执行整体任务部分的服务代理。
- en: Intermediate routing pattern
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间路由模式
- en: 'How can dynamic runtime factors affect the path of a message?:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 动态运行时因素如何影响消息路径？：
- en: '| **Problem** | The larger and more complex a service composition is, the more
    difficult it is to anticipate and design for all possible runtime scenarios in
    advance, especially with asynchronous and messaging-based communication. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 服务组合越大、越复杂，提前预想和设计所有可能的运行时场景就越困难，尤其是在异步和基于消息的通信中。|'
- en: '| **Solution** | Message paths can be dynamically determined through the use
    of intermediary routing logic. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 通过使用中间件路由逻辑，可以动态确定消息路径。|'
- en: '| **Impacts** | Dynamically determining a message path adds layers of processing
    logic and correspondingly can increase performance overhead. Also, the use of
    multiple routing logic can result in overly complex service activities. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 动态确定消息路径会增加处理逻辑的层级，相应地可能会增加性能开销。此外，使用多个路由逻辑可能导致服务活动过于复杂。|'
- en: '**Problem**: A service composition can be viewed as a chain of point-to-point
    data exchanges between composition participants. Collectively, these exchanges
    end up automating a parent business process. The message routing logic (the decision
    logic that determines how messages are passed from one service to another) can
    be embedded within the logic of each service in a composition. This allows for
    the successful execution of predetermined message paths. However, there may be
    unforeseen factors that are not accounted for in the embedded routing logic, which
    can lead to unanticipated system failures. For example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：服务组合可以看作是组合参与者之间的一系列点对点数据交换。这些交换共同自动化一个父级业务流程。消息路由逻辑（决定消息如何从一个服务传递到另一个服务的决策逻辑）可以嵌入到组合中每个服务的逻辑中。这允许成功执行预定的消息路径。然而，可能存在未考虑到的因素，这些因素可能导致未预见的系统故障。例如：'
- en: The destination service a message is being transmitted to is temporarily (or
    even permanently) unavailable
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息正在传输到的目标服务暂时（甚至永久）不可用
- en: The embedded routing logic contains a *catch-all* condition to handle exceptions,
    but the resulting message destination is still incorrect
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入的路由逻辑包含一个*通配符*条件来处理异常，但结果的消息目的地仍然不正确
- en: The originally planned message path cannot be carried out, resulting in a rejection
    of the message from the service's previous consumer
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原计划的消息路径无法执行，导致服务的前一个消费者拒绝消息
- en: Alternatively, there may simply be functional requirements that are dynamic
    in nature and for which services cannot be designed in advance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可能只是存在动态的功能需求，而服务无法提前设计。
- en: '**Solution**: Generic and multi-purpose routing logic can be abstracted so
    that it exists as a separate part of the architecture in support of multiple services
    and service compositions. Most commonly, this is achieved through the use of event-driven
    service agents that transparently intercept messages and dynamically determine
    their paths.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：通用的多用途路由逻辑可以被抽象化，使其作为架构的独立部分存在，以支持多个服务和服务组合。最常见的是，这通过使用事件驱动的服务代理来实现，这些代理可以透明地拦截消息并动态确定它们的路径。'
- en: This pattern is usually applied as a specialized implementation of a service
    agent. Routing-centric agents required to perform dynamic routing are often provided
    by messaging middleware and are fundamental components of **enterprise service
    bus** (**ESB**) products. These types of out-of-the-box agents can be configured
    to carry out a range of routing functions. However, the creation of custom routing
    agents is also possible and not uncommon, especially in environments that need
    to support complex service compositions with special requirements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常作为服务代理的专用实现应用。需要执行动态路由的路由中心代理通常由消息中间件提供，是企业服务总线（**ESB**）产品的基本组件。这些类型的即用型代理可以被配置为执行一系列路由功能。然而，创建自定义路由代理也是可能的，并且并不罕见，尤其是在需要支持具有特殊要求复杂服务组合的环境中。
- en: State messaging pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态消息模式
- en: 'How can services remain stateless while contributing to stateful interactions?:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在保持无状态的同时，为有状态交互做出贡献？
- en: '| **Problem** | When services are required to maintain state information in
    memory between message exchanges with consumers, their scalability can be compromised,
    and they can become a performance bottleneck on the surrounding infrastructure.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 当服务需要在消息交换与消费者之间在内存中维护状态信息时，它们的可扩展性可能会受损，并且它们可能成为周围基础设施的性能瓶颈。|'
- en: '| **Solution** | Instead of retaining the state data in memory, its storage
    is temporarily delegated to messages. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 不是在内存中保留状态数据，而是临时将其存储委托给消息。 |'
- en: '| **Impacts** | This pattern may not be suitable for all forms of state data
    and should the message be lost, any state information they carried may be lost
    as well. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 此模式可能不适用于所有形式的状态数据，并且如果消息丢失，它们携带的任何状态信息也可能丢失。 |'
- en: '**Problem**: Services are sometimes required to be involved in runtime activities
    that span multiple message exchanges. In these cases, a service may need to retain
    state information until the overarching task is completed. This is especially
    common with services that act as composition controllers. By default, services
    are often designed to keep this state data in memory so that it is easily accessible
    and essentially remains alive for as long as the service instance is active. However,
    this design approach can lead to serious scalability problems and further runs
    contrary to the service statelessness design principle.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：服务有时需要参与跨越多个消息交换的运行时活动。在这些情况下，服务可能需要保留状态信息，直到整体任务完成。这对于充当组合控制器的服务尤其常见。默认情况下，服务通常设计为将此状态数据保留在内存中，以便易于访问，并且基本上在服务实例活跃期间保持活跃。然而，这种设计方法可能导致严重的可扩展性问题，并且进一步违反了服务无状态设计原则。'
- en: '**Solution**: Instead of the service maintaining state data in memory, it moves
    the data to the message. During a conversational interaction, the service retrieves
    the latest state data from the next input message.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：服务不是在内存中维护状态数据，而是将其移动到消息中。在对话交互期间，服务从下一个输入消息中检索最新的状态数据。'
- en: There are two common approaches for applying this pattern, both of which affect
    how the service consumer relates to the state data. The consumer retains a copy
    of the latest state data in memory and only the service benefits from delegating
    the state data to the message. This approach is suitable for when this pattern
    is implemented using WS-Addressing, due to the one-way conversational nature of
    **endpoint references** (**EPRs**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此模式有两种常见方法，这两种方法都会影响服务消费者与状态数据的关系。消费者在内存中保留最新状态数据的副本，而只有服务从将状态数据委托给消息中受益。这种方法适用于使用
    WS-Addressing 实现此模式时，由于端点引用（**EPRs**）的单向对话性质。
- en: Both the consumer and the service use messages to temporarily offload state
    data. This two-way interaction with state data may be appropriate when both consumer
    and service are actual services within a larger composition. This technique can
    be achieved using custom message headers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者和服务都使用消息来临时卸载状态数据。当消费者和服务都是更大组合中的实际服务时，这种与状态数据的双向交互可能是合适的。此技术可以通过自定义消息头部实现。
- en: When following the two-way model with custom headers, messages that are lost
    due to runtime failure or exception conditions will further lose the state data,
    thereby placing the overarching task in jeopardy. It is also important to consider
    the security implications of state data placed on the messaging layer. For services
    that handle sensitive or private data, the corresponding state information should
    either be suitably encrypted and/or digitally signed, and it is not uncommon for
    the consumer to not gain access to protected state data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当遵循带有自定义头部的双向模型时，由于运行时失败或异常条件而丢失的消息将进一步丢失状态数据，从而将整体任务置于危险之中。同时，考虑放置在消息层上的状态数据的安全影响也很重要。对于处理敏感或私人数据的服务，相应的状态信息应适当加密和/或数字签名，消费者无法访问受保护的状态数据的情况并不少见。
- en: Furthermore, because this pattern requires that state data be stored within
    messages that are passed back and forth with every request and response, it is
    important to consider the size of this information and the implications on bandwidth
    and runtime latency. As with other patterns that require new infrastructure extensions,
    establishing inventory-wide support for state messaging will introduce cost and
    effort due to the necessary infrastructure upgrades.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于此模式要求状态数据存储在每次请求和响应中传递和回传的消息中，因此考虑此信息的大小及其对带宽和运行时延迟的影响很重要。与其他需要新基础设施扩展的模式一样，建立库存范围内的状态消息支持将引入成本和努力，这是由于必要的基础设施升级所导致的。
- en: Service callback pattern
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务回调模式
- en: 'How can a service sync up asynchronously with its consumers?:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务如何异步与其消费者同步？：
- en: '| **Problem** | When a service needs to respond to a consumer request for the
    issuance of multiple messages or when service message processing requires a large
    amount of time, it is often not possible to communicate synchronously. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 当服务需要响应消费者请求以发送多个消息，或者服务消息处理需要大量时间时，通常无法进行同步通信。|'
- en: '| **Solution** | A service can require that consumers communicate with it asynchronously
    and provide a callback address to which the service can send response messages.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 服务可以要求消费者异步与其通信，并提供一个回调地址，服务可以将响应消息发送到该地址。|'
- en: '| **Impacts** | Asynchronous communication can introduce reliability concerns
    and can further require that surrounding infrastructure be upgraded to fully support
    the necessary callback correlation. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 异步通信可能会引入可靠性问题，并可能需要升级周围的基础设施以完全支持必要的回调关联。|'
- en: '**Problem**: When service logic requires that a consumer request is responded
    to with multiple messages, a standard request-response messaging exchange is not
    appropriate. Similarly, when a given consumer request requires that the service
    perform prolonged processing before being able to respond, synchronous communication
    is not possible without jeopardizing scalability and reliability of the service
    and its surrounding architecture.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：当服务逻辑需要用多个消息来响应消费者请求时，标准的请求-响应消息交换是不合适的。同样，当特定的消费者请求需要服务在能够响应之前进行长时间处理时，同步通信是不可能的，这可能会危及服务及其周围架构的可扩展性和可靠性。'
- en: '**Solution**: Services are designed in such a manner that consumers provide
    them with a callback address at which they can be contacted by the service at
    some point after the service receives the initial consumer request message. Consumers
    are furthermore asked to supply correlation details that allow the service to
    send an identifier within future messages so that consumers can associate them
    with the original task.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：服务被设计成消费者提供一个回调地址，服务在接收到初始消费者请求消息后，在某个时间点可以通过该地址联系消费者。此外，还要求消费者提供关联细节，以便服务可以在未来的消息中发送一个标识符，从而消费者可以将它们与原始任务关联起来。'
- en: Service instance routing
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实例路由
- en: 'How can consumers contact and interact with service instances without the need
    for proprietary processing logic?:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在不需要专有处理逻辑的情况下，让消费者联系和交互服务实例？
- en: '| **Problem** | When required to repeatedly access a specific stateful service
    instance, consumers must rely on the custom logic that more tightly couples them
    to the service. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 当需要反复访问特定的状态化服务实例时，消费者必须依赖于将它们与服务更紧密耦合的自定义逻辑。|'
- en: '| **Solution** | The service provides an instance identifier along with its
    destination information in a standardized format that shields the consumer from
    having to resort to custom logic. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 服务以标准化的格式提供实例标识符及其目标信息，从而保护消费者免于需要使用自定义逻辑。|'
- en: '| **Impacts** | This pattern can introduce the need for significant infrastructure
    upgrades, and when misused can further lead to overly stateful messaging activities
    that can violate the service statelessness principle. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 这种模式可能会引入对重大基础设施升级的需求，并且如果滥用，还可能导致过度状态化的消息活动，从而违反服务无状态原则。|'
- en: '**Problem**: There are cases where a consumer sends multiple messages to a
    service and the messages need to be processed within the same runtime context.
    Such services are intentionally designed to remain stateful so that they can carry
    out conversational or session-centric message exchanges. However, service contracts
    generally do not provide a standardized means of representing or targeting instances
    of services. Therefore, consumer and service designers need to resort to passing
    proprietary instance identifiers as part of the regular message data, which results
    in the need for proprietary instance processing logic.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：存在消费者向服务发送多个消息，并且这些消息需要在同一运行时上下文中处理的情况。这类服务被有意设计成保持状态化，以便它们可以执行对话或以会话为中心的消息交换。然而，服务合同通常不提供一种标准化的方式来表示或定位服务实例。因此，消费者和服务设计者需要求助于将专有实例标识符作为常规消息数据的一部分传递，这导致需要专有实例处理逻辑。'
- en: '**Solution**: The underlying infrastructure is extended to support the processing
    of message metadata that enables a service instance identifier to be placed into
    a reference to the overall destination of the service. This reference (also referred
    to as an **endpoint reference**) is managed by the messaging infrastructure so
    that messages issued by the consumer are automatically routed to the destination
    represented by the reference. As a result, the processing of instance IDs does
    not negatively affect consumer-to-service coupling because consumers are not required
    to contain proprietary service instance processing logic. Because the instance
    IDs are part of a reference that is managed by the infrastructure, they are opaque
    to consumers. This means that consumers do not need to be aware of whether they
    are sending messages to a service or one of its instances because this is the
    responsibility of the routing logic within the messaging infrastructure.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：底层基础设施扩展以支持处理消息元数据，这使得可以将服务实例标识符放入对服务整体目标的引用中。此引用（也称为**端点引用**）由消息基础设施管理，以便消费者发出的消息自动路由到由引用表示的目标。因此，实例
    ID 的处理不会对消费者到服务的耦合产生负面影响，因为消费者不需要包含专有的服务实例处理逻辑。由于实例 ID 是由基础设施管理的引用的一部分，因此对消费者来说是透明的。这意味着消费者不需要知道他们是否正在向服务或其实例发送消息，因为这是由消息基础设施内部的路由逻辑负责的。'
- en: Asynchronous queuing pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步队列模式
- en: 'How can a service and its consumers accommodate isolated failures and avoid
    unnecessarily locking resources?:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让服务和其消费者适应隔离故障并避免不必要地锁定资源？：
- en: '| **Problem** | When a service capability requires that consumers interact
    with it synchronously, it can inhibit performance and compromise reliability.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 当服务能力要求消费者同步与之交互时，它可能会抑制性能并损害可靠性。|'
- en: '| **Solution** | A service can exchange messages with its consumers through
    an intermediary buffer, allowing services and consumers to process messages independently
    by remaining temporally decoupled. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 服务可以通过中介缓冲区与其消费者交换消息，允许服务和消费者通过保持时间解耦独立处理消息。|'
- en: '| **Impacts** | There may be no acknowledgment of successful message delivery,
    and atomic transactions may not be possible. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 可能不会有成功消息交付的确认，并且原子事务可能不可行。|'
- en: '**Problem**: Synchronous communication requires an immediate response to each
    request, and therefore forces two-way data exchange for every service interaction.
    When services need to carry out synchronous communication, both service and service
    consumer must be available and ready to complete the data exchange. This can introduce
    reliability issues when either the service cannot guarantee its availability to
    receive the request message or the service consumer cannot guarantee its availability
    to receive the response to its request. Because of its sequential nature, synchronous
    message exchanges can further impose processing overhead, as the service consumer
    needs to wait until it receives a response from its original request before proceeding
    to its next action. Prolonged responses can introduce latency by temporarily locking
    both consumer and service.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：同步通信要求对每个请求立即做出响应，因此强迫每个服务交互进行双向数据交换。当服务需要执行同步通信时，服务和消费者都必须可用并准备好完成数据交换。这可能会在服务无法保证其接收请求消息的可用性或服务消费者无法保证其接收请求响应的可用性时引入可靠性问题。由于其顺序性，同步消息交换还可以进一步增加处理开销，因为服务消费者需要等待收到其原始请求的响应后才能进行其下一项操作。长时间的响应可以通过暂时锁定消费者和服务来引入延迟。'
- en: Another problem forced synchronous communication can cause is an overload of
    services required to facilitate a great deal of concurrent access. Because services
    are expected to process requests as soon as they are received, usage thresholds
    can be more easily reached, thereby exposing the service to multi-consumer latency
    or overall failure.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 强制同步通信可能导致的另一个问题是，需要大量并发访问的服务可能会过载。因为服务预计会立即处理接收到的请求，所以使用阈值更容易达到，从而使得服务暴露于多消费者延迟或整体故障。
- en: '**Solution**: A queue is introduced as an intermediary buffer that receives
    request messages and then forwards them on behalf of the service consumers. If
    the target service is unavailable, the queue acts as temporary storage and retains
    the message. It then periodically attempts retransmission. Similarly, if there
    is a response, it can be issued through the same queue that will forward it back
    to the service consumer when the consumer is available. While either service or
    consumer is processing message contents, the other can deactivate itself (or move
    on to other processing) in order to minimize memory consumption.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：引入一个队列作为中介缓冲区，接收请求消息，然后代表服务消费者转发它们。如果目标服务不可用，队列充当临时存储并保留消息。然后它定期尝试重新传输。同样，如果有响应，它可以通过同一个队列发出，当消费者可用时，该队列会将它转发回服务消费者。当服务或消费者处理消息内容时，另一方可以停用自己（或继续其他处理），以最小化内存消耗。|'
- en: Reliable messaging pattern
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠消息模式
- en: 'How do we enable and ensure services to interact reliably in an unreliable
    environment?:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在不可靠的环境中启用并确保服务可靠地交互？：
- en: '| **Problem** | Messages need to reach the right services and should not be
    tampered within their path. That is, unreliable communication protocols and service
    environments are said to be the main barriers for service reliability. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | 消息需要到达正确的服务，并且在其路径中不应被篡改。也就是说，不可靠的通信协议和服务环境被认为是服务可靠性的主要障碍。|'
- en: '| **Solution** | An intermediate reliability mechanism has to be in place in
    order to guarantee that messages reach the right services and their integrity
    and confidentiality are being maintained appropriately. Also, this middleware
    has to guarantee message delivery. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | 必须实施一个中间可靠性机制，以确保消息能够到达正确的服务，并且它们的完整性和保密性得到适当的维护。此外，这个中间件还必须保证消息的投递。|'
- en: '| **Impacts** | Using a reliability framework adds processing overhead that
    can affect service activity performance. It also increases composition design
    complexity and may not be compatible with atomic service transactions. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 使用可靠性框架会增加处理开销，这可能会影响服务活动性能。它还增加了组合设计复杂性，并且可能不兼容原子服务事务。|'
- en: '**Problem**: When services are designed to activate and act through messages,
    there is a natural tendency for the loss of quality of service due to the stateless
    nature of underlying messaging protocols, such as HTTP. The binary communication
    protocols maintain a persistent connection until the data transmission between
    a sender and receiver is completed. However, with message exchanges, the runtime
    platform may not be able to provide feedback to the sender as to whether or not
    the message was successfully delivered to the target service endpoint. With more
    services and more network links, the complexity of service composition grows accordingly.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：当服务被设计为通过消息激活和行动时，由于底层消息协议（如HTTP）的无状态特性，自然会有服务质量下降的趋势。二进制通信协议在发送者和接收者之间的数据传输完成之前保持持久连接。然而，在消息交换中，运行时平台可能无法向发送者提供反馈，告知消息是否成功送达目标服务端点。随着服务和网络链路的增加，服务组合的复杂性相应增加。|'
- en: If the middleware infrastructure being employed is not able to guarantee reliable
    message delivery, then risks erupt. How can messages be exchanged while guaranteeing
    that messages are not lost in the case of system or communication failures? Reliability
    agents further manage the confirmation of successful and failed message deliveries
    through positive (ACK) and negative (NACK) acknowledgment notifications. Messages
    may be transmitted and acknowledged individually, or they may be bundled into
    message sequences that are acknowledged in groups (and may also have sequence-related
    delivery rules).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用的中间件基础设施无法保证可靠的消息投递，那么风险就会爆发。如何在系统或通信失败的情况下保证消息交换，同时确保消息不会丢失？可靠性代理通过正（ACK）和负（NACK）确认通知进一步管理成功和失败的消息投递的确认。消息可以单独传输和确认，也可以捆绑成消息序列，这些序列以组的形式确认（并且也可能有与序列相关的投递规则）。
- en: When messages are exchanged in distributed systems, errors can occur during
    the transmission of messages over communication links or during the processing
    of messages in system components. Under these conditions, it should be guaranteed
    that no messages are lost and that messages can be eventually recovered after
    a system failure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当在分布式系统中交换消息时，在通信链路上传输消息或在系统组件中处理消息时可能会发生错误。在这些条件下，应保证没有消息丢失，并且在系统故障后最终可以恢复消息。
- en: '**Solution: **The underlying infrastructure is fitted with a reliability framework
    that tracks and temporarily persists message transmissions and issues positive
    and negative acknowledgments to communicate successful and failed transmissions
    to message senders. Message exchange during communication partners is performed
    under transactional context, guaranteeing ACID behavior. In the cloud, there are
    several messaging systems that can be accessed as a service, such as Amazon SQS
    or the queue service part of Windows Azure Storage.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**底层基础设施配备了一个可靠性框架，该框架跟踪和临时持久化消息传输，并向消息发送者发出成功和失败确认，以传达成功和失败的消息传输。在通信伙伴之间进行消息交换是在事务上下文中执行的，保证了ACID行为。在云中，有几个消息系统可以作为服务访问，例如Amazon
    SQS或Windows Azure存储的队列服务。'
- en: As articulated previously, cloud integration patterns are very vital for cloud-based
    distributed application development, deployment, and delivery. There are specialized
    adapters, connectors, drivers, and other plugins to simplify and streamline cloud
    integration requirements. The integration patterns are crucial for the success
    of the cloud paradigm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，云集成模式对于基于云的分布式应用程序的开发、部署和交付至关重要。有专门的适配器、连接器、驱动程序和其他插件来简化并简化云集成需求。集成模式对于云范式的成功至关重要。
- en: Cloud design patterns
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云设计模式
- en: This section will discuss various cloud application design patterns that are
    highly useful for building reliable, scalable, and secure applications in the
    cloud. Readers can find deeper and decisive details of the patterns on the Microsoft
    website: [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论各种对在云中构建可靠、可扩展和安全的云应用程序非常有用的云应用程序设计模式。读者可以在Microsoft网站上找到有关这些模式的更深入和决定性的细节：[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)。
- en: Cache-aside pattern
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存旁路模式
- en: The gist of this pattern is to load data on demand into a cache from a data
    store. This pattern can improve performance and also helps to maintain consistency
    between data held in the cache and the data in the data store. Applications use
    a cache to optimize repeated access to information held in a data store. However,
    it is usually impractical to expect that cached data will always be completely
    consistent with the data in the data store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的核心是从数据存储中按需将数据加载到缓存中。此模式可以提高性能，并有助于保持缓存中保留的数据与数据存储中的数据之间的一致性。应用程序使用缓存来优化对数据存储中保留信息的重复访问。然而，通常不切实际地期望缓存数据始终与数据存储中的数据完全一致。
- en: There are many commercial caching systems providing read-through and write-through/write-behind
    operations. In these systems, an application retrieves data by referencing the
    cache. If the data is not available in the cache, it is transparently retrieved
    from the distant data store and added to the cache. Any modifications to data
    held in the cache are automatically written back to the data store as well. For
    caches that do not provide this functionality, it is the responsibility of the
    applications that use the cache to maintain the data in the cache. An application
    can emulate the functionality of read-through caching by implementing the cache-aside
    strategy. This strategy effectively loads data into the cache on demand.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多商业缓存系统提供读取通过和写入通过/写入后操作。在这些系统中，应用程序通过引用缓存来检索数据。如果数据不在缓存中，它将透明地从远程数据存储中检索并添加到缓存中。对缓存中保留的数据的任何修改都将自动写回数据存储。对于不提供此功能的缓存，维护缓存中的数据是使用缓存的应用程序的责任。应用程序可以通过实现缓存旁路策略来模拟读取通过缓存的函数。此策略有效地按需将数据加载到缓存中。
- en: Cloud application performance is often questioned by many. Hence, there is a
    bevy of performance enhancement techniques and tips being unearthed and promoted.
    This pattern is one such breakthrough solution technique in order to supply all
    the right and relevant information for application designers to substantially
    increase cloud performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用性能经常受到许多人的质疑。因此，涌现出大量性能提升技术和技巧。这种模式就是这样一个突破性的解决方案技术，旨在为应用设计师提供所有正确和相关的信息，以显著提高云性能。
- en: 'The usage scenarios include:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景包括：
- en: A cache doesn't provide native read-through and write-through operations
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存不提供原生的读透和写透操作
- en: Resource demand is unpredictable
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源需求是不可预测的
- en: Circuit breaker pattern
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: We all know that distributed computing is the way forward for new-generation
    businesses. Connectivity to remote services and resources is a core requirement
    in distributed computing environments. Remote connectivity has the habit of failure.
    That is, an application is trying to get connected with a remote service or data
    source and is not able to get access due to some transient fault, such as slow
    network connection, timeouts, the resources being overloaded, temporarily unavailable,
    and so on. These faults typically correct themselves after a short period of time,
    and a robust cloud application should be prepared to overcome these by using a
    well-drawn strategy, such as that described by the retry pattern.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，分布式计算是新代企业的发展方向。在分布式计算环境中，连接到远程服务和资源是一个核心需求。远程连接有故障的倾向。也就是说，应用试图连接到远程服务或数据源，但由于某些暂时性故障（如网络连接缓慢、超时、资源过载、暂时不可用等）而无法访问。这些故障通常在短时间内自行纠正，一个健壮的云应用应准备好通过使用如重试模式所描述的良好策略来克服这些故障。
- en: However, there may also be situations where faults occur out of unexpected events
    that are quite tough to anticipate. Furthermore, those faults may take a longer
    time to get rectified. These faults can range in severity, from a partial loss
    of connectivity to the complete failure of a service. In these situations, it
    may be pointless for an application to continually retry performing an operation
    that is unlikely to succeed, and instead, the application should quickly accept
    that the operation has failed and handle the failure accordingly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可能出现故障由难以预料的事件引起的特殊情况。此外，这些故障可能需要更长的时间才能得到修复。这些故障的严重程度可能从部分连接丢失到服务的完全失败不等。在这些情况下，应用不断重试执行不太可能成功的操作可能毫无意义，相反，应用应迅速接受操作已失败，并相应地处理故障。
- en: The circuit breaker pattern can prevent an application repeatedly trying to
    execute an operation that is likely to fail, allowing it to continue without waiting
    for the fault to be rectified or wasting CPU cycles while it determines that the
    fault is long lasting. The circuit breaker pattern also enables an application
    to detect whether the fault has been resolved. If the problem appears to have
    been rectified, the application can attempt to invoke the operation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式可以防止应用反复尝试执行可能失败的操作，允许它在等待故障修复或确定故障持续时间较长时继续运行，而不会浪费CPU周期。断路器模式还使应用能够检测故障是否已解决。如果问题似乎已经得到解决，应用可以尝试调用操作。
- en: The circuit breaker pattern is different from the retry pattern. The retry pattern
    enables an application to retry an operation with the expectation that it will
    succeed, but the circuit breaker pattern prevents an application from performing
    an operation that is likely to fail. An application may combine these two patterns
    by using the retry pattern to invoke an operation through a circuit breaker. However,
    the retry logic should be sensitive to any exceptions returned by the circuit
    breaker and abandon retry attempts if the circuit breaker indicates that a fault
    is not transient.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式与重试模式不同。重试模式允许应用在有成功期望的情况下重试操作，但断路器模式阻止应用执行可能失败的操作。应用可以通过使用断路器通过重试模式调用操作来结合这两种模式。然而，重试逻辑应敏感于断路器返回的任何异常，并在断路器指示故障不是暂时性的情况下放弃重试尝试。
- en: A circuit breaker acts as a proxy for operations that may fail. The proxy should
    monitor the number of recent failures that have occurred, and then use this information
    to decide whether to allow the operation to proceed, or simply return an exception
    immediately.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器充当可能失败的操作的代理。代理应监控最近发生的失败次数，然后使用这些信息来决定是否允许操作继续进行，或者立即返回异常。
- en: Compensating transaction pattern
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补偿事务模式
- en: We all know that any business and financial transaction has to strictly fulfill
    the ACID properties. Steadily, transactional applications are being deployed in
    cloud environments. Now, in the big data era, distributed computing is becoming
    the mainstream computing model. NoSQL databases are very prominent and dominant
    these days in order to do justice to big data. Increasingly, there is an assortment
    of segregated yet connected data sources as well as stores to perform high-performance
    data access, processing, and retrieval. In this case, strong transactional consistency
    is not being maintained. Rather, the application should go for eventual consistency.
    While these steps are being performed, the overall view of the system state may
    be inconsistent, but when the operation has completed and all of the steps have
    been executed, the system should become consistent again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，任何商业和金融交易都必须严格满足ACID属性。随着事务性应用程序在云环境中的部署，这些属性正逐渐得到满足。现在，在大数据时代，分布式计算已成为主流计算模型。NoSQL数据库如今非常突出和主导，以适应大数据的需求。越来越多的数据源和存储被分割但相互连接，以执行高性能的数据访问、处理和检索。在这种情况下，强事务一致性没有得到保持。相反，应用程序应追求最终一致性。在这些步骤执行过程中，系统的整体状态可能不一致，但一旦操作完成并且所有步骤都已执行，系统应再次变得一致。
- en: A significant challenge in the eventual consistency model is how to handle a
    step that has failed irrecoverably. In this case, it may be necessary to undo
    all of the work completed by the previous steps in the operation. However, the
    data cannot simply be rolled back because other concurrent instances of the application
    may have since changed it. Even in cases where the data has not been changed by
    a concurrent instance, undoing a step might not simply be a matter of restoring
    the original state. It may be necessary to apply various business-specific rules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终一致性模型中，一个重大挑战是如何处理一个无法恢复的失败步骤。在这种情况下，可能需要撤销操作中之前步骤完成的所有工作。然而，数据不能简单地回滚，因为其他并发实例的应用程序可能已经更改了它。即使在数据没有被并发实例更改的情况下，撤销一个步骤可能不仅仅是恢复原始状态的问题。可能需要应用各种特定于业务规则。
- en: Compensation has been the typical response when a transaction fails. This pattern
    is mainly to undo the work performed by a series of steps, which together define
    an eventually consistent operation if one or more of the steps fail. A compensating
    transaction might not be able to simply replace the current state with the state
    the system was in at the start of the operation because this approach could overwrite
    changes made by other concurrent instances of an application. Rather, it must
    be an intelligent process that takes into account any work done by concurrent
    instances. This process will usually be application-specific, driven by the nature
    of the work performed by the original operation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 补偿机制是事务失败时的典型响应。这种模式主要是撤销一系列步骤所执行的工作，这些步骤共同定义了一个最终一致性操作，如果其中一个或多个步骤失败。补偿事务可能无法简单地用操作开始时系统的状态替换当前状态，因为这种方法可能会覆盖其他并发应用程序实例所做的更改。相反，它必须是一个智能过程，考虑到任何并发实例完成的工作。这个过程通常将是特定于应用程序的，由原始操作执行的工作的性质驱动。
- en: A common approach to implementing an eventually consistent operation that requires
    compensation is to use a workflow. As the original operation proceeds, the system
    records information about each step and how the work performed by that step can
    be undone. If the operation fails at any point, the workflow rewinds back through
    the steps it has completed and performs the work that reverses each step.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实现需要补偿的最终一致性操作的常见方法是用工作流。随着原始操作的进行，系统记录有关每个步骤以及该步骤执行的工作如何撤销的信息。如果操作在任何一点失败，工作流将回滚到已完成的步骤，并执行每个步骤的反向工作。
- en: Competing consumers pattern
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争消费者模式
- en: With the surging popularity of web-scale applications, there can be a large
    number of requests from different parts of the world for those applications. The
    user and data loads are generally unpredictable. The task/operation complexity
    is also unpredictable. Because of heavy loads, cloud applications find it difficult
    to process every request and deliver the reply within the stipulated timeline.
    One option is to add new server instances. There are some practical difficulties
    in clustered and load-balanced environments too. However, these consumers must
    be coordinated to ensure that each message is only delivered to a single consumer.
    The workload also needs to be load balanced across consumers to prevent an instance
    from becoming a bottleneck.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web规模应用程序的日益流行，可能会有来自世界各地的许多请求。用户和数据负载通常是不可预测的。任务/操作复杂性也是不可预测的。由于负载沉重，云应用程序发现很难在规定的时间内处理每个请求并给出回复。一个选择是添加新的服务器实例。在集群和负载均衡环境中也存在一些实际困难。然而，这些消费者必须协调一致，以确保每个消息只被发送给单个消费者。工作负载也需要在消费者之间进行负载均衡，以防止实例成为瓶颈。
- en: An overwhelming solution approach here is to use a messaging system (message
    queue or broker) in between any requesting applications/users and the processing
    applications. A **message-oriented middleware** (**MOM**) is a way forward for
    meeting a large number of concurrent consumers. This middleware approach supports
    asynchronous communication and processing, thereby the massive number of requests
    can be answered quickly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个压倒性的解决方案是，在请求应用程序/用户和处理应用程序之间使用消息系统（消息队列或代理）。**面向消息的中间件（MOM**）是满足大量并发消费者需求的一种方法。这种中间件方法支持异步通信和处理，因此可以快速响应大量请求。
- en: 'A message queue/broker/bus is used to establish the communication channel between
    the application and the instances of the consumer service. The application posts
    requests in the form of messages to the queue and the consumer service instances
    receive messages from the queue and process them. This approach enables the same
    pool of consumer service instances to handle messages from any instance of the
    application. The following figure illustrates this architecture:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列/代理/总线用于在应用程序和消费者服务实例之间建立通信通道。应用程序将请求以消息的形式发布到队列中，消费者服务实例从队列中接收消息并处理它们。这种方法使得同一池的消费者服务实例可以处理来自应用程序任何实例的消息。以下图示说明了这种架构：
- en: '![](img/378c8a83-880e-45e9-95c9-7642e2a044bb.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/378c8a83-880e-45e9-95c9-7642e2a044bb.png)'
- en: This pattern enables multiple concurrent consumers to process messages received
    on the same messaging channel. This pattern enables a system to process multiple
    messages concurrently to optimize throughput, to improve scalability and availability,
    and to balance the workload.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式允许多个并发消费者处理同一消息通道接收到的消息。此模式允许系统并发处理多个消息以优化吞吐量，提高可扩展性和可用性，并平衡工作负载。
- en: Compute resource consolidation pattern
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算资源整合模式
- en: There are several architectural patterns, such as MVC, **service-oriented architecture**
    (**SOA**), **event-driven architecture** (**EDA**), **resource-oriented architecture**
    (**ROA**), **microservices architecture** (**MSA**), and so on, recommending the
    application partitioning for various benefits. However, there are occasions wherein
    consolidating multiple tasks or operations into a single computational unit brings
    forth a number of advantages.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种架构模式，如MVC、**面向服务的架构（SOA**）、**事件驱动架构（EDA**）、**资源导向架构（ROA**）、**微服务架构（MSA**）等，推荐应用分区以获得各种好处。然而，有时将多个任务或操作整合到一个计算单元中会带来许多优势。
- en: A common approach is to look for tasks that have a similar profile concerning
    their scalability, lifetime, and processing requirements. Grouping these items
    together allows them to scale as a unit. The elasticity provided by many cloud
    environments enables additional instances of a computational unit to be started
    and stopped according to the workload. This pattern can increase compute resource
    utilization, and reduce the costs and management overhead associated with performing
    compute processing in cloud-hosted applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的做法是寻找具有相似的可扩展性、生命周期和处理要求的任务。将这些项目分组在一起可以使它们作为一个单元进行扩展。许多云环境提供的弹性使得可以根据工作负载启动和停止计算单元的额外实例。这种模式可以提高计算资源利用率，并减少在云托管应用程序中执行计算处理相关的成本和管理开销。
- en: Command and query responsibility segregation (CQRS) pattern
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令和查询责任分离（CQRS）模式
- en: 'In traditional database management systems, both commands (updates to the data)
    and queries (requests for data) are executed against the same set of entities
    in a single data repository. These entities may be a subset of the rows in one
    or more tables in an RDBMS. Typically, in these systems, all **create**, **read**,
    **update**, and **delete** (**CRUD**) operations are applied to the same representation
    of the entity. Traditional CRUD designs work well when there is only limited business
    logic applied to the data operations. There are a few serious issues being associated
    with the CRUD approach, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的数据库管理系统（DBMS）中，命令（对数据的更新）和查询（对数据的要求）都是针对单个数据仓库中的同一组实体执行的。这些实体可能是RDBMS中一个或多个表中的行的一个子集。通常，在这些系统中，所有**创建**、**读取**、**更新**和**删除**（**CRUD**）操作都应用于实体的同一表示。当对数据操作应用的业务逻辑有限时，传统的CRUD设计效果良好。与CRUD方法相关联存在一些严重问题，如下所述：
- en: There may be a mismatch between the read and write representations of the data,
    such as additional columns or properties that must be updated correctly even though
    they are not required as a part of an operation
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的读取和写入表示之间可能存在不匹配，例如，即使它们不是操作的一部分，也必须正确更新额外的列或属性
- en: It risks encountering data contention in a collaborative domain (where multiple
    actors operate in parallel on the same set of data) when records are locked in
    the data store, or update conflicts caused by concurrent updates when optimistic
    locking is used
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据存储中锁定记录时，可能会在协作域（多个操作者在同一组数据上并行操作）中遇到数据竞争，或者在乐观锁定时由于并发更新而引起更新冲突
- en: This pattern segregates operations that read data from operations that update
    data by using separate interfaces. This pattern can maximize performance, scalability,
    and security, support evolution of the system over time through higher flexibility,
    and prevent update commands from causing merge conflicts at the domain level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式通过使用单独的接口将读取数据的操作与更新数据的操作分开，从而隔离操作。此模式可以最大化性能、可伸缩性和安全性，通过更高的灵活性支持系统随时间的演变，并防止更新命令在域级别引起合并冲突。
- en: '**The event sourcing pattern and the CQRS pattern**: CQRS-based systems use
    separate read and write data models. Each model is tailored to relevant tasks
    and often located in physically separate stores. When used with event sourcing,
    the store of events is the write model, and this is the authoritative source of
    information. The read model of a CQRS-based system provides materialized views
    of the data as highly denormalized views. These views are tailored to the interfaces
    and display requirements of the application and this helps to maximize both display
    and query performance.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件溯源模式和CQRS模式**：基于CQRS的系统使用单独的读取和写入数据模型。每个模型都针对相关任务进行定制，并且通常位于物理上分开的存储中。当与事件溯源一起使用时，事件存储是写入模型，这是信息的权威来源。基于CQRS的系统中的读取模型提供数据的高度反规范化视图。这些视图针对应用程序的接口和显示要求进行定制，这有助于最大化显示和查询性能。'
- en: Using the stream of events as the write store, rather than the actual data at
    a point in time, avoids update conflicts on a single aggregate and maximizes performance
    and scalability. The events can be used to asynchronously generate materialized
    views of the data that are used to populate the read store.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件流作为写入存储，而不是在某个时间点的实际数据，避免了单个聚合上的更新冲突，并最大化了性能和可伸缩性。这些事件可以用来异步生成用于填充读取存储的数据的物化视图。
- en: Event sourcing pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源模式
- en: Most applications work with data, and the overwhelming approach is for the application
    to maintain the current state of the data by updating it as users work with the
    data. For example, in the CRUD model, a data process reads data from the store,
    makes some modifications to it, and updates the current state of the data with
    the new values. The problem with this approach is that performing update operations
    directly against a data store may degrade performance and responsiveness. The
    scalability aspect may also be affected. In a collaborative environment, there
    are many concurrent users, and hence there is a high possibility for data update
    conflicts because the update operations take place on a single item of data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都与数据一起工作，最常见的方法是应用程序通过在用户操作数据时更新数据来维护数据的当前状态。例如，在 CRUD 模型中，数据处理过程从存储中读取数据，对其进行一些修改，并使用新值更新数据的当前状态。这种方法的缺点是直接对数据存储执行更新操作可能会降低性能和响应速度。可扩展性方面也可能受到影响。在协作环境中，有众多并发用户，因此数据更新冲突的可能性很高，因为更新操作是在单个数据项上进行的。
- en: The events are persisted in an event store that acts as the source of truth
    about the current state of the data. The event store typically publishes these
    events so that consumers can be notified and can handle them if needed. Consumers
    could, for example, initiate tasks that apply the operations in the events to
    other systems. The point to be noted here is that application code that generates
    the events is decoupled from the systems that subscribe to the events.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事件被持久化在事件存储中，该存储作为数据当前状态的真相来源。事件存储通常发布这些事件，以便消费者可以收到通知并在需要时处理它们。例如，消费者可以启动任务，将事件中的操作应用于其他系统。需要注意的是，生成事件的应用程序代码与订阅事件的系统是解耦的。
- en: The solution is to use an append-only store to record the full series of events
    that describe actions taken on data in a domain, rather than storing just the
    current state so that the store can be used to materialize the domain objects.
    This pattern can simplify tasks in complex domains by avoiding the requirement
    to synchronize the data model and the business domain. This pattern improves performance,
    scalability, and responsiveness. Furthermore, it provides consistency for transactional
    data and maintains full audit trails and history that may enable compensating
    actions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用只追加存储来记录描述在域中对数据执行的操作的完整事件序列，而不是仅存储当前状态，以便存储可以用来实例化域对象。这种模式可以通过避免同步数据模型和业务域的要求来简化复杂域中的任务。这种模式提高了性能、可扩展性和响应速度。此外，它为事务数据提供了一致性，并维护了完整的审计跟踪和历史记录，这可能使补偿操作成为可能。
- en: External configuration store pattern
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部配置存储模式
- en: The majority of application runtime environments include configuration information
    that is held in files deployed with the application, located within the application
    folders. In some cases, it is possible to edit these files to change the behavior
    of the application after it has been deployed. However, in many cases, changes
    to the configuration require the application to be redeployed, resulting in unacceptable
    downtime and additional administrative overhead.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序的运行时环境包括配置信息，这些信息存储在与应用程序一起部署的文件中，位于应用程序文件夹内。在某些情况下，可以编辑这些文件来更改已部署应用程序的行为。然而，在许多情况下，对配置的更改需要重新部署应用程序，从而导致不可接受的停机时间和额外的管理开销。
- en: Local configuration files also limit the configuration to a single application,
    whereas, in some scenarios, it would be useful to share configuration settings
    across multiple applications. Managing changes to local configurations across
    multiple running instances of the application is another challenge. The approach
    is to store the configuration information in external storage. This moves configuration
    information out of the application deployment package to a centralized location.
    This pattern can provide opportunities for easier management and control of configuration
    data, and for sharing configuration data across applications and application instances**.**
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本地配置文件也限制了配置仅限于单个应用程序，而在某些场景中，跨多个应用程序共享配置设置会很有用。管理多个应用程序运行实例之间的本地配置更改是另一个挑战。解决方案是将配置信息存储在外部存储中。这把配置信息从应用程序部署包移至集中位置。这种模式可以提供更易于管理和控制配置数据的机会，以及跨应用程序和应用程序实例共享配置数据的机会**。**
- en: Federated identity pattern
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦身份模式
- en: There are many applications hosted by different cloud service providers. Predominantly,
    there are email and social networking applications. These applications are being
    subscribed to and used by many people from different parts of the world. Typically,
    users need to memorize and use different credentials for accessing each of these
    customer-centric, collaborative, and cloud applications. Managing multiple credentials
    is a tough assignment. The solution is to implement an authentication mechanism
    that can use the proven concept of federated identity. This is accomplished by
    separating the aspect of user authentication from the application logic code and
    delegating the authentication requirement to a trusted and third-party identity
    service provider. The trusted identity providers can authenticate users on behalf
    of application service providers. The identity service providers have, for example,
    a Microsoft, Google, Yahoo!, or Facebook account. This identity pattern can simplify
    development, minimize the requirement for user administration, and improve the
    user experience of the application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多应用由不同的云服务提供商托管。主要的是电子邮件和社交网络应用。这些应用被来自世界各地的人们订阅和使用。通常，用户需要记住并使用不同的凭证来访问这些以客户为中心的、协作的和云应用中的每一个。管理多个凭证是一项艰巨的任务。解决方案是实现一种可以使用联邦身份这一经过验证的概念的认证机制。这是通过将用户认证方面与应用逻辑代码分离，并将认证需求委托给受信任的第三方身份服务提供商来实现的。受信任的身份提供者可以代表应用服务提供商认证用户。例如，身份服务提供商拥有微软、谷歌、雅虎！或Facebook账户。这种身份模式可以简化开发，减少用户管理的需求，并提高应用的用户体验。
- en: Gatekeeper pattern
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守门人模式
- en: Cloud applications need to be protected from malicious users. Also, some cloud
    applications are provided by multiple cloud service providers. Users are therefore
    in a position to choose one service provider according to his or her terms. Cloud
    broker is a new software product enabling users to zero down the appropriate cloud
    service providers. Thus, a kind of gatekeeper software solution is needed to act
    as a broker between application clients and application services, validate and
    sanitize requests, and pass requests and data between them. This can provide an
    additional layer of security, and limit the attack surface of the system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用需要保护免受恶意用户的侵害。此外，一些云应用由多个云服务提供商提供。因此，用户可以根据自己的条款选择一个服务提供商。云代理是一种新的软件产品，使用户能够缩小合适的云服务提供商。因此，需要一种守门人软件解决方案来作为应用客户端和应用服务之间的经纪人，验证和清理请求，并在它们之间传递请求和数据。这可以提供额外的安全层，并限制系统的攻击面。
- en: This pattern minimizes the risk of clients gaining access to sensitive information
    and services. This gateway solution contributes as a façade or a dedicated task
    that interacts with clients and then hands off the request perhaps through a decoupled
    interface to the hosts or tasks that'll handle the request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式最小化了客户端获取敏感信息和服务的风险。此网关解决方案作为一个门面或专门的任务，与客户端交互，然后将请求通过解耦接口传递给处理请求的主机或任务。
- en: Application health monitoring pattern
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用健康监控模式
- en: Cloud applications ought to fulfill the various service and operational expectations
    that are formally contracted through an SLA agreement. Hence, it is pertinent
    to have a competent health monitoring system to precisely and minutely monitor
    the functioning and health of cloud applications, database systems, middleware
    solutions, and so on. The health check is, therefore, an important factor in ensuring
    the agreed quality parameters. The monitoring is not an easy thing to do. Cloud
    environments are hugely complicated due to the massive scale, such as increasingly
    software-defined, federated, and shared. The way forward here is to put a health
    monitoring system in place in order to send requests to an endpoint on the application
    so as to capture the right and relevant data to act upon with clarity and confidence.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用应满足通过SLA协议正式签订的各种服务和运营期望。因此，拥有一个能够精确和细致监控云应用、数据库系统、中间件解决方案等运行和健康状况的健康监控系统是相关的。因此，健康检查是确保协议质量参数的重要因素。监控并非易事。由于规模巨大，如日益软件定义、联邦化和共享，云环境非常复杂。前进的道路是将健康监控系统实施到位，以便向应用端点发送请求，以捕获正确和相关的数据，以便清晰和自信地采取行动。
- en: Leader election pattern
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领导选举模式
- en: Cloud applications are extremely complicated yet sophisticated. Multiple instances
    of cloud applications can run in a cloud environment. Similarly, different components
    of an application can run on clouds. The tasks might be working together in parallel
    to perform the individual parts of a complex calculation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用极其复杂且精密。多个云应用实例可以在云环境中运行。同样，应用程序的不同组件也可以在云上运行。任务可能会并行工作，以执行复杂计算的各个部分。
- en: The task instances might run separately for much of the time, but it might also
    be necessary to coordinate the actions of each instance to ensure that they don't
    create any sort of conflict, cause contention for shared resources, or accidentally
    interfere with the work that other task instances are performing. So, there is
    a need for adept coordinator software; each action has to be coordinated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 任务实例可能大部分时间都在单独运行，但有时也可能需要协调每个实例的行动，以确保它们不会产生任何冲突，不会对共享资源造成竞争，或者意外干扰其他任务实例正在执行的工作。因此，需要熟练的协调软件；每个动作都必须得到协调。
- en: A single task instance should be elected to act as the leader, and this instance
    should coordinate the actions of the other subordinate task instances. If all
    of the task instances are running the same code, then one instance can act as
    the leader. However, the election of the leader has to be done smartly. There
    has to be a robust mechanism in place for leader selection. This selection method
    has to cope with the events, such as network outages or process failures. In many
    solutions, the subordinate task instances monitor the leader through some type
    of heartbeat method, or by polling. If the designated leader terminates unexpectedly,
    or a network failure makes the leader unavailable to the subordinate task instances,
    it is necessary for them to elect a new leader.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应该选择一个单独的任务实例作为领导者，并且这个实例应该协调其他从属任务实例的行动。如果所有任务实例都在运行相同的代码，那么一个实例可以充当领导者。然而，领导者的选举必须做得聪明。必须有一个健壮的领导者选择机制。这种选择方法必须能够处理诸如网络中断或进程故障等事件。在许多解决方案中，从属任务实例通过某种心跳方法或轮询来监控领导者。如果指定的领导者意外终止，或者网络故障使领导者对从属任务实例不可用，那么他们必须选举一个新的领导者。
- en: Materialized views pattern
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物化视图模式
- en: When storing data, developers and database administrators are more concerned
    about how the data is stored. They are least bothered about how the data will
    be read. The chosen data storage format is usually closely related to the format
    of the data, requirements for managing data size and data integrity, and the kind
    of store in use. For example, when using a NoSQL document store, the data is often
    represented as a series of aggregates, each containing all of the information
    for that entity. However, this can have a negative effect on queries. When a query
    only needs a subset of the data from some entities, such as a summary of orders
    for several customers without all of the order details, it must extract all of
    the data for the relevant entities in order to obtain the required details.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储数据时，开发人员和数据库管理员更关心数据是如何存储的。他们最不关心的是数据如何被读取。选择的数据存储格式通常与数据的格式、管理数据大小和数据完整性的要求以及所使用的存储类型密切相关。例如，当使用NoSQL文档存储时，数据通常表示为一系列聚合，每个聚合包含该实体的所有信息。然而，这可能会对查询产生负面影响。当查询只需要从某些实体中获取数据的一个子集时，例如，几个客户的订单摘要而不包括所有订单详情，它必须提取相关实体的所有数据以获取所需详情。
- en: To support efficient querying, a common solution is to generate, in advance,
    a view that materializes the data in a format suited to the required results set.
    The materialized view pattern describes generating prepopulated views of data
    in environments where the source data isn't in a suitable format for querying,
    where generating a suitable query is difficult, or where query performance is
    poor due to the nature of the data or the data store.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持高效的查询，一个常见的解决方案是在预先生成一个视图，该视图以适合所需结果集的格式实现数据。物化视图模式描述了在源数据不适合查询、生成合适的查询困难或由于数据或数据存储的性质导致查询性能较差的环境中生成预填充的数据视图。
- en: These materialized views, which only contain data required by a query, allow
    applications to quickly obtain the information they need. In addition to joining
    tables or combining data entities, materialized views can include the current
    values of calculated columns or data items, the results of combining values or
    executing transformations on the data items, and values specified as part of the
    query. A materialized view can even be optimized for just a single query. This
    pattern can help support efficient querying and data extraction, and improve application
    performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仅包含查询所需数据的物化视图，允许应用程序快速获取所需的信息。除了连接表或组合数据实体之外，物化视图还可以包括计算列或数据项的当前值，对数据项进行组合值或执行转换的结果，以及作为查询一部分指定的值。物化视图甚至可以针对单个查询进行优化。这种模式可以帮助支持高效的查询和数据提取，并提高应用程序性能。
- en: Pipes and filters pattern
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和过滤器模式
- en: An application is mandated to perform a variety of tasks of varying complexity
    on the information that it receives, processes, and presents. Traditionally, a
    monolithic application is produced to perform this duty. However, the monolithic
    architecture and approach are bound to fail in due course due to various reasons
    (modifiability, replaceability, reusability, substitutability, simplicity, accessibility,
    sustainability, scalability, and so on). Therefore, the proven and potential technique
    of *divide and conquer* has become a preferred approach in the field of software
    engineering. **Aspect-oriented programming** (**AOP**) is a popular method. There
    are other decomposition approaches.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须执行其在接收、处理和呈现信息时遇到的各种不同复杂性的任务。传统上，为了完成这项任务，会生成一个单体应用程序。然而，由于各种原因（可修改性、可替换性、可重用性、可替代性、简单性、可访问性、可持续性、可扩展性等），单体架构和方式注定会在某个时候失败。因此，经过验证的“分而治之”技术已经成为软件工程领域的一种首选方法。**面向方面编程**（**AOP**）是一种流行的方法。还有其他分解方法。
- en: Furthermore, some of the tasks that the monolithic modules perform are functionally
    very similar, but the modules have been designed separately. Some tasks might
    be compute intensive and could benefit from running on powerful hardware, while
    others might not require such expensive resources. Also, additional processing
    might be required in the future, or the order in which the tasks are performed
    by the processing could change.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单体模块执行的一些任务在功能上非常相似，但模块是分别设计的。一些任务可能是计算密集型的，可能从在强大的硬件上运行中受益，而其他任务可能不需要这样昂贵的资源。此外，未来可能需要额外的处理，或者处理执行任务的顺序可能会改变。
- en: Considering all these limitations, the recommended approach is to break down
    the processing required for each stream of tasks into a set of separate components
    (filters), and each component (filter) is assigned to perform a single task. By
    standardizing the format of the data that each component receives and sends, these
    filters can be combined together into a pipeline. This helps to avoid duplicating
    code and makes it easy to remove, replace, or integrate additional components
    if the processing requirements change. This unique pattern can substantially improve
    performance, scalability, and reusability by allowing task elements that perform
    the processing to be deployed and scaled independently.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些限制，推荐的方法是将每个任务流所需的处理分解成一组单独的组件（过滤器），并将每个组件（过滤器）分配以执行单个任务。通过标准化每个组件接收和发送的数据格式，这些过滤器可以组合成一个管道。这有助于避免代码重复，并使得在处理需求发生变化时，轻松地移除、替换或集成额外的组件变得容易。这种独特的模式可以通过允许执行处理的任务元素独立部署和扩展，从而显著提高性能、可扩展性和可重用性。
- en: Priority queue pattern
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列模式
- en: Applications can delegate specific tasks to other services to perform them,
    such as some background processing or the integration with third-party or external
    applications or services. Employing middleware solutions to perform those intermediary
    jobs has been a widely followed activity. The message queue is a prominent one
    in enterprise and cloud environments to realize tasks, such as intermediation,
    enrichment, filtering and funneling, and so on. Here, the order of the requests
    is not important. That is, giving a kind of priority for a particular task is
    being insisted in certain scenarios. These requests should be processed earlier
    than lower priority requests that were sent previously by the application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以将特定任务委托给其他服务执行，例如一些后台处理或与第三方或外部应用程序或服务的集成。采用中间件解决方案来执行这些中间任务已经成为一种广泛遵循的活动。消息队列在企业级和云环境中是实现诸如中介、丰富、过滤和导流等任务的突出工具。在这里，请求的顺序并不重要。也就是说，在某些场景下，对特定任务给予一种优先级是必须坚持的。这些请求应该比应用程序先前发送的优先级较低的请求先被处理。
- en: A queue is usually a **first-in, first-out** (**FIFO**) structure, and consumers
    typically receive messages in the same order that they were posted to the queue.
    However, some message queues support priority messaging. The application posting
    a message can assign a priority and the messages in the queue are automatically
    reordered so that those with a higher priority will be received before those with
    a lower priority. This pattern is useful in applications that offer different
    service-level guarantees to individual clients.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 队列通常是一个**先进先出**（**FIFO**）结构，消费者通常以它们被发布到队列中的相同顺序接收消息。然而，一些消息队列支持优先级消息。发布消息的应用程序可以分配一个优先级，队列中的消息将自动重新排序，以便具有更高优先级的消息将在具有较低优先级的消息之前被接收。这种模式在为个别客户提供不同服务级别保证的应用程序中非常有用。
- en: Queue-based load leveling pattern
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于队列的负载均衡模式
- en: Cloud applications may sometimes be subjected to heavy loads (user and data).
    Applications are being designed and developed accordingly and are made to run
    on clustered environments in order to meet sudden or seasonal spikes. When applications
    are under heavy loads, the application performance may go down. Especially, some
    crucial tasks that are the part of the application may come under heavy bombardment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用程序有时可能会面临沉重的负载（用户和数据）。应用程序据此被设计和开发，并部署在集群环境中以应对突然或季节性的高峰。当应用程序承受重负载时，应用程序的性能可能会下降。特别是，一些作为应用程序一部分的关键任务可能会受到重压。
- en: The viable approach is to refactor the application and introduce a queue between
    the task and the service. The idea here is that the task and the service run asynchronously.
    The task posts a message containing the data required by the service to a queue.
    The queue acts as a buffer, storing the message until it's retrieved by the service.
    The service retrieves the messages from the queue and processes them. Requests
    from a number of tasks, which can be generated at a highly variable rate, can
    be passed to the service through the same message queue. This pattern can help
    to minimize the impact of peaks in demand on availability and responsiveness for
    both the task and the service.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可行的做法是对应用程序进行重构，并在任务和服务之间引入一个队列。这里的想法是任务和服务异步运行。任务将包含服务所需数据的消息发布到队列中。队列充当缓冲区，存储消息直到被服务检索。服务从队列中检索消息并处理它们。来自多个任务（这些任务可以以高度可变的速度生成）的请求可以通过同一个消息队列传递到服务。这种模式可以帮助最小化需求高峰对任务和服务可用性和响应性的影响。
- en: Retry pattern
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试模式
- en: Applications are spread across multiple clouds, across continents, countries,
    counties, and cities. Not only public clouds are being leveraged as the application
    deployment, delivery, and management platform, but also mission-critical, high-performance,
    and secure applications and data stores are being deployed and delivered through
    private clouds. Some enterprises continue with traditional IT environments. Applications
    literally have to connect, access and use nearby, as well as remotely held, applications
    or databases often as a part of successfully fulfilling any brewing business process
    requirements. But applications connecting and collaborating with other applications
    in the vicinity or in off-premise environments are not that straightforward.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序分布在多个云中，跨越大陆、国家、县和城市。不仅公共云被用作应用程序部署、交付和管理平台，而且关键任务、高性能和安全的应用程序和数据存储也通过私有云进行部署和交付。一些企业继续使用传统的IT环境。应用程序实际上必须连接、访问和使用附近的，以及远程持有的应用程序或数据库，通常作为成功满足任何正在酝酿的业务流程需求的一部分。但是，与附近或异地环境中的其他应用程序连接和协作的应用程序并不那么简单。
- en: There can be transient faults in the way of accessing other applications. The
    network connectivity, the failure of the requested applications due to overload,
    the temporary unavailability of the application, and so on, are being touted as
    the challenges for applications talking to one another over any network.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问其他应用程序的方式中可能会出现短暂的故障。网络连接问题、由于过载导致的请求应用程序的失败、应用程序的暂时不可用等问题，都被视为在任意网络中相互通信的应用程序所面临的挑战。
- en: Applications ought to be designed in such a way that they try again to connect
    and proceed with their task-fulfillment. If the application request fails, the
    application can wait and make another attempt. If necessary, this process can
    be repeated with increasing delays between retry attempts, until some maximum
    number of requests has been attempted. The delay can be increased incrementally
    or exponentially, depending on the type of failure and the probability that it'll
    be corrected during this time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该设计成尝试再次连接并继续完成任务。如果应用程序请求失败，应用程序可以等待并再次尝试。如果需要，这个过程可以在尝试请求之间增加延迟，直到尝试了最大数量的请求。延迟可以按增量或指数方式增加，具体取决于失败类型和在此期间得到纠正的概率。
- en: Runtime reconfiguration pattern
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时重新配置模式
- en: Traditionally, a static configuration has been the way for any application.
    If there is a need to make changes in the configuration, then the application
    has to be shut down and restarted after incorporating the configuration changes.
    Now in the web world, the downtime is not liked. Therefore, there is a need for
    a workable technique to achieve runtime configuration. That is, while the application
    is still running and delivering its service, the required configuration has to
    be brought in. The application has to immediately consider the changes and act
    on that. Similarly, the application has to convey the configuration changes to
    all its components.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，静态配置一直是任何应用程序的方式。如果需要更改配置，那么在合并配置更改后，应用程序必须关闭并重新启动。现在在互联网世界中，停机时间不受欢迎。因此，需要一种可行的技术来实现运行时配置。也就是说，当应用程序仍在运行并交付其服务时，必须引入所需的配置。应用程序必须立即考虑这些更改并采取行动。同样，应用程序必须将其配置更改传达给所有其组件。
- en: The success of this pattern squarely depends on the features available in the
    application runtime environment. Typically, the application code will respond
    to one or more events that are raised by the hosting infrastructure when it detects
    a change to the application configuration. This is usually the result of uploading
    a new configuration file, or in response to changes in the configuration through
    the administration portal or by accessing an API.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的成功完全取决于应用程序运行时环境中的功能。通常，应用程序代码将对托管基础设施在检测到应用程序配置更改时引发的一个或多个事件做出响应。这通常是由于上传新的配置文件，或者通过管理门户或通过访问API对配置进行更改的结果。
- en: The source code that handles the configuration change events can examine the
    changes and apply them to the components of the application. These components
    have to detect and react to the changes. The components should use the new values
    so that the intended application behavior can be achieved. This helps to maintain
    availability and minimize downtime.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 处理配置更改事件的源代码可以检查更改并将它们应用到应用程序的组件中。这些组件必须检测并响应更改。组件应使用新值，以便实现预期的应用程序行为。这有助于保持可用性并最小化停机时间。
- en: Scheduler agent supervisor pattern
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度代理监督者模式
- en: Enterprise-class applications are slated to do many tasks in sequence or in
    parallel. Each task is performed by a microservice architecture that can comfortably
    run inside Docker containers. Some tasks may have to connect and collaborate with
    remote application services or third-party services. As stated previously, the
    remote connectivity is beset with a number of challenges because there are other
    components contributing to the remote connectivity and access. Now, complex applications
    are being simplified through process flows comprising control as well as data
    flows. That means an application has to orchestrate all the steps/services in
    order to ensure its capability for consumers. In the distributed computing arena,
    all services have to play their unique role and deliver value to their application.
    If anyone fails to transact, then the retry pattern can be leveraged. If that
    also fails to take off, then the entire operation has to be canceled.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级应用被安排按顺序或并行执行许多任务。每个任务都由一个可以在Docker容器内舒适运行的微服务架构执行。一些任务可能需要连接和协作与远程应用程序服务或第三方服务。如前所述，远程连接面临着许多挑战，因为还有其他组件在贡献远程连接和访问。现在，通过包括控制流和数据流在内的流程流简化了复杂应用。这意味着一个应用必须编排所有步骤/服务以确保其消费者能力。在分布式计算领域，所有服务都必须扮演其独特角色并为应用提供价值。如果有人未能完成交易，则可以利用重试模式。如果这也未能起飞，那么整个操作必须被取消。
- en: The solution is to use the scheduler agent supervisor pattern that skillfully
    orchestrates all the right and relevant steps to finish the expected job. This
    orchestration software solution manages all the participating and contributing
    steps in a resilient and rewarding fashion in distributed work environments. The
    scheduler, which is the principal component of the scheduler agent supervisor,
    arranges for the steps that make up the task to be executed and orchestrates their
    operation. These steps can be combined into a pipeline or workflow. The scheduler
    is responsible for ensuring that the steps in this workflow are performed in the
    right order. The self-recovery of services is being termed as one of the paramount
    properties of new-generation software services.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用调度代理监督者模式，该模式巧妙地编排所有正确且相关的步骤以完成预期的任务。这种编排软件解决方案以弹性和有奖的方式管理分布式工作环境中所有参与和贡献的步骤。调度器，作为调度代理监督者的主要组件，负责安排构成任务的步骤执行，并编排它们的操作。这些步骤可以组合成一个管道或工作流程。调度器负责确保此工作流程中的步骤按正确顺序执行。服务的自我恢复被称作新一代软件服务的首要属性之一。
- en: Sharding pattern
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片模式
- en: In the big data world, data stores need to store a humongous amount of data.
    Due to the extraordinary growth of data collection, storage, processing, and analysis,
    there arise several operational and management challenges including storage space.
    Furthermore, interactive querying and data retrieval are also difficult.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据世界中，数据存储需要存储大量的数据。由于数据收集、存储、处理和分析的非凡增长，出现了包括存储空间在内的几个操作和管理挑战。此外，交互式查询和数据检索也困难重重。
- en: Data is becoming big data that in turn promises big insights. Batch and real-time
    processing of big data are also mandated by business houses. The new normal is
    poly-structured data. Thus, massive amounts of multi-structured data structurally
    and operationally challenge the traditional SQL database management systems. That
    is, in the new world order, NoSQL and NewSQL databases are very popular. The prime
    reason for this new trend is the faster maturity and stability of sharding, which
    is unambiguously partitioning big databases into smaller and manageable databases.
    These segregated databases are being run in different and distributed commoditized
    server machines. The sharding intrinsically supports horizontal scalability (scale
    out), whereas the SQL databases support the scale up (vertical scalability). The
    runtime incorporation of schema changes is also being supported by NoSQL databases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 数据正在变成大数据，这反过来又承诺带来深刻的见解。批处理和实时处理大数据也被企业所要求。新的常态是多结构化数据。因此，大量多结构化数据在结构和操作上对传统的SQL数据库管理系统构成了挑战。也就是说，在新世界秩序中，NoSQL和NewSQL数据库非常流行。这一新趋势的主要原因是对分片（将大型数据库明确划分为更小且可管理的数据库）的成熟度和稳定性的更快提升。这些隔离的数据库正在不同的分布式通用服务器机器上运行。分片本质上支持水平可扩展性（向外扩展），而SQL数据库支持向上扩展（垂直可扩展性）。NoSQL数据库还支持运行时模式更改的集成。
- en: 'This pattern has the following benefits:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式具有以下优点：
- en: The database system can scale out by adding further shards running on additional
    storage nodes
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库系统可以通过添加运行在额外存储节点上的更多分片来向外扩展。
- en: A system can use off-the-shelf hardware rather than specialized and expensive
    computers for each storage node
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以使用现成的硬件，而不是为每个存储节点使用专用和昂贵的计算机。
- en: You can reduce contention and improve performance by balancing the workload
    across shards
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在分片之间平衡工作负载，您可以减少竞争并提高性能。
- en: In the cloud, shards can be located physically close to the users that'll access
    the data
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中，数据分片可以物理上靠近将访问数据的用户。
- en: Throttling pattern
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节流模式
- en: The load on a cloud application typically varies over time based on the number
    of active users or the types of activities they are performing. There can be more
    users during business hours. During festivities, more users will come to electronic
    commerce and e-business applications. There might also be sudden and unanticipated
    bursts in activity. If the processing requirements of the system exceed the capacity
    of the resources that are available, it will suffer from poor performance and
    can even fail. If the system has to meet an agreed level of service, such kinds
    of failures could be unacceptable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用程序的负载通常根据活跃用户数量或他们执行的活动类型随时间变化。在办公时间内可能会有更多用户。在节日期间，更多用户会访问电子商务和电子商务应用。也可能会有突然和不可预见的活动高峰。如果系统的处理需求超过了可用资源的容量，它将遭受性能下降，甚至可能失败。如果系统必须满足约定的服务水平，这类故障可能是不被接受的。
- en: There are several strategies and workarounds for tackling this important challenge.
    A viable solution is to use resources only up to a limit and then throttle them
    when the assigned limit is reached. An alternative strategy to auto-scaling is
    to allow applications to use resources only up to a limit, and then throttle them
    when this limit is reached.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种策略和解决方案可以应对这一重要挑战。一个可行的解决方案是仅使用到一定限度的资源，然后在达到分配的极限时进行节流。另一种替代自动扩展的策略是允许应用程序仅使用到一定限度的资源，然后在达到这个极限时进行节流。
- en: The system should monitor how it's using resources so that, when usage exceeds
    the threshold, it can throttle requests from one or more users. This will enable
    the system to continue functioning and meet any **service level agreements** (**SLAs**)
    that are in place.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该监控其资源使用情况，以便在超过阈值时，可以限制一个或多个用户的请求。这将使系统能够继续运行并满足任何现有的**服务水平协议**（**SLAs**）。
- en: Workload distribution pattern
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载分配模式
- en: IT resources and business workloads are sometimes subjected to heavy usage.
    When the number of users goes up sharply, the problems, such as performance degradation,
    reduced availability, reliability, and so on, can arise and choke the system.
    There are a few interesting solutions being recommended for overcoming these issues.
    Horizontal scalability and the leverage of load balancers in front of web, application,
    and database servers are being widely and wisely implemented in order to fulfill
    the agreed SLAs between the providers and the users. Workload instances need to
    be distributed to tackle heavy user loads.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: IT资源和业务工作负载有时会面临高负载。当用户数量急剧增加时，可能会出现性能下降、可用性降低、可靠性等问题，这些问题可能会阻塞系统。目前有一些有趣的解决方案被推荐用于克服这些问题。水平扩展和利用负载均衡器在Web、应用和数据库服务器前进行广泛和明智的实施，以满足提供商和用户之间达成的SLA。需要将工作负载实例分布以应对高用户负载。
- en: Cloud workload scheduler pattern
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云工作负载调度器模式
- en: The cloud workload scheduler automates, monitors, and controls the workload
    throughout the cloud infrastructure. This automation usually manages hundreds
    of thousands of workloads per day from a single point of control. The cloud scheduler
    could also be an orchestration engine automatically scheduling workloads. The
    scheduler must be provided, the security level required by the workload.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 云工作负载调度器自动化、监控和控制整个云基础设施中的工作负载。这种自动化通常每天从单一控制点管理数十万个工作负载。云调度器也可以是一个自动调度工作负载的编排引擎。调度器必须提供，以及工作负载所需的安全级别。
- en: There are fresh design patterns for accelerating cloud application design. While
    the cloud idea is progressing fast and is seeing a surging popularity, there can
    be additional design patterns. We will come across exclusive and elegant patterns
    for cloud brokerage services and orchestration capabilities. There will be focuses
    on unearthing competent solutions and patterns for deeper and decisive automation
    of cloud activities. **Self-service** is another buzzword being given extreme
    importance so that clouds become business-friendly and business-aware. Serverless
    computing is another pragmatic and popular topic of deeper study and research
    in the cloud arena. Docker-enabled containerization is the mainstream topic of
    deliberations and discourses, and in the near future, we will hear more about
    containerized cloud infrastructures, platforms, and application workloads. Highly
    beneficial design patterns will emerge and empower next-generation cloud applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有新的设计模式用于加速云应用程序设计。虽然云理念发展迅速且越来越受欢迎，但可能会有更多的设计模式。我们将遇到专为云经纪服务和编排能力设计的独特而优雅的模式。将重点关注挖掘更深入和决定性的云活动自动化解决方案和模式。**自助服务**也是一个被赋予极高重要性的热门词汇，以便云变得对商业友好且具有商业意识。无服务器计算是云领域深入研究和研究的另一个实用且热门的话题。容器化的Docker是讨论和讨论的主流话题，不久的将来，我们将听到更多关于容器化云基础设施、平台和应用工作负载的消息。高度有益的设计模式将出现并赋予下一代云应用程序能力。
- en: Cloud reliability and resilience patterns
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云可靠性及弹性模式
- en: The reliability or dependability of cloud applications has to be ensured through
    technologically sound solutions. Cloud infrastructures too have to be accordingly
    empowered to be reliable. The second aspect is cloud resilience. As business workloads
    and IT platforms are being increasingly modernized and moved to cloud environments,
    the need for cloud resilience has gone up drastically. Viable mechanisms are being
    worked by cloud professionals in order to boost the confidence of people on the
    cloud paradigm. Having competent patterns for those recurring requirements and
    common problems is one sure way for tackling the QoS and QoE factors. This section
    is dedicated to illustrating prominent cloud reliability and resilience patterns.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 必须通过技术可靠的解决方案来确保云应用程序的可靠性和可靠性。云基础设施也必须相应地获得能力以确保可靠性。第二个方面是云弹性。随着业务工作负载和IT平台越来越多地现代化并迁移到云环境中，对云弹性的需求急剧增加。云专业人员正在努力工作，以增强人们对云范式的信心。对于这些重复需求和常见问题，拥有有能力的模式是解决QoS和QoE因素的一种可靠方式。本节致力于说明突出的云可靠性和弹性模式。
- en: Resource pooling pattern
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源池化模式
- en: For scalability purposes, IT resources have to be pooled in order to provide
    additional resources on a need basis. The auto-scaling capability can be realized
    when the appropriate resources are pooled. The challenge here is that of manually
    establishing and maintaining the level of required synchronicity across a collection
    of shared resources. Any kind of variance or disparity among shared IT resources
    potentially can lead to inconsistency and sometimes result in risky operations.
    The solution is to get identical IT resources and pool them to be leveraged when
    necessary. The key resources include **bare metal** (**BM**) servers, **virtual
    machines** (**VMs**), and containers. Furthermore, the fine-grained resources
    include memory, storage, processing cores, I/O, and so on. There are several monitoring,
    measurement, and management tools in place for resource provisioning, replication,
    and utilization.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可扩展性，IT资源必须按需集中管理，以便在需要时提供额外的资源。当适当的资源被集中时，可以实现自动扩展能力。这里的挑战是手动在共享资源集合中建立和维护所需同步性的水平。共享IT资源之间的任何差异或差异都可能导致不一致性，有时甚至导致风险操作。解决方案是获取相同的IT资源并将它们集中起来，以便在必要时使用。关键资源包括**裸机**（**BM**）服务器、**虚拟机**（**VMs**）和容器。此外，细粒度资源包括内存、存储、处理核心、I/O等等。已经部署了多种监控、测量和管理工具，用于资源分配、复制和利用。
- en: Resource reservation pattern
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源预留模式
- en: Capacity planning is an important factor in realizing highly optimized IT infrastructures
    and resources for meeting the various tricky demands of applications. If not properly
    done, then there is a possibility of getting into the issue of resource constraints.
    When more cloud consumers try to access a shared IT resource, which does not have
    the capacity to fulfill the consumers' processing needs, then this condition of
    resource constraint creeps in. The result may be performance degradation or even
    the request may not be fulfilled at all. Depending on how IT resources are designed
    for shared usage and depending on their available levels of capacity, concurrent
    access can lead to a runtime exception condition called **resource constraint**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 容量规划是实现高度优化的IT基础设施和资源以满足应用各种复杂需求的重要因素。如果没有得到妥善处理，那么可能会遇到资源限制的问题。当更多的云用户尝试访问一个没有能力满足用户处理需求的共享IT资源时，这种资源限制的情况就会发生。结果可能是性能下降，甚至可能完全无法满足请求。这取决于IT资源如何设计用于共享使用，以及它们可用的容量水平，并发访问可能导致称为**资源限制**的运行时异常条件。
- en: A resource constraint is a condition that occurs when two or more cloud consumers
    have been allocated to share an IT resource that does not have the capacity to
    accommodate the entire processing requirements of the cloud consumers. As a result,
    one or more of the consumers will encounter a sort of degraded performance or
    be rejected altogether.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 资源限制是在两个或多个云用户被分配到共享一个没有能力容纳云用户全部处理需求的IT资源时发生的情况。结果，一个或多个用户可能会遇到某种性能下降，或者完全被拒绝。
- en: The solution is primarily dynamic capacity planning and to have an IT resource
    reservation system in order to protect cloud service consumers. This reservation
    system guarantees a minimum amount of IT resources for each cloud consumer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案主要是动态容量规划和建立一个IT资源预留系统，以保护云服务消费者。这个预留系统为每个云消费者保证了一定数量的IT资源。
- en: Hypervisor clustering pattern
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机管理程序集群模式
- en: Any kind of IT infrastructures and resources can go down at any point in time.
    It is good practice to expect failure of IT systems in order to design IT systems
    in a better-informed fashion. Now hypervisors, alternatively touted as **virtual
    machine monitors** (**VMMs**), represent an additional abstraction in order to
    emulate underlying hardware. The issue is that hypervisors too are liable failure.
    When hypervisors fail, then all the virtual machines on them are bound to fail.
    Thus, it becomes critical for the high-availability of hypervisors.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 任何IT基础设施和资源在任何时候都可能发生故障。预期IT系统会失败是一种良好的做法，以便更好地设计IT系统。现在，虚拟机管理程序，也被称为**虚拟机监控程序**（**VMMs**），为了模拟底层硬件而提供了一个额外的抽象层。问题是虚拟机管理程序也可能发生故障。当虚拟机管理程序失败时，它们上面的所有虚拟机也必然失败。因此，确保虚拟机管理程序的高可用性变得至关重要。
- en: A high-availability hypervisor cluster is created to establish a group of hypervisors
    that span physical servers. As a result, if a given physical server or hypervisor
    becomes unavailable, hosted virtual servers can be moved to another physical server
    or hypervisor.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个高可用性虚拟机管理程序集群，以建立一个跨越物理服务器的虚拟机管理程序组。结果，如果某个物理服务器或虚拟机管理程序变得不可用，托管虚拟服务器可以被移动到另一个物理服务器或虚拟机管理程序。
- en: Redundant storage pattern
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冗余存储模式
- en: Cloud storage is gaining a lot of attention these days because of the enhanced
    flexibility and extreme affordability. There are block storage, object storage,
    file storage, and so on. Storage devices are also subject to failure and disruption
    due to a variety of causes including network connectivity issues, storage controller
    failures, general hardware failure, and security breaches. When a cloud storage
    system gets compromised, the result will be unprecedented. A secondary cloud storage
    device is incorporated into a system that synchronizes its data with the data
    in the primary cloud storage device. When the primary device fails, a storage
    service gateway diverts requests to the secondary device automatically to fulfill
    the **business continuity** (**BC**) requirements.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于增强了灵活性和极端的性价比，云存储最近受到了很多关注。有块存储、对象存储、文件存储等等。存储设备也可能会因各种原因而出现故障和中断，包括网络连接问题、存储控制器故障、通用硬件故障和安全漏洞。当云存储系统受到损害时，结果将是前所未有的。一个辅助云存储设备被纳入一个系统，该系统与其主云存储设备中的数据进行同步。当主设备失败时，存储服务网关会自动将请求重定向到辅助设备，以满足**业务连续性**（**BC**）的要求。
- en: This pattern fundamentally relies on the resource replication mechanism to keep
    the primary cloud storage device synchronized with secondary cloud storage devices.
    Cloud service providers may put secondary storage appliances in a geographically
    different location for ensuring data and disaster recovery.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式基本依赖于资源复制机制，以保持主云存储设备与辅助云存储设备同步。云服务提供商可能会将辅助存储设备放置在地理位置不同的位置，以确保数据备份和灾难恢复。
- en: Dynamic failure detection and recovery pattern
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态故障检测和恢复模式
- en: Cloud environments comprise a large number of IT infrastructures in a consolidated
    and centralized fashion in order to fulfill the variable IT needs of worldwide
    consumers. Cloud environments ensure self-service capability. The major portions
    of the IT infrastructures are virtualized, shared, and commoditized servers, storage
    appliances, and networking solutions. The failure rate is quite high and hence
    failure detection proactively is turning out to be a key requirement for successfully
    running cloud environments.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境以集中和统一的方式包含大量IT基础设施，以满足全球消费者多变的IT需求。云环境确保了自助服务能力。IT基础设施的主要部分包括虚拟化、共享和商品化的服务器、存储设备和网络解决方案。故障率相当高，因此主动检测故障正成为成功运行云环境的关键要求。
- en: A resilient watchdog system has to be established to monitor, measure, and respond
    to a wider range of predefined failure scenarios. This system is further able
    to notify and escalate certain failure conditions that it cannot automatically
    solve itself.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 必须建立一个有弹性的看门狗系统来监控、测量和响应更广泛的预定义故障场景。该系统还能够通知并升级某些它无法自动解决的故障条件。
- en: Redundant physical connection for virtual servers pattern
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟服务器的冗余物理连接模式
- en: A virtual server is connected to an external network through a virtual switch
    uplink port. If the uplink fails (due to cable disconnection, port failure, or
    any other accidents and incidents), the virtual server becomes isolated and disconnects
    from the external network. One or more redundant uplink connections are established
    and positioned in standby mode. A redundant uplink connection is available to
    take over as the active uplink connection whenever the primary uplink connection
    becomes unavailable or experiences failure conditions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟服务器通过虚拟交换机上行链路端口连接到外部网络。如果上行链路失败（由于电缆断开、端口故障或任何其他事故和事件），虚拟服务器就会变得孤立，并从外部网络断开连接。建立并置于待机模式的一个或多个冗余上行链路连接。当主上行链路连接不可用或出现故障条件时，冗余上行链路连接可以接管作为活动上行链路连接。
- en: Cloud environments promise to have some unique capabilities, such as infrastructure
    elasticity and application scalability. These enhance cloud availability. There
    are techniques and patterns being experimented in order to guarantee cloud reliability/dependability.
    Furthermore, resiliency is being given the sufficient thrust by cloud professors
    so that the goals of reliability and resiliency out of cloud assets can be met
    quite easily and quickly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境承诺具有一些独特的功能，例如基础设施弹性和应用程序可伸缩性。这些增强了云的可用性。正在尝试技术和模式以确保云的可靠性/可信赖性。此外，云教授们正在给予足够的推动力，以便能够轻松且快速地实现云资产可靠性和弹性的目标。
- en: Cloud security patterns
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云安全模式
- en: As widely accepted and articulated, the issue of cloud security has been the
    principal barrier for individuals, institutions, and innovators towards readily
    and confidently leveraging the cloud environments; especially the public clouds
    for hosting and delivering their enterprise-grade, business-critical, and high-performance
    applications and databases (customer, corporate, and confidential). In this section,
    we will discuss some of the prominent cloud security patterns in order to empower
    cloud security architects, consultants, and evangelists with all the right details.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如广泛接受和阐述的那样，云安全问题是个人、机构和创新者利用云环境的主要障碍，尤其是对于托管和交付他们企业级、业务关键和高性能应用程序和数据库（客户、公司和机密）的公共云。在本节中，我们将讨论一些突出的云安全模式，以便为云安全架构师、顾问和传教士提供所有正确的细节。
- en: Cryptographic key management system pattern
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学密钥管理系统模式
- en: Cryptography is the unique approach to ensuring data security. Encryption and
    decryption are the two major components of this mathematical theory. Keys are
    generated and stored securely and are used fluently for securing data while in
    transit, rest, and being used by software applications. The worry here is how
    to safely and securely keep the keys generated. If the keys are somehow lost,
    then the encrypted data cannot be decrypted. Therefore, the industry recommends
    having a **cryptographic key management system** (**CKMS**), which consists of
    policies, procedures, components, and devices that are used to protect, manage,
    and distribute cryptographic keys and certain specific information, called **metadata**.
    A CKMS includes all devices or subsystems that can access an unencrypted key or
    its metadata. Encrypted keys and their cryptographically protected metadata can
    be handled by computers and transmitted through communication systems and stored
    in media that are not considered to be part of a CKMS.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是确保数据安全的独特方法。加密和解密是这个数学理论的两个主要组成部分。密钥被安全生成和存储，并且在使用过程中流畅地用于保护数据，无论是传输中、静止还是被软件应用程序使用。这里的担忧是如何安全地存储生成的密钥。如果密钥丢失，那么加密的数据将无法解密。因此，行业推荐使用**密码学密钥管理系统**（**CKMS**），它包括用于保护、管理和分发密码学密钥以及某些特定信息（称为**元数据**）的政策、程序、组件和设备。CKMS包括所有可以访问未加密密钥或其元数据的设备或子系统。加密密钥及其密码学保护的元数据可以由计算机处理，并通过通信系统传输，存储在不被视为CKMS一部分的媒体中。
- en: Virtual private network (VPN) pattern
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟专用网络（VPN）模式
- en: 'In the connected world, the internet is the cheap, open, flexible and public
    communication infrastructure. The **virtual private network** (**VPN**) is a network
    that uses a public telecommunication infrastructure, such as the internet, to
    provide consumers with secure connections to their organization''s network. The
    VPN ensures privacy through security procedures and tunneling protocols, including
    the **layer two tunneling protocol** (**L2TP**). Data is encrypted at the sending
    end for transmission and decrypted at the receiving end, as shown in the following
    figure:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联的世界中，互联网是廉价、开放、灵活和公共通信基础设施。**虚拟专用网络**（**VPN**）是一个使用公共电信基础设施（如互联网）来为消费者提供对其组织网络的加密连接的网络。VPN通过安全程序和隧道协议（包括**二层隧道协议**（**L2TP**））确保隐私。数据在发送端加密以进行传输，并在接收端解密，如下面的图所示：
- en: '![](img/b9bd0d01-9d19-490d-b51a-6003e6ca249e.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9bd0d01-9d19-490d-b51a-6003e6ca249e.png)'
- en: The figure shows two firewalls establishing a VPN between two clouds. They first
    exchange each other's certificates and use asymmetric encryption to securely exchange
    keying material to establish efficient symmetric key encryption. IPsec is a framework
    of open standards for private communications over public networks. It is a network
    layer security control that is used to create the VPN.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图中显示了两个防火墙在两个云之间建立VPN。它们首先交换彼此的证书，并使用非对称加密来安全地交换密钥材料，以建立有效的对称密钥加密。IPsec是在公共网络上进行私有通信的开放标准框架。它是一种网络层安全控制，用于创建VPN。
- en: Cloud authentication gateway pattern
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云认证网关模式
- en: Cloud consumers are compelled to support multiple authentications, communication,
    and session protocols in order to access and use various cloud services. An authentication
    service authenticates cloud consumers to access cloud services. The authentication
    service uses the diverse protocols required by cloud service providers for authenticating
    cloud consumers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 云消费者被迫支持多种身份验证、通信和会话协议，以便访问和使用各种云服务。身份验证服务用于验证云消费者访问云服务。身份验证服务使用云服务提供商为验证云消费者所需的多种协议。
- en: An **authentication gateway service** (**AGS**) can be established as a reverse
    proxy frontend between the cloud consumer and the cloud resource. This AGS intercepts
    and terminates the consumer's encrypted network connection and authenticates the
    cloud consumer. Furthermore, it authenticates itself and the consumer to the cloud
    provider and then proxies all communication between the two.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在云消费者和云资源之间建立一个**身份验证网关服务**（**AGS**），作为反向代理前端。此AGS拦截并终止消费者的加密网络连接，并验证云消费者。此外，它还验证自身和消费者到云提供商，然后代理两者之间的所有通信。
- en: In-transit cloud data encryption pattern
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在传输中的云数据加密模式
- en: Data security is an important component for the continued growth of the cloud
    concept. With data analytics gaining widespread significance, the need for secure
    data capture, transmission, exchange, persistence, and usage has grown greatly.
    Data transmission networks, data management systems, data analytics platforms,
    data storage appliances, filesystems, and so on, are the prominent ingredients
    for the next-generation knowledge era. Encryption is the primary mechanism for
    securing data interchanged between data sources and servers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 数据安全是云概念持续增长的重要组件。随着数据分析获得广泛的重视，对安全数据捕获、传输、交换、持久化和使用的需求大大增加。数据传输网络、数据管理系统、数据分析平台、数据存储设备、文件系统等，是下一代知识时代的重要成分。加密是保护数据源和服务器之间交换数据的主要机制。
- en: Cloud storage device masking pattern
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云存储设备屏蔽模式
- en: As illustrated previously, data security is essential for boosting the confidence
    of cloud consumers on cloud-based enterprise applications and databases. Authorized
    data access is the foremost thing for ensuring utmost data security. Data stored
    in a shared cloud environment can be vulnerable to many security risks, threats,
    vulnerabilities, and holes. An LUN masking mechanism can enforce defined policies
    at the physical storage array in order to prevent unauthorized cloud consumers
    from accessing a specific cloud storage device in a shared cloud environment.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据安全对于增强云消费者对基于云的企业应用程序和数据库的信心至关重要。授权数据访问是确保最高数据安全的首要任务。存储在共享云环境中的数据可能容易受到许多安全风险、威胁、漏洞和漏洞的影响。LUN屏蔽机制可以在物理存储阵列中强制执行定义的政策，以防止未经授权的云消费者在共享云环境中访问特定的云存储设备。
- en: Cloud storage data at rest encryption pattern
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态云存储数据加密模式
- en: Data stored in a cloud environment requires security against access to the physical
    hard disks forming the cloud storage device. The solution is to leverage any encryption
    mechanism supported by the physical storage arrays to automatically encrypt data
    stored on the disks and decrypt data leaving the disks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在云环境中的数据需要防止访问构成云存储设备的物理硬盘。解决方案是利用物理存储阵列支持的任何加密机制，自动加密存储在硬盘上的数据，并解密离开硬盘的数据。
- en: Endpoint threat detection and response pattern
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点威胁检测和响应模式
- en: Endpoint security refers to the protection of an organization's network when
    accessed through remote devices, such as smartphones, tablets, and laptops. **Endpoint
    threat detection and response** (**ETDR**) focuses on the endpoint as opposed
    to the network. It is recommended to leverage integrated security tools in order
    to understand the security holes of edge devices in order to strengthen the cloud
    networks and servers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 端点安全是指通过远程设备（如智能手机、平板电脑和笔记本电脑）访问组织网络时的保护。**端点威胁检测和响应**（**ETDR**）侧重于端点而不是网络。建议利用集成安全工具来了解边缘设备的安全漏洞，以加强云网络和服务器。
- en: Threat intelligence processing pattern
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁情报处理模式
- en: The act of analytics is becoming pervasive these days. Operational, behavioral,
    security, log, and performance data of IT environments are consciously collected
    and subjected to a variety of investigations. Deeper and decisive analytics on
    security-related data emits a lot of useful information for security analysts,
    architects, and advisors. The extracted insights come in handy in proactively
    putting appropriate security mechanisms in place in order to ward off any kind
    of security attacks and exploitations.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 分析行为日益普遍。IT环境的操作、行为、安全、日志和性能数据被有意识地收集并接受各种调查。对安全相关数据的深入和决定性分析为安全分析师、架构师和顾问提供了大量有用的信息。提取的见解有助于主动建立适当的网络安全机制，以防范任何类型的网络安全攻击和利用。
- en: A threat intelligence system can be put in place to receive and process external
    intelligence feeds as well as to gain intelligence gained from analyzing attacks
    internally. The details received and collected can be fed into security-enablement
    systems, such as security information and **event management systems** (**SIEMs**),
    **network forensics monitors** (**NFM**), **endpoint threat detection and response
    systems** (**ETDRs**), **intrusion detection and protections systems** (**IDPSs**),
    and so on. Also, those sensitive details can be shared across cloud security operational
    teams to enable them to ponder and proceed with the best course of action.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可以建立一个威胁情报系统来接收和处理外部情报源，以及从分析内部攻击中获得情报。接收和收集的详细信息可以输入到安全增强系统中，例如安全信息和**事件管理系统**（**SIEMs**）、**网络取证监控器**（**NFM**）、**端点威胁检测和响应系统**（**ETDRs**）、**入侵检测和保护系统**（**IDPSs**）等。此外，这些敏感的详细信息可以在云安全运营团队之间共享，以便他们能够考虑并采取最佳行动。
- en: Cloud denial of service (DoS) protection pattern
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云拒绝服务（DoS）保护模式
- en: Cloud DoS attacks are multifaceted and prevent consumers of cloud services from
    accessing their cloud resources. A cloud DoS protection service has to be incorporated
    into the security architecture to shield the cloud provider from DoS attacks.
    A network DoS protection service updates the **domain name service** (**DNS**)
    to route all cloud provider traffic through the protection service, which filters
    attack traffic and routes only legitimate traffic to the cloud provider. Alternately,
    the cloud provider can route traffic to a DoS protection service when experiencing
    an attack, or create its own DoS protection service. Considering the insistence
    for unbreakable and impenetrable cloud security solutions, fresh cloud security
    patterns are being unearthed by security experts and researchers. In the future,
    there will be a few more security-related patterns.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 云拒绝服务（DoS）攻击是多方面的，阻止了云服务的消费者访问他们的云资源。必须将云DoS保护服务纳入安全架构中，以保护云服务提供商免受DoS攻击。网络DoS保护服务更新**域名服务**（**DNS**），将所有云服务提供商的流量路由通过保护服务，该服务过滤攻击流量，并将合法流量仅路由到云服务提供商。或者，当云服务提供商遭受攻击时，可以将其流量路由到DoS保护服务，或者创建自己的DoS保护服务。考虑到对坚不可摧和无法渗透的云安全解决方案的坚持，安全专家和研究人员正在挖掘新的云安全模式。未来，将出现更多与安全相关的模式。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Patterns have been the principal enabling tools for strategic and simplified
    design and engineering of all kinds of business and social systems. The IT domain
    too has embraced the proven and potential concept of patterns in order to overcome
    the inherent limitations of IT systems and services engineering. This chapter
    is specially prepared for describing the various architectural and design patterns
    being unearthed and articulated by various cloud computing professionals. The
    readers can find the right amount of detail for each of the patterns. With the
    cloud paradigm on the fast track, there is a need for detailing various and recently
    articulated cloud patterns and their correct details. This chapter comes in handy
    for interested IT people in understanding cloud-related patterns.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 模式一直是战略和简化设计以及各种商业和社会系统工程的根本工具。IT领域也采纳了模式这一经过验证和具有潜力的概念，以便克服IT系统和服务的工程固有限制。本章专门编写，用于描述各种云计算专业人士正在挖掘和阐述的各类架构和设计模式。读者可以找到每个模式所需的确切细节。随着云范式的高速发展，有必要详细阐述各种最近提出的云模式及其正确细节。本章对有兴趣了解云相关模式的IT人士来说非常有用。
- en: Bibliography
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: The cloud patterns registry: [http://cloudpatterns.org/](http://cloudpatterns.org/)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 云模式注册表：[http://cloudpatterns.org/](http://cloudpatterns.org/)
- en: Cloud design patterns by Microsoft: [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的云设计模式：[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)
- en: Cloud computing patterns: [http://www.cloudcomputingpatterns.org/](http://www.cloudcomputingpatterns.org/)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算模式：[http://www.cloudcomputingpatterns.org/](http://www.cloudcomputingpatterns.org/)
- en: Cloud design patterns by Amazon Web Services: [http://en.clouddesignpattern.org/index.php/Main_Page](http://en.clouddesignpattern.org/index.php/Main_Page)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务的云设计模式：[http://en.clouddesignpattern.org/index.php/Main_Page](http://en.clouddesignpattern.org/index.php/Main_Page)
- en: Cloud architecture patterns: [http://shop.oreilly.com/product/0636920023777.do](http://shop.oreilly.com/product/0636920023777.do)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 云架构模式：[http://shop.oreilly.com/product/0636920023777.do](http://shop.oreilly.com/product/0636920023777.do)
