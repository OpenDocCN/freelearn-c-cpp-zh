<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Classical Polymorphism and Generic Programming</h1>
                
            
            <article>
                
<p class="calibre2">The C++ standard library has two distinct, yet equally important, missions. One of these missions is to provide rock-solid implementations of certain concrete data types or functions that have tended to be useful in many different programs, yet aren't built into the core language syntax. This is why the standard library contains <kbd class="calibre12">std::string</kbd>, <kbd class="calibre12">std::regex</kbd>, <kbd class="calibre12">std::filesystem::exists</kbd>, and so on. The other mission of the standard library is to provide rock-solid implementations of widely used <em class="calibre22">abstract algorithms</em> such as sorting, searching, reversing, collating, and so on. In this first chapter, we will nail down exactly what we mean when we say that a particular piece of code is "abstract," and describe the two approaches that the standard library uses to provide abstraction: <em class="calibre22">classical polymorphism</em> and <em class="calibre22">generic programming</em>.</p>
<p class="calibre2">We will look at the following topics in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">Concrete (monomorphic) functions, whose behavior is not parameterizable</li>
<li class="calibre15">Classical polymorphism by means of base classes, virtual member functions, and inheritance</li>
<li class="calibre15">Generic programming by means of concepts, requirements, and models</li>
<li class="calibre15">The practical advantages and disadvantages of each approach</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Concrete monomorphic functions</h1>
                
            
            <article>
                
<p class="calibre2">What distinguishes an abstract algorithm from a concrete function? This is best shown by example. Let's write a function to multiply each of the elements in an array by 2:</p>
<pre class="calibre23">    class array_of_ints {<br class="title-page-name"/>      int data[10] = {};<br class="title-page-name"/>      public:<br class="title-page-name"/>        int size() const { return 10; }<br class="title-page-name"/>        int&amp; at(int i) { return data[i]; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void double_each_element(array_of_ints&amp; arr)<br class="title-page-name"/>    {<br class="title-page-name"/>      for (int i=0; i &lt; arr.size(); ++i) {<br class="title-page-name"/>        arr.at(i) *= 2;<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Our function <kbd class="calibre12">double_each_element</kbd> works <em class="calibre22">only</em> with objects of type <kbd class="calibre12">array_of_int</kbd>; passing in an object of a different type won't work (nor even compile). We refer to functions like this version of <kbd class="calibre12">double_each_element</kbd> as <em class="calibre22">concrete</em> or <em class="calibre22">monomorphic</em> functions. We call them <em class="calibre22">concrete</em> because they are insufficiently <em class="calibre22">abstract</em> for our purposes. Just imagine how painful it would be if the C++ standard library provided a concrete <kbd class="calibre12">sort</kbd> routine that worked only on one specific data type!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Classically polymorphic functions</h1>
                
            
            <article>
                
<p class="calibre2">We can increase the abstraction level of our algorithms via the techniques of classical <strong class="calibre1">object-oriented</strong> (<strong class="calibre1">OO</strong>) programming, as seen in languages such as Java and C#. The OO approach is to decide exactly which behaviors we'd like to be customizable, and then declare them as the public virtual member functions of an <em class="calibre22">abstract base class</em>:</p>
<pre class="calibre23">    class container_of_ints {<br class="title-page-name"/>      public:<br class="title-page-name"/>      virtual int size() const = 0;<br class="title-page-name"/>      virtual int&amp; at(int) = 0;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class array_of_ints : public container_of_ints {<br class="title-page-name"/>      int data[10] = {};<br class="title-page-name"/>      public:<br class="title-page-name"/>        int size() const override { return 10; }<br class="title-page-name"/>        int&amp; at(int i) override { return data[i]; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class list_of_ints : public container_of_ints {<br class="title-page-name"/>      struct node {<br class="title-page-name"/>        int data;<br class="title-page-name"/>        node *next;<br class="title-page-name"/>      };<br class="title-page-name"/>      node *head_ = nullptr;<br class="title-page-name"/>      int size_ = 0;<br class="title-page-name"/>      public:<br class="title-page-name"/>       int size() const override { return size_; }<br class="title-page-name"/>       int&amp; at(int i) override {<br class="title-page-name"/>        if (i &gt;= size_) throw std::out_of_range("at");<br class="title-page-name"/>        node *p = head_;<br class="title-page-name"/>        for (int j=0; j &lt; i; ++j) {<br class="title-page-name"/>          p = p-&gt;next;<br class="title-page-name"/>        }<br class="title-page-name"/>        return p-&gt;data;<br class="title-page-name"/>      }<br class="title-page-name"/>      ~list_of_ints();<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void double_each_element(container_of_ints&amp; arr) <br class="title-page-name"/>    {<br class="title-page-name"/>      for (int i=0; i &lt; arr.size(); ++i) {<br class="title-page-name"/>        arr.at(i) *= 2;<br class="title-page-name"/>      } <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      array_of_ints arr;<br class="title-page-name"/>      double_each_element(arr);<br class="title-page-name"/><br class="title-page-name"/>      list_of_ints lst;<br class="title-page-name"/>      double_each_element(lst);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Inside <kbd class="calibre12">test</kbd>, the two different calls to <kbd class="calibre12">double_each_element</kbd> compile because in classical OO terminology, an <kbd class="calibre12">array_of_ints</kbd> <strong class="calibre1">IS-A</strong> <kbd class="calibre12">container_of_ints</kbd> (that is, it inherits from <kbd class="calibre12">container_of_ints</kbd> and implements the relevant virtual member functions), and a <kbd class="calibre12">list_of_ints</kbd> <strong class="calibre1">IS-A</strong> <kbd class="calibre12">container_of_ints</kbd> as well. However, the behavior of any given <kbd class="calibre12">container_of_ints</kbd> object is parameterized by its <em class="calibre22">dynamic type</em>; that is, by the table of function pointers associated with this particular object.</p>
<p class="calibre2">Since we can now parameterize the behavior of the <kbd class="calibre12">double_each_element</kbd> function without editing its source code directly--simply by passing in objects of different dynamic types--we say that the function has become <em class="calibre22">polymorphic</em>.</p>
<p class="calibre2">But still, this polymorphic function can handle only those types which are descendants of the base class <kbd class="calibre12">container_of_ints</kbd>. For example, you couldn't pass a <kbd class="calibre12">std::vector&lt;int&gt;</kbd> to this function; you'd get a compile error if you tried. Classical polymorphism is useful, but it does not get us all the way to full genericity.</p>
<p class="calibre2">An advantage of classical (object-oriented) polymorphism is that the source code still bears a one-to-one correspondence with the machine code that is generated by the compiler. At the machine-code level, we still have just one <kbd class="calibre12">double_each_element</kbd> function, with one signature and one well-defined entry point. For example, we can take the address of <kbd class="calibre12">double_each_element</kbd> as a function pointer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generic programming with templates</h1>
                
            
            <article>
                
<p class="calibre2">In modern C++, the typical way to write a fully generic algorithm is to implement the algorithm as a <em class="calibre22">template</em>. We're still going to implement the function template in terms of the public member functions <kbd class="calibre12">.size()</kbd> and <kbd class="calibre12">.at()</kbd>, but we're no longer going to require that the argument <kbd class="calibre12">arr</kbd> be of any particular type. Because our new function will be a template, we'll be telling the compiler "I don't care what type <kbd class="calibre12">arr</kbd> is. Whatever type it is, just generate a brand-new function (that is, a template instantiation) with that type as its parameter type."</p>
<pre class="calibre23">    template&lt;class ContainerModel&gt;<br class="title-page-name"/>    void double_each_element(ContainerModel&amp; arr)<br class="title-page-name"/>    {<br class="title-page-name"/>      for (int i=0; i &lt; arr.size(); ++i) {<br class="title-page-name"/>        arr.at(i) *= 2;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      array_of_ints arr;<br class="title-page-name"/>      double_each_element(arr);<br class="title-page-name"/><br class="title-page-name"/>      list_of_ints lst;<br class="title-page-name"/>      double_each_element(lst);<br class="title-page-name"/><br class="title-page-name"/>      std::vector&lt;int&gt; vec = {1, 2, 3};<br class="title-page-name"/>      double_each_element(vec);<br class="title-page-name"/>    }</pre>
<p class="calibre2">In most cases, it helps us design better programs if we can put down in words exactly what operations must be supported by our template type parameter <kbd class="calibre12">ContainerModel</kbd>. That set of operations, taken together, constitutes what's known in C++ as a <em class="calibre22">concept</em>; in this example we might say that the concept <kbd class="calibre12">Container</kbd> consists of "having a member function named <kbd class="calibre12">size</kbd> that returns the size of the container as an <kbd class="calibre12">int</kbd> (or something comparable to <kbd class="calibre12">int</kbd>); and having a member function named <kbd class="calibre12">at</kbd> that takes an <kbd class="calibre12">int</kbd> index (or something implicitly convertible from <kbd class="calibre12">int</kbd>) and produces a non-const reference to the <em class="calibre22">index</em>'th element of the container." Whenever some class <kbd class="calibre12">array_of_ints</kbd> correctly supplies the operations required by the concept <kbd class="calibre12">Container</kbd>, such that <kbd class="calibre12">array_of_ints</kbd> is usable with <kbd class="calibre12">double_each_element</kbd>, we say that the concrete class <kbd class="calibre12">array_of_ints</kbd> <em class="calibre22">is a model of</em> the <kbd class="calibre12">Container</kbd> concept. This is why I gave the name <kbd class="calibre12">ContainerModel</kbd> to the template type parameter in the preceding example.</p>
<div class="packt_infobox">It would be more traditional to use the name <kbd class="calibre25">Container</kbd> for the template type parameter itself, and I will do that from now on; I just didn't want to start us off on the wrong foot by muddying the distinction between the <kbd class="calibre25">Container</kbd> concept and the particular template type parameter to this particular function template that happens to desire as its argument a concrete class that models the <kbd class="calibre25">Container</kbd> concept.</div>
<p class="calibre2">When we implement an abstract algorithm using templates, so that the behavior of the algorithm can be parameterized at compile time by any types modeling the appropriate concepts, we say we are doing generic programming.</p>
<p class="calibre2">Notice that our description of the <kbd class="calibre12">Container</kbd> concept didn't mention that we expect the type of the contained elements to be <kbd class="calibre12">int</kbd>; and not coincidentally, we find that we can now use our generic <kbd class="calibre12">double_each_element</kbd> function even with containers that don't hold <kbd class="calibre12">int</kbd>!</p>
<pre class="calibre23">    std::vector&lt;double&gt; vecd = {1.0, 2.0, 3.0};<br class="title-page-name"/>    double_each_element(vecd);</pre>
<p class="calibre2">This extra level of genericity is one of the big benefits of using C++ templates for generic programming, as opposed to classical polymorphism. Classical polymorphism hides the varying behavior of different classes behind a stable <em class="calibre22">interface signature</em> (for example, <kbd class="calibre12">.at(i)</kbd> always returns <kbd class="calibre12">int&amp;</kbd>), but once you start messing with varying signatures, classical polymorphism is no longer a good tool for the job.</p>
<p class="calibre2">Another advantage of generic programming is that it offers blazing speed through increased opportunities for inlining. The classically polymorphic example must repeatedly query the <kbd class="calibre12">container_of_int</kbd> object's virtual table to find the address of its particular virtual <kbd class="calibre12">at</kbd> method, and generally cannot see through the virtual dispatch at compile time. The template function <kbd class="calibre12">double_each_element&lt;array_of_int&gt;</kbd> can compile in a direct call to <kbd class="calibre12">array_of_int::at</kbd> or even inline the call completely.</p>
<p class="calibre2">Because generic programming with templates can so easily deal with complicated requirements and is so flexible in dealing with types--even primitive types like <kbd class="calibre12">int</kbd>, where classical polymorphism fails--the standard library uses templates for all its algorithms and the containers on which they operate. For this reason, the algorithms-and-containers part of the standard library is often referred to as the <strong class="calibre1">Standard Template Library</strong> or <strong class="calibre1">STL</strong>.</p>
<div class="packt_infobox">That's right--technically, the STL is only a small part of the C++ standard library! However, in this book, as in real life, we may occasionally slip up and use the term STL when we mean standard library, or vice versa.</div>
<p class="calibre2">Let's look at a couple more hand-written generic algorithms, before we dive into the standard generic algorithms provided by the STL. Here is a function template <kbd class="calibre12">count</kbd>, returning the total number of elements in a container:</p>
<pre class="calibre23">    template&lt;class Container&gt;<br class="title-page-name"/>    int count(const Container&amp; container)<br class="title-page-name"/>    {<br class="title-page-name"/>      int sum = 0;<br class="title-page-name"/>      for (auto&amp;&amp; elt : container) {<br class="title-page-name"/>        sum += 1;<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum;<br class="title-page-name"/>    }</pre>
<p class="calibre2">And here is <kbd class="calibre12">count_if</kbd>, which returns the number of elements satisfying a user-supplied <em class="calibre22">predicate</em> function:</p>
<pre class="calibre23">    template&lt;class Container, class Predicate&gt;<br class="title-page-name"/>    int count_if(const Container&amp; container, Predicate pred) <br class="title-page-name"/>    { <br class="title-page-name"/>      int sum = 0;<br class="title-page-name"/>      for (auto&amp;&amp; elt : container) {<br class="title-page-name"/>        if (pred(elt)) {<br class="title-page-name"/>            sum += 1;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum;<br class="title-page-name"/>    }</pre>
<p class="calibre2">These functions would be used like this:</p>
<pre class="calibre23">    std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9, 2, 6};<br class="title-page-name"/><br class="title-page-name"/>    assert(count(v) == 8);<br class="title-page-name"/><br class="title-page-name"/>    int number_above =<br class="title-page-name"/>      count_if(v, [](int e) { return e &gt; 5; });<br class="title-page-name"/>    int number_below =<br class="title-page-name"/>      count_if(v, [](int e) { return e &lt; 5; });<br class="title-page-name"/><br class="title-page-name"/>    assert(number_above == 2);<br class="title-page-name"/>    assert(number_below == 5);</pre>
<p class="calibre2">There is so much power packed into that little expression <kbd class="calibre12">pred(elt)</kbd>! I encourage you to try re-implementing the <kbd class="calibre12">count_if</kbd> function in terms of classical polymorphism, just to get a sense of where the whole thing breaks down. There are a lot of varying signatures hidden under the syntactic sugar of modern C++. For example, the ranged for-loop syntax in our <kbd class="calibre12">count_if</kbd> function is converted (or lowered") by the compiler into a for-loop in terms of <kbd class="calibre12">container.begin()</kbd> and <kbd class="calibre12">container.end()</kbd>, each of which needs to return an iterator whose type is dependent on the type of <kbd class="calibre12">container</kbd> itself. For another example, in the generic-programming version, we never specify--we never <em class="calibre22">need</em> to specify--whether <kbd class="calibre12">pred</kbd> takes its parameter <kbd class="calibre12">elt</kbd> by value or by reference. Try doing <em class="calibre22">that</em> with a <kbd class="calibre12">virtual bool operator()</kbd>!</p>
<p class="calibre2">Speaking of iterators: you may have noticed that all of our example functions in this chapter (no matter whether they were monomorphic, polymorphic, or generic) have been expressed in terms of containers. When we wrote <kbd class="calibre12">count</kbd>, we counted the elements in the entire container. When we wrote <kbd class="calibre12">count_if</kbd>, we counted the matching elements in the entire container. This turns out to be a very natural way to write, especially in modern C++; so much so that we can expect to see container-based algorithms (or their close cousin, range-based algorithms) arriving in C++20 or C++23. However, the STL dates back to the 1990s and pre-modern C++. So, the STL's authors assumed that dealing primarily in containers would be very expensive (due to all those expensive copy-constructions--remember that move semantics and move-construction did not arrive until C++11); and so they designed the STL to deal primarily in a much lighter-weight concept: the <em class="calibre22">iterator</em>. This will be the subject of our next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2"><span>Both classical polymorphism and generic programming deal with the essential</span> problem of parameterizing the behavior of an algorithm: for example, writing a search function that works with any arbitrary matching operation.</p>
<p class="calibre2">Classical polymorphism tackles that problem by specifying an <em class="calibre22">abstract base class</em> with a closed set of <em class="calibre22">virtual member functions</em>, and writing <em class="calibre22">polymorphic functions</em> that accept pointers or references to instances of concrete classes <em class="calibre22">inheriting from</em> that base class.</p>
<p class="calibre2">Generic programming tackles the same problem by specifying a <em class="calibre22">concept</em> with a closed set of <em class="calibre22">requirements</em>, and instantiating <em class="calibre22">function templates</em> with concrete classes <em class="calibre22">modeling</em> that concept.</p>
<p class="calibre2">Classical polymorphism has trouble with higher-level parameterizations (for example, manipulating function objects of any signature) and with relationships between types (for example, manipulating the elements of an arbitrary container). Therefore, the Standard Template Library uses a great deal of template-based generic programming, and hardly any classical polymorphism.</p>
<p class="calibre2">When you use generic programming, it will help if you keep in mind the conceptual requirements of your types, or even write them down explicitly; but as of C++17, the compiler cannot directly help you check those requirements.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>