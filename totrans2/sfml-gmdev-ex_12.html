<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Can You Hear Me Now? – Sound and Music</h1></div></div></div><p>There's nothing quite like the enjoyment of being immersed in a virtual environment. From the movies we watch to the games we play, appeal to and usage of as many human senses as possible can either make or break the captivation that a form of media can hold. Creating a living and breathing atmosphere can rarely, if ever, be only down to visual effects. Throughout this chapter, we will briefly close our eyes and engage in the auditory side of this project by covering subjects such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basics of sound and music in SFML</li><li class="listitem" style="list-style-type: disc">Placement of sounds and the listener in 3D space</li><li class="listitem" style="list-style-type: disc">Proper management and recycling of sound instances</li><li class="listitem" style="list-style-type: disc">Expansion of the entity component system to allow for sounds</li></ul></div><p>We have a long way to go until our first sonic boom, so let's dive right in!</p><div><div><div><div><h1 class="title"><a id="ch12lvl1sec100"/>Use of copyrighted resources</h1></div></div></div><p>Before <a id="id509" class="indexterm"/>we jump into managing sounds, let's give credit <a id="id510" class="indexterm"/>where it is due. Throughout this chapter, we're going to use the following resources:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Fantozzi's Footsteps (Grass/Sand &amp; Stone)</em> by <em>Fantozzi</em> under the CC0 license (public domain): <a class="ulink" href="http://opengameart.org/content/fantozzis-footsteps-grasssand-stone">http://opengameart.org/content/fantozzis-footsteps-grasssand-stone</a></li><li class="listitem" style="list-style-type: disc"><em>Electrix</em> (NES Version) by <em>Snabisch</em> under the CC-BY 3.0 license: <a class="ulink" href="http://opengameart.org/content/electrix-nes-version">http://opengameart.org/content/electrix-nes-version</a></li><li class="listitem" style="list-style-type: disc"><em>Town Theme RPG</em> by <em>cynicmusic</em> under the CC-BY 3.0 license: <a class="ulink" href="http://opengameart.org/content/town-theme-rpg">http://opengameart.org/content/town-theme-rpg</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec101"/>Preparing the project for sound</h1></div></div></div><p>In order <a id="id511" class="indexterm"/>to successfully compile a project that uses SFML audio, we need to make sure these additional dependency <code class="literal">.lib</code> files are included:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sfml-audio-s.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">openal32.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">flac.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ogg.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">vorbis.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">vorbisenc.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">vorbisfile.lib</code></li></ul></div><p>Additionally, the executable file must always be accompanied by the <code class="literal">openal32.dll</code> file, which comes with SFML and can be found inside the <code class="literal">bin</code> folder of the library.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec102"/>Basics of SFML sound</h1></div></div></div><p>Anything <a id="id512" class="indexterm"/>audio related falls into one of two categories within SFML: <code class="literal">sf::Sound</code> that represents short sound effects, or <code class="literal">sf::Music</code> that is used to play longer audio tracks. It's prudent that we understand how these two classes are used before continuing further. Let's talk about each one individually.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec56"/>Playing sounds</h2></div></div></div><p>The <code class="literal">sf::Sound</code> class is<a id="id513" class="indexterm"/> extremely lightweight and should only ever be used to play short sound effects that don't take up a lot of memory. The way it stores and utilizes actual audio files is by using a <code class="literal">sf::SoundBuffer</code> instance. It is analogous to <code class="literal">sf::Sprite</code> and the way it uses an instance of <code class="literal">sf::Texture</code> for drawing. The <code class="literal">sf::SoundBuffer</code> is used to hold audio data in memory, which the <code class="literal">sf::Sound</code> class then reads and plays from. It can be used as follows:</p><div><pre class="programlisting">sf::SoundBuffer buffer;
buffer.loadFromFile("SomeSound.ogg");

sf::Sound sound(buffer);
sound.setBuffer(buffer); // Alternative.</pre></div><p>As you can see, a sound buffer can be attached to an instance of <code class="literal">sf::Sound</code> by either passing it to the sound's constructor or by using the <code class="literal">setBuffer</code> method of a sound instance.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>As long as the sound is expected to be playing, the <code class="literal">sf::SoundBuffer</code> instance <em>shouldn't</em> be destroyed!</p></div></div><p>After the <a id="id514" class="indexterm"/>sound buffer loads the sound file and is attached to an instance of <code class="literal">sf::Sound</code>, it can be played by invoking the <code class="literal">play()</code> method:</p><div><pre class="programlisting">sound.play(); // Play the sound!</pre></div><p>It can also be paused and stopped by using the appropriately named <code class="literal">pause()</code> and <code class="literal">stop()</code> methods:</p><div><pre class="programlisting">sound.pause(); // Pause the sound.
sound.stop(); // Stop the sound.</pre></div><p>Obtaining the current status of a sound to determine if it's playing, paused, or stopped can be done like this:</p><div><pre class="programlisting">sf::SoundSource::Status status = sound.getStatus();</pre></div><p>The status it returns is a simple enumeration of three values: <code class="literal">stopped</code>, <code class="literal">paused</code>, and <code class="literal">playing</code>.</p><p>Lastly, we can adjust the sound's volume, pitch, whether it loops or not, and how far the sound has progressed by using these methods respectively:</p><div><pre class="programlisting">sound.setVolume(100.f); // Takes in a float.
sound.setPitch(1.f); // Takes in a float.
sound.setLoop(true); // Takes in a Boolean.
sound.setPlayingOffset(sf::seconds(5.f)); // Takes in sf::Time.</pre></div><p>Audio pitch is simply a numeric value that represents frequency of the sound. Values above 1 will result in the sound playing at a higher pitch, while anything below 1 has the opposite effect. If the pitch is changed, it also changes the sound's playing speed.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec57"/>Playing music</h2></div></div></div><p>Any <code class="literal">sf::Music</code> instance<a id="id515" class="indexterm"/> supports all of the methods discussed previously, except <code class="literal">setBuffer</code>. As you already know, <code class="literal">sf::Sound</code> uses instances of <code class="literal">sf::SoundBuffer</code> that it reads from. This means that the entire sound file has to be loaded in memory for it to be played. With larger files, this quickly becomes inefficient, and that's the reason <code class="literal">sf::Music</code> exists. Instead of using buffer objects, it streams the data from the file itself as the music plays, only loading as much data as it needs for the time being. </p><p>Let's take a look at an example:</p><div><pre class="programlisting">sf::Music music;
music.openFromFile("SomeMusic.ogg");
music.play();
...
music.stop();</pre></div><p>Notice the name of the method <code class="literal">openFromFile</code>. In contrast, where sound buffers load files, <code class="literal">sf::Music</code> merely opens it and reads from it.</p><p>A very<a id="id516" class="indexterm"/> important thing to mention here is that <code class="literal">sf::Music</code> is a non-copyable class! This means that any sort of assignment by value will automatically result in an error:</p><div><pre class="programlisting">sf::Music music;
sf::Music music2 = music; // ERROR!</pre></div><p>Passing a music instance to a function or a method by value would also produce the same results.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec103"/>Sound spatialization</h1></div></div></div><p>Both <code class="literal">sf::Sound</code> and <code class="literal">sf::Music</code> also support spatial positioning. It takes advantage of left and <a id="id517" class="indexterm"/>right audio channels and makes it feel like the sound is actually playing around you. There is a catch, though. Every sound or music instance that is desired to be spatial has to only have a single channel. It is more commonly known as a monophonic or mono sound, as opposed to stereo that already decides how the speakers are used.</p><p>The way sounds are perceived in three-dimensional space is manipulated through a single, static class: <code class="literal">sf::Listener</code>. It's static because there can only ever be one listener per application. The main two aspects of this class we're interested in are the position and direction of the listener. Keep in mind that although we may be working on a 2D game, SFML sounds exist in 3D space. Let's take a look at an example:</p><div><pre class="programlisting">sf::Listener::setPosition(5.f, 0.f, 5.f);
sf::Listener::setDirection(1.f, 0.f, 0.f);</pre></div><p>First, let's address the three-dimensional coordinates. In SFML, the default up vector is on the positive <em>Y</em> axis. Look at the following figure:</p><div><img src="img/B04284_12_01.jpg" alt="Sound spatialization"/><div><p>Each axis the character is on represents a direction vector in three dimensions</p></div></div><p>This <a id="id518" class="indexterm"/>arrangement of axes is known as a <em>right-handed Cartesian coordinate system</em> and is the standard for OpenGL, which is the basis of SFML. What this means is that what we've been calling the <em>Y</em> axis in two dimensions is really the <em>Z</em> axis in a three dimensional space. That's important to keep in mind if we want to have correct results when moving sound through space.</p><p>The listener direction is represented by something called a unit vector, also referred to as a normalized vector, which means it can only have a maximum magnitude of 1. When setting the listener's direction, the vector provided is normalized again, so these two lines of code would produce equivalent results of a south-east direction:</p><div><pre class="programlisting">sf::Listener::setDirection(1.f, 0.f, 1.f);
sf::Listener::setDirection(0.5f, 0.f, 0.5f);</pre></div><p>For our purposes, however, we're not going to need to use diagonal directions, as our main character, who will obviously be the sole listener, can only face four possible directions.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec58"/>Placing sounds in space</h2></div></div></div><p>Much like how <a id="id519" class="indexterm"/>sprites are positioned in two-dimensional space, sounds can be positioned as well by using the method with the same name:</p><div><pre class="programlisting">sf::Sound sound;
sound.setPosition(5.f, 0.f, 5.f);</pre></div><p>Let's say that the listener is facing in the positive <em>X</em> direction <em>(1.f, 0.f, 0.f)</em>. The sound that we just placed at coordinates <em>(5.f, 0.f, 5.f)</em> would be five units ahead and five units to the right of our listener and would be heard through the right speaker. How loud would it have to be, though? That's where the minimum sound distance and attenuation come in:</p><div><pre class="programlisting">sound.setMinDistance(6.f);
sound.setAttenuation(2.f);</pre></div><p>Sound<a id="id520" class="indexterm"/> minimum distance is the threshold at which the sound begins to lose volume and gets quieter. In the preceding example, if the listener is closer or exactly six units of distance away from the sound source, full volume of the sound will be heard. Otherwise, the sound begins to fade. How fast it fades is determined by the attenuation factor. Consider this figure:</p><div><img src="img/B04284_12_02.jpg" alt="Placing sounds in space"/><div><p>The circle with a radius of Min_Distance represents an area, where the sound can be heard at maximum volume. After the minimum distance is exceeded, the attenuation factor is applied to the volume.</p></div></div><p>Attenuation is simply a multiplicative factor. The higher it is, the faster sound fades over distance. Setting attenuation to 0 would result in a sound heard everywhere, while a value like 100 would mean that it is heard only when the listener is very close to it.</p><p>Remember that although we're not going to be taking advantage of it, music in SFML behaves under the same rules of spatialization as sound, as long as it only has one channel.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec104"/>Audio manager</h1></div></div></div><p>Similar to <a id="id521" class="indexterm"/>what we did for textures and fonts, we're going to need a way to manage <code class="literal">sf::SoundBuffer</code> instances easily. Luckily, our <code class="literal">ResourceManager</code> class is there to make it extremely convenient, so let's create the <code class="literal">AudioManager.h</code> file and define the way sound buffers are set up:</p><div><pre class="programlisting">class AudioManager : public ResourceManager&lt;
  AudioManager, sf::SoundBuffer&gt;
{
public:
  AudioManager() : ResourceManager("audio.cfg"){}

  sf::SoundBuffer* Load(const std::string&amp; l_path){
    sf::SoundBuffer* sound = new sf::SoundBuffer();
    if (!sound-&gt;loadFromFile(
      Utils::GetWorkingDirectory() + l_path))
    {
      delete sound;
      sound = nullptr;
      std::cerr &lt;&lt; "! Failed to load sound: "
        &lt;&lt; l_path &lt;&lt; std::endl;
    }
    return sound;
  }
};</pre></div><p>As you can tell already, the sound interface is pretty much exactly the same as that of textures or fonts. Similar to the previous resource managers, we also provide a file that paths are loaded from. In this case, it is the <code class="literal">audio.cfg</code> file:</p><div><pre class="programlisting">Footstep media/Audio/footstep.ogg
TownTheme media/Audio/TownTheme.ogg</pre></div><p>Once again, it is just like dealing with textures or fonts. So far, so good!</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec105"/>Defining sound properties</h1></div></div></div><p>Sound, much <a id="id522" class="indexterm"/>like any other medium, has a few different properties of interest that are up for tweaking. The effects we're going to be playing in our game don't just have varying sources, but also different volumes, pitch values, the distance a sound can cover, and a factor that represents how fast that sound fades. How we're going to store this information is defined in <code class="literal">SoundProps.h</code>:</p><div><pre class="programlisting">struct SoundProps{
    SoundProps(const std::string&amp; l_name): m_audioName(l_name), m_volume(100), m_pitch(1.f), m_minDistance(10.f), m_attenuation(10.f){}
    std::string m_audioName;
    float m_volume;
    float m_pitch;
    float m_minDistance;
    float m_attenuation;
};</pre></div><p>In addition<a id="id523" class="indexterm"/> to the qualities described earlier, it is also necessary to store the identifier of the audio file that a sound is going to be using. A typical sound file for our application would look something like <code class="literal">footstep.sound</code>:</p><div><pre class="programlisting">Audio Footstep
Volume 25
Pitch 1.0
Distance 150
Attenuation 2</pre></div><p>With this out of the way, we can actually jump right into managing the <code class="literal">sf::Sound</code> instances!</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec106"/>Managing sounds</h1></div></div></div><p>Due to<a id="id524" class="indexterm"/> the limitations on the number of sounds we can have in an application, it's best to have a centralized way of handling and recycling them. This is where the <code class="literal">SoundManager</code> class comes in. Let's begin aliasing a data type for sound IDs:</p><div><pre class="programlisting">using SoundID = int;</pre></div><p>A simple integer type is more than qualified for the job of keeping sounds identified.</p><p>Additionally, we'll want to store some information with the sound instance:</p><div><pre class="programlisting">struct SoundInfo{
    SoundInfo(const std::string&amp; l_name): m_name(l_name), m_manualPaused(false){}
    std::string m_name;
    bool m_manualPaused;
};</pre></div><p>In order to properly deallocate resources when it counts, we're going to want to store the string identifier of the audio file that the sound is using. Keeping track of whether the sound has been paused automatically or not is important for consistency. That's what the <code class="literal">m_manualPaused </code>Boolean flag is there for.</p><p>Lastly, before we delve deeper into the sound manager, looking at a few type definitions used here is essential:</p><div><pre class="programlisting">using SoundProperties = std::unordered_map&lt;std::string,
  SoundProps&gt;;
using SoundContainer = std::unordered_map&lt;SoundID,
  std::pair&lt;SoundInfo, sf::Sound*&gt;&gt;;
using Sounds = std::unordered_map&lt;StateType, SoundContainer&gt;;
using RecycledSounds = std::vector&lt;std::pair&lt;
  std::pair&lt;SoundID, std::string&gt;, sf::Sound*&gt;&gt;;
using MusicContainer = std::unordered_map&lt;StateType,
  std::pair&lt;SoundInfo, sf::Music*&gt;&gt;;</pre></div><p>The <code class="literal">SoundProperties</code> type is just a map that associates the name of a sound to a structure that<a id="id525" class="indexterm"/> contains its properties. <code class="literal">SoundContainer</code> is another map that ties a <code class="literal">SoundID</code> to a pair that contains the <code class="literal">SoundInfo</code> structure, as well as the actual instance of the <code class="literal">sf::Sound</code> object. The <code class="literal">Sounds</code> data type is responsible for grouping these sound containers by <code class="literal">State</code>.</p><p>Further down the line, as sounds get recycled, they need to be moved to a different container of type <code class="literal">RecycledSounds</code>. It stores the sound ID and name alongside the <code class="literal">sf::Sound</code> instance.</p><p>The last type definition we're going to be dealing with here is a container for <code class="literal">sf::Music</code> instances. Just like sounds, they're grouped by states. One major difference here is the fact that we're only allowing one instance of <code class="literal">sf::Music</code> per state, which is stored together with a <code class="literal">SoundInfo</code> structure.</p><p>Now that we have everything we need, let's take a look at the sound manager header file:</p><div><pre class="programlisting">class SoundManager{
public:
  SoundManager(AudioManager* l_audioMgr);
  ~SoundManager();

  void ChangeState(const StateType&amp; l_state);
  void RemoveState(const StateType&amp; l_state);

  void Update(float l_dT);

  SoundID Play(const std::string&amp; l_sound, 
    const sf::Vector3f&amp; l_position, 
    bool l_loop = false, 
    bool l_relative = false);
  bool Play(const SoundID&amp; l_id);
  bool Stop(const SoundID&amp; l_id);
  bool Pause(const SoundID&amp; l_id);

  bool PlayMusic(const std::string&amp; l_musicId,
    float l_volume = 100.f, bool l_loop = false);
  bool PlayMusic(const StateType&amp; l_state);
  bool StopMusic(const StateType&amp; l_state);
  bool PauseMusic(const StateType&amp; l_state);

  bool SetPosition(const SoundID&amp; l_id, const sf::Vector3f&amp; l_pos);
  bool IsPlaying(const SoundID&amp; l_id);
  SoundProps* GetSoundProperties(const std::string&amp; l_soundName);

  <strong>static const int Max_Sounds = 150;</strong>
  <strong>static const int Sound_Cache = 75;</strong>
private:
  bool LoadProperties(const std::string&amp; l_file);
  void PauseAll(const StateType&amp; l_state);
  void UnpauseAll(const StateType&amp; l_state);

  sf::Sound* CreateSound(SoundID&amp; l_id,
    const std::string&amp; l_audioName);
  void SetUpSound(sf::Sound* l_snd, const SoundProps* l_props, 
    bool l_loop = false, bool l_relative = false);
  bool RecycleSound(const SoundID&amp; l_id, sf::Sound* l_snd,
    const std::string&amp; l_name);

  void Cleanup();

  Sounds m_audio;
  MusicContainer m_music;
  RecycledSounds m_recycled;
  SoundProperties m_properties;
  StateType m_currentState;

  SoundID m_lastID;
  unsigned int m_numSounds;
  float m_elapsed;

  AudioManager* m_audioManager;
};</pre></div><p>As mentioned<a id="id526" class="indexterm"/> previously, it's a good idea to keep the number of <code class="literal">sf::Sound</code> and <code class="literal">sf::Music</code> instances in your application down to a designated limit that never exceeds 256. In this case, we're playing it pretty safe by using static data members for setting a limit of 150 sounds loaded in memory at the same time. In addition to that, we're also setting a limit to how many sound instances can be recycled before they're used again, which is 75. These values can obviously be tweaked to your liking.</p><p>Let's talk about the private data members of this class before we get into implementation details. As expected, the sound and music containers are stored in this class under the names <code class="literal">m_audio</code> and <code class="literal">m_music</code>. Additionally, we're storing all of the sound properties in this class, alongside the recycled sound container. Because sound functionality is state based, the <code class="literal">m_currentState</code> data member is necessary for keeping tabs on what state the application is running in.</p><p>In order to <a id="id527" class="indexterm"/>assign sound IDs properly, keeping track of the last ID is a good idea, hence <code class="literal">m_lastID</code>. Also, since enforcing restrictions on how many instances of <code class="literal">sf::Sound</code> and <code class="literal">sf::Music</code> can be "alive" at the same time is of paramount importance; <code class="literal">m_numSounds</code> is used to keep track of every instance of these two classes. We're also going to need to check time passage in our application, which is what <code class="literal">m_elapsed</code> will be used for.</p><p>Finally, a pointer to the audio manager is kept around for resource management and retrieval.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec59"/>Implementing the sound manager</h2></div></div></div><p>Let's begin, as<a id="id528" class="indexterm"/> always, by looking at the constructor and destructor of this class:</p><div><pre class="programlisting">SoundManager::SoundManager(AudioManager* l_audioMgr)
    : m_lastID(0), m_audioManager(l_audioMgr), 
    m_elapsed(0.f), m_numSounds(0){}

SoundManager::~SoundManager(){ Cleanup(); }</pre></div><p>A pointer to an <code class="literal">AudioManager</code> instance is obtained through the argument list of the constructor and initialized in the initializer list, alongside other data members and their default values. The destructor simply invokes another method called <code class="literal">Cleanup()</code>, which is responsible for the de-allocation of memory. It will be covered shortly.</p><p>We have already discussed the role that application states play in sound management. Now, let's take a look at actually defining the behavior of sound when states are changed:</p><div><pre class="programlisting">void SoundManager::ChangeState(const StateType&amp; l_state){
  PauseAll(m_currentState);
  UnpauseAll(l_state);
  m_currentState = l_state;
  
  if (m_music.find(m_currentState) != m_music.end()){ return; }
  SoundInfo info("");
  sf::Music* music = nullptr;
  m_music.emplace(m_currentState, std::make_pair(info, music));
}</pre></div><p>Upon the application state being altered, a <code class="literal">PauseAll</code> method is invoked with the argument of <code class="literal">m_currentState</code>. It's responsible for effectively silencing every sound that is currently playing. We don't want to be hearing fights and explosions of the in-game action while<a id="id529" class="indexterm"/> we're in the main menu. The <code class="literal">UnpauseAll</code> method is called next, with the identifier of the state being changed to being passed in as the argument. Obviously, if we're in the main menu and we're switching back to the game state, we want all of the action to resume and this includes all of the sound effects. The data member that holds the current state information is then altered.</p><p>The last few lines of code in this method are responsible for making sure that the music container has information about the new state. If nothing is found, some blank information is inserted into the <code class="literal">m_music</code> container in order to signify that the current state currently has no music playing.</p><p>Next, let's talk about what happens when a state is removed from the application:</p><div><pre class="programlisting">void SoundManager::RemoveState(const StateType&amp; l_state){
  auto&amp; StateSounds = m_audio.find(l_state)-&gt;second;
  for (auto &amp;itr : StateSounds){
    RecycleSound(itr.first, itr.second.second,
      itr.second.first.m_name);
  }
  m_audio.erase(l_state);
  auto music = m_music.find(l_state);
  if (music == m_music.end()){ return; }
  if (music-&gt;second.second){
    delete music-&gt;second.second;
    --m_numSounds;
  }
  m_music.erase(l_state);
}</pre></div><p>The sound container is first obtained for the state that is being removed. Every sound in that state is then iterated over and recycled via the <code class="literal">RecycleSound</code> method, which takes in the sound ID, pointer to the <code class="literal">sf::Sound</code> instance, and the sound name. Once that is done, all of the state information is erased from the <code class="literal">m_audio</code> container. Additionally, if an instance of <code class="literal">sf::Music</code> is found in that state, the memory for it is deallocated and the number of sounds currently existing in memory is decreased.</p><p>Good memory management is extremely important in an application and is one of the main reasons we're using manager classes instead of simply having resources scattered all over the place. The method responsible for cleaning up the mess in this case might look a little something like this:</p><div><pre class="programlisting">void SoundManager::Cleanup(){
  for (auto &amp;state : m_audio){
    for (auto &amp;sound : state.second){
      m_audioManager-&gt;ReleaseResource(sound.second.first.m_name);
      delete sound.second.second;
    }
  }
  m_audio.clear();
  for (auto &amp;recycled : m_recycled){
    m_audioManager-&gt;ReleaseResource(recycled.first.second);
    delete recycled.second;
  }
  m_recycled.clear();
  for (auto &amp;music : m_music){
    if (music.second.second){ 
      delete music.second.second;
    }
  }
  m_music.clear();

  m_properties.clear();
  m_numSounds = 0;
  m_lastID = 0;
}</pre></div><p>First, we <a id="id530" class="indexterm"/>iterate over the container of currently playing sounds and release the audio resources that are being used. The dynamic memory for the sound is then deleted safely instead of being recycled. The exact same process is repeated one more time for all of the sounds that exist in the <code class="literal">m_recycled</code> container. Finally, all of the music instances are also deleted. Once all containers are properly cleared, the number of sounds is set back to 0, along with the last sound ID.</p><p>Now that we've covered all of the "housekeeping" details, let's take a look at how we can make a system like this tick through its <code class="literal">Update</code> method:</p><div><pre class="programlisting">void SoundManager::Update(float l_dT){
  m_elapsed += l_dT;
  if (m_elapsed &lt; 0.33f){ return; }
  // Run once every third of a second.
  m_elapsed = 0;
  auto&amp; container = m_audio[m_currentState];
  for (auto itr = container.begin(); itr != container.end();){
    if (!itr-&gt;second.second-&gt;getStatus()){
      RecycleSound(itr-&gt;first, itr-&gt;second.second,
        itr-&gt;second.first.m_name);
      itr = container.erase(itr); // Remove sound.
      continue;
    }
    ++itr;
  }
  auto music = m_music.find(m_currentState);
  if (music == m_music.end()){ return; }
  if (!music-&gt;second.second){ return; }
  if (music-&gt;second.second-&gt;getStatus()){ return; }
  delete music-&gt;second.second;
  music-&gt;second.second = nullptr;
  --m_numSounds;
}</pre></div><p>An important <a id="id531" class="indexterm"/>thing to keep in mind here is that we really don't need to run this chunk of code every single tick of the application. Instead, we keep track of time passing and check the <code class="literal">m_elapsed</code> data member each cycle to see if it's time to run our code yet. The <code class="literal">0.33f</code> value is arbitrary in this case and can be set to anything within a reasonable range.</p><p>If enough time has passed, we loop over every sound in the current state and check its status. If the sound has stopped, we can safely recycle it by invoking the <code class="literal">RecycleSound</code> method and then remove it from our primary sound container.</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>When an element in an STL container is removed, all iterators of said container become invalid. If left unattended, this can lead to elements being skipped or out of bounds accesses. It can be addressed by setting the iterator to the return value of the <code class="literal">erase</code> method, as it returns a valid iterator to an element <em>after</em> the one that has been erased. It increments the iterator only if an element hasn't been erased during the current cycle of the loop.</p></div></div><p>In this system, music follows the exact same treatment and is removed if it's no longer playing.</p><p>Next, let's look at providing a way for the users of this class to play sounds:</p><div><pre class="programlisting">SoundID SoundManager::Play(const std::string&amp; l_sound,
  const sf::Vector3f&amp; l_position, bool l_loop, bool l_relative)
{
  SoundProps* props = GetSoundProperties(l_sound);
  if (!props){ return -1; } // Failed to load sound properties.
  SoundID id;
  sf::Sound* sound = CreateSound(id, props-&gt;m_audioName);
  if (!sound){ return -1; }
  // Sound created successfully.
  SetUpSound(sound, props, l_loop, l_relative);
  sound-&gt;setPosition(l_position);
  SoundInfo info(props-&gt;m_audioName);
  m_audio[m_currentState].emplace(id,std::make_pair(info, sound));
  sound-&gt;play();
  return id;
}</pre></div><p>We begin by obtaining a pointer to the sound properties structure by using the <code class="literal">GetSoundProperties</code> method, which we will be covering later. If it returned a <code class="literal">nullptr</code> value, -1 is returned by the <code class="literal">Play</code> method to signify a loading error. Otherwise, we proceed by creating a sound ID instance that is going to be passed in <em>by reference</em> to the <code class="literal">CreateSound</code> method, along with the identifier of the audio sound buffer. If the sound was created<a id="id532" class="indexterm"/> successfully, it returns a pointer to the <code class="literal">sf::Sound</code> instance that is ready to be used.</p><p>The <code class="literal">SetUpSound</code> method is then invoked with pointers to the <code class="literal">sf::Sound</code> instance and properties being passed in as arguments, as well as two Boolean flags for whether the sound should loop and be relative to the listener. The latter two are passed in as arguments to the <code class="literal">Play</code> method we're currently implementing. The sound is then positioned in space and stored in the <code class="literal">m_audio</code> container, along with the <code class="literal">SoundInfo</code> structure that is set up just one line before and holds the audio identifier.</p><p>The final step is then calling the <code class="literal">play()</code> method of our sound instance and returning the ID of said sound for later manipulations.</p><p>As the header file suggests, there are two versions of the <code class="literal">Play</code> method. Let's cover the other one now:</p><div><pre class="programlisting">bool SoundManager::Play(const SoundID&amp; l_id){
  auto&amp; container = m_audio[m_currentState];
  auto sound = container.find(l_id);
  if (sound == container.end()){ return false; }
  sound-&gt;second.second-&gt;play();
  sound-&gt;second.first.m_manualPaused = false;
  return true;
}</pre></div><p>This version of the <code class="literal">Play</code> method only takes in a single argument of the sound ID and returns a Boolean flag. It's meant to start an already existing sound, which begins by it being located in the sound container. If the sound has been found, its <code class="literal">play</code> method is invoked and the <code class="literal">m_manualPaused</code> flag is set to <code class="literal">false</code>, showing that it is no longer paused.</p><p>Stopping a sound works in a very similar fashion:</p><div><pre class="programlisting">bool SoundManager::Stop(const SoundID&amp; l_id){
  auto&amp; container = m_audio[m_currentState];
  auto sound = container.find(l_id);
  if (sound == container.end()){ return false; }
  sound-&gt;second.second-&gt;stop();
  sound-&gt;second.first.m_manualPaused = true;
  return true;
}</pre></div><p>The only difference here is that the <code class="literal">stop</code> method is invoked instead, and the <code class="literal">m_manualPaused</code> flag is set to <code class="literal">true</code> to signify that it has been paused in a non-automatic fashion.</p><p>One more<a id="id533" class="indexterm"/> method that follows the exact same pattern is the <code class="literal">Pause</code> method:</p><div><pre class="programlisting">bool SoundManager::Pause(const SoundID&amp; l_id){
  auto&amp; container = m_audio[m_currentState];
  auto sound = container.find(l_id);
  if (sound == container.end()){ return false; }
  sound-&gt;second.second-&gt;pause();
  sound-&gt;second.first.m_manualPaused = true;
  return true;
}</pre></div><p>Now it's time to move on from sound and to music, specifically how it can be played:</p><div><pre class="programlisting">bool SoundManager::PlayMusic(const std::string&amp; l_musicId,
  float l_volume, bool l_loop)
{
  auto s = m_music.find(m_currentState);
  if (s == m_music.end()){ return false; }
  std::string path = m_audioManager-&gt;GetPath(l_musicId);
  if (path == ""){ return false; }
  if (!s-&gt;second.second){
    s-&gt;second.second = new sf::Music();
    ++m_numSounds;
  }
  sf::Music* music = s-&gt;second.second;
  if (!music-&gt;openFromFile(Utils::GetWorkingDirectory() + path)){
    delete music;
    --m_numSounds;
    s-&gt;second.second = nullptr;
    std::cerr &lt;&lt; "[SoundManager] Failed to load music from file: "
      &lt;&lt; l_musicId &lt;&lt; std::endl;
    return false;
  }
  music-&gt;setLoop(l_loop);
  music-&gt;setVolume(l_volume);
  music-&gt;setRelativeToListener(true); // Always relative.
  music-&gt;play();
  s-&gt;second.first.m_name = l_musicId;
  return true;
}</pre></div><p>First, the music element for the current state is located. The path to the actual audio file is then obtained by using our newly added <code class="literal">GetPath</code> method and checked for being blank. If it isn't, we check whether an actual instance of <code class="literal">sf::Music</code> exists for the current state and create one<a id="id534" class="indexterm"/> if it doesn't. The <code class="literal">openFromFile</code> method of the <code class="literal">sf::Music</code> instance is then called in an <code class="literal">if</code>
statement in order to check if it was successful or not. If it wasn't, the <code class="literal">sf::Music</code> instance is deleted and the number of sounds is decreased. Otherwise, the music instance is set to the volume and loop preferences provided as arguments and played. Note that we're setting every music instance to also be relative to the listener. While it is possible to make music positional, we have no need for it at this point.</p><p>Because we want the same functionality for music as we do for any given sound, we have a fairly similar line-up of methods for manipulating music as well: </p><div><pre class="programlisting">bool SoundManager::PlayMusic(const StateType&amp; l_state){
  auto music = m_music.find(m_currentState);
  if (music == m_music.end()){ return false; }
  if (!music-&gt;second.second){ return false; }
  music-&gt;second.second-&gt;play();
  music-&gt;second.first.m_manualPaused = false;
  return true;
}
bool SoundManager::StopMusic(const StateType&amp; l_state){
  auto music = m_music.find(m_currentState);
  if (music == m_music.end()){ return false; }
  if (!music-&gt;second.second){ return false; }
  music-&gt;second.second-&gt;stop();
  delete music-&gt;second.second;
  music-&gt;second.second = nullptr;
  --m_numSounds;
  return true;
}
bool SoundManager::PauseMusic(const StateType&amp; l_state){
  auto music = m_music.find(m_currentState);
  if (music == m_music.end()){ return false; }
  if (!music-&gt;second.second){ return false; }
  music-&gt;second.second-&gt;pause();
  music-&gt;second.first.m_manualPaused = true;
  return true;
}</pre></div><p>Let's get back to sound now. Since we're going to be utilizing its spatial qualities, it's a good idea to have a method that can be used for setting its position in space:</p><div><pre class="programlisting">bool SoundManager::SetPosition(const SoundID&amp; l_id,
  const sf::Vector3f&amp; l_pos)
{
  auto&amp; container = m_audio[m_currentState];
  auto sound = container.find(l_id);
  if (sound == container.end()){ return false; }
  sound-&gt;second.second-&gt;setPosition(l_pos);
  return true;
}</pre></div><p>This<a id="id535" class="indexterm"/> method simply locates the sound instance in its container and sets its position to the one provided as an argument.</p><p>What if we want to check if a sound is still playing? No problem! That's what the <code class="literal">IsPlaying</code> method is for:</p><div><pre class="programlisting">bool SoundManager::IsPlaying(const SoundID&amp; l_id){
  auto&amp; container = m_audio[m_currentState];
  auto sound = container.find(l_id);
  return (sound != container.end() ?
    sound-&gt;second.second-&gt;getStatus() : false);
}</pre></div><p>Due to the fact that sound status is a simple enumeration table, it can be forced into a Boolean value. Since we don't care about the "paused" state, returning the status as a Boolean works just fine.</p><p>Next, we have a way for obtaining the sound properties:</p><div><pre class="programlisting">SoundProps* SoundManager::GetSoundProperties(
  const std::string&amp; l_soundName)
{
  auto&amp; properties = m_properties.find(l_soundName);
  if (properties == m_properties.end()){
    if (!LoadProperties(l_soundName)){ return nullptr; }
    properties = m_properties.find(l_soundName);
  }
  return &amp;properties-&gt;second;
}</pre></div><p>Because sound properties aren't loaded during start-up, simply not finding the right information might simply mean that it was never loaded. If that's the case, the <code class="literal">LoadProperties</code> method is invoked. It returns a Boolean value that informs us of a failure, in which case a <code class="literal">nullptr</code> value is returned. Otherwise, the properties structure is searched for again and then returned at the end of this method.</p><p>As we're on the subject of loading properties, let's actually take a look at how they're loaded from the <code class="literal">.sound</code> file:</p><div><pre class="programlisting">bool SoundManager::LoadProperties(const std::string&amp; l_name){
  std::ifstream file;
  file.open(Utils::GetWorkingDirectory() +
    "media/Sounds/" + l_name + ".sound");
  if (!file.is_open()){
    std::cerr &lt;&lt; "Failed to load sound: " &lt;&lt; l_name &lt;&lt; std::endl;
    return false;
  }
  SoundProps props("");
  std::string line;
  while (std::getline(file, line)){
    if (line[0] == '|'){ continue; }
    std::stringstream keystream(line);
    std::string type;
    keystream &gt;&gt; type;
    if (type == "Audio"){
      keystream &gt;&gt; props.m_audioName;
    } else if (type == "Volume"){
      keystream &gt;&gt; props.m_volume;
    } else if (type == "Pitch"){
      keystream &gt;&gt; props.m_pitch;
    } else if (type == "Distance"){
      keystream &gt;&gt; props.m_minDistance;
    } else if (type == "Attenuation"){
      keystream &gt;&gt; props.m_attenuation;
    } else {
      // ?
    }
  }
  file.close();
  if (props.m_audioName == ""){ return false; }
  m_properties.emplace(l_name, props);
  return true;
}</pre></div><p>Having<a id="id536" class="indexterm"/> loaded many files in the past, this should be nothing new. So, let's just breeze right through it. A temporary <code class="literal">SoundProps</code> instance called <code class="literal">props</code> is created on the stack with a default audio name that is blank. The file is then processed and checked line by line for relevant keywords. The information is then loaded directly into the temporary properties instance using the <code class="literal">&gt;&gt;</code> operator.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>For extra credit, the <code class="literal">if else</code> chain could be replaced with some sort of associative container of lambda functions, but let's keep the logic as it is for the sake of simplicity.</p></div></div><p>Once the file has all been read in, it is closed and the audio name of the properties instance is checked for not being a blank, as it should've been loaded during the process. If the name is, in fact, something other than a blank, the <code class="literal">SoundProps</code> instance is inserted into the property container and true is returned for success.</p><p>As we<a id="id537" class="indexterm"/> were covering changing states, a few methods for pausing and starting all sounds were introduced. Let's take a look at one of them now:</p><div><pre class="programlisting">void SoundManager::PauseAll(const StateType&amp; l_state){
  auto&amp; container = m_audio[l_state];
  for (auto itr = container.begin(); itr != container.end();){
    if (!itr-&gt;second.second-&gt;getStatus()){
      RecycleSound(itr-&gt;first, itr-&gt;second.second,
        itr-&gt;second.first.m_name);
      itr = container.erase(itr);
      continue;
    }
    itr-&gt;second.second-&gt;pause();
    ++itr;
  }
  auto music = m_music.find(l_state);
  if (music == m_music.end()){ return; }
  if (!music-&gt;second.second){ return; }
  music-&gt;second.second-&gt;pause();
}</pre></div><p>The <code class="literal">PauseAll</code> method first obtains the container of all sounds for the provided state. It iterates over each one and checks if the sound is actually stopped or not. If it is, the sound is simply recycled and the element is erased. Otherwise, the sound's <code class="literal">pause</code> method is called. Music for the provided state is also paused, provided that it exists.</p><p>The <code class="literal">UnpauseAll</code> method is simpler, as it has no reason to recycle sounds:</p><div><pre class="programlisting">void SoundManager::UnpauseAll(const StateType&amp; l_state){
  auto&amp; container = m_audio[l_state];
  for (auto &amp;itr : container){
    if (itr.second.first.m_manualPaused){ continue; }
    itr.second.second-&gt;play();
  }

  auto music = m_music.find(l_state);
  if (music == m_music.end()){ return; }
  if (!music-&gt;second.second ||music-&gt;second.first.m_manualPaused){
    return;
  }
  music-&gt;second.second-&gt;play();
}</pre></div><p>The catch here is that the sounds and music are only played again if they weren't manually paused by their respective <code class="literal">Pause</code> methods.</p><p>Now, let's implement <a id="id538" class="indexterm"/>arguably the most important piece of this class that is responsible for actual creation and recycling of the <code class="literal">sf::Sound</code> instances:</p><div><pre class="programlisting">sf::Sound* SoundManager::CreateSound(SoundID&amp; l_id,
  const std::string&amp; l_audioName)
{
  sf::Sound* sound = nullptr;
  if (!m_recycled.empty() &amp;&amp; (m_numSounds &gt;= Max_Sounds ||
    m_recycled.size() &gt;= Sound_Cache))
  {
    auto itr = m_recycled.begin();
    while (itr != m_recycled.end()){
      if (itr-&gt;first.second == l_audioName){ break; }
      ++itr;
    }
    if (itr == m_recycled.end()){
      // If a sound with the same name hasn't been found!
      auto element = m_recycled.begin();
      l_id = element-&gt;first.first;
      m_audioManager-&gt;ReleaseResource(element-&gt;first.second);
      m_audioManager-&gt;RequireResource(l_audioName);
      sound = element-&gt;second;
      sound-&gt;setBuffer(*m_audioManager-&gt;GetResource(l_audioName));
      m_recycled.erase(element);
    } else {
      l_id = itr-&gt;first.first;
      sound = itr-&gt;second;
      m_recycled.erase(itr);
    }
    return sound;
  }
  if (m_numSounds &lt; Max_Sounds){
    if (m_audioManager-&gt;RequireResource(l_audioName)){
      sound = new sf::Sound();
      l_id = m_lastID;
      ++m_lastID;
      ++m_numSounds;
      sound-&gt;setBuffer(*m_audioManager-&gt;GetResource(l_audioName));
      return sound;
    }
  }
  std::cerr &lt;&lt; "[SoundManager] Failed to create sound."
    &lt;&lt; std::endl;
  return nullptr;
}</pre></div><p>A local <a id="id539" class="indexterm"/>variable named <code class="literal">sound</code> is first set up with the value of <code class="literal">nullptr</code>, and it will be manipulated throughout the rest of this method. The size of the recycled sound container is then checked, along with whether the number of maximum sounds overall or maximum cached sounds has been exceeded.</p><p>If the number of sounds is too high on either count and the recycled container isn't empty, we know we're going to be recycling an already existing sound. This process begins by first attempting to find a sound that already uses the same <code class="literal">sf::SoundBuffer</code> instance. In the case of such sound not existing, we simply pop the first element from the recycled container, store its ID in the variable <code class="literal">l_id</code> and release the resource that was used by the sound being recycled. The <code class="literal">l_id</code> argument takes a reference to a <code class="literal">SoundID</code> that it modifies, which serves as a way to let the outside code know the ID that has been assigned to the sound instance. The new resource that our sound is going to use is then reserved and our sound variable is set to point to the recycled sound instance, which is then set to use a new sound buffer. Our refurbished sound is removed from the recycled container. On the other hand, if a sound that uses the same <code class="literal">sf::SoundBuffer</code> instance was found, it doesn't need any additional setting up and can simply be returned after its ID is stored and it's erased from the <code class="literal">m_recycled</code> container.</p><p>If there were no recycled sounds available or we had extra space to spare, a new sound is created instead of using a recycled one. The ID of the sound is set to match that of <code class="literal">m_lastID</code>, which is then incremented (same as <code class="literal">m_numSounds</code>). After the sound's buffer is set up, it can safely be returned for further processing, such as in the <code class="literal">SetUpSound</code> method:</p><div><pre class="programlisting">void SoundManager::SetUpSound(sf::Sound* l_snd, 
  const SoundProps* l_props, bool&amp; l_loop, bool&amp; l_relative)
{
    l_snd-&gt;setVolume(l_props-&gt;m_volume);
    l_snd-&gt;setPitch(l_props-&gt;m_pitch);
    l_snd-&gt;setMinDistance(l_props-&gt;m_minDistance);
    l_snd-&gt;setAttenuation(l_props-&gt;m_attenuation);
    l_snd-&gt;setLoop(l_loop);
    l_snd-&gt;setRelativeToListener(l_relative);
}</pre></div><p>The main idea of this method is simply reducing code wherever possible. It sets up the volume, pitch, minimum distance, attenuation, looping, and relativity of the sound all based on the arguments provided.</p><p>Let's wrap this class up with a relatively simple yet commonly used piece of code:</p><div><pre class="programlisting">void SoundManager::RecycleSound(const SoundID&amp; l_id, 
  sf::Sound* l_snd, const std::string&amp; l_name)
{
  m_recycled.emplace_back(std::make_pair(l_id, l_name), l_snd);
}</pre></div><p>This<a id="id540" class="indexterm"/> method is only responsible for pushing the information provided as arguments into the recycled container for later use.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec107"/>Adding support for sound</h1></div></div></div><p>In <a id="id541" class="indexterm"/>order to make our entities emit sounds, some preparations have to be made. For now, we're only going to concern ourselves with simply adding the sound of footsteps whenever a character walks. Doing so requires a slight modification of the <code class="literal">EntityMessage</code> enumeration in <code class="literal">EntityMessages.h</code>:</p><div><pre class="programlisting">enum class EntityMessage{ 
  Move, Is_Moving, <strong>Frame_Change</strong>, State_Changed, <strong>Direction_Changed</strong>,
  Switch_State, Attack_Action, Dead
};</pre></div><p>The highlighted bits are what we're going to be focusing on. <code class="literal">Frame_Change</code> is a new type of message that's been added in this chapter, and <code class="literal">Direction_Changed</code> will be used to manipulate the sound listener's direction. In order to detect when a frame changes during the animation process, however, we're going to need to make a few more adjustments to our code base.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec60"/>Animation system hooks</h2></div></div></div><p>In order to <a id="id542" class="indexterm"/>have the ability to send out the <code class="literal">Frame_Change</code> message we've just created, our animation system is going to need a few minor additions, starting with <code class="literal">Anim_Base.h</code>:</p><div><pre class="programlisting">class Anim_Base{
public:
    ...
    bool CheckMoved();
    ...
protected:
    ...
    bool m_hasMoved;
    ...
};</pre></div><p>Here, we're adding a new data member and a method to check if the current frame of an animation has recently been changed. Let's actually integrate this code in <code class="literal">Anim_Base.cpp</code>:</p><div><pre class="programlisting">Anim_Base::Anim_Base()...,m_hasMoved(false){ ... }

bool Anim_Base::CheckMoved(){
    bool result = m_hasMoved;
    m_hasMoved = false;
    return result;
}</pre></div><p>In the <a id="id543" class="indexterm"/>constructor, it's important to remember to set the newly added data member to a default value, which in this case is <code class="literal">false</code>. The actual <code class="literal">CheckMoved</code> method is a very basic chunk of code that returns the value of <code class="literal">m_hasMoved</code> but sets it to <code class="literal">false</code> at the same time in order to avoid false positives.</p><p>Now that we have an active flag that is going to be used to check for frame changes, all that's missing is simply setting it to <code class="literal">true</code> in the <code class="literal">SetFrame</code> method:</p><div><pre class="programlisting">bool Anim_Base::SetFrame(const unsigned int&amp; l_frame){
    if((l_frame &gt;= m_frameStart &amp;&amp; l_frame &lt;= m_frameEnd)||
      (l_frame &gt;= m_frameEnd &amp;&amp; l_frame &lt;= m_frameStart))
    {
        m_frameCurrent = l_frame;
        <strong>m_hasMoved = true;</strong>
        <strong>return true;</strong>
    }
    <strong>return false;</strong>
}</pre></div><p>Notice the return value is now a Boolean instead of void. This additional change makes it very easy to do error checking, which is very important for making our last alteration in <code class="literal">Anim_Directional.cpp</code>:</p><div><pre class="programlisting">void Anim_Directional::FrameStep(){
  bool b = SetFrame(m_frameCurrent +
    (m_frameStart &lt;= m_frameEnd ? 1 : -1));
  if (b){ return; }
  if (m_loop){ SetFrame(m_frameStart); }
  else { SetFrame(m_frameEnd); Pause(); }
}</pre></div><p>The difference here is subtle but relevant. We essentially went from incrementing the current frame by hand by using <code class="literal">m_frameCurrent</code> to only using the <code class="literal">SetFrame</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec61"/>Entity component system expansion</h2></div></div></div><p>With <a id="id544" class="indexterm"/>adjustments made previously, we can now put down our last piece of the puzzle in making this work by sending out the <code class="literal">Frame_Change</code> message in <code class="literal">S_SheetAnimation.cpp</code>:</p><div><pre class="programlisting">void S_SheetAnimation::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities){
    ...
    if (sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;CheckMoved()){
      int frame = sheet-&gt;GetSpriteSheet()-&gt;
        GetCurrentAnim()-&gt;GetFrame();
      Message msg((MessageType)EntityMessage::Frame_Change);
      msg.m_receiver = entity;
      msg.m_int = frame;
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
    }
  }
}</pre></div><p>The <code class="literal">Update</code> method, as you might recall, already handles other types of messages that are related to entities attacking and dying, so this is already gift-wrapped for us. The <code class="literal">CheckMoved</code> method we added earlier comes in handy and aids us in checking for changes. If there has been a change, the current frame is obtained and stored in the message, which is shortly followed by a <code class="literal">Dispatch</code> call.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec108"/>The sound emitter component</h1></div></div></div><p>Within the<a id="id545" class="indexterm"/> entity component system paradigm, every possible entity parameter or feature is represented as a component. Emitting sounds is definitely one of those features. In order for that to happen, we do have some setting up to do, starting with creating and implementing it in the <code class="literal">C_SoundEmitter.h</code> header. Before that, however, let's define the types of sounds an entity can have:</p><div><pre class="programlisting">enum class EntitySound{ None = -1, Footstep, Attack, Hurt,Death };</pre></div><p>As you can see, we're only going to be working with four types of sound, one of which is going to be implemented in this chapter. A <code class="literal">None</code> value is also set up in order to make error checking easier.</p><p>Every sound that an entity can emit will most likely have different frames it plays during, which calls for a new data structure that encapsulates such information:</p><div><pre class="programlisting">struct SoundParameters{
  static const int Max_SoundFrames = 5;
  SoundParameters(){
    for (int i = 0; i &lt; Max_SoundFrames; ++i){ m_frames[i] = -1; }
  }
  std::string m_sound;
  std::array&lt;int, Max_SoundFrames&gt; m_frames;
};</pre></div><p>Since sounds<a id="id546" class="indexterm"/> are going to be tied to specific frames of animation, we need to define the maximum possible number of frames that can have sounds attached to them. The static constant named <code class="literal">Max_SoundFrames</code> is used for that purpose here.</p><p>The constructor of the <code class="literal">SoundParameters</code> structure initializes the entire array of frames to a value of -1. This is going to allow us to check this information in a slightly more efficient way, as the check can be over whenever the first -1 value is encountered. In addition to an array of frame numbers, this structure also stores the name of the sound that is to be emitted.</p><p>Now, we can finally begin implementing the sound emitter component:</p><div><pre class="programlisting">class C_SoundEmitter : public C_Base{
public:
    static const int Max_EntitySounds = 4;
    ...
private:
    SoundID m_soundID;
    std::array&lt;SoundParameters, Max_EntitySounds&gt; m_params;
};</pre></div><p>First, another static constant is created in order to denote the number of entity sounds that are going to exist. The component itself only has two data members. The first one is a sound ID that will be used for emitting sounds that should not be played repeatedly and have to wait until the previous sound is finished. The second data member is an array of sound parameters for each possible type of entity sound.</p><p>Let's begin implementing the component, starting with its constructor:</p><div><pre class="programlisting">C_SoundEmitter(): C_Base(Component::SoundEmitter), m_soundID(-1){}</pre></div><p>Apart from the typical invocation of the <code class="literal">C_Base</code> constructor with the component type passed in, the sound ID data member is initialized to -1 as well to signify that this component currently is not playing any sounds.</p><p>In order for the future sound system to know what sounds to play, we're going to provide a way sound information can be extracted from this component:</p><div><pre class="programlisting">const std::string&amp; GetSound(const EntitySound&amp; l_snd){
  static std::string empty = "";
  return((int)l_snd &lt; Max_EntitySounds ?
    m_params[(int)l_snd].m_sound : empty);
}</pre></div><p>By simply<a id="id547" class="indexterm"/> providing one of the enumerated values of <code class="literal">EntitySound</code> as an argument, outside classes can retrieve information about which sound to play given the circumstances.</p><p>Additionally, in order to know if a sound should be played or not, the sound system will need a way to tell if the current frame of animation should be emitting sound or not. This is where the <code class="literal">IsSoundFrame</code> method comes in:</p><div><pre class="programlisting">bool IsSoundFrame(const EntitySound&amp; l_snd, int l_frame){
  if ((int)l_snd &gt;= Max_EntitySounds){ return false; }
  for (int i = 0; i &lt; SoundParameters::Max_SoundFrames; ++i){
    if (m_params[(int)l_snd].m_frames[i] == -1){ return false; }
    if (m_params[(int)l_snd].m_frames[i] == l_frame){return true;}
  }
  return false;
}</pre></div><p>If the provided sound argument is larger than the highest supported entity sound ID, <code class="literal">false</code> is returned. Otherwise, all of the frames for the given sound are iterated over. If a -1 value is encountered, <code class="literal">false</code> is returned right away. However, if the frame provided as an argument matches a sound frame in the array, this method returns <code class="literal">true</code>.</p><p>Next, we're going to need a few helper methods to set and get certain information:</p><div><pre class="programlisting">SoundID GetSoundID(){ return m_soundID; }
void SetSoundID(const SoundID&amp; l_id){ m_soundID = l_id; }
SoundParameters* GetParameters(){ return &amp;m_params[0]; }</pre></div><p>Before we get to reading in this component's information from the entity file, let's take a gander at what it might look like. This snippet can be found inside <code class="literal">Player.entity</code>:</p><div><pre class="programlisting">Name Player
...
Component 6 footstep:1,4</pre></div><p>After the component ID, we're going to be reading in the name of the sound effect to be played, followed by a set of frames delimited by commas. The name of the sound itself is separated from the frame information by a colon. Let's write this:</p><div><pre class="programlisting">void ReadIn(std::stringstream&amp; l_stream){
  std::string main_delimiter = ":";
  std::string frame_delimiter = ",";
  for (int i = 0; i &lt; Max_EntitySounds; ++i){
    std::string chunk;
    l_stream &gt;&gt; chunk;
    if (chunk == ""){ break; }

    std::string sound = chunk.substr(0,
      chunk.find(main_delimiter));
    std::string frames = chunk.substr(
      chunk.find(main_delimiter) + main_delimiter.length());
    m_params[i].m_sound = sound;
    size_t pos = 0;
    unsigned int frameNum = 0;
    while (frameNum &lt; SoundParameters::Max_SoundFrames){
      pos = frames.find(frame_delimiter);
      int frame = -1;
      if (pos != std::string::npos){
        frame = stoi(frames.substr(0, pos));
        frames.erase(0, pos + frame_delimiter.length());
      } else {
        frame = stoi(frames);
        m_params[i].m_frames[frameNum] = frame;
        break;
      }
      m_params[i].m_frames[frameNum] = frame;
      ++frameNum;
    }
  }
}</pre></div><p>After the <a id="id548" class="indexterm"/>delimiter information is set up, we iterate once for each possible entity sound and read in the contents of the next segment of the line into a string named <code class="literal">chunk</code>. If that string is actually empty, we break out of the loop as there's clearly no more information to be loaded. Otherwise, the chunk is split into two parts right at the colon delimiter: <code class="literal">sound</code> and <code class="literal">frames</code>. The entity sound is then stored inside the parameters structure.</p><p>Lastly, it's necessary to process the frame information, which is delimited by commas. Two local variables are set up to help us with this: <code class="literal">pos</code> that stores the position of the comma delimiter if one is found and <code class="literal">frameNum</code> that is used to make sure the <code class="literal">Max_SoundFrames</code> limit is honored. Inside the <code class="literal">while</code> loop, the frame delimiter is first located using the <code class="literal">find</code> method of the <code class="literal">std::string</code> class. If a delimiter was found, the frame is extracted from the string and converted to an integer, which is stored inside the variable <code class="literal">frame</code>. That entire segment, including the delimiter, is then erased from the string <code class="literal">frames</code> and the extracted information is stored inside the parameters structure. In a case where a delimiter wasn't found, however, the loop is stopped right after the frame information has been extracted.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec109"/>The sound listener component</h1></div></div></div><p>In order <a id="id549" class="indexterm"/>to properly implement spatial sounds, there has to be a listener within our game world. That listener is, of course, the player of the game. Fortunately, there isn't a lot of information we need to process or store when creating a component for an audio listener: </p><div><pre class="programlisting">class C_SoundListener : public C_Base{
public:
    C_SoundListener() : C_Base(Component::SoundListener){}
    void ReadIn(std::stringstream&amp; l_stream){}
private:

};</pre></div><p>Yes, that's it! In its most essential form, this class simply represents a sign that its owner entity should be treated as a listener in the auditory world.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec110"/>Implementing the sound system</h1></div></div></div><p>With both <a id="id550" class="indexterm"/>sound emitter and sound listener components out of the way, we have a green light to begin implementing the sound system that is going to bring all of this code to life. Let's get it started!</p><div><pre class="programlisting">class S_Sound : public S_Base{
public:
  S_Sound(SystemManager* l_systemMgr);
  ~S_Sound();

  void Update(float l_dT);
  void HandleEvent(const EntityId&amp; l_entity,
    const EntityEvent&amp; l_event);
  void Notify(const Message&amp; l_message);

  void SetUp(AudioManager* l_audioManager,
    SoundManager* l_soundManager);
private:
  sf::Vector3f MakeSoundPosition(const sf::Vector2f&amp; l_entityPos,
    unsigned int l_elevation);
  void EmitSound(const EntityId&amp; l_entity,
    const EntitySound&amp; l_sound, bool l_useId, bool l_relative,
    int l_checkFrame = -1);
  AudioManager* m_audioManager;
  SoundManager* m_soundManager;
};</pre></div><p>Apart from the typical methods that a system is required to implement and a few custom ones, we also <a id="id551" class="indexterm"/>have two data members that point to instances of the <code class="literal">AudioManager</code> and <code class="literal">SoundManager</code> classes. Let's begin actually implementing the sound system:</p><div><pre class="programlisting">S_Sound::S_Sound(SystemManager* l_systemMgr)
  : S_Base(System::Sound, l_systemMgr), m_audioManager(nullptr),
  m_soundManager(nullptr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::SoundEmitter);
  m_requiredComponents.push_back(req);
  req.ClearBit((unsigned int)Component::SoundEmitter);
  req.TurnOnBit((unsigned int)Component::SoundListener);
  m_requiredComponents.push_back(req);

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Direction_Changed, this);
  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Frame_Change, this);
}</pre></div><p>The constructor, predictably enough, sets up two possible versions of the requirement bitmask, both of which require the position component to be present. It then subscribes to the two message types we discussed previously.</p><p>Since we're going to need access to both the audio manager and sound manager, a method like this can definitely come in handy: </p><div><pre class="programlisting">void S_Sound::SetUp(AudioManager* l_audioManager, 
    SoundManager* l_soundManager)
{ 
    m_audioManager = l_audioManager;
    m_soundManager = l_soundManager;
}</pre></div><p>Next, let's take a jab at implementing the <code class="literal">Update</code> method:</p><div><pre class="programlisting">void S_Sound::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for (auto &amp;entity : m_entities){
    C_Position* c_pos = entities-&gt;
      GetComponent&lt;C_Position&gt;(entity, Component::Position);
    sf::Vector2f position = c_pos-&gt;GetPosition();
    unsigned int elevation = c_pos-&gt;GetElevation();

    bool IsListener = entities-&gt;
      HasComponent(entity, Component::SoundListener);
    if (IsListener){
      sf::Listener::setPosition(
        MakeSoundPosition(position, elevation));
    }

    if (!entities-&gt;HasComponent(
      entity, Component::SoundEmitter))
    {
      continue;
    }
    C_SoundEmitter* c_snd = entities-&gt;GetComponent&lt;C_SoundEmitter&gt;
      (entity,Component::SoundEmitter);
    if (c_snd-&gt;GetSoundID() == -1){ continue; }
    if (!IsListener){
      if (!m_soundManager-&gt;SetPosition(c_snd-&gt;GetSoundID(),
        MakeSoundPosition(position, elevation)))
      {
        c_snd-&gt;SetSoundID(-1);
      }
    } else {
      if (!m_soundManager-&gt;IsPlaying(c_snd-&gt;GetSoundID())){
        c_snd-&gt;SetSoundID(-1);
      }
    }
  }
}</pre></div><p>Each entity in this system first has its position and elevation obtained and stored inside a few local<a id="id552" class="indexterm"/> variables. It also determines if the current entity is the sound listener or not and stores that information inside a Boolean variable.</p><p>If the current entity has a sound emitter component and its sound ID is not equal to -1, it's safe to deduce that the sound is currently still being played. If the current entity is not a sound listener, we attempt to update the sound's position and catch the result of that in an <code class="literal">if</code> statement. If the position update fails, the sound ID is set back to -1, since it means the sound is no longer active. If the entity is, in fact, a listener, we don't need to update the sound's position at all. Instead, we determine if the sound is still playing or not by calling the <code class="literal">IsPlaying</code> method.</p><p>Afterwards, it's necessary to update the position of the <code class="literal">sf::Listener</code> class if the current entity has the listener component. Note the use of the <code class="literal">MakeSoundPosition</code> method here, as well as in the previous chunk of code. It returns a <code class="literal">sf::Vector3f</code> based on the position and elevation of an entity. We're going to cover this method shortly.</p><p>Let's work on handling both of the message types we've discussed previously next:</p><div><pre class="programlisting">void S_Sound::Notify(const Message&amp; l_message){
  if (!HasEntity(l_message.m_receiver)){ return; }
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  bool IsListener = entities-&gt;
    HasComponent(l_message.m_receiver, Component::SoundListener);
  EntityMessage m = (EntityMessage)l_message.m_type;
  switch (m){
  case EntityMessage::Direction_Changed:
  {
    if (!IsListener){ return; }
    Direction dir = (Direction)l_message.m_int;
    switch (dir){
    case Direction::Up: sf::Listener::setDirection(0, 0, -1);
      break;
    case Direction::Down: sf::Listener::setDirection(0, 0, 1);
      break;
    case Direction::Left: sf::Listener::setDirection(-1, 0, 0);
      break;
    case Direction::Right: sf::Listener::setDirection(1, 0, 0);
      break;
    }
  }
    break;
  case EntityMessage::Frame_Change:
    if (!entities-&gt;HasComponent(l_message.m_receiver,
      Component::SoundEmitter))
    {
      return;
    }
    EntityState state = entities-&gt;GetComponent&lt;C_State&gt;
      (l_message.m_receiver, Component::State)-&gt;GetState();
    EntitySound sound = EntitySound::None;
    if (state==EntityState::Walking){sound=EntitySound::Footstep;}
       else if(state == EntityState::Attacking){
         sound = EntitySound::Attack;
    } else if (state==EntityState::Hurt){sound=EntitySound::Hurt;}
    else if (state==EntityState::Dying){sound=EntitySound::Death;}
    if (sound == EntitySound::None){ return; }
    EmitSound(l_message.m_receiver, sound, false,
      IsListener, l_message.m_int);
    break;
  }
}</pre></div><p>In case the entity's direction has changed and it is the sound listener, we obviously need to change the direction of the <code class="literal">sf::Listener</code> to match the one that is carried inside the message. On the other hand, if we receive a message about a frame changing, the <code class="literal">EmitSound</code> method is called with the entity ID, sound type, two Boolean flags indicating whether the <a id="id553" class="indexterm"/>sound should loop and whether it should be relative to the listener or not, and the current frame the animation is in all passed in as arguments. The sound relativity to the listener in the scene is simply decided by whether the current entity itself is a listener or not.</p><p>Positioning sounds in space is also a huge part of this whole system working correctly. Let's take a look at the <code class="literal">MakeSoundPosition</code> method:</p><div><pre class="programlisting">sf::Vector3f S_Sound::MakeSoundPosition(
  const sf::Vector2f&amp; l_entityPos, unsigned int l_elevation)
{
  return sf::Vector3f(l_entityPos.x,
    l_elevation * Sheet::Tile_Size, l_entityPos.y);
}</pre></div><p>Due to the default up vector in SFML being the positive <em>Y</em> axis, the two dimensional coordinates of an entity position are passed in as X and Z arguments. Meanwhile, the <em>Y</em> argument is simply the entity's elevation multiplied by the <code class="literal">Tile_Size</code> value, found inside the <code class="literal">Map.h</code> header, which results in entity elevation simulating the height.</p><p>Last but definitely not least, we have a chunk of code that is responsible for entities emitting all their sounds that we need to take a look at:</p><div><pre class="programlisting">void S_Sound::EmitSound(const EntityId&amp; l_entity,
  const EntitySound&amp; l_sound, bool l_useId, bool l_relative,
  int l_checkFrame)
{
  if (!HasEntity(l_entity)){ return; }
  if (!m_systemManager-&gt;GetEntityManager()-&gt;
    HasComponent(l_entity, Component::SoundEmitter))
  {
    return;
  }
  // Is a sound emitter.
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  C_SoundEmitter* c_snd = entities-&gt;GetComponent&lt;C_SoundEmitter&gt;
    (l_entity, Component::SoundEmitter);
  if (c_snd-&gt;GetSoundID() != -1 &amp;&amp; l_useId){ return; }
  // If sound is free or use of ID isn't required.
  if (l_checkFrame != -1 &amp;&amp;
    !c_snd-&gt;IsSoundFrame(l_sound, l_checkFrame))
  {
    return;
  }
  // Frame is irrelevant or correct.
  C_Position* c_pos = entities-&gt;
    GetComponent&lt;C_Position&gt;(l_entity, Component::Position);
  sf::Vector3f pos = (l_relative ?
    sf::Vector3f(0.f, 0.f, 0.f) :
    MakeSoundPosition(c_pos-&gt;GetPosition(),
    c_pos-&gt;GetElevation()));
  if (l_useId){
    c_snd-&gt;SetSoundID(m_soundManager-&gt;
      Play(c_snd-&gt;GetSound(l_sound), pos));
  } else {
    m_soundManager-&gt;Play(c_snd-&gt;GetSound(l_sound),
      pos, false, l_relative);
  }
}</pre></div><p>The first task<a id="id554" class="indexterm"/> is obviously checking if the sound system has an entity with the provided ID, and if the entity is a sound emitter. If it is, the sound emitter component is obtained and the sound ID it stores is checked for being equal to -1. The code still proceeds, however, if an entity is already emitting another sound but the <code class="literal">l_useId</code> argument is set to <code class="literal">false</code>, which tells us that a sound should be emitted regardless. Next, the frame passed in as an argument is checked for either being equal to -1, which means the sound should be played regardless, or for it being one of the sound frames defined inside the sound emitter component.</p><p>Once we commit to playing the sound, the entity's position component is obtained and used to calculate the position of the sound. If it should be relative to the listener, the position is simply set to be at the absolute zero coordinate of all axes.</p><p>If we want to only keep a single instance of a particular sound, the <code class="literal">Play</code> method of the sound manager is invoked within the <code class="literal">SetSoundID</code> argument list of the sound emitter component to catch the returned ID. It only has two arguments passed in, as the other two Boolean flags hold the default values of <code class="literal">false</code>. Otherwise, if this particular sound should be played irrespective of whether the entity is already emitting another sound or not, the <code class="literal">Play</code> method of our sound manager is called by itself and the Boolean flag for sound being relative to the listener is passed in as the last argument.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec111"/>Integrating our code</h1></div></div></div><p>In <a id="id555" class="indexterm"/>order to prevent sounds or music from playing at inappropriate times, our state manager must notify the sound manager of any state changes:</p><div><pre class="programlisting">void StateManager::SwitchTo(const StateType&amp; l_type){
  ...
  m_shared-&gt;m_soundManager-&gt;ChangeState(l_type);
  ...
}</pre></div><p>Since the <a id="id556" class="indexterm"/>sound manager also cares about states being removed, let's tell it when that happens:</p><div><pre class="programlisting">void StateManager::RemoveState(const StateType&amp; l_type){
  for (auto itr = m_states.begin();
    itr != m_states.end(); ++itr)
  {
    if (itr-&gt;first == l_type){
      ...
      m_shared-&gt;m_soundManager-&gt;RemoveState(l_type);
      return;
    }
  }
}</pre></div><p>The only thing we have left to do now is actually integrating everything we worked on into the rest of our code base, starting with <code class="literal">SharedContext.h</code>:</p><div><pre class="programlisting">...
#include "AudioManager.h"
#include "SoundManager.h"
...
struct SharedContext{
    SharedContext():
        ...
        m_audioManager(nullptr),
        m_soundManager(nullptr),
        ...
        {}

    ...
    AudioManager* m_audioManager;
    SoundManager* m_soundManager;
    ...
};</pre></div><p>Next, instantiating and managing these two new classes inside the shared context is of utmost importance. Let's start by modifying the <code class="literal">Game.h</code> header:</p><div><pre class="programlisting">class Game{
public:
    ...
private:
    ...
    AudioManager m_audioManager;
    SoundManager m_soundManager;
    ...
};</pre></div><p>As always, we<a id="id557" class="indexterm"/> keep these manager classes inside <code class="literal">Game</code> in order to manage their lifetime properly. For some of them, however, merely existing isn't enough. They require to be set up like this:</p><div><pre class="programlisting">Game::Game(): ..., m_soundManager(&amp;m_audioManager)
{
  ...
  m_context.m_audioManager = &amp;m_audioManager;
  m_context.m_soundManager = &amp;m_soundManager;
  ...
  m_systemManager.GetSystem&lt;S_Sound&gt;(System::Sound)-&gt;
    SetUp(&amp;m_audioManager, &amp;m_soundManager);
  ...
}</pre></div><p>After both classes are created, their addresses are passed to the shared context. One more important detail that's easy to overlook is actually setting up the sound system at this point. It needs to have access to both the audio and the sound manager.</p><p>Let's not forget to also update the sound manager properly during the flow of the entire application:</p><div><pre class="programlisting">void Game::Update(){
    ...
    m_soundManager.Update(m_elapsed.asSeconds());
    ...
}</pre></div><p>With the creation of new components and systems comes the responsibility of making sure they can actually be created automatically, by adding the component types to the entity manager:</p><div><pre class="programlisting">EntityManager::EntityManager(SystemManager* l_sysMgr, 
  TextureManager* l_textureMgr): ...
{
  ...
  AddComponentType&lt;C_SoundEmitter&gt;(Component::SoundEmitter);
  AddComponentType&lt;C_SoundListener&gt;(Component::SoundListener);
}</pre></div><p>Our sound system also needs to be created inside the system manager:</p><div><pre class="programlisting">SystemManager::SystemManager():...{
  ...
  m_systems[System::Sound] = new S_Sound(this);
}</pre></div><p>Having all <a id="id558" class="indexterm"/>of that done, we can finally add some music to our game! Let's start by making sure we have an intro soundtrack by modifying <code class="literal">State_Intro.cpp</code>:</p><div><pre class="programlisting">void State_Intro::OnCreate(){
    ...
    m_stateMgr-&gt;GetContext()-&gt;m_soundManager-&gt;
        PlayMusic("Electrix", 100.f, true);
}</pre></div><p>Also, it would be nice to have some background music during actual game-play, so let's modify <code class="literal">State_Game.cpp</code> as follows:</p><div><pre class="programlisting">void State_Game::OnCreate(){
    ...
    m_stateMgr-&gt;GetContext()-&gt;m_soundManager-&gt;
        PlayMusic("TownTheme", 50.f, true);
}</pre></div><p>And voila! Just like that, we now have music and dynamic sound effects baked into our RPG!</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec112"/>Summary</h1></div></div></div><p>With possibilities ranging anywhere from simple ambiance to complex musical scores tugging at the heart strings of the player, our game world starts to develop a sense of character and presence. All of the hard work we put in towards making sure our project isn't mute adds up to yet another major leap in the direction of quality. However, as we begin to approach the end of this book with only two chapters remaining, the most challenging part is still yet to come.</p><p>In the next chapter, we will be exploring the vast world of networking and how it can help us turn our lonely, quiet RPG into a battle zone of multiple other players. See you there!</p></div></body></html>