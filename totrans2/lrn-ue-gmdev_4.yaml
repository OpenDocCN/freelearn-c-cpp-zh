- en: Chapter 4. Material and Light
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 材质与照明
- en: In this chapter, we will learn in detail about the materials and the lights
    in Unreal Engine 4\. We have grouped both Material and Light together in this
    chapter because how an object looks is largely determined by both—material and
    lighting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细了解虚幻引擎4中的材质和灯光。我们将材质和灯光一起放在本章中，因为一个对象的外观很大程度上是由这两者——材质和照明——决定的。
- en: Material is what we apply to the surface of an object and it affects how the
    object looks in the game. Material/Shader programming is a hot ongoing research
    topic as we always strive to improve the texture performance—seeking higher graphic
    details/realism/quality with limited CPU/GPU rendering power. Researchers in this
    area need to find ways to make the models we have in a game look as real as possible,
    with as little calculations/data size as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 材质是我们应用到对象表面的东西，它影响对象在游戏中的外观。材质/着色器编程是一个热门的研究课题，因为我们总是努力提高纹理性能——在有限的CPU/GPU渲染能力下寻求更高的图形细节/真实感/质量。该领域的学者需要找到方法，使我们在游戏中拥有的模型尽可能真实，同时尽可能减少计算/数据量。
- en: Lighting is also a very powerful tool in world creation. There are many uses
    of light. Lights can create a mood for the level. When effectively used, it can
    be used to focus attention on objects in the level and guide players through your
    level. Light also creates shadow. In a game level, shadow needs to be created
    artificially. Hence, we will also learn how we get shadows rendered appropriately
    for our game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 照明也是世界创建中的一个非常强大的工具。照明有许多用途。照明可以创造一个关卡的氛围。当有效地使用时，它可以用来聚焦关卡中的对象，并引导玩家通过你的关卡。照明也创造阴影。在游戏关卡中，阴影需要人工创建。因此，我们还将学习如何适当地渲染我们的游戏中的阴影。
- en: Materials
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质
- en: In the previous chapter, we briefly touched on what a material is and what a
    texture is. A texture is like a simple image file in the format of `.png`/`.tga`.
    A material is a combination of different elements, including textures to create
    a surface property that we apply to our objects in the game. We have also briefly
    covered what UV coordinates are and how we use them to apply a 2D texture to the
    surface of a 3D object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了材质和纹理是什么。纹理就像一个简单的`.png`/`.tga`格式的图像文件。材质是由不同元素组合而成的，包括纹理，以创建我们应用到游戏对象上的表面属性。我们还简要介绍了UV坐标是什么以及我们如何使用它们将2D纹理应用到3D对象的表面上。
- en: So far, we have only learned how to apply materials that are available in the
    default Unreal Engine. In this chapter, we will dive deeper into how we can actually
    create our own custom material in Unreal Engine 4\. Fundamentally, the material
    creation for the objects falls into the scope of an artist. For special customized
    textures, they are sometimes hand painted by 2D artists using tools such as Photoshop
    or taken from photographs of textures from the exact objects we want, or similar
    objects. Textures can also be tweaked from existing texture collection to create
    the customized material that is needed for the 3D models. Due to the vast number
    of realistic textures needed, textures are sometimes also generated algorithmically
    by the programmers to allow more control over its final look. This is also an
    important research area for the advancing materials for computer graphics.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只学习了如何应用虚幻引擎默认提供的材质。在本章中，我们将深入探讨如何在虚幻引擎4中实际创建我们自己的自定义材质。从根本上说，对象的材质创建属于艺术家的范畴。对于特殊的定制纹理，它们有时由2D艺术家使用Photoshop等工具手工绘制，或者从我们想要的精确对象的纹理照片中获取，或者从类似对象中获取。纹理也可以从现有的纹理集合中进行调整，以创建所需的用于3D模型的定制材质。由于需要大量的真实纹理，程序员有时也会通过算法生成纹理，以便更好地控制其最终外观。这也是计算机图形学中材料进步的一个重要研究领域。
- en: Material manipulation here falls under the scope of a specialized group of programmers
    known as **graphic programmers**. They are sometimes also researchers that look
    into ways to better compress texture, improve rendering performance, and create
    special dynamic material manipulation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的材质操作属于被称为**图形程序员**的专门程序员群体的范畴。他们有时也是研究人员，研究如何更好地压缩纹理、提高渲染性能以及创建特殊的动态材质操作。
- en: The Material Editor
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质编辑器
- en: In Unreal Engine 4, material manipulation can be achieved using the Material
    Editor. What this editor offers is the ability to create material expressions.
    Material expressions work together to create an overall surface property for the
    material. You can think of them as mathematical formulas that add/multiply together
    to affect the properties of a material. The Material Editor makes it easy to edit/formulate
    material expressions to create customized material and provides the capability
    to quickly preview the changes in the game. Through Unreal's Blueprint capabilities
    and programming, we can also achieve dynamic manipulation of materials as needed
    by the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，可以通过材质编辑器来实现材质操作。这个编辑器提供的是创建材质表达式的功能。材质表达式协同工作，为材质创建一个整体表面属性。你可以把它们看作是数学公式，通过相加/相乘来影响材质的属性。材质编辑器使得编辑/制定材质表达式变得容易，以创建定制的材质，并提供快速预览游戏中的更改的能力。通过虚幻的蓝图功能和编程，我们还可以根据游戏需求动态地操作材质。
- en: The rendering system
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染系统
- en: The rendering system in Unreal Engine 4 uses the DirectX 11 pipeline, which
    includes deferred shading, global illumination, lit translucency, and post processing.
    Unreal Engine 4 has also started branching to work with the newest DirectX 12
    pipeline for Windows 10, and DirectX 12 capabilities will be available to all.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎4中的渲染系统使用DirectX 11管线，包括延迟着色、全局照明、自发光透明度和后期处理。虚幻引擎4也开始分支以支持最新的DirectX 12管线，适用于Windows
    10，DirectX 12功能将对所有用户可用。
- en: Physical Based Shading Model
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于物理的着色模型
- en: 'Unreal Engine 4 uses the **Physical Based Shading Model** (**PBSP**). This
    is a concept used in many modern day game engines. It uses an approximation of
    what light does in order to give an object its properties. Using this concept,
    we give values (0 to 1) to these four properties: **Base Color**, **Roughness**,
    **Metallic**, and **Specular** to approximate the visual properties.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎4使用**基于物理的着色模型**（**PBSP**）。这是一个在许多现代游戏引擎中使用的概念。它使用对光的行为的近似来赋予物体属性。使用这个概念，我们给这四个属性赋予值（0到1）：**基础颜色**、**粗糙度**、**金属度**和**高光**，以近似视觉属性。
- en: For example, the bark of a tree trunk is normally brown, rough, and not very
    reflective. Based on what we know about how the bark should look like, we would
    probably set the metallic value to low value, roughness to a high value, and the
    base color to display brown with a low specular value.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，树干的树皮通常是棕色、粗糙且不太反光的。根据我们对树皮外观的了解，我们可能会将金属值设置为低值，粗糙度设置为高值，并将基础颜色设置为显示棕色，具有低高光值。
- en: This improves the process of creating materials as it is more intuitive as visual
    properties are governed by how light reacts, instead of the old method where we
    approximate the visual properties based on how light should behave.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这改善了创建材质的过程，因为它更直观，因为视觉属性是由光如何反应来控制的，而不是像旧方法那样，我们根据光应该如何行为来近似视觉属性。
- en: For those who are familiar with the old terms used to describe material properties,
    you can think of it as having **Diffuse Color** and **Specular Power** replaced
    by **Base Color**, **Metallic**, and **Roughness**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉描述材质属性的老术语的人来说，你可以把它看作是**漫反射颜色**和**高光强度**被**基础颜色**、**金属度**和**粗糙度**所取代。
- en: The advantage of using PBSP is that we can better approximate material properties
    with more accuracy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PBSP的优势在于我们可以更准确地近似材质属性。
- en: High Level Shading Language
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级着色语言
- en: The Material Editor enables visual scripting of the **High Level Shading Language**
    (**HLSL**), using a network of nodes and connection. Those who are completely
    new to the concept of shaders or HLSL should go on to read the next section about
    shaders, DirectX and HLSL first, so that you have the basic foundation on how
    the computer renders material information on the screen. HLSL is aproprietary
    shading language developed by Microsoft. OpenGL has its own version, known as
    GLSL. HLSL is the programming language used to program the stages in the graphics
    pipeline. It uses variables that are similar to C programming and has many intrinsic
    functions that are already written and available for use by simply calling the
    function.HLSL shaders can be compiled at author-time or at runtime, and set at
    runtime into the appropriate pipeline stage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 材质编辑器允许使用节点网络和连接进行高级着色语言（**HLSL**）的可视化脚本。对于那些对着色器或HLSL概念完全陌生的人来说，应该先阅读下一节关于着色器、DirectX和HLSL的内容，以便您对计算机如何在屏幕上渲染材质信息有基本了解。HLSL是由微软开发的一种专有着色语言。OpenGL有自己的版本，称为GLSL。HLSL是用于编程图形管道中各个阶段的编程语言。它使用与C编程类似的变量，并有许多已编写和可供使用的内置函数。HLSL着色器可以在作者时间或运行时编译，并在运行时设置到适当的管道阶段。
- en: Getting started
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: To open the Material Editor in Unreal Engine 4, go to **Content Browser** |
    **Material** and double-click on any material asset. Alternatively, you can select
    a material asset, right-click to open the context menu and select **Edit** to
    view that asset in the Material Editor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中打开材质编辑器，请转到**内容浏览器** | **材质**，然后双击任何材质资产。或者，您可以选择一个材质资产，右键单击以打开上下文菜单，并选择**编辑**来在材质编辑器中查看该资产。
- en: If you want to learn how to create a new material, you can try out the example,
    which is covered in the upcoming section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想学习如何创建新的材质，您可以在即将到来的部分中尝试示例。
- en: Creating a simple custom material
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建简单的自定义材质
- en: We will continue to use the levels we have created. Open `Chapter3Level.umap`
    and rename it `Chapter4Level.umap` to prevent overwriting what we have completed
    at the end of the previous chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们创建的关卡。打开`Chapter3Level.umap`并将其重命名为`Chapter4Level.umap`，以防止覆盖前一章结尾处我们已完成的内容。
- en: To create a new Material asset in our game package, go to **Content Browser**
    | **Material**. With **Material** selected, right-click to open the contextual
    menu, navigate to **New Asset** | **Material**. This creates the new material
    in the `Material` folder (we want to place assets in logical folders so that we
    can find game assets easily). Alternatively, you can go to **Content Browser**
    | **New** | **Material**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏包中创建新的材质资产，请转到**内容浏览器** | **材质**。选择**材质**后，右键单击以打开上下文菜单，导航到**新资产** |
    **材质**。这将在`材质`文件夹中创建新的材质（我们希望将资产放在逻辑文件夹中，以便我们能够轻松找到游戏资产）。或者，您也可以转到**内容浏览器** |
    **新** | **材质**。
- en: '![Creating a simple custom material](img/B03679_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的自定义材质](img/B03679_04_01.jpg)'
- en: 'Rename the new material to `MyMaterial`. The following screenshot shows the
    new **MyMaterial** correctly created:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将新材质重命名为`MyMaterial`。以下截图显示了正确创建的新的**MyMaterial**：
- en: '![Creating a simple custom material](img/B03679_04_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的自定义材质](img/B03679_04_02.jpg)'
- en: Note that the thumbnail display for the new **MyMaterial** shows a grayed-out
    checkered material. This is the default material when no material has been applied.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，新**MyMaterial**的缩略图显示为灰色的棋盘图案材质。这是未应用任何材质时的默认材质。
- en: To open the Material Editor to start designing our material, double-click on
    **MyMaterial**. The following screenshot shows the Material Editor with a blank
    new material. The spherical preview of the material shows up as black since no
    properties have been defined yet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开材质编辑器开始设计我们的材质，双击**MyMaterial**。以下截图显示了带有空白新材质的材质编辑器。由于尚未定义任何属性，材质的球形预览显示为黑色。
- en: '![Creating a simple custom material](img/B03679_04_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的自定义材质](img/B03679_04_03.jpg)'
- en: Let's start to define some properties for the **MyMaterial** node to create
    our very own unique material. **Base Color**, **Metallic**, and **Roughness**
    are the three values we will learn to configure first.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为**MyMaterial**节点定义一些属性，以创建我们自己的独特材质。"基础颜色"、"金属"和"粗糙度"是我们将首先学习的三个值。
- en: '**Base Color** is defined by the red, green, and blue values in the form of
    a vector. To do so, we will drag and drop **Constant3Vector** from **MyPalette**
    on the right-hand side into the main window where the **MyMaterial** node is in.
    Alternatively, you can right-click to open the context menu and type `vector`
    into the search box to filter the list. Click and select **Constant3Vector** to
    create the node. Double-click on the **Constant3Vector** to display the **Color
    Picker** window. The following screenshot shows the setting of **Constant3Vector**
    we want to use to create a material for a red wall. (**R** = **0.4**, **G** =
    **0.0**, **B** = **0.0**, **H** = **0.0**, **S** = **1.0**, **V** = **0.4**):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础颜色**由红、绿、蓝的向量形式定义。为此，我们将从右侧的**MyPalette**拖放**Constant3Vector**到主窗口中，其中包含**MyMaterial**节点。或者，您也可以右键单击以打开上下文菜单，并在搜索框中输入`vector`以过滤列表。点击并选择**Constant3Vector**以创建节点。双击**Constant3Vector**以显示**颜色选择器**窗口。以下截图显示了我们要用于创建红色墙面材质的**Constant3Vector**设置。（**R**
    = **0.4**，**G** = **0.0**，**B** = **0.0**，**H** = **0.0**，**S** = **1.0**，**V**
    = **0.4**）：'
- en: '![Creating a simple custom material](img/B03679_04_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的自定义材质](img/B03679_04_04.jpg)'
- en: Connect the **Constant3Vector** to the **MyMaterial** node as shown in the following
    screenshot by clicking and dragging from the small circle from the **Constant3Vector**
    node to the small circle next to the **Base Color** property in the **MyMaterial**
    node. This **Constant3Vector** node now provides the base color to the material.
    Notice how the spherical preview on the left updates to show the new color. If
    the color is not updated automatically, make sure that the **Live Preview** setting
    on the top ribbon is selected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下截图所示，通过点击并拖动从**Constant3Vector**节点的小圆圈到**MyMaterial**节点旁边**基础颜色**属性的小圆圈来将**Constant3Vector**连接到**MyMaterial**节点。这个**Constant3Vector**节点现在为材质提供基础颜色。注意左边的球形预览如何更新以显示新的颜色。如果颜色没有自动更新，请确保顶部的工具栏上的**实时预览**设置被选中。
- en: '![Creating a simple custom material](img/B03679_04_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的自定义材质](img/B03679_04_05.jpg)'
- en: 'Now, let us set the **Metallic** value for the material. This property takes
    a numerical value from 0 to 1, where 1 is for a 100% metal. To create an input
    for a value, click and drag **Constant** from **MyPalette** or right-click in
    the Material Editor to open the menu; type in `Constant` into the search box to
    filter and select **Constant** from the filtered list. To edit the value in the
    constant, click on the **Constant** node to display the **Details** window and
    fill in the value. The following screenshot shows how the material would look
    if **Metallic** is set to 1:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置材质的**金属度**值。这个属性接受从0到1的数值，其中1代表100%的金属。要为值创建输入，请从**MyPalette**点击并拖动**Constant**，或者在材质编辑器中右键单击以打开菜单；在搜索框中输入`Constant`以过滤并从过滤列表中选择**Constant**。要编辑常量中的值，请单击**Constant**节点以显示**详细信息**窗口并填写值。以下截图显示了如果**金属度**设置为1时材质的外观：
- en: '![Creating a simple custom material](img/B03679_04_06.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的自定义材质](img/B03679_04_06.jpg)'
- en: 'After seeing how the **Metallic** value affects the material, let us see what
    **Roughness** does. **Roughness** also takes a **Constant** value from 0 to 1,
    where 0 is completely smooth and makes the surface very reflective. The left-hand
    screenshot shows how the material looks when **Roughness** is set to 0, whereas
    the right-hand screenshot shows how the material will look when **Roughness**
    is set to 1:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到**金属度**值如何影响材质后，让我们看看**粗糙度**会做什么。**粗糙度**也接受从0到1的**Constant**值，其中0是完全光滑的，使表面非常反光。左侧的截图显示了当**粗糙度**设置为0时材质的外观，而右侧的截图显示了当**粗糙度**设置为1时材质的外观：
- en: '![Creating a simple custom material](img/B03679_04_07.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的自定义材质](img/B03679_04_07.jpg)'
- en: 'We want to use this new material to texture the walls. So, we have set **Metallic**
    as **0.3** and **Roughness** as **0.7**. The following screenshot shows the final
    settings we have for our first custom material:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用这种新材料来纹理墙面。因此，我们将**金属度**设置为**0.3**，将**粗糙度**设置为**0.7**。以下截图显示了我们对第一个自定义材质的最终设置：
- en: '![Creating a simple custom material](img/B03679_04_08.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的自定义材质](img/B03679_04_08.jpg)'
- en: 'Go to **MyMaterial** in **Content Browser** and duplicate **MyMaterial**. Rename
    it `MyWall_Grey`. Change the base color to gray using the following values as
    shown in the picker node for the **Constant3Vector** value for **Base Color**.
    (**R** = **0.185**, **G** = **0.185**, **B** = **0.185**, **H** = **0.0**, **S**
    = **0.0**, **V** = **0.185**):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '前往**内容浏览器**中的**MyMaterial**并复制**MyMaterial**。将其重命名为`MyWall_Grey`。使用以下值将基础颜色更改为灰色，如选择器节点中所示，用于**Base
    Color**的**Constant3Vector**值。（**R** = **0.185**, **G** = **0.185**, **B** = **0.185**,
    **H** = **0.0**, **S** = **0.0**, **V** = **0.185**）:'
- en: '![Creating a simple custom material](img/B03679_04_09.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的自定义材质](img/B03679_04_09.jpg)'
- en: 'The following screenshot shows the links for the **MyWall_Grey** node. (**Metallic**
    = **0.3**, **Roughness** = **0.7**):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '以下截图显示了**MyWall_Grey**节点的链接。（**Metallic** = **0.3**, **Roughness** = **0.7**）:'
- en: '![Creating a simple custom material](img/B03679_04_10.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的自定义材质](img/B03679_04_10.jpg)'
- en: Creating custom material using simple textures
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单纹理创建自定义材质
- en: To create a material using textures, we must first select a texture that is
    suitable. Textures can be created by artists or taken from photos of materials.
    For learning purposes, you can find suitable free source images from the Web,
    such as [www.textures.com](http://www.textures.com), and use them. Remember to
    check for conditions of usage and other license-related clauses, if you plan to
    publish it in a game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用纹理创建材质，我们必须首先选择一个合适的纹理。纹理可以由艺术家创建或从材料的照片中获取。为了学习目的，你可以从网络中找到合适的免费源图像，例如[www.textures.com](http://www.textures.com)，并使用它们。如果你计划在游戏中发布，请记住检查使用条件和其他与许可证相关的条款。
- en: There are two types of textures we need for a custom material using a simple
    texture. First, the actual texture that we want to use. For now, let us keep this
    selection simple and straightforward. Select this texture based on the color and
    it should have the overall properties of what you want the material to look like.
    Next, we need a normal texture. If you still remember what a normal map is, it
    controls the bumps on a surface. The normal map gives the grooves in a material.
    Both of these textures will work together to give you a realistic-looking material
    that you can use in your game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个简单的纹理来创建自定义材质。首先，我们需要使用的实际纹理。目前，让我们保持这个选择简单直接。根据颜色选择这个纹理，它应该具有你希望材质看起来具有的整体属性。接下来，我们需要一个法线纹理。如果你还记得什么是法线图，它控制着表面的凹凸。法线图给出了材质中的凹槽。这两种纹理将共同工作，为你提供一个看起来逼真的材质，你可以在游戏中使用。
- en: In this example, we will create another wood texture that we will use to replace
    the wood texture from the default package that we have already applied in the
    room.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建另一个木纹纹理，我们将用它来替换房间中已经应用的自定义包中的木纹。
- en: Here, we will start first by importing the textures that we need in Unreal Engine.
    Go to **Content Browser** | **Textures**. Then click on the **Import** button
    at the top. This opens up a window to browse to the location of your texture.
    Navigate to the folder location where your texture is saved, select the texture
    and click on **Open**. Note that if you are importing textures that are not in
    the power of two (256 x 256, 1024 x 1024, and so on), you would have a warning
    message. Textures that are not in the power of two should be avoided due to poor
    memory usage. If you are importing the example images that I am using, they are
    already converted to the power of two so you would not get this warning message
    on screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将首先导入在Unreal Engine中需要的纹理。前往**内容浏览器** | **纹理**。然后点击顶部的**导入**按钮。这会打开一个窗口，用于浏览纹理的位置。导航到保存纹理的文件夹位置，选择纹理并点击**打开**。注意，如果你导入的不是2的幂（256
    x 256、1024 x 1024等）的纹理，你会收到一个警告消息。由于内存使用效率低下，应避免使用不是2的幂的纹理。如果你导入的是我使用的示例图像，它们已经转换为2的幂，因此你不会在屏幕上收到此警告消息。
- en: Import both **T_Wood_Light** and **T_Wood_Light_N**. **T_Wood_Light** will be
    used as the main texture, we want to have, and **T_Wood_Light_N** is the normal
    map texture, which we will use for this wood.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 导入**T_Wood_Light**和**T_Wood_Light_N**。**T_Wood_Light**将用作我们想要的主体纹理，而**T_Wood_Light_N**是法线图纹理，我们将用它来处理这种木材。
- en: Next, we follow the same steps to create a new material, as in the previous
    example. Go to **Content Browser** | **Material**. With the **Material** folder
    selected, to open the contextual menu, navigate to **New Asset** | **Material**.
    Rename the new material `MyWood`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照前面的步骤创建一个新的材料，如前例所示。转到**内容浏览器** | **材料**。选择**材料**文件夹，打开上下文菜单，导航到**新资产**
    | **材料**。将新材料重命名为`MyWood`。
- en: Now, instead of selecting **Constant3Vector** to provide values to the base
    color, we will use **TextureSample**. Go to **MyPalette** and type in `Texture`
    to filter the list. Select **TextureSample**, drag and drop it into the Material
    Editor. Click on the **TextureSample** node to display the **Details** panel,
    as shown in the following screenshot. On the **Details** panel, go to **Material
    Expression Texture Base** and click on the small arrow next to it. This opens
    up a popup with all the suitable assets that you can use. Scroll down to select
    **T_Wood_Light**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再选择**Constant3Vector**来提供基础颜色的值，而是使用**TextureSample**。转到**MyPalette**并输入`Texture`以过滤列表。选择**TextureSample**，将其拖放到材质编辑器中。单击**TextureSample**节点以显示**详细信息**面板，如图所示。在**详细信息**面板中，转到**材质表达式纹理基础**并单击其旁边的小箭头。这会弹出一个包含所有可用的合适资产的弹出窗口。向下滚动以选择**T_Wood_Light**。
- en: '![Creating custom material using simple textures](img/B03679_04_11.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用简单纹理创建自定义材料](img/B03679_04_11.jpg)'
- en: Now, we have configured **TextureSample** with the wood texture that we have
    imported into the editor earlier. Connect **TextureSample** by clicking on the
    white hollow circle connector, dragging it and dropping it on the **Base Color**
    connector on the **MyWood** node.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经配置了**TextureSample**，使用的是我们之前导入到编辑器中的木纹。通过单击白色空心圆连接器，将其拖动并放置在**MyWood**节点的**Base
    Color**连接器上。
- en: Repeat the same steps to create a **TextureSample** node for the **T_Wood_Light_N**
    normal map texture and connect it to the **Normal** input for **MyWood**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的步骤创建一个用于**T_Wood_Light_N**法线贴图纹理的**TextureSample**节点，并将其连接到**MyWood**的**Normal**输入。
- en: 'The following screenshot shows the settings that we want to have for **MyWood**.
    To have a little glossy feel for our wood texture, set **Roughness** to **0.2**
    by using a **Constant** node. (Recap: drag and drop a **Constant** node from **MyPalette**
    and set the value to **0.2**, connect it to the **Roughness** input of **MyWood**.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们要为**MyWood**设置的参数。为了使我们的木纹有一点光泽感，使用**Constant**节点将**Roughness**设置为**0.2**。（回顾：从**MyPalette**拖放一个**Constant**节点并将其值设置为**0.2**，连接到**MyWood**的**Roughness**输入。）
- en: '![Creating custom material using simple textures](img/B03679_04_12.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用简单纹理创建自定义材料](img/B03679_04_12.jpg)'
- en: Using custom materials to transform the level
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义材料来转换级别
- en: Using the custom materials that we have created in the previous two examples,
    we will replace the current materials that we have used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在前两个示例中创建的自定义材料，我们将替换当前使用的材料。
- en: The following screenshot shows the before and after look of the first room.
    Notice how the new custom materials have transformed the room into a modern looking
    room.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了第一个房间的前后对比。注意新自定义材料如何将房间转换成现代风格的房间。
- en: '![Using custom materials to transform the level](img/B03679_04_13.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义材料来转换级别](img/B03679_04_13.jpg)'
- en: 'From the preceding screenshot, we also have added a Point Light and placed
    it onto the lamp prop, making it seem to be emitting light. The following screenshot
    shows the Point Light setting we have used (**Light Intensity** = **1000.0**,
    **Attenuation Radius** = **1000.0**):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，我们还添加了一个点光源并将其放置在灯具道具上，使其看起来像是在发光。以下截图显示了我们所使用的点光源设置（**Light Intensity**
    = **1000.0**，**Attenuation Radius** = **1000.0**）：
- en: '![Using custom materials to transform the level](img/B03679_04_14.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义材料来转换级别](img/B03679_04_14.jpg)'
- en: Next, we added a ceiling to cover up the room. The ceiling of the wall uses
    the same box geometry as the rest of the walls. We have applied the **M_Basic_Wall**
    material onto it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个天花板来覆盖房间。墙壁的天花板使用与墙壁相同的盒子几何形状。我们已将**M_Basic_Wall**材料应用到其上。
- en: Then, we use the red wall material (**MyMaterial**) to replace the material
    on wall with the door frame. The gray wall material (**MyWall_Grey**) is used
    to replace the brick material for the walls at the side. The glossy wood material
    (**MyWood**) is used to replace the wooden floor material.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用红色墙壁材料（**MyMaterial**）来替换带有门框的墙壁上的材料。灰色墙壁材料（**MyWall_Grey**）用于替换侧面墙壁的砖材料。光泽木材料（**MyWood**）用于替换木地板材料。
- en: Rendering pipeline
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染管线
- en: For an image to appear on the screen, the computer must draw the images on the
    screen to display it. The sequence of steps to create a 2D representation of a
    scene by using both 2D and 3D data information is known as the graphics or rendering
    pipeline. Computer hardware such as **central processing unit** (**CPU**) and
    **graphics processing unit** (**GPU**) are used to calculate and manipulate the
    input data needed for drawing the 3D scene.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图像出现在屏幕上，计算机必须在屏幕上绘制图像以显示它。通过使用2D和3D数据信息创建场景的2D表示的步骤序列被称为图形或渲染管线。计算机硬件，如**中央处理器**（**CPU**）和**图形处理器**（**GPU**），用于计算和操纵绘制3D场景所需的输入数据。
- en: As games are interactive and rely heavily on real-time rendering, the amount
    of data necessary for rendering moving scenes is huge. Coordinate position, color,
    and all display information needs to be calculated for each vertex of the triangle
    polygon and at the same time, taking into account the effect of overlapping polygons
    before they can be displayed on screen correctly. Hence, it is very crucial to
    optimize both the CPU and GPU capabilities to process this data and deliver them
    timely on the screen. Continuous improvement in this area has been made over the
    years to allow better quality images to be rendered at higher frame rates for
    a better visual effect. At this point, games should run at a minimum frame rate
    of 30fps in order for players to have a reasonable gaming experience.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏是交互式的，并且高度依赖于实时渲染，因此渲染移动场景所需的数据量很大。需要计算三角形多边形的每个顶点的坐标位置、颜色以及所有显示信息，同时考虑到在它们正确显示在屏幕上之前重叠多边形的影响。因此，优化CPU和GPU的能力以处理这些数据并及时在屏幕上显示它们至关重要。多年来，这一领域一直在不断改进，以允许以更高的帧率渲染出更高品质的图像，从而获得更好的视觉效果。在此阶段，游戏应至少以30fps的帧率运行，以便玩家获得合理的游戏体验。
- en: The rendering pipeline today uses a series of programmable shaders to manipulate
    information about an image before displaying the image on the screen. We'll cover
    shaders and Direct3D 11 graphics pipeline in more detail in the upcoming section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的渲染管线使用一系列可编程着色器来操纵图像信息，在屏幕上显示图像之前。我们将在下一节中更详细地介绍着色器和Direct3D 11图形管线。
- en: Shaders
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: Shaders can be thought of as a sequence of programming codes that tells a computer
    how an image should be drawn. Different shaders govern different properties of
    an image. For example, Vertex Shaders give properties such as position, color,
    and UV coordinates for individual vertices. Another important purpose of vertex
    shaders is to transform vertices with 3D coordinates into the 2D screen space
    for display. Pixel shaders processes pixels to provide color, z-depth, and alpha
    value information. Geometry shader is responsible for processing data at the level
    of a primitive (triangle, line, and vertex).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器可以被视为一系列编程代码的序列，它告诉计算机如何绘制图像。不同的着色器控制图像的不同属性。例如，顶点着色器为单个顶点提供诸如位置、颜色和UV坐标等属性。顶点着色器的另一个重要目的是将具有3D坐标的顶点转换成2D屏幕空间以便显示。像素着色器处理像素以提供颜色、z深度和alpha值信息。几何着色器负责处理原始数据（三角形、线和顶点）级别的数据。
- en: Data information from an image is passed from one shader to the next for processing
    before they are finally output through a frame buffer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的数据信息从一个个着色器传递到下一个着色器进行处理，最终通过帧缓冲区输出。
- en: Shaders are also used to incorporate post-processing effects such as Volumetric
    Lighting, HDR, and Bloom effects to accentuate images in a game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器还用于结合后处理效果，如体积光照、HDR和光晕效果，以增强游戏中的图像。
- en: The language which shaders are programmed in depends on the target environment.
    For Direct3D, the official language is HLSL. For OpenGL, the official shading
    language is **OpenGL Shading Language** (**GLSL**).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器编程所使用的语言取决于目标环境。对于Direct3D，官方语言是HLSL。对于OpenGL，官方的着色语言是**OpenGL着色语言**（**GLSL**）。
- en: Since most shaders are coded for a GPU, major GPU makers Nvidia and AMD have
    also tried developing their own languages that can output for both OpenGL and
    Direct3D shaders. Nvidia developed Cg (deprecated now after version 3.1 in 2012)
    and AMD developed Mantle (used in some games, such as *Battlefield 4*, that were
    released in 2014 and seems to be gaining popularity among developers). Apple has
    also recently released its own shading language known as **Metal Shading Language**
    for iOS 8 in September 2014 to increase the performance benefits for iOS. Kronos
    has also announced a next generation graphics API based on OpenGL known as **Vulkan**
    in early 2015, which appears to be strongly supported by member companies such
    as Valve Corporation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数着色器是为GPU编写的，因此主要的GPU制造商Nvidia和AMD也尝试开发自己的语言，以便为OpenGL和Direct3D着色器输出。Nvidia开发了Cg（在2012年3.1版本后已弃用）和AMD开发了Mantle（用于2014年发布的某些游戏，如*战场4*，似乎在开发者中越来越受欢迎）。苹果公司也于2014年9月为其iOS
    8发布了名为**Metal着色语言**的自己的着色语言，以提高iOS的性能优势。Kronos还于2015年初宣布了一种基于OpenGL的下一代图形API，称为**Vulkan**，这似乎得到了Valve
    Corporation等成员公司的强烈支持。
- en: The following image is taken from a Direct3D 11 graphics pipeline on MSDN ([http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx)).
    It shows the programmable stages, which data can flow through to generate real-time
    graphics for our game, known as the rendering pipeline state representation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像来自MSDN上的Direct3D 11图形流水线（[http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx)）。它显示了可编程阶段，数据可以通过这些阶段生成用于我们游戏的实时图形，称为渲染流水线状态表示。
- en: '![Shaders](img/B03679_04_15.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![着色器](img/B03679_04_15.jpg)'
- en: The information here is taken from Microsoft MSDN page. You can use the Direct3D
    11API to configure all of the stages. Stages such as vertex, hull, domain, geometry,
    and pixel-shader (those with the rounded rectangular blocks), are programmable
    using HLSL. The ability to configure this pipeline programmatically makes it flexible
    for the game graphics rendering.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的信息来自Microsoft MSDN页面。您可以使用Direct3D 11API配置所有阶段。如顶点、Hull、Domain、几何和像素着色器（那些有圆形矩形块的）等阶段，可以使用HLSL进行编程。能够以编程方式配置此流水线使其在游戏图形渲染方面具有灵活性。
- en: 'What each stage does is explained as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个阶段功能的解释：
- en: '| Stage | Function |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 功能 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input-assembler | This stage supplies data (in the form of triangles, lines,
    and points) to the pipeline. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 输入汇编器 | 此阶段向流水线提供数据（以三角形、线和点等形式）|'
- en: '| Vertex-shader | This stage processes vertices such as undergoing transformations,
    skinning, and lighting. The number of vertices does not change after undergoing
    this stage. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 顶点着色器 | 此阶段处理顶点，如变换、蒙皮和光照。经过此阶段后，顶点的数量不会改变。 |'
- en: '| Geometry-shader | This stage processes entire geometry primitives such as
    triangles, lines, and a single vertex for a point. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 几何着色器 | 此阶段处理整个几何原语，如三角形、线和点。 |'
- en: '| Stream-output | This stage serves to stream primitive data from the pipeline
    to memory while on its way to the rasterizer. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 流输出 | 此阶段在数据流向光栅化器的同时，将原始数据从流水线传输到内存。 |'
- en: '| Rasterizer | This clips primitives and prepare the primitives for the pixel-shader.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 光栅化器 | 此阶段剪辑原始数据，并为像素着色器准备原始数据。 |'
- en: '| Pixel-shader | Pixel manipulation is done here. Each pixel in the primitive
    is processed here, for example, pixel color. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 像素着色器 | 在这里进行像素操作。每个原始像素都在这里进行处理，例如像素颜色。 |'
- en: '| Output-merger | This stage combines the various output data (pixel-shader
    values, depth, and stencil information) with the contents of the render target
    and depth/stencil buffers to generate the final pipeline result. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 输出合并 | 此阶段将各种输出数据（像素着色器值、深度和模板信息）与渲染目标的内容以及深度/模板缓冲区的内容合并，以生成最终的流水线结果。 |'
- en: '| Hull-shader, tessellator, and domain-shader | These tessellation stages convert
    higher-order surfaces to triangles to prepare for rendering. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Hull着色器、细分器和域着色器 | 这些细分阶段将高阶表面转换为三角形，为渲染做准备。 |'
- en: 'To help you better visualize what happens in each of the stages, the following
    image shows a very good illustration of a simplified rendering pipeline for vertices
    only. The image is taken from an old Cg tutorial. Note that different APIs have
    different pipelines but rely on similar basic concepts in rendering (source: [http://goanna.cs.rmit.edu.au/~gl/teaching/rtr&3dgp/notes/pipeline.html](http://goanna.cs.rmit.edu.au/~gl/teaching/rtr&3dgp/notes/pipeline.html)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地可视化每个阶段发生的情况，以下图像展示了一个仅针对顶点的简化渲染管道的非常好的插图。图像来自一个旧的 Cg 教程。请注意，不同的 API
    有不同的管道，但它们在渲染的基本概念上依赖于相似性（来源：[http://goanna.cs.rmit.edu.au/~gl/teaching/rtr&3dgp/notes/pipeline.html](http://goanna.cs.rmit.edu.au/~gl/teaching/rtr&3dgp/notes/pipeline.html))。
- en: '![Shaders](img/B03679_04_16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![着色器](img/B03679_04_16.jpg)'
- en: 'Example flow of how graphics is displayed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图形显示的示例流程：
- en: The CPU sends instructions (compiled shading language programs) and geometry
    data to the graphics processing unit, located on the graphics card.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 将指令（编译的着色语言程序）和几何数据发送到位于显卡上的图形处理单元。
- en: The data is passed through into the vertex shader where vertices are transformed.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传递到顶点着色器，在那里顶点被转换。
- en: If the geometry shader is active in the GPU, the geometry changes are performed
    in the scene.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 GPU 中启用了几何着色器，则在场景中执行几何形状的变化。
- en: If a tessellation shader is active in the GPU, the geometries in the scene can
    be subdivided. The calculated geometry is triangulated (subdivided into triangles).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 GPU 中启用了细分着色器，场景中的几何形状可以被细分。计算出的几何形状被三角化（细分为三角形）。
- en: Triangles are broken down into fragments. Fragment quads are modified according
    to the fragment shader.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形被分解成片段。根据片段着色器修改片段四边形。
- en: To create the feel of depth, the z buffer value is set for the fragments and
    then sent to the frame buffer for displaying.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创建深度感，为片段设置 z 缓冲区值，然后将其发送到帧缓冲区进行显示。
- en: APIs – DirectX and OpenGL
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: APIs – DirectX 和 OpenGL
- en: Both DirectX and OpenGL are collections of **application programming interfaces**
    (**APIs**) used for handling multimedia information in a computer. They are the
    two most common APIs used today for video cards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: DirectX 和 OpenGL 都是用于在计算机中处理多媒体信息的应用程序编程接口（API）集合。它们是目前用于视频卡的最常见的两种 API。
- en: DirectX is created by Microsoft to allow multimedia related hardware, such as
    GPU, to communicate with the Windows system. OpenGL is the open source version
    that can be used on many operating system including Mac OS.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DirectX 是由微软创建的，以便多媒体相关硬件，如 GPU，能与 Windows 系统通信。OpenGL 是开源版本，可以在包括 Mac OS 在内的许多操作系统上使用。
- en: The decision to use DirectX or OpenGL APIs to program is dependent on operating
    system of the target machine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DirectX 或 OpenGL API 编程的决定取决于目标机器的操作系统。
- en: DirectX
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DirectX
- en: Unreal Engine 4 was first launched using DirectX11\. Following the announcement
    that DirectX 12 ships with Windows 10, Unreal has created a DirectX 12 branch
    from the 4.4 version to allow developers to start creating games using this new
    DirectX 12.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 4 首次使用 DirectX11 发布。在宣布 DirectX 12 与 Windows 10 一起发布后，Unreal 从
    4.4 版本开始创建了一个 DirectX 12 分支，以便开发者可以开始使用这个新的 DirectX 12 来创建游戏。
- en: An easy way to identify APIs that are a part of DirectX is that the names all
    begin with Direct. For computer games, the APIs that we are most concerned about
    are Direct3D, which is the graphical API for drawing high performance 3D graphics
    in games, and DirectSound3D, which is for the sound playback.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 识别属于 DirectX 的 API 的一个简单方法就是它们的名称都以 Direct 开头。对于电脑游戏来说，我们最关心的 API 是 Direct3D，它是用于在游戏中绘制高性能
    3D 图形的图形 API，以及 DirectSound3D，它是用于声音播放的。
- en: DirectX APIs are integral in creating high-performance 2D and 3D graphics for
    the Windows operating system. For example, DirectX11 is supported in Windows Vista,
    Windows 7 and Windows 8.1\. The latest version of DirectX can be updated through
    service pack updates. DirectX 12 is known to be shipped with Windows 10.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: DirectX API 对于创建 Windows 操作系统的高性能 2D 和 3D 图形至关重要。例如，DirectX11 支持在 Windows Vista、Windows
    7 和 Windows 8.1 上。最新的 DirectX 版本可以通过服务包更新进行更新。已知 DirectX 12 是与 Windows 10 一起发布的。
- en: DirectX12
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DirectX12
- en: 'Direct3D 12 was announced in 2014 and has been vastly revamped from Direct3D
    11 to provide significant performance improvement. This is a very good link to
    a video posted on the MSDN blog that shows the tech demo for DirectX 12: [http://channel9.msdn.com/Blogs/DirectX-Developer-Blog/DirectX-Techdemo](http://channel9.msdn.com/Blogs/DirectX-Developer-Blog/DirectX-Techdemo).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Direct3D 12于2014年发布，从Direct3D 11进行了大幅改进，以提供显著的性能提升。这是一个非常好的链接，指向MSDN博客上发布的一段视频，展示了DirectX
    12的技术演示：[http://channel9.msdn.com/Blogs/DirectX-Developer-Blog/DirectX-Techdemo](http://channel9.msdn.com/Blogs/DirectX-Developer-Blog/DirectX-Techdemo)。
- en: (If you are unfamiliar with Direct3D 11 and have not read the *Shaders* section
    earlier, read that section before proceeding with the rest of the DirectX section.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你对Direct3D 11不熟悉，或者之前没有阅读*着色器*部分，请在继续阅读DirectX部分之前先阅读该部分。）
- en: Pipeline state representation
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道状态表示
- en: 'If you can recall from the *Shaders* section, we have looked at the programmable
    pipeline for Direct3D 11\. The following image is the same from the *Shaders*
    section (taken from MSDN) and it shows a series of programmable shaders:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能从*着色器*部分回忆起，我们曾查看Direct3D 11的可编程管道。以下图像与*着色器*部分相同（来自MSDN），它显示了一系列可编程着色器：
- en: '![Pipeline state representation](img/B03679_04_17.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![管道状态表示](img/B03679_04_17.jpg)'
- en: 'In Direct3D 11, each of the stages is configurable independently and each stage
    is setting states on the hardware independently. Since many stages have the capability
    to set the same hardware state due to interdependency, this results in hardware
    mismatch overhead. The following image is an excellent illustration of how hardware
    mismatch overhead happens:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Direct3D 11中，每个阶段都可以独立配置，并且每个阶段都会独立地在硬件上设置状态。由于许多阶段由于相互依赖而具有设置相同硬件状态的能力，这导致了硬件不匹配的开销。以下图像是硬件不匹配开销如何发生的极好说明：
- en: '![Pipeline state representation](img/B03679_04_18.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![管道状态表示](img/B03679_04_18.jpg)'
- en: The driver will normally record these states from the application (game) first
    and wait until the draw time, when it is ready to send it to the display monitor.
    At draw time, these states are then queried in a control loop before they are
    is translated into a GPU code for the hardware in order to render the correct
    scene for the game. This creates an additional overhead to record and query for
    all the states at draw time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序通常会首先从应用程序（游戏）中记录这些状态，并等待直到绘制时间，当它准备好将其发送到显示监视器时。在绘制时间，这些状态在它们被转换为用于硬件的GPU代码以渲染游戏正确场景之前，在一个控制循环中进行查询。这为在绘制时间记录和查询所有状态创建了一个额外的开销。
- en: In Direct3D 12, some programmable stages are grouped to form a single object
    known as **pipeline state object** (**PSO**) so that the each hardware state is
    set only once by the entire group, preventing hardware mismatch overhead. These
    states can now be used directly, instead of having to spend resources computing
    the resulting hardware states before the draw call. This reduces the draw call
    overhead, allowing more draw calls per frame. The PSO that is in use can still
    be changed dynamically based on whatever hardware native instructions and states
    that are required.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Direct3D 12中，一些可编程阶段被组合成一个称为**管道状态对象**（**PSO**）的单个对象，以便整个组只设置一次每个硬件状态，从而防止硬件不匹配的开销。现在可以直接使用这些状态，而不是在绘制调用之前计算结果硬件状态所需的资源。这减少了绘制调用的开销，允许每帧进行更多的绘制调用。正在使用的PSO可以根据所需的任何硬件原生指令和状态动态更改。
- en: '![Pipeline state representation](img/B03679_04_19.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![管道状态表示](img/B03679_04_19.jpg)'
- en: Work submission
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作提交
- en: In Direct3D 11, work submission to the GPU is immediate. What is new in Direct3D
    12 is that it uses command lists and bundles that contain the entire information
    needed to execute a particular workload.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Direct3D 11中，向GPU的工作提交是立即的。Direct3D 12的新特性是它使用包含执行特定工作负载所需全部信息的命令列表和包。
- en: Immediate work submission in Direct3D 11 means that information is passed as
    a single stream of command to the GPU and due to the lack of the entire information,
    these commands are often deferred until the actual work can be done.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Direct3D 11中，立即工作提交意味着信息以单个命令流的形式传递给GPU，由于缺少完整信息，这些命令通常会被延迟，直到实际工作可以完成。
- en: When work submission is grouped in the self-contained command list, the drivers
    can precompute all the necessary GPU commands and then send that list to the GPU,
    making Direct3D 12 work submission a more efficient process. Additionally, the
    use of bundles can be thought of as a small list of commands that are grouped
    to create a particular object. When this object needs to be duplicated on screen,
    this bundle of commands can be "played back" to create the duplicated object.
    This further reduces computational time needed in Direct3D 12.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作提交被分组在自包含的命令列表中时，驱动程序可以预先计算所有必要的GPU命令，然后将该列表发送到GPU，使Direct3D 12的工作提交过程更加高效。此外，使用包可以被视为一组创建特定对象的命令的小列表。当这个对象需要在屏幕上重复时，这个命令包可以被“回放”以创建重复的对象。这进一步减少了Direct3D
    12所需的计算时间。
- en: Resource access
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源访问
- en: In Direct3D 11, the game creates resource views that bind these views to slots
    at the shaders. These shaders then read the data from these explicit bound slots
    during a draw call. If the game wants to draw using different resources, it will
    be done in the next draw call with a different view.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Direct3D 11中，游戏创建资源视图，将这些视图绑定到着色器中的插槽。这些着色器然后在绘制调用期间从这些显式绑定的插槽中读取数据。如果游戏想要使用不同的资源进行绘制，它将在下一个绘制调用中使用不同的视图进行。
- en: In Direct3D 12, you can create various resource views by using descriptor heaps.
    Each descriptor heap can be customized to be linked to a specific shader using
    specific resources. This flexibility to design the descriptor heap allows you
    to have full control over the resource usage pattern, fully utilizing modern hardware
    capabilities. You are also able to describe more than one descriptor heap that
    is indexed to allow easy flexibility to swap heaps, to complete a single draw
    call.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Direct3D 12中，您可以通过使用描述符堆来创建各种资源视图。每个描述符堆都可以定制以链接到特定的着色器，使用特定的资源。这种设计描述符堆的灵活性允许您完全控制资源使用模式，充分利用现代硬件的能力。您还可以描述多个索引的描述符堆，这允许轻松地交换堆，以完成单个绘制调用。
- en: Lights
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光
- en: We have briefly gone through the types of light in [Chapter 1](ch01.html "Chapter 1. An
    Overview of Unreal Engine"), *An Overview of Unreal Engine*. Let us do a quick
    recap first. Directional Light emits beams of parallel lights. Point Light emits
    light like a light bulb (from a single point radially outward in all directions).
    Spot Light emits light in a conical shape outwards and Sky Light mimics light
    from the sky downwards on the objects in the level.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。Unreal引擎概述")中简要介绍了灯光的类型，*Unreal引擎概述*。让我们先快速回顾一下。方向光发射平行光束。点光源像灯泡一样发光（从单个点以径向向外所有方向）。聚光灯以锥形形状向外发射光，而天空光则模仿天空向下照射关卡中的对象。
- en: In this chapter, we will learn how to use these basic lights to illuminate an
    interior area. We have already placed a Point Light in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Level"), *Creating Your First Level*, and learned how to adjust its
    intensity to 1700\. Here in this chapter, we will learn more about the parameters
    that we can adjust with each type of light to create the lighting that we want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用这些基本灯光照亮室内区域。我们已经在[第2章](ch02.html "第2章。创建您的第一个关卡")中放置了一个点光源，*创建您的第一个关卡*，并学习了如何将其强度调整为1700。在本章中，我们将学习更多关于我们可以调整的每个类型灯光的参数，以创建我们想要的照明效果。
- en: Let us first view a level that has been illuminated using these Unreal lights.
    Load `Chapter4Level_Prebuilt.umap`, build and play the level to look around. Click
    on the lights that are placed in the level and you will notice that most of lights
    used are Point or Spot Light. These two forms of lights are quite commonly found
    in interior lighting.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先查看使用这些Unreal灯光照亮的关卡。加载`Chapter4Level_Prebuilt.umap`，构建并播放关卡以四处查看。点击关卡中放置的灯光，你会注意到大多数使用的灯光是点光源或聚光灯。这两种形式的灯光在室内照明中相当常见。
- en: The next section will guide you to extend the level on your own. Alternatively,
    you can use the `Chapter4Level_Prebuilt` level to help you along in the creation
    of your own level since it does take a fair amount of time to create the entire
    level. If you wish to skip to the next section, feel free to simply use the prebuilt
    version of the map provided, and go through the other examples in this chapter
    using the prebuilt map as a reference. However, it will be a great opportunity
    to revise what you have learned in the previous chapters and extend the level
    on your own.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将指导您自己扩展关卡。或者，您可以使用`Chapter4Level_Prebuilt`关卡来帮助您创建自己的关卡，因为创建整个关卡确实需要相当多的时间。如果您想跳到下一节，可以直接使用提供的预建地图版本，并使用预建地图作为参考来浏览本章的其他示例。然而，这将是一个很好的机会来复习您在前几章学到的内容，并自己扩展关卡。
- en: Before we embark on the optional exercise to extend the level, let us go through
    a few tutorial examples on how we can place and configure the different types
    of light.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始扩展关卡的选做练习之前，让我们通过几个教程示例来了解我们如何放置和配置不同类型的灯光。
- en: Configuring a Point Light with more settings
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置具有更多设置的点光源
- en: Open `Chapter4Level.umap` and rename it `Chapter4Level_PointLight.umap`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Chapter4Level.umap`并将其重命名为`Chapter4Level_PointLight.umap`。
- en: Go to **Modes** | **Lights**, drag and drop a Point Light into the level. As
    Point Light emits light equally in all directions from a single point, **Attenuation
    Radius**, **Intensity**, and **Color** are the three most common values that are
    configured for a Point Light.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**模式** | **灯光**，将一个点光源拖放到关卡中。由于点光源从单个点向所有方向均匀发射光线，**衰减半径**、**强度**和**颜色**是配置点光源时最常见的三个值。
- en: Attenuation Radius
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 衰减半径
- en: The following screenshot shows when the Point Light has its default **Attenuation
    Radius** of **1000**. The radius of the three blue circles is based on the attenuation
    radius of the Point Light and is used to show its area of effect on the environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了点光源具有默认的**衰减半径**为**1000**的情况。三个蓝色圆圈的半径基于点光源的衰减半径，用于显示其对环境的影响区域。
- en: '![Attenuation Radius](img/B03679_04_20.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![衰减半径](img/B03679_04_20.jpg)'
- en: 'The following screenshot shows when the attenuation radius is reduced to 500\.
    In this situation, you probably cannot see any difference in the lighting since
    the radius is still larger than the room itself:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了衰减半径减少到500的情况。在这种情况下，由于半径仍然大于房间本身，您可能看不到任何光照上的差异：
- en: '![Attenuation Radius](img/B03679_04_21.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![衰减半径](img/B03679_04_21.jpg)'
- en: Now, let us take a look at what happens when we adjust the radius much smaller.
    The following screenshot shows the difference in light brightness when the radius
    changes. The image on the left is when the attenuation radius is set as 500 and
    the right when attenuation radius is set as 10.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们调整半径变得非常小时会发生什么。以下截图显示了当半径变化时光线亮度的差异。左边的图像是衰减半径设置为500时的情况，右边的图像是衰减半径设置为10时的情况。
- en: '![Attenuation Radius](img/B03679_04_22.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![衰减半径](img/B03679_04_22.jpg)'
- en: Intensity
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强度
- en: Another setting for Point Light is **Intensity**. Intensity affects the brightness
    of the light. You can play around the Intensity value to adjust the brightness
    of the light. Before we determine what value to use for this field and how bright
    we want our light to be, you should be aware of another setting, **Use Inverse
    Squared Falloff**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 点光源的另一个设置是**强度**。强度影响光线的亮度。您可以调整强度值来调整光线的亮度。在我们确定这个字段应该使用什么值以及我们希望光线有多亮之前，您应该了解另一个设置，**使用逆平方衰减**。
- en: Use Inverse Squared Falloff
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用逆平方衰减
- en: 'Point Lights and Spot Lights have physically based inverse squared falloff
    set on, as default. This setting is configurable as a checkbox found in the **Light**
    details under **Advanced**. The following screenshot shows where this property
    is found in the **Details** panel:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 点光源和聚光灯默认启用了基于物理的逆平方衰减。此设置可配置为在**高级**下的**灯光**详情中找到的复选框。以下截图显示了在**详情**面板中找到此属性的位置：
- en: '![Use Inverse Squared Falloff](img/B03679_04_23.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![使用逆平方衰减](img/B03679_04_23.jpg)'
- en: Inverse squared falloff is a physics law that describes how light intensity
    naturally fades over distance. When we have this setting, the units for intensity
    use the same units as the lights we have in the real world, in lumens. When inverse
    squared distance falloff is not used, intensity becomes just a value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 平方反比衰减是一种物理定律，描述了光强度如何随距离自然衰减。当我们有这个设置时，强度的单位与我们在现实世界中的灯光相同的单位，即流明。当不使用平方反比距离衰减时，强度只是一个值。
- en: In the previous chapter where we have added our first Point Light, we have set
    intensity as 1700\. This is equivalent to the brightness of a light bulb that
    has 1700 lumens because inverse squared distance falloff is used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们添加了第一个点光源，并将强度设置为1700。这相当于一个1700流明的灯泡的亮度，因为使用了平方反比距离衰减。
- en: Color
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色
- en: 'To adjust the color of Point Light, go to **Light** | **Color**. The following
    screenshot shows how the color of the light can be adjusted by specifying the
    RGB values or using the color picker to select the desired color:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整点光源的颜色，转到**灯光** | **颜色**。以下截图显示了如何通过指定 RGB 值或使用颜色选择器选择所需颜色来调整灯光的颜色：
- en: '![Color](img/B03679_04_24.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![颜色](img/B03679_04_24.jpg)'
- en: Adding and configuring a Spot Light
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和配置聚光灯
- en: Open `Chapter4Level.umap` and rename it `Chapter4Level_SpotLight.umap`. Go to
    **Modes** | **Lights**, drag and drop a Spot Light into the level.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Chapter4Level.umap`并将其重命名为`Chapter4Level_SpotLight.umap`。转到**模式** | **灯光**，将聚光灯拖放到场景中。
- en: The brightness, visible influence radius, and color of a Spot Light can be configured
    in the same way as the Point Light through the value of **Intensity**, **Attenuation
    Radius**, and **Color**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 聚光灯的亮度、可见影响半径和颜色可以通过**强度**、**衰减半径**和**颜色**的值以与点光源相同的方式进行配置。
- en: Since Point Light has light emitting in all directions and a Spot Light emits
    light from a single point outwards in a conical shape with a direction, the Spot
    Light has additional properties such as inner cone and outer cone angle, which
    are configurable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点光源向所有方向发射光线，而聚光灯则从单个点向外以锥形形状发射光线，具有方向，因此聚光灯具有额外的属性，如内锥角和外锥角，这些是可以配置的。
- en: Inner cone and outer cone angle
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内锥角和外锥角
- en: The unit for the outer cone angle and inner cone angle is in degrees. The following
    screenshot shows the light radius that the spotlight has when the outer cone angle
    = 20 (on the left) and outer cone angle = 15 (on the right). The inner cone angle
    value did not produce much visible results in the screenshot, so very often the
    value is 0\. However, the inner cone angle can be used to provide light in the
    center of the cone. This would be more visible for lights with a wider spread
    and certain IES Profiles.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 外锥角和内锥角的单位是度。以下截图显示了当外锥角 = 20（左侧）和外锥角 = 15（右侧）时聚光灯的光半径。内锥角值在截图中没有产生太多可见结果，因此通常值为0。然而，内锥角可以用来在锥形中心提供光线。对于扩散较宽的灯光和某些
    IES 轮廓，这将更加明显。
- en: '![Inner cone and outer cone angle](img/B03679_04_25.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![内锥角和外锥角](img/B03679_04_25.jpg)'
- en: Using the IES Profile
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IES 轮廓
- en: Open `Chapter4Level_PointLight.umap` and rename it `Chapter4Level_IESProfile.umap`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Chapter4Level_PointLight.umap`并将其重命名为`Chapter4Level_IESProfile.umap`。
- en: IES Light Profile is a file that contains information that describes how a light
    will look. This is created by light manufacturers and can be downloaded from the
    manufacturers' websites. These profiles could be used in architectural models
    to render scenes with realistic lighting. In the same way, the IES Profile information
    can be used in Unreal Engine 4 to render more realistic lights. IES Light Profiles
    can be applied to a Point Light or a Spot Light.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: IES 光线轮廓是一个包含描述光线外观信息的文件。这是由灯光制造商创建的，可以从制造商的网站上下载。这些配置文件可以在建筑模型中使用，以渲染具有逼真照明的场景。同样，IES
    轮廓信息也可以在虚幻引擎4中使用，以渲染更逼真的灯光。IES 光线轮廓可以应用于点光源或聚光灯。
- en: Downloading IES Light Profiles
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载 IES 光线轮廓
- en: 'IES Light Profiles can be downloaded from light manufacturers'' websites. Here''s
    a few that you can use:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: IES 光线轮廓可以从灯光制造商的网站上下载。以下是一些您可以使用的轮廓：
- en: '**Cooper** **Industries**: [http://www.cooperindustries.com/content/public/en/lighting/resources/design_center_tools/photometric_tool_box.html](http://www.cooperindustries.com/content/public/en/lighting/resources/design_center_tools/photometric_tool_box.html)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库伯工业公司**：[http://www.cooperindustries.com/content/public/en/lighting/resources/design_center_tools/photometric_tool_box.html](http://www.cooperindustries.com/content/public/en/lighting/resources/design_center_tools/photometric_tool_box.html)'
- en: '**Philips**: [http://www.usa.lighting.philips.com/connect/tools_literature/photometric_data_1.wpd](http://www.usa.lighting.philips.com/connect/tools_literature/photometric_data_1.wpd)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Philips**: [http://www.usa.lighting.philips.com/connect/tools_literature/photometric_data_1.wpd](http://www.usa.lighting.philips.com/connect/tools_literature/photometric_data_1.wpd)'
- en: '**Lithonia**: [http://www.lithonia.com/photometrics.aspx](http://www.lithonia.com/photometrics.aspx)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lithonia**: [http://www.lithonia.com/photometrics.aspx](http://www.lithonia.com/photometrics.aspx)'
- en: Importing IES Profiles into the Unreal Engine Editor
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将IES配置文件导入Unreal Engine编辑器
- en: 'From **Content Browser**, click on **Import**, as shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从**内容浏览器**中，点击**导入**，如下面的屏幕截图所示：
- en: '![Importing IES Profiles into the Unreal Engine Editor](img/B03679_04_26.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![将IES配置文件导入Unreal Engine编辑器](img/B03679_04_26.jpg)'
- en: I prefer to have my files in a certain order, hence I have created a new folder
    called `IESProfile` and created subfolders with the names of the manufacturers
    to better categorize all the light profiles that were imported.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢我的文件按照一定的顺序排列，因此我创建了一个名为`IESProfile`的新文件夹，并创建了以制造商命名的子文件夹，以更好地分类所有导入的灯光配置文件。
- en: Using IES Profiles
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用IES配置文件
- en: Continuing from the previous example, select the right Spot Light which we have
    in the scene and make sure it is selected. Go to the **Details** panel and scroll
    down to show the Light Profile of the light.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例的基础上继续，选择场景中正确的聚光灯并确保它被选中。转到**详细信息**面板并向下滚动以显示灯光的灯光配置文件。
- en: Then go to **Content Browser** and go to the `IESProfile` folder where we have
    imported the light profiles into. Click on one of the profiles that you want,
    drag and drop it on the IES Texture of the Spot Light. Alternatively, you can
    select the profile and go back to the **Details** panel of the **Light** and click
    on the arrow next to **IES Texture** to apply the profile on the Spot Light. In
    the following screenshot, I applied one of the profiles downloaded from the Panasonic
    website labeled **144907**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到**内容浏览器**并进入`IESProfile`文件夹，我们将灯光配置文件导入到该文件夹中。点击你想要的配置文件之一，将其拖放到聚光灯的IES纹理上。或者，你可以选择配置文件，然后返回到**灯光**的**详细信息**面板，点击**IES纹理**旁边的箭头以将配置文件应用到聚光灯上。在下面的屏幕截图中，我应用了从松下网站下载的标记为**144907**的配置文件之一。
- en: '![Using IES Profiles](img/B03679_04_27.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用IES配置文件](img/B03679_04_27.jpg)'
- en: I reconfigured the Spot Light with **Intensity** = **1000**, **Attenuation Radius**
    = **1000**, **Outer Cone Angle** = **40**, and **Inner Cone Angle** = **0**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我重新配置了聚光灯，设置**强度**= **1000**，**衰减半径**= **1000**，**外锥角**= **40**，和**内锥角**= **0**。
- en: Next, I deleted the other Spot Light and replaced it with a Point Light where
    I set **Intensity** = **1000** and **Attenuation Radius** = **1000**. I also set
    the **Rotation-Y** = **-90** and then applied the same IES Profile to it. The
    following screenshot shows the difference when the same light profile is applied
    to a Spot Light and a Point Light. Note that the spread of the light in the Spot
    Light is reduced. This reinforces the concept that a Spot Light provides a conical
    shaped light with a direction spreading from the point source outwards. The outer
    cone angle determines this spread. The point light emits light in all directions
    and equally out, so it did not attenuate the light profile settings allowing the
    full design of this light profile to be displayed on the screen. This is one thing
    to keep in mind while using the IES Light Profile and which types of light to
    use them on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我删除了另一个聚光灯，并用一个设置**强度**= **1000**和**衰减半径**= **1000**的点光源替换它。我还设置了**旋转-Y**=
    **-90**，并将其相同的IES配置文件应用到它上。下面的屏幕截图显示了当相同的灯光配置文件应用到聚光灯和点光源时产生的差异。请注意，聚光灯中光的扩散减少了。这加强了聚光灯提供从点光源向外扩散的锥形光的概念。外锥角决定了这种扩散。点光源向所有方向发射光，并且均匀地发射，因此它没有衰减灯光配置文件设置，允许在屏幕上完全显示此灯光配置文件的设计。这是在使用IES灯光配置文件时需要注意的一件事，以及它们适用于哪些类型的灯光。
- en: '![Using IES Profiles](img/B03679_04_28.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![使用IES配置文件](img/B03679_04_28.jpg)'
- en: Adding and configuring a Directional Light
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和配置方向光
- en: Open `Chapter4Level.umap` and rename it `Chapter4Level_DirectionalLight.umap`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Chapter4Level.umap`并将其重命名为`Chapter4Level_DirectionalLight.umap`。
- en: We have already added a Directional Light into our level in [Chapter 2](ch02.html
    "Chapter 2. Creating Your First Level"), *Creating Your First Level*, and it provides
    parallel beams of light into the level.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](ch02.html "第2章。创建您的第一个关卡")“创建您的第一个关卡”中添加了方向光到我们的关卡中，它向关卡提供平行光束。
- en: Directional Light can also be used to light the level by controlling the direction
    of the sun. The screenshot on the left shows the Directional Light when the **Atmosphere
    Sun Light** checkbox is unchecked. The screenshot on the right shows the Directional
    Light when the **Atmosphere Sun Light** checkbox is checked. When the **Atmosphere
    Sun Light** checkbox is checked, you can control the direction of the sunlight
    by adjusting the rotation of Directional Light.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 轮向光也可以通过控制太阳的方向来照亮场景。左边的截图显示了当**大气阳光**复选框未选中时的轮向光。右边的截图显示了当**大气阳光**复选框选中时的轮向光。当**大气阳光**复选框选中时，你可以通过调整轮向光的旋转来控制阳光的方向。
- en: '![Adding and configuring a Directional Light](img/B03679_04_29.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![添加和配置轮向光](img/B03679_04_29.jpg)'
- en: 'The following screenshot shows how this looks when **Rotation-Y** = **0**.
    This looks like an early sunset scene:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当**旋转-Y** = **0**时的样子。这看起来像是一个早上的日落场景：
- en: '![Adding and configuring a Directional Light](img/B03679_04_30.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![添加和配置轮向光](img/B03679_04_30.jpg)'
- en: Example – adding and configuring a Sky light
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 – 添加和配置天空光
- en: Open `Chapter4Level_DirectionalLight.umap` and rename it `Chapter4Level_Skylight.umap`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Chapter4Level_DirectionalLight.umap`并将其重命名为`Chapter4Level_Skylight.umap`。
- en: In the previous example, we have added sunlight control in the Directional Light.
    Build and compile to see how the level now looks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们在轮向光中添加了阳光控制。构建和编译以查看场景现在的样子。
- en: Now, let us add a Sky Light into the level by going to **Modes** | **Lights**
    and then clicking and dragging Sky Light into the level. When adding a Sky Light
    to the level, always remember to build and compile first in order to see the effect
    of the Sky Light.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过转到**模式** | **灯光**，然后点击并拖动天空光到场景中来向场景中添加天空光。在向场景添加天空光时，始终记得先构建和编译，以便看到天空光的效果。
- en: What does a Sky Light do? Sky Light models the color/light from the sky and
    is used to light up the external areas of the level. So the external areas of
    the level look more realistic as the color/light is reflecting off the surfaces
    (instead of using simple white/colored light).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 天空光有什么作用？天空光模拟天空的颜色/光线，用于照亮场景的外部区域。因此，外部区域看起来更真实，因为颜色/光线是反射在表面上的（而不是使用简单的白色/彩色光）。
- en: The following screenshot shows the effect of a Sky Light. The left image shows
    the Sky Light not in the level. The right one shows the Sky Light. Note that the
    walls now have a tinge of the color of the sky.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了天空光的效果。左边的图像显示了天空光不在场景中。右边的图像显示了天空光。注意，墙壁现在带有天空的颜色。
- en: '![Example – adding and configuring a Sky light](img/B03679_04_31.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 添加和配置天空光](img/B03679_04_31.jpg)'
- en: Static, stationary, or movable lights
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态、固定或可移动灯光
- en: After learning how to place and configure the different lights, we need to consider
    what kind of lights we need in the level. If you are new to the concept of light,
    you might want to briefly go through the useful light terms section to help in
    your understanding.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何放置和配置不同的灯光后，我们需要考虑在场景中需要哪种类型的灯光。如果你对灯光的概念不熟悉，你可能想简要地浏览一下有用的灯光术语部分，以帮助你的理解。
- en: The following screenshot shows the **Details** panel where you can change a
    light to be static, stationary, or movable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了可以更改灯光为静态、固定或可移动的**详细信息**面板。
- en: '![Static, stationary, or movable lights](img/B03679_04_32.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![静态、固定或可移动灯光](img/B03679_04_32.jpg)'
- en: '**Static** and **Stationary** light sounds pretty much similar. What is the
    difference? When do you want to use a **Static** light and when do you want to
    use a **Stationary** light?'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态**和**固定**灯光听起来非常相似。它们有什么区别？你什么时候想使用**静态**灯光，什么时候想使用**固定**灯光？'
- en: Common light/shadow definitions
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的灯光/阴影定义
- en: 'The common light/shadow definitions are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的灯光/阴影定义如下：
- en: '**Direct Light**: This is the light that is present in the scene directly due
    to a light source.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接光**：这是由于光源直接存在于场景中的光。'
- en: '**Indirect Light**: This is the light in the scene that is not directly from
    a light source. It is reflected light bouncing around and it comes from all sides.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间接光**：这是场景中不是直接来自光源的光。这是反射光在周围弹跳，并来自各个方向。'
- en: '**Light Map**: This is a data structure that stores the light/brightness information
    about an object. This makes the rendering of the object much quicker because we
    already know its color/brightness information in advance and it is not necessary
    to compute this during runtime.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照图**：这是一个存储对象关于光/亮度信息的数据结构。这使得对象的渲染速度更快，因为我们已经提前知道了它的颜色/亮度信息，并且在运行时不需要计算这些信息。'
- en: '**Shadow Map**: This is a process created to make dynamic shadows. It is fundamentally
    made up of two passes to create shadows. More passes can be added to render nicer
    shadows.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影图**：这是一个创建动态阴影的过程。它基本上由两个步骤组成以创建阴影。可以添加更多步骤以渲染更漂亮的阴影。'
- en: Static Light
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态光
- en: In a game, we always want to have the best performance, and Static Light will
    be an excellent option because a Static Light needs only to be precomputed once
    into a Light Map. So for a Static Light, we have the lowest performance cost but
    in exchange, we are unable to change how the light looks, move the light, and
    integrate the effect of this light with moving objects (which means it is unable
    to create a shadow for the moving object as it moves within the influence of the
    light) into the environment during gameplay. However, a Static Light can cast
    shadow on the existing stationary objects that are in the level within its influence
    of radius. The radius of influence is based on the source radius of the light.
    In return for low performance cost, a Static Light has quite a bit of limitation.
    Hence, Static Lights are commonly used in the creation of scenes targeted for
    devices with low computational power.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们总是希望有最佳的性能，静态光将是一个极好的选择，因为静态光只需要预先计算一次到光照图中。因此，对于静态光，我们有最低的性能成本，但作为交换，我们无法改变光的外观，移动光，以及将此光的效果与移动对象（这意味着它无法在光的影响范围内移动时为移动对象创建阴影）集成到游戏环境中的效果。然而，静态光可以在其影响半径内的现有静止对象上投射阴影。影响半径基于光源的源半径。作为对低性能成本的回报，静态光有一些限制。因此，静态光通常用于针对计算能力较低的设备创建场景。
- en: Stationary Light
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态光
- en: Stationary Light can be used in situations when we do not need to move, rotate,
    or change the influence radius of the light during gameplay, but allow the light
    the capacity to change color and brightness. Indirect Light and shadows are prebaked
    in Light Map in the same way as Static Light. Direct Light shadows are stored
    within Shadow Maps.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 静态光可以用于在游戏过程中我们不需要移动、旋转或改变光的影响半径的情况下，但允许光有改变颜色和亮度的能力。间接光和阴影与静态光一样，在光照图中预先烘焙。直接光阴影存储在阴影图中。
- en: Stationary Light is medium in performance cost as it is able to create static
    shadow on static objects through the use of distance field shadow maps. Completely
    dynamic light and shadows is often more than 20 times more intensive.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 静态光在性能成本上是中等的，因为它能够通过使用距离场阴影图在静态对象上创建静态阴影。完全动态的光和阴影通常比静态光和阴影多20倍以上。
- en: Movable Light
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移动光
- en: Movable Light is used to cast dynamic light and shadows for the scene. This
    should be used sparingly in the level, unless absolutely necessary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可移动光用于为场景投射动态光和阴影。除非绝对必要，否则在级别中应谨慎使用。
- en: Exercise – extending your game level (optional)
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 扩展你的游戏级别（可选）
- en: 'Here are the steps that I have taken to extend the current **Level4** to the
    prebuilt version of what we have right now. They are by no means the only way
    to do it. I have simply used a Geometry Brush to extend the level here for simplicity.
    The following screenshot shows one part of the extended level:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我为了将当前的**Level4**扩展到我们目前拥有的预构建版本所采取的步骤。这绝对不是唯一的方法。我只是简单地使用了一个几何刷来简化这一级别的扩展。以下截图显示了扩展级别的一部分：
- en: '![Exercise – extending your game level (optional)](img/B03679_04_33.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![练习 – 扩展你的游戏级别（可选）](img/B03679_04_33.jpg)'
- en: Useful tips
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用提示
- en: Group items in the same area together when possible and rename the entity to
    help you identify parts of the level more quickly. These simple extra steps can
    save time when using the editor to create a mock-up of a game level.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，将同一区域内的项目分组在一起，并重命名实体以帮助您更快地识别级别的各个部分。这些简单的额外步骤在编辑器中创建游戏级别原型时可以节省时间。
- en: Guidelines
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指南
- en: If you plan to extend the game level on your own, open and load `Level4.umap`.
    Then save map as `Level4_MyPreBuilt.umap`. You can also open a copy of the extended
    level to copy assets or use it as a quick reference.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划自己扩展游戏关卡，请打开并加载 `Level4.umap`。然后保存地图为 `Level4_MyPreBuilt.umap`。你也可以打开扩展后的关卡副本以复制资源或作为快速参考。
- en: Area expansion
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面积扩展
- en: We will start by extending the floor area of the level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先延长这一层的地面区域。
- en: Part 1 – lengthening the current walkway
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一部分 – 延长现有通道
- en: The short walkway was extended to form an L-shaped walkway. The dimensions of
    the extended portion are X1200 x Y340 x Z40.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 短通道被延长形成了一个 L 形通道。延长部分的尺寸为 X1200 x Y340 x Z40。
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSP 数量 | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Ceiling | 1200 | 400 | 40 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 天花板 | 1200 | 400 | 40 |'
- en: '| Floor | 1200 | 400 | 40 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 地面 | 1200 | 400 | 40 |'
- en: '| Left wall | 1570 | 30 | 280 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 左墙 | 1570 | 30 | 280 |'
- en: '| Right wall | 1260 | 30 | 280 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 右墙 | 1260 | 30 | 280 |'
- en: Part 2 – creating a big room (living and kitchen area)
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二部分 – 创建大房间（居住和厨房区域）
- en: The walkway leads to a big room at the end, which is the main living and kitchen
    area.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通道通向末尾的大房间，这是主要的居住和厨房区域。
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSP 数量 | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Ceiling | 2000 | 1600 | 40 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 天花板 | 2000 | 1600 | 40 |'
- en: '| Floor | 2000 | 1600 | 40 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 地面 | 2000 | 1600 | 40 |'
- en: '| The left wall dividing the big room and walkway (the wall closest to you
    as you enter the big room from the walkway) | 30 | 600 | 340 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 将大房间和通道分开的左侧墙（从通道进入大房间时离你最近的墙） | 30 | 600 | 340 |'
- en: '| The light wall dividing the big room and walkway (the wall closest to you
    as you enter the big room from the walkway) | 30 | 600 | 340 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 将大房间和通道分开的灯光墙（从通道进入大房间时离你最近的墙） | 30 | 600 | 340 |'
- en: '| The left wall of the big room (where the kitchen area is) | 1200 | 30 | 340
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 大房间（厨房区域）的左侧墙 | 1200 | 30 | 340 |'
- en: '| The right wall of the big room (where the dining area is) | 2000 | 30 | 340
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 大房间（餐厅区域）的右侧墙 | 2000 | 30 | 340 |'
- en: '| The left wall to the door (the wall across the room as you enter from the
    walkway, where the window seats are) | 30 | 350 | 340 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 从通道进入房间左侧的墙（进入房间时，窗户座位所在的位置的墙） | 30 | 350 | 340 |'
- en: '| The right wall to the door (the wall across the room as you enter from the
    walkway, where the long benches are) | 30 | 590 | 340 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 从通道进入房间右侧的墙（进入房间时，长长长凳所在的位置的墙） | 30 | 590 | 340 |'
- en: '| Door area (consists of brick walls, door frames, and door) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 门区域（包括砖墙、门框和门） |'
- en: '| Wall filler left | 30 | 130 | 340 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 左侧墙填充物 | 30 | 130 | 340 |'
- en: '| Wall filler right | 30 | 126 | 340 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 右侧墙填充物 | 30 | 126 | 340 |'
- en: '| Door x 2 | 20 | 116 | 250 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 门 x 2 | 20 | 116 | 250 |'
- en: '| Side door frame x 2 | 25 | 4 | 250 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 侧门框 x 2 | 25 | 4 | 250 |'
- en: '| Horizontal door frame | 25 | 242 | 5 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 水平门框 | 25 | 242 | 5 |'
- en: '| Side brick wall x 2 | 30 | 52 | 340 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 侧砖墙 x 2 | 30 | 52 | 340 |'
- en: '| Horizontal brick wall | 30 | 242 | 74 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 水平砖墙 | 30 | 242 | 74 |'
- en: Part 3 – creating a small room along the walkway
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三部分 – 沿通道创建一个小房间
- en: To create the walkway to the small room, duplicate the same doorframe that we
    have created in the first room.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建通往小房间的通道，复制我们在第一个房间中创建的相同门框。
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSP 数量 | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Ceiling | 800 | 600 | 40 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 天花板 | 800 | 600 | 40 |'
- en: '| Floor | 800 | 600 | 40 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 地面 | 800 | 600 | 40 |'
- en: '| Side wall x 2 | 30 | 570 | 340 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 侧墙 x 2 | 30 | 570 | 340 |'
- en: '| Opposite wall (wall with the windows) | 740 | 30 | 340 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 对面墙（有窗户的墙） | 740 | 30 | 340 |'
- en: Part 4 – Creating a den area in the big room
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第四部分 – 在大房间中创建一个娱乐区
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSP 数量 | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Sidewall x 2 | 30 | 620 | 340 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 侧墙 x 2 | 30 | 620 | 340 |'
- en: '| Wall with shelves | 740 | 30 | 340 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 带有书架的墙 | 740 | 30 | 340 |'
- en: Creating windows and doors
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建窗户和门
- en: Now that we are done with rooms, we can work on the doors and windows.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了房间的制作，我们可以开始制作门和窗户。
- en: Part 1 – creating large glass windows for the dining area
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一部分 – 为餐厅区域创建大玻璃窗户
- en: To create the windows, we use a subtractive Geometry Brush to create holes in
    the wall. First, create one of size X144 x Y30 x Z300 and place it right in the
    middle between the ceiling and ground. Duplicate this and convert it to an additive
    brush; adjust the size to X142 x Y4 x Z298.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建窗户，我们使用减法几何笔刷在墙上创建洞口。首先，创建一个尺寸为 X144 x Y30 x Z300 的洞口，并将其放置在天花板和地面之间的正中间。复制这个洞口并将其转换为加法笔刷；调整尺寸为
    X142 x Y4 x Z298。
- en: 'Apply **M_Metal_Copper** for the frame and **M_Glass** to the addition brush,
    which was just created. Now, group them and duplicate both the brushes four times
    to create five windows. The screenshot of the dining area windows is shown as
    follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **M_Metal_Copper** 为框架，并使用 **M_Glass** 为刚刚创建的附加刷子。现在，将它们分组，并将两个刷子各复制四次以创建五个窗户。餐厅区域窗户的截图如下所示：
- en: '![Part 1 – creating large glass windows for the dining area](img/B03679_04_34.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![第1部分 – 为餐厅区域创建大型玻璃窗](img/B03679_04_34.jpg)'
- en: Part 2 – creating an open window for the window seat
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2部分 – 为窗座创建开放式窗户
- en: To create the window for the window seat area, create a subtractive geometry
    brush of size X50 x Y280 x Z220\. For this window, we have a protruding ledge
    of X50 x Y280 x Z5 at the bottom of the window. Then for the glass, we duplicate
    the subtractive brush of size X4 x Y278 x Z216, convert it to additive brush and
    adjust it to fit.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建窗座区域的窗户，创建一个尺寸为 X50 x Y280 x Z220 的减法几何刷子。对于这个窗户，我们在窗户底部有一个 X50 x Y280 x
    Z5 的突出边缘。然后对于玻璃，我们复制尺寸为 X4 x Y278 x Z216 的减法刷子，将其转换为添加刷子并调整以适应。
- en: Apply **M_Metal_Brushed** for the frame and **M_Glass** to the addition brush
    that was just created.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **M_Metal_Brushed** 为框架，并使用 **M_Glass** 为刚刚创建的附加刷子。
- en: '![Part 2 – creating an open window for the window seat](img/B03679_04_35.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![第2部分 – 为窗座创建开放式窗户](img/B03679_04_35.jpg)'
- en: Part 3 – creating windows for the room
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3部分 – 创建房间窗户
- en: 'For the room windows, create a subtractive brush of size X144 x Y40 x Z94\.
    This is to create a hollow in the wall for the prop frame: **SM_WindowFrame**.
    Duplicate the subtractive brush and prop to create two windows for the room.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于房间窗户，创建一个尺寸为 X144 x Y40 x Z94 的减法刷子。这是为了在墙上创建一个用于道具框架 **SM_WindowFrame** 的空洞：。复制减法刷子和道具以创建房间的两个窗户。
- en: Part 4 – creating the main door area
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4部分 – 创建主门区域
- en: For the main door area, we start by creating the doors and its frame, then the
    brick walls around the door and lastly, the remaining concrete plain wall.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主门区域，我们首先创建门及其框架，然后是门周围的砖墙，最后是剩余的混凝土平面墙。
- en: 'We have two doors with frames then some brick wall to augment before going
    back to the usual smooth walls. Here are the dimensions for creating this door
    area:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个带框架的门和一些砖墙需要增加，然后再回到通常的平滑墙。以下是创建这个门区域的尺寸：
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSPs | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Actual door x 2 | 20 | 116 | 250 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 实际门 x 2 | 20 | 116 | 250 |'
- en: '| Side frame x 2 | 25 | 4 | 250 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 侧框 x 2 | 25 | 4 | 250 |'
- en: '| Top frame | 25 | 242 | 5 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 顶部框架 | 25 | 242 | 5 |'
- en: 'Here are the dimensions for creating the area around the door:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建门周围区域的尺寸：
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSPs | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Brick wall side x 2 | 30 | 52 | 340 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 砖墙侧面 x 2 | 30 | 52 | 340 |'
- en: '| Brick wall top | 30 | 242 | 74 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 砖墙顶部 | 30 | 242 | 74 |'
- en: '| Smooth wall left | 30 | 126 | 340 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 左侧平滑墙 | 30 | 126 | 340 |'
- en: '| Smooth wall right | 30 | 130 | 360 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 右侧平滑墙 | 30 | 130 | 360 |'
- en: Creating basic furniture
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建基本家具
- en: Let us begin it part by part as follows.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分开始，如下所述。
- en: Part 1 – creating a dining table and placing chairs
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1部分 – 创建餐桌并放置椅子
- en: For the dining table, we will be customizing a wooden table with a table top
    of size X480 x Y160 x Z12 and two legs each of size X20 x Y120 x Z70 placed 40
    from the edge of the table. Material used to texture is **M_Wood_Walnut**.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于餐桌，我们将定制一个尺寸为 X480 x Y160 x Z12 的木质餐桌，并在餐桌边缘40厘米处放置两个尺寸为 X20 x Y120 x Z70
    的腿。用于纹理的材料是 **M_Wood_Walnut**。
- en: Then arrange eight chairs around the table using **SM_Chair** from the `Props`
    folder.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `Props` 文件夹中的 **SM_Chair** 在桌子周围安排八张椅子。
- en: Part 2 – decorating the sitting area
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2部分 – 装饰休息区
- en: 'There are two low tables in the middle and one low long table at the wall.
    Place three **SM_Couch** from the `Props` folder around the low tables. Here are
    the dimensions for the larger table:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 中间有两个低桌子，墙边有一个低长桌子。使用 `Props` 文件夹中的三个 **SM_Couch** 围绕低桌子放置。以下是大型桌子的尺寸：
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSPs | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Square top | 140 | 140 | 8 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 平面顶部 | 140 | 140 | 8 |'
- en: '| Leg x 2 | 120 | 12 | 36 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 腿 x 2 | 120 | 12 | 36 |'
- en: 'Here are the dimensions for the smaller table:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是小型餐桌的尺寸：
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSPs | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Leg x 2 | 120 | 12 | 36 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 腿 x 2 | 120 | 12 | 36 |'
- en: 'Here are the dimensions for a low long table at the wall:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是墙边低长桌的尺寸：
- en: '| BSPs needed | X | Y | Z |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 需要的 BSPs | X | Y | Z |'
- en: '| --- | --- | --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Block | 100 | 550 | 100 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 块 | 100 | 550 | 100 |'
- en: Part 3 – creating the window seat area
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3部分 – 创建窗户座位区
- en: Next to the open window, place a geometry box of size X120 x Y310 x Z100\. This
    is to create a simplified seat by the window.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的窗户旁边放置一个尺寸为 X120 x Y310 x Z100 的几何盒子。这是为了在窗户旁边创建一个简化的座位。
- en: Part 4 – creating the Japanese seating area
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4部分 – 创建日本座位区
- en: The Japanese square table with surface size X200 x Y200 x Z8 and 4 short legs,
    each of size X20 x Y20 x Z36) is placed close to the corner of the table.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 表面尺寸为 X200 x Y200 x Z8，并带有4条短腿（每条腿尺寸为 X20 x Y20 x Z36）的日本方形桌子放置在桌子角落附近。
- en: To create a leg space under the table, I used a subtractive brush (X140 x Y140
    x Z40) and placed it on the ground under the table. I used the corner of this
    subtractive brush as a guide as to where to place the short legs for the table.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在桌子下创造一个腿部空间，我使用了一个减法刷子（X140 x Y140 x Z40），并将其放置在桌子下面的地面上。我使用这个减法刷子的角落作为放置桌子短腿的指南。
- en: Part 5 – creating the kitchen cabinet area
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第5部分 – 创建厨房柜子区
- en: 'This is a simplified block prototype for the kitchen cabinet area. The following
    are the dimensions for L-shaped area:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个厨房柜子区的简化块原型。以下L形区域的尺寸：
- en: '| BSPs needed | Material | X | Y | Z |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 需要的BSPs | 材质 | X | Y | Z |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Shorter L: cabinet under tabletop | **M_Wood_Walnut** | 140 | 450 | 100 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 较短的L：桌面下的柜子 | **M_Wood_Walnut** | 140 | 450 | 100 |'
- en: '| Longer L: cabinet under tabletop | **M_Wood_Walnut** | 890 | 140 | 100 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 较长的L：桌面下的柜子 | **M_Wood_Walnut** | 890 | 140 | 100 |'
- en: '| Shorter L: tabletop | **M_Metal_Brushed_Nickel** | 150 | 450 | 10 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 较短的L：桌面 | **M_Metal_Brushed_Nickel** | 150 | 450 | 10 |'
- en: '| Longer L: tabletop | **M_Metal_Brushed_Nickel** | 900 | 150 | 10 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 较长的L：桌面 | **M_Metal_Brushed_Nickel** | 900 | 150 | 10 |'
- en: '| Shorter L: hanging cabinet | **M_Wood_Walnut** | 100 | 500 | 100 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 较短的L：悬挂柜子 | **M_Wood_Walnut** | 100 | 500 | 100 |'
- en: '| Longer L: hanging cabinet | **M_Wood_Walnut** | 900 | 100 | 100 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 较长的L：悬挂柜子 | **M_Wood_Walnut** | 900 | 100 | 100 |'
- en: 'The following are the dimensions for the island area (hood):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是小岛区域（风扇）的尺寸：
- en: '| BSPs needed | Material | X | Y | Z |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 需要的BSPs | 材质 | X | Y | Z |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Hood (wooden area) | **M_Wood_Walnut** | 400 | 75 | 60 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 风扇（木质区域） | **M_Wood_Walnut** | 400 | 75 | 60 |'
- en: '| Hood (metallic area) | **M_Metal_Chrome** | 500 | 150 | 30 |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 风扇（金属区域） | **M_Metal_Chrome** | 500 | 150 | 30 |'
- en: 'The following are the dimensions for the island area (table):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是小岛区域（桌子）的尺寸：
- en: '| BSPs needed | Material | X | Y | Z |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 需要的BSPs | 材质 | X | Y | Z |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Cabinet under the table | **M_Wood_Walnut** | 500 | 150 | 100 |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 桌下柜子 | **M_Wood_Walnut** | 500 | 150 | 100 |'
- en: '| Tabletop | **M_Metal_Chrome** | 550 | 180 | 10 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 桌面 | **M_Metal_Chrome** | 550 | 180 | 10 |'
- en: '| Sink (use a subtractive brush) | **M_Metal_Chrome** | 100 | 80 | 40 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 水槽（使用减法刷子） | **M_Metal_Chrome** | 100 | 80 | 40 |'
- en: '| Stovetop | **M_Metal_Burnished_Steel** | 140 | 100 | 5 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 炉灶台面 | **M_Metal_Burnished_Steel** | 140 | 100 | 5 |'
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered in-depth information about materials and lights.
    We learned how the rendering system works and the underlying graphics pipeline/technology
    such as Directx 11, DirectX 12, and OpenGL/Vulkan. We also learned how to use
    the Unreal 4 Material Editor to create custom materials and apply it into your
    level.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了材料和灯光的信息。我们学习了渲染系统的工作原理以及底层图形管道/技术，如Directx 11、Directx 12和OpenGL/Vulkan。我们还学习了如何使用Unreal
    4材质编辑器创建自定义材质并将其应用到你的级别中。
- en: We also explored the different types of lights and adjusting **Intensity**,
    **Attenuation Radius**, and other settings to customize lights for the level.
    We also learned how to import IES light profiles from light manufacturer's website
    to create realistic lights for the level. We learned about the differences between
    **Static**, **Stationary**, and **Movable** lights and how the different lights
    cast shadows for the level.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了不同类型的灯光，以及调整**强度**、**衰减半径**和其他设置来自定义级别的灯光。我们还学习了如何从灯光制造商的网站上导入IES灯光配置文件，以创建级别的真实灯光。我们还了解了**静态**、**固定**和**可移动**灯光之间的区别以及不同灯光如何为级别投射阴影。
- en: In the next chapter, we will learn about animation and artificial intelligence
    in games. Stay tuned for more!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习游戏中的动画和人工智能。敬请期待更多内容！
