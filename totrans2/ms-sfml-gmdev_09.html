<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9.  The Speed of Dark - Lighting and Shadows </h1></div></div></div><p>Contrasting differences are the very essence of existence, as the <em>yin-yang</em> symbol properly illustrates. Light and darkness are opposites, yet complementary, as they offset one another and give meaning through variety. Without darkness there can be no light, as they are never truly separate. By breathing light into our world, we are inevitably forced to add back the darkness that it creates. Let's follow the previous chapter and truly complete to our lighting engine by reintroducing the concept of darkness to it.</p><p>In this chapter, we will be covering the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using OpenGL to render to and sample from cubemap textures</li><li class="listitem" style="list-style-type: disc">Advanced shadow mapping for omni-directional point lights</li><li class="listitem" style="list-style-type: disc">The use of Percentage Closer Filtering to smooth out shadow edges</li><li class="listitem" style="list-style-type: disc">Combating common and frustrating issues with shadow mapping</li></ul></div><p>There's quite a bit of theory to get out of the way, so let's get to it!</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Use of third-party software</h1></div></div></div><p>Before diving into such a difficult subject to debug, it's always nice to have proper tools that will ease the headaches and reduce the number of questions one might ask oneself during development. While normal code executed on the <em>CPU</em> can just be stepped through and analyzed during runtime, shader code and OpenGL resources, such as textures are a bit more difficult to handle. Most, if not all, <em>C++</em> compilers don't have native support for dealing with <em>GPU-bound</em> problems. Luckily, there is software out there that makes it easier to deal with that very predicament.</p><p>Among the few tools that exist out there to alleviate such headaches, <em>CodeXL</em> by <em>AMD Developer Tools Team</em> stands out. It's a free piece of software that can be used as a standalone application for Windows and Linux or even as a plugin for Visual Studio. Its most prominent features include being able to view OpenGL resources (including textures) while the program is running, profile the code and find bottlenecks, and even step through the shader code as it's being executed (given the right hardware). The tool can be found and downloaded here: <a class="ulink" href="http://gpuopen.com/compute-product/codexl/">http://gpuopen.com/compute-product/codexl/</a>.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Theory behind shadowing techniques</h1></div></div></div><p>There are a couple of different techniques that can be used when implementing realistic looking shadows in games. Choosing the right one can not only impact the kind of performance your application is going to exhibit, but can also heavily influence how good the effect is going to look in the end.</p><p>An approach that isn't at all uncommon for 2D is referred to as <strong>ray tracing</strong>. Depending on the type of light, a number of rays are cast in an appropriate direction. Shadows are then implemented depending on which solids these rays actually intersect with. Some simpler games tend to create an overlay mask and fill in geometrically the parts of it that are "in the shadow". This mask is later overlaid on top of the usual scene and blended in order to create the aesthetic of darkened areas meant to represent shadows. More advanced 3D games tend to allow rays to bounce around the scene, carrying different information about the particular fragments that they intersect with. By the time a ray reaches the camera, it will have enough information to do more than create simple shadows. Scenes that require extremely advanced lighting tend to use this technique, and rightly so, as it imitates the way light bounces off objects and hits the observer's eye in real life.</p><p>An older, but still widely used approach for specifically creating shadows is called <strong>shadow mapping</strong>. The essence of this technique comes down to simply rendering the scene to an off screen buffer from the point of view of the light. All the solids' depth information, as opposed to color information, is written to this buffer as pixel data. When the real scene is rendered, some matrix math is then used to sample the right pixels of the shadow map to figure out whether they can be directly seen by the light, thus being illuminated, or whether they're being obstructed by something, and therefore sitting in the shadow.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec93"/>Shadow mapping</h2></div></div></div><p>The main idea behind creating a shadow map is rendering the scene from the point of view of the light, and effectively encoding the depth of a particular piece of geometry being rendered as a color value that can later be sampled. The depth value itself is nothing more than the distance between the position of the light and the position of the vertex. Consider the following diagram:</p><div><img src="img/image_09_001.jpg" alt="Shadow mapping"/></div><p>The distance between the light and a given vertex will be converted to a color value by simply dividing it by the frustum far distance, yielding a result in a range <em>[0;1]</em>. The frustum far value is simply the distance of how far the light/camera can see.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec94"/>Omni-directional point lights</h2></div></div></div><p>In the previous chapter, we managed to create lights that emit in all directions from a center point. These types of lights have a very fitting name: omni-directional point lights. Dealing with shadow mapping for these lights comes with a certain layer of complexity, as the scene now needs to be drawn in all six directions, rather than just one if we were dealing with a directional light. This means we need a good way of storing the results of this process that can be accessed with relative ease. Luckily, OpenGL provides a new type of texture we can use, the <strong>cubemap</strong>.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec18"/>Cubemap textures</h3></div></div></div><p>A cubemap is pretty much exactly what it sounds like. It's a special texture that really holds six textures for each face of the cube. These textures are internally stored in an <em>unfolded</em> manner, as shown here:</p><div><img src="img/image_09_003.jpg" alt="Cubemap textures"/></div><p>Because of this property, rendering shadow maps for omni-directional lights can be as simple as rendering the scene once for each direction of a cubemap. Sampling them is also quite easy. The shape of a cube lends itself to some useful properties we can exploit. If all of the cube's vertices are in relation to its absolute center, then the coordinates of these vertices can also be thought of as directional vectors:</p><div><img src="img/image_09_005.jpg" alt="Cubemap textures"/></div><p>
</p><div><img src="img/image_09_006.jpg" alt="Cubemap textures"/></div><p>The direction (0, 1, 0) from the center of the cube would be pointing directly in the middle of the <em>+Y</em> face, for example. Since each face of a cubemap texture also holds a texture of its own that represents the view of the scene, it can easily be sampled using these coordinates. For a 2D texture, our shaders had to use the <code class="literal">sampler2D</code> type and provide 2D coordinates of the sampling location. Cubemaps have their own sampler type, <code class="literal">samplerCube</code>, and use a 3D vector for sampling. The consequence of this is that the largest member of the 3D vector is used to determine which face is to be sampled, and the other two members become the UV texture coordinates for that particular 2D texture/face.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>Cube textures can be used for much more than shadow mapping. 3D environments can take advantage of them when implementing skyboxes and reflective/refractive materials, to name just a few techniques.</p></div></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Preparations for rendering</h1></div></div></div><p>It's safe to say that all of this functionality is a bit beyond the scope of SFML, as it seeks to deal with simple two-dimensional concepts. While we're still going to be using SFML to render our sprites, the lighting and shadowing of the scene will have to fall back on raw OpenGL. This includes setting up and sampling cubemap textures, as well as creating, uploading, and drawing 3D primitives used to represent objects that cast shadows.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec95"/>Representing shadow casters</h2></div></div></div><p>While SFML is great for rendering sprites, we must remember that these are two-dimensional objects. In 3D space, our character would literally be paper thin. This means that all of our game's shadow casters are going to need some 3D geometry behind them. Keep in mind that these basic rendering concepts have already been covered in <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>, <em>One Step Forward, One Level Down - OpenGL Basics</em>. Let's start by creating some common definitions that this system will use:</p><pre class="programlisting">static const glm::vec3 CubeMapDirections[6] = { 
  { 1.f, 0.f, 0.f },  // 0 = Positive X 
  { -1.f, 0.f, 0.f }, // 1 = Negative X 
  { 0.f, 1.f, 0.f },  // 2 = Positive Y 
  { 0.f, -1.f, 0.f }, // 3 = Negative Y 
  { 0.f, 0.f, 1.f },  // 4 = Positive Z 
  { 0.f, 0.f, -1.f }  // 5 = Negative Z 
}; 
</pre><p>This is going to be a common lookup array for us, and it's important that the directional vectors here are defined correctly. It represents a direction towards each face of the cubemap texture.</p><p>Another common data structure we will be using is a list of indices used to draw the cubes/3D rectangles that represent our shadow casters:</p><pre class="programlisting">static const int ShadowMeshIndices = 36; 
static const GLuint CubeIndices[ShadowMeshIndices] = { 
  0, 4, 7, 7, 3, 0,  // Front 
  0, 1, 5, 5, 4, 0,  // Left 
  3, 7, 6, 6, 2, 3,  // Right 
  1, 2, 6, 6, 5, 1,  // Back 
  7, 4, 5, 5, 6, 7,  // Up 
  1, 0, 3, 3, 2, 1   // Down 
}; 
</pre><p>Since the cubes have 6 faces and each face uses 6 indices to enumerate the two triangles that make them up, we have a total of 36 indices.</p><p>Finally, we need an up vector for each direction of a cubemap texture:</p><pre class="programlisting">static const glm::vec3 CubeMapUpDirections[6] = { 
  { 0.f, -1.f, 0.f },  // 0 = Positive X 
  { 0.f, -1.f, 0.f }, // 1 = Negative X 
  { 0.f, 0.f, -1.f },  // 2 = Positive Y 
  { 0.f, 0.f, -1.f }, // 3 = Negative Y 
  { 0.f, -1.f, 0.f },  // 4 = Positive Z 
  { 0.f, -1.f, 0.f }  // 5 = Negative Z 
}; 
</pre><p>In order to get correct shadow mapping for the geometry, we're going to need to use these up directions when rendering to a shadow cubemap. Note that, unless we're rendering to <em>Y</em> faces of the cubemap, the <em>Y</em> direction is always used as up. This allows the geometry being rendered to be seen correctly by the camera.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec19"/>Implementing the shadow caster structure</h3></div></div></div><p>Representing the literally shapeless entities of our game is the task we're going to be tackling next. In order to minimize the memory usage of this approach, it will be broken down into two parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Prototype</strong>: This is a structure that holds handles to uploaded geometry used by OpenGL. This kind of object represents a unique, one of a kind model.</li><li class="listitem" style="list-style-type: disc"><strong>Caster</strong>: This is a structure that holds a pointer to a prototype it's using, along with its own transform, to position, rotate, and scale it correctly.</li></ul></div><p>The prototype structure needs to hold on to the resources it allocates, as follows:</p><pre class="programlisting">struct ShadowCasterPrototype { 
  ... 
  glm::vec3 m_vertices[ShadowMeshVertices]; 
  GLuint m_VAO; 
  GLuint m_VBO; 
  GLuint m_indexVBO; 
}; 
</pre><p>The constructor and destructor of this structure will take care of allocation/de-allocation of these resources:</p><pre class="programlisting">ShadowCasterPrototype() : m_VAO(0), m_VBO(0), m_indexVBO(0) {} 
~ShadowCasterPrototype() { 
  if (m_VBO) { glDeleteBuffers(1, &amp;m_VBO); } 
  if (m_indexVBO) { glDeleteBuffers(1, &amp;m_indexVBO); } 
  if (m_VAO) { glDeleteVertexArrays(1, &amp;m_VAO); } 
} 
</pre><p>Once the internal <code class="literal">m_vertices</code> data member is properly filled out, the geometry can be submitted to the GPU as follows:</p><pre class="programlisting">void UploadVertices() { 
  if (!m_VAO) { glGenVertexArrays(1, &amp;m_VAO); } 
  glBindVertexArray(m_VAO); 
  if (!m_VBO) { glGenBuffers(1, &amp;m_VBO); } 
  if (!m_indexVBO) { glGenBuffers(1, &amp;m_indexVBO); } 
 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
  glBufferData(GL_ARRAY_BUFFER, 
    ShadowMeshVertices * sizeof(m_vertices[0]), m_vertices, 
    GL_STATIC_DRAW); 
  // Position vertex attribute. 
  glEnableVertexAttribArray(0); 
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 
    sizeof(glm::vec3), 0); 
 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); 
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 
    ShadowMeshIndices * sizeof(CubeIndices[0]), CubeIndices, 
    GL_STATIC_DRAW); 
  glBindBuffer(GL_ARRAY_BUFFER, 0); 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 
 
  glBindVertexArray(0); 
} 
</pre><p>Once the vertex array object and two buffers for vertices and indices are properly created, they're all bound and used to push the data to. Note the highlighted portion of the code that deals with the vertex attributes. Since this geometry is only going to be used to generate shadows, we really don't need anything else except the vertex position. The necessary math of converting all of that information into color values that represent distance from the light source is going to be done inside the shaders.</p><p>Also, note the usage of indices to render this geometry here. Doing it this way allows us to save some space by not having to upload twice as many vertices to the GPU as we would have to otherwise.</p><p>The drawing of the shadow primitives is just as simple as one would imagine:</p><pre class="programlisting">void Draw() { 
  glBindVertexArray(m_VAO); 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); 
  glDrawElements(GL_TRIANGLES, ShadowMeshIndices, 
    GL_UNSIGNED_INT, 0); // 0 = offset. 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 
  glBindBuffer(GL_ARRAY_BUFFER, 0); 
  glBindVertexArray(0); 
} 
</pre><p>Once all of the buffers are bound, we invoke <code class="literal">glDrawElements</code>. Let it know we're drawing triangles, give the method the count of indices to use, specify their data type, and provide the proper offset for those indices, which in this case is <em>0</em>.</p><p>Finally, because we're using prototypes to store unique pieces of geometry, it's definitely useful to overload the <code class="literal">==</code> operator for easy checking of matching shapes:</p><pre class="programlisting">bool operator == (const ShadowCasterPrototype&amp; l_rhs) const { 
  for (unsigned short i = 0; i &lt; ShadowMeshVertices; ++i) { 
    if (m_vertices[i] != l_rhs.m_vertices[i]) { return false; } 
  } 
  return true; 
} 
</pre><p>Each vertex of the shadow primitive is iterated over and compared to the equivalent vertex of the provided argument. So far, nothing out of the ordinary!</p><p>The prototypes are going to need to be identified in some way when they're being stored. Using string identifiers can be quite intuitive in this case, so let's define a proper storage container type for this structure:</p><pre class="programlisting">using ShadowCasterPrototypes = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;ShadowCasterPrototype&gt;&gt;; 
</pre><p>With that out of the way, we can implement our simple <code class="literal">ShadowCaster</code> structure that's going to hold all of the variable information about the prototype:</p><pre class="programlisting">struct ShadowCaster { 
  ShadowCaster() : m_prototype(nullptr) { } 
  ShadowCasterPrototype* m_prototype; 
  GL_Transform m_transform; 
}; 
</pre><p>As you can see, it's a very simple data structure that holds a pointer to a prototype it uses, as well as its own <code class="literal">GL_Transform</code> member, which is going to store the displacement information of an object.</p><p>The shadow casters are also going to need a proper storage data type:</p><pre class="programlisting">using ShadowCasters = std::vector&lt;std::unique_ptr&lt;ShadowCaster&gt;&gt;; 
</pre><p>This effectively leaves us with the means to create and manipulate different types of shadow-casting primitives in a memory-conservative manner.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec96"/>Creating the transform class</h2></div></div></div><p>The transform class that we're using is exactly the same as the one in <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>, <em>One Step Forward, One Level Down - OpenGL Basics</em>. For a quick refresher, let's take a look at the most important part of it that we're going to need for this process--the generation of a model matrix:</p><pre class="programlisting">glm::mat4 GL_Transform::GetModelMatrix() { 
  glm::mat4 matrix_pos = glm::translate(m_position); 
  glm::mat4 matrix_scale = glm::scale(m_scale); 
  // Represent each stored rotation as a different matrix, 
  // because we store angles. 
  //                Directional vector  x, y, z 
  glm::mat4 matrix_rotX = 
    glm::rotate(m_rotation.x, glm::vec3(1, 0, 0)); 
  glm::mat4 matrix_rotY = 
    glm::rotate(m_rotation.y, glm::vec3(0, 1, 0)); 
  glm::mat4 matrix_rotZ = 
    glm::rotate(m_rotation.z, glm::vec3(0, 0, 1)); 
  // Create a rotation matrix. Multiply in reverse order it 
  // needs to be applied. 
  glm::mat4 matrix_rotation = matrix_rotZ*matrix_rotY*matrix_rotX; 
  // Apply transforms in reverse order they need to be applied in. 
  return matrix_pos * matrix_rotation * matrix_scale; 
} 
</pre><p>All of this should be familiar by now, and if it isn't, a quick zip through <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>, <em>One Step Forward, One Level Down - OpenGL Basics</em> is definitely in order. The main idea, however, is combining the translation, scale, and rotation matrices in the right order to retrieve a single matrix that contains all of the information about the primitive required to bring its vertices from object space to world space.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec97"/>Creating a camera class</h2></div></div></div><p>Similar to the <code class="literal">GL_Transform</code> class, we're also going to incorporate the <code class="literal">GL_Camera</code> class from <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>,<em> One Step Forward, One Level Down - OpenGL Basics</em>. When we're rendering shadow maps, the projection and view matrices for all six directions will need to be submitted to the respective shaders. This makes the <code class="literal">GL_Camera</code> class perfect for representing a light in a scene that needs to draw what it sees into a cubemap texture. Once again, this has been covered already, so we're just going to breeze through it:</p><pre class="programlisting">GL_Camera::GL_Camera(const glm::vec3&amp; l_pos, float l_fieldOfView, 
  float l_aspectRatio, float l_frustumNear, float l_frustumFar) 
  :m_position(l_pos),m_fov(l_fieldOfView),m_aspect(l_aspectRatio), 
  m_frustumNear(l_frustumNear), m_frustumFar(l_frustumFar) 
{ 
  RecalculatePerspective(); 
  m_forwardDir = glm::vec3(0.f, 0.f, 1.f); 
  m_upDir = glm::vec3(0.f, 1.f, 0.f); 
} 
</pre><p>Appropriately enough, shadow maps are going to be drawn using a perspective projection. After all the necessary information about view frustum is collected, we can begin constructing the matrices necessary to transform those vertices from world space to the light's view space, as well as to clip space:</p><pre class="programlisting">glm::mat4 GL_Camera::GetViewMatrix() { 
  return glm::lookAt(m_position, m_position + m_forwardDir, 
    m_upDir); 
} 
glm::mat4&amp; GL_Camera::GetProjectionMatrix() { 
  return m_perspectiveMatrix; 
} 
 
void GL_Camera::RecalculatePerspective() { 
  m_perspectiveMatrix = glm::perspective(glm::radians(m_fov), 
    m_aspect, m_frustumNear, m_frustumFar); 
} 
</pre><p>We're using <code class="literal">glm::lookAt</code> to construct a view matrix for the light's camera. Then, <code class="literal">glm::perspective</code> is used in another method to create the perspective projection matrix for the camera.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>It's very important to remember that <code class="literal">glm::perspective</code> takes the field of view angle of the view frustum as the first argument. It expects this parameter to be in <strong>radians</strong>, not degrees! Because we're storing it in degrees, <code class="literal">glm::radians</code> is used to convert that value. This is a very easy mistake to make and many people end up having problems with their shadow maps not mapping correctly.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec98"/>Defining a cube texture class</h2></div></div></div><p>Now that we have the storage of geometry and representation of the light's view frustum figured out, it's time to create the cube texture we're going to use to actually render the scene to.</p><p>Let's start by creating a simple class definition for it:</p><pre class="programlisting">class CubeTexture { 
public: 
  CubeTexture(); 
  ~CubeTexture(); 
 
  void RenderingBind(); 
  void RenderingUnbind(); 
  void SamplingBind(unsigned int l_unit); 
  void SamplingUnbind(unsigned int l_unit); 
 
  GLuint GetTextureHandle()const; 
 
  void RenderToFace(unsigned int l_face); 
  void Clear(); 
 
  static const unsigned int TextureWidth = 1024; 
  static const unsigned int TextureHeight = 1024; 
private: 
  void Create(); 
  void CreateBuffers(); 
  void CreateFaces(); 
  GLuint m_textureID; // Texture handle. 
  GLuint m_fbo; // Frame-buffer handle. 
  GLuint m_rbo; // Render-buffer handle. 
}; 
</pre><p>The texture is going to be used for two distinctive actions: being rendered to and being sampled. Both of these processes have a method for binding and unbinding the texture, with the notable difference that the sampling step also requires a texture unit as an argument. We're going to cover that soon. This class also needs to have a separate method that needs to be called for each of the six faces when they're being rendered.</p><p>Although cube textures can be used for many things, in this particular instance, we're simply going to be using them for shadow mapping. The texture dimensions, therefore, are defined as constants of <em>1024px</em>.</p><div><div><h3 class="title"><a id="tip35"/>Tip</h3><p>The size of a cubemap texture matters greatly, and can cause artifacting if left too small. Smaller textures will lead to sampling inaccuracies and will cause jagged shadow edges.</p></div></div><p>Lastly, alongside the helper methods used when creating the texture and all of the necessary buffers, we store the handles to the texture itself, the frame buffer object, and render buffer object. The last two objects haven't been covered until this point, so let's dive right in and see what they're for!</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec20"/>Implementing the cube texture class</h3></div></div></div><p>Let's start, as always, by covering the construction and destruction of this particular OpenGL asset:</p><pre class="programlisting">CubeTexture::CubeTexture() : m_textureID(0), m_fbo(0), m_rbo(0) 
  { Create(); } 
CubeTexture::~CubeTexture() { 
  if (m_fbo) { glDeleteFramebuffers(1, &amp;m_fbo); } 
  if (m_rbo) { glDeleteRenderbuffers(1, &amp;m_rbo); } 
  if (m_textureID) { glDeleteTextures(1, &amp;m_textureID); } 
} 
</pre><p>Similar to geometry classes, the handles are initialized to values of <em>0</em> to indicate their state of not being set up. The destructor checks those values and invokes the appropriate <code class="literal">glDelete</code> methods for the buffers/textures used.</p><p>Creating the cubemap is quite similar to a regular 2D texture, so let's take a look:</p><pre class="programlisting">void CubeTexture::Create() { 
  if (m_textureID) { return; } 
  glGenTextures(1, &amp;m_textureID); 
  CreateFaces(); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_MAG_FILTER, GL_NEAREST); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_MIN_FILTER, GL_NEAREST); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
 
  CreateBuffers(); 
  glBindTexture(GL_TEXTURE_CUBE_MAP, 0); 
} 
</pre><p>First, a check is made to make sure we haven't already allocated this object. Provided that isn't the case, <code class="literal">glGenTextures</code> is used, just like for 2D textures, to create space for one texture object. Our first private helper method is then invoked to create all six faces of the cubemap, which brings us to the parameter setup. The <em>Min/Mag</em> filters are set up to use the nearest-neighbor interpolation, but can later be converted to <code class="literal">GL_LINEAR</code> for smoother results, if necessary. The texture wrapping parameters are then set up so that they're clamped to the edge, giving us a seamless transition between faces.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>Note that there are three parameters for texture wrapping: R, S, and T. That's because we're dealing with a three-dimensional texture type now, so each axis must be accounted for.</p></div></div><p>Lastly, another helper method is invoked for the creation of the buffers, just before we unbind the texture as we're done with it.</p><p>The creation of the cubemap faces, once again, is similar to how we set up its 2D counterpart back in <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>, <em>One Step Forward, One Level Down - OpenGL Basics</em>, but the trick is to do it once for each face:</p><pre class="programlisting">void CubeTexture::CreateFaces() { 
  glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureID); 
  for (auto face = 0; face &lt; 6; ++face) { 
    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, 0,GL_RGBA, 
      TextureWidth, TextureHeight, 0, GL_RGBA, 
      GL_UNSIGNED_BYTE, nullptr); 
  } 
} 
</pre><p>Once the texture is bound, we iterate over each face and use <code class="literal">glTexImage2D</code> to set the face up. Each face is treated as a 2D texture, so this should really be nothing new to look at. Note, however, the use of the <code class="literal">GL_TEXTURE_CUBE_MAP_POSITIVE_X</code> definition usage is the first argument. 2D textures would take in a <code class="literal">GL_TEXTURE_2D</code> definition, but because cubemaps are stored in an unfolded manner, getting this part right is important.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>There are six definitions of <code class="literal">GL_TEXTURE_CUBE_MAP_</code>*. They're all defined in a row of <em>+X</em>, <em>-X</em>, <em>+Y</em>, <em>-Y</em>, <em>+Z</em>, and <em>-Z</em>, which is why we can use some basic arithmetic to pass in the correct face to the function by simply adding an integer to the definition.</p></div></div><p>Clearing the cubemap texture is relatively easy:</p><pre class="programlisting">void CubeTexture::Clear() { 
  glClearColor(1.f, 1.f, 1.f, 1.f); 
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
} 
</pre><p>Note that we're specifying the clear color as white, because that represents <em>infinite distance from the light</em> in a shadow map.</p><p>Finally, sampling the cubemap is actually not any different from sampling a regular 2D texture:</p><pre class="programlisting">void CubeTexture::SamplingBind(unsigned int l_unit) { 
  assert(l_unit &gt;= 0 &amp;&amp; l_unit &lt;= 31); 
  glActiveTexture(GL_TEXTURE0 + l_unit); 
  glEnable(GL_TEXTURE_CUBE_MAP); 
  glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureID); 
} 
void CubeTexture::SamplingUnbind(unsigned int l_unit) { 
  assert(l_unit &gt;= 0 &amp;&amp; l_unit &lt;= 31); 
  glActiveTexture(GL_TEXTURE0 + l_unit); 
  glBindTexture(GL_TEXTURE_CUBE_MAP, 0); 
  glDisable(GL_TEXTURE_CUBE_MAP); 
} 
</pre><p>Both binding and unbinding for sampling requires us to pass in the texture unit we want to use. Once the unit is active, we should enable the use of cubemaps and then bind the cubemap texture handle. The reverse of this procedure should be followed when unbinding the texture.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>Keep in mind that the respective <code class="literal">sampler2D</code>/<code class="literal">samplerCube</code> uniforms inside fragment shaders are set to hold the unit ID of the texture they're sampling. When a texture is bound, the specific ID of that unit will be used to access it in a shader from then on, not the actual texture handle.</p></div></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec1"/>Rendering to an off-screen buffer</h4></div></div></div><p>Something we didn't cover in <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>, <em>One Step Forward, One Level Down - OpenGL Basics</em> is rendering a scene to a buffer image, rather than drawing directly onscreen. Luckily, because OpenGL operates as a giant state machine, it's just a matter of invoking the right functions at the right time, and doesn't involve us having to redesign the rendering procedures in any way.</p><p>In order to render to a texture object, we must use what is called a <strong>framebuffer</strong>. It's a very basic object that directs draw calls to a texture the FBO is bound to. While FBOs are useful for color information, they don't carry the depth components with them. A <strong>renderbuffer</strong> object is used for that very purpose of attaching additional components to the FBO.</p><p>The first step to drawing something offscreen is creating a <code class="literal">FRAMEBUFFER</code> object and a <code class="literal">RENDERBUFFER</code> object:</p><pre class="programlisting">void CubeTexture::CreateBuffers() { 
  glGenFramebuffers(1, &amp;m_fbo); 
  glBindFramebuffer(GL_FRAMEBUFFER, m_fbo); 
  glGenRenderbuffers(1, &amp;m_rbo); 
  glBindRenderbuffer(GL_RENDERBUFFER, m_rbo); 
 
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, 
    TextureWidth, TextureHeight); 
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, 
    GL_RENDERBUFFER, m_rbo); 
  auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER); 
  if (status != GL_FRAMEBUFFER_COMPLETE) { ... } // Print status. 
  glBindFramebuffer(GL_FRAMEBUFFER, 0); 
} 
</pre><p>After the buffers have been generated, the render buffer needs to have some storage allocated for any additional components it will provide. In this case, we're simply dealing with the depth component.</p><div><div><h3 class="title"><a id="tip39"/>Tip</h3><p>The <code class="literal">GL_DEPTH_COMPONENT24</code> simply indicates that each depth pixel has a size of 24 bits. This definition can be replaced with a basic <code class="literal">GL_DEPTH_COMPONENT</code>, which will allow the application to choose the pixel size.</p></div></div><p>The depth render buffer is then attached to the FBO as a depth attachment. Finally, if there were any errors during this procedure, <code class="literal">glCheckFramebufferStatus</code> is used to catch them. The next line simply prints out the status variable using <code class="literal">std::cout</code>.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>Frame buffers should always be unbound when no longer used, using <code class="literal">glBindFramebuffer(GL_FRAMEBUFFER, 0)</code>! That's the only way we're ever going to go back to rendering subsequent geometry to the screen, rather than the buffer texture.</p></div></div><p>Now that we have the buffers set up, let's use them! When drawing to a buffer texture is desired, it's first necessary to bind the frame buffer:</p><pre class="programlisting">void CubeTexture::RenderingBind() { 
  glBindFramebuffer(GL_FRAMEBUFFER, m_fbo); 
} 
void CubeTexture::RenderingUnbind() { 
  glBindFramebuffer(GL_FRAMEBUFFER, 0); // Render to screen. 
} 
</pre><p>Unbinding the FBO is necessary after we're done with it. Using <code class="literal">RenderingUnbind()</code> means that any subsequent geometry will be drawn onscreen.</p><p>Of course, just because the FBO is bound, doesn't mean we're going to magically start drawing to the cubemap. In order to do that, we must draw to one face at a time by binding the frame buffer to the desired face of the cubemap:</p><pre class="programlisting">void CubeTexture::RenderToFace(unsigned int l_face) { 
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
    GL_TEXTURE_CUBE_MAP_POSITIVE_X + l_face, m_textureID, 0); 
  Clear(); 
} 
</pre><p>The first argument to <code class="literal">glFramebufferTexture2D</code> simply indicates we're dealing with an FBO. We then specify that we want to use <code class="literal">GL_COLOR_ATTACHMENT0</code>. Frame buffers can have multiple attachments and use shaders to output different data to each one of them. For our purposes, we're only going to need to use one attachment.</p><p>Because we're rendering to one face of the cubemap at a time, basic definition arithmetic is, once again, used to pick the correct face of the cube to render to. Finally, the texture handle and mipmapping level are passed in at the very end, just before <code class="literal">Clear()</code> is invoked to clear the face we currently bound to complete white.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Rendering the shadow maps</h1></div></div></div><p>We now have everything we need in order to start rendering shadow maps of our scene. Some rather significant changes are going to have to be made to the <code class="literal">LightManager</code> class in order to support this functionality, not to mention properly store and use these shadow map textures during later passes. Let's see what changes we need to make in order to make this happen.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec99"/>Modifying the light manager</h2></div></div></div><p>First, let's make some adjustments to the light manager class definition. We're going to need a couple of methods to add shadow caster prototypes, add actual shadow casting objects, and render the shadow maps:</p><pre class="programlisting">class LightManager { 
public: 
  ... 
  const std::string&amp; AddCasterPrototype(const std::string&amp; l_name, 
    std::unique_ptr&lt;ShadowCasterPrototype&gt; l_caster); 
  ShadowCaster* AddShadowCaster(const std::string&amp; l_prototypeName); 
  ShadowCasterPrototype* GetPrototype(const std::string&amp; l_name); 
  ... 
private: 
  ... 
  void DrawShadowMap(GLuint l_shadowShader, LightBase&amp; l_light, 
    unsigned int l_texture); 
  ... 
  ShadowCasterPrototypes m_casterPrototypes; 
  ShadowCasters m_shadowCasters; 
  GL_Camera m_perspectiveCamera; 
  std::unique_ptr&lt;CubeTexture&gt; m_cubeTextures[LightsPerPass]; 
  ... 
}; 
</pre><p>In addition to the aforementioned methods, the <code class="literal">LightManager</code> class is also going to need to store extra information to support these changes. A list of both shadow primitive prototypes and the primitives themselves will need to be used to manage the entities that have to cast shadows. Additionally, we need to have the camera class that will be used as the point of view of the light.</p><p>Lastly, an array of cubemap textures is required, since each light onscreen will be potentially seeing the scene from a completely different point of view, of course. The size of this array is simply the number of lights we're dealing with per shader pass, because these cubemap textures only need to exist for as long as they're being sampled. Once the lighting pass for those particular lights is over, the textures can be re-used for the next batch.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec21"/>Implementing the light manager changes</h3></div></div></div><p>The adjustments to the constructor of the <code class="literal">LightManager</code> class are fairly simple to make this work:</p><pre class="programlisting">LightManager::LightManager(...) : ..., 
  m_perspectiveCamera({0.f, 0.f, 0.f}, 90.f, 
    CubeTexture::TextureWidth / CubeTexture::TextureHeight, 
    1.f, 200.f) 
{ 
  ... 
  for (auto i = 0; i &lt; LightsPerPass; ++i) { 
    m_cubeTextures[i] = std::make_unique&lt;CubeTexture&gt;(); 
  } 
} 
</pre><p>The first thing we need to worry about is setting up the perspective camera correctly. It's initialized to be positioned at absolute zero coordinates in the world, and has its field of view angle set to <strong>90 degrees</strong>. The aspect ratio of the perspective camera is obviously going to be <em>1</em>, because the width and height of the textures we're using for rendering shadow casters to are identical. The view frustum minimum value is set to <em>1.f</em>, which ensures that the geometry won't be rendered if the light is intersecting with a face. The maximum value, however, will change for each light, depending on its radius. This default value isn't really important.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>Setting the field of view angle of <strong>90</strong> degrees for rendering a scene to a cubemap texture is important, as that's the only way the scene is going to be captured completely for each direction the camera looks at. Going too low on this value means there are going to be blind spots, and going too high will cause overlapping.</p></div></div><p>The last thing we need to do in the constructor is make sure that all cubemap textures are allocated properly.</p><p>Next, let's worry about adding shadow caster prototypes to the light manager:</p><pre class="programlisting">const std::string&amp; LightManager::AddCasterPrototype( 
  const std::string&amp; l_name, 
  std::unique_ptr&lt;ShadowCasterPrototype&gt; l_caster) 
{ 
  auto itr = m_casterPrototypes.find(l_name); 
  if (itr != m_casterPrototypes.end()) { 
    l_caster.release(); return l_name; 
  } 
  for (auto&amp; prototype : m_casterPrototypes) { 
    if (*prototype.second == *l_caster) { 
      l_caster.release(); return prototype.first; 
    } 
  } 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  l_caster-&gt;UploadVertices(); 
  m_casterPrototypes.emplace(l_name, std::move(l_caster)); 
  return l_name; 
} 
</pre><p>When adding a prototype, the caller of this particular method will provide a string identifier for it, as well as move its established and allocated smart pointer to the second argument after the vertices have been properly loaded. First, we make sure the name provided as an argument isn't already taken. If it is, that same string is returned back just after the memory for the prototype provided as an argument is released.</p><p>The second test makes sure that a prototype with the exact arrangement of vertices doesn't already exist under a different name, by iterating over every stored prototype and using the <code class="literal">== </code>operator we implemented earlier to compare the two. If something is found, the name of that prototype is returned instead, just after the <code class="literal">l_caster</code> is released.</p><p>Finally, since we can be sure that the prototype we're adding is completely unique, the render window is set to active. <code class="literal">UploadVertices</code> on the object is invoked to send the data to the GPU and the prototype is placed inside the designated container.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Using <code class="literal">sf::RenderWindow::setActive(true)</code> ensures that the main context is used while the vertices are uploaded. OpenGL <strong>does not</strong> share its states among different contexts, and since SFML likes to keep a number of different contexts alive internally, it's imperative to make sure the main context is selected during all operations.</p></div></div><p>Adding shadow casters themselves is relatively easy as well:</p><pre class="programlisting">ShadowCaster* LightManager::AddShadowCaster( 
  const std::string&amp; l_prototypeName) 
{ 
  auto prototype = GetPrototype(l_prototypeName); 
  if (!prototype) { return nullptr; } 
  m_shadowCasters.emplace_back(); 
  auto&amp; caster = m_shadowCasters.back(); 
  caster = std::make_unique&lt;ShadowCaster&gt;(); 
  caster-&gt;m_prototype = prototype; 
  return caster.get(); 
} 
</pre><p>This method only takes a string identifier for the prototype to be used, and allocates space for a new shadow caster object, provided the prototype with said name exists. Note the line just before the <code class="literal">return</code> statement. It ensures that the located prototype is passed to the shadow caster, so that it can use the prototype later.</p><p>Obtaining the prototypes is incredibly simple, and only requires a lookup into an <code class="literal">unordered_map</code> container:</p><pre class="programlisting">ShadowCasterPrototype* LightManager::GetPrototype( 
  const std::string&amp; l_name) 
{ 
  auto itr = m_casterPrototypes.find(l_name); 
  if (itr == m_casterPrototypes.end()) { return nullptr; } 
  return itr-&gt;second.get(); 
} 
</pre><p>We now only have one task at hand drawing the shadow maps!</p><div><div><div><div><h4 class="title"><a id="ch09lvl4sec2"/>Drawing the actual shadow maps</h4></div></div></div><p>In order to keep this manageable and compartmentalized, we're going to break down the <code class="literal">DrawShadowMap</code> method into smaller parts that we can discuss independently of the rest of the code. Let's start by looking at the actual blueprint of the method:</p><pre class="programlisting">void LightManager::DrawShadowMap(GLuint l_shadowShader, 
  LightBase&amp; l_light, unsigned int l_texture) 
{ 
  ... 
} 
</pre><p>First, it takes in a handle for the shadow pass shader. This is about as raw as it gets, since the handle is a simple unsigned integer we're going to bind to before drawing. The second argument is a reference to a light that we're currently drawing the shadow map for. Lastly, we have an <em>unsigned integer</em> that serves as the ID for the light that's being rendered in the current pass. In the case of having 4 lights per shader pass, this value will range from 0 to 3, and then get reset in the next pass. It is going to be used as an index for the cubemap texture lookup.</p><p>Now, it's time to really get into the actual rendering of the shadow maps, starting with enabling necessary OpenGL features:</p><pre class="programlisting">glEnable(GL_DEPTH_TEST); 
glEnable(GL_CULL_FACE); 
glCullFace(GL_FRONT); 
</pre><p>The first and most obvious feature we're going to be using here is the depth test. This ensures that different shadow caster geometry isn't rendered in the wrong order, overlapping each other. Then, we're going to be performing some face culling. Unlike normal geometry, however, we're going to be culling the front faces only. Drawing the back faces of shadow geometry will ensure that the front faces of sprites we're using will be lit, since the depth stored in the shadow map is the depth of the very back of the shadow-casting primitives.</p><pre class="programlisting">glUseProgram(l_shadowShader); 
auto u_model = glGetUniformLocation(l_shadowShader, "m_model"); 
auto u_view = glGetUniformLocation(l_shadowShader, "m_view"); 
auto u_proj = glGetUniformLocation(l_shadowShader, "m_proj"); 
auto u_lightPos = glGetUniformLocation(l_shadowShader,"lightPos"); 
auto u_frustumFar = glGetUniformLocation(l_shadowShader, 
  "frustumFar"); 
</pre><p>The next part here deals with actually binding the shadow pass shader and fetching locations of different shader uniform variables. We have a model matrix uniform, a view matrix uniform, a projection matrix uniform, a light position uniform, and the frustum far uniform to update.</p><pre class="programlisting">auto&amp; texture = m_cubeTextures[l_texture]; 
auto l_pos = l_light.m_lightPos; 
m_perspectiveCamera.SetPosition({ l_pos.x, l_pos.z, l_pos.y }); 
glViewport( 
  0, 0, CubeTexture::TextureWidth, CubeTexture::TextureHeight); 
texture-&gt;RenderingBind(); 
glUniform3f(u_lightPos, l_pos.x, l_pos.z, l_pos.y); 
</pre><p>This next part of the code obtains a reference to the appropriate cubemap texture for the particular light, storing the light position, and positioning the perspective camera at that exact position.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>Note the swapped <em>Z</em> and <em>Y</em> coordinates. By default, OpenGL deals with the right-hand coordinate system. It also deals with the default <em>up</em> direction being the <em>+Y</em> axis. Our lights store coordinates using the <em>+Z</em> axis as the <em>up</em> direction.</p></div></div><p>After the camera is set up, <code class="literal">glViewport</code> is invoked to resize the render target to the size of the cubemap texture. The cubemap is then bound to for rendering and we submit the light position uniform to the shaders. Just as before, the <em>Z</em> and <em>Y</em> directions here are swapped.</p><p>With the setup out of the way, we can actually begin rendering the scene for each face of the cubemap:</p><pre class="programlisting">for (auto face = 0; face &lt; 6; ++face) { 
  texture-&gt;RenderToFace(face); 
  m_perspectiveCamera.SetForwardDir(CubeMapDirections[face]); 
  m_perspectiveCamera.SetUpDir(CubeMapUpDirections[face]); 
  m_perspectiveCamera.SetFrustumFar(l_light.m_radius); 
  m_perspectiveCamera.RecalculatePerspective(); 
  auto viewMat = m_perspectiveCamera.GetViewMatrix(); 
  auto&amp; projMat = m_perspectiveCamera.GetProjectionMatrix(); 
  glUniformMatrix4fv(u_view, 1, GL_FALSE, &amp;viewMat[0][0]); 
  glUniformMatrix4fv(u_proj, 1, GL_FALSE, &amp;projMat[0][0]); 
  glUniform1f(u_frustumFar, m_perspectiveCamera.GetFrustumFar()); 
  for (auto&amp; caster : m_shadowCasters) { 
    auto modelMat = caster-&gt;m_transform.GetModelMatrix(); 
    glUniformMatrix4fv(u_model, 1, GL_FALSE, &amp;modelMat[0][0]); 
    caster-&gt;m_prototype-&gt;Draw(); 
  } 
} 
</pre><p>The cubemap texture is first told which face we wish to render to in order to set up the FBO correctly. The forward and up directions for that particular face are then passed to the light's camera, along with the frustum far value, being the radius of the light. The perspective projection matrix is then recalculated, and both the view and projection matrices are retrieved from <code class="literal">GL_Camera</code> to pass to the shader, along with the frustum far value.</p><p>Lastly, for each of the 6 faces of the cubemap, we iterate over all of the shadow caster objects, retrieve their model matrices, pass them into the shader, and invoke the prototype's <code class="literal">Draw()</code> method, which takes care of the rendering.</p><p>After all of the texture's faces have been drawn to, we need to set the state back to what it was before rendering shadow maps:</p><pre class="programlisting">texture-&gt;RenderingUnbind(); 
glViewport( 
  0, 0, m_window-&gt;GetWindowSize().x, m_window-&gt;GetWindowSize().y); 
glDisable(GL_DEPTH_TEST); 
glDisable(GL_CULL_FACE); 
glCullFace(GL_BACK); 
</pre><p>The texture is first unbound for rendering, which sets the FBO to 0 and allows us to draw to the screen again. The viewport is then resized back to the original size our window had, and the depth test, along with face culling, are both disabled.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec100"/>The shadow pass shaders</h2></div></div></div><p>The C++ side of shadow mapping is finished, but we still have some logic to cover. The shaders here play an important role of actually translating the vertex information into depth. Let's take a look at the vertex shader first:</p><pre class="programlisting">in vec3 position; 
uniform mat4 m_model; 
uniform mat4 m_view; 
uniform mat4 m_proj; 
uniform vec3 lightPos; 
uniform float frustumFar; 
out float distance; 
 
void main() { 
  vec4 worldCoords = m_model * vec4(position, 1.0); 
  float d = length(worldCoords.xyz - lightPos); 
  d /= frustumFar; 
  gl_Position = m_proj * m_view * worldCoords; 
  distance = d; 
} 
</pre><p>The <code class="literal">vec3</code> input coordinates of a vertex position we receive on the GPU are in local space, which means they have to be passed through a number of matrices to be brought to world, view, and clip spaces in that order. The world coordinates are calculated first and stored separately, because they're used to determine the distance between the vertex and the light. That distance is stored in the local variable <code class="literal">d</code>, which is divided by the frustum far value to convert it to a range of <em>[0;1]</em>. The position of the vertex is then converted to clip space by using the world, view, and projection matrices, and the distance value is passed on to the fragment shader, where it's stored as a color for a particular pixel:</p><pre class="programlisting">in float distance; 
 
void main() { 
  gl_FragColor = vec4(distance, distance, distance, 1.0); 
} 
</pre><p>Remember that the output variables from the vertex shader are interpolated between the vertices, so each fragment in between those vertices will be shaded in a gradient-like manner.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec101"/>Results</h2></div></div></div><p>While we still don't have any actual geometry in the project to see the results of this, once we're done, it will look like the following screenshot:</p><div><img src="img/image_09_007.jpg" alt="Results"/></div><p>In this particular case, the primitives were extremely close to the light, so they're shaded really dark. Given greater distances, a particular face of a shadow map would look a little something like this, where <em>#1</em> is a primitive close to the camera, <em>#2</em> is further away, and <em>#3</em> is near the far end of the view frustum:</p><div><img src="img/image_09_008.jpg" alt="Results"/></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Adapting the light pass</h1></div></div></div><p>With the shadow maps rendered, it may be extremely tempting to try and sample them in our existing code, since the hard part is over, right? Well, not entirely. While we were extremely close with our previous approach, sadly, sampling of cubemap textures is the only thing that we couldn't do because of SFML. The sampling itself isn't really the problem, as much as binding the cubemap textures to be sampled is. Remember that sampling is performed by setting a uniform value of the sampler inside the shader to the <strong>texture unit ID</strong> that's bound to the texture in our C++ code. SFML resets these units each time something is rendered either onscreen, or to a render texture. The reason we haven't had this problem before is because we can set the uniforms of the shaders through SFML's <code class="literal">sf::Shader</code> class, which keeps track of references to textures and binds them to appropriate units when a shader is used for rendering. That's all fine and good, except for when the time comes to sample other types of textures that SFML doesn't support, which includes cubemaps. This is the only problem that requires us to completely cut SFML out of the picture during the light pass and use raw OpenGL instead.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec102"/>Replacing the m_fullScreenQuad</h2></div></div></div><p>First things first, replacing the <code class="literal">sf::VertexArray</code> object inside the <code class="literal">LightManager</code> class that's used to redraw an entire buffer texture, which we were utilizing for multipass rendering. Since SFML has to be completely cut out of the picture here, we can't use its built-in vertex array class and render a quad that covers the entire screen. Otherwise, SFML will force its own state on before rendering, which isn't going to work with our system properly as it re-assigns its own texture units each time.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec22"/>Defining a generic frame buffer object</h3></div></div></div><p>Just like before, we need to create a frame buffer object in order to render to a texture, rather than the screen. Since we've already done this once before for a cubemap, let's breeze through the implementation of a generic FBO class for 2D textures:</p><pre class="programlisting">class GenericFBO { 
public: 
  GenericFBO(const sf::Vector2u&amp; l_size); 
  ~GenericFBO(); 
 
  void Create(); 
 
  void RenderingBind(GLuint l_texture); 
  void RenderingUnbind(); 
private: 
  sf::Vector2u m_size; 
  GLuint m_FBO; 
  GLuint m_RBO; 
}; 
</pre><p>The main difference here is the fact that we're using variable sizes for textures now. They may vary at some point, so it's a good idea to store the size internally, rather than using constant values.</p><div><div><div><div><h4 class="title"><a id="ch09lvl4sec3"/>Implementing a generic frame buffer object</h4></div></div></div><p>The constructor and destructor of this class, once again, deals with resource management:</p><pre class="programlisting">GenericFBO::GenericFBO(const sf::Vector2u&amp; l_size) : 
  m_size(l_size), m_FBO(0), m_RBO(0) {} 
 
GenericFBO::~GenericFBO() { 
  if (m_FBO) { glDeleteFramebuffers(1, &amp;m_FBO); } 
  if (m_RBO) { glDeleteRenderbuffers(1, &amp;m_RBO); } 
} 
</pre><p>We're not storing a texture handle, because that too will vary depending on circumstances.</p><p>Creating the buffers for this class is pretty similar to what we've done before:</p><pre class="programlisting">void GenericFBO::Create() { 
  if (!m_FBO) { glCreateFramebuffers(1, &amp;m_FBO); } 
  glBindFramebuffer(GL_FRAMEBUFFER, m_FBO); 
  if (!m_RBO) { glCreateRenderbuffers(1, &amp;m_RBO); } 
  glBindRenderbuffer(GL_RENDERBUFFER, m_RBO); 
 
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, 
    m_size.x, m_size.y); 
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, 
    GL_RENDERBUFFER, m_RBO); 
  auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER); 
  if (status != GL_FRAMEBUFFER_COMPLETE) { ... } // Print status. 
  glBindFramebuffer(GL_FRAMEBUFFER, 0); 
  glBindRenderbuffer(GL_RENDERBUFFER, 0); 
} 
</pre><p>Just like the cubemap textures, we need to attach a depth render buffer to the FBO. After allocation and binding, the FBO is checked for errors and both buffers are unbound.</p><p>Rendering FBO points to a 2D texture is much easier. Binding for rendering needs to take a handle to a texture, because one is not stored internally, since this is a generic class that will be used with many different textures:</p><pre class="programlisting">void GenericFBO::RenderingBind(GLuint l_texture) { 
  glBindFramebuffer(GL_FRAMEBUFFER, m_FBO); 
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
    GL_TEXTURE_2D, l_texture, 0); 
} 
 
void GenericFBO::RenderingUnbind() { 
  glBindFramebuffer(GL_FRAMEBUFFER, 0); 
} 
</pre><p>Once the FBO is bound, we again invoke <code class="literal">glFramebufferTexture2D</code>. This time, however, we use <code class="literal">GL_TEXTURE_2D</code> as the type of the texture, and pass in the <code class="literal">l_texture</code> argument into the function instead.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec103"/>Rendering from a buffer to another buffer in OpenGL</h2></div></div></div><p>During our potentially numerous light passes, we're going to need a way of redrawing every pixel onscreen to the buffer texture just like we did before, except without using SFML this time. For this purpose, we're going to construct a quad that has four vertices, all positioned in screen coordinates, and covers the screen entirely. These vertices are also going to have texture coordinates that will be used to sample the buffer texture. A basic structure of such vertex, similar to the one we created in <a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics">Chapter 7
</a>, <em>One Step Forward, One Level Down - OpenGL Basics</em> looks like this:</p><pre class="programlisting">struct BasicVertex { 
  glm::vec3 m_pos; 
  glm::vec2 m_tex; 
}; 
</pre><p>This small structure will be used by the quad primitive that will cover the entire screen.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec23"/>Creating a basic quad primitive</h3></div></div></div><p>The quad primitive, just like any other piece of geometry, must be pushed to the GPU for later use. Let's construct a very basic class that will break down this functionality into manageable methods we can easily call from other classes:</p><pre class="programlisting">class BasicQuadPrimitive { 
public: 
  BasicQuadPrimitive(); 
  ~BasicQuadPrimitive(); 
 
  void Create(); 
  void Bind(); 
  void Render(); 
  void Unbind(); 
private: 
  GLuint m_VAO; 
  GLuint m_VBO; 
  GLuint m_indices; 
}; 
</pre><p>Once again, we have methods for creating, rendering, binding, and unbinding the primitive. The class stores the <code class="literal">m_VAO</code>, <code class="literal">m_VBO</code>, and <code class="literal">m_indices</code> of this primitive, which all need to be filled out.</p><div><div><div><div><h4 class="title"><a id="ch09lvl4sec4"/>Implementing the quad primitive class</h4></div></div></div><p>Construction and destruction of this class, once again, all take care of the resource allocation/de-allocation:</p><pre class="programlisting">BasicQuadPrimitive::BasicQuadPrimitive() : m_VAO(0), 
  m_VBO(0), m_indices(0) {} 
 
BasicQuadPrimitive::~BasicQuadPrimitive() { 
  if (m_VAO) { glDeleteVertexArrays(1, &amp;m_VAO); } 
  if (m_VBO) { glDeleteBuffers(1, &amp;m_VBO); } 
  if (m_indices) { glDeleteBuffers(1, &amp;m_indices); } 
} 
</pre><p>Creating and uploading the primitive to the GPU is exactly the same as before:</p><pre class="programlisting">void BasicQuadPrimitive::Create() { 
  glGenVertexArrays(1, &amp;m_VAO); 
  glBindVertexArray(m_VAO); 
  glGenBuffers(1, &amp;m_VBO); 
  glGenBuffers(1, &amp;m_indices); 
 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
 
  BasicVertex vertices[4] = { 
    //    x    y    z        u    v 
    { { -1.f, 1.f, 0.f }, { 0.f, 1.f } }, // Top-left. 
    { { 1.f, 1.f, 0.f }, { 1.f, 1.f } },  // Top-right. 
    { { 1.f, -1.f, 0.f }, { 1.f, 0.f } }, // Bottom-right. 
    { { -1.f, -1.f, 0.f }, { 0.f, 0.f } } // Bottom-left. 
  }; 
 
  auto stride = sizeof(vertices[0]); 
  auto texCoordOffset = sizeof(vertices[0].m_pos); 
  glBufferData(GL_ARRAY_BUFFER, 4 * sizeof(vertices[0]), 
    &amp;vertices[0], GL_STATIC_DRAW); 
  glEnableVertexAttribArray(0); 
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, 0); 
  glEnableVertexAttribArray(1); 
  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, 
    (void*)texCoordOffset); 
 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indices); 
  unsigned int indices[6] = { 0, 1, 2, 2, 3, 0 }; // CW! 
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), 
    &amp;indices[0], GL_STATIC_DRAW); 
  Unbind(); 
} 
</pre><p>The main difference here is that we're defining the vertices inside the method, since they're never going to change. The vertex attribute pointers are set up after the data is pushed onto the GPU; indices get defined in a clockwise manner (default for SFML), and pushed to the GPU.</p><p>Binding and unbinding the buffers for rendering is, once again, exactly the same as with all of the other geometry for OpenGL:</p><pre class="programlisting">void BasicQuadPrimitive::Bind() { 
  if (!m_VAO) { return; } 
  glBindVertexArray(m_VAO); 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indices); 
} 
 
void BasicQuadPrimitive::Unbind() { 
  if (!m_VAO) { return; } 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 
  glBindBuffer(GL_ARRAY_BUFFER, 0); 
  glBindVertexArray(0); 
} 
</pre><p>Since we're using indices, rendering the quad is achieved by calling <code class="literal">glDrawElements</code>, just like before:</p><pre class="programlisting">void BasicQuadPrimitive::Render() { 
  glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 
} 
</pre><p>This concludes the necessary preparations for rendering from an offscreen buffer to the screen.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec104"/>Making the changes to the light manager</h2></div></div></div><p>Given the complete re-architecture of our rendering process for shadows, it's obvious some things are going to have to change within the <code class="literal">LightManager</code> class. First, let's start with some new data we're going to need to store:</p><pre class="programlisting">using MaterialHandles = std::unordered_map&lt; 
  MaterialMapType, unsigned int&gt;; 
using MaterialUniformNames = std::unordered_map&lt; 
  MaterialMapType, std::string&gt;; 
</pre><p>The <code class="literal">MaterialHandles</code> and <code class="literal">MaterialUniformNames</code> containers will be used to store the names and locations of uniforms in our light pass shader. This is an effort made entirely to make the mapping of new material map types and uniforms much easier by automating it.</p><p>With that out of the way, let's take a look at the <code class="literal">LightManager</code> class definition and the changes we need to make to it:</p><pre class="programlisting">class LightManager { 
  ... 
private: 
  void GenerateMaterials(); 
  void Bind2DTextures(GLuint l_program, int l_pass); 
  void Unbind2DTextures(); 
  void SubmitLightUniforms(GLuint l_program, 
    unsigned int l_lightID, const LightBase&amp; l_light); 
  ... 
  MaterialHandles m_materialHandles; 
  MaterialUniformNames m_materialNames; 
  //sf::VertexArray m_fullScreenQuad; 
  GenericFBO m_rendererFBO; 
  BasicQuadPrimitive m_fullScreenQuad; 
  ... 
}; 
</pre><p>In addition to creating some new helper methods for generating material names, binding and unbinding all of the necessary 2D textures for the light pass sampling, and submitting the uniforms of a given light to the light pass shader, we're also storing the material names and handles. The <code class="literal">m_fullScreenQuad</code> class is replaced by our own class, and to accompany it, we have the <code class="literal">GenericFBO</code> object that will help us render to an offscreen buffer.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec24"/>Implementing light manager changes</h3></div></div></div><p>The constructor of our <code class="literal">LightManager</code> class now has additional work to do in setting up all of the new data members we added:</p><pre class="programlisting">LightManager::LightManager(...) : ..., 
  m_rendererFBO(l_window-&gt;GetWindowSize()), ... 
{ 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  GenerateMaterials(); 
  m_materialNames[MaterialMapType::Diffuse] = "DiffuseMap"; 
  m_materialNames[MaterialMapType::Normal] = "NormalMap"; 
  m_materialNames[MaterialMapType::Specular] = "SpecularMap"; 
  m_materialNames[MaterialMapType::Height] = "HeightMap"; 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  m_rendererFBO.Create(); 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  m_fullScreenQuad.Create(); 
  ... 
} 
</pre><p>First, the FBO we'll be using is set up in the initializer list to hold the size of our window. We then ensure that the main OpenGL context is active by activating our window, and invoke the <code class="literal">GenerateMaterials</code> method that will take care of material texture allocation and storage of the texture handles for the same.</p><p>The uniform sampler2D names for all material types are then stored in the appropriate container. These names have to match the ones inside the light pass shader!</p><p>Finally, the main OpenGL context is selected again and the FBO is created. We do this one more time for the <code class="literal">m_fullScreenQuad</code> class as well.</p><p>The <code class="literal">GenerateMaterials()</code> method can be implemented like this:</p><pre class="programlisting">void LightManager::GenerateMaterials() { 
  auto windowSize = m_window-&gt;GetWindowSize(); 
  for (auto i = 0; i &lt; 
    static_cast&lt;int&gt;(MaterialMapType::COUNT); ++i) 
  { 
    auto type = static_cast&lt;MaterialMapType&gt;(i); 
    auto pair = m_materialMaps.emplace(type, 
      std::move(std::make_unique&lt;sf::RenderTexture&gt;())); 
    auto&amp; texture = pair.first-&gt;second; 
    texture-&gt;create(windowSize.x, windowSize.y); 
    m_materialHandles[type] = texture-&gt; 
      getTexture().getNativeHandle(); 
  } 
} 
</pre><p>It iterates over each material type and creates a new texture for it, just like we did before. The only difference here is that we also store the handle of the newly created texture in <code class="literal">m_materialHandles</code>, in an effort to tie a specific <code class="literal">MaterialMapType</code> to an existing texture. We're still using SFML's render textures, because they did a fine job at managing 2D resources.</p><p>Binding all of the necessary textures to be sampled in the light pass shader would look like this:</p><pre class="programlisting">void LightManager::Bind2DTextures(GLuint l_program, int l_pass) { 
  auto finishedTexture = m_window-&gt;GetRenderer()-&gt; 
    GetFinishedTexture()-&gt;getTexture().getNativeHandle(); 
  auto lastPassHandle = (l_pass == 0 ? 
    m_materialHandles[MaterialMapType::Diffuse] : 
    finishedTexture); 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  glActiveTexture(GL_TEXTURE0); 
  glBindTexture(GL_TEXTURE_2D, lastPassHandle); 
  glUniform1i(glGetUniformLocation(l_program, "LastPass"), 0); 
 
  for (int i = 0;i&lt;static_cast&lt;int&gt;(MaterialMapType::COUNT);++i) { 
    auto type = static_cast&lt;MaterialMapType&gt;(i); 
    glActiveTexture(GL_TEXTURE1 + i); 
    glBindTexture(GL_TEXTURE_2D, m_materialMaps[type]-&gt; 
      getTexture().getNativeHandle()); 
    auto uniform = glGetUniformLocation(l_program, 
      m_materialNames[type].c_str()); 
    glUniform1i(uniform, i + 1); 
  } 
} 
</pre><p>This particular method will be used inside the <code class="literal">RenderScene</code> method for rendering lights. It takes two arguments: a handler for the light pass shader, and the ID of the current pass taking place.</p><p>The finished texture handle is then obtained from the <code class="literal">Renderer</code> class. Just like before, we must pass the right texture as the <code class="literal">"LastPass"</code> uniform in the light pass shader. If we're still on the very first pass, a diffuse texture is used instead.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>Passing textures to a shader for sampling simply means we're sending one integer to the shader. That integer represents the texture unit we want to sample.</p></div></div><p>The render window is then set to active once again to make sure the main OpenGL context is active. We then bind to the texture unit 0 and use it for the <code class="literal">"LastPass"</code> uniform. All of the other materials are taken care of inside a <code class="literal">for</code> loop that runs once for each material type. The texture unit <code class="literal">GL_TEXTURE1 + i</code> is activated, which ensures that we start from unit 1 and go up, since unit 0 is already being used. The appropriate texture is then bound to, and the uniform of the correct sampler for that material type is located. The uniform is then set to the texture unit we've just activated.</p><p>Unbinding these textures is easier still:</p><pre class="programlisting">void LightManager::Unbind2DTextures() { 
  for (int i = 0; i &lt;= 
    static_cast&lt;int&gt;(MaterialMapType::COUNT); ++i) 
  { 
    glActiveTexture(GL_TEXTURE0 + i); 
    glBindTexture(GL_TEXTURE_2D, 0); 
  } 
} 
</pre><p>Note that we're now iterating from 0 up and including the material type count. This ensures that even texture unit <code class="literal">0 </code>is unbound, since we're activating <code class="literal">GL_TEXTURE0 + i</code>.</p><div><div><div><div><h4 class="title"><a id="ch09lvl4sec5"/>Re-working the light pass</h4></div></div></div><p>Finally, we'll take a look at the <code class="literal">RenderScene()</code> method. For clarity, we're going to break it down into smaller chunks, just like before:</p><pre class="programlisting">void LightManager::RenderScene() { 
  ... 
} 
</pre><p>First, let's start at the top of the method and set up some variables that are going to be used throughout:</p><pre class="programlisting">... // Inside the RenderScene() method. 
auto renderer = m_window-&gt;GetRenderer(); 
auto passes = static_cast&lt;int&gt;( 
  std::ceil(static_cast&lt;float&gt;(m_lights.size()) / LightsPerPass)); 
auto&amp; beginning = m_lights.begin(); 
auto LightPassShaderHandle = renderer-&gt; 
  GetShader("LightPass")-&gt;getNativeHandle(); 
auto ShadowPassShaderHandle = renderer-&gt; 
  GetShader("ShadowPass")-&gt;getNativeHandle(); 
auto CurrentShaderHandle = (renderer-&gt;GetCurrentShader() ?  
  renderer-&gt;GetCurrentShader()-&gt;getNativeHandle() : 0); 
 
auto window = m_window-&gt;GetRenderWindow(); 
</pre><p>The <code class="literal">passes</code> variable works out how many passes we're going to need with the given number of lights. We then obtain a reference to the beginning of the light container, the light pass shader handle, the shadow pass shader handle, and the shader handle of the currently used shader that's set up inside the <code class="literal">Renderer</code> object, if there is one. Lastly, the <code class="literal">window</code> pointer is obtained for easy access.</p><p>Still inside the <code class="literal">RenderScene</code> method, we enter into a <code class="literal">for</code> loop that's going to iterate for each pass:</p><pre class="programlisting">... // Inside the RenderScene() method. 
for (int pass = 0; pass &lt; passes; ++pass) { 
  auto&amp; first = beginning + (pass * LightsPerPass); 
  auto LightCount = 0; 
  ... 
} 
</pre><p>Another reference to a light container iterator is obtained. This time, it points to the first light for this current pass. Also, a <code class="literal">LightCount</code> variable is set up to keep track of the number of lights rendered for the current pass so far.</p><p>Before we go on to do any actual light rendering, we need to draw the shadow maps for the lights we're going to be using in this pass:</p><pre class="programlisting">... // Inside the pass loop. 
for (int lightID = 0; lightID &lt; LightsPerPass; ++lightID) { 
  // Drawing shadow maps. 
  auto&amp; light = first + lightID; 
  if (light == m_lights.end()) { break; } 
  window-&gt;setActive(true); 
  DrawShadowMap(ShadowPassShaderHandle, *light, lightID); 
  ++LightCount; 
} 
</pre><p>Here, we iterate over each light that belongs to this pass. A check needs to be made to make sure we haven't reached the end of the container, however. Provided that's not the case, the main OpenGL context is enabled by calling <code class="literal">setActive(true)</code>, and the shadow map for the current light is drawn to the cubemap buffer texture. The <code class="literal">LightCount</code> is then incremented to let the rest of the code know how many lights we're dealing with during this pass.</p><p>After shadow maps have been rendered, it's time to actually bind the light pass shader and begin passing information to it:</p><pre class="programlisting">... // Inside the pass loop. 
glUseProgram(LightPassShaderHandle); 
Bind2DTextures(LightPassShaderHandle, pass); 
glUniform3f(glGetUniformLocation(LightPassShaderHandle, 
    "AmbientLight"), 
  m_ambientLight.m_lightColor.x, 
  m_ambientLight.m_lightColor.y, 
  m_ambientLight.m_lightColor.z); 
glUniform1i(glGetUniformLocation(LightPassShaderHandle, 
  "LightCount"), LightCount); 
glUniform1i(glGetUniformLocation(LightPassShaderHandle, 
  "PassNumber"), pass); 
</pre><p>After the light pass shader has been bound, we must also bind all of the 2D textures of necessary material maps. This is followed by submission of the ambient light uniform, along with the light count, and current pass uniforms.</p><p>All of this is great, but we still haven't addressed the main concept that caused a necessity for this massive redesign to begin with the cubemap textures:</p><pre class="programlisting">... // Inside the pass loop. 
auto BaseCubeMapUnit = static_cast&lt;int&gt;(MaterialMapType::COUNT)+1; 
for (int lightID = 0; lightID &lt; LightCount; ++lightID) { 
  auto&amp; light = first + lightID; // Verified by previous loop. 
  SubmitLightUniforms(LightPassShaderHandle, lightID, *light); 
  // Bind the CUBE texture of the light. 
  m_cubeTextures[lightID]-&gt;SamplingBind(BaseCubeMapUnit +lightID); 
  auto ShadowMapName = "ShadowMap["+std::to_string(lightID)+"]"; 
  glUniform1i(glGetUniformLocation(LightPassShaderHandle, 
    ShadowMapName.c_str()), BaseCubeMapUnit + lightID); 
} 
</pre><p>The texture unit for binding the very first cubemap texture is defined by simply adding <em>1</em> to the count of material map types. We have four types at this moment, and with unit <em>0</em> dedicated to the <code class="literal">LastPass</code> texture, it means units 1-4 will be used for material map textures. This leaves units 5 and up free for other samplers.</p><p>Another <code class="literal">for</code> loop is entered, this time using the <code class="literal">LightCount</code> variable for maximum value. We've already determined how many lights we're dealing with during the shadow pass, so we don't need to make that check again here.</p><p>A reference to a light is fetched and passed into the <code class="literal">SubmitLightUniforms()</code> method, along with the light pass shader handle and the light number currently being used. The cubemap texture for that specific light is then bound for sampling. Note the use of <code class="literal">BaseCubeMapUnit + lightID</code>. This ensures that each light gets its own texture unit.</p><p>Inside the light pass shader, the shadow map samplers are going to be stored inside an array. Because of this, a string name for each element of the array is constructed based on the current light ID we're working with, and the uniform for the texture unit is sent to the shader.</p><p>Finally, because all of the uniforms and textures are properly bound and updated, we can actually invoke the light-pass shader by rendering <code class="literal">m_fullScreenQuad</code>:</p><pre class="programlisting">... // Inside the pass loop. 
m_rendererFBO.RenderingBind(renderer-&gt;GetCurrentTexture()-&gt; 
  getTexture().getNativeHandle()); 
m_fullScreenQuad.Bind(); 
m_fullScreenQuad.Render(); // This is where the magic happens! 
m_fullScreenQuad.Unbind(); 
m_rendererFBO.RenderingUnbind(); 
Unbind2DTextures(); 
</pre><p>First, the FBO is bound to the handle of the current texture being used as a buffer. The quad itself is then bound, rendered, and unbound again. This is all we need to redraw the entire finished buffer texture to the current buffer texture, so the FBO is unbound. The 2D textures are also unbound at this point, since the light pass shader has just commenced executing.</p><p>Speaking of unbinding, all of these cubemap textures need to be unbound as well:</p><pre class="programlisting">... // Inside the pass loop. 
for (int lightID = 0; lightID &lt; LightCount; ++lightID) { 
  m_cubeTextures[lightID]-&gt;SamplingUnbind( 
    BaseCubeMapUnit + lightID); 
} 
</pre><p>At this point, the very last thing left to do inside the lighting pass loop is to swap the buffer textures inside the <code class="literal">Renderer</code> class:</p><pre class="programlisting">... // Inside the pass loop. 
renderer-&gt;SwapTextures(); 
</pre><p>This makes sure the most recent buffer is always stored as the finished texture.</p><p>Finally, once the light passes have, commenced, we must clean up the state of everything and actually render the finished buffer texture:</p><pre class="programlisting">... // Right after the pass loop, inside RenderScene(). 
glUseProgram(CurrentShaderHandle); 
window-&gt;resetGLStates(); 
auto currentView = window-&gt;getView(); 
window-&gt;setView(window-&gt;getDefaultView()); 
renderer-&gt;DrawBufferTexture(); 
window-&gt;setView(currentView); 
</pre><p>The shader program is first reset to whatever it was before the light pass was executed. The SFML window itself has its OpenGL states reset, because our use of OpenGL functions most likely altered them. Afterwards, we obtain the current window view, reset the window to its default view, draw the buffer texture, and swap the previous view back, just as in <a class="link" href="ch08.html" title="Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting">Chapter 8
</a>, <em>Let There Be Light! - An Introduction to Advanced Lighting</em>.</p></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec6"/>Submitting light uniforms to the shader</h4></div></div></div><p>One more little piece of code we still haven't covered is the actual light uniform submission to the light pass shader:</p><pre class="programlisting">void LightManager::SubmitLightUniforms(GLuint l_program, 
  unsigned int l_lightID, const LightBase&amp; l_light) 
{ 
  auto window = m_window-&gt;GetRenderWindow(); 
  auto id = "Lights[" + std::to_string(l_lightID) + "]."; 
 
  sf::Vector2i screenPos = window-&gt;mapCoordsToPixel( 
    { l_light.m_lightPos.x, l_light.m_lightPos.y }, 
    window-&gt;getView()); 
  float y = static_cast&lt;float&gt;( 
    static_cast&lt;int&gt;(window-&gt;getSize().y) - screenPos.y); 
 
  glUniform3f(glGetUniformLocation(l_program, 
      (id + "position").c_str()), 
    screenPos.x, y, l_light.m_lightPos.z); 
  glUniform3f(glGetUniformLocation(l_program, 
      (id + "color").c_str()), 
    l_light.m_lightColor.x, 
    l_light.m_lightColor.y, 
    l_light.m_lightColor.z); 
  glUniform1f(glGetUniformLocation(l_program, 
    (id + "radius").c_str()), l_light.m_radius); 
  glUniform1f(glGetUniformLocation(l_program, 
    (id + "falloff").c_str()), l_light.m_falloff); 
  glUniform1f(glGetUniformLocation(l_program, 
      (id + "specularExponent").c_str()), 
    l_light.m_specularExponent); 
  glUniform1f(glGetUniformLocation(l_program, 
      (id + "specularStrength").c_str()), 
    l_light.m_specularStrength); 
} 
</pre><p>This chunk of code is pretty much exactly the same as in <a class="link" href="ch08.html" title="Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting">Chapter 8
</a>, <em>Let There Be Light! - An Introduction to Advanced Lighting</em>
<em>,</em> except it uses raw OpenGL functions to submit the uniforms.</p></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec7"/>The new and improved light pass shaders</h4></div></div></div><p>Since the light pass had to be completely rewritten to use raw modern OpenGL, the shaders need to reflect those changes too. To begin with, the vertex shader is much simpler now, because it no longer uses outdated and deprecated ways of obtaining and transforming vertex information, texture coordinates, and so on:</p><pre class="programlisting">in vec3 position; 
in vec2 texCoordIn; 
out vec2 texCoords; 
void main() 
{ 
  texCoords = texCoordIn; 
  gl_Position = vec4(position, 1.0); 
} 
</pre><p>The position being passed to this shader is that of <code class="literal">m_fullScreenQuad</code>, so it's already in clip space. There's no reason to transform it. The texture coordinates are simply passed along to the fragment shader, where they get interpolated between vertices, ensuring sampling of every pixel:</p><pre class="programlisting">const int MaxLights = 4; 
const float LightHeightOffset = 16.0; 
in vec2 texCoords; 
uniform sampler2D LastPass; 
uniform sampler2D DiffuseMap; 
uniform sampler2D NormalMap; 
uniform sampler2D SpecularMap; 
uniform sampler2D HeightMap; 
uniform samplerCube ShadowMap[MaxLights]; 
uniform vec3 AmbientLight; 
uniform int LightCount; 
uniform int PassNumber; 
</pre><p>The fragment shader of the light pass has a couple of new values at the very top. We have a constant that's going to be used to offset the light's height, which we're going to cover very shortly. There's also the input value from the vertex shader of the texture coordinates we're going to need to sample. Lastly, we're using an array of <code class="literal">samplerCube</code> uniforms to access the shadow map information.</p><p>Let's take a look at the main body of the light pass fragment shader:</p><pre class="programlisting">void main() 
{ 
  vec4 pixel = texture2D(LastPass, texCoords); 
  vec4 diffusepixel = texture2D(DiffuseMap, texCoords); 
  vec4 normalpixel = texture2D(NormalMap, texCoords); 
  vec4 specularpixel = texture2D(SpecularMap, texCoords); 
  float pixelheight = texture2D(HeightMap, texCoords).r * 255.0; 
  vec3 PixelCoordinates = 
    vec3(gl_FragCoord.x, gl_FragCoord.y, pixelheight); 
  vec4 finalPixel = pixel; 
  ... 
  if(PassNumber == 0) { finalPixel *= vec4(AmbientLight, 1.0); } 
  for(int i = 0; i &lt; LightCount; ++i){ 
    ... 
    float ShadowValue = CalculateShadow( 
      PixelCoordinates, Lights[i].position, i); 
    finalPixel += (diffusepixel * 
                  (vec4(Lights[i].color, 1.0) * attenuation) + 
                  vec4(specularReflection, 1.0)) 
      * normalDot * ShadowValue; 
  } 
  gl_FragColor = finalPixel; 
} 
</pre><p>Things have changed, yet oddly enough stayed the same. We're sampling all of the values from different textures just like before, only now we're using the <code class="literal">texCoords</code> variable passed down from the vertex shader.</p><p>Another small change is the pass number that gets checked for ambient lighting. It used to be <em>1</em> for clarity in the previous chapter. It's now changed to <em>0</em>.</p><p>Finally, the very reason we're here today the shadow calculations. A floating point value is obtained from the <code class="literal">CalculateShadow</code> function, that takes in coordinates of the current fragment, the position of the current light, and the number identifier of the current light as well. This value is later used when calculating the final pixel color. The pixel is simply multiplied by <code class="literal">ShadowValue</code> at the end, which determines how much in the shadow it is.</p><p>This function is for calculating the shadow value of a fragment that is implemented at the top of the shader as follows:</p><pre class="programlisting">float CalculateShadow(vec3 fragment, vec3 light, int lightID) { 
  light.z += LightHeightOffset; 
  vec3 difference = fragment - light; 
  float currentDepth = length(difference); 
  difference.y *= -1.0; 
  float nearestDepth = texture(ShadowMap[lightID], 
    difference.xzy).r; 
  return (currentDepth &gt; nearestDepth * Lights[lightID].radius 
    ? nearestDepth : 1.0); 
} 
</pre><p>Looks simple enough, right? Well, it is. First, the light's height is offset by the height offset constant we defined at the top of the shader. This is just a detail of further tweaking that ensures lighting looks as good as it can, and could be completely changed. The current value simply looks better than the default 0.</p><p>The difference between the fragment's position and the light's position is then calculated by subtracting one from the other. The order matters here because this is going to be used as a directional vector to determine which face of the cubemap texture should be sampled.</p><div><div><h3 class="title"><a id="note45"/>Note</h3><p>Keep in mind that our fragment and light positions use the <em>Z</em> component as the height. This effectively makes <em>Y</em> the depth axis, which can be visualized as the direction to and from the screen, as opposed to left/right for <em>X</em>, and up/down for <em>Z</em>.</p></div></div><p>The <code class="literal">currentDepth</code> variable is the distance from the light to the fragment being sampled. The <em>Y</em> component of the difference vector is then inverted, because in the right-hand coordinate system OpenGL uses, pointing towards the screen means going into the negatives.</p><p>Now it's time to actually sample the shadow map texture and obtain the nearest depth at that particular fragment. This is done by passing the difference vector as a directional vector. Don't worry about it not being normalized, because it doesn't have to be. Also note the <em>Z</em> and <em>Y</em> components swapped. Again, we use <em>Z</em> for height, while OpenGL uses <em>Y</em>. Finally, we check whether the depth between the fragment and the light is greater than the depth sampled from the current shadow map, and if it is, it means the fragment is in the shadow. 0 could be returned, but in order to create shadows that slowly fade out with distance, <code class="literal">nearestDepth</code> is returned instead. This is the value that the final pixel gets multiplied by, and because it's in the range <em>[0;1]</em>, we get the linear fade with distance.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>Note <code class="literal">nearestDepth</code> being multiplied by the light radius, which represents the frustum far value, when it's being checked. This transforms it from the range <em>[0;1]</em>, to the actual distance at which the shadow primitive is away from the light.</p></div></div><p>Consider the following diagram to help get the point across:</p><div><img src="img/image_09_010.jpg" alt="The new and improved light pass shaders"/></div><p>Here, the main arrow from the sample point to the light is <code class="literal">currentDepth</code>, and the <code class="literal">nearestDepth</code> after being multiplied by the light's radius is the arrow from the black box in the middle to the light.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Adding shadow casters to entities</h1></div></div></div><p>Now that we have all of the rendering resolved, we still need to make sure entities can cast shadows. This will be achieved by actually attaching special components to entities that will hold pointers to 3D geometry used during shadow pass. This geometry will obviously need to be updated to match the position of the entities it represents, which is why the component data is going to be accompanied by a separate system, used to actually keep everything synced up.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec105"/>Adding the shadow caster component</h2></div></div></div><p>First, because our entities exist within the ECS paradigm, we need to add a component that represents the shadow volume of an entity:</p><pre class="programlisting">class C_ShadowCaster : public C_Base { 
public: 
  C_ShadowCaster() : C_Base(Component::ShadowCaster), 
    m_shadowCaster(nullptr) {} 
 
  void SetShadowCaster(ShadowCaster* l_caster) { 
    m_shadowCaster = l_caster; 
  } 
  void UpdateCaster(const glm::vec3&amp; l_pos) { 
    m_shadowCaster-&gt;m_transform.SetPosition(l_pos); 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    m_shadowPrimitive = std::make_unique&lt;ShadowCasterPrototype&gt;(); 
    for (auto i = 0; i &lt; ShadowMeshVertices; ++i) { 
      l_stream &gt;&gt; m_shadowPrimitive-&gt;m_vertices[i].x &gt;&gt; 
      m_shadowPrimitive-&gt;m_vertices[i].y &gt;&gt; 
      m_shadowPrimitive-&gt;m_vertices[i].z; 
    } 
  } 
 
  std::unique_ptr&lt;ShadowCasterPrototype&gt; m_shadowPrimitive; 
private: 
  ShadowCaster* m_shadowCaster; 
}; 
</pre><p>This component will be used to load entity shadow caster primitives from the entity file, as well as update their respective <code class="literal">ShadowCaster</code> instances. The player entity file, for example, would look like this with the new component added:</p><pre class="programlisting">Name Player 
Attributes 511 
|Component|ID|Individual attributes| 
... 
Component 8 -0.5 0.0 0.5 -0.5 0.0 -0.5 0.5 0.0 -0.5 ... 
</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec106"/>Creating the shadow system</h2></div></div></div><p>Updating these components should be done in a separate, designated system for this very purpose. Because we've done this so many times before, let's just take a look at the relevant parts of the code:</p><pre class="programlisting">S_Shadow::S_Shadow(SystemManager* l_systemMgr) 
  : S_Base(System::Shadow, l_systemMgr), 
  m_lightManager(nullptr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::ShadowCaster); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
} 
</pre><p>The constructor of this system simply sets up the entity requirements to belong here. It requires the position and shadow caster components, obviously.</p><p>Updating these components is equally as easy:</p><pre class="programlisting">void S_Shadow::Update(float l_dT) { 
  if (!m_lightManager) { return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for (auto &amp;entity : m_entities) { 
    auto position = entities-&gt;GetComponent&lt;C_Position&gt;( 
      entity, Component::Position); 
    auto caster = entities-&gt;GetComponent&lt;C_ShadowCaster&gt;( 
      entity, Component::ShadowCaster); 
    float height = static_cast&lt;float&gt;( 
      (position-&gt;GetElevation() * Sheet::Tile_Size) - 
        Sheet::Tile_Size); 
    caster-&gt;UpdateCaster({ 
      position-&gt;GetPosition().x, 
      height, 
      position-&gt;GetPosition().y - 8.f }); 
  } 
} 
</pre><p>For each entity that belongs to this system, the position and shadow caster components are obtained. The shadow caster's <code class="literal">UpdateCaster</code> method is then invoked, with the 2D position and height being passed in. The constant value of <code class="literal">8.f</code> is simply used to offset the shadow primitive in order to center it properly.</p><div><div><h3 class="title"><a id="note47"/>Note</h3><p>Note that the <em>Y</em> and <em>Z</em> values are, once again, swapped around.</p></div></div><p>Finally, because we want to properly emplace and manage unique shadow caster prototypes in the light manager, the shadow system must implement a method that will be called when the entity has finished loading and is about to be added, in order to set everything up properly:</p><pre class="programlisting">void S_Shadow::OnEntityAdd(const EntityId&amp; l_entity) { 
  auto component = m_systemManager-&gt;GetEntityManager()-&gt; 
   GetComponent&lt;C_ShadowCaster&gt;(l_entity,Component::ShadowCaster); 
  if (!component) { return; } 
  std::string entityType; 
  if (!m_systemManager-&gt;GetEntityManager()-&gt; 
    GetEntityType(l_entity, entityType)) 
  { 
    ... // Error 
    return; 
  } 
 
  auto name = m_lightManager-&gt;AddCasterPrototype("Entity_" + 
    entityType, std::move(component-&gt;m_shadowPrimitive)); 
  auto caster = m_lightManager-&gt;AddShadowCaster(name); 
  if (!caster) { return; } // Error 
  component-&gt;SetShadowCaster(caster); 
  caster-&gt;m_transform.SetScale({ 16.f, 16.f, 16.f }); 
} 
</pre><p>Once the shadow caster component is retrieved, the entity type name is obtained from the entity manager. This is simply the name of the entity prototype, such as player, skeleton, and so on. The primitive prototype with the appropriate name is then attempted to be added, and should there be an exact same shadow caster prototype already in <code class="literal">LightManager</code>, that name is returned instead. The shadow caster itself is then created, passed on to the <code class="literal">C_ShadowCaster</code> component, and scaled to a decent size. For the time being, this is a constant value, but it can obviously be made to change depending on the entity type, if it's stored inside the entity file along with the rest of the component data.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Integrating the changes made</h1></div></div></div><p>Finally, all we have left to do in order to make this work is add the newly created component and system types to the ECS:</p><pre class="programlisting">void Game::SetUpECS() { 
  ... 
  m_entityManager-&gt;AddComponentType&lt;C_ShadowCaster&gt; 
    (Component::ShadowCaster); 
  ... 
  m_systemManager-&gt;AddSystem&lt;S_Shadow&gt;(System::Shadow); 
  ... 
  m_systemManager-&gt;GetSystem&lt;S_Shadow&gt;(System::Shadow)-&gt; 
    SetLightManager(m_lightManager.get()); 
} 
</pre><p>The shadow system itself also needs a pointer to the light manager for obvious reasons. Running the game now, with all of the lights properly set up and shadow casters correctly loaded, we should have three-dimensional shadows!</p><div><img src="img/image_09_012.jpg" alt="Integrating the changes made"/></div><p>Because the entities can hop elevations, the lights can be made to change their heights, and the actual light pass of the scene incorporates different heights of tile layers. Moving the lights around actually creates results in three-dimensional space, allowing the shadows to flow across walls, if at a right angle. After all of that hard work, the effect is absolutely astonishing!</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Potential issues and how to address them</h1></div></div></div><p>Although we aren't facing any of these issues at this very point, most 3D games will have to deal with them as soon as basic shadows are established using this method.</p><p><strong>Shadow acne</strong> is a graphical artefact that can be summarized as horrible <em>tearing</em>, where lit areas are horribly defaced with dark and white lines closely nested together. This happens because shadow maps are of finite size and pixels that are right next to each other will end up spanning a small distance on actual, <em>real</em> geometry being shaded. It can be fixed by simply adding or subtracting a simple <em>bias</em> floating point value to or from the shadow map's depth sample inside the light pass shader. This floating point value would, ideally, not be a constant and instead depend on the slope between the point on the geometry and the light.</p><p><strong>Peter panning</strong> can be described as shadows that appear to be <em>floating</em> away from the geometry that casts them. Adding the floating point bias to fix shadow acne will usually make this problem worse, especially when dealing with incredibly thin geometry. A common and easy fix for this problem is simply avoiding thin geometry and using front face culling during the shadow pass, as we did.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec107"/>Percentage closer filtering</h2></div></div></div><p>You may have noticed that the shadows produced by our geometry are rather hard and don't exactly smooth out around the edges. As always, there is a solution that will resolve this, and it involves sampling the shadow map a couple more times per pixel.</p><p>By sampling not only the calculated pixel of the shadow map, but also the surrounding ones, we can easily take an average value of all of them and use it to <em>smooth</em> out the edge. If, for example, our sampled pixel is in the shadow but <em>50%</em> of all other sampled pixels around it are lit up, the center pixel itself should only be <em>50%</em> opaque. By eliminating this binary rule of a pixel either being completely lit or completely dark, we can successfully implement soft shadows using this technique. Higher numbers of surrounding pixels will obviously yield smoother results, but will also bog down performance.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Summary</h1></div></div></div><p>Congratulations on making it to the end of this chapter! Although it took quite a while to re-architect our lighting engine, the results cannot be dismissed as miniscule. The shadows created by this method add a lot of graphical diversity to our world. In the next chapter, we're going to be discussing optimizations that can be applied to make the game run as fast as it possibly can after all of the fancy, clock cycle sucking techniques used throughout this book. See you there!</p></div></div></div></body></html>