<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 9.  The Speed of Dark - Lighting and Shadows"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/><span class="koboSpan" id="kobo.1.1">Chapter 9.  The Speed of Dark - Lighting and Shadows </span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Contrasting differences are the very essence of existence, as the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">yin-yang</span></em></span><span class="koboSpan" id="kobo.4.1"> symbol properly illustrates. </span><span class="koboSpan" id="kobo.4.2">Light and darkness are opposites, yet complementary, as they offset one another and give meaning through variety. </span><span class="koboSpan" id="kobo.4.3">Without darkness there can be no light, as they are never truly separate. </span><span class="koboSpan" id="kobo.4.4">By breathing light into our world, we are inevitably forced to add back the darkness that it creates. </span><span class="koboSpan" id="kobo.4.5">Let's follow the previous chapter and truly complete to our lighting engine by reintroducing the concept of darkness to it.</span></p><p><span class="koboSpan" id="kobo.5.1">In this chapter, we will be covering the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Using OpenGL to render to and sample from cubemap textures</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Advanced shadow mapping for omni-directional point lights</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">The use of Percentage Closer Filtering to smooth out shadow edges</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.9.1">Combating common and frustrating issues with shadow mapping</span></li></ul></div><p><span class="koboSpan" id="kobo.10.1">There's quite a bit of theory to get out of the way, so let's get to it!</span></p><div class="section" title="Use of third-party software"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec80"/><span class="koboSpan" id="kobo.11.1">Use of third-party software</span></h1></div></div></div><p><span class="koboSpan" id="kobo.12.1">Before diving into such a difficult subject to debug, it's always nice to have proper tools that will ease the headaches and reduce the number of questions one might ask oneself during development. </span><span class="koboSpan" id="kobo.12.2">While normal code executed on the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">CPU</span></em></span><span class="koboSpan" id="kobo.14.1"> can just be stepped through and analyzed during runtime, shader code and OpenGL resources, such as textures are a bit more difficult to handle. </span><span class="koboSpan" id="kobo.14.2">Most, if not all, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">C++</span></em></span><span class="koboSpan" id="kobo.16.1"> compilers don't have native support for dealing with </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">GPU-bound</span></em></span><span class="koboSpan" id="kobo.18.1"> problems. </span><span class="koboSpan" id="kobo.18.2">Luckily, there is software out there that makes it easier to deal with that very predicament.</span></p><p><span class="koboSpan" id="kobo.19.1">Among the few tools that exist out there to alleviate such headaches, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">CodeXL</span></em></span><span class="koboSpan" id="kobo.21.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">AMD Developer Tools Team</span></em></span><span class="koboSpan" id="kobo.23.1"> stands out. </span><span class="koboSpan" id="kobo.23.2">It's a free piece of software that can be used as a standalone application for Windows and Linux or even as a plugin for Visual Studio. </span><span class="koboSpan" id="kobo.23.3">Its most prominent features include being able to view OpenGL resources (including textures) while the program is running, profile the code and find bottlenecks, and even step through the shader code as it's being executed (given the right hardware). </span><span class="koboSpan" id="kobo.23.4">The tool can be found and downloaded here: </span><a class="ulink" href="http://gpuopen.com/compute-product/codexl/"><span class="koboSpan" id="kobo.24.1">http://gpuopen.com/compute-product/codexl/</span></a><span class="koboSpan" id="kobo.25.1">.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Theory behind shadowing techniques"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec81"/><span class="koboSpan" id="kobo.1.1">Theory behind shadowing techniques</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There are a couple of different techniques that can be used when implementing realistic looking shadows in games. </span><span class="koboSpan" id="kobo.2.2">Choosing the right one can not only impact the kind of performance your application is going to exhibit, but can also heavily influence how good the effect is going to look in the end.</span></p><p><span class="koboSpan" id="kobo.3.1">An approach that isn't at all uncommon for 2D is referred to as </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1">ray tracing</span></strong></span><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Depending on the type of light, a number of rays are cast in an appropriate direction. </span><span class="koboSpan" id="kobo.5.3">Shadows are then implemented depending on which solids these rays actually intersect with. </span><span class="koboSpan" id="kobo.5.4">Some simpler games tend to create an overlay mask and fill in geometrically the parts of it that are "in the shadow". </span><span class="koboSpan" id="kobo.5.5">This mask is later overlaid on top of the usual scene and blended in order to create the aesthetic of darkened areas meant to represent shadows. </span><span class="koboSpan" id="kobo.5.6">More advanced 3D games tend to allow rays to bounce around the scene, carrying different information about the particular fragments that they intersect with. </span><span class="koboSpan" id="kobo.5.7">By the time a ray reaches the camera, it will have enough information to do more than create simple shadows. </span><span class="koboSpan" id="kobo.5.8">Scenes that require extremely advanced lighting tend to use this technique, and rightly so, as it imitates the way light bounces off objects and hits the observer's eye in real life.</span></p><p><span class="koboSpan" id="kobo.6.1">An older, but still widely used approach for specifically creating shadows is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">shadow mapping</span></strong></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">The essence of this technique comes down to simply rendering the scene to an off screen buffer from the point of view of the light. </span><span class="koboSpan" id="kobo.8.3">All the solids' depth information, as opposed to color information, is written to this buffer as pixel data. </span><span class="koboSpan" id="kobo.8.4">When the real scene is rendered, some matrix math is then used to sample the right pixels of the shadow map to figure out whether they can be directly seen by the light, thus being illuminated, or whether they're being obstructed by something, and therefore sitting in the shadow.</span></p><div class="section" title="Shadow mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec93"/><span class="koboSpan" id="kobo.9.1">Shadow mapping</span></h2></div></div></div><p><span class="koboSpan" id="kobo.10.1">The main idea behind creating a shadow map is rendering the scene from the point of view of the light, and effectively encoding the depth of a particular piece of geometry being rendered as a color value that can later be sampled. </span><span class="koboSpan" id="kobo.10.2">The depth value itself is nothing more than the distance between the position of the light and the position of the vertex. </span><span class="koboSpan" id="kobo.10.3">Consider the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_09_001.jpg" alt="Shadow mapping"/></span></div><p><span class="koboSpan" id="kobo.12.1">The distance between the light and a given vertex will be converted to a color value by simply dividing it by the frustum far distance, yielding a result in a range </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">[0;1]</span></em></span><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">The frustum far value is simply the distance of how far the light/camera can see.</span></p></div><div class="section" title="Omni-directional point lights"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec94"/><span class="koboSpan" id="kobo.15.1">Omni-directional point lights</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">In the previous chapter, we managed to create lights that emit in all directions from a center point. </span><span class="koboSpan" id="kobo.16.2">These types of lights have a very fitting name: omni-directional point lights. </span><span class="koboSpan" id="kobo.16.3">Dealing with shadow mapping for these lights comes with a certain layer of complexity, as the scene now needs to be drawn in all six directions, rather than just one if we were dealing with a directional light. </span><span class="koboSpan" id="kobo.16.4">This means we need a good way of storing the results of this process that can be accessed with relative ease. </span><span class="koboSpan" id="kobo.16.5">Luckily, OpenGL provides a new type of texture we can use, the </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">cubemap</span></strong></span><span class="koboSpan" id="kobo.18.1">.</span></p><div class="section" title="Cubemap textures"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec18"/><span class="koboSpan" id="kobo.19.1">Cubemap textures</span></h3></div></div></div><p><span class="koboSpan" id="kobo.20.1">A cubemap is pretty much exactly what it sounds like. </span><span class="koboSpan" id="kobo.20.2">It's a special texture that really holds six textures for each face of the cube. </span><span class="koboSpan" id="kobo.20.3">These textures are internally stored in an </span><span class="emphasis"><em><span class="koboSpan" id="kobo.21.1">unfolded</span></em></span><span class="koboSpan" id="kobo.22.1"> manner, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.23.1"><img src="graphics/image_09_003.jpg" alt="Cubemap textures"/></span></div><p><span class="koboSpan" id="kobo.24.1">Because of this property, rendering shadow maps for omni-directional lights can be as simple as rendering the scene once for each direction of a cubemap. </span><span class="koboSpan" id="kobo.24.2">Sampling them is also quite easy. </span><span class="koboSpan" id="kobo.24.3">The shape of a cube lends itself to some useful properties we can exploit. </span><span class="koboSpan" id="kobo.24.4">If all of the cube's vertices are in relation to its absolute center, then the coordinates of these vertices can also be thought of as directional vectors:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.25.1"><img src="graphics/image_09_005.jpg" alt="Cubemap textures"/></span></div><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.26.1"><img src="graphics/image_09_006.jpg" alt="Cubemap textures"/></span></div><p><span class="koboSpan" id="kobo.27.1">The direction (0, 1, 0) from the center of the cube would be pointing directly in the middle of the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">+Y</span></em></span><span class="koboSpan" id="kobo.29.1"> face, for example. </span><span class="koboSpan" id="kobo.29.2">Since each face of a cubemap texture also holds a texture of its own that represents the view of the scene, it can easily be sampled using these coordinates. </span><span class="koboSpan" id="kobo.29.3">For a 2D texture, our shaders had to use the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">sampler2D</span></code><span class="koboSpan" id="kobo.31.1"> type and provide 2D coordinates of the sampling location. </span><span class="koboSpan" id="kobo.31.2">Cubemaps have their own sampler type, </span><code class="literal"><span class="koboSpan" id="kobo.32.1">samplerCube</span></code><span class="koboSpan" id="kobo.33.1">, and use a 3D vector for sampling. </span><span class="koboSpan" id="kobo.33.2">The consequence of this is that the largest member of the 3D vector is used to determine which face is to be sampled, and the other two members become the UV texture coordinates for that particular 2D texture/face.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/><span class="koboSpan" id="kobo.34.1">Note</span></h3><p><span class="koboSpan" id="kobo.35.1">Cube textures can be used for much more than shadow mapping. </span><span class="koboSpan" id="kobo.35.2">3D environments can take advantage of them when implementing skyboxes and reflective/refractive materials, to name just a few techniques.</span></p></div></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Preparations for rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/><span class="koboSpan" id="kobo.1.1">Preparations for rendering</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">It's safe to say that all of this functionality is a bit beyond the scope of SFML, as it seeks to deal with simple two-dimensional concepts. </span><span class="koboSpan" id="kobo.2.2">While we're still going to be using SFML to render our sprites, the lighting and shadowing of the scene will have to fall back on raw OpenGL. </span><span class="koboSpan" id="kobo.2.3">This includes setting up and sampling cubemap textures, as well as creating, uploading, and drawing 3D primitives used to represent objects that cast shadows.</span></p><div class="section" title="Representing shadow casters"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec95"/><span class="koboSpan" id="kobo.3.1">Representing shadow casters</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">While SFML is great for rendering sprites, we must remember that these are two-dimensional objects. </span><span class="koboSpan" id="kobo.4.2">In 3D space, our character would literally be paper thin. </span><span class="koboSpan" id="kobo.4.3">This means that all of our game's shadow casters are going to need some 3D geometry behind them. </span><span class="koboSpan" id="kobo.4.4">Keep in mind that these basic rendering concepts have already been covered in </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.5.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.6.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Let's start by creating some common definitions that this system will use:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">static const glm::vec3 CubeMapDirections[6] = { 
  { 1.f, 0.f, 0.f },  // 0 = Positive X 
  { -1.f, 0.f, 0.f }, // 1 = Negative X 
  { 0.f, 1.f, 0.f },  // 2 = Positive Y 
  { 0.f, -1.f, 0.f }, // 3 = Negative Y 
  { 0.f, 0.f, 1.f },  // 4 = Positive Z 
  { 0.f, 0.f, -1.f }  // 5 = Negative Z 
}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This is going to be a common lookup array for us, and it's important that the directional vectors here are defined correctly. </span><span class="koboSpan" id="kobo.10.2">It represents a direction towards each face of the cubemap texture.</span></p><p><span class="koboSpan" id="kobo.11.1">Another common data structure we will be using is a list of indices used to draw the cubes/3D rectangles that represent our shadow casters:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">static const int ShadowMeshIndices = 36; 
static const GLuint CubeIndices[ShadowMeshIndices] = { 
  0, 4, 7, 7, 3, 0,  // Front 
  0, 1, 5, 5, 4, 0,  // Left 
  3, 7, 6, 6, 2, 3,  // Right 
  1, 2, 6, 6, 5, 1,  // Back 
  7, 4, 5, 5, 6, 7,  // Up 
  1, 0, 3, 3, 2, 1   // Down 
}; 
</span></pre><p><span class="koboSpan" id="kobo.13.1">Since the cubes have 6 faces and each face uses 6 indices to enumerate the two triangles that make them up, we have a total of 36 indices.</span></p><p><span class="koboSpan" id="kobo.14.1">Finally, we need an up vector for each direction of a cubemap texture:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">static const glm::vec3 CubeMapUpDirections[6] = { 
  { 0.f, -1.f, 0.f },  // 0 = Positive X 
  { 0.f, -1.f, 0.f }, // 1 = Negative X 
  { 0.f, 0.f, -1.f },  // 2 = Positive Y 
  { 0.f, 0.f, -1.f }, // 3 = Negative Y 
  { 0.f, -1.f, 0.f },  // 4 = Positive Z 
  { 0.f, -1.f, 0.f }  // 5 = Negative Z 
}; 
</span></pre><p><span class="koboSpan" id="kobo.16.1">In order to get correct shadow mapping for the geometry, we're going to need to use these up directions when rendering to a shadow cubemap. </span><span class="koboSpan" id="kobo.16.2">Note that, unless we're rendering to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">Y</span></em></span><span class="koboSpan" id="kobo.18.1"> faces of the cubemap, the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Y</span></em></span><span class="koboSpan" id="kobo.20.1"> direction is always used as up. </span><span class="koboSpan" id="kobo.20.2">This allows the geometry being rendered to be seen correctly by the camera.</span></p><div class="section" title="Implementing the shadow caster structure"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec19"/><span class="koboSpan" id="kobo.21.1">Implementing the shadow caster structure</span></h3></div></div></div><p><span class="koboSpan" id="kobo.22.1">Representing the literally shapeless entities of our game is the task we're going to be tackling next. </span><span class="koboSpan" id="kobo.22.2">In order to minimize the memory usage of this approach, it will be broken down into two parts:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">Prototype</span></strong></span><span class="koboSpan" id="kobo.24.1">: This is a structure that holds handles to uploaded geometry used by OpenGL. </span><span class="koboSpan" id="kobo.24.2">This kind of object represents a unique, one of a kind model.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">Caster</span></strong></span><span class="koboSpan" id="kobo.26.1">: This is a structure that holds a pointer to a prototype it's using, along with its own transform, to position, rotate, and scale it correctly.</span></li></ul></div><p><span class="koboSpan" id="kobo.27.1">The prototype structure needs to hold on to the resources it allocates, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">struct ShadowCasterPrototype { 
  ... 
  </span><span class="koboSpan" id="kobo.28.2">glm::vec3 m_vertices[ShadowMeshVertices]; 
  GLuint m_VAO; 
  GLuint m_VBO; 
  GLuint m_indexVBO; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.29.1">The constructor and destructor of this structure will take care of allocation/de-allocation of these resources:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">ShadowCasterPrototype() : m_VAO(0), m_VBO(0), m_indexVBO(0) {} 
~ShadowCasterPrototype() { 
  if (m_VBO) { glDeleteBuffers(1, &amp;m_VBO); } 
  if (m_indexVBO) { glDeleteBuffers(1, &amp;m_indexVBO); } 
  if (m_VAO) { glDeleteVertexArrays(1, &amp;m_VAO); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.31.1">Once the internal </span><code class="literal"><span class="koboSpan" id="kobo.32.1">m_vertices</span></code><span class="koboSpan" id="kobo.33.1"> data member is properly filled out, the geometry can be submitted to the GPU as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">void UploadVertices() { 
  if (!m_VAO) { glGenVertexArrays(1, &amp;m_VAO); } 
  glBindVertexArray(m_VAO); 
  if (!m_VBO) { glGenBuffers(1, &amp;m_VBO); } 
  if (!m_indexVBO) { glGenBuffers(1, &amp;m_indexVBO); } 
 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
  glBufferData(GL_ARRAY_BUFFER, 
    ShadowMeshVertices * sizeof(m_vertices[0]), m_vertices, 
    GL_STATIC_DRAW); 
  // Position vertex attribute. 
  </span><span class="koboSpan" id="kobo.34.2">glEnableVertexAttribArray(0); 
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 
    sizeof(glm::vec3), 0); 
 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); 
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 
    ShadowMeshIndices * sizeof(CubeIndices[0]), CubeIndices, 
    GL_STATIC_DRAW); 
  glBindBuffer(GL_ARRAY_BUFFER, 0); 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 
 
  glBindVertexArray(0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.35.1">Once the vertex array object and two buffers for vertices and indices are properly created, they're all bound and used to push the data to. </span><span class="koboSpan" id="kobo.35.2">Note the highlighted portion of the code that deals with the vertex attributes. </span><span class="koboSpan" id="kobo.35.3">Since this geometry is only going to be used to generate shadows, we really don't need anything else except the vertex position. </span><span class="koboSpan" id="kobo.35.4">The necessary math of converting all of that information into color values that represent distance from the light source is going to be done inside the shaders.</span></p><p><span class="koboSpan" id="kobo.36.1">Also, note the usage of indices to render this geometry here. </span><span class="koboSpan" id="kobo.36.2">Doing it this way allows us to save some space by not having to upload twice as many vertices to the GPU as we would have to otherwise.</span></p><p><span class="koboSpan" id="kobo.37.1">The drawing of the shadow primitives is just as simple as one would imagine:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">void Draw() { 
  glBindVertexArray(m_VAO); 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); 
  glDrawElements(GL_TRIANGLES, ShadowMeshIndices, 
    GL_UNSIGNED_INT, 0); // 0 = offset. 
  </span><span class="koboSpan" id="kobo.38.2">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 
  glBindBuffer(GL_ARRAY_BUFFER, 0); 
  glBindVertexArray(0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">Once all of the buffers are bound, we invoke </span><code class="literal"><span class="koboSpan" id="kobo.40.1">glDrawElements</span></code><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">Let it know we're drawing triangles, give the method the count of indices to use, specify their data type, and provide the proper offset for those indices, which in this case is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.42.1">0</span></em></span><span class="koboSpan" id="kobo.43.1">.</span></p><p><span class="koboSpan" id="kobo.44.1">Finally, because we're using prototypes to store unique pieces of geometry, it's definitely useful to overload the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">==</span></code><span class="koboSpan" id="kobo.46.1"> operator for easy checking of matching shapes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">bool operator == (const ShadowCasterPrototype&amp; l_rhs) const { 
  for (unsigned short i = 0; i &lt; ShadowMeshVertices; ++i) { 
    if (m_vertices[i] != l_rhs.m_vertices[i]) { return false; } 
  } 
  return true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.48.1">Each vertex of the shadow primitive is iterated over and compared to the equivalent vertex of the provided argument. </span><span class="koboSpan" id="kobo.48.2">So far, nothing out of the ordinary!</span></p><p><span class="koboSpan" id="kobo.49.1">The prototypes are going to need to be identified in some way when they're being stored. </span><span class="koboSpan" id="kobo.49.2">Using string identifiers can be quite intuitive in this case, so let's define a proper storage container type for this structure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">using ShadowCasterPrototypes = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;ShadowCasterPrototype&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.51.1">With that out of the way, we can implement our simple </span><code class="literal"><span class="koboSpan" id="kobo.52.1">ShadowCaster</span></code><span class="koboSpan" id="kobo.53.1"> structure that's going to hold all of the variable information about the prototype:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">struct ShadowCaster { 
  ShadowCaster() : m_prototype(nullptr) { } 
  ShadowCasterPrototype* m_prototype; 
  GL_Transform m_transform; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.55.1">As you can see, it's a very simple data structure that holds a pointer to a prototype it uses, as well as its own </span><code class="literal"><span class="koboSpan" id="kobo.56.1">GL_Transform</span></code><span class="koboSpan" id="kobo.57.1"> member, which is going to store the displacement information of an object.</span></p><p><span class="koboSpan" id="kobo.58.1">The shadow casters are also going to need a proper storage data type:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.59.1">using ShadowCasters = std::vector&lt;std::unique_ptr&lt;ShadowCaster&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.60.1">This effectively leaves us with the means to create and manipulate different types of shadow-casting primitives in a memory-conservative manner.</span></p></div></div><div class="section" title="Creating the transform class"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec96"/><span class="koboSpan" id="kobo.61.1">Creating the transform class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.62.1">The transform class that we're using is exactly the same as the one in </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.63.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.64.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.65.1">One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">For a quick refresher, let's take a look at the most important part of it that we're going to need for this process--the generation of a model matrix:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.67.1">glm::mat4 GL_Transform::GetModelMatrix() { 
  glm::mat4 matrix_pos = glm::translate(m_position); 
  glm::mat4 matrix_scale = glm::scale(m_scale); 
  // Represent each stored rotation as a different matrix, 
  // because we store angles. 
  </span><span class="koboSpan" id="kobo.67.2">//                Directional vector  x, y, z 
  glm::mat4 matrix_rotX = 
    glm::rotate(m_rotation.x, glm::vec3(1, 0, 0)); 
  glm::mat4 matrix_rotY = 
    glm::rotate(m_rotation.y, glm::vec3(0, 1, 0)); 
  glm::mat4 matrix_rotZ = 
    glm::rotate(m_rotation.z, glm::vec3(0, 0, 1)); 
  // Create a rotation matrix. </span><span class="koboSpan" id="kobo.67.3">Multiply in reverse order it 
  // needs to be applied. 
  </span><span class="koboSpan" id="kobo.67.4">glm::mat4 matrix_rotation = matrix_rotZ*matrix_rotY*matrix_rotX; 
  // Apply transforms in reverse order they need to be applied in. 
  </span><span class="koboSpan" id="kobo.67.5">return matrix_pos * matrix_rotation * matrix_scale; 
} 
</span></pre><p><span class="koboSpan" id="kobo.68.1">All of this should be familiar by now, and if it isn't, a quick zip through </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.69.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.70.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.71.1">One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.72.1"> is definitely in order. </span><span class="koboSpan" id="kobo.72.2">The main idea, however, is combining the translation, scale, and rotation matrices in the right order to retrieve a single matrix that contains all of the information about the primitive required to bring its vertices from object space to world space.</span></p></div><div class="section" title="Creating a camera class"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec97"/><span class="koboSpan" id="kobo.73.1">Creating a camera class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.74.1">Similar to the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">GL_Transform</span></code><span class="koboSpan" id="kobo.76.1"> class, we're also going to incorporate the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">GL_Camera</span></code><span class="koboSpan" id="kobo.78.1"> class from </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.79.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.80.1">,</span><span class="emphasis"><em><span class="koboSpan" id="kobo.81.1"> One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">When we're rendering shadow maps, the projection and view matrices for all six directions will need to be submitted to the respective shaders. </span><span class="koboSpan" id="kobo.82.3">This makes the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">GL_Camera</span></code><span class="koboSpan" id="kobo.84.1"> class perfect for representing a light in a scene that needs to draw what it sees into a cubemap texture. </span><span class="koboSpan" id="kobo.84.2">Once again, this has been covered already, so we're just going to breeze through it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.85.1">GL_Camera::GL_Camera(const glm::vec3&amp; l_pos, float l_fieldOfView, 
  float l_aspectRatio, float l_frustumNear, float l_frustumFar) 
  :m_position(l_pos),m_fov(l_fieldOfView),m_aspect(l_aspectRatio), 
  m_frustumNear(l_frustumNear), m_frustumFar(l_frustumFar) 
{ 
  RecalculatePerspective(); 
  m_forwardDir = glm::vec3(0.f, 0.f, 1.f); 
  m_upDir = glm::vec3(0.f, 1.f, 0.f); 
} 
</span></pre><p><span class="koboSpan" id="kobo.86.1">Appropriately enough, shadow maps are going to be drawn using a perspective projection. </span><span class="koboSpan" id="kobo.86.2">After all the necessary information about view frustum is collected, we can begin constructing the matrices necessary to transform those vertices from world space to the light's view space, as well as to clip space:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.87.1">glm::mat4 GL_Camera::GetViewMatrix() { 
  return glm::lookAt(m_position, m_position + m_forwardDir, 
    m_upDir); 
} 
glm::mat4&amp; GL_Camera::GetProjectionMatrix() { 
  return m_perspectiveMatrix; 
} 
 
void GL_Camera::RecalculatePerspective() { 
  m_perspectiveMatrix = glm::perspective(glm::radians(m_fov), 
    m_aspect, m_frustumNear, m_frustumFar); 
} 
</span></pre><p><span class="koboSpan" id="kobo.88.1">We're using </span><code class="literal"><span class="koboSpan" id="kobo.89.1">glm::lookAt</span></code><span class="koboSpan" id="kobo.90.1"> to construct a view matrix for the light's camera. </span><span class="koboSpan" id="kobo.90.2">Then, </span><code class="literal"><span class="koboSpan" id="kobo.91.1">glm::perspective</span></code><span class="koboSpan" id="kobo.92.1"> is used in another method to create the perspective projection matrix for the camera.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/><span class="koboSpan" id="kobo.93.1">Note</span></h3><p><span class="koboSpan" id="kobo.94.1">It's very important to remember that </span><code class="literal"><span class="koboSpan" id="kobo.95.1">glm::perspective</span></code><span class="koboSpan" id="kobo.96.1"> takes the field of view angle of the view frustum as the first argument. </span><span class="koboSpan" id="kobo.96.2">It expects this parameter to be in </span><span class="strong"><strong><span class="koboSpan" id="kobo.97.1">radians</span></strong></span><span class="koboSpan" id="kobo.98.1">, not degrees! </span><span class="koboSpan" id="kobo.98.2">Because we're storing it in degrees, </span><code class="literal"><span class="koboSpan" id="kobo.99.1">glm::radians</span></code><span class="koboSpan" id="kobo.100.1"> is used to convert that value. </span><span class="koboSpan" id="kobo.100.2">This is a very easy mistake to make and many people end up having problems with their shadow maps not mapping correctly.</span></p></div></div></div><div class="section" title="Defining a cube texture class"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec98"/><span class="koboSpan" id="kobo.101.1">Defining a cube texture class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.102.1">Now that we have the storage of geometry and representation of the light's view frustum figured out, it's time to create the cube texture we're going to use to actually render the scene to.</span></p><p><span class="koboSpan" id="kobo.103.1">Let's start by creating a simple class definition for it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.104.1">class CubeTexture { 
public: 
  CubeTexture(); 
  ~CubeTexture(); 
 
  void RenderingBind(); 
  void RenderingUnbind(); 
  void SamplingBind(unsigned int l_unit); 
  void SamplingUnbind(unsigned int l_unit); 
 
  GLuint GetTextureHandle()const; 
 
  void RenderToFace(unsigned int l_face); 
  void Clear(); 
 
  static const unsigned int TextureWidth = 1024; 
  static const unsigned int TextureHeight = 1024; 
private: 
  void Create(); 
  void CreateBuffers(); 
  void CreateFaces(); 
  GLuint m_textureID; // Texture handle. 
  </span><span class="koboSpan" id="kobo.104.2">GLuint m_fbo; // Frame-buffer handle. 
  </span><span class="koboSpan" id="kobo.104.3">GLuint m_rbo; // Render-buffer handle. 
</span><span class="koboSpan" id="kobo.104.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.105.1">The texture is going to be used for two distinctive actions: being rendered to and being sampled. </span><span class="koboSpan" id="kobo.105.2">Both of these processes have a method for binding and unbinding the texture, with the notable difference that the sampling step also requires a texture unit as an argument. </span><span class="koboSpan" id="kobo.105.3">We're going to cover that soon. </span><span class="koboSpan" id="kobo.105.4">This class also needs to have a separate method that needs to be called for each of the six faces when they're being rendered.</span></p><p><span class="koboSpan" id="kobo.106.1">Although cube textures can be used for many things, in this particular instance, we're simply going to be using them for shadow mapping. </span><span class="koboSpan" id="kobo.106.2">The texture dimensions, therefore, are defined as constants of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.107.1">1024px</span></em></span><span class="koboSpan" id="kobo.108.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/><span class="koboSpan" id="kobo.109.1">Tip</span></h3><p><span class="koboSpan" id="kobo.110.1">The size of a cubemap texture matters greatly, and can cause artifacting if left too small. </span><span class="koboSpan" id="kobo.110.2">Smaller textures will lead to sampling inaccuracies and will cause jagged shadow edges.</span></p></div></div><p><span class="koboSpan" id="kobo.111.1">Lastly, alongside the helper methods used when creating the texture and all of the necessary buffers, we store the handles to the texture itself, the frame buffer object, and render buffer object. </span><span class="koboSpan" id="kobo.111.2">The last two objects haven't been covered until this point, so let's dive right in and see what they're for!</span></p><div class="section" title="Implementing the cube texture class"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec20"/><span class="koboSpan" id="kobo.112.1">Implementing the cube texture class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.113.1">Let's start, as always, by covering the construction and destruction of this particular OpenGL asset:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.114.1">CubeTexture::CubeTexture() : m_textureID(0), m_fbo(0), m_rbo(0) 
  { Create(); } 
CubeTexture::~CubeTexture() { 
  if (m_fbo) { glDeleteFramebuffers(1, &amp;m_fbo); } 
  if (m_rbo) { glDeleteRenderbuffers(1, &amp;m_rbo); } 
  if (m_textureID) { glDeleteTextures(1, &amp;m_textureID); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.115.1">Similar to geometry classes, the handles are initialized to values of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.116.1">0</span></em></span><span class="koboSpan" id="kobo.117.1"> to indicate their state of not being set up. </span><span class="koboSpan" id="kobo.117.2">The destructor checks those values and invokes the appropriate </span><code class="literal"><span class="koboSpan" id="kobo.118.1">glDelete</span></code><span class="koboSpan" id="kobo.119.1"> methods for the buffers/textures used.</span></p><p><span class="koboSpan" id="kobo.120.1">Creating the cubemap is quite similar to a regular 2D texture, so let's take a look:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.121.1">void CubeTexture::Create() { 
  if (m_textureID) { return; } 
  glGenTextures(1, &amp;m_textureID); 
  CreateFaces(); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_MAG_FILTER, GL_NEAREST); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_MIN_FILTER, GL_NEAREST); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); 
  glTexParameteri(GL_TEXTURE_CUBE_MAP, 
    GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
 
  CreateBuffers(); 
  glBindTexture(GL_TEXTURE_CUBE_MAP, 0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.122.1">First, a check is made to make sure we haven't already allocated this object. </span><span class="koboSpan" id="kobo.122.2">Provided that isn't the case, </span><code class="literal"><span class="koboSpan" id="kobo.123.1">glGenTextures</span></code><span class="koboSpan" id="kobo.124.1"> is used, just like for 2D textures, to create space for one texture object. </span><span class="koboSpan" id="kobo.124.2">Our first private helper method is then invoked to create all six faces of the cubemap, which brings us to the parameter setup. </span><span class="koboSpan" id="kobo.124.3">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.125.1">Min/Mag</span></em></span><span class="koboSpan" id="kobo.126.1"> filters are set up to use the nearest-neighbor interpolation, but can later be converted to </span><code class="literal"><span class="koboSpan" id="kobo.127.1">GL_LINEAR</span></code><span class="koboSpan" id="kobo.128.1"> for smoother results, if necessary. </span><span class="koboSpan" id="kobo.128.2">The texture wrapping parameters are then set up so that they're clamped to the edge, giving us a seamless transition between faces.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/><span class="koboSpan" id="kobo.129.1">Note</span></h3><p><span class="koboSpan" id="kobo.130.1">Note that there are three parameters for texture wrapping: R, S, and T. </span><span class="koboSpan" id="kobo.130.2">That's because we're dealing with a three-dimensional texture type now, so each axis must be accounted for.</span></p></div></div><p><span class="koboSpan" id="kobo.131.1">Lastly, another helper method is invoked for the creation of the buffers, just before we unbind the texture as we're done with it.</span></p><p><span class="koboSpan" id="kobo.132.1">The creation of the cubemap faces, once again, is similar to how we set up its 2D counterpart back in </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.133.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.134.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.135.1">One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.136.1">, but the trick is to do it once for each face:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.137.1">void CubeTexture::CreateFaces() { 
  glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureID); 
  for (auto face = 0; face &lt; 6; ++face) { 
    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, 0,GL_RGBA, 
      TextureWidth, TextureHeight, 0, GL_RGBA, 
      GL_UNSIGNED_BYTE, nullptr); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.138.1">Once the texture is bound, we iterate over each face and use </span><code class="literal"><span class="koboSpan" id="kobo.139.1">glTexImage2D</span></code><span class="koboSpan" id="kobo.140.1"> to set the face up. </span><span class="koboSpan" id="kobo.140.2">Each face is treated as a 2D texture, so this should really be nothing new to look at. </span><span class="koboSpan" id="kobo.140.3">Note, however, the use of the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span></code><span class="koboSpan" id="kobo.142.1"> definition usage is the first argument. </span><span class="koboSpan" id="kobo.142.2">2D textures would take in a </span><code class="literal"><span class="koboSpan" id="kobo.143.1">GL_TEXTURE_2D</span></code><span class="koboSpan" id="kobo.144.1"> definition, but because cubemaps are stored in an unfolded manner, getting this part right is important.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/><span class="koboSpan" id="kobo.145.1">Note</span></h3><p><span class="koboSpan" id="kobo.146.1">There are six definitions of </span><code class="literal"><span class="koboSpan" id="kobo.147.1">GL_TEXTURE_CUBE_MAP_</span></code><span class="koboSpan" id="kobo.148.1">*. </span><span class="koboSpan" id="kobo.148.2">They're all defined in a row of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.149.1">+X</span></em></span><span class="koboSpan" id="kobo.150.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.151.1">-X</span></em></span><span class="koboSpan" id="kobo.152.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.153.1">+Y</span></em></span><span class="koboSpan" id="kobo.154.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.155.1">-Y</span></em></span><span class="koboSpan" id="kobo.156.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.157.1">+Z</span></em></span><span class="koboSpan" id="kobo.158.1">, and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.159.1">-Z</span></em></span><span class="koboSpan" id="kobo.160.1">, which is why we can use some basic arithmetic to pass in the correct face to the function by simply adding an integer to the definition.</span></p></div></div><p><span class="koboSpan" id="kobo.161.1">Clearing the cubemap texture is relatively easy:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.162.1">void CubeTexture::Clear() { 
  glClearColor(1.f, 1.f, 1.f, 1.f); 
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
} 
</span></pre><p><span class="koboSpan" id="kobo.163.1">Note that we're specifying the clear color as white, because that represents </span><span class="emphasis"><em><span class="koboSpan" id="kobo.164.1">infinite distance from the light</span></em></span><span class="koboSpan" id="kobo.165.1"> in a shadow map.</span></p><p><span class="koboSpan" id="kobo.166.1">Finally, sampling the cubemap is actually not any different from sampling a regular 2D texture:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.167.1">void CubeTexture::SamplingBind(unsigned int l_unit) { 
  assert(l_unit &gt;= 0 &amp;&amp; l_unit &lt;= 31); 
  glActiveTexture(GL_TEXTURE0 + l_unit); 
  glEnable(GL_TEXTURE_CUBE_MAP); 
  glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureID); 
} 
void CubeTexture::SamplingUnbind(unsigned int l_unit) { 
  assert(l_unit &gt;= 0 &amp;&amp; l_unit &lt;= 31); 
  glActiveTexture(GL_TEXTURE0 + l_unit); 
  glBindTexture(GL_TEXTURE_CUBE_MAP, 0); 
  glDisable(GL_TEXTURE_CUBE_MAP); 
} 
</span></pre><p><span class="koboSpan" id="kobo.168.1">Both binding and unbinding for sampling requires us to pass in the texture unit we want to use. </span><span class="koboSpan" id="kobo.168.2">Once the unit is active, we should enable the use of cubemaps and then bind the cubemap texture handle. </span><span class="koboSpan" id="kobo.168.3">The reverse of this procedure should be followed when unbinding the texture.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/><span class="koboSpan" id="kobo.169.1">Note</span></h3><p><span class="koboSpan" id="kobo.170.1">Keep in mind that the respective </span><code class="literal"><span class="koboSpan" id="kobo.171.1">sampler2D</span></code><span class="koboSpan" id="kobo.172.1">/</span><code class="literal"><span class="koboSpan" id="kobo.173.1">samplerCube</span></code><span class="koboSpan" id="kobo.174.1"> uniforms inside fragment shaders are set to hold the unit ID of the texture they're sampling. </span><span class="koboSpan" id="kobo.174.2">When a texture is bound, the specific ID of that unit will be used to access it in a shader from then on, not the actual texture handle.</span></p></div></div><div class="section" title="Rendering to an off-screen buffer"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec1"/><span class="koboSpan" id="kobo.175.1">Rendering to an off-screen buffer</span></h4></div></div></div><p><span class="koboSpan" id="kobo.176.1">Something we didn't cover in </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.177.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.178.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.179.1">One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.180.1"> is rendering a scene to a buffer image, rather than drawing directly onscreen. </span><span class="koboSpan" id="kobo.180.2">Luckily, because OpenGL operates as a giant state machine, it's just a matter of invoking the right functions at the right time, and doesn't involve us having to redesign the rendering procedures in any way.</span></p><p><span class="koboSpan" id="kobo.181.1">In order to render to a texture object, we must use what is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.182.1">framebuffer</span></strong></span><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">It's a very basic object that directs draw calls to a texture the FBO is bound to. </span><span class="koboSpan" id="kobo.183.3">While FBOs are useful for color information, they don't carry the depth components with them. </span><span class="koboSpan" id="kobo.183.4">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.184.1">renderbuffer</span></strong></span><span class="koboSpan" id="kobo.185.1"> object is used for that very purpose of attaching additional components to the FBO.</span></p><p><span class="koboSpan" id="kobo.186.1">The first step to drawing something offscreen is creating a </span><code class="literal"><span class="koboSpan" id="kobo.187.1">FRAMEBUFFER</span></code><span class="koboSpan" id="kobo.188.1"> object and a </span><code class="literal"><span class="koboSpan" id="kobo.189.1">RENDERBUFFER</span></code><span class="koboSpan" id="kobo.190.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.191.1">void CubeTexture::CreateBuffers() { 
  glGenFramebuffers(1, &amp;m_fbo); 
  glBindFramebuffer(GL_FRAMEBUFFER, m_fbo); 
  glGenRenderbuffers(1, &amp;m_rbo); 
  glBindRenderbuffer(GL_RENDERBUFFER, m_rbo); 
 
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, 
    TextureWidth, TextureHeight); 
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, 
    GL_RENDERBUFFER, m_rbo); 
  auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER); 
  if (status != GL_FRAMEBUFFER_COMPLETE) { ... </span><span class="koboSpan" id="kobo.191.2">} // Print status. 
  </span><span class="koboSpan" id="kobo.191.3">glBindFramebuffer(GL_FRAMEBUFFER, 0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.192.1">After the buffers have been generated, the render buffer needs to have some storage allocated for any additional components it will provide. </span><span class="koboSpan" id="kobo.192.2">In this case, we're simply dealing with the depth component.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/><span class="koboSpan" id="kobo.193.1">Tip</span></h3><p><span class="koboSpan" id="kobo.194.1">The </span><code class="literal"><span class="koboSpan" id="kobo.195.1">GL_DEPTH_COMPONENT24</span></code><span class="koboSpan" id="kobo.196.1"> simply indicates that each depth pixel has a size of 24 bits. </span><span class="koboSpan" id="kobo.196.2">This definition can be replaced with a basic </span><code class="literal"><span class="koboSpan" id="kobo.197.1">GL_DEPTH_COMPONENT</span></code><span class="koboSpan" id="kobo.198.1">, which will allow the application to choose the pixel size.</span></p></div></div><p><span class="koboSpan" id="kobo.199.1">The depth render buffer is then attached to the FBO as a depth attachment. </span><span class="koboSpan" id="kobo.199.2">Finally, if there were any errors during this procedure, </span><code class="literal"><span class="koboSpan" id="kobo.200.1">glCheckFramebufferStatus</span></code><span class="koboSpan" id="kobo.201.1"> is used to catch them. </span><span class="koboSpan" id="kobo.201.2">The next line simply prints out the status variable using </span><code class="literal"><span class="koboSpan" id="kobo.202.1">std::cout</span></code><span class="koboSpan" id="kobo.203.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/><span class="koboSpan" id="kobo.204.1">Note</span></h3><p><span class="koboSpan" id="kobo.205.1">Frame buffers should always be unbound when no longer used, using </span><code class="literal"><span class="koboSpan" id="kobo.206.1">glBindFramebuffer(GL_FRAMEBUFFER, 0)</span></code><span class="koboSpan" id="kobo.207.1">! </span><span class="koboSpan" id="kobo.207.2">That's the only way we're ever going to go back to rendering subsequent geometry to the screen, rather than the buffer texture.</span></p></div></div><p><span class="koboSpan" id="kobo.208.1">Now that we have the buffers set up, let's use them! </span><span class="koboSpan" id="kobo.208.2">When drawing to a buffer texture is desired, it's first necessary to bind the frame buffer:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.209.1">void CubeTexture::RenderingBind() { 
  glBindFramebuffer(GL_FRAMEBUFFER, m_fbo); 
} 
void CubeTexture::RenderingUnbind() { 
  glBindFramebuffer(GL_FRAMEBUFFER, 0); // Render to screen. 
</span><span class="koboSpan" id="kobo.209.2">} 
</span></pre><p><span class="koboSpan" id="kobo.210.1">Unbinding the FBO is necessary after we're done with it. </span><span class="koboSpan" id="kobo.210.2">Using </span><code class="literal"><span class="koboSpan" id="kobo.211.1">RenderingUnbind()</span></code><span class="koboSpan" id="kobo.212.1"> means that any subsequent geometry will be drawn onscreen.</span></p><p><span class="koboSpan" id="kobo.213.1">Of course, just because the FBO is bound, doesn't mean we're going to magically start drawing to the cubemap. </span><span class="koboSpan" id="kobo.213.2">In order to do that, we must draw to one face at a time by binding the frame buffer to the desired face of the cubemap:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.214.1">void CubeTexture::RenderToFace(unsigned int l_face) { 
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
    GL_TEXTURE_CUBE_MAP_POSITIVE_X + l_face, m_textureID, 0); 
  Clear(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.215.1">The first argument to </span><code class="literal"><span class="koboSpan" id="kobo.216.1">glFramebufferTexture2D</span></code><span class="koboSpan" id="kobo.217.1"> simply indicates we're dealing with an FBO. </span><span class="koboSpan" id="kobo.217.2">We then specify that we want to use </span><code class="literal"><span class="koboSpan" id="kobo.218.1">GL_COLOR_ATTACHMENT0</span></code><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">Frame buffers can have multiple attachments and use shaders to output different data to each one of them. </span><span class="koboSpan" id="kobo.219.3">For our purposes, we're only going to need to use one attachment.</span></p><p><span class="koboSpan" id="kobo.220.1">Because we're rendering to one face of the cubemap at a time, basic definition arithmetic is, once again, used to pick the correct face of the cube to render to. </span><span class="koboSpan" id="kobo.220.2">Finally, the texture handle and mipmapping level are passed in at the very end, just before </span><code class="literal"><span class="koboSpan" id="kobo.221.1">Clear()</span></code><span class="koboSpan" id="kobo.222.1"> is invoked to clear the face we currently bound to complete white.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Rendering the shadow maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/><span class="koboSpan" id="kobo.1.1">Rendering the shadow maps</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">We now have everything we need in order to start rendering shadow maps of our scene. </span><span class="koboSpan" id="kobo.2.2">Some rather significant changes are going to have to be made to the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">LightManager</span></code><span class="koboSpan" id="kobo.4.1"> class in order to support this functionality, not to mention properly store and use these shadow map textures during later passes. </span><span class="koboSpan" id="kobo.4.2">Let's see what changes we need to make in order to make this happen.</span></p><div class="section" title="Modifying the light manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec99"/><span class="koboSpan" id="kobo.5.1">Modifying the light manager</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">First, let's make some adjustments to the light manager class definition. </span><span class="koboSpan" id="kobo.6.2">We're going to need a couple of methods to add shadow caster prototypes, add actual shadow casting objects, and render the shadow maps:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class LightManager { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.7.2">const std::string&amp; AddCasterPrototype(const std::string&amp; l_name, 
    std::unique_ptr&lt;ShadowCasterPrototype&gt; l_caster); 
  ShadowCaster* AddShadowCaster(const std::string&amp; l_prototypeName); 
  ShadowCasterPrototype* GetPrototype(const std::string&amp; l_name); 
  ... 
</span><span class="koboSpan" id="kobo.7.3">private: 
  ... 
  </span><span class="koboSpan" id="kobo.7.4">void DrawShadowMap(GLuint l_shadowShader, LightBase&amp; l_light, 
    unsigned int l_texture); 
  ... 
  </span><span class="koboSpan" id="kobo.7.5">ShadowCasterPrototypes m_casterPrototypes; 
  ShadowCasters m_shadowCasters; 
  GL_Camera m_perspectiveCamera; 
  std::unique_ptr&lt;CubeTexture&gt; m_cubeTextures[LightsPerPass]; 
  ... 
</span><span class="koboSpan" id="kobo.7.6">}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">In addition to the aforementioned methods, the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">LightManager</span></code><span class="koboSpan" id="kobo.10.1"> class is also going to need to store extra information to support these changes. </span><span class="koboSpan" id="kobo.10.2">A list of both shadow primitive prototypes and the primitives themselves will need to be used to manage the entities that have to cast shadows. </span><span class="koboSpan" id="kobo.10.3">Additionally, we need to have the camera class that will be used as the point of view of the light.</span></p><p><span class="koboSpan" id="kobo.11.1">Lastly, an array of cubemap textures is required, since each light onscreen will be potentially seeing the scene from a completely different point of view, of course. </span><span class="koboSpan" id="kobo.11.2">The size of this array is simply the number of lights we're dealing with per shader pass, because these cubemap textures only need to exist for as long as they're being sampled. </span><span class="koboSpan" id="kobo.11.3">Once the lighting pass for those particular lights is over, the textures can be re-used for the next batch.</span></p><div class="section" title="Implementing the light manager changes"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec21"/><span class="koboSpan" id="kobo.12.1">Implementing the light manager changes</span></h3></div></div></div><p><span class="koboSpan" id="kobo.13.1">The adjustments to the constructor of the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">LightManager</span></code><span class="koboSpan" id="kobo.15.1"> class are fairly simple to make this work:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">LightManager::LightManager(...) : ..., 
  m_perspectiveCamera({0.f, 0.f, 0.f}, 90.f, 
    CubeTexture::TextureWidth / CubeTexture::TextureHeight, 
    1.f, 200.f) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.16.2">for (auto i = 0; i &lt; LightsPerPass; ++i) { 
    m_cubeTextures[i] = std::make_unique&lt;CubeTexture&gt;(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.17.1">The first thing we need to worry about is setting up the perspective camera correctly. </span><span class="koboSpan" id="kobo.17.2">It's initialized to be positioned at absolute zero coordinates in the world, and has its field of view angle set to </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">90 degrees</span></strong></span><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">The aspect ratio of the perspective camera is obviously going to be </span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">1</span></em></span><span class="koboSpan" id="kobo.21.1">, because the width and height of the textures we're using for rendering shadow casters to are identical. </span><span class="koboSpan" id="kobo.21.2">The view frustum minimum value is set to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">1.f</span></em></span><span class="koboSpan" id="kobo.23.1">, which ensures that the geometry won't be rendered if the light is intersecting with a face. </span><span class="koboSpan" id="kobo.23.2">The maximum value, however, will change for each light, depending on its radius. </span><span class="koboSpan" id="kobo.23.3">This default value isn't really important.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/><span class="koboSpan" id="kobo.24.1">Note</span></h3><p><span class="koboSpan" id="kobo.25.1">Setting the field of view angle of </span><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">90</span></strong></span><span class="koboSpan" id="kobo.27.1"> degrees for rendering a scene to a cubemap texture is important, as that's the only way the scene is going to be captured completely for each direction the camera looks at. </span><span class="koboSpan" id="kobo.27.2">Going too low on this value means there are going to be blind spots, and going too high will cause overlapping.</span></p></div></div><p><span class="koboSpan" id="kobo.28.1">The last thing we need to do in the constructor is make sure that all cubemap textures are allocated properly.</span></p><p><span class="koboSpan" id="kobo.29.1">Next, let's worry about adding shadow caster prototypes to the light manager:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">const std::string&amp; LightManager::AddCasterPrototype( 
  const std::string&amp; l_name, 
  std::unique_ptr&lt;ShadowCasterPrototype&gt; l_caster) 
{ 
  auto itr = m_casterPrototypes.find(l_name); 
  if (itr != m_casterPrototypes.end()) { 
    l_caster.release(); return l_name; 
  } 
  for (auto&amp; prototype : m_casterPrototypes) { 
    if (*prototype.second == *l_caster) { 
      l_caster.release(); return prototype.first; 
    } 
  } 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  l_caster-&gt;UploadVertices(); 
  m_casterPrototypes.emplace(l_name, std::move(l_caster)); 
  return l_name; 
} 
</span></pre><p><span class="koboSpan" id="kobo.31.1">When adding a prototype, the caller of this particular method will provide a string identifier for it, as well as move its established and allocated smart pointer to the second argument after the vertices have been properly loaded. </span><span class="koboSpan" id="kobo.31.2">First, we make sure the name provided as an argument isn't already taken. </span><span class="koboSpan" id="kobo.31.3">If it is, that same string is returned back just after the memory for the prototype provided as an argument is released.</span></p><p><span class="koboSpan" id="kobo.32.1">The second test makes sure that a prototype with the exact arrangement of vertices doesn't already exist under a different name, by iterating over every stored prototype and using the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">== </span></code><span class="koboSpan" id="kobo.34.1">operator we implemented earlier to compare the two. </span><span class="koboSpan" id="kobo.34.2">If something is found, the name of that prototype is returned instead, just after the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">l_caster</span></code><span class="koboSpan" id="kobo.36.1"> is released.</span></p><p><span class="koboSpan" id="kobo.37.1">Finally, since we can be sure that the prototype we're adding is completely unique, the render window is set to active. </span><code class="literal"><span class="koboSpan" id="kobo.38.1">UploadVertices</span></code><span class="koboSpan" id="kobo.39.1"> on the object is invoked to send the data to the GPU and the prototype is placed inside the designated container.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/><span class="koboSpan" id="kobo.40.1">Note</span></h3><p><span class="koboSpan" id="kobo.41.1">Using </span><code class="literal"><span class="koboSpan" id="kobo.42.1">sf::RenderWindow::setActive(true)</span></code><span class="koboSpan" id="kobo.43.1"> ensures that the main context is used while the vertices are uploaded. </span><span class="koboSpan" id="kobo.43.2">OpenGL </span><span class="strong"><strong><span class="koboSpan" id="kobo.44.1">does not</span></strong></span><span class="koboSpan" id="kobo.45.1"> share its states among different contexts, and since SFML likes to keep a number of different contexts alive internally, it's imperative to make sure the main context is selected during all operations.</span></p></div></div><p><span class="koboSpan" id="kobo.46.1">Adding shadow casters themselves is relatively easy as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">ShadowCaster* LightManager::AddShadowCaster( 
  const std::string&amp; l_prototypeName) 
{ 
  auto prototype = GetPrototype(l_prototypeName); 
  if (!prototype) { return nullptr; } 
  m_shadowCasters.emplace_back(); 
  auto&amp; caster = m_shadowCasters.back(); 
  caster = std::make_unique&lt;ShadowCaster&gt;(); 
  caster-&gt;m_prototype = prototype; 
  return caster.get(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.48.1">This method only takes a string identifier for the prototype to be used, and allocates space for a new shadow caster object, provided the prototype with said name exists. </span><span class="koboSpan" id="kobo.48.2">Note the line just before the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">return</span></code><span class="koboSpan" id="kobo.50.1"> statement. </span><span class="koboSpan" id="kobo.50.2">It ensures that the located prototype is passed to the shadow caster, so that it can use the prototype later.</span></p><p><span class="koboSpan" id="kobo.51.1">Obtaining the prototypes is incredibly simple, and only requires a lookup into an </span><code class="literal"><span class="koboSpan" id="kobo.52.1">unordered_map</span></code><span class="koboSpan" id="kobo.53.1"> container:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">ShadowCasterPrototype* LightManager::GetPrototype( 
  const std::string&amp; l_name) 
{ 
  auto itr = m_casterPrototypes.find(l_name); 
  if (itr == m_casterPrototypes.end()) { return nullptr; } 
  return itr-&gt;second.get(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.55.1">We now only have one task at hand drawing the shadow maps!</span></p><div class="section" title="Drawing the actual shadow maps"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec2"/><span class="koboSpan" id="kobo.56.1">Drawing the actual shadow maps</span></h4></div></div></div><p><span class="koboSpan" id="kobo.57.1">In order to keep this manageable and compartmentalized, we're going to break down the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">DrawShadowMap</span></code><span class="koboSpan" id="kobo.59.1"> method into smaller parts that we can discuss independently of the rest of the code. </span><span class="koboSpan" id="kobo.59.2">Let's start by looking at the actual blueprint of the method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.60.1">void LightManager::DrawShadowMap(GLuint l_shadowShader, 
  LightBase&amp; l_light, unsigned int l_texture) 
{ 
  ... 
</span><span class="koboSpan" id="kobo.60.2">} 
</span></pre><p><span class="koboSpan" id="kobo.61.1">First, it takes in a handle for the shadow pass shader. </span><span class="koboSpan" id="kobo.61.2">This is about as raw as it gets, since the handle is a simple unsigned integer we're going to bind to before drawing. </span><span class="koboSpan" id="kobo.61.3">The second argument is a reference to a light that we're currently drawing the shadow map for. </span><span class="koboSpan" id="kobo.61.4">Lastly, we have an </span><span class="emphasis"><em><span class="koboSpan" id="kobo.62.1">unsigned integer</span></em></span><span class="koboSpan" id="kobo.63.1"> that serves as the ID for the light that's being rendered in the current pass. </span><span class="koboSpan" id="kobo.63.2">In the case of having 4 lights per shader pass, this value will range from 0 to 3, and then get reset in the next pass. </span><span class="koboSpan" id="kobo.63.3">It is going to be used as an index for the cubemap texture lookup.</span></p><p><span class="koboSpan" id="kobo.64.1">Now, it's time to really get into the actual rendering of the shadow maps, starting with enabling necessary OpenGL features:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.65.1">glEnable(GL_DEPTH_TEST); 
glEnable(GL_CULL_FACE); 
glCullFace(GL_FRONT); 
</span></pre><p><span class="koboSpan" id="kobo.66.1">The first and most obvious feature we're going to be using here is the depth test. </span><span class="koboSpan" id="kobo.66.2">This ensures that different shadow caster geometry isn't rendered in the wrong order, overlapping each other. </span><span class="koboSpan" id="kobo.66.3">Then, we're going to be performing some face culling. </span><span class="koboSpan" id="kobo.66.4">Unlike normal geometry, however, we're going to be culling the front faces only. </span><span class="koboSpan" id="kobo.66.5">Drawing the back faces of shadow geometry will ensure that the front faces of sprites we're using will be lit, since the depth stored in the shadow map is the depth of the very back of the shadow-casting primitives.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.67.1">glUseProgram(l_shadowShader); 
auto u_model = glGetUniformLocation(l_shadowShader, "m_model"); 
auto u_view = glGetUniformLocation(l_shadowShader, "m_view"); 
auto u_proj = glGetUniformLocation(l_shadowShader, "m_proj"); 
auto u_lightPos = glGetUniformLocation(l_shadowShader,"lightPos"); 
auto u_frustumFar = glGetUniformLocation(l_shadowShader, 
  "frustumFar"); 
</span></pre><p><span class="koboSpan" id="kobo.68.1">The next part here deals with actually binding the shadow pass shader and fetching locations of different shader uniform variables. </span><span class="koboSpan" id="kobo.68.2">We have a model matrix uniform, a view matrix uniform, a projection matrix uniform, a light position uniform, and the frustum far uniform to update.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.69.1">auto&amp; texture = m_cubeTextures[l_texture]; 
auto l_pos = l_light.m_lightPos; 
m_perspectiveCamera.SetPosition({ l_pos.x, l_pos.z, l_pos.y }); 
glViewport( 
  0, 0, CubeTexture::TextureWidth, CubeTexture::TextureHeight); 
texture-&gt;RenderingBind(); 
glUniform3f(u_lightPos, l_pos.x, l_pos.z, l_pos.y); 
</span></pre><p><span class="koboSpan" id="kobo.70.1">This next part of the code obtains a reference to the appropriate cubemap texture for the particular light, storing the light position, and positioning the perspective camera at that exact position.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/><span class="koboSpan" id="kobo.71.1">Note</span></h3><p><span class="koboSpan" id="kobo.72.1">Note the swapped </span><span class="emphasis"><em><span class="koboSpan" id="kobo.73.1">Z</span></em></span><span class="koboSpan" id="kobo.74.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.75.1">Y</span></em></span><span class="koboSpan" id="kobo.76.1"> coordinates. </span><span class="koboSpan" id="kobo.76.2">By default, OpenGL deals with the right-hand coordinate system. </span><span class="koboSpan" id="kobo.76.3">It also deals with the default </span><span class="emphasis"><em><span class="koboSpan" id="kobo.77.1">up</span></em></span><span class="koboSpan" id="kobo.78.1"> direction being the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.79.1">+Y</span></em></span><span class="koboSpan" id="kobo.80.1"> axis. </span><span class="koboSpan" id="kobo.80.2">Our lights store coordinates using the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.81.1">+Z</span></em></span><span class="koboSpan" id="kobo.82.1"> axis as the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.83.1">up</span></em></span><span class="koboSpan" id="kobo.84.1"> direction.</span></p></div></div><p><span class="koboSpan" id="kobo.85.1">After the camera is set up, </span><code class="literal"><span class="koboSpan" id="kobo.86.1">glViewport</span></code><span class="koboSpan" id="kobo.87.1"> is invoked to resize the render target to the size of the cubemap texture. </span><span class="koboSpan" id="kobo.87.2">The cubemap is then bound to for rendering and we submit the light position uniform to the shaders. </span><span class="koboSpan" id="kobo.87.3">Just as before, the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.88.1">Z</span></em></span><span class="koboSpan" id="kobo.89.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.90.1">Y</span></em></span><span class="koboSpan" id="kobo.91.1"> directions here are swapped.</span></p><p><span class="koboSpan" id="kobo.92.1">With the setup out of the way, we can actually begin rendering the scene for each face of the cubemap:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.93.1">for (auto face = 0; face &lt; 6; ++face) { 
  texture-&gt;RenderToFace(face); 
  m_perspectiveCamera.SetForwardDir(CubeMapDirections[face]); 
  m_perspectiveCamera.SetUpDir(CubeMapUpDirections[face]); 
  m_perspectiveCamera.SetFrustumFar(l_light.m_radius); 
  m_perspectiveCamera.RecalculatePerspective(); 
  auto viewMat = m_perspectiveCamera.GetViewMatrix(); 
  auto&amp; projMat = m_perspectiveCamera.GetProjectionMatrix(); 
  glUniformMatrix4fv(u_view, 1, GL_FALSE, &amp;viewMat[0][0]); 
  glUniformMatrix4fv(u_proj, 1, GL_FALSE, &amp;projMat[0][0]); 
  glUniform1f(u_frustumFar, m_perspectiveCamera.GetFrustumFar()); 
  for (auto&amp; caster : m_shadowCasters) { 
    auto modelMat = caster-&gt;m_transform.GetModelMatrix(); 
    glUniformMatrix4fv(u_model, 1, GL_FALSE, &amp;modelMat[0][0]); 
    caster-&gt;m_prototype-&gt;Draw(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.94.1">The cubemap texture is first told which face we wish to render to in order to set up the FBO correctly. </span><span class="koboSpan" id="kobo.94.2">The forward and up directions for that particular face are then passed to the light's camera, along with the frustum far value, being the radius of the light. </span><span class="koboSpan" id="kobo.94.3">The perspective projection matrix is then recalculated, and both the view and projection matrices are retrieved from </span><code class="literal"><span class="koboSpan" id="kobo.95.1">GL_Camera</span></code><span class="koboSpan" id="kobo.96.1"> to pass to the shader, along with the frustum far value.</span></p><p><span class="koboSpan" id="kobo.97.1">Lastly, for each of the 6 faces of the cubemap, we iterate over all of the shadow caster objects, retrieve their model matrices, pass them into the shader, and invoke the prototype's </span><code class="literal"><span class="koboSpan" id="kobo.98.1">Draw()</span></code><span class="koboSpan" id="kobo.99.1"> method, which takes care of the rendering.</span></p><p><span class="koboSpan" id="kobo.100.1">After all of the texture's faces have been drawn to, we need to set the state back to what it was before rendering shadow maps:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.101.1">texture-&gt;RenderingUnbind(); 
glViewport( 
  0, 0, m_window-&gt;GetWindowSize().x, m_window-&gt;GetWindowSize().y); 
glDisable(GL_DEPTH_TEST); 
glDisable(GL_CULL_FACE); 
glCullFace(GL_BACK); 
</span></pre><p><span class="koboSpan" id="kobo.102.1">The texture is first unbound for rendering, which sets the FBO to 0 and allows us to draw to the screen again. </span><span class="koboSpan" id="kobo.102.2">The viewport is then resized back to the original size our window had, and the depth test, along with face culling, are both disabled.</span></p></div></div></div><div class="section" title="The shadow pass shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec100"/><span class="koboSpan" id="kobo.103.1">The shadow pass shaders</span></h2></div></div></div><p><span class="koboSpan" id="kobo.104.1">The C++ side of shadow mapping is finished, but we still have some logic to cover. </span><span class="koboSpan" id="kobo.104.2">The shaders here play an important role of actually translating the vertex information into depth. </span><span class="koboSpan" id="kobo.104.3">Let's take a look at the vertex shader first:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.105.1">in vec3 position; 
uniform mat4 m_model; 
uniform mat4 m_view; 
uniform mat4 m_proj; 
uniform vec3 lightPos; 
uniform float frustumFar; 
out float distance; 
 
void main() { 
  vec4 worldCoords = m_model * vec4(position, 1.0); 
  float d = length(worldCoords.xyz - lightPos); 
  d /= frustumFar; 
  gl_Position = m_proj * m_view * worldCoords; 
  distance = d; 
} 
</span></pre><p><span class="koboSpan" id="kobo.106.1">The </span><code class="literal"><span class="koboSpan" id="kobo.107.1">vec3</span></code><span class="koboSpan" id="kobo.108.1"> input coordinates of a vertex position we receive on the GPU are in local space, which means they have to be passed through a number of matrices to be brought to world, view, and clip spaces in that order. </span><span class="koboSpan" id="kobo.108.2">The world coordinates are calculated first and stored separately, because they're used to determine the distance between the vertex and the light. </span><span class="koboSpan" id="kobo.108.3">That distance is stored in the local variable </span><code class="literal"><span class="koboSpan" id="kobo.109.1">d</span></code><span class="koboSpan" id="kobo.110.1">, which is divided by the frustum far value to convert it to a range of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.111.1">[0;1]</span></em></span><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">The position of the vertex is then converted to clip space by using the world, view, and projection matrices, and the distance value is passed on to the fragment shader, where it's stored as a color for a particular pixel:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.113.1">in float distance; 
 
void main() { 
  gl_FragColor = vec4(distance, distance, distance, 1.0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.114.1">Remember that the output variables from the vertex shader are interpolated between the vertices, so each fragment in between those vertices will be shaded in a gradient-like manner.</span></p></div><div class="section" title="Results"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec101"/><span class="koboSpan" id="kobo.115.1">Results</span></h2></div></div></div><p><span class="koboSpan" id="kobo.116.1">While we still don't have any actual geometry in the project to see the results of this, once we're done, it will look like the following screenshot:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.117.1"><img src="graphics/image_09_007.jpg" alt="Results"/></span></div><p><span class="koboSpan" id="kobo.118.1">In this particular case, the primitives were extremely close to the light, so they're shaded really dark. </span><span class="koboSpan" id="kobo.118.2">Given greater distances, a particular face of a shadow map would look a little something like this, where </span><span class="emphasis"><em><span class="koboSpan" id="kobo.119.1">#1</span></em></span><span class="koboSpan" id="kobo.120.1"> is a primitive close to the camera, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.121.1">#2</span></em></span><span class="koboSpan" id="kobo.122.1"> is further away, and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.123.1">#3</span></em></span><span class="koboSpan" id="kobo.124.1"> is near the far end of the view frustum:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.125.1"><img src="graphics/image_09_008.jpg" alt="Results"/></span></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Adapting the light pass"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/><span class="koboSpan" id="kobo.1.1">Adapting the light pass</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">With the shadow maps rendered, it may be extremely tempting to try and sample them in our existing code, since the hard part is over, right? </span><span class="koboSpan" id="kobo.2.2">Well, not entirely. </span><span class="koboSpan" id="kobo.2.3">While we were extremely close with our previous approach, sadly, sampling of cubemap textures is the only thing that we couldn't do because of SFML. </span><span class="koboSpan" id="kobo.2.4">The sampling itself isn't really the problem, as much as binding the cubemap textures to be sampled is. </span><span class="koboSpan" id="kobo.2.5">Remember that sampling is performed by setting a uniform value of the sampler inside the shader to the </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">texture unit ID</span></strong></span><span class="koboSpan" id="kobo.4.1"> that's bound to the texture in our C++ code. </span><span class="koboSpan" id="kobo.4.2">SFML resets these units each time something is rendered either onscreen, or to a render texture. </span><span class="koboSpan" id="kobo.4.3">The reason we haven't had this problem before is because we can set the uniforms of the shaders through SFML's </span><code class="literal"><span class="koboSpan" id="kobo.5.1">sf::Shader</span></code><span class="koboSpan" id="kobo.6.1"> class, which keeps track of references to textures and binds them to appropriate units when a shader is used for rendering. </span><span class="koboSpan" id="kobo.6.2">That's all fine and good, except for when the time comes to sample other types of textures that SFML doesn't support, which includes cubemaps. </span><span class="koboSpan" id="kobo.6.3">This is the only problem that requires us to completely cut SFML out of the picture during the light pass and use raw OpenGL instead.</span></p><div class="section" title="Replacing the m_fullScreenQuad"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec102"/><span class="koboSpan" id="kobo.7.1">Replacing the m_fullScreenQuad</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">First things first, replacing the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">sf::VertexArray</span></code><span class="koboSpan" id="kobo.10.1"> object inside the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">LightManager</span></code><span class="koboSpan" id="kobo.12.1"> class that's used to redraw an entire buffer texture, which we were utilizing for multipass rendering. </span><span class="koboSpan" id="kobo.12.2">Since SFML has to be completely cut out of the picture here, we can't use its built-in vertex array class and render a quad that covers the entire screen. </span><span class="koboSpan" id="kobo.12.3">Otherwise, SFML will force its own state on before rendering, which isn't going to work with our system properly as it re-assigns its own texture units each time.</span></p><div class="section" title="Defining a generic frame buffer object"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec22"/><span class="koboSpan" id="kobo.13.1">Defining a generic frame buffer object</span></h3></div></div></div><p><span class="koboSpan" id="kobo.14.1">Just like before, we need to create a frame buffer object in order to render to a texture, rather than the screen. </span><span class="koboSpan" id="kobo.14.2">Since we've already done this once before for a cubemap, let's breeze through the implementation of a generic FBO class for 2D textures:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">class GenericFBO { 
public: 
  GenericFBO(const sf::Vector2u&amp; l_size); 
  ~GenericFBO(); 
 
  void Create(); 
 
  void RenderingBind(GLuint l_texture); 
  void RenderingUnbind(); 
private: 
  sf::Vector2u m_size; 
  GLuint m_FBO; 
  GLuint m_RBO; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.16.1">The main difference here is the fact that we're using variable sizes for textures now. </span><span class="koboSpan" id="kobo.16.2">They may vary at some point, so it's a good idea to store the size internally, rather than using constant values.</span></p><div class="section" title="Implementing a generic frame buffer object"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec3"/><span class="koboSpan" id="kobo.17.1">Implementing a generic frame buffer object</span></h4></div></div></div><p><span class="koboSpan" id="kobo.18.1">The constructor and destructor of this class, once again, deals with resource management:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">GenericFBO::GenericFBO(const sf::Vector2u&amp; l_size) : 
  m_size(l_size), m_FBO(0), m_RBO(0) {} 
 
GenericFBO::~GenericFBO() { 
  if (m_FBO) { glDeleteFramebuffers(1, &amp;m_FBO); } 
  if (m_RBO) { glDeleteRenderbuffers(1, &amp;m_RBO); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.20.1">We're not storing a texture handle, because that too will vary depending on circumstances.</span></p><p><span class="koboSpan" id="kobo.21.1">Creating the buffers for this class is pretty similar to what we've done before:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void GenericFBO::Create() { 
  if (!m_FBO) { glCreateFramebuffers(1, &amp;m_FBO); } 
  glBindFramebuffer(GL_FRAMEBUFFER, m_FBO); 
  if (!m_RBO) { glCreateRenderbuffers(1, &amp;m_RBO); } 
  glBindRenderbuffer(GL_RENDERBUFFER, m_RBO); 
 
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, 
    m_size.x, m_size.y); 
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, 
    GL_RENDERBUFFER, m_RBO); 
  auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER); 
  if (status != GL_FRAMEBUFFER_COMPLETE) { ... </span><span class="koboSpan" id="kobo.22.2">} // Print status. 
  </span><span class="koboSpan" id="kobo.22.3">glBindFramebuffer(GL_FRAMEBUFFER, 0); 
  glBindRenderbuffer(GL_RENDERBUFFER, 0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">Just like the cubemap textures, we need to attach a depth render buffer to the FBO. </span><span class="koboSpan" id="kobo.23.2">After allocation and binding, the FBO is checked for errors and both buffers are unbound.</span></p><p><span class="koboSpan" id="kobo.24.1">Rendering FBO points to a 2D texture is much easier. </span><span class="koboSpan" id="kobo.24.2">Binding for rendering needs to take a handle to a texture, because one is not stored internally, since this is a generic class that will be used with many different textures:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">void GenericFBO::RenderingBind(GLuint l_texture) { 
  glBindFramebuffer(GL_FRAMEBUFFER, m_FBO); 
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
    GL_TEXTURE_2D, l_texture, 0); 
} 
 
void GenericFBO::RenderingUnbind() { 
  glBindFramebuffer(GL_FRAMEBUFFER, 0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.26.1">Once the FBO is bound, we again invoke </span><code class="literal"><span class="koboSpan" id="kobo.27.1">glFramebufferTexture2D</span></code><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">This time, however, we use </span><code class="literal"><span class="koboSpan" id="kobo.29.1">GL_TEXTURE_2D</span></code><span class="koboSpan" id="kobo.30.1"> as the type of the texture, and pass in the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">l_texture</span></code><span class="koboSpan" id="kobo.32.1"> argument into the function instead.</span></p></div></div></div><div class="section" title="Rendering from a buffer to another buffer in OpenGL"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec103"/><span class="koboSpan" id="kobo.33.1">Rendering from a buffer to another buffer in OpenGL</span></h2></div></div></div><p><span class="koboSpan" id="kobo.34.1">During our potentially numerous light passes, we're going to need a way of redrawing every pixel onscreen to the buffer texture just like we did before, except without using SFML this time. </span><span class="koboSpan" id="kobo.34.2">For this purpose, we're going to construct a quad that has four vertices, all positioned in screen coordinates, and covers the screen entirely. </span><span class="koboSpan" id="kobo.34.3">These vertices are also going to have texture coordinates that will be used to sample the buffer texture. </span><span class="koboSpan" id="kobo.34.4">A basic structure of such vertex, similar to the one we created in </span><a class="link" href="ch07.html" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><span class="koboSpan" id="kobo.35.1">Chapter 7
</span></a><span class="koboSpan" id="kobo.36.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.37.1">One Step Forward, One Level Down - OpenGL Basics</span></em></span><span class="koboSpan" id="kobo.38.1"> looks like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">struct BasicVertex { 
  glm::vec3 m_pos; 
  glm::vec2 m_tex; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.40.1">This small structure will be used by the quad primitive that will cover the entire screen.</span></p><div class="section" title="Creating a basic quad primitive"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec23"/><span class="koboSpan" id="kobo.41.1">Creating a basic quad primitive</span></h3></div></div></div><p><span class="koboSpan" id="kobo.42.1">The quad primitive, just like any other piece of geometry, must be pushed to the GPU for later use. </span><span class="koboSpan" id="kobo.42.2">Let's construct a very basic class that will break down this functionality into manageable methods we can easily call from other classes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">class BasicQuadPrimitive { 
public: 
  BasicQuadPrimitive(); 
  ~BasicQuadPrimitive(); 
 
  void Create(); 
  void Bind(); 
  void Render(); 
  void Unbind(); 
private: 
  GLuint m_VAO; 
  GLuint m_VBO; 
  GLuint m_indices; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.44.1">Once again, we have methods for creating, rendering, binding, and unbinding the primitive. </span><span class="koboSpan" id="kobo.44.2">The class stores the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">m_VAO</span></code><span class="koboSpan" id="kobo.46.1">, </span><code class="literal"><span class="koboSpan" id="kobo.47.1">m_VBO</span></code><span class="koboSpan" id="kobo.48.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.49.1">m_indices</span></code><span class="koboSpan" id="kobo.50.1"> of this primitive, which all need to be filled out.</span></p><div class="section" title="Implementing the quad primitive class"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec4"/><span class="koboSpan" id="kobo.51.1">Implementing the quad primitive class</span></h4></div></div></div><p><span class="koboSpan" id="kobo.52.1">Construction and destruction of this class, once again, all take care of the resource allocation/de-allocation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.53.1">BasicQuadPrimitive::BasicQuadPrimitive() : m_VAO(0), 
  m_VBO(0), m_indices(0) {} 
 
BasicQuadPrimitive::~BasicQuadPrimitive() { 
  if (m_VAO) { glDeleteVertexArrays(1, &amp;m_VAO); } 
  if (m_VBO) { glDeleteBuffers(1, &amp;m_VBO); } 
  if (m_indices) { glDeleteBuffers(1, &amp;m_indices); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.54.1">Creating and uploading the primitive to the GPU is exactly the same as before:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.55.1">void BasicQuadPrimitive::Create() { 
  glGenVertexArrays(1, &amp;m_VAO); 
  glBindVertexArray(m_VAO); 
  glGenBuffers(1, &amp;m_VBO); 
  glGenBuffers(1, &amp;m_indices); 
 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
 
  BasicVertex vertices[4] = { 
    //    x    y    z        u    v 
    { { -1.f, 1.f, 0.f }, { 0.f, 1.f } }, // Top-left. 
    </span><span class="koboSpan" id="kobo.55.2">{ { 1.f, 1.f, 0.f }, { 1.f, 1.f } },  // Top-right. 
    </span><span class="koboSpan" id="kobo.55.3">{ { 1.f, -1.f, 0.f }, { 1.f, 0.f } }, // Bottom-right. 
    </span><span class="koboSpan" id="kobo.55.4">{ { -1.f, -1.f, 0.f }, { 0.f, 0.f } } // Bottom-left. 
  </span><span class="koboSpan" id="kobo.55.5">}; 
 
  auto stride = sizeof(vertices[0]); 
  auto texCoordOffset = sizeof(vertices[0].m_pos); 
  glBufferData(GL_ARRAY_BUFFER, 4 * sizeof(vertices[0]), 
    &amp;vertices[0], GL_STATIC_DRAW); 
  glEnableVertexAttribArray(0); 
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, 0); 
  glEnableVertexAttribArray(1); 
  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, 
    (void*)texCoordOffset); 
 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indices); 
  unsigned int indices[6] = { 0, 1, 2, 2, 3, 0 }; // CW! 
  </span><span class="koboSpan" id="kobo.55.6">glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), 
    &amp;indices[0], GL_STATIC_DRAW); 
  Unbind(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.56.1">The main difference here is that we're defining the vertices inside the method, since they're never going to change. </span><span class="koboSpan" id="kobo.56.2">The vertex attribute pointers are set up after the data is pushed onto the GPU; indices get defined in a clockwise manner (default for SFML), and pushed to the GPU.</span></p><p><span class="koboSpan" id="kobo.57.1">Binding and unbinding the buffers for rendering is, once again, exactly the same as with all of the other geometry for OpenGL:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.58.1">void BasicQuadPrimitive::Bind() { 
  if (!m_VAO) { return; } 
  glBindVertexArray(m_VAO); 
  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indices); 
} 
 
void BasicQuadPrimitive::Unbind() { 
  if (!m_VAO) { return; } 
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 
  glBindBuffer(GL_ARRAY_BUFFER, 0); 
  glBindVertexArray(0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.59.1">Since we're using indices, rendering the quad is achieved by calling </span><code class="literal"><span class="koboSpan" id="kobo.60.1">glDrawElements</span></code><span class="koboSpan" id="kobo.61.1">, just like before:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">void BasicQuadPrimitive::Render() { 
  glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.63.1">This concludes the necessary preparations for rendering from an offscreen buffer to the screen.</span></p></div></div></div><div class="section" title="Making the changes to the light manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec104"/><span class="koboSpan" id="kobo.64.1">Making the changes to the light manager</span></h2></div></div></div><p><span class="koboSpan" id="kobo.65.1">Given the complete re-architecture of our rendering process for shadows, it's obvious some things are going to have to change within the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">LightManager</span></code><span class="koboSpan" id="kobo.67.1"> class. </span><span class="koboSpan" id="kobo.67.2">First, let's start with some new data we're going to need to store:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.68.1">using MaterialHandles = std::unordered_map&lt; 
  MaterialMapType, unsigned int&gt;; 
using MaterialUniformNames = std::unordered_map&lt; 
  MaterialMapType, std::string&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.69.1">The </span><code class="literal"><span class="koboSpan" id="kobo.70.1">MaterialHandles</span></code><span class="koboSpan" id="kobo.71.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.72.1">MaterialUniformNames</span></code><span class="koboSpan" id="kobo.73.1"> containers will be used to store the names and locations of uniforms in our light pass shader. </span><span class="koboSpan" id="kobo.73.2">This is an effort made entirely to make the mapping of new material map types and uniforms much easier by automating it.</span></p><p><span class="koboSpan" id="kobo.74.1">With that out of the way, let's take a look at the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">LightManager</span></code><span class="koboSpan" id="kobo.76.1"> class definition and the changes we need to make to it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.77.1">class LightManager { 
  ... 
</span><span class="koboSpan" id="kobo.77.2">private: 
  void GenerateMaterials(); 
  void Bind2DTextures(GLuint l_program, int l_pass); 
  void Unbind2DTextures(); 
  void SubmitLightUniforms(GLuint l_program, 
    unsigned int l_lightID, const LightBase&amp; l_light); 
  ... 
  </span><span class="koboSpan" id="kobo.77.3">MaterialHandles m_materialHandles; 
  MaterialUniformNames m_materialNames; 
  //sf::VertexArray m_fullScreenQuad; 
  GenericFBO m_rendererFBO; 
  BasicQuadPrimitive m_fullScreenQuad; 
  ... 
</span><span class="koboSpan" id="kobo.77.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.78.1">In addition to creating some new helper methods for generating material names, binding and unbinding all of the necessary 2D textures for the light pass sampling, and submitting the uniforms of a given light to the light pass shader, we're also storing the material names and handles. </span><span class="koboSpan" id="kobo.78.2">The </span><code class="literal"><span class="koboSpan" id="kobo.79.1">m_fullScreenQuad</span></code><span class="koboSpan" id="kobo.80.1"> class is replaced by our own class, and to accompany it, we have the </span><code class="literal"><span class="koboSpan" id="kobo.81.1">GenericFBO</span></code><span class="koboSpan" id="kobo.82.1"> object that will help us render to an offscreen buffer.</span></p><div class="section" title="Implementing light manager changes"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec24"/><span class="koboSpan" id="kobo.83.1">Implementing light manager changes</span></h3></div></div></div><p><span class="koboSpan" id="kobo.84.1">The constructor of our </span><code class="literal"><span class="koboSpan" id="kobo.85.1">LightManager</span></code><span class="koboSpan" id="kobo.86.1"> class now has additional work to do in setting up all of the new data members we added:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.87.1">LightManager::LightManager(...) : ..., 
  m_rendererFBO(l_window-&gt;GetWindowSize()), ... 
</span><span class="koboSpan" id="kobo.87.2">{ 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  GenerateMaterials(); 
  m_materialNames[MaterialMapType::Diffuse] = "DiffuseMap"; 
  m_materialNames[MaterialMapType::Normal] = "NormalMap"; 
  m_materialNames[MaterialMapType::Specular] = "SpecularMap"; 
  m_materialNames[MaterialMapType::Height] = "HeightMap"; 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  m_rendererFBO.Create(); 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  m_fullScreenQuad.Create(); 
  ... 
</span><span class="koboSpan" id="kobo.87.3">} 
</span></pre><p><span class="koboSpan" id="kobo.88.1">First, the FBO we'll be using is set up in the initializer list to hold the size of our window. </span><span class="koboSpan" id="kobo.88.2">We then ensure that the main OpenGL context is active by activating our window, and invoke the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">GenerateMaterials</span></code><span class="koboSpan" id="kobo.90.1"> method that will take care of material texture allocation and storage of the texture handles for the same.</span></p><p><span class="koboSpan" id="kobo.91.1">The uniform sampler2D names for all material types are then stored in the appropriate container. </span><span class="koboSpan" id="kobo.91.2">These names have to match the ones inside the light pass shader!</span></p><p><span class="koboSpan" id="kobo.92.1">Finally, the main OpenGL context is selected again and the FBO is created. </span><span class="koboSpan" id="kobo.92.2">We do this one more time for the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">m_fullScreenQuad</span></code><span class="koboSpan" id="kobo.94.1"> class as well.</span></p><p><span class="koboSpan" id="kobo.95.1">The </span><code class="literal"><span class="koboSpan" id="kobo.96.1">GenerateMaterials()</span></code><span class="koboSpan" id="kobo.97.1"> method can be implemented like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.98.1">void LightManager::GenerateMaterials() { 
  auto windowSize = m_window-&gt;GetWindowSize(); 
  for (auto i = 0; i &lt; 
    static_cast&lt;int&gt;(MaterialMapType::COUNT); ++i) 
  { 
    auto type = static_cast&lt;MaterialMapType&gt;(i); 
    auto pair = m_materialMaps.emplace(type, 
      std::move(std::make_unique&lt;sf::RenderTexture&gt;())); 
    auto&amp; texture = pair.first-&gt;second; 
    texture-&gt;create(windowSize.x, windowSize.y); 
    m_materialHandles[type] = texture-&gt; 
      getTexture().getNativeHandle(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.99.1">It iterates over each material type and creates a new texture for it, just like we did before. </span><span class="koboSpan" id="kobo.99.2">The only difference here is that we also store the handle of the newly created texture in </span><code class="literal"><span class="koboSpan" id="kobo.100.1">m_materialHandles</span></code><span class="koboSpan" id="kobo.101.1">, in an effort to tie a specific </span><code class="literal"><span class="koboSpan" id="kobo.102.1">MaterialMapType</span></code><span class="koboSpan" id="kobo.103.1"> to an existing texture. </span><span class="koboSpan" id="kobo.103.2">We're still using SFML's render textures, because they did a fine job at managing 2D resources.</span></p><p><span class="koboSpan" id="kobo.104.1">Binding all of the necessary textures to be sampled in the light pass shader would look like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.105.1">void LightManager::Bind2DTextures(GLuint l_program, int l_pass) { 
  auto finishedTexture = m_window-&gt;GetRenderer()-&gt; 
    GetFinishedTexture()-&gt;getTexture().getNativeHandle(); 
  auto lastPassHandle = (l_pass == 0 ? 
    </span><span class="koboSpan" id="kobo.105.2">m_materialHandles[MaterialMapType::Diffuse] : 
    finishedTexture); 
  m_window-&gt;GetRenderWindow()-&gt;setActive(true); 
  glActiveTexture(GL_TEXTURE0); 
  glBindTexture(GL_TEXTURE_2D, lastPassHandle); 
  glUniform1i(glGetUniformLocation(l_program, "LastPass"), 0); 
 
  for (int i = 0;i&lt;static_cast&lt;int&gt;(MaterialMapType::COUNT);++i) { 
    auto type = static_cast&lt;MaterialMapType&gt;(i); 
    glActiveTexture(GL_TEXTURE1 + i); 
    glBindTexture(GL_TEXTURE_2D, m_materialMaps[type]-&gt; 
      getTexture().getNativeHandle()); 
    auto uniform = glGetUniformLocation(l_program, 
      m_materialNames[type].c_str()); 
    glUniform1i(uniform, i + 1); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.106.1">This particular method will be used inside the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">RenderScene</span></code><span class="koboSpan" id="kobo.108.1"> method for rendering lights. </span><span class="koboSpan" id="kobo.108.2">It takes two arguments: a handler for the light pass shader, and the ID of the current pass taking place.</span></p><p><span class="koboSpan" id="kobo.109.1">The finished texture handle is then obtained from the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">Renderer</span></code><span class="koboSpan" id="kobo.111.1"> class. </span><span class="koboSpan" id="kobo.111.2">Just like before, we must pass the right texture as the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">"LastPass"</span></code><span class="koboSpan" id="kobo.113.1"> uniform in the light pass shader. </span><span class="koboSpan" id="kobo.113.2">If we're still on the very first pass, a diffuse texture is used instead.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/><span class="koboSpan" id="kobo.114.1">Note</span></h3><p><span class="koboSpan" id="kobo.115.1">Passing textures to a shader for sampling simply means we're sending one integer to the shader. </span><span class="koboSpan" id="kobo.115.2">That integer represents the texture unit we want to sample.</span></p></div></div><p><span class="koboSpan" id="kobo.116.1">The render window is then set to active once again to make sure the main OpenGL context is active. </span><span class="koboSpan" id="kobo.116.2">We then bind to the texture unit 0 and use it for the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">"LastPass"</span></code><span class="koboSpan" id="kobo.118.1"> uniform. </span><span class="koboSpan" id="kobo.118.2">All of the other materials are taken care of inside a </span><code class="literal"><span class="koboSpan" id="kobo.119.1">for</span></code><span class="koboSpan" id="kobo.120.1"> loop that runs once for each material type. </span><span class="koboSpan" id="kobo.120.2">The texture unit </span><code class="literal"><span class="koboSpan" id="kobo.121.1">GL_TEXTURE1 + i</span></code><span class="koboSpan" id="kobo.122.1"> is activated, which ensures that we start from unit 1 and go up, since unit 0 is already being used. </span><span class="koboSpan" id="kobo.122.2">The appropriate texture is then bound to, and the uniform of the correct sampler for that material type is located. </span><span class="koboSpan" id="kobo.122.3">The uniform is then set to the texture unit we've just activated.</span></p><p><span class="koboSpan" id="kobo.123.1">Unbinding these textures is easier still:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.124.1">void LightManager::Unbind2DTextures() { 
  for (int i = 0; i &lt;= 
    static_cast&lt;int&gt;(MaterialMapType::COUNT); ++i) 
  { 
    glActiveTexture(GL_TEXTURE0 + i); 
    glBindTexture(GL_TEXTURE_2D, 0); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.125.1">Note that we're now iterating from 0 up and including the material type count. </span><span class="koboSpan" id="kobo.125.2">This ensures that even texture unit </span><code class="literal"><span class="koboSpan" id="kobo.126.1">0 </span></code><span class="koboSpan" id="kobo.127.1">is unbound, since we're activating </span><code class="literal"><span class="koboSpan" id="kobo.128.1">GL_TEXTURE0 + i</span></code><span class="koboSpan" id="kobo.129.1">.</span></p><div class="section" title="Re-working the light pass"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec5"/><span class="koboSpan" id="kobo.130.1">Re-working the light pass</span></h4></div></div></div><p><span class="koboSpan" id="kobo.131.1">Finally, we'll take a look at the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">RenderScene()</span></code><span class="koboSpan" id="kobo.133.1"> method. </span><span class="koboSpan" id="kobo.133.2">For clarity, we're going to break it down into smaller chunks, just like before:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.134.1">void LightManager::RenderScene() { 
  ... 
</span><span class="koboSpan" id="kobo.134.2">} 
</span></pre><p><span class="koboSpan" id="kobo.135.1">First, let's start at the top of the method and set up some variables that are going to be used throughout:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.136.1">... </span><span class="koboSpan" id="kobo.136.2">// Inside the RenderScene() method. 
</span><span class="koboSpan" id="kobo.136.3">auto renderer = m_window-&gt;GetRenderer(); 
auto passes = static_cast&lt;int&gt;( 
  std::ceil(static_cast&lt;float&gt;(m_lights.size()) / LightsPerPass)); 
auto&amp; beginning = m_lights.begin(); 
auto LightPassShaderHandle = renderer-&gt; 
  GetShader("LightPass")-&gt;getNativeHandle(); 
auto ShadowPassShaderHandle = renderer-&gt; 
  GetShader("ShadowPass")-&gt;getNativeHandle(); 
auto CurrentShaderHandle = (renderer-&gt;GetCurrentShader() ?  
  </span><span class="koboSpan" id="kobo.136.4">renderer-&gt;GetCurrentShader()-&gt;getNativeHandle() : 0); 
 
auto window = m_window-&gt;GetRenderWindow(); 
</span></pre><p><span class="koboSpan" id="kobo.137.1">The </span><code class="literal"><span class="koboSpan" id="kobo.138.1">passes</span></code><span class="koboSpan" id="kobo.139.1"> variable works out how many passes we're going to need with the given number of lights. </span><span class="koboSpan" id="kobo.139.2">We then obtain a reference to the beginning of the light container, the light pass shader handle, the shadow pass shader handle, and the shader handle of the currently used shader that's set up inside the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">Renderer</span></code><span class="koboSpan" id="kobo.141.1"> object, if there is one. </span><span class="koboSpan" id="kobo.141.2">Lastly, the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">window</span></code><span class="koboSpan" id="kobo.143.1"> pointer is obtained for easy access.</span></p><p><span class="koboSpan" id="kobo.144.1">Still inside the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">RenderScene</span></code><span class="koboSpan" id="kobo.146.1"> method, we enter into a </span><code class="literal"><span class="koboSpan" id="kobo.147.1">for</span></code><span class="koboSpan" id="kobo.148.1"> loop that's going to iterate for each pass:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.149.1">... </span><span class="koboSpan" id="kobo.149.2">// Inside the RenderScene() method. 
</span><span class="koboSpan" id="kobo.149.3">for (int pass = 0; pass &lt; passes; ++pass) { 
  auto&amp; first = beginning + (pass * LightsPerPass); 
  auto LightCount = 0; 
  ... 
</span><span class="koboSpan" id="kobo.149.4">} 
</span></pre><p><span class="koboSpan" id="kobo.150.1">Another reference to a light container iterator is obtained. </span><span class="koboSpan" id="kobo.150.2">This time, it points to the first light for this current pass. </span><span class="koboSpan" id="kobo.150.3">Also, a </span><code class="literal"><span class="koboSpan" id="kobo.151.1">LightCount</span></code><span class="koboSpan" id="kobo.152.1"> variable is set up to keep track of the number of lights rendered for the current pass so far.</span></p><p><span class="koboSpan" id="kobo.153.1">Before we go on to do any actual light rendering, we need to draw the shadow maps for the lights we're going to be using in this pass:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.154.1">... </span><span class="koboSpan" id="kobo.154.2">// Inside the pass loop. 
</span><span class="koboSpan" id="kobo.154.3">for (int lightID = 0; lightID &lt; LightsPerPass; ++lightID) { 
  // Drawing shadow maps. 
  </span><span class="koboSpan" id="kobo.154.4">auto&amp; light = first + lightID; 
  if (light == m_lights.end()) { break; } 
  window-&gt;setActive(true); 
  DrawShadowMap(ShadowPassShaderHandle, *light, lightID); 
  ++LightCount; 
} 
</span></pre><p><span class="koboSpan" id="kobo.155.1">Here, we iterate over each light that belongs to this pass. </span><span class="koboSpan" id="kobo.155.2">A check needs to be made to make sure we haven't reached the end of the container, however. </span><span class="koboSpan" id="kobo.155.3">Provided that's not the case, the main OpenGL context is enabled by calling </span><code class="literal"><span class="koboSpan" id="kobo.156.1">setActive(true)</span></code><span class="koboSpan" id="kobo.157.1">, and the shadow map for the current light is drawn to the cubemap buffer texture. </span><span class="koboSpan" id="kobo.157.2">The </span><code class="literal"><span class="koboSpan" id="kobo.158.1">LightCount</span></code><span class="koboSpan" id="kobo.159.1"> is then incremented to let the rest of the code know how many lights we're dealing with during this pass.</span></p><p><span class="koboSpan" id="kobo.160.1">After shadow maps have been rendered, it's time to actually bind the light pass shader and begin passing information to it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.161.1">... </span><span class="koboSpan" id="kobo.161.2">// Inside the pass loop. 
</span><span class="koboSpan" id="kobo.161.3">glUseProgram(LightPassShaderHandle); 
Bind2DTextures(LightPassShaderHandle, pass); 
glUniform3f(glGetUniformLocation(LightPassShaderHandle, 
    "AmbientLight"), 
  m_ambientLight.m_lightColor.x, 
  m_ambientLight.m_lightColor.y, 
  m_ambientLight.m_lightColor.z); 
glUniform1i(glGetUniformLocation(LightPassShaderHandle, 
  "LightCount"), LightCount); 
glUniform1i(glGetUniformLocation(LightPassShaderHandle, 
  "PassNumber"), pass); 
</span></pre><p><span class="koboSpan" id="kobo.162.1">After the light pass shader has been bound, we must also bind all of the 2D textures of necessary material maps. </span><span class="koboSpan" id="kobo.162.2">This is followed by submission of the ambient light uniform, along with the light count, and current pass uniforms.</span></p><p><span class="koboSpan" id="kobo.163.1">All of this is great, but we still haven't addressed the main concept that caused a necessity for this massive redesign to begin with the cubemap textures:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.164.1">... </span><span class="koboSpan" id="kobo.164.2">// Inside the pass loop. 
</span><span class="koboSpan" id="kobo.164.3">auto BaseCubeMapUnit = static_cast&lt;int&gt;(MaterialMapType::COUNT)+1; 
for (int lightID = 0; lightID &lt; LightCount; ++lightID) { 
  auto&amp; light = first + lightID; // Verified by previous loop. 
  </span><span class="koboSpan" id="kobo.164.4">SubmitLightUniforms(LightPassShaderHandle, lightID, *light); 
  // Bind the CUBE texture of the light. 
  </span><span class="koboSpan" id="kobo.164.5">m_cubeTextures[lightID]-&gt;SamplingBind(BaseCubeMapUnit +lightID); 
  auto ShadowMapName = "ShadowMap["+std::to_string(lightID)+"]"; 
  glUniform1i(glGetUniformLocation(LightPassShaderHandle, 
    ShadowMapName.c_str()), BaseCubeMapUnit + lightID); 
} 
</span></pre><p><span class="koboSpan" id="kobo.165.1">The texture unit for binding the very first cubemap texture is defined by simply adding </span><span class="emphasis"><em><span class="koboSpan" id="kobo.166.1">1</span></em></span><span class="koboSpan" id="kobo.167.1"> to the count of material map types. </span><span class="koboSpan" id="kobo.167.2">We have four types at this moment, and with unit </span><span class="emphasis"><em><span class="koboSpan" id="kobo.168.1">0</span></em></span><span class="koboSpan" id="kobo.169.1"> dedicated to the </span><code class="literal"><span class="koboSpan" id="kobo.170.1">LastPass</span></code><span class="koboSpan" id="kobo.171.1"> texture, it means units 1-4 will be used for material map textures. </span><span class="koboSpan" id="kobo.171.2">This leaves units 5 and up free for other samplers.</span></p><p><span class="koboSpan" id="kobo.172.1">Another </span><code class="literal"><span class="koboSpan" id="kobo.173.1">for</span></code><span class="koboSpan" id="kobo.174.1"> loop is entered, this time using the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">LightCount</span></code><span class="koboSpan" id="kobo.176.1"> variable for maximum value. </span><span class="koboSpan" id="kobo.176.2">We've already determined how many lights we're dealing with during the shadow pass, so we don't need to make that check again here.</span></p><p><span class="koboSpan" id="kobo.177.1">A reference to a light is fetched and passed into the </span><code class="literal"><span class="koboSpan" id="kobo.178.1">SubmitLightUniforms()</span></code><span class="koboSpan" id="kobo.179.1"> method, along with the light pass shader handle and the light number currently being used. </span><span class="koboSpan" id="kobo.179.2">The cubemap texture for that specific light is then bound for sampling. </span><span class="koboSpan" id="kobo.179.3">Note the use of </span><code class="literal"><span class="koboSpan" id="kobo.180.1">BaseCubeMapUnit + lightID</span></code><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">This ensures that each light gets its own texture unit.</span></p><p><span class="koboSpan" id="kobo.182.1">Inside the light pass shader, the shadow map samplers are going to be stored inside an array. </span><span class="koboSpan" id="kobo.182.2">Because of this, a string name for each element of the array is constructed based on the current light ID we're working with, and the uniform for the texture unit is sent to the shader.</span></p><p><span class="koboSpan" id="kobo.183.1">Finally, because all of the uniforms and textures are properly bound and updated, we can actually invoke the light-pass shader by rendering </span><code class="literal"><span class="koboSpan" id="kobo.184.1">m_fullScreenQuad</span></code><span class="koboSpan" id="kobo.185.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.186.1">... </span><span class="koboSpan" id="kobo.186.2">// Inside the pass loop. 
</span><span class="koboSpan" id="kobo.186.3">m_rendererFBO.RenderingBind(renderer-&gt;GetCurrentTexture()-&gt; 
  getTexture().getNativeHandle()); 
m_fullScreenQuad.Bind(); 
m_fullScreenQuad.Render(); // This is where the magic happens! 
</span><span class="koboSpan" id="kobo.186.4">m_fullScreenQuad.Unbind(); 
m_rendererFBO.RenderingUnbind(); 
Unbind2DTextures(); 
</span></pre><p><span class="koboSpan" id="kobo.187.1">First, the FBO is bound to the handle of the current texture being used as a buffer. </span><span class="koboSpan" id="kobo.187.2">The quad itself is then bound, rendered, and unbound again. </span><span class="koboSpan" id="kobo.187.3">This is all we need to redraw the entire finished buffer texture to the current buffer texture, so the FBO is unbound. </span><span class="koboSpan" id="kobo.187.4">The 2D textures are also unbound at this point, since the light pass shader has just commenced executing.</span></p><p><span class="koboSpan" id="kobo.188.1">Speaking of unbinding, all of these cubemap textures need to be unbound as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.189.1">... </span><span class="koboSpan" id="kobo.189.2">// Inside the pass loop. 
</span><span class="koboSpan" id="kobo.189.3">for (int lightID = 0; lightID &lt; LightCount; ++lightID) { 
  m_cubeTextures[lightID]-&gt;SamplingUnbind( 
    BaseCubeMapUnit + lightID); 
} 
</span></pre><p><span class="koboSpan" id="kobo.190.1">At this point, the very last thing left to do inside the lighting pass loop is to swap the buffer textures inside the </span><code class="literal"><span class="koboSpan" id="kobo.191.1">Renderer</span></code><span class="koboSpan" id="kobo.192.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.193.1">... </span><span class="koboSpan" id="kobo.193.2">// Inside the pass loop. 
</span><span class="koboSpan" id="kobo.193.3">renderer-&gt;SwapTextures(); 
</span></pre><p><span class="koboSpan" id="kobo.194.1">This makes sure the most recent buffer is always stored as the finished texture.</span></p><p><span class="koboSpan" id="kobo.195.1">Finally, once the light passes have, commenced, we must clean up the state of everything and actually render the finished buffer texture:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.196.1">... </span><span class="koboSpan" id="kobo.196.2">// Right after the pass loop, inside RenderScene(). 
</span><span class="koboSpan" id="kobo.196.3">glUseProgram(CurrentShaderHandle); 
window-&gt;resetGLStates(); 
auto currentView = window-&gt;getView(); 
window-&gt;setView(window-&gt;getDefaultView()); 
renderer-&gt;DrawBufferTexture(); 
window-&gt;setView(currentView); 
</span></pre><p><span class="koboSpan" id="kobo.197.1">The shader program is first reset to whatever it was before the light pass was executed. </span><span class="koboSpan" id="kobo.197.2">The SFML window itself has its OpenGL states reset, because our use of OpenGL functions most likely altered them. </span><span class="koboSpan" id="kobo.197.3">Afterwards, we obtain the current window view, reset the window to its default view, draw the buffer texture, and swap the previous view back, just as in </span><a class="link" href="ch08.html" title="Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting"><span class="koboSpan" id="kobo.198.1">Chapter 8
</span></a><span class="koboSpan" id="kobo.199.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.200.1">Let There Be Light! </span><span class="koboSpan" id="kobo.200.2">- An Introduction to Advanced Lighting</span></em></span><span class="koboSpan" id="kobo.201.1">.</span></p></div><div class="section" title="Submitting light uniforms to the shader"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec6"/><span class="koboSpan" id="kobo.202.1">Submitting light uniforms to the shader</span></h4></div></div></div><p><span class="koboSpan" id="kobo.203.1">One more little piece of code we still haven't covered is the actual light uniform submission to the light pass shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.204.1">void LightManager::SubmitLightUniforms(GLuint l_program, 
  unsigned int l_lightID, const LightBase&amp; l_light) 
{ 
  auto window = m_window-&gt;GetRenderWindow(); 
  auto id = "Lights[" + std::to_string(l_lightID) + "]."; 
 
  sf::Vector2i screenPos = window-&gt;mapCoordsToPixel( 
    { l_light.m_lightPos.x, l_light.m_lightPos.y }, 
    window-&gt;getView()); 
  float y = static_cast&lt;float&gt;( 
    static_cast&lt;int&gt;(window-&gt;getSize().y) - screenPos.y); 
 
  glUniform3f(glGetUniformLocation(l_program, 
      (id + "position").c_str()), 
    screenPos.x, y, l_light.m_lightPos.z); 
  glUniform3f(glGetUniformLocation(l_program, 
      (id + "color").c_str()), 
    l_light.m_lightColor.x, 
    l_light.m_lightColor.y, 
    l_light.m_lightColor.z); 
  glUniform1f(glGetUniformLocation(l_program, 
    (id + "radius").c_str()), l_light.m_radius); 
  glUniform1f(glGetUniformLocation(l_program, 
    (id + "falloff").c_str()), l_light.m_falloff); 
  glUniform1f(glGetUniformLocation(l_program, 
      (id + "specularExponent").c_str()), 
    l_light.m_specularExponent); 
  glUniform1f(glGetUniformLocation(l_program, 
      (id + "specularStrength").c_str()), 
    l_light.m_specularStrength); 
} 
</span></pre><p><span class="koboSpan" id="kobo.205.1">This chunk of code is pretty much exactly the same as in </span><a class="link" href="ch08.html" title="Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting"><span class="koboSpan" id="kobo.206.1">Chapter 8
</span></a><span class="koboSpan" id="kobo.207.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.208.1">Let There Be Light! </span><span class="koboSpan" id="kobo.208.2">- An Introduction to Advanced Lighting</span></em></span>
<span class="emphasis"><em><span class="koboSpan" id="kobo.209.1">,</span></em></span><span class="koboSpan" id="kobo.210.1"> except it uses raw OpenGL functions to submit the uniforms.</span></p></div><div class="section" title="The new and improved light pass shaders"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec7"/><span class="koboSpan" id="kobo.211.1">The new and improved light pass shaders</span></h4></div></div></div><p><span class="koboSpan" id="kobo.212.1">Since the light pass had to be completely rewritten to use raw modern OpenGL, the shaders need to reflect those changes too. </span><span class="koboSpan" id="kobo.212.2">To begin with, the vertex shader is much simpler now, because it no longer uses outdated and deprecated ways of obtaining and transforming vertex information, texture coordinates, and so on:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.213.1">in vec3 position; 
in vec2 texCoordIn; 
out vec2 texCoords; 
void main() 
{ 
  texCoords = texCoordIn; 
  gl_Position = vec4(position, 1.0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.214.1">The position being passed to this shader is that of </span><code class="literal"><span class="koboSpan" id="kobo.215.1">m_fullScreenQuad</span></code><span class="koboSpan" id="kobo.216.1">, so it's already in clip space. </span><span class="koboSpan" id="kobo.216.2">There's no reason to transform it. </span><span class="koboSpan" id="kobo.216.3">The texture coordinates are simply passed along to the fragment shader, where they get interpolated between vertices, ensuring sampling of every pixel:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.217.1">const int MaxLights = 4; 
const float LightHeightOffset = 16.0; 
in vec2 texCoords; 
uniform sampler2D LastPass; 
uniform sampler2D DiffuseMap; 
uniform sampler2D NormalMap; 
uniform sampler2D SpecularMap; 
uniform sampler2D HeightMap; 
uniform samplerCube ShadowMap[MaxLights]; 
uniform vec3 AmbientLight; 
uniform int LightCount; 
uniform int PassNumber; 
</span></pre><p><span class="koboSpan" id="kobo.218.1">The fragment shader of the light pass has a couple of new values at the very top. </span><span class="koboSpan" id="kobo.218.2">We have a constant that's going to be used to offset the light's height, which we're going to cover very shortly. </span><span class="koboSpan" id="kobo.218.3">There's also the input value from the vertex shader of the texture coordinates we're going to need to sample. </span><span class="koboSpan" id="kobo.218.4">Lastly, we're using an array of </span><code class="literal"><span class="koboSpan" id="kobo.219.1">samplerCube</span></code><span class="koboSpan" id="kobo.220.1"> uniforms to access the shadow map information.</span></p><p><span class="koboSpan" id="kobo.221.1">Let's take a look at the main body of the light pass fragment shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.222.1">void main() 
{ 
  vec4 pixel = texture2D(LastPass, texCoords); 
  vec4 diffusepixel = texture2D(DiffuseMap, texCoords); 
  vec4 normalpixel = texture2D(NormalMap, texCoords); 
  vec4 specularpixel = texture2D(SpecularMap, texCoords); 
  float pixelheight = texture2D(HeightMap, texCoords).r * 255.0; 
  vec3 PixelCoordinates = 
    vec3(gl_FragCoord.x, gl_FragCoord.y, pixelheight); 
  vec4 finalPixel = pixel; 
  ... 
  </span><span class="koboSpan" id="kobo.222.2">if(PassNumber == 0) { finalPixel *= vec4(AmbientLight, 1.0); } 
  for(int i = 0; i &lt; LightCount; ++i){ 
    ... 
    </span><span class="koboSpan" id="kobo.222.3">float ShadowValue = CalculateShadow( 
      PixelCoordinates, Lights[i].position, i); 
    finalPixel += (diffusepixel * 
                  (vec4(Lights[i].color, 1.0) * attenuation) + 
                  vec4(specularReflection, 1.0)) 
      * normalDot * ShadowValue; 
  } 
  gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.223.1">Things have changed, yet oddly enough stayed the same. </span><span class="koboSpan" id="kobo.223.2">We're sampling all of the values from different textures just like before, only now we're using the </span><code class="literal"><span class="koboSpan" id="kobo.224.1">texCoords</span></code><span class="koboSpan" id="kobo.225.1"> variable passed down from the vertex shader.</span></p><p><span class="koboSpan" id="kobo.226.1">Another small change is the pass number that gets checked for ambient lighting. </span><span class="koboSpan" id="kobo.226.2">It used to be </span><span class="emphasis"><em><span class="koboSpan" id="kobo.227.1">1</span></em></span><span class="koboSpan" id="kobo.228.1"> for clarity in the previous chapter. </span><span class="koboSpan" id="kobo.228.2">It's now changed to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.229.1">0</span></em></span><span class="koboSpan" id="kobo.230.1">.</span></p><p><span class="koboSpan" id="kobo.231.1">Finally, the very reason we're here today the shadow calculations. </span><span class="koboSpan" id="kobo.231.2">A floating point value is obtained from the </span><code class="literal"><span class="koboSpan" id="kobo.232.1">CalculateShadow</span></code><span class="koboSpan" id="kobo.233.1"> function, that takes in coordinates of the current fragment, the position of the current light, and the number identifier of the current light as well. </span><span class="koboSpan" id="kobo.233.2">This value is later used when calculating the final pixel color. </span><span class="koboSpan" id="kobo.233.3">The pixel is simply multiplied by </span><code class="literal"><span class="koboSpan" id="kobo.234.1">ShadowValue</span></code><span class="koboSpan" id="kobo.235.1"> at the end, which determines how much in the shadow it is.</span></p><p><span class="koboSpan" id="kobo.236.1">This function is for calculating the shadow value of a fragment that is implemented at the top of the shader as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.237.1">float CalculateShadow(vec3 fragment, vec3 light, int lightID) { 
  light.z += LightHeightOffset; 
  vec3 difference = fragment - light; 
  float currentDepth = length(difference); 
  difference.y *= -1.0; 
  float nearestDepth = texture(ShadowMap[lightID], 
    difference.xzy).r; 
  return (currentDepth &gt; nearestDepth * Lights[lightID].radius 
    ? </span><span class="koboSpan" id="kobo.237.2">nearestDepth : 1.0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.238.1">Looks simple enough, right? </span><span class="koboSpan" id="kobo.238.2">Well, it is. </span><span class="koboSpan" id="kobo.238.3">First, the light's height is offset by the height offset constant we defined at the top of the shader. </span><span class="koboSpan" id="kobo.238.4">This is just a detail of further tweaking that ensures lighting looks as good as it can, and could be completely changed. </span><span class="koboSpan" id="kobo.238.5">The current value simply looks better than the default 0.</span></p><p><span class="koboSpan" id="kobo.239.1">The difference between the fragment's position and the light's position is then calculated by subtracting one from the other. </span><span class="koboSpan" id="kobo.239.2">The order matters here because this is going to be used as a directional vector to determine which face of the cubemap texture should be sampled.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/><span class="koboSpan" id="kobo.240.1">Note</span></h3><p><span class="koboSpan" id="kobo.241.1">Keep in mind that our fragment and light positions use the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.242.1">Z</span></em></span><span class="koboSpan" id="kobo.243.1"> component as the height. </span><span class="koboSpan" id="kobo.243.2">This effectively makes </span><span class="emphasis"><em><span class="koboSpan" id="kobo.244.1">Y</span></em></span><span class="koboSpan" id="kobo.245.1"> the depth axis, which can be visualized as the direction to and from the screen, as opposed to left/right for </span><span class="emphasis"><em><span class="koboSpan" id="kobo.246.1">X</span></em></span><span class="koboSpan" id="kobo.247.1">, and up/down for </span><span class="emphasis"><em><span class="koboSpan" id="kobo.248.1">Z</span></em></span><span class="koboSpan" id="kobo.249.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.250.1">The </span><code class="literal"><span class="koboSpan" id="kobo.251.1">currentDepth</span></code><span class="koboSpan" id="kobo.252.1"> variable is the distance from the light to the fragment being sampled. </span><span class="koboSpan" id="kobo.252.2">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.253.1">Y</span></em></span><span class="koboSpan" id="kobo.254.1"> component of the difference vector is then inverted, because in the right-hand coordinate system OpenGL uses, pointing towards the screen means going into the negatives.</span></p><p><span class="koboSpan" id="kobo.255.1">Now it's time to actually sample the shadow map texture and obtain the nearest depth at that particular fragment. </span><span class="koboSpan" id="kobo.255.2">This is done by passing the difference vector as a directional vector. </span><span class="koboSpan" id="kobo.255.3">Don't worry about it not being normalized, because it doesn't have to be. </span><span class="koboSpan" id="kobo.255.4">Also note the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.256.1">Z</span></em></span><span class="koboSpan" id="kobo.257.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.258.1">Y</span></em></span><span class="koboSpan" id="kobo.259.1"> components swapped. </span><span class="koboSpan" id="kobo.259.2">Again, we use </span><span class="emphasis"><em><span class="koboSpan" id="kobo.260.1">Z</span></em></span><span class="koboSpan" id="kobo.261.1"> for height, while OpenGL uses </span><span class="emphasis"><em><span class="koboSpan" id="kobo.262.1">Y</span></em></span><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">Finally, we check whether the depth between the fragment and the light is greater than the depth sampled from the current shadow map, and if it is, it means the fragment is in the shadow. </span><span class="koboSpan" id="kobo.263.3">0 could be returned, but in order to create shadows that slowly fade out with distance, </span><code class="literal"><span class="koboSpan" id="kobo.264.1">nearestDepth</span></code><span class="koboSpan" id="kobo.265.1"> is returned instead. </span><span class="koboSpan" id="kobo.265.2">This is the value that the final pixel gets multiplied by, and because it's in the range </span><span class="emphasis"><em><span class="koboSpan" id="kobo.266.1">[0;1]</span></em></span><span class="koboSpan" id="kobo.267.1">, we get the linear fade with distance.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/><span class="koboSpan" id="kobo.268.1">Note</span></h3><p><span class="koboSpan" id="kobo.269.1">Note </span><code class="literal"><span class="koboSpan" id="kobo.270.1">nearestDepth</span></code><span class="koboSpan" id="kobo.271.1"> being multiplied by the light radius, which represents the frustum far value, when it's being checked. </span><span class="koboSpan" id="kobo.271.2">This transforms it from the range </span><span class="emphasis"><em><span class="koboSpan" id="kobo.272.1">[0;1]</span></em></span><span class="koboSpan" id="kobo.273.1">, to the actual distance at which the shadow primitive is away from the light.</span></p></div></div><p><span class="koboSpan" id="kobo.274.1">Consider the following diagram to help get the point across:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.275.1"><img src="graphics/image_09_010.jpg" alt="The new and improved light pass shaders"/></span></div><p><span class="koboSpan" id="kobo.276.1">Here, the main arrow from the sample point to the light is </span><code class="literal"><span class="koboSpan" id="kobo.277.1">currentDepth</span></code><span class="koboSpan" id="kobo.278.1">, and the </span><code class="literal"><span class="koboSpan" id="kobo.279.1">nearestDepth</span></code><span class="koboSpan" id="kobo.280.1"> after being multiplied by the light's radius is the arrow from the black box in the middle to the light.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Adding shadow casters to entities"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/><span class="koboSpan" id="kobo.1.1">Adding shadow casters to entities</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Now that we have all of the rendering resolved, we still need to make sure entities can cast shadows. </span><span class="koboSpan" id="kobo.2.2">This will be achieved by actually attaching special components to entities that will hold pointers to 3D geometry used during shadow pass. </span><span class="koboSpan" id="kobo.2.3">This geometry will obviously need to be updated to match the position of the entities it represents, which is why the component data is going to be accompanied by a separate system, used to actually keep everything synced up.</span></p><div class="section" title="Adding the shadow caster component"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec105"/><span class="koboSpan" id="kobo.3.1">Adding the shadow caster component</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">First, because our entities exist within the ECS paradigm, we need to add a component that represents the shadow volume of an entity:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class C_ShadowCaster : public C_Base { 
public: 
  C_ShadowCaster() : C_Base(Component::ShadowCaster), 
    m_shadowCaster(nullptr) {} 
 
  void SetShadowCaster(ShadowCaster* l_caster) { 
    m_shadowCaster = l_caster; 
  } 
  void UpdateCaster(const glm::vec3&amp; l_pos) { 
    m_shadowCaster-&gt;m_transform.SetPosition(l_pos); 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    m_shadowPrimitive = std::make_unique&lt;ShadowCasterPrototype&gt;(); 
    for (auto i = 0; i &lt; ShadowMeshVertices; ++i) { 
      l_stream &gt;&gt; m_shadowPrimitive-&gt;m_vertices[i].x &gt;&gt; 
      m_shadowPrimitive-&gt;m_vertices[i].y &gt;&gt; 
      m_shadowPrimitive-&gt;m_vertices[i].z; 
    } 
  } 
 
  std::unique_ptr&lt;ShadowCasterPrototype&gt; m_shadowPrimitive; 
private: 
  ShadowCaster* m_shadowCaster; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">This component will be used to load entity shadow caster primitives from the entity file, as well as update their respective </span><code class="literal"><span class="koboSpan" id="kobo.7.1">ShadowCaster</span></code><span class="koboSpan" id="kobo.8.1"> instances. </span><span class="koboSpan" id="kobo.8.2">The player entity file, for example, would look like this with the new component added:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">Name Player 
Attributes 511 
|Component|ID|Individual attributes| 
... 
</span><span class="koboSpan" id="kobo.9.2">Component 8 -0.5 0.0 0.5 -0.5 0.0 -0.5 0.5 0.0 -0.5 ... 
</span></pre></div><div class="section" title="Creating the shadow system"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec106"/><span class="koboSpan" id="kobo.10.1">Creating the shadow system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.11.1">Updating these components should be done in a separate, designated system for this very purpose. </span><span class="koboSpan" id="kobo.11.2">Because we've done this so many times before, let's just take a look at the relevant parts of the code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">S_Shadow::S_Shadow(SystemManager* l_systemMgr) 
  : S_Base(System::Shadow, l_systemMgr), 
  m_lightManager(nullptr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::ShadowCaster); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">The constructor of this system simply sets up the entity requirements to belong here. </span><span class="koboSpan" id="kobo.13.2">It requires the position and shadow caster components, obviously.</span></p><p><span class="koboSpan" id="kobo.14.1">Updating these components is equally as easy:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">void S_Shadow::Update(float l_dT) { 
  if (!m_lightManager) { return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for (auto &amp;entity : m_entities) { 
    auto position = entities-&gt;GetComponent&lt;C_Position&gt;( 
      entity, Component::Position); 
    auto caster = entities-&gt;GetComponent&lt;C_ShadowCaster&gt;( 
      entity, Component::ShadowCaster); 
    float height = static_cast&lt;float&gt;( 
      (position-&gt;GetElevation() * Sheet::Tile_Size) - 
        Sheet::Tile_Size); 
    caster-&gt;UpdateCaster({ 
      position-&gt;GetPosition().x, 
      height, 
      position-&gt;GetPosition().y - 8.f }); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.16.1">For each entity that belongs to this system, the position and shadow caster components are obtained. </span><span class="koboSpan" id="kobo.16.2">The shadow caster's </span><code class="literal"><span class="koboSpan" id="kobo.17.1">UpdateCaster</span></code><span class="koboSpan" id="kobo.18.1"> method is then invoked, with the 2D position and height being passed in. </span><span class="koboSpan" id="kobo.18.2">The constant value of </span><code class="literal"><span class="koboSpan" id="kobo.19.1">8.f</span></code><span class="koboSpan" id="kobo.20.1"> is simply used to offset the shadow primitive in order to center it properly.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/><span class="koboSpan" id="kobo.21.1">Note</span></h3><p><span class="koboSpan" id="kobo.22.1">Note that the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.23.1">Y</span></em></span><span class="koboSpan" id="kobo.24.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.25.1">Z</span></em></span><span class="koboSpan" id="kobo.26.1"> values are, once again, swapped around.</span></p></div></div><p><span class="koboSpan" id="kobo.27.1">Finally, because we want to properly emplace and manage unique shadow caster prototypes in the light manager, the shadow system must implement a method that will be called when the entity has finished loading and is about to be added, in order to set everything up properly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">void S_Shadow::OnEntityAdd(const EntityId&amp; l_entity) { 
  auto component = m_systemManager-&gt;GetEntityManager()-&gt; 
   GetComponent&lt;C_ShadowCaster&gt;(l_entity,Component::ShadowCaster); 
  if (!component) { return; } 
  std::string entityType; 
  if (!m_systemManager-&gt;GetEntityManager()-&gt; 
    GetEntityType(l_entity, entityType)) 
  { 
    ... </span><span class="koboSpan" id="kobo.28.2">// Error 
    return; 
  } 
 
  auto name = m_lightManager-&gt;AddCasterPrototype("Entity_" + 
    entityType, std::move(component-&gt;m_shadowPrimitive)); 
  auto caster = m_lightManager-&gt;AddShadowCaster(name); 
  if (!caster) { return; } // Error 
  component-&gt;SetShadowCaster(caster); 
  caster-&gt;m_transform.SetScale({ 16.f, 16.f, 16.f }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">Once the shadow caster component is retrieved, the entity type name is obtained from the entity manager. </span><span class="koboSpan" id="kobo.29.2">This is simply the name of the entity prototype, such as player, skeleton, and so on. </span><span class="koboSpan" id="kobo.29.3">The primitive prototype with the appropriate name is then attempted to be added, and should there be an exact same shadow caster prototype already in </span><code class="literal"><span class="koboSpan" id="kobo.30.1">LightManager</span></code><span class="koboSpan" id="kobo.31.1">, that name is returned instead. </span><span class="koboSpan" id="kobo.31.2">The shadow caster itself is then created, passed on to the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">C_ShadowCaster</span></code><span class="koboSpan" id="kobo.33.1"> component, and scaled to a decent size. </span><span class="koboSpan" id="kobo.33.2">For the time being, this is a constant value, but it can obviously be made to change depending on the entity type, if it's stored inside the entity file along with the rest of the component data.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Integrating the changes made"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/><span class="koboSpan" id="kobo.1.1">Integrating the changes made</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Finally, all we have left to do in order to make this work is add the newly created component and system types to the ECS:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">void Game::SetUpECS() { 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">m_entityManager-&gt;AddComponentType&lt;C_ShadowCaster&gt; 
    (Component::ShadowCaster); 
  ... 
  </span><span class="koboSpan" id="kobo.3.3">m_systemManager-&gt;AddSystem&lt;S_Shadow&gt;(System::Shadow); 
  ... 
  </span><span class="koboSpan" id="kobo.3.4">m_systemManager-&gt;GetSystem&lt;S_Shadow&gt;(System::Shadow)-&gt; 
    SetLightManager(m_lightManager.get()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.4.1">The shadow system itself also needs a pointer to the light manager for obvious reasons. </span><span class="koboSpan" id="kobo.4.2">Running the game now, with all of the lights properly set up and shadow casters correctly loaded, we should have three-dimensional shadows!</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.5.1"><img src="graphics/image_09_012.jpg" alt="Integrating the changes made"/></span></div><p><span class="koboSpan" id="kobo.6.1">Because the entities can hop elevations, the lights can be made to change their heights, and the actual light pass of the scene incorporates different heights of tile layers. </span><span class="koboSpan" id="kobo.6.2">Moving the lights around actually creates results in three-dimensional space, allowing the shadows to flow across walls, if at a right angle. </span><span class="koboSpan" id="kobo.6.3">After all of that hard work, the effect is absolutely astonishing!</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Potential issues and how to address them"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec87"/><span class="koboSpan" id="kobo.1.1">Potential issues and how to address them</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Although we aren't facing any of these issues at this very point, most 3D games will have to deal with them as soon as basic shadows are established using this method.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">Shadow acne</span></strong></span><span class="koboSpan" id="kobo.4.1"> is a graphical artefact that can be summarized as horrible </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">tearing</span></em></span><span class="koboSpan" id="kobo.6.1">, where lit areas are horribly defaced with dark and white lines closely nested together. </span><span class="koboSpan" id="kobo.6.2">This happens because shadow maps are of finite size and pixels that are right next to each other will end up spanning a small distance on actual, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">real</span></em></span><span class="koboSpan" id="kobo.8.1"> geometry being shaded. </span><span class="koboSpan" id="kobo.8.2">It can be fixed by simply adding or subtracting a simple </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">bias</span></em></span><span class="koboSpan" id="kobo.10.1"> floating point value to or from the shadow map's depth sample inside the light pass shader. </span><span class="koboSpan" id="kobo.10.2">This floating point value would, ideally, not be a constant and instead depend on the slope between the point on the geometry and the light.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">Peter panning</span></strong></span><span class="koboSpan" id="kobo.12.1"> can be described as shadows that appear to be </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">floating</span></em></span><span class="koboSpan" id="kobo.14.1"> away from the geometry that casts them. </span><span class="koboSpan" id="kobo.14.2">Adding the floating point bias to fix shadow acne will usually make this problem worse, especially when dealing with incredibly thin geometry. </span><span class="koboSpan" id="kobo.14.3">A common and easy fix for this problem is simply avoiding thin geometry and using front face culling during the shadow pass, as we did.</span></p><div class="section" title="Percentage closer filtering"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec107"/><span class="koboSpan" id="kobo.15.1">Percentage closer filtering</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">You may have noticed that the shadows produced by our geometry are rather hard and don't exactly smooth out around the edges. </span><span class="koboSpan" id="kobo.16.2">As always, there is a solution that will resolve this, and it involves sampling the shadow map a couple more times per pixel.</span></p><p><span class="koboSpan" id="kobo.17.1">By sampling not only the calculated pixel of the shadow map, but also the surrounding ones, we can easily take an average value of all of them and use it to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">smooth</span></em></span><span class="koboSpan" id="kobo.19.1"> out the edge. </span><span class="koboSpan" id="kobo.19.2">If, for example, our sampled pixel is in the shadow but </span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">50%</span></em></span><span class="koboSpan" id="kobo.21.1"> of all other sampled pixels around it are lit up, the center pixel itself should only be </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">50%</span></em></span><span class="koboSpan" id="kobo.23.1"> opaque. </span><span class="koboSpan" id="kobo.23.2">By eliminating this binary rule of a pixel either being completely lit or completely dark, we can successfully implement soft shadows using this technique. </span><span class="koboSpan" id="kobo.23.3">Higher numbers of surrounding pixels will obviously yield smoother results, but will also bog down performance.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec88"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Congratulations on making it to the end of this chapter! </span><span class="koboSpan" id="kobo.2.2">Although it took quite a while to re-architect our lighting engine, the results cannot be dismissed as miniscule. </span><span class="koboSpan" id="kobo.2.3">The shadows created by this method add a lot of graphical diversity to our world. </span><span class="koboSpan" id="kobo.2.4">In the next chapter, we're going to be discussing optimizations that can be applied to make the game run as fast as it possibly can after all of the fancy, clock cycle sucking techniques used throughout this book. </span><span class="koboSpan" id="kobo.2.5">See you there!</span></p></div></div></div></body></html>