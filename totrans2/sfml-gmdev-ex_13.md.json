["```cpp\n#include <SFML/Network.hpp>\n```", "```cpp\nsf::TcpSocket socket;\nsf::Socket::Status status = \n  socket.connect(\"192.168.1.2\", 5600, sf::seconds(5.f));\nif (status != sf::Socket::Done){\n    // Connection failed.\n}\n```", "```cpp\nsf::TcpListener listener;\nif (listener.listen(5600) != sf::Socket::Done)\n{\n    // Unable to bind to port.\n}\n\nsf::TcpSocket incoming;\nif (listener.accept(incoming) != sf::Socket::Done)\n{\n    // Failed accepting an incoming connection.\n}\n```", "```cpp\nchar data[100];\n// ...\nif (socket.send(data, 100) != sf::Socket::Done){\n    // Sending data failed.\n}\n```", "```cpp\nchar data[100];\nstd::size_t received;\n\nif (socket.receive(data, 100, received) != sf::Socket::Done)\n{\n    // Failed receiving data.\n}\n```", "```cpp\nsf::TcpSocket socket;\n// ...\nsf::SocketSelector selector;\nselector.add(socket);\n```", "```cpp\nsf::SocketSelector selector;\nstd::vector<sf::TcpSocket> container;\n// ...\nsf::TcpSocket socket;\nselector.add(socket);\ncontainer.push_back(socket);\nif (selector.wait(sf::seconds(10))){\n  for (auto &itr : container){\n    if (selector.isReady(itr)){\n      // Socket received data.\n      char data[100];\n      std::size_t received;\n      sf::Socket::Status status= itr.receive(data, 100, received);\n      if (status != sf::Socket::Done){\n        // Failed receiving data...\n      }\n    }\n  }\n} else {\n  // Timed out...\n}\n```", "```cpp\nsf::UdpSocket socket;\n\n// Bind to port 5600\nif (socket.bind(5600) != sf::Socket::Done)\n{\n    // Binding failed.\n}\n```", "```cpp\nsf::UdpSocket socket;\n// ...\nunsigned int port = socket.getLocalPort();\n```", "```cpp\nsf::UdpSocket socket;\n// ...\nchar data[100];\nif (socket.send(data, 100, \"192.168.1.2\", 5600)\n  != sf::Socket::Done)\n{\n    // Sending failed.\n}\n// ...\nsf::IpAddress ipAddr;\nunsigned short port;\nstd::size_t received;\nif (socket.receive(data, 100, received, ipAddr, port) \n  != sf::Socket::Done)\n{\n    // Receiving failed.\n}\n```", "```cpp\nsf::Int16 n = 16;\nfloat f = 32.f;\nstd::string str = \"Aloha\";\n\nsf::Packet packet;\npacket << n << f << str;\n// ...\npacket >> n >> f >> str;\n```", "```cpp\nif(!(packet >> n)){\n    // Failed extraction.\n}\n```", "```cpp\nsf::Packet packet;\n// TCP\ntcpSocket.send(packet);\ntcpSocket.receive(packet);\n// UDP\nudpSocket.send(packet, \"192.168.1.2\", 5600);\nsf::IpAddress senderIP;\nunsigned short senderPort;\nudpSocket.receive(packet, senderIP, senderPort);\n```", "```cpp\nstruct SomeStructure{\n    sf::Int32 m_int;\n    std::string m_str;\n};\n\nsf::Packet& operator <<(sf::Packet& l_packet, \n  const SomeStructure& l_struct)\n{\n    return l_packet << l_struct.m_int << l_struct.m_str;\n}\n\nsf::Packet& operator >>(sf::Packet& l_packet, \n  SomeStructure& l_struct)\n{\n    return l_packet >> l_struct.m_int >> l_struct.m_str;\n}\n```", "```cpp\nSomeStructure s;\nsf::Packet packet;\n\npacket << s;\npacket >> s;\n```", "```cpp\nsf::TcpSocket tcp;\ntcp.setBlocking(false);\n\nsf::TcpListener tcpListener;\ntcpListener.setBlocking(false);\n\nsf::UdpSocket udp;\nudp.setBlocking(false);\n```", "```cpp\nsend(const void* data, std::size_t size, std::size_t& sent)\n```", "```cpp\nvoid Test(){\n    for (int i = 0; i < 10; ++i){\n        std::cout << i << std::endl;\n    }\n}\n```", "```cpp\nsf::Thread thread1(Test);\n```", "```cpp\nthread1.launch();\n```", "```cpp\nthread1.wait();\n```", "```cpp\nsf::Mutex mutex;\n\nvoid Test(){\n    mutex.lock();\n    for (int i = 0; i < 10; ++i){\n        std::cout << i << std::endl;\n    }\n    mutex.unlock();\n}\n\nint main(){\n    sf::Thread thread1(Test);\n    thread1.launch();\n\n    mutex.lock();\n    // Do something data-sensitive here.\n    mutex.unlock();\n    return 0;\n}\n```", "```cpp\nsf::Mutex mutex;\n\nvoid Test(){\n    sf::Lock lock(mutex);\n    for (int i = 0; i < 10; ++i){\n        std::cout << i << std::endl;\n        if (i == 5){ return; } // mutex.unlock() called.\n    }\n} // mutex.unlock() called.\n```", "```cpp\nusing PacketID = sf::Int8;\nenum class PacketType{\n  Disconnect = -1, Connect, Heartbeat, Snapshot,\n  Player_Update, Message, Hurt, OutOfBounds\n};\nvoid StampPacket(const PacketType& l_type, sf::Packet& l_packet);\n```", "```cpp\nvoid StampPacket(const PacketType& l_type, sf::Packet& l_packet){\n    l_packet << PacketID(l_type);\n}\n```", "```cpp\nenum class Network{\n  HighestTimestamp = 2147483647, ClientTimeout = 10000,\n  ServerPort = 5600, NullID = -1\n};\nusing ClientID = int;\nusing PortNumber = unsigned short;\n```", "```cpp\n#define CONNECT_TIMEOUT 5000 // Milliseconds.\n\nclass Client;\nusing PacketHandler = std::function<\n  void(const PacketID&, sf::Packet&, Client*)>;\n```", "```cpp\nclass Client{\npublic:\n  Client();\n  ~Client();\n  bool Connect();\n  bool Disconnect();\n  void Listen();\n  bool Send(sf::Packet& l_packet);\n  const sf::Time& GetTime() const;\n  const sf::Time& GetLastHeartbeat() const;\n  void SetTime(const sf::Time& l_time);\n  void SetServerInformation(const sf::IpAddress& l_ip,\n    const PortNumber& l_port);\n\n  template<class T>\n  void Setup(void(T::*l_handler)\n    (const PacketID&, sf::Packet&, Client*), T* l_instance)\n  {\n    m_packetHandler = std::bind(l_handler, l_instance,\n      std::placeholders::_1, std::placeholders::_2,\n      std::placeholders::_3);\n  }\n\n  void Setup(void(*l_handler)(const PacketID&,\n    sf::Packet&, Client*));\n  void UnregisterPacketHandler();\n  void Update(const sf::Time& l_time);\n  bool IsConnected() const;\n  void SetPlayerName(const std::string& l_name);\n  sf::Mutex& GetMutex();\nprivate:\n  std::string m_playerName;\n\n  sf::UdpSocket m_socket;\n  sf::IpAddress m_serverIp;\n  PortNumber m_serverPort;\n  PacketHandler m_packetHandler;\n  bool m_connected;\n  sf::Time m_serverTime;\n  sf::Time m_lastHeartbeat;\n\n  sf::Thread m_listenThread;\n  sf::Mutex m_mutex;\n};\n```", "```cpp\nClient::Client():m_listenThread(&Client::Listen, this){}\nClient::~Client(){ m_socket.unbind(); }\n```", "```cpp\nbool Client::Connect(){\n  if (m_connected){ return false; }\n  m_socket.bind(sf::Socket::AnyPort);\n  sf::Packet p;\n  StampPacket(PacketType::Connect, p);\n  p << m_playerName;\n  if (m_socket.send(p, m_serverIp, m_serverPort) !=\n    sf::Socket::Done)\n  {\n    m_socket.unbind();\n    return false;\n  }\n  m_socket.setBlocking(false);\n  p.clear();\n  sf::IpAddress recvIP;\n  PortNumber recvPORT;\n  sf::Clock timer;\n  timer.restart();\n  while (timer.getElapsedTime().asMilliseconds()<CONNECT_TIMEOUT){\n    sf::Socket::Status s = m_socket.receive(p, recvIP, recvPORT);\n    if (s != sf::Socket::Done){ continue; }\n    if (recvIP != m_serverIp){ continue; }\n    PacketID id;\n    if (!(p >> id)){ break; }\n    if ((PacketType)id != PacketType::Connect){ continue; }\n    m_packetHandler(id, p, this);\n    m_connected = true;\n    m_socket.setBlocking(true);\n    m_lastHeartbeat = m_serverTime;\n    m_listenThread.launch();\n    return true;\n  }\n  std::cout << \"Connection attempt failed! Server info: \" \n    << m_serverIp << \":\" << m_serverPort << std::endl;\n  m_socket.unbind();\n  m_socket.setBlocking(true);\n  return false;\n}\n```", "```cpp\nvoid Client::Listen(){\n  sf::Packet packet;\n  sf::IpAddress recvIP;\n  PortNumber recvPORT;\n  while (m_connected){\n    packet.clear();\n    sf::Socket::Status status =\n      m_socket.receive(packet, recvIP, recvPORT);\n    if (status != sf::Socket::Done){\n      if (m_connected){\n        std::cout << \"Failed receiving a packet from \"\n          << recvIP << \":\" << recvPORT << \". Status: \"\n          << status << std::endl;\n        continue;\n      } else {\n        std::cout << \"Socket unbound.\" << std::endl;\n        break;\n      }\n    }\n    if (recvIP != m_serverIp){\n      // Ignore packets not sent from the server.\n      continue;\n    }\n    PacketID p_id;\n    if (!(packet >> p_id)){\n      // Non-conventional packet.\n      continue;\n    }\n    PacketType id = (PacketType)p_id;\n    if (id<PacketType::Disconnect||id >=PacketType::OutOfBounds){\n      // Invalid packet type.\n      continue;\n    }\n\n    if (id == PacketType::Heartbeat){\n      sf::Packet p;\n      StampPacket(PacketType::Heartbeat, p);\n      if (m_socket.send(p, m_serverIp, m_serverPort) !=\n        sf::Socket::Done)\n      {\n        std::cout << \"Failed sending a heartbeat!\" << std::endl;\n      }\n      sf::Int32 timestamp;\n      packet >> timestamp;\n      SetTime(sf::milliseconds(timestamp));\n      m_lastHeartbeat = m_serverTime;\n    } else if(m_packetHandler){\n      m_packetHandler((PacketID)id, packet, this); // Handle.\n    }\n  }\n}\n```", "```cpp\nbool Client::Disconnect(){\n  if (!m_connected){ return false; }\n  sf::Packet p;\n  StampPacket(PacketType::Disconnect, p);\n  sf::Socket::Status s =\n    m_socket.send(p, m_serverIp, m_serverPort);\n  m_connected = false;\n  m_socket.unbind(); // Unbind to close the listening thread.\n  if (s != sf::Socket::Done){ return false; }\n  return true;\n}\n```", "```cpp\nbool Client::Send(sf::Packet& l_packet){\n  if (!m_connected){ return false; }\n  if (m_socket.send(l_packet, m_serverIp, m_serverPort) !=\n    sf::Socket::Done)\n  {\n    return false;\n  }\n  return true;\n}\n```", "```cpp\nvoid Client::Setup(void(*l_handler)\n  (const PacketID&, sf::Packet&, Client*))\n{\n    m_packetHandler = std::bind(l_handler,\n      std::placeholders::_1, std::placeholders::_2, \n      std::placeholders::_3);\n}\n```", "```cpp\nvoid Client::UnregisterPacketHandler(){\n    m_packetHandler = nullptr;\n}\n```", "```cpp\nvoid Client::Update(const sf::Time& l_time){\n  if (!m_connected){ return; }\n  m_serverTime += l_time;\n  if (m_serverTime.asMilliseconds() < 0){\n    m_serverTime -= sf::milliseconds(\n      sf::Int32(Network::HighestTimestamp));\n    m_lastHeartbeat = m_serverTime;\n    return;\n  }\n  if (m_serverTime.asMilliseconds() -\n    m_lastHeartbeat.asMilliseconds() >=\n      sf::Int32(Network::ClientTimeout))\n  {\n    // Timeout.\n    std::cout << \"Server connection timed out!\" << std::endl;\n    Disconnect();\n  }\n}\n```", "```cpp\n#define HEARTBEAT_INTERVAL 1000 // Milliseconds.\n#define HEARTBEAT_RETRIES 5\n```", "```cpp\nstruct ClientInfo{\n   sf::IpAddress m_clientIP;\n   PortNumber m_clientPORT;\n   sf::Time m_lastHeartbeat;\n   sf::Time m_heartbeatSent;\n   bool m_heartbeatWaiting;\n   unsigned short m_heartbeatRetry;\n   unsigned int m_latency;\n\n   ClientInfo(const sf::IpAddress& l_ip, const PortNumber& l_port,\n     const sf::Time& l_heartbeat): m_clientIP(l_ip),\n     m_clientPORT(l_port), m_lastHeartbeat(l_heartbeat), \n     m_heartbeatWaiting(false), m_heartbeatRetry(0), m_latency(0)\n   {}\n\n   ClientInfo& operator=(const ClientInfo& l_rhs){\n      m_clientIP         = l_rhs.m_clientIP;\n      m_clientPORT       = l_rhs.m_clientPORT;\n      m_lastHeartbeat    = l_rhs.m_lastHeartbeat;\n      m_heartbeatSent    = l_rhs.m_heartbeatSent;\n      m_heartbeatWaiting = l_rhs.m_heartbeatWaiting;\n      m_heartbeatRetry   = l_rhs.m_heartbeatRetry;\n      m_latency          = l_rhs.m_latency;\n      return *this;\n   }\n};\n```", "```cpp\nusing Clients = std::unordered_map<ClientID, ClientInfo>;\nclass Server;\nusing PacketHandler = std::function<void(sf::IpAddress&,\n  const PortNumber&, const PacketID&, sf::Packet&, Server*)>;\nusing TimeoutHandler = std::function<void(const ClientID&)>;\n```", "```cpp\nclass Server{\npublic:\n   template <class T>\n   Server(void(T::*l_handler)(sf::IpAddress&, const PortNumber&, \n      const PacketID&, sf::Packet&, Server*),\n      T* l_instance): m_listenThread(&Server::Listen, this)\n   {\n      m_packetHandler = std::bind(l_handler, l_instance,\n         std::placeholders::_1, std::placeholders::_2, \n         std::placeholders::_3, std::placeholders::_4, \n         std::placeholders::_5);\n   }\n\n   Server(void(*l_handler)(sf::IpAddress&, const PortNumber&, \n      const PacketID&, sf::Packet&, Server*));\n   ~Server();\n\n   template<class T>\n   void BindTimeoutHandler(void(T::*l_handler)\n      (const ClientID&), T* l_instance)\n   {\n      m_timeoutHandler = std::bind(l_handler, l_instance, \n         std::placeholders::_1);\n   }\n   void BindTimeoutHandler(void(*l_handler)(const ClientID&));\n\n   bool Send(const ClientID& l_id, sf::Packet& l_packet);\n   bool Send(sf::IpAddress& l_ip, const PortNumber& l_port, \n      sf::Packet& l_packet);\n   void Broadcast(sf::Packet& l_packet, \n      const ClientID& l_ignore = ClientID(Network::NullID));\n\n   void Listen();\n   void Update(const sf::Time& l_time);\n\n   ClientID AddClient(const sf::IpAddress& l_ip, \n      const PortNumber& l_port);\n   ClientID GetClientID(const sf::IpAddress& l_ip, \n      const PortNumber& l_port);\n   bool HasClient(const ClientID& l_id);\n   bool HasClient(const sf::IpAddress& l_ip, \n      const PortNumber& l_port);\n   bool GetClientInfo(const ClientID& l_id, ClientInfo& l_info);\n   bool RemoveClient(const ClientID& l_id);\n   bool RemoveClient(const sf::IpAddress& l_ip, \n      const PortNumber& l_port);\n\n   void DisconnectAll();\n   bool Start();\n   bool Stop();\n\n   bool IsRunning();\n\n   unsigned int GetClientCount();\n   std::string GetClientList();\n\n   sf::Mutex& GetMutex();\nprivate:\n   void Setup();\n   ClientID m_lastID;\n\n   sf::UdpSocket m_incoming;\n   sf::UdpSocket m_outgoing;\n\n   PacketHandler m_packetHandler;\n   TimeoutHandler m_timeoutHandler;\n\n   Clients m_clients;\n   sf::Time m_serverTime;\n\n   bool m_running;\n\n   sf::Thread m_listenThread;\n   sf::Mutex m_mutex;\n\n   size_t m_totalSent;\n   size_t m_totalReceived;\n};\n```", "```cpp\nServer::Server(void(*l_handler)(sf::IpAddress&, const PortNumber&, \n   const PacketID&, sf::Packet&, Server*))\n   : m_listenThread(&Server::Listen, this)\n{\n   // Bind a packet handler function.\n   m_packetHandler = std::bind(l_handler, \n     std::placeholders::_1, std::placeholders::_2,\n     std::placeholders::_3, std::placeholders::_4,\n     std::placeholders::_5);\n}\n\nServer::~Server(){ Stop(); }\n```", "```cpp\nvoid Server::BindTimeoutHandler(void(*l_handler)\n  (const ClientID&))\n{\n   m_timeoutHandler = std::bind(l_handler, std::placeholders::_1);\n}\n```", "```cpp\nbool Server::Start(){\n    if (m_running){ return false; }\n    if(m_incoming.bind(SERVER_PORT) != sf::Socket::Done){\n        return false;\n    }\n    m_outgoing.bind(sf::Socket::AnyPort);\n    Setup();\n    std::cout << \"Incoming port: \" <<\n      m_incoming.getLocalPort() << \". Outgoing port: \" \n      << m_outgoing.getLocalPort() << std::endl;\n    m_listenThread.launch();\n    m_running = true;\n    return true;\n}\n```", "```cpp\nbool Server::Stop(){\n    if (!m_running){ return false; }\n    DisconnectAll();\n    m_running = false;\n    m_incoming.unbind(); // Stops the listening thread.\n    return true;\n}\n```", "```cpp\nvoid Server::Setup(){\n    m_lastID = 0;\n    m_running = false;\n    m_totalSent = 0;\n    m_totalReceived = 0;\n}\n```", "```cpp\nbool Server::Send(const ClientID& l_id, sf::Packet& l_packet){\n   sf::Lock lock(m_mutex);\n   auto itr = m_clients.find(l_id);\n   if (itr == m_clients.end()){ return false; }\n   if (m_outgoing.send(l_packet, itr->second.m_clientIP, \n      itr->second.m_clientPORT) != sf::Socket::Done)\n   {\n      std::cout << \"Error sending a packet...\" << std::endl;\n      return false;\n   }\n   m_totalSent += l_packet.getDataSize();\n   return true;\n}\n```", "```cpp\nbool Server::Send(sf::IpAddress& l_ip,\n  const PortNumber& l_port, sf::Packet& l_packet)\n{\n  if (m_outgoing.send(l_packet, l_ip, l_port) != sf::Socket::Done)\n  {\n    return false;\n  }\n  m_totalSent += l_packet.getDataSize();\n  return true;\n}\n```", "```cpp\nvoid Server::Broadcast(sf::Packet& l_packet,\n  const ClientID& l_ignore)\n{\n  sf::Lock lock(m_mutex);\n  for (auto &itr : m_clients)\n  {\n    if (itr.first != l_ignore){\n      if (m_outgoing.send(l_packet, itr.second.m_clientIP,\n        itr.second.m_clientPORT) != sf::Socket::Done)\n      {\n        std::cout << \"Error broadcasting a packet to client: \" \n          << itr.first << std::endl;\n        continue;\n      }\n      m_totalSent += l_packet.getDataSize();\n    }\n  }\n}\n```", "```cpp\nvoid Server::Listen(){\n  sf::IpAddress ip;\n  PortNumber port;\n  sf::Packet packet;\n  while (m_running){\n    packet.clear();\n    sf::Socket::Status status =\n      m_incoming.receive(packet, ip, port);\n    if (status != sf::Socket::Done){\n      if (m_running){\n        std::cout << \"Error receiving a packet from: \"\n          << ip << \":\" << port << \". Code: \" <<\n          status << std::endl;\n        continue;\n      } else {\n        std::cout << \"Socket unbound.\" << std::endl;\n        break;\n      }\n    }\n\n    m_totalReceived += packet.getDataSize();\n\n    PacketID p_id;\n    if (!(packet >> p_id)){\n      continue;\n    } // Non-conventional packet.\n    PacketType id = (PacketType)p_id;\n    if (id<PacketType::Disconnect || id>=PacketType::OutOfBounds){\n      continue;\n    } // Invalid packet type.\n\n    if (id == PacketType::Heartbeat){\n      sf::Lock lock(m_mutex);\n      for (auto &itr : m_clients){\n        if (itr.second.m_clientIP != ip ||\n          itr.second.m_clientPORT != port)\n        {\n          continue;\n        }\n        if (!itr.second.m_heartbeatWaiting){\n          std::cout << \"Invalid heartbeat packet received!\"\n            << std::endl;\n          break;\n        }\n        itr.second.m_ping = m_serverTime.asMilliseconds() -\n          itr.second.m_heartbeatSent.asMilliseconds();\n        itr.second.m_lastHeartbeat = m_serverTime;\n        itr.second.m_heartbeatWaiting = false;\n        itr.second.m_heartbeatRetry = 0;\n        break;\n      }\n    } else if (m_packetHandler){\n      m_packetHandler(ip, port, (PacketID)id, packet, this);\n    }\n  }\n}\n```", "```cpp\nClientID Server::AddClient(const sf::IpAddress& l_ip,\n  const PortNumber& l_port)\n{\n  sf::Lock lock(m_mutex);\n  for (auto &itr : m_clients){\n    if (itr.second.m_clientIP == l_ip &&\n      itr.second.m_clientPORT == l_port)\n    {\n      return ClientID(Network::NullID);\n    }\n  }\n  ClientID id = m_lastID;\n  ClientInfo info(l_ip, l_port, m_serverTime);\n  m_clients.insert(std::make_pair(id, info));\n  ++m_lastID;\n  return id;\n}\n```", "```cpp\nClientID Server::GetClientID(const sf::IpAddress& l_ip,\n  const PortNumber& l_port)\n{\n  sf::Lock lock(m_mutex);\n  for (auto &itr : m_clients){\n    if (itr.second.m_clientIP == l_ip &&\n      itr.second.m_clientPORT == l_port)\n    {\n      return itr.first;\n    }\n  }\n  return ClientID(Network::NullID);\n}\n```", "```cpp\nbool Server::HasClient(const ClientID& l_id){\n    return (m_clients.find(l_id) != m_clients.end());\n}\n\nbool Server::HasClient(const sf::IpAddress& l_ip, \n  const PortNumber& l_port)\n{\n    return(GetClientID(l_ip, l_port) >= 0);\n}\n\nbool Server::IsRunning(){ return m_running; }\nsf::Mutex& Server::GetMutex(){ return m_mutex; }\n```", "```cpp\nbool Server::GetClientInfo(const ClientID& l_id,\n  ClientInfo& l_info)\n{\n  sf::Lock lock(m_mutex);\n  for (auto &itr : m_clients){\n    if (itr.first == l_id){\n      l_info = itr.second;\n      return true;\n    }\n  }\n  return false;\n}\n```", "```cpp\nbool Server::RemoveClient(const ClientID& l_id){\n  sf::Lock lock(m_mutex);\n  auto itr = m_clients.find(l_id);\n  if (itr == m_clients.end()){ return false; }\n  sf::Packet p;\n  StampPacket(PacketType::Disconnect, p);\n  Send(l_id, p);\n  m_clients.erase(itr);\n  return true;\n}\n```", "```cpp\nbool Server::RemoveClient(const sf::IpAddress& l_ip,\n  const PortNumber& l_port)\n{\n  sf::Lock lock(m_mutex);\n  for (auto itr = m_clients.begin(); \n    itr != m_clients.end(); ++itr)\n  {\n    if (itr->second.m_clientIP == l_ip &&\n      itr->second.m_clientPORT == l_port)\n    {\n      sf::Packet p;\n      StampPacket(PacketType::Disconnect , p);\n      Send(itr->first, p);\n      m_clients.erase(itr);\n      return true;\n    }\n  }\n  return false;\n}\n```", "```cpp\nvoid Server::DisconnectAll(){\n  if (!m_running){ return; }\n  sf::Packet p;\n  StampPacket(PacketType::Disconnect, p);\n  Broadcast(p);\n  sf::Lock lock(m_mutex);\n  m_clients.clear();\n}\n```", "```cpp\nvoid Server::Update(const sf::Time& l_time){\n  m_serverTime += l_time;\n  if (m_serverTime.asMilliseconds() < 0){ \n    m_serverTime -= sf::milliseconds(HIGHEST_TIMESTAMP);\n    sf::Lock lock(m_mutex);\n    for (auto &itr : m_clients)\n    {\n      Itr.second.m_lastHeartbeat = \n        sf::milliseconds(std::abs(\n        itr.second.m_lastHeartbeat.asMilliseconds() - \n        HIGHEST_TIMESTAMP));\n    }\n  }\n\n  sf::Lock lock(m_mutex);\n  for (auto itr = m_clients.begin(); itr != m_clients.end();){\n    sf::Int32 elapsed = \n      m_serverTime.asMilliseconds() - \n      itr->second.m_lastHeartbeat.asMilliseconds();\n    if (elapsed >= HEARTBEAT_INTERVAL){\n      if (elapsed >= CLIENT_TIMEOUT \n        || itr->second.m_heartbeatRetry > HEARTBEAT_RETRIES)\n      {\n        // Remove client.\n        std::cout << \"Client \" << \n          itr->first << \" has timed out.\" << std::endl;\n        if (m_timeoutHandler){ m_timeoutHandler(itr->first); }\n        itr = m_clients.erase(itr);\n        continue;\n      }\n      if (!itr->second.m_heartbeatWaiting || (elapsed >= \n        HEARTBEAT_INTERVAL * (itr->second.m_heartbeatRetry + 1)))\n      {\n        // Heartbeat\n        if (itr->second.m_heartbeatRetry >= 3){\n          std::cout << \"Re-try(\" << itr->second.m_heartbeatRetry\n            << \") heartbeat for client \" \n            << itr->first << std::endl;\n        }\n        sf::Packet Heartbeat;\n        StampPacket(PACKET_HEARTBEAT, Heartbeat);\n        Heartbeat << m_serverTime.asMilliseconds();\n        Send(itr->first, Heartbeat);\n        if (itr->second.m_heartbeatRetry == 0){\n          itr->second.m_heartbeatSent = m_serverTime;\n        }\n        itr->second.m_heartbeatWaiting = true;\n        ++itr->second.m_heartbeatRetry;\n\n        m_totalSent += Heartbeat.getDataSize();\n      }\n    }\n    ++itr;\n  }\n}\n```", "```cpp\nvoid Handler(sf::IpAddress& l_ip, const PortNumber& l_port,\n  const PacketID& l_id, sf::Packet& l_packet, Server* l_server)\n{\n  ClientID id = l_server->GetClientID(l_ip, l_port);\n  if (id >= 0){\n    if ((PacketType)l_id == PacketType::Disconnect){\n      l_server->RemoveClient(l_ip, l_port);\n      sf::Packet p;\n      StampPacket(PacketType::Message, p);\n      std::string message;\n      message = \"Client left! \" + l_ip.toString() +\n        \":\" + std::to_string(l_port);\n      p << message;\n      l_server->Broadcast(p, id);\n    } else if ((PacketType)l_id == PacketType::Message){\n      std::string receivedMessage;\n      l_packet >> receivedMessage;\n      std::string message = l_ip.toString() + \":\" +\n        std::to_string(l_port) + \" :\" + receivedMessage;\n      sf::Packet p;\n      StampPacket(PacketType::Message, p);\n      p << message;\n      l_server->Broadcast(p, id);\n    }\n  } else {\n    if ((PacketType)l_id == PacketType::Connect){\n      ClientID id = l_server->AddClient(l_ip, l_port);\n      sf::Packet packet;\n      StampPacket(PacketType::Connect, packet);\n      l_server->Send(id, packet);\n    }\n  }\n}\n```", "```cpp\nvoid CommandProcess(Server* l_server){\n   while (l_server->IsRunning()){\n      std::string str;\n      std::getline(std::cin, str);\n      if (str == \"!quit\"){\n         l_server->Stop();\n         break;\n      } else if (str == \"dc\"){\n         l_server->DisconnectAll();\n         std::cout << \"DC...\" << std::endl;\n      } else if (str == \"list\"){\n         std::cout << l_server->GetClientCount() \n            << \" clients online:\" << std::endl;\n         std::cout << l_server->GetClientList() << std::endl;\n      }\n   }\n}\n```", "```cpp\nint main(){\n   Server server(Handler);\n\n   if (server.Start()){\n      sf::Thread c(&CommandProcess, &server);\n      c.launch();\n\n      sf::Clock clock;\n      clock.restart();\n      while (server.IsRunning()){\n         server.Update(clock.restart());\n      }\n      std::cout << \"Stopping server...\" << std::endl;\n   }\n\n   system(\"PAUSE\");\n   return 0;\n}\n```", "```cpp\nvoid HandlePacket(const PacketID& l_id,\n  sf::Packet& l_packet, Client* l_client)\n{\n  if ((PacketType)l_id == PacketType::Message){\n    std::string message;\n    l_packet >> message;\n    std::cout << message << std::endl;\n  } else if ((PacketType)l_id == PacketType::Disconnect){\n    l_client->Disconnect();\n  }\n}\n```", "```cpp\nvoid CommandProcess(Client* l_client){\n   while (l_client->IsConnected()){\n      std::string str;\n      std::getline(std::cin, str);\n      if (str != \"\"){\n         if (str == \"!quit\"){\n            l_client->Disconnect();\n            break;\n         }\n         sf::Packet p;\n         StampPacket(PacketType::Message, p);\n         p << str;\n         l_client->Send(p);\n      }\n   }\n}\n```", "```cpp\nvoid main(int argc, char** argv){\n    sf::IpAddress ip;\n    PortNumber port;\n    if (argc == 1){\n        std::cout << \"Enter Server IP: \";\n        std::cin >> ip;\n        std::cout << \"Enter Server Port: \";\n        std::cin >> port;\n    } else if (argc == 3){\n        ip = argv[1];\n        port = atoi(argv[2]);\n    } else {\n        return;\n    }\n\n    Client client;\n    client.SetServerInformation(ip, port);\n    client.Setup(&HandlePacket);\n    sf::Thread c(&CommandProcess, &client);\n    if (client.Connect()){\n        c.launch();\n        sf::Clock clock;\n        clock.restart();\n        while (client.IsConnected()){\n            client.Update(clock.restart());\n        }\n    } else {\n        std::cout << \"Failed to connect.\" << std::endl;\n    }\n    std::cout << \"Quitting...\" << std::endl;\n    sf::sleep(sf::seconds(1.f));\n}\n```"]