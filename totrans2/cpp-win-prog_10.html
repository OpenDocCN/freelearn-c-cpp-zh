<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;The Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. The Framework</h1></div></div></div><p>The remaining chapters of this book explain the details of the Small Windows implementation. This chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of the classes of Small Windows</li><li class="listitem" style="list-style-type: disc">An example of the Hello World application, which we covered at the beginning of this book, written in the Win32 API7</li><li class="listitem" style="list-style-type: disc">The <code class="literal">MainWindow</code> and <code class="literal">WinMain</code> functions</li><li class="listitem" style="list-style-type: disc">The implementation of the main classes of Small Windows: <code class="literal">Application</code>, <code class="literal">Window</code>, and <code class="literal">Graphics</code></li></ul></div><div class="section" title="An overview of Small Windows"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec45"/>An overview of Small Windows</h1></div></div></div><p>Here is a short description of the classes of Small Windows:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Chapter</strong></span></p>
</td><td>
<p><span class="strong"><strong>Class</strong></span></p>
</td><td>
<p><span class="strong"><strong>Description</strong></span></p>
</td></tr><tr><td>
<p>10</p>
</td><td>
<p>
<code class="literal">Application</code>
</p>
</td><td>
<p>This is the <code class="literal">main</code> class of Small Windows. It manages the message loop and registration of Windows classes.</p>
</td></tr><tr><td>
<p>10</p>
</td><td>
<p>
<code class="literal">Window</code>
</p>
</td><td>
<p>This the root <code class="literal">Window</code> class. It creates individual windows and provides basic window functionality, such as mouse, touch, and keyboard input, drawing, zooming, timer, focus, size, and coordinate systems.</p>
</td></tr><tr><td>
<p>10</p>
</td><td>
<p>
<code class="literal">Graphics</code>
</p>
</td><td>
<p>This is the class for drawing lines, rectangles, ellipses, and text in the client area of the window.</p>
</td></tr><tr><td>
<p>11</p>
</td><td>
<p>
<code class="literal">Document</code> extends <code class="literal">Window</code>
</p>
</td><td>
<p>This extends the window with document functionality, such as scrolling, caret handling, and drop files.</p>
</td></tr><tr><td>
<p>11</p>
</td><td>
<p>
<code class="literal">Menu</code>
</p>
</td><td>
<p>This handles menu bars, menus, menu items, and the menu separator.</p>
</td></tr><tr><td>
<p>11</p>
</td><td>
<p>
<code class="literal">Accelerator</code>
</p>
</td><td>
<p>This extracts accelerator information from the menu item texts.</p>
</td></tr><tr><td>
<p>11</p>
</td><td>
<p>
<code class="literal">StandardDocument</code> extends <code class="literal">Document</code>
</p>
</td><td>
<p>This provides a document-based framework with the common <span class="strong"><strong>File</strong></span>, <span class="strong"><strong>Edit</strong></span>, and <span class="strong"><strong>Help</strong></span> menu items.</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>
<code class="literal">Size</code>
</p>
<p>
<code class="literal">Point</code>
</p>
<p>
<code class="literal">Rect</code>
</p>
</td><td>
<p>These are auxiliary classes that handle a two-dimensional point (x and y), size (width and height), or the four corners of a rectangle.</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>
<code class="literal">Font</code>
</p>
</td><td>
<p>This wraps the <code class="literal">LOGFONT</code> structure, which holds information about the font's name, size, and whether it is bold or italic.</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>
<code class="literal">Cursor</code>
</p>
</td><td>
<p>This sets the cursor and provides a set of standard cursors.</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>
<code class="literal">DynamicList</code> template</p>
</td><td>
<p>This is a list of dynamic size and a set of callback methods.</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>
<code class="literal">Tree</code> template</p>
</td><td>
<p>This is a tree structure where each node has a (possibly empty) list of child nodes.</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>
<code class="literal">InfoList</code>
</p>
</td><td>
<p>This is a list of generic information, which can be transformed to and from a memory buffer.</p>
</td></tr><tr><td>
<p>13</p>
</td><td>
<p>
<code class="literal">Registry</code>
</p>
</td><td>
<p>This provides an interface against the Windows registry.</p>
</td></tr><tr><td>
<p>13</p>
</td><td>
<p>
<code class="literal">Clipboard</code>
</p>
</td><td>
<p>This provides an interface against the Windows clipboard.</p>
</td></tr><tr><td>
<p>13</p>
</td><td>
<p>
<code class="literal">StandardDialog</code>
</p>
</td><td>
<p>This displays the standard dialogs for saving and opening files, choosing a font or color, and printing.</p>
</td></tr><tr><td>
<p>13</p>
</td><td>
<p>
<code class="literal">PreviewDocument</code> extends <code class="literal">Document</code>
</p>
</td><td>
<p>This sets up a document whose logical size is fixed regardless of its physical size.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">Dialog</code> extends <code class="literal">Window</code>
</p>
</td><td>
<p>This provides a modal dialog. The controls below are added to the dialog.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">Control</code> abstract</p>
</td><td>
<p>This is the base class for dialog controls.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">ButtonControl</code> extends <code class="literal">Control</code>
</p>
</td><td>
<p>This is the base class for button controls.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">GroupBox</code>, <code class="literal">PushButton</code>, <code class="literal">CheckBox</code>, <code class="literal">RadioButton</code> extends <code class="literal">ButtonControl</code>
</p>
</td><td>
<p>These are classes for group boxes, push buttons, checkboxes, and radio buttons.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">ListControl</code> extends <code class="literal">Control</code>
</p>
</td><td>
<p>This is the base class for list controls.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">ListBox</code>, <code class="literal">MultipleListBox</code> extends <code class="literal">ListControl</code>
</p>
</td><td>
<p>These are classes for single and multiple list boxes.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">ComboBox</code> extends <code class="literal">Control</code>
</p>
</td><td>
<p>This is the class for a combo (drop-down) box.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">Label</code> extends <code class="literal">Control</code>
</p>
</td><td>
<p>This is the class for a simple label, often used as a prompt for <code class="literal">TextField</code>.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">TextField</code> template extends <code class="literal">Control</code>
</p>
</td><td>
<p>This is a class for an editable field, where a converter may convert between a string and any type.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">Converter</code> template</p>
</td><td>
<p>This is a converter class that can be specified by any type.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">PageSetupDialog</code> extends <code class="literal">Dialog</code>
</p>
</td><td>
<p>This is a dialog for page setup settings, such as margins, headers, and footer text.</p>
</td></tr><tr><td>
<p>14</p>
</td><td>
<p>
<code class="literal">PageSetupInfo</code>
</p>
</td><td>
<p>This has page setup information, which we saw previously.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="&quot;Hello&quot; window for the Win32 API"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec46"/>"Hello" window for the Win32 API</h1></div></div></div><p>First of all, let's take a look at the Hello application from the first chapter of this book. The following code snippet is the same application written directly with the Win32 API, without Small Windows. Note that the code is written in C rather than C++ as the Win32 API is a C function library rather than a C++ class library. As you can see, the code is a lot more complicated compared to the application in the first chapter.</p><p>Do not worry if it looks complicated. Its purpose is actually to demonstrate the complexity of the Win32 API; we'll discuss the details in this and the following chapters.</p><p>
<span class="strong"><strong>MainWindow.c</strong></span>
</p><pre class="programlisting">#include &lt;Windows.h&gt; &#13;
#include &lt;Assert.h&gt; &#13;
#include &lt;String.h&gt; &#13;
#include &lt;TChar.h&gt; &#13;
 &#13;
LRESULT CALLBACK WindowProc(HWND windowHandle, UINT message, &#13;
                            WPARAM wordParam, LPARAM longParam); &#13;
</pre><p>The <code class="literal">WinMain</code> method is called when the application starts to execute. It corresponds to <code class="literal">main</code> in Standard C.</p><pre class="programlisting">int WINAPI WinMain(HINSTANCE instanceHandle, &#13;
                   HINSTANCE prevInstanceHandle, &#13;
                   char* commandLine, int commandShow) { &#13;
</pre><p>First, we need to register the <code class="literal">Windows</code> class for our window. Note that <code class="literal">Windows</code> classes are not C++ classes:</p><pre class="programlisting">  WNDCLASS windowClass; &#13;
  memset(&amp;windowClass, 0, sizeof windowClass); &#13;
  windowClass.hInstance = instanceHandle; &#13;
</pre><p>The style of the <code class="literal">Windows</code> class will be redrawn when the window size is changed in the horizontal and vertical direction:</p><pre class="programlisting">  windowClass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; &#13;
</pre><p>The icon of the window is the standard application icon, the cursor is the standard arrow cursor, and the background of the  client area is white.</p><pre class="programlisting">  windowClass.hIcon = LoadIcon(NULL, IDI_APPLICATION); &#13;
  windowClass.hCursor = LoadCursor(NULL, IDC_ARROW); &#13;
  windowClass.hbrBackground = &#13;
    (HBRUSH) GetStockObject(WHITE_BRUSH); &#13;
</pre><p>The <code class="literal">WindowProc</code> function is a callback function called every time the window receives a message:</p><pre class="programlisting">  windowClass.lpfnWndProc = WindowProc; &#13;
</pre><p>The name of the <code class="literal">Windows</code> class is <code class="literal">window</code>, which is used in the <code class="literal">CreateWindowEx</code> call here:</p><pre class="programlisting">  windowClass.lpszClassName = TEXT("window"); &#13;
  RegisterClass(&amp;windowClass); &#13;
</pre><p>The <code class="literal">CreateWindowEx</code> method creates a window with the default position and size. Note that we can create many windows with the same <code class="literal">Windows</code> class:</p><pre class="programlisting">  HWND windowHandle = &#13;
    CreateWindowEx(0, TEXT("window"), NULL, WS_OVERLAPPEDWINDOW, &#13;
                   CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, &#13;
                   CW_USEDEFAULT, NULL, CreateMenu(), &#13;
                   instanceHandle, NULL); &#13;
  assert(windowHandle != NULL); &#13;
  ShowWindow(windowHandle, commandShow); &#13;
  RegisterTouchWindow(windowHandle, 0); &#13;
  SetWindowText(windowHandle, TEXT("Hello Window")); &#13;
</pre><p>The <code class="literal">GetMessage</code> method waits for the next message, which is translated and dispatched to the window with an input focus. The <code class="literal">GetMessage</code> method returns <code class="literal">true</code> for all messages except the quit message, which is eventually sent when the user closes the window:</p><pre class="programlisting">  MSG message; &#13;
  while (GetMessage(&amp;message, NULL, 0, 0)) { &#13;
    TranslateMessage(&amp;message); &#13;
    DispatchMessage(&amp;message); &#13;
  }  &#13;
  return ((int) message.wParam); &#13;
}  &#13;
&#13;
LRESULT CALLBACK WindowProc(HWND windowHandle, UINT message, &#13;
                            WPARAM wordParam, LPARAM longParam){ &#13;
&#13;
  switch (message) { &#13;
    case WM_PAINT: { &#13;
</pre><p>When painting the client area, we need to create a paint structure and a device context, which is created by <code class="literal">BeginPaint</code>:</p><pre class="programlisting">        PAINTSTRUCT paintStruct; &#13;
        HDC deviceContextHandle = &#13;
          BeginPaint(windowHandle, &amp;paintStruct); &#13;
        SetMapMode(deviceContextHandle, MM_ISOTROPIC); &#13;
</pre><p>Since we want to use logical units (hundreds of a millimeters), we need to set the device context by calling <code class="literal">SetWindowExtEx</code> and <code class="literal">SetViewportExtEx</code>:</p><pre class="programlisting">        int horizontalSize = &#13;
              100 * GetDeviceCaps(deviceContextHandle, HORZSIZE), &#13;
            verticalSize = &#13;
              100 * GetDeviceCaps(deviceContextHandle,VERTSIZE); &#13;
&#13;
&#13;
        SetWindowExtEx(deviceContextHandle, horizontalSize, &#13;
                       verticalSize, NULL);  &#13;
        int horizontalResolution = &#13;
              (int) GetDeviceCaps(deviceContextHandle,HORZRES), &#13;
            verticalResolution = &#13;
              (int) GetDeviceCaps(deviceContextHandle,VERTRES); &#13;
        SetViewportExtEx(deviceContextHandle,horizontalResolution, &#13;
                         verticalResolution, NULL); &#13;
</pre><p>Since we also want to take scroll movements into consideration, we also call <code class="literal">SetWindowOrgEx</code>:</p><pre class="programlisting">        int horizontalScroll = &#13;
          GetScrollPos(windowHandle, SB_HORZ), &#13;
            verticalScroll = GetScrollPos(windowHandle, SB_VERT); &#13;
        SetWindowOrgEx(deviceContextHandle, horizontalScroll, &#13;
                       verticalScroll, NULL); &#13;
</pre><p>Also, as we want to take scroll movements into consideration, we call <code class="literal">SetWindowOrgEx</code> to set to logical origin of the client area:</p><pre class="programlisting">        RECT clientRect; &#13;
        GetClientRect(windowHandle, &amp;clientRect); &#13;
        POINT bottomRight = {clientRect.right, clientRect.bottom}; &#13;
        DPtoLP(deviceContextHandle, &amp;bottomRight, 1); &#13;
        clientRect.right = bottomRight.x; &#13;
        clientRect.top = bottomRight.y; &#13;
</pre><p>We need to set a <code class="literal">LOGFONT</code> structure to create the 12-point boldface <code class="literal">Times New Roman</code> font:</p><pre class="programlisting">        LOGFONT logFont; &#13;
        memset(&amp;logFont, 0, sizeof logFont); &#13;
        _tcscpy_s(logFont.lfFaceName, LF_FACESIZE, &#13;
                  TEXT("Times New Roman")); &#13;
        int fontSize = 12; &#13;
</pre><p>Since we work with logical units that are hundreds of millimeters, one typographical point is 1 inch divided by 72 and 1 inch is 25.4 millimeters. We multiply the font size by 2,540 and divide it by 72:</p><pre class="programlisting">        logFont.lfHeight = (int) ((2540.0 * fontSize) / 72); &#13;
        logFont.lfWeight = FW_BOLD; &#13;
        logFont.lfItalic = FALSE; &#13;
</pre><p>When we use the font to write text in the client area, we need to create the font indirectly and add it as a graphical object. We also need to save the previous object in order to restore it later:</p><pre class="programlisting">        HFONT fontHandle = CreateFontIndirect(&amp;logFont); &#13;
        HFONT oldFontHandle = &#13;
          (HFONT) SelectObject(deviceContextHandle, fontHandle); &#13;
</pre><p>The text color is black and its background color is white. <code class="literal">RGB</code> is a macro that transforms the red, green, and blue parts of the color into a <code class="literal">COLORREF</code> value:</p><pre class="programlisting">        COLORREF black = RGB(0, 0, 0), white = RGB(255, 255, 255); &#13;
        SetTextColor(deviceContextHandle, black); &#13;
        SetBkColor(deviceContextHandle, white); &#13;
</pre><p>Finally, <code class="literal">DrawText</code> draws the text in the middle of the client area:</p><pre class="programlisting">        TCHAR* textPtr = TEXT("Hello, Small Windows!"); &#13;
        DrawText(deviceContextHandle, textPtr, _tcslen(textPtr), &#13;
                 &amp;clientRect, DT_SINGLELINE|DT_CENTER|DT_VCENTER); &#13;
</pre><p>Since fonts are system resources, we need to restore the previous font object and delete the new font object. We also need to restore the paint structure:</p><pre class="programlisting">        SelectObject(deviceContextHandle, oldFontHandle); &#13;
        DeleteObject(fontHandle); &#13;
        EndPaint(windowHandle, &amp;paintStruct); &#13;
      } &#13;
</pre><p>Since we have handled the <code class="literal">WM_PAINT</code> message, we return zero.</p><pre class="programlisting">      break; &#13;
  } &#13;
</pre><p>For all messages other than <code class="literal">WM_PAINT</code>, we call <code class="literal">DefWindowProc</code> to handle the message:</p><pre class="programlisting">  return DefWindowProc(windowHandle, message, &#13;
                       wordParam, longParam); &#13;
} &#13;
</pre></div>
<div class="section" title="The MainWindow function"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec47"/>The MainWindow function</h1></div></div></div><p>In regular C and C++, the execution of the application starts with the <code class="literal">main</code> function. In Small Windows, however, <code class="literal">main</code> has been replaced by <code class="literal">MainWindow</code>. <code class="literal">MainWindow</code> is implemented by the user of Small Windows for each project. Its task is to define the application name and create the main window object.</p><p>
<span class="strong"><strong>MainWindow.h</strong></span>
</p><pre class="programlisting">void MainWindow(vector&lt;String&gt; argumentList, &#13;
                SmallWindows::WindowShow windowShow); &#13;
</pre></div>
<div class="section" title="The WinMain function"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec48"/>The WinMain function</h1></div></div></div><p>In the Win32 API, <code class="literal">WinMain</code> is the function equivalent to <code class="literal">main</code>. Each application must include the definition of the <code class="literal">WinMain</code> function. In order for Small Windows to work, <code class="literal">WinMain</code> is implemented as a part of Small Windows, while <code class="literal">MainWindow</code> has to be implemented by the user of Small Windows for each project. To sum it up, here are the three kinds of main functions:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Regular C/C++</strong></span></p>
</td><td>
<p><span class="strong"><strong>Win32 API</strong></span></p>
</td><td>
<p><span class="strong"><strong>Small Windows</strong></span></p>
</td></tr><tr><td>
<p>main</p>
</td><td>
<p>WinMain</p>
</td><td>
<p>MainWindow</p>
</td></tr></tbody></table></div><p>The <code class="literal">WinMain</code> function is called by the Windows system and takes the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">instanceHandle</code>: This holds the handle of the application</li><li class="listitem" style="list-style-type: disc"><code class="literal">prevInstanceHandle</code>: This is present due to backward compatibility but is always <code class="literal">null</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">commandLine</code>: This is a null-terminated character (<code class="literal">char</code>, not <code class="literal">TCHAR</code>) array holding the arguments for the application, separated by spaces</li><li class="listitem" style="list-style-type: disc"><code class="literal">commandShow</code>: This holds the preferred appearance of the main window</li></ul></div><p>
<span class="strong"><strong>WinMain.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
int WINAPI WinMain(HINSTANCE instanceHandle, &#13;
                   HINSTANCE /* prevInstanceHandle */, &#13;
                   char* commandLine, int commandShow) { &#13;
</pre><p>The <code class="literal">WinMain</code> function performs the following tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It divides the space-separated words of the command line into a <code class="literal">String</code> list by calling <code class="literal">GenerateArgumentList</code>. Refer to <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <span class="emphasis"><em>Auxiliary Classes</em></span>, for the definitions of <code class="literal">CharPtrToGenericString</code> and <code class="literal">Split</code>.</li><li class="listitem" style="list-style-type: disc">It instantiates an <code class="literal">Application</code> object.</li><li class="listitem" style="list-style-type: disc">It calls the <code class="literal">MainWindow</code> function, which creates the main window of the application and sets its name.</li><li class="listitem" style="list-style-type: disc">It calls the <code class="literal">RunMessageLoop</code> method of <code class="literal">Application</code>, which continues to handle Windows messages until the quit message is sent.</li></ul></div><pre class="programlisting">  Application::RegisterWindowClasses(instanceHandle); &#13;
  vector&lt;String&gt; argumentList = &#13;
    Split(CharPtrToGenericString(commandLine)); &#13;
  MainWindow(argumentList, (WindowShow) commandShow); &#13;
  return Application::RunMessageLoop(); &#13;
} &#13;
</pre></div>
<div class="section" title="The Application class"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec49"/>The Application class</h1></div></div></div><p>The <code class="literal">Application</code> class handles the message loop of the application. The message loop waits for the next message from the Windows system and sends it to the right window. The <code class="literal">Application</code> class also defines the <code class="literal">Windows</code> classes (which are not C++ classes) for the <code class="literal">Window</code>, <code class="literal">Document</code>, <code class="literal">StandardDocument</code>, and <code class="literal">Dialog</code> C++ classes. The fields of the classes are static since <code class="literal">Application</code> is not intended to be instantiated.</p><p>From this point in Small Windows, every part of the Small Windows implementation is included in the <code class="literal">SmallWindows</code> namespace. A namespace is a C++ feature that encapsulates classes and functions. The declaration of <code class="literal">MainWindow</code>, we saw earlier, is not included in the <code class="literal">Smallwindows</code> namespace since the C++ language rules stipulate that it cannot be included in a namespace. The <code class="literal">WinMain</code> definition is also not included in the namespace, since it needs to be placed outside the namespace to be called by the Windows system.</p><p>
<span class="strong"><strong>Application.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Application { &#13;
    public: &#13;
</pre><p>The <code class="literal">RegisterWindowClasses</code> method defines the Windows classes for the <code class="literal">Window</code>, <code class="literal">Document</code>, <code class="literal">StandardDocument</code>, and <code class="literal">Dialog</code> C++ classes. The <code class="literal">RunMessageLoop</code> method runs the message loop of the Windows message system. It waits for the next message and sends it to the right window. When a special quit message is received it breaks the message loop, which leads to the termination of the <code class="literal">Application</code> class:</p><pre class="programlisting">      static void RegisterWindowClasses(HINSTANCE instanceHandle); &#13;
      static int RunMessageLoop(); &#13;
</pre><p>In Windows, each application holds a <span class="strong"><strong>handle</strong></span> to the application instance. Handles are common in the Win32 API, and are used to access objects of the Windows system. They are similar to pointers but provide identification without revealing any location information.</p><p>The instance handle (of the <code class="literal">HINSTANCE</code> type) is used when creating windows in the constructor of the following <code class="literal">Window</code> class and when displaying standard dialogs in the Standard Dialogs section in <a class="link" href="ch14.html" title="Chapter 14. Dialogs, Controls, and Page Setup">Chapter 14</a>, <span class="emphasis"><em>Dialogs, Controls, and Page Setup</em></span>:</p><pre class="programlisting">      static HINSTANCE&amp; InstanceHandle() {return instanceHandle;} &#13;
</pre><p>The application name is set by each application and is referred to by the standard <span class="strong"><strong>File</strong></span>, <span class="strong"><strong>Help</strong></span>, and <span class="strong"><strong>About</strong></span> menus, the <span class="strong"><strong>Open</strong></span> and <span class="strong"><strong>Save</strong></span> dialogs, and the registry:</p><pre class="programlisting">      static String&amp; ApplicationName() {return applicationName;} &#13;
</pre><p>The pointer to the main window of the application is referenced when the user closes a window. If it is the main window, the application exits. Moreover, when the user selects the <span class="strong"><strong>Exit</strong></span> menu item, the main window is closed before the application exits:</p><pre class="programlisting">      static Window*&amp; MainWindowPtr() {return mainWindowPtr;} &#13;
 &#13;
  private: &#13;
      static HINSTANCE instanceHandle; &#13;
      static String applicationName; &#13;
      static Window* mainWindowPtr; &#13;
  }; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Application.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  HINSTANCE Application::instanceHandle; &#13;
  String Application::applicationName; &#13;
  Window* Application::mainWindowPtr; &#13;
</pre><div class="section" title="The Win32 API Windows classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec85"/>The Win32 API Windows classes</h2></div></div></div><p>The <code class="literal">Windows</code> classes are registered in <code class="literal">Application</code>. A Windows class needs to be registered only once. After it has been registered, more than one window can be created for each <code class="literal">Windows</code> class. Again, note that windows classes are not C++ classes. Each <code class="literal">Windows</code> class is stored by its name: <code class="literal">lpszClassName</code>. The <code class="literal">lpfnWndProc</code> field defines the freestanding function that receives the window messages from the message loop. Each window allows double-clicks as well as horizontal and vertical redraw styles, which means that the <code class="literal">WM_PAINT</code> message is sent to the window and the <code class="literal">OnPaint</code> method is called each time the user changes the size of the window. Moreover, each window has the standard application icon in its top-right corner and the standard arrow cursor. The client area is white, except for the dialog, where the client area is light gray:</p><pre class="programlisting">  void Application::RegisterWindowClasses(HINSTANCE &#13;
                                          instanceHandle) { &#13;
    Application::instanceHandle = instanceHandle; &#13;
    assert(instanceHandle != nullptr); &#13;
 &#13;
    WNDCLASS windowClass; &#13;
    memset(&amp;windowClass, 0, sizeof windowClass); &#13;
    windowClass.hInstance = instanceHandle; &#13;
    windowClass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; &#13;
    windowClass.hIcon = LoadIcon(nullptr, IDI_APPLICATION); &#13;
    windowClass.hCursor = LoadCursor(nullptr, IDC_ARROW); &#13;
    windowClass.hbrBackground = &#13;
      (HBRUSH) GetStockObject(WHITE_BRUSH); &#13;
 &#13;
    windowClass.lpfnWndProc = WindowProc; &#13;
    windowClass.lpszClassName = TEXT("window"); &#13;
    ::RegisterClass(&amp;windowClass); &#13;
 &#13;
    windowClass.lpfnWndProc = DocumentProc; &#13;
    windowClass.lpszClassName = TEXT("document"); &#13;
    ::RegisterClass(&amp;windowClass); &#13;
 &#13;
    windowClass.lpfnWndProc = DocumentProc; &#13;
    windowClass.lpszClassName = TEXT("standarddocument"); &#13;
    ::RegisterClass(&amp;windowClass); &#13;
  } &#13;
</pre></div><div class="section" title="The message loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec86"/>The message loop</h2></div></div></div><p>The <code class="literal">RunMessageLoop</code> method holds the classic Windows message loop. There are two cases: if the main window pointer points at an object of the <code class="literal">Window</code> class, we just need to handle the message queue with the Win32 API functions <code class="literal">GetMessage</code>, <code class="literal">TranslateMessage</code>, and <code class="literal">DispatchMessage</code> without caring about accelerators. However, if it points at an object of <code class="literal">Document</code> or any of its subclasses, the message loop becomes more complicated because we need to take accelerators into consideration:</p><pre class="programlisting">  int Application::RunMessageLoop() { &#13;
    assert(!applicationName.empty()); &#13;
    assert(mainWindowPtr != nullptr); &#13;
 &#13;
    MSG message; &#13;
&#13;
&#13;
    if (dynamic_cast&lt;Document*&gt;(mainWindowPtr) == nullptr) { &#13;
      while (::GetMessage(&amp;message, nullptr, 0, 0)) { &#13;
        ::TranslateMessage(&amp;message); &#13;
        ::DispatchMessage(&amp;message); &#13;
      } &#13;
    } &#13;
</pre><p>If the main window pointer points at an object of <code class="literal">Document</code> or any of its subclasses, we set up a buffer for the accelerator table defined in <code class="literal">Document</code>, which we use in the message loop. The Win32 API <code class="literal">TranslateAccelerator</code> function looks up the accelerator and decides whether a key stroke message should be treated as the menu item associated with the accelerator:</p><pre class="programlisting">    else { &#13;
      Document* documentPtr = (Document*) mainWindowPtr; &#13;
      int size = documentPtr-&gt;AcceleratorSet().size(), index = 0; &#13;
</pre><p>The <code class="literal">TranslateAccelerator</code> method wants an array of ACCEL structures, so we convert the accelerator set to an array:</p><pre class="programlisting">      ACCEL* acceleratorTablePtr = new ACCEL[size]; &#13;
      assert(acceleratorTablePtr != nullptr); &#13;
 &#13;
      for (ACCEL accelerator : documentPtr-&gt;AcceleratorSet()) { &#13;
        acceleratorTablePtr[index++] = accelerator; &#13;
      } &#13;
 &#13;
      HACCEL acceleratorTable = &#13;
              ::CreateAcceleratorTable(acceleratorTablePtr, size); &#13;
 &#13;
      while (::GetMessage(&amp;message, nullptr, 0, 0)) { &#13;
        if (!::TranslateAccelerator(mainWindowPtr-&gt;WindowHandle(), &#13;
                                    acceleratorTable, &amp;message)) { &#13;
          ::TranslateMessage(&amp;message); &#13;
          ::DispatchMessage(&amp;message); &#13;
        } &#13;
      } &#13;
</pre><p>When the accelerator array is used, it is deleted:</p><pre class="programlisting">      delete [] acceleratorTablePtr; &#13;
    } &#13;
</pre><p>When the message loop is finished, we return the last massage:</p><pre class="programlisting">    return ((int) message.wParam); &#13;
  } &#13;
</pre></div></div>
<div class="section" title="The Window class"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec50"/>The Window class</h1></div></div></div><p>The <code class="literal">Window</code> class is the root class of the document classes; it handles basic window functionality such as the timer, input focus, coordinate transformation, window size and position, text metrics, and the message box as well as mouse, keyboard, and touch screen input. Moreover, <code class="literal">Window</code> defines enumerations for window styles and appearances, buttons, icons, and coordinate systems.</p><p>
<span class="strong"><strong>Window.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  extern map&lt;HWND,Window*&gt; WindowMap; &#13;
</pre><p>There is large set of window styles. The window may be equipped with a border, a thick frame, scroll bars, or minimize and maximize boxes:</p><pre class="programlisting">  enum WindowStyle {NoStyle = 0, Border = WS_BORDER, &#13;
                    ThickFrame = WS_THICKFRAME, &#13;
                    Caption = WS_CAPTION, Child = WS_CHILD, &#13;
                    ClipChildren = WS_CLIPCHILDREN, &#13;
                    ClipSibling = WS_CLIPSIBLINGS, &#13;
                    Disabled = WS_DISABLED, &#13;
                    DialogFrame = WS_DLGFRAME, Group = WS_GROUP, &#13;
                    HScroll = WS_HSCROLL, Minimize = WS_MINIMIZE, &#13;
                    Maximize = WS_MAXIMIZE, &#13;
                    MaximizeBox = WS_MAXIMIZEBOX, &#13;
                    MinimizeBox = WS_MINIMIZEBOX, &#13;
                    Overlapped = WS_OVERLAPPED, &#13;
                    OverlappedWindow = WS_OVERLAPPEDWINDOW, &#13;
                    Popup = WS_POPUP,PopupWindow = WS_POPUPWINDOW, &#13;
                    SystemMenu = WS_SYSMENU, &#13;
                    Tabulatorstop = WS_TABSTOP, &#13;
                    Thickframe = WS_THICKFRAME, &#13;
                    Tiled = WS_TILED, Visible = WS_VISIBLE, &#13;
                    VScroll = WS_VSCROLL}; &#13;
</pre><p>The window can be displayed in minimized, maximized, or normal mode:</p><pre class="programlisting">  enum WindowShow {Restore = SW_RESTORE, Default = SW_SHOWDEFAULT, &#13;
                   Maximized = SW_SHOWMAXIMIZED, &#13;
                   Minimized = SW_SHOWMINIMIZED, &#13;
                   MinNoActive = SW_SHOWMINNOACTIVE, &#13;
                   NoActive = SW_SHOWNA, &#13;
                   NoActivate = SW_SHOWNOACTIVATE, &#13;
                   Normal = SW_SHOWNORMAL, &#13;
                   Show = SW_SHOW, Hide = SW_HIDE}; &#13;
</pre><p>A mouse may hold the left, middle, and right button. The mouse wheel can be rolled upwards or downwards:</p><pre class="programlisting">  enum MouseButton {NoButton = 0x00, LeftButton = 0x01, &#13;
                    MiddleButton = 0x02, RightButton = 0x04}; &#13;
  enum WheelDirection {WheelUp, WheelDown}; &#13;
</pre><p>There are four kinds of coordinate system as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LogicalWithScroll</code>: In this, each unit is one hundredth of a millimeter, regardless of the physical screen resolution, with the current scroll bar settings taken into consideration</li><li class="listitem" style="list-style-type: disc"><code class="literal">LogicalWithoutScroll</code>: This is the same as <code class="literal">LogicalWithScroll</code>, except that the scroll bars settings are ignored</li><li class="listitem" style="list-style-type: disc"><code class="literal">PreviewCoordinate</code>: In this, the window client area always holds a specific logical size, which means that the size of the logical units is changed when the size of the window is changed</li></ul></div><pre class="programlisting">  enum CoordinateSystem {LogicalWithScroll, LogicalWithoutScroll, &#13;
                         PreviewCoordinate}; &#13;
</pre><p>The message box comes equipped with a set of button combinations, icons, and answers. Note that the answer corresponding to the <span class="strong"><strong>OK</strong></span> button is named <code class="literal">OkAnswer</code> in the <code class="literal">Answer</code> enumeration in order to avoid name clashes with the <code class="literal">OK</code> button in the <code class="literal">ButtonGroup</code> enumeration:</p><pre class="programlisting">  enum ButtonGroup {Ok = MB_OK, OkCancel = MB_OKCANCEL, &#13;
                    YesNo = MB_YESNO, &#13;
                    YesNoCancel = MB_YESNOCANCEL, &#13;
                    RetryCancel = MB_RETRYCANCEL, &#13;
                    CancelTryContinue = MB_CANCELTRYCONTINUE, &#13;
                    AbortRetryIgnore = MB_ABORTRETRYIGNORE}; &#13;
 &#13;
  enum Icon {NoIcon = 0, Information = MB_ICONINFORMATION, &#13;
             Stop = MB_ICONSTOP, Warning = MB_ICONWARNING, &#13;
             Question = MB_ICONQUESTION}; &#13;
 &#13;
  enum Answer {OkAnswer = IDOK, Cancel = IDCANCEL, Yes = IDYES, &#13;
               No = IDNO, Retry = IDRETRY, Continue = IDCONTINUE, &#13;
               Abort = IDABORT, Ignore = IDIGNORE} const; &#13;
</pre><p>The default definitions of <code class="literal">OnPaint</code> and <code class="literal">OnPrint</code> both call <code class="literal">OnDraw</code>. In order to distinguish the two cases, the <code class="literal">OnDraw</code> parameter has the value <code class="literal">Paint</code> or <code class="literal">Print</code>:</p><pre class="programlisting">  enum DrawMode {Paint, Print}; &#13;
</pre><p>The first <code class="literal">Window</code> constructor is public and intended to be used when a window is created directly. The <code class="literal">pageSize</code> field refers to the size of the window client area. The constructor also takes a pointer to the window's parent window (which is <code class="literal">null</code> if there is no parent window), the window's basic style and extended style, and its initial appearance, position, and size. If the position or size is zero, the window is located or dimensioned in accordance with the system's default settings.</p><p>Note the difference between the document and windows sizes in <code class="literal">PreviewCoordinate</code>: the document size is the size of the client area in units defined by the window's coordinate system, while the size and position of the window are given in the coordinate system of the parent window or in device units if there is no parent window. Moreover, the document size refers to the size of the client area while the window size refers to the size of the whole window:</p><pre class="programlisting">  class Application; &#13;
 &#13;
  class Window { &#13;
    public: &#13;
      Window(CoordinateSystem system, Size pageSize = ZeroSize, &#13;
             Window* parentPtr = nullptr, &#13;
             WindowStyle style = OverlappedWindow, &#13;
             WindowStyle extendedStyle = NoStyle, &#13;
             WindowShow windowShow = Normal, &#13;
             Point topLeft = ZeroPoint, Size windowSize=ZeroSize); &#13;
</pre><p>The second constructor is protected and intended to be called by subclasses' constructors. The difference when compared to the first constructor is that is takes the name of the <code class="literal">window</code> class as its first parameter. As defined by the <code class="literal">Application</code> class, the class name can be <code class="literal">Window</code>, <code class="literal">Document</code>, <code class="literal">StandardDocument</code>, or <code class="literal">Dialog</code>:</p><pre class="programlisting">    protected: &#13;
      Window(Window* parentPtr = nullptr); &#13;
      Window(String className, CoordinateSystem system, &#13;
             Size pageSize = ZeroSize, &#13;
             Window* parentPtr = nullptr, &#13;
             WindowStyle style = OverlappedWindow, &#13;
             WindowStyle extendedStyle = NoStyle, &#13;
             WindowShow windowShow = Normal, &#13;
             Point windowTopLeft = ZeroPoint, &#13;
             Size windowSize = ZeroSize); &#13;
</pre><p>A <span class="strong"><strong>device context</strong></span> is used when painting the client area, when transforming between logical and device units, and when calculating the size of text. It is a connection to the client area of a window or to a printer. However, since it comes with a set of functions for drawing text of graphical objects, it can also be considered as a toolbox for drawing. However, before it is used, it needs to be prepared and adjusted in accordance with the current coordinate system:</p><pre class="programlisting">      void PrepareDeviceContext(HDC deviceContextHandle) const; &#13;
</pre><p>The destructor destroys the window and exits the application if the window is the application's main window:</p><pre class="programlisting">    public: &#13;
      virtual ~Window(); &#13;
</pre><p>The window can be visible or invisible; it can also be enabled in such a way that it catches mouse, touch, and keyboard inputs:</p><pre class="programlisting">      void ShowWindow(bool visible); &#13;
      void EnableWindow(bool enable); &#13;
</pre><p>The <code class="literal">OnSize</code> and <code class="literal">OnMove</code> methods are called when the user changes the size of the window or moves it. The size and position are given in logical coordinates. The <code class="literal">OnHelp</code> method is called when the user presses the <span class="emphasis"><em>F1</em></span> key of the <span class="emphasis"><em>Help</em></span> button in a message box. The methods are intended to be overridden by subclasses, and their default behavior is to do nothing:</p><pre class="programlisting">      virtual void OnSize(Size windowSize) {/* Empty. */} &#13;
      virtual void OnMove(Point topLeft) {/* Empty. */} &#13;
      virtual void OnHelp() {/* Empty. */} &#13;
</pre><p>The <code class="literal">WindowHandle</code> method returns the Win32 API window handle, which is used by standard dialog functions. The <code class="literal">ParentWindowPtr</code> method returns the pointer to the parent window, which is <code class="literal">null</code>, meaning that there is no parent window. The <code class="literal">SetHeader</code> method sets the title of the window, which is visible in the upper border:</p><pre class="programlisting">      HWND WindowHandle() const {return windowHandle;} &#13;
      HWND&amp; WindowHandle() {return windowHandle;} &#13;
      Window* ParentWindowPtr() const {return parentPtr;} &#13;
      Window*&amp; ParentWindowPtr() {return parentPtr;} &#13;
      void SetHeader(String headerText); &#13;
</pre><p>The client area of the window is zoomed in accordance with the zoom factor; 1.0 corresponds to the normal size:</p><pre class="programlisting">      double GetZoom() const {return zoom;} &#13;
      void SetZoom(double z) {zoom = z;} &#13;
</pre><p>Several timers can be set or dropped as long as the values of the <code class="literal">timerId</code> parameter differ. The <code class="literal">OnTimer</code> method is called in accordance with the intervals in milliseconds; its default behavior is to do nothing.</p><pre class="programlisting">      void SetTimer(int timerId, unsigned int interval); &#13;
      void DropTimer(int timerId); &#13;
      virtual void OnTimer(int timerId) {/* Empty. */} &#13;
</pre><p>The <code class="literal">SetFocus</code> method sets the input focus to this window. The input focus directs the keyboard input and clipboard to the window. However, the mouse pointer may be aiming at another window. The window previously holding the input focus loses the focus; only one window can hold the focus at a given time. The <code class="literal">HasFocus</code> method returns <code class="literal">true</code> if the window has input focus.</p><pre class="programlisting">      void SetFocus() const; &#13;
      bool HasFocus() const; &#13;
</pre><p>The <code class="literal">OnGainFocus</code> and <code class="literal">OnLoseFocus</code> methods are called when the window gains or loses input focus. They are intended to be overridden by subclasses, and their default behavior is to do nothing.</p><pre class="programlisting">      virtual void OnGainFocus() {/* Empty. */} &#13;
      virtual void OnLoseFocus() {/* Empty. */} &#13;
</pre><p>In Windows, a mouse is regarded as holding three buttons, even if it does not do so physically. The mouse buttons can be pressed or released and the mouse can be moved. The <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseUp</code>, and <code class="literal">OnMouseMove</code> methods are called when the user presses or releases one of the mouse buttons or moves the mouse with at least one button pressed. The user may press the <span class="emphasis"><em>
<span class="strong"><strong>Shift</strong></span>
</em></span> or <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> key at the same time, in which case <code class="literal">shiftPressed</code> or <code class="literal">controlPressed</code> is <code class="literal">true</code>:</p><pre class="programlisting">      virtual void OnMouseDown(MouseButton mouseButtons,&#13;
                               Point mousePoint,&#13;
                               bool shiftPressed,&#13;
                               bool controlPressed) {/* Empty. */}&#13;
      virtual void OnMouseUp(MouseButton mouseButtons,&#13;
                             Point mousePoint,&#13;
                             bool shiftPressed,&#13;
                             bool controlPressed) {/* Empty. */}&#13;
      virtual void OnMouseMove(MouseButton mouseButtons,&#13;
                               Point mousePoint,&#13;
                               bool shiftPressed,&#13;
                               bool controlPressed) {/* Empty. */}&#13;
</pre><p>The user can also double-click a mouse button, in which case <code class="literal">OnDoubleClick</code> is called. What constitutes a double-click is decided by the Windows system and can be set in the Control Panel. When the user single-clicks a button, <code class="literal">OnMouseDown</code> is called, followed by <code class="literal">OnMouseMove</code> in the case of potential mouse movements, and finally <code class="literal">OnMouseUp</code>. However, in the case of a double-click, <code class="literal">OnMouseDown</code> is not called, its call is replaced by <code class="literal">OnDoubleClick</code>:</p><pre class="programlisting">      virtual void OnDoubleClick(MouseButton mouseButtons,&#13;
                           Point mousePoint, bool shiftPressed,&#13;
                           bool controlPressed) {/* Empty. */}&#13;
</pre><p>The <code class="literal">OnMouseWheel</code> method is called when the user rolls the mouse wheel one step upwards or downwards:</p><pre class="programlisting">      virtual void OnMouseWheel(WheelDirection direction,&#13;
                                bool shiftPressed,&#13;
                                bool controlPressed){/* Empty. */}&#13;
</pre><p>The <code class="literal">OnTouchDown</code>, <code class="literal">OnTouchMove</code>, and <code class="literal">OnTouchUp</code> methods are called when the user touches the screen. Unlike mouse clicks, the user can touch the screen at several locations at the same time. Therefore, the parameter is a list of points rather than a single point. The methods are intended to be overridden by subclasses. Their default behavior is to simulate a mouse click for each touch point with no button and with neither the <span class="emphasis"><em>
<span class="strong"><strong>Shift</strong></span>
</em></span> nor the <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> key pressed:</p><pre class="programlisting">      virtual void OnTouchDown(vector&lt;Point&gt; pointList); &#13;
      virtual void OnTouchMove(vector&lt;Point&gt; pointList); &#13;
      virtual void OnTouchUp(vector&lt;Point&gt; pointList); &#13;
</pre><p>The <code class="literal">OnKeyDown</code> and <code class="literal">OnKeyUp</code> methods are called when the user presses and releases a key. If the key is a graphical character (with ASCII number between 32 and 127, inclusive), <code class="literal">OnChar</code> is called in between. The <code class="literal">OnKeyDown</code> and <code class="literal">OnKeyUp</code> methods return <code class="literal">bool</code>; the idea is that the methods return <code class="literal">true</code> if the key was used. If not, they return <code class="literal">false</code> and the caller method is free to use the key to, for instance, control scroll movements:</p><pre class="programlisting">      virtual bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                             bool controlPressed) {return false;} &#13;
      virtual void OnChar(TCHAR tChar) {/* Empty. */} &#13;
      virtual bool OnKeyUp(WORD key, bool shiftPressed, &#13;
                           bool controlPressed) {return false;} &#13;
</pre><p>The <code class="literal">OnPaint</code> method is called when the client area of the window needs to be redrawn, partly or completely, and <code class="literal">OnPrint</code> is called when the user selects the <span class="strong"><strong>Print</strong></span> menu item. In both cases, the default definition calls <code class="literal">OnDraw</code>, which performs the actual drawing; <code class="literal">drawMode</code> is <code class="literal">Paint</code> when called by <code class="literal">OnPaint</code> and <code class="literal">Print</code> when called by <code class="literal">OnPrint</code>. The idea is that we let <code class="literal">OnPaint</code> and <code class="literal">OnPrint</code> perform actions specific to painting and printing and call <code class="literal">OnDraw</code> for the common drawing. The <code class="literal">Graphics</code> class is described in the next section:</p><pre class="programlisting">      virtual void OnPaint(Graphics&amp; graphics) const&#13;
                          {OnDraw(graphics, Paint);} &#13;
      virtual void OnPrint(Graphics&amp; graphics, int page, &#13;
                           int copy, int totalPages) const&#13;
                           {OnDraw(graphics, Print);} &#13;
      virtual void OnDraw(Graphics&amp; graphics, &#13;
                          DrawMode drawMode) const {/* Empty. */} &#13;
</pre><p>The <code class="literal">Invalidate</code> method invalidates the client area, partly or completely; that is, it prepares the area to be redrawn by <code class="literal">OnPaint</code> or <code class="literal">OnDraw</code>. If <code class="literal">clear</code> is <code class="literal">true</code>, the area is first cleared (painted by the window client color). The <code class="literal">UpdateWindow</code> method forces a repainting of the invalidated parts of the client area:</p><pre class="programlisting">      void Invalidate(bool clear = true) const; &#13;
      void Invalidate(Rect areaRect, bool clear = true) const; &#13;
      void UpdateWindow(); &#13;
</pre><p>The <code class="literal">OnClose</code> method is called when the user tries to close the window; its default behavior is to call <code class="literal">TryClose</code>. If <code class="literal">TryClose</code> returns <code class="literal">true</code> (which it does in its default definition), the window is closed. If that happens, <code class="literal">OnDestroy</code> is called, whose default behavior is to do nothing:</p><pre class="programlisting">      virtual bool TryClose() {return true;} &#13;
      virtual void OnClose(); &#13;
      virtual void OnDestroy() {/* Empty. */} &#13;
</pre><p>The following method transforms a <code class="literal">Point</code>, <code class="literal">Rectangle</code>, or <code class="literal">Size</code> object between device units and logical units. They are protected since they are intended to be called by subclasses only:</p><pre class="programlisting">    protected: &#13;
      Point DeviceToLogical(Point point) const; &#13;
      Rect DeviceToLogical(Rect rect) const; &#13;
      Size DeviceToLogical(Size size) const; &#13;
      Point LogicalToDevice(Point point) const; &#13;
      Rect LogicalToDevice(Rect rect) const; &#13;
      Size LogicalToDevice(Size size) const; &#13;
</pre><p>The following method gets or sets the size and position of the window and the client area in device units:</p><pre class="programlisting">    public: &#13;
      Point GetWindowDevicePosition() const; &#13;
      void SetWindowDevicePosition(Point topLeft); &#13;
      Size GetWindowDeviceSize() const; &#13;
      void SetWindowDeviceSize(Size windowSize); &#13;
      Size GetClientDeviceSize() const; &#13;
      Rect GetWindowDeviceRect() const; &#13;
      void SetWindowDeviceRect(Rect windowRect); &#13;
</pre><p>The following method gets or sets the logical size and position of the window and the client area, in logical units, in accordance with the coordinate system of the window:</p><pre class="programlisting">      Point GetWindowPosition() const; &#13;
      void SetWindowPosition(Point topLeft); &#13;
      Size GetWindowSize() const; &#13;
      void SetWindowSize(Size windowSize); &#13;
      Size GetClientSize() const; &#13;
      Rect GetWindowRect() const; &#13;
      void SetWindowRect(Rect windowRect) ; &#13;
</pre><p>The <code class="literal">CreateTextMetric</code> method initializes and returns a Win32 API <code class="literal">TEXTMETRIC</code> structure, which is then used by the text metric methods in order to calculate the logical size of text. It is private since it in intended to be called only by the <code class="literal">Window</code> methods:</p><pre class="programlisting">    private: &#13;
      TEXTMETRIC CreateTextMetric(Font font); &#13;
</pre><p>The following method calculates and returns the width, height, ascent, or average width of a character or text with the given font, in logical units:</p><pre class="programlisting">    public: &#13;
      int GetCharacterAverageWidth(Font font) const; &#13;
      int GetCharacterHeight(Font font) const; &#13;
      int GetCharacterAscent(Font font) const; &#13;
      int GetCharacterWidth(Font font, TCHAR tChar) const; &#13;
</pre><p>The <code class="literal">MessageBox</code> method displays a message box with a message, caption, a set of buttons, an icon, and on optional <span class="strong"><strong>Help</strong></span> button:</p><pre class="programlisting">      Answer MessageBox(String message, &#13;
                    String caption = TEXT("Error"), &#13;
                    ButtonGroup buttonGroup = Ok, &#13;
                    Icon icon = NoIcon, bool help = false) const; &#13;
</pre><p>The <code class="literal">pageSize</code> field holds the window client's logical size in the <code class="literal">PreviewCoordinate</code> coordinate system, which is used when transforming coordinates between logical and device coordinates. In the <code class="literal">LogicalWithScroll</code> and <code class="literal">LogicalWithoutScroll</code> coordinate systems, <code class="literal">pageSize</code> holds the logical size of the document, which does not necessarily equal the logical size of the client area, and is not changed when the window is resized. It is protected since it is also used by the <code class="literal">Document</code> and <code class="literal">StandardDocument</code> subclasses in the next chapter:</p><pre class="programlisting">    protected: &#13;
      const Size pageSize; &#13;
</pre><p>In the previous section, there was a handle to the application instance. <code class="literal">windowHandle</code> is a handle of type <code class="literal">HWND</code> to a Win32 API window; <code class="literal">parentPtr</code> is a pointer to the parent window, which is <code class="literal">null</code> if there is no parent window:</p><pre class="programlisting">      HWND windowHandle; &#13;
      Window* parentPtr; &#13;
</pre><p>The coordinate system chosen for the window is stored in <code class="literal">system</code>. The <code class="literal">zoom</code> field holds the zooming factor of the window, where 1.0 is the default:</p><pre class="programlisting">    private: &#13;
      CoordinateSystem system; &#13;
      double zoom = 1.0; &#13;
</pre><p>The <code class="literal">WindowProc</code> method is called each time the window receives a message. It is a friend of <code class="literal">Window</code>, since it needs access to its private members:</p><pre class="programlisting">      friend LRESULT CALLBACK WindowProc(HWND windowHandle, &#13;
                                 UINT message, WPARAM wordParam, &#13;
                                 LPARAM longParam); &#13;
  }; &#13;
</pre><p>Finally, <code class="literal">WindowMap</code> maps the <code class="literal">HWND</code> handles to the <code class="literal">Window</code> pointers, which are used in <code class="literal">WindowProc</code> as follows:</p><pre class="programlisting">  extern map&lt;HWND,Window*&gt; WindowMap; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Window.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  map&lt;HWND,Window*&gt; WindowMap; &#13;
</pre><div class="section" title="Initialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec87"/>Initialization</h2></div></div></div><p>The first constructor simply calls the second constructor with the class name <code class="literal">window</code>:</p><pre class="programlisting">  Window::Window(CoordinateSystem system, Size pageSize &#13;
                 /* = ZeroSize */, Window* parentPtr /*=nullptr*/, &#13;
                 WindowStyle style /* = OverlappedWindow */, &#13;
                 WindowStyle extendedStyle /* = NoStyle */, &#13;
                 WindowShow windowShow /* = Normal */, &#13;
                 Point windowTopLeft /* = ZeroPoint */, &#13;
                 Size windowSize /* = ZeroSize */) &#13;
   :Window(TEXT("window"), system, pageSize, parentPtr, style, &#13;
           extendedStyle, windowShow, windowTopLeft, windowSize) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The second constructor initializes the <code class="literal">parentPtr</code>, <code class="literal">system</code>, and <code class="literal">pageSize</code> fields:</p><pre class="programlisting">  Window::Window(String className, CoordinateSystem system, &#13;
                 Size pageSize /* = ZeroSize */, &#13;
                 Window* parentPtr /* = nullptr */, &#13;
                 WindowStyle style /* = OverlappedWindow */, &#13;
                 WindowStyle extendedStyle /* = NoStyle */, &#13;
                 WindowShow windowShow /* = Normal */, &#13;
                 Point windowTopLeft /* = ZeroPoint */, &#13;
                 Size windowSize /* = ZeroSize */) &#13;
   :parentPtr(parentPtr), &#13;
    system(system), &#13;
    pageSize(pageSize) { &#13;
</pre><p>If the window is a child window (the parent pointer is not <code class="literal">null</code>), its coordinates are converted to the coordinate system of its parent window:</p><pre class="programlisting">    if (parentPtr != nullptr) { &#13;
      windowTopLeft = parentPtr-&gt;LogicalToDevice(windowTopLeft); &#13;
      windowSize = parentPtr-&gt;LogicalToDevice(windowSize); &#13;
    } &#13;
</pre><p>The Win32 API window creation process is divided into two steps. First, a Windows class needs to be registered, which was done in the <code class="literal">Application</code> constructor earlier. Then, the <code class="literal">Windows</code> class name is used in the call to the Win32 API <code class="literal">CreateWindowEx</code> function, which returns a handle to the window. If the size or position is zero, default values are used:</p><pre class="programlisting">    int left, top, width, height; &#13;
 &#13;
    if (windowTopLeft != ZeroPoint) { &#13;
      left = windowTopLeft.X(); &#13;
      top = windowTopLeft.Y(); &#13;
    } &#13;
    else { &#13;
      left = CW_USEDEFAULT; &#13;
      top = CW_USEDEFAULT; &#13;
    } &#13;
 &#13;
    if (windowSize != ZeroSize) { &#13;
      width = windowSize.Width(); &#13;
      height = windowSize.Height(); &#13;
    } &#13;
&#13;
    else { &#13;
      width = CW_USEDEFAULT; &#13;
      height = CW_USEDEFAULT; &#13;
    } &#13;
 &#13;
    HWND parentHandle = (parentPtr != nullptr) ? &#13;
                        parentPtr-&gt;windowHandle : nullptr; &#13;
 &#13;
    windowHandle = &#13;
      CreateWindowEx(extendedStyle, className.c_str(), &#13;
                     nullptr, style, left, top, width, height, &#13;
                     parentHandle,::CreateMenu(), &#13;
                     Application::InstanceHandle(), this); &#13;
 &#13;
    assert(windowHandle != nullptr); &#13;
</pre><p>In order for <code class="literal">WindowProc</code> to be able to receive messages and identify the recipient window, the handle is stored in <code class="literal">WindowMap</code>:</p><pre class="programlisting">    WindowMap[windowHandle] = this; &#13;
</pre><p>The Win32 API functions <code class="literal">ShowWindow</code> and <code class="literal">RegisterTouchWindow</code> are called to make the window visible in accordance with the <code class="literal">windowShow</code> parameter and to make the window receptive to touch movements:</p><pre class="programlisting">    ::ShowWindow(windowHandle, windowShow); &#13;
    ::RegisterTouchWindow(windowHandle, 0); &#13;
  } &#13;
</pre><p>The destructor calls <code class="literal">OnDestroy</code> and erases the window from <code class="literal">windowMap</code>. If the window has a parent window, it receives an input focus:</p><pre class="programlisting">  Window::~Window() { &#13;
    OnDestroy(); &#13;
    WindowMap.erase(windowHandle); &#13;
 &#13;
    if (parentPtr != nullptr) { &#13;
      parentPtr-&gt;SetFocus(); &#13;
    } &#13;
</pre><p>If the window is the application's main window, the Win32 API <code class="literal">PostQuitMessage</code> function is called. It posts a quit message, which is eventually caught by <code class="literal">RunMessageLoop</code> in the <code class="literal">Application</code> class that terminates the execution. Finally, the window is destroyed:</p><pre class="programlisting">    if (this == Application::MainWindowPtr()) { &#13;
      ::PostQuitMessage(0); &#13;
    } &#13;
 &#13;
    WindowMap.erase(windowHandle); &#13;
    ::DestroyWindow(windowHandle); &#13;
  } &#13;
</pre></div><div class="section" title="Header and visibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec88"/>Header and visibility</h2></div></div></div><p>The <code class="literal">ShowWindow</code> and <code class="literal">EnableWindow</code> methods call the Win32 API functions <code class="literal">ShowWindow</code> and <code class="literal">EnableWindow</code> with the window handle as their first parameter:</p><pre class="programlisting">  void Window::ShowWindow(bool visible) { &#13;
    ::ShowWindow(windowHandle, visible ? SW_SHOW : SW_HIDE); &#13;
  } &#13;
</pre><p>Note that the second parameter of <code class="literal">EnableWindow</code> is a value of the Win32 API type <code class="literal">BOOL</code>, which is not necessarily the same type as the C++ type <code class="literal">bool</code>. Therefore, since <code class="literal">enable</code> holds the type <code class="literal">bool</code> we need to convert it to <code class="literal">BOOL</code>:</p><pre class="programlisting">  void Window::EnableWindow(bool enable) { &#13;
    ::EnableWindow(windowHandle, enable ? TRUE : FALSE); &#13;
  } &#13;
</pre><p>The <code class="literal">SetHeader</code> method sets the title of the window by calling the Win32 API function <code class="literal">SetWindowText</code>. As <code class="literal">headerText</code> is a <code class="literal">String</code> object and <code class="literal">SetWindowText</code> wants a C string (a zero-terminated char pointer) as parameter, we need to call the <code class="literal">c_str</code> function:</p><pre class="programlisting">  void Window::SetHeader(String headerText) { &#13;
    ::SetWindowText(windowHandle, headerText.c_str()); &#13;
  } &#13;
</pre><p>The <code class="literal">SetTimer</code> and <code class="literal">DropTimer</code> methods turn the timer with the given identity on and off by calling the Win32 API functions <code class="literal">SetTimer</code> and <code class="literal">KillTimer</code>. The interval in the <code class="literal">SetTimer</code> call is given in milliseconds:</p><pre class="programlisting">  void Window::SetTimer(int timerId, unsigned int interval) { &#13;
    ::SetTimer(windowHandle, timerId, interval, nullptr); &#13;
  } &#13;
 &#13;
  void Window::DropTimer(int timerId) { &#13;
    ::KillTimer(windowHandle, timerId); &#13;
  } &#13;
</pre><p>The <code class="literal">SetFocus</code> method sets the focus by calling the corresponding Win32 API function <code class="literal">SetFocus</code>. The <code class="literal">HasFocus</code> method returns <code class="literal">true</code> if the window has the input focus by calling the <code class="literal">GetFocus</code> Win32 API function, which returns the handle to the window, holding the input focus that is compared to the window's handle:</p><pre class="programlisting">  void Window::SetFocus() const { &#13;
    ::SetFocus(windowHandle); &#13;
  } &#13;
 &#13;
  bool Window::HasFocus() const { &#13;
    return (::GetFocus() == windowHandle); &#13;
  } &#13;
</pre></div><div class="section" title="The touch screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec89"/>The touch screen</h2></div></div></div><p>The default behavior of <code class="literal">OnTouchDown</code>, <code class="literal">OnTouchMove</code>, and <code class="literal">OnTouchUp</code> is to call the corresponding mouse input method for each touch point, with no button and neither the <span class="emphasis"><em>
<span class="strong"><strong>Shift</strong></span>
</em></span> nor the <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> key pressed:</p><pre class="programlisting">  void Window::OnTouchDown(vector&lt;Point&gt; pointList) { &#13;
    for (Point touchPoint : pointList) { &#13;
      OnMouseDown(NoButton, touchPoint, false, false); &#13;
    } &#13;
  } &#13;
 &#13;
  void Window::OnTouchMove(vector&lt;Point&gt; pointList) { &#13;
    for (Point touchPoint : pointList) { &#13;
      OnMouseMove(NoButton, touchPoint, false, false); &#13;
    } &#13;
  } &#13;
 &#13;
  void Window::OnTouchUp(vector&lt;Point&gt; pointList) { &#13;
    for (Point touchPoint : pointList) { &#13;
      OnMouseUp(NoButton, touchPoint, false, false); &#13;
    } &#13;
  } &#13;
</pre><p>With a modern screen, the user can touch the screen in ways similar to mouse clicks. However, the user can touch the screen at several locations at once, and its positions are stored in a point list. The <code class="literal">OnTouch</code> method is an auxiliary method calling <code class="literal">OnTouchDown</code>, <code class="literal">OnTouchMove</code>, and <code class="literal">OnTouchUp</code> when the user touches the screen. It creates a list of points in logical coordinates:</p><pre class="programlisting">  void OnTouch(Window* windowPtr, WPARAM wordParam, &#13;
               LPARAM longParam, Point windowTopLeft) { &#13;
    UINT inputs = LOWORD(wordParam); &#13;
    HTOUCHINPUT touchInputHandle = (HTOUCHINPUT) longParam; &#13;
 &#13;
    TOUCHINPUT* inputArray = new TOUCHINPUT[inputs]; &#13;
    assert(inputArray != nullptr); &#13;
 &#13;
    if (::GetTouchInputInfo(touchInputHandle, inputs, &#13;
                            inputArray, sizeof(TOUCHINPUT))){ &#13;
      vector&lt;Point&gt; pointList; &#13;
 &#13;
      for (UINT index = 0; index &lt; inputs; ++index) { &#13;
        Point touchPoint &#13;
          ((inputArray[index].x / 100) - windowTopLeft.X(), &#13;
           (inputArray[index].y / 100) - windowTopLeft.Y()); &#13;
        pointList.push_back(touchPoint); &#13;
      } &#13;
</pre><p>If the touch identity does not equal the first value in the input array, we have a touch down event; if it does, we have a touch move event:</p><pre class="programlisting">      static DWORD touchId = -1; &#13;
      if (touchId != inputArray[0].dwID) { &#13;
        touchId = inputArray[0].dwID; &#13;
        windowPtr-&gt;OnTouchDown(pointList); &#13;
      } &#13;
      else { &#13;
        windowPtr-&gt;OnTouchMove(pointList); &#13;
      } &#13;
 &#13;
      ::CloseTouchInputHandle(touchInputHandle); &#13;
    } &#13;
 &#13;
    delete [] inputArray; &#13;
  } &#13;
</pre></div><div class="section" title="Invalidation and window updates"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec90"/>Invalidation and window updates</h2></div></div></div><p>When the window's client area needs to be (partly or completely) repainted, one of the <code class="literal">Invalidate</code> methods is called. The <code class="literal">Invalidate</code> methods call the Win32 API function <code class="literal">InvalicateRect</code>, which posts a message that results in a call to <code class="literal">OnPaint</code> when <code class="literal">UpdateWindow</code> is called. The <code class="literal">clear</code> parameter indicates whether the invalidated area should be cleared (repainted with the window client area's color) before it is redrawn, which normally is the case. Similar to the <code class="literal">EnableWindow</code> method we saw earlier, we need to convert <code class="literal">clear</code> from type <code class="literal">bool</code> to <code class="literal">BOOL</code>:</p><pre class="programlisting">  void Window::Invalidate(bool clear /* = true */) const { &#13;
    ::InvalidateRect(windowHandle, nullptr, clear ? TRUE : FALSE); &#13;
  } &#13;
</pre><p>The <code class="literal">Invalidate</code> method transforms the area from logical to device coordinates before the call to the Win32 API function <code class="literal">InvalidateRect</code> and stores the size in a <code class="literal">RECT</code> structure:</p><pre class="programlisting">  void Window::Invalidate(Rect areaRect, bool clear /* = true */) &#13;
                          const { &#13;
    RECT rect = (RECT) LogicalToDevice(areaRect); &#13;
    ::InvalidateRect(windowHandle, &amp;rect, clear ? TRUE : FALSE); &#13;
  } &#13;
</pre><p>The <code class="literal">UpdateWindow</code> method calls the Win32 API function <code class="literal">UpdateWindow</code>, which eventually results in a call to <code class="literal">OnPaint</code>:</p><pre class="programlisting">  void Window::UpdateWindow() { &#13;
    ::UpdateWindow(windowHandle); &#13;
  } &#13;
</pre></div><div class="section" title="Preparing the device context"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec91"/>Preparing the device context</h2></div></div></div><p>When painting the windows's client area, we need a device context, which we need to prepare in accordance with the coordinate system in order to paint with logical coordinates. The Win32 API function <code class="literal">SetMapMode</code> sets the mapping mode of the logical coordinate system. <code class="literal">MISOTROPIC</code> forces that the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axis to have the same unit length (resulting in non-elliptic circles) that is suitable for the <code class="literal">LogicalWithScroll</code> and <code class="literal">LogicalWithoutScroll</code> systems, while <code class="literal">MANISOTROPIC</code> allows different unit lengths that are suitable for the <code class="literal">PreviewCoordinate</code> system. We establish a mapping between the logical and device systems by calling the Win32 API functions <code class="literal">SetWindowExtEx</code>, which takes the logical size of the client area, and <code class="literal">SetViewportExtEx</code>, which takes its physical (device) size.</p><p>In the case of the <code class="literal">PreviewCoordinate</code> system, we simply match the logical size (<code class="literal">pageSize</code>) of the client area to its device size (<code class="literal">clientDeviceRect</code>), given by the Win32 API function <code class="literal">GetClientRect</code>, resulting in the client area always having the same logical size, regardless of its physical size:</p><pre class="programlisting">  void Window::PrepareDeviceContext(HDC deviceContextHandle)const{ &#13;
    switch (system) { &#13;
      case PreviewCoordinate: { &#13;
        RECT clientDeviceRect; &#13;
        ::GetClientRect(windowHandle, &amp;clientDeviceRect); &#13;
 &#13;
        ::SetMapMode(deviceContextHandle, MM_ANISOTROPIC); &#13;
        ::SetWindowExtEx(deviceContextHandle, pageSize.Width(), &#13;
                         pageSize.Height(), nullptr); &#13;
&#13;
        ::SetViewportExtEx(deviceContextHandle, &#13;
                           clientDeviceRect.right, &#13;
                           clientDeviceRect.bottom, nullptr); &#13;
      } &#13;
      break; &#13;
</pre><p>In the case of the logical coordinate system, we need to find the ratio between logical coordinates (hundreds of millimeters) and device coordinates (pixels). In other words, we need to establish the logical size of a pixel. We can find the number of pixels on the screen by calling the Win32 API function <code class="literal">GetDeviceCaps</code> with <code class="literal">HORZSIZE</code> and <code class="literal">VERTSIZE</code>, and the size of the screen in millimeters with <code class="literal">HORZRES</code> and <code class="literal">VERTRES</code>. We multiply the logical size by 100, since we have hundreds of millimeters as our logical unit. We also need to take into account the zooming factor of the window, which we do by multiplying the physical size by <code class="literal">zoom</code>.</p><p>Note that it's only in the <code class="literal">PreviewCoordinate</code> system that the client area always has the same logical size. In the other systems, the logical size changes when the size of the window is changed. The logical units are always the same in <code class="literal">LogicalWithScroll</code> and <code class="literal">LogicalWithoutScroll</code>: hundreds of millimeters:</p><pre class="programlisting">      case LogicalWithScroll: &#13;
      case LogicalWithoutScroll: &#13;
        ::SetMapMode(deviceContextHandle, MM_ISOTROPIC); &#13;
 &#13;
        { int horizontalSize = &#13;
                100 * GetDeviceCaps(deviceContextHandle,HORZSIZE), &#13;
              verticalSize = &#13;
                100 * GetDeviceCaps(deviceContextHandle,VERTSIZE); &#13;
          ::SetWindowExtEx(deviceContextHandle, horizontalSize, &#13;
                           verticalSize, nullptr); &#13;
        } &#13;
 &#13;
        { int horizontalResolution = (int)  &#13;
               (zoom*GetDeviceCaps(deviceContextHandle, HORZRES)), &#13;
             verticalResolution = (int)  &#13;
               (zoom*GetDeviceCaps(deviceContextHandle, VERTRES)); &#13;
          ::SetViewportExtEx(deviceContextHandle, &#13;
               horizontalResolution, verticalResolution, nullptr); &#13;
        } &#13;
</pre><p>In the case of the <code class="literal">LogicalWithScroll</code> logical coordinate system, we also need to adjust the origin of the window in accordance with the current scroll settings by calling the Win32 API function <code class="literal">SetWindowOrg</code>:</p><pre class="programlisting">        if (system == LogicalWithScroll) { &#13;
          int horizontalScroll = &#13;
                ::GetScrollPos(windowHandle, SB_HORZ), &#13;
              verticalScroll = &#13;
                ::GetScrollPos(windowHandle, SB_VERT); &#13;
          ::SetWindowOrgEx(deviceContextHandle, horizontalScroll, &#13;
                           verticalScroll, nullptr); &#13;
        } &#13;
        break; &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Unit transformation"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec92"/>Unit transformation</h2></div></div></div><p>The <code class="literal">DeviceToLogical</code> method transforms the device coordinates of a point, rectangle, or size to logical coordinates by preparing the device context and then calling the Win32 API function <code class="literal">DPtoLP</code> (Device Point to Logical Point). Note that we establish the device context by calling the Win32 API function <code class="literal">GetDC</code> and we need to return it by calling <code class="literal">ReleaseDC</code>. Also, note that we need to convert the <code class="literal">Point</code> object to a <code class="literal">POINT</code> structure and back again, since <code class="literal">DPtoLP</code> takes a pointer to a <code class="literal">POINT</code>:</p><pre class="programlisting">  Point Window::DeviceToLogical(Point point) const { &#13;
    HDC deviceContextHandle = ::GetDC(windowHandle); &#13;
    PrepareDeviceContext(deviceContextHandle); &#13;
    POINT pointStruct = (POINT) point; &#13;
    ::DPtoLP(deviceContextHandle, &amp;pointStruct, 1); &#13;
    ::ReleaseDC(windowHandle, deviceContextHandle); &#13;
    return Point(pointStruct); &#13;
  } &#13;
</pre><p>When transforming a rectangle, we use the point method to transform its top-left and bottom-right corners. When transforming a size, we create a rectangle, call the rectangle method, and convert the rectangle to a size:</p><pre class="programlisting">  Rect Window::DeviceToLogical(Rect rect) const { &#13;
    return Rect(DeviceToLogical(rect.TopLeft()), &#13;
                DeviceToLogical(rect.BottomRight())); &#13;
  } &#13;
 &#13;
  Size Window::DeviceToLogical(Size size) const { &#13;
    return ((Size) DeviceToLogical(Rect(ZeroPoint, size))); &#13;
  } &#13;
</pre><p>The <code class="literal">LogicalToDevice</code> method transforms the point, rectangle, or size from logical to device coordinates calling the Win32 API function <code class="literal">LPtoDP</code> (Logical Point to Device Point) in the same manner as the earlier methods. The only difference is that they call <code class="literal">LPtoDP</code> instead of <code class="literal">DPtoLP</code>:</p><pre class="programlisting">  Point Window::LogicalToDevice(Point point) const { &#13;
    HDC deviceContextHandle = ::GetDC(windowHandle); &#13;
    PrepareDeviceContext(deviceContextHandle); &#13;
    POINT pointStruct = (POINT) point; &#13;
    ::LPtoDP(deviceContextHandle, &amp;pointStruct, 1); &#13;
    ::ReleaseDC(windowHandle, deviceContextHandle); &#13;
    return Point(pointStruct); &#13;
  } &#13;
 &#13;
  Rect Window::LogicalToDevice(Rect rect) const { &#13;
    return Rect(LogicalToDevice(rect.TopLeft()), &#13;
                LogicalToDevice(rect.BottomRight())); &#13;
  } &#13;
 &#13;
  Size Window::LogicalToDevice(Size size) const { &#13;
    return ((Size) LogicalToDevice(Rect(ZeroPoint, size))); &#13;
  } &#13;
</pre></div><div class="section" title="Window size and position"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec93"/>Window size and position</h2></div></div></div><p>The <code class="literal">GetWindowDevicePosition</code>, <code class="literal">SetWindowDevicePosition</code>, <code class="literal">GetWindowDeviceSize</code>, <code class="literal">SetWindowDeviceSize</code>, and <code class="literal">GetClientDeviceSize</code> methods call the corresponding Win32 API functions <code class="literal">GetWindowRect</code>, <code class="literal">GetClientRect</code>, and <code class="literal">SetWindowPos</code>:</p><pre class="programlisting">  Point Window::GetWindowDevicePosition() const { &#13;
    return GetWindowDeviceRect().TopLeft(); &#13;
  } &#13;
 &#13;
  void Window::SetWindowDevicePosition(Point topLeft) { &#13;
    ::SetWindowPos(windowHandle, nullptr, topLeft.X(), &#13;
                   topLeft.Y(), 0, 0, SWP_NOSIZE); &#13;
  } &#13;
 &#13;
  Size Window::GetWindowDeviceSize() const { &#13;
    return GetWindowDeviceRect().GetSize(); &#13;
  } &#13;
 &#13;
  void Window::SetWindowDeviceSize(Size windowSize) { &#13;
    ::SetWindowPos(windowHandle, nullptr, 0, 0, &#13;
               windowSize.Width(),windowSize.Height(),SWP_NOMOVE); &#13;
  } &#13;
 &#13;
&#13;
  Size Window::GetClientDeviceSize() const { &#13;
    RECT rectStruct; &#13;
    ::GetClientRect(windowHandle, &amp;rectStruct); &#13;
    return Size(rectStruct.right, rectStruct.bottom); &#13;
  } &#13;
 &#13;
  Rect Window::GetWindowDeviceRect() const { &#13;
    RECT windowRect; &#13;
    ::GetWindowRect(windowHandle, &amp;windowRect); &#13;
    POINT topLeft = {windowRect.left, windowRect.top}, &#13;
          bottomRight = {windowRect.right, windowRect.bottom}; &#13;
 &#13;
    if (parentPtr != nullptr) { &#13;
      ::ScreenToClient(parentPtr-&gt;windowHandle, &amp;topLeft); &#13;
      ::ScreenToClient(parentPtr-&gt;windowHandle, &amp;bottomRight); &#13;
    } &#13;
 &#13;
    return Rect(Point(topLeft), Point(bottomRight)); &#13;
  } &#13;
 &#13;
  void Window::SetWindowDeviceRect(Rect windowRect) { &#13;
    SetWindowDevicePosition(windowRect.TopLeft()); &#13;
    SetWindowDeviceSize(windowRect.GetSize()); &#13;
  } &#13;
</pre><p>The <code class="literal">GetWindowPosition</code>, <code class="literal">SetWindowPosition</code>, <code class="literal">GetWindowSize</code>, <code class="literal">SetWindowSize</code>, and <code class="literal">GetClientSize</code> methods call the corresponding device methods together with <code class="literal">LogicalToDevice</code> or <code class="literal">DeviceToLogical</code>:</p><pre class="programlisting">  Point Window::GetWindowPosition() const { &#13;
    return DeviceToLogical(GetWindowDevicePosition()); &#13;
  } &#13;
 &#13;
  void Window::SetWindowPosition(Point topLeft) { &#13;
    SetWindowDevicePosition(LogicalToDevice(topLeft)); &#13;
  } &#13;
 &#13;
  Size Window::GetWindowSize() const { &#13;
    return DeviceToLogical(GetWindowDeviceSize()); &#13;
  } &#13;
 &#13;
  void Window::SetWindowSize(Size windowSize) { &#13;
    SetWindowDeviceSize(LogicalToDevice(windowSize)); &#13;
  } &#13;
 &#13;
  Size Window::GetClientSize() const { &#13;
    return DeviceToLogical(GetClientDeviceSize()); &#13;
  } &#13;
 &#13;
  Rect Window::GetWindowRect() const { &#13;
    return DeviceToLogical(GetWindowDeviceRect()); &#13;
  } &#13;
 &#13;
  void Window::SetWindowRect(Rect windowRect) { &#13;
    SetWindowDeviceRect(LogicalToDevice(windowRect)); &#13;
  } &#13;
</pre></div><div class="section" title="Text metrics"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec94"/>Text metrics</h2></div></div></div><p>Given a font, <code class="literal">CreateTextMetric</code> creates a metric structure holding the height, ascent line, and average width of a character of the font. The <code class="literal">CreateFontIndirect</code> and <code class="literal">SelectObject</code> methods prepare the font for <code class="literal">GetTextExtentPoint</code>:</p><pre class="programlisting">  TEXTMETRIC Window::CreateTextMetric(Font font) const { &#13;
    font.PointsToLogical(); &#13;
 &#13;
    HDC deviceContextHandle = ::GetDC(windowHandle); &#13;
    PrepareDeviceContext(deviceContextHandle); &#13;
 &#13;
    HFONT fontHandle = ::CreateFontIndirect(&amp;font.LogFont()); &#13;
    HFONT oldFontHandle = &#13;
      (HFONT) ::SelectObject(deviceContextHandle, fontHandle); &#13;
 &#13;
    TEXTMETRIC textMetric; &#13;
    ::GetTextMetrics(deviceContextHandle, &amp;textMetric); &#13;
</pre><p>Note that <code class="literal">CreateFontIndirect</code> must be matched by <code class="literal">DeleteObject</code> and the first call to <code class="literal">SelectObject</code> must be matched by a second call to <code class="literal">SelectObject</code> to reinstall the original object:</p><pre class="programlisting">    ::SelectObject(deviceContextHandle, oldFontHandle); &#13;
    ::DeleteObject(fontHandle); &#13;
</pre><p>Also, note that the device context received from <code class="literal">GetDC</code> must be released with <code class="literal">ReleaseDC</code>:</p><pre class="programlisting">    ::ReleaseDC(windowHandle, deviceContextHandle); &#13;
    return textMetric; &#13;
  } &#13;
</pre><p>The <code class="literal">GetCharacterHeight</code>, <code class="literal">GetCharacterAscent</code>, and <code class="literal">GetCharacterAverageWidth</code> methods call <code class="literal">CreateTextMetric</code> and return the relevant information:</p><pre class="programlisting">  int Window::GetCharacterHeight(Font font) const { &#13;
    return CreateTextMetric(font).tmHeight; &#13;
  } &#13;
 &#13;
  int Window::GetCharacterAscent(Font font) const { &#13;
    return CreateTextMetric(font).tmAscent; &#13;
  } &#13;
 &#13;
  int Window::GetCharacterAverageWidth(Font font) const { &#13;
    return CreateTextMetric(font).tmAveCharWidth; &#13;
  } &#13;
</pre><p>The <code class="literal">GetCharacterWidth</code> method calls <code class="literal">GetTextExtentPoint</code> to establish the width of a character of the given font. Since the font height is given in typographical points (1 point = 1/72 of an inch = 1/72 * 25.4 mm ≈≈ 0.35 mm) and needs to be given in millimeters, we call <code class="literal">PointsToLogical</code>. Similar to what we did earlier in <code class="literal">CreateTextMetric</code>, <code class="literal">CreateFontIndirect</code> and <code class="literal">SelectObject</code> prepare the font for <code class="literal">GetTextExtentPoint</code>:</p><pre class="programlisting">  int Window::GetCharacterWidth(Font font, TCHAR tChar) const { &#13;
    font.PointsToLogical(); &#13;
 &#13;
    HDC deviceContextHandle = ::GetDC(windowHandle); &#13;
    PrepareDeviceContext(deviceContextHandle); &#13;
 &#13;
    HFONT fontHandle = ::CreateFontIndirect(&amp;font.LogFont()); &#13;
    HFONT oldFontHandle = &#13;
      (HFONT) ::SelectObject(deviceContextHandle, fontHandle); &#13;
 &#13;
    SIZE szChar; &#13;
    ::GetTextExtentPoint(deviceContextHandle, &amp;tChar, 1, &amp;szChar); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldFontHandle); &#13;
    ::DeleteObject(fontHandle); &#13;
    ::ReleaseDC(windowHandle, deviceContextHandle); &#13;
 &#13;
    return szChar.cx; &#13;
  } &#13;
</pre></div><div class="section" title="Closing the window"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec95"/>Closing the window</h2></div></div></div><p>When the user tries to close the window, the <code class="literal">Window</code> object (<code class="literal">this</code>) is deleted if <code class="literal">TryClose</code> returns <code class="literal">true</code>:</p><pre class="programlisting">  void Window::OnClose() { &#13;
    if (TryClose()) { &#13;
      delete this; &#13;
    } &#13;
  } &#13;
</pre></div><div class="section" title="The MessageBox method"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec96"/>The MessageBox method</h2></div></div></div><p>The <code class="literal">MessageBox</code> method displays a message box holding a caption, a message, a combination of buttons (<span class="strong"><strong>OK</strong></span>, <span class="strong"><strong>OK-Cancel</strong></span>, <span class="strong"><strong>Retry-Cancel</strong></span>, <span class="strong"><strong>Yes-No</strong></span>, <span class="strong"><strong>Yes-No-Cancel</strong></span>, <span class="strong"><strong>Cancel-Try-Continue</strong></span>, or <span class="strong"><strong>Abort-Retry-Ignore</strong></span>), an optional icon (<span class="strong"><strong>Information</strong></span>, <span class="strong"><strong>Stop</strong></span>, <span class="strong"><strong>Warning</strong></span>, or <span class="strong"><strong>Question</strong></span>), and an optional H<span class="strong"><strong>elp</strong></span> button. It returns the answer <span class="strong"><strong>OK Answer</strong></span> (since OK is already taken by the <code class="literal">ButtonGroup</code> enumeration), <span class="strong"><strong>Cancel</strong></span>, <span class="strong"><strong>Yes</strong></span>, <span class="strong"><strong>No</strong></span>, <span class="strong"><strong>Retry</strong></span>, <span class="strong"><strong>Continue</strong></span>, <span class="strong"><strong>Abort</strong></span>, or <span class="strong"><strong>Ignore</strong></span>:</p><pre class="programlisting">  Answer Window::MessageBox(String message, &#13;
                            String caption /*=TEXT("Error")*/, &#13;
                            ButtonGroup buttonGroup /* = Ok */, &#13;
                            Icon icon /* = NoIcon */, &#13;
                            bool help /* = false */) const { &#13;
    return (Answer) ::MessageBox(windowHandle, message.c_str(), &#13;
                                 caption.c_str(), buttonGroup | &#13;
                                 icon | (help ? MB_HELP : 0)); &#13;
  } &#13;
</pre><p>When a window is created by calling <code class="literal">CreateWindowEx</code> in the <code class="literal">Window</code> class constructor, the name of a <code class="literal">Windows</code> class that has earlier been given by the <code class="literal">Application</code> class constructor is enclosed. When the class is registered, a freestanding function is also given. For the <code class="literal">Window</code> class, the function is <code class="literal">WindowProc</code>, which is thereby called every time the window receives a message.</p><p>The <code class="literal">wordParam</code> and <code class="literal">longParam</code> parameters (<code class="literal">WPARAM</code> and <code class="literal">LPARAM</code> are both 4 bytes) hold message-specific information, which may be divided into low and high words (2 bytes) with the <code class="literal">LOWORD</code> and <code class="literal">HIWORD</code> macros:</p><pre class="programlisting">  LRESULT CALLBACK WindowProc(HWND windowHandle, UINT message, &#13;
                              WPARAM wordParam, LPARAM longParam){ &#13;
</pre><p>First we need to find the <code class="literal">Window</code> object associated with the window handle by looking up the handle in the static field <code class="literal">WindowMap</code>:</p><pre class="programlisting">    if (WindowMap.count(windowHandle) == 1) { &#13;
      Window* windowPtr = WindowMap[windowHandle]; &#13;
</pre><p>When receiving the <code class="literal">WSETFOCUS</code>, <code class="literal">WKILLFOCUS</code>, and <code class="literal">WTIMER</code> messages, the corresponding methods in <code class="literal">Window</code> are simply called. When the messages have been handled, they do not need to be further processed; therefore, zero is returned:</p><pre class="programlisting">      switch (message) { &#13;
        case WM_SETFOCUS: &#13;
          windowPtr-&gt;OnGainFocus(); &#13;
          return 0; &#13;
 &#13;
        case WM_KILLFOCUS: &#13;
          windowPtr-&gt;OnLoseFocus(); &#13;
          return 0; &#13;
</pre><p>The identity of the timer (the <code class="literal">timerId</code> parameter in <code class="literal">SetTimer</code> and <code class="literal">DropTimer</code>) is stored in <code class="literal">wordParam</code>:</p><pre class="programlisting">        case WM_TIMER: &#13;
          windowPtr-&gt;OnTimer((int) wordParam); &#13;
          return 0; &#13;
</pre><p>When receiving the <code class="literal">WMOVE</code> and <code class="literal">WSIZE</code> messages, the <code class="literal">Point</code> value stored in <code class="literal">longParam</code> is given in device units that need to be transformed into logical units by calling <code class="literal">DeviceToLogical</code> in the calls to <code class="literal">OnMove</code> and <code class="literal">OnSize</code> in <code class="literal">Window</code>:</p><pre class="programlisting">        case WM_MOVE: { &#13;
            Point windowTopLeft = &#13;
              {LOWORD(longParam), HIWORD(longParam)}; &#13;
            windowPtr-&gt;OnMove &#13;
                     (windowPtr-&gt;DeviceToLogical(windowTopLeft)); &#13;
          } &#13;
          return 0; &#13;
 &#13;
        case WM_SIZE: { &#13;
            Size clientSize = &#13;
              {LOWORD(longParam), HIWORD(longParam)}; &#13;
            windowPtr-&gt; &#13;
              OnSize(windowPtr-&gt;DeviceToLogical(clientSize)); &#13;
          } &#13;
          return 0; &#13;
</pre><p>If the user presses the <span class="emphasis"><em>
<span class="strong"><strong>F1</strong></span>
</em></span> key or the <span class="strong"><strong>Help</strong></span> button in a message box, the <code class="literal">WM_HELP</code> message is sent. We call <code class="literal">OnHelp</code> in <code class="literal">Window</code>:</p><pre class="programlisting">        case WM_HELP: &#13;
          windowPtr-&gt;OnHelp(); &#13;
          break; &#13;
</pre><p>When handling mouse or keyboard input messages, it is useful to decide whether the user simultaneously presses the <span class="emphasis"><em>
<span class="strong"><strong>Shift</strong></span>
</em></span> or <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> key. This can be established by calling the Win32 API function, <code class="literal">GetKeyState</code>, which returns an integer value less than zero if the key is pressed when called with <code class="literal">VK_SHIFT</code> or <code class="literal">VK_CONTROL</code>:</p><pre class="programlisting">        case WM_KEYDOWN: { &#13;
            WORD key = wordParam; &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
</pre><p>If <code class="literal">OnKeyDown</code> returns <code class="literal">true</code>, the key message has been processed and we return zero. If it returns <code class="literal">false</code>, the Win32 API function <code class="literal">DefWindowProc</code>, as shown here, will be called, which further processes the message:</p><pre class="programlisting">            if (windowPtr-&gt;OnKeyDown(wordParam, shiftPressed, &#13;
                                     controlPressed)) { &#13;
              return 0; &#13;
            } &#13;
          } &#13;
          break; &#13;
</pre><p>If the pressed key is a graphical character (ASCII numbers between 32 and 127, inclusive), <code class="literal">OnChar</code> is called:</p><pre class="programlisting">        case WM_CHAR: { &#13;
            int asciiCode = (int) wordParam; &#13;
 &#13;
            if ((asciiCode &gt;= 32) &amp;&amp; (asciiCode &lt;= 127)) { &#13;
              windowPtr-&gt;OnChar((TCHAR) asciiCode); &#13;
              return 0; &#13;
            } &#13;
          } &#13;
          break; &#13;
 &#13;
        case WM_KEYUP: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
 &#13;
            if (windowPtr-&gt;OnKeyUp(wordParam, shiftPressed, &#13;
                                   controlPressed)) { &#13;
              return 0; &#13;
            } &#13;
          } &#13;
          break; &#13;
</pre><p>All mouse input points stored in <code class="literal">longParam</code> are given in device coordinates, which need to be transformed into logical coordinates by <code class="literal">DeviceToLogical</code>. The mouse-down message is normally followed by the corresponding mouse-up message. Unfortunately, that is not the case if the user presses the mouse button in one window and releases it in another window, in which case the mouse-up message is sent to the other window. However, the problem can be solved by the Win32 API function, <code class="literal">SetCapture</code>, which makes sure that every mouse message is sent to the window until <code class="literal">ReleaseCapture</code> is called:</p><pre class="programlisting">        case WM_LBUTTONDOWN: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            ::SetCapture(windowPtr-&gt;windowHandle); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnMouseDown(LeftButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
          } &#13;
          return 0; &#13;
 &#13;
        case WM_MBUTTONDOWN: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            ::SetCapture(windowPtr-&gt;windowHandle); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnMouseDown(MiddleButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
          } &#13;
          return 0; &#13;
 &#13;
        case WM_RBUTTONDOWN: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            ::SetCapture(windowPtr-&gt;windowHandle); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnMouseDown(RightButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
          } &#13;
          return 0; &#13;
</pre><p>When the user moves the mouse, they may at the same time press a combination of buttons, stored in <code class="literal">buttonMask</code>:</p><pre class="programlisting">        case WM_MOUSEMOVE: { &#13;
            MouseButton buttonMask = (MouseButton) &#13;
              (((wordParam &amp; MK_LBUTTON) ? LeftButton : 0) | &#13;
               ((wordParam &amp; MK_MBUTTON) ? MiddleButton : 0) | &#13;
               ((wordParam &amp; MK_RBUTTON) ? RightButton : 0)); &#13;
&#13;
 &#13;
            if (buttonMask != NoButton) { &#13;
              bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
              bool controlPressed = (::GetKeyState(VK_CONTROL)&lt;0); &#13;
              Point mousePoint = &#13;
                Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
              windowPtr-&gt;OnMouseMove(buttonMask, &#13;
                           windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                           shiftPressed, controlPressed); &#13;
            } &#13;
          } &#13;
          return 0; &#13;
</pre><p>Note that <code class="literal">ReleaseCapture</code> is called at the end of the mouse-up methods in order to release the mouse message from the window and make it possible for mouse messages to be sent to other windows:</p><pre class="programlisting">        case WM_LBUTTONUP: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnMouseUp(LeftButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
            ::ReleaseCapture(); &#13;
          } &#13;
          return 0;  &#13;
&#13;
        case WM_MBUTTONUP: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnMouseUp(MiddleButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
            ::ReleaseCapture(); &#13;
          } &#13;
          return 0; &#13;
&#13;
        case WM_RBUTTONUP: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnMouseUp(RightButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
            ::ReleaseCapture(); &#13;
          } &#13;
          return 0;  &#13;
&#13;
        case WM_LBUTTONDBLCLK: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnDoubleClick(LeftButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
          } &#13;
          return 0;  &#13;
&#13;
        case WM_MBUTTONDBLCLK: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnDoubleClick(MiddleButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
          } &#13;
          return 0;  &#13;
&#13;
        case WM_RBUTTONDBLCLK: { &#13;
            bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
            bool controlPressed = (::GetKeyState(VK_CONTROL) &lt; 0); &#13;
            Point mousePoint = &#13;
              Point({LOWORD(longParam), HIWORD(longParam)}); &#13;
            windowPtr-&gt;OnDoubleClick(RightButton, &#13;
                         windowPtr-&gt;DeviceToLogical(mousePoint), &#13;
                         shiftPressed, controlPressed); &#13;
          } &#13;
          return 0; &#13;
</pre><p>When a touch message is sent, <code class="literal">OnTouch</code> is called, which needs the position of the window in device units:</p><pre class="programlisting">        case WM_TOUCH: &#13;
          OnTouch(windowPtr, wordParam, longParam, &#13;
                  windowPtr-&gt;GetWindowDevicePosition()); &#13;
          return 0; &#13;
</pre><p>When creating a device context in response to a paint message, we use the Win32 API functions <code class="literal">BeginPaint</code> and <code class="literal">EndPaint</code> instead of <code class="literal">GetDC</code> and <code class="literal">ReleaseDC</code> to handle the device context. However, the device context still needs to be prepared for the window's coordinate system, which is accomplished by <code class="literal">PrepareDeviceContext</code>:</p><pre class="programlisting">        case WM_PAINT: { &#13;
            PAINTSTRUCT paintStruct; &#13;
            HDC deviceContextHandle = &#13;
              ::BeginPaint(windowHandle,&amp;paintStruct); &#13;
            windowPtr-&gt;PrepareDeviceContext(deviceContextHandle); &#13;
            Graphics graphics(windowPtr, deviceContextHandle); &#13;
            windowPtr-&gt;OnPaint(graphics); &#13;
            ::EndPaint(windowHandle, &amp;paintStruct); &#13;
          } &#13;
          return 0; &#13;
</pre><p>When the user tries to close the window by clicking on the close box in the top-right corner, <code class="literal">OnClose</code> is called. It calls <code class="literal">TryClose</code> and closes the window if <code class="literal">TryClose</code> returns true:</p><pre class="programlisting">        case WM_CLOSE: &#13;
          windowPtr-&gt;OnClose(); &#13;
          return 0; &#13;
      } &#13;
    } &#13;
</pre><p>If we reach this point, the Win32 API function <code class="literal">DefWindowProc</code> is called, which performs the default message handling:</p><pre class="programlisting">    return DefWindowProc(windowHandle, message, wordParam, longParam); &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div class="section" title="The Graphics class"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec51"/>The Graphics class</h1></div></div></div><p>The <code class="literal">Graphics</code> class is a wrapper class for a device context. It also provides functionality for drawing lines, rectangles, and ellipses; writing text; saving and restoring graphic states; setting the origin of the device context; and clipping the painting area. The constructor is private since <code class="literal">Graphics</code> objects are intended to be created internally by Small Windows only.</p><p>
<span class="strong"><strong>Graphics.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
</pre><p>When drawing a line, it can be solid, dashed, dotted, dashed and dotted, as well as dashed and double-dotted:</p><pre class="programlisting">  class Window; &#13;
  enum PenStyle {Solid = PS_SOLID, Dash = PS_DASH, Dot = PS_DOT, &#13;
                 DashDot = PS_DASHDOT, DashDotDot =PS_DASHDOTDOT};&#13;
  class Graphics { &#13;
    private: &#13;
      Graphics(Window* windowPtr, HDC deviceContextHandle); &#13;
</pre><p>The <code class="literal">Save</code> method saves the current state of the <code class="literal">Graphics</code> object and <code class="literal">Restore</code> restores it:</p><pre class="programlisting">    public: &#13;
      int Save(); &#13;
      void Restore(int saveId); &#13;
</pre><p>The <code class="literal">SetOrigin</code> method sets the origin of the coordinate system and <code class="literal">IntersectClip</code> restricts the area to be painted:</p><pre class="programlisting">      void SetOrigin(Point centerPoint); &#13;
      void IntersectClip(Rect clipRect); &#13;
</pre><p>The following methods draw lines, rectangles, and ellipses, and write text:</p><pre class="programlisting">      void DrawLine(Point startPoint, Point endPoint, &#13;
                    Color penColor, PenStyle penStyle = Solid); &#13;
      void DrawRectangle(Rect rect, Color penColor, &#13;
                         PenStyle = Solid); &#13;
      void FillRectangle(Rect rect, Color penColor, &#13;
                       Color brushColor, PenStyle penStyle=Solid); &#13;
      void DrawEllipse(Rect rect, Color penColor, &#13;
                       PenStyle = Solid); &#13;
      void FillEllipse(Rect rect, Color penColor, &#13;
                       Color brushColor, PenStyle penStyle=Solid); &#13;
      void DrawText(Rect areaRect, String text, Font font, &#13;
                    Color textColor, Color backColor, &#13;
                    bool pointsToMeters = true); &#13;
</pre><p>The <code class="literal">GetDeviceContextHandle</code> method returns the device context wrapped by the <code class="literal">Graphics</code> object:</p><pre class="programlisting">      HDC GetDeviceContextHandle() const &#13;
                                   {return deviceContextHandle;} &#13;
</pre><p>The <code class="literal">windowPtr</code> field holds a pointer to the window about which client area is to be drawn, and <code class="literal">deviceContextHandle</code> holds the handle to the device context, of type <code class="literal">HDC</code>:</p><pre class="programlisting">    private: &#13;
      Window* windowPtr; &#13;
      HDC deviceContextHandle; &#13;
</pre><p>The <code class="literal">WindowProc</code> and <code class="literal">DialogProc</code> functions are friends of the <code class="literal">Graphics</code> class, since they need access to its private members. This is the same for the <code class="literal">PrintDialog</code> methods of the <code class="literal">StandardDialog</code> class:</p><pre class="programlisting">      friend LRESULT CALLBACK &#13;
        WindowProc(HWND windowHandle, UINT message, &#13;
                   WPARAM wordParam, LPARAM longParam); &#13;
      friend Graphics* StandardDialog::PrintDialog &#13;
                               (Window*parentPtr,int totalPages, &#13;
                                int&amp; firstPage, int&amp; lastPage, &#13;
                                int&amp; copies, bool&amp; sorted); &#13;
  }; &#13;
};</pre><p>
<span class="strong"><strong>Graphics.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h"</pre><p>The constructor initializes the window pointer and device context:</p><pre class="programlisting">namespace SmallWindows { &#13;
  Graphics::Graphics(Window* windowPtr, HDC deviceContextHandle) &#13;
   :windowPtr(windowPtr), &#13;
    deviceContextHandle(deviceContextHandle) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>Sometimes, it is desirable to save the current state of the <code class="literal">Graphics</code> object with <code class="literal">Save</code>, which returns an identity number that can be used to restore the <code class="literal">Graphics</code> object with <code class="literal">Restore</code>:</p><pre class="programlisting">  int Graphics::Save() { &#13;
    return ::SaveDC(deviceContextHandle); &#13;
  } &#13;
 &#13;
  void Graphics::Restore(int saveId) { &#13;
    ::RestoreDC(deviceContextHandle, saveId); &#13;
  } &#13;
</pre><p>The default origin (x = 0 and y = 0) of the coordinate system is the top-left corner of the window client area. This can be changed with <code class="literal">SetOrigin</code>, which takes the new origin in logical units. The win32 API function <code class="literal">SetWindowOrgEx</code> sets the new origin:</p><pre class="programlisting">  void Graphics::SetOrigin(Point centerPoint) { &#13;
    ::SetWindowOrgEx(deviceContextHandle, centerPoint.X(), &#13;
                     centerPoint.Y(), nullptr); &#13;
  } &#13;
</pre><p>The part of the client area to be painted can be restricted with <code class="literal">IntersectClip</code>, resulting in the area outside the given rectangle not being affected. The Win32 API function <code class="literal">IntersectClip</code> sets the restricted area:</p><pre class="programlisting">  void Graphics::IntersectClip(Rect clipRect) { &#13;
    ::IntersectClipRect(deviceContextHandle, clipRect.Left(), &#13;
               clipRect.Top(),clipRect.Right(),clipRect.Bottom()); &#13;
  } &#13;
</pre><p>It is possible to draw lines, rectangles, and ellipses using a pen, which is obtained by the Win32 API functions <code class="literal">CreatePen</code> and <code class="literal">SelectObject</code>. Note that we save the previous object in order to restore it later:</p><pre class="programlisting">  void Graphics::DrawLine(Point startPoint, Point endPoint, &#13;
                     Color color, PenStyle penStyle/* = Solid */){ &#13;
    HPEN penHandle = ::CreatePen(penStyle, 0, color.ColorRef()); &#13;
    HPEN oldPenHandle = &#13;
      (HPEN) ::SelectObject(deviceContextHandle,penHandle); &#13;
</pre><p>By the way, the technique of moving the pen to the start point and then drawing the line to the end point with <code class="literal">MoveToEx</code> and <code class="literal">LineTo</code> is called <span class="strong"><strong>Turtle </strong></span>
<span class="strong"><strong>graphics</strong></span>, referring to a turtle moving over the client area with the pen up or down:</p><pre class="programlisting">    ::MoveToEx(deviceContextHandle, startPoint.X(), &#13;
               startPoint.Y(), nullptr); &#13;
    ::LineTo(deviceContextHandle, endPoint.X(), endPoint.Y()); &#13;
</pre><p>Similar to <code class="literal">CreateTextMetrics</code> and <code class="literal">GetCharacterWidth</code> in <code class="literal">Window</code>, we need to select the previous object and restore the pen:</p><pre class="programlisting">    ::SelectObject(deviceContextHandle, oldPenHandle); &#13;
    ::DeleteObject(penHandle); &#13;
  } &#13;
</pre><p>When drawing a rectangle, we need a solid pen and a hollow brush, which we create with the Win32 API function <code class="literal">CreateBrushIndirect</code> with a <code class="literal">LOGBRUSH</code> structure parameter:</p><pre class="programlisting">  void Graphics::DrawRectangle(Rect rect, Color penColor, &#13;
                               PenStyle penStyle /* = Solid */) { &#13;
&#13;
    HPEN penHandle = &#13;
      ::CreatePen(penStyle, 0, penColor.ColorRef()); &#13;
 &#13;
    LOGBRUSH lbBrush; &#13;
    lbBrush.lbStyle = BS_HOLLOW; &#13;
    HBRUSH brushHandle = ::CreateBrushIndirect(&amp;lbBrush); &#13;
 &#13;
&#13;
    HPEN oldPenHandle = &#13;
      (HPEN) ::SelectObject(deviceContextHandle,penHandle); &#13;
    HBRUSH oldBrushHandle = &#13;
      (HBRUSH)  ::SelectObject(deviceContextHandle, brushHandle); &#13;
 &#13;
    ::Rectangle(deviceContextHandle, rect.Left(), rect.Top(), &#13;
                rect.Right(), rect.Bottom()); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldBrushHandle); &#13;
    ::DeleteObject(brushHandle); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldPenHandle); &#13;
    ::DeleteObject(penHandle); &#13;
  } &#13;
</pre><p>When filling a rectangle, we also need a solid brush, which we create with the Win32 API function <code class="literal">CreateSolidBrush</code>:</p><pre class="programlisting">  void Graphics::FillRectangle(Rect rect, Color penColor, &#13;
               Color brushColor, PenStyle penStyle /* = Solid */){ &#13;
&#13;
    HPEN penHandle = &#13;
      ::CreatePen(penStyle, 0, penColor.ColorRef()); &#13;
    HBRUSH brushHandle = &#13;
      ::CreateSolidBrush(brushColor.ColorRef()); &#13;
 &#13;
    HPEN oldPenHandle = &#13;
      (HPEN)::SelectObject(deviceContextHandle,penHandle); &#13;
    HBRUSH oldBrushHandle = &#13;
      (HBRUSH) ::SelectObject(deviceContextHandle, brushHandle); &#13;
 &#13;
    ::Rectangle(deviceContextHandle, rect.Left(), rect.Top(), &#13;
                rect.Right(), rect.Bottom()); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldBrushHandle); &#13;
    ::DeleteObject(brushHandle); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldPenHandle); &#13;
    ::DeleteObject(penHandle); &#13;
  } &#13;
</pre><p>The <code class="literal">DrawEllipse</code> and <code class="literal">FillEllipse</code> methods are similar to <code class="literal">DrawRectangle</code> and <code class="literal">FillRectangle</code>. The only difference is that they call the Win32 API function <code class="literal">Ellipse</code> instead of <code class="literal">Rectangle</code>:</p><pre class="programlisting">  void Graphics::DrawEllipse(Rect rect, Color penColor, &#13;
                             PenStyle penStyle /* = Solid */) { &#13;
 &#13;
   HPEN penHandle = &#13;
      ::CreatePen(penStyle, 0, penColor.ColorRef()); &#13;
 &#13;
    LOGBRUSH lbBrush; &#13;
    lbBrush.lbStyle = BS_HOLLOW; &#13;
    HBRUSH brushHandle = ::CreateBrushIndirect(&amp;lbBrush); &#13;
 &#13;
    HPEN oldPenHandle = &#13;
      (HPEN)::SelectObject(deviceContextHandle,penHandle); &#13;
    HBRUSH oldBrushHandle = &#13;
      (HBRUSH) ::SelectObject(deviceContextHandle, brushHandle); &#13;
 &#13;
    ::Ellipse(deviceContextHandle, rect.Left(), rect.Top(), &#13;
              rect.Right(), rect.Bottom()); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldBrushHandle); &#13;
    ::DeleteObject(brushHandle); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldPenHandle); &#13;
    ::DeleteObject(penHandle); &#13;
  } &#13;
 &#13;
  void Graphics::FillEllipse(Rect rect, Color penColor, &#13;
               Color brushColor, PenStyle penStyle /* = Solid */){ &#13;
    HPEN penHandle = &#13;
      ::CreatePen(penStyle, 0, penColor.ColorRef()); &#13;
    HBRUSH brushHandle = &#13;
      ::CreateSolidBrush(brushColor.ColorRef()); &#13;
 &#13;
    HPEN oldPenHandle = &#13;
      (HPEN) ::SelectObject(deviceContextHandle,penHandle); &#13;
    HBRUSH oldBrushHandle = &#13;
      (HBRUSH) ::SelectObject(deviceContextHandle, brushHandle); &#13;
 &#13;
    ::Ellipse(deviceContextHandle, rect.Left(), rect.Top(), &#13;
              rect.Right(), rect.Bottom()); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldBrushHandle); &#13;
    ::DeleteObject(brushHandle); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldPenHandle); &#13;
    ::DeleteObject(penHandle); &#13;
  } &#13;
</pre><p>When drawing text, we first need to check whether the font is given in typographical points and needs to be transformed into logical units (if <code class="literal">pointToMeters</code> is true), which is the case in the <code class="literal">LogicalWithScroll</code> and <code class="literal">LogicalWithoutScroll</code> coordinates systems. However, in the <code class="literal">PreviewCoordinate</code> system, the size of the text is already given in logical units and should not be transformed. Moreover, before we write the text, we need to create and select a font object and set the text and background colors. The Win32 <code class="literal">DrawText</code> function centers the text within the given rectangle:</p><pre class="programlisting">  void Graphics::DrawText(Rect areaRect, String text, Font font, &#13;
                          Color textColor, Color backColor, &#13;
                          bool pointsToMeters /* = true */) { &#13;
    if (pointsToMeters) { &#13;
      font.PointsToLogical(); &#13;
    } &#13;
 &#13;
    HFONT fontHandle = ::CreateFontIndirect(&amp;font.LogFont()); &#13;
    HFONT oldFontHandle = &#13;
      (HFONT) ::SelectObject(deviceContextHandle, fontHandle); &#13;
 &#13;
    ::SetTextColor(deviceContextHandle, textColor.ColorRef()); &#13;
    ::SetBkColor(deviceContextHandle, backColor.ColorRef()); &#13;
 &#13;
    RECT rectStruct = (RECT) areaRect; &#13;
    ::DrawText(deviceContextHandle, text.c_str(), text.length(), &#13;
               &amp;rectStruct, DT_SINGLELINE |DT_CENTER |DT_VCENTER); &#13;
 &#13;
    ::SelectObject(deviceContextHandle, oldFontHandle); &#13;
    ::DeleteObject(fontHandle); &#13;
  } &#13;
}; &#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we looked into the core of Small Windows: the <code class="literal">MainWindow</code> function and the <code class="literal">Application</code>, <code class="literal">Window</code>, and <code class="literal">Graphics</code> classes. In <a class="link" href="ch11.html" title="Chapter 11. The Document">Chapter 11</a>, <span class="emphasis"><em>The Document</em></span>, we look into the document classes of Small Windows: <code class="literal">Document</code>, <code class="literal">Menu</code>, <code class="literal">Accelerator</code>, and <code class="literal">StandardDocument</code>.</p></div></body></html>