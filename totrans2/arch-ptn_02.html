<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Client/Server Multi-Tier Architectural Patterns</h1>
                </header>
            
            <article>
                
<p>This chapter provides a bird's eye view of client-server architectural patterns. It starts with the need for the evolution of two-tier client-server patterns and highlights how the limitations of two-tier client-server patterns led to the evolution of three-tier and consequently <em>n</em>-tier client-server patterns. The different variants of client-server patterns like the master-slave pattern, peer-to-peer patterns, and so on are also explained in-depth with relevant use cases. The second part of the chapter focuses on web application frameworks. The requirements of web applications are different from that of client-server applications, the key differentiating factor being the dynamic updates to the UI based on the changes in the underlying data. All the popular patterns used in web application design are covered in this part of the chapter.</p>
<p>The major topics covered in this chapter are as follows:</p>
<ul>
<li>Two-tier, three-tier, and <em>n</em>-tier client-server patterns</li>
<li>The master-slave pattern</li>
<li>The peer-to-peer pattern</li>
<li>The distributed client-server pattern</li>
<li>The model-view-controller pattern</li>
<li>The model-view-presenter pattern</li>
<li>The model-view-model pattern</li>
<li>The front controller pattern</li>
<li>Some common design patterns used for web application development</li>
</ul>
<p>The client-server pattern is one of the oldest architectural patterns. In simple terms, how do we describe a client and a server? It is described as follows:</p>
<ul>
<li><strong>Client</strong>: This is the component that is a requestor of a service and sends requests for various types of services to the server</li>
<li><strong>Server</strong>: This is the component that is a service provider and continuously provides services to the client as per the requests placed by it</li>
</ul>
<p>Clients and servers typically comprise of distributed systems, which communicate over a network.</p>
<p>The following diagram is a simple graphic depicting the client-server architecture:</p>
<div class="CDPAlignCenter CDPAlign"><img height="344" width="618" class=" image-border" src="assets/3940b149-f6fb-413e-a076-367eb80b8c8d.png"/></div>
<p>There is no upper bound on the number of clients that can be serviced by a single server. It is also not mandatory that the client and server should reside in separate systems. Both client and server can reside in the same system based on the hardware configuration of the system and the type of functionality or service provided by the server. The communication between client and server happens by exchange of messages using a request-response pattern. The client basically sends a request for a service and server returns a response. This request-response pattern of communication which happens between a client and a server is a very good example of inter-process communication. For this communication to happen efficiently, it is necessary to have a well-defined communication protocol which lays down the rules of communication such as the format of request messages, response messages, error handling, and so on. All communication protocols that are used for client-server communication work in the application layer of the protocol stack. To further streamline the process of client-server communication, the server sometimes implements specific <strong>application programming interfaces</strong> (<strong>APIs</strong>) which could be used by the client to access any specific service from the server. This client-server pattern depicted in the graphic has two tiers: the client tier and the server tier, and hence it is also called the <strong>two-tier client-server pattern</strong>.</p>
<p>The term "<span>service"</span> used in the context of client-server architecture refers to the abstraction of a resource. The resource could be of any type, and <span>the server is named</span> based on the resource that is provided by the server (service). For example, if the server provides web pages, it is called a <strong>web server</strong> and if the server provides files, it is called a <strong>file server</strong>, and so on. A server can receive requests from <em>n</em> number of clients at a specific point in time. But any server will have its own limitations about its processing capabilities. So, many times, it becomes necessary for a server to prioritize the incoming requests and service them as per their priority. The scheduling system present in the server helps the server with the assignment of priorities. The common applications of client-server patterns for different use cases are as follows.</p>
<p><strong>Email server</strong> and <strong>email client</strong>: An email server provides emails as per the request received from the email client. Some commonly used enterprise email solutions are Microsoft Exchange from Microsoft, Lotus notes from IBM, Gmail from Google, and so on. Working on an email system is described as follows.</p>
<p>A mail server which is also known as an email server is the server that processes and delivers emails over the network, which is typically internet. A mail server is also equipped to receive emails from client computers and deliver them to other mail servers that are present in the network. An email client is a system in which the emails are read. It could be a desktop, laptop or a smartphone which can support emails.</p>
<p>The working of an email system is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/011a8490-7939-42cd-a536-e4bf51a87ae5.png"/></div>
<p>When an email is sent from a client, the email software which is present in the client system will connect to a server which is present in the network called the <strong>simple mail transfer protocol</strong> (<strong>SMTP</strong>) server. SMTP refers to a protocol which is used to deliver emails from clients to servers and from one server to another.<br/>
When emails are downloaded using the email software present on your client machine, the email software will connect to another server, which performs a function called a <strong>p</strong><span><strong>ost office protocol version3</strong></span> (<strong>POP3</strong>) server. POP3 server uses a <span>POP3</span> protocol. This protocol works like a mail delivery system used in a post office and hence the name. A detailed discussion of these protocols is beyond the scope of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain name service (DNS) server and DNS client</h1>
                </header>
            
            <article>
                
<p>DNS is one of the most important services that is present on the internet. An internet has thousands of devices that are a part of it and each of these devices is referred to as a host. Each host could be a printer, router, computer, or any other device. Each host has a unique IP address associated with it. Apart from the IP address, each host also has a unique hostname associated with it. For example, if the hostname is <kbd>LP471</kbd> and it is present in a domain <kbd>technest.com</kbd>, then the <strong>fully qualified domain name</strong> (<strong>FQDN</strong>) of the host is <kbd>LP471.technest.com</kbd>. The FQDN is used to identify the host uniquely within the DNS namespace. The DNS namespace contains some commonly used name suffixes; they are as follows:</p>
<ul>
<li><kbd>.com</kbd>: Commercial organizations</li>
<li><kbd>.edu</kbd>: Educational institutions</li>
<li><kbd>.gov</kbd>: Government organizations</li>
<li><kbd>.org</kbd>: Non-profit bodies like IEEE</li>
<li><kbd>.net</kbd>: Networking organizations</li>
</ul>
<p>Apart from these commonly used name suffixes, there are several others, too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The workings of a DNS</h1>
                </header>
            
            <article>
                
<p>A DNS works using the concept of distributed databases based on the client-server model. DNS clients are entities that require a name resolution (mapping of host names to IP addresses). DNS servers maintain the data that is required for name resolution. The high-level schematic of a DNS client-server architecture is given in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="278" width="541" class=" image-border" src="assets/bc263f97-ec1e-475c-8a4a-491e3b007bc0.png"/></div>
<p>Suppose the URL <kbd>www.xyzworks.com</kbd> is typed into the browser of the DNS client. The browser gets connected to a DNS server to get the equivalent IP address. The DNS server performs this task by first connecting to one of the root DNS servers. The root servers will store the IP addresses of all DNS servers that handle top-level domains such as <kbd>.edu</kbd>, <kbd>.com</kbd>, and so on. In this example, the root server after getting the IP address of the top-level domain <kbd>.com</kbd>, sends it a query asking for the IP address of <kbd>www.xyzworks.com</kbd>. The DNS server that handles the <kbd><span>.com</span></kbd> domain will respond with the IP addresses of the name servers that handle the <kbd>www.xyzworks.com</kbd> domain.</p>
<p>The name server then sends the query to the <kbd>www.xyzworks.com</kbd> DNS server. This DNS server responds with the entire IP address to the name server, which in turn sends it back to the DNS client which had initiated the DNS request. The DNS client machine can then use the IP address to access the required web page.</p>
<p>The salient aspects of this client-server architecture are as follows:</p>
<ul>
<li><strong>Redundancy</strong>: There are multiple DNS servers at each level so that even if one fails, the other server can take its role.</li>
<li><strong>Caching</strong>: Once a DNS request is resolved, the DNS server caches the IP address received by it. For example, where the IP address of the <kbd>.com</kbd> domain server is cached by the DNS server so that any subsequent requests for a <kbd><span>.com</span></kbd> domain can be handled by it without initiating repetitive DNS query mechanisms.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional requirements in two-tier client-server patterns</h1>
                </header>
            
            <article>
                
<p>The key functional requirements in two-tier client-server patterns are classified in the following table:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Functional requirement</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Presentation services</p>
</td>
<td>
<p>Provides user interface and dialog control</p>
</td>
</tr>
<tr>
<td>
<p>Presentation logic</p>
</td>
<td>
<p>User interaction and validation of inputs</p>
</td>
</tr>
<tr>
<td>
<p>Business logic</p>
</td>
<td>
<p>Set of business rules that specify how data can be stored, created, and changed</p>
</td>
</tr>
<tr>
<td>
<p>Distribution service</p>
</td>
<td>
<p>Management of communication</p>
</td>
</tr>
<tr>
<td>
<p>Database logic</p>
</td>
<td>
<p>Data operations and manage integrity of data</p>
</td>
</tr>
<tr>
<td>
<p>Database services</p>
</td>
<td>
<p>Management of various attributes of a database transaction</p>
</td>
</tr>
<tr>
<td>
<p>File services</p>
</td>
<td>
<p>Operations on files and sharing of files</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distribution of functional requirements in a client-server pattern</h1>
                </header>
            
            <article>
                
<p>Clients are broadly classified into the following two major categories:</p>
<ul>
<li><strong>Fat client</strong>: Most of the functional services are performed by the client component. One classic example of a fat client is a file server.</li>
<li><strong>Thin client</strong>: If it is a thin client, it relies on the server component for most of its computational capability.</li>
</ul>
<p>The choice of the client is made based on the type of client-server pattern, which is planned and implemented in a system. For example, if the pattern involves a lot of functionality to be done on the client side, then the choice of client is typically fat client, and vice versa. The functional requirements that are discussed in this section will give a better idea regarding the choice of client and server systems for implementing specific client-server patterns.</p>
<p>There are various ways in which functional requirements can be implemented in a client-server pattern. The following are some of the prominent ways of implementing client-server patterns:</p>
<ul>
<li>The remote data access client-server pattern</li>
<li><span>The r</span>emote presentation client-server pattern</li>
<li>The split logic data client-server architecture pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The remote data access client-server pattern</h1>
                </header>
            
            <article>
                
<p>In the remote <span>data access client-server</span> pattern, the application resides on the client component, whereas the data management is done by the server component. The server that performs data management is typically referred to as <strong>database management server</strong> (<strong>DBMS</strong>) or data server. Most of the <strong>relational database management system</strong> (<strong>RDBMS</strong>) products available in the market are implemented using this pattern. These RDBMS products typically provide a layer or component of software at the client side, which handles communication with the data server. This component of the software is called <strong>data manipulation language</strong> (<strong>DML</strong>). Client systems support the presentation and business logic and interact with the data server using DML. These patterns typically involve the usage of fat clients as a significant amount of processing is done by the client systems as well.</p>
<p>The implementation of functional requirements in a remote data access client-server architecture is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="203" width="379" class=" image-border" src="assets/366ad14d-5f99-422b-9ea0-c1588f5648a5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The remote presentation client-server pattern</h1>
                </header>
            
            <article>
                
<p>In the remote presentation client-server pattern, the <strong>graphical user interface</strong> (<strong>GUI</strong>) frontend is mapped to an existing application's text-based screen. This process is called Remote mapping or Front ending. The typical mode of operation of this pattern involves the use of intelligent workstations, which are equipped with the capability to intercept the text screen streams of data that are sent from a server system, and display them in a windowed system using a GUI. However, in these systems, most of the processing and computation happens on the server end only. One ideal example of this implementation is IBM's 3270 (mainframe) application. In this application, data from the application is sent to 3270's screen program on the mainframe to be displayed. The data is then sent to the client workstation in the form of a 3270-data stream. The client workstation receives the data, interprets it, and converts it to a graphical form to be displayed in a window. If the user enters any data through the client workstation in the GUI window, the front ware application that runs in the client workstation converts the data into a 3270-compatible format and sends it back to the server for the next course of action. The split of functions in a remote <strong>presentation</strong> client-server pattern is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="245" width="427" class=" image-border" src="assets/1d71d464-1cfb-4d6c-bfe2-55d3e9ab7216.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The split logic data client-server architecture pattern</h1>
                </header>
            
            <article>
                
<p>In the split logic data client-server architecture pattern, the application functionality is split into two parts: one will be implemented on the client side and the other one will be implemented on the server side. This pattern is very complex when compared to the other two patterns because both client and server need separately compiled application programs for their functioning. Before implementing this pattern, it is very important for developers to identify the functions to be implemented on the client and the server side and list out the type of communication dialogs that must happen between the application programs running on the client and the server side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The three-tier pattern / multi-tier pattern client-server</h1>
                </header>
            
            <article>
                
<p>The following diagram represents a client-server interaction:</p>
<div class="CDPAlignCenter CDPAlign"><img height="221" width="373" class=" image-border" src="assets/91118019-e466-4904-8460-5ab1afb9e7f1.png"/></div>
<p>We will discuss some of the variants of client-server patterns in this section. Some of the prominent variants of client-server patterns are as follows:</p>
<div style="margin-left: 2em">
<ul>
<li>The master-slave pattern</li>
<li>The peer-to-peer pattern</li>
</ul>
<p>Let's discuss them in detail.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The master-slave pattern</h1>
                </header>
            
            <article>
                
<p>The master-slave pattern is applied for designing a system if the system involves similar or identical computations that need to be performed repeatedly with separate set of inputs and context. The master-slave pattern offers support for fault tolerance and parallel computation.</p>
<p>The master-slave pattern is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="194" width="393" class=" image-border" src="assets/b35851ef-fe49-498a-8de9-a79828a7074a.png"/></div>
<p>The master component distributes the work among all the slave components and calculates the ﬁnal result by summing up the results that are returned by each slave. The master-slave pattern is used for architecting embedded systems and used in the design of systems that perform massive parallel computations. The following is a sequence diagram of the master-slave pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img height="313" width="410" class=" image-border" src="assets/0241228f-d7e6-45e6-88d7-7547afa99ea7.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issues in the master-slave pattern</h1>
                </header>
            
            <article>
                
<p>The master-slave pattern works based on the divide and conquer principle. In the working of this pattern, the coordination concept is separated from the actual work as all the slaves work in parallel. Hence, the slaves have not shared state and they work in isolation. Another issue in the master slave pattern is its latency. This could cause an issue in systems where the response time is very critical, for example, real-time systems. Moreover, this pattern can be applied to a specific problem only if it is decomposable.</p>
<p>One of the ways of implementing the master-slave pattern is through a single master thread, which creates multiple slave threads. Each of the slave threads performs a variant of the required computation and returns the result to the master. Once the computation is complete, the master thread accumulates the results and terminates the slave threads.</p>
<div class="packt_infobox"><span class="packt_screen">Client-queue-client patterns</span><strong><br/></strong>This is also called passive queue architecture. This is a variant of the client-server architecture in which all components, including servers, are treated only as client systems. This is because servers were treated as passive queues by the clients which are present in the system and are used by the clients for transferring messages to other clients present in the network. This architecture could be treated as one of the early evolutions of peer-to-peer architecture, which is discussed in the next section and is obsolete today.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Peer-to-peer patterns</h1>
                </header>
            
            <article>
                
<p>Peer-to-peer architectural patterns belong to the category of symmetric client-server patterns. Symmetric in this context refers to the fact that there is no need for a strict division in terms of client, server, and so on in the network of systems. In a peer-to-peer pattern, a single system acts as both client and server. Each system, also called a peer, sends requests to other peers in the network and at the same time receives and services requests from other peers, which are part of the network. This is a great difference when compared to a traditional client server network where a client must only send a request and wait for the server to process.</p>
<p>In general, this pattern is typically used to implement a decentralized network of systems using distributed resources that are expected to perform specific function. The distributed resources could be either processing power, data, or bandwidth which may be used for any distributed computing task like Sharing of content, communication, and so on. The generic architecture of a peer-to-peer pattern is depicted in the following diagrams (however, some variations are possible, which we will discuss later):</p>
<div class="CDPAlignCenter CDPAlign"><img height="313" width="562" src="assets/2f9b2560-2563-417c-b238-5ca1ee4e0691.png"/></div>
<div class="CDPAlignCenter CDPAlign"><img height="352" width="559" class=" image-border" src="assets/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png"/></div>
<p>Peer-to-peer patterns are basically implemented in two ways:</p>
<ul>
<li>A pure peer-to-peer pattern</li>
<li>A hybrid peer-to-peer pattern</li>
</ul>
<p>In a pure peer-to-peer pattern, all the systems that are part of the network are peers and they act as both client and server. There is no dependency on a centralized server for managing the various operations. The main advantage of this architecture is its fault tolerance. Another advantage is the simplicity and ease of implementation as this architecture moves away from the concept of centralization. The downside of the architecture is that the network bandwidth gets overused due to flooding of requests from all the peers that are part of the network. Gnutella, a popular file sharing protocol, is implemented using the pure peer-to-peer pattern. The preceding diagram is an example of a pure peer-to-peer pattern.</p>
<p>In the hybrid peer-to-peer pattern, there exists a central server to perform certain administrative tasks that are required for the smooth functioning of P2P services. This can be better explained with the help of a simple example. Napster, a file sharing protocol is designed based on hybrid peer-to-peer pattern. In Napster, there is a server whose main functionality is to help peer systems which are part of the network search for files. Transfer of files between the systems are then initiated based on the search results which are returned by the server. In other words, only the catalogue of files is maintained in the server whereas the actual files which are present in the catalogue are scattered across all the peer systems which are part of the network. This pattern is less fault tolerant when compared to the pure peer-to-peer pattern because of the dependency on centralized server component. However, the main benefit of this pattern is that there is no unnecessary consumption of network resources and this architecture is highly scalable. The hybrid peer-to-peer pattern is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign CDPAlignLeft"><img height="350" width="556" src="assets/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png"/></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Though peer-to-peer patterns are very effective for applications like file sharing, they also provide options for a lot of security threats and malicious code to enter the network and get propagated to other peer systems which are part of the network. Hence, the TCP ports which are used by peer-to-peer application should be constantly monitored and kept under the surveillance of <strong>intrusion detection systems</strong> / <strong>intrusion prevention systems</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of two-tier client-server patterns</h1>
                </header>
            
            <article>
                
<p>Some of the key advantages of client server systems are as follows:</p>
<ul>
<li><strong>Security</strong>: Data is stored centrally in the server. This offers greater control over the server and offers higher level of security than protecting the data that will be spread across a large number of client machines, which may involve offering special security mechanisms for each client machine.</li>
<li><strong>Centralized access to data</strong>: As most of the data is stored centrally in the server, it is much easier to do updates on the data. This is one of the simplest architectural styles.</li>
<li><strong>Ease of maintenance</strong>: In this architectural pattern, the client is unaware of details of the server and hence server maintenance activities like repair, upgrade, and so on do not affect the functioning of the client.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design considerations - when to use a two-tier client-server pattern?</h1>
                </header>
            
            <article>
                
<p>Having read so much about the two-tier client-server pattern, the next question which arises in our mind is when to use two-tier client server pattern for a specific architectural design. The following points could be used as a guideline to decide that:</p>
<ul>
<li>If the application under consideration is server based and will support numerous client, then the two-tier client server pattern is a good choice.</li>
<li>Some of the applications that work well with a two-tier client server pattern are web applications that are accessed through a web browser or for business process applications that are likely to be used throughout the organization.</li>
<li>If you are looking at centralizing data operations like storage, backup, and other related administration tasks, even then a two-tier client server pattern is an ideal choice.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limitations of two-tier client-server patterns</h1>
                </header>
            
            <article>
                
<p>The following are some of the main limitations of client-server patterns:</p>
<ul>
<li><strong>Limited extensibility, scalability, and reliability</strong>: In most of the implementations, application data and business logic reside on the same central server. This aspect impacts the system extensibility, scalability, and reliability.</li>
<li><strong>Excessive network bandwidth usage:</strong> communication between and the client and the server consumes excessive bandwidth. Request and response data often need to be converted to a common format as they might have a different format of representation on the client side and the server side. This aspect also contributes to additional traffic.</li>
</ul>
<p>To overcome these limitations of the two-tier client server pattern, three-tier/multi-tier client-server architecture was developed. Most of the applications of the present day, which are developed using the client-server architecture, are based on the three-tire/multi-tier architectural model, which is discussed in the next section.</p>
<p>Because of the slight difference in their architecture, three-tier and multi-tiered architectures are handled as separate topics in this chapter, though they may be referred to interchangeably in many other forums.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Three-tier client-server architecture</h1>
                </header>
            
            <article>
                
<p>The three tiers that are present in this architecture are as follows:</p>
<ul>
<li>The presentation tier</li>
<li>The application or business logic tier</li>
<li>Data tier</li>
</ul>
<p>The diagram depicting the three-tier client-server architecture is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="365" width="608" src="assets/43ab3182-df6d-4495-8ce0-c2705abf261f.png"/></div>
<p>In a three-tier architecture, the different layers are developed and maintained as different modules, sometimes on different platforms as well. The following are the functions of each layer:</p>
<ul>
<li><strong>Presentation tier</strong>: This is the first and topmost layer which is present in the application. This tier provides presentation services, that is presentation, of content to the end user through GUI. This tier can be accessed through any type of client device like desktop, laptop, tablet, mobile, thin client, and so on. For the content to the displayed to the user, the relevant web pages should be fetched by the web browser or other presentation component which is running in the client device. To present the content, it is essential for this tier to interact with the other tiers that are present preceding it.</li>
<li><strong>Application tier</strong>: This is the middle tier of this architecture. This is the tier in which the business logic of the application runs. Business logic is the set of rules that are required for running the application as per the guidelines laid down by the organization. The components of this tier typically run on one or more application servers.</li>
<li><strong>Data tier</strong>: This is the lowest tier of this architecture and is mainly concerned with the storage and retrieval of application data. The application data is typically stored in a database server, file server, or any other device or media that supports data access logic and provides the necessary steps to ensure that only the data is exposed without providing any access to the data storage and retrieval mechanisms. This is done by the data tier by providing an API to the application tier. The provision of this API ensures complete transparency to the data operations which are done in this tier without affecting the application tier. For example, updates or upgrades to the systems in this tier do not affect the application tier of this architecture.</li>
</ul>
<p>Benefits of the three-tier architecture are as follows:<strong><br/></strong></p>
<ul>
<li><strong>Scalability</strong> and <strong>flexibility</strong>: The major advantage of this architecture is its scalability and flexibility. Each tier of this architecture is a modular component, that is, any kind of operations like changes or upgrades done to one tier does not affect or cause downtime to the other tiers. Less functionality performed by the client and no high-end configuration is required for client systems which are present in the presentation tier.</li>
<li><strong>Increased security</strong>: Splitting of tasks among the various tiers provides increased security to each tier.</li>
</ul>
<p>Though three-tier architectural patterns offer several benefits, there are still limits on the scalability of the architecture when it comes to networks like internet which require massive scalability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design considerations for using three-tier architecture</h1>
                </header>
            
            <article>
                
<p>The following are some of the scenarios in which the three-tier architecture is a good choice:</p>
<ul>
<li>If you are developing an application with limited functionality/configuration for client systems. In this case, other components of the architecture like business logic and data logic can be distributed to other tiers.</li>
<li>If you are in the process of developing an application to be deployed within an intranet where all the servers are located within a specific private network.</li>
<li>If you are developing an internet application where there are no security constraints for deploying the business logic on the public networks of web or application servers.</li>
</ul>
<p>A variant of the three-tier architectural pattern which offers massive scalability is the <em>n</em>-tier architectural pattern. In an <em>n</em>-tier architectural pattern, the total number of tiers is <em>n</em>, where <em>n</em> has a value greater than three in order to differentiate it from the three-tier architectural pattern. In <em>n</em>-tier architecture, the application tier (which is the middle tier) is split into many tiers. The distribution of application code and functions among the various tiers varies from one architectural design to another. The diagram of the <em>n</em>-tier architectural pattern is depicted as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="351" width="466" src="assets/bce7f1a0-002c-4c49-b6bd-0ad51cd2781e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design considerations for n-tier architecture</h1>
                </header>
            
            <article>
                
<p>The following are some of the scenarios in which <em>n</em>-tier architecture is a good choice:</p>
<ul>
<li>If you are architecting a system in which it is possible to split the application logic into smaller components that could be spread across several servers. This could lead to the design of multiple tiers in the application tier.</li>
<li>If the system under consideration requires faster network communications, high reliability, and great performance, then <em>n</em>-tier has the capability to provide that as this architectural pattern is designed to reduce the overhead which is caused by network traffic.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An example of n-tier architecture (shopping cart web application)</h1>
                </header>
            
            <article>
                
<p>We can illustrate the working of an <em>n</em>-tier architecture with the help of an example of a shopping cart web application which is present in all e-commerce sites. The shopping cart web application is used by the e-commerce site user to complete the purchase of items through the e-commerce site.</p>
<p>Hence, the application should have several features which enable the user to do activities like the following:</p>
<ul>
<li>Adding selected items to the cart</li>
<li>Changing the quantities of items in the cart</li>
<li>Making payments</li>
</ul>
<p>The client tier, which is present in the shopping cart application, interacts with the end user through a GUI. The client tier also interacts with the application that runs in the application servers present in multiple tiers. Since the shopping cart is a web application, the client tier contains the web browser. The presentation tier present in the shopping cart application displays information related to the services like browsing merchandise, buying them, adding them to the shopping cart, and so on. The presentation tier communicates with other tiers by sending results to the client tier and all other tiers which are present in the network.</p>
<p>The presentation tier also makes calls to database stored procedures and web services. All these activities are done with the objective of providing a quick response time to the end user. The presentation tier plays a vital role by acting as a glue which binds the entire shopping cart application together by allowing the functions present in different tiers to communicate with each other and display the outputs to the end user through the web browser.</p>
<p>In this <em>n</em>-tier architecture, the business logic which is required for processing activities like calculation of shipping cost and so on are pulled from the application tier to the presentation tier. The application tier also acts as the integration layer and allows the applications to communicate seamlessly with both the data tier and the presentation tier. The last tier which is the data tier is used to maintain data. This layer typically contains database servers. This layer maintains data independent from the application server and the business logic. This approach provides enhanced scalability and performance to the data tier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The distributed client-server architecture</h1>
                </header>
            
            <article>
                
<p>The <em>n</em>-tier client-server architecture used for the shopping cart web application, which is discussed in the earlier section, is an ideal example of a distributed client-server architecture. Distributed architectures typically have some kind of backend host components (such as Mainframe, Database server, and so on), an intelligent client in the frontend, and multiple agents in the middle, which takes care of all activities pertaining to transactions like transaction processing, security, handling messages, and so on, and a network for communication.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/95677737-8b64-44ef-a5fb-4a903482fa83.png"/></div>
<p>Some of the key concepts associated with distributed architectures are as follows:</p>
<ul>
<li><strong>Transaction processing</strong>: Transaction processing is the automated processing of transactions in order to update a shared database. A transaction processing application in general will have many users who are concurrently interacting with the system in order to process business transactions on a shared database.</li>
<li><strong>Transaction processing monitor</strong> (<strong>TP monitor</strong>): The main task of the TP monitor is to manage the flow of transactions through a client server system efficiently. The TP monitor also works to ensure that simultaneous transactions which are happening on a shared database do not cause any inconsistency to the data which is present in the database.</li>
</ul>
<p>TP monitors also provide the following functions:</p>
<ul>
<li>They help in setting up back and forth connections between client and server components</li>
<li>They provide services that help in transaction-tracking, load balancing, and the capability to restart servers and the queues present in them automatically</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motivation for development of web application patterns</h1>
                </header>
            
            <article>
                
<p>Most of the web applications are highly interactive in nature. This means that when there is a change to the data, it should be reflected in the UI instantaneously without any further delay. To add on to this scenario, different users of the application may demand outputs in various formats like excel sheets, bar charts, pie charts, dashboards, and so on, as depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="387" width="659" src="assets/c09d80af-06d8-49d7-a33d-8587bbed8bb4.png"/></div>
<p>When there is a change in the functionality of a specific application, the user interface of the application should also be able to reflect the changes with the addition of new options like menus, dropdowns, and so on. This emphasizes the fact that user interfaces of web applications are always subjected to series of change requests. These <strong>user interfaces</strong> (<strong>UIs</strong>) change requests can happen in various circumstances, as follows:</p>
<ul>
<li>A request from the end user/customer for a change in the UI feature for various reasons like ease of use, adaptability, and so on</li>
<li>Porting of a system from one platform to another</li>
<li>Upgrades of system to new versions</li>
<li>Changes to database design</li>
</ul>
<p>From this, we can infer that user interfaces are always a target for changes. Different users of an application place different types of conflicting requirements on the user interface in order to make their operations easy. For example, an executive who uses a form-based interface for data entry may need more ease of use in the form based interface, whereas an administrator who is in charge of reporting may require more feature addition to the reporting interface. All this warrants a user interface where the design is flexible enough to accommodate all types of UI paradigms. It is impossible to build a system with this kind of flexibility if the UI is tightly tied to the functional core of the application. In such a scenario, it becomes necessary to develop and maintain several types of software applications, one for each type of user interface. The following are the main aspects that need to be kept in mind for the design of design patterns for web applications:</p>
<ul>
<li>It should be possible to represent the same information in different formats in different windows, for example, in one window as a pie chart, in another window as an excel sheet, and so on</li>
<li>It should be possible to change the UI easily even at runtime</li>
<li>It should be possible to provide various look and feel standards and changes to the user interface should not imply changes to the application code</li>
</ul>
<p>All these factors are the motivation for the design of the <strong>model view controller</strong> (<strong>MVC</strong>) pattern, which is predominantly used for the design and development of mobile and web applications. The following are the main components of the MVC architectural pattern:</p>
<ul>
<li><strong>Model</strong>: The function of the model component of MVC is to encapsulate core data and functionality. The model component has the capability to function independently, irrespective of output representations and input behavior. In design terms, the model essentially represents a set of classes which are used to depict the business logic.</li>
<li><strong>View</strong>: The function of the view component is to display information to the end user. The view component gets the data to be displayed from the model. A model can have any number of views depending on the requirements of the application. In design terms, the view essentially depicts the UI components such as HTML, jQuery, and so on.</li>
<li><strong>Controller</strong>: Each view is associated with a controller. Controllers get inputs, usually in the form of events from the user. The events could be received in the form of mouse clicks, keystrokes from the keyboard, and so on. These event are converted to service requests and are passed on to the model or the view. The controller is the only component through which the user interacts with the system.</li>
</ul>
<p>The separation of model, view, and controller components provide flexibility by allowing multiple views of the same model. In case the user changes, the model data using the controller component of one view, all other views which use the same data should be updated immediately to reflect the new changes. This is taken care of by the model by notifying all the views whenever its data changes. The view in turn takes the updated data from the model and updates all relevant views. All these sequences of actions necessitate the presence of a change propagation mechanism in the MVC model. This change in the propagation mechanism is explained in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Workings of the MVC pattern</h1>
                </header>
            
            <article>
                
<p>The model component exports procedures for application-specific processing. These procedures are called by the controller components in response to inputs received from the user. The model component also provides functions that can be used by the view component to access its data.</p>
<p>View components are used for presenting information to the end user. There may be different views for providing information in different ways as per the requirements of users. Each view is associated with an update procedure that is activated by the change propagation mechanism. The change propagation mechanism works by maintaining a registry of all the dependent components that are present within the model. All the related views and controllers that will be impacted by changes to these components also register their need so that they are kept informed of all the changes. Any change in model state in turn triggers the change-propagation mechanism. With the help of the update procedure, the view component retrieves the most updated data values from the model and displays them on the user interface screens.</p>
<p>The controller component accepts user input in the form of events. The format in which this event data is delivered to the controller is dependent on the user interface platform. But in general, each controller executes an event-handling procedure that is associated with an event. The overall working of the MVC pattern is depicted in the graphic which is given here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e0a0d5b3-4f96-4a83-8634-f816cf05f980.png"/></div>
<p>In the next section, we will discuss a popular programming framework which is developed using the MVC pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ASP.Net framework</h1>
                </header>
            
            <article>
                
<p>In ASP.Net, the patterns for the view component and the controller component are well-defined. Only the pattern for the model component is left to be designed by the developer as per the specific application requirements.</p>
<p><strong>View</strong>: The files that handle the responsibilities associated with the view component are <span>ASPX and</span> ASCX. In this design, the view object typically inherits from the controller object.</p>
<p><strong>Controller</strong>: The responsibilities of the controller component are split among two components. The generation and passing of events is done by the framework and, to be more speciﬁc, is done by the Page and Control classes. The event handling is taken care of by the code-behind class.</p>
<p><strong>Model</strong>: ASP.NET does not necessarily require a model. It is left to the choice of the developer whether to create a model class, or to forgo it. In case a model is not used, the event handlers in the controller can be used to perform any calculations and also ensure data persistence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The model view presenter (MVP) pattern</h1>
                </header>
            
            <article>
                
<p>The MVP pattern is a variant of MVC pattern and is mainly used for the development of user interfaces for web applications. It was mainly designed to make it easier to perform automated unit testing. The graphic given here depicts the architecture of the MVP pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img height="250" width="263" src="assets/2010ba93-0258-4e5e-bea1-603711a678c7.png"/></div>
<p>The various components of the MVP pattern are as follows:</p>
<ul>
<li><strong>Model</strong>: This component specifies the data to be displayed/sent from or to the user interface.</li>
<li><strong>View</strong>: The presentation logic lies in the Presenter component. It acts on both the model and the view components. It is responsible for fetching data from the model, applying appropriate logic, and sending it back for display in the view. When compared to the view and controller components in the MVC model, the view and presenter components present in the MVP pattern are fully decoupled from each other and they communicate by means of an interface.</li>
<li><strong>Presenter</strong>: The view component just acts as a passive interface. It displays data from the model and sends user inputs and commands to the presenter component. These user inputs and commands will be used to perform operations on the data.</li>
</ul>
<p>The following are some of the key considerations about the MVP pattern:</p>
<ul>
<li>The end user interacts only with the View</li>
<li>One View component is mapped only to one Presenter component</li>
<li>View references Presenter component but it has no reference to Model component</li>
<li>The pattern facilitates two way communication between the View component and the Presenter component</li>
</ul>
<p>Some of the common applications that use this pattern are ASP.Net forms and Windows forms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The model-view-viewmodel (MVVM) pattern</h1>
                </header>
            
            <article>
                
<p>MVVM is a popular pattern used for developing reusable and easily testable web applications. MVVM is a modern variant of MVC and the core objective is to have true separation between the Model and the View components. The main components of the pattern are the following:</p>
<ul>
<li>Model</li>
<li>View</li>
<li>ViewModel</li>
</ul>
<p>The layered architecture of the pattern is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="270" width="190" src="assets/b882d4c6-80c9-48a1-ae8b-c7247c0ad3e4.png"/></div>
<p><span>The various components of the MVVM pattern are as follows:</span></p>
<p><strong>Model</strong>: This component represents business logic and data. This means that the business logic that specifies how the data should be manipulated is present in the Model component.</p>
<p><strong>View</strong>: This component represents the UI components and will essentially contain UI elements such as CSS, HTML, and so on. It is only responsible for representing the data and does not perform any manipulations on data. However, unlike MVM, the View in MVVM is an active component and contains behaviors, events, and data-bindings that require information about the underlying model and viewModel components.</p>
<p><strong>ViewModel</strong>: The ViewModel is a very important component of the architecture as it helps in presentation separation, that is, it helps to keep the view separate from the model and, at the same time, acts as a controller that supports interaction and coordination between the View and the model components. The ViewModel component also contains commands and methods that help maintain the state of the view and help to manipulate the Model as per the actions, which are performed on the view. The ViewModel component also helps to trigger events in the view component itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key advantages of the MVVM pattern</h1>
                </header>
            
            <article>
                
<p>The following are the key advantages of using the MVVM pattern for design:</p>
<ul>
<li><strong>Maintainability</strong>: In this pattern, the clear separation of the different pieces of code makes it easier to maintain the code and also ensures quick releases using the code.</li>
<li><strong>Testability</strong>: In this pattern, the different pieces of code are very granular and are a key away from the core functional logic. This makes unit testing very easy.</li>
<li><strong>Extensibility</strong>: The granular pieces of code facilitate the reuse of code and also allows quick modification of code snippets.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design considerations for using the MVVM pattern</h1>
                </header>
            
            <article>
                
<p>The MVVM pattern is a right choice for design web applications that require the following aspects:</p>
<ul>
<li>Thorough unit testing of various components</li>
<li>Development of applications using the concept of reusable code and development of applications which can generate reusable snippets of code</li>
<li>Flexibility to change the user interface without changing the code base</li>
</ul>
<p>In the next section, we will discuss a sample framework that is built using the MVVM pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prism</h1>
                </header>
            
            <article>
                
<p>Prism is a framework that is built using the MVVM pattern. It helps in the design and development of flexible and easy to maintain <strong>Windows presentation foundation</strong> (<strong>WPF</strong>) desktop applications. It also helps to build rich internet applications using the Microsoft Silverlight Browser plugin. The following are the key features of the Prism framework:</p>
<ul>
<li>It uses architectural pattern that supports important design concepts such as separation of concerns and loosely coupled components.</li>
<li>Prism helps in the design of code snippets/components that can be easily integrated to form an application. Applications of this type which are formed by integrating components are called composite applications.</li>
</ul>
<p>The following are some of the important features of Prism:</p>
<ul>
<li>Support for the MVVM pattern, which in turn provides a bindable base class.</li>
<li>It has a flexible ViewModelLocator, which allows the View and ViewModel component to be hooked up in a loosely coupled way. It provides full support for the development of modular applications as it has several loosely coupled class libraries. These libraries can be brought together at runtime in the form of an application for the end user. The code base still remains decoupled.</li>
<li>Supports a rich set of navigation features that supports features like forward navigation, backward navigation, and so on. The navigation stack of prism allows ViewModels to be part of the navigation process directly.</li>
<li>Prism supports the concept of Pub/Sub events. These refer to a mechanism of loosely coupled events where the publisher and subscriber components can communicate with the help of events. It is not necessary that the publisher or subscriber components should have explicit references or the same lifetimes.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design patterns for web application development</h1>
                </header>
            
            <article>
                
<p>Apart from the MVC, MVP, and MVVM architectural patterns, which were discussed in the previous sections, there are several design patterns that are used for the design of applications along with these patterns. In this section, we will discuss some of the commonly used design patterns for web application design. These patterns and their functionalities are described in the following table:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Pattern name</strong></p>
</td>
<td>
<p><strong>Functionality</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Interpreter design pattern</strong></p>
</td>
<td>
<p>This pattern is widely used in the development of menus for applications like editors and Integrated Development Environments (IDEs). This pattern works by interpreting instructions that are written in the form of a language grammar or as notations. This pattern involves the implementation of an expression interface, which is used to interpret a given context.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Mediator design pattern</strong></p>
</td>
<td>
<p>The key feature of this pattern is that it allows objects to interact with each other without knowing their structure. This is made possible by defining an object by encapsulating how they interact with other objects. This feature also helps in easy maintainability and the reuse of code. This pattern is also widely used for developing menus for applications like editor and IDE.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Memento design pattern</strong></p>
</td>
<td>
<p>The key feature of this pattern is that it helps to capture the present state of an object and store it as is so that it can be used again at a later point in time when needed without actually breaking the rules associated with object encapsulation.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Observer design pattern</strong></p>
</td>
<td>
<p>This pattern is used in scenarios where there exists a one to many relationship between objects. In such scenarios, if an object is modified, it becomes necessary to notify its dependent objects about the changes. That is the main motivation for the use of observer design pattern. This pattern allows a single object called subject to notify its state changes to all other observer objects that are dependent on it.</p>
</td>
</tr>
<tr>
<td>
<p><strong>State design pattern</strong></p>
</td>
<td>
<p>This pattern is used in scenarios where there exists a one to many relationship between objects. In such scenarios, if an object is modified, it becomes necessary to notify its dependent objects about the changes. This pattern is primarily used in situations where it is necessary to alter the behaviour of an object when there is a change in its internal state. This pattern works by creating an object to represent various states and an associated context object whose behaviour changes as per the state changes of the created object.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Strategy design pattern</strong></p>
</td>
<td>
<p>This pattern provides flexibility to a client to choose any specific algorithm from a group of algorithms at runtime. It also provides a simple way for the client to access the algorithm. This pattern works by removing an algorithm from its host class and placing it in a separate class. This will help in the prevention of code-related issues that will arise if the algorithm is present in the host class.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Template method design pattern</strong></p>
</td>
<td>
<p>This pattern provides the feature to define basic steps of algorithm execution while allowing specific execution steps to be changed. This is very similar to the Strategy design pattern; the only difference is that it allows modification of certain algorithm steps instead of the entire algorithm.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Visitor design pattern</strong></p>
</td>
<td>
<p>This pattern provides flexibility to create and perform new operations on a set of objects without altering the structure of the object and its associated classes. This pattern allows the loose coupling of components and hence new operations can be done on them without altering the existing object structure.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Bridge pattern</strong></p>
</td>
<td>
<p>This pattern provides the flexibility to separate an abstraction from its implementation. This allows both of them to be modified independently. The separation of abstraction from implementation is done by means of an interface that provides a bridge between the abstraction class and implementer class. This separation also makes the implementer class functionality independent of the abstraction class functionality.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Composite pattern</strong></p>
</td>
<td>
<p>This pattern provides the flexibility to treat a group of objects and a single object in the same manner. The composite pattern arranges objects in the form of a tree structure to represent part as well as whole hierarchies.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Factory method design pattern</strong></p>
</td>
<td>
<p>This pattern provides the flexibility to create an object without exposing its creation logic. In this pattern, an interface is used for creating an object. The subclass decides which class needs to be instantiated. The creation of an object is done only as and when it is required.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Builder design pattern</strong></p>
</td>
<td>
<p>This pattern allows us to build a complex object by using a step by step approach. A specialized interface called the Builder interface specifies the steps that are required to build the final object. This Builder interface is independent of the objects creation process. A class known as Director controls the object creation process. Another speciality of this pattern is that it specifies a way to separate an object from its construction. The same construction method can be used to create multiple representations of the same object.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Adapter pattern</strong></p>
</td>
<td>
<p>This pattern is used when it is required to provide a bridge between two incompatible interfaces. This pattern provides a single class called adapter that facilitates communication between two independent or incompatible interfaces.</p>
<p><strong>For example:</strong> A card reader acts as an adapter for the memory card present in the laptop. This is done by plugging in the memory card into the card reader. The card reader is then plugged into the laptop so that the memory card can be read through the laptop.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The front controller pattern</h1>
                </header>
            
            <article>
                
<p class="mce-root CDPAlignLeft CDPAlign">Another architectural pattern that is popular in web application development is the front controller pattern. This pattern ensures that there is only one point of entry for all incoming requests. A single piece of code called the controller handles all the incoming requests and then delegates the processing of each request to other application objects, which are present in the system. This core feature of the pattern helps the web application developers by providing necessary flexibility using the reuse of code. The architecture of the front controller pattern is depicted in the following graphic:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/797640eb-7f26-4753-9d48-c661ee130fdb.png"/></div>
<p>The following are the different components of this pattern:</p>
<ul>
<li><strong>Front controller</strong>: This component handles all types of incoming requests for the application</li>
<li><strong>Dispatcher</strong>: This component is used to dispatch a request to a specific handler for further processing</li>
</ul>
<ul>
<li><strong>Views</strong>: These correspond to the objects for which the requests are made</li>
</ul>
<p>In the next section, we will discuss a popular framework that is developed using the front controller pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring framework</h1>
                </header>
            
            <article>
                
<p>Spring, a very popular framework for web application development, follows two architectural patterns for its design: the front controller pattern and the MVC pattern. The architecture is depicted in the following graphic:</p>
<div class="CDPAlignCenter CDPAlign"><img height="383" width="566" src="assets/1aa38905-4d60-4952-97ad-1b2c3314ffad.png"/></div>
<p>The Dispatcher Servlet component is the single servlet that functions as the front controller and handles all incoming requests. The Dispatcher Servlet then calls Handler Mapping in order to find an object that could service the request. The request is then given to the controller object so that the Dispatcher becomes free to perform functions associated with the fulfilment of business logic as per the user's request. The controller object returns an encapsulated object that contains the model object and view object. This is represented by the ModelandView <span>class</span>. If the ModelandView contains the logical name of the view, the Dispatcher Servlet calls the View Resolver to get details of the actual view object from its logical name. The Dispatcher Servlet then gives the model object to the view object so that it can be displayed to the end user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started the discussion with a two-tier client-server pattern. This is one of the earliest and oldest client-server patterns. With the growth of the information technology industry, this two-tier client server pattern was not sufficient to meet the infrastructure requirements. This led to the evolution of the three-tier client-server pattern followed by <em>n</em>-tier client-server pattern. Some other variants of the client-server pattern like the master-slave pattern, peer-to-peer pattern, and so on were also discussed in this chapter. The applications and the design considerations for each type of pattern was also discussed in this chapter.</p>
<p>Web application development, which caught steam later could not use client-server architecture because of its inherent limitations. This led to the evolution of some patterns that were custom-made for the development of web applications. These patterns needed the basic flexibility to be able to change the UI without altering the code base. The second half of this chapter dealt mainly with these patterns. The main patterns that were discussed in this part were <span>MVC,</span> <span>MVP,</span> <span>MVVM, and the f</span><span>ront controller.</span></p>
<p>Some of the common design patterns that are used along with these patterns were also discussed in this chapter.</p>
<p>Additional reference for this chapter: <a href="http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet">http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet</a></p>


            </article>

            
        </section>
    </body></html>