- en: Chapter 5. Graphics with Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：Qt中的图形
- en: When it comes to graphics, we have so far been using only ready-made widgets
    for the user interface, which resulted in the crude approach of using buttons
    for a tic-tac-toe game. In this chapter, you will learn about much of what Qt
    has to offer with regard to custom graphics. This will let you not only create
    your own widgets, incorporating content that is entirely customized, but also
    integrate multimedia in your programs. You will also learn about employing your
    OpenGL skills to display fast 3D graphics. If you are not familiar with OpenGL,
    this chapter should give you a kick-start for further research in this topic.
    By the end of the chapter, you will be able to create 2D and 3D graphics for your
    games using classes offered by Qt and integrate them with the rest of the user
    interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形方面，我们到目前为止只使用现成的控件来构建用户界面，这导致了使用按钮进行井字棋游戏的粗糙方法。在本章中，你将了解Qt在自定义图形方面提供的许多功能。这将让你不仅能够创建自己的控件，包含完全定制的内嵌内容，还能够将多媒体集成到你的程序中。你还将学习如何使用OpenGL技能来显示快速3D图形。如果你不熟悉OpenGL，本章应该为你在这个主题上的进一步研究提供一个起点。到本章结束时，你将能够使用Qt提供的类创建2D和3D图形，并将它们与用户界面的其余部分集成。
- en: When it comes to graphics, Qt splits this domain into two separate parts. One
    of them is raster graphics (used by widgets, for example). This part focuses on
    using high-level operations (such as drawing lines or filling rectangles) to manipulate
    colors of a grid of points that can be visualized on different devices, such as
    images or the display of your computer device. The other is vector graphics, which
    involves manipulating vertices, triangles, and textures. This is tailored for
    maximum speed of processing and display using hardware acceleration provided by
    modern graphics cards. Qt abstracts graphics by using the concept of a surface
    that it draws on. The surface (represented by the `QSurface` class) can be of
    one of two types—`RasterSurface` or `OpenGLSurface`. The surface can be further
    customized using the `QSurfaceFormat` class, but we will talk about that later
    as it is not important right now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形方面，Qt将这个领域分为两个独立的部分。其中之一是光栅图形（例如，由控件使用）。这部分侧重于使用高级操作（如绘制线条或填充矩形）来操纵可以在不同设备上可视化的点的网格的颜色，例如图像或计算机设备的显示。另一个是矢量图形，它涉及操纵顶点、三角形和纹理。这是为了利用现代显卡提供的硬件加速，以实现处理和显示的最大速度。Qt通过使用它所绘制的表面的概念来抽象图形。表面（由`QSurface`类表示）可以是两种类型之一——`RasterSurface`或`OpenGLSurface`。可以使用`QSurfaceFormat`类进一步自定义表面，但我们将稍后讨论这一点，因为它现在并不重要。
- en: Raster painting
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光栅绘制
- en: When we talk about GUI frameworks, raster painting is usually associated with
    drawing on widgets. However, since Qt is something more than a GUI toolkit, the
    scope of raster painting that it offers is much broader.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论GUI框架时，光栅绘制通常与在控件上绘制相关联。然而，由于Qt不仅仅是一个GUI工具包，它提供的光栅绘制的范围要广泛得多。
- en: In general, Qt's drawing architecture consists of three parts. The most important
    part is the device the drawing takes place on, represented by the `QPaintDevice`
    class. Qt provides a number of paint device subclasses such as `QWidget` or `QImage`
    and `QPrinter` or `QPdfWriter`. You can see that the approach for drawing on a
    widget and printing on a printer will be quite the same. The difference is in
    the second component of the architecture—the paint engine (`QPaintEngine`). The
    engine is responsible for performing the actual paint operations on a particular
    paint device. Different paint engines are used to draw on images and to print
    on printers. This is completely hidden from you as a developer, so you really
    don't need to worry about it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Qt的绘制架构由三个部分组成。最重要的部分是绘制发生的设备，由`QPaintDevice`类表示。Qt提供了一系列的绘制设备子类，如`QWidget`、`QImage`、`QPrinter`或`QPdfWriter`。你可以看到，在控件上绘制和在打印机上打印的方法将非常相似。区别在于架构的第二部分——绘制引擎（`QPaintEngine`）。引擎负责在特定的绘制设备上执行实际的绘制操作。不同的绘制引擎用于在图像上绘制和在打印机上打印。这对于你作为开发者来说是完全隐藏的，所以你真的不需要担心这一点。
- en: 'For you, the most important piece is the third component—`QPainter`—which is
    an adapter for the whole painting framework. It contains a set of high-level operations
    that can be invoked on the paint device. Behind the scenes, the whole work is
    delegated to an appropriate paint engine. While talking about painting, we will
    be focusing solely on the painter object as any painting code can be invoked on
    any of the target devices only by using a painter initialized on a different paint
    device. This effectively makes painting in Qt device agnostic, like in the following
    example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对您来说，最重要的部分是第三个组件——`QPainter`——它是对整个绘画框架的适配器。它包含一组可以在绘图设备上调用的高级操作。幕后，所有工作都委托给适当的绘图引擎。在讨论绘画时，我们将专注于画家对象，因为任何绘画代码都只能通过在另一个绘图设备上初始化的画家来在目标设备上调用。这有效地使Qt的绘画设备无关，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The same code can be executed on a painter working on any possible `QPaintDevice`
    class, be it a widget, an image, or an OpenGL context (through the use of `QOpenGLPaintDevice`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同一段代码可以在任何可能的`QPaintDevice`类上执行，无论是小部件、图像还是OpenGL上下文（通过使用`QOpenGLPaintDevice`）。
- en: Painter attributes
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画家属性
- en: The `QPainter` class has a rich API that can basically be divided into three
    groups of methods. The first group contains setters and getters for attributes
    of the painter. The second group consists of methods, with names starting with
    `draw` and `fill` that perform drawing operations on the device. The last group
    has other methods, mostly ones that allow manipulating the coordinate system of
    the painter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`类有一个丰富的API，基本上可以分为三组方法。第一组包含画家的属性设置器和获取器。第二组由以`draw`和`fill`开头的方法组成，这些方法在设备上执行绘图操作。最后一组有其他方法，主要是允许操作画家的坐标系。'
- en: Let's start with the attributes. The three most important ones are the font,
    pen, and brush. The first is an instance of the `QFont` class. It contains a large
    number of methods for controlling such font parameters as font family, style (italic
    or oblique), font weight, and font size (either in points or device-dependent
    pixels). All the parameters are self-explanatory, so we will not discuss them
    here in detail. It is important to note that `QFont` can use any font installed
    on the system. In case more control over fonts is required or a font that is not
    installed in the system needs to be used, one can take advantage of the `QFontDatabase`
    class. It provides information about available fonts (such as whether a particular
    font is scalable or bitmap or what writing systems it supports) and allows adding
    new fonts into the registry by loading their definitions directly from files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从属性开始。最重要的三个属性是字体、画笔和刷子。第一个是`QFont`类的实例。它包含大量用于控制字体参数的方法，如字体家族、样式（斜体或倾斜）、字体粗细和字体大小（以点或设备相关像素为单位）。所有参数都是不言自明的，所以我们在这里不会详细讨论它们。重要的是要注意`QFont`可以使用系统上安装的任何字体。如果需要更多对字体的控制或需要使用系统上未安装的字体，可以利用`QFontDatabase`类。它提供了有关可用字体（例如，特定字体是否可缩放或位图或它支持哪些书写系统）的信息，并允许通过直接从文件加载它们的定义来将新字体添加到注册表中。
- en: 'An important class, when it comes to fonts, is the `QFontMetrics` class. It
    allows calculating how much space is needed to paint particular text using a font
    or calculates text eliding. The most common use case is to check how much space
    to allocate for a particular user-visible string, for example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在字体方面，一个重要的类别是`QFontMetrics`类。它允许计算使用字体绘制特定文本所需的空间，或者计算文本的省略。最常见的用例是检查为特定用户可见字符串分配多少空间，例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is especially useful when trying to determine `sizeHint` for a widget.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这在尝试确定小部件的`sizeHint`时特别有用。
- en: 'The pen and brush are two attributes that define how different drawing operations
    are performed. The pen defines the outline, and the brush fills the shapes drawn
    using the painter. The former is represented by the `QPen` class and the latter
    by `QBrush`. Each of them is really a set of parameters. The most simple one is
    the color defined either as a predefined global color enumeration value (such
    as `Qt::red` or `Qt::transparent`) or an instance of the `QColor` class. The effective
    color is made up of four attributes—three color components (red, green, and blue)
    and an optional alpha channel value that determines transparency of the color
    (the larger the value, the more opaque the color). By default, all components
    are expressed as 8-bit values (0 to 255) but can also be expressed as real values
    representing a percentage of the maximum saturation of the component; for example,
    0.6 corresponds to 153 (*0.6*255*). For convenience, one of the `QColor` constructors
    accepts hexadecimal color codes used in HTML (with `#0000FF` being an opaque blue
    color) or even bare color names (for example, `blue`) from a predefined list of
    colors returned by a static function `QColor::colorNames()`. Once a color object
    is defined using RGB components, it can be queried using different color spaces
    (for example, CMYK or HSV). Also, a set of static methods are available that act
    as constructors for colors expressed in different color spaces. For example, to
    construct a clear magenta color, any of the following expressions can be used:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 笔刷和画笔是两个属性，它们定义了不同的绘图操作如何执行。笔刷定义了轮廓，而画笔则填充使用绘图器绘制的形状。前者由`QPen`类表示，后者由`QBrush`表示。每个都是一组参数。最简单的一个是颜色，它可以是预定义的全局颜色枚举值（例如`Qt::red`或`Qt::transparent`）或`QColor`类的实例。有效颜色由四个属性组成——三个颜色分量（红色、绿色和蓝色）以及一个可选的alpha通道值，该值决定了颜色的透明度（值越大，颜色越不透明）。默认情况下，所有分量都表示为8位值（0到255），也可以表示为表示分量最大饱和度百分比的实数值；例如，0.6对应于153（*0.6*255*）。为了方便，`QColor`构造函数之一接受HTML中使用的十六进制颜色代码（例如，`#0000FF`是一个不透明的蓝色颜色）或甚至是从静态函数`QColor::colorNames()`返回的预定义颜色列表中的裸颜色名称（例如，`blue`）。一旦使用RGB分量定义了颜色对象，就可以使用不同的颜色空间进行查询（例如，CMYK或HSV）。此外，还有一系列静态方法，它们作为不同颜色空间中表达的颜色构造函数。例如，要构造一个清澈的洋红色颜色，可以使用以下任何一种表达式：
- en: '`QColor("magenta")`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor("magenta")`'
- en: '`QColor("#FF00FF")`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor("#FF00FF")`'
- en: '`QColor(255, 0, 255)`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor(255, 0, 255)`'
- en: '`QColor::fromRgbF(1, 0, 1)`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor::fromRgbF(1, 0, 1)`'
- en: '`QColor::fromHsv(300, 255, 255)`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor::fromHsv(300, 255, 255)`'
- en: '`QColor::fromCmyk(0, 255, 0, 0)`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor::fromCmyk(0, 255, 0, 0)`'
- en: '`Qt::magenta`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::magenta`'
- en: 'Apart from the color, `QBrush` has two additional ways of expressing the fill
    of a shape. You can use `QBrush::setTexture()` to set a pixmap that will be used
    as a stamp or `QBrush::setGradient()` to make the brush use a gradient to do the
    filling. For example, to use a gradient that goes diagonally and starts yellow
    in the top-left corner of the shape, becomes red in the middle of the shape, and
    ends magenta at the bottom-right corner of the shape, the following code can be
    used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颜色之外，`QBrush`还有两种表示形状填充的方式。您可以使用`QBrush::setTexture()`设置一个用作戳记的位图，或者使用`QBrush::setGradient()`使画笔使用渐变进行填充。例如，要使用一个对角线渐变，从形状的左上角开始为黄色，在形状的中间变为红色，并在形状的右下角结束为洋红色，可以使用以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When used with drawing a rectangle, this code will give the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当与绘制矩形一起使用时，此代码将产生以下输出：
- en: '![Painter attributes](img/8874OS_05_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![绘图属性](img/8874OS_05_01.jpg)'
- en: Qt can handle linear (`QLinearGradient`), radial (`QRadialGradient`), and conical
    (`QConicalGradient`) gradients. It comes with a sample (shown in the following
    screenshot) where you can see different gradients in action. This sample is located
    in `examples/widgets/painting/gradients`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Qt可以处理线性（`QLinearGradient`）、径向（`QRadialGradient`）和锥形（`QConicalGradient`）渐变。它附带了一个示例（如下面的屏幕截图所示），其中可以看到不同的渐变效果。此示例位于`examples/widgets/painting/gradients`。
- en: '![Painter attributes](img/8874OS_05_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![绘图属性](img/8874OS_05_02.jpg)'
- en: As for the pen, its main attribute is its width (expressed in pixels), which
    determines the thickness of the shape outline. A special width setting is `0`,
    which constitutes a so-called cosmetic pen that is always drawn as a 1 pixel-wide
    line no matter what transformations are applied to the painter (we'll cover this
    later). A pen can of course have a color set but, in addition to that, you can
    use any brush as a pen. The result of such an operation is that you can draw thick
    outlines of shapes using gradients or textures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 至于笔，它的主要属性是其宽度（以像素为单位），它决定了形状轮廓的厚度。一个特殊的宽度设置是`0`，这构成了所谓的装饰性笔，无论对画家应用什么变换，它总是以1像素宽的线条绘制（我们稍后会介绍这一点）。当然，笔可以设置颜色，但除此之外，您还可以使用任何画笔作为笔。这种操作的结果是，您可以使用渐变或纹理绘制形状的粗轮廓。
- en: 'There are three more important properties for a pen. The first of them is the
    pen style, set using `QPen::setStyle()`. It determines whether lines drawn by
    the pen are continuous or somehow divided (dashes, dots, and so on). You can see
    available line styles together with their corresponding constants in the following
    diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于笔来说，还有三个更重要的属性。第一个是笔的样式，通过`QPen::setStyle()`设置。它决定了笔绘制的线条是连续的还是以某种方式分割的（虚线、点等）。您可以在以下图中看到可用的线条样式及其对应的常量：
- en: '![Painter attributes](img/8874OS_05_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![画家属性](img/8874OS_05_03.jpg)'
- en: 'The second attribute is the cap style, which can be flat, square, or round.
    The third attribute—the join style—is important for polyline outlines and dictates
    how different segments of the polyline are connected. You can make the joins sharp
    (with `Qt::MiterJoin`), round (`Qt::RoundJoin`), or a hybrid of the two (`Qt::BevelJoin`).
    You can see the different pen attribute configurations (including different join
    and cap styles) in action by launching the pathstroke example shown in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性是帽样式，可以是平的、方的或圆的。第三个属性——连接样式——对于多段线轮廓很重要，它决定了多段线的不同部分是如何连接的。您可以使连接尖锐（使用`Qt::MiterJoin`），圆形（`Qt::RoundJoin`），或者两者的混合（`Qt::BevelJoin`）。您可以通过启动以下截图所示的路径描边示例来查看不同的笔属性配置（包括不同的连接和帽样式）：
- en: '![Painter attributes](img/8874OS_05_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![画家属性](img/8874OS_05_04.jpg)'
- en: The next important aspect of the painter is its coordinate system. The painter
    in fact has two coordinate systems. One is its own logical coordinate system that
    operates on real numbers, and the other is the physical coordinate system of the
    device the painter operates on. Each operation on the logical coordinate system
    is mapped to physical coordinates in the device and applied there. Let's start
    with explaining the logical coordinate system first, and then we'll see how this
    relates to physical coordinates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 画家的下一个重要方面是其坐标系。实际上，画家有两个坐标系。一个是它自己的逻辑坐标系，它使用实数进行操作，另一个是画家操作的设备的物理坐标系。逻辑坐标系上的每个操作都会映射到设备的物理坐标，并在那里应用。让我们首先解释逻辑坐标系，然后我们将看到这与物理坐标有什么关系。
- en: The painter represents an infinite Cartesian canvas with the horizontal axis
    pointing right and the vertical axis pointing down by default. The system can
    be modified by applying affine transformations to it—translating, rotating, scaling,
    and shearing. This way, you can draw an analog clock face that marks each hour
    with a line by executing a loop that rotates the coordinate system by 30 degrees
    for each hour and draws a line that is vertical in the newly obtained coordinate
    system. Another example is when you wish to draw a simple plot with *x* axis going
    right and *y* axis going up. To obtain the proper coordinate system, you would
    scale the coordinate system by `-1` in the vertical direction, effectively reversing
    the direction of the vertical axis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 画家代表一个无限大的笛卡尔画布，默认情况下水平轴指向右，垂直轴指向下。可以通过对其应用仿射变换来修改系统——平移、旋转、缩放和剪切。这样，您可以通过执行一个循环来绘制一个模拟时钟面，每个小时用一条线标记，该循环将坐标系旋转30度，并在新获得的坐标系中绘制一条垂直线。另一个例子是当您希望绘制一个简单的图表，其中*x*轴向右，*y*轴向上。为了获得正确的坐标系，您需要在垂直方向上将坐标系缩放为`-1`，从而有效地反转垂直轴的方向。
- en: What we described here modifies the world transformation matrix for the painter
    represented by an instance of the `QTransform` class. You can always query the
    current state of the matrix by calling `transform()` on the painter and you can
    set a new matrix by calling `setTransform()`. `QTransform` has methods such as
    `scale()`, `rotate()`, and `translate()` that modify the matrix, but `QPainter`
    has equivalent methods for manipulating the world matrix directly. In most cases,
    using these would be preferable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的修改了由`QTransform`类实例表示的绘图者的世界变换矩阵。您可以通过在绘图者上调用`transform()`来查询矩阵的当前状态，您可以通过调用`setTransform()`来设置一个新的矩阵。`QTransform`有`scale()`、`rotate()`和`translate()`等方法来修改矩阵，但`QPainter`有直接操作世界矩阵的等效方法。在大多数情况下，使用这些方法会更可取。
- en: Each painting operation is expressed in logical coordinates, goes through the
    world transformation matrix, and reaches the second stage of coordinate manipulation,
    which is the view matrix. The painter has the concept of `viewport()` and `window()`
    rectangles. The `viewport` rectangle represents the physical coordinates of an
    arbitrary rectangle while the `window` rectangle expresses the same rectangle
    but in logical coordinates. Mapping one to another gives a transformation that
    needs to be applied to each drawn primitive to calculate the area of the physical
    device that is to be painted. By default, the two rectangles are identical to
    the rectangle of the underlying device (thus no `window`-`viewport` mapping is
    done). Such transformation is useful if you wish to perform painting operations
    using measurement units other than the pixels of the target device. For example,
    if you want to express coordinates using percentages of the width and height of
    the target device, you would set the window width and height both to `100`. Then,
    to draw a line starting at 20% of the width and 10% of the height and ending at
    70% of the width and 30% of the height, you would tell the painter to draw the
    line between (`20`, `10`) and (`70`, `30`). If you wanted those percentages to
    apply not to the whole area of an image but rather to its left half, you set the
    viewport rectangle only to the left half of the image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绘图操作都使用逻辑坐标表示，经过世界变换矩阵，然后达到坐标操作的第二个阶段，即视图矩阵。绘图者有`viewport()`和`window()`矩形的观念。`viewport`矩形表示任意矩形的物理坐标，而`window`矩形表示相同的矩形，但在逻辑坐标中。将一个映射到另一个给出一个需要应用于每个绘制的原型的变换，以计算要绘制的物理设备的区域。默认情况下，这两个矩形与底层设备的矩形相同（因此不执行`window`-`viewport`映射）。这种变换在您希望使用除目标设备像素以外的测量单位执行绘图操作时很有用。例如，如果您想使用目标设备宽度和高度的百分比来表示坐标，您可以将窗口宽度和高度都设置为`100`。然后，要绘制从宽度20%和高度10%开始，到宽度70%和高度30%结束的线，您会告诉绘图者绘制从(`20`,
    `10`)到(`70`, `30`)的线。如果您想将这些百分比应用于图像的左半部分而不是整个区域，您只需将视口矩形设置为图像的左半部分。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Setting the `window` and `viewport` rectangles only defines coordinate mapping;
    it does not prevent drawing operations from painting outside the `viewport` rectangle.
    If you want such behavior, you have to set a `clipping` rectangle on the painter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仅设置`window`和`viewport`矩形仅定义了坐标映射；它不会阻止绘图操作在`viewport`矩形之外绘制。如果您想有这种行为，您必须在绘图者上设置一个`clipping`矩形。
- en: Once you have the painter properly set, you can start issuing painting operations.
    `QPainter` has a rich set of operations for drawing different kinds of primitives.
    All of these operations have the prefix `draw` in their names, followed by the
    name of the primitive that is to be drawn. Thus, such operations as `drawLine`,
    `drawRoundedRect`, and `drawText` are available with a number of overloads that
    usually allow us to express coordinates using different data types. These may
    be pure values (either integer or real), Qt's classes, such as `QPoint` and `QRect`,
    or their floating point equivalents—`QPointF` and `QRectF`. Each operation is
    performed using current painter settings (font, pen, and brush).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确设置了绘图者，您就可以开始发出绘图操作。`QPainter`有一套丰富的操作来绘制不同类型的原型。所有这些操作在其名称中都有`draw`前缀，后面跟着要绘制的原型的名称。因此，`drawLine`、`drawRoundedRect`和`drawText`等操作都可用，具有多个重载，通常允许我们使用不同的数据类型来表示坐标。这些可能是纯值（整数或实数），Qt的类，如`QPoint`和`QRect`，或它们的浮点等效类——`QPointF`和`QRectF`。每个操作都是使用当前的绘图者设置（字体、笔和画刷）执行的。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see the list of all drawing operations available, switch to the **Help**
    pane in Qt Creator. From the drop-down list on top of the window, choose **Index**
    and then type in `qpainter`. After confirming the search, you should see the reference
    manual for the `QPainter` class with all the drawing operations listed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的绘图操作列表，请切换到 Qt Creator 中的 **帮助** 面板。在窗口顶部的下拉列表中选择 **索引**，然后输入 `qpainter`。确认搜索后，你应该会看到
    `QPainter` 类的参考手册，其中列出了所有绘图操作。
- en: 'Before you start drawing, you have to tell the painter what device you wish
    to draw on. This is done using the `begin()` and `end()` methods. The former accepts
    a pointer to a `QPaintDevice` instance and initializes the drawing infrastructure,
    and the latter marks the drawing as complete. Usually, we don''t have to use these
    methods directly as the constructor of `QPainter` calls `begin()` for us and the
    destructor invokes `end()`. Thus, the typical workflow is to instantiate a painter
    object, passing it the device, then do the drawing by calling `set` and `draw`
    methods, and finally let the painter be destroyed by going out of scope, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始绘图之前，你必须告诉画家你希望在哪个设备上绘图。这是通过使用 `begin()` 和 `end()` 方法来完成的。前者接受一个指向 `QPaintDevice`
    实例的指针并初始化绘图基础设施，后者标记绘图完成。通常，我们不需要直接使用这些方法，因为 `QPainter` 的构造函数会为我们调用 `begin()`，而析构函数会调用
    `end()`。因此，典型的流程是实例化一个画家对象，传递设备，然后通过调用 `set` 和 `draw` 方法进行绘图，最后让画家在超出作用域时被销毁，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will cover more methods from the `draw` family in the following sections
    of this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后续部分介绍 `draw` 家族中的更多方法。
- en: Widget painting
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件绘图
- en: It is time to actually get something onto the screen by painting on a widget.
    A widget is repainted as a result of receiving an event called `QEvent::Paint`,
    which is handled by reimplementing the virtual method `paintEvent()`. This method
    accepts a pointer to the event object of type `QPaintEvent` that contains various
    bits of information about the repaint request. Remember that you can only paint
    on the widget from within that widget's `paintEvent()` call.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过在小部件上绘图来将一些内容真正显示到屏幕上了。小部件由于接收到一个名为 `QEvent::Paint` 的事件而被重新绘制，这个事件通过重写虚拟方法
    `paintEvent()` 来处理。此方法接受一个类型为 `QPaintEvent` 的事件对象的指针，该对象包含有关重新绘制请求的各种信息。记住，你只能在
    `paintEvent()` 调用内部对小部件进行绘图。
- en: Time for action – custom-painted widgets
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 自定义绘制小部件
- en: Let's immediately use our new skills in practice!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即将我们的新技能付诸实践！
- en: Start by creating a new **Qt Widgets Application** in Qt Creator, choosing `QWidget`
    as the base class, and making sure the **Generate Form** box is unchecked.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 中开始创建一个新的 **Qt Widgets 应用程序**，选择 `QWidget` 作为基类，并确保 **生成表单** 复选框未勾选。
- en: 'Switch to the header file for the newly created class, add a protected section
    to the class and type void `paintEvent` for the section. Then press *Ctrl* + spacebar
    on your keyboard and Creator will suggest the parameters for the method. You should
    end up with the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到新创建类的头文件，在类中添加一个受保护的节，并为此节输入 `void paintEvent`。然后按键盘上的 *Ctrl* + 空格键，Creator
    将会建议方法的参数。你应该得到以下代码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Creator will leave the cursor positioned right before the semicolon. Pressing
    *Alt* + *Enter* will open the refactoring menu, letting you add the definition
    in the implementation file. The standard code for a paint event is one that instantiates
    a painter on the widget, as shown:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Creator 将光标定位在分号之前。按 *Alt* + *Enter* 将打开重构菜单，让你在实现文件中添加定义。绘制事件的常规代码是实例化小部件上的画家，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run this code, the widget will remain blank. Now we can start adding
    the actual painting code there:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，小部件将保持空白。现在我们可以开始添加实际的绘图代码了：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build and run the code, and you''ll obtain the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行代码，你将得到以下输出：
- en: '![Time for action – custom-painted widgets](img/8874OS_05_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 自定义绘制小部件](img/8874OS_05_06.jpg)'
- en: '*What just happened?*'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: First we set a 2 pixel-wide black pen for the painter. Then we called `rect()`
    to retrieve the geometry rectangle of the widget. By calling `adjusted()`, we
    received a new rectangle with its coordinates (in left, top, right, and bottom
    order) modified by the given arguments, effectively giving us a rectangle with
    a 10 pixel margin on each side.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为画家设置了一个 2 像素宽的黑笔。然后我们调用 `rect()` 来检索小部件的几何矩形。通过调用 `adjusted()`，我们得到了一个新的矩形，其坐标（按左、上、右、下的顺序）被给定的参数修改，从而有效地给我们一个每边有
    10 像素边距的矩形。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Qt usually offers two methods that allow us to work with modified data. Calling
    `adjusted()` returns a new object with its attributes modified, while if we had
    called `adjust()`, the modification would have been done in place. Pay special
    attention to which method you use to avoid unexpected results. It's best to always
    check the return value for a method—whether it returns a copy or void.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Qt通常提供两种方法，允许我们处理修改后的数据。调用`adjusted()`返回一个具有修改后属性的新对象，而如果我们调用`adjust()`，修改将就地完成。请特别注意你使用的方法，以避免意外结果。最好始终检查方法的返回值——它返回的是副本还是空值。
- en: 'Finally we call `drawRoundedRect()`, which paints a rectangle with its corners
    rounded by the number of pixels (in *x*, *y* order) given as the second and third
    argument. If you look closely, you will notice that the rectangle has nasty jagged
    rounded parts. This is caused by the effect of aliasing, where a logical line
    is approximated using the limited resolution of the screen; due to this, a pixel
    is either fully drawn or not drawn at all. Qt offers a mechanism called antialiasing
    to counter this effect by using intermediate pixel colors where appropriate. You
    can enable this mechanism by setting a proper render hint on the painter before
    you draw the rounded rectangle, as shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`drawRoundedRect()`，该方法绘制一个矩形，其角落通过第二个和第三个参数（*x*，*y*顺序）给出的像素数进行圆滑处理。如果你仔细观察，你会注意到矩形有讨厌的锯齿状圆滑部分。这是由混叠效应引起的，其中逻辑线使用屏幕有限的分辨率进行近似；由于这个原因，一个像素要么完全绘制，要么完全不绘制。Qt提供了一种称为抗锯齿的机制，通过在绘制圆角矩形之前在画家上设置适当的渲染提示来抵消这种效果。你可以通过在绘制圆角矩形之前在画家上设置适当的渲染提示来启用此机制，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you''ll get the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会得到以下输出：
- en: '![What just happened?](img/8874OS_05_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_05_07.jpg)'
- en: Of course, this has a negative impact on performance, so use antialiasing only
    where the aliasing effect is noticeable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会对性能产生负面影响，因此只有在混叠效果明显的地方才使用抗锯齿。
- en: Time for action – transforming the viewport
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 转换视口
- en: 'Let''s extend our code so that all future operations focus only on drawing
    within the border boundaries after the border is drawn. Use the `window` and `viewport`
    transformation as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的代码，以便所有未来的操作都只关注在绘制边框边界内，边框绘制完毕后。如下使用`window`和`viewport`转换：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also create a protected method called `drawChart()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还创建一个名为`drawChart()`的保护方法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a look at our output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的输出：
- en: '![Time for action – transforming the viewport](img/8874OS_05_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 转换视口](img/8874OS_05_08.jpg)'
- en: '*What just happened?*'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The first thing we did in the newly added code is call `painter.save()`. This
    call stores all parameters of the painter in an internal stack. We can then modify
    the painter state (by changing its attributes, applying transformations, and so
    on) and then, if at any point we want to go back to the saved state, it is enough
    to call `painter.restore()` to undo all the modifications in one go.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在新添加的代码中，我们首先调用`painter.save()`。此调用将画家的所有参数存储在一个内部堆栈中。然后我们可以修改画家状态（通过更改其属性、应用转换等），然后，如果我们想在任何时候返回到保存的状态，只需调用`painter.restore()`即可一次性撤销所有修改。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `save()` and `restore()` methods can be called as many times as needed.
    Just remember to always pair a call to `save()` with a similar call to `restore()`,
    or the internal painter state will get corrupted. Each call to `restore()` will
    revert the painter to the last saved state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`和`restore()`方法可以按需调用。只需记住，始终将`save()`的调用与类似的`restore()`调用配对，否则内部画家状态将损坏。每次调用`restore()`都会将画家恢复到最后保存的状态。'
- en: After the state is saved, we modify the rectangle again by adjusting for the
    width of the border. Then, we set the new rectangle as the viewport, informing
    the painter about the physical range of coordinates to operate on. Then we move
    the rectangle by half its height and set that as the painter window. This effectively
    puts the origin of the painter at half the height of the widget. Then, the `drawChart()`
    method is called whereby a red line is drawn on the *x* axis of the new coordinate
    system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 状态保存后，我们再次调整矩形，以适应边框的宽度。然后，我们将新矩形设置为视口，通知画家操作坐标的物理范围。然后，我们将矩形移动到其高度的一半，并将其设置为画家窗口。这有效地将画家的原点放置在窗口高度的一半处。然后，调用`drawChart()`方法，在新的坐标系*x*轴上绘制一条红线。
- en: Time for action – drawing an oscillogram
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 绘制示波图
- en: Let's further extend our widget to become a simple oscillogram renderer. For
    that we have to make the widget remember a set of values and draw them as a series
    of lines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展我们的小部件，使其成为一个简单的示波图渲染器。为此，我们需要让小部件记住一组值并将它们绘制成一系列线条。
- en: 'Let''s start by adding a `QList<quint16>` member variable that holds a list
    of unsigned 16-bit integer values. We will also add slots for adding values to
    the list and for clearing the list, as shown:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加一个`QList<quint16>`成员变量，它包含一个无符号16位整数值的列表。我们还将添加用于向列表添加值和清除列表的槽，如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that each modification of the list invokes a method called `update()`.
    This schedules a paint event so that our widget can be redrawn with the new values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次修改列表都会调用一个名为`update()`的方法。这将安排一个绘图事件，以便我们的小部件可以用新值重新绘制。
- en: 'Drawing code is also easy; we just iterate over the list and draw symmetric
    blue lines based on the values from the list. Since the lines are vertical, they
    don''t suffer from aliasing and so we can disable this render hint, as shown:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图代码也很简单；我们只需遍历列表，并根据列表中的值绘制对称的蓝色线条。由于线条是垂直的，它们不会受到混叠的影响，因此我们可以禁用此渲染提示，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To see the result add a loop to `main` as follows. This fills the widget with
    data:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，请将以下循环添加到`main`中。这将用数据填充小部件：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This loop takes a random number between `0` and `119` and adds it as a point
    to the widget. A sample result from running such code can be seen in the following
    screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环从`0`到`119`之间取一个随机数，并将其作为一个点添加到小部件中。运行此类代码的示例结果可以在下面的屏幕截图中看到：
- en: '![Time for action – drawing an oscillogram](img/8874OS_05_09.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![执行时间 – 绘制示波图](img/8874OS_05_09.jpg)'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you scale down the window, you will notice that the oscillogram extends past
    the boundaries of the rounded rectangle. Remember about clipping? You can use
    it now to constrain drawing by adding a simple `painter.setClipRect(r)` call just
    before you call `drawChart()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你缩小窗口，你会注意到示波图超出了圆角矩形的边界。还记得剪裁吗？现在你可以通过在调用`drawChart()`之前添加一个简单的`painter.setClipRect(r)`调用来约束绘图。
- en: Input events
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入事件
- en: So far, the custom widget was not interactive at all. Although the widget content
    could be manipulated from within the source code (say by adding new points to
    the plot), the widget was deaf to any user actions (apart from resizing the widget,
    which caused a repaint). In Qt, any interaction between the user and the widget
    is done by delivering events to the widget. Such a family of events is generally
    called input events and contains events such as keyboard events and different
    forms of pointing-device events—mouse, tablet, and touch events.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，自定义小部件根本不具备交互性。尽管可以从源代码中操作小部件内容（例如，通过向图表添加新点），但小部件对任何用户操作（除了调整小部件大小，这会导致重绘）都充耳不闻。在Qt中，用户与小部件之间的任何交互都是通过向小部件传递事件来完成的。这类事件通常被称为输入事件，包括键盘事件和不同形式的指向设备事件——鼠标、平板和触摸事件。
- en: In a typical mouse event flow, a widget first receives a mouse press event,
    then a number of mouse move events (when the user moves the mouse around while
    the mouse button is kept pressed), and finally, a mouse release event. The widget
    can also receive an additional mouse double-click event in addition to these events.
    It is important to remember that, by default, mouse move events are only delivered
    if a mouse button is pressed when the mouse is moved. To receive mouse move events
    when no button is pressed, a widget needs to activate a feature called **mouse
    tracking**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的鼠标事件流程中，小部件首先接收到鼠标按下事件，然后是一系列鼠标移动事件（当用户在鼠标按钮按下时移动鼠标时），最后是鼠标释放事件。小部件还可以接收到除了这些事件之外的额外鼠标双击事件。重要的是要记住，默认情况下，只有在鼠标移动时按下鼠标按钮时，才会传递鼠标移动事件。要接收鼠标移动事件而无需按下按钮，小部件需要激活一个称为**鼠标跟踪**的功能。
- en: Time for action – making oscillograms selectable
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间 – 使示波图可选择
- en: 'It''s time to make our oscillogram widget interactive. We will teach it to
    add a couple of lines of code to it that let the user select part of the plot.
    Let''s start with storage for the selection. We''ll need two integer variables
    that can be accessed via read-only properties; therefore, add the following two
    properties to the class (you can initialize them both to `-1`) and implement their
    getters:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让我们的示波图小部件变得交互式了。我们将教会它添加几行代码，使用户能够选择图表的一部分。让我们从存储选择开始。我们需要两个可以通过只读属性访问的整数变量；因此，向类中添加以下两个属性（你可以将它们都初始化为`-1`）并实现它们的getter：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The user can change the selection by dragging the mouse cursor over the plot.
    When the user presses the mouse button over some place in the plot, we''ll mark
    that place as the start of the selection. Dragging the mouse will determine the
    end of the selection. The scheme for naming events is similar to the paint event;
    therefore, we need to declare and implement the following two protected methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过将鼠标光标拖动到图表上来更改选择。当用户在图表的某个位置按下鼠标按钮时，我们将该位置标记为选择的开始。拖动鼠标将确定选择的结束。事件命名的方案与绘图事件类似；因此，我们需要声明并实现以下两个受保护的方法：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The structure of both event handlers is similar. We update the needed values,
    taking into consideration the left padding (12 pixels) of the plot, similar to
    what we do while drawing. Then, a signal is emitted and `update()` is called to
    schedule a repaint of the widget.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 两个事件处理程序的结构类似。我们更新所需值，考虑到图表的左填充（12像素），类似于我们在绘图时所做的。然后，发出一个信号并调用`update()`来安排小部件的重绘。
- en: 'What remains is to introduce changes to the drawing code. I suggest you add
    a `drawSelection()` method similar to `drawChart()` but that is called from the
    paint event handler immediately before `drawChart()`, as shown:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是引入绘图代码的更改。我建议您添加一个类似于`drawChart()`的`drawSelection()`方法，但该方法在`drawChart()`之前立即从绘图事件处理程序中调用，如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First we check if there is any selection to be drawn at all. Then, we save the
    painter state and adjust the pen and brush of the painter. The pen is set to `Qt::NoPen`,
    which means the painter should not draw any outline. To determine the brush, we
    use `palette()`; this returns an object of type `QPalette` holding basic colors
    for a widget. One of the colors held in the object is the color of the highlight
    often used for marking selections. If you use an entry from the palette instead
    of manually specifying a color, you gain an advantage that when the user of the
    class modifies the palette, this modification is taken into account by our widget
    code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否需要绘制任何选择。然后，我们保存绘图器的状态并调整绘图器的笔和画刷。笔被设置为`Qt::NoPen`，这意味着绘图器不应绘制任何轮廓。为了确定画刷，我们使用`palette()`；这返回一个包含小部件基本颜色的`QPalette`对象。对象中包含的颜色之一是常用于标记选择的突出显示颜色。如果您使用调色板中的条目而不是手动指定颜色，那么当类的用户修改调色板时，这种修改会被我们的小部件代码考虑在内。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can use other colors from the palette in the widget for other things we
    draw in the widget. You can even define your own `QPalette` object in the constructor
    of the widget to provide default colors for it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用小部件中的调色板中的其他颜色来绘制小部件中的其他内容。您甚至可以在小部件的构造函数中定义自己的`QPalette`对象，以提供默认颜色。
- en: Finally, we adjust the rectangle to be drawn and issue the drawing call.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调整要绘制的矩形并发出绘图调用。
- en: 'When you run this program, you will notice that the selection color doesn''t
    contrast very well with the plot itself. To overcome this, a common approach is
    to draw the "selected" content with a different (often inverted) color. This can
    easily be applied in this situation by modifying the `drawChart()` code slightly:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，您会注意到选择颜色与图表本身的对比度不是很好。为了克服这个问题，一个常见的方法是用不同的（通常是反转的）颜色绘制“已选择”的内容。在这种情况下，可以通过稍微修改`drawChart()`代码轻松应用：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now you see the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到以下输出：
- en: '![Time for action – making oscillograms selectable](img/8874OS_05_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 使示波图可选择](img/8874OS_05_10.jpg)'
- en: Have a go hero – reacting only to the left mouse button
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 只对左鼠标按钮做出反应
- en: As an exercise, you can modify the event handling code so that it only changes
    the selection if the mouse event was triggered by the left mouse button. To see
    which button triggered the mouse press event, you can use the `QMouseEvent::button()`
    method, which returns `Qt::LeftButton` for the left button, `Qt::RightButton`
    for the right, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以修改事件处理代码，使其仅在鼠标事件由左键触发时更改选择。要查看哪个按钮触发了鼠标按下事件，您可以使用`QMouseEvent::button()`方法，该方法对于左键返回`Qt::LeftButton`，对于右键返回`Qt::RightButton`，依此类推。
- en: Handling touch events is different. For any such event, you receive a call to
    the `touchEvent()` virtual method. The parameter of such a call is an object that
    can retrieve a list of points currently touched by the user with additional information
    regarding the history of user interaction (whether the touch was just initiated
    or the point was pressed earlier and moved) and what force is applied to the point
    by the user. Note that this is a low-level framework that allows you to precisely
    follow the history of touch interaction. If you are more interested in higher-level
    gesture recognition (pan, pinch, and swipe), there is a separate family of events
    available for it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 处理触摸事件是不同的。对于任何此类事件，你都会收到对`touchEvent()`虚拟方法的调用。此类调用的参数是一个对象，可以检索用户当前触摸的点列表，以及有关用户交互历史（触摸是否刚刚开始或点是否之前被按下并移动）以及用户施加到点的力的附加信息。请注意，这是一个低级框架，允许你精确地跟踪触摸交互的历史。如果你对高级手势识别（平移、捏合和滑动）更感兴趣，有专门的事件系列可供使用。
- en: Handling gestures is a two-step procedure. First you need to activate gesture
    recognition on your widget by calling `grabGesture()` and passing in the type
    of gesture you want to handle. A good place for such code is the widget constructor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 处理手势是一个两步过程。首先，你需要通过调用`grabGesture()`并在其中传入你想要处理的手势类型来在你的小部件上激活手势识别。这样的代码的好地方是小部件构造函数。
- en: 'Then your widget will start receiving gesture events. There are no dedicated
    handlers for gesture events but, fortunately, all events for an object flow through
    its `event()` method, which we can reimplement. Here is some example code that
    handles pan gestures:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的小部件将开始接收手势事件。没有专门的手势事件处理程序，但幸运的是，所有对象的事件都通过其`event()`方法流动，我们可以重新实现它。以下是一些处理平移手势的示例代码：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, a check for the event type is made; if it matches the expected value,
    the event object is cast to `QGestureEvent`. Then, the event is asked if `Qt::PanGesture`
    was recognized. Finally, a `handlePanGesture` method is called. You can implement
    such a method to handle your pan gestures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查事件类型；如果它与预期值匹配，则将事件对象转换为`QGestureEvent`。然后，询问事件是否识别出`Qt::PanGesture`。最后，调用`handlePanGesture`方法。你可以实现这样的方法来处理你的平移手势。
- en: Working with images
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理图像
- en: Qt has two classes for handling images. The first one is `QImage`, more tailored
    towards direct pixel manipulation. You can check the size of the image or check
    and modify the color of each pixel. You can convert the image into a different
    internal representation (say from 8-bit color map to full 32-bit color with a
    premultiplied alpha channel). This type, however, is not that fit for rendering.
    For that, we have a different class called `QPixmap`. The difference between the
    two classes is that `QImage` is always kept in the application memory, while `QPixmap`
    can only be a handle to a resource that may reside in the graphics card memory
    or on a remote *X* server. Its main advantage over `QImage` is that it can be
    rendered very quickly at the cost of the inability to access pixel data. You can
    freely convert between the two types but bear in mind that, on some platforms,
    this might be an expensive operation. Always consider which class serves your
    particular situation better. If you intend to crop the image, tint it with some
    color, or paint over it, `QImage` is a better choice. But if you just want to
    render a bunch of icons, it's best to keep them as `QPixmap` instances.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Qt有两个用于处理图像的类。第一个是`QImage`，更侧重于直接像素操作。你可以检查图像的大小或检查和修改每个像素的颜色。你可以将图像转换为不同的内部表示（例如从8位调色板到带有预乘alpha通道的完整32位颜色）。然而，这种类型并不适合渲染。为此，我们有一个不同的类，称为`QPixmap`。这两个类之间的区别在于`QImage`始终保留在应用程序内存中，而`QPixmap`只能是一个指向可能位于图形卡内存或远程*X*服务器上的资源的句柄。它相对于`QImage`的主要优势是它可以非常快速地渲染，但代价是无法访问像素数据。你可以自由地在两种类型之间转换，但请记住，在某些平台上，这可能是一个昂贵的操作。始终考虑哪个类更适合你的特定情况。如果你打算裁剪图像、用某种颜色着色或在其上绘制，`QImage`是一个更好的选择。但如果你只是想渲染一些图标，最好将它们保持为`QPixmap`实例。
- en: Loading
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载
- en: 'Loading images is very easy. Both `QPixmap` and `QImage` have constructors
    that simply accept a path to a file containing the image. Qt accesses image data
    through plugins that implement reading and writing operations for different image
    formats. Without going into the details of plugins, it is enough to say that the
    default Qt installation supports reading the following image types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像非常简单。`QPixmap` 和 `QImage` 都有构造函数，它们简单地接受包含图像的文件的路径。Qt 通过实现不同图像格式读取和写入操作的插件来访问图像数据。不深入插件细节，只需说明默认的
    Qt 安装支持读取以下图像类型：
- en: '| Type | Description |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| BMP | Windows bitmap |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| BMP | Windows 位图 |'
- en: '| GIF | Graphics Interchange Format |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| GIF | 图像交换格式 |'
- en: '| ICO | Windows icon |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ICO | Windows 图标 |'
- en: '| JPEG | Joint Photography Experts Group |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| JPEG | 联合摄影专家小组 |'
- en: '| MNG | Multiple-image Network Graphics |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| MNG | 多图像网络图形 |'
- en: '| PNG | Portable Network Graphics |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| PNG | 可移植网络图形 |'
- en: '| PPM/PBM/PGM | Portable anymap |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| PPM/PBM/PGM | 可移植任意映射 |'
- en: '| SVG | Scalable Vector Graphics |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| SVG | 可缩放矢量图形 |'
- en: '| TIFF | Tagged Image File Format |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| TIFF | 标签图像文件格式 |'
- en: '| XBM | X Bitmap |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| XBM | X 位图 |'
- en: '| XPM | X Pixmap |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| XPM | X 图像 |'
- en: As you can see, most popular image formats are available. The list can be further
    extended by installing additional plugins.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大多数流行的图像格式都是可用的。通过安装额外的插件，列表可以进一步扩展。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can ask Qt for a list of supported image types by calling a static method,
    `QImageReader::supportedImageFormats()`, which returns a list of formats that
    can be read by Qt. For a list of writable formats, call `QImageWriter::supportedFileFormats()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用静态方法 `QImageReader::supportedImageFormats()` 来请求 Qt 支持的图像类型列表，该方法返回 Qt
    可以读取的格式列表。对于可写格式的列表，请调用 `QImageWriter::supportedFileFormats()`。
- en: An image can also be loaded directly from an existing memory buffer. This can
    be done in two ways. The first one is to use the `loadFromData()` method (it exists
    in both `QPixmap` and `QImage`), which behaves the same as when loading an image
    from a file—you pass it a data buffer and the size of the buffer and based on
    that, the loader determines the image type by inspecting the header data and loads
    the picture into `QImage` or `QPixmap`. The second situation is when you don't
    have images stored in a "filetype" such as JPEG or PNG but rather you have raw
    pixel data itself. In such a situation, `QImage` offers a constructor that takes
    a pointer to a block of data together with the size of the image and format of
    the data. The format is not a file format such as the ones listed earlier but
    rather a memory layout for data representing a single pixel.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接从现有的内存缓冲区加载图像。这可以通过两种方式完成。第一种是使用 `loadFromData()` 方法（它存在于 `QPixmap` 和 `QImage`
    中），其行为与从文件加载图像时相同——你传递一个数据缓冲区和缓冲区的大小，然后根据这些信息，加载器通过检查头部数据来确定图像类型，并将图片加载到 `QImage`
    或 `QPixmap` 中。第二种情况是当你没有存储在“文件类型”如 JPEG 或 PNG 中的图像，而是有原始像素数据本身。在这种情况下，`QImage`
    提供了一个构造函数，它接受一个数据块的指针以及图像的大小和数据格式。格式不是如前面列出的文件格式，而是一个表示单个像素数据的内存布局。
- en: 'The most popular format is `QImage::Format_ARGB32`, which means that each pixel
    is represented by 32-bits (4 bytes) of data divided equally between alpha, red,
    green, and blue channels—8-bits per channel. Another popular format is `QImage::Format_ARGB32_Premultiplied`,
    where values for the red, green, and blue channels are stored after being multiplied
    by the value of the alpha channel, which often results in faster rendering. You
    can change the internal data representation using a call to `convertToFormat()`.
    For example, the following code converts a true-color image to 256 colors, where
    color for each pixel is represented by an index in a color table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的格式是 `QImage::Format_ARGB32`，这意味着每个像素由 32 位（4 字节）的数据表示，这些数据在 alpha、红色、绿色和蓝色通道之间平均分配——每个通道
    8 位。另一种流行的格式是 `QImage::Format_ARGB32_Premultiplied`，其中红色、绿色和蓝色通道的值在乘以 alpha 通道的值之后存储，这通常会导致渲染速度更快。你可以通过调用
    `convertToFormat()` 方法来更改内部数据表示。例如，以下代码将真彩色图像转换为 256 种颜色，其中每个像素的颜色由颜色表中索引表示：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The color table itself is a vector of color definitions that can be fetched
    using `colorTable()` and replaced using `setColorTable()`. The simplest way to
    convert an indexed image to grayscale is to adjust its color table as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色表本身是一个颜色定义的向量，可以使用 `colorTable()` 方法获取，并使用 `setColorTable()` 方法替换。将索引图像转换为灰度的最简单方法是调整其颜色表如下：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Modifying
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改
- en: 'There are two ways to modify image pixel data. The first one works only for
    `QImage` and involves direct manipulation of pixels using the `setPixel()` call,
    which takes the pixel coordinates and color to be set for that pixel. The second
    one works for both `QImage` and `QPixmap` and makes use of the fact that both
    these classes are subclasses of `QPaintDevice`. Therefore, you can open `QPainter`
    on such objects and use its drawing API. Here is an example of obtaining a pixmap
    with a blue rectangle and red circle painted over it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修改图像像素数据有两种方式。第一种仅适用于 `QImage`，涉及使用 `setPixel()` 调用直接操作像素，该调用接受像素坐标和要设置的像素颜色。第二种方式适用于
    `QImage` 和 `QPixmap`，利用这两个类都是 `QPaintDevice` 的子类这一事实。因此，你可以在这类对象上打开 `QPainter`
    并使用其绘图 API。以下是一个绘制带有蓝色矩形和红色圆圈的位图的示例：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First we create a 256 x 256 pixmap and fill it with transparent color. Then
    we open a painter on it and invoke a series of calls that draws a blue rectangle
    and red circle.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 256 x 256 的位图，并用透明颜色填充它。然后，我们在其上打开一个绘图器，并调用一系列绘制蓝色矩形和红色圆圈的调用。
- en: '`QImage` also offers a number of methods for transforming the image, including
    `scaled()`, `mirrored()`, `transformed()`, and `copy()`. Their API is intuitive
    so we won''t discuss them here.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage` 还提供了一系列用于变换图像的方法，包括 `scaled()`、`mirrored()`、`transformed()` 和 `copy()`。它们的
    API 很直观，所以我们在这里不讨论它们。'
- en: Painting
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制
- en: Painting images in its basic form is as simple as calling `drawImage()` or `drawPixmap()`
    from the `QPainter` API. There are different variants of the two methods, but
    basically all of them allow one to specify which portion of a given image or pixmap
    is to be drawn and where. It is worth noting that painting pixmaps is preferred
    to painting images as an image has to first be converted into a pixmap before
    it can be drawn.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，绘制图像就像从 `QPainter` API 调用 `drawImage()` 或 `drawPixmap()` 一样简单。这两个方法有不同的变体，但基本上它们都允许指定要绘制给定图像或位图的哪个部分以及在哪里绘制。值得注意的是，绘制位图比绘制图像更受欢迎，因为图像必须首先转换为位图，然后才能绘制。
- en: If you have a lot of pixmaps to draw, a class called `QPixmapCache` may come
    in handy. It provides an application-wide cache for pixmaps. By using it, you
    can speed up pixmap loading while introducing a cap on memory usage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多位图需要绘制，一个名为 `QPixmapCache` 的类可能会很有用。它为位图提供了一个应用程序范围内的缓存。通过使用它，你可以加快位图加载速度，同时限制内存使用量。
- en: Painting text
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制文本
- en: Drawing text using `QPainter` deserves a separate explanation, not because it
    is complicated but rather because Qt offers much flexibility in this regard. In
    general, painting text takes place by calling `QPainter::drawText()` or `QPainter::drawStaticText()`.
    Let's focus on the former first, which allows the drawing of generic text.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QPainter` 绘制文本值得单独解释，不是因为其复杂，而是因为 Qt 在这方面提供了很多灵活性。一般来说，绘制文本是通过调用 `QPainter::drawText()`
    或 `QPainter::drawStaticText()` 来实现的。我们先关注前者，它允许绘制通用文本。
- en: 'The most basic call to paint some text is a variant of this method, which takes
    *x* and *y* coordinates and the text to draw:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一些文本的最基本调用是这个方法的变体，它接受 *x* 和 *y* 坐标以及要绘制的文本：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding call draws the given text at position 10 horizontally and places
    the baseline of the text at position 20 vertically. The text is drawn using the
    painter''s current font and pen. The coordinates can alternatively be passed as
    `QPoint` instances instead of being given *x* and *y* values separately. The problem
    with this method is that it allows little control over how the text is drawn.
    A much more flexible variant is one that lets us give a set of flags and expresses
    the position of the text as a rectangle instead of a point. The flags can specify
    alignment of the text within the given rectangle or instruct the rendering engine
    about wrapping and clipping the text. You can see the result of giving a different
    combination of flags to the call in the following image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用在水平位置 10 处绘制了给定的文本，并将文本的基线垂直放置在位置 20。文本使用绘图器的当前字体和笔来绘制。坐标也可以作为 `QPoint`
    实例传递，而不是分别给出 *x* 和 *y* 值。这个方法的问题在于它对文本的绘制控制很少。一个更灵活的变体是允许我们给出一系列标志，并将文本的位置表示为一个矩形而不是一个点。标志可以指定文本在给定矩形内的对齐方式，或者指示渲染引擎关于文本换行和裁剪的指令。你可以在以下图像中看到向调用提供不同组合的标志的结果：
- en: '![Painting text](img/8874OS_05_12.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![绘制文本](img/8874OS_05_12.jpg)'
- en: 'In order to obtain each of the preceding results, run code similar to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得前面的每个结果，运行类似于以下代码的代码：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that, unless you set the `Qt::TextDontClip` flag, the text is clipped
    to the given rectangle; setting `Qt::TextWordWrap` enables line wrapping and `Qt::TextSingleLine`
    makes the engine ignore any newline characters encountered.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，除非你设置了 `Qt::TextDontClip` 标志，否则文本会被剪切到给定的矩形内；设置 `Qt::TextWordWrap` 允许文本换行，而
    `Qt::TextSingleLine` 使得引擎忽略遇到的任何换行符。
- en: Static text
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态文本
- en: Qt has to perform a number of calculations when laying out the text, and this
    has to be done each time the text is rendered. This will be a waste of time if
    the text and its attributes have not changed since the last time. To avoid the
    need to recalculate the layout, the concept of static text was introduced.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 在布局文本时需要进行一系列的计算，并且每次渲染文本时都必须执行这些计算。如果自上次渲染以来文本及其属性没有发生变化，这将是一种时间的浪费。为了避免重新计算布局的需要，引入了静态文本的概念。
- en: 'To use it, instantiate `QStaticText` and initialize it with text you want to
    render along with any options you might want it to have (kept as the `QTextOption`
    instance). Then, store the object somewhere and, whenever you want the text to
    be rendered, just call `QPainter::drawStaticText()`, passing the static text object
    to it. If the layout of the text has not changed since the previous time the text
    was drawn, it will not be recalculated, resulting in improved performance. Here
    is an example of a custom widget that simply draws text using the static text
    approach:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，实例化 `QStaticText` 并用你想要渲染的文本以及你可能希望它具有的任何选项（保持为 `QTextOption` 实例）进行初始化。然后，将对象存储在某个地方，每次你想渲染文本时，只需调用
    `QPainter::drawStaticText()`，并将静态文本对象传递给它。如果自上次绘制文本以来文本的布局没有发生变化，则不会重新计算，从而提高性能。以下是一个使用静态文本方法简单地绘制文本的自定义小部件的示例：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Rich text
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 富文本
- en: So far, we have seen how to draw text where all the glyphs were rendered using
    the same attributes (font, color, and style) and laid out as a contiguous flow
    of characters. While useful, this doesn't handle situations where we want to mark
    out portions of the text using a different color or align it differently. To make
    it work, we would have to execute a series of `drawText` calls with modified painter
    attributes and with manually calculated text positions. Fortunately, there are
    better solutions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何绘制所有符号都使用相同属性（字体、颜色和样式）渲染的文本，并且作为字符的连续流进行布局。虽然很有用，但这不处理我们想要使用不同颜色标记文本部分或以不同方式对其对齐的情况。为了使其工作，我们可能需要执行一系列带有修改后的画家属性和手动计算文本位置的
    `drawText` 调用。幸运的是，有更好的解决方案。
- en: Qt supports complex document formatting using its `QTextDocument` class. With
    this we can manipulate the text in a fashion similar to that of a text processor,
    applying formatting to paragraphs of text or individual characters. Then we can
    lay out and render the resulting document according to our needs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 通过其 `QTextDocument` 类支持复杂的文档格式。使用它，我们可以以类似文本处理器的风格操纵文本，对文本段落或单个字符应用格式。然后，我们可以根据我们的需求布局和渲染生成的文档。
- en: 'While useful and powerful, building `QTextDocument` is too complicated if all
    we want is to draw a small amount of text with simple customizations applied.
    The authors of Qt have thought about that as well and have implemented a rich
    text mode for rendering text. After enabling this mode, you can specify the formatted
    text to `drawText` directly using a subset of HTML tags to obtain formatting effects
    such as changing the color of the text, underlining it, or making it superscript.
    Drawing a centered underlined caption followed by a fully justified description
    in a given rectangle is as easy as issuing the following call:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很有用且功能强大，但如果我们只想用简单的自定义应用来绘制少量文本，构建 `QTextDocument` 就太复杂了。Qt 的作者们也考虑了这一点，并实现了一种富文本模式来渲染文本。启用此模式后，你可以直接使用
    HTML 标签的子集来指定格式化文本给 `drawText`，以获得如更改文本颜色、加下划线或使其成为上标等格式化效果。在给定矩形内绘制居中加下划线的标题，然后跟一个完全对齐的描述，就像发出以下调用一样简单：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Qt's rich text engine does not implement the full HTML specification; it will
    not handle cascading style sheets, hyperlinks, tables, or JavaScript. The *Supported
    HTML Subset* page in the Qt reference manual describes what parts of the HTML
    4 standard are supported. If you require full HTML support, you will have to use
    Qt's web page and web browser classes contained in the `webkitwidgets` (classes
    `QWebPage` and `QWebView`) or `webenginewidgets` (classes `QWebEnginePage` and
    `QWebEngineView`) modules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 的富文本引擎没有实现完整的 HTML 规范；它不会处理层叠样式表、超链接、表格或 JavaScript。Qt 参考手册中的“支持的 HTML 子集”页面描述了哪些
    HTML 4 标准的部分被支持。如果您需要完整的 HTML 支持，您将不得不使用 Qt 的网页和小部件类，这些类包含在 `webkitwidgets`（类
    `QWebPage` 和 `QWebView`）或 `webenginewidgets`（类 `QWebEnginePage` 和 `QWebEngineView`）模块中。
- en: Optimized drawing
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化绘制
- en: During game programming, performance is often a bottleneck. Qt tries its best
    to be as efficient as possible, but sometimes the code needs additional tweaking
    to work even faster. Using static text instead of regular text is one such tweak;
    use it whenever possible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏编程中，性能通常是瓶颈。Qt 尽力做到尽可能高效，但有时代码需要额外的调整才能运行得更快。使用静态文本而不是常规文本就是这样一种调整；尽可能使用它。
- en: Another important trick is to avoid re-rendering the whole widget unless really
    required. One thing is that the `QPaintEvent` object passed to `paintEvent()`
    contains information about the region of the widget that needs to be redrawn.
    If the logic of your widget allows it, you can optimize the process by rendering
    only the required part.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的技巧是，除非确实需要，否则避免重新渲染整个小部件。一方面，传递给 `paintEvent()` 的 `QPaintEvent` 对象包含有关需要重绘的小部件区域的信息。如果您的部件逻辑允许，您可以通过仅渲染所需部分来优化此过程。
- en: Time for action – optimizing oscillogram drawing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 优化示波器绘制
- en: 'As an exercise, we will modify our oscillogram widget so that it only re-renders
    the part of its data that is required. The first step is to modify the paint event
    handling code to fetch information about the region that needs updating and pass
    it to the method drawing the chart. The changed parts of the code have been highlighted
    here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们将修改我们的示波器小部件，使其仅重新渲染所需的数据部分。第一步是修改绘制事件处理代码，以获取需要更新的区域信息并将其传递给绘制图表的方法。这里已经突出显示了更改的部分代码：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next step is to modify `drawSelection()` to only draw the part of the selection
    that intersects with the exposed rectangle. Luckily, `QRect` offers a method to
    calculate the intersection for us:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改 `drawSelection()` 以仅绘制与暴露矩形相交的选择部分。幸运的是，`QRect` 提供了一个为我们计算交集的方法：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, `drawChart` needs to be adjusted to omit the values outside the exposed
    rectangle:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`drawChart` 需要调整以省略暴露矩形外的值：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*What just happened?*'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: By implementing these changes, we have effectively reduced the painted area
    to the rectangle received with the event. In this particular situation, we will
    not save much time as drawing the plot is not that time-consuming; in many situations,
    however, you will be able to save a lot of time using this approach. For example,
    if we were to plot a very detailed aerial map of a game world, it would be very
    expensive to replot the whole map if only a small part of it were modified. We
    can easily reduce the number of calculations and drawing calls by taking advantage
    of the information about the exposed area.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些更改，我们已经有效地将绘制区域减少到事件接收到的矩形。在这种情况下，我们不会节省太多时间，因为绘制图表并不那么耗时；然而，在许多情况下，您将能够通过这种方法节省大量时间。例如，如果我们需要绘制一个游戏世界的非常详细的地形图，如果只有一小部分被修改，重新绘制整个地图将非常昂贵。我们可以通过利用暴露区域的信息来轻松减少计算和绘图调用的数量。
- en: Making use of the exposed rectangle is already a good step towards efficiency,
    but we can go a step further. The current approach requires that we redraw each
    and every line of the plot within the exposed rectangle, which still takes some
    time. Instead, we can paint those lines only once into a pixmap, and then, whenever
    the widget needs repainting, tell Qt to render part of the pixmap to the widget.
    This approach is usually called "double-buffering" (the second buffer being the
    pixmap acting as a cache).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 利用暴露矩形已经是提高效率的良好步骤，但我们还可以更进一步。当前的方法要求我们在暴露矩形内重新绘制每一行图表，这仍然需要一些时间。相反，我们可以将这些线条只绘制一次到位图中，然后，每当小部件需要重新绘制时，告诉
    Qt 将位图的一部分渲染到小部件上。这种方法通常被称为“双缓冲”（第二个缓冲区是作为缓存的位图）。
- en: Have a go hero – implementing a double-buffered oscillogram
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄，尝试实现一个双缓冲的示波器
- en: 'It should be very easy for you now to implement this approach for our example
    widget. The main difference is that each change to the plot contents should not
    result in a call to `update()` but rather in a call that will re-render the pixmap
    and then call `update()`. The `paintEvent` method then becomes simply this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很容易为你示例控件实现这种方法。主要区别是，对绘图内容的每次更改不应导致调用`update()`，而应调用将重新渲染位图并随后调用`update()`的调用。`paintEvent`方法因此变得非常简单：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You'll also need to re-render the pixmap when the widget is resized. This can
    be done from within the void `resizeEvent(QResizeEvent*)` method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在控件大小调整时重新渲染位图。这可以通过在`void resizeEvent(QResizeEvent*)`方法内部完成。
- en: At this point, you are ready to employ your newly gained skills in rendering
    graphics with Qt to create a game that uses widgets with custom graphics. The
    hero of today is going to be chess and other chess-like games.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经准备好运用你新获得的使用 Qt 渲染图形的技能来创建一个使用自定义图形的控件游戏。今天的英雄将是象棋和其他类似象棋的游戏。
- en: Time for action – developing the game architecture
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——开发游戏架构
- en: Create a new **Qt Widgets Application** project. After the project infrastructure
    is ready, choose **New File or Project** from the **File** menu and choose to
    create a **C++ Class**. Call the new class `ChessBoard` and set `QObject` as its
    base class. Repeat the process to create a `GameAlgorithm` class derived from
    `QObject` and another one called `ChessView` but, this time, choose `QWidget`
    as the base class. You should end up with a file named `main.cpp` and four classes—`MainWindow`,
    `ChessView`, `ChessBoard`, and `ChessAlgorithm`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的**Qt Widgets 应用程序**项目。在项目基础设施准备就绪后，从**文件**菜单中选择**新建文件或项目**，然后选择创建一个**C++
    类**。将新类命名为`ChessBoard`，并将`QObject`设置为它的基类。重复此过程创建一个从`QObject`派生的`GameAlgorithm`类，另一个名为`ChessView`，但这次，选择`QWidget`作为基类。你应该最终得到一个名为`main.cpp`的文件和四个类——`MainWindow`、`ChessView`、`ChessBoard`和`ChessAlgorithm`。
- en: 'Now navigate to the header file for `ChessAlgorithm` and add the following
    methods to the class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到`ChessAlgorithm`的头文件，并向该类添加以下方法：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, add a private `m_board` field of type `ChessBoard*`. Remember to either
    include `chessboard.h` or forward-declare the `ChessBoard` class. Implement `board()`
    as a simple getter method for `m_board`. The `setBoard()` method is going to be
    a protected setter for `m_board`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还要添加一个私有的`m_board`字段，类型为`ChessBoard*`。记住要么包含`chessboard.h`，要么提前声明`ChessBoard`类。实现`board()`作为一个简单的获取`m_board`的方法。`setBoard()`方法将是一个受保护的设置器`m_board`：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let''s provide a base implementation for `setupBoard()` to create a default
    chess board with eight ranks and eight columns:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们提供一个`setupBoard()`的基础实现来创建一个默认的棋盘，具有八个等级和八个列：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The natural place to prepare the board is in a function executed when a new
    game is started:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 准备棋盘的自然地方是在启动新游戏时执行的功能中：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last addition to this class for now is to extend the provided constructor
    to initialize `m_board` to a null pointer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对这个类最后的添加是扩展提供的构造函数以初始化`m_board`为空指针。
- en: In the last method shown, we instantiated a `ChessBoard` object so let's focus
    on that class now. First extend the constructor to accept two additional integer
    parameters besides the regular parent argument. Store their values in private
    `m_ranks` and `m_columns` fields (remember to declare the fields themselves in
    the class header file).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后显示的方法中，我们实例化了一个`ChessBoard`对象，所以现在让我们专注于这个类。首先扩展构造函数以接受两个额外的整数参数，除了常规的父参数。将这些值存储在私有的`m_ranks`和`m_columns`字段中（记住在类头文件中声明这些字段本身）。
- en: 'In the header file, just under the `Q_OBJECT` macro, add the following two
    lines as property definitions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，在`Q_OBJECT`宏下方，添加以下两行作为属性定义：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare signals and implement getter methods to cooperate with those definitions.
    Also add two protected methods:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 声明信号并实现获取方法以与这些定义协同工作。还要添加两个受保护的函数：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These will be setters for ranks and columns properties, but we don't want to
    expose them to the outside world so we will give them `protected` access scope.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是等级和列属性的设置器，但我们不希望将它们暴露给外部世界，因此我们将给予它们`protected`访问范围。
- en: 'Put the following code into the `setRanks()` method body:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入`setRanks()`方法体中：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, in a similar way, you can implement `setColumns()`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以类似的方式，你可以实现`setColumns()`。
- en: 'The last class we will deal with now is our custom widget, `ChessView`. For
    now, we will provide only a rudimentary implementation for one method, but we
    will expand it later as our implementation grows. Add a public `setBoard(ChessBoard
    *)` method with the following body:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要处理的最后一个类是我们的自定义小部件，`ChessView`。目前，我们只为一个方法提供一个基本的实现，但我们将随着实现的扩展而扩展它。添加一个公共的`setBoard(ChessBoard
    *)`方法，其内容如下：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s declare the `m_board` member. Because we are not the owners of the
    board object (the algorithm class is responsible for managing it) we will use
    the `QPointer` class, which tracks the lifetime of `QObject` and sets itself to
    null once the object is destroyed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来声明`m_board`成员。因为我们不是棋盘对象的所有者（算法类负责管理它），我们将使用`QPointer`类，该类跟踪`QObject`的生命周期，并在对象被销毁后将其自身设置为null：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`QPointer` initializes its value to null, so we don''t have to do it ourselves
    in the constructor. For completeness, let''s provide a getter method for the board:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPointer`将其值初始化为null，因此我们不需要在构造函数中自己进行初始化。为了完整性，让我们提供一个获取棋盘的方法：'
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*What just happened?*'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'In the last exercise, we defined the base architecture for our solution. We
    can see that there are three classes involved: `ChessView` acting as the user
    interface, `ChessAlgorithm` for driving the actual game, and `ChessBoard` as a
    data structure shared between the view and the engine. The algorithm is going
    to be responsible for setting up the board (through `setupBoard()`), making moves,
    checking win conditions, and so on. The view will be rendering the current state
    of the board and will signal user interaction to the underlying logic.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们定义了我们解决方案的基本架构。我们可以看到涉及三个类：`ChessView`作为用户界面，`ChessAlgorithm`用于驱动实际游戏，以及`ChessBoard`作为视图和引擎之间共享的数据结构。算法将负责设置棋盘（通过`setupBoard()`），进行移动，检查胜利条件等。视图将渲染棋盘的当前状态，并将用户交互信号传递给底层逻辑。
- en: '![What just happened?](img/8874OS_05_17.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/8874OS_05_17.jpg)'
- en: Most of the code is self-explanatory. You can see in the `ChessView::setBoard()`
    method that we are disconnecting all signals from an old board object, attaching
    the new one (we will come back to connecting the signals later when we have already
    defined them), and finally telling the widget to update its size and redraw itself
    with the new board.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是自解释的。您可以在`ChessView::setBoard()`方法中看到，我们正在断开旧棋盘对象的所有信号，连接新对象（我们将在定义了它们之后回来连接信号），最后告诉小部件更新其大小并使用新棋盘重新绘制自己。
- en: Time for action – implementing the game board class
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 实现游戏棋盘类
- en: 'Now we will focus on our data structure. Add a new private member to `ChessBoard`,
    a vector of characters that will contain information about pieces on the board:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注我们的数据结构。向`ChessBoard`添加一个新的私有成员，它是一个字符向量，将包含关于棋盘上棋子的信息：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Consider the following table that shows the piece type and the letters used
    for it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表格，它显示了棋子类型及其所用的字母：
- en: '| Piece type | White | Black |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 棋子类型 | 白色 | 黑色 |'
- en: '| --- | --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ![Time for action – implementing the game board class](img/Image_05_01.JPG)
    | King | K | k |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| ![行动时间 – 实现游戏棋盘类](img/Image_05_01.JPG) | 国王 | K | k |'
- en: '| ![Time for action – implementing the game board class](img/Image_05_02.JPG)
    | Queen | Q | q |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| ![行动时间 – 实现游戏棋盘类](img/Image_05_02.JPG) | 后 | Q | q |'
- en: '| ![Time for action – implementing the game board class](img/Image_05_03.JPG)
    | Rook | R | r |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| ![行动时间 – 实现游戏棋盘类](img/Image_05_03.JPG) | 车 | R | r |'
- en: '| ![Time for action – implementing the game board class](img/Image_05_04.JPG)
    | Bishop | B | b |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| ![行动时间 – 实现游戏棋盘类](img/Image_05_04.JPG) | 象 | B | b |'
- en: '| ![Time for action – implementing the game board class](img/Image_05_05.JPG)
    | Knight | N | n |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| ![行动时间 – 实现游戏棋盘类](img/Image_05_05.JPG) | 马兵 | N | n |'
- en: '| ![Time for action – implementing the game board class](img/Image_05_06.JPG)
    | Pawn | P | P |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| ![行动时间 – 实现游戏棋盘类](img/Image_05_06.JPG) | 兵 | P | P |'
- en: 'You can see that white pieces use upper-case letters and black pieces use lower-case
    variants of the same letters. In addition to that, we will use a space character
    (0x20 ASCII value) to denote that a field is empty. We will add a protected method
    for setting up an empty board based on the number of ranks and columns on the
    board and a `boardReset()` signal to inform that the position on the board has
    changed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，白棋使用大写字母，而黑棋使用相同字母的小写变体。此外，我们还将使用空格字符（ASCII值为0x20）来表示一个字段为空。我们将添加一个受保护的方法来根据棋盘上的行数和列数设置一个空棋盘，并添加一个`boardReset()`信号来通知棋盘上的位置已更改：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can update our methods for setting rank and column counts to make use of
    that method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新我们的设置行数和列数的方法，以便使用该方法：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `initBoard()` method should also be called from within the constructor,
    so place the call there as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`initBoard()`方法也应该在构造函数内部调用，所以也要在那里放置调用。'
- en: Next, we need a method to read which piece is positioned in the particular field
    of the board.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个方法来读取棋盘特定字段中放置的是哪个棋子。
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Ranks and columns have indexes starting from 1, but the data structure is indexed
    starting from 0; therefore, we have to subtract 1 from both the rank and column
    index. It is also required to have a method to modify the data for the board.
    Implement the following public method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 行和列的索引从1开始，但数据结构是从0开始的；因此，我们必须从行和列索引中减去1。还需要有一个方法来修改棋盘的数据。实现以下公共方法：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The method makes use of another one that does the actual job. However, this
    method should be declared with `protected` access scope. Again we adjust for index
    differences.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法利用另一个实际执行工作的方法。然而，这个方法应该声明为`protected`访问范围。我们再次调整索引差异。
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since `setData()` makes use of a signal, we have to declare it as well:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setData()`使用了一个信号，我们也要声明它：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The signal will be emitted every time there is a successful change to the situation
    on the board. We delegate the actual work to the protected method to be able to
    modify the board without emitting the signal.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每当棋盘上的情况成功更改时，将发出该信号。我们将实际工作委托给受保护的方法，以便在不发出信号的情况下修改棋盘。
- en: 'Having defined `setData()`, we can add another method for our convenience:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`setData()`之后，我们可以添加另一个方便的方法：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Can you guess what it does? That's right! It moves a piece from one field to
    another one leaving an empty space behind.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到它做什么吗？没错！它将一个棋子从一个字段移动到另一个字段，并在后面留下一个空位。
- en: 'There is still one more method worth implementing. A regular chess game contains
    32 pieces, and there are variants of the game where starting positions for the
    pieces might be different. Setting the position of each piece through a separate
    call to `setData()` would be very cumbersome. Fortunately, there is a neat chess
    notation called the **Forsyth-Edwards Notation** (**FEN**), with which the complete
    state of the game can be stored as a single line of text. If you want the complete
    definition of the notation, you can look it up yourself. In short, we can say
    that the textual string lists piece placement rank by rank, starting from the
    last rank where each position is described by a single character interpreted as
    in our internal data structure (`K` for white king, `q` for black queen, and so
    on). Each rank description is separated by a `/` character. If there are empty
    fields on the board, they are not stored as spaces but rather as a digit specifying
    the number of consecutive empty fields. Therefore, the starting position for a
    standard game can be written as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个值得实现的方法。标准的国际象棋游戏包含32个棋子，而游戏变体中棋子的起始位置可能不同。通过单独调用`setData()`来设置每个棋子的位置将非常繁琐。幸运的是，有一种整洁的国际象棋记法称为**福赛斯-爱德华斯记法**（**FEN**），它可以存储为单行文本，以表示游戏的完整状态。如果你想知道记法的完整定义，你可以自己查找。简而言之，我们可以这样说，文本字符串按行列出棋子的放置，从最后一行开始，每个位置由一个字符描述，该字符被解释为我们的内部数据结构（`K`代表白王，`q`代表黑后，等等）。每个行描述由一个`/`字符分隔。如果棋盘上有空位，它们不会存储为空格，而是存储为指定连续空位数量的数字。因此，标准游戏的起始位置可以写成如下：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This can be interpreted visually as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如下直观地解释：
- en: '![Time for action – implementing the game board class](img/8874OS_05_18.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 实现游戏棋盘类](img/8874OS_05_18.jpg)'
- en: 'Let''s write a method called `setFen()` to set up the board based on an FEN
    string:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为`setFen()`的方法，根据FEN字符串设置棋盘：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The method iterates over all fields on the board and determines whether it is
    currently in the middle of inserting empty fields on the board or should rather
    read the next character from the string. If a digit is encountered, it is converted
    into an integer by subtracting the ASCII value of the 0 character (that is, *7-0
    = 7*). After setting each rank, we require that a slash or a space be read from
    the string. Otherwise, we reset the board to an empty one and bail out of the
    method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历棋盘上的所有方格，并确定它是否正在中间插入空方格，或者应该从字符串中读取下一个字符。如果遇到数字，它将通过减去0字符的ASCII值（即 *7-0
    = 7*）将其转换为整数。设置每个等级后，我们要求从字符串中读取一个斜杠或空格。否则，我们将棋盘重置为空棋盘，并退出该方法。
- en: '*What just happened?*'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We taught the `ChessBoard` class to store simple information about chess pieces
    using a one-dimensional array of characters. We also equipped it with methods
    that allow querying and modifying game data. We implemented a fast way of setting
    the current state of the game by adopting the FEN standard. The game data itself
    is not tied to classic chess. Although we comply with a standard notation for
    describing pieces, it is possible to use other letters and characters outside
    the well-defined set for chess pieces. This creates a versatile solution for storing
    information about chess-like games, such as checkers, and possibly any other custom
    game played on a two-dimensional board of any size with ranks and columns. The
    data structure we came up with is not a stupid one—it communicates with its environment
    by emitting signals when the state of the game is modified.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们教会了 `ChessBoard` 类使用字符的单维数组存储关于棋子的简单信息。我们还为其配备了允许查询和修改游戏数据的方法。我们通过采用FEN标准来实现设置游戏当前状态的一种快速方法。游戏数据本身并不局限于经典象棋。尽管我们遵守了描述棋子的标准记法，但可以使用其他字母和字符，这些字母和字符超出了定义良好的棋子集。这为存储类似棋类游戏（如国际象棋）的信息提供了一种灵活的解决方案，可能还可以用于任何其他在任意大小、带有等级和列的二维棋盘上进行的自定义游戏。我们提出的数据结构并非愚蠢——它通过在游戏状态修改时发出信号与其环境进行通信。
- en: Time for action – understanding the ChessView class
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 理解 ChessView 类
- en: This is a chapter about doing graphics, so it is high time to focus on displaying
    our chess game. Our widget currently displays nothing, and our first task is going
    to be to show a chess board with rank and column symbols and fields colored appropriately.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章关于图形制作的章节，因此现在是时候专注于显示我们的棋盘游戏了。我们的小部件目前什么也不显示，我们的第一个任务将是显示带有等级和列符号以及适当着色的棋盘。
- en: 'By default, the widget does not have any proper size defined and we will have
    to fix that by implementing `sizeHint()`. However, to be able to calculate the
    size, we have to decide how big a single field on the board is going to be. Therefore,
    in `ChessView`, you should declare a property containing the size of the field,
    as shown:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，小部件没有定义任何合适的尺寸，我们将通过实现 `sizeHint()` 来解决这个问题。然而，为了能够计算尺寸，我们必须决定棋盘上单个方格的大小。因此，在
    `ChessView` 中，你应该声明一个包含方格大小的属性，如下所示：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To speed up coding, you can position the cursor over the property declaration,
    hit the *Alt* + *Enter* combination, and choose the **Generate missing Q_PROPERTY
    members** fixup from the pop-up menu. Creator will provide minor implementations
    for the getter and setter for you. You can move the generated code to the implementation
    file by positioning the cursor over each method, hitting *Alt* + *Enter,* and
    choosing the **Move definition to chessview.cpp file** fixup. While the generated
    getter method is fine, the setter needs some adjusting. Modify it by adding the
    following highlighted code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快编码速度，你可以将光标放在属性声明上，按 *Alt* + *Enter* 组合键，并从弹出菜单中选择 **生成缺失的 Q_PROPERTY 成员**
    修复。Creator 将为你提供getter和setter的简单实现。你可以通过将光标放在每个方法上，按 *Alt* + *Enter*，并选择 **将定义移动到
    chessview.cpp 文件** 修复，将生成的代码移动到实现文件中。虽然生成的getter方法是好的，但setter需要一些调整。通过添加以下突出显示的代码来修改它：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This tells our widget to recalculate its size whenever the size of the field
    is modified. Now we can implement `sizeHint()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的小部件，每当方格的大小被修改时，就重新计算其大小。现在我们可以实现 `sizeHint()`：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First we check if we have a valid board definition and if not, return a sane
    size of 100 x 100 pixels. Otherwise, the method calculates the size of all the
    fields by multiplying the size of each of the fields by the number of columns
    or ranks. We add one pixel to each dimension to accommodate the right and bottom
    border. A chess board not only consists of not only the fields themselves but
    also displays rank symbols on the left edge of the board and column numbers on
    the bottom edge of the board. Since we use letters to enumerate ranks, we check
    the width of the widest letter in the alphabet using the `QFontMetrics` class.
    We use the same class to check how much space is required to render a line of
    text using the current font so that we have enough space to put column numbers.
    In both cases, we add 4 to the result to make a 2 pixel margin between the text
    and the edge of the board and another 2 pixel margin between the text and the
    edge of the widget.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否有有效的棋盘定义，如果没有，则返回一个合理的100 x 100像素大小。否则，该方法通过将每个字段的大小乘以列数或等级数来计算所有字段的大小。我们在每个维度上添加一个像素以容纳右侧和底部的边框。棋盘不仅由字段本身组成，还在棋盘的左侧边缘显示等级符号，在棋盘的底部边缘显示列号。由于我们使用字母来枚举等级，我们使用`QFontMetrics`类检查字母表中字母的最宽宽度。我们使用相同的类来检查使用当前字体渲染一行文本所需的空间，以便我们有足够的空间放置列号。在这两种情况下，我们将结果增加4，以便在文本和棋盘边缘之间以及文本和部件边缘之间留出2像素的边距。
- en: 'It is very useful to define a helper method for returning a rectangle that
    contains a particular field, as shown:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个辅助方法来返回包含特定字段的矩形非常有用，如下所示：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since rank numbers decrease from the top towards the bottom of the board, we
    subtract the desired rank from the maximum rank there is while calculating `fRect`.
    Then, we calculate the horizontal offset for rank symbols just like we did in
    `sizeHint()` and translate the rectangle by that offset before returning the result.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于等级数字从棋盘顶部到底部递减，我们在计算`fRect`时从最大等级中减去所需的等级。然后，我们像在`sizeHint()`中做的那样计算等级符号的水平偏移量，并在返回结果之前通过该偏移量平移矩形。
- en: 'Finally, we can move on to implementing the event handler for the paint event.
    Declare the `paintEvent()` method (the fixup menu available under the *Alt* +
    *Enter* keyboard shortcut will let you generate a stub implementation of the method)
    and fill it with the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以继续实现绘制事件的处理器。声明`paintEvent()`方法（在*Alt* + *Enter*键盘快捷键下可用的修复菜单将允许你生成方法的存根实现）并填充以下代码：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The handler is quite simple. First we instantiate the `QPainter` object that
    operates on the widget. Then we have three loops—the first one iterates over ranks,
    the second over columns, and the third over all fields. The body of each loop
    is very similar: there is a call to a custom draw method that accepts a pointer
    to the painter and index of the rank, column, or both of them, respectively. Each
    of the calls is surrounded by executing `save()` and `restore()`on our `QPainter`
    instance. What are the calls for here? The three draw methods—`drawRank()`, `drawColumn()`,
    and `drawField()`—are going to be virtual methods responsible for rendering the
    rank symbol, the column number, and the field background. It will be possible
    to subclass `ChessView` and provide custom implementations for those renderers
    so that it is possible to provide a different look of the chess board. Since each
    of these methods takes the painter instance as its parameter, overrides of these
    methods could alter attribute values of the painter behind our back. Calling `save()`
    before handing the painter over to such override stores its state on an internal
    stack, and calling `restore()` after returning from the override resets the painter
    to what was stored with `save()`. This effectively gives us a failsafe to avoid
    breaking the painter in case the override does not clean up after itself if it
    modifies the painter.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器相当简单。首先，我们实例化一个在部件上操作的`QPainter`对象。然后我们有三个循环——第一个遍历行，第二个遍历列，第三个遍历所有字段。每个循环的体都非常相似：都有一个调用自定义绘图方法的调用，该方法接受指向绘图器的指针和行、列或两者的索引。每个调用都被执行`save()`和`restore()`操作包围在我们的`QPainter`实例周围。这些调用是做什么的？三个绘图方法——`drawRank()`、`drawColumn()`和`drawField()`——将是负责渲染行符号、列数字和字段背景的虚拟方法。将能够子类化`ChessView`并为这些渲染器提供自定义实现，以便能够提供不同的棋盘外观。由于这些方法都接受绘图器实例作为参数，因此这些方法的覆盖可以改变绘图器背后的属性值。在将绘图器传递给这样的覆盖之前调用`save()`会将它的状态存储在一个内部堆栈上，在覆盖返回后调用`restore()`会将绘图器重置为`save()`存储的状态。这实际上为我们提供了一个安全措施，以避免在覆盖没有清理自己修改的绘图器时破坏绘图器。
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Calling `save()` and `restore()` very often introduces a performance hit, so
    you should avoid saving and restoring painter states too often in time-critical
    situations. As our painting is very simple, we don't have to worry about that
    when painting our chess board.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁调用`save()`和`restore()`会引入性能损失，因此在时间敏感的情况下应避免过于频繁地保存和恢复绘图器状态。由于我们的绘图非常简单，所以在绘制棋盘时我们不必担心这一点。
- en: 'Having introduced our three methods, we can start implementing them. Let''s
    start with `drawRank` and `drawColumn`. Remember to declare them as virtual and
    put them in protected access scope (that''s usually where Qt classes put such
    methods), as shown:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了我们的三种方法后，我们可以开始实施它们。让我们从`drawRank`和`drawColumn`开始。请记住将它们声明为虚拟的，并将它们放在受保护的访问范围内（这通常是Qt类放置此类方法的地点），如下所示：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Both methods are very similar. We use `fieldRect()` to query for the left-most
    column and bottom-most rank and based on that, we calculate where rank symbols
    and column numbers should be placed. The call to `QRect::adjusted()` is to accommodate
    the 2 pixel margin around the text to be drawn. Finally, we use `drawText()` to
    render appropriate text. For the rank, we ask the painter to align the text to
    the right edge of the rectangle and center the text vertically. In a similar way,
    when drawing the column we align to the top edge and center the text horizontally.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法非常相似。我们使用`fieldRect()`查询最左列和最底行的位置，然后根据这个位置计算行符号和列数字应该放置的位置。调用`QRect::adjusted()`是为了适应将要绘制的文本周围的2像素边距。最后，我们使用`drawText()`来渲染适当的文本。对于行，我们要求绘图器将文本对齐到矩形的右边缘并垂直居中。以类似的方式，在绘制列时，我们将文本对齐到顶部边缘并水平居中。
- en: 'Now we can implement the third draw method. It should also be declared protected
    and virtual. Place the following code in the method body:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现第三个绘图方法。它也应该被声明为受保护的虚拟方法。将以下代码放置在方法体中：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this method, we use the `QPalette` object coupled with each widget to query
    for `Light` (usually white) and `Mid` (darkish) color depending on whether the
    field we are drawing on the chess board is considered white or black. We do that
    instead of hardcoding the colors to make it possible to modify colors of the tiles
    without subclassing simply by adjusting the palette object. Then we use the palette
    again to ask for the `Dark` color and use that as a pen for our painter. When
    we draw a rectangle with such settings, the pen will stroke the border of the
    rectangle to give it a more elegant look. Note how we modify attributes of the
    painter in this method and we do not set them back afterwards. We can get away
    with it because of the `save()` and `restore()` calls surrounding the `drawField()`
    execution.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用与每个部件耦合的 `QPalette` 对象来查询 `Light`（通常是白色）和 `Mid`（较暗）颜色，这取决于我们在棋盘上绘制的字段是被认为是白色还是黑色。我们这样做而不是硬编码颜色，以便可以通过调整调色板对象来修改瓷砖的颜色，而无需子类化。然后我们再次使用调色板来请求
    `Dark` 颜色，并将其用作画家的笔。当我们用这样的设置绘制矩形时，笔将勾勒出矩形的边缘，使其看起来更优雅。注意我们如何在方法中修改画家的属性，并且在之后没有将它们设置回原位。我们可以这样做是因为
    `save()` 和 `restore()` 调用包围了 `drawField()` 的执行。
- en: 'We are ready now to see the results of our work. Let''s switch to the `MainWindow`
    class and equip it with the following two private variables:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好看到我们工作的结果。让我们切换到 `MainWindow` 类，并为其配备以下两个私有变量：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then modify the constructor by adding the following highlighted code to set
    up the view and the game engine:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过添加以下突出显示的代码来修改构造函数，以设置视图和游戏引擎：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Afterwards, you should be able to build the project. When you run it, you should
    see a result similar to the one in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，你应该能够构建项目。当你运行它时，你应该看到以下截图中的类似结果：
- en: '![Time for action – understanding the ChessView class](img/8874OS_05_19.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 理解 ChessView 类](img/8874OS_05_19.jpg)'
- en: '*What just happened?*'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In this exercise, we did two things. First we provided a number of methods for
    calculating the geometry of important parts of the chess board and the size of
    the widget. Second, we defined three virtual methods for rendering visual primitives
    of a chess board. By making the methods virtual, we provided an infrastructure
    to let the look be customized by subclassing and overriding base implementations.
    Furthermore, by reading color from `QPalette`, we allowed customizing the colors
    of the primitives even without subclassing.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们做了两件事。首先，我们提供了一些方法来计算棋盘重要部分和部件大小的几何形状。其次，我们定义了三个用于渲染棋盘视觉原语的方法。通过使这些方法成为虚拟的，我们提供了一个基础设施，允许通过子类化和覆盖基本实现来自定义外观。此外，通过从
    `QPalette` 读取颜色，我们允许自定义原语的颜色，即使不进行子类化也可以。
- en: The last line of the main window constructor tells the layout of the window
    to force a fixed size of the window equal to what the size hint of the widget
    inside it reports.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口构造函数的最后一行告诉布局强制窗口大小等于其中部件的大小提示。
- en: Time for action – rendering the pieces
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 渲染棋子
- en: Now that we can see the board, it is time to put the pieces on it. We are going
    to use images for that purpose. In my case, we found a number of SVG files with
    chess pieces and decided to use them. SVG is a vector graphics format where all
    curves are defined not as a fixed set of points but rather as mathematic curves.
    Their main benefit is that they scale very well without causing an aliasing effect.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到棋盘了，是时候在上面放置棋子了。我们将使用图像来完成这个任务。在我的情况下，我们找到了一些带有棋子的 SVG 文件，并决定使用它们。SVG
    是一种矢量图形格式，其中所有曲线都不是定义为固定的一组点，而是定义为数学曲线。它们的主要优点是它们可以很好地缩放，而不会产生锯齿效应。
- en: 'Let''s equip our view with a registry of images to be used for "stamping" a
    particular piece type. Since each piece type is identified with char, we can use
    it to generate keys for a map of images. Let''s put the following API into `ChessView`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的视图配备一个用于“盖章”特定棋子类型的图像注册表。由于每个棋子类型都与字符相关联，我们可以使用它来生成图像映射的键。让我们将以下 API
    放入 `ChessView`：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For the image type, we do not use `QImage` or `QPixmap` but rather `QIcon`.
    This is because `QIcon` can store many pixmaps of different sizes and use the
    most appropriate one when we request an icon of a given size to be painted. This
    doesn't matter if we use vector images, but it does matter if you choose to use
    PNG or other types of image. In such cases, you can use `addFile()` to add many
    images to a single icon.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our registry, the implementation is very simple. We just store
    the icon in a map and ask the widget to repaint itself:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we can fill the registry with actual images right after we create the view
    inside the `MainWindow` constructor. Note that we stored all the images in a resource
    file, as shown:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next thing to do is to extend the `paintEvent()` method of the view to
    actually render our pieces. For that, we will introduce another protected virtual
    method called `drawPiece()`. We''ll call it when iterating over all the ranks
    and columns of the board, as shown:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It is not a coincidence that we start drawing from the highest (top) rank to
    the lowest (bottom) one. By doing that, we allow a pseudo-3D effect: if a piece
    drawn extends past the area of the field, it will intersect the field from the
    next rank (which is possibly occupied by another piece). By drawing higher rank
    pieces first, we cause them to be partially covered by pieces from the lower rank,
    which imitates the effect of depth. By thinking ahead, we allow reimplementations
    of `drawPiece()` to have more freedom in what they can do.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to provide a base implementation for this method, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The method is very simple, it queries for the rectangle of a given column and
    rank, then asks the `ChessBoard` instance about the piece occupying the given
    field. If there is a piece there, we ask the registry for the proper icon; if
    we get a valid one, we call its `paint()` routine to draw the piece centered in
    the field's rect. The image drawn will be scaled to the size of the rectangle.
    It is important that you only use images with a transparent background (such as
    PNG or SVG files and not JPEG files) so that the color of the field can be seen
    through the piece.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the implementation, you can modify the algorithm to fill the board
    with the default piece set up by introducing the following change to the `ChessAlgorithm`
    class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running the program should show the following result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8874OS_05_20.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: 'The modification we did in this step was very simple. First we provided a way
    to tell the board what each piece type looks like. This includes not only standard
    chess pieces but anything that fits into char and can be set inside the `ChessBoard`
    class''s internal data array. Second, we made an abstraction for drawing the pieces
    with the simplest possible base implementation: taking an icon from the registry
    and rendering it to the field. By making use of `QIcon`, we can add several pixmaps
    of different sizes to be used with different sizes of a single field. Alternatively,
    the icon can contain a single vector image that scales very well all by itself.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中我们做的修改非常简单。首先，我们提供了一种方法来告诉棋盘每种棋子类型的外观。这包括不仅限于标准棋子，任何适合放入字符并可以设置在`ChessBoard`类内部数据数组中的东西。其次，我们为绘制棋子提供了一个抽象，使用最简单的基类实现：从注册表中取一个图标并将其渲染到字段上。通过使用`QIcon`，我们可以添加不同大小的多个位图，用于不同大小的单个字段。或者，图标可以包含一个单矢量图像，它可以自行很好地缩放。
- en: Time for action – making the chess game interactive
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使棋盘游戏交互式
- en: 'We have managed to display the chess board but to actually play a game, we
    have to tell the program what moves we want to play. We could do that by adding
    the `QLineEdit` widget where we would input the move in algebraic form (for example,
    `Nf3` to move a knight to `f3`), but a more natural way is to click a piece with
    the mouse cursor (or tap it with a finger) and then click again on the destination
    field. To obtain such functionality, the first thing to do is to teach `ChessView`
    to detect mouse clicks. Therefore, add the following method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功显示了棋盘，但要实际玩游戏，我们必须告诉程序我们想要进行的移动。我们可以通过添加`QLineEdit`小部件来实现这一点，在那里我们将以代数形式输入移动（例如，`Nf3`将马移动到`f3`），但更自然的方式是使用鼠标光标（或用手指轻触）点击一个棋子，然后再次点击目标字段。为了获得这种功能，首先要做的是教会`ChessView`检测鼠标点击。因此，添加以下方法：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The code looks very similar to the implementation of `fieldRect()`. This is
    because `fieldAt()` implements its reverse operation—it transforms a point in
    the widget coordinate space to the column and rank index of a field the point
    is contained in. The index is calculated by dividing point coordinates by the
    size of the field. You surely remember that, in the case of columns, the fields
    are offset by the size of the widest letter and a margin of 4 and we have to consider
    that in our calculations here as well. We do two checks: first we check the horizontal
    point coordinate against the offset to detect if the user clicked on the part
    of the widget where column symbols are displayed, and then we check if the rank
    and column calculated fit the range represented in the board. Finally, we return
    the result as a `QPoint` value since this is the easiest way in Qt to represent
    a two-dimensional value.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与`fieldRect()`的实现非常相似。这是因为`fieldAt()`实现了其逆操作——它将小部件坐标空间中的点转换为包含该点的字段的列和秩索引。索引是通过将点坐标除以字段大小来计算的。你肯定还记得，在列的情况下，字段通过最宽字母的大小和4个边距进行偏移，我们在这里的计算中也要考虑这一点。我们进行两个检查：首先，我们将水平点坐标与偏移量进行比较，以检测用户是否点击了显示列符号的小部件部分，然后我们检查计算出的秩和列是否适合在板上表示的范围。最后，我们将结果作为`QPoint`值返回，因为这是在Qt中表示二维值的最简单方式。
- en: 'Now we need to find a way to make the widget notify its environment that a
    particular field was clicked. We can do this through the signal-slot mechanism.
    Switch to the header file of `ChessView` (if you currently have chessview.cpp
    opened in Qt Creator, you can simply push the *F4* key to be transferred to the
    corresponding header file) and declare a `clicked(const QPoint &)` signal:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到一种方法让小部件通知其环境特定字段已被点击。我们可以通过信号-槽机制来实现。切换到`ChessView`的头文件（如果你目前在Qt Creator中打开了`chessview.cpp`，你可以简单地按*F4*键跳转到相应的头文件）并声明一个`clicked(const
    QPoint &)`信号：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To detect mouse input, we have to override one of the mouse event handlers
    a widget has, either `mousePressEvent` or `mouseReleaseEvent`. It seems obvious
    we should choose the former event; this would work, but it is not the best decision.
    Just think about the semantics of a mouse click: it is a complex event composed
    of pushing and releasing the mouse button. The actual "click" takes place after
    the mouse is released. Therefore let''s use `mouseReleaseEvent` as our event handler:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测鼠标输入，我们必须重写小部件具有的一个鼠标事件处理程序，即`mousePressEvent`或`mouseReleaseEvent`。显然，我们应该选择前者事件；这将有效，但并不是最佳选择。让我们想想鼠标点击的语义：它是由按下和释放鼠标按钮组成的复杂事件。实际的“点击”发生在鼠标释放之后。因此，让我们使用`mouseReleaseEvent`作为我们的事件处理程序：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The code is simple; we use the method we just implemented and pass it the position
    read from the `QMouseEvent` object. If the returned point is invalid, we quietly
    return from the method. Otherwise, `clicked()` is emitted with the obtained column
    and rank values.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单；我们使用刚刚实现的方法，并传递从`QMouseEvent`对象中读取的位置。如果返回的点无效，我们默默地从方法中返回。否则，将发出带有获得的列和行值的`clicked()`。
- en: 'We can make use of the signal now. Go to the constructor of `MainWindow` and
    add the following line to connect the widget''s clicked signal to a custom slot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用这个信号了。转到`MainWindow`的构造函数，并添加以下行以将小部件的点击信号连接到自定义槽位：
- en: '[PRE67]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Declare the slot and implement it as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 声明槽位并按以下方式实现：
- en: '[PRE68]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The function uses a class member variable `m_clickPoint` to store the clicked
    field. The variable value is made invalid after a move is made. Thus we can detect
    whether the click we are currently handling has "select" or "move" semantics.
    In the first case, we store the selection in `m_clickPoint`; in the other case,
    we ask the board to make a move using the helper method we implemented some time
    ago. Remember to declare `m_clickPoint` as a private member variable of `MasinWindow`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用类成员变量`m_clickPoint`来存储点击的字段。变量值在移动后变为无效。因此，我们可以检测我们目前正在处理的点击是否具有“选择”或“移动”语义。在前一种情况下，我们将选择存储在`m_clickPoint`中；在另一种情况下，我们要求棋盘使用我们之前实现的一些辅助方法进行移动。请记住将`m_clickPoint`声明为`MasinWindow`的私有成员变量。
- en: 'All should be working now. However, if you build the application, run it, and
    start clicking around on the chess board, you will see that nothing happens. This
    is because we forgot to tell the view to refresh itself when the game position
    on the board is changed. We have to connect the signals the board emits to the
    `update()` slot of the view. Open the `setBoard()` method of the widget class
    and fix it as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该一切正常。然而，如果你构建应用程序，运行它，并在棋盘上开始点击，你会发现没有任何反应。这是因为我们忘记告诉视图在棋盘上的游戏位置改变时刷新自己。我们必须将棋盘发出的信号连接到视图的`update()`槽位。打开小部件类的`setBoard()`方法，并按以下方式修复：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you run the program now, moves you make will be reflected in the widget,
    as shown:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你做出的移动将在小部件中反映出来，如下所示：
- en: '![Time for action – making the chess game interactive](img/8874OS_05_21.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 使棋盘游戏互动](img/8874OS_05_21.jpg)'
- en: At this point, we might consider the visual part of the game as finished, but
    there is still one problem you might have spotted while testing our latest additions.
    When you click on the board, there is no visual hint that any piece was actually
    selected. Let's fix that now by introducing the ability to highlight any field
    on the board.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能认为游戏的视觉部分已经完成，但在测试我们最新的添加时，你可能已经注意到了一个问题。当你点击棋盘时，没有任何视觉提示表明任何棋子实际上已被选中。现在让我们通过引入突出显示棋盘上任何字段的能力来修复这个问题。
- en: 'To do that, we will develop a generic system for different highlights. Begin
    by adding a `Highlight` class as an internal class to `ChessView`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将开发一个用于不同突出显示的通用系统。首先，将`Highlight`类作为`ChessView`的内部类添加：
- en: '[PRE70]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It is a minimalistic interface for highlights and only exposes a method returning
    the type of the highlight using a virtual method. In our exercise, we will focus
    on just a basic type that marks a single field with a given color. Such a situation
    is going to be represented by the `FieldHighlight` class:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简约的突出显示界面，仅通过一个返回突出显示类型的虚拟方法暴露方法。在我们的练习中，我们将专注于仅标记单个字段的基本类型，该类型使用给定的颜色。这种情况将由`FieldHighlight`类表示：
- en: '[PRE71]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can see we provided a constructor that takes the column and rank indices
    and a color for the highlight and stores them in private member variables. Also,
    `type()` is redefined to return `FieldHighlight::Type`, which we can use to easily
    identify the type of highlight. The next step is to extend `ChessView` with abilities
    to add and remove highlights. As the container declares a private `QList<Highlight*>
    m_highlights` member variable, add method declarations:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们提供了一个构造函数，它接受列索引和行索引以及一个用于高亮的颜色，并将它们存储在私有成员变量中。此外，`type()` 被重新定义以返回 `FieldHighlight::Type`，我们可以用它来轻松地识别高亮类型。下一步是扩展
    `ChessView` 以添加和删除高亮功能。由于容器声明了一个私有的 `QList<Highlight*> m_highlights` 成员变量，因此添加方法声明：
- en: '[PRE72]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next provide implementations for non-inline methods:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来提供非内联方法的实现：
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Drawing the highlights is really easy: we will use yet another virtual `draw`
    method. Place the following call in the `paintEvent()` implementation right before
    the loop that is responsible for rendering pieces:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制高亮非常简单：我们将使用另一个虚拟 `draw` 方法。在 `paintEvent()` 实现中，在负责渲染棋子的循环之前放置以下调用：
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The implementation simply iterates over all the highlights and renders those
    it understands.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 实现只是简单地遍历所有高亮，并渲染它所理解的高亮。
- en: '[PRE75]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: By checking the type of the highlight, we know which class to cast the generic
    pointer to. Then we can query the object for the needed data. Finally, we use
    `QPainter::fillRect()` to fill the field with the given color. As `drawHighlights()`
    is called before the piece painting loop and after the field painting loop, the
    highlight will cover the background but not the piece.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查高亮的类型，我们知道要将泛型指针转换成哪个类。然后我们可以查询对象以获取所需的数据。最后，我们使用 `QPainter::fillRect()`
    用给定的颜色填充场地。由于 `drawHighlights()` 在棋子绘制循环之前和场地绘制循环之后被调用，因此高亮将覆盖背景但不会覆盖棋子。
- en: 'That''s the basic highlighting system. Let''s make our `viewClicked()` slot
    use it:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本的高亮系统。让我们让 `viewClicked()` 插槽使用它：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Notice how we check that a field can only be selected if it is not empty (that
    is, there is an existing piece occupying that field)?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何检查一个场地只有在它不为空的情况下（也就是说，有一个现有的棋子占据该场地）才能被选中的？
- en: You should also add a `ChessView::FieldHighlight *m_selectedField` private member
    variable and initialize it with a null pointer in the constructor. You can now
    build the game, execute it, and start moving pieces around.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该添加一个 `ChessView::FieldHighlight *m_selectedField` 私有成员变量，并在构造函数中将其初始化为空指针。现在您可以构建游戏，执行它，并开始移动棋子。
- en: '![Time for action – making the chess game interactive](img/8874OS_05_22.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![是时候行动起来——制作交互式棋盘游戏](img/8874OS_05_22.jpg)'
- en: '*What just happened?*'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: By adding a few lines of code, we managed to make the board clickable. We connected
    a custom slot that reads which field was clicked and can highlight it with a semi-transparent
    red color. Clicking on another field will move the highlighted piece there. The
    highlighting system we developed is very generic. We use it to highlight a single
    field with a solid color, but you can mark as many fields as you want with a number
    of different colors, for example, to show valid moves after selecting a piece.
    The system can easily be extended with new types of highlights; for example, you
    can draw arrows on the board using `QPainterPath` to have a complex hinting system
    (say showing the player the suggested move).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加几行代码，我们成功地使棋盘可点击。我们连接了一个自定义槽，该槽读取被点击的场地，并可以用半透明的红色颜色高亮显示它。点击另一个场地将移动高亮显示的棋子到那里。我们开发的高亮系统非常通用。我们用它用纯色高亮显示单个场地，但您可以用多种不同的颜色标记任意数量的场地，例如，在选中一个棋子后显示有效移动。该系统可以很容易地通过新的高亮类型进行扩展；例如，您可以使用
    `QPainterPath` 在棋盘上绘制箭头，以拥有一个复杂提示系统（比如向玩家显示建议的移动）。
- en: '![What just happened?](img/8874OS_05_23.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/8874OS_05_23.jpg)'
- en: Time for action – connecting the game algorithm
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动起来——连接游戏算法
- en: It would take us too long to implement a full chess game algorithm here, so
    we will instead settle for a much simpler game called Fox and Hounds. One of the
    players has four pawns (hounds) which can only move over black fields and the
    pawn can only move in a forward fashion (toward higher ranks). The other player
    has just a single pawn (fox) which starts from the opposite side of the board.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里实现完整的棋盘游戏算法会花费我们太多时间，所以我们将满足于一个名为狐狸与猎犬的简单游戏。其中一位玩家有四个兵（猎犬），它们只能移动到黑色场地，并且兵只能向前移动（向更高的排数移动）。另一位玩家只有一个兵（狐狸），它从棋盘的另一侧开始。
- en: '![Time for action – connecting the game algorithm](img/8874OS_05_24.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 连接游戏算法](img/8874OS_05_24.jpg)'
- en: It can also move only over black fields; however it can move both forwards (toward
    higher ranks) as well as backwards (toward lower ranks). Players move in turns
    by moving their pawn by to a neighboring black field. The goal of the fox is to
    reach the opposite end of the board; the goal of the hounds is to trap the fox
    so that it can't make a move.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 它只能移动到黑色棋盘上；然而，它可以向前（向更高等级）和向后（向更低等级）移动。玩家通过将他们的棋子移动到相邻的黑色棋盘上来轮流移动。狐狸的目标是到达棋盘的另一端；猎犬的目标是捕捉狐狸，使其无法移动。
- en: '![Time for action – connecting the game algorithm](img/8874OS_05_25.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 连接游戏算法](img/8874OS_05_25.jpg)'
- en: 'Time to get to work! First we will extend the `ChessAlgorithm` class with the
    required interface:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始工作了！首先，我们将扩展 `ChessAlgorithm` 类以包含所需的接口：
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'There are two sets of members here. First we have a number of enums, variables,
    signals, and methods that are related to the state of the game: which player should
    make his move now and what is currently the result of the game. The `Q_ENUMS`
    macro is used to register enumerations in Qt''s meta-type system so that they
    can be used as values for properties or arguments in signals. Property declarations
    and getters for them don''t need any extra explanation. We have also declared
    protected methods for setting the variables from within subclasses. Here is their
    suggested implementation:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两组成员。首先，我们有一些与游戏状态相关的枚举、变量、信号和方法：哪个玩家应该移动，以及当前游戏的结果是什么。`Q_ENUMS` 宏用于在 Qt
    的元类型系统中注册枚举，以便它们可以用作属性或信号中的值。属性声明及其获取器不需要任何额外说明。我们还在子类中声明了用于设置变量的受保护方法。以下是它们的建议实现：
- en: '[PRE78]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Remember about initializing `m_currentPlayer` and `m_result` to `NoPlayer` and
    `NoResult` in the constructor of the `ChessAlgorithm` class.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 `ChessAlgorithm` 类的构造函数中将 `m_currentPlayer` 和 `m_result` 初始化为 `NoPlayer`
    和 `NoResult`。
- en: 'The second group of functions is methods that modify the state of the game—the
    two variants of `move()`. The virtual variant is meant to be reimplemented by
    the real algorithm to check whether a given move is valid in the current game
    state and if that is the case, to perform the actual modification of the game
    board. In the base class, we can simply reject all possible moves:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组函数是修改游戏状态的函数——`move()` 的两个变体。虚拟变体意味着由实际算法重新实现，以检查给定移动在当前游戏状态中是否有效，如果是这样，则执行游戏棋盘的实际修改。在基类中，我们可以简单地拒绝所有可能的移动：
- en: '[PRE79]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`Q_UNUSED` is a macro to prevent the compiler from issuing warnings during
    compilation if the enclosed local variable is never used in the scope.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_UNUSED` 是一个宏，用于防止编译器在编译期间发出关于包含的局部变量从未在作用域中使用过的警告。'
- en: The overload is simply a convenience method that accepts two `QPoint` objects
    instead of four integers.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 重载是一个方便的方法，它接受两个 `QPoint` 对象而不是四个整数。
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The interface for the algorithm is ready now and we can implement it for the
    Fox and Hounds game. Subclass `ChessAlgorithm` to create a `FoxAndHounds` class:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的接口现在已经准备好了，我们可以为狐狸和猎犬游戏实现它。从 `ChessAlgorithm` 派生一个 `FoxAndHounds` 类：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The implementation of `newGame()` is pretty simple: we set up the board, place
    pieces on it, and signal that it is time for the first player to make their move.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`newGame()` 的实现相当简单：我们设置棋盘，放置棋子，并发出信号，表示现在是第一位玩家的移动时间。'
- en: '[PRE82]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The algorithm for the game is quite simple. Implement `move()` as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的算法相当简单。按照以下方式实现 `move()`：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Declare a protected `foxCanMove()` method and implement it using the following
    code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个受保护的 `foxCanMove()` 方法，并使用以下代码实现它：
- en: '[PRE84]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then do the same with `emptyByOffset()`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对 `emptyByOffset()` 也进行相同的操作：
- en: '[PRE85]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Lastly declare a private `QPoint m_fox` member variable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，声明一个私有的 `QPoint m_fox` 成员变量。
- en: 'The simplest way to test the game is to make two changes to the code. First,
    in the constructor of the main window class, replace `m_algorithm = new ChessAlgorithm(this)`
    with `m_algorithm = new FoxAndHounds(this)`. Second, modify the `viewClicked()`
    slot as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏的简单方法是对代码进行两项更改。首先，在主窗口类的构造函数中，将 `m_algorithm = new ChessAlgorithm(this)`
    替换为 `m_algorithm = new FoxAndHounds(this)`。其次，修改 `viewClicked()` 槽如下：
- en: '[PRE86]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can also connect signals from the algorithm class to custom slots of the
    view or window to notify about the end of the game and provide a visual hint as
    to which player should make his move now.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将算法类的信号连接到视图或窗口的自定义槽，以通知游戏结束，并为当前应该移动的玩家提供视觉提示。
- en: '*What just happened?*'
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a very simplistic API for implementing chess-like games by introducing
    the `newGame()` and `move()` virtual methods to the algorithm class. The former
    method simply sets everything up. The latter uses simple checks to determine whether
    a particular move is valid and if the game has ended. We use the `m_fox` member
    variable to track the current position of the fox to be able to quickly determine
    if it has any valid moves. When the game ends, the `gameOver()` signal is emitted
    and the result of the game can be obtained from the algorithm. You can use the
    exact same framework for implementing all chess rules.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在算法类中引入`newGame()`和`move()`虚拟方法来创建一个实现类似国际象棋游戏的非常简单的API。前者方法只是简单地设置一切。后者使用简单的检查来确定特定的移动是否有效以及游戏是否结束。我们使用`m_fox`成员变量来跟踪狐狸的当前位置，以便能够快速确定它是否有任何有效的移动。当游戏结束时，会发出`gameOver()`信号，并可以从算法中获取游戏的结果。你可以使用完全相同的框架来实现所有国际象棋规则。
- en: Have a go hero – implementing the UI around the chess board
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大胆尝试英雄——围绕棋盘实现UI
- en: During the exercise, we focused on developing the game board view and necessary
    classes to make the game actually run. But we completely neglected the regular
    user interface the game might possess, such as toolbars and menus. You can try
    designing a set of menus and toolbars for the game. Make it possible to start
    a new game, save a game in progress (say by implementing a FEN serializer), load
    a saved game (say by leveraging the existing FEN string parser), or choose different
    game types that will spawn different `ChessAlgorithm` subclasses. You can also
    provide a settings dialog for adjusting the look of the game board. If you feel
    like it, you can add chess clocks or implement a simple tutorial system that will
    guide the player through the basics of chess using text and visual hints via the
    highlight system we implemented.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习过程中，我们专注于开发游戏板视图和必要的类，以便使游戏能够实际运行。但我们完全忽略了游戏可能拥有的常规用户界面，例如工具栏和菜单。你可以尝试为游戏设计一套菜单和工具栏。使其能够启动新游戏，保存进行中的游戏（例如通过实现FEN序列化器），加载已保存的游戏（例如通过利用现有的FEN字符串解析器），或者选择不同的游戏类型，这将生成不同的`ChessAlgorithm`子类。你也可以提供一个设置对话框来调整游戏板的样式。如果你愿意，你可以添加棋钟或实现一个简单的教程系统，该系统将通过文本和视觉提示（通过我们实现的突出显示系统）引导玩家了解国际象棋的基础。
- en: Have a go hero – connecting a UCI-compliant chess engine
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大胆尝试英雄——连接一个UCI兼容的棋引擎
- en: 'If you really want to test your skills, you can implement a `ChessAlgorithm`
    subclass that will connect to a **Universal Chess Interface** (UCI) chess engine
    such as StockFish ([http://stockfishchess.org](http://stockfishchess.org)) and
    provide a challenging artificial intelligence opponent for a human player. UCI
    is the de facto standard for communication between a chess engine and a chess
    frontend. Its specification is freely available, so you can study it on your own.
    To talk to a UCI-compliant engine you can use `QProcess`, which will spawn the
    engine as an external process and attach itself to its standard input and standard
    output. Then you can send commands to the engine by writing to its standard input
    and read messages from the engine by reading its standard output. To get you started,
    here is a short snippet of code that starts the engine and attaches to its communication
    channels:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想测试你的技能，你可以实现一个连接到**通用国际象棋接口**（UCI）棋引擎（如StockFish [http://stockfishchess.org](http://stockfishchess.org)）的`ChessAlgorithm`子类，并为人类玩家提供一个具有挑战性的人工智能对手。UCI是棋引擎和棋前端之间通信的事实标准。其规范是免费提供的，因此你可以自行研究。要与UCI兼容的引擎通信，你可以使用`QProcess`，它将引擎作为外部进程启动，并将其附加到其标准输入和标准输出。然后你可以通过写入标准输入向引擎发送命令，通过读取标准输出从引擎读取消息。为了帮助你入门，这里有一段简短的代码片段，用于启动引擎并附加到其通信通道：
- en: '[PRE87]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: OpenGL
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL
- en: We are not experts on OpenGL, so in this part of the chapter we will not teach
    you to do any fancy stuff with OpenGL and Qt but rather will show you how to enable
    the use of your OpenGL skills in Qt applications. There are a lot of tutorials
    and courses on OpenGL out there so if you're not that skilled with OpenGL, you
    can still benefit from what is described here by employing the knowledge gained
    here to more easily learn fancy stuff. You can use external materials and a high-level
    API offered by Qt, which is going to speed up many of the tasks described in the
    tutorials.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是 OpenGL 的专家，所以在本章的这一部分，我们不会教您如何使用 OpenGL 和 Qt 做任何花哨的事情，而是向您展示如何使您的 OpenGL
    技能在 Qt 应用程序中使用。关于 OpenGL 有很多教程和课程，如果您对 OpenGL 的技能不是那么熟练，您仍然可以通过应用在这里获得的知识来更容易地学习花哨的事情。您可以使用外部材料和
    Qt 提供的高级 API，这将加快教程中描述的许多任务的执行。
- en: Introduction to OpenGL with Qt
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Qt 的 OpenGL 简介
- en: There are basically two ways you can use OpenGL in Qt. The first approach is
    to use `QOpenGLWidget`. This is mostly useful if your application heavily depends
    on other widgets (for example. the 3D view is only one of the views in your application
    and is controlled using a bunch of other widgets surrounding the main view). The
    other way is to use `QOpenGLWindow`; this is most useful when the GL window is
    the dominant or even the only part of the program. Both APIs are very similar;
    they use instances of the `QOpenGLContext` class to access the GL context. The
    difference is practically only in how they render the scene to the window. `QOpenGLWindow`
    renders directly to the given window, while `QOpenGLWidget` first renders to an
    offscreen buffer that is then rendered to the widget. The advantage of the latter
    approach is that `QOpenGLWidget` can be part of a more complex widget layout while
    `QOpenGLWindow` is usually used as the sole, often fullscreen, window. In this
    chapter we will be using the more direct approach (`QOpenGLWindow`); however,
    bear in mind that you can do everything described here using the widget too. Just
    replace the window classes with their widget equivalents and you should be good
    to go.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中使用 OpenGL 基本上有两种方式。第一种方法是使用 `QOpenGLWidget`。这通常在你应用程序严重依赖于其他小部件时很有用（例如，3D
    视图只是你应用程序中的视图之一，并且通过围绕主视图的一堆其他小部件来控制）。另一种方法是使用 `QOpenGLWindow`；这在 GL 窗口是主导的甚至可能是程序唯一部分时最有用。这两个
    API 非常相似；它们使用 `QOpenGLContext` 类的实例来访问 GL 上下文。它们之间的区别实际上仅在于它们将场景渲染到窗口的方式。`QOpenGLWindow`
    直接渲染到指定的窗口，而 `QOpenGLWidget` 首先渲染到一个离屏缓冲区，然后该缓冲区被渲染到小部件上。后一种方法的优势在于 `QOpenGLWidget`
    可以成为更复杂的小部件布局的一部分，而 `QOpenGLWindow` 通常用作唯一的、通常是全屏的窗口。在本章中，我们将使用更直接的方法（`QOpenGLWindow`）；然而，请注意，您也可以使用小部件来完成这里描述的所有操作。只需将窗口类替换为它们的小部件等效类，您就应该可以开始了。
- en: We said that the whole API revolves around the `QOpenGLContext` class. It represents
    the overall state of the GL pipeline, which guides the process of data processing
    and rendering to a particular device.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到整个 API 都围绕着 `QOpenGLContext` 类展开。它代表了 GL 管道整体状态，指导数据处理和渲染到特定设备的过程。
- en: A related concept that needs explanation is the idea of a GL context being "current"
    in a thread. The way OpenGL calls work is that they do not use any handle to any
    object containing information on where and how to execute the series of low-level
    GL calls. Instead, it is assumed that they are executed in the context of the
    current machine state. The state may dictate whether to render a scene to a screen
    or to a frame buffer object, which mechanisms are enabled, or the properties of
    the surface OpenGL is rendering on. Making a context "current" means that all
    further OpenGL operations issued by a particular thread will be applied to this
    context. To add to that, a context can be "current" only in one thread at the
    same time; therefore, it is important to make the context current before making
    any OpenGL calls and then marking it as available after you are done accessing
    OpenGL resources.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的另一个相关概念是 GL 上下文在某个线程中是“当前”的。OpenGL 调用的方式是，它们不使用任何包含有关在哪里以及如何执行一系列低级 GL
    调用的对象的句柄。相反，它们假定是在当前机器状态的环境中执行的。状态可能规定是否将场景渲染到屏幕或帧缓冲区对象，启用了哪些机制，或者 OpenGL 正在渲染的表面的属性。使上下文“当前”意味着所有由特定线程发出的后续
    OpenGL 操作都将应用于此上下文。此外，上下文在同一时间只能在一个线程中“当前”；因此，在执行任何 OpenGL 调用之前使上下文“当前”，并在完成访问
    OpenGL 资源后将其标记为可用，这一点非常重要。
- en: '`QOpenGLWindow` has a very simple API that hides most of the unnecessary details
    from the developer. Apart from constructors and a destructor, it provides a small
    number of very useful methods. First there are auxiliary methods for managing
    the OpenGL context: `context()`, which returns the context, and `makeCurrent()`
    as well as `doneCurrent()` for acquiring and releasing the context. The remaining
    methods of the class are a number of virtual methods we can reimplement to display
    OpenGL graphics.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`QOpenGLWindow`有一个非常简单的API，它隐藏了大多数不必要的细节，对开发者来说。除了构造函数和析构函数之外，它还提供了一小部分非常有用的方法。首先，有一些辅助方法用于管理OpenGL上下文：`context()`返回上下文，以及`makeCurrent()`和`doneCurrent()`用于获取和释放上下文。该类剩余的方法是一系列我们可以重写的虚拟方法，用于显示OpenGL图形。'
- en: The first method is called `initializeGL()`, and it is invoked by the framework
    once before any painting is actually done so that you can prepare any resources
    or initialize the context in any way you require.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法被称为`initializeGL()`，框架在实际上进行任何绘画之前会调用它一次，以便你可以准备任何资源或以任何你需要的任何方式初始化上下文。
- en: 'Then there are two most important methods: `resizeGL()` and `paintGL()`. The
    first is a callback invoked every time the window is resized. It accepts the width
    and height of the window as parameters. You can make use of that method by reimplementing
    it so that you can prepare yourself for the fact that the next call to the other
    method, `paintGL()`, renders to a viewport of a different size. Speaking of `paintGL()`,
    this is the equivalent of `paintEvent()` for the widget classes; it gets executed
    whenever the window needs to be repainted. This is the function where you should
    put your OpenGL rendering code.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有两个最重要的方法：`resizeGL()`和`paintGL()`。第一个方法是在窗口大小改变时被调用的回调函数。它接受窗口的宽度和高度作为参数。你可以通过重写该方法来利用它，以便为其他方法`paintGL()`的调用做好准备，该方法将渲染不同大小的视口。说到`paintGL()`，这是小部件类中`paintEvent()`的等价方法；每当窗口需要重绘时，它都会被执行。这是你应该放置OpenGL渲染代码的函数。
- en: Time for action – drawing a triangle using Qt and OpenGL
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用Qt和OpenGL绘制三角形
- en: 'For the first exercise, we will create a subclass of `QOpenGLWindow` that renders
    a triangle using simple OpenGL calls. Create a new project starting with **Empty
    qmake Project** from the **Other Projects** group as the template. In the project
    file, put the following content:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个练习，我们将创建一个`QOpenGLWindow`的子类，使用简单的OpenGL调用渲染一个三角形。从**其他项目**组中选择**空qmake项目**作为模板，创建一个新的项目。在项目文件中，输入以下内容：
- en: '[PRE88]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Having the basic project setup ready, let's define a `SimpleGLWindow` class
    as a subclass of `QOpenGLWindow` and override the `initializeGL()` method to set
    white as the clear color of our scene. We do this by calling an OpenGL function
    called `glClearColor`. Qt provides a convenience class called `QOpenGLFunctions`
    that takes care of resolving most commonly used OpenGL functions in a platform-independent
    way. This is the recommended approach to access OpenGLES functions in a platform-independent
    manner. Our window is going to inherit not only `QOpenGLWindow` but also `QOpenGLFunctions`.
    However, since we don't want to allow external access to those functions, we use
    protected inheritance.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 基本项目设置就绪后，让我们定义一个`SimpleGLWindow`类作为`QOpenGLWindow`的子类，并重写`initializeGL()`方法，将白色设置为场景的清除颜色。我们通过调用名为`glClearColor`的OpenGL函数来实现这一点。Qt提供了一个名为`QOpenGLFunctions`的便利类，它以平台无关的方式处理大多数常用的OpenGL函数。这是以平台无关的方式访问OpenGLES函数的推荐方法。我们的窗口将继承`QOpenGLWindow`和`QOpenGLFunctions`。然而，由于我们不希望允许外部访问这些函数，我们使用了保护继承。
- en: '[PRE89]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In `initializeGL()`, we first call `initializeOpenGLFunctions()`, which is a
    method of the `QOpenGLFunctions` class, one of the base classes of our window
    class. The method takes care of setting up all the functions according to the
    parameters of the current GL context (thus it is important to first make the context
    current, which luckily is done for us behind the scenes before `initializeGL()`
    is invoked). Then we set the clear color of the scene to white.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initializeGL()`中，我们首先调用`initializeOpenGLFunctions()`，这是`QOpenGLFunctions`类的一个方法，也是我们窗口类的一个基类。该方法负责根据当前GL上下文的参数设置所有函数（因此，首先使上下文成为当前上下文非常重要，幸运的是，在调用`initializeGL()`之前，这已经在幕后为我们完成了）。然后我们将场景的清除颜色设置为白色。
- en: 'The next step is to reimplement `paintGL()` and put the actual drawing code
    there:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重写`paintGL()`并将实际的绘图代码放在那里：
- en: '[PRE90]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This function first clears the color buffer and sets the GL viewport of the
    context to be the size of the window. Then we tell OpenGL to start drawing using
    triangles with the `glBegin()` call and passing `GL_TRIANGLES` as the drawing
    mode. Then we pass three vertices along with their colors to form a triangle.
    Finally, we inform the pipeline by invoking `glEnd()` that we are done drawing
    using the current mode.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先清除颜色缓冲区，并将上下文的GL视口设置为窗口的大小。然后我们告诉OpenGL使用`glBegin()`调用开始绘制，传递`GL_TRIANGLES`作为绘制模式。然后我们传递三个顶点及其颜色来形成一个三角形。最后，通过调用`glEnd()`通知管道我们已完成当前模式的绘制。
- en: 'What is left is a trivial `main()` function that sets up the window and starts
    the event loop. Add a new **C++ Source File**, call it main.cpp, and implement
    `main()` as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是一个简单的`main()`函数，用于设置窗口并启动事件循环。添加一个新的**C++源文件**，命名为main.cpp，并实现`main()`如下：
- en: '[PRE91]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![Time for action – drawing a triangle using Qt and OpenGL](img/8874OS_05_13.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践时间 – 使用 Qt 和 OpenGL 绘制三角形](img/8874OS_05_13.jpg)'
- en: Tip
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can see the triangle has jagged edges. That''s because of the aliasing
    effect. You can counter it by enabling multisampling for the window, which will
    make OpenGL render the contents multiple times and then average the result, which
    acts as antialiasing. To do that, add the following code to the constructor of
    the window:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到三角形有锯齿状的边缘。这是因为走样效应。你可以通过为窗口启用多采样来抵消它，这将使OpenGL多次渲染内容，然后平均结果，这起到抗锯齿的作用。为此，将以下代码添加到窗口的构造函数中：
- en: '[PRE92]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Drawing colored triangles is fun, but drawing textured cubes is even more fun
    so let's see how we can use OpenGL textures with Qt.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制彩色三角形很有趣，但绘制纹理立方体更有趣，所以让我们看看我们如何使用OpenGL纹理与Qt结合。
- en: Time for action – scene-based rendering
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践时间 – 基于场景的渲染
- en: Let's take our rendering code to a higher level. Putting OpenGL code directly
    into the `window` class requires subclassing the window class and makes the window
    class more and more complex. Let's follow good programming practice and separate
    rendering code from window code.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的渲染代码提升到一个更高的层次。直接将OpenGL代码放入`window`类需要子类化窗口类，并使窗口类变得越来越复杂。让我们遵循良好的编程实践，将渲染代码与窗口代码分开。
- en: 'Create a new class and call it `AbstractGLScene`. It is going to be the base
    class for definitions of OpenGL scenes. You can derive the class (with protected
    scope) from `QOpenGLFunctions` to make accessing different GL functions easier.
    Make the scene class accept a pointer to `QOpenGLWindow`, either in the constructor
    or through a dedicated setter method. Make sure the pointer is stored in the class
    for easier access as we are going to rely on that pointer for accessing physical
    properties of the window. Add methods for querying the window''s OpenGL context.
    You should end up with code similar to the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`AbstractGLScene`。它将成为OpenGL场景定义的基类。你可以从`QOpenGLFunctions`派生这个类（具有保护作用），以便更容易访问不同的GL函数。让场景类接受一个指向`QOpenGLWindow`的指针，无论是在构造函数中还是在专门的设置器方法中。确保将指针存储在类中，以便更容易访问，因为我们将要依赖这个指针来访问窗口的物理属性。添加查询窗口OpenGL上下文的方法。最终，你的代码可能类似于以下内容：
- en: '[PRE93]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now the essential part begins. Add two pure virtual methods called `paint()`
    and `initialize()`. Also remember about adding a virtual destructor.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最重要的部分开始了。添加两个纯虚方法，分别命名为`paint()`和`initialize()`。还要记得添加一个虚析构函数。
- en: Tip
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Instead of making `initialize()` a pure virtual function, you can implement
    its body in such a way that it will call `initializeOpenGLFunctions()` to fulfill
    the requirements of the `QOpenGFunctions` class. Then, subclasses of `AbstractGLScene`
    can make sure the functions are initialized properly by calling the base class
    implementation of `initialize()`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必将`initialize()`实现为纯虚函数，你可以以这种方式实现其主体，使其调用`initializeOpenGLFunctions()`来满足`QOpenGFunctions`类的要求。然后，`AbstractGLScene`的子类可以通过调用基类的`initialize()`实现来确保函数被正确初始化。
- en: Next, create a subclass of `QOpenGLWindow` and call it `SceneGLWindow`. Equip
    it with setter and getter methods to allow the object to operate on an `AbstractGLScene`
    instance.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`QOpenGLWindow`的子类，命名为`SceneGLWindow`。给它配备设置器和获取器方法，以便对象能够操作`AbstractGLScene`实例。
- en: 'Then reimplement the `initializeGL()` and `paintGL()` methods and make them
    call appropriate equivalents in the scene:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新实现`initializeGL()`和`paintGL()`方法，并使它们调用场景中的适当等效方法：
- en: '[PRE94]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '*What just happened?*'
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have just set up a class chain that separates the window code from the actual
    OpenGL scene. The window forwards all calls related to scene contents to the scene
    object so that when the window is requested to repaint itself, it delegates the
    task to the scene object. Note that prior to doing that, the window will make
    the GL context current; therefore, all OpenGL calls the scene makes will be related
    to that context. You can store the code created in this exercise for later reuse
    in further exercises and your own projects.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了一个类链，它将窗口代码与实际的OpenGL场景分开。窗口将所有与场景内容相关的调用转发到场景对象，以便当窗口被请求重绘时，它将任务委托给场景对象。请注意，在这样做之前，窗口将使GL上下文成为当前上下文；因此，场景所做的所有OpenGL调用都将与该上下文相关。您可以将在此练习中创建的代码存储起来，以供后续练习和自己的项目重用。
- en: Time for action – drawing a textured cube
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 绘制纹理立方体
- en: 'Subclass `AbstractGLScene` and implement the constructor to match the one from
    `AbstractGLScene`. Add a method to store a `QImage` object in the scene that will
    contain texture data for the cube. Add a `QOpenGLTexture` pointer member as well,
    which will contain the texture, initialize it to 0 in the constructor, and delete
    it in the destructor. Let''s call the image object `m_tex` and the texture `m_texture`.
    Now add a protected `initializeTexture()` method and fill it with the following
    code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 继承`AbstractGLScene`并实现构造函数以匹配`AbstractGLScene`中的构造函数。添加一个方法来存储包含立方体纹理数据的`QImage`对象。同时添加一个`QOpenGLTexture`指针成员，它将包含纹理，在构造函数中将它初始化为0，并在析构函数中删除它。让我们称图像对象为`m_tex`，纹理为`m_texture`。现在添加一个受保护的`initializeTexture()`方法，并用以下代码填充它：
- en: '[PRE95]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The function first mirrors the image vertically. This is because OpenGL expects
    the texture to be "upside down". Then we create a `QOpenGLTexture` object, passing
    it our image. Then we set minification and magnification filters so that the texture
    looks better when it is scaled.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先垂直翻转图像。这是因为OpenGL期望纹理是“颠倒的”。然后我们创建一个`QOpenGLTexture`对象，传递我们的图像。然后我们设置缩小和放大过滤器，以便在缩放时纹理看起来更好。
- en: We are now ready to implement the `initialize()` method that will take care
    of setting up the texture and the scene itself.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始实现`initialize()`方法，该方法将负责设置纹理和场景本身。
- en: '[PRE96]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We make use of a flag called `m_initialized`. This flag is needed to prevent
    the texture from being set up too early (when no GL context is available yet).
    Then we check if the texture image is set (using the `QImage::isNull()` method);
    if so, we initialize the texture. Then we set some additional properties of the
    GL context.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`m_initialized`的标志。这个标志是必要的，以防止纹理设置得太早（当还没有GL上下文可用时）。然后我们检查纹理图像是否已设置（使用`QImage::isNull()`方法）；如果是，我们初始化纹理。然后我们设置GL上下文的某些附加属性。
- en: Tip
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the setter for `m_tex`, add code that checks if `m_initialized` is set to
    `true` and if so, calls `initializeTexture()`. This is to make certain that the
    texture is properly set regardless of the order in which the setter and `initialize()`
    are called. Also remember to set `m_initialized` to `false` in the constructor.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在`m_tex`的设置器中，添加代码检查`m_initialized`是否设置为`true`，如果是，则调用`initializeTexture()`。这是为了确保无论设置器和`initialize()`调用的顺序如何，纹理都能正确设置。同时，记得在构造函数中将`m_initialized`设置为`false`。
- en: The next step is to prepare the cube data. We will define a special data structure
    for the cube that groups vertex coordinates and texture data in a single object.
    To store coordinates, we are going to use classes tailored to that purpose—`QVector3D`
    and `QVector2D`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备立方体数据。我们将为立方体定义一个特殊的数据结构，该结构将顶点坐标和纹理数据组合在一个单独的对象中。为了存储坐标，我们将使用专门为此目的定制的类——`QVector3D`和`QVector2D`。
- en: '[PRE97]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`QVector<TexturedPoint>` will hold information for the whole cube. The vector
    is initialized with data using the following code:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector<TexturedPoint>`将保存整个立方体的信息。该向量使用以下代码初始化：'
- en: '[PRE98]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The code uses C++11 syntax to operate on the vector. If you have an older compiler,
    you will have to use `QVector::append()` instead.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用C++11语法来操作向量。如果你有一个较旧的编译器，你将不得不使用`QVector::append()`。
- en: '[PRE99]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The cube consists of six faces and is centered on the origin of the coordinate
    system. The following image presents the same data in graphical form. Purple figures
    are texture coordinates in UV coordinate space.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体由六个面组成，位于坐标系的原点。以下图像以图形形式展示了相同的数据。紫色图形是UV坐标空间中的纹理坐标。
- en: '![Time for action – drawing a textured cube](img/8874OS_05_14.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 绘制纹理立方体](img/8874OS_05_14.jpg)'
- en: '`initializeCubeData()` should be called from the scene constructor or from
    the `initialize()` method. What remains is the painting code.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeCubeData()`应该从场景构造函数或从`initialize()`方法中调用。剩下的就是绘图代码。'
- en: '[PRE100]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'First we set up the viewport and then we rotate the view. Before calling `paintCube()`,
    which is going to render the cube itself, we enable depth testing and face culling
    so that only visible faces are drawn. The `paintCube()` routine looks as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置视口，然后旋转视图。在调用`paintCube()`之前，该函数将渲染立方体本身，我们启用深度测试和面剔除，以便只绘制可见的面。`paintCube()`例程如下所示：
- en: '[PRE101]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: First the texture is bound and texturing is enabled. Then we enter the quad
    drawing mode and stream in data from our data structure. Finally, we disable texturing
    again.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 首先绑定纹理并启用纹理映射。然后我们进入四边形绘制模式，并从我们的数据结构中流式传输数据。最后，再次禁用纹理映射。
- en: 'For completeness, here is a `main()` function that executes the scene:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，这里是一个执行场景的`main()`函数：
- en: '[PRE102]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Please note the use of `QSurfaceFormat` to enable multisample antialiasing for
    the scene. We have also put the texture image into a resource file to avoid problems
    with the relative path to the file.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`QSurfaceFormat`为场景启用多采样抗锯齿。我们还将纹理图像放入资源文件中，以避免文件相对路径的问题。
- en: Have a go hero – animating a cube
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 - 动画一个立方体
- en: 'Try modifying the code to make the cube animated. To do that, have the scene
    inherit `QObject`, add an angle property of type `float` to it (remember about
    the `Q_OBJECT` macro). Then modify one of the `glRotatef()` lines to use the angle
    value instead of a constant value. Put the following code in `main()` right before
    calling `app.exec()`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改代码以使立方体动画化。为此，让场景继承`QObject`，向其中添加一个类型为`float`的角度属性（记得关于`Q_OBJECT`宏）。然后修改`glRotatef()`中的一行，使用角度值而不是常数值。在`main()`中，在调用`app.exec()`之前放入以下代码：
- en: '[PRE103]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Remember to put a call to `window()->update()` in the setter for the angle property
    so that the scene is redrawn.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在角度属性的setter中调用`window()->update()`，以便重新绘制场景。
- en: Modern OpenGL with Qt
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带Qt的现代OpenGL
- en: OpenGL code shown in the previous section uses a very old technique of streaming
    vertices one by one into a fixed OpenGL pipeline. Nowadays, modern hardware is
    much more feature rich and not only does it allow faster processing of vertex
    data but it also offers the ability to adjust different processing stages with
    the use of reprogrammable units called shaders. In this section, we will take
    a look at what Qt has to offer in the domain of a "modern" approach to using OpenGL.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中显示的OpenGL代码使用了一种非常古老的技术，即逐个将顶点流式传输到一个固定的OpenGL管道中。如今，现代硬件功能更加丰富，不仅允许更快地处理顶点数据，而且还提供了使用可重编程单元（着色器）调整不同处理阶段的能力。在本节中，我们将探讨Qt在“现代”OpenGL使用方法领域的提供内容。
- en: Shaders
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器
- en: Qt can make use of shaders through a set of classes based around `QOpenGLShaderProgram`.
    This class allows compiling, linking, and executing shader programs written in
    GLSL. You can check if your OpenGL implementation supports shaders by inspecting
    the result of a static `QOpenGLShaderProgram::hasOpenGLShaderPrograms()` call
    that accepts a pointer to a GL context. All modern hardware and all decent graphics
    drivers should have some support for shaders. A single shader is represented by
    an instance of the `QOpenGLShader` class. Using it, you can decide on the type
    of shader, associate, and shader source code. The latter is done by calling `QOpenGLShader::compileSourceCode()`,
    which has a number of overloads for handling different input formats.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Qt可以通过基于`QOpenGLShaderProgram`的一系列类来使用着色器。这个类允许编译、链接和执行用GLSL编写的着色器程序。你可以通过检查静态`QOpenGLShaderProgram::hasOpenGLShaderPrograms()`调用的结果来检查你的OpenGL实现是否支持着色器。所有现代硬件和所有不错的图形驱动程序都应该对着色器有一些支持。一个着色器由`QOpenGLShader`类的实例表示。使用它，你可以决定着色器的类型，关联和着色器源代码。后者是通过调用`QOpenGLShader::compileSourceCode()`来完成的，它有几个重载来处理不同的输入格式。
- en: 'Qt supports all kinds of shaders, with the most common being vertex and fragment
    shaders. These are both part of the classic OpenGL pipeline. You can see an illustration
    of the pipeline on the following diagram:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Qt支持所有类型的着色器，其中最常见的是顶点着色器和片段着色器。这些都是经典OpenGL管道的一部分。你可以在以下图中看到管道的示意图：
- en: '![Shaders](img/8874OS_05_15.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![着色器](img/8874OS_05_15.jpg)'
- en: When you have a set of shaders defined, you can assemble a complete program
    by using `QOpenGLShaderProgram::addShader()`. After all shaders are added, you
    can `link()` the program and `bind()` it to the current GL context. The program
    class has a number of methods for setting values of different input parameters—uniforms
    and attributes both in singular and array versions. Qt provides mappings between
    its own types (such as `QSize` or `QColor`) to GLSL counterparts (for example,
    `vec2` and `vec4`) to make the programmer's life even easier.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义了一组着色器后，你可以通过使用 `QOpenGLShaderProgram::addShader()` 来组装一个完整的程序。在所有着色器都添加完毕后，你可以
    `link()` 程序并将其 `bind()` 到当前的 GL 上下文中。程序类提供了一系列方法来设置不同输入参数的值——包括单值和数组版本的统一变量和属性。Qt
    提供了其自身类型（如 `QSize` 或 `QColor`）与 GLSL 对应类型（例如，`vec2` 和 `vec4`）之间的映射，以使程序员的开发工作更加轻松。
- en: 'A typical code flow for using shaders for rendering is as follows (first a
    vertex shader is created and compiled):'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用着色器进行渲染的典型代码流程如下（首先创建并编译一个顶点着色器）：
- en: '[PRE104]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The process is repeated for a fragment shader:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程对片段着色器重复进行：
- en: '[PRE105]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then shaders are linked into a single program in a given GL context:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将着色器链接到给定 GL 上下文中的单个程序中：
- en: '[PRE106]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Whenever the program is used, it should be bound to the current GL context
    and filled with required data:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用程序时，它都应绑定到当前 GL 上下文并填充所需数据：
- en: '[PRE107]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'After that, calls activating the render pipeline are going to use the bound
    program:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，激活渲染管道的调用将使用绑定的程序：
- en: '[PRE108]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Time for action – shaded objects
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行着色物体操作了
- en: Let's convert our last program so that it uses shaders. To make the cube better,
    we will implement a smooth lighting model using the Phong algorithm. At the same
    time, we will learn to use some helper classes that Qt offers for use with OpenGL.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将最后一个程序转换为使用着色器。为了使立方体更好，我们将使用 Phong 算法实现平滑光照模型。同时，我们将学习使用 Qt 为 OpenGL 提供的一些辅助类。
- en: 'The basic goals for this mini-project are as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 本小项目的目标如下：
- en: Use vertex and fragment shaders for rendering a complex object
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器来渲染复杂对象
- en: Handle model, view, and projection matrices
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理模型、视图和投影矩阵
- en: Use attribute arrays for faster drawing
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性数组进行快速绘制
- en: 'Start by creating a new subclass of `AbstractGLScene`. Let''s give it the following
    interface:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个 `AbstractGLScene` 的新子类。让我们给它以下接口：
- en: '[PRE109]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Significant changes to the class interface in comparison with the previous project
    have been highlighted. We're not using textures in this project so `TexturedPoint`
    was simplified to `ScenePoint` with UV texture coordinates removed.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目相比，类接口有显著的变化。在这个项目中我们不使用纹理，因此 `TexturedPoint` 被简化为 `ScenePoint`，并移除了 UV
    纹理坐标。
- en: We can start implementing the interface with the `initializeObjectData()` function.
    We're not going to go line by line explaining what the body of the method does.
    You can implement it as you want; it is important that the method fill the `m_data`
    member with information about vertices and their normals.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 `initializeObjectData()` 函数开始实现接口。我们不会逐行解释方法体做了什么。你可以按自己的意愿实现它；重要的是确保该方法将有关顶点和它们法线的信息填充到
    `m_data` 成员中。
- en: Tip
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the sample code that comes with this book, you can find code that loads data
    from a file in PLY format generated with the Blender 3D program. To export a model
    from Blender, make sure it consists of just triangles (for that, select the model,
    go into the Edit mode by pressing *Tab*, open the **Faces** menu with *Ctrl* +
    *F*, and choose **Triangulate Faces**). Then click on **File** and **Export**;
    choose **Stanford (.ply)**. You will end up with a text file containing vertex
    and normal data as well as face definitions for the vertices.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带示例代码中，你可以找到使用 Blender 3D 程序生成的 PLY 格式文件加载数据的代码。要从 Blender 导出模型，请确保它仅由三角形组成（为此，选择模型，按
    *Tab* 键进入编辑模式，使用 *Ctrl* + *F* 打开 **面** 菜单，并选择 **三角化面**）。然后点击 **文件** 和 **导出**；选择
    **斯坦福 (.ply)**。你将得到一个包含顶点和法线数据以及顶点面定义的文本文件。
- en: You can always reuse the cube object from the previous project. Just be aware
    that its normals are not calculated properly for smooth shading; thus, you will
    have to correct them.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以始终重用之前项目中使用的立方体对象。但请注意，它的法线没有正确计算以进行平滑着色；因此，你必须纠正它们。
- en: 'Before we can set up the shader program, we have to be aware of what the actual
    shaders look like. Shader code is going to be loaded from external files, so the
    first step is to add a new file to the project. In Creator, click on **File**
    and choose **New File or Project**; from the bottom pane, choose **GLSL**, and
    from the list of available templates choose **Vertex Shader (Desktop OpenGL)**.
    Call the new file `phong.vert` and input the following code:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以设置着色器程序之前，我们必须了解实际的着色器是什么样的。着色器代码将从外部文件加载，因此第一步是为项目添加一个新文件。在Creator中，点击**文件**并选择**新建文件或项目**；从底部面板中选择**GLSL**，然后从可用模板列表中选择**顶点着色器（桌面OpenGL）**。将新文件命名为`phong.vert`并输入以下代码：
- en: '[PRE110]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The code is very simple. We declare four matrices representing different stages
    of coordinate mapping for the scene. We also define two input attributes—`Vertex`
    and `Normal`—which contain the vertex data. The shader is going to output two
    pieces of data—a normalized vertex normal and a transformed vertex coordinate
    as seen by the camera. Of course, apart from that we set `gl_Position` to be the
    final vertex coordinate. In each case, we want to be compliant with the OpenGL/ES
    specification so we prefix each variable declaration with a precision specifier.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。我们声明了四个矩阵，分别代表场景坐标映射的不同阶段。我们还定义了两个输入属性——`Vertex`和`Normal`——它们包含顶点数据。着色器将输出两份数据——一个归一化的顶点法线和从相机视角看到的变换后的顶点坐标。当然，除此之外，我们还将`gl_Position`设置为最终的顶点坐标。在每种情况下，我们都希望符合OpenGL/ES规范，因此在每个变量声明前加上一个精度指定符。
- en: 'Next, add another file, call it `phong.frag`, and make it a Fragment Shader
    (Desktop OpenGL). The content of the file is a typical ambient, diffuse, and specular
    calculation:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加另一个文件，命名为`phong.frag`，并将其设置为片段着色器（桌面OpenGL）。文件的内容是典型的环境、漫反射和镜面反射计算：
- en: '[PRE111]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Apart from using the two varying variables to obtain the interpolated normal
    (`N`) and fragment (`v`) position, the shader declares two structures for keeping
    light and material information. Without going into the details about how the shader
    itself works, it calculates three components—ambient light, diffused light, and
    specular reflection—adds them together, and sets that as the fragment color. Since
    all the per vertex input data is interpolated for each fragment, the final color
    is calculated individually for each pixel.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用两个变化变量来获取插值后的法线（`N`）和片段（`v`）位置外，着色器还声明了两个结构来保存光和材料信息。不深入着色器本身的工作细节，它计算三个组件——环境光、漫射光和镜面反射——将它们相加，并将结果设置为片段颜色。由于所有顶点输入数据都会为每个片段进行插值，因此最终颜色是针对每个像素单独计算的。
- en: 'Once we know what the shaders expect, we can set up the shader program object.
    Let''s go through the `initialize()` method:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道着色器期望什么，我们就可以设置着色器程序对象。让我们看一下`initialize()`方法：
- en: '[PRE112]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'First we call the base class implementation and set the background color of
    the scene to black, as shown in the following code:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用基类实现并设置场景的背景颜色为黑色，如下面的代码所示：
- en: '[PRE113]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Then we add two shaders to the program reading their source code from external
    files with the use of a custom helper function called `fileContent()`. This function
    essentially opens a file and returns its content. Then we link the shader program.
    The `link()` function returns a Boolean value but for simplicity we skip the error
    check here. The next step is to prepare all the input data for the shader, as
    shown:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们向程序中添加两个着色器，使用一个名为`fileContent()`的自定义辅助函数从外部文件中读取它们的源代码。这个函数本质上会打开一个文件并返回其内容。然后我们链接着色器程序。`link()`函数返回一个布尔值，但为了简单起见，这里我们跳过了错误检查。下一步是为着色器准备所有输入数据，如下所示：
- en: '[PRE114]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: First the shader program is bound to the current context so that we can operate
    on it. Then we enable the setup of two attribute arrays—one for vertex coordinates
    and the other for their normals. We inform the program that an attribute called
    `Vertex` consists of three values of type `GL_FLOAT`. The first value is located
    at `m_data.constData()`, and data for the next vertex is located `sizeof(ScenePoint)`
    bytes later than data for the current point. Then we have a similar declaration
    for the `Normal` attribute, with the only exception that the first piece of data
    is placed at `&m_data[0].normal`. By informing the program about layout of the
    data, we allow it to quickly read all the vertex information when needed.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将着色器程序绑定到当前上下文，以便我们可以对其操作。然后我们启用设置两个属性数组——一个用于顶点坐标，另一个用于它们的法线。我们通知程序，一个名为`Vertex`的属性由三个`GL_FLOAT`类型的值组成。第一个值位于`m_data.constData()`，下一个顶点的数据位于当前点数据`sizeof(ScenePoint)`字节之后。然后我们对`Normal`属性有类似的声明，唯一的区别是第一个数据块放置在`&m_data[0].normal`。通过通知程序数据布局，我们允许它在需要时快速读取所有顶点信息。
- en: 'After attribute arrays are set, we pass values for uniform variables to the
    shader program, which concludes the shader program setup. You will notice that
    we didn''t set values for uniforms representing the various matrices; we will
    do that separately for each repaint. The `paint()` method takes care of setting
    up all the matrices:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置属性数组之后，我们将统一变量的值传递给着色器程序，这完成了着色器程序的设置。你会注意到我们没有为表示各种矩阵的统一变量设置值；我们将为每次重绘分别设置。`paint()`方法负责设置所有矩阵：
- en: '[PRE115]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In this method, we make heavy use of the `QMatrix4x4` class that represents
    a 4 x 4 matrix in so-called row-major order, which is suited to use with OpenGL.
    At the beginning, we reset the projection matrix and use the `perspective()` method
    to give it a perspective transformation based on current window size. Afterwards,
    the view matrix is also reset and the `lookAt()` method is used to prepare the
    transformation for the camera; center value indicates the center of the view eye
    is looking at. The `up` vector dictates the vertical orientation of the camera
    (with respect to the eye position).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们大量使用了表示4 x 4矩阵的`QMatrix4x4`类，该矩阵以所谓的行主序排列，适合与OpenGL一起使用。一开始，我们重置投影矩阵，并使用`perspective()`方法根据当前窗口大小给它一个透视变换。之后，视图矩阵也被重置，并使用`lookAt()`方法为摄像机准备变换；中心值表示视图眼睛所看的中心。`up`向量指定了摄像机的垂直方向（相对于眼睛位置）。
- en: 'The next couple of lines are similar to what we had in the previous project:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行与上一个项目中的类似：
- en: '[PRE116]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'After that, we do the actual painting of the object:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们进行对象的实际绘制：
- en: '[PRE117]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We start by setting the model matrix, which dictates where the rendered object
    is positioned relative to the center of the world (in this case, we say it is
    rotated 45 degrees around the *y* axis). Then we assemble the model-view matrix
    (denoting the position of the object relative to the camera) and pass it to the
    `paintObject()` method, as shown:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置模型矩阵，它决定了渲染对象相对于世界中心的位置（在这种情况下，我们说它是绕 *y* 轴旋转了45度）。然后我们组装模型视图矩阵（表示对象相对于摄像机的位置）并将其传递给`paintObject()`方法，如下所示：
- en: '[PRE118]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This method is very easy since most of the work was done when setting up the
    shader program. First the shader program is activated. Then all required matrices
    are set as uniforms for the shader. Included is the normal matrix calculated from
    the model-view matrix. Finally, a call to `glDrawArrays()` is issued telling it
    to render with the `GL_TRIANGLES` mode using active arrays, starting from the
    beginning of the array (offset `0`) and reading in the `pointCount` entities from
    the array.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单，因为大部分工作都是在设置着色器程序时完成的。首先激活着色器程序。然后设置所有所需的矩阵作为着色器的统一变量。包括从模型视图矩阵计算出的法线矩阵。最后，发出调用`glDrawArrays()`，告诉它以`GL_TRIANGLES`模式使用活动数组进行渲染，从数组的开始（偏移`0`）读取`pointCount`个实体。
- en: 'After you run the project, you should get a result similar to the following
    one, which happens to contain the Blender monkey, Suzanne:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，你应该得到一个类似于以下的结果，它恰好包含了Blender猴子，Suzanne：
- en: '![Time for action – shaded objects](img/8874OS_05_16.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 - 着色对象](img/8874OS_05_16.jpg)'
- en: GL buffers
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GL缓冲区
- en: 'Using attribute arrays can speed up programming, but for rendering, all data
    still requires to be copied to the graphics card on each use. This can be avoided
    with OpenGL buffer objects. Qt provides a neat interface for such objects with
    its `QOpenGLBuffer` class. Currently supported buffer types are vertex buffers
    (where the buffer contains vertex information), index buffers (where the content
    of the buffer is a set of indexes to other buffers that can be used with `glDrawElements()`),
    and also less commonly used pixel pack buffers and pixel unpack buffers. The buffer
    is essentially a block of memory that can be uploaded to the graphics card and
    stored there for faster access. There are different usage patterns available that
    dictate how and when the buffer is transferred between the host memory and GPU
    memory. The most common pattern is a one-time upload of vertex information to
    the GPU that can later be referred to during rendering as many times as needed.
    Changing an existing application that uses an attribute array to use vertex buffers
    is very easy. First a buffer needs to be instantiated:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性数组可以加快编程速度，但在渲染时，所有数据仍然需要在每次使用时复制到图形卡上。这可以通过OpenGL缓冲区对象来避免。Qt通过其`QOpenGLBuffer`类提供了一个方便的接口。目前支持的缓冲区类型包括顶点缓冲区（其中缓冲区包含顶点信息）、索引缓冲区（其中缓冲区的内容是一组索引，可以与`glDrawElements()`一起使用），以及较少使用的像素打包缓冲区和像素解包缓冲区。缓冲区本质上是一块内存，可以上传到图形卡并存储在那里以实现更快的访问。有不同可用使用模式，这些模式规定了缓冲区如何在主机内存和GPU内存之间传输以及何时传输。最常见模式是一次性将顶点信息上传到GPU，以后在渲染过程中可以多次引用。将使用属性数组的现有应用程序更改为使用顶点缓冲区非常简单。首先需要一个缓冲区实例：
- en: '[PRE119]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Then its usage pattern needs to be set. In case of a one-time upload, the most
    appropriate type is `StaticDraw`, as shown:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要设置其使用模式。在一次性上传的情况下，最合适的类型是`StaticDraw`，如下所示：
- en: '[PRE120]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Then the buffer itself has to be created for the current context:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要为当前上下文创建缓冲区本身：
- en: '[PRE121]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The next step is to actually allocate some memory for the buffer:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实际为缓冲区分配一些内存：
- en: '[PRE122]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'To write data to the buffer, there are two options. First you can attach the
    buffer to the application''s memory space using a call to `map()` and then fill
    the data using a returned pointer:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据写入缓冲区，有两种选择。首先，您可以通过调用`map()`将缓冲区附加到应用程序的内存空间，然后使用返回的指针填充数据：
- en: '[PRE123]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'An alternative approach is to write to the buffer directly using `write()`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法是直接使用`write()`将数据写入缓冲区：
- en: '[PRE124]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Finally, the buffer can be used in the shader program in a way similar to an
    attribute array:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，缓冲区可以以类似于属性数组的方式在着色器程序中使用：
- en: '[PRE125]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The result is that all the data is uploaded to the GPU once and then used as
    needed by the current shader program or other OpenGL call supporting buffer objects.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，所有数据都一次性上传到GPU，然后根据当前着色器程序或其他支持缓冲区对象的OpenGL调用按需使用。
- en: Off-screen rendering
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离屏渲染
- en: Sometimes, it is useful to render a GL scene not to the screen but rather to
    some image that can be later processed externally or used as a texture in some
    other part of rendering. For that, the concept of **Framebuffer Objects** (**FBO**)
    was created. An FBO is a rendering surface that behaves like the regular device
    frame buffer, with the only exception that the resulting pixels do not land on
    the screen. An FBO target can be bound as a texture in an existing scene or dumped
    as an image to regular computer memory. In Qt, such an entity is represented by
    a `QOpenGLFramebufferObject` class.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将GL场景渲染到屏幕之外而不是屏幕上是有用的，这样可以将图像稍后外部处理或用作渲染其他部分的纹理。为此，创建了**帧缓冲对象**（**FBO**）的概念。FBO是一个渲染表面，其行为类似于常规设备帧缓冲区，唯一的区别是生成的像素不会出现在屏幕上。FBO目标可以作为纹理绑定到现有场景中，或者作为图像存储在常规计算机内存中。在Qt中，此类实体由`QOpenGLFramebufferObject`类表示。
- en: Once you have a current OpenGL context, you can create an instance of `QOpenGLFramebufferObject`
    using one of the available constructors. A mandatory parameter to pass is the
    size of the canvas (either as a `QSize` object or as a pair of integers describing
    the width and height of the frame). Different constructors accept other parameters
    such as the type of texture the FBO is to generate or a set of parameters encapsulated
    in `QOpenGLFramebufferObjectFormat`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个当前的OpenGL上下文，您可以使用可用的构造函数之一创建`QOpenGLFramebufferObject`的实例。必须传递的强制参数是画布的大小（可以是`QSize`对象，也可以是一对整数，描述帧的宽度和高度）。不同的构造函数接受其他参数，例如FBO要生成的纹理类型或封装在`QOpenGLFramebufferObjectFormat`中的参数集。
- en: When the object is created, you can issue a `bind()` call on it, which switches
    the OpenGL pipeline to render to the FBO instead of the default target. A complementary
    method is `release()`, which restores the default rendering target. Afterwards,
    the FBO can be queried to return the ID of the OpenGL texture (using the `texture()`
    method) or to convert the texture to `QImage` (by invoking `toImage()`).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被创建时，你可以在其上发出一个`bind()`调用，这将切换OpenGL管道以渲染到FBO而不是默认目标。一个互补的方法是`release()`，它将恢复默认渲染目标。之后，可以通过调用`texture()`方法查询FBO以返回OpenGL纹理的ID，或者通过调用`toImage()`将纹理转换为`QImage`。
- en: Summary
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about using graphics with Qt. You should be aware
    we have only scratched the surface of Qt capabilities in this regard. What was
    presented in this chapter will let you implement custom widgets, do some basic
    painting on images, and render OpenGL scenes. There are many more functionalities
    that we didn't go through, such as composition modes, paths, SVG handling, and
    many others. We will come back to some of these features in subsequent chapters,
    but we will leave most for you to discover on your own.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Qt进行图形处理。你应该意识到，关于Qt在这方面我们只是触及了皮毛。本章所介绍的内容将帮助你实现自定义小部件，对图像进行一些基本的绘制，以及渲染OpenGL场景。还有很多其他的功能我们没有涉及，例如合成模式、路径、SVG处理等。我们将在后续章节中回顾一些这些功能，但大部分我们将留给你自己探索。
- en: In the next chapter, we will learn a more object-oriented approach to do graphics,
    called Graphics View.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一种更面向对象的方法来进行图形处理，称为图形视图。
