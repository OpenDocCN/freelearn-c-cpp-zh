- en: Chapter 2. Building LLVM IR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A high level programming language facilitates human interaction with the target
    machine. Most of the popular high level languages today have certain basic elements
    such as variables, loops, if-else decision making statements, blocks, functions,
    and so on. A variable holds value of data types; a basic block gives an idea of
    the scope of the variable. An if-else decision statement helps in selection of
    a path of code. A function makes a block of code reusable. High level languages
    may vary in type checking, type casting, variable declarations, complex data types,
    and so on. However, almost every other language has the basic building blocks
    listed earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: A language may have its own parser which tokenizes the statement and extracts
    meaningful information such as identifier, its data type; a function name, its
    declaration, definition and calls; a loop condition, and so on. This meaningful
    information may be stored in a data structure where the flow of the code can be
    easily retrieved. **Abstract Syntax Tree** (**AST**) is a popular tree representation
    of the source code. The AST's can be used for further transformation and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A language parser can be written in various ways with various tools such as
    `lex`, `yacc`, and so on, or can even be handwritten. Writing an efficient parser
    is an art in itself. But this is not what we intend to cover in this chapter.
    We would like to focus more on LLVM IR and how a high-level language after parsing
    can be converted to LLVM IR using LLVM libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover how to construct basic working LLVM sample code, which
    includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an LLVM module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting a function in a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a block to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting a global variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting a return statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting function arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting a simple arithmetic statement in a basic block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting if-else condition IR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting LLVM IR for loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an LLVM module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we got an idea as to how an LLVM IR looks. In LLVM,
    a module represents a single unit of code that is to be processed together. An
    LLVM module class is the top-level container for all other LLVM IR objects. The
    LLVM module contains global variables, functions, data layout, host triples, and
    so on. Let's create a simple LLVM module.
  prefs: []
  type: TYPE_NORMAL
- en: 'LLVM provides `Module()` constructor for creating a module. The first argument
    is the name of the module. The second argument is `LLVMContext`. Let''s get these
    arguments in the main function and create a module as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For these functions to work, we need to include certain header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Put this code in a file, let''s say `toy.cpp` and compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Emitting a function in a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a module, the next step is to emit a function. LLVM
    has an `IRBuilder` class that is used to generate LLVM IR and print it using the
    `dump` function of the Module object. LLVM provides the class `llvm::Function`
    to create a function and `llvm::FunctionType()` to associate a return type for
    the function. Let's assume that our `foo()` function returns an integer type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, call function `verifyFunction()` on `fooFunc`. This function performs
    a variety of consistency checks on the generated code, to determine if our compiler
    is doing everything right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Add the `IR/IRBuilder.h`, `IR/DerivedTypes.h` and `IR/Verifier.h` file in include
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the `toy.cpp` with the same options as stated earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding a block to a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function consists of basic blocks. A basic block has an entry point. A basic
    block consists of a number of IR instructions, the last instruction being a terminator
    instruction. It has single exit point. LLVM provides the `BasicBlock` class to
    create and handle basic blocks. A basic block might have an entry point as its
    label, which indicates where to insert the next instructions. We can use the `IRBuilder`
    object to hold these new basic block IR.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the `toy.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Emitting a global variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global variables have visibility of all the functions within a given module.
    LLVM provides the `GlobalVariable` class to create global variables and set its
    properties such as linkage type, alignment, and so on. The `Module` class has
    the method `getOrInsertGlobal()` to create a global variable. It takes two arguments—the
    first is the name of the variable and the second is the data type of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As global variables are part of a module, we create global variables after
    creating the module. Insert the following code just after creating the module
    in `toy.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Linkage** is what determines if multiple declarations of the same object
    refer to the same object, or to separate ones. The LLVM reference manual cites
    the following types of Linkages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ExternalLinkage` | Externally visible function. |'
  prefs: []
  type: TYPE_TB
- en: '| `AvailableExternallyLinkage` | Available for inspection, not emission. |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkOnceAnyLinkage` | Keep one copy of function when linking (inline) |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkOnceODRLinkage` | Same, but only replaced by something equivalent. |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakAnyLinkage` | Keep one copy of named function when linking (weak) |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakODRLinkage` | Same, but only replaced by something equivalent. |'
  prefs: []
  type: TYPE_TB
- en: '| `AppendingLinkage` | Special purpose, only applies to global arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| `InternalLinkage` | Rename collisions when linking (static functions). |'
  prefs: []
  type: TYPE_TB
- en: '| `PrivateLinkage` | Like internal, but omit from symbol table. |'
  prefs: []
  type: TYPE_TB
- en: '| `ExternalWeakLinkage` | `ExternalWeak` linkage description. |'
  prefs: []
  type: TYPE_TB
- en: '| `CommonLinkage` | Tentative definitions |'
  prefs: []
  type: TYPE_TB
- en: Alignment gives information about address alignment. An alignment must be a
    power of `2`. If not specified explicitly, it is set by the target. The maximum
    alignment is `1 << 29`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the `toy.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Emitting a return statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function might return a value or it may return void. Here in our example,
    we have defined that our function returns an integer. Let's assume that our function
    returns `0`. The first step is to get a `0` value, which can be done using the
    `Constant` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compile `toy.cpp` file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Emitting function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function takes arguments that have their own data type. For simplification,
    assume that our function has all the arguments of i32 type (integer 32 bit).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will consider that two arguments, a and b, are passed to the
    function. We will store these two arguments in a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to specify that the function will have two arguments. This
    can be done by passing the Integer argument to the `functiontype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to set the names of the function arguments. This can be done
    by `Function` argument iterator in a loop, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the `toy.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Emitting a simple arithmetic statement in a basic block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic block consists of a list of instructions. For example, an instruction
    can be a simple statement performing tasks based on some simple arithmetic instruction.
    We will see how the LLVM API can be used to emit arithmetic instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to multiply first argument a with integer value `16`,
    we will create a constant integer value `16` with the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We already have a from the function argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: LLVM provides a rich list of API's to create binary operations. You can go through
    the `include/llvm/IR/IRBuild.h` file for more details on the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that for demo purposes, the preceding function returns multiplication.
    We leave it to the readers to make this function more flexible to return any binary
    operations. You can explore more binary operations in `include/llvm/IR/IRBuild.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole code now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the return value? We returned the multiplication instead of constant
    0.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting if-else condition IR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **if-else** statement has a condition expression and two code paths to execute,
    depending on the condition evaluating to true or false. The condition expression
    is generally a comparison statement. Let's emit a condition statement at the start
    of the block. For example, let the condition be like `a<100`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On compilation, we get following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to define the then and else block expressions, which will be
    executed depending on the result of condition expression "`booltmp`". Here, an
    important concept of **PHI** instruction comes into picture. A phi instruction
    takes various values coming from different basic blocks and decides which value
    to assign depending on the condition expression.
  prefs: []
  type: TYPE_NORMAL
- en: Two separate basic blocks "`ThenBB`" and "`ElseBB`" will be created. Let's say
    that the then expression is 'add 1 to a' and else expression is 'add 2 to a'.
  prefs: []
  type: TYPE_NORMAL
- en: A third block will represent the merge block, which contains the instructions
    to be executed at the merging of the then and else blocks. These blocks need to
    be pushed into the function `foo()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reusability, we create `BasicBlock` and `Value` containers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `SmallVector<>` is vector container wrapper provided by LLVM for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also push some of the values in a `Value*` list to process them in the if-else
    block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We create three basic blocks and push them in container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We finally create a function to emit the if-else block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling, the output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Emitting LLVM IR for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the if-else statement, loops can also be emitted using LLVM API''s,
    with slight modification of the code. For example, we want to have LLVM IR for
    the following Loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The loop has induction variable `i`, which has some initial value that updates
    after each iteration. The induction variable is updated after each iteration by
    a step value that is `1` in the preceding example. Then there is a loop ending
    condition. In the preceding example, '`i=1`' is the initial value, '`i<b`' is
    the end condition of the loop, and '`i++`' is the step value by which the induction
    variable '`i`' is incremented after every iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing a function to create a loop, some `Value` and `BasicBlock` need
    to be pushed into a list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a function for the emitting loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`IndVar` is a PHI node, which has two incoming values from two blocks—startval
    from the Preheader block (`i=1`), and `Nextval` from the LoopEnd block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create simple LLVM IR using rich libraries
    provided by LLVM. Remember that LLVM IR is an intermediate representation. The
    high-level programming languages are converted to LLVM IR using the custom parser,
    which breaks down the code into atomic pieces such as variables, functions, function
    return type, function arguments, if-else conditions, loops, pointers, array, and
    so on. These atomic elements can be stored into custom data structures and then
    those data structures can be used to emit LLVM IR, as demonstrated in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the parser phase, syntactic analysis can be done, while lexical analysis
    and type checking can be done in an intermediate stage after parsing and before
    emitting IR.
  prefs: []
  type: TYPE_NORMAL
- en: In practical usage, one would hardly find the IR being emitted in a hard-coded
    way as demonstrated in this chapter. Instead, a language is parsed and represented
    in an Abstract Syntax Tree. The tree is then used to emit LLVM IR with the help
    of the LLVM library, as shown earlier. The LLVM community has provided an excellent
    tutorial for writing a parser and emitting LLVM IR. You can visit [http://llvm.org/docs/tutorial/](http://llvm.org/docs/tutorial/)
    for the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to emit some complex data structures such
    as array, pointers. Also, we will go through some examples from Clang, the frontend
    for C/C++, and understand how semantic Analysis is done.
  prefs: []
  type: TYPE_NORMAL
