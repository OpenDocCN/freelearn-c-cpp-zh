- en: Chapter 2. Building LLVM IR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：构建 LLVM IR
- en: A high level programming language facilitates human interaction with the target
    machine. Most of the popular high level languages today have certain basic elements
    such as variables, loops, if-else decision making statements, blocks, functions,
    and so on. A variable holds value of data types; a basic block gives an idea of
    the scope of the variable. An if-else decision statement helps in selection of
    a path of code. A function makes a block of code reusable. High level languages
    may vary in type checking, type casting, variable declarations, complex data types,
    and so on. However, almost every other language has the basic building blocks
    listed earlier in this section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编程语言便于人与目标机器的交互。今天的大多数流行高级语言都有一些基本元素，如变量、循环、if-else 决策语句、块、函数等。变量持有数据类型的价值；基本块给出了变量的作用域的概念。if-else
    决策语句有助于选择代码路径。函数使代码块可重用。高级语言可能在类型检查、类型转换、变量声明、复杂数据类型等方面有所不同。然而，几乎每种语言都有本节前面列出的基本构建块。
- en: A language may have its own parser which tokenizes the statement and extracts
    meaningful information such as identifier, its data type; a function name, its
    declaration, definition and calls; a loop condition, and so on. This meaningful
    information may be stored in a data structure where the flow of the code can be
    easily retrieved. **Abstract Syntax Tree** (**AST**) is a popular tree representation
    of the source code. The AST's can be used for further transformation and analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一种语言可能有自己的解析器，它将语句标记化并提取有意义的信息，如标识符及其数据类型；函数名称、其声明、定义和调用；循环条件等。这些有意义的信息可以存储在数据结构中，以便可以轻松检索代码的流程。**抽象语法树**（**AST**）是源代码的流行树形表示。AST
    可以用于进一步的转换和分析。
- en: A language parser can be written in various ways with various tools such as
    `lex`, `yacc`, and so on, or can even be handwritten. Writing an efficient parser
    is an art in itself. But this is not what we intend to cover in this chapter.
    We would like to focus more on LLVM IR and how a high-level language after parsing
    can be converted to LLVM IR using LLVM libraries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 语言解析器可以用各种方式编写，使用各种工具如 `lex`、`yacc` 等，甚至可以手动编写。编写一个高效的解析器本身就是一门艺术。但本章我们并不打算涵盖这一点。我们更希望关注
    LLVM IR 以及如何使用 LLVM 库将解析后的高级语言转换为 LLVM IR。
- en: 'This chapter will cover how to construct basic working LLVM sample code, which
    includes the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何构建基本的工作 LLVM 示例代码，包括以下内容：
- en: Creating an LLVM module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 LLVM 模块
- en: Emitting a function in a module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中发射一个函数
- en: Adding a block to a function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数中添加一个块
- en: Emitting a global variable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射全局变量
- en: Emitting a return statement
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射返回语句
- en: Emitting function arguments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射函数参数
- en: Emitting a simple arithmetic statement in a basic block
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基本块中发射一个简单的算术语句
- en: Emitting if-else condition IR
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射 if-else 条件 IR
- en: Emitting LLVM IR for loops
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射循环的 LLVM IR
- en: Creating an LLVM module
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 LLVM 模块
- en: In the previous chapter, we got an idea as to how an LLVM IR looks. In LLVM,
    a module represents a single unit of code that is to be processed together. An
    LLVM module class is the top-level container for all other LLVM IR objects. The
    LLVM module contains global variables, functions, data layout, host triples, and
    so on. Let's create a simple LLVM module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到了 LLVM IR 的外观。在 LLVM 中，一个模块代表了一个要一起处理的单个代码单元。LLVM 模块类是所有其他 LLVM IR
    对象的最高级容器。LLVM 模块包含全局变量、函数、数据布局、主机三元组等。让我们创建一个简单的 LLVM 模块。
- en: 'LLVM provides `Module()` constructor for creating a module. The first argument
    is the name of the module. The second argument is `LLVMContext`. Let''s get these
    arguments in the main function and create a module as demonstrated here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 提供了 `Module()` 构造函数用于创建模块。第一个参数是模块的名称。第二个参数是 `LLVMContext`。让我们在主函数中获取这些参数并创建一个模块，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For these functions to work, we need to include certain header files:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些函数正常工作，我们需要包含某些头文件：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Put this code in a file, let''s say `toy.cpp` and compile it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入一个文件中，比如 `toy.cpp`，然后编译它：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output will be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Emitting a function in a module
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模块中发射一个函数
- en: Now that we have created a module, the next step is to emit a function. LLVM
    has an `IRBuilder` class that is used to generate LLVM IR and print it using the
    `dump` function of the Module object. LLVM provides the class `llvm::Function`
    to create a function and `llvm::FunctionType()` to associate a return type for
    the function. Let's assume that our `foo()` function returns an integer type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个模块，下一步是输出一个函数。LLVM 有一个 `IRBuilder` 类，用于生成 LLVM IR 并使用模块对象的 `dump`
    函数打印它。LLVM 提供了 `llvm::Function` 类来创建函数和 `llvm::FunctionType()` 来为函数关联返回类型。让我们假设我们的
    `foo()` 函数返回整数类型。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, call function `verifyFunction()` on `fooFunc`. This function performs
    a variety of consistency checks on the generated code, to determine if our compiler
    is doing everything right.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `fooFunc` 上调用函数 `verifyFunction()`。此函数对生成的代码执行各种一致性检查，以确定我们的编译器是否一切正常。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add the `IR/IRBuilder.h`, `IR/DerivedTypes.h` and `IR/Verifier.h` file in include
    section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含部分添加 `IR/IRBuilder.h`、`IR/DerivedTypes.h` 和 `IR/Verifier.h` 文件。
- en: 'The overall code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码如下：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile the `toy.cpp` with the same options as stated earlier:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前所述的相同选项编译 `toy.cpp`：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding a block to a function
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向函数添加一个块
- en: A function consists of basic blocks. A basic block has an entry point. A basic
    block consists of a number of IR instructions, the last instruction being a terminator
    instruction. It has single exit point. LLVM provides the `BasicBlock` class to
    create and handle basic blocks. A basic block might have an entry point as its
    label, which indicates where to insert the next instructions. We can use the `IRBuilder`
    object to hold these new basic block IR.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数由基本块组成。基本块有一个入口点。基本块由一系列 IR 指令组成，最后一条指令是终止指令。它有一个单一的出口点。LLVM 提供了 `BasicBlock`
    类来创建和处理基本块。基本块可能以标签作为入口点，这表示在哪里插入后续指令。我们可以使用 `IRBuilder` 对象来保存这些新的基本块 IR。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The overall code is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码如下：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compile the `toy.cpp` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 `toy.cpp` 文件：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output will be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Emitting a global variable
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出全局变量
- en: Global variables have visibility of all the functions within a given module.
    LLVM provides the `GlobalVariable` class to create global variables and set its
    properties such as linkage type, alignment, and so on. The `Module` class has
    the method `getOrInsertGlobal()` to create a global variable. It takes two arguments—the
    first is the name of the variable and the second is the data type of the variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量的可见性是给定模块内所有函数的。LLVM 提供了 `GlobalVariable` 类来创建全局变量并设置其属性，如链接类型、对齐等。`Module`
    类有 `getOrInsertGlobal()` 方法来创建全局变量。它接受两个参数——第一个是变量的名称，第二个是变量的数据类型。
- en: 'As global variables are part of a module, we create global variables after
    creating the module. Insert the following code just after creating the module
    in `toy.cpp`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全局变量是模块的一部分，我们在创建模块后创建全局变量。在 `toy.cpp` 中创建模块后立即插入以下代码：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Linkage** is what determines if multiple declarations of the same object
    refer to the same object, or to separate ones. The LLVM reference manual cites
    the following types of Linkages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接** 决定了相同对象的多个声明是否引用同一个对象，还是不同的对象。LLVM 参考手册引用了以下类型的链接：'
- en: '| `ExternalLinkage` | Externally visible function. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `ExternalLinkage` | 外部可见函数。|'
- en: '| `AvailableExternallyLinkage` | Available for inspection, not emission. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `AvailableExternallyLinkage` | 可供检查，但不进行输出。|'
- en: '| `LinkOnceAnyLinkage` | Keep one copy of function when linking (inline) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `LinkOnceAnyLinkage` | 链接时（内联）保留函数的一个副本|'
- en: '| `LinkOnceODRLinkage` | Same, but only replaced by something equivalent. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `LinkOnceODRLinkage` | 相同，但仅替换为等效项。|'
- en: '| `WeakAnyLinkage` | Keep one copy of named function when linking (weak) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `WeakAnyLinkage` | 链接时（弱）保留命名函数的一个副本|'
- en: '| `WeakODRLinkage` | Same, but only replaced by something equivalent. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `WeakODRLinkage` | 相同，但仅替换为等效项。|'
- en: '| `AppendingLinkage` | Special purpose, only applies to global arrays. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `AppendingLinkage` | 特殊用途，仅适用于全局数组。|'
- en: '| `InternalLinkage` | Rename collisions when linking (static functions). |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `InternalLinkage` | 链接时重命名冲突（静态函数）。|'
- en: '| `PrivateLinkage` | Like internal, but omit from symbol table. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `PrivateLinkage` | 类似于内部，但省略符号表。|'
- en: '| `ExternalWeakLinkage` | `ExternalWeak` linkage description. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `ExternalWeakLinkage` | `ExternalWeak` 链接描述。|'
- en: '| `CommonLinkage` | Tentative definitions |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `CommonLinkage` | 暂定定义|'
- en: Alignment gives information about address alignment. An alignment must be a
    power of `2`. If not specified explicitly, it is set by the target. The maximum
    alignment is `1 << 29`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐提供了关于地址对齐的信息。对齐必须是 `2` 的幂。如果没有明确指定，则由目标设置。最大对齐为 `1 << 29`。
- en: 'The overall code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码如下：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compile the `toy.cpp`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 `toy.cpp`：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output will be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Emitting a return statement
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射返回语句
- en: A function might return a value or it may return void. Here in our example,
    we have defined that our function returns an integer. Let's assume that our function
    returns `0`. The first step is to get a `0` value, which can be done using the
    `Constant` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能返回一个值，也可能返回 void。在我们的例子中，我们定义了我们的函数返回一个整数。让我们假设我们的函数返回 `0`。第一步是获取一个 `0`
    值，这可以通过使用 `Constant` 类来完成。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The overall code is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码如下：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile `toy.cpp` file
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 `toy.cpp` 文件
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Emitting function arguments
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射函数参数
- en: A function takes arguments that have their own data type. For simplification,
    assume that our function has all the arguments of i32 type (integer 32 bit).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受具有其自身数据类型的参数。为了简化，假设我们的函数所有参数都是 i32 类型（32 位整数）。
- en: 'For example, we will consider that two arguments, a and b, are passed to the
    function. We will store these two arguments in a vector:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将考虑将两个参数 a 和 b 传递给函数。我们将这两个参数存储在一个向量中：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next step is to specify that the function will have two arguments. This
    can be done by passing the Integer argument to the `functiontype`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是指定函数将有两个参数。这可以通过将整数参数传递给 `functiontype` 来完成。
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last step is to set the names of the function arguments. This can be done
    by `Function` argument iterator in a loop, as shown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为函数参数设置名称。这可以通过在循环中使用 `Function` 参数迭代器来完成，如下所示：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The overall code is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码如下：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile the `toy.cpp` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 `toy.cpp` 文件：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will be as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Emitting a simple arithmetic statement in a basic block
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在基本块中发射一个简单的算术语句
- en: A basic block consists of a list of instructions. For example, an instruction
    can be a simple statement performing tasks based on some simple arithmetic instruction.
    We will see how the LLVM API can be used to emit arithmetic instructions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块由一系列指令组成。例如，一个指令可以是一个简单的语句，根据一些简单的算术指令执行任务。我们将看到如何使用 LLVM API 发射算术指令。
- en: 'For example, if we want to multiply first argument a with integer value `16`,
    we will create a constant integer value `16` with the following API:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将第一个参数 a 与整数值 `16` 相乘，我们将使用以下 API 创建一个常量整数值 `16`：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We already have a from the function argument list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从函数参数列表中有了：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: LLVM provides a rich list of API's to create binary operations. You can go through
    the `include/llvm/IR/IRBuild.h` file for more details on the APIs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 提供了一个丰富的 API 列表来创建二元运算。你可以通过查看 `include/llvm/IR/IRBuild.h` 文件来获取更多关于 API
    的详细信息。
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Note that for demo purposes, the preceding function returns multiplication.
    We leave it to the readers to make this function more flexible to return any binary
    operations. You can explore more binary operations in `include/llvm/IR/IRBuild.h`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，出于演示目的，前面的函数返回乘法。我们留给读者去使这个函数更灵活，以返回任何二元运算。你可以在 `include/llvm/IR/IRBuild.h`
    中探索更多二元运算。
- en: 'The whole code now looks as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码现在看起来如下：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile the following program:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编译以下程序：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output will be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Did you notice the return value? We returned the multiplication instead of constant
    0.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到返回值了吗？我们返回了乘法而不是常数 0。
- en: Emitting if-else condition IR
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射 if-else 条件 IR
- en: An **if-else** statement has a condition expression and two code paths to execute,
    depending on the condition evaluating to true or false. The condition expression
    is generally a comparison statement. Let's emit a condition statement at the start
    of the block. For example, let the condition be like `a<100`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**if-else** 语句有一个条件表达式和两个代码路径来执行，取决于条件评估为真或假。条件表达式通常是一个比较语句。让我们在块的开始处发射一个条件语句。例如，让条件为
    `a<100`。'
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On compilation, we get following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，我们得到以下输出：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The next step is to define the then and else block expressions, which will be
    executed depending on the result of condition expression "`booltmp`". Here, an
    important concept of **PHI** instruction comes into picture. A phi instruction
    takes various values coming from different basic blocks and decides which value
    to assign depending on the condition expression.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义`then`和`else`块表达式，这将根据条件表达式"`booltmp`"的结果执行。在这里，**PHI**指令的重要概念出现了。一个phi指令接受来自不同基本块的各种值，并根据条件表达式决定分配哪个值。
- en: Two separate basic blocks "`ThenBB`" and "`ElseBB`" will be created. Let's say
    that the then expression is 'add 1 to a' and else expression is 'add 2 to a'.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建两个单独的基本块"`ThenBB`"和"`ElseBB`"。假设`then`表达式是'将a加1'，而`else`表达式是'将a加2'。
- en: A third block will represent the merge block, which contains the instructions
    to be executed at the merging of the then and else blocks. These blocks need to
    be pushed into the function `foo()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个块将表示合并块，其中包含在`then`和`else`块合并时需要执行的指令。这些块需要推入`foo()`函数中。
- en: 'For reusability, we create `BasicBlock` and `Value` containers as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高复用性，我们创建如下所示的`BasicBlock`和`Value`容器：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `SmallVector<>` is vector container wrapper provided by LLVM for simplicity.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`SmallVector<>`是LLVM为了简化提供的向量容器包装器。
- en: 'We also push some of the values in a `Value*` list to process them in the if-else
    block, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将一些值推入`Value*`列表中，以便在if-else块中处理，如下所示：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We create three basic blocks and push them in container, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建三个基本块并将它们推入容器中，如下所示：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We finally create a function to emit the if-else block:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终创建一个函数来生成if-else块：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Overall code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After compiling, the output looks like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，输出如下所示：
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Emitting LLVM IR for loop
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环的LLVM IR生成
- en: 'Similar to the if-else statement, loops can also be emitted using LLVM API''s,
    with slight modification of the code. For example, we want to have LLVM IR for
    the following Loops:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与if-else语句类似，循环也可以使用LLVM API的稍作修改来生成。例如，我们想要以下循环的LLVM IR：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The loop has induction variable `i`, which has some initial value that updates
    after each iteration. The induction variable is updated after each iteration by
    a step value that is `1` in the preceding example. Then there is a loop ending
    condition. In the preceding example, '`i=1`' is the initial value, '`i<b`' is
    the end condition of the loop, and '`i++`' is the step value by which the induction
    variable '`i`' is incremented after every iteration of the loop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 循环有一个循环变量`i`，它有一个初始值，在每次迭代后更新。在先前的例子中，循环变量在每次迭代后通过一个步长值更新，该步长值为`1`。然后有一个循环结束条件。在先前的例子中，"`i=1`"是初始值，"`i<b`"是循环的结束条件，"`i++`"是每次循环迭代后循环变量"`i`"增加的步长值。
- en: 'Before writing a function to create a loop, some `Value` and `BasicBlock` need
    to be pushed into a list, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写创建循环的函数之前，需要将一些`Value`和`BasicBlock`推入一个列表中，如下所示：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s create a function for the emitting loop:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于生成循环的函数：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Consider the following lines of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码行：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`IndVar` is a PHI node, which has two incoming values from two blocks—startval
    from the Preheader block (`i=1`), and `Nextval` from the LoopEnd block.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndVar`是一个PHI节点，它从两个块中接收两个值——从预头块(`i=1`)的`startval`和从循环结束块(`Nextval`)。'
- en: 'The overall code is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 整体代码如下：
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After compiling the program, we get the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序后，我们得到以下输出：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to create simple LLVM IR using rich libraries
    provided by LLVM. Remember that LLVM IR is an intermediate representation. The
    high-level programming languages are converted to LLVM IR using the custom parser,
    which breaks down the code into atomic pieces such as variables, functions, function
    return type, function arguments, if-else conditions, loops, pointers, array, and
    so on. These atomic elements can be stored into custom data structures and then
    those data structures can be used to emit LLVM IR, as demonstrated in this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用LLVM提供的丰富库创建简单的LLVM IR。记住，LLVM IR是一个中间表示。高级编程语言通过自定义解析器转换为LLVM
    IR，该解析器将代码分解为原子元素，如变量、函数、函数返回类型、函数参数、if-else条件、循环、指针、数组等。这些原子元素可以存储到自定义数据结构中，然后可以使用这些数据结构来生成LLVM
    IR，正如本章所演示的那样。
- en: In the parser phase, syntactic analysis can be done, while lexical analysis
    and type checking can be done in an intermediate stage after parsing and before
    emitting IR.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析器阶段，可以进行句法分析，而词法分析和类型检查可以在解析后、发射IR之前的中级阶段进行。
- en: In practical usage, one would hardly find the IR being emitted in a hard-coded
    way as demonstrated in this chapter. Instead, a language is parsed and represented
    in an Abstract Syntax Tree. The tree is then used to emit LLVM IR with the help
    of the LLVM library, as shown earlier. The LLVM community has provided an excellent
    tutorial for writing a parser and emitting LLVM IR. You can visit [http://llvm.org/docs/tutorial/](http://llvm.org/docs/tutorial/)
    for the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，几乎不会以本章所示的方式硬编码地发射红外线。相反，一种语言会被解析并表示为抽象语法树。然后，借助LLVM库，使用该树发射LLVM IR，如前所述。LLVM社区已经提供了一个优秀的教程，用于编写解析器并发射LLVM
    IR。您可以访问[http://llvm.org/docs/tutorial/](http://llvm.org/docs/tutorial/)获取相同的信息。
- en: In the next chapter, we will see how to emit some complex data structures such
    as array, pointers. Also, we will go through some examples from Clang, the frontend
    for C/C++, and understand how semantic Analysis is done.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何发射一些复杂的数据结构，如数组、指针。我们还将通过Clang（C/C++的前端）的一些示例，了解语义分析是如何进行的。
