["```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Assume that the client application has already \n  // obtained the IP-address and the protocol port number.\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  // Used to store information about error that happens\n  // while parsing the raw IP-address.\n  boost::system::error_code ec;\n  // Step 2\\. Using IP protocol version independent address\n  // representation.\n  asio::ip::address ip_address =\n    asio::ip::address::from_string(raw_ip_address, ec);\n\n  if (ec.value() != 0) {\n    // Provided IP address is invalid. Breaking execution.\n    std::cout \n      << \"Failed to parse the IP address. Error code = \"\n      << ec.value() << \". Message: \" << ec.message();\n      return ec.value();\n  }\n\n  // Step 3.\n  asio::ip::tcp::endpoint ep(ip_address, port_num);\n\n  // Step 4\\. The endpoint is ready and can be used to specify a \n  // particular server in the network the client wants to \n  // communicate with.\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Here we assume that the server application has\n  //already obtained the protocol port number.\n  unsigned short port_num = 3333;\n\n  // Step 2\\. Create special object of asio::ip::address class\n  // that specifies all IP-addresses available on the host. Note\n  // that here we assume that server works over IPv6 protocol.\n  asio::ip::address ip_address = asio::ip::address_v6::any();\n\n  // Step 3.\n  asio::ip::tcp::endpoint ep(ip_address, port_num);\n\n  // Step 4\\. The endpoint is created and can be used to \n  // specify the IP addresses and a port number on which \n  // the server application wants to listen for incoming \n  // connections.\n\n  return 0;\n}\n```", "```cpp\nstatic asio::ip::address from_string(\n    const std::string & str,\n    boost::system::error_code & ec);\n```", "```cpp\nclass tcp\n{\npublic:\n  /// The type of a TCP endpoint.\n typedef basic_endpoint<tcp> endpoint;\n\n  //...\n}\n```", "```cpp\nclass udp\n{\npublic:\n  /// The type of a UDP endpoint.\n typedef basic_endpoint<udp> endpoint;\n\n  //...\n}\n```", "```cpp\n// Step 3.\nasio::ip::udp::endpoint ep(ip_address, port_num);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. An instance of 'io_service' class is required by\n  // socket constructor. \n  asio::io_service ios;\n\n  // Step 2\\. Creating an object of 'tcp' class representing\n  // a TCP protocol with IPv4 as underlying protocol.\n  asio::ip::tcp protocol = asio::ip::tcp::v4();\n\n  // Step 3\\. Instantiating an active TCP socket object.\n  asio::ip::tcp::socket sock(ios);\n\n  // Used to store information about error that happens\n  // while opening the socket.\n  boost::system::error_code ec;\n\n  // Step 4\\. Opening the socket.\n  sock.open(protocol, ec);\n\n  if (ec.value() != 0) {\n    // Failed to open the socket.\n    std::cout\n      << \"Failed to open the socket! Error code = \"\n      << ec.value() << \". Message: \" << ec.message();\n      return ec.value();\n  }\n\n  return 0;\n}\n```", "```cpp\nnamespace boost {\nnamespace asio {\nnamespace ip {\n\n  // ...\n  class tcp\n  {\n  public:\n    /// The type of a TCP endpoint.\n    typedef basic_endpoint<tcp> endpoint;\n\n    // ...\n\n    /// The TCP socket type.\n    typedef basic_stream_socket<tcp> socket;\n\n    /// The TCP acceptor type.\n    typedef basic_socket_acceptor<tcp> acceptor;\n\n    // ...\n```", "```cpp\ntry {\n  // Step 3 + 4 in single call. May throw.\n  asio::ip::tcp::socket sock(ios, protocol);\n} catch (boost::system::system_error & e) {\n  std::cout << \"Error occured! Error code = \" << e.code()\n    << \". Message: \"<< e.what();\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. An instance of 'io_service' class is required by\n  // socket constructor. \n  asio::io_service ios;\n\n  // Step 2\\. Creating an object of 'udp' class representing\n  // a UDP protocol with IPv6 as underlying protocol.\n  asio::ip::udp protocol = asio::ip::udp::v6();\n\n  // Step 3\\. Instantiating an active UDP socket object.\n  asio::ip::udp::socket sock(ios);\n\n  // Used to store information about error that happens\n  // while opening the socket.\n  boost::system::error_code ec;\n\n  // Step 4\\. Opening the socket.\n  sock.open(protocol, ec);\n\n  if (ec.value() != 0) {\n    // Failed to open the socket.\n    std::cout\n      << \"Failed to open the socket! Error code = \"\n      << ec.value() << \". Message: \" << ec.message();\n    return ec.value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. An instance of 'io_service' class is required by\n  // socket constructor. \n  asio::io_service ios;\n\n  // Step 2\\. Creating an object of 'tcp' class representing\n  // a TCP protocol with IPv6 as underlying protocol.\n  asio::ip::tcp protocol = asio::ip::tcp::v6();\n\n  // Step 3\\. Instantiating an acceptor socket object.\n  asio::ip::tcp::acceptor acceptor(ios);\n\n  // Used to store information about error that happens\n  // while opening the acceptor socket.\n  boost::system::error_code ec;\n\n  // Step 4\\. Opening the acceptor socket.\n  acceptor.open(protocol, ec);\n\n  if (ec.value() != 0) {\n    // Failed to open the socket.\n    std::cout\n      << \"Failed to open the acceptor socket!\"\n      << \"Error code = \"\n      << ec.value() << \". Message: \" << ec.message();\n    return ec.value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Assume that the client application has already\n  // obtained the DNS name and protocol port number and \n  // represented them as strings.\n  std::string host = \"samplehost.com\";\n  std::string port_num = \"3333\";\n\n  // Step 2.\n  asio::io_service ios;\n\n  // Step 3\\. Creating a query.\n  asio::ip::tcp::resolver::query resolver_query(host,\n    port_num, asio::ip::tcp::resolver::query::numeric_service);\n\n  // Step 4\\. Creating a resolver.\n  asio::ip::tcp::resolver resolver(ios);\n\n  // Used to store information about error that happens\n  // during the resolution process.\n  boost::system::error_code ec;\n\n  // Step 5.\n  asio::ip::tcp::resolver::iterator it =\n    resolver.resolve(resolver_query, ec);\n\n  // Handling errors if any.\n  if (ec != 0) {\n    // Failed to resolve the DNS name. Breaking execution.\n    std::cout << \"Failed to resolve a DNS name.\"\n      << \"Error code = \" << ec.value() \n      << \". Message = \" << ec.message();\n\n    return ec.value();\n  }\n\n  return 0;\n}\n```", "```cpp\nasio::ip::tcp::resolver::iterator it = \n    resolver.resolve(resolver_query, ec);\n\nasio::ip::tcp::resolver::iterator it_end;\n\nfor (; it != it_end; ++it) {\n  // Here we can access the endpoint like this.\n  asio::ip::tcp::endpoint ep = it->endpoint();\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Assume that the client application has already\n// obtained the DNS name and protocol port number and \n// represented them as strings.\nstd::string host = \"samplehost.book\";\n  std::string port_num = \"3333\";\n\n  // Step 2.\n  asio::io_service ios;\n\n  // Step 3\\. Creating a query.\n  asio::ip::udp::resolver::query resolver_query(host,\nport_num, asio::ip::udp::resolver::query::numeric_service);\n\n  // Step 4\\. Creating a resolver.\n  asio::ip::udp::resolver resolver(ios);\n\n  // Used to store information about error that happens\n  // during the resolution process.\n  boost::system::error_code ec;\n\n  // Step 5.\n  asio::ip::udp::resolver::iterator it =\n    resolver.resolve(resolver_query, ec);\n\n  // Handling errors if any.\n  if (ec != 0) {\n    // Failed to resolve the DNS name. Breaking execution.\n    std::cout << \"Failed to resolve a DNS name.\"\n<< \"Error code = \" << ec.value() \n<< \". Message = \" << ec.message();\n\n    return ec.value();\n  }\n\nasio::ip::udp::resolver::iterator it_end;\n\nfor (; it != it_end; ++it) {\n    // Here we can access the endpoint like this.\n    asio::ip::udp::endpoint ep = it->endpoint();\n}\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Here we assume that the server application has\n  // already obtained the protocol port number.\n  unsigned short port_num = 3333;\n\n  // Step 2\\. Creating an endpoint.\n  asio::ip::tcp::endpoint ep(asio::ip::address_v4::any(),\n    port_num);\n\n  // Used by 'acceptor' class constructor.\n  asio::io_service ios;\n\n  // Step 3\\. Creating and opening an acceptor socket.\n  asio::ip::tcp::acceptor acceptor(ios, ep.protocol());\n\n  boost::system::error_code ec;\n\n  // Step 4\\. Binding the acceptor socket.\n  acceptor.bind(ep, ec);\n\n  // Handling errors if any.\n  if (ec != 0) {\n    // Failed to bind the acceptor socket. Breaking\n    // execution.\n    std::cout << \"Failed to bind the acceptor socket.\"\n      << \"Error code = \" << ec.value() << \". Message: \"\n      << ec.message();\n\n    return ec.value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Here we assume that the server application has\n  // already obtained the protocol port number.\n  unsigned short port_num = 3333;\n\n  // Step 2\\. Creating an endpoint.\n  asio::ip::udp::endpoint ep(asio::ip::address_v4::any(),\n    port_num);\n\n  // Used by 'socket' class constructor.\n  asio::io_service ios;\n\n  // Step 3\\. Creating and opening a socket.\n  asio::ip::udp::socket sock(ios, ep.protocol());\n\n  boost::system::error_code ec;\n\n  // Step 4\\. Binding the socket to an endpoint.\n  sock.bind(ep, ec);\n\n  // Handling errors if any.\n  if (ec != 0) {\n    // Failed to bind the socket. Breaking execution.\n    std::cout << \"Failed to bind the socket.\"\n      << \"Error code = \" << ec.value() << \". Message: \"\n      << ec.message();\n\n    return ec.value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Assume that the client application has already\n  // obtained the IP address and protocol port number of the\n  // target server.\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    // Step 2\\. Creating an endpoint designating \n    // a target server application.\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n    // Step 3\\. Creating and opening a socket.\n    asio::ip::tcp::socket sock(ios, ep.protocol());\n\n    // Step 4\\. Connecting a socket.\n    sock.connect(ep);\n\n    // At this point socket 'sock' is connected to \n    // the server application and can be used\n    // to send data to or receive data from it.\n  }\n  // Overloads of asio::ip::address::from_string() and \n  // asio::ip::tcp::socket::connect() used here throw\n  // exceptions in case of error condition.\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // Step1\\. Assume that the client application has already\n  // obtained the DNS name and protocol port number and\n  // represented them as strings.\n  std::string host = \"samplehost.book\";\n  std::string port_num = \"3333\";\n\n  // Used by a 'resolver' and a 'socket'.\n  asio::io_service ios;\n\n  // Creating a resolver's query.\n  asio::ip::tcp::resolver::query resolver_query(host, port_num,\n    asio::ip::tcp::resolver::query::numeric_service);\n\n  // Creating a resolver.\n  asio::ip::tcp::resolver resolver(ios);\n\n  try {\n    // Step 2\\. Resolving a DNS name.\n    asio::ip::tcp::resolver::iterator it =\n      resolver.resolve(resolver_query);\n\n    // Step 3\\. Creating a socket.\n    asio::ip::tcp::socket sock(ios);\n\n    // Step 4\\. asio::connect() method iterates over\n    // each endpoint until successfully connects to one\n    // of them. It will throw an exception if it fails\n    // to connect to all the endpoints or if other\n    // error occurs.\n    asio::connect(sock, it);\n\n    // At this point socket 'sock' is connected to \n    // the server application and can be used\n    // to send data to or receive data from it.\n  }\n  // Overloads of asio::ip::tcp::resolver::resolve and \n  // asio::connect() used here throw\n  // exceptions in case of error condition.\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  // The size of the queue containing the pending connection\n  // requests.\n  const int BACKLOG_SIZE = 30;\n\n  // Step 1\\. Here we assume that the server application has\n  // already obtained the protocol port number.\n  unsigned short port_num = 3333;\n\n  // Step 2\\. Creating a server endpoint.\n  asio::ip::tcp::endpoint ep(asio::ip::address_v4::any(),\n    port_num);\n\n  asio::io_service ios;\n\n  try {\n    // Step 3\\. Instantiating and opening an acceptor socket.\n    asio::ip::tcp::acceptor acceptor(ios, ep.protocol());\n\n    // Step 4\\. Binding the acceptor socket to the \n    // server endpint.\n    acceptor.bind(ep);\n\n    // Step 5\\. Starting to listen for incoming connection\n    // requests.\n    acceptor.listen(BACKLOG_SIZE);\n\n    // Step 6\\. Creating an active socket.\n    asio::ip::tcp::socket sock(ios);\n\n    // Step 7\\. Processing the next connection request and \n    // connecting the active socket to the client.\n    acceptor.accept(sock);\n\n    // At this point 'sock' socket is connected to \n    //the client application and can be used to send data to\n    // or receive data from it.\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```"]