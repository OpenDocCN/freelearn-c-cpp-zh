- en: Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a geometry with a vertex diffuse lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a geometry with a fragment specular lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a normal mapped geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a reflective and refractive geometry using cubemaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding shadows to the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lighting is one of the most important factors influencing the way we perceive
    everything that surrounds us. Most of the information our brains gather about
    the world comes from our eyes. Human sight is very sensitive to even the slightest
    change in lighting conditions. That's why lighting is also very important for
    creators of 3D applications, games, and movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the times when 3D graphics libraries supported only a fixed-function pipeline,
    lighting calculations were performed according to a predefined set of rules--developers
    could only select colors for a light source and a lit object. This led most games
    and applications that used a given library to have a similar look and feel. The
    next step in the evolution of graphics hardware was the introduction of fragment
    shaders: their main purpose was to calculate the final color of a fragment (pixel).
    Fragment shaders literally shaded the geometry, so the name shader was a natural
    choice. Their main advantage was that they were programmable. They could perform
    not only lighting calculations, but also realize almost any other algorithm. Nowadays,
    graphics hardware is much more sophisticated. There are other types of programmable
    parts of graphics hardware which have also adopted the term shaders for their
    names. There are many different algorithms and approaches which all use shaders
    to display interesting images in games, 3D applications, and movies. The basic
    purpose of shader programs is still very important even today--lighting calculations
    must be performed if we want to achieve interesting, eye-catching results.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about commonly used lighting techniques from
    simple object diffuse lighting calculations, to a shadow mapping algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a geometry with a vertex diffuse lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic diffuse lighting algorithm lies at the core of most lighting calculations.
    It is used to simulate the appearance of matte surfaces that reflect the light,
    scattering it in many different directions. In this recipe, we will see how to
    achieve geometry rendering using vertex and fragment shaders that implement the
    diffuse lighting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an image generated with this recipe looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_001.png)'
  prefs: []
  type: TYPE_IMG
- en: The following recipe is very detailed so that you can understand and follow
    all the steps more easily. Further recipes will be based on the knowledge described
    here, so they are shorter but also more general.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Diffuse lighting is based on a **cosine law** introduced by **Johann Heinrich
    Lambert**. It says that the lighting intensity of an observed surface is proportional
    to the cosine of the angle between the direction from the surface to the source
    of light (a light vector) and the surface normal vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This law is easily implemented inside shaders. Normal vectors are provided
    from the application as one of the vertex attributes. The positions of all vertices
    are also known, so we only need to provide a light direction or the position of
    a light source to calculate the light vector inside shaders. Both normal and light
    vectors must be normalized (both must have a length equal to `1.0`). The next
    step is to calculate a cosine of the angle between these two vectors. This is
    done with a single `dot()` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We must remember that a cosine can give negative results. This happens when
    we calculate lighting for points on a surface that point in the opposite direction
    to a light source. Such points cannot be lit by a given light source (they are
    in shadow from the perspective of a given light source), so we must disregard
    such results and clamp them to the `0` value.
  prefs: []
  type: TYPE_NORMAL
- en: In all the following recipes we will use objects of a `VkDestroyer` class, which
    allow us to automatically destroy Vulkan resources. For convenience, a `InitVkDestroyer()`
    function is also introduced. Its purpose is to wrap a given resource in the `VkDestroyer`
    object and connect it to a created logical device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Vulkan instance and a logical device with a set of enabled swapchain
    extensions. Also store the handle of a physical device from which the logical
    device was created (refer to the *Creating a Vulkan Instance with WSI extensions
    enabled* and *Creating a logical device with WSI extensions enabled* recipes from
    [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire handles of graphics and presentation queues from the logical device
    (refer to the *Getting a device queue* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a swapchain with a desired set of parameters. Store the swapchain's size
    (image dimensions) and format (refer to the *Creating a swapchain with R8G8B8A8
    format and a MAILBOX present mode* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get handles of all swapchain images (refer to the *Getting handles of swapchain
    images* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image
    Presentation*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create image views for all swapchain images (refer to the *Creating an image
    view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of resources required to generate frames of animation--command
    pool and command buffers, semaphores (at least two for acquiring a swapchain image
    and to indicate when a frame rendering is finished, which is required during swapchain
    image presentation), fences and framebuffers. Create at least one such set, but
    more can be created if we want to render more frames separately (refer to the
    *Increasing the performance through increasing the number of separately rendered
    frames* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command
    Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load a 3D model data with vertex positions and normal vectors into a variable
    of type `Mesh` named `Model` (refer to the *Loading a 3D model from an OBJ file*
    recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper
    Recipes*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a buffer that will serve as a vertex buffer and will support `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    and `VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` usages (refer to the *Creating a buffer
    recipe* from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    and bind it to the vertex buffer (refer to the *Allocating and binding memory
    object to a buffer* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy vertex data from the `Data` member of the `Model` variable into the vertex
    buffer using a staging buffer (refer to the *Using staging buffer to update buffer
    with a device-local memory bound* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a uniform buffer with `VK_BUFFER_USAGE_TRANSFER_DST_BIT` and `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`
    usages that is big enough to hold data for two 16-element matrices of floating-point
    values (refer to the *Creating a uniform buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a descriptor set layout with only one uniform buffer accessed by a vertex
    shader stage (refer to the *Creating a descriptor set layout* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a descriptor pool from which a descriptor for one uniform buffer can
    be allocated (refer to the *Creating a descriptor pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate a descriptor set from the created pool using the prepared layout (refer
    to *Allocating descriptor sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the descriptor set with the uniform buffer's handle (refer to the *Updating
    descriptor sets* recipes from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepare parameters for a render pass creation. First, specify descriptions
    of two attachments (refer to the *Specifying attachments descriptions* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first attachment should have the same format as the swapchain images. It
    should be cleared on a render pass start and its contents should be stored at
    the end of the render pass. Its initial layout can be undefined, but a final layout
    must be a `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second attachment should have one of the supported depth formats (`VK_FORMAT_D16_UNORM`
    format must always be supported, and at least one of `VK_FORMAT_X8_D24_UNORM_PACK32`
    or `VK_FORMAT_D32_SFLOAT` must be supported). It must be cleared on the render
    pass start, but its contents don't need to be preserved after the render pass.
    Its initial layout may be undefined and the final layout should be the same as
    a layout specified in a subpass (to avoid unnecessary layout transitions).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify one subpass for the render pass, in which the first render pass attachment
    will be provided as a color attachment with a `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
    layout, and the second attachment will be used as a depth attachment with a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`
    layout (refer to the *Specifying subpass descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify two subpass dependencies for the render pass (refer to the *Specifying
    dependencies between subpasses* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*). Use the following values for the first dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_SUBPASS_EXTERNAL` value for `srcSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `dstSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` value for `srcStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `dstStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_MEMORY_READ_BIT` value for `srcAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `dstAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following values for the second render pass dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` value for `srcSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SUBPASS_EXTERNAL` value for `dstSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `srcStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` value for `dstStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `srcAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_MEMORY_READ_BIT` value for `dstAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the render pass using the prepared parameters (refer to the *Creating
    a render pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pipeline layout using the prepared descriptor set layout with only
    a uniform buffer (refer to the *Creating a pipeline layout* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a shader module for a vertex shader stage using a SPIR-V assembly generated
    from the following GLSL code (refer to the *Converting GLSL shaders to SPIR-V
    assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to the *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from respective shader modules (refer to the *Specifying pipeline
    shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify a pipeline vertex input state with two attributes that are read from
    the same 0 binding. Binding should be created with data read per vertex and a
    stride equal to `6 * sizeof( float )` (refer to the *Specifying pipeline vertex
    input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). The first attribute should have the following
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second vertex attribute should be specified using the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3 * sizeof( float)` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify a pipeline input assembly state with a `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`
    topology and without primitive restart (refer to the *Specifying pipeline input
    assembly state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a pipeline viewport and scissor test state with only one viewport and
    scissor test state. Initial values don't matter as they will be set dynamically
    (refer to the *Specifying pipeline viewport and scissor test state* recipe from
    [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a pipeline rasterization state without depth clamp, with no rasterization
    discard, with a `VK_POLYGON_MODE_FILL``,` `VK_CULL_MODE_BACK_BIT` and `VK_FRONT_FACE_COUNTER_CLOCKWISE`,
    without a depth bias and with line widths of `1.0f` (refer to the *Specifying
    pipeline rasterization state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a pipeline multisample state with only a single sample and without sample
    shading, sample masks, alpha to coverage, or alpha to one (refer to the *Specifying
    pipeline multisample state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a pipeline depth state with a depth test and depth writes enabled, with
    a `VK_COMPARE_OP_LESS_OR_EQUAL` operator and without depth bounds or stencil tests
    (refer to the *Specifying pipeline depth and stencil state* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a pipeline blend state with both logical operations and blending disabled
    (refer to the *Specifying pipeline blend state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the viewport and scissor test as dynamic states of a pipeline (refer
    to the *Specifying pipeline dynamic states* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a graphics pipeline using the prepared parameters (refer to the *Creating
    graphics pipelines* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a staging buffer supporting a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage,
    which can hold data of two matrices, each with 16 floating-point elements. The
    buffer's memory object should be allocated on a memory that is host-visible (refer
    to the *Creating a buffer* and *Allocating and binding memory object to a buffer*
    recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 2D image (with an appropriate memory object) and an image view with
    the same format as the render pass's depth attachment, with the same size as the
    size of swapchain images, with one mipmap level and array layer. The image must
    support a `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` usage (refer to the *Creating
    a 2D image and view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*). Remember that these resources (along with the swapchain)
    must be recreated each time the application's window is resized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a model matrix, which can be a multiplication of rotation, scaling and
    translation matrices (refer to the *Preparing a translation matrix*, *Preparing
    a rotation matrix* and *Preparing a scaling matrix* recipes from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*). Copy the contents of the concatenated matrix to the staging
    buffer at a `0` offset (refer to the *Mapping, updating and unmapping host-visible
    memory* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a perspective projection matrix based on the aspect ratio of swapchain's
    dimensions (refer to the *Preparing a perspective projection matrix recipe* from
    [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*). Copy
    contents of the matrix to the staging buffer at an offset equal to the number
    of elements in the model matrix (16) multiplied by the size of a single element
    (`sizeof(float)`). Remember to recreate the projection matrix and copy it to the
    staging buffer each time the application's window is resized (refer to *Mapping,
    updating and unmapping host-visible memory* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside a rendering loop, for each loop iteration, prepare a frame of animation
    by acquiring one of the swapchain images, creating a framebuffer with the acquired
    swapchain image and the image serving as a depth attachment, recording the command
    buffer as described below, submitting it to the graphics queue and presenting
    the acquired image (refer to the *Preparing a single frame of animation* recipe
    from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To record the command buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin recording the command buffer specifying a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`
    usage (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the staging buffer has been updated since the last frame, set a buffer memory
    barrier for the uniform buffer to inform the driver that the buffer's memory will
    be accessed in a different way, copy data from the staging buffer to the uniform
    buffer, and set up another buffer memory barrier (refer to the *Setting a buffer
    memory barrier* and *Copying data between buffers* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When graphics and presentation queues are different, transform the ownership
    for the acquired swapchain image from the presentation queue to the graphics queue
    using an image memory barrier (refer to the *Setting an image memory barrier*
    from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Begin the render pass (refer to the *Beginning a render pass* recipe from [Chapter
    6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and Framebuffers*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the viewport and scissor test states dynamically providing the current swapchain
    dimensions (refer to the *Setting viewport state dynamically* and *Setting scissors
    state dynamically* recipes from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the vertex buffer to the `0` binding (refer to the *Binding vertex buffers*
    recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command
    Recording and Drawing*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the descriptor set to the `0` index (refer to the *Binding descriptor sets*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the graphics pipeline (refer to the *Binding a pipeline object* recipe
    from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw the model geometry (refer to the *Drawing a geometry* recipe from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End the render pass (refer to the *Ending a render pass* recipe from [Chapter
    6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and Framebuffers*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the graphics and presentation queues are different, transform the ownership
    for the acquired swapchain image from the graphics queue to the presentation queue
    using an image memory barrier (refer to the *Setting an image memory barrier*
    from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End the command buffer's recording operation (refer to the *Ending a command
    buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To increase the performance of an application, prepare multiple animation frames
    using separate sets of resources (refer to the *Increasing the performance through
    increasing the number of separately rendered frames* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume we have created a Vulkan Instance and a logical device with enabled WSI
    extensions. We also created a swapchain object (the full source code for these
    operations can be found in the accompanying code samples).
  prefs: []
  type: TYPE_NORMAL
- en: 'To render any geometry, we need to first load a 3D model. Its data needs to
    be copied to a vertex buffer, so we also need to create a vertex buffer, allocate
    and bind a memory to it, and we need to copy the model data using a staging buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a uniform buffer is required. Using the uniform buffer we will provide
    transformation matrices to the shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The uniform buffer will be accessed in a vertex shader. For this purpose, we
    need a descriptor set layout, a descriptor pool, and a single descriptor set,
    which will be updated (populated) with the created uniform buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering operations can only be performed inside render passes. We need a
    render pass with two attachments: the first is a swapchain image; and second is
    an image created by us that will serve as a depth attachment. As we will render
    only a single model without any postprocessing techniques, it is enough for the
    render pass to have just one subpass.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a staging buffer. It will be used to transfer data from the application
    to the uniform buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can render a frame, we need to do one last thing: create a graphics
    pipeline. As the code required to create one is pretty straightforward, we will
    skip it (it can be seen in the code samples accompanying this book).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the model, we need to prepare model and projection matrices. A model
    matrix is used to place a model in a virtual world--it can be moved, scaled, or
    rotated. Such a matrix is usually combined with a view matrix, which is used to
    move a camera in our scene. Here, for simplicity, we won''t use a view transformation;
    but we still need a projection matrix. Because the values in the projection matrix
    depend on the framebuffer''s aspect ratio (in this case the size of the application''s
    window), it must be recomputed every time the application window''s dimensions
    are changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the last thing we need to do is to prepare an animation frame. This
    is usually performed inside a rendering loop, where for each loop iteration a
    separate (new) frame is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to check if the uniform buffer''s contents need to be updated
    and whether the data needs to be copied from the staging buffer to the uniform
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we transfer queue ownership for swapchain images (in a situation when
    graphics and present queues are different). After that, we start the render pass
    and set up all the states required to render a geometry: we set viewport and scissor
    test states, bind the vertex buffer, descriptor set and the graphics pipeline.
    After that, the geometry is drawn and the render pass is finished. Once again,
    we need to transfer the queue ownership back to the presentation queue (if the
    graphics queue is different) and we stop recording the command buffer. Now it
    can be submitted to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we prepare the preceding frame, normal vectors and vertex positions are
    automatically fetched from the vertex buffer. Positions are used, not only to
    display a geometry, but along with the normal vectors, they are also used for
    lighting calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, the light vector is hardcoded in the vertex shader, but normally
    it should be provided using a uniform buffer or a push constant. In this case,
    the light vector always points in the same direction (for all vertices), so it
    simulates a directional light, which usually represents the sun.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, all lighting calculations are performed in the view space.
    We can perform such calculations in any coordinate system we want, but all vectors
    (normal, light vectors, view vectors, and so on) must be transformed to the same
    space in order for the calculations to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: After calculating the diffuse term, we also add a constant value to the calculated
    color. Usually this is referred to as ambient lighting, which is used to brighten
    up the scene (otherwise all shadows/unlit surfaces would be too dark).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below we can see diffuse lighting calculated at each vertex applied to geometry
    with a different number of polygons: on the left, a detailed geometry (high-polygon);
    and, on the right model, with a much smaller amount of detail (low-polygon):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_003.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a Vulkan Instance with WSI extensions enabled*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a logical device with WSI extensions enabled*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a swapchain with R8G8B8A8 format and a MAILBOX present mode*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, the recipe *Beginning a command buffer recording operation*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, the recipe *Creating graphics pipelines*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, the recipe *increasing the performance by increasing the number
    of separately rendered frames*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    the recipe* Loading a 3D model from an OBJ file*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rendering a geometry with a fragment specular lighting*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rendering a normal mapped geometry*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a geometry with a fragment specular lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specular lighting allows us to add bright highlights or reflections on the surface
    of a model. This way rendered geometry looks shinier and more glossy.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an image generated with this recipe looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most commonly used algorithm describing the way surfaces are lit is a **Blinn-Phong**
    model. It is an empirical model, which isn't physically correct but gives results
    that are more plausible in situations where rendered geometry is simplified. So
    it is well suited for 3D real-time graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Blinn-Phong** model describes light leaving a given surface as a sum
    of four components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Emissive**: The amount of light emitted by the surface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ': The amount of reflected light that is scattered around the whole scene and
    doesn''t have any visible source (used to brighten up the geometry)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ambient: The amount of reflected light that is scattered around the whole scene
    and doesn''t have any visible source (used to brighten up the geometry) Diffuse:
    Describes the light reflected by rough surfaces (based on the Lambert lighting
    equation)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specular**: Describes the light reflected by shiny, slick surfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the above components may have a different color, which describes the
    surface material (diffuse color is usually taken from a texture). Each light source
    may also be represented with a separate color for each component (except the emissive).
    We can interpret it as how much given light source influences the ambient light
    available in the scene, how much diffuse lighting is emitted by the light source,
    and so on. We can, of course, modify the preceding algorithm to adjust it to our
    needs. This way we can achieve various results that are easy to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will focus on the diffuse lighting and specular reflections.
    The former are described in the *Rendering a geometry with a vertex diffuse lighting*
    recipe. The latter are calculated with a dot product of a surface normal vector
    and a half vector. A half vector is a vector that is halfway between a view vector
    (from the lit point to the viewer) and the light vector (from the lit point to
    the light source):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The calculated dot product value is responsible for creating shinny light reflections
    on slick surfaces. As the area lit this way may be too big, the calculated value
    is then raised to the power. The higher the power value, the smaller and more
    concentrated are light reflexes on an object''s surface. In the shader, these
    are calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Normal vector is usually loaded along the geometry and provided by the application.
    The half vector is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To achieve correct results, all vectors must be normalized. Of course, specular
    highlights are not visible when the surface is not lit (or doesn't face the light
    source). So they should be calculated only when the diffuse component is greater
    than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare Vulkan resources as described in the *Rendering a geometry with a vertex
    diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pipeline layout using the prepared descriptor set layout with only
    a uniform buffer and also with a single push constant range accessed by a fragment
    shader stage, beginning at a 0^(th) offset and of a `4 * sizeof( float )` size
    (refer to the *Creating a pipeline layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a shader module for a vertex shader stage using a SPIR-V assembly generated
    from the following GLSL code (refer to the *Converting GLSL shaders to SPIR-V
    assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Specify the pipeline shader stages with vertex and fragment shaders, both using
    a main function from the respective shader modules (refer to the *Specifying pipeline
    shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a graphics pipeline using the pipeline layout and shader stages presented
    previously. The rest of pipeline parameters remain identical to those presented
    in the *Rendering a geometry with a vertex diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a command buffer recording (or a rendering) function executed each frame.
    To do this, we need to begin a command buffer recording, copy data from the staging
    buffer to the uniform buffer (if needed), set an image memory barrier to transfer
    queue ownership for an image acquired from the swapchain, begin the render pass,
    set the viewport and scissor test states dynamically, bind the vertex buffers,
    descriptor sets and the graphics pipeline (refer to the *Rendering a geometry
    with a vertex diffuse lighting* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a position of a light source and provide it to the shaders through push
    constants. For this operation, provide the pipeline layout, a `VK_SHADER_STAGE_FRAGMENT_BIT`
    shader stage, `0` offset and a size of `sizeof( float ) * 4`, and a pointer to
    the data, in which the light source's position is stored (refer to the *Providing
    data to shaders through push constants* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finalize the command buffer by recording the model drawing operation, ending
    the render pass, setting another image memory barrier for the swapchain image
    and ending the command buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submit the command buffer to the graphics queue and present an image (refer
    to the *Preparing a single frame of animation* and *Increasing the performance
    through increasing the number of separately rendered frames* recipes from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole source code is almost identical to the one presented in the *Rendering
    a geometry with a vertex diffuse lighting* recipe. The most important difference
    is in the vertex and fragment shaders, which perform lighting calculations based
    on data provided from the application. This time a light vector is not hardcoded
    in the shader. Instead, it is calculated using the data provided from the application.
    Positions and normal vectors are automatically read as vertex attributes. The
    position of a light source is read using a push constant, so we need to include
    a push constant range, when we create a pipeline layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Data to a push constant is provided during the command buffer recording operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Through the push constant, we provide a position of a light source. This way
    our shaders becomes more universal, as we can calculate light vector directly
    in a shader and use it for lighting calculations.
  prefs: []
  type: TYPE_NORMAL
- en: In the following image, we can see the results of rendering a geometry lit with
    a diffuse and specular lighting calculated inside a fragment shader. The results
    of lighting calculations performed in the fragment shader are much better than
    if the same calculations were performed in the vertex shader. The lighting looks
    good even if the geometry is quite simple. But, of course, this comes with reduced
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_006.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, the recipe
    *Converting GLSL shaders to SPIR-V assemblies*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a shader module*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline shader stages*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a pipeline layout*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes::'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing data to shaders through push constants*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipe in this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rendering a geometry with a vertex diffuse lighting*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a normal mapped geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normal mapping is a technique that allows us to increase the details of a model's
    surface without increasing its geometrical complexity. Using this technique, normal
    vectors associated with vertices are not used during lighting calculations. They
    are replaced with normal vectors read from an image (a texture). This way, the
    shape of a model is unchanged, so we don't need additional processing power to
    transform vertices. However, the lighting quality is much better and depends only
    on the quality of a normal map image instead of the complexity of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an image generated with this recipe looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normal map is an image, in which normal vectors acquired from a highly detailed
    geometry are stored. It is used to simulate the high amount of surface details
    on a simple (low-polygon) geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_008-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For simple lighting calculations, we just need to load positions and normal
    vectors, but normal mapping requires us to load (or generate) much more data for
    a given 3D model. Apart from the above attributes, we also need texture coordinates,
    so we can sample a normal map inside fragment shaders, and two additional vectors:
    tangent and bitangent. The normal vector is perpendicular to the surface at a
    given point and points in a direction that is away from the surface. Tangent and
    bitangent vectors are tangential to the surface. Tangent vector points in the
    direction on object''s surface, in which texture image advances *horizontally*,
    from left to right (`s` component of texture coordinates is increasing). Bitangent
    points in the direction on object''s surface, in which the texture image advances
    *vertically*, from top to bottom (`t` component of texture coordinates is decreasing).
    Additionally, all three vectors - a normal, tangent and bitangent - should be
    perpendicular to each other (small deviations are acceptable) and have a length
    equal to `1.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Normal, tangent and bitangent vectors are not used directly for lighting calculations.
    Instead, they form a rotation matrix, which can be used to convert a vector from
    texture (or tangent) space to a local model space or vice versa. This way we don't
    need to create a texture with normal vectors that can only be applied to a dedicated
    model, but we can prepare a general normal map and use it with an arbitrary geometry.
    Using the so called TBN matrix, we can load a normal vector from the texture and
    use it for lighting calculations performed in a coordinate system that is more
    convenient for us.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare Vulkan resources as described in the *Rendering a geometry with a vertex
    diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load texture data from a file with a normal map (refer to the *Loading texture
    data from a file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a two-dimensional combined image sampler that has a color aspect and
    format (in example `VK_FORMAT_R8G8B8A8_UNORM`) and supports `VK_IMAGE_USAGE_SAMPLED_BIT`
    and `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usages (refer to the *Creating a combined
    image sampler* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy data loaded from a normal map into the created image using a staging buffer
    (refer to the *Using staging buffer to update an image with a device-local memory
    bound* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load a 3D model from a file. Apart from the vertex positions and normal vectors,
    load also texture coordinates and load or generate tangent and bitangent vectors.
    Create a (vertex) buffer and copy loaded model data to the buffer's memory using
    a staging buffer (refer to the *Loading a 3D model from an OBJ file* from [Chapter
    10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a descriptor set layout with one uniform buffer accessed by a vertex
    shader at 0^(th) binding and with one combined image sampler accessed by a fragment
    shader at 1^(st) binding (refer to the *Creating a descriptor set layout* recipe
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a descriptor pool from which one uniform buffer descriptor and one combined
    image sampler descriptor can be allocated (refer to the *Creating a descriptor
    pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate one descriptor set from the created pool using a descriptor set layout
    with one uniform buffer and one combined image sampler (refer to *Allocating descriptor
    sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the descriptor set with the uniform buffer accessed at the 0^(th) binding
    and with the created combined image sampler with normal map data accessed at the
    1^(st) binding. Provide a `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value as
    the image's layout (refer to the *Updating descriptor sets* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pipeline layout using the prepared descriptor set layout that also
    specifies a single push constant range accessed by a fragment shader stage, beginning
    at a 0^(th) offset and of a `4 * sizeof( float )` size (refer to the *Creating
    a pipeline layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a shader module for a vertex shader stage using a SPIR-V assembly generated
    from the following GLSL code (refer to the *Converting GLSL shaders to SPIR-V
    assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders and to Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from respective shader modules (refer to the *Specifying pipeline
    shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify a pipeline vertex input state with five attributes that are read from
    the same 0^(th) binding. The binding should be created with data read per vertex
    and a stride equal to `14 * sizeof( float )` (refer to the *Specifying pipeline
    vertex input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). The first attribute should have the following
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second attribute should be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3 * sizeof( float )` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third attribute should have the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6 * sizeof( float )` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fourth attribute should be specified as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8 * sizeof( float )` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fifth attribute should use these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`4` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`11 * sizeof( float )` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In each frame of animation, record a command buffer, inside which copy data
    from the staging buffer to the uniform buffer, begin the render pass, set the
    viewport and scissor test state dynamically, bind the vertex buffer, the descriptor
    set and the graphics pipeline (refer to the *Rendering a geometry with a vertex
    diffuse lighting recipe*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the position of a light source and provide it to shaders through push
    constants. For this operation, provide the pipeline layout, a `VK_SHADER_STAGE_FRAGMENT_BIT`
    shader stage, `0` offset and a size of `sizeof( float ) * 4`, and a pointer to
    the data, in which light source's position is stored (refer to the *Providing
    data to shaders through push constants* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the model, record the rest of the required operations into the command
    buffer, submit the command buffer to the graphics queue, and present an image
    (refer to the P*reparing a single frame of animation and Increasing the performance
    through increasing the number of separately rendered frames* recipes from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use normal mapping in our application, we need to prepare an image, in which
    normal vectors are stored. We must load the image''s contents, create an image,
    and copy the data to the image''s memory. We also need to create a sampler that,
    along with the image, will form a combined image sampler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to load a 3D model. We need to load positions, normal vectors,
    and texture coordinates. Tangent and bitangent vectors must also be loaded, but
    as the `.obj` format cannot store so many different attributes, we must generate
    them (this is performed inside the `Load3DModelFromObjFile()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to modify the descriptor set described in the *Rendering a geometry
    with a vertex diffuse lighting* recipe. First, we start by creating a proper layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a descriptor pool is required. From it a descriptor set is allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the descriptor set is allocated, we can update it with handles of the
    uniform buffer and the combined image sampler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we have not two but five vertex attributes, so we also need to modify
    the vertex input state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding attributes are read in the vertex shader, which transforms the
    vertex position to a clip space using the model-view and projection matrices.
    Additionally, the view-space position and unmodified texture coordinates are passed
    to the fragment shader. Normal, tangent and bitangent vectors are also passed
    to the fragment shader, but they are first transformed to a view space with the
    model-view matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part, from the normal mapping perspective, takes place in
    the fragment shader. It first reads the normal vector from the texture. Usually,
    textures store values that are in the `0.0` - `1.0` range inclusive (unless we
    use signed-normalized texture formats: `SNORM`). However, all the components of
    normal vectors may have values in the `-1.0` - `1.0` range, so we need to expand
    the loaded normal vector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader calculates diffuse and specular lighting in the same way
    as described in the *Rendering a geometry with a fragment specular lighting* recipe.
    It just takes the normal vector loaded from the texture instead of the one provided
    from the vertex shader. There is just one additional thing it needs to perform:
    all the vectors (light and view) are in the view space, but the normal vector
    stored in the normal map is in the tangent space, so it also needs to be converted
    to the same view space. This is done with a TBN matrix formed from the normal,
    tangent and bitangent vectors. They are provided from the vertex shader. Because
    the vertex shader transforms them from the model space into a view space (by multiplying
    them by the model-view matrix), the created TBN matrix converts the normal vector
    from the tangent space directly into the view space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`mat3()` is a constructor for creating a 3x3 matrix from three-component vectors.
    Using such a matrix, we can perform rotations and scaling, but no translation.
    Since we want to transform directions (unit-length vectors), this is exactly what
    we need in this situation.'
  prefs: []
  type: TYPE_NORMAL
- en: Normal mapping can give us impressive lighting even on very simple (low-poly)
    geometry. In the image below, on the left we can see normal mapped geometry with
    many polygons; while on the right, similar geometry is presented but with fewer
    vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_009.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*,
    the recipe *Using staging buffer to update an image with a device local memory
    bound*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    the recipe *Creating a combined image sampler*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    see the following recipes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading texture data from a file*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading a 3D model from an OBJ file*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, look at the following recipes in the same chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rendering a geometry with a vertex diffuse lighting*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rendering a geometry with a fragment specular lighting*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a reflective and refractive geometry using cubemaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real-life, transparent objects both transmit light rays, and also reflect
    them. If an object's surface is viewed from high angles, we see more light being
    reflected. Looking at an object's surface more directly, we see more light being
    transmitted through the object. Simulating such an effect may generate very plausible
    results. In this recipe, we will see how to render a geometry that is both refractive
    and reflective.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an image generated with this recipe looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cubemaps are textures with images covering six sides of a cube. They usually
    store the view of a scene from a given position. The most common use for cubemaps
    are skyboxes. They are also handy when we want to map reflections on a surface
    of a given model. Another example of common use is to simulate transparent objects
    (that is made of glass), which refract light rays. Very low resolution cubemaps
    (in example 4x4 pixels) can even be used directly for ambient lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cubemaps contain six two-dimensional images. All of them are square and have
    the same size. In Vulkan, cubemaps are created using 2D images with six array
    layers, for which a cubemap image view is created. Through it, the six array layers
    are interpreted as cubemap faces in the following order: `+X`, `-X`, `+Y`, `-Y`,
    `+Z`, `-Z`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_011.png)'
  prefs: []
  type: TYPE_IMG
- en: Images courtesy of Emil Persson ([h t t p ://w w w . h u m u s . n a m e](http://www.humus.name))
  prefs: []
  type: TYPE_NORMAL
- en: Six sides of a cubemap correspond to six directions, as if we stayed in one
    position, turned around, and took photos of the world around us. Using such a
    texture, we can simulate the world being reflected from the surface of the object
    or being transmitted through the object. However, when an object moves too far
    from the place the texture was created for, the illusion is broken until we apply
    a new texture that is valid for the new position.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare Vulkan resources as described in the *Rendering a geometry with a vertex
    diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load a 3D model data from file with vertex positions and normal vectors. This
    model will be displayed as the one reflecting and transmitting the environment
    (refer to the *Loading a 3D model from an OBJ file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper
    Recipes*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a (vertex) buffer with a memory object and use it store the vertex data
    for our model (refer to the *Creating a buffer, Allocating and binding memory
    object to a buffer* and *Using staging buffer to update buffer with a device-local
    memory bound* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load a 3D model containing vertex positions of a cube. This model will be used
    to display the environment being reflected (refer to the *Drawing a skybox* recipe
    from [Chapter 12](82938796-18a3-413b-b05d-47816d70e49a.xhtml), *Advanced Rendering
    Techniques*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a buffer, along with a memory object bound it, to hold the vertex data
    of the environment (skybox).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a two-dimensional combined image sampler with six array layers and a
    cube image view. It must support `VK_IMAGE_USAGE_SAMPLED_BIT` and `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
    uses. A `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` sampler address mode must be used
    for all addressing dimensions (refer to the *Creating a combined image sampler*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load texture data for all six sides of a cubemap from files (refer to the *Loading
    texture data from a file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upload each loaded texture to a separate array layer of a created combined
    image sampler. Textures should be uploaded in the following order: positive and
    negative X, positive and negative Y, positive and negative Z (refer to the *Using
    staging buffer to update an image with a device-local memory bound* from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a descriptor set layout with two descriptor resources: a uniform buffer
    accessed in a vertex shader at 0^(th) binding and with a combined image sampler
    accessed in a fragment shader at 1^(st) binding (refer to the *Creating a descriptor
    set layout* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a descriptor pool, from which one uniform buffer descriptor and one combined
    image sampler descriptor can be allocated (refer to the *Creating a descriptor
    pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate a descriptor set from the created pool using the descriptor set layout
    with a uniform buffer and a combined image sampler resources (refer to the *Allocating
    descriptor sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update (populate) the descriptor set with the uniform buffer accessed at the
    0^(th) binding and with the created combined image sampler (cubemap) accessed
    at the 1^(st) binding. Provide a `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value
    as the cubemap's layout (refer to the *Updating descriptor sets* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pipeline layout using the prepared descriptor set layout that also
    specifies a single push constant range accessed by a fragment shader stage, beginning
    at a 0^(th) offset and of a `4 * sizeof( float )` size (refer to the *Creating
    a pipeline layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a graphics pipeline used for drawing a reflective and refractive model.
    Start by creating a shader module for a vertex shader stage using a SPIR-V assembly
    generated from the following GLSL code (refer to the *Converting GLSL shaders
    to SPIR-V assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to Creating a shader module recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from the respective shader modules (refer to the *Specifying
    pipeline shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a graphics pipeline for drawing a model using the preceding pipeline
    shader stages definition, with the rest of the pipeline's parameters defined in
    the same way as in the *Rendering a geometry with a vertex diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a graphics pipeline for drawing an environment being reflected--a skybox
    (refer to the *Drawing a skybox* recipe from [Chapter 12](82938796-18a3-413b-b05d-47816d70e49a.xhtml),
    *Advanced Rendering Techniques*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To render a frame, record a command buffer in each iteration of a rendering
    loop. In the command buffer, copy data from the staging buffer to the uniform
    buffer, begin the render pass, set the viewport and scissor test states dynamically
    and bind the descriptor set (refer to the *Rendering a geometry with a vertex
    diffuse lighting* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the graphics pipeline and the vertex buffer created for the reflective/refractive
    model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the position of a camera, from which the scene is observed and provide
    it to shaders through push constants. For this operation, provide the pipeline
    layout, a `VK_SHADER_STAGE_FRAGMENT_BIT` shader stage, `0` offset and a size of
    `sizeof( float ) * 4`, and a pointer to the data, in which the camera's position
    is stored (refer to the *Providing data to shaders through push constants* recipe
    from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the model (refer to the *Drawing a geometry* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the graphics pipeline and the vertex buffer created for the skybox and
    draw it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record the rest of the required operations into the command buffer, submit the
    command buffer to the graphics queue, and present an image (refer to the *Preparing
    a single frame of animation and Increasing the performance through increasing
    the number of separately rendered frames* recipes from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start this recipe by loading and preparing buffers for two models: the first
    being the one simulating our main scene (reflective/refractive model); and second
    being used to draw the environment itself (a skybox). We need to copy vertex data
    using staging buffers to both vertex buffers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a cubemap. We do this by creating a combined image
    sampler. The image must be of a 2D type, must have six array layers, and must
    support `VK_IMAGE_USAGE_SAMPLED_BIT` and `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usages.
    The format of the image depends on the case, but usually a `VK_FORMAT_R8G8B8A8_UNORM`
    would be a good choice. The created sampler must use a `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`
    addressing mode for all sampling dimensions (`u`, `v`, and `w`), otherwise we
    might see the edges of all cubemap faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to upload data to the cubemap image. In this sample we load data
    from six separate files and copy it to six layers of an image like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a descriptor set through which a fragment shader will be able
    to access the cubemap. To allocate a descriptor set its layout is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Descriptor sets are allocated from pools. So now we create one and allocate
    the descriptor set itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One last step connected with descriptor resources is to update the created
    set with handles of resources that should be accessed in shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After descriptor sets, it''s time to create a render pass and a graphics pipeline,
    or rather two pipelines: one for drawing the model, and one for drawing the environment
    (a skybox). A graphics pipeline used for the model is very similar to the one
    created in the *Rendering a geometry with a vertex diffuse lighting* recipe, except
    it uses different shader programs and a push constant range, so we need to include
    it during pipeline layout creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The vertex shader, as usual, calculates the clip space position of a vertex
    and passes the unmodified position and normal vector to the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating reflections or refractions is most easily done in the world space
    and we should transform both vectors to this coordinate system. However, to simplify
    the recipe, the above vertex shader makes an assumption that the model is already
    provided in the world space, that''s why unmodified vectors (position and normal)
    are passed to the fragment shader. It then takes these vectors and uses them to
    calculate both reflected and refracted vectors with built-in `reflect()` and `refract()`
    functions. Calculated vectors are used to read values from the cubemap. They are
    then mixed together based on the viewing angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As for the creation of a graphics pipeline used for the skybox rendering, there
    is a dedicated *Drawing a skybox* recipe in [Chapter 12](82938796-18a3-413b-b05d-47816d70e49a.xhtml),
    *Advanced Rendering Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we should focus on is a command buffer recording. Here we render
    two objects, not one, so first we need to set an appropriate state required to
    properly draw the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after the preceding code, we render the skybox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we don't need to render the environment--the reflections (and refractions)
    are stored in the texture. However, usually we also want to see the environment
    being reflected, not only the reflections.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the knowledge in this recipe combined with the *Rendering a geometry with
    a vertex diffuse lighting* recipe, should generate the results seen in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_012.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    the recipe *Creating a combined image sampler*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, the recipe *Providing data to shaders through push constants*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    see the following recipes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading texture data from a file*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading a 3D model from an OBJ file*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe *Rendering a geometry with a vertex diffuse lighting*, in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding shadows to the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lighting is one of the most important operations performed by 3D applications.
    Unfortunately, due to the specifics of graphics libraries and the graphics hardware
    itself, lighting calculations have one major drawback--they don't have information
    about positions of all drawn objects. That's why generating shadows requires a
    special approach and advanced rendering algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: There are several popular techniques targeted at efficient generation of natural
    looking shadows. Now we will learn about a technique called shadow mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an image generated with this recipe looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_013.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shadow mapping technique requires us to render a scene twice. Firstly, we
    render objects that cast shadows. They are rendered from the light's point of
    view. This way we store depth values in a depth attachment (color values are not
    required).
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the second step, we render the scene as we normally do, from the camera's
    point of view. Inside shaders we use the shadow map generated in the first step.
    The vertex position is projected onto the shadow map and its distance from the
    light position is compared with the value read from the shadow map. If it is greater,
    it means a given point is covered in shadow, otherwise it is normally lit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare the Vulkan resources as described in the *Rendering a geometry with
    a vertex diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the 3D models with vertex positions and normal vectors. Store loaded data
    in a (vertex) buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a uniform buffer with `VK_BUFFER_USAGE_TRANSFER_DST_BIT` and `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`
    usages that are big enough to hold data for three 16-element matrices of floating-point
    values (refer to the *Creating a uniform buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a staging buffer supporting a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage,
    which is able to hold data for three matrices each with 16 floating-point elements.
    The buffer's memory object should be allocated on a memory that is host-visible
    (refer to the *Creating a buffer and Allocating and binding memory object to a
    buffer* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a combined image sampler that should act as a shadow map. The image should
    be two-dimensional with one of the supported depth formats (`VK_FORMAT_D16_UNORM`
    must always be supported), and should support `VK_IMAGE_USAGE_SAMPLED_BIT` and
    `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` usages (refer to the *Creating a
    combined image sampler* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a descriptor set layout with two descriptor resources: a uniform buffer
    accessed in a vertex shader at 0^(th) binding and with a combined image sampler
    accessed in a fragment shader at 1^(st) binding (refer to the *Creating a descriptor
    set layout* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a descriptor pool, from which one uniform buffer descriptor and one combined
    image sampler descriptor can be allocated (refer to the *Creating a descriptor
    pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A descriptor set from the created pool using the descriptor set layout with
    a uniform buffer and a combined image sampler resources (refer to the *Allocating
    descriptor sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update (populate) the descriptor set with the uniform buffer accessed at the
    0^(th) binding and with the created combined image sampler (shadow map) accessed
    at the 1^(st) binding. Provide a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
    value as the image's layout (refer to the *Updating descriptor sets* recipe from
    [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare data for a render pass used for drawing the whole scene into the shadow
    map. This render pass should have only one attachment, which has the same format
    as the combined image sampler's format. The image should be cleared on load, its
    initial layout may be undefined. The image contents should be stored at the end
    of the render pass and the final layout should be set to a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
    (refer to the *Specifying attachments descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The render pass used for shadow map generation should have just one subpass
    with only a depth attachment, for which framebuffer's 0^(th) attachment with a
    `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` layout should be used (refer
    to the *Specifying subpass descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify two subpass dependencies for the render pass (refer to the *Specifying
    dependencies between subpasses* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*). Use the following values for the first dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_SUBPASS_EXTERNAL` value for `srcSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `dstSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` value for `srcStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` value for `dstStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_SHADER_READ_BIT` value for `srcAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` value for `dstAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following values for the second render pass dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` value for `srcSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_SUBPASS_EXTERNAL` value for `dstSubpass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` value for `srcStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` value for `dstStageMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` value for `srcAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_ACCESS_SHADER_READ_BIT` value for `dstAccessMask`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a render pass using the above parameters (refer to the *Creating a render
    pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render
    Passes and Framebuffers*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a framebuffer compatible with the created render pass. The Framebuffer
    should have one attachment, for which the image view created along with the shadow
    map's combined image sampler should be used. Framebuffer should also have the
    same dimensions as the shadow map image (refer to the *Creating a framebuffer*
    recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second render pass used for drawing the scene normally into a swapchain
    (refer to the *Rendering a geometry with a vertex diffuse lighting* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pipeline layout using the prepared descriptor set layout. Also, specify
    a single push constant range accessed by a vertex shader stage, beginning at a
    0^(th) offset and of a `4 * sizeof( float )` size (refer to the *Creating a pipeline
    layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a graphics pipeline used for drawing a scene into the shadow map. Start
    by creating a shader module for a vertex shader stage using a SPIR-V assembly
    generated from the following GLSL code (refer to the *Converting GLSL shaders
    to SPIR-V assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Specify pipeline shader stages with a vertex shader only, which uses a `main`
    function from the prepared shader module (refer to the *Specifying pipeline shader*
    stages recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify a pipeline vertex input state with one attribute that is read from
    the 0^(th) binding. The binding should be created with data read per vertex and
    a stride equal to `6 * sizeof( float )` (refer to the *Specifying pipeline vertex
    input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). The attribute should have the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the viewport and scissor test parameters with one viewport, whose dimensions
    match the size of the shadow map image (refer to the *Specifying pipeline viewport
    and scissor test state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a graphics pipeline using the previously specified parameters. Skip the
    blending state, because the render pass used for the shadow map generation doesn't
    have any color attachments (rasterization must be enabled though, because otherwise
    no fragments will be generated and their depth won't be stored in the shadow map).
    Also, don't use dynamic states, because the size of the shadow map doesn't change
    (refer to the *Creating graphics pipelines* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another graphics pipeline used for rendering a shadowed scene. This
    time, create a shader module for a vertex shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from a respective shader modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify a pipeline vertex input state with two attributes that are read from
    the same 0^(th) binding. The binding should be created with data read per vertex
    and a stride equal to `6 * sizeof( float )`. The first attribute should have the
    following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 value for `offset`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second attribute should have the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` value for `location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `binding`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3 * sizeof( float )` value for `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a graphics pipeline for rendering the shadowed scene using the above
    shader stages and two attributes, with the rest of the parameters similar to those
    defined in the *Rendering a geometry with a vertex diffuse lighting* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a view matrix, which can be a multiplication of rotation, scaling and
    translation matrices used to draw the scene from the light's perspective (refer
    to the *Preparing a translation matrix*, *Preparing a rotation matrix* and *Preparing
    a scaling matrix* recipes from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*). Copy the contents of the concatenated matrix to the staging
    buffer at a `0` offset (refer to the *Mapping, updating and unmapping host-visible
    memory* recipe from [Chapter 4](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Resources
    and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a view matrix used to draw the scene normally, from the camera's perspective.
    Copy the contents of this matrix to the staging buffer at a `16 * sizeof( float
    )` offset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a perspective projection matrix based on the aspect ratio of the swapchain's
    dimensions (refer to the *Preparing a perspective projection matrix* recipe from
    [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*). Copy
    the contents of the matrix to the staging buffer at a `32 * sizeof( float )`.
    Remember to recreate the projection matrix and copy it to the staging buffer each
    time the application's window is resized (refer to the *Mapping, updating and
    unmapping host-visible memory* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In each frame of animation, record a command buffer. Start by checking whether
    any of the view or projection matrices were modified: if they were, copy the contents
    of the staging buffer to the uniform buffer, guarded by the proper pipeline barriers
    (refer to the *Copying data between buffers* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin a render pass used for drawing the scene from the light's perspective
    into the shadow map. Bind the vertex buffer, descriptor set, and the pipeline
    used to fill the shadow map. Draw the geometry and end the render pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transfer ownership of the acquired swapchain image if necessary. Set the viewport
    and scissor test states dynamically, bind the graphics pipeline created for rendering
    the shadowed scene, and draw the geometry once again. End the command buffer recording,
    submit the command buffer to the queue, and present an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating a combined image sampler, in which depth information from
    the light''s perspective will be stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The combined image sampler, along with uniform buffer, will be accessed in
    shaders, so we need a descriptor set through which shaders will have access to
    both. Despite the fact that we render the scene twice using two different pipelines,
    we can use one descriptor set to avoid unnecessary state switching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to populate the descriptor set with the handles of a uniform buffer
    and the combined image sampler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a dedicated render pass for storing the depth information
    in the shadow map. It doesn''t use any color attachments, because we only need
    depth data. We also create a framebuffer. It can have fixed dimensions as we don''t
    change the size of the shadow map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two graphics pipelines. They both use the same push constant
    range to lower the number of variables (though only the second pipeline uses it
    in shaders):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first pipeline is for the shadow map generation. It uses very simple shaders
    that read only vertex positions and render the scene from the light's point of
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second pipeline renders the scene normally into the swapchain image. Its
    shaders are more complicated. A vertex shader calculates the position normally,
    but also converts the normal vector and the light vector into the view space for
    correct lighting calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important thing that the vertex shader does is to calculate the vertex''s
    position in the light source''s view space. To do this, we multiply it by the
    light''s model-view and projection matrices (perspective division is done in the
    fragment shader). The acquired result is used to fetch data from the shadow map.
    However, the calculated position values (after perspective division) are in the
    `-1.0 - 1.0` range and reading data from textures using normalized texture coordinates
    requires providing the values in the `0.0 - 1.0` range. That''s why we need to
    bias the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This way the fragment shader can project the interpolated position onto the
    shadow map and read the value from a proper coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The value read from the shadow map is compared with the point's distance from
    the light's position (offset by a small value). If the distance is greater than
    the value stored in the shadow map, the point is lying in a shadow and shouldn't
    be lit. We need to add the small offset, so the surface of an object doesn't cast
    shadows on itself (only on parts that are further away). We also don't fully discard
    the lighting to avoid the shadows being too dark, hence the value `0.5` assigned
    to the shadow variable.
  prefs: []
  type: TYPE_NORMAL
- en: The above calculations can be performed using a `textureProj()`and a `sampler2DShadow`.
    This way perspective division, offsetting the distance and comparing it to a reference
    value is performed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the resources created in this recipe are similar to those presented
    in the *Rendering a geometry with a vertex diffuse lighting* recipe. Rendering/recording
    a command buffer requires us, apart from the usual stuff, to render the scene
    twice. Firstly, we fill the shadow map by drawing all objects from the light''s
    perspective. The shadow map is then used during the rendering of all the objects
    normally from the camera''s perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows different models casting shadows on a flat plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_014.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a combined image sampler*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a render pass*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a framebuffer*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe *Rendering a geometry with a vertex diffuse lighting*, in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
