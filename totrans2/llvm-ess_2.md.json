["```cpp\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\n```", "```cpp\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\nusing namespace llvm;\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\n\nint main(int argc, char *argv[]) {\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n$ ./toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\n```", "```cpp\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n```", "```cpp\nint main(int argc, char *argv[]) {\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);\n Function *fooFunc = llvm::Function::Create(\n funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n return fooFunc;\n}\n\nint main(int argc, char *argv[]) {\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n\n```", "```cpp\n$ ./toy\n; ModuleID = 'my compiler'\n\ndeclare i32 @foo()\n\n```", "```cpp\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nint main(int argc, char *argv[]) {\n  static IRBuilder<> Builder(Context);\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\ndefine i32 @foo() {\nentry:\n}\n```", "```cpp\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n  ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n  GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n  gVar->setLinkage(GlobalValue::CommonLinkage);\n  gVar->setAlignment(4);\n  return gVar;\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n gVar->setLinkage(GlobalValue::CommonLinkage);\n gVar->setAlignment(4);\n return gVar;\n}\n\nint main(int argc, char *argv[]) {\n  static IRBuilder<> Builder(Context);\n  GlobalVariable *gVar = createGlob(Builder, \"x\");\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo() {\nentry:\n}\n```", "```cpp\nBuilder.CreateRet(Builder.getInt32(0));\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n  ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n  GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n  gVar->setLinkage(GlobalValue::CommonLinkage);\n  gVar->setAlignment(4);\n  return gVar;\n}\n\nint main(int argc, char *argv[]) {\n  static IRBuilder<> Builder(Context);\n  GlobalVariable *gVar = createGlob(Builder, \"x\");\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n Builder.CreateRet(Builder.getInt32(0));\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo() {\nentry:\n  ret i32 0\n}\n```", "```cpp\n static std::vector <std::string> FunArgs;\n FunArgs.push_back(\"a\");\n FunArgs.push_back(\"b\");\n\n```", "```cpp\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n std::vector<Type *> Integers(FunArgs.size(), Type::getInt32Ty(Context));\n  FunctionType *funcType =\n      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n```", "```cpp\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n unsigned Idx = 0;\n Function::arg_iterator AI, AE;\n for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n ++AI, ++Idx)\n AI->setName(FunArgs[Idx]);\n}\n\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n std::vector<Type *> Integers(FunArgs.size(), Type::getInt32Ty(Context));\n  FunctionType *funcType =\n      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n unsigned Idx = 0;\n Function::arg_iterator AI, AE;\n for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n ++AI, ++Idx)\n AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n  ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n  GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n  gVar->setLinkage(GlobalValue::CommonLinkage);\n  gVar->setAlignment(4);\n  return gVar;\n}\n\nint main(int argc, char *argv[]) {\n FunArgs.push_back(\"a\");\n FunArgs.push_back(\"b\");\n  static IRBuilder<> Builder(Context);\n  GlobalVariable *gVar = createGlob(Builder, \"x\");\n  Function *fooFunc = createFunc(Builder, \"foo\");\n setFuncArgs(fooFunc, FunArgs);\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  Builder.CreateRet(Builder.getInt32(0));\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo(i32 %a, i32 %b) {\nentry:\n ret i32 0\n}\n\n```", "```cpp\nValue *constant = Builder.getInt32(16);\n\n```", "```cpp\nValue *Arg1 = fooFunc->arg_begin();\n\n```", "```cpp\nValue *createArith(IRBuilder<> &Builder, Value *L, Value *R) {\n  return Builder.CreateMul(L, R, \"multmp\");\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  std::vector<Type *> Integers(FunArgs.size(), Type::getInt32Ty(Context));\n  FunctionType *funcType =\n      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n  ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n  GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n  gVar->setLinkage(GlobalValue::CommonLinkage);\n  gVar->setAlignment(4);\n  return gVar;\n}\n\nValue *createArith(IRBuilder<> &Builder, Value *L, Value *R) {\n return Builder.CreateMul(L, R, \"multmp\");\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  FunArgs.push_back(\"b\");\n  static IRBuilder<> Builder(Context);\n  GlobalVariable *gVar = createGlob(Builder, \"x\");\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n Value *Arg1 = fooFunc->arg_begin();\n Value *constant = Builder.getInt32(16);\n Value *val = createArith(Builder, Arg1, constant);\n  Builder.CreateRet(val);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags  --system-libs --libs core` -o toy\n\n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo(i32 %a, i32 %b) {\nentry:\n  %multmp = mul i32 %a, 16\n  ret i32 %multmp\n}\n```", "```cpp\n Value *val2 = Builder.getInt32(100);\n Value *Compare = Builder.CreateICmpULT(val, val2, \"cmptmp\"); \n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo(i32 %a, i32 %b) {\nentry:\n  %multmp = mul i32 %a, 16\n  %cmptmp = icmp ult i32 %multmp, 100\n\n  ret i32 %multmp\n}\n```", "```cpp\ntypedef SmallVector<BasicBlock *, 16> BBList;\ntypedef SmallVector<Value *, 16> ValList;\n```", "```cpp\n Value *Condtn = Builder.CreateICmpNE(Compare, Builder.getInt32(0),\n \"ifcond\");\n ValList VL;\n VL.push_back(Condtn);\n VL.push_back(Arg1);\n```", "```cpp\n  BasicBlock *ThenBB = createBB(fooFunc, \"then\");\n  BasicBlock *ElseBB = createBB(fooFunc, \"else\");\n  BasicBlock *MergeBB = createBB(fooFunc, \"ifcont\");\n  BBList List;\n  List.push_back(ThenBB);\n  List.push_back(ElseBB);\n  List.push_back(MergeBB);\n```", "```cpp\nValue *createIfElse(IRBuilder<> &Builder, BBList List, ValList VL) {\n  Value *Condtn = VL[0];\n  Value *Arg1 = VL[1];\n  BasicBlock *ThenBB = List[0];\n  BasicBlock *ElseBB = List[1];\n  BasicBlock *MergeBB = List[2];\n  Builder.CreateCondBr(Condtn, ThenBB, ElseBB);\n\n  Builder.SetInsertPoint(ThenBB);\n  Value *ThenVal = Builder.CreateAdd(Arg1, Builder.getInt32(1), \"thenaddtmp\");\n  Builder.CreateBr(MergeBB);\n\n  Builder.SetInsertPoint(ElseBB);\n  Value *ElseVal = Builder.CreateAdd(Arg1, Builder.getInt32(2), \"elseaddtmp\");\n  Builder.CreateBr(MergeBB);\n\n  unsigned PhiBBSize = List.size() - 1;\n  Builder.SetInsertPoint(MergeBB);\n  PHINode *Phi = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), PhiBBSize, \"iftmp\");\n  Phi->addIncoming(ThenVal, ThenBB);\n  Phi->addIncoming(ElseVal, ElseBB);\n\n  return Phi;\n}\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\ntypedef SmallVector<BasicBlock *, 16> BBList;\ntypedef SmallVector<Value *, 16> ValList;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  std::vector<Type *> Integers(FunArgs.size(), Type::getInt32Ty(Context));\n  FunctionType *funcType =\n      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n  ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n  GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n  gVar->setLinkage(GlobalValue::CommonLinkage);\n  gVar->setAlignment(4);\n  return gVar;\n}\n\nValue *createArith(IRBuilder<> &Builder, Value *L, Value *R) {\n  return Builder.CreateMul(L, R, \"multmp\");\n}\n\nValue *createIfElse(IRBuilder<> &Builder, BBList List, ValList VL) {\n Value *Condtn = VL[0];\n Value *Arg1 = VL[1];\n BasicBlock *ThenBB = List[0];\n BasicBlock *ElseBB = List[1];\n BasicBlock *MergeBB = List[2];\n Builder.CreateCondBr(Condtn, ThenBB, ElseBB);\n\n Builder.SetInsertPoint(ThenBB);\n Value *ThenVal = Builder.CreateAdd(Arg1, Builder.getInt32(1), \"thenaddtmp\");\n Builder.CreateBr(MergeBB);\n\n Builder.SetInsertPoint(ElseBB);\n Value *ElseVal = Builder.CreateAdd(Arg1, Builder.getInt32(2), \"elseaddtmp\");\n Builder.CreateBr(MergeBB);\n\n unsigned PhiBBSize = List.size() - 1;\n Builder.SetInsertPoint(MergeBB);\n PHINode *Phi = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), PhiBBSize, \"iftmp\");\n PhiBBSize, \"iftmp\");\n Phi->addIncoming(ThenVal, ThenBB);\n Phi->addIncoming(ElseVal, ElseBB);\n\n return Phi;\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  FunArgs.push_back(\"b\");\n  static IRBuilder<> Builder(Context);\n  GlobalVariable *gVar = createGlob(Builder, \"x\");\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n  Value *Arg1 = fooFunc->arg_begin();\n  Value *constant = Builder.getInt32(16);\n  Value *val = createArith(Builder, Arg1, constant);\n\n Value *val2 = Builder.getInt32(100);\n Value *Compare = Builder.CreateICmpULT(val, val2, \"cmptmp\");\n Value *Condtn = Builder.CreateICmpNE(Compare, Builder.getInt32(0), \"ifcond\");\n\n ValList VL;\n VL.push_back(Condtn);\n VL.push_back(Arg1);\n\n BasicBlock *ThenBB = createBB(fooFunc, \"then\");\n BasicBlock *ElseBB = createBB(fooFunc, \"else\");\n BasicBlock *MergeBB = createBB(fooFunc, \"ifcont\");\n BBList List;\n List.push_back(ThenBB);\n List.push_back(ElseBB);\n List.push_back(MergeBB);\n\n Value *v = createIfElse(Builder, List, VL);\n\n  Builder.CreateRet(v);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo(i32 %a, i32 %b) {\nentry:\n  %multmp = mul i32 %a, 16\n  %cmptmp = icmp ult i32 %multmp, 100\n  %ifcond = icmp ne i1 %cmptmp, i32 0\n  br i1 %ifcond, label %then, label %else\n\nthen:                                             ; preds = %entry\n  %thenaddtmp = add i32 %a, 1\n  br label %ifcont\n\nelse:                                             ; preds = %entry\n  %elseaddtmp = add i32 %a, 2\n  br label %ifcont\n\nifcont:                                           ; preds = %else, %then\n  %iftmp = phi i32 [ %thenaddtmp, %then ], [ %elseaddtmp, %else ]\n  ret i32 %iftmp\n}\n```", "```cpp\nfor(i=1; i< b; i++)  {body}\n```", "```cpp\nFunction::arg_iterator AI = fooFunc->arg_begin();\n  Value *Arg1 = AI++;\n  Value *Arg2 = AI;\n  Value *constant = Builder.getInt32(16);\n  Value *val = createArith(Builder, Arg1, constant);\n  ValList VL;\n  VL.push_back(Arg1);\n\n  BBList List;\n  BasicBlock *LoopBB = createBB(fooFunc, \"loop\");\n  BasicBlock *AfterBB = createBB(fooFunc, \"afterloop\");\n  List.push_back(LoopBB);\n  List.push_back(AfterBB);\n\n  Value *StartVal = Builder.getInt32(1);\n```", "```cpp\nPHINode *createLoop(IRBuilder<> &Builder, BBList List, ValList VL,\n                    Value *StartVal, Value *EndVal) {\n  BasicBlock *PreheaderBB = Builder.GetInsertBlock();\n  Value *val = VL[0];\n  BasicBlock *LoopBB = List[0];\n  Builder.CreateBr(LoopBB);\n  Builder.SetInsertPoint(LoopBB);\n  PHINode *IndVar = Builder.CreatePHI(Type::getInt32Ty(Context), 2, \"i\");\n  IndVar->addIncoming(StartVal, PreheaderBB);\n  Builder.CreateAdd(val, Builder.getInt32(5), \"addtmp\");\n  Value *StepVal = Builder.getInt32(1);\n  Value *NextVal = Builder.CreateAdd(IndVar, StepVal, \"nextval\");\n  Value *EndCond = Builder.CreateICmpULT(IndVar, EndVal, \"endcond\");\n  EndCond = Builder.CreateICmpNE(EndCond, Builder.getInt32(0), \"loopcond\");\n  BasicBlock *LoopEndBB = Builder.GetInsertBlock();\n  BasicBlock *AfterBB = List[1];\n  Builder.CreateCondBr(EndCond, LoopBB, AfterBB);\n  Builder.SetInsertPoint(AfterBB);\n  IndVar->addIncoming(NextVal, LoopEndBB);\n  return IndVar;\n}\n```", "```cpp\nIndVar->addIncoming(StartVal, PreheaderBB);…\nIndVar->addIncoming(NextVal, LoopEndBB);\n```", "```cpp\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Verifier.h\"\n#include <vector>\nusing namespace llvm;\n\ntypedef SmallVector<BasicBlock *, 16> BBList;\ntypedef SmallVector<Value *, 16> ValList;\n\nstatic LLVMContext &Context = getGlobalContext();\nstatic Module *ModuleOb = new Module(\"my compiler\", Context);\nstatic std::vector<std::string> FunArgs;\n\nFunction *createFunc(IRBuilder<> &Builder, std::string Name) {\n  std::vector<Type *> Integers(FunArgs.size(), Type::getInt32Ty(Context));\n  FunctionType *funcType =\n      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);\n  Function *fooFunc = llvm::Function::Create(\n      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);\n  return fooFunc;\n}\n\nvoid setFuncArgs(Function *fooFunc, std::vector<std::string> FunArgs) {\n\n  unsigned Idx = 0;\n  Function::arg_iterator AI, AE;\n  for (AI = fooFunc->arg_begin(), AE = fooFunc->arg_end(); AI != AE;\n       ++AI, ++Idx)\n    AI->setName(FunArgs[Idx]);\n}\n\nBasicBlock *createBB(Function *fooFunc, std::string Name) {\n  return BasicBlock::Create(Context, Name, fooFunc);\n}\n\nGlobalVariable *createGlob(IRBuilder<> &Builder, std::string Name) {\n  ModuleOb->getOrInsertGlobal(Name, Builder.getInt32Ty());\n  GlobalVariable *gVar = ModuleOb->getNamedGlobal(Name);\n  gVar->setLinkage(GlobalValue::CommonLinkage);\n  gVar->setAlignment(4);\n  return gVar;\n}\n\nValue *createArith(IRBuilder<> &Builder, Value *L, Value *R) {\n  return Builder.CreateMul(L, R, \"multmp\");\n}\n\nValue *createLoop(IRBuilder<> &Builder, BBList List, ValList VL,\n Value *StartVal, Value *EndVal) {\n BasicBlock *PreheaderBB = Builder.GetInsertBlock();\n Value *val = VL[0];\n BasicBlock *LoopBB = List[0];\n Builder.CreateBr(LoopBB);\n Builder.SetInsertPoint(LoopBB);\n PHINode *IndVar = Builder.CreatePHI(Type::getInt32Ty(Context), 2, \"i\");\n IndVar->addIncoming(StartVal, PreheaderBB);\n Value *Add = Builder.CreateAdd(val, Builder.getInt32(5), \"addtmp\");\n Value *StepVal = Builder.getInt32(1);\n Value *NextVal = Builder.CreateAdd(IndVar, StepVal, \"nextval\");\n Value *EndCond = Builder.CreateICmpULT(IndVar, EndVal, \"endcond\");\n EndCond = Builder.CreateICmpNE(EndCond, Builder.getInt32(0), \"loopcond\");\n BasicBlock *LoopEndBB = Builder.GetInsertBlock();\n BasicBlock *AfterBB = List[1];\n Builder.CreateCondBr(EndCond, LoopBB, AfterBB);\n Builder.SetInsertPoint(AfterBB);\n IndVar->addIncoming(NextVal, LoopEndBB);\n return Add;\n}\n\nint main(int argc, char *argv[]) {\n  FunArgs.push_back(\"a\");\n  FunArgs.push_back(\"b\");\n  static IRBuilder<> Builder(Context);\n  GlobalVariable *gVar = createGlob(Builder, \"x\");\n  Function *fooFunc = createFunc(Builder, \"foo\");\n  setFuncArgs(fooFunc, FunArgs);\n  BasicBlock *entry = createBB(fooFunc, \"entry\");\n  Builder.SetInsertPoint(entry);\n Function::arg_iterator AI = fooFunc->arg_begin();\n Value *Arg1 = AI++;\n Value *Arg2 = AI;\n Value *constant = Builder.getInt32(16);\n Value *val = createArith(Builder, Arg1, constant);\n ValList VL;\n VL.push_back(Arg1);\n\n BBList List;\n BasicBlock *LoopBB = createBB(fooFunc, \"loop\");\n BasicBlock *AfterBB = createBB(fooFunc, \"afterloop\");\n List.push_back(LoopBB);\n List.push_back(AfterBB);\n\n Value *StartVal = Builder.getInt32(1);\n Value *Res = createLoop(Builder, List, VL, StartVal, Arg2);\n\n  Builder.CreateRet(Res);\n  verifyFunction(*fooFunc);\n  ModuleOb->dump();\n  return 0;\n}\n```", "```cpp\n; ModuleID = 'my compiler'\n\n@x = common global i32, align 4\n\ndefine i32 @foo(i32 %a, i32 %b) {\nentry:\n  %multmp = mul i32 %a, 16\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %i = phi i32 [ 1, %entry ], [ %nextval, %loop ]\n  %addtmp = add i32 %a, 5\n  %nextval = add i32 %i, 1\n  %endcond = icmp ult i32 %i, %b\n  %loopcond = icmp ne i1 %endcond, i32 0\n  br i1 %loopcond, label %loop, label %afterloop\n\nafterloop:                                        ; preds = %loop\n  ret i32 %addtmp\n}\n```"]