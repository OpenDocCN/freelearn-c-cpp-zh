<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with SDL"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with SDL</h1></div></div></div><p>
<span class="strong"><strong>Simple DirectMedia Layer</strong></span> (<span class="strong"><strong>SDL</strong></span>) is a cross-platform multimedia library<a class="indexterm" id="id0"/> created by Sam Oscar Latinga. It provides low-level access to input (via mouse, keyboard, and gamepads/joysticks), 3D hardware, and the 2D video frame buffer. SDL is written in the C programming language, yet has native support for C++. The library also has bindings for several other languages such as Pascal, Objective-C, Python, Ruby, and Java; a full list of supported languages is available at <a class="ulink" href="http://www.libsdl.org/languages.php">http://www.libsdl.org/languages.php</a>.</p><p>SDL has been used in many commercial games including World of Goo, Neverwinter Nights, and Second Life. It is also used in emulators such as ZSNES, Mupen64, and VisualBoyAdvance. Some popular games ported to Linux platforms such as Quake 4, Soldier of Fortune, and Civilization: Call to Power utilize SDL in some form.</p><p>SDL is not just used for games. It is useful for all manner of applications. If your software needs access to graphics and input, chances are that SDL will be a great help. The SDL official website has a list of applications that have been created using the library (<a class="ulink" href="http://www.libsdl.org/applications.php">http://www.libsdl.org/applications.php</a>).</p><p>In this chapter we will cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting the latest SDL build from the Mercurial repository</li><li class="listitem" style="list-style-type: disc">Building and setting up SDL in Visual C++ 2010 Express</li><li class="listitem" style="list-style-type: disc">Creating a window with SDL</li><li class="listitem" style="list-style-type: disc">Implementing a basic game class</li></ul></div><div class="section" title="Why use SDL?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Why use SDL?</h1></div></div></div><p>Each platform has its own way of creating and displaying windows and graphics, handling user input, and <a class="indexterm" id="id1"/>accessing any low-level hardware; each one with its own intricacies and syntax. SDL provides a uniform way of accessing these platform-specific features. This uniformity leads to more time spent tweaking your game rather than worrying about how a specific platform allows you to render or get user input, and so on. Game programming can be quite difficult, and having a library such as SDL can get your game up and running relatively quickly.</p><p>The ability to write a game on <a class="indexterm" id="id2"/>Windows and then go on to compile it on OSX or Linux with little to no changes in the code is extremely powerful and perfect for developers who want to target as many platforms as possible; SDL makes this kind of cross-platform development a breeze. While SDL is extremely effective for cross-platform development, it is also an excellent choice for creating a game with just one platform in mind, due to its ease of use and abundance of features.</p><p>SDL has a large user base and is being actively updated and maintained. There is also a responsive community along with a helpful mailing list. Documentation for SDL 2.0 is up-to-date and constantly maintained. Visiting the SDL website, <a class="ulink" href="http://libsdl.org">libsdl.org</a>, offers up lots of articles and information with links to the documentation, mailing list, and forums.</p><p>Overall, SDL offers a great place to start with game development, allowing you to focus on the game itself and ignore which platform you are developing for, until it is completely necessary. Now, with SDL 2.0 and the new features it brings to the table, SDL has become an even more capable library for game development using C++.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The best way to find out what you can do with SDL and its various functions is to use the documentation found at <a class="ulink" href="http://wiki.libsdl.org/moin.cgi/CategoryAPI">http://wiki.libsdl.org/moin.cgi/CategoryAPI</a>. There you can see a list of all of SDL 2.0's functions along with various code examples.</p></div></div><div class="section" title="What is new in SDL 2.0?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>What is new in SDL 2.0?</h2></div></div></div><p>The latest version of SDL and SDL 2.0, which we will be covering in this book, is still in development. It adds many new<a class="indexterm" id="id3"/> features to the existing SDL 1.2 framework. The <a class="indexterm" id="id4"/>SDL 2.0 Roadmap (<a class="ulink" href="http://wiki.libsdl.org/moin.cgi/Roadmap">wiki.libsdl.org/moin.cgi/Roadmap</a>) lists these features as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A 3D accelerated, texture-based rendering API</li><li class="listitem" style="list-style-type: disc">Hardware-accelerated 2D graphics</li><li class="listitem" style="list-style-type: disc">Support for render targets</li><li class="listitem" style="list-style-type: disc">Multiple window support</li><li class="listitem" style="list-style-type: disc">API support for clipboard access</li><li class="listitem" style="list-style-type: disc">Multiple input device support</li><li class="listitem" style="list-style-type: disc">Support for 7.1 audio</li><li class="listitem" style="list-style-type: disc">Multiple audio device support</li><li class="listitem" style="list-style-type: disc">Force-feedback API for joysticks</li><li class="listitem" style="list-style-type: disc">Horizontal mouse wheel support</li><li class="listitem" style="list-style-type: disc">Multitouch input API support</li><li class="listitem" style="list-style-type: disc">Audio capture support</li><li class="listitem" style="list-style-type: disc">Improvements to multithreading</li></ul></div><p>While not all of these will be <a class="indexterm" id="id5"/>used in our game-programming adventures, some of them are invaluable and make SDL an even better framework to use to develop games. We will be taking advantage of the new hardware-accelerated 2D graphics to make sure our games have excellent performance.</p></div><div class="section" title="Migrating SDL 1.2 extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Migrating SDL 1.2 extensions</h2></div></div></div><p>SDL has separate extensions that can be used to add new capabilities to the library. The reason these<a class="indexterm" id="id6"/> extensions are not included in the first place is to keep SDL as lightweight as possible, with the extensions serving to add functionality only when <a class="indexterm" id="id7"/>necessary. The next table shows some useful extensions along with their purpose. These extensions have been updated from their SDL1.2/3 Versions to support SDL 2.0, <a class="indexterm" id="id8"/>and this book will cover cloning and building them from their respective repositories as and when they are needed.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_image</code>
<a class="indexterm" id="id9"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is an image file loading library with support for BMP, GIF, PNG, TGA, PCX, and among others.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_net</code>
<a class="indexterm" id="id10"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a cross-platform networking library.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_mixer</code>
<a class="indexterm" id="id11"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is an audio mixer library. It has support for MP3, MIDI, <a class="indexterm" id="id12"/>and OGG.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_ttf</code>
<a class="indexterm" id="id13"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a library supporting the use of <code class="literal">TrueType</code> fonts in SDL applications.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_rtf</code>
<a class="indexterm" id="id14"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a library to support the rendering of the <span class="strong"><strong>Rich Text Format</strong></span> (<span class="strong"><strong>RTF</strong></span>).</p>
</td></tr></tbody></table></div></div></div></div>
<div class="section" title="Setting up SDL in Visual C++ Express 2010"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up SDL in Visual C++ Express 2010</h1></div></div></div><p>This book will cover setting up SDL 2.0 in Microsoft's Visual C++ Express 2010 IDE. This IDE was chosen as it is <a class="indexterm" id="id15"/>available for free online, and is a widely used development environment within the games industry. The application is available at <a class="ulink" href="https://www.microsoft.com/visualstudio/en-gb/express">https://www.microsoft.com/visualstudio/en-gb/express</a>. Once the IDE has been installed we can go ahead and download SDL 2.0. If you are not using Windows to develop games, then these instructions can be altered to suit your IDE of choice<a class="indexterm" id="id16"/> using its specific steps to link libraries and include files.</p><p>SDL 2.0 is still in <a class="indexterm" id="id17"/>development so there are no official releases as yet. The library can be retrieved in two different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One is to download the under-construction snapshot; you can then link against this to build your games (the quickest option)</li><li class="listitem" style="list-style-type: disc">The second option is to clone the latest source using mercurial-distributed source control and build it from scratch (a good option to keep up with the latest developments of the library)</li></ul></div><p>Both of these options are available at <a class="ulink" href="http://www.libsdl.org/hg.php">http://www.libsdl.org/hg.php</a>.</p><p>Building SDL 2.0 on Windows also requires the latest DirectX SDK, which is available at <a class="ulink" href="http://www.microsoft.com/en-gb/download/details.aspx?id=6812">http://www.microsoft.com/en-gb/download/details.aspx?id=6812</a>, so make sure this is installed first.</p><div class="section" title="Using Mercurial to get SDL 2.0 on Windows"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Using Mercurial to get SDL 2.0 on Windows</h2></div></div></div><p>Getting SDL 2.0 directly from the constantly updated repository is the best way of making sure you have the latest build of SDL 2.0 and that you are taking advantage of any current bug fixes. To download<a class="indexterm" id="id18"/> and build the latest version of SDL 2.0 on Windows, we must first install a mercurial source control client so that we can mirror the latest source code and build from it. There are various command-line tools and GUIs available for use with mercurial. We will use TortoiseHg, a free and user-friendly mercurial application; it is available at <a class="ulink" href="http://tortoisehg.bitbucket.org">tortoisehg.bitbucket.org</a>. Once the application is installed, we can go ahead and grab the latest build.</p><div class="section" title="Cloning and building the latest SDL 2.0 repository"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Cloning and building the latest SDL 2.0 repository</h3></div></div></div><p>Cloning and building the<a class="indexterm" id="id19"/> latest<a class="indexterm" id="id20"/> version of SDL directly from the repository is relatively straightforward when following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up the <a class="indexterm" id="id21"/><span class="strong"><strong>TortoiseHg Workbench</strong></span> window.<div class="mediaobject"><img alt="Cloning and building the latest SDL 2.0 repository" src="graphics/6821OT_01_01.jpg"/></div></li><li class="listitem">Pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>N</em></span> will open the clone dialog box.</li><li class="listitem">Input the source of the repository; in this case it is listed on the SDL 2.0 website as <a class="ulink" href="http://hg.libsdl.org/SDL">http://hg.libsdl.org/SDL</a>.</li><li class="listitem">Input or browse to choose a destination for the cloned repository—this book will assume that <code class="literal">C:\SDL2</code> is set as the location.</li><li class="listitem">Click on <span class="strong"><strong>Clone</strong></span> and allow the repository to copy to the chosen destination.<div class="mediaobject"><img alt="Cloning and building the latest SDL 2.0 repository" src="graphics/6821OT_01_02.jpg"/></div></li><li class="listitem">Within the <code class="literal">C:\SDL2</code> directory there will be a <code class="literal">VisualC</code> folder; inside the folder there is a Visual<a class="indexterm" id="id22"/> C++ 2010 solution, which we have to open with Visual C++ Express 2010.</li><li class="listitem">Visual C++ Express will throw up a few errors about solution folders not being supported in the express version, but they can be safely ignored without affecting our ability to build the library.</li><li class="listitem">Change the current build configuration to release and also choose 32 or 64 bit depending on your operating system.<div class="mediaobject"><img alt="Cloning and building the latest SDL 2.0 repository" src="graphics/6821OT_01_03.jpg"/></div></li><li class="listitem">Right-click on <a class="indexterm" id="id23"/>the project named <span class="strong"><strong>SDL</strong></span> listed in the <span class="strong"><strong>Solution Explorer</strong></span> list and choose <span class="strong"><strong>Build</strong></span>.</li><li class="listitem">We now have a build<a class="indexterm" id="id24"/> of the SDL 2.0 library to use. It will be located at <code class="literal">C:\SDL2\VisualC\SDL\Win32(or x64)\Release\SDL.lib</code>.</li><li class="listitem">We also need to build the SDL main library file, so choose it within the <span class="strong"><strong>Solution Explorer</strong></span> list and build it. This file will build to <code class="literal">C:\SDL2\VisualC\SDLmain\Win32(or x64)\Release\SDLmain.lib</code>.</li><li class="listitem">Create a folder named <code class="literal">lib</code> in <code class="literal">C:\SDL2</code> and copy <code class="literal">SDL.lib</code> and <code class="literal">SDLmain.lib</code> into this newly created folder.</li></ol></div></div></div><div class="section" title="I have the library; now what?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>I have the library; now what?</h2></div></div></div><p>Now a Visual C++ 2010 project can be created <a class="indexterm" id="id25"/>and linked with the SDL library. Here are the steps involved:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new empty project in Visual C++ express and give it a name, such as <code class="literal">SDL-game</code>.</li><li class="listitem">Once created, right-click on the project in the <span class="strong"><strong>Solution Explorer</strong></span> list and choose <span class="strong"><strong>Properties</strong></span>.</li><li class="listitem">Change the configuration drop-down list to <span class="strong"><strong>All Configurations</strong></span>.</li><li class="listitem">Under <span class="strong"><strong>VC++ Directories</strong></span>, click on <span class="strong"><strong>Include Directories</strong></span>. A small arrow will allow a drop-down menu; click on <span class="strong"><strong>&lt;Edit…&gt;</strong></span>.<div class="mediaobject"><img alt="I have the library; now what?" src="graphics/6821OT_01_04.jpg"/></div></li><li class="listitem">Double-click inside the box to create a new location. You can type or browse to <code class="literal">C:\SDL2.0\include</code> and click on <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">Next, do the same<a class="indexterm" id="id26"/> thing under library directories, this time passing in your created <code class="literal">lib</code> folder (<code class="literal">C:\SDL2\lib</code>).</li><li class="listitem">Next, navigate to the <span class="strong"><strong>Linker</strong></span> heading; inside the heading there will be an <span class="strong"><strong>Input</strong></span> choice. Inside <span class="strong"><strong>Additional Dependencies</strong></span> type <code class="literal">SDL.lib SDLmain.lib</code>:<div class="mediaobject"><img alt="I have the library; now what?" src="graphics/6821OT_01_05.jpg"/></div></li><li class="listitem">Navigate to the <span class="strong"><strong>System</strong></span> heading and set the <span class="strong"><strong>SubSystem</strong></span> heading to <span class="strong"><strong>Windows(/SUBSYSTEM:WINDOWS)</strong></span>.<div class="mediaobject"><img alt="I have the library; now what?" src="graphics/6821OT_01_06.jpg"/></div></li><li class="listitem">Click on <span class="strong"><strong>OK</strong></span><a class="indexterm" id="id27"/> and we are done.</li></ol></div></div></div>
<div class="section" title="Hello SDL"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Hello SDL</h1></div></div></div><p>We now have an empty project, which links to the SDL library, so it is time to start our SDL development. Click on <span class="strong"><strong>Source Files</strong></span>
<a class="indexterm" id="id28"/> and use the keyboard shortcut <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>A</em></span> to add a new item. Create a C++ file called <code class="literal">main.cpp</code>. After creating this file, copy the following code into the source file:</p><div class="informalexample"><pre class="programlisting">#include&lt;SDL.h&gt;

SDL_Window* g_pWindow = 0;
SDL_Renderer* g_pRenderer = 0;

int main(int argc, char* args[])
{
  // initialize SDL
  if(SDL_Init(SDL_INIT_EVERYTHING) &gt;= 0)
  {
    // if succeeded create our window
    g_pWindow = SDL_CreateWindow("Chapter 1: Setting up SDL", 
    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
    640, 480, 
    SDL_WINDOW_SHOWN);

    // if the window creation succeeded create our renderer
    if(g_pWindow != 0)
    {
      g_pRenderer = SDL_CreateRenderer(g_pWindow, -1, 0);
    }
  }
  else
  {
    return 1; // sdl could not initialize
  }

  // everything succeeded lets draw the window

  // set to black // This function expects Red, Green, Blue and 
  //  Alpha as color values
  SDL_SetRenderDrawColor(g_pRenderer, 0, 0, 0, 255);

  // clear the window to black
  SDL_RenderClear(g_pRenderer);

  // show the window
  SDL_RenderPresent(g_pRenderer);

  // set a delay before quitting
  SDL_Delay(5000);

  // clean up SDL
  SDL_Quit();

  return 0;
}</pre></div><p>We can now attempt to build our first SDL application. Right-click on the project and choose <span class="strong"><strong>Build</strong></span>. There will be an <a class="indexterm" id="id29"/>error about the <code class="literal">SDL.dll</code> file not being found:</p><div class="mediaobject"><img alt="Hello SDL" src="graphics/6821OT_01_07.jpg"/></div><p>The attempted build should have created a <code class="literal">Debug</code> or <code class="literal">Release</code> folder within the project directory (usually located in your <code class="literal">Documents</code> folder under visual studio and projects). This folder contains the <code class="literal">.exe</code> file from our attempted build; we need to add the <code class="literal">SDL.dll</code> file to this folder. The <code class="literal">SDL.dll</code> file is located at <code class="literal">C:\SDL2\VisualC\SDL\Win32</code> (or <code class="literal">x64)\Release\SDL.dll l</code>). When you want to distribute your game to another computer, you will have to share this file as well as the executable. After you have added the <code class="literal">SDL.dll</code> file to the executable folder, the project will now compile and show an SDL window; wait for 5 seconds and then close.</p><div class="section" title="An overview of Hello SDL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>An overview of Hello SDL</h2></div></div></div><p>Let's go through<a class="indexterm" id="id30"/> the <code class="literal">Hello SDL</code> code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we included the <code class="literal">SDL.h</code> header file so that we have access to all of SDL's functions:<div class="informalexample"><pre class="programlisting">#include&lt;SDL.h&gt;</pre></div></li><li class="listitem">The next step is to create some global variables. One is a pointer to an <code class="literal">SDL_Window</code> function, <a class="indexterm" id="id31"/>which will be set using the <code class="literal">SDL_CreateWindow</code> function. The second is a pointer to an <code class="literal">SDL_Renderer</code> object; set using the <code class="literal">SDL_CreateRenderer</code> function:<div class="informalexample"><pre class="programlisting">SDL_Window* g_pWindow = 0;
SDL_Renderer* g_pRenderer = 0;</pre></div></li><li class="listitem">We can now initialize SDL. This example initializes all of SDL's subsystems using the <code class="literal">SDL_INIT_EVERYTHING</code> flag, but this does not always have to be the case (see SDL initialization flags):<div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
  // initialize SDL
  if(SDL_Init(SDL_INIT_EVERYTHING) &gt;= 0)
   {</pre></div></li><li class="listitem">If the SDL initialization<a class="indexterm" id="id32"/> was successful, we can create the pointer to our window. <code class="literal">SDL_CreateWindow</code> returns a pointer to a window matching the passed parameters. The parameters are the window title, <span class="emphasis"><em>x</em></span> position of the window, <span class="emphasis"><em>y</em></span> position of the window, width, height, and any required <code class="literal">SDL_flags</code> (we will cover these later in the chapter). <code class="literal">SDL_WINDOWPOS_CENTERED</code> will center our window relative to the screen:<div class="informalexample"><pre class="programlisting">// if succeeded create our window
g_pWindow = SDL_CreateWindow("Chapter 1: Setting up SDL", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN);</pre></div></li><li class="listitem">We can now check whether the window creation was successful, and if so, move on to set the pointer to our renderer, passing the window we want the renderer to use as a parameter; in our case, it is the newly created <code class="literal">g_pWindow</code> pointer. The second parameter passed is the index of the rendering driver to initialize; in this case, we use <code class="literal">-1</code> to use the first capable driver. The final parameter is <code class="literal">SDL_RendererFlag</code> (see SDL renderer flags):<div class="informalexample"><pre class="programlisting">// if the window creation succeeded create our renderer
if(g_pWindow != 0)
{
  g_pRenderer = SDL_CreateRenderer(g_pWindow, -1, 0);
}
else
{
  return 1; // sdl could not initialize
}</pre></div></li><li class="listitem">If everything was successful, we can now create and show our window:<div class="informalexample"><pre class="programlisting">// everything succeeded lets draw the window

  // set to black
SDL_SetRenderDrawColor(g_pRenderer, 0, 0, 0, 255);

   // clear the window to black
SDL_RenderClear(g_pRenderer);

   // show the window
SDL_RenderPresent(g_pRenderer);

   // set a delay before quitting
SDL_Delay(5000);

   // clean up SDL
SDL_Quit();</pre></div></li></ol></div></div><div class="section" title="SDL initialization flags"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>SDL initialization flags</h2></div></div></div><p>Event handling, file I/O, and threading <a class="indexterm" id="id33"/>subsystems are all initialized <a class="indexterm" id="id34"/>by default in SDL. Other subsystems can be initialized using the following flags:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flag</p>
</th><th style="text-align: left" valign="bottom">
<p>Initialized subsystem(s)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_HAPTIC</code>
<a class="indexterm" id="id35"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Force feedback subsystem<a class="indexterm" id="id36"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_AUDIO</code>
<a class="indexterm" id="id37"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Audio subsystem<a class="indexterm" id="id38"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_VIDEO</code>
<a class="indexterm" id="id39"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Video subsystem<a class="indexterm" id="id40"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_TIMER</code>
<a class="indexterm" id="id41"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Timer subsystem<a class="indexterm" id="id42"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_JOYSTICK</code>
<a class="indexterm" id="id43"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Joystick subsystem<a class="indexterm" id="id44"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_EVERYTHING</code>
<a class="indexterm" id="id45"/>
</p>
</td><td style="text-align: left" valign="top">
<p>All subsystems<a class="indexterm" id="id46"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_INIT_NOPARACHUTE</code>
<a class="indexterm" id="id47"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Don't catch fatal signals<a class="indexterm" id="id48"/>
</p>
</td></tr></tbody></table></div><p>We can also use bitwise (<code class="literal">|</code>) to initialize more than one subsystem. To initialize only the audio and video subsystems, we can use a call to <code class="literal">SDL_Init</code>, for example:</p><div class="informalexample"><pre class="programlisting">SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO);</pre></div><p>Checking whether a subsystem has been initialized or not can be done with a call to<a class="indexterm" id="id49"/> the <code class="literal">SDL_WasInit()</code> function:</p><div class="informalexample"><pre class="programlisting">if(SDL_WasInit(SDL_INIT_VIDEO) != 0)
{
  cout &lt;&lt; "video was initialized";
}</pre></div></div><div class="section" title="SDL renderer flags"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>SDL renderer flags</h2></div></div></div><p>When initializing an <code class="literal">SDL_Renderer</code> flag, <a class="indexterm" id="id50"/>we can pass in a flag to determine its behavior. The following table describes each flag's purpose:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flag</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_RENDERER_SOFTWARE</code>
<a class="indexterm" id="id51"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Use software rendering<a class="indexterm" id="id52"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_RENDERER_ACCELERATED</code>
<a class="indexterm" id="id53"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Use hardware acceleration<a class="indexterm" id="id54"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_RENDERER_PRESENTVSYNC</code>
<a class="indexterm" id="id55"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Synchronize renderer update with screen's refresh rate<a class="indexterm" id="id56"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_RENDERER_TARGETTEXTURE</code>
<a class="indexterm" id="id57"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Supports render to texture<a class="indexterm" id="id58"/>
</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="What makes up a game"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>What makes up a game</h1></div></div></div><p>Outside the design and gameplay of a game, the underlying mechanics are essentially the interaction of various subsystems <a class="indexterm" id="id59"/>such as graphics, game logic, and user input. The graphics subsystem should not know how the game logic is implemented or vice versa. We can think of the structure of a game as follows:</p><div class="mediaobject"><img alt="What makes up a game" src="graphics/6821OT_01_08.jpg"/></div><p>Once the game is initialized, it then goes into a loop of checking for user input, updating any values based on the <a class="indexterm" id="id60"/>game physics, before rendering to the screen. Once the user chooses to exit, the loop is broken and the game moves onto cleaning everything up and exiting. This is the basic scaffold for a game and it is what will be used in this book.</p><p>We will be building a reusable framework that will take all of the legwork out of creating a game in SDL 2.0. When it comes to boilerplate code and setup code, we really only want to write it once and then reuse it within new projects. The same can be done with drawing code, event handling, map loading, game states, and anything else that all games may require. We will start by breaking up the Hello SDL 2.0 example into separate parts. This will help us to start thinking about how code can be broken into reusable standalone chunks rather than <a class="indexterm" id="id61"/>packing everything into one large file.</p><div class="section" title="Breaking up the Hello SDL code"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Breaking up the Hello SDL code</h2></div></div></div><p>We can break up the Hello <a class="indexterm" id="id62"/>SDL into separate functions:</p><div class="informalexample"><pre class="programlisting">bool g_bRunning = false; // this will create a loop</pre></div><p>Follow these steps to break the <code class="literal">Hello SDL</code> code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an <code class="literal">init</code> function after the two global variables that takes any necessary values as parameters and passes them to the <code class="literal">SDL_CreateWindow</code> function:<div class="informalexample"><pre class="programlisting">bool init(const char* title, int xpos, int ypos, int 
height, int width, int flags)
{
  // initialize SDL
  if(SDL_Init(SDL_INIT_EVERYTHING) &gt;= 0)
  {
    // if succeeded create our window
    g_pWindow = SDL_CreateWindow(title, xpos, ypos, 
    height, width, flags);

    // if the window creation succeeded create our 
    renderer
    if(g_pWindow != 0)
    {
      g_pRenderer = SDL_CreateRenderer(g_pWindow, -1, 0);
    }
  }
  else
  {
    return false; // sdl could not initialize
  }

  return true;
}

void render()
{
  // set to black
  SDL_SetRenderDrawColor(g_pRenderer, 0, 0, 0, 255);

  // clear the window to black
  SDL_RenderClear(g_pRenderer);

  // show the window
  SDL_RenderPresent(g_pRenderer);
}</pre></div></li><li class="listitem">Our main function can<a class="indexterm" id="id63"/> now use these functions to initialize SDL:<div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
  if(init("Chapter 1: Setting up SDL", 
  SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 
  480, SDL_WINDOW_SHOWN))
  {
    g_bRunning = true;
  }
  else
  {
    return 1; // something's wrong
  }

  while(g_bRunning)
  {
    render();
  }

  // clean up SDL
  SDL_Quit();

  return 0;
}</pre></div></li></ol></div><p>As you can see, we have broken the code up into separate parts: one function does the initialization for us and the other does the rendering code. We've added a way to keep the program running in the form of a <code class="literal">while</code> loop that runs continuously, rendering our window.</p><p>Let's take it a step further and try to identify which separate parts a full game might have and how our main loop might look. Referring to the first screenshot, we can see that the functions we will need<a class="indexterm" id="id64"/> are <code class="literal">initialize</code>, <code class="literal">get input</code>, <code class="literal">do physics</code>, <code class="literal">render</code>, and <code class="literal">exit</code>. We will generalize these functions slightly and rename them to <code class="literal">init()</code>, <code class="literal">handleEvents()</code>, <code class="literal">update()</code>, <code class="literal">render()</code>, and <code class="literal">clean()</code>. Let's put these functions into <code class="literal">main.cpp</code>:</p><div class="informalexample"><pre class="programlisting">void init(){}
void render(){}
void update(){}
void handleEvents(){}
void clean(){}

bool g_bRunning = true;

int main()
{
  init();

  while(g_bRunning)
  {
    handleEvents();
    update();
    render();
  }

  clean();
}</pre></div></div><div class="section" title="What does this code do?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>What does this code do?</h2></div></div></div><p>This code does not do much at the moment, but it shows the bare bones of a game and how a main loop might be <a class="indexterm" id="id65"/>broken apart. We declare some functions that can be used to run our game: first, the <code class="literal">init()</code> function, which will initialize SDL and create our window, and second, we declare the core loop functions of <code class="literal">render</code>, <code class="literal">update</code>, and <code class="literal">handle events</code>. We also declare a<a class="indexterm" id="id66"/> <code class="literal">clean</code> function, which will clean up code at the end of our game. We want this loop to continue running so we have a Boolean value that is set to <code class="literal">true</code>, so that we can continuously call our core loop functions.</p></div></div>
<div class="section" title="The Game class"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The Game class</h1></div></div></div><p>So, now that we have an idea of <a class="indexterm" id="id67"/>what makes up a game, we can separate the functions into their own class by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go ahead and create a new file in the project called <code class="literal">Game.h</code>:<div class="informalexample"><pre class="programlisting">#ifndef __Game__
#define __Game__

class Game
{
};

#endif /* defined(__Game__) */</pre></div></li><li class="listitem">Next, we can move our functions from the <code class="literal">main.cpp</code> file into the <code class="literal">Game.h</code> header file:<div class="informalexample"><pre class="programlisting">class Game
{
public:

  Game() {}
  ~Game() {}

  // simply set the running variable to true
  void init() { m_bRunning = true; }    

  void render(){}
  void update(){}
  void handleEvents(){}
  void clean(){}

  // a function to access the private running variable 
  bool running() { return m_bRunning; }

private:

  bool m_bRunning;
};</pre></div></li><li class="listitem">Now, we can alter the <code class="literal">main.cpp</code> file to use this new <code class="literal">Game</code> class:<div class="informalexample"><pre class="programlisting">#include "Game.h"

// our Game object
Game* g_game = 0;

int main(int argc, char* argv[])
{
  g_game = new Game();

  g_game-&gt;init("Chapter 1", 100, 100, 640, 480, 0);

  while(g_game-&gt;running())
  {
    g_game-&gt;handleEvents();
    g_game-&gt;update();
    g_game-&gt;render();
  }
  g_game-&gt;clean();

  return 0;
}</pre></div><p>Our <code class="literal">main.cpp</code> file now does not declare or define any of these functions; it simply<a class="indexterm" id="id68"/> creates an instance of <code class="literal">Game</code> and calls the needed methods.</p></li><li class="listitem">Now that we have this skeleton code, we can go ahead and tie SDL into it to create a window; we will also add a small event handler so that we can exit the application rather than having to force it to quit. We will slightly alter our <code class="literal">Game.h</code> file to allow us to add some SDL specifics and to also allow us to use an implementation file instead of defining functions in the header:<div class="informalexample"><pre class="programlisting">#include "SDL.h"

class Game
{
public:

  Game();
  ~Game();

  void init();

  void render();
  void update();
  void handleEvents();
  void clean();

  bool running() { return m_bRunning; }

private:

  SDL_Window* m_pWindow;
  SDL_Renderer* m_pRenderer;

  bool m_bRunning;
};</pre></div></li></ol></div><p>Looking back at the first part of this chapter (where we created an SDL window), we know that we need a pointer<a class="indexterm" id="id69"/> to an <code class="literal">SDL_Window</code> object that is set when calling <code class="literal">SDL_CreateWindow</code>, and a pointer to an <code class="literal">SDL_Renderer</code> object that is created by passing our window into <code class="literal">SDL_CreateRenderer</code>. The <code class="literal">init</code> function can be extended to use the same parameters as in the initial sample as well. This function will now return a Boolean value so that we can check whether SDL is initialized correctly:</p><div class="informalexample"><pre class="programlisting">bool init(const char* title, int xpos, int ypos, int width, int height, int flags);</pre></div><p>We can now create a new implementation <code class="literal">Game.cpp</code> file in the project so that we can create the definitions for these functions. We can take the code from the <span class="emphasis"><em>Hello SDL</em></span> section and add it to the functions in our new <code class="literal">Game</code> class.</p><p>Open up <code class="literal">Game.cpp</code> and we can begin adding some functionality:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we must include our <code class="literal">Game.h</code> header file:<div class="informalexample"><pre class="programlisting">#include "Game.h"</pre></div></li><li class="listitem">Next, we can define our<a class="indexterm" id="id70"/> <code class="literal">init</code> function; it is essentially the same as the <code class="literal">init</code> function we have previously written in our <code class="literal">main.cpp</code> file:<div class="informalexample"><pre class="programlisting">bool Game::init(const char* title, int xpos, int ypos, int width, int height, int flags)
{
  // attempt to initialize SDL
  if(SDL_Init(SDL_INIT_EVERYTHING) == 0)
  {
    std::cout &lt;&lt; "SDL init success\n";
    // init the window
    m_pWindow = SDL_CreateWindow(title, xpos, ypos, 
    width, height, flags);

    if(m_pWindow != 0) // window init success
    {
      std::cout &lt;&lt; "window creation success\n";
      m_pRenderer = SDL_CreateRenderer(m_pWindow, -1, 0);

      if(m_pRenderer != 0) // renderer init success
      {
        std::cout &lt;&lt; "renderer creation success\n";
        SDL_SetRenderDrawColor(m_pRenderer, 
        255,255,255,255);
      }
      else
      {
        std::cout &lt;&lt; "renderer init fail\n";
        return false; // renderer init fail
      }
    }
    else
    {
      std::cout &lt;&lt; "window init fail\n";
      return false; // window init fail
    }
  }
  else
  {
    std::cout &lt;&lt; "SDL init fail\n";
    return false; // SDL init fail
  }

  std::cout &lt;&lt; "init success\n";
  m_bRunning = true; // everything inited successfully, 
  start the main loop

  return true;
}</pre></div></li><li class="listitem">We will also define<a class="indexterm" id="id71"/> the <code class="literal">render</code> function. It clears the renderer and then renders again with the clear color:<div class="informalexample"><pre class="programlisting">void Game::render()
{
  SDL_RenderClear(m_pRenderer); // clear the renderer to 
  the draw color

  SDL_RenderPresent(m_pRenderer); // draw to the screen
}</pre></div></li><li class="listitem">Finally, we can<a class="indexterm" id="id72"/> clean up. We destroy both the window and the renderer and also call the <code class="literal">SDL_Quit</code> function to close all the subsystems:<div class="informalexample"><pre class="programlisting">{
  std::cout &lt;&lt; "cleaning game\n";
  SDL_DestroyWindow(m_pWindow);
  SDL_DestroyRenderer(m_pRenderer);
  SDL_Quit();
}</pre></div></li></ol></div><p>So we have moved the <code class="literal">Hello SDL 2.0</code> code from the <code class="literal">main.cpp</code> file into a class called <code class="literal">Game</code>. We have freed up the <code class="literal">main.cpp</code> file to handle only the <code class="literal">Game</code> class; it knows nothing about SDL or how the <code class="literal">Game</code> class is implemented. Let's add one more thing to the class to allow us to close the application the regular way:</p><div class="informalexample"><pre class="programlisting">void Game::handleEvents()
{
  SDL_Event event;
  if(SDL_PollEvent(&amp;event))
  {
    switch (event.type)
    {
      case SDL_QUIT:
        m_bRunning = false;
      break;

      default:
      break;
    }
  }
}</pre></div><p>We will cover event handling in more detail in a forthcoming chapter. What this function now does is check if there is an event to handle, and if so, check if it is an <code class="literal">SDL_QUIT</code> event (by clicking on the cross to close a window). If the event is <code class="literal">SDL_QUIT</code>, we set the <code class="literal">Game</code> class' <code class="literal">m_bRunning</code> member <a class="indexterm" id="id73"/>variable to <code class="literal">false</code>. The act of setting this variable to <code class="literal">false</code> makes the main loop stop and the application move onto cleaning up and then exiting:</p><div class="informalexample"><pre class="programlisting">void Game::clean()
{
  std::cout &lt;&lt; "cleaning game\n";
  SDL_DestroyWindow(m_pWindow);
  SDL_DestroyRenderer(m_pRenderer);
  SDL_Quit();
}</pre></div><p>The <code class="literal">clean()</code> function destroys the window and renderer and then calls the <code class="literal">SDL_Quit()</code> function, closing all the initialized SDL subsystems.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>To enable us to view our <code class="literal">std::cout</code> messages, we must first include <code class="literal">Windows.h</code> and then call <code class="literal">AllocConsole(); andfreopen("CON", "w", stdout);</code>. You can do this in the <code class="literal">main.cpp</code> file. Just remember to remove it when sharing your game.</p></div></div><div class="section" title="Fullscreen SDL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Fullscreen SDL</h2></div></div></div><p>
<code class="literal">SDL_CreateWindow</code> takes an enumeration value of type <code class="literal">SDL_WindowFlags</code>. These values set how the window will<a class="indexterm" id="id74"/> behave. We created an <code class="literal">init</code> function in our <code class="literal">Game</code> class:</p><div class="informalexample"><pre class="programlisting">bool init(const char* title, int xpos, int ypos, int width, int height, int flags);</pre></div><p>The final parameter is an <code class="literal">SDL_WindowFlags</code> value, which is then passed into the <code class="literal">SDL_CreateWindow</code> function when initializing:</p><div class="informalexample"><pre class="programlisting">// init the window
m_pWindow = SDL_CreateWindow(title, xpos, ypos, width, height, flags);</pre></div><p>Here is a table of the <a class="indexterm" id="id75"/>
<code class="literal">SDL_WindowFlags</code> function:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flag</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_FULLSCREEN</code>
<a class="indexterm" id="id76"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Make the window<a class="indexterm" id="id77"/> fullscreen</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_OPENGL</code>
<a class="indexterm" id="id78"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Window can be used<a class="indexterm" id="id79"/> with as an OpenGL context</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_SHOWN</code>
<a class="indexterm" id="id80"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The window is visible<a class="indexterm" id="id81"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_HIDDEN</code>
<a class="indexterm" id="id82"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Hide the window<a class="indexterm" id="id83"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_BORDERLESS</code>
<a class="indexterm" id="id84"/>
</p>
</td><td style="text-align: left" valign="top">
<p>No border on the window<a class="indexterm" id="id85"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_RESIZABLE</code>
<a class="indexterm" id="id86"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Enable resizing<a class="indexterm" id="id87"/> of the window</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_MINIMIZED</code>
<a class="indexterm" id="id88"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Minimize the window<a class="indexterm" id="id89"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_MAXIMIZED</code>
<a class="indexterm" id="id90"/>
<a class="indexterm" id="id91"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Maximize the window<a class="indexterm" id="id92"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_INPUT_GRABBED</code>
<a class="indexterm" id="id93"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Window has grabbed input focus<a class="indexterm" id="id94"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_INPUT_FOCUS</code>
<a class="indexterm" id="id95"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Window has input focus<a class="indexterm" id="id96"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_MOUSE_FOCUS</code>
<a class="indexterm" id="id97"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Window has mouse focus<a class="indexterm" id="id98"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SDL_WINDOW_FOREIGN</code>
<a class="indexterm" id="id99"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The window <a class="indexterm" id="id100"/>was not created using SDL</p>
</td></tr></tbody></table></div><p>Let's pass in <code class="literal">SDL_WINDOW_FULLSCREEN</code> to the <code class="literal">init</code> function and test out some fullscreen SDL. Open up the <code class="literal">main.cpp</code> file and add this flag:</p><div class="informalexample"><pre class="programlisting">g_game-&gt;init("Chapter 1", 100, 100, 640, 580, SDL_WINDOW_FULLSCREEN))</pre></div><p>Build the application again<a class="indexterm" id="id101"/> and you should see that the window is fullscreen. To exit the application, it will have to be forced to quit (<span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>F4</em></span> on Windows); we will be able to use the keyboard to quit the application in forthcoming chapters, but for now, we won't need fullscreen. One problem we have here is that we have now added something SDL specific to the <code class="literal">main.cpp</code> file. While we will not use any other frameworks in this book, in future we may want to use another. We can remove this SDL-specific flag and replace it with a Boolean value for whether we want fullscreen or not.</p><p>Replace the <a class="indexterm" id="id102"/>
<code class="literal">int flags</code> parameter in our <code class="literal">Game init</code> function with a<a class="indexterm" id="id103"/> <code class="literal">boolfullscreen</code> parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code snippet for <code class="literal">Game.h</code>:<div class="informalexample"><pre class="programlisting">bool init(const char* title, int xpos, int ypos, int width, int height, bool fullscreen);</pre></div></li><li class="listitem" style="list-style-type: disc">The code snippet for <code class="literal">Game.cpp</code>:<div class="informalexample"><pre class="programlisting">bool Game::init(const char* title, int xpos, int ypos, int width, int height, bool fullscreen)
{
  int flags = 0;

  if(fullscreen)
  {
    flags = SDL_WINDOW_FULLSCREEN;
  }
}</pre></div></li></ul></div><p>We create an <code class="literal">int</code> flags variable to pass into the <a class="indexterm" id="id104"/>
<code class="literal">SDL_CreateWindow</code> function; if we have set <code class="literal">fullscreen</code> to <code class="literal">true</code>, then<a class="indexterm" id="id105"/> this value will be set to the <a class="indexterm" id="id106"/>
<code class="literal">SDL_WINDOW_FULLSCREEN</code> flag, otherwise it will remain as <code class="literal">0</code> to signify that no flags are being used. Let's test this now in our <code class="literal">main.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">if(g_game-&gt;init("Chapter 1", 100, 100, 640, 480, true))</pre></div><p>This will again set our window to fullscreen, but we aren't using the SDL-specific flag to do it. Set it to <code class="literal">false</code> again as we will not need fullscreen for a while. Feel free to try out a few of the other flags to see what effects they have.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>A lot of ground has been covered in this chapter. We learned what SDL is and why it is a great tool for game development. We looked at the overall structure of a game and how it can be broken into individual parts, and we started to develop the skeleton of our framework by creating a <code class="literal">Game</code> class that can be used to initialize SDL and render things to the screen. We also had a small look at how SDL handles events by listening for a <code class="literal">quit</code> event to close our application. In the next chapter we will look at drawing in SDL and building the <code class="literal">SDL_image</code> extension.</p></div></body></html>