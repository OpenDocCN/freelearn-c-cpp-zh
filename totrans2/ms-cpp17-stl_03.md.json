["```cpp\n    constexpr int N = 10;\n    int a[N];\n\n    // A correct for-loop.\n    for (int i=0; i < N; ++i) {\n      // ...\n    }\n\n    // One variety of \"smelly\" for-loop.\n    for (int i=0; i <= N; ++i) {\n      // ... \n    }\n\n    // A correct invocation of a standard algorithm.\n    std::count_if(std::begin(a), std::end(a), [](int){ return true; });\n\n    // A \"smelly\" invocation.\n    std::count_if(std::begin(a), std::end(a) - 1, [](int){ return true; });\n\n    // A \"trivial\" invocation: counting a range of length zero.\n    std::count_if(std::begin(a), std::begin(a), [](int){ return true; });\n```", "```cpp\n    int a[] {1, 2, 3, 4, 5};\n    std::list<int> lst {1, 2, 3, 4, 5};\n    std::forward_list<int> flst {1, 2, 3, 4, 5};\n\n    assert(std::distance(std::begin(a), std::end(a)) == 5);\n    assert(std::distance(std::begin(lst), std::end(lst)) == 5);\n    assert(std::distance(std::begin(lst), std::end(lst)) == 5);\n\n    assert(std::distance(std::end(a), std::begin(a)) == -5);\n```", "```cpp\n    // The following line gives an \"incorrect\" answer!\n    // assert(std::distance(std::end(lst), std::begin(lst)) == 1);\n    // And this one just segfaults!\n    // std::distance(std::end(flst), std::begin(flst));\n```", "```cpp\n    std::set<int> s { 1, 2, 3, 10, 42, 99 };\n    bool present;\n\n    // O(n): compare each element with 42\n    present = std::count(s.begin(), s.end(), 42);\n\n    // O(log n): ask the container to look up 42 itself\n    present = s.count(42);\n```", "```cpp\n    template<class InputIterator, class UnaryPredicate>\n    InputIterator find_if(InputIterator first, InputIterator last,\n      UnaryPredicate p) \n    {\n      for (; first != last; ++first) {\n        if (p(*first)) {\n          return first;\n        }\n      }\n      return last;\n    }\n\n    template<class It, class U>\n    It find_if_not(It first, It last, U p) {\n      return std::find_if(first, last, [&](auto&& e){ return !p(e); }); \n    }\n\n    template<class It, class T>\n    It find(It first, It last, T value) {\n      return std::find_if(first, last, [&](auto&& e)\n        { return e == value; }); \n    }\n```", "```cpp\n    template<class It, class UnaryPredicate>\n    bool all_of(It first, It last, UnaryPredicate p)\n    {\n      return std::find_if_not(first, last, p) == last;\n    }\n\n    template <class It, class U>\n    bool any_of(It first, It last, U p)\n    {\n      return std::find_if(first, last, p) != last;\n    }\n\n    template <class It, class U>\n    bool none_of(It first, It last, U p)\n    {\n      return std::find_if(first, last, p) == last;\n    }\n```", "```cpp\n    template <class It, class FwdIt>\n    It find_first_of(It first, It last, FwdIt targetfirst,\n      FwdIt targetlast)\n    {\n      return std::find_if(first, last, [&](auto&& e) {\n        return std::any_of(targetfirst, targetlast, [&](auto&& t) {\n          return e == t;\n        });\n      });\n    }\n\n    template <class It, class FwdIt, class BinaryPredicate>\n    It find_first_of(It first, It last, FwdIt targetfirst,\n      FwdIt targetlast, BinaryPredicate p)\n    {\n      return std::find_if(first, last, [&](auto&& e) {\n        return std::any_of(targetfirst, targetlast, [&](auto&& t) {\n          return p(e, t);\n        });\n      });\n    }\n```", "```cpp\n    std::istream_iterator<char> ii(std::cin);\n    std::istream_iterator<char> iend{};\n    std::string s = \"hello\";\n\n    // Chomp characters from std::cin until finding an 'h', 'e', 'l', or 'o'.\n    std::find_first_of(ii, iend, s.begin(), s.end());\n```", "```cpp\n    template<class T> constexpr bool is_random_access_iterator_v =\n      std::is_base_of_v<std::random_access_iterator_tag, typename \n      std::iterator_traits<T>::iterator_category>;\n\n    template<class It1, class It2, class B>\n    auto mismatch(It1 first1, It1 last1, It2 first2, It2 last2, B p)\n    {\n      while (first1 != last1 && first2 != last2 && p(*first1, *first2)) {\n        ++first1;\n        ++first2;\n      }\n      return std::make_pair(first1, first2);\n    }\n\n    template<class It1, class It2>\n    auto mismatch(It1 first1, It1 last1, It2 first2, It2 last2)\n    {\n      return std::mismatch(first1, last1, first2, last2, std::equal_to<>{});\n    }\n\n    template<class It1, class It2, class B>\n    bool equal(It1 first1, It1 last1, It2 first2, It2 last2, B p)\n    {\n      if constexpr (is_random_access_iterator_v<It1> &&\n        is_random_access_iterator_v<It2>) {\n        // Ranges of different lengths can never be equal.\n        if ((last2 - first2) != (last1 - first1)) {\n          return false;\n        }\n      }\n      return std::mismatch(first1, last1, first2, last2, p) ==\n        std::make_pair(last1, last2);\n    }\n\n    template<class It1, class It2>\n    bool equal(It1 first1, It1 last1, It2 first2, It2 last2)\n    {\n      return std::equal(first1, last1, first2, last2, std::equal_to<>{});\n    }\n```", "```cpp\n    template<class InIt, class OutIt>\n    OutIt copy(InIt first1, InIt last1, OutIt destination)\n    {\n      while (first1 != last1) {\n        *destination = *first1;\n        ++first1;\n        ++destination;\n      }\n      return destination;\n    }\n```", "```cpp\n    class putc_iterator : public boost::iterator_facade<\n      putc_iterator, // T\n      const putc_iterator, // value_type\n      std::output_iterator_tag\n      >\n    {\n      friend class boost::iterator_core_access;\n\n       auto& dereference() const { return *this; }\n       void increment() {}\n       bool equal(const putc_iterator&) const { return false; }\n       public:\n       // This iterator is its own proxy object!\n       void operator= (char ch) const { putc(ch, stdout); }\n    };\n\n    void test()\n    {\n      std::string s = \"hello\";\n      std::copy(s.begin(), s.end(), putc_iterator{});\n    }\n```", "```cpp\n    namespace std {\n      template<class Container>\n      class back_insert_iterator {\n        using CtrValueType = typename Container::value_type;\n        Container *c;\n      public:\n        using iterator_category = output_iterator_tag;\n        using difference_type = void;\n        using value_type = void;\n        using pointer = void;\n        using reference = void;\n\n        explicit back_insert_iterator(Container& ctr) : c(&ctr) {}\n\n        auto& operator*() { return *this; }\n        auto& operator++() { return *this; }\n        auto& operator++(int) { return *this; }\n\n        auto& operator= (const CtrValueType& v) {\n            c->push_back(v);\n            return *this;\n        }\n        auto& operator= (CtrValueType&& v) {\n            c->push_back(std::move(v));\n            return *this;\n        }\n      };\n\n      template<class Container>\n      auto back_inserter(Container& c)\n      {\n         return back_insert_iterator<Container>(c);\n      }\n    }\n\n    void test()\n    {\n      std::string s = \"hello\";\n      std::vector<char> dest;\n      std::copy(s.begin(), s.end(), std::back_inserter(dest));\n      assert(dest.size() == 5);\n    }\n```", "```cpp\n    template<class InIt, class OutIt>\n    OutIt move(InIt first1, InIt last1, OutIt destination)\n    {\n      while (first1 != last1) {\n        *destination = std::move(*first1);\n        ++first1;\n        ++destination;\n      }\n      return destination;\n    }\n```", "```cpp\n    template<class It>\n    class move_iterator {\n      using OriginalRefType = typename std::iterator_traits<It>::reference;\n      It iter;\n      public:\n       using iterator_category = typename\n         std::iterator_traits<It>::iterator_category;\n       using difference_type = typename\n         std::iterator_traits<It>::difference_type;\n       using value_type = typename std::iterator_traits<It>::value_type;\n       using pointer = It;\n       using reference = std::conditional_t<\n         std::is_reference_v<OriginalRefType>,\n         std::remove_reference_t<OriginalRefType>&&,\n         OriginalRefType\n         >;\n\n       move_iterator() = default;\n       explicit move_iterator(It it) : iter(std::move(it)) {}\n\n       // Allow constructing or assigning from any kind of move-iterator.\n       // These templates also serve as our own type's copy constructor\n       // and assignment operator, respectively.\n       template<class U>\n       move_iterator(const move_iterator<U>& m) : iter(m.base()) {}\n       template<class U>\n       auto& operator=(const move_iterator<U>& m)\n         { iter = m.base(); return *this; }\n\n       It base() const { return iter; }\n\n       reference operator*() { return static_cast<reference>(*iter); }\n       It operator->() { return iter; }\n       decltype(auto) operator[](difference_type n) const \n         { return *std::move(iter[n]); }\n\n      auto& operator++() { ++iter; return *this; }\n      auto& operator++(int)\n        { auto result = *this; ++*this; return result; }\n      auto& operator--() { --iter; return *this; }\n      auto& operator--(int)\n        { auto result = *this; --*this; return result; } \n\n      auto& operator+=(difference_type n) const\n        { iter += n; return *this; }\n      auto& operator-=(difference_type n) const\n        { iter -= n; return *this; }\n    };\n\n    // I've omitted the definitions of non-member operators\n    // == != < <= > >= + - ; can you fill them in?\n\n    template<class InputIterator>\n    auto make_move_iterator(InputIterator& c) \n    {\n      return move_iterator(c);\n    }\n```", "```cpp\n    std::vector<std::string> input = {\"hello\", \"world\"};\n    std::vector<std::string> output(2);\n\n    // First approach: use the std::move algorithm\n    std::move(input.begin(), input.end(), output.begin());\n\n    // Second approach: use move_iterator\n    std::copy(\n      std::move_iterator(input.begin()),\n      std::move_iterator(input.end()),\n      output.begin()\n    );\n```", "```cpp\n    std::vector<const char *> input = {\"hello\", \"world\"};\n    std::vector<std::string> output(2);\n\n    std::copy(input.begin(), input.end(), output.begin());\n\n    assert(output[0] == \"hello\");\n    assert(output[1] == \"world\");\n```", "```cpp\n    template<class InIt, class OutIt, class Unary>\n    OutIt transform(InIt first1, InIt last1, OutIt destination, Unary op)\n    {\n      while (first1 != last1) {\n        *destination = op(*first1);\n        ++first1;\n        ++destination;\n      }\n      return destination;\n    }\n\n    void test() \n    {\n      std::vector<std::string> input = {\"hello\", \"world\"};\n      std::vector<std::string> output(2);\n\n      std::transform(\n        input.begin(),\n        input.end(),\n        output.begin(),\n        [](std::string s) {\n          // It works for transforming in-place, too!\n          std::transform(s.begin(), s.end(), s.begin(), ::toupper);\n          return s;\n        }\n      );\n\n      assert(input[0] == \"hello\");\n      assert(output[0] == \"HELLO\");\n    }\n```", "```cpp\n    template<class InIt1, class InIt2, class OutIt, class Binary>\n    OutIt transform(InIt1 first1, InIt1 last1, InIt2 first2, OutIt destination,\n      Binary op)\n    {\n      while (first1 != last1) {\n        *destination = op(*first1, *first2);\n        ++first1;\n        ++first2;\n        ++destination;\n      }\n      return destination;\n    }\n```", "```cpp\n    std::vector<std::string> input = {\"hello\", \"world\"};\n    std::vector<std::string> output(2);\n\n    // Third approach: use std::transform\n    std::transform(\n      input.begin(),\n      input.end(),\n      output.begin(),\n      std::move<std::string&>\n    );\n```", "```cpp\n    template<class FwdIt, class T>\n    void fill(FwdIt first, FwdIt last, T value) {\n      while (first != last) {\n        *first = value;\n         ++first;\n      }\n    }\n\n    template<class FwdIt, class T>\n    void iota(FwdIt first, FwdIt last, T value) {\n      while (first != last) {\n        *first = value;\n        ++value;\n        ++first;\n      }\n    }\n\n    template<class FwdIt, class G>\n    void generate(FwdIt first, FwdIt last, G generator) {\n      while (first != last) {\n        *first = generator();\n        ++first;\n      }\n    }\n```", "```cpp\n    std::vector<std::string> v(4);\n\n    std::fill(v.begin(), v.end(), \"hello\");\n    assert(v[0] == \"hello\");\n    assert(v[1] == \"hello\");\n    assert(v[2] == \"hello\");\n    assert(v[3] == \"hello\");\n\n    std::iota(v.begin(), v.end(), \"hello\");\n    assert(v[0] == \"hello\");\n    assert(v[1] == \"ello\");\n    assert(v[2] == \"llo\");\n    assert(v[3] == \"lo\");\n\n    std::generate(v.begin(), v.end(), [i=0]() mutable {\n      return ++i % 2 ? \"hello\" : \"world\";\n    });\n    assert(v[0] == \"hello\");\n    assert(v[1] == \"world\");\n    assert(v[2] == \"hello\");\n    assert(v[3] == \"world\");\n```", "```cpp\n    template<class T>\n    void destroy_at(T *p)\n    {\n      p->~T();\n    }\n\n    template<class FwdIt>\n    void destroy(FwdIt first, FwdIt last)\n    {\n      for ( ; first != last; ++first) {\n        std::destroy_at(std::addressof(*first));\n      }\n    }\n```", "```cpp\n    template<class It, class FwdIt>\n    FwdIt uninitialized_copy(It first, It last, FwdIt out)\n    {\n      using T = typename std::iterator_traits<FwdIt>::value_type;\n      FwdIt old_out = out;\n      try {\n        while (first != last) {\n          ::new (static_cast<void*>(std::addressof(*out))) T(*first);\n          ++first;\n          ++out;\n        }\n        return out;\n      } catch (...) {\n        std::destroy(old_out, out);\n        throw;\n      }\n    }\n\n    void test()\n    { \n      alignas(std::string) char b[5 * sizeof (std::string)];  \n      std::string *sb = reinterpret_cast<std::string *>(b);\n\n      std::vector<const char *> vec = {\"quick\", \"brown\", \"fox\"};\n\n      // Construct three std::strings.\n      auto end = std::uninitialized_copy(vec.begin(), vec.end(), sb);\n\n      assert(end == sb + 3);\n\n      // Destroy three std::strings.\n      std::destroy(sb, end);\n    }\n```", "```cpp\n    std::vector<int> v = {3, 1, 4, 1, 5, 9};\n    std::sort(v.begin(), v.end(), [](auto&& a, auto&& b) {\n      return a % 7 < b % 7;\n    });\n    assert((v == std::vector{1, 1, 9, 3, 4, 5}));\n```", "```cpp\n    namespace my {\n      class obj {\n        int v;\n      public:\n        obj(int value) : v(value) {}\n\n        void swap(obj& other) {\n          using std::swap;\n          swap(this->v, other.v);\n        }\n      };\n\n      void swap(obj& a, obj& b) {\n        a.swap(b);\n      }\n    } // namespace my\n\n    void test()\n    {\n      int i1 = 1, i2 = 2;\n      std::vector<int> v1 = {1}, v2 = {2};\n      my::obj m1 = 1, m2 = 2;\n      using std::swap;\n      swap(i1, i2); // calls std::swap<int>(int&, int&)\n      swap(v1, v2); // calls std::swap(vector&, vector&)\n      swap(m1, m2); // calls my::swap(obj&, obj&)\n    }\n```", "```cpp\n    void reverse_words_in_place(std::string& s)\n    {\n      // First, reverse the whole string.\n      std::reverse(s.begin(), s.end());\n\n      // Next, un-reverse each individual word.\n      for (auto it = s.begin(); true; ++it) {\n        auto next = std::find(it, s.end(), ' ');\n        // Reverse the order of letters in this word.\n        std::reverse(it, next);\n        if (next == s.end()) {\n          break;\n        }\n        it = next;\n      }\n    }\n\n    void test()\n    {\n      std::string s = \"the quick brown fox jumps over the lazy dog\";\n      reverse_words_in_place(s);\n      assert(s == \"dog lazy the over jumps fox brown quick the\");\n    }\n```", "```cpp\n    template<class BidirIt>\n    void reverse(BidirIt first, BidirIt last)\n    {\n      while (first != last) {\n        --last;\n        if (first == last) break;\n        using std::swap;\n        swap(*first, *last);\n        ++first;\n      }\n    }\n\n    template<class BidirIt, class Unary>\n    auto partition(BidirIt first, BidirIt last, Unary p)\n    {\n      while (first != last && p(*first)) {\n        ++first;\n      }\n\n      while (first != last) {\n        do {\n          --last;\n        } while (last != first && !p(*last));\n        if (first == last) break;\n        using std::swap;\n        swap(*first, *last);\n        do {\n          ++first;\n        } while (first != last && p(*first));\n      }\n      return first;\n    }\n\n    void test()  \n    {\n      std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6, 5};\n      auto it = std::partition(v.begin(), v.end(), [](int x) {\n        return x % 2 == 0;\n      });\n      assert(it == v.begin() + 3);\n      assert((v == std::vector{6, 2, 4, 1, 5, 9, 1, 3, 5}));\n    }\n```", "```cpp\n    // Shorthands for \"reversing\" and \"unreversing\".\n    template<class It>\n    auto rev(It it) {\n      return std::reverse_iterator(it);\n    };\n\n    template<class InnerIt>\n    auto unrev(std::reverse_iterator<InnerIt> it) {\n      return it.base();\n    }\n\n    template<class BidirIt, class Unary>\n    auto partition(BidirIt first, BidirIt last, Unary p)\n    {\n      first = std::find_if_not(first, last, p);\n\n      while (first != last) {\n        last = unrev(std::find_if(rev(last), rev(first), p));\n        if (first == last) break;\n        using std::swap;\n        swap(*first++, *--last);\n        first = std::find_if_not(first, last, p);\n      }\n      return first;\n    }\n```", "```cpp\n    template<class FwdIt>\n    FwdIt rotate(FwdIt a, FwdIt mid, FwdIt b)\n    {\n      auto result = a + (b - mid);\n\n      // First, reverse the whole range.\n      std::reverse(a, b);\n\n      // Next, un-reverse each individual segment.\n      std::reverse(a, result);\n      std::reverse(result, b);\n\n      return result;\n    }\n\n    void test()\n    {\n      std::vector<int> v = {1, 2, 3, 4, 5, 6};\n      auto five = std::find(v.begin(), v.end(), 5);\n      auto one = std::rotate(v.begin(), five, v.end());\n      assert((v == std::vector{5, 6, 1, 2, 3, 4}));\n      assert(*one == 1);\n    }\n```", "```cpp\n    std::vector<int> p = {10, 20, 30};\n    std::vector<std::vector<int>> results;\n\n    // Collect the permutations of these three elements.\n    for (int i=0; i < 6; ++i) {\n      results.push_back(p);\n      std::next_permutation(p.begin(), p.end());\n    }\n\n    assert((results == std::vector<std::vector<int>>{\n      {10, 20, 30},\n      {10, 30, 20},\n      {20, 10, 30},\n      {20, 30, 10},\n      {30, 10, 20},\n      {30, 20, 10},\n    }));\n```", "```cpp\n    template<class RandomIt>\n    void push_heap(RandomIt a, RandomIt b)\n    {\n      auto child = ((b-1) - a);\n      while (child != 0) {\n        auto parent = (child - 1) / 2;\n        if (a[child] < a[parent]) {\n          return; // max-heap property has been restored\n        }\n        std::iter_swap(a+child, a+parent);\n        child = parent;\n      }\n    }\n\n    template<class RandomIt>\n    void pop_heap(RandomIt a, RandomIt b)\n    {\n      using DistanceT = decltype(b - a);\n\n      std::iter_swap(a, b-1);\n\n      DistanceT parent = 0;\n      DistanceT new_heap_size = ((b-1) - a);\n\n      while (true) {\n        auto leftchild = 2 * parent + 1;\n        auto rightchild = 2 * parent + 2;\n        if (leftchild >= new_heap_size) {\n          return;\n        }\n        auto biggerchild = leftchild;\n        if (rightchild < new_heap_size && a[leftchild] < a[rightchild]) {\n          biggerchild = rightchild;\n        }\n        if (a[biggerchild] < a[parent]) {\n          return; // max-heap property has been restored\n        }\n        std::iter_swap(a+parent, a+biggerchild);\n        parent = biggerchild;\n      }\n    }\n\n    template<class RandomIt>\n    void make_heap(RandomIt a, RandomIt b)\n    {\n      for (auto it = a; it != b; ) {\n        push_heap(a, ++it);\n      }\n    }\n\n    template<class RandomIt>\n    void sort_heap(RandomIt a, RandomIt b)\n    {\n      for (auto it = b; it != a; --it) {\n        pop_heap(a, it);\n      }\n    }\n\n    template<class RandomIt>\n    void sort(RandomIt a, RandomIt b)\n    {\n      make_heap(a, b);\n      sort_heap(a, b);\n    }\n```", "```cpp\n    template<class RandomIt>\n    void sort(RandomIt a, RandomIt b)\n    {\n      auto n = std::distance(a, b);\n      if (n >= 2) {\n        auto mid = a + n/2;\n        std::sort(a, mid);\n        std::sort(mid, b);\n        std::inplace_merge(a, mid, b);\n      }\n    }\n```", "```cpp\n    template<class FwdIt, class T, class C>\n    FwdIt lower_bound(FwdIt first, FwdIt last, const T& value, C lessthan)\n    {\n      using DiffT = typename std::iterator_traits<FwdIt>::difference_type;\n      FwdIt it;\n      DiffT count = std::distance(first, last);\n\n      while (count > 0) {\n        DiffT step = count / 2;\n        it = first;\n        std::advance(it, step);\n        if (lessthan(*it, value)) {\n          ++it;\n          first = it;\n          count -= step + 1;\n        } else {\n          count = step;\n        }\n      }\n      return first;\n    }\n\n    template<class FwdIt, class T>\n    FwdIt lower_bound(FwdIt first, FwdIt last, const T& value) \n    {\n      return std::lower_bound(first, last, value, std::less<>{});\n    }\n```", "```cpp\n    std::vector<int> vec = {3, 7};\n    for (int value : {1, 5, 9}) {\n      // Find the appropriate insertion point...\n      auto it = std::lower_bound(vec.begin(), vec.end(), value);\n      // ...and insert our value there.\n      vec.insert(it, value);\n    }\n    // The vector has remained sorted.\n    assert((vec == std::vector{1, 3, 5, 7, 9}));\n```", "```cpp\n    std::vector<int> vec = {2, 3, 3, 3, 4};\n    auto lower = std::lower_bound(vec.begin(), vec.end(), 3);\n\n    // First approach:\n    // upper_bound's interface is identical to lower_bound's.\n    auto upper = std::upper_bound(vec.begin(), vec.end(), 3);\n\n    // Second approach:\n    // We don't need to binary-search the whole array the second time.\n    auto upper2 = std::upper_bound(lower, vec.end(), 3);\n    assert(upper2 == upper);\n\n    // Third approach:\n    // Linear scan from the lower bound might well be faster\n    // than binary search if our total range is really big.\n    auto upper3 = std::find_if(lower, vec.end(), [](int v) {\n      return v != 3;\n    });\n    assert(upper3 == upper);\n\n    // No matter which approach we take, this is what we end up with.\n    assert(*lower >= 3);\n    assert(*upper > 3);\n    assert(std::all_of(lower, upper, [](int v) { return v == 3; }));\n```", "```cpp\n    std::vector<int> vec = {1, 3, 3, 4, 6, 8};\n\n    // Partition our vector so that all the non-3s are at the front\n    // and all the 3s are at the end.\n    auto first_3 = std::stable_partition(\n      vec.begin(), vec.end(), [](int v){ return v != 3; }\n    );\n\n    assert((vec == std::vector{1, 4, 6, 8, 3, 3}));\n\n    // Now erase the \"tail\" of our vector.\n    vec.erase(first_3, vec.end());\n\n    assert((vec == std::vector{1, 4, 6, 8}));\n```", "```cpp\n    template<class FwdIt, class T>\n    FwdIt remove(FwdIt first, FwdIt last, const T& value) \n    {\n      auto out = std::find(first, last, value);\n      if (out != last) {\n        auto in = out;\n        while (++in != last) {\n          if (*in == value) {\n             // don't bother with this item\n          } else {\n             *out++ = std::move(*in);\n          }\n        }\n      }\n      return out;\n    }\n\n    void test()\n    {\n      std::vector<int> vec = {1, 3, 3, 4, 6, 8};\n\n      // Partition our vector so that all the non-3s are at the front.\n      auto new_end = std::remove(\n        vec.begin(), vec.end(), 3\n      );\n\n      // std::remove_if doesn't preserve the \"removed\" elements.\n      assert((vec == std::vector{1, 4, 6, 8, 6, 8}));\n\n      // Now erase the \"tail\" of our vector.\n      vec.erase(new_end, vec.end());\n\n      assert((vec == std::vector{1, 4, 6, 8}));\n\n      // Or, do both steps together in a single line.\n      // This is the \"erase-remove idiom\":\n      vec.erase(\n        std::remove(vec.begin(), vec.end(), 3),\n        vec.end()\n      );\n\n      // But if the array is very long, and we know it's sorted,\n      // then perhaps it would be better to binary-search for\n      // the elements to erase.\n      // Here the \"shifting-down\" is still happening, but it's\n      // happening inside vector::erase instead of inside std::remove.\n      auto first = std::lower_bound(vec.begin(), vec.end(), 3);\n      auto last = std::upper_bound(first, vec.end(), 3);\n      vec.erase(first, last);\n    }\n```", "```cpp\n    std::vector<int> vec = {1, 2, 2, 3, 3, 3, 1, 3, 3};\n\n    vec.erase(\n      std::unique(vec.begin(), vec.end()),\n      vec.end()\n    );\n\n    assert((vec == std::vector{1, 2, 3, 1, 3}));\n```", "```cpp\n    namespace my {\n      template<class BidirIt, class T>\n      BidirIt unstable_remove(BidirIt first, BidirIt last, const T& value)\n      {\n        while (true) {\n          // Find the first instance of \"value\"...\n          first = std::find(first, last, value);\n          // ...and the last instance of \"not value\"...\n          do {\n            if (first == last) {\n              return last;\n            }\n            --last;\n          } while (*last == value);\n          // ...and move the latter over top of the former.\n          *first = std::move(*last);\n          // Rinse and repeat.\n          ++first;\n        }\n      }\n    } // namespace my\n\n    void test()\n    {\n      std::vector<int> vec = {4, 1, 3, 6, 3, 8};\n\n      vec.erase(\n        my::unstable_remove(vec.begin(), vec.end(), 3),\n        vec.end()\n      );\n\n      assert((vec == std::vector{4, 1, 8, 6}));\n    }\n```"]