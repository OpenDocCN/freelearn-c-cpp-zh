["```cpp\n$ cat test.ll\ndefine i32 @test(i32 %a, i32 %b, i32 %c) {\n%add = add nsw i32 %a, %b\n%div = sdiv i32 %add, %c\nret i32 %div\n}\n\n```", "```cpp\n %add = add nsw i32 %a, %b\n\n```", "```cpp\nvoid SelectionDAGBuilder::visit(unsigned Opcode, const User &I) {\n  // Note: this doesn't use InstVisitor, because it has to work with\n  // ConstantExpr's in addition to instructions.\n  switch (Opcode) {\n  default: llvm_unreachable(\"Unknown instruction type encountered!\");\n    // Build the switch statement using the Instruction.def file.\n#define HANDLE_INST(NUM, OPCODE, CLASS) \\\n    case Instruction::OPCODE: visit##OPCODE((const CLASS&)I); break;\n#include \"llvm/IR/Instruction.def\"\n  }\n}\n```", "```cpp\nvoid SelectionDAGBuilder::visitBinary(const User &I, unsigned OpCode) {\n SDValue Op1 = getValue(I.getOperand(0));\n SDValue Op2 = getValue(I.getOperand(1));\n\n  bool nuw = false;\n  bool nsw = false;\n  bool exact = false;\n  FastMathFlags FMF;\n\n  if (const OverflowingBinaryOperator *OFBinOp =\n          dyn_cast<const OverflowingBinaryOperator>(&I)) {\n    nuw = OFBinOp->hasNoUnsignedWrap();\n    nsw = OFBinOp->hasNoSignedWrap();\n  }\n  if (const PossiblyExactOperator *ExactOp =\n          dyn_cast<const PossiblyExactOperator>(&I))\n    exact = ExactOp->isExact();\n  if (const FPMathOperator *FPOp = dyn_cast<const FPMathOperator>(&I))\n    FMF = FPOp->getFastMathFlags();\n\n  SDNodeFlags Flags;\n  Flags.setExact(exact);\n  Flags.setNoSignedWrap(nsw);\n  Flags.setNoUnsignedWrap(nuw);\n  if (EnableFMFInDAG) {\n    Flags.setAllowReciprocal(FMF.allowReciprocal());\n    Flags.setNoInfs(FMF.noInfs());\n    Flags.setNoNaNs(FMF.noNaNs());\n    Flags.setNoSignedZeros(FMF.noSignedZeros());\n    Flags.setUnsafeAlgebra(FMF.unsafeAlgebra());\n  }\n SDValue BinNodeValue = DAG.getNode(OpCode, getCurSDLoc(), Op1.getValueType(), Op1, Op2, &Flags);\n  setValue(&I, BinNodeValue);\n}\n```", "```cpp\n%div = sdiv i32 %add, %c\n\n```", "```cpp\nvoid SelectionDAGBuilder::visitSDiv(const User &I) {\n  SDValue Op1 = getValue(I.getOperand(0));\n  SDValue Op2 = getValue(I.getOperand(1));\n\n  SDNodeFlags Flags;\n  Flags.setExact(isa<PossiblyExactOperator>(&I) &&\n                 cast<PossiblyExactOperator>(&I)->isExact());\n  setValue(&I, DAG.getNode(ISD::SDIV, getCurSDLoc(), Op1.getValueType(), Op1, Op2, &Flags));\n}\n```", "```cpp\nvoid SelectionDAGLegalize::LegalizeOp(SDNode *Node){\n…\n…\ncase TargetLowering::Expand:\n      ExpandNode(Node);\n      return;\n…\n…\n}\n```", "```cpp\ncase ISD::SDIV: {\n    bool isSigned = Node->getOpcode() == ISD::SDIV;\n    unsigned DivRemOpc = isSigned ? ISD::SDIVREM : ISD::UDIVREM;\n    EVT VT = Node->getValueType(0);\n    SDVTList VTs = DAG.getVTList(VT, VT);\n    if (TLI.isOperationLegalOrCustom(DivRemOpc, VT) ||\n        (isDivRemLibcallAvailable(Node, isSigned, TLI) &&\n         useDivRem(Node, isSigned, true)))\n      Tmp1 = DAG.getNode(DivRemOpc, dl, VTs, Node->getOperand(0),\n                         Node->getOperand(1));\n    else if (isSigned)\n      Tmp1 = ExpandIntLibCall(Node, true,\n                              RTLIB::SDIV_I8,\n                              RTLIB::SDIV_I16, RTLIB::SDIV_I32,\n                              RTLIB::SDIV_I64, RTLIB::SDIV_I128);\n    else\n      Tmp1 = ExpandIntLibCall(Node, false,\n                              RTLIB::UDIV_I8,\n                              RTLIB::UDIV_I16, RTLIB::UDIV_I32,\n                              RTLIB::UDIV_I64, RTLIB::UDIV_I128);\n    Results.push_back(Tmp1);\n    break;\n  }\n```", "```cpp\n#include <arm_neon.h>\nunsigned hadd(uint32x4_t a) {\n  return a[0] + a[1] + a[2] + a[3];\n}\n```", "```cpp\ndefine i32 @hadd(<4 x i32> %a) nounwind {\n  %vecext = extractelement <4 x i32> %a, i32 3\n  %vecext1 = extractelement <4 x i32> %a, i32 2\n  %add = add i32 %vecext, %vecext1\n  %vecext2 = extractelement <4 x i32> %a, i32 1\n  %add3 = add i32 %add, %vecext2\n  %vecext4 = extractelement <4 x i32> %a, i32 0\n  %add5 = add i32 %add3, %vecext4\n  ret i32 %add5\n}\n```", "```cpp\n SDNode *AArch64DAGToDAGISel::Select(SDNode *Node) {\n…\n…\n  case ISD::ADD: {\n     if (SDNode *I = SelectMLAV64LaneV128(Node))\n       return I;\n    if (SDNode *I = SelectADDV(Node))\n return I;\n     break;\n  }\n}\n```", "```cpp\nSDNode *AArch64DAGToDAGISel::SelectADDV(SDNode *N) {\n  if (N->getValueType(0) != MVT::i32)\n    return nullptr;\n  SDValue SecondAdd;\n  SDValue FirstExtr;\n  if (!checkVectorElemAdd(N, SecondAdd, FirstExtr))\n    return nullptr;\n\n  SDValue Vector = FirstExtr.getOperand(0);\n  if (Vector.getValueType() != MVT::v4i32)\n    return nullptr;\n\n  uint64_t LaneMask = 0;\n  ConstantSDNode *LaneNode = cast<ConstantSDNode>(FirstExtr->getOperand(1));\n  LaneMask |= 1 << LaneNode->getZExtValue();\n\n  SDValue ThirdAdd;\n  SDValue SecondExtr;\n  if (!checkVectorElemAdd(SecondAdd.getNode(), ThirdAdd, SecondExtr))\n    return nullptr;\n  if (Vector != SecondExtr.getOperand(0))\n    return nullptr;\n  ConstantSDNode *LaneNode2 = cast<ConstantSDNode>(SecondExtr->getOperand(1));\n  LaneMask |= 1 << LaneNode2->getZExtValue();\n  SDValue LHS = ThirdAdd.getOperand(0);\n  SDValue RHS = ThirdAdd.getOperand(1);\n  if (LHS.getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n      RHS.getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n      LHS.getOperand(0) != Vector ||\n      RHS.getOperand(0) != Vector)\n    return nullptr;\n  ConstantSDNode *LaneNode3 = cast<ConstantSDNode>(LHS->getOperand(1));\n  LaneMask |= 1 << LaneNode3->getZExtValue();\n  ConstantSDNode *LaneNode4 = cast<ConstantSDNode>(RHS->getOperand(1));\n  LaneMask |= 1 << LaneNode4->getZExtValue();\n  if (LaneMask != 0x0F)\n    return nullptr;\n  return CurDAG->getMachineNode(AArch64::ADDVv4i32v, SDLoc(N), MVT::i32,\n                                Vector);\n}\n```", "```cpp\nstatic bool checkVectorElemAdd(SDNode *N, SDValue &Add, SDValue &Extr) {\n  SDValue Op0 = N->getOperand(0);\n  SDValue Op1 = N->getOperand(1);\n  const unsigned Opc0 = Op0->getOpcode();\n  const unsigned Opc1 = Op1->getOpcode();\n\n  const bool AddLeft  = (Opc0 == ISD::ADD && Opc1 == ISD::EXTRACT_VECTOR_ELT);\n  const bool AddRight = (Opc0 == ISD::EXTRACT_VECTOR_ELT && Opc1 == ISD::ADD);\n\n  if (!(AddLeft || AddRight))\n    return false;\n\n  Add  = AddLeft ? Op0 : Op1;\n  Extr = AddLeft ? Op1 : Op0;\n  return true;\n}\n```", "```cpp\n$ llc -mtriple=aarch64-linux-gnu -verify-machineinstrs hadd.ll\n\n```", "```cpp\n  mov  w8, v0.s[3]\n  mov  w9, v0.s[2]\n  add  w8, w8, w9\n  mov  w9, v0.s[1]\n  add  w8, w8, w9\n  fmov  w9, s0\n  add  w0, w8, w9\n  ret\n```", "```cpp\n  addv  s0, v0.4s\n  fmov  w0, s0\n  ret\n```", "```cpp\nSDNode *ResNode = SelectCode(Node);\n```", "```cpp\n$ cat test.ll\ndefine i32 @test(i32 %a, i32 %b, i32 %c) {\n%add = add nsw i32 %a, %b\n%div = sdiv i32 %add, %c\nret i32 %div\n}\n\n```", "```cpp\n$ llc –view-isel-dags test.ll\n\n```", "```cpp\n$ llc –view-sched-dags test.ll\n\n```", "```cpp\nfor (unsigned i = NumSkip; i != NodeOperands; ++i)\n    AddOperand(MIB, Node->getOperand(i), i-NumSkip+NumDefs, &II,\n               VRBaseMap, /*IsDebug=*/false, IsClone, IsCloned);\nMBB->insert(InsertPos, MIB); \n```", "```cpp\nif (!UsedRegs.empty() || II.getImplicitDefs())\n    MIB->setPhysRegsDeadExcept(UsedRegs, *TRI);\n```", "```cpp\nif (II.hasPostISelHook())\n    TLI->AdjustInstrPostInstrSelection(MIB, Node);\n```", "```cpp\n$ cat test.ll\ndefine i32 @test(i32 %a, i32 %b, i32 %c) {\n%add = add nsw i32 %a, %b\n%div = sdiv i32 %add, %c\nret i32 %div\n}\n\n```", "```cpp\nllc -print-machineinstrs test.ll > outfile 2>&1\n\n```", "```cpp\n# After Instruction Selection:\n# Machine code for function test: SSA\nFunction Live Ins: %EDI in %vreg0, %ESI in %vreg1, %EDX in %vreg2\nBB#0: derived from LLVM BB %0\n    Live Ins: %EDI %ESI %EDX\n        %vreg2<def> = COPY %EDX; GR32:%vreg2\n        %vreg1<def> = COPY %ESI; GR32:%vreg1\n        %vreg0<def> = COPY %EDI; GR32:%vreg0\n        %vreg3<def,tied1> = ADD32rr %vreg0<tied0>, %vreg1, %EFLAGS<imp-def,dead>; GR32:%vreg3,%vreg0,%vreg1\n        %EAX<def> = COPY %vreg3; GR32:%vreg3\n        CDQ %EAX<imp-def>, %EDX<imp-def>, %EAX<imp-use>\n        IDIV32r %vreg2, %EAX<imp-def>, %EDX<imp-def,dead>, %EFLAGS<imp-def,dead>, %EAX<imp-use>, %EDX<imp-use>; GR32:%vreg2\n        %vreg4<def> = COPY %EAX; GR32:%vreg4\n        %EAX<def> = COPY %vreg4; GR32:%vreg4\n        RETQ %EAX\n# End machine code for function test.\n```", "```cpp\n$ llc test.ll –regalloc=greedy –o test1.s\n$ cat test1.s\n .text\n .file  \"test.ll\"\n .globl  test\n .align  16, 0x90\n .type  test,@function\ntest:                                   # @test\n .cfi_startproc\n# BB#0:\n movl  %edx, %ecx\n leal  (%rdi,%rsi), %eax\n cltd\n idivl  %ecx\n retq\n.Lfunc_end0:\n .size  test, .Lfunc_end0-test\n .cfi_endproc\n .section  \".note.GNU-stack\",\"\",@progbits\n\n```", "```cpp\nmovl  %esi, %edx\nmovl  %edi, %eax\nleal  (%rax, %rdx), %eax.\n```", "```cpp\nllc test.ll -asm-show-inst -o -\n  .text\n  .file  \"test.ll\"\n  .globl  test\n  .align  16, 0x90\n  .type  test,@function\ntest:                                   # @test\n  .cfi_startproc\n# BB#0:\n  movl  %edx, %ecx              # <MCInst #1674 MOV32rr\n                                        #  <MCOperand Reg:22>\n                                        #  <MCOperand Reg:24>>\n  leal  (%rdi,%rsi), %eax       # <MCInst #1282 LEA64_32r\n                                        #  <MCOperand Reg:19>\n                                        #  <MCOperand Reg:39>\n                                        #  <MCOperand Imm:1>\n                                        #  <MCOperand Reg:43>\n                                        #  <MCOperand Imm:0>\n                                        #  <MCOperand Reg:0>>\n  cltd                            # <MCInst #388 CDQ>\n  idivl  %ecx                    # <MCInst #903 IDIV32r\n                                        #  <MCOperand Reg:22>>\n  retq                            # <MCInst #2465 RETQ\n                                        #  <MCOperand Reg:19>>\n.Lfunc_end0:\n  .size  test, .Lfunc_end0-test\n  .cfi_endproc\n\n  .section  \".note.GNU-stack\",\"\",@progbits\n```", "```cpp\n$ llc test.ll -show-mc-encoding -o -\n .text \n .file  \"test.ll\"\n .globl  test\n .align  16, 0x90\n .type  test,@function\ntest:                                   # @test\n .cfi_startproc\n# BB#0:\n movl  %edx, %ecx              # encoding: [0x89,0xd1]\n leal  (%rdi,%rsi), %eax       # encoding: [0x8d,0x04,0x37]\n cltd                            # encoding: [0x99]\n idivl  %ecx                    # encoding: [0xf7,0xf9]\n retq                            # encoding: [0xc3]\n.Lfunc_end0:\n .size  test, .Lfunc_end0-test\n .cfi_endproc\n\n .section  \".note.GNU-stack\",\"\",@progbits\n\n```"]