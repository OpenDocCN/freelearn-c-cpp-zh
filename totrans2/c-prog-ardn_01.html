<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Let's Plug Things</h1></div></div></div><p>Arduino<a id="id0" class="indexterm"/> is all about plugging things. We are going to do that in a couple of minutes after we have learned a bit more about microcontrollers in general and especially the big and amazing Arduino family. This chapter is going to teach you how to be totally ready to code, wire, and test things with your new hardware friend. Yes, this will happen soon, very soon; now let's dive in!</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is a microcontroller?</h1></div></div></div><p>A <strong>microcontroller</strong>
<a id="id1" class="indexterm"/> is an <strong>integrated circuit</strong> (<strong>IC</strong>)<a id="id2" class="indexterm"/> containing all main parts of a typical computer, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Processor</li><li class="listitem" style="list-style-type: disc">Memories</li><li class="listitem" style="list-style-type: disc">Peripherals</li><li class="listitem" style="list-style-type: disc">Inputs and outputs</li></ul></div><p>The <strong>processor</strong>
<a id="id3" class="indexterm"/>
<a id="id4" class="indexterm"/> is the brain, the part where all decisions are taken and which can calculate.</p><p>
<strong>Memories</strong>
<a id="id5" class="indexterm"/>
<a id="id6" class="indexterm"/> are often both spaces where both the core inner-self program and the user elements are running (generally called <strong>Read Only Memory</strong> (<strong>ROM</strong>)<a id="id7" class="indexterm"/> and <a id="id8" class="indexterm"/>
<strong>Random Access Memory</strong> (<strong>RAM</strong>)).</p><p>I define peripherals<a id="id9" class="indexterm"/>
<a id="id10" class="indexterm"/> by the self-peripherals contained in a global board; these are very different types of integrated circuits with a main purpose: to support the processor and to extend its capabilities.</p><p>Inputs<a id="id11" class="indexterm"/>
<a id="id12" class="indexterm"/>
<a id="id13" class="indexterm"/> and outputs<a id="id14" class="indexterm"/> are the ways of communication between the world (around the microcontroller) and the microcontroller itself.</p><p>The very first single-chip processor was built and proposed by Intel Corporation<a id="id15" class="indexterm"/> in 1971 under the name <strong>Intel 4004</strong>
<a id="id16" class="indexterm"/>. It was a 4-bit <a id="id17" class="indexterm"/>
<strong>central processing unit</strong> (<strong>CPU</strong>).</p><p>Since the 70s, things have evolved a lot and we have a lot of processors around us. Look around, you'll see your phone, your computer, and your screen. Processors or microprocessors drive almost everything.</p><p>Compared to microprocessors<a id="id18" class="indexterm"/>, microcontrollers provide a way to reduce power consumption, size, and cost. Indeed, microprocessors, even if they are faster than processors embedded in microcontrollers, require a lot of peripherals to be able to work. The high-level of integration provided by a microcontroller makes it the friend of embedded systems that are car engine controller, remote controller of your TV, desktop equipment including your nice printer, home appliances, games of children, mobile phones, and I could continue…</p><p>There are many families of microcontrollers that I cannot write about in this book, not to quote <strong>PICs</strong>
<a id="id19" class="indexterm"/> (<a class="ulink" href="http://en.wikipedia.org/wiki/PIC_microcontroller">http://en.wikipedia.org/wiki/PIC_microcontroller</a>) and <strong>Parallax SX</strong> microcontroller lines<a id="id20" class="indexterm"/>. I also want to quote a particular music hardware development open source project: <strong>MIDIbox</strong>
<a id="id21" class="indexterm"/> (PIC-, then STM32-based, check <a class="ulink" href="http://www.ucapps.de">http://www.ucapps.de</a>). This is a very strong and robust framework, very tweakable. The Protodeck controller<a id="id22" class="indexterm"/> (<a class="ulink" href="http://julienbayle.net/protodeck">http://julienbayle.net/protodeck</a>) is based on <a id="id23" class="indexterm"/>MIDIbox.</p><p>Now that you have understood you have a whole computer in your hands, let's specifically describe Arduino boards!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Presenting the big Arduino family</h1></div></div></div><p>Arduino<a id="id24" class="indexterm"/> is an open source<a id="id25" class="indexterm"/> (<a class="ulink" href="http://en.wikipedia.org/wiki/Open_source">http://en.wikipedia.org/wiki/Open_source</a>) singleboard-based microcontroller. It is a very popular platform forked from the <strong>Wiring</strong> platform<a id="id26" class="indexterm"/>
<a id="id27" class="indexterm"/> (<a class="ulink" href="http://www.wiring.org.co/">http://www.wiring.org.co/</a>) and firstly designed to popularize the use of electronics in interaction design university students' projects.</p><div><img src="img/7584_01_001.jpg" alt="Presenting the big Arduino family"/><div><p>My Arduino MEGA in my hand</p></div></div><p>It is <a id="id28" class="indexterm"/>based on the Atmel AVR processor<a id="id29" class="indexterm"/> (<a class="ulink" href="http://www.atmel.com/products/microcontrollers/avr/default.aspx">http://www.atmel.com/products/microcontrollers/avr/default.aspx</a>) and provides many inputs and outputs in only one self-sufficient piece of hardware. The official website for the project is <a class="ulink" href="http://www.arduino.cc">http://www.arduino.cc</a>.</p><p>The project was started in Italy in 2005 by founders Massimo Banzi and David Cuartielles. Today it is one of the most beautiful examples of the open source concept, brought to the hardware world and being often used only in the software world.</p><p>We talk about Arduino family because today we can count around 15 boards 'Arduino-based', which is a funny meta-term to define different type of board designs all made using an Atmel AVR processor. The main differences between those boards are the:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Type of processor</li><li class="listitem" style="list-style-type: disc">Number of inputs and outputs</li><li class="listitem" style="list-style-type: disc">Form factor</li></ul></div><p>Some Arduino boards<a id="id30" class="indexterm"/> are a bit more powerful, considering calculation speed, some other have more memory, some have a lot of inputs/outputs (check the huge Arduino Mega), some are intended to be integrated in more complex projects and have a very small form factor with very few inputs and outputs… as I used to tell my students <em>each one can find his friend in the Arduino family</em>. There are also boards that<a id="id31" class="indexterm"/> include peripherals like Ethernet Connectors or even Bluetooth modules, including antennas.</p><p>The magic behind this family is the fact we can use the same <strong>Integrated Development Environment</strong> (<strong>IDE</strong>)<a id="id32" class="indexterm"/> on our computers with any of those boards (<a class="ulink" href="http://en.wikipedia.org/wiki/Integrated_development_environment">http://en.wikipedia.org/wiki/Integrated_development_environment</a>). Some bits need to be correctly setup but this is the very same software and language we'll use:</p><div><img src="img/7584_01_002.jpg" alt="Presenting the big Arduino family"/><div><p>Some notable Arduino family members: Uno R3, LilyPad, Arduino Ethernet, Arduino Mega, Arduino Nano, Arduino Pro, and a prototyping shield</p></div></div><p>A very nice but non-exhaustive reference page about this can be found at <a class="ulink" href="http://arduino.cc/en/Main/Hardware">http://arduino.cc/en/Main/Hardware</a>.</p><p>I especially want you to check the following models:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Arduino Uno</strong> is the <a id="id33" class="indexterm"/>basic one with a replaceable chipset</li><li class="listitem" style="list-style-type: disc"><strong>Arduino Mega</strong>, 2560 provides<a id="id34" class="indexterm"/> a bunch of inputs and outputs</li><li class="listitem" style="list-style-type: disc"><strong>Arduino LilyPad</strong>, is<a id="id35" class="indexterm"/> wearable as clothes</li><li class="listitem" style="list-style-type: disc"><strong>Arduino Nano</strong>, is<a id="id36" class="indexterm"/> very small</li></ul></div><p>Throughout this book I'll use an Arduino Mega and Arduino Uno too; but don't be afraid, when you've mastered Arduino programming, you'll be able to use any of them!</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>About hardware prototyping</h1></div></div></div><p>We can program and build software <a id="id37" class="indexterm"/>quite easily today using a lot of open source frameworks for which you can find a lot of helpful communities on the Web. I'm thinking about <a id="id38" class="indexterm"/>
<strong>Processing</strong> (Java-based, check <a class="ulink" href="http://processing.org">http://processing.org</a>), and <strong>openFrameworks</strong>
<a id="id39" class="indexterm"/> (C++-based, check <a class="ulink" href="http://www.openframeworks.cc">http://www.openframeworks.cc</a>), but there are many others that sometimes use very different paradigms like graphical programming languages such as <strong>Pure Data</strong>
<a id="id40" class="indexterm"/> (<a class="ulink" href="http://puredata.info">http://puredata.info</a>), <strong>Max 6</strong>
<a id="id41" class="indexterm"/> (<a class="ulink" href="http://cycling74.com/products/max/">http://cycling74.com/products/max/</a>), or <strong>vvvv</strong>
<a id="id42" class="indexterm"/> (<a class="ulink" href="http://vvvv.org">http://vvvv.org</a>) for Windows.</p><p>Because we, the makers, are totally involved in do-it-yourself practices, we all want and need to build and design our own tools and it often means hardware and electronics tools. We want to extend our computers with sensors, blinking lights, and even create standalone gears.</p><p>Even for testing very basic things like blinking a <a id="id43" class="indexterm"/>
<strong>light emitting diode</strong> (<strong>LED</strong>), it involves many elements from supplying power to chipset low-level programming, from resistors value calculations to voltage-driven quartz clock setup. All those steps just gives headache to students and even motivated ones can be put off making just a first test.</p><p>Arduino appeared and changed everything in the landscape by proposing an inexpensive and all-included solution (we have to pay $30 for the Arduino Uno R3), a cross-platform toolchain running on Windows, OS X, and Linux, a very easy high-level C language and library that can also tweak the low-level bits, and a totally extensible open source framework.</p><p>Indeed, with an all-included small and cute board, an USB cable, and your computer, you can learn electronics, program embedded hardware using C language, and blink your LED.</p><p>Hardware prototyping became (almost) as easy as software prototyping because of the high level of integration between the software and the hardware provided by the whole framework.</p><p>One of the most important things to understand here is the prototyping cycle.</p><div><img src="img/7584_01_003.jpg" alt="About hardware prototyping"/><div><p>One easy hardware prototyping steps list</p></div></div><p>From our idea<a id="id44" class="indexterm"/> to our final render, we usually have to follow these steps.</p><p>If we want to make that<a id="id45" class="indexterm"/> LED blink, we have to define several blinking characteristics for instance. It will help to precisely define the project, which is a key to success.</p><p>Then we'll have to sketch a schematic with our Arduino board and our LED; it will dig the question, "How are they connected together?"</p><p>The firmware programming using C language can directly be started after we have sketched the circuit because, as we'll see later, it is directly related to the hardware. This is one of the strong powers of Arduino development. You remember? The board design has been designed only to make us think about our project and not to confuse us with very low-level abstract learning bits.</p><p>The upload step is a very important one. It can provide us a lot of information especially in case of further troubleshooting. We'll learn that this step doesn't require more than a couple of clicks once the board is correctly wired to our computer.</p><p>Then, the subcycle test and fix will occur. We'll learn by making, by testing, and it means by failing too. It is an important part of the process and it will teach you a lot. I have to confess something important here: at the time when I first began my <strong>bonome</strong> project<a id="id46" class="indexterm"/> (<a class="ulink" href="http://julienbayle.net/bonome">http://julienbayle.net/bonome</a>), an RGB monome clone device, I spent two hours fixing a reverse wired LED matrix. Now, I know them very well because I failed one day.</p><p>The last step is the coolest one. I mentioned it because we have to keep in our mind the final target, the one that will make us happy in the end; it is a secret to succeed!</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Understanding Arduino software architecture</h1></div></div></div><p>In order to understand how to make <a id="id47" class="indexterm"/>
<a id="id48" class="indexterm"/>our nice Arduino board work exactly as we want it to, we have to understand the global software architecture and the toolchain that we'll be using quite soon.</p><p>Take your Arduino board in hand. You'll see a rectangle-shaped IC with the word ATMEL<a id="id49" class="indexterm"/> written on the top; this is the processor.</p><p>This processor is the place that will contain the entire program that we'll write and that will make things happen.</p><p>When we buy (check <em>Appendix G, List of Components' Distributors</em>, and this link: <a class="ulink" href="http://arduino.cc/en/Main/Buy">http://arduino.cc/en/Main/Buy</a>) an Arduino, the processor, also named <em>chipset</em>, is preburnt. It has been programmed by careful people in order to make our life easier. The program already contained in the chipset is called the <strong>bootloader</strong>
<a id="id50" class="indexterm"/> (<a class="ulink" href="http://en.wikipedia.org/wiki/Booting">http://en.wikipedia.org/wiki/Booting</a>). Basically, it takes care of the very first moment of awakening of the processor life when you supply it some power. But its major role is the load of our firmware (<a class="ulink" href="http://en.wikipedia.org/wiki/Firmware">http://en.wikipedia.org/wiki/Firmware</a>), I mean, our precious compiled program.</p><p>Let's have a look at a small diagram for better understanding:</p><div><img src="img/7584_01_004.jpg" alt="Understanding Arduino software architecture"/></div><p>I like to define it by saying that <em>the bootloader is the hardware's software and the firmware is the user's software</em>. Indeed, it also has some significance because memory spaces in the chipset are not equal for write operations (within a specific hardware which we'll discuss in the future sections of this book). Using a <a id="id51" class="indexterm"/>
<strong>programmer</strong>, we cannot overwrite the bootloader (which is safer at this point of our reading) but only the firmware. This will be more than enough even for advanced purposed, as you'll see all along the book.</p><p>Not all Arduino boards' <a id="id52" class="indexterm"/>
<a id="id53" class="indexterm"/>bootloaders are equivalent. Indeed, they have been made to be very specific to the hardware part, which provides us more abstraction of the hardware; we can focus on higher levels of design because the bootloader provides us services such as firmware upload via USB and serial monitoring.</p><p>Let's now download some required software:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>FTDI USB drivers</strong>: <a class="ulink" href="http://www.ftdichip.com/Drivers/VCP.htm">http://www.ftdichip.com/Drivers/VCP.htm</a></li><li class="listitem" style="list-style-type: disc"><strong>Arduino IDE</strong>: <a class="ulink" href="http://arduino.cc/en/Main/Software">http://arduino.cc/en/Main/Software</a></li><li class="listitem" style="list-style-type: disc"><strong>Processing</strong>: <a class="ulink" href="http://processing.org/download/">http://processing.org/download/</a></li></ul></div><p><strong>Processing is used in this book but isn't necessary to program and use Arduino boards.</strong></p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>What is the Arduino's toolchain?</strong>
</p><p>Usually, we call Arduino's <strong>toolchain</strong>
<a id="id54" class="indexterm"/> a set of software tools required to handle all steps from the C code we are typing in the Arduino IDE on our computer to the firmware uploaded on the board. Indeed, the C code you type has to be prepared before the compilation step with avr-gcc and avr-g++ compilers. Once the resulting object's files are linked by some other programs of the toolchain, into usually only one file, you are done. This can later be uploaded to the board. There are other ways to use Arduino boards and we'll introduce that in the last chapter of this book.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Installing Arduino development environment (IDE)</h1></div></div></div><p>Let's find the compressed file downloaded from <a class="ulink" href="http://arduino.cc/en/Main/Software">http://arduino.cc/en/Main/Software</a> in the previous part and let's decompress it on our computer.</p><p>Whatever the platform, the IDE works equally and even if I'll describe some specific bits of three different platforms, I'll only describe the use of the IDE and show screenshots from OS X.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Installing the IDE</h2></div></div></div><p>There isn't a <a id="id55" class="indexterm"/>typical installation of the IDE because it runs into the <strong>Java Virtual Machine</strong>
<a id="id56" class="indexterm"/>. This means you only have to download it, to decompress it somewhere on your system, and then launch it and JAVA will execute the program. It is possible to use only the <a id="id57" class="indexterm"/>
<strong>CLI</strong> (<strong>command-line interface</strong>, the famous g33ks window in which you can type the command directly to the system) to build your binaries instead of the graphical interface, but at this point, I don't recommend this.</p><p>Usually, Windows and OS X come with Java installed. If that isn't the case, please install it from the <code class="literal">java.com</code> website page at <a class="ulink" href="http://www.java.com/en/download/">http://www.java.com/en/download/</a>.</p><p>On Linux, the process really depends on the distribution you are using, so I suggest to check the page <a class="ulink" href="http://www.arduino.cc/playground/Learning/Linux">http://www.arduino.cc/playground/Learning/Linux</a> and if you want to check and install all the environment and dependencies from sources, you can also check the page <a class="ulink" href="http://www.arduino.cc/playground/Linux/All">http://www.arduino.cc/playground/Linux/All</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How to launch the environment?</h2></div></div></div><p>In Windows, let's click on<a id="id58" class="indexterm"/> the <code class="literal">.exe</code> file included in the uncompressed folder. On OS X, let's click on the global self-contained package with the pretty Arduino logo. On Linux, you'll have to start the Arduino script from the GUI or by typing in the CLI.</p><p>You have to know that using the IDE you can do everything we will make in this book.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>What does the IDE look like?</h2></div></div></div><p>The IDE provides a<a id="id59" class="indexterm"/> graphical interface in which you can write your code, debug it, compile it, and upload it, basically.</p><div><img src="img/7584_01_005.jpg" alt="What does the IDE look like?"/><div><p>The famous Blink code example opened in the Arduino IDE</p></div></div><p>There are six icons from left to right that we have to know very well because we'll use them every time:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Verify</strong> (check symbol): This provides code checking for errors</li><li class="listitem" style="list-style-type: disc"><strong>Upload</strong> (right-side arrow): This compiles and uploads our code to the Arduino board</li><li class="listitem" style="list-style-type: disc"><strong>New</strong> (small blank page): This creates a new blank sketch</li><li class="listitem" style="list-style-type: disc"><strong>Open</strong> (up arrow): This opens a list of all sketches already existing in our sketchbook</li><li class="listitem" style="list-style-type: disc"><strong>Save</strong> (down arrow): This saves our sketch in our sketchbook</li><li class="listitem" style="list-style-type: disc"><strong>Serial Monitor</strong> (small magnifying glass): This provides the serial monitoring</li></ul></div><p>Each menu <a id="id60" class="indexterm"/>item in the top bar provides more options we will discover progressively all throughout this book.</p><p>However, the <strong>Tools</strong> menu deserves closer attention:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Auto Format</strong>: This provides code formatting with correct and standard indentations</li><li class="listitem" style="list-style-type: disc"><strong>Archive Sketch</strong>: This compresses the whole current sketch with all files</li><li class="listitem" style="list-style-type: disc"><strong>Board</strong>: This provides a list of all boards supported</li><li class="listitem" style="list-style-type: disc"><strong>Serial Port</strong>: This provides a list of all serial devices on the system</li><li class="listitem" style="list-style-type: disc"><strong>Programmer</strong>: This provides a list of all programmer devices supported and used in case of total reprogramming of the AVR chipset</li><li class="listitem" style="list-style-type: disc"><strong>Burn Bootloader</strong>: This is the option used when you want to overwrite (or even write) a new bootloader on your board.<div><img src="img/7584_01_006.jpg" alt="What does the IDE look like?"/><div><p>The Tools menu</p></div></div></li></ul></div><p>The preferences dialog is also a part we have to learn about right now. As usual, the preferences dialog is a place where we don't really need to go often but only for changing global parameters of the IDE. You can choose the sketchbook location and the Editor language in this dialog. You can also change a couple of bits like automatic check-up of IDE updates at start up or Editor font size.</p><p>The sketchbook <a id="id61" class="indexterm"/>concept will make our life easier. Indeed, the sketchbook is a folder where, basically, all your sketches will go. On my personal point of view, it is very precious to use it like this because it really organizes things for you and you can retrieve your pieces of code easier. Follow me there; you'll thank me later.</p><p>When we start a sketch from scratch, we basically type the code, verify it, upload it, and save it. By saving it, the first time, the IDE creates a folder in which it will put all the files related to our current sketch. By clicking on the sketch file inside this folder, the Arduino IDE will open and the related code will be displayed in the edit/typing part of the window.</p><p>We are almost done!</p><p>Let's install the drivers of the Arduino USB interface on our system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Installing Arduino drivers</h1></div></div></div><p>Arduino boards provide<a id="id62" class="indexterm"/>
<a id="id63" class="indexterm"/>
<a id="id64" class="indexterm"/> an USB interface. Before we plug the USB cable and link the board to our computer, we have to install specific drivers in the latter.</p><p>There is a huge difference between Windows and OS X here; basically, OS X doesn't require any specific drivers for Arduino Uno or even Mega 2560. If you are using older boards, you'd have to download the latest version of drivers on the FTDI website, double-click the package, then follow instructions, and finally, restart your computer.</p><p>Let's describe how it works on Windows-based systems, I mean, Windows 7, Vista, and XP.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Installing drivers for Arduino Uno R3</h2></div></div></div><p>It is important to follow<a id="id65" class="indexterm"/>
<a id="id66" class="indexterm"/> the steps mentioned next to be able to use the Arduino Uno R3 and some other boards. Please check the Arduino website for up-to-date references.</p><div><ol class="orderedlist arabic"><li class="listitem">Plug your board in and wait for Windows to begin the driver installation process. After a few moments, the process fails.</li><li class="listitem">Click on the Start menu, and open <strong>Control Panel</strong>.</li><li class="listitem">In <strong>Control Panel</strong>, navigate to <strong>System and Security</strong>. Next, click on <strong>System</strong>. Once the <strong>System</strong> window is up, open <strong>Device Manager</strong>.</li><li class="listitem">Look under <strong>Ports (COM &amp; LPT)</strong>. Check the open port named <strong>Arduino UNO (COMxx)</strong>.</li><li class="listitem">Right-click on <strong>the Arduino UNO (COMxx)</strong> port and choose the <strong>Update Driver Software</strong> option.</li><li class="listitem">Next, choose the <strong>Browse my computer for driver software</strong> option.</li><li class="listitem">Finally, navigate and select the Uno's driver file, named <code class="literal">ArduinoUNO.inf</code>, located in the <code class="literal">Drivers</code> folder of the Arduino software download (be careful: not the <code class="literal">FTDI USB Drivers</code> subdirectory).</li><li class="listitem">Windows will<a id="id67" class="indexterm"/><a id="id68" class="indexterm"/> finish the driver installation from there and everything will be fine.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Installing drivers for Arduino Duemilanove, Nano, or Diecimilla</h2></div></div></div><p>When you connect the <a id="id69" class="indexterm"/>
<a id="id70" class="indexterm"/>
<a id="id71" class="indexterm"/>
<a id="id72" class="indexterm"/>
<a id="id73" class="indexterm"/>
<a id="id74" class="indexterm"/>board, Windows should initiate the driver installation process (if you haven't used the computer with an Arduino board before).</p><p>On Windows Vista, the driver should be automatically downloaded and installed. (Really, it works!)</p><p>On Windows XP, the <strong>Add New Hardware</strong> wizard will open:</p><div><ol class="orderedlist arabic"><li class="listitem">When asked <strong>Can Windows connect to Windows Update to search for software?</strong> select <strong>No, not this time</strong>. Click on <strong>Next</strong>.</li><li class="listitem">Select <strong>Install from a list or specified location (Advanced)</strong> and click on <strong>Next</strong>.</li><li class="listitem">Make sure that <strong>Search for the best driver in these locations</strong> is checked, uncheck <strong>Search removable media</strong>, check <strong>Include this location in the search</strong>, and browse to the <strong>drivers/FTDI USB Drivers</strong> directory of the Arduino distribution. (The latest version of the drivers can be found on the <em>FTDI</em> website.) Click on <strong>Next</strong>.</li><li class="listitem">The wizard will search for the driver and then tell you that a <strong>USB Serial Converter</strong> was found. Click on <strong>Finish</strong>.</li><li class="listitem">The new hardware wizard will appear again. Go through the same steps and select the same options and location to search. This time, a <strong>USB Serial Port</strong> will be found.</li></ol></div><p>You can check that the drivers have been installed by opening <strong>Windows Device Manager</strong> (in the <strong>Hardware</strong> tab of the <strong>System</strong> control panel). Look for a <strong>USB Serial Port</strong> in the <strong>Ports</strong> section; that's the Arduino board.</p><p>Now, our <a id="id75" class="indexterm"/>
<a id="id76" class="indexterm"/>
<a id="id77" class="indexterm"/>
<a id="id78" class="indexterm"/>
<a id="id79" class="indexterm"/>
<a id="id80" class="indexterm"/>computer can recognize our Arduino board. Let's move to the physical world a bit to join together the tangible and intangible worlds.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>What is electricity?</h1></div></div></div><p>Arduino is all about<a id="id81" class="indexterm"/> electronic, and electronic refers to electricity. This may be your first dive into this amazing universe, made of wires and voltages, including blinking LEDs and signals. I'm defining several very useful notions in this part; you can consider turning down the corner of this page and to come back as often as you need.</p><p>Here, I'm using the usual analogy of <a id="id82" class="indexterm"/>water. Basically, wires<a id="id83" class="indexterm"/> are pipes<a id="id84" class="indexterm"/> and water is electricity itself.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Voltage</h2></div></div></div><p>
<strong>Voltage</strong> <a id="id85" class="indexterm"/>is a potential difference. Basically, this difference is created and maintained by a generator. This value is expressed in Volt units (the symbol is V).</p><p>The direct analogy with hydraulic systems compare the voltage to the difference of pressure of water in two points of a pipe. The higher the pressure, the faster the water moves, for a constant diameter of pipe of course.</p><p>We'll deal with low voltage all throughout this book, which means nothing more than 5 V. Very quickly, we'll use 12 V to supply motors and I'll precise that each time we do.</p><p>When you switch on the generator of closed circuits, it produces and keeps this potential difference. Voltage is a difference and has to be measured between two points on a circuit. We use voltmeters to measure the voltage.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Current and power</h2></div></div></div><p>
<strong>Current</strong> <a id="id86" class="indexterm"/>can be compared to the hydraulic volume flow rate, which is the volumetric quantity of flowing water over a time interval.</p><p>The current value is expressed in Ampères (the symbol is A). The higher the current, the higher will be the quantity of electricity moving.</p><p>A flow rate doesn't require two points to be measured as a difference of pressure; we only need one point of the circuit to make our measurement with an equipment named Ampere meter.</p><p>In all of our applications, we'll deal with <strong>direct current</strong> (<strong>DC</strong>)<a id="id87" class="indexterm"/>, which is different from <strong>alternative current</strong> (<strong>AC</strong>)<a id="id88" class="indexterm"/>.</p><p>
<strong>Power</strong> <a id="id89" class="indexterm"/>is a specific notion, which is expressed in Watt (the symbol is W).</p><p>Following is a mathematical relationship between voltage, current, and power:</p><p>P = V x I</p><p>where, P is the power in Watt, V the voltage in V, and I the current in<a id="id90" class="indexterm"/> Ampères.</p><p>Are you already feeling better? This analogy has to be understood as a proper analogy, but it really helps to understand what we'll make a bit later.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>And what are resistors, capacitors, and so on?</h2></div></div></div><p>Following the same analogy, <strong>resistors</strong>
<a id="id91" class="indexterm"/> are small components that slow down the flow of current. They are more resistive than any piece of wire you can use; they generally dissipate it as heat. They are two passive terminal components and aren't polarized, which means you can wire them in both directions.</p><p>Resistors are defined by their <em>electrical resistance</em> expressed in Ohms<a id="id92" class="indexterm"/> (the symbol is Ω).</p><p>There is a direct mathematical relation between voltage measured at the resistor sides, current, and resistance known as the Ohm's law:</p><p>R = V / I</p><p>where R the electrical resistance in Ohms, V the voltage in Volts<a id="id93" class="indexterm"/>, and I the current in Ampères.</p><p>For a constant value of voltage, if the resistance is high, the current is low and vice-versa. It is important to have that in mind.</p><p>On each resistor, there is a color code showing the resistance value.</p><p>There are many types of resistors. Some have a constant resistance, some others can provide different resistance values depending on physical parameters such as temperature, or light intensity for instance.</p><p>A <strong>potentiometer</strong>
<a id="id94" class="indexterm"/> is a variable resistor. You move a slider or rotate a knob and the resistance changes. I guess you begin to understand my point…</p><p>A <strong>capacitor</strong>
<a id="id95" class="indexterm"/> (or <strong>condenser</strong>) is another type of component used very often. The direct analogy is the rubber membrane put in the pipe: no water can pass through it, but water can move by stretching it.</p><p>They are also passive two-terminal components but can be polarized. Usually, small capacitors aren't.</p><p>We usually are saying that capacitors store potential energy by charging. Indeed, the rubber membrane itself stores energy while you stretch it; try to release the stretched membrane, it will find its first position.</p><p>Capacitance<a id="id96" class="indexterm"/> is the value defining each capacitor. It is expressed in Farads (the symbol is F).</p><p>We'll stop here about capacitance calculations because it involves advanced mathematics which isn't the purpose of this book. By the way, keep in mind the higher the capacitance, more will be the potential the capacitor can store.</p><p>A <strong>diode</strong>
<a id="id97" class="indexterm"/> is again a two-terminal passive component but is polarized. It lets the current pass through it only in one direction and stop it in the other. We'll see that even in the case of direct current, it can help and make our circuits safer in some cases.</p><p>LEDs are a specific type of diode. While the current passes through them in the correct direction, they glow. This is a nice property we'll use to check if our circuit is correctly closed in a few minutes.</p><p>
<strong>Transistor</strong> is the <a id="id98" class="indexterm"/>last item I'm describing here because it is a bit more complex, but we cannot talk about electronics without quoting it.</p><p>Transistors are semiconductor devices that can amplify and switch electronics signals and power, depending on how they are used. They are three-terminal components. This is the key active component of almost all modern electronics around us. Microprocessors are made of transistors and they can even contain more than 1 billion of them.</p><p>Transistors in the Arduino world are often used to drive high current, which couldn't pass through the Arduino board itself without burning it. In that case, we basically use them as analogue switches. When we need them to close a circuit of high currents to drive a motor for instance, we just drive one of their three terminals with a 5 V coming from the Arduino and the high current flows through it as if it had closed a circuit. In that case, it extends the possibilities of the Arduino board, making us able to drive higher currents with our little piece of hardware.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Wiring things and Fritzing</h2></div></div></div><p>With the previous analogy, we can <a id="id99" class="indexterm"/>understand well that a circuit needs to be closed in order to let the current flow.</p><p>Circuits<a id="id100" class="indexterm"/> are made with wires, which are basically conductors. A conductor is a matter with a resistance near to zero; it lets the current flow easily. Metals are usually good conductors. We often use copper wires.</p><p>In order to keep our wiring operations easy, we often use pins and headers. This is a nice way to connect things without using a soldering iron each time!</p><p>By the way, there are many ways to wire different components together. For our prototyping purpose, we won't design printed circuit board or even use our soldering iron; we'll use breadboards!</p><div><img src="img/7584_01_007.jpg" alt="Wiring things and Fritzing"/><div><p>A breadboard with its buses blue and red and its numerous perforations</p></div></div><p>Breadboards are the way to rapid prototyping and this is the way to go here.</p><p>Basically, breadboards<a id="id101" class="indexterm"/> consists of a piece of plastic with many perforations in which there are small pieces of conductors allowing to connect wires and components' leads inside.</p><p>The distance between two perforations is 2.54 mm (equal to 0.1") that is a standard; for instance, dual in-line package integrated circuits' leads are all separated by this particular distance and thus, you can even put IC on breadboards.</p><p>As we saw on the previous screenshot, there are buses and terminals strips.</p><p>
<strong>Buses</strong>
<a id="id102" class="indexterm"/> are series of five perforations in the central part and put in column for which the underlying conductors are connected. I have surrounded one bus with a green stroke.</p><p>
<strong>Terminals</strong> are <a id="id103" class="indexterm"/>special buses usually used for power supplying the circuit and appear in between blue and red lines. Usually, we use blue for ground lines and red for voltage source (5 V or 3.3 V in some cases). A whole line of terminals has its perforations all connected, providing voltage source and ground easily available on all the breadboard without having to use a lot of connection to the Arduino. I surrounded 2 of the 4 terminals with red and blue strokes.</p><p>Breadboards provide one of the easiest ways of prototyping without soldering. It also means you can use and reuse your breadboards throughout the years!</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>What is Fritzing?</h3></div></div></div><p>I discovered the open source <strong>Fritzing</strong> project (<a class="ulink" href="http://fritzing.org">http://fritzing.org</a>) when I needed a tool to make my first master classes slideshows schematic around the Protodeck controller (<a class="ulink" href="http://julienbayle.net/protodeck">http://julienbayle.net/protodeck</a>) I built in 2010.</p><p>Fritzing<a id="id104" class="indexterm"/> is defined as <em>an open source initiative to support designers, artists, researchers and hobbyists to work creatively with interactive electronics</em>. It sounds as if it had been made for us, doesn't it?</p><p>You can find the Fritzing's latest versions at <a class="ulink" href="http://fritzing.org/download/">http://fritzing.org/download/</a>.</p><p>Basically, with Fritzing, you can design and sketch electronic circuits. Because there are many representations of electronic circuits, this precious tool provides two of the classic ones and a PCB design tool too.</p><p>Considering the first practical work we are going to do, you have to take your breadboard, your Arduino, and wire the lead and the resistor exactly as it is shown in the next screenshot:</p><div><img src="img/7584_01_008.jpg" alt="What is Fritzing?"/><div><p>The breadboard view showing our first circuit</p></div></div><p>The <em>breadboard view</em> is the <a id="id105" class="indexterm"/>one that looks the most like what we have in front of us on the table. You represent all wires and you connect a virtual breadboard to your Arduino and directly plug components.</p><p>The magic lies in the fact that the schematic is automatically build while you are sketching in the breadboard view. And it works both ways! You can make a schematic, and Fritzing connect components in the breadboard view. Of course, you'd probably have to place the part in a more convenient or aesthetical way, but it works perfectly fine. Especially, the <strong>Autorouter</strong> helps you with making all wires more linear and simple.</p><p>In the next screenshot, you can see the same circuit as before, but shown in the <em>schematic view</em>:</p><div><img src="img/7584_01_009.jpg" alt="What is Fritzing?"/><div><p>The schematic view representing the circuit diagram</p></div></div><p>There are a lot of components already designed especially for Fritzing and you can even create yours quite easily. The page to visit for this purpose<a id="id106" class="indexterm"/> is <a class="ulink" href="http://fritzing.org/parts/">http://fritzing.org/parts/</a>.</p><p>The native library contains all parts required in all schematics of this book from all Arduino boards, to any discrete components and IC too. Indeed, all schematics of this book have been made using Fritzing!</p><p>Now that you know how to wire things without any soldering iron, and how to quietly sketch and check things on your computer before you do it for real on your desktop, let's learn a bit about power supply.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Power supply fundamentals</h2></div></div></div><p>We learned a bit more <a id="id107" class="indexterm"/>about electricity before, but how can I supply all my circuits in real life?</p><p>Arduino boards can be supplied in three different ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By our computer via the USB cable (5 V is provided)</li><li class="listitem" style="list-style-type: disc">By a battery or a direct external <a id="id108" class="indexterm"/><strong>Power Supply Unit</strong> (<strong>PSU</strong>) / Adapter</li><li class="listitem" style="list-style-type: disc">By attaching a regulated 5 V to the +5 V pin</li></ul></div><p>The <a id="id109" class="indexterm"/>USB cable <a id="id110" class="indexterm"/>contains four cables: two for data communication purpose and two for power supply. Those latter are basically used to supply Arduino when you are connecting it to the computer via USB.</p><p>USB is a special communication bus that provides 5 V but no more than 500 mA. (0.5 A) It means we have to use another supply source in special projects where we need a lot of LED, motors, and other devices that drive a lot of current.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>What adapter can I use with my Arduino?</strong>
</p><p>Arduino Uno and Mega can be directly supplied by DC Adapter but this one <em>has</em> to respect some characteristics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The output voltage should be between 9 V and 12 V</li><li class="listitem" style="list-style-type: disc">It should be able to drive at least 250 mA of current</li><li class="listitem" style="list-style-type: disc">It must have a 2.1 mm power plug with center positive</li></ul></div></div></div><p>Usually, if you ask yourself about the fact whether to use an adapter or not, it means you need more current than the USB's 500 mA (Practically, ask yourself this question whether you need around 400 mA).</p><p>Using USB or the 2.1 mm power plug with an adapter are the safest ways to use Arduino boards for many reasons. The main one is the fact that those two sources are (hopefully) clean, which means they deliver a regulated voltage.</p><p>However, you have to change something on the board if you want to use one or the other source: a jumper has to be moved to the right position:</p><div><img src="img/7584_01_015.jpg" alt="Power supply fundamentals"/><div><p>On the left, the jumper is set to USB power supply and on the right, it is set to external power supply</p></div></div><p>Usually, an idle Arduino board drains around 100 mA and, except in specified cases (see <a class="link" href="ch09.html" title="Chapter 9. Making Things Move and Creating Sounds">Chapter 9</a>, <em>Making Things Move and Creating Sounds</em>), we'll use the USB way of supply. This is what you have to do now: plug in the USB cable both in the Arduino and your computer.</p><p>Launch the Arduino IDE<a id="id111" class="indexterm"/> too, and let's move further to the hardware <em>Hello World</em> of our system, I call that the <em>Hello LED</em>!</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Hello LED!</h2></div></div></div><p>If your Arduino doesn't contain any firmware, the LED<a id="id112" class="indexterm"/> probably does nothing. If you check the built-in LED on the Arduino board itself, that one should blink.</p><p>Let's take the control over our external cute LED plugged in the breadboard right now.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>What do we want to do exactly?</h3></div></div></div><p>If you remember correctly, this is the first question we have to ask. Of course, we bypassed this step a bit especially about the hardware part because I had to explain things while you were wiring, but let's continue the prototyping process explained in part by checking the code and uploading it.</p><p>We want to make our LED blink. But what blink speed ? How much time? Let's say we want to make it blink every 250 ms with a one second pause between the blinks. And we want to do that infinitely.</p><p>If you check the schematic, you can understand that the LED is put between the ground, and the line to the digital output pin number 8.</p><p>There is a resistor and you now know that it can consume a bit of energy by resisting to the current flowing to the LED. We can say the resistor protects our LED.</p><p>In order to make the <a id="id113" class="indexterm"/>LED light up, we have to create a flow of current. Sending +5 V to the digital output number 8 can do this. That way, there will be a potential difference at the two leads of the LED, driving it to be lighted. But the digital output shouldn't be at +5 V at each time. We have to control the moment when it will provide this voltage. Still okay?</p><p>Let's summarize what we have to do:</p><div><ol class="orderedlist arabic"><li class="listitem">Put the 5 V to the digital output 8 during 250ms.</li><li class="listitem">Stop to drive the digital output 8 during 1s.</li><li class="listitem">Restart this every time the Arduino is powered</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>How can I do that using C code?</h3></div></div></div><p>If you followed the previous page correctly, you already have your Arduino board wired to the computer via your USB cable on one side, and wired to the breadboard on the other side.</p><p>Now, launch your Arduino IDE.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec01"/>Start with a new blank page</h4></div></div></div><p>If you already<a id="id114" class="indexterm"/> tested your IDE by loading some examples, or if you already wrote some piece of code, you have to click on the <em>New icon</em> in order to load a blank page, ready to host our <code class="literal">Blink250ms</code> code:</p><div><img src="img/7584_01_012.jpg" alt="Start with a new blank page"/><div><p>A nice and attractive blank page</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec02"/>Setting up the environment according the board we are using</h4></div></div></div><p>The IDE has to know <a id="id115" class="indexterm"/>with which board it will have to communicate. We will do it in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to the <strong>Tools</strong> menu and choose the correct board. The first one is <strong>Arduino Uno</strong>:<div><img src="img/7584_01_013.jpg" alt="Setting up the environment according the board we are using"/><div><p>Choose the board you are using</p></div></div></li><li class="listitem">Once we have done that, we have to choose the correct serial port. Go to the <strong>Tools</strong> menu again and choose the correct serial port:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On OS X, the correct one begins with <strong>/dev/tty.usbmodem</strong> for both Uno and Mega 2560 and with <strong>/dev/tty.usbserial</strong> for older boards.</li><li class="listitem" style="list-style-type: disc">On Windows, the correct port is usually <strong>COM3</strong> (<strong>COM1</strong> and <strong>COM2</strong> are often reserved by the operating system). By the way, it can also be <strong>COM4</strong>, <strong>COM5</strong>, or whatever else. To be sure, please check the device manager.</li><li class="listitem" style="list-style-type: disc">On Linux, the port is usually <strong>/dev/ttyUSB0</strong>:</li></ul></div><div><img src="img/7584_01_014.jpg" alt="Setting up the environment according the board we are using"/><div><p>Choose the serial port corresponding to your board</p></div></div></li></ol></div><p>Now, our IDE can talk to our board. Let's push the code now.</p></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec03"/>Let's write the code</h4></div></div></div><p>The following<a id="id116" class="indexterm"/> is the complete code. You can find it in the zip file in the <code class="literal">Chapter01/Blink250ms/</code> folder:</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><div><pre class="programlisting">/*
  Blink250ms Program
  Turns a LED connected to digital pin 8 on for 250ms, then off for 1s, infinitely.
  Written by Julien Bayle, this example code is Creative Commons CC-BY-SA
 */
 
// Pin 8 is the one connected to our LED
int ledPin = 8;                // ledPin is an integer variable initialized at 8

// --------- the setup routine runs once when you power up the board or push the reset switch
void setup() {                
  pinMode(ledPin, OUTPUT);     // initialize the digital pin as an output because we want it to source a current
}

// --------- the loop routine runs forever
void loop() {
  digitalWrite(ledPin, HIGH);   // turn the LED on (HIGH is a constant meaning a 5V voltage)
  delay(250);                   // wait for 250ms in the current state
  digitalWrite(ledPin, LOW);    // turn the LED off (LOW is a constant meaning a 5V voltage)
  delay(1000);                  // wait for 1s in the current state
}</pre></div><p>Let's comment it a bit. Indeed, we'll learn how to code our own C code in the next chapter, then I'll only describe this one and give you some small tips.</p><p>First, everything between <code class="literal">/*</code> and <code class="literal">*/</code>, and everything after <code class="literal">//</code> are just comments. The first form is used for comments more than one line at a time, and the other one is for one line commenting only. You can write any comments like that and they won't be considered by the compiler at all. I strongly advice you to comment your code; this is another key to succeed.</p><p>Then, the first part of the code contains one variable declaration and initialization:</p><div><pre class="programlisting">int ledPin = 8;                </pre></div><p>Then, we can see two particular structures between curly braces:</p><div><pre class="programlisting">void setup() {                
  pinMode(ledPin, OUTPUT);     
}
void loop() {
  digitalWrite(ledPin, HIGH);   
  delay(250);                   
  digitalWrite(ledPin, LOW);    
  delay(1000);                  
}</pre></div><p>The first one (<code class="literal">setup()</code>) is a <a id="id117" class="indexterm"/>function that is executed only one time when the Arduino board is started (or reseted); this is the place where we are telling the board that the pin where the LED is connected is an output, that is, this pin will have to drive current while activated.</p><p>The second one (<code class="literal">loop()</code>) is a function executed infinitely when the Arduino board is supplied. This is the main part of our code in which we can find the steps we wanted to light up the LED for 250 ms and switch off the LED for 1 s, repeatedly.</p></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Let's upload the code, at last!</h3></div></div></div><p>If you correctly<a id="id118" class="indexterm"/> followed and manipulated the hardware and the IDE as explained before, we are now ready to upload the code on the board.</p><p>Just click on the Upload button in the IDE. You'll see the TX and RX LEDs blinking a bit and … your LED on your breadboard should blink as expected. This is our very first <em>HELLO LED!</em> example and I hope you liked it.</p><p>If you want to tweak the code a bit, you can replace the following line:</p><div><pre class="programlisting">delay(1000);</pre></div><p>With the following line, for instance:</p><div><pre class="programlisting">delay(100);</pre></div><p>Now upload this new code again and see what happens.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter itself, we learnt a bit about Arduino and microcontrollers, and about electricity too. That will help us in the next chapters in which we will talk a lot about circuits.</p><p>We also installed the IDE that we will use every time while programming Arduino boards and we even tested the first piece of code. We are now able to continue our travel by learning more about the C language itself.</p></div></body></html>