<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Dynamic Memory Allocation" id="1GKCM1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Dynamic Memory Allocation</h1></div></div></div><p class="calibre9">In the previous chapter, we talked about class definitions and how to devise your own custom class. We discussed how by devising our own custom classes, we can construct variables that represented entities within your game or program.</p><p class="calibre9">In this chapter, we will talk about <a id="id280" class="calibre1"/>dynamic memory allocations and how to create space in memory for groups of objects.</p><p class="calibre9">Assume that we have a simplified version of <code class="email">class Player</code>, as before, with only a constructor and a destructor:</p><div class="note"><pre class="programlisting">class Player
{
  string name;
  int hp;
public:
  Player(){ cout &lt;&lt; "Player born" &lt;&lt; endl; }
  ~Player(){ cout &lt;&lt; "Player died" &lt;&lt; endl; }
};</pre></div><p class="calibre9">We talked earlier about the <span class="strong"><em class="calibre10">scope</em></span> of a variable in C++; to recap, the scope of a variable is the section of the program where that variable can be used. The scope of a variable is generally inside the block in which it was declared. A block is just any section of code contained between { and }. Here is a sample program that illustrates variable scope:</p><div class="mediaobject"><img src="../images/00071.jpeg" alt="Dynamic Memory Allocation" class="calibre11"/><div class="caption"><p class="calibre16">In this sample program, the x variable has scope through all of main(). The y variable's scope is only inside the if block</p></div></div><p class="calibre12"> </p><p class="calibre9">We mentioned previously<a id="id281" class="calibre1"/> that in general variables are destroyed when they go out of scope. Let's test this idea out with instances of <code class="email">class Player</code>:</p><div class="note"><pre class="programlisting">int main()
{
  Player player; // "Player born"
}                // "Player died" - player object destroyed here</pre></div><p class="calibre9">The output of this program is as follows:</p><div class="note"><pre class="programlisting">Player born
Player died</pre></div><p class="calibre9">The destructor for the player object is called at the end of the player object's scope. Since the scope of a variable is the block within which it is defined in the three lines of code, the <code class="email">Player</code> object would be destroyed immediately at the end of <code class="email">main()</code>, when it goes out of scope.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Dynamic Memory Allocation" id="1GKCM1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Dynamic memory allocation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec48" class="calibre1"/>Dynamic memory allocation</h1></div></div></div><p class="calibre9">Now, let's try <a id="id282" class="calibre1"/>allocating a <code class="email">Player</code> object dynamically. What does that mean?</p><p class="calibre9">We use the <code class="email">new</code> keyword to allocate it!</p><div class="note"><pre class="programlisting">int main()
{
  // "dynamic allocation" – using keyword new!
  // this style of allocation means that the player object will
  // NOT be deleted automatically at the end of the block where
  // it was declared!
Player *player = new Player();
} // NO automatic deletion!</pre></div><p class="calibre9">The output of this program is as follows:</p><div class="note"><pre class="programlisting">Player born</pre></div><p class="calibre9">The player does not die! How do we kill the player? We must explicitly call <code class="email">delete</code> on the <code class="email">player</code> pointer.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Dynamic Memory Allocation" id="1GKCM1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Dynamic memory allocation">
<div class="book" title="The delete keyword"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec80" class="calibre1"/>The delete keyword</h2></div></div></div><p class="calibre9">The <a id="id283" class="calibre1"/>
<code class="email">delete</code> operator invokes the destructor on the object being deleted, as shown in the following code:</p><div class="note"><pre class="programlisting">int main()
{
  // "dynamic allocation" – using keyword new!
  Player *player = new Player();
  delete player; // deletion invokes dtor
}</pre></div><p class="calibre9">The output of the program is as follows:</p><div class="note"><pre class="programlisting">Player born
Player died</pre></div><p class="calibre9">So, only "normal" (or "automatic" also called as non-pointer type) variable types get destroyed at the end of the block in which they were declared. Pointer types (variables declared with <code class="email">*</code> and <code class="email">new</code>) are not automatically destroyed even when they go out of scope.</p><p class="calibre9">What is the use of this? Dynamic allocations let you control when an object is created and destroyed. This <a id="id284" class="calibre1"/>will come in handy later.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Dynamic Memory Allocation" id="1GKCM1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Dynamic memory allocation">
<div class="book" title="Memory leaks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec81" class="calibre1"/>Memory leaks</h2></div></div></div><p class="calibre9">So dynamically allocated objects created with <code class="email">new</code> are not automatically deleted, unless you explicitly call <code class="email">delete</code> on them. There is a risk here! It is called a <a id="id285" class="calibre1"/>
<span class="strong"><em class="calibre10">memory leak</em></span>. Memory leaks <a id="id286" class="calibre1"/>happen when an object allocated with <code class="email">new</code> is not ever deleted. What can happen is that if a lot of objects in your program are allocated with <code class="email">new</code> and then you stop using them, your computer will run out of memory eventually due to memory leakage.</p><p class="calibre9">Here is a ridiculous sample program to illustrate the problem:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Player
{
  string name;
  int hp;
public:
  Player(){ cout &lt;&lt; "Player born" &lt;&lt; endl; }
  ~Player(){ cout &lt;&lt; "Player died" &lt;&lt; endl; }
};

int main()
{
  while( true ) // keep going forever,
  {
    // alloc..
    Player *player = new Player();
    // without delete == Memory Leak!
  }
}</pre></div><p class="calibre9">This program, if left to run long enough, will eventually gobble the computer's memory, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00072.jpeg" alt="Memory leaks" class="calibre11"/><div class="caption"><p class="calibre16">2 GB of RAM used for Player objects!</p></div></div><p class="calibre12"> </p><p class="calibre9">Note that no one ever<a id="id287" class="calibre1"/> intends to write a program with this type of problem in it! Memory leak problems happen accidentally. You must take care of your memory allocations and <code class="email">delete</code> objects that are no longer in use.</p></div></div></div>

<div class="book" title="Regular arrays" id="1HIT81-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec49" class="calibre1"/>Regular arrays</h1></div></div></div><p class="calibre9">An <a id="id288" class="calibre1"/>array in C++ can be declared as follows:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
int main()
{
  int array[ 5 ];  // declare an "array" of 5 integers
                   // fill slots 0-4 with values
array[ 0 ] = 1;
array[ 1 ] = 2;
array[ 2 ] = 3;
array[ 3 ] = 4;
array[ 4 ] = 5;
  // print out the contents
  for( int index = 0; index &lt; 5; index++ )
    cout &lt;&lt; array[ index ] &lt;&lt; endl;
}</pre></div><p class="calibre9">The way this looks in memory is something like this:</p><div class="mediaobject"><img src="../images/00073.jpeg" alt="Regular arrays" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">That is, inside<a id="id289" class="calibre1"/> the <code class="email">array</code> variable are five slots or elements. Inside each of the slots is a regular <code class="email">int</code> variable.</p></div>

<div class="book" title="Regular arrays" id="1HIT81-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="The array syntax"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec82" class="calibre1"/>The array syntax</h2></div></div></div><p class="calibre9">So, how do<a id="id290" class="calibre1"/> you access <a id="id291" class="calibre1"/>one of the <code class="email">int</code> values in the array? To access the individual elements of an array, we use square brackets, as shown in the following line of code:</p><div class="note"><pre class="programlisting">array[ 0 ] = 10;</pre></div><p class="calibre9">The preceding line of code would change the element at slot 0 of the array to a 10:</p><div class="mediaobject"><img src="../images/00074.jpeg" alt="The array syntax" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">In general, to get to a particular slot of an array, you will write the following:</p><div class="note"><pre class="programlisting">array[ slotNumber ] = value to put into array;</pre></div><p class="calibre9">Keep in mind that array slots are always indexed starting from 0. To get into the first slot of the array, use <code class="email">array[0]</code>. The second slot of the array is <code class="email">array[1]</code> (not <code class="email">array[2]</code>). The final slot of the array above is <code class="email">array[4]</code> (not <code class="email">array[5]</code>). The <code class="email">array[5]</code> data type<a id="id292" class="calibre1"/> is out of bounds of the array! (There is no slot with index 5 in the preceding diagram. The highest index is 4.)</p><p class="calibre9">Don't go out of bounds <a id="id293" class="calibre1"/>of the array! It might work some times, but other times your program will crash with a <a id="id294" class="calibre1"/>
<span class="strong"><strong class="calibre2">memory access violation</strong></span> (accessing memory that doesn't belong to your program). In general, accessing memory that does not belong to your program is going to cause your app to crash, and if it doesn't do so immediately, there will be a hidden bug in your program that only causes problems once in a while. You must always be careful when indexing an array.</p><p class="calibre9">Arrays are built into C++, that is, you don't need to include anything special to have immediate use of arrays. You can have arrays of any type of data that you want, for example, arrays of <code class="email">int</code>, <code class="email">double</code>, <code class="email">string</code>, and even your own custom object types (<code class="email">Player</code>).</p></div></div>

<div class="book" title="Regular arrays" id="1HIT81-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Exercise"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec83" class="calibre1"/>Exercise</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create <a id="id295" class="calibre1"/>an array of five strings and put inside it some names (made up or random, it doesn't matter).</li><li class="listitem" value="2">Create an array of doubles called <code class="email">temps</code> with three elements and store the temperature for the last three days in it.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Regular arrays" id="1HIT81-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Solutions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec84" class="calibre1"/>Solutions</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The following is<a id="id296" class="calibre1"/> a sample program with an array of five strings:<div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
  string array[ 5 ];  // declare an "array" of 5 strings
                      // fill slots 0-4 with values
array[ 0 ] = "Mariam McGonical";
array[ 1 ] = "Wesley Snice";
array[ 2 ] = "Kate Winslett";
array[ 3 ] = "Erika Badu";
array[ 4 ] = "Mohammad";
  // print out the contents
  for( int index = 0; index &lt; 5; index++ )
    cout &lt;&lt; array[ index ] &lt;&lt; endl;
}</pre></div></li><li class="listitem" value="2">The following <a id="id297" class="calibre1"/>is just the array:<div class="note"><pre class="programlisting">double temps[ 3 ];
// fill slots 0-2 with values
temps[ 0 ] = 0;
temps[ 1 ] = 4.5;
temps[ 2 ] = 11;</pre></div></li></ol><div class="calibre14"/></div></div></div>
<div class="book" title="C++ style dynamic size arrays (new[] and delete[])" id="1IHDQ1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec50" class="calibre1"/>C++ style dynamic size arrays (new[] and delete[])</h1></div></div></div><p class="calibre9">It probably <a id="id298" class="calibre1"/>occurred to you that we won't always know the size of an array at the start of a program. We would need to allocate the array's size dynamically.</p><p class="calibre9">However, if you've tried it, you might have noticed that this doesn't work!</p><p class="calibre9">Let's try and use the <code class="email">cin</code> command<a id="id299" class="calibre1"/> to take in an array size from the user. Let's ask the user how big he wants his array and try to create one for him of that size:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
int main()
{
  cout &lt;&lt; "How big?" &lt;&lt; endl;
  int size;       // try and use a variable for size..
  cin &gt;&gt; size;    // get size from user
  int array[ size ];  // get error: "unknown size"
}</pre></div><p class="calibre9">We get the following error:</p><div class="note"><pre class="programlisting">error C2133: 'array' : unknown size</pre></div><p class="calibre9">The problem is that the compiler wants to allocate the size of the array. However, unless the variable size is marked <code class="email">const</code>, the compiler will not be sure of its value at compile time. The C++ compiler cannot size the array at compile time, so it generates a compile time error.</p><p class="calibre9">To fix this, we have to allocate the array dynamically (on the "heap"):</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
int main()
{
  cout &lt;&lt; "How big?" &lt;&lt; endl;
  int size;       // try and use a variable for size..
  cin &gt;&gt; size;
  int *array = new int[ size ];  // this works
  // fill the array and print
for( int index = 0; index &lt; size; index++ )
{
  array[ index ] = index * 2;
  cout &lt;&lt; array[ index ] &lt;&lt; endl;
}
delete[] array; // must call delete[] on array allocated with 
                // new[]!
}</pre></div><p class="calibre9">So the lessons <a id="id300" class="calibre1"/>here are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">To allocate an array of some type (for example, <code class="email">int</code>) dynamically, you must use new <code class="email">int[numberOfElementsInArray]</code>.</li><li class="listitem">Arrays allocated with <code class="email">new[]</code><a id="id301" class="calibre1"/> must be later deleted with <code class="email">delete[]</code>, otherwise <a id="id302" class="calibre1"/>you'll get a memory leak! (that's <code class="email">delete[]</code> with square brackets! Not regular delete).</li></ul></div></div>
<div class="book" title="Dynamic C-style arrays" id="1JFUC1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec51" class="calibre1"/>Dynamic C-style arrays</h1></div></div></div><p class="calibre9">C-style arrays are a legacy topic, but they are still worth discussing since even though they are old, you might still see them used sometimes.</p><p class="calibre9">The way we declare a C-style array is as follows:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
int main()
{
  cout &lt;&lt; "How big?" &lt;&lt; endl;
  int size;       // try and use a variable for size..
  cin &gt;&gt; size;
  // the next line will look weird..
  int *array = <span class="strong"><strong class="calibre2">(int*)malloc( size*sizeof(int) ); // C-style</strong></span>
  // fill the array and print
for( int index = 0; index &lt; size; index++ )
  {
    array[ index ] = index * 2;
    cout &lt;&lt; array[ index ] &lt;&lt; endl;
  }
<span class="strong"><strong class="calibre2">free</strong></span>( array ); // must call free() on array allocated with 
               // malloc() (not delete[]!)
}</pre></div><p class="calibre9">The differences here are highlighted.</p><p class="calibre9">A C-style array<a id="id303" class="calibre1"/> is created using the<a id="id304" class="calibre1"/> <code class="email">malloc()</code> function. The word malloc stands for "memory allocate". This function requires you to pass in the size of the array in bytes to create and not just the number of elements you want in the array. For this reason, we multiply the number of elements requested (size) by <code class="email">sizeof</code> of the type inside the array. The size in bytes of a few typical C++ types is listed in the following table:</p><div class="note"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">C++ primitive type</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">sizeof (size in bytes)</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">int</code>
<a id="id305" class="indexterm"/>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">float</code>
<a id="id306" class="indexterm"/>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">double</code>
<a id="id307" class="indexterm"/>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">8</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">long long</code>
<a id="id308" class="indexterm"/>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">8</p>
</td></tr></tbody></table></div><p class="calibre9">Memory allocated with the <code class="email">malloc()</code> function must later be released using <code class="email">free()</code>.</p></div>
<div class="book" title="Summary" id="1KEEU1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This chapter introduced you to C and C++ style arrays. In most of the UE4 code, you will use the UE4 editor built in collection classes (<code class="email">TArray&lt;T&gt;</code>). However, you need familiarity with the basic C and C++ style arrays to be a very good C++ programmer.</p></div></body></html>