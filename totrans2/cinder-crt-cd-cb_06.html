<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Rendering and Texturing Particle Systems</h1></div></div></div><p>In this chapter we will learn about:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Texturing particles</li><li class="listitem" style="list-style-type: disc">Adding a tail to our particles</li><li class="listitem" style="list-style-type: disc">Creating a cloth simulation</li><li class="listitem" style="list-style-type: disc">Texturing a cloth simulation</li><li class="listitem" style="list-style-type: disc">Texturing the particle system using point sprites and shaders</li><li class="listitem" style="list-style-type: disc">Connecting particles</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Introduction</h1></div></div></div><p>Continuing from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>, we will learn how to render and apply textures to our particles in order to make them more appealing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Texturing particles</h1></div></div></div><p>In this recipe we will render particles<a id="id363" class="indexterm"/> introduced in the previous chapter using texture loaded from the PNG file.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec159"/>Getting started</h2></div></div></div><p>This recipe code base is an example of the recipe <em>Simulating particles flying on the wind</em> from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>. We also need a texture for a single particle. You can prepare one easily with probably any graphical program. For this example, we are going to use a PNG file with transparency stored inside the <code class="literal">assets</code> folder with a name, <code class="literal">particle.png</code>. In this case it is just a radial gradient with transparency.</p><div><img src="img/8703OS_06_01.jpg" alt="Getting started"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec160"/>How to do it…</h2></div></div></div><p>We will render particles using<a id="id364" class="indexterm"/> the previously created texture.</p><div><ol class="orderedlist arabic"><li class="listitem">Include the necessary header files:<div><pre class="programlisting">#include "cinder/gl/Texture.h"
#include "cinder/ImageIo.h"</pre></div></li><li class="listitem">Add a member to the application main class:<div><pre class="programlisting">gl::Texture particleTexture;</pre></div></li><li class="listitem">Inside the <code class="literal">setup</code> method load <code class="literal">particleTexture</code>:<div><pre class="programlisting">particleTexture=gl::Texture(loadImage(loadAsset("particle.png")));</pre></div></li><li class="listitem">We also have to change the particle size for this example:<div><pre class="programlisting">float radius = Rand::randFloat(2.f, 10.f);</pre></div></li><li class="listitem">At the end of the <code class="literal">draw</code> method we will draw our particles as follows:<div><pre class="programlisting">gl::enableAlphaBlending();
particleTexture.enableAndBind();
gl::color(ColorA::white());
mParticleSystem.draw();</pre></div></li><li class="listitem">Replace the <code class="literal">draw</code> method inside the <code class="literal">Particle.cpp</code> source file with the following code:<div><pre class="programlisting">void Particle::draw(){
ci::gl::drawSolidRect(ci::Rectf(position.x-radius, position.y-radius,
position.x+radius, position.y+radius));
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec161"/>How it works…</h2></div></div></div><p>In step 5, we saw two important lines. One enables alpha blending and the other binds our texture stored in the <code class="literal">particleTexture</code> property. If you look at step 6, you can see we drew each particle as a rectangle and each rectangle had texture applied. It is a simple<a id="id365" class="indexterm"/> way of texturing particles and not very performance effective, but in this case, it works quite well. It is possible to change the color of drawing particles by changing the color just before invoking the <code class="literal">draw</code> method on <code class="literal">ParticleSystem</code>.</p><div><img src="img/8703OS_06_02.jpg" alt="How it works…"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec162"/>See also</h2></div></div></div><p>Look into the recipe <em>Texturing the particle system using Point sprites and shaders</em></p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Adding a tail to our particles</h1></div></div></div><p>In this recipe, we will show you<a id="id366" class="indexterm"/> how to add a tail to the particle animation.<a id="id367" class="indexterm"/></p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec163"/>Getting started</h2></div></div></div><p>In this recipe we are going to use the code base from the recipe <em>Applying repulsion and attraction forces</em> from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec164"/>How to do it…</h2></div></div></div><p>We will add a tail to the particles using different techniques.</p><div><div><div><div><h3 class="title"><a id="ch06lvl4sec03"/>Drawing history</h3></div></div></div><p>Simply replace the <code class="literal">draw</code> method with the following code:</p><div><pre class="programlisting">void MainApp::draw()
{   
gl::enableAlphaBlending();
gl::setViewport(getWindowBounds());
gl::setMatricesWindow(getWindowWidth(), getWindowHeight());

gl::color( ColorA(0.f,0.f,0.f, 0.05f) );
gl::drawSolidRect(getWindowBounds());
gl::color( ColorA(1.f,1.f,1.f, 1.f) );
mParticleSystem.draw();
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl4sec04"/>Tail as a line</h3></div></div></div><p>We will add a tail constructed from several lines.<a id="id368" class="indexterm"/></p><div><ol class="orderedlist arabic"><li class="listitem">Add new properties to the <code class="literal">Particle</code> class inside the <code class="literal">Particle.h</code> header file:<div><pre class="programlisting">std::vector&lt;ci::Vec2f&gt; positionHistory;
int tailLength;</pre></div></li><li class="listitem">At the end of the <code class="literal">Particle</code> constructor, inside the <code class="literal">Particle.cpp</code> source file, set the default value to the <code class="literal">tailLength</code> property:<div><pre class="programlisting">tailLength = 10;</pre></div></li><li class="listitem">At the end of the <code class="literal">update</code> method of the <code class="literal">Particle</code> class add the following code:<div><pre class="programlisting">position History.push_back(position);
if(positionHistory.size() &gt;tailLength) {
positionHistory.erase( positionHistory.begin() );
}</pre></div></li><li class="listitem">Replace your <code class="literal">Particle::draw</code> method with the <a id="id369" class="indexterm"/>following code:<div><pre class="programlisting">void Particle::draw(){
  glBegin( GL_LINE_STRIP );
  for( int i=0; i&lt;positionHistory.size(); i++ ){
float alpha = (float)i/(float)positionHistory.size();
ci::gl::color( ci::ColorA(1.f,1.f,1.f, alpha));
ci::gl::vertex( positionHistory[i] );
  }
  glEnd();

ci::gl::color( ci::ColorA(1.f,1.f,1.f, 1.f) );
ci::gl::drawSolidCircle( position, radius );
}</pre></div></li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl2sec165"/>How it works…</h1></div></div></div><p>Now, we will explain how each <a id="id370" class="indexterm"/>technique works.<a id="id371" class="indexterm"/></p><div><div><div><div><h2 class="title"><a id="ch06lvl4sec05"/>Drawing history</h2></div></div></div><p>The idea behind this method is very<a id="id372" class="indexterm"/> simple, instead of clearing the drawing area, we are continuously drawing semi-transparent rectangles that cover old drawing states more and more. This very simple method can give you interesting effects with particles. You can also manipulate the opacity of each rectangle by changing the alpha channel of the rectangle color, which becomes a color of the background.</p><div><img src="img/8703OS_06_03.jpg" alt="Drawing history"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl4sec06"/>Tail as a line</h2></div></div></div><p>To draw a tail with lines, <a id="id373" class="indexterm"/>we have to store several particle positions and draw a line through these locations with variable opacity. The rule for opacity is just to draw older locations with less opacity. You can see the drawing code and alpha channel calculation in step 4</p><div><img src="img/8703OS_06_04.jpg" alt="Tail as a line"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Creating a cloth simulation</h1></div></div></div><p>In this recipe we will learn <a id="id374" class="indexterm"/>how to simulate cloth by creating a grid of particles connected by springs.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec166"/>Getting Ready</h2></div></div></div><p>In this recipe, we will be using the particle system described in the recipe <em>Creating a particle system in 2D</em> from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>.</p><p>We will also be using the <code class="literal">Springs</code> class created in the recipe <em>Creating springs </em>from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>.</p><p>So, you will need to add the following files to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Particle.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ParticleSystem.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring.cpp</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec167"/>How to do it…</h2></div></div></div><p>We will create a grid <a id="id375" class="indexterm"/>of particles connected with springs to create a cloth simulation.</p><div><ol class="orderedlist arabic"><li class="listitem">Include the particle system file in your project by adding the following code on top of your source file:<div><pre class="programlisting">#include "ParticleSystem.h"</pre></div></li><li class="listitem">Add the <code class="literal">using</code> statements before the application class declaration as shown in the following code:<div><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></li><li class="listitem">Create an instance of a <code class="literal">ParticleSystem</code> object and member variables to store the top corners of the grid. We will also create variables to store the number of rows and lines that make up our grid. Add the following code in your application class:<div><pre class="programlisting">ParticleSystem mParticleSystem;
  Vec2f mLeftCorner, 
mRightCorner;
  intmNumRows, mNumLines;</pre></div></li><li class="listitem">Before we start creating our particle grid, let's update and draw our particle system in our application's <code class="literal">update</code> and <code class="literal">draw</code> methods.<div><pre class="programlisting">Void MyApp::update(){
  mParticleSystem.update();
}

void MyApp::draw(){
  gl::clear( Color( 0, 0, 0 ) ); 
  mParticleSystem.draw();
}</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, let's initialize the grid corner positions and number of rows and lines. Add the following code at the top of the <code class="literal">setup</code> method:<div><pre class="programlisting">mLeftCorner = Vec2f( 50.0f, 50.0f );
mRightCorner = Vec2f( getWindowWidth() - 50.0f, 50.0f );
mNumRows = 20;
mNumLines = 15;</pre></div></li><li class="listitem">Calculate the distance between each particle on the grid.<div><pre class="programlisting">float gap = ( mRightCorner.x - mLeftCorner.x ) / ( mNumRows-1 );</pre></div></li><li class="listitem">Let's create a grid of evenly <a id="id376" class="indexterm"/>spaced particles and add them to <code class="literal">ParticleSystem</code>. We'll do this by creating a nested loop where each loop index will be used to calculate the particle's position. Add the following code in the <code class="literal">setup</code> method:<div><pre class="programlisting">for( int i=0; i&lt;mNumRows; i++ ){
for( int j=0; j&lt;mNumLines; j++ ){
float x = mLeftCorner.x + ( gap * i );
float y = mLeftCorner.y + ( gap * j );
Particle *particle = new Particle( Vec2f( x, y ), 5.0f, 5.0f, 0.95f );
mParticleSystem.addParticle( particle );
        }
    }</pre></div></li><li class="listitem">Now that the particles are created, we need to connect them with springs. Let's start by connecting each particle to the one directly below it. In a nested loop, we will calculate the index of the particle in <code class="literal">ParticleSystem</code> and the one below it. We then create a <code class="literal">Spring</code> class connecting both particles using their current distance as <code class="literal">rest</code> and a <code class="literal">strength</code> value of <code class="literal">1.0</code>. Add the following to the bottom of the <code class="literal">setup</code> method:<div><pre class="programlisting">for( int i=0; i&lt;mNumRows; i++ ){
for( int j=0; j&lt;mNumLines-1; j++ ){
int indexA = i * mNumLines + j;
int indexB = i * mNumLines + j + 1;
            Particle *partA = mParticleSystem.particles[ indexA ];
            Particle *partB = mParticleSystem.particles[ indexB ];
float rest = partA-&gt;position.distance( partB-&gt;position );
            Spring *spring = new Spring( partA, partB, rest, 1.0f );
mParticleSystem.addSpring( spring );
        }
    }</pre></div></li><li class="listitem">We now have a static grid made out of particles and springs. Let's add some gravity by applying a constant vertical force to each particle. Add the following code at the bottom of the <code class="literal">update</code> method:<div><pre class="programlisting">Vec2f gravity( 0.0f, 1.0f );
for( vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){
        (*it)-&gt;forces += gravity;
    }</pre></div></li><li class="listitem">To prevent the grid from falling down, we need to make the particles at the top edges static in their initial positions, defined by <code class="literal">mLeftCorner</code> and <code class="literal">mRightCorner</code>. Add the following code to the <code class="literal">update</code> method:<div><pre class="programlisting">int topLeftIndex = 0;
int topRightIndex = ( mNumRows-1 ) * mNumLines;
mParticleSystem.particles[ topLeftIndex ]-&gt;position = mLeftCorner;
mParticleSystem.particles[ topRightIndex ]-&gt;position = mRightCorner;</pre></div></li><li class="listitem">Build and run the application; you'll see a grid of particles falling down with gravity, locked by its top corners.<div><img src="img/8703OS_06_05.jpg" alt="How to do it…"/></div></li><li class="listitem">Let's add some interactivity <a id="id377" class="indexterm"/>by allowing the user to drag particles with the mouse. Declare a <code class="literal">Particle</code> pointer to store the particle being dragged.<div><pre class="programlisting">Particle *mDragParticle;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method initialize the particle to <code class="literal">NULL</code>.<div><pre class="programlisting">mDragParticle = NULL;</pre></div></li><li class="listitem">Declare the <code class="literal">mouseUp</code> and <code class="literal">mouseDown</code> methods in the application's class declaration.<div><pre class="programlisting">void mouseDown( MouseEvent event );
void mouseUp( MouseEvent event );</pre></div></li><li class="listitem">In the implementation of the <a id="id378" class="indexterm"/><code class="literal">mouseDown</code> event, we iterate the overall particles and, if a particle is under the cursor, we set <code class="literal">mDragParticle</code> to point to it.<div><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
for( vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){
        Particle *part = *it;
        float dist = part-&gt;position.distance( event.getPos() );
if( dist&lt; part-&gt;radius ){
mDragParticle = part;
return;
        }
    }
}</pre></div></li><li class="listitem">In the <a id="id379" class="indexterm"/><code class="literal">mouseUp</code> event <a id="id380" class="indexterm"/>we simply set <code class="literal">mDragParticle</code> to <code class="literal">NULL</code>.<div><pre class="programlisting">void MyApp::mouseUp( MouseEvent event ){
mDragParticle = NULL;
}</pre></div></li><li class="listitem">We need to check if <code class="literal">mDragParticle</code> is a valid pointer and set the particle's position to the mouse cursor. Add the following code to the <code class="literal">update</code> method:<div><pre class="programlisting">if( mDragParticle != NULL ){
mDragParticle-&gt;position = getMousePos();
    }</pre></div></li><li class="listitem">Build and run the application. Press and drag the mouse over any particle and drag it around to see how the cloth simulation reacts.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec168"/>How it works…</h2></div></div></div><p>The cloth simulation is<a id="id381" class="indexterm"/> achieved by creating a two dimensional grid of particles and connecting them with springs. Each particle will be connected with a spring to the ones next to it and to the ones above and below it.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec169"/>There's more…</h2></div></div></div><p>The density of the grid can be changed to accommodate the user's needs. Using a grid with more particles will generate a more precise simulation but will be slower.</p><p>Change <code class="literal">mNumLines</code> and <code class="literal">mNumRows</code> to change the number of particles that make up the grid.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Texturing a cloth simulation</h1></div></div></div><p>In this recipe, we will learn how to apply a texture to the cloth simulation we created in the <em>Creating a cloth simulation</em> recipe of the<a id="id382" class="indexterm"/> current chapter.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec170"/>Getting ready</h2></div></div></div><p>We will be using the cloth simulation developed in the recipe <em>Creating a cloth Simulation</em> as the base for this recipe.</p><p>You will also need an image to use as texture; place it inside your <code class="literal">assets</code> folder. In this recipe we will name our image <code class="literal">texture.jpg</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec171"/>How to do it…</h2></div></div></div><p>We will calculate the correspondent texture coordinate to each particle in the cloth simulation and apply a texture.</p><div><ol class="orderedlist arabic"><li class="listitem">Include the necessary files to work with the texture and read images.<div><pre class="programlisting">#include "cinder/gl/Texture.h"
#include "cinder/ImageIo.h"</pre></div></li><li class="listitem">Declare a <code class="literal">ci::gl::Texture</code> object in your application's class declaration.<div><pre class="programlisting">gl::Texture mTexture;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method load the image.<div><pre class="programlisting">mTexture = loadImage( loadAsset( "image.jpg" ) );</pre></div></li><li class="listitem">We will remake the <code class="literal">draw</code> method. So we'll erase everything in it which was changed in the <em>Creating a cloth simulation</em> recipe and apply the <code class="literal">clear</code> method. Your <code class="literal">draw</code> method should be like the following:<div><pre class="programlisting">void MyApp::draw(){
  gl::clear( Color( 0, 0, 0 ) );
}</pre></div></li><li class="listitem">After the <code class="literal">clear</code> method call, enable the <code class="literal">VERTEX</code> and <code class="literal">TEXTURE COORD</code> arrays and bind the texture. Add the following to the <code class="literal">draw</code> method:<div><pre class="programlisting">
glEnableClientState( GL_VERTEX_ARRAY );
glEnableClientState( GL_TEXTURE_COORD_ARRAY );
mTexture.enableAndBind();</pre></div></li><li class="listitem">We will now iterate over all particles and springs that make up the cloth simulation grid and draw a textured triangle strip between each row and the row next to it. Start by creating a <code class="literal">for</code> loop with <code class="literal">mNumRows-1</code> iterations and create two <code class="literal">std::vector&lt;Vec2f&gt;</code> containers to store vertex and texture coordinates.<div><pre class="programlisting">for( int i=0; i&lt;mNumRows-1; i++ ){
  vector&lt;Vec2f&gt;vertexCoords, textureCoords;
}</pre></div></li><li class="listitem">Inside the loop we will create a nested loop that will iterate over all lines in the cloth grid. In this<a id="id383" class="indexterm"/> loop we will calculate the index of the particles whose vertices will be drawn, calculate their correspondent texture coordinates, and add them with the positions of <code class="literal">textureCoords</code> and <code class="literal">vertexCoords</code>. Type the following code into the loop that we created in the previous step:<div><pre class="programlisting">or( int j=0; j&lt;mNumLines; j++ ){
 int indexTopLeft = i * mNumLines + j;
 int indexTopRight = ( i+1) * mNumLines + j;
 Particle *left = mParticleSystem.particles[ indexTopLeft ];
 Particle *right = mParticleSystem.particles[indexTopRight ];
 float texX = ( (float)i / (float)(mNumRows-1) ) * mTexture.getRight();
 float texY = ( (float)j / (float)(mNumLines-1) ) * mTexture.getBottom();
 textureCoords.push_back( Vec2f( texX, texY ) );
 vertexCoords.push_back( left-&gt;position );
 texX = ( (float)(i+1) / (float)(mNumRows-1) ) * mTexture.getRight();
 textureCoords.push_back( Vec2f( texX, texY ) );
 vertexCoords.push_back( right-&gt;position );
}</pre></div><p>Now that the <code class="literal">vertex</code> and <code class="literal">texture</code> coordinates are calculated and placed inside <code class="literal">vertexCoords</code> and <code class="literal">textureCoords</code> we will draw them. Here is the complete nested loop:</p><div><pre class="programlisting">for( int i=0; i&lt;mNumRows-1; i++ ){
 vector&lt;Vec2f&gt; vertexCoords, textureCoords;
 for( int j=0; j&lt;mNumLines; j++ ){
  int indexTopLeft = i * mNumLines + j;
  int indexTopRight = ( i+1) * mNumLines + j;
  Particle *left = mParticleSystem.particles[ indexTopLeft ];
  Particle *right = mParticleSystem.particles[ indexTopRight ];
  float texX = ( (float)i / (float)(mNumRows-1) ) * mTexture.getRight();
  float texY = ( (float)j / (float)(mNumLines-1) ) * mTexture.getBottom();
  textureCoords.push_back( Vec2f( texX, texY ) );
  vertexCoords.push_back( left-&gt;position );
  texX = ( (float)(i+1) / (float)(mNumRows-1) ) * mTexture.getRight();
  textureCoords.push_back( Vec2f( texX, texY ) );
  vertexCoords.push_back( right-&gt;position );
 }
 glVertexPointer 2, GL_FLOAT, 0, &amp;vertexCoords[0] );
 glTexCoordPointer( 2, GL_FLOAT, 0, &amp;textureCoords[0] );
 glDrawArrays( GL_TRIANGLE_STRIP, 0, vertexCoords.size() );
}</pre></div></li><li class="listitem">Finally we need to unbind <code class="literal">mTexture</code> by adding the following:<div><pre class="programlisting">mTexture.unbind();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec172"/>How it works…</h2></div></div></div><p>We calculated the <a id="id384" class="indexterm"/>correspondent texture coordinate according to the particle's position on the grid. We then drew our texture as triangular strips formed by the particles on a row with the particles on the row next to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Texturing a particle system using point sprites and shaders</h1></div></div></div><p>In this recipe, we<a id="id385" class="indexterm"/> will learn how<a id="id386" class="indexterm"/> to apply a texture to all our particles using OpenGL point sprites and a GLSL Shader.</p><p>This method is optimized and allows for a large number of particles to be drawn at fast frame rates.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec173"/>Getting ready</h2></div></div></div><p>We will be using the particle system developed in the recipe <em>Creating a particle system in 2D</em> from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>. So we will need to add the following files to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Particle.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ParticleSystem.h</code></li></ul></div><p>We will also be loading an image to use as texture. The image's size must be a power of two, such as 256 x 256 or 512 x 512. Place the image inside the <code class="literal">assets</code> folder and name it <code class="literal">particle.png</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec174"/>How to do it...</h2></div></div></div><p>We will create a GLSL shader and<a id="id387" class="indexterm"/> then enable OpenGL point sprites to draw <a id="id388" class="indexterm"/>textured particles.</p><div><ol class="orderedlist arabic"><li class="listitem">Let's begin by creating the GLSL Shader. Create the following files:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">shader.frag</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">shader.vert</code></li></ul></div><p>Add them to the <code class="literal">assets</code> folder.</p></li><li class="listitem">Open the file <code class="literal">shader.frag</code> in your IDE of choice and declare a <code class="literal">uniform sampler2D</code>:<div><pre class="programlisting">uniform sampler2D tex; </pre></div></li><li class="listitem">In the <code class="literal">main</code> function we use the texture to define the fragment color. Add the following code:<div><pre class="programlisting">void main (void) {
  gl_FragColor = texture2D(tex, gl_TexCoord[0].st) * gl_Color;
}</pre></div></li><li class="listitem">Open the <code class="literal">shader.vert</code> file and create <code class="literal">float attribute</code> to store the particle's radiuses. In the <code class="literal">main</code> method we define the position, color, and point size attributes. Add the following code:<div><pre class="programlisting">attribute float particleRadius;
void main(void)
{
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  gl_PointSize = particleRadius;
  gl_FrontColor = gl_Color;
}</pre></div></li><li class="listitem">Our shader is done! Let's go to our application source file and include the necessary files. Add the<a id="id389" class="indexterm"/> following code to your <a id="id390" class="indexterm"/>application source file:<div><pre class="programlisting">#include "cinder/gl/Texture.h"
#include "cinder/ImageIo.h"
#include "cinder/Rand.h"
#include "cinder/gl/GlslProg.h"
#include "ParticleSystem.h"</pre></div></li><li class="listitem">Declare the member variables to create a particle system and arrays to store the particle's positions and radiuses. Also declare a variable to store the number of particles.<div><pre class="programlisting">ParticleSystem mParticleSystem;
int mNumParticles;
Vec2f *mPositions;
float *mRadiuses;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, let's initialize <code class="literal">mNumParticles</code> to <code class="literal">1000</code> and allocate the arrays. We will also create the random particles.<div><pre class="programlisting">mNumParticles = 1000;
mPositions = new Vec2f[ mNumParticles ];
mRadiuses = new float[ mNumParticles ];

for( int i=0; i&lt;mNumParticles; i++ ){
 float x = randFloat( 0.0f, getWindowWidth() );
 float y = randFloat( 0.0f, getWindowHeight() );
 float radius = randFloat( 5.0f, 50.0f );
 Particle *particle = new Particle( Vec2f( x, y ), radius, 1.0f, 0.9f );
 mParticleSystem.addParticle( particle );
}
mParticleSystem.addParticle( particle );</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, <a id="id391" class="indexterm"/>we will update <code class="literal">mParticleSystem</code> and the <code class="literal">mPositions</code> and <code class="literal">mRadiuses</code> arrays. Add the following code to the <code class="literal">update</code> method:<div><pre class="programlisting">mParticleSystem.update();
for( int i=0; i&lt;mNumParticles; i++ ){
 mPositions[i] = mParticleSystem.particles[i]-&gt;position;
 mRadiuses[i] = mParticleSystem.particles[i]-&gt;radius;
}</pre></div></li><li class="listitem">Declare the shaders and the particle's texture.<div><pre class="programlisting">gl::Texture mTexture;
gl::GlslProg mShader;</pre></div></li><li class="listitem">Load the shaders and texture by adding the following code in the <code class="literal">setup</code> method:<div><pre class="programlisting">mTexture = loadImage( loadAsset( "particle.png" ) );
mShader = gl::GlslProg( loadAsset( "shader.vert"), loadAsset( "shader.frag" ) );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, <a id="id392" class="indexterm"/>we will start by clearing the background with black, set the window's matrices, enable the additive blend, and bind the shader.<div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );
gl::enableAdditiveBlending();
mShader.bind();</pre></div></li><li class="listitem">Get the location <a id="id393" class="indexterm"/>for the <code class="literal">particleRadius</code> attribute in the <code class="literal">Vertex</code> shader. Enable vertex attribute arrays and set the pointer to <code class="literal">mRadiuses</code>.<div><pre class="programlisting">GLint particleRadiusLocation = mShader.getAttribLocation( "particleRadius" );
glEnableVertexAttribArray(particleRadiusLocation);
glVertexAttribPointer(particleRadiusLocation, 1, GL_FLOAT, false, 0, mRadiuses);</pre></div></li><li class="listitem">Enable point sprites and enable our shader to write to point sizes.<div><pre class="programlisting">glEnable(GL_POINT_SPRITE);
glTexEnvi(GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE);
glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);	</pre></div></li><li class="listitem">Enable vertex arrays and set the vertex pointer to <code class="literal">mPositions</code>.<div><pre class="programlisting">glEnableClientState(GL_VERTEX_ARRAY);
glVertexPointer(2, GL_FLOAT, 0, mPositions);</pre></div></li><li class="listitem">Now enable and bind the texture, draw the vertex array as points, and unbind the texture.<div><pre class="programlisting">mTexture.enableAndBind();
glDrawArrays( GL_POINTS, 0, mNumParticles );
mTexture.unbind();</pre></div></li><li class="listitem">All we need to do now is disable the vertex arrays, disable the vertex attribute arrays, and unbind the shader.<div><pre class="programlisting">glDisableClientState(GL_VERTEX_ARRAY); 
glDisableVertexAttribArrayARB(particleRadiusLocation);
mShader.unbind();</pre></div></li><li class="listitem">Build and run the application and you will see <code class="literal">1000</code> random particles with the applied texture.<div><img src="img/8703OS_06_06.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec175"/>How it works…</h2></div></div></div><p>Point sprites is a nice feature of <a id="id394" class="indexterm"/>OpenGL that allows for the application of an entire texture to a single point. It is extremely useful when drawing particle <a id="id395" class="indexterm"/>systems and is quite optimized, since it reduces the amount of information sent to the graphics card and performs most of the calculations on the GPU.</p><p>In the recipe we also created a GLSL shader, a high-level programming language, that allows more control over the programming pipeline, to define individual point sizes for each particle.</p><p>In the <code class="literal">update</code> method we updated the <code class="literal">Positions</code> and <code class="literal">Radiuses</code> arrays, so that if the particles are animated the arrays will represent the correct values.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec176"/>There's more…</h2></div></div></div><p>Point sprites allow us to texturize<a id="id396" class="indexterm"/> points in 3D space. To draw <a id="id397" class="indexterm"/>the particle system in 3D do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">Particle</code> class described in the <em>There's more…</em> section of the recipe <em>Creating a Particle system in 2D</em> from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>.</li><li class="listitem">Declare and initialize <code class="literal">mPositions</code> as a <code class="literal">ci::Vec3f</code> array.</li><li class="listitem">In the <code class="literal">draw</code> method, indicate that the vertex pointer contains 3D information by applying the following change:<div><pre class="programlisting">glVertexPointer(2, GL_FLOAT, 0, mPositions);</pre></div><p>Change the previous code line to:</p><div><pre class="programlisting">glVertexPointer(3, GL_FLOAT, 0, mPositions);</pre></div></li><li class="listitem">The vertex shader needs to adjust the point size according to the depth of the particle. The <code class="literal">shader.vert</code> file would need to read the following code:<div><pre class="programlisting">attribute float particleRadius;

void main(void)
{
  vec4eyeCoord = gl_ModelViewMatrix * gl_Vertex;
  gl_Position = gl_ProjectionMatrix * eyeCoord;
  float distance = sqrt(eyeCoord.x*eyeCoord.x + eyeCoord.y*eyeCoord.y + eyeCoord.z*eyeCoord.z);
  float attenuation = 3000.0 / distance;
  gl_PointSize = particleRadius * attenuation;
  gl_FrontColor = gl_Color;
}</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Connecting the dots</h1></div></div></div><p>In this recipe we will show how to connect particles with lines and introduce another way of drawing particles.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec177"/>Getting started</h2></div></div></div><p>This recipe's code base is an<a id="id398" class="indexterm"/> example from the recipe <em>Simulating particles flying on the wind</em> (from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>), so please refer to this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec178"/>How to do it…</h2></div></div></div><p>We will connect particles rendered as circles with lines.</p><div><ol class="orderedlist arabic"><li class="listitem">Change the number of particles to create inside the <code class="literal">setup</code> method:<div><pre class="programlisting">int numParticle = 100;</pre></div></li><li class="listitem">We will calculate <code class="literal">radius</code> and <code class="literal">mass</code> of each particle as follows:<div><pre class="programlisting">float radius = Rand::randFloat(2.f, 5.f);
float mass = radius*2.f;</pre></div></li><li class="listitem">Replace the <code class="literal">draw</code> method inside the <code class="literal">Particle.cpp</code> source file with the following:<div><pre class="programlisting">void Particle::draw(){
 ci::gl::drawSolidCircle(position, radius);
 ci::gl::drawStrokedCircle(position, radius+2.f);
}</pre></div></li><li class="listitem">Replace the <code class="literal">draw</code> method inside the <code class="literal">ParticleSystem.cpp</code> source file as follows:<div><pre class="programlisting">void ParticleSystem::draw(){
 gl::enableAlphaBlending();
 std::vector&lt;Particle*&gt;::iterator it;
 for(it = particles.begin(); it != particles.end(); ++it){
  std::vector&lt;Particle*&gt;::iterator it2;
  for(it2=particles.begin(); it2!= particles.end(); ++it2){
   float distance = (*it)-&gt;position.distance( 
    (*it2)-&gt;position ));
   float per = 1.f - (distance / 100.f);
   ci::gl::color( ci::ColorA(1.f,1.f,1.f, per*0.8f) );
   ci::Vec2f conVec = (*it2)-&gt;position-(*it)-&gt;position;
   conVec.normalize();
   ci::gl::drawLine(
    (*it)-&gt;position+conVec * ((*it)-&gt;radius+2.f),
    (*it2)-&gt;position-conVec * ((*it2)-&gt;radius+2.f ));
  }
 }
 ci::gl::color( ci::ColorA(1.f,1.f,1.f, 0.8f) );
 std::vector&lt;Particle*&gt;::iterator it3;
 for(it3 = particles.begin(); it3!= particles.end(); ++it3){
  (*it3)-&gt;draw();
 }
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec179"/>How it works…</h2></div></div></div><p>The most interesting part<a id="id399" class="indexterm"/> of this example is mentioned in step 4. We are iterating through all the points, actually through all possible pairs of the points, to connect it with a line and apply the right opacity. The opacity of the line connecting two particles is calculated from the distance between these two particles; the longer distance makes the connection line more transparent.</p><div><img src="img/8703OS_06_07.jpg" alt="How it works…"/></div><p>Have a look at how the particles are been drawn in step 3. They are solid circles with a slightly bigger outer circle. The nice detail is the connection line that we are drawing between particles that stick to the edge of the outer circle, but don't cross it. We have done it in step 4, <a id="id400" class="indexterm"/>where we calculated the normalized vector of the vectors connecting two particles, then used them to move the attachment point towards that vector, multiplied by the outer circle radius.</p><div><img src="img/8703OS_06_08.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Connecting particles with spline</h1></div></div></div><p>In this recipe we<a id="id401" class="indexterm"/> are going to <a id="id402" class="indexterm"/>learn how to connect particles with splines in 3D.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec180"/>Getting started</h2></div></div></div><p>In this recipe we are going to use the particle's code base from the recipe <em>Creating a particle system</em>, from <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>. We are going to use the 3D version.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec181"/>How to do it…</h2></div></div></div><p>We will <a id="id403" class="indexterm"/>create splines <a id="id404" class="indexterm"/>connecting particles.</p><div><ol class="orderedlist arabic"><li class="listitem">Include the necessary header file inside <code class="literal">ParticleSystem.h</code>:<div><pre class="programlisting">#include "cinder/BSpline.h"</pre></div></li><li class="listitem">Add a new property to the <code class="literal">ParticleSystem</code> class:<div><pre class="programlisting">ci::BSpline3f spline;</pre></div></li><li class="listitem">Implement the <code class="literal">computeBSpline</code> method for the <code class="literal">ParticleSystem</code> class:<div><pre class="programlisting">void ParticleSystem::computeBspline(){ 
 std::vector&lt;ci::Vec3f&gt; splinePoints;
 std::vector&lt;Particle*&gt;::iterator it;
 for(it = particles.begin(); it != particles.end(); ++it ){
  ++it;
  splinePoints.push_back( ci::Vec3f( (*it)-&gt;position ) );
 }
 spline = ci::BSpline3f( splinePoints, 3, false, false );
}</pre></div></li><li class="listitem">At the end of the <code class="literal">ParticleSystem</code> update method, invoke the following code:<div><pre class="programlisting">computeBSpline();</pre></div></li><li class="listitem">Replace the <code class="literal">draw</code> method of <code class="literal">ParticleSystem</code> with the following:<div><pre class="programlisting">void ParticleSystem::draw(){
 ci::gl::color(ci::Color::black());
 if(spline.isUniform()) {
  glBegin(GL_LINES);
  float step = 0.001f;
  for( float t = step; t &lt;1.0f; t += step ) {
   ci::gl::vertex( spline.getPosition( t-step ) );
   ci::gl::vertex( spline.getPosition( t ) );
  } 
  glEnd();
 }
 ci::gl::color(ci::Color(0.0f,0.0f,1.0f));
 std::vector&lt;Particle*&gt;::iterator it;
 for(it = particles.begin(); it != particles.end(); ++it ){
  (*it)-&gt;draw();
 }
}</pre></div></li><li class="listitem">Add headers to your main Cinder application class files:<div><pre class="programlisting">#include "cinder/app/AppBasic.h"
#include "cinder/gl/Texture.h"
#include "cinder/Rand.h"
#include "cinder/Surface.h"
#include "cinder/MayaCamUI.h"
#include "cinder/BSpline.h"

#include "ParticleSystem.h"</pre></div></li><li class="listitem">Add members for your <code class="literal">main</code> class:<div><pre class="programlisting">ParticleSystem mParticleSystem;

float repulsionFactor;
float maxAlignSpeed;

CameraPersp        mCam;
MayaCamUI mMayaCam;

Vec3f mRepPosition;

BSpline3f   spline;</pre></div></li><li class="listitem">Implement <a id="id405" class="indexterm"/>the <a id="id406" class="indexterm"/><code class="literal">setup</code> method as follows:<div><pre class="programlisting">void MainApp::setup()
{
repulsionFactor = -1.0f;
maxAlignSpeed = 10.f;
mRepPosition = Vec3f::zero();

mCam.setPerspective(45.0f, getWindowAspectRatio(), 0.1, 10000);
mCam.setEyePoint(Vec3f(7.f,7.f,7.f));
mCam.setCenterOfInterestPoint(Vec3f::zero());
mMayaCam.setCurrentCam(mCam);
vector&lt;Vec3f&gt; splinePoints;
float step = 0.5f;
float width = 20.f;
for (float t = 0.f; t &lt; width; t += step) {
 float mass = Rand::randFloat(20.f, 25.f);
 float drag = 0.95f;
 splinePoints.push_back( Vec3f(math&lt;float&gt;::cos(t),
 math&lt;float&gt;::sin(t),
 t - width*0.5f) );
 Particle *particle;
 particle = new Particle( 
  Vec3f( math&lt;float&gt;::cos(t)+Rand::randFloat(-0.8f,0.8f),
   math&lt;float&gt;::sin(t)+Rand::randFloat(-0.8f,0.8f),
   t - width*0.5f), 
  1.f, mass, drag );
 mParticleSystem.addParticle( particle );
}
spline = BSpline3f( splinePoints, 3, false, false );
}</pre></div></li><li class="listitem">Add<a id="id407" class="indexterm"/> members<a id="id408" class="indexterm"/> for camera navigation:<div><pre class="programlisting">void MainApp::resize( ResizeEvent event ){
  mCam = mMayaCam.getCamera();
  mCam.setAspectRatio(getWindowAspectRatio());
  mMayaCam.setCurrentCam(mCam);
}

void MainApp::mouseDown(MouseEvent event){
  mMayaCam.mouseDown( event.getPos() );
}

void MainApp::mouseDrag( MouseEvent event ){
  mMayaCam.mouseDrag( event.getPos(), event.isLeftDown(), event.isMiddleDown(), event.isRightDown() );
}</pre></div></li><li class="listitem">Implement the <a id="id409" class="indexterm"/><code class="literal">update</code> method as follows:<div><pre class="programlisting">void MainApp::update() {
 float pos=math&lt;float&gt;::abs(sin(getElapsedSeconds()*0.5f));
 mRepPosition = spline.getPosition( pos );
 std::vector&lt;Particle*&gt;::iterator it;
 it = mParticleSystem.particles.begin();
 for(; it != mParticleSystem.particles.end(); ++it ) {
  Vec3f repulsionForce = (*it)-&gt;position - mRepPosition;
  repulsionForce = repulsionForce.normalized() *
   math&lt;float&gt;::max(0.f, 3.f-repulsionForce.length());
  (*it)-&gt;forces += repulsionForce;
  Vec3f alignForce = (*it)-&gt;anchor - (*it)-&gt;position;
  alignForce.limit(maxAlignSpeed);
  (*it)-&gt;forces += alignForce;
 }
 mParticleSystem.update();
}</pre></div></li><li class="listitem">Implement the <code class="literal">draw</code> method <a id="id410" class="indexterm"/>as follows:<div><pre class="programlisting">void MainApp::draw() {
 gl::enableDepthRead();
 gl::enableDepthWrite();
 gl::clear( Color::white() );
 gl::setViewport(getWindowBounds());
 gl::setMatrices(mMayaCam.getCamera());
 gl::color(Color(1.f,0.f,0.f));
 gl::drawSphere(mRepPosition, 0.25f);
 mParticleSystem.draw();
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec182"/>How it works…</h2></div></div></div><p><strong>B-spline</strong> lets us draw a very<a id="id411" class="indexterm"/> smooth curved line through some given points, in our case, particle positions. We can still apply some attraction and repulsion forces so that the line behaves quite like a spring. In Cinder, you can use B-splines in 2D and 3D space and calculate them with the <code class="literal">BSpline</code> class.</p><div><img src="img/8703OS_06_09.jpg" alt="How it works…"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec183"/>See also</h2></div></div></div><p>More details <a id="id412" class="indexterm"/>about<a id="id413" class="indexterm"/> <a id="id414" class="indexterm"/>B-spline are available at <a class="ulink" href="http://en.wikipedia.org/wiki/B-spline">http://en.wikipedia.org/wiki/B-spline</a>.</p></div></div></body></html>