<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Responding to Player Inputs</h1></div></div></div><p>Games by their very nature are interactive. They can respond to user input, unlike movies which play out exactly the same every time. So, you need a way to detect and respond to the user's input via mouse, keyboard, or gamepad. How can we accomplish this in our game? There<a id="id57" class="indexterm"/> are two options we can use for this: <strong>DirectInput</strong> and <strong>XInput</strong>.</p><p>In this <a id="id58" class="indexterm"/>chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">DirectInput versus XInput</li><li class="listitem" style="list-style-type: disc">Mouse and keyboard input</li><li class="listitem" style="list-style-type: disc">Using joysticks with DirectInput</li><li class="listitem" style="list-style-type: disc">Using joysticks with XInput</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>DirectInput versus XInput</h1></div></div></div><p>So, which <a id="id59" class="indexterm"/>of these two options should we use? The answer is possibly <a id="id60" class="indexterm"/>both. Why both, you ask? The reason is that we need to use <a id="id61" class="indexterm"/>DirectInput to support older input devices that don't <a id="id62" class="indexterm"/>support the new features of XInput. An <strong>input device</strong>
<a id="id63" class="indexterm"/> is any device that the user uses to provide input to the game, such as a mouse, keyboard, gamepad, and steering wheel.</p><p>We could just use DirectInput, but this approach has some limitations. DirectInput can handle XInput devices, but the left and right trigger buttons on a gamepad will be treated as a single button. One trigger is treated as the positive direction and the other as the negative direction. So, the two triggers are treated together as a single axis. DirectInput also does not support XInput vibration effects, and you cannot query for headset devices. On the flip side, we could just use XInput but then people with older DirectInput devices would not be able to play our game with them.</p><p>To support these features of newer input devices, we will need to use XInput along with DirectInput. This allows people with XInput devices to take advantage of their new features, while at the same time allowing users with older DirectInput devices to still be able to play our game with them. The players will undoubtedly appreciate this. So, what is the true <a id="id64" class="indexterm"/>difference between DirectInput and XInput? XInput is<a id="id65" class="indexterm"/> geared specifically towards Xbox 360 controllers and specialized <a id="id66" class="indexterm"/>Xbox 360 controllers, such as guitars. XInput supports a maximum of four controllers, each with no more than four axes, 10 buttons, two triggers, and an eight-directional digital pad.</p><p>XInput only really supports <em>next generation</em> controllers, and it does not support keyboards or mouse-type devices. DirectInput on the other hand is for all controllers and supports controllers with up to eight axes and 128 buttons.</p><p>So, the true answer to the question of whether to use DirectInput, XInput, or both, truly depends on the game you are developing. Just be aware that Microsoft essentially forces us to use XInput if we want to support some features of Xbox 360 and similar controllers in a PC game, as discussed earlier.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Mouse and keyboard input</h1></div></div></div><p>Even though players can play games using gamepads and other types of controllers, mouse and keyboard input are still quite important in PC game development. Some games have too many commands to map<a id="id67" class="indexterm"/> all of them on a gamepad, for example. When we assign an in-game action to a specific button on a keyboard, mouse, or gamepad, we say that we have mapped that action to that particular button. This is also sometimes referred to as <a id="id68" class="indexterm"/>binding, because we are, in effect, binding a certain key or button to a specific in-game action.</p><p>Let's first implement our mouse and keyboard input. Start Visual Studio and open the solution we <a id="id69" class="indexterm"/>worked on in the previous chapter. We are going to add a <a id="id70" class="indexterm"/>new class that will handle user input for us. Right-click on the <code class="literal">SlimFramework</code> project in the <strong>Solution Explorer</strong> pane and add a new class named <code class="literal">UserInput.cs</code>. We will make this class implement the <code class="literal">IDisposable</code> interface, just <a id="id71" class="indexterm"/>like we did with our <code class="literal">GameWindow.cs</code> class<a id="id72" class="indexterm"/> in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>. So, we need to change the class declaration from <code class="literal">public class UserInput</code> to <code class="literal">public class UserInput : IDisposable</code>.</p><p>We also need to add two <code class="literal">using</code> statements to the top of this class file. One for DirectInput and one for XInput:</p><div><pre class="programlisting">using SlimDX.DirectInput;
using SlimDX.XInput;</pre></div><p>Now, we are ready to set up the member variables for our new user input class. We'll create a member variables section just like we did in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>. Here is the code:</p><div><pre class="programlisting">bool m_IsDisposed = false;
DirectInput m_DirectInput;

Keyboard m_Keyboard;
KeyboardState m_KeyboardStateCurrent;
KeyboardState m_KeyboardStateLast;

Mouse m_Mouse;
MouseState m_MouseStateCurrent;
MouseState m_MouseStateLast;</pre></div><p>We have a<a id="id73" class="indexterm"/> handful of member variables here. The first one is <code class="literal">m_IsDisposed</code>, which has the same purpose as the <code class="literal">m_IsDisposed</code> member variable that we <a id="id74" class="indexterm"/>created in<a id="id75" class="indexterm"/> our <code class="literal">GameWindow</code> class. The <a id="id76" class="indexterm"/>second variable, <code class="literal">m_DirectInput</code>, will hold our DirectInput object.</p><p>Next, we have a group of three variables. The first one, <code class="literal">m_Keyboard</code>, holds the keyboard object. The next two keep track of the current and previous state of the keyboard. So, <code class="literal">m_KeyboardStateCurrent</code> holds the keyboard state for the current frame while <code class="literal">m_KeyboardStateLast</code> holds the keyboard state from the previous frame. Why do we need both? This is necessary, for example, if you want to detect whether or not the user is holding down a key, rather than simply pressing it.</p><p>Next, we have a set of three very similar variables for our mouse object and our current and previous mouse state (<code class="literal">m_Mouse</code>, <code class="literal">m_MouseStateCurrent</code>, and <code class="literal">m_MouseStateLast</code>).</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>The constructor</h2></div></div></div><p>Now, we need to <a id="id77" class="indexterm"/>create our constructor to initialize our user input <a id="id78" class="indexterm"/>object. Here is the code to do so:</p><div><pre class="programlisting">public UserInput()
{
  InitDirectInput();

  m_KeyboardStateCurrent = new KeyboardState();
  m_KeyboardStateLast = new KeyboardState();

  m_MouseStateCurrent = new MouseState();
  m_MouseStateLast = new MouseState();

}</pre></div><p>The first line calls the <a id="id79" class="indexterm"/>
<code class="literal">InitDirectInput()</code> method to initialize DirectInput for us. We will create this method in a second, but first we need to finish looking at the <code class="literal">UserInput()</code> method<a id="id80" class="indexterm"/>. The next two lines initialize our keyboard state variables with the empty <code class="literal">KeyboardState</code> objects. This is necessary to <a id="id81" class="indexterm"/>prevent a crash that would occur if the program tries to access these variables on the first frame (when they would be uninitialized, and therefore null, which would result in a <strong>Null Reference</strong> exception). This type of<a id="id82" class="indexterm"/> exception occurs when the program tries to access a variable<a id="id83" class="indexterm"/> that is null. You can't use an object before you initialize it, after all!</p><p>The last two lines do exactly the same thing, but this time for our mouse state variables.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Initializing DirectInput</h2></div></div></div><p>Now that<a id="id84" class="indexterm"/> our constructor is done, we need to create our <code class="literal">InitDirectInput()</code> method<a id="id85" class="indexterm"/>. It is a pretty short method, and<a id="id86" class="indexterm"/> here is the code:</p><div><pre class="programlisting">private void InitDirectInput()
{
  m_DirectInput = new DirectInput();

  // Create our keyboard and mouse devices.
  m_Keyboard = new Keyboard(m_DirectInput);
  m_Mouse = new Mouse(m_DirectInput);

}</pre></div><p>This method only has three lines of code at the moment. The first one creates and initializes our DirectInput object and stores it in our <code class="literal">m_DirectInput</code> member variable. The second line creates and initializes our keyboard object, storing it in our <code class="literal">m_Keyboard</code> member variable. The third line does the same thing, but for our mouse object, storing it in our <code class="literal">m_Mouse</code> member variable.</p><p>The fact that this method is short as it is, owes itself to SlimDX helping us out. If you were to write this same code in C++ and without SlimDX, it would be much longer and also a bit more cryptic. This is one of the things that makes SlimDX a great framework to work with. It takes care of some stuff behind the scenes for us, while still allowing us to leverage the full power of DirectX.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>The Update() method</h2></div></div></div><p>Now, we are going to add an <code class="literal">Update()</code> method<a id="id87" class="indexterm"/> to our user input class. This method will be called once per frame to get the latest user input data. We will be <a id="id88" class="indexterm"/>calling this method from the <code class="literal">UpdateScene()</code> method in <a id="id89" class="indexterm"/>our <code class="literal">GameWindow</code> class. Here is the code:</p><div><pre class="programlisting">public void Update()
{
  // Reacquire the devices in case another application has
  // taken control of them.
  m_Keyboard.Acquire();
  m_Mouse.Acquire();

  // Update our keyboard state variables.
  m_KeyboardStateLast = m_KeyboardStateCurrent;
  m_KeyboardStateCurrent = m_Keyboard.GetCurrentState();

  // Update our mouse state variables.
  m_MouseStateLast = m_MouseStateCurrent;
  m_MouseStateCurrent = m_Mouse.GetCurrentState();
}</pre></div><p>The first two lines of code reacquire the keyboard and mouse devices in case another application has taken control of them since the previous frame. We have to acquire the mouse and <a id="id90" class="indexterm"/>keyboard devices so that our program has access to them. As long as the device is acquired, DirectInput makes its data available to our program. Acquiring the device is not permanent however, which is why we do it at the beginning of the <code class="literal">UpdateScene()</code> method. This ensures that we have access to the keyboard and mouse devices before we try to use them in the next lines of code.</p><p>So, why is this acquisition mechanism needed? Firstly, DirectInput needs a way to tell our application if the flow of data from a device has been interrupted by the system. This would happen, for example, if the user switches to another application window using <em>Alt</em> + <em>Tab</em> and uses the same input device in that application.</p><p>The second reason this acquisition mechanism is needed is because our program can change the properties of a device. DirectInput requires us to release the device before changing its properties. This is done by calling its <code class="literal">Unacquire()</code> method. Then you would reacquire it<a id="id91" class="indexterm"/> once you've finished changing its properties. This ensures that the device is not being used when we're changing its properties as this could cause serious problems. Note that there is one exception to this rule, which is that you can change the gain of a force feedback device while it is acquired.</p><p>Back to our code. The next two lines update our keyboard state variables. First, the keyboard state that was current for the previous frame is copied from the <code class="literal">m_KeyboardStateCurrent</code> member variable into the <code class="literal">m_KeyboardStateLast</code> member variable. Then, we get the current keyboard state and store it in our <code class="literal">m_KeyboardStateCurrent</code> member variable.</p><p>The last two <a id="id92" class="indexterm"/>lines do the same thing, but with our mouse state member<a id="id93" class="indexterm"/> variables.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>The IDisposable interface</h2></div></div></div><p>As you'll recall <a id="id94" class="indexterm"/>from earlier in this chapter, we changed the declaration of the <code class="literal">UserInput</code> class to make it implement the <code class="literal">IDisposable</code> interface. We covered this<a id="id95" class="indexterm"/> interface in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>.</p><p>As you may recall, we must implement two methods. The <code class="literal">public void Dispose()</code> method<a id="id96" class="indexterm"/> is identical to the one we created in our <code class="literal">GameWindow</code> class. So, I will not show it here. On the other hand, the <code class="literal">protected void Dispose(bool)</code> method is different. Here is its code:</p><div><pre class="programlisting">protected virtual void Dispose(bool disposing)
{
  if (!this.m_IsDisposed)
  {
    if (disposing)
    {
      // Unregister events

      // get rid of managed resources here
      if (m_DirectInput != null)
      m_DirectInput.Dispose();

      if (m_Keyboard != null)
      m_Keyboard.Dispose();

      if (m_Mouse != null)
      m_Mouse.Dispose();
    }

    // get rid of unmanaged resources here

  }

  m_bDisposed = true;
}</pre></div><p>As you can see, the internal structure of this method is identical to the one we created in the <code class="literal">GameWindow</code> class. It has the same <code class="literal">if</code> statements inside it. The difference is that this time, we don't have an event to unhook, and we've added code to dispose of our DirectInput, keyboard, and mouse objects in the managed resources section of this method.</p><p>So, why is each of these objects disposed of inside its own little <code class="literal">if</code> statement? The reason for this is to prevent a potential crash that would happen if one of these objects is for some<a id="id97" class="indexterm"/> reason null. So, we check to see if the object is null. If it is not, then we dispose of it. Calling dispose on an object that is null will cause a Null Reference<a id="id98" class="indexterm"/> exception.</p><p>Now, we just have a few properties to add to our user input class. They are all very simple, and they just provide access to our member variables. Here are two of these properties. Check out the downloadable code for this chapter to see all of them.</p><div><pre class="programlisting">public bool IsDisposed
{
  get
  {
    return m_bDisposed;
  }
}

public Keyboard Keyboard
{
  get
  {
    return m_Keyboard;
  }
}</pre></div><p>With this class now finished, we just need to modify our <code class="literal">GameWindow</code> class to make use of it now.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Updating the GameWindow class</h2></div></div></div><p>The first thing <a id="id99" class="indexterm"/>we need to do now is add a <code class="literal">using</code> statement to <a id="id100" class="indexterm"/>the top of the <code class="literal">GameWindow.cs</code> file:</p><div><pre class="programlisting">using SlimDX.DirectInput;</pre></div><p>This will allow us to use the <code class="literal">Key</code> enumeration to specify which keys we want to check. Next, we need to add a new member variable to our <code class="literal">GameWindow</code> class. This variable will be called <code class="literal">m_UserInput</code> and it will contain our new <code class="literal">UserInput</code> object that we just finished creating. The declaration of this member variable looks like the following code:</p><div><pre class="programlisting">private UserInput m_UserInput;</pre></div><p>Next, we need to modify our constructor to create and initialize our user input object. To accomplish this, we simply add the following line of code to the end of our constructor, just above the closing <code class="literal">}</code>:</p><div><pre class="programlisting">m_UserInput = new UserInput();</pre></div><p>It is a good idea to add some member methods to our <code class="literal">UserInput</code> class to make handling user input a bit simpler for us. So, let's create a new method named <code class="literal">IsKeyPressed()</code>, which looks like the following code:</p><div><pre class="programlisting">public bool IsKeyPressed(Key key)
{
  return m_KeyboardStateCurrent.IsPressed(key);
}</pre></div><p>This method checks if the specified key is pressed, and returns <code class="literal">true</code> if it is or <code class="literal">false</code> if it is not. As you can see from the code in this method, the <code class="literal">KeyboardState</code> object has the <code class="literal">IsPressed()</code> method<a id="id101" class="indexterm"/> that we use to see if the specified key is pressed. It also has an <code class="literal">IsReleased()</code> method for testing if a key is not pressed. In <a id="id102" class="indexterm"/>addition to these, it has <code class="literal">PressedKeys</code> and <code class="literal">ReleasedKeys</code> properties that return a list of the currently pressed keys and currently not <a id="id103" class="indexterm"/>pressed keys respectively. And lastly, it has the <code class="literal">AllKeys</code> property<a id="id104" class="indexterm"/> that gives you the states of all keys on the <a id="id105" class="indexterm"/>keyboard.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>The downloadable code for this chapter contains some additional keyboard <a id="id106" class="indexterm"/>handling methods like this one. They are <code class="literal">IsKeyReleased()</code> and <code class="literal">IsKeyHeldDown()</code>.</p></div></div><p>There is now just one step left before we can see our keyboard input code in action. We need to add some code into our <code class="literal">UpdateScene()</code> method to check for some key presses. Here is the new <a id="id107" class="indexterm"/>code in the <code class="literal">UpdateScene()</code> method:</p><div><pre class="programlisting">public virtual void UpdateScene(double frameTime)
{
  // Get the latest user input.
  m_UserInput.Update();

  if (m_UserInput.IsKeyPressed(Key.Return) &amp;&amp;
    (m_UserInput.IsKeyPressed(Key.LeftAlt) ||
    m_UserInput.IsKeyPressed(Key.RightAlt)))
  {
    // Toggle fullscreen mode.
    ToggleFullscreen();
  }
  else if (m_UserInput.IsKeyPressed(Key.Escape))
  {
    // Close the program.
    m_Form.Close();
  }
}</pre></div><p>This code adds some basic keyboard commands to our window. The first <code class="literal">if</code> statement checks to see if the user is holding down the <em>Return</em> key along with either the left or right <em>Alt</em> key. If this<a id="id108" class="indexterm"/> is the case, then the <code class="literal">if</code> statement calls the <code class="literal">ToggleFullscreen()</code> method.</p><p>The <code class="literal">else if</code> clause checks to see if the user is pressing the <em>Esc</em> key. If so, then we close the game <a id="id109" class="indexterm"/>window, and the program terminates.</p><p>Before we can test run the program, we need to add a single line of code into the <code class="literal">GameWindow</code> class' <code class="literal">protected void Dispose(bool)</code> method. We need to add the following <a id="id110" class="indexterm"/>line of code into the managed resources section of the function:</p><div><pre class="programlisting">m_UserInput.Dispose();</pre></div><p>With that done, we can now test run the program. The game window looks identical to the way it did in the figure <em>The game window in action</em> in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>. However, you can now close it by pressing the <em>Esc</em> key.</p><p>If you press <em>Enter</em> + <em>Alt</em>, nothing will happen at the moment. As mentioned in the previous chapter, we can't toggle fullscreen mode yet since we are not using DirectX's graphics APIs yet. <strong>Application Programming Interface</strong> (<strong>API</strong>) simply refers collectively<a id="id111" class="indexterm"/> to all of the public methods and types that are made available by the API. For example, SlimDX is an API, as is DirectX.</p><p>Smaller parts of an API can sometimes be considered as APIs in their own right as well. For example, DirectX's DirectInput is an API in and of itself. DirectX is more like a collection of several different APIs for different purposes, as is SlimDX.</p><p>As you can see, keyboard input is fairly simple to implement with SlimDX. Mouse input, though we haven't really used any yet, is just as simple. Responding to mouse input is almost identical to doing so for keyboard input. Simply check the <code class="literal">X</code> and <code class="literal">Y</code> properties of the <code class="literal">MouseState</code> object to find out the mouse cursor's position. The <code class="literal">Z</code> property allows you to detect movement of the mouse's scroll wheel if it has one. If your mouse does not have a scroll wheel, then this property will simply return <code class="literal">0</code>. Note that the value of the <code class="literal">Z</code> property is a delta, or in other words it is the amount that the scroll wheel has moved since the last update. Lastly, you can use the <code class="literal">IsPressed()</code> and <code class="literal">IsReleased()</code> methods to detect if a given mouse button is pressed or released.</p><p>Note that<a id="id112" class="indexterm"/> the downloadable code for this chapter <a id="id113" class="indexterm"/>also includes mouse handling methods added into our <code class="literal">UserInput</code> class. These are <code class="literal">IsMouseButtonPressed()</code>, <code class="literal">IsMouseButtonReleased()</code>, <code class="literal">IsMouseButtonHeldDown()</code>, <code class="literal">MouseHasMoved()</code>, and <code class="literal">MousePosition()</code>, among others. The <code class="literal">IsMouseButtonHeld()</code> method can be used to implement clicking-and-dragging behavior while the <code class="literal">HasMouseMoved()</code> method returns <code class="literal">true</code> if the mouse has moved since the previous frame, or <code class="literal">false</code> otherwise.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Using joysticks with DirectInput</h1></div></div></div><p>Now, let's shift <a id="id114" class="indexterm"/>gears and take a look at using <strong>joysticks</strong>. In <a id="id115" class="indexterm"/>this book, we will use the term joystick to<a id="id116" class="indexterm"/> refer to any game controller. First, we will look at how to use joysticks with DirectInput.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Enumerating devices</h2></div></div></div><p>You've probably seen some games that let you choose which game controller you want to use if you <a id="id117" class="indexterm"/>have more than one attached to your PC. In this section, we <a id="id118" class="indexterm"/>are going to look at how to get the list of available devices. With SlimDX, it is actually quite easy.</p><p>The <code class="literal">DirectInput</code> object (remember that we stored it in our <code class="literal">m_DirectInput</code> member variable) has a method named <code class="literal">GetDevices()</code>. To get a list of the available controllers, we would call that method like this:</p><div><pre class="programlisting">m_DirectInput.GetDevices(DeviceClass.GameController, DeviceEnumerationFlags.AttachedOnly);</pre></div><p>To try this out, let's add a new method to our <code class="literal">UserInput.cs</code> class. This method will simply write some debug output about the available devices. Here is the code:</p><div><pre class="programlisting">public void GetJoysticks()
{
  IList&lt;DeviceInstance&gt; deviceList = m_DirectInput.GetDevices(DeviceClass.GameController, DeviceEnumerationFlags.AttachedOnly);
  if (deviceList.Count &lt; 1)
  {
    System.Diagnostics.Debug.WriteLine("NO GAME CONTROLLERS WERE FOUND!");
  }
  else
  {
    foreach (DeviceInstance device in deviceList)
    {
      System.Diagnostics.Debug.WriteLine("PRODUCT NAME: " + device.ProductName);
    }
  }
}</pre></div><p>First, we create a variable named <code class="literal">deviceList</code>, get the list of game controllers, and store it in this <a id="id119" class="indexterm"/>new variable. For the first parameter of the <code class="literal">GetDevices()</code> method, we pass in the value <code class="literal">DeviceClass.GameController</code> to tell it that we are only interested in game controllers. For the second parameter, we give it the value <code class="literal">DeviceEnumerationFlags.AttachedOnly</code> because we only want devices that are actually installed and connected to the PC.</p><p>Next, we have an <code class="literal">if</code> statement that checks to see if the list of game controllers is empty. If so, it prints a debug message to let you know that no game controllers are connected to your computer. In the <code class="literal">else</code> clause of this <code class="literal">if</code> statement, we have a <code class="literal">foreach</code> loop that iterates <a id="id120" class="indexterm"/>through the list of game controllers that we just <a id="id121" class="indexterm"/>retrieved and stored in the <code class="literal">deviceList</code> variable. Inside the <code class="literal">foreach</code> loop, we have a single line of code. This line simply writes a single line of debug output into Visual Studio's <strong>Output</strong> pane for each game controller in the list. The <strong>Output</strong> pane is generally found at the bottom of the Visual Studio window. You may have to click on the <strong>Output</strong> tab in the lower-left corner of the window to display it if autohide is on. You can also access it by going to the <strong>View</strong> menu and selecting <strong>Output</strong>.</p><p>By default, Visual Studio automatically displays the <strong>Output</strong> pane while you are running your program so that you can see your program's debug output, as shown in the following screenshot. If it does not show the <strong>Output</strong> pane, see the preceding paragraph for how to access it.</p><p>Next, go to the <a id="id122" class="indexterm"/>
<code class="literal">InitDirectInput()</code> method and add the following line of code to the end of the function:</p><div><pre class="programlisting">GetJoysticks();</pre></div><p>This makes a <a id="id123" class="indexterm"/>call to our new <code class="literal">GetJoysticks()</code> method at the end of the constructor. If you run this code now, you will see a list of game controllers displayed in Visual Studio's <strong>Output</strong> pane. The following screenshot shows what this looks like on my system, where I have one game controller connected to the computer:</p><div><img src="img/7389OS_02_01.jpg" alt="Enumerating devices"/><div><p>The Output pane showing our Debug output</p></div></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Your <a id="id124" class="indexterm"/>output from this code will most likely be <a id="id125" class="indexterm"/>different than mine. So, you will probably see a different list of controllers to what I have, so your output will likely differ from that shown in the preceding screenshot.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Getting input from the joystick</h1></div></div></div><p>This is all <a id="id126" class="indexterm"/>well and good, but we still can't get input from a<a id="id127" class="indexterm"/> joystick. So let's look at that now. First, we need to add three member variables for our joystick, just like we did for the mouse and keyboard. Here are the three new member variables we need to add to our <code class="literal">UserInput.cs</code> class:</p><div><pre class="programlisting">Joystick m_Joystick1;
JoystickState m_Joy1StateCurrent;
JoystickState m_Joy1StateLast;</pre></div><p>As before, we have a variable to hold our device object (in this case, a <code class="literal">Joystick</code> object), and two more variables to hold the joystick state for the current frame and for the previous frame.</p><p>Now, we need to add two lines at the bottom of our constructor to initialize the joystick state variables. As discussed earlier in this chapter, this prevents a crash from potentially happening. Add these two lines at the end of the constructor:</p><div><pre class="programlisting">m_Joy1StateCurrent = new JoystickState();
m_Joy1StateLast = new JoystickState();</pre></div><p>Now, let's modify our <a id="id128" class="indexterm"/>
<code class="literal">GetJoysticks()</code> method. We will simply make it use the first joystick in the returned list of controllers. Here is the new code for the <code class="literal">GetJoysticks()</code> method:</p><div><pre class="programlisting">public void GetJoysticks()
{
  IList&lt;DeviceInstance&gt; deviceList = m_DirectInput.GetDevices(DeviceClass.GameController, DeviceEnumerationFlags.AttachedOnly);

  for (int i = 0; i &lt; deviceList.Count; i++)
  {
    if (i == 0)
    {
      m_Joystick1 = new Joystick(m_DirectInput, deviceList[0].InstanceGuid);
      // Set the range to use for all of the axis on our game controller.
      m_Joystick1.Properties.SetRange(-1000, 1000);

    }
  }
}</pre></div><p>As you can<a id="id129" class="indexterm"/> see, we've also added a second line inside the <code class="literal">if</code> statement. This sets the minimum and maximum possible values for each axis on our <a id="id130" class="indexterm"/>game controller. In this case, we set it to <code class="literal">-1,000</code> and <code class="literal">1,000</code>. This means when the joystick is all the way to the left, its horizontal position is <code class="literal">-1,000</code>. When it is all the way to the right, its horizontal position is <code class="literal">1,000</code>. The same is true for the vertical axis. When the joystick is centered, its position will be (0,0). It is important to know the range of possible values to make our controls work correctly. You can get the range from the <code class="literal">Joystick.Properties.LowerRange</code> and <code class="literal">Joystick.Properties.UpperRange</code> properties. Note that these properties can throw an exception in some cases depending on your game controller's drivers and your DirectX version.</p><p>Now, we need <a id="id131" class="indexterm"/>to add a couple of lines of code into our <code class="literal">Update()</code> method to get the latest joystick data. To do this, we first need to add a line at the beginning of this method to acquire the joystick. You can't use a device without acquiring it first (see the <em>Mouse and keyboard input</em> section of this chapter for information on acquisition and why we need to do it). So, we will add the following line of code to acquire the joystick for us:</p><div><pre class="programlisting">m_Joystick1.Acquire();</pre></div><p>We are basically letting the system know that we wish to use the joystick now and get access to it. Now that we have gotten the access to the joystick, we need to add these two lines at the end of the <code class="literal">Update()</code> method:</p><div><pre class="programlisting">m_Joy1StateLast = m_Joy1StateCurrent;
m_Joy1StateCurrent = m_Joystick1.GetCurrentState();</pre></div><p>As we did with the mouse and keyboard, we do with our <code class="literal">Joystick</code> object too. We take the value of the <code class="literal">m_Joy1StateCurrent</code> member variable and copy it into the <code class="literal">m_Joy1StateLast</code> variable since this state data is now one frame old. Then we get the current joystick state and store it in the <code class="literal">m_Joy1StateCurrent</code> member variable.</p><p>Our user input class now supports the use of one joystick. You could support more by adding variables and code for the second joystick the same way we did for this first joystick. Now, let's add <a id="id132" class="indexterm"/>some test code at the end of the <code class="literal">Update()</code> method to see this in action:</p><div><pre class="programlisting">if (m_Joy1StateCurrent.IsPressed(0))
  System.Diagnostics.Debug.WriteLine("DIRECTINPUT: BUTTON 0 IS PRESSED!");
if (m_Joy1StateCurrent.IsPressed(1))
  System.Diagnostics.Debug.WriteLine("DIRECTINPUT: BUTTON 1 IS PRESSED!");
if (m_Joy1StateCurrent.IsPressed(2))
  System.Diagnostics.Debug.WriteLine("DIRECTINPUT: BUTTON 2 IS PRESSED!");
if (m_Joy1StateCurrent.IsPressed(3))
  System.Diagnostics.Debug.WriteLine("DIRECTINPUT: BUTTON 3 IS PRESSED!");</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>If you don't have a game controller, then you won't see any of the output from the previous code. The program would still work, but there would not be any debug output since there is no game controller to get it from.</p></div></div><p>This test <a id="id133" class="indexterm"/>code is a simple group of <code class="literal">if</code> statements. The first <code class="literal">if</code> statement checks if button <code class="literal">0</code> is pressed. If so, it writes a line of debug output to show <a id="id134" class="indexterm"/>you that it has detected the button press. The second <code class="literal">if</code> statement checks if button <code class="literal">1</code> is pressed, and if so, writes a debug message saying so. And the last two <code class="literal">if</code> statements do the same for buttons <code class="literal">2</code> and <code class="literal">3</code>.</p><p>So, why are we using numbers here? The reason is because each joystick button has an index that we use to refer to it. So for example, on my gamepad, button <code class="literal">0</code> is the <em>A</em> button.</p><p>We need to add two more lines of code to our <code class="literal">Dispose(bool)</code> method now. They will go in the managed resources section of the method. Here they are:</p><div><pre class="programlisting">if (m_Joystick1 != null)
  m_Joystick1.Dispose();</pre></div><p>This simply checks if the <code class="literal">Joystick</code> object is null. If not, then we dispose of it.</p><p>Run the program and press the buttons on your game controller. If you press the buttons <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>, or <code class="literal">3</code>, you will see some new lines of debug output appearing on Visual Studio's <strong>Output</strong> pane. When one of these buttons we coded for is pressed, its message appears multiple times. This is due to the speed at which the game loop is running. It is running super fast right now since it doesn't even have to render any graphics or simulate anything yet! The downloadable code for this chapter adds more <code class="literal">if</code> statements to cover more buttons than we did here. It also has some commented out lines for displaying the current positions of the left and right joysticks, and the position of the axis that is being used to represent the triggers (these are the buttons you can press in a little bit, all the way, or not at all, and they are usually found on the shoulders of a gamepad style controller).</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>You can detect when the user presses the thumbstick buttons the same way you do normal buttons on the gamepad, you just need to figure out which index represents each thumbstick button. This is not normally a problem since most games let the user bind game actions to whichever buttons or axes they want. In other words, you should generally never hardcode the controls in your game as they might not be correct or desirable for some players.</p></div></div><p>We've really <a id="id135" class="indexterm"/>only scratched the surface of using joysticks <a id="id136" class="indexterm"/>with DirectInput. Spend some time exploring the various properties of the <code class="literal">Joystick</code> object that we stored in our <code class="literal">m_Joystick1</code> member variable. You'll see that it has a lot of other properties we didn't use here. The <code class="literal">X</code> and <code class="literal">Y</code> properties, for example, will usually tell you what the left joystick is doing. The <code class="literal">RotationX</code> and <code class="literal">RotationY</code> properties will usually tell you the position of the right analog stick. A joystick has two axis as you can see. If the joystick is not moved at all, it is centered, so its position reading will be in the center of the ranges of both axis. If you push the joystick all the way to the right, it will be at its maximum value on its horizontal axis. If you push it up all the way, it will be at the minimum value for its vertical axis.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>You might expect the joystick's position to be (0,0) if you push it all the way up and left, but it isn't. This is because most joysticks have a circular range of movement and therefore the joystick will never be at the absolute upper-left corner of the movement range defined by its pair of axes.</p></div></div><p>The <code class="literal">Z</code> property will usually give you the value for the axis that represents the trigger buttons for gamepad style devices in most cases. If neither trigger is pressed, the value is in the middle of the range. If the left trigger is completely pressed, the <code class="literal">Z</code> property will have the maximum value for the axis, and of course if the right trigger is completely pressed, then <code class="literal">Z</code> will have the minimum value for the range of this axis. The range can vary and you can also modify stuff like this by messing with the <code class="literal">Properties</code> property of the <code class="literal">Joystick</code> object (remember that you have to release a device before you can change its properties). This range can vary from one controller to the next.</p><p>What about the Directional Pad though (often called a D-Pad for short)? How you handle these depends on how the controller reports it. Some may report the D-Pad as normal buttons, in which case it would be handled in the same way as normal buttons. Other controllers report the D-Pad as a POV (point of view) controller. In this case, you can access it using the <code class="literal">GetPointOfViewControllers()</code> method of the <code class="literal">JoystickState</code> object. It returns an <code class="literal">int</code> array. The first index represents the first POV controller on your game controller. The value of the first element of the array will change depending on which direction you are pressing. For mine, the first element has the value <code class="literal">0</code> when I press up, <code class="literal">9,000</code> when I press to the right, <code class="literal">18,000</code> when I press down, and <code class="literal">27,000</code> when I press to the left on the D-Pad.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Much of this can vary depending on the type of game controller you are using and how DirectInput sees it. So, you may have to play around with different properties in the <code class="literal">JoystickState</code> object (remember we stored ours in the <code class="literal">m_Joy1StateCurrent</code> member variable) to find what you need.</p></div></div><p>Feel free to experiment with the debug code we just added into the <code class="literal">Update()</code> method. Experimentation is a great way to learn new things. Sometimes, it's quicker than reading lots of boring<a id="id137" class="indexterm"/> documentation too! We won't fully cover <a id="id138" class="indexterm"/>DirectInput here as that could fill an entire book by itself.</p><p>The downloadable code for this chapter contains a bunch of handy joystick handling methods added to our <code class="literal">UserInput</code> class. They include <code class="literal">DI_LeftStickPosition()</code>, <code class="literal">DI_RightStickPosition</code>, and <code class="literal">DI_TriggersAxis()</code>, among others. <strong>DI</strong> is of course short for DirectInput. The <code class="literal">TriggersAxis()</code> method<a id="id139" class="indexterm"/> gets the current value of the axis that represents the triggers (discussed earlier). The joystick methods get the current position of the joysticks. For mine, each axis has a range of <code class="literal">0</code> to <code class="literal">65535</code>, and each joystick has two axes of course (horizontal and vertical). When the joystick is not pressed at all, its position will be in the center of both its horizontal and vertical axes.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>These methods may not work quite right with some devices since different game controllers are set up differently. It should work correctly for most gamepad style controllers though.</p></div></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Remember that you should really never hardcode the controls in your game. Players <a id="id140" class="indexterm"/>will be very annoyed if the controls <a id="id141" class="indexterm"/>are screwy or don't work on their particular game controller, and they find that they can't change them because you hardcoded the controls in your game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Using joysticks with XInput</h1></div></div></div><p>Once <a id="id142" class="indexterm"/>again, we first need to add some member variables <a id="id143" class="indexterm"/>for our XInput device. They look a bit different this time, but here they are:</p><div><pre class="programlisting">Controller m_Controller1;
Gamepad m_Controller1StateCurrent;
Gamepad m_Controller1StateLast;</pre></div><p>In XInput, we use the <code class="literal">Controller</code> class to represent a controller. The <code class="literal">Gamepad</code> structure stores the state of the controller. As before, we have one variable to hold our device, and two more to hold its current and previous state.</p><p>Now, we will <a id="id144" class="indexterm"/>add a very short new method named <code class="literal">InitXInput()</code>. Here is its code:</p><div><pre class="programlisting">private void InitXInput()
{
  m_Controller1 = new Controller(UserIndex.One);
}</pre></div><p>This code sets up one XInput controller for us to use. We pass into its constructor the value <code class="literal">UserIndex.One</code> to indicate that this controller will be used by player 1.</p><p>We need to modify the constructor of our user input class to call this new method now. We also need to add some code to initialize our XInput joystick state variables. As mentioned earlier, this is necessary to prevent the program from crashing. Here is what the constructor looks like now with the new bits of code highlighted:</p><div><pre class="programlisting">public UserInput()
{
  InitDirectInput();
<strong>  InitXInput();</strong>

  m_KeyboardStateCurrent = new KeyboardState();
  m_KeyboardStateLast = new KeyboardState();

  m_MouseStateCurrent = new MouseState();
  m_MouseStateLast = new MouseState();

  m_Joy1StateCurrent = new JoystickState();
  m_Joy1StateLast = new JoystickState();

<strong>  m_Controller1StateCurrent = new Gamepad();</strong>
<strong>  m_Controller1StateLast = new Gamepad();</strong>
}</pre></div><p>Now, we must add the following code to the end of the <code class="literal">Update()</code> method in our user input class:</p><div><pre class="programlisting">m_Controller1StateLast = m_Controller1StateCurrent;
m_Controller1StateCurrent = m_Controller1.GetState().Gamepad;"
if (XI_IsButtonPressed(GamepadButtonFlags.A))
  System.Diagnostics.Debug.WriteLine("XINPUT: THE A BUTTON IS PRESSED!!");
if (XI_IsButtonPressed(GamepadButtonFlags.B))
  System.Diagnostics.Debug.WriteLine("XINPUT: THE B BUTTON IS PRESSED!!");
if (XI_IsButtonPressed(GamepadButtonFlags.X))
  System.Diagnostics.Debug.WriteLine("XINPUT: THE X BUTTON IS PRESSED!!");
if (XI_IsButtonPressed(GamepadButtonFlags.Y))
  System.Diagnostics.Debug.WriteLine("XINPUT: THE Y BUTTON IS PRESSED!!");</pre></div><p>This code is very similar to our DirectInput joystick test code. It copies the state data from the previous frame into the <code class="literal">m_Controller1StateLast</code> member variable, and then gets the <a id="id145" class="indexterm"/>current controller state and stores it in the <code class="literal">m_Controller1StateCurrent</code> variable.</p><p>The <code class="literal">if</code> statements are just like the ones we used to test our DirectInput joystick code. The first <a id="id146" class="indexterm"/>one checks if the <em>A</em> button is pressed. If so, it prints a debug message saying so in Visual Studio's <strong>Output</strong> pane. The second <code class="literal">if</code> statement does this for the <em>B</em> button, and the last two <code class="literal">if</code> statements do the same for the <em>X</em> and <em>Y</em> buttons.</p><p>You may have noticed that we didn't have to <em>acquire</em> the XInput controller at the beginning of the <code class="literal">Update()</code> method like we do with the mouse, keyboard, and joysticks under DirectInput. Instead, we simply set up the XInput controller in our <code class="literal">InitXInput()</code> method<a id="id147" class="indexterm"/>. You may also have noticed that we didn't need to add code in our <code class="literal">Dispose(bool)</code> method to dispose of the XInput controller object either. It doesn't even have a <a id="id148" class="indexterm"/>
<code class="literal">Dispose()</code> method.</p><p>We are now ready to test our new code. You will need an XInput compatible controller to test it. If you don't have one, this code will still run, but it just won't do anything since there's no XInput controller for it to get input from.</p><p>If you have a controller that supports XInput, you may see dual output from this code because both the DirectInput and the XInput test code will be outputting debug messages to Visual Studio's <strong>Output</strong> pane at the same time (if both are reading input from the same controller), as shown in the following screenshot:</p><div><img src="img/7389OS_02_02.jpg" alt="Using joysticks with XInput"/><div><p>DirectInput and XInput both reading input from the same device</p></div></div><p>We have<a id="id149" class="indexterm"/> once again only really scratched the surface <a id="id150" class="indexterm"/>here. There is more to XInput than what we've looked at. For example, you can get the state of the left and right sticks by accessing the <code class="literal">LeftThumbX</code> and <code class="literal">LeftThumbY</code> properties for the left stick, and the <code class="literal">RightThumbX</code> and <code class="literal">RightThumbY</code> properties for the right stick. Note that the range for joystick axis values in XInput is always <code class="literal">-32,768</code> to <code class="literal">32,767</code>.</p><p>You also may have noticed that we didn't add properties to the user input class to provide access to our joystick objects. They would be just as simple as the properties we added in this chapter, so they've simply been omitted from the chapter to save space. They are, however, included in the downloadable code for this chapter. Also included are a bunch of joystick handling methods for XInput devices, including <code class="literal">XI_LeftStickPosition()</code>, <code class="literal">XI_RightStickPosition()</code>, <code class="literal">XI_LeftTrigger()</code>, and <code class="literal">XI_RightTrigger()</code>, among others. <strong>XI</strong> is of course short for XInput. Note that for the left and right triggers, their values are in the range of <code class="literal">0</code> to <code class="literal">255</code> depending on how much you press the trigger in. Also, in XInput the D-Pad is treated as regular buttons, so you will find button flags for all of its directions in the <code class="literal">GamepadButtonFlags</code> enumeration. This is also true for the thumbstick buttons.</p><p>Explore the various properties of the XInput <code class="literal">Controller</code> object to learn more about what you can do. Remember that we stored our <code class="literal">Controller</code> object in the <code class="literal">m_Controller1</code> member variable. Experiment with this code and see what you can discover.</p><p>Note that the downloadable code for this chapter also includes some additional test code for the<a id="id151" class="indexterm"/> keyboard and mouse input inside our <code class="literal">Update()</code> method in the <code class="literal">UserInput</code> class. This code is very similar to the joystick test code that was <a id="id152" class="indexterm"/>shown in this chapter for both DirectInput and XInput.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we had a crash course in responding to user input. First we looked at the differences between DirectInput and XInput. Then we looked at how to detect and respond to mouse and keyboard input. Next, we moved on to using joysticks with DirectInput, where we first looked at how to get a list of the available game controllers that are connected to the computer. Then, for simplicity, we added code to obtain the first game controller from the list and get some input from it. We wrote test code that outputs some debug text when you press the <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>, or <code class="literal">3</code> buttons. And finally, we looked at XInput controllers. The code we implemented to get input from the XInput controller was very similar to the DirectInput code, but slightly different. And lastly, we added some code to write some debug text into Visual Studio's <strong>Output</strong> pane whenever you press the <em>A</em>, <em>B</em>, <em>X</em>, or <em>Y</em> buttons on the XInput controller. In the next chapter, we will learn how to draw 2D graphics on the screen and create a 2D tile-based game world.</p></div></body></html>