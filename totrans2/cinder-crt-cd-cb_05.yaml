- en: Chapter 5. Building Particle Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating a particle system in 2D
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying repulsion and attraction forces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating particles flying in the wind
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating flocking behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our particles sound reactive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to processed images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to mesh surfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating springs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle systems are a computational technique of using a large number of small
    graphic objects to perform different types of simulations such as explosions,
    wind, fire, water, and flocking.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to create and animate particles using
    popular and versatile physics algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Creating a particle system in 2D
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how we can build a basic particle system
    in two dimensions using the Verlet algorithm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to create two classes, a `Particle` class representing a single
    particle, and a `ParticleSystem` class to manage our particles.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your IDE of choice, create the following files:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`Particle.h`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Particle.cpp`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem.h`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem.cpp`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how we can create a basic particle system. Perform the following
    steps to do so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s declare our `Particle` class in the `Particle.h` file and include
    the necessary Cinder files:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's add, to the class declaration, the necessary member variables – `ci::Vec2f`
    to store the position, previous position, and applied forces; and `float` to store
    particle radius, mass, and drag.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last thing needed to finalize the `Particle` declaration is to add a constructor
    that takes the particle's initial position, radius, mass, and drag, and methods
    to update and draw the particle.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the final `Particle` class declaration:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's move on to the `Particle.cpp` file and implement the `Particle` class.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first necessary step is to include the `Particle.h` file, as follows:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We initialize the member variables to the values passed in the constructor.
    We also initialize `forces` to `zero` and `prevPosition` to the initial position.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `update` method, we need to create a temporary `ci::Vec2f` variable to
    store the particle's position before it is updated.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We calculate the velocity of the particle by finding the difference between
    current and previous positions and multiplying it by `drag`. We store this value
    in `ci::Vec2f` temporarily for clarity.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To update the particle's position, we add the previously calculated velocity
    and add `forces` divided by `mass`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The final steps in the `update` method are to copy the previously stored position
    to `prevPosition` and reset `forces` to a `zero` vector.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the complete `update` method implementation:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `draw` implementation, we simply draw a circle at the particle's position
    using its radius.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now with the `Particle` class complete, we need to begin working on the `ParticleSystem`
    class. Move to the `ParticleSystem.h` file, include the necessary files, and create
    the `ParticleSystem` class declaration.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s add a destructor and methods to update and draw our particles. We''ll
    also need to create methods to add and destroy particles and finally a `std::vector`
    variable to store the particles in this system. The following is the final class
    declaration:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Moving to the `ParticleSystem.cpp` file, let's begin working on the implementation.
    The first thing we need to do is include the file with the class declaration.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let's implement the methods one by one. In the destructor, we iterate through
    all the particles and delete them.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `update` method will be used to iterate all the particles and call `update`
    on each of them.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `draw` method will iterate all the particles and call `draw` on each of
    them.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `addParticle` method will insert the particle on the `particles` container.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, `destroyParticle` will delete the particle and remove it from the particles'
    list.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll find the particles' iterator and use it to delete and later remove the
    object from the container.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With our classes ready, let's go to our application's class and create some
    particles.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our application''s class, we need to include the `ParticleSystem` header
    file and the necessary header to use random numbers at the top of the source file:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Declare a `ParticleSystem` object on our class declaration.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `setup` method we can create 100 particles with random positions on our
    window and random radius. We'll define the mass to be the same as the radius as
    a way to have a relation between size and mass. `drag` will be set to 9.5.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet inside the setup method:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `update` method, we need to update the particles by calling the `update`
    method on `mParticleSystem`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `draw` method we need to clear the screen, set up the window's matrices,
    and call the `draw` method on `mParticleSystem`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Build and run the application and you will see 100 random circles on screen,
    as shown in the following screenshot:![How to do it…](img/8703OS_5_1.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next recipes we will learn how to animate the particles in organic and
    appealing ways.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method described previously uses a popular and versatile Verlet integrator.
    One of its main characteristics is an implicit approximation of velocity. This
    is accomplished by calculating, on each update of the simulation, the distance
    traveled since the last update of the simulation. This allows for greater stability
    as velocity is implicit to position and there is less chance these will ever get
    out of sync.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drag` member variable represents resistance to movement and should be
    a number between 0.0 and 1.0\. A value of 0.0 represents such a great resistance
    that the particle will not be able to move. A value of 1.0 represents absence
    of resistance and will make the particle move indefinitely. We applied `drag`
    in step 7, where we multiplied `drag` by the velocity:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a particle system in 3D it is necessary to use a 3D vector instead
    of a 2D one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Since Cinder's vector 2D and 3D vector classes have a very similar class structure,
    we simply need to change `position`, `prevPosition`, and `forces` to be `ci::Vec3f`
    objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The constructor will also need to take a `ci::Vec3f` object as an argument instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the class declaration with these changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `draw` method should also be changed to allow for 3D drawing; we could,
    for example, draw a sphere instead of a circle:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the implementation of the Verlet algorithm, please refer
    to the paper by Thomas Jakobsen, located at [http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf](http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the Verlet integration, please read the wiki at [http://en.wikipedia.org/wiki/Verlet_integration](http://en.wikipedia.org/wiki/Verlet_integration)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying repulsion and attraction forces
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how you can apply repulsion and attraction forces
    to the particle system that we have implemented in the previous recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the code from the *Creating particle system
    in 2D* recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will illustrate how you can apply forces to the particle system. Perform
    the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Add properties to your application's main class.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Set the default value inside the `setup` method.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `mouseMove` and `mouseDown` methods, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the beginning of the `update` method, add the following code snippet:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example we added interaction to the particles engine introduced in the
    first recipe. The attraction force is pointing to your mouse cursor position but
    the repulsion vector points in the opposite direction. These forces were calculated
    and applied to each particle in steps 3 and 4, and then we made the particles
    follow your mouse cursor, but when you click on the left mouse button, they are
    suddenly moves away from the mouse cursor. This effect can be achieved with basic
    vector operations. Cinder lets you perform vector calculations pretty much the
    same way you usually do on scalars.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The repulsion force is calculated in step 3\. We are using the normalized vector
    beginning at the mouse cursor position and the end of the particle position, multiplied
    by the repulsion factor, calculated on the basis of the distance between the particle
    and the mouse cursor position. Using the `repulsionRadius` value, we can limit
    the range of the repulsion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: We are calculating the attraction force in step 4 taking the vector beginning
    at the particle position and the end at the mouse cursor position. We are multiplying
    this vector by the `attrFactor` value, which controls the strength of the attraction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_2.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Simulating particles flying in the wind
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explain how you can apply Brownian motion to your particles.
    Particles are going to behave like snowflakes or leaves flying in the wind.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to use the code base from the *Creating a particle
    system in 2D* recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add movement to particles calculated from the Perlin noise and sine
    function. Perform the following steps to do so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Add the necessary headers.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add properties to your application's main class.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Set the default value inside the `setup` method.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Change the number of the particles, their radius, and mass.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the beginning of the `update` method, add the following code snippet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main movement calculations and forces are applied in step 5\. As you can
    see we are using the Perlin noise algorithm implemented as a part of Cinder. It
    provides a method to retrieve Brownian motion vectors for each particle. We also
    add `oscilationVec` that makes particles swing from left-to-right and backwards,
    adding more realistic behavior.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_3.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Perlin noise original source**: [http://mrl.nyu.edu/~perlin/doc/oscar.html#noise](http://mrl.nyu.edu/~perlin/doc/oscar.html#noise)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brownian motion**: [http://en.wikipedia.org/wiki/Brownian_motion](http://en.wikipedia.org/wiki/Brownian_motion)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating flocking behavior
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flocking is a term applied to the behavior of birds and other flying animals
    that are organized into a swarm or flock.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'From our point of view, it is especially interesting that flocking behavior
    can be simulated by applying only three rules to each particle (Boid). These rules
    are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation**: Avoid neighbors that are too near'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment**: Steer towards the average velocity of neighbors'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion**: Steer towards the average position of neighbors'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the code from the *Creating a particle system
    in 2D* recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement the rules for flocking behavior. Perform the following steps
    to do so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Change the number of the particles, their radius, and mass.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add a definition for new methods and properties to the `Particle` class inside
    the `Particle.h` header file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Set the default values for `maxspeed` and `maxforce` at the end of the `Particle`
    constructor inside the `Particle.cpp` source file.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Implement the new methods of the `Particle` class inside the `Particle.cpp`
    source file.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add a method for the separation rule.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Add a method for the alignment rule.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Add a method for the cohesion rule.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Change the `update` method to read as follows
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change the `drawing` method of `Particle`, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Change the `update` method of `ParticleSystem` inside the `ParticleSystem.cpp`
    source file, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Three rules for flocking—separation, alignment, and cohesion—were implemented
    starting from step 4 and they were applied to each particle in step 10\. In this
    step, we also prevented Boids from going out of the window boundaries by resetting
    their positions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_12.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Flocking**: [http://en.wikipedia.org/wiki/Flocking_(behavior)](http://en.wikipedia.org/wiki/Flocking_(behavior))'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our particles sound reactive
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will pick on the previous particle system and add animations
    based on **fast Fourier transform** (**FFT**) analysis from an audio file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The FFT analysis will return a list of values representing the amplitudes of
    several frequency windows. We will match each particle to a frequency window and
    use its value to animate the repulsion that each particle applies to all other
    particles.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: This example uses Cinder's FFT processor, which is only available on Mac OS
    X.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the same particle system developed in the previous recipe,
    *Creating a particle system in 2D*. Create the `Particle` and `ParticleSystem`
    classes described in that recipe, and include the `ParticleSystem.h` file at the
    top of the application's source file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using values from the FFT analysis we will animate our particles. Perform the
    following steps to do so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `ParticleSystem` object on your application's class and a variable
    to store the number of particles we will create.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `setup` method we'll create 256 random particles. The number of particles
    will match the number of values we will receive from the audio analysis.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The particles will begin at a random position on the window and have a random
    size and mass. `drag` will be `0.9`.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the `update` method, we have to call the `update` method on the particle
    system.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `draw` method, we have to clear the background, calculate the window's
    matrices, and call the `draw` method on the particle system.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s load and play an audio file. We start by including the necessary
    files to load, play, and perform the FFT analysis. Add the following code snippet
    at the top of the source file:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now declare `ci::audio::TrackRef`, which is a reference to an audio track.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the `setup` method we will open a file dialog to allow the user to select
    which audio file to play.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the retrieved path is not empty, we will use it to load and add a new audio
    track.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We'll check if `mAudio` was successfully loaded and played. We will also enable
    the PCM buffer and looping.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have an audio file playing, we need to start animating the particles.
    First we need to apply an elastic force towards the center of the window. We do
    so by iterating the over all particles and adding a force, which is one-tenth
    of the difference between the particle's position and the window's center position.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet to the `update` method:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`update`方法中：
- en: '[PRE53]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we have to calculate the FFT analysis. This will be done once after every
    frame in the update.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须计算FFT分析。这将在每次更新帧后进行一次。
- en: Declare a local variable `std::shared_ptr<float>`, where the result of the FFT
    will be stored.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明一个局部变量`std::shared_ptr<float>`，用于存储FFT的结果。
- en: We will get a reference to the PCM buffer of `mAudio` and perform an FFT analysis
    on its left channel. It is a good practice to perform a test to check the validity
    of `mAudio` and its buffer.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将获取`mAudio`的PCM缓冲区的引用，并在其左通道上执行FFT分析。对`mAudio`及其缓冲区进行测试以检查其有效性是一个好的实践。
- en: '[PRE54]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will use the values from the FFT analysis to scale the repulsion each particle
    is applying.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用FFT分析的结果来调整每个粒子施加的排斥力。
- en: 'Add the following code snippet to the `update` method:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`update`方法中：
- en: '[PRE55]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Build and run the application; you will be prompted to select an audio file.
    Select it and it will begin playing. The particles will move and push each other
    around according to the audio's frequencies.![How to do it…](img/8703OS_5_6.jpg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序；您将被提示选择一个音频文件。选择它，它将开始播放。粒子将根据音频的频率移动并相互推挤。![如何操作…](img/8703OS_5_6.jpg)
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We created a particle for each one of the values the FFT analysis returns and
    made each particle repulse every other particle according to its correspondent
    frequency window amplitude. As the music evolves, the animation will react accordingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为FFT分析返回的每个值创建了一个粒子，并根据相应的频率窗口幅度使每个粒子排斥其他粒子。随着音乐的演变，动画将相应地做出反应。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about fast Fourier transform please visit [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于快速傅里叶变换的信息，请访问[http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
- en: Aligning particles to a processed image
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将粒子对齐到处理后的图像
- en: In this recipe, we will show how you can use techniques you were introduced
    to in the previous recipes to make particles align to the edge detected in the
    image.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示如何使用在前面的食谱中介绍的技术使粒子对齐到图像中检测到的边缘。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are going to use the particles' implementation from the *Creating
    a particle system in 2D* recipe; the image processing example from the *Detecting
    edges* recipe in [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*; as well as simulating repulsion covered in
    the *Applying repulsion and attraction forces* recipe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用来自*在2D中创建粒子系统*食谱的粒子实现；来自[第3章](ch03.html "第3章。使用图像处理技术")的*检测边缘*食谱中的图像处理示例；以及*应用排斥和吸引力量*食谱中涵盖的模拟排斥。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will create particles aligning to the detected edges in the image. Perform
    the following steps to do so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建与图像中检测到的边缘对齐的粒子。为此，请执行以下步骤：
- en: Add an `anchor` property to the `Particle` class in the `Particle.h` file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.h`文件中为`Particle`类添加一个`anchor`属性。
- en: '[PRE56]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Set the `anchor` value at the end of the `Particle` class constructor in the
    `Particle.cpp` source file.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.cpp`源文件的`Particle`类构造函数末尾设置`anchor`值。
- en: '[PRE57]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Add a new property to your application's main class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您应用程序的主类添加一个新属性。
- en: '[PRE58]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the end of the `setup` method, after image processing, add new particles,
    as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法末尾，在图像处理之后，添加新粒子，如下所示：
- en: '[PRE59]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `update` method for your main class, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的主类实现`update`方法，如下所示：
- en: '[PRE60]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Change the `draw` method for `Particle` inside the `Particle.cpp` source file
    to read as follows
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Particle.cpp`源文件中的`Particle`类的`draw`方法更改为以下内容
- en: '[PRE61]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first major step was to allocate particles at some characteristic points
    of the image. To do so, we detected the edges, which was covered in the *Detecting
    edges* recipe in [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*. In step 4 you can see that we iterated through
    each pixel of each processed image and placed particles only at detected features.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要步骤是在图像的一些特征点上分配粒子。为此，我们检测了边缘，这在[第3章](ch03.html "第3章。使用图像处理技术")的*检测边缘*食谱中有介绍，*使用图像处理技术*。在第4步中，您可以看到我们遍历了每个处理图像的每个像素，并在检测到的特征处放置粒子。
- en: You can find another important calculation in step 5, where we tried to move
    back the particles to their original positions stored in the `anchor` property.
    To disorder particles, we used the same repulsion code that we used in the *Applying
    repulsion and attraction forces* recipe.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_8.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about fast Fourier transform, please visit [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to the mesh surface
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to use a 3D version of the particles' code base
    from the *Creating a particle system in 2D* recipe. To navigate in 3D space, we
    will use `MayaCamUI` covered in the *Using MayaCamUI* recipe in [Chapter 2](ch02.html
    "Chapter 2. Preparing for Development"), *Preparing for Development*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simulate repulsion, we are using the code from the *Applying repulsion and
    attraction forces* recipe with slight modifications for three-dimensional space.
    For this example, we are using the `ducky.mesh` mesh file that you can find in
    the `resources` directory of the Picking3D sample inside the Cinder package. Please
    copy this file to the `assets` folder in your project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create particles aligned to the mesh. Perform the following steps to
    do so:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Add an `anchor` property to the `Particle` class in the `Particle.h` file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Set the `anchor` value at the end of the `Particle` class constructor in the
    `Particle.cpp` source file.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Add the necessary headers in your main class.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Add the new properties to your application's main class.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Set the default values inside the `setup` method.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'At the end of the `setup` method, add the following code snippet:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Add methods for camera navigation.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Implement the `update` and `draw` methods for your main application class.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Replace the `draw` method for `Particle` inside the `Particle.cpp` source file
    to read as follows
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we created particles in place of vertices of the mesh that you can
    see in step 6.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_9.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: You can find another important calculation in step 8 where we tried to move
    particles back to their original positions stored in the `anchor` property. To
    displace the particles, we used the same repulsion code that we used in the *Applying
    repulsion and attraction forces* recipe but with slight modifications for three-dimensional
    space. Basically, it is about using `Vec3f` types instead of `Vec2f`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_10.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Creating springs
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can create springs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**Springs** are objects that connect two particles and force them to be at
    a defined rest distance.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will create random particles, and whenever the user presses
    a mouse button, two random particles will be connected by a new spring with a
    random rest distance.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the same particle system developed in the previous recipe,
    *Creating a particle system in 2D*. Create the `Particle` and `ParticleSystem`
    classes described in that recipe and include the `ParticleSystem.h` file at the
    top of the application source file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating a `Spring` class, so it is necessary to create the following
    files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring.h`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spring.cpp`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create springs that constrain the movement of particles. Perform the
    following steps to do so:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In the `Spring.h` file, we will declare a `Spring` class. The first thing we
    need to do is to add the `#pragma once` macro and include the necessary files.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, declare the `Spring` class.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We will add member variables, two `Particle` pointers to reference the particles
    that will be connected by this spring, and the `rest` and `strengthfloat` variables.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we will declare the constructor that will take pointers to two `Particle`
    objects, and the `rest` and `strength` values.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also declare the `update` and `draw` methods.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is the final `Spring` class declaration:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let's implement the `Spring` class in the `Spring.cpp` file.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we will set the values of the member values to the ones
    passed in the arguments.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the `update` method of the `Spring` class, we will calculate the difference
    between the particles' distance and the spring's rest distance, and adjust them
    accordingly.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the `draw` method of the `Spring` class, we will simply draw a line connecting
    both particles.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now we will have to make some changes in the `ParticleSystem` class to allow
    the addition of springs.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ParticleSystem` file, include the `Spring.h` file.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Declare the `std::vector<Spring*>` member in the class declaration.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Declare the `addSpring` and `destroySpring` methods to add and destroy springs
    to the system.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the final `ParticleSystem` class declaration:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s implement the `addSpring` method. In the `ParticleSystem.cpp` file,
    add the following code snippet:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the implementation of `destroySpring`, we will find the correspondent iterator
    for the argument `Spring` and remove it from springs. We will also delete the
    object.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet in the `ParticleSystem.cpp` file:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: It is necessary to alter the `update` method to update all springs.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows what the final update should look like:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the `draw` method, we will also need to iterate over all springs and call
    the `draw` method on them.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final implementation of the `ParticleSystem::draw` method should be as
    follows:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We have finished creating the `Spring` class and making all necessary changes
    to the `ParticleSystem` class.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go to our application''s class and include the `ParticleSystem.h` file:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Declare a `ParticleSystem` object.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create some random particles by adding the following code snippet to the `setup`
    method:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the `update` method, we will need to call the `update` method on `ParticleSystem`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the `draw` method, clear the background, define the window's matrices, and
    call the `draw` method on `mParticleSystem`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Since we want to create springs whenever the user presses the mouse, we will
    need to declare the `mouseDown` method.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet to your application''s class declaration:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the `mouseDown` implementation we will connect two random particles.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by declaring a `Particle` pointer and defining it as a random particle
    in the particle system.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now declare a second `Particle` pointer and make it equal to the first one.
    In the `while` loop, we will set its value to a random particle in `mParticleSystem`
    until both particles are different. This will avoid the case where both pointers
    point to the same particle.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now we'll create a `Spring` object that will connect both particles, define
    a random rest distance, and set `strength` to `1.0`. Add the created spring to
    `mParticleSystem`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the final `mouseDown` implementation:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Build and run the application. Every time a mouse button is pressed, two particles
    will become connected with a white line and their distance will remain unchangeable.![How
    to do it…](img/87030s_5_11.jpg)
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Spring` object will calculate the difference between two particles and correct
    their positions, so that the distance between the two particles will be equal
    to the springs' rest value.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: By using their masses, we will also take into account each particle's mass,
    so that the correction will take into account the particles' weight.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same principle can also be applied to particle systems in 3D.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a 3D particle, as explained in the *There's more…* section
    of the *Creating a particle system in 2D* recipe, the `Spring` class simply needs
    to change its calculations to use `ci::Vec3f` instead of `ci::Vec2f`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method of the `Spring` class would need to look like the following
    code snippet:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
