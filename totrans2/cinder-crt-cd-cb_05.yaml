- en: Chapter 5. Building Particle Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a particle system in 2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying repulsion and attraction forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating particles flying in the wind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating flocking behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our particles sound reactive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to processed images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to mesh surfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating springs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle systems are a computational technique of using a large number of small
    graphic objects to perform different types of simulations such as explosions,
    wind, fire, water, and flocking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to create and animate particles using
    popular and versatile physics algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a particle system in 2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how we can build a basic particle system
    in two dimensions using the Verlet algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to create two classes, a `Particle` class representing a single
    particle, and a `ParticleSystem` class to manage our particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your IDE of choice, create the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Particle.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Particle.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how we can create a basic particle system. Perform the following
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s declare our `Particle` class in the `Particle.h` file and include
    the necessary Cinder files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's add, to the class declaration, the necessary member variables – `ci::Vec2f`
    to store the position, previous position, and applied forces; and `float` to store
    particle radius, mass, and drag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing needed to finalize the `Particle` declaration is to add a constructor
    that takes the particle's initial position, radius, mass, and drag, and methods
    to update and draw the particle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the final `Particle` class declaration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's move on to the `Particle.cpp` file and implement the `Particle` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first necessary step is to include the `Particle.h` file, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We initialize the member variables to the values passed in the constructor.
    We also initialize `forces` to `zero` and `prevPosition` to the initial position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `update` method, we need to create a temporary `ci::Vec2f` variable to
    store the particle's position before it is updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We calculate the velocity of the particle by finding the difference between
    current and previous positions and multiplying it by `drag`. We store this value
    in `ci::Vec2f` temporarily for clarity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To update the particle's position, we add the previously calculated velocity
    and add `forces` divided by `mass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final steps in the `update` method are to copy the previously stored position
    to `prevPosition` and reset `forces` to a `zero` vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the complete `update` method implementation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` implementation, we simply draw a circle at the particle's position
    using its radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now with the `Particle` class complete, we need to begin working on the `ParticleSystem`
    class. Move to the `ParticleSystem.h` file, include the necessary files, and create
    the `ParticleSystem` class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s add a destructor and methods to update and draw our particles. We''ll
    also need to create methods to add and destroy particles and finally a `std::vector`
    variable to store the particles in this system. The following is the final class
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Moving to the `ParticleSystem.cpp` file, let's begin working on the implementation.
    The first thing we need to do is include the file with the class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's implement the methods one by one. In the destructor, we iterate through
    all the particles and delete them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `update` method will be used to iterate all the particles and call `update`
    on each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `draw` method will iterate all the particles and call `draw` on each of
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `addParticle` method will insert the particle on the `particles` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, `destroyParticle` will delete the particle and remove it from the particles'
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll find the particles' iterator and use it to delete and later remove the
    object from the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our classes ready, let's go to our application's class and create some
    particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our application''s class, we need to include the `ParticleSystem` header
    file and the necessary header to use random numbers at the top of the source file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare a `ParticleSystem` object on our class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method we can create 100 particles with random positions on our
    window and random radius. We'll define the mass to be the same as the radius as
    a way to have a relation between size and mass. `drag` will be set to 9.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet inside the setup method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `update` method, we need to update the particles by calling the `update`
    method on `mParticleSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method we need to clear the screen, set up the window's matrices,
    and call the `draw` method on `mParticleSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application and you will see 100 random circles on screen,
    as shown in the following screenshot:![How to do it…](img/8703OS_5_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next recipes we will learn how to animate the particles in organic and
    appealing ways.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method described previously uses a popular and versatile Verlet integrator.
    One of its main characteristics is an implicit approximation of velocity. This
    is accomplished by calculating, on each update of the simulation, the distance
    traveled since the last update of the simulation. This allows for greater stability
    as velocity is implicit to position and there is less chance these will ever get
    out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drag` member variable represents resistance to movement and should be
    a number between 0.0 and 1.0\. A value of 0.0 represents such a great resistance
    that the particle will not be able to move. A value of 1.0 represents absence
    of resistance and will make the particle move indefinitely. We applied `drag`
    in step 7, where we multiplied `drag` by the velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a particle system in 3D it is necessary to use a 3D vector instead
    of a 2D one.
  prefs: []
  type: TYPE_NORMAL
- en: Since Cinder's vector 2D and 3D vector classes have a very similar class structure,
    we simply need to change `position`, `prevPosition`, and `forces` to be `ci::Vec3f`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor will also need to take a `ci::Vec3f` object as an argument instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the class declaration with these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` method should also be changed to allow for 3D drawing; we could,
    for example, draw a sphere instead of a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the implementation of the Verlet algorithm, please refer
    to the paper by Thomas Jakobsen, located at [http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf](http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the Verlet integration, please read the wiki at [http://en.wikipedia.org/wiki/Verlet_integration](http://en.wikipedia.org/wiki/Verlet_integration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying repulsion and attraction forces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how you can apply repulsion and attraction forces
    to the particle system that we have implemented in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the code from the *Creating particle system
    in 2D* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will illustrate how you can apply forces to the particle system. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add properties to your application's main class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the default value inside the `setup` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `mouseMove` and `mouseDown` methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the beginning of the `update` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example we added interaction to the particles engine introduced in the
    first recipe. The attraction force is pointing to your mouse cursor position but
    the repulsion vector points in the opposite direction. These forces were calculated
    and applied to each particle in steps 3 and 4, and then we made the particles
    follow your mouse cursor, but when you click on the left mouse button, they are
    suddenly moves away from the mouse cursor. This effect can be achieved with basic
    vector operations. Cinder lets you perform vector calculations pretty much the
    same way you usually do on scalars.
  prefs: []
  type: TYPE_NORMAL
- en: The repulsion force is calculated in step 3\. We are using the normalized vector
    beginning at the mouse cursor position and the end of the particle position, multiplied
    by the repulsion factor, calculated on the basis of the distance between the particle
    and the mouse cursor position. Using the `repulsionRadius` value, we can limit
    the range of the repulsion.
  prefs: []
  type: TYPE_NORMAL
- en: We are calculating the attraction force in step 4 taking the vector beginning
    at the particle position and the end at the mouse cursor position. We are multiplying
    this vector by the `attrFactor` value, which controls the strength of the attraction.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simulating particles flying in the wind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explain how you can apply Brownian motion to your particles.
    Particles are going to behave like snowflakes or leaves flying in the wind.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to use the code base from the *Creating a particle
    system in 2D* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add movement to particles calculated from the Perlin noise and sine
    function. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the necessary headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add properties to your application's main class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the default value inside the `setup` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the number of the particles, their radius, and mass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the beginning of the `update` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main movement calculations and forces are applied in step 5\. As you can
    see we are using the Perlin noise algorithm implemented as a part of Cinder. It
    provides a method to retrieve Brownian motion vectors for each particle. We also
    add `oscilationVec` that makes particles swing from left-to-right and backwards,
    adding more realistic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Perlin noise original source**: [http://mrl.nyu.edu/~perlin/doc/oscar.html#noise](http://mrl.nyu.edu/~perlin/doc/oscar.html#noise)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brownian motion**: [http://en.wikipedia.org/wiki/Brownian_motion](http://en.wikipedia.org/wiki/Brownian_motion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating flocking behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flocking is a term applied to the behavior of birds and other flying animals
    that are organized into a swarm or flock.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our point of view, it is especially interesting that flocking behavior
    can be simulated by applying only three rules to each particle (Boid). These rules
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation**: Avoid neighbors that are too near'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment**: Steer towards the average velocity of neighbors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion**: Steer towards the average position of neighbors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the code from the *Creating a particle system
    in 2D* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement the rules for flocking behavior. Perform the following steps
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the number of the particles, their radius, and mass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a definition for new methods and properties to the `Particle` class inside
    the `Particle.h` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the default values for `maxspeed` and `maxforce` at the end of the `Particle`
    constructor inside the `Particle.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the new methods of the `Particle` class inside the `Particle.cpp`
    source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a method for the separation rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a method for the alignment rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a method for the cohesion rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the `update` method to read as follows
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `drawing` method of `Particle`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `update` method of `ParticleSystem` inside the `ParticleSystem.cpp`
    source file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Three rules for flocking—separation, alignment, and cohesion—were implemented
    starting from step 4 and they were applied to each particle in step 10\. In this
    step, we also prevented Boids from going out of the window boundaries by resetting
    their positions.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Flocking**: [http://en.wikipedia.org/wiki/Flocking_(behavior)](http://en.wikipedia.org/wiki/Flocking_(behavior))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our particles sound reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will pick on the previous particle system and add animations
    based on **fast Fourier transform** (**FFT**) analysis from an audio file.
  prefs: []
  type: TYPE_NORMAL
- en: The FFT analysis will return a list of values representing the amplitudes of
    several frequency windows. We will match each particle to a frequency window and
    use its value to animate the repulsion that each particle applies to all other
    particles.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses Cinder's FFT processor, which is only available on Mac OS
    X.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the same particle system developed in the previous recipe,
    *Creating a particle system in 2D*. Create the `Particle` and `ParticleSystem`
    classes described in that recipe, and include the `ParticleSystem.h` file at the
    top of the application's source file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using values from the FFT analysis we will animate our particles. Perform the
    following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `ParticleSystem` object on your application's class and a variable
    to store the number of particles we will create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method we'll create 256 random particles. The number of particles
    will match the number of values we will receive from the audio analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The particles will begin at a random position on the window and have a random
    size and mass. `drag` will be `0.9`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `update` method, we have to call the `update` method on the particle
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method, we have to clear the background, calculate the window's
    matrices, and call the `draw` method on the particle system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s load and play an audio file. We start by including the necessary
    files to load, play, and perform the FFT analysis. Add the following code snippet
    at the top of the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now declare `ci::audio::TrackRef`, which is a reference to an audio track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method we will open a file dialog to allow the user to select
    which audio file to play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the retrieved path is not empty, we will use it to load and add a new audio
    track.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll check if `mAudio` was successfully loaded and played. We will also enable
    the PCM buffer and looping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have an audio file playing, we need to start animating the particles.
    First we need to apply an elastic force towards the center of the window. We do
    so by iterating the over all particles and adding a force, which is one-tenth
    of the difference between the particle's position and the window's center position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet to the `update` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have to calculate the FFT analysis. This will be done once after every
    frame in the update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a local variable `std::shared_ptr<float>`, where the result of the FFT
    will be stored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will get a reference to the PCM buffer of `mAudio` and perform an FFT analysis
    on its left channel. It is a good practice to perform a test to check the validity
    of `mAudio` and its buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the values from the FFT analysis to scale the repulsion each particle
    is applying.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet to the `update` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application; you will be prompted to select an audio file.
    Select it and it will begin playing. The particles will move and push each other
    around according to the audio's frequencies.![How to do it…](img/8703OS_5_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a particle for each one of the values the FFT analysis returns and
    made each particle repulse every other particle according to its correspondent
    frequency window amplitude. As the music evolves, the animation will react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about fast Fourier transform please visit [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to a processed image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how you can use techniques you were introduced
    to in the previous recipes to make particles align to the edge detected in the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the particles' implementation from the *Creating
    a particle system in 2D* recipe; the image processing example from the *Detecting
    edges* recipe in [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*; as well as simulating repulsion covered in
    the *Applying repulsion and attraction forces* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create particles aligning to the detected edges in the image. Perform
    the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an `anchor` property to the `Particle` class in the `Particle.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the `anchor` value at the end of the `Particle` class constructor in the
    `Particle.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new property to your application's main class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `setup` method, after image processing, add new particles,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `update` method for your main class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the `draw` method for `Particle` inside the `Particle.cpp` source file
    to read as follows
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first major step was to allocate particles at some characteristic points
    of the image. To do so, we detected the edges, which was covered in the *Detecting
    edges* recipe in [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*. In step 4 you can see that we iterated through
    each pixel of each processed image and placed particles only at detected features.
  prefs: []
  type: TYPE_NORMAL
- en: You can find another important calculation in step 5, where we tried to move
    back the particles to their original positions stored in the `anchor` property.
    To disorder particles, we used the same repulsion code that we used in the *Applying
    repulsion and attraction forces* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about fast Fourier transform, please visit [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning particles to the mesh surface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to use a 3D version of the particles' code base
    from the *Creating a particle system in 2D* recipe. To navigate in 3D space, we
    will use `MayaCamUI` covered in the *Using MayaCamUI* recipe in [Chapter 2](ch02.html
    "Chapter 2. Preparing for Development"), *Preparing for Development*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simulate repulsion, we are using the code from the *Applying repulsion and
    attraction forces* recipe with slight modifications for three-dimensional space.
    For this example, we are using the `ducky.mesh` mesh file that you can find in
    the `resources` directory of the Picking3D sample inside the Cinder package. Please
    copy this file to the `assets` folder in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create particles aligned to the mesh. Perform the following steps to
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an `anchor` property to the `Particle` class in the `Particle.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the `anchor` value at the end of the `Particle` class constructor in the
    `Particle.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the necessary headers in your main class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the new properties to your application's main class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the default values inside the `setup` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `setup` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add methods for camera navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `update` and `draw` methods for your main application class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace the `draw` method for `Particle` inside the `Particle.cpp` source file
    to read as follows
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we created particles in place of vertices of the mesh that you can
    see in step 6.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can find another important calculation in step 8 where we tried to move
    particles back to their original positions stored in the `anchor` property. To
    displace the particles, we used the same repulsion code that we used in the *Applying
    repulsion and attraction forces* recipe but with slight modifications for three-dimensional
    space. Basically, it is about using `Vec3f` types instead of `Vec2f`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_5_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating springs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can create springs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Springs** are objects that connect two particles and force them to be at
    a defined rest distance.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will create random particles, and whenever the user presses
    a mouse button, two random particles will be connected by a new spring with a
    random rest distance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the same particle system developed in the previous recipe,
    *Creating a particle system in 2D*. Create the `Particle` and `ParticleSystem`
    classes described in that recipe and include the `ParticleSystem.h` file at the
    top of the application source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating a `Spring` class, so it is necessary to create the following
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spring.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create springs that constrain the movement of particles. Perform the
    following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Spring.h` file, we will declare a `Spring` class. The first thing we
    need to do is to add the `#pragma once` macro and include the necessary files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, declare the `Spring` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will add member variables, two `Particle` pointers to reference the particles
    that will be connected by this spring, and the `rest` and `strengthfloat` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we will declare the constructor that will take pointers to two `Particle`
    objects, and the `rest` and `strength` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also declare the `update` and `draw` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is the final `Spring` class declaration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's implement the `Spring` class in the `Spring.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we will set the values of the member values to the ones
    passed in the arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `update` method of the `Spring` class, we will calculate the difference
    between the particles' distance and the spring's rest distance, and adjust them
    accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method of the `Spring` class, we will simply draw a line connecting
    both particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we will have to make some changes in the `ParticleSystem` class to allow
    the addition of springs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ParticleSystem` file, include the `Spring.h` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the `std::vector<Spring*>` member in the class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the `addSpring` and `destroySpring` methods to add and destroy springs
    to the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the final `ParticleSystem` class declaration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s implement the `addSpring` method. In the `ParticleSystem.cpp` file,
    add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the implementation of `destroySpring`, we will find the correspondent iterator
    for the argument `Spring` and remove it from springs. We will also delete the
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet in the `ParticleSystem.cpp` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is necessary to alter the `update` method to update all springs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows what the final update should look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method, we will also need to iterate over all springs and call
    the `draw` method on them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final implementation of the `ParticleSystem::draw` method should be as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have finished creating the `Spring` class and making all necessary changes
    to the `ParticleSystem` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go to our application''s class and include the `ParticleSystem.h` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare a `ParticleSystem` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create some random particles by adding the following code snippet to the `setup`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `update` method, we will need to call the `update` method on `ParticleSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method, clear the background, define the window's matrices, and
    call the `draw` method on `mParticleSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we want to create springs whenever the user presses the mouse, we will
    need to declare the `mouseDown` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet to your application''s class declaration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `mouseDown` implementation we will connect two random particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by declaring a `Particle` pointer and defining it as a random particle
    in the particle system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now declare a second `Particle` pointer and make it equal to the first one.
    In the `while` loop, we will set its value to a random particle in `mParticleSystem`
    until both particles are different. This will avoid the case where both pointers
    point to the same particle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we'll create a `Spring` object that will connect both particles, define
    a random rest distance, and set `strength` to `1.0`. Add the created spring to
    `mParticleSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the final `mouseDown` implementation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application. Every time a mouse button is pressed, two particles
    will become connected with a white line and their distance will remain unchangeable.![How
    to do it…](img/87030s_5_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Spring` object will calculate the difference between two particles and correct
    their positions, so that the distance between the two particles will be equal
    to the springs' rest value.
  prefs: []
  type: TYPE_NORMAL
- en: By using their masses, we will also take into account each particle's mass,
    so that the correction will take into account the particles' weight.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same principle can also be applied to particle systems in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a 3D particle, as explained in the *There's more…* section
    of the *Creating a particle system in 2D* recipe, the `Spring` class simply needs
    to change its calculations to use `ci::Vec3f` instead of `ci::Vec2f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method of the `Spring` class would need to look like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
