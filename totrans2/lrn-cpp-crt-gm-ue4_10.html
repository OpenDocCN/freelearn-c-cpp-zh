<html><head></head><body>
<div class="book" title="Chapter&#xA0;10.&#xA0;Inventory System and Pickup Items"><div class="book" id="24L8G2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Inventory System and Pickup Items</h1></div></div></div><p class="calibre9">We want our player to be able to pick up items from the game world. In this chapter, we will code and design a backpack for our player to store items. We will display what the player is carrying in the pack when the user presses the <span class="strong"><em class="calibre10">I</em></span> key.</p><p class="calibre9">As a data representation, we can use the <code class="email">TMap&lt;FString, int&gt;</code> items covered in the previous chapter to store our items. When the player picks up an item, we add it to the map. If the item is already in the map, we just increase its value by the quantity of the new items picked up.</p></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Inventory System and Pickup Items">
<div class="book" title="Declaring the backpack"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec70" class="calibre1"/>Declaring the backpack</h1></div></div></div><p class="calibre9">We can <a id="id456" class="calibre1"/>represent the player's backpack as a simple <code class="email">TMap&lt;FString, int&gt;</code> item. To allow your player to gather items from the world, open the <code class="email">Avatar.h</code> file and add the following <code class="email">TMap</code> declaration:</p><div class="note"><pre class="programlisting">class APickupItem; //  forward declare the APickupItem class,
                   // since it will be "mentioned" in a member  function decl below
UCLASS()
class GOLDENEGG_API AAvatar : public ACharacter
{
  GENERATED_UCLASS_BODY()

  // A map for the player's backpack
  TMap&lt;FString, int&gt; Backpack;

  // The icons for the items in the backpack, lookup by string
  TMap&lt;FString, UTexture2D*&gt; Icons;

  // A flag alerting us the UI is showing
  bool inventoryShowing;
  // member function for letting the avatar have an item
  void Pickup( APickupItem *item );
  // ... rest of Avatar.h same as before
};</pre></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Inventory System and Pickup Items">
<div class="book" title="Declaring the backpack">
<div class="book" title="Forward declaration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec109" class="calibre1"/>Forward declaration</h2></div></div></div><p class="calibre9">Before <a id="id457" class="calibre1"/>
<code class="email">AAvatar</code> class, notice that we have a <code class="email">class APickupItem</code> forward declaration. Forward declarations are needed in a code file when a<a id="id458" class="calibre1"/> class is mentioned (such as the <code class="email">APickupItem::Pickup( APickupItem *item );</code> function prototype), but there is no code in the file actually using an object of that type inside the file. Since the <code class="email">Avatar.h</code> header file does not contain executable code that uses an object of the type <code class="email">APickupItem</code>, a forward declaration is what we need.</p><p class="calibre9">The absence of a forward declaration will give a compiler error, since the compiler won't have heard of <code class="email">class APickupItem</code> before compiling the code in <code class="email">class AAvatar</code>. The compiler error will come at the declaration of the <code class="email">APickupItem::Pickup( APickupItem *item );</code> function prototype declaration.</p><p class="calibre9">We declared two <code class="email">TMap</code> objects inside the <code class="email">AAvatar</code> class. This is how the objects will look, as shown in the following table:</p><div class="note"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">
<code class="literal">FString</code> (name)</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">
<code class="literal">int</code> (quantity)</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">
<code class="literal">UTexture2D*</code> (im)</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">GoldenEgg</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">2</p>
</td><td valign="top" class="calibre25">
<div class="mediaobject1"><img src="../images/00142.jpeg" alt="Forward declaration" class="calibre27"/></div><p class="calibre28"> </p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">MetalDonut</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">1</p>
</td><td valign="top" class="calibre25">
<div class="mediaobject1"><img src="../images/00143.jpeg" alt="Forward declaration" class="calibre27"/></div><p class="calibre28"> </p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">Cow</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">2</p>
</td><td valign="top" class="calibre25">
<div class="mediaobject1"><img src="../images/00144.jpeg" alt="Forward declaration" class="calibre27"/></div><p class="calibre28"> </p>
</td></tr></tbody></table></div><p class="calibre9">In the <code class="email">TMap</code> backpack, we store the <code class="email">FString</code> variable of the item that the player is holding. In the <code class="email">Icons</code> map, we store a single reference to the image of the item the player is holding.</p><p class="calibre9">At render time, we<a id="id459" class="calibre1"/> can use the two maps working together <a id="id460" class="calibre1"/>to look up both the quantity of an item that the player has (in his <code class="email">Backpack</code> mapping) and the texture asset reference of that item (in the <code class="email">Icons</code> map). The following screenshot shows how the rendering of the HUD will look:</p><div class="mediaobject"><img src="../images/00145.jpeg" alt="Forward declaration" class="calibre11"/></div><p class="calibre12"> </p><div class="note" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre9">Note that we can also use an array of <code class="email">struct</code> with an <code class="email">FString</code> variable and <code class="email">UTexture2D*</code> in it instead of using two maps.</p><p class="calibre9">For example, we can keep <code class="email">TArray&lt;Item&gt; Backpack;</code> with a <code class="email">struct</code> variable, as shown in the following code:</p><div class="note"><pre class="programlisting">struct Item
{
  FString name;
  int qty;
  UTexture2D* tex;
};</pre></div><p class="calibre9">Then, as we pick up items, they will be added to the linear array. However, counting the number of each item we have in the backpack will require constant reevaluation by iterating through the array of items each time we want to see the count. For example, to see how many hairbrushes you have, you will need to make a pass through the whole array. This is not as efficient as using a map.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Inventory System and Pickup Items">
<div class="book" title="Declaring the backpack">
<div class="book" title="Importing assets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec110" class="calibre1"/>Importing assets</h2></div></div></div><p class="calibre9">You <a id="id461" class="calibre1"/>might have noticed the <span class="strong"><strong class="calibre2">Cow</strong></span> asset in the preceding screenshot, which is not a part of the standard set of assets that UE4 provides in a new project. In order to use the <span class="strong"><strong class="calibre2">Cow</strong></span> asset, you need to import the cow from the <span class="strong"><strong class="calibre2">Content Examples</strong></span> project. There is a standard importing procedure that UE4 uses. </p><p class="calibre9">In the following screenshot, I have outlined the procedure for importing the <span class="strong"><strong class="calibre2">Cow</strong></span> asset. Other assets will be imported from other projects in UE4 using the same method. Perform the following steps to import the <span class="strong"><strong class="calibre2">Cow</strong></span> asset:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Download and open UE4's <span class="strong"><strong class="calibre2">Content Examples</strong></span> project:<div class="mediaobject"><img src="../images/00146.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">After you have downloaded <span class="strong"><strong class="calibre2">Content Examples</strong></span>, open it and click on <span class="strong"><strong class="calibre2">Create Project</strong></span>:<div class="mediaobject"><img src="../images/00147.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Next, name<a id="id462" class="calibre1"/> the folder in which you will put your <code class="email">ContentExamples</code> and click on <span class="strong"><strong class="calibre2">Create</strong></span>.</li><li class="listitem" value="4">Open your <code class="email">ContentExamples</code> project from the library. Browse the assets available in the project until you find one that you like. Searching for <code class="email">SM_</code> will help since all static meshes usually begin with <code class="email">SM_</code> by convention.<div class="mediaobject"><img src="../images/00148.jpeg" alt="Importing assets" class="calibre11"/><div class="caption"><p class="calibre16">Lists of static meshes, all beginning with SM_</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="5">When you <a id="id463" class="calibre1"/>find an asset that you like, import it into your project by right-clicking on the asset and then clicking on <span class="strong"><strong class="calibre2">Migrate...</strong></span>: <div class="mediaobject"><img src="../images/00149.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">Click on<a id="id464" class="calibre1"/> <span class="strong"><strong class="calibre2">OK</strong></span> in the <span class="strong"><strong class="calibre2">Asset Report</strong></span> dialog:<div class="mediaobject"><img src="../images/00150.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="7">Select the <span class="strong"><strong class="calibre2">Content</strong></span> folder from your project that you want to add the <span class="strong"><strong class="calibre2">SM_Door</strong></span> file to. For me, I want to add it to <code class="email">Y:/Unreal Projects/GoldenEgg/Content</code>, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00151.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="8">If the<a id="id465" class="calibre1"/> import was completed successfully, you will see a message as follows:<div class="mediaobject"><img src="../images/00152.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li><li class="listitem" value="9">Once you import your asset, you will see it show up in your asset browser inside your project:<div class="mediaobject"><img src="../images/00153.jpeg" alt="Importing assets" class="calibre11"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div><p class="calibre9">You can then<a id="id466" class="calibre1"/> use the asset inside your project normally.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Inventory System and Pickup Items">
<div class="book" title="Declaring the backpack">
<div class="book" title="Attaching an action mapping to a key"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec111" class="calibre1"/>Attaching an action mapping to a key</h2></div></div></div><p class="calibre9">We need to<a id="id467" class="calibre1"/> attach a key to activate the display of the player's inventory. Inside the UE4 editor, add an <span class="strong"><strong class="calibre2">Action Mappings +</strong></span> called <code class="email">Inventory</code> and assign it to the keyboard key <span class="strong"><em class="calibre10">I</em></span>:</p><div class="mediaobject"><img src="../images/00154.jpeg" alt="Attaching an action mapping to a key" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">In the <code class="email">Avatar.h</code> file, add a member function to be run when the player's inventory needs to be displayed:</p><div class="note"><pre class="programlisting">void ToggleInventory();</pre></div><p class="calibre9">In the <code class="email">Avatar.cpp</code> file, implement<a id="id468" class="calibre1"/> the <code class="email">ToggleInventory()</code> function, as shown in the following code:</p><div class="note"><pre class="programlisting">void AAvatar::ToggleInventory()
{
  if( GEngine )
  {
    GEngine-&gt;AddOnScreenDebugMessage( 0, 5.f, FColor::Red,  "Showing inventory..." );
  }
}</pre></div><p class="calibre9">Then, connect the <code class="email">"Inventory"</code> action to <code class="email">AAvatar::ToggleInventory()</code> in <code class="email">SetupPlayerInputComponent()</code>:</p><div class="note"><pre class="programlisting">void AAvatar::SetupPlayerInputComponent(class UInputComponent*  InputComponent)
{
  InputComponent-&gt;BindAction( "Inventory", IE_Pressed, this,  &amp;AAvatar::ToggleInventory );
  // rest of SetupPlayerInputComponent same as before
}</pre></div></div></div></div>

<div class="book" title="Base class PickupItem" id="25JP21-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec71" class="calibre1"/>Base class PickupItem</h1></div></div></div><p class="calibre9">We need to define how a pickup item looks in code. Each pickup item will derive from a common base class. Let's construct the base class for a <code class="email">PickupItem</code> class now.</p><p class="calibre9">The <code class="email">PickupItem</code> base class<a id="id469" class="calibre1"/> should inherit from the <code class="email">AActor</code> class. Similar to how we created multiple NPC blueprints from the base NPC class, we can create multiple <code class="email">PickupItem</code> blueprints from a single <code class="email">PickupItem</code> base class, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00155.jpeg" alt="Base class PickupItem" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Once you have created the <code class="email">PickupItem</code> class, open its code in Visual Studio.</p><p class="calibre9">The <code class="email">APickupItem</code> class will need quite a few members, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An <code class="email">FString</code> variable<a id="id470" class="calibre1"/> for the name of the item being picked up</li><li class="listitem">An <code class="email">int32</code> variable<a id="id471" class="calibre1"/> for the quantity of the item being picked up</li><li class="listitem">A <code class="email">USphereComponent</code> variable<a id="id472" class="calibre1"/> for the sphere that you will collide with for the item to be picked up</li><li class="listitem">A <code class="email">UStaticMeshComponent</code> variable<a id="id473" class="calibre1"/> to hold the actual <code class="email">Mesh</code></li><li class="listitem">A <code class="email">UTexture2D</code> variable<a id="id474" class="calibre1"/> for the icon that represents the item</li><li class="listitem">A pointer for the HUD (which we will initialize later)</li></ul></div><p class="calibre9">This is how the code in <code class="email">PickupItem.h</code>
<a id="id475" class="calibre1"/> looks:</p><div class="note"><pre class="programlisting">UCLASS()
class GOLDENEGG_API APickupItem : public AActor
{
  GENERATED_UCLASS_BODY()

  // The name of the item you are getting
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
  FString Name;

  // How much you are getting
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
  int32 Quantity;

  // the sphere you collide with to pick item up
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Item)
  TSubobjectPtr&lt;USphereComponent&gt; ProxSphere;

  // The mesh of the item
  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Item)
  TSubobjectPtr&lt;UStaticMeshComponent&gt; Mesh;

  // The icon that represents the object in UI/canvas
  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
  UTexture2D* Icon;

  // When something comes inside ProxSphere, this function runs
  UFUNCTION(BlueprintNativeEvent, Category = Collision)
  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;  SweepResult );
};</pre></div><p class="calibre9">The point of all <a id="id476" class="calibre1"/>these <code class="email">UPROPERTY()</code> declarations is to make <code class="email">APickupItem</code> completely configurable by blueprints. For example, the items in the <span class="strong"><strong class="calibre2">Pickup</strong></span> category will be displayed as follows in the blueprints editor:</p><div class="mediaobject"><img src="../images/00156.jpeg" alt="Base class PickupItem" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">In the <code class="email">PickupItem.cpp</code> file, we <a id="id477" class="calibre1"/>complete the constructor for the <code class="email">APickupItem</code> class, as shown in the following code:</p><div class="note"><pre class="programlisting">APickupItem::APickupItem(const class FPostConstructInitializeProperties&amp; PCIP) : Super(PCIP)
{
  Name = "UNKNOWN ITEM";
  Quantity = 0;

  // initialize the unreal objects
  ProxSphere = PCIP.CreateDefaultSubobject&lt;USphereComponent&gt;(this,  TEXT("ProxSphere"));
  Mesh = PCIP.CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(this,  TEXT("Mesh"));

  // make the root object the Mesh
  RootComponent = Mesh;
  Mesh-&gt;SetSimulatePhysics(true);

  // Code to make APickupItem::Prox() run when this
  // object's proximity sphere overlaps another actor.
  ProxSphere-&gt;OnComponentBeginOverlap.AddDynamic(this,  &amp;APickupItem::Prox);
  ProxSphere-&gt;AttachTo( Mesh ); // very important!	
}</pre></div><p class="calibre9">In the first two lines, we perform an initialization of <code class="email">Name</code> and <code class="email">Quantity</code> to values that should stand out to the game designer as being uninitialized. I used block capitals so that the designer can clearly see that the variable has never been initialized before.</p><p class="calibre9">We then initialize the <code class="email">ProxSphere</code> and <code class="email">Mesh</code> components using <code class="email">PCIP.CreateDefaultSubobject</code>. The freshly initialized objects might have some of their default values initialized, but <code class="email">Mesh</code> will start out empty. You will have to load the actual mesh later, inside blueprints.</p><p class="calibre9">For the mesh, we set it <a id="id478" class="calibre1"/>to simulate realistic physics so that pickup items will bounce and roll around if they are dropped or moved. Pay special attention to the line <code class="email">ProxSphere-&gt;AttachTo( Mesh )</code>. This line tells you to make sure the pickup item's <code class="email">ProxSphere</code> component is attached to the <code class="email">Mesh</code> root component. This means that when the mesh moves in the level, <code class="email">ProxSphere</code> follows. If you forget this step (or if you did it the other way around), then <code class="email">ProxSphere</code> will not follow the mesh when it bounces.</p></div>

<div class="book" title="Base class PickupItem" id="25JP21-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="The root component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec112" class="calibre1"/>The root component</h2></div></div></div><p class="calibre9">In the<a id="id479" class="calibre1"/> preceding code, we assigned <code class="email">RootComponent</code> of <code class="email">APickupItem</code> to the <code class="email">Mesh</code> object. The <code class="email">RootComponent</code> member is a part of the <code class="email">AActor</code> base class, so<a id="id480" class="calibre1"/> every <code class="email">AActor</code> and its derivatives has a root component. The root component is basically meant to be the core of the object, and also defines how you collide with the object. The <code class="email">RootComponent</code> object is defined in the <code class="email">Actor.h</code> file, as shown in the following code:</p><div class="note"><pre class="programlisting">/**
 * Collision primitive that defines the transform (location,  rotation, scale) of this Actor.
 */
UPROPERTY()
class USceneComponent* RootComponent;</pre></div><p class="calibre9">So the UE4 creators intended <code class="email">RootComponent</code> to always be a reference to the collision primitive. Sometimes the collision primitive can be capsule shaped, other times it can be spherical or even box shaped, or it can be arbitrarily shaped, as in our case, with the mesh. It's rare that a character should have a box-shaped root component, however, because the corners of the box can get caught on walls. Round shapes are usually preferred. The <code class="email">RootComponent</code> property<a id="id481" class="calibre1"/> shows up in the blueprints, where you can see and manipulate it.</p><div class="mediaobject"><img src="../images/00157.jpeg" alt="The root component" class="calibre11"/><div class="caption"><p class="calibre16">You can edit the ProxSphere root component from its blueprints once you create a blueprint based on the PickupItem class</p></div></div><p class="calibre12"> </p><p class="calibre9">Finally, the<a id="id482" class="calibre1"/> <code class="email">Prox_Implementation</code> function gets<a id="id483" class="calibre1"/> implemented, as follows:</p><div class="note"><pre class="programlisting">void APickupItem::Prox_Implementation( AActor* OtherActor,  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool  bFromSweep, const FHitResult &amp; SweepResult )
{
  // if the overlapped actor is NOT the player,
  // you simply should return
  if( Cast&lt;AAvatar&gt;( OtherActor ) == nullptr )
  {
    return;
  }

  // Get a reference to the player avatar, to give him
  // the item
  AAvatar *avatar = Cast&lt;AAvatar&gt;(  UGameplayStatics::GetPlayerPawn( GetWorld(), 0 ) );

  // Let the player pick up item
  // Notice use of keyword this!
  // That is how _this_ Pickup can refer to itself.
  avatar-&gt;Pickup( this );

  // Get a reference to the controller
  APlayerController* PController = GetWorld()- &gt;GetFirstPlayerController();

  // Get a reference to the HUD from the controller
  AMyHUD* hud = Cast&lt;AMyHUD&gt;( PController-&gt;GetHUD() );
  hud-&gt;addMessage( Message( Icon, FString("Picked up ") + FString::FromInt(Quantity) + FString(" ") + Name, 5.f, FColor::White, FColor::Black ) );

  Destroy();
}</pre></div><p class="calibre9">A couple <a id="id484" class="calibre1"/>of tips here that are pretty important: first, we have to access a couple of <span class="strong"><em class="calibre10">globals</em></span> to get the objects we need. There are three main <a id="id485" class="calibre1"/>objects we'll be accessing through these functions that manipulate the HUD: the controller (<code class="email">APlayerController</code>), the HUD (<code class="email">AMyHUD</code>), and the player himself (<code class="email">AAvatar</code>). There is only one of each of these three types of objects in the game instance. UE4 has made finding them easy.</p><div class="book" title="Getting the avatar"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec37" class="calibre1"/>Getting the avatar</h3></div></div></div><p class="calibre9">The <code class="email">player</code> class <a id="id486" class="calibre1"/>object can be found at any time from any place in the code by simply calling the following code:</p><div class="note"><pre class="programlisting">AAvatar *avatar = Cast&lt;AAvatar&gt;(
  UGameplayStatics::GetPlayerPawn( GetWorld(), 0 ) );</pre></div><p class="calibre9">We then pass him the item by calling the <code class="email">AAvatar::Pickup()</code> function defined earlier.</p><p class="calibre9">Because the <code class="email">PlayerPawn</code> object is really an <code class="email">AAvatar</code> instance, we cast the result to the <code class="email">AAvatar</code> class, using the <code class="email">Cast&lt;AAvatar&gt;</code> command. The <code class="email">UGameplayStatics</code> family of functions are accessible anywhere in your code—they are global functions.</p></div><div class="book" title="Getting the player controller"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec38" class="calibre1"/>Getting the player controller</h3></div></div></div><p class="calibre9">Retrieving<a id="id487" class="calibre1"/> the player controller is from a <span class="strong"><em class="calibre10">superglobal</em></span> as well:</p><div class="note"><pre class="programlisting">APlayerController* PController =
  GetWorld()-&gt;GetFirstPlayerController();</pre></div><p class="calibre9">The <code class="email">GetWorld()</code> function is actually defined in the <code class="email">UObject</code> base class. Since all UE4 objects derive from <code class="email">UObject</code>, any object in the game actually has access to the <code class="email">world</code> object.</p></div><div class="book" title="Getting the HUD"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec39" class="calibre1"/>Getting the HUD</h3></div></div></div><p class="calibre9">Although<a id="id488" class="calibre1"/> this organization might seem strange at first, the HUD is actually attached to the player's controller. You can retrieve the HUD as follows:</p><div class="note"><pre class="programlisting">AMyHUD* hud = Cast&lt;AMyHUD&gt;( PController-&gt;GetHUD() );</pre></div><p class="calibre9">We cast the HUD object since we previously set the HUD to being an <code class="email">AMyHUD</code> instance in blueprints. Since we will be using the HUD often, we can actually store a permanent pointer to the HUD inside our <code class="email">APickupItem</code> class. We will discuss this point later.</p><p class="calibre9">Next, we implement <code class="email">AAvatar::Pickup</code>, which adds an object of the type <code class="email">APickupItem</code> to Avatar's backpack:</p><div class="note"><pre class="programlisting">void AAvatar::Pickup( APickupItem *item )
{
  if( Backpack.Find( item-&gt;Name ) )
  {
    // the item was already in the pack.. increase qty of it
    Backpack[ item-&gt;Name ] += item-&gt;Quantity;
  }
  else
  {
    // the item wasn't in the pack before, add it in now
    Backpack.Add(item-&gt;Name, item-&gt;Quantity);
    // record ref to the tex the first time it is picked up
    Icons.Add(item-&gt;Name, item-&gt;Icon);
  }
}</pre></div><p class="calibre9">In the preceding code, we check whether the pickup item that the player just got is already in his pack. If it is, we increase its quantity. If it is not in his pack, we add it to both his pack and the <code class="email">Icons</code> mapping.</p><p class="calibre9">To add the pickup items to the pack, use the following line of code:</p><div class="note"><pre class="programlisting">avatar-&gt;Pickup( this );</pre></div><p class="calibre9">The <code class="email">APickupItem::Prox_Implementation</code> is the way this member function will get called.</p><p class="calibre9">Now, we <a id="id489" class="calibre1"/>need to display the contents of our backpack in the HUD when the player presses <span class="strong"><em class="calibre10">I</em></span>.</p></div></div></div>

<div class="book" title="Drawing the player inventory"><div class="book" id="26I9K2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec72" class="calibre1"/>Drawing the player inventory</h1></div></div></div><p class="calibre9">An<a id="id490" class="calibre1"/> inventory screen in a game such as <span class="strong"><em class="calibre10">Diablo</em></span> features a pop-up window, with the icons of the items you've picked up in the past arranged in a grid. We can achieve this type of behavior in UE4.</p><p class="calibre9">There are a number of approaches to drawing a UI in UE4. The most basic way is to simply use the <code class="email">HUD::DrawTexture()</code> calls. Another way is to use Slate. Another way still is to use the newest UE4 UI functionality: <span class="strong"><strong class="calibre2">Unreal Motion Graphics</strong></span> (<span class="strong"><strong class="calibre2">UMG</strong></span>) Designer.</p><p class="calibre9">Slate uses a declarative syntax to lay out UI elements in C++. Slate is best suited for menus and the like. UMG is new in UE 4.5 and uses a heavily blueprint-based workflow. Since our focus here is on exercises that use C++ code, we will stick to a <code class="email">HUD::DrawTexture()</code> implementation. This means that we will have to manage all the data that deals with the inventory in our code.</p></div>

<div class="book" title="Drawing the player inventory">
<div class="book" title="Using HUD::DrawTexture()"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec113" class="calibre1"/>Using HUD::DrawTexture()</h2></div></div></div><p class="calibre9">We will <a id="id491" class="calibre1"/>achieve this in two steps. The first step is <a id="id492" class="calibre1"/>to push the contents of our inventory to the HUD when the user presses the <span class="strong"><em class="calibre10">I</em></span> key. The second step is to actually render the icons into the HUD in a grid-like fashion.</p><p class="calibre9">To keep all the information about how a widget can be rendered, we declare a simple structure to keep the information concerning what icon it uses, its current position, and current size.</p><p class="calibre9">This is how the <code class="email">Icon</code> and <code class="email">Widget</code> structures look:</p><div class="note"><pre class="programlisting">struct Icon
{
  FString name;
  UTexture2D* tex;
  Icon(){ name = "UNKNOWN ICON"; tex = 0; }
  Icon( FString&amp; iName, UTexture2D* iTex )
  {
    name = iName;
    tex = iTex;
  }
};

struct Widget
{
  Icon icon;
  FVector2D pos, size;
  Widget(Icon iicon)
  {
    icon = iicon;
  }
  float left(){ return pos.X; }
  float right(){ return pos.X + size.X; }
  float top(){ return pos.Y; }
  float bottom(){ return pos.Y + size.Y; }
};</pre></div><p class="calibre9">You can <a id="id493" class="calibre1"/>add these<a id="id494" class="calibre1"/> structure declarations to the top of <code class="email">MyHUD.h</code>, or you can add them to a separate file and include that file everywhere those structures are used.</p><p class="calibre9">Notice the four member functions on the <code class="email">Widget</code> structure to get to the <code class="email">left()</code>, <code class="email">right()</code>, <code class="email">top()</code>, and <code class="email">bottom()</code> functions of the widget. We will use these later to determine whether a click point is inside the box.</p><p class="calibre9">Next, we declare the function that will render the widgets out on the screen in the <code class="email">AMyHUD</code> class:</p><div class="note"><pre class="programlisting">void AMyHUD::DrawWidgets()
{
  for( int c = 0; c &lt; widgets.Num(); c++ )
  {
    DrawTexture( widgets[c].icon.tex, widgets[c].pos.X,  widgets[c].pos.Y, widgets[c].size.X, widgets[c].size.Y, 0, 0,  1, 1 );
    DrawText( widgets[c].icon.name, FLinearColor::Yellow,  widgets[c].pos.X, widgets[c].pos.Y, hudFont, .6f, false );
  }
}</pre></div><p class="calibre9">A call to the<a id="id495" class="calibre1"/> <code class="email">DrawWidgets()</code> function <a id="id496" class="calibre1"/>should be added to the <code class="email">DrawHUD()</code> function:</p><div class="note"><pre class="programlisting">void AMyHUD::DrawHUD()
{
  Super::DrawHUD();
  // dims only exist here in stock variable Canvas
  // Update them so use in addWidget()
  dims.X = Canvas-&gt;SizeX;
  dims.Y = Canvas-&gt;SizeY;
  DrawMessages();
  DrawWidgets();
}</pre></div><p class="calibre9">Next, we will fill the <code class="email">ToggleInventory()</code> function. This is the function that runs when the user presses <span class="strong"><em class="calibre10">I</em></span>:</p><div class="note"><pre class="programlisting">void AAvatar::ToggleInventory()
{
  // Get the controller &amp; hud
  APlayerController* PController = GetWorld()- &gt;GetFirstPlayerController();
  AMyHUD* hud = Cast&lt;AMyHUD&gt;( PController-&gt;GetHUD() );

  // If inventory is displayed, undisplay it.
  if( inventoryShowing )
  {
    hud-&gt;clearWidgets();
    inventoryShowing = false;
    PController-&gt;bShowMouseCursor = false;
    return;
  }

  // Otherwise, display the player's inventory
  inventoryShowing = true;
  PController-&gt;bShowMouseCursor = true;
  for( TMap&lt;FString,int&gt;::TIterator it =  Backpack.CreateIterator(); it; ++it )
  {
    // Combine string name of the item, with qty eg Cow x 5
    FString fs = it-&gt;Key + FString::Printf( TEXT(" x %d"), it- &gt;Value );
    UTexture2D* tex;
    if( Icons.Find( it-&gt;Key ) )
      tex = Icons[it-&gt;Key];
    hud-&gt;addWidget( Widget( Icon( fs, tex ) ) );
  }
}</pre></div><p class="calibre9">For the <a id="id497" class="calibre1"/>preceding<a id="id498" class="calibre1"/> code to compile, we need to add a function to <code class="email">AMyHUD</code>:</p><div class="note"><pre class="programlisting">void AMyHUD::addWidget( Widget widget )
{
  // find the pos of the widget based on the grid.
  // draw the icons..
  FVector2D start( 200, 200 ), pad( 12, 12 );
  widget.size = FVector2D( 100, 100 );
  widget.pos = start;
  // compute the position here
  for( int c = 0; c &lt; widgets.Num(); c++ )
  {
    // Move the position to the right a bit.
    widget.pos.X += widget.size.X + pad.X;
    // If there is no more room to the right then
    // jump to the next line
    if( widget.pos.X + widget.size.X &gt; dims.X )
    {
      widget.pos.X = start.X;
      widget.pos.Y += widget.size.Y + pad.Y;
    }
  }
  widgets.Add( widget );
}</pre></div><p class="calibre9">We keep using the <code class="email">Boolean</code> variable in <code class="email">inventoryShowing</code> to tell us whether the inventory is currently displayed or not. When the inventory is shown, we also show the mouse so that the user knows what he's clicking on. Also, when the inventory is displayed, free motion<a id="id499" class="calibre1"/> of the player is disabled. The easiest way to disable a player's free motion is by simply returning from the movement functions before actually moving. The following code is an example:</p><div class="note"><pre class="programlisting">void AAvatar::Yaw( float amount )
{
  if( inventoryShowing )
  {
    return; // when my inventory is showing,
    // player can't move
  }
  AddControllerYawInput(200.f*amount * GetWorld()- &gt;GetDeltaSeconds());
}</pre></div><div class="book" title="Exercise"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec40" class="calibre1"/>Exercise</h3></div></div></div><p class="calibre9">Check<a id="id500" class="calibre1"/> out each of the movement functions with the <code class="email">if( inventoryShowing ) { return; }</code> short circuit return.</p></div></div></div>

<div class="book" title="Drawing the player inventory">
<div class="book" title="Detecting inventory item clicks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec114" class="calibre1"/>Detecting inventory item clicks</h2></div></div></div><p class="calibre9">We can <a id="id501" class="calibre1"/>detect whether someone is<a id="id502" class="calibre1"/> clicking on one of our inventory items by doing a simple hit point-in-box hit. A point-in-box test is done by checking the point of the click against the contents of the box.</p><p class="calibre9">Add the following member function to <code class="email">struct Widget</code>:</p><div class="note"><pre class="programlisting">struct Widget
{
  // .. rest of struct same as before ..
  bool hit( FVector2D p )
  {
    // +---+ top (0)
    // |   |
    // +---+ bottom (2) (bottom &gt; top)
    // L   R
    return p.X &gt; left() &amp;&amp; p.X &lt; right() &amp;&amp; p.Y &gt; top() &amp;&amp; p.Y &lt;  bottom();
  }
};</pre></div><p class="calibre9">The point-in-box test is as follows:</p><div class="mediaobject"><img src="../images/00158.jpeg" alt="Detecting inventory item clicks" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">So, it is a hit if <code class="email">p.X</code> is all of:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Right of <code class="email">left() (p.X &gt; left())</code></li><li class="listitem">Left of <code class="email">right() (p.X &lt; right())</code></li><li class="listitem">Below the <code class="email">top() (p.Y &gt; top())</code></li><li class="listitem">Above the <code class="email">bottom() (p.Y &lt; bottom())</code></li></ul></div><p class="calibre9">Remember <a id="id503" class="calibre1"/>that in UE4 (and UI rendering in general) the <span class="strong"><em class="calibre10">y</em></span> axis <a id="id504" class="calibre1"/>is inverted. In other words, y goes down in UE4. This means that <code class="email">top()</code> is less than <code class="email">bottom()</code> since the origin (the <code class="email">(0, 0)</code> point) is at the top-left corner of the screen.</p><div class="book" title="Dragging elements"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec41" class="calibre1"/>Dragging elements</h3></div></div></div><p class="calibre9">We can <a id="id505" class="calibre1"/>drag elements easily. The first step to enable dragging is to respond to the left mouse button click. First, we'll write the function to execute when the left mouse button is clicked. In the <code class="email">Avatar.h</code> file, add the following prototype to the class declaration:</p><div class="note"><pre class="programlisting">void MouseClicked();</pre></div><p class="calibre9">In the <code class="email">Avatar.cpp</code> file, we <a id="id506" class="calibre1"/>can attach a function to execute on a mouse click and pass the click request to the HUD, as follows: </p><div class="note"><pre class="programlisting">void AAvatar::MouseClicked()
{
  APlayerController* PController = GetWorld()- &gt;GetFirstPlayerController();
  AMyHUD* hud = Cast&lt;AMyHUD&gt;( PController-&gt;GetHUD() );
  hud-&gt;MouseClicked();
}</pre></div><p class="calibre9">Then in <code class="email">AAvatar::SetupPlayerInputComponent</code>, we have to attach our responder:</p><div class="note"><pre class="programlisting">InputComponent-&gt;BindAction( "MouseClickedLMB", IE_Pressed, this,  &amp;AAvatar::MouseClicked );</pre></div><p class="calibre9">The following screenshot shows how you can attach a render:</p><div class="mediaobject"><img src="../images/00159.jpeg" alt="Dragging elements" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">Add a member to the <code class="email">AMyHUD</code> class:</p><div class="note"><pre class="programlisting">Widget* heldWidget;  // hold the last touched Widget in memory</pre></div><p class="calibre9">Next, in <code class="email">AMyHUD::MouseClicked()</code>, we start searching for the <code class="email">Widget</code> hit:</p><div class="note"><pre class="programlisting">void AMyHUD::MouseClicked()
{
  FVector2D mouse;
  PController-&gt;GetMousePosition( mouse.X, mouse.Y );
  heldWidget = NULL; // clear handle on last held widget
  // go and see if mouse xy click pos hits any widgets
  for( int c = 0; c &lt; widgets.Num(); c++ )
  {
    if( widgets[c].hit( mouse ) )
    {
      heldWidget = &amp;widgets[c];// save widget
      return;                  // stop checking
    }
  }
}</pre></div><p class="calibre9">In the <code class="email">AMyHUD::MouseClicked</code> function, we<a id="id507" class="calibre1"/> loop through all the widgets that are on the screen and check for a hit with the current mouse position. You can get the current mouse position from the controller at any time by simply looking up <code class="email">PController-&gt;GetMousePosition()</code>.</p><p class="calibre9">Each widget is checked against the current mouse position, and the widget that got hit by the mouse click will be moved once a mouse is dragged. Once we have determined which widget got hit, we can stop checking, so we have a <code class="email">return</code> value from the <code class="email">MouseClicked()</code> function.</p><p class="calibre9">Hitting widget is not enough, though. We need to drag the widget that got hit when the mouse moves. For this, we need to implement a <code class="email">MouseMoved()</code> function in <code class="email">AMyHUD</code>:</p><div class="note"><pre class="programlisting">void AMyHUD::MouseMoved()
{
  static FVector2D lastMouse;
  FVector2D thisMouse, dMouse;
  PController-&gt;GetMousePosition( thisMouse.X, thisMouse.Y );
  dMouse = thisMouse - lastMouse;
  // See if the left mouse has been held down for
  // more than 0 seconds. if it has been held down,
  // then the drag can commence.
  float time = PController-&gt;GetInputKeyTimeDown(  EKeys::LeftMouseButton );
  if( time &gt; 0.f &amp;&amp; heldWidget )
  {
    // the mouse is being held down.
    // move the widget by displacement amt
    heldWidget-&gt;pos.X += dMouse.X;
    heldWidget-&gt;pos.Y += dMouse.Y; // y inverted
  }
  lastMouse = thisMouse;
}</pre></div><p class="calibre9">Don't forget to include a declaration in the <code class="email">MyHUD.h</code> file.</p><p class="calibre9">The drag function<a id="id508" class="calibre1"/> looks at the difference in the mouse position between the last frame and this frame and moves the selected widget by that amount. A <code class="email">static</code> variable (global with local scope) is used to remember the <code class="email">lastMouse</code> position between the calls for the <code class="email">MouseMoved()</code> function.</p><p class="calibre9">How can we link the mouse's motion to running the <code class="email">MouseMoved()</code> function in <code class="email">AMyHUD</code>? If you remember, we have already connected the mouse motion in the <code class="email">Avatar</code> class. The two functions that we used were <code class="email">AAvatar::Pitch()</code> (the y axis) and <code class="email">AAvatar::Yaw()</code> (the x axis). Extending these functions will enable you to pass mouse inputs to the HUD. I will show you the <code class="email">Yaw</code> function now, and you can extrapolate how <code class="email">Pitch</code> will work from there:</p><div class="note"><pre class="programlisting">void AAvatar::Yaw( float amount )
{
  //x axis
  if( inventoryShowing )
  {
    // When the inventory is showing,
    // pass the input to the HUD
    APlayerController* PController = GetWorld()- &gt;GetFirstPlayerController();
    AMyHUD* hud = Cast&lt;AMyHUD&gt;( PController-&gt;GetHUD() );
    hud-&gt;MouseMoved();
    return;
  }
  else
  {
    AddControllerYawInput(200.f*amount * GetWorld()- &gt;GetDeltaSeconds());
  }
}</pre></div><p class="calibre9">The <code class="email">AAvatar::Yaw()</code> function first checks whether the inventory is showing or not. If it is showing, inputs are <a id="id509" class="calibre1"/>routed straight to the HUD, without affecting <code class="email">Avatar</code>. If the HUD is not showing, inputs just go to <code class="email">Avatar</code>.</p></div><div class="book" title="Exercises"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec42" class="calibre1"/>Exercises</h3></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Complete<a id="id510" class="calibre1"/> the <code class="email">AAvatar::Pitch()</code> function (y axis) to route inputs to the HUD instead of to <code class="email">Avatar</code>.</li><li class="listitem" value="2">Make the NPC characters from <a class="calibre1" title="Chapter 8. Actors and Pawns" href="part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d">Chapter 8</a>, <span class="strong"><em class="calibre10">Actors and Pawns</em></span>, give the player an item (such as <code class="email">GoldenEgg</code>) when he goes near them.</li></ol><div class="calibre14"/></div></div></div></div>
<div class="book" title="Summary" id="27GQ61-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec73" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we covered how to set up multiple pickup items for the player to see displayed in the level and also pick up. In the next chapter, we will introduce <span class="strong"><em class="calibre10">Monsters</em></span> and the player will be able to defend himself against the monsters using magic spells.</p></div></body></html>