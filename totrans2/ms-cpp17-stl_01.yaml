- en: Classical Polymorphism and Generic Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典多态与泛型编程
- en: 'The C++ standard library has two distinct, yet equally important, missions.
    One of these missions is to provide rock-solid implementations of certain concrete
    data types or functions that have tended to be useful in many different programs,
    yet aren''t built into the core language syntax. This is why the standard library
    contains `std::string`, `std::regex`, `std::filesystem::exists`, and so on. The
    other mission of the standard library is to provide rock-solid implementations
    of widely used *abstract algorithms* such as sorting, searching, reversing, collating,
    and so on. In this first chapter, we will nail down exactly what we mean when
    we say that a particular piece of code is "abstract," and describe the two approaches
    that the standard library uses to provide abstraction: *classical polymorphism*
    and *generic programming*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库有两个截然不同但同样重要的任务。其中之一是提供某些具体数据类型或函数的稳固实现，这些类型或函数在许多不同的程序中都有用，但并未内置于核心语言语法中。这就是为什么标准库包含了`std::string`、`std::regex`、`std::filesystem::exists`等等。标准库的另一个任务是提供广泛使用的**抽象算法**（如排序、搜索、反转、排序等）的稳固实现。在本章中，我们将明确说明当我们说某段代码是“抽象的”时，我们指的是什么，并描述标准库用来提供抽象的两种方法：**经典多态**和**泛型编程**。
- en: 'We will look at the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Concrete (monomorphic) functions, whose behavior is not parameterizable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的（单态）函数，其行为不可参数化
- en: Classical polymorphism by means of base classes, virtual member functions, and
    inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基类、虚拟成员函数和继承实现经典多态
- en: Generic programming by means of concepts, requirements, and models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过概念、要求和模型实现泛型编程
- en: The practical advantages and disadvantages of each approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种方法的实际优缺点
- en: Concrete monomorphic functions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体的单态函数
- en: 'What distinguishes an abstract algorithm from a concrete function? This is
    best shown by example. Let''s write a function to multiply each of the elements
    in an array by 2:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是区分抽象算法和具体函数的特征？这最好通过例子来说明。让我们编写一个函数，将数组中的每个元素乘以2：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our function `double_each_element` works *only* with objects of type `array_of_int`;
    passing in an object of a different type won't work (nor even compile). We refer
    to functions like this version of `double_each_element` as *concrete* or *monomorphic*
    functions. We call them *concrete* because they are insufficiently *abstract*
    for our purposes. Just imagine how painful it would be if the C++ standard library
    provided a concrete `sort` routine that worked only on one specific data type!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能`double_each_element`**仅**与`array_of_int`类型的对象一起工作；传递不同类型的对象将不起作用（甚至无法编译）。我们将此类版本的`double_each_element`称为**具体**或**单态**函数。我们称它们为**具体**，因为它们对我们来说不够**抽象**。想象一下，如果C++标准库提供了一个仅对一种特定数据类型工作的具体`sort`例程，那会多么痛苦！
- en: Classically polymorphic functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的多态函数
- en: 'We can increase the abstraction level of our algorithms via the techniques
    of classical **object-oriented** (**OO**) programming, as seen in languages such
    as Java and C#. The OO approach is to decide exactly which behaviors we''d like
    to be customizable, and then declare them as the public virtual member functions
    of an *abstract base class*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过经典**面向对象**（**OO**）编程的技术来提高我们算法的抽象级别，如Java和C#等语言所示。面向对象的方法是决定我们希望哪些行为是可定制的，然后将它们声明为**抽象基类**的公共虚拟成员函数：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside `test`, the two different calls to `double_each_element` compile because
    in classical OO terminology, an `array_of_ints` **IS-A** `container_of_ints` (that
    is, it inherits from `container_of_ints` and implements the relevant virtual member
    functions), and a `list_of_ints` **IS-A** `container_of_ints` as well. However,
    the behavior of any given `container_of_ints` object is parameterized by its *dynamic
    type*; that is, by the table of function pointers associated with this particular
    object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`内部，对`double_each_element`的两次不同调用可以编译，因为在经典的OO术语中，一个`array_of_ints` **是**
    一个`container_of_ints`（即它继承自`container_of_ints`并实现了相关的虚拟成员函数），一个`list_of_ints`
    **也是** 一个`container_of_ints`。然而，任何给定的`container_of_ints`对象的行为由其**动态类型**参数化；也就是说，由与该特定对象关联的函数指针表。
- en: Since we can now parameterize the behavior of the `double_each_element` function
    without editing its source code directly--simply by passing in objects of different
    dynamic types--we say that the function has become *polymorphic*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以通过传递不同动态类型的对象来参数化`double_each_element`函数的行为，而不必直接编辑其源代码，我们可以说这个函数已经变得*多态*。
- en: But still, this polymorphic function can handle only those types which are descendants
    of the base class `container_of_ints`. For example, you couldn't pass a `std::vector<int>`
    to this function; you'd get a compile error if you tried. Classical polymorphism
    is useful, but it does not get us all the way to full genericity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个多态函数只能处理那些是基类`container_of_ints`的子类的类型。例如，你不能将`std::vector<int>`传递给这个函数；如果你尝试这样做，你会得到编译错误。经典多态很有用，但它并没有把我们带到完全泛型的地步。
- en: An advantage of classical (object-oriented) polymorphism is that the source
    code still bears a one-to-one correspondence with the machine code that is generated
    by the compiler. At the machine-code level, we still have just one `double_each_element`
    function, with one signature and one well-defined entry point. For example, we
    can take the address of `double_each_element` as a function pointer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 经典（面向对象）多态的一个优点是源代码仍然与编译器生成的机器代码保持一对一的对应关系。在机器代码级别，我们仍然只有一个`double_each_element`函数，具有一个签名和一个定义良好的入口点。例如，我们可以将`double_each_element`的地址作为函数指针。
- en: Generic programming with templates
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板泛型编程
- en: In modern C++, the typical way to write a fully generic algorithm is to implement
    the algorithm as a *template*. We're still going to implement the function template
    in terms of the public member functions `.size()` and `.at()`, but we're no longer
    going to require that the argument `arr` be of any particular type. Because our
    new function will be a template, we'll be telling the compiler "I don't care what
    type `arr` is. Whatever type it is, just generate a brand-new function (that is,
    a template instantiation) with that type as its parameter type."
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代C++中，编写完全泛型算法的典型方式是将算法实现为一个*模板*。我们仍然将以`.size()`和`.at()`公共成员函数为依据实现函数模板，但我们不再要求参数`arr`是任何特定类型。因为我们的新函数将是一个模板，我们将告诉编译器“我不关心`arr`的类型是什么。无论它是什么类型，只要生成一个新的函数（即模板实例化），使其参数类型为该类型。”
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In most cases, it helps us design better programs if we can put down in words
    exactly what operations must be supported by our template type parameter `ContainerModel`.
    That set of operations, taken together, constitutes what's known in C++ as a *concept*;
    in this example we might say that the concept `Container` consists of "having
    a member function named `size` that returns the size of the container as an `int`
    (or something comparable to `int`); and having a member function named `at` that
    takes an `int` index (or something implicitly convertible from `int`) and produces
    a non-const reference to the *index*'th element of the container." Whenever some
    class `array_of_ints` correctly supplies the operations required by the concept
    `Container`, such that `array_of_ints` is usable with `double_each_element`, we
    say that the concrete class `array_of_ints` *is a model of* the `Container` concept.
    This is why I gave the name `ContainerModel` to the template type parameter in
    the preceding example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果我们能够用文字精确地描述我们的模板类型参数`ContainerModel`必须支持的操作，这有助于我们设计更好的程序。这些操作的总和构成了C++中所谓的*概念*；在这个例子中，我们可以说概念`Container`由“有一个名为`size`的成员函数，它返回容器的大小作为一个`int`（或与`int`相当的东西）；并且有一个名为`at`的成员函数，它接受一个`int`索引（或可以隐式转换为`int`的东西）并产生对容器中*索引*元素的非const引用。”每当某个类`array_of_ints`正确地提供概念`Container`所需的操作，使得`array_of_ints`可以与`double_each_element`一起使用时，我们就说具体类`array_of_ints`*是*`Container`概念的模型。这就是为什么我在前面的例子中将模板类型参数命名为`ContainerModel`。
- en: It would be more traditional to use the name `Container` for the template type
    parameter itself, and I will do that from now on; I just didn't want to start
    us off on the wrong foot by muddying the distinction between the `Container` concept
    and the particular template type parameter to this particular function template
    that happens to desire as its argument a concrete class that models the `Container`
    concept.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Container`作为模板类型参数本身的名称更为传统，从现在开始我将这样做；我只是不想一开始就混淆`Container`概念和特定函数模板的特定模板类型参数之间的区别，这个函数模板恰好希望将其参数设置为模型`Container`概念的具体类。
- en: When we implement an abstract algorithm using templates, so that the behavior
    of the algorithm can be parameterized at compile time by any types modeling the
    appropriate concepts, we say we are doing generic programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用模板实现一个抽象算法，使得算法的行为可以在编译时通过任何建模适当概念的类型进行参数化时，我们说我们在进行泛型编程。
- en: Notice that our description of the `Container` concept didn't mention that we
    expect the type of the contained elements to be `int`; and not coincidentally,
    we find that we can now use our generic `double_each_element` function even with
    containers that don't hold `int`!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们关于 `Container` 概念的描述并没有提到我们期望包含的元素类型是 `int`；并且不是巧合的是，我们发现现在我们甚至可以使用我们的通用
    `double_each_element` 函数，即使容器不包含 `int`！
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This extra level of genericity is one of the big benefits of using C++ templates
    for generic programming, as opposed to classical polymorphism. Classical polymorphism
    hides the varying behavior of different classes behind a stable *interface signature*
    (for example, `.at(i)` always returns `int&`), but once you start messing with
    varying signatures, classical polymorphism is no longer a good tool for the job.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外的泛型级别是使用 C++ 模板进行泛型编程而不是经典多态的一个大优点。经典多态在稳定的 *接口签名*（例如，`.at(i)` 总是返回 `int&`）后面隐藏了不同类的不同行为，但一旦你开始与变化的签名打交道，经典多态就不再是这项工作的好工具。
- en: Another advantage of generic programming is that it offers blazing speed through
    increased opportunities for inlining. The classically polymorphic example must
    repeatedly query the `container_of_int` object's virtual table to find the address
    of its particular virtual `at` method, and generally cannot see through the virtual
    dispatch at compile time. The template function `double_each_element<array_of_int>`
    can compile in a direct call to `array_of_int::at` or even inline the call completely.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程的另一个优点是，它通过增加内联的机会提供了闪电般的速度。经典多态的例子必须反复查询 `container_of_int` 对象的虚表以找到其特定虚拟
    `at` 方法的地址，并且通常无法在编译时看到虚拟调度。模板函数 `double_each_element<array_of_int>` 可以直接调用 `array_of_int::at`
    或甚至完全内联调用。
- en: Because generic programming with templates can so easily deal with complicated
    requirements and is so flexible in dealing with types--even primitive types like
    `int`, where classical polymorphism fails--the standard library uses templates
    for all its algorithms and the containers on which they operate. For this reason,
    the algorithms-and-containers part of the standard library is often referred to
    as the **Standard Template Library** or **STL**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板泛型编程可以如此轻松地处理复杂的需求，并且在处理类型方面非常灵活——甚至对于像 `int` 这样的原始类型，在经典多态中失败的情况下——标准库使用模板来处理所有算法及其操作的容器。因此，标准库中算法和容器部分通常被称为
    **标准模板库** 或 **STL**。
- en: That's right--technically, the STL is only a small part of the C++ standard
    library! However, in this book, as in real life, we may occasionally slip up and
    use the term STL when we mean standard library, or vice versa.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对的——技术上，STL 只是 C++ 标准库的一小部分！然而，在这本书中，就像在现实生活中一样，我们有时可能会不小心使用 STL 这个词，而实际上我们指的是标准库，反之亦然。
- en: 'Let''s look at a couple more hand-written generic algorithms, before we dive
    into the standard generic algorithms provided by the STL. Here is a function template
    `count`, returning the total number of elements in a container:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 STL 提供的标准泛型算法之前，让我们先看看几个手写的通用算法。这里有一个函数模板 `count`，它返回容器中元素的总数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is `count_if`, which returns the number of elements satisfying a user-supplied
    *predicate* function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `count_if`，它返回满足用户提供的 *谓词* 函数的元素数量：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These functions would be used like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的使用方式如下：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is so much power packed into that little expression `pred(elt)`! I encourage
    you to try re-implementing the `count_if` function in terms of classical polymorphism,
    just to get a sense of where the whole thing breaks down. There are a lot of varying
    signatures hidden under the syntactic sugar of modern C++. For example, the ranged
    for-loop syntax in our `count_if` function is converted (or lowered") by the compiler
    into a for-loop in terms of `container.begin()` and `container.end()`, each of
    which needs to return an iterator whose type is dependent on the type of `container`
    itself. For another example, in the generic-programming version, we never specify--we
    never *need* to specify--whether `pred` takes its parameter `elt` by value or
    by reference. Try doing *that* with a `virtual bool operator()`!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个小小的表达式`pred(elt)`中蕴含了如此多的力量！我鼓励你尝试用经典多态重新实现`count_if`函数，只是为了了解整个系统在哪里崩溃。在现代C++的语法糖下隐藏着许多不同的签名。例如，在我们的`count_if`函数中的范围for循环语法被编译器转换（或降低）为基于`container.begin()`和`container.end()`的for循环，每个都需要返回一个迭代器，其类型取决于`container`本身的类型。另一个例子，在泛型编程版本中，我们从未指定——我们从未*需要*指定——`pred`是否通过值或引用接收其参数`elt`。尝试用`virtual
    bool operator()`做*那*件事！
- en: 'Speaking of iterators: you may have noticed that all of our example functions
    in this chapter (no matter whether they were monomorphic, polymorphic, or generic)
    have been expressed in terms of containers. When we wrote `count`, we counted
    the elements in the entire container. When we wrote `count_if`, we counted the
    matching elements in the entire container. This turns out to be a very natural
    way to write, especially in modern C++; so much so that we can expect to see container-based
    algorithms (or their close cousin, range-based algorithms) arriving in C++20 or
    C++23\. However, the STL dates back to the 1990s and pre-modern C++. So, the STL''s
    authors assumed that dealing primarily in containers would be very expensive (due
    to all those expensive copy-constructions--remember that move semantics and move-construction
    did not arrive until C++11); and so they designed the STL to deal primarily in
    a much lighter-weight concept: the *iterator*. This will be the subject of our
    next chapter.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到迭代器：你可能已经注意到，本章中的所有示例函数（无论它们是单态、多态还是泛型）都是用容器来表达的。当我们编写`count`时，我们计算整个容器中的元素数量。当我们编写`count_if`时，我们计算整个容器中匹配的元素数量。这证明是一种非常自然的方式来编写，特别是在现代C++中；如此之多，以至于我们可以期待在C++20或C++23中看到基于容器的算法（或其近亲，基于范围的算法）的出现。然而，STL可以追溯到20世纪90年代和现代C++之前。因此，STL的作者假设主要处理容器将会非常昂贵（由于所有那些昂贵的拷贝构造——记住移动语义和移动构造直到C++11才出现）；因此，他们设计了STL主要处理一个更轻量级的概念：*迭代器*。这将是下一章的主题。
- en: Summary
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Both classical polymorphism and generic programming deal with the essential
    problem of parameterizing the behavior of an algorithm: for example, writing a
    search function that works with any arbitrary matching operation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 经典多态和泛型编程都处理了参数化算法行为的本质问题：例如，编写一个与任何任意匹配操作一起工作的搜索函数。
- en: Classical polymorphism tackles that problem by specifying an *abstract base
    class* with a closed set of *virtual member functions*, and writing *polymorphic
    functions* that accept pointers or references to instances of concrete classes
    *inheriting from* that base class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的多态通过指定一个具有一组封闭的*抽象基类*和*虚成员函数*的类，以及编写接受从该基类继承的具体类实例的指针或引用的*多态函数*来解决该问题。
- en: Generic programming tackles the same problem by specifying a *concept* with
    a closed set of *requirements*, and instantiating *function templates* with concrete
    classes *modeling* that concept.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程通过指定一个具有一组封闭的*要求*的概念，并用具体类实例化*函数模板*来解决这个问题，这些具体类模拟了该概念。
- en: Classical polymorphism has trouble with higher-level parameterizations (for
    example, manipulating function objects of any signature) and with relationships
    between types (for example, manipulating the elements of an arbitrary container).
    Therefore, the Standard Template Library uses a great deal of template-based generic
    programming, and hardly any classical polymorphism.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 经典多态在处理高级参数化（例如，操作任何签名的函数对象）和类型之间的关系（例如，操作任意容器的元素）方面存在困难。因此，标准模板库大量使用了基于模板的泛型编程，而几乎没有使用经典多态。
- en: When you use generic programming, it will help if you keep in mind the conceptual
    requirements of your types, or even write them down explicitly; but as of C++17,
    the compiler cannot directly help you check those requirements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用泛型编程时，如果你能记住你类型的概念性要求，或者甚至将它们明确地写下来，这将有所帮助；但截至C++17，编译器无法直接帮助你检查这些要求。
