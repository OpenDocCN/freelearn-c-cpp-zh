- en: Iostreams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen classical polymorphism in just a couple of places in the
    standard library. We just saw the classically polymorphic `std::pmr::memory_resource`
    in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d), *Allocators*;
    and polymorphism is used "behind the scenes" in the type-erased types `std::any`
    and `std::function`, as detailed in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*. However, by and large, the standard library gets by without
    classical polymorphism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Two places in the standard library, however, make *massive* use of classical
    polymorphism. One is the standard exception hierarchy--for convenience, all exceptions
    thrown by the standard library are subclasses of `std::exception`. (We don't cover
    the exception hierarchy in this book.) The other is the contents of the standard
    `<iostream>` header, which we will cover in this chapter. However, we have a lot
    of background to cover before we get there!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The division of output into buffering and formatting; and of input into buffering,
    lexing, and parsing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POSIX API for unformatted file I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "C" API in `<stdio.h>`, which adds both buffering and formatting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of the classical `<iostream>` API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dangers of *locale-dependent* formatting, and new C++17 features that can
    help avoid them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many ways to convert numeric data to and from strings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trouble with I/O in C++
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common measure of a programming language''s ease of use is what''s called
    **TTHW**--"**time to hello world**." Many popular programming languages have a
    very low TTHW: in many scripting languages, such as Python and Perl, the "hello
    world" program is literally the single line: `print "hello world"`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ and its ancestor C are systems programming languages, which is to say that
    their primary concerns are with "power": control over the machine, speed, and
    (in C++''s case) the ability to leverage the type system with generic algorithms.
    This is a mixture of concerns not suited to small "hello world" programs.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The canonical "hello world" program in C is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In C++, it is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The canonical C++ source code is not much longer than the canonical C source
    code, but it has many more "parameters" or "knobs" that can be adjusted--knobs
    that the novice user must learn about even if all he learns is not to adjust them.
    For example, where, in C, we called a function named `puts` (informally, a "verb"),
    in C++, we apply an *operator* to an object named `std::cout` (so, informally,
    we have both a "verb" and an "indirect object"). In the C++ example, we also had
    to learn a special name for the end-of-line (newline) character--`std::endl`--a
    detail that C's `puts` function hid from us.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, this complexity "turns off" newcomers to C++, especially if they're
    learning C++ in school and maybe aren't sure they want to be learning it in the
    first place. However, this is an unfortunate misunderstanding! You see, the preceding
    "C" source code (using `puts`) is also perfectly valid C++, and there is nothing
    wrong with using the facilities of the `<stdio.h>` header. In fact, in this chapter,
    we'll explain the facilities of `<stdio.h>` before we even tackle the facilities
    of `<iostream>`. However, we'll see that C++14 and C++17 have introduced some
    little-known new features--in headers such as `<string>` and `<utility>`--that
    help with some common I/O tasks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'A note on header naming: I''ve been using the `<stdio.h>` name for the header
    that contains "C-style" I/O facilities. Ever since C++03, there has been a similar
    standard header named `<cstdio>`. The only difference between `<stdio.h>` and
    `<cstdio>` is that in `<stdio.h>`, all of the facilities are guaranteed to be
    in the global namespace (for example, `::printf`) and may or may not be in the
    `std` namespace (for example, `std::printf`); whereas, in `<cstdio>`, they are
    guaranteed to be in `std` (for example, `std::printf`), but not necessarily in
    the global namespace (for example, `::printf`). In practice, there is no difference
    at all, because all major vendors put the facilities in both namespaces, no matter
    which header you include. My recommendation is merely to pick a style and stick
    with it. If your code base uses a lot of POSIX headers, such as `<unistd.h>`,
    which only ever have names with `.h`; it may be aesthetically preferable to stick
    with the `.h` names of the standard "C-style" headers as well.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Buffering versus formatting
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be easier for you to understand both "C-style" I/O and "iostream-style"
    I/O if you remember that there are at least two fundamentally different things
    going on when you "output" some data (and likewise, in reverse, when you input
    some data). Just to have some sort of name for them, let's refer to them as *formatting*
    and *buffering:*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*Formatting* is the task of taking a bunch of strongly typed data values from
    the'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: program--ints, strings, floating-point numbers, user-defined class types--and
    translating or serializing them into "text." For example, when the number 42 is
    printed out as `"42"` (or `"+42"` or `"0x002A"`), that's *formatting*. Generally,
    a formatting library will have its own "mini-language" to describe how you want
    each value to be formatted.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Buffering* is the task of taking a bunch of raw bytes from the program and
    sending them to some output device (on output), or collecting data from some input
    device and making it available to the program as a bunch of raw bytes (on input).
    The part of the library concerned with buffering may do things such as "collect
    4096 bytes of data at a time, then flush"; or it might be concerned with *where*
    the data is going: to a file in the filesystem, a network socket, or an array
    of bytes in memory?'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, I deliberately said that the output of the *formatting* stage is "text"
    and the input to the *buffering* stage is "a bunch of bytes." On sensible operating
    systems, "text" and "bytes" are the same thing. However, if you're on one of those
    strange operating systems where newlines are encoded as two bytes, or where the
    expected encoding for text files is not UTF-8, then there must be some additional
    processing going on in one or both of these stages, or even further downstream
    (such as in the operating system syscall that writes the data to the file). We
    won't talk much more about that kind of thing, because my hope is that you're
    not using that kind of operating system (or locale) for actual production use.
    In production, you should *always* be using UTF-8 for character encoding, and
    UTC for your time zone, and `"C.UTF-8"` for your locale. So, for our purposes,
    we can pretend that "formatting" and "buffering" are the only pieces of the pipeline
    we need to worry about.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: When we're doing input, we do the "buffering" first, to read some unformatted
    bytes from the input device; and then we do "formatting" to turn the bytes into
    strongly typed data values. The "formatting" stage for input may be subdivided
    further into *lexing* (to determine the length of an individual data item in the
    stream) and *parsing* (to determine the actual value of the item from those bytes).
    We'll talk more about lexing in [Chapter 10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d),
    *Regular Expressions*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Using the POSIX API
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important thing to keep in mind whenever we're talking about file I/O
    is that everything I/O-related in C and C++ is built on top of the POSIX standard.
    POSIX is a very low-level specification, almost at the level of Linux system calls,
    that has quite a bit of overlap with the C and C++ standards for I/O; and, if
    you don't understand the gist of the POSIX layer, you'll have a very hard time
    understanding the concepts that come later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that technically, *none* of what follows is standard C++! It is,
    rather, *valid* C++ that conforms to a *non-C++ standard*: the POSIX standard.
    In practice, this means that it''ll work on any operating system except Windows,
    and may even work on modern Windows systems via the **Windows Subsystem for Linux**
    (**WSL**). Regardless, all the standard APIs (both `<stdio.h>` and `<iostream>`)
    are built on top of this model.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The non-standard headers that define most of what follows are `<unistd.h>` and
    `<fcntl.h>`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In POSIX, the term *file* refers to an actual file on disk (or at least in some
    sort of *file system*; forgive me if I occasionally use the word "disk" to refer
    to the file system). Multiple programs can read or write the same file concurrently,
    via operating system resources known as *file descriptors*. In a C or C++ program,
    you'll never see a file descriptor object itself; all you'll see is a handle (or
    pointer) to a file descriptor. These handles (or pointers) present themselves
    not as pointer types, but as small integers--literally, values of type `int`.
    (The committee behind POSIX is not nearly as obsessed with type-safety as your
    average C++ programmer!)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new file descriptor and get an integer handle to it, you use the
    `open` function; for example, `int fd = open("myfile.txt", O_RDONLY)`. The second
    argument is a bitmask, which may contain any of the following bit-flags, or''ed
    together:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**Required**: One and only one "access mode." The possible "access modes" are
    `O_RDONLY` (read only), `O_WRONLY` (write only), and `O_RDWR` (both read and write).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optionally**: Some "open-time flags," describing actions you want the system
    to take at the time the file is opened. For example, `O_CREAT` means "if the named
    file doesn''t exist, please create it for me" (as opposed to returning failure);
    and you can even add `O_EXCL`, which means "...and if the named file *does* exist
    already, then *do* return failure." The other important open-time flag is `O_TRUNC`,
    which means "truncate--clear out, empty, reset--the file after opening it."'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optionally**: Some "operating modes," describing the manner in which I/O
    is to be'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: done via this file descriptor. The important one here is `O_APPEND`.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`O_APPEND` indicates "append mode." When a file is in "append mode," you can
    seek around in it (as you''ll see next) as usual, but every time you write to
    the file, your write is implicitly preceded by a seek to the end of the file (which
    means that after the write, your cursor will be located at the end of the file,
    even if you had just been reading from a different position). Opening a file descriptor
    in append mode is useful if you''re using it for logging, especially if you''re
    using it for logging from different threads. Some standard utility programs, such
    as `logrotate`, work best when the program doing the logging has correctly opened
    their log file in "append mode." In short, append mode is so broadly useful that
    we''ll see it coming back again and again in every one of the higher-level APIs.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Now to explain "cursor" and "seek." Each POSIX file descriptor has some associated
    data--basically its "member variables." One of those pieces of associated data
    is the descriptor's current operating mode; another is the descriptor's current
    *file position indicator*, henceforth referred to as a "cursor." Like the cursor
    in a text editor, this cursor points to the place in the underlying file where
    the next read or write will take place. Using `read` or `write` on a descriptor
    advances its cursor. And, as described in the previous paragraph, using `write`
    on a file descriptor in "append mode" will reset the cursor to the very end of
    the file. Notice that there is only a single cursor per file descriptor! If you
    open a file descriptor with `O_RDWR`, you don't get a read cursor and a write
    cursor; you get just a single cursor that is advanced by reading *and* by writing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`read(fd, buffer, count)`: This reads raw bytes from the underlying file and
    stores them in the given buffer--up to `count` bytes, or until it encounters some
    sort of temporary or permanent error (for example, if we''d need to wait for more
    data over a network connection, or if someone unmounts the underlying filesystem
    in the middle of the read). It returns the number of bytes read; and remember,
    it advances the cursor.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write(fd, buffer, count)`: This writes raw bytes from the given buffer into
    the underlying file--up to `count` bytes, or until it encounters some sort of
    temporary or permanent error. It returns the number of bytes written; and remember,
    it advances the cursor. (And *before* it writes any data, if the file descriptor
    is in append mode, it will seek to the end of the file.)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lseek(fd, offset, SEEK_SET)`: This seeks (that is, moves the cursor) to the
    given offset from the start of the file, and returns that offset (or `-1` if the
    operation fails, for example, by running off the end of the file).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lseek(fd, offset, SEEK_CUR)`: This seeks to the given offset relative to the
    *current* cursor. Relative movements like this generally aren''t important, but
    the special case of `lseek(fd, 0, SEEK_CUR)` is very important because that''s
    how you find out the current position of your cursor!'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lseek(fd, offset, SEEK_END)`: This seeks to the given offset relative to the
    end of the file. Again, this version is most useful when `offset` is zero.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incidentally, there is no way to "copy-construct" a POSIX file descriptor so
    that you can get a second cursor to the same file. If you want two cursors, you'll
    need to `open` the file twice. Confusingly, there *is* a POSIX function named
    `dup`, which takes an integer file descriptor handle and returns a different integer
    that can be used as a second handle to the *same* descriptor; this is a kind of
    primitive reference-counting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: When you're done with a file descriptor, you call `close(fd)` to release your
    handle; if this was the last handle to the descriptor (that is, if nobody has
    called `dup` on it in the meantime), then the file descriptor itself will be reclaimed
    by the operating system--which is to say, the underlying file will be "closed."
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we can write a simple program like this using the
    POSIX API to open, read, write, seek, and close file descriptors:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the POSIX API doesn't bother with anything related to *formatting*.
    It is merely concerned with making sure that we can get raw bytes into and out
    of files on disk; that is, with about half of the *buffering* stage--the "where
    the data is going" half. POSIX doesn't bother with the "buffered output"; when
    you call `write`, your data will be written out. That is, it may still be sitting
    in a buffer at the OS level, or at the disk-controller level, or in the hardware,
    but as far as your program is concerned, the data is *on its way*. Any further
    delay in the output is out of your control and not your fault. This, in turn,
    means that if you need to write a lot of data efficiently using the POSIX API,
    your program must take charge of writing data to a buffer and then sending that
    whole buffer to `write` at once. A single 4096-byte `write` will be much faster
    than a 4,096 one-byte `write`!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Or, instead of writing your own buffer-management code, you could step up one
    level of abstraction and use the C API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard C API
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This description is necessarily almost as brief and incomplete as our discussion
    of POSIX earlier. For a complete description of the facilities in `<stdio.h>`,
    you'll have to consult another source, such as [cppreference.com](https://cppreference.com)
    or your local `man` pages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'In the "C-style" API, POSIX *file descriptors* are given a new name: the thing
    corresponding to a file descriptor is called `FILE`, and the thing corresponding
    to an integer file descriptor handle is (naturally) called `FILE*`. Just as in
    the POSIX API, though, you''ll never construct an instance of `FILE` yourself.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new `FILE` object and get a pointer to it, you use the `fopen`
    function; for example, `FILE *fp = fopen("myfile.txt", "r")`. The second argument
    is a string (that is, a pointer to a null-terminated array of characters--generally,
    you''ll just use a string literal, as I did here), which must be one of the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`"r"`: This is equivalent to POSIX `O_RDONLY`. Open for reading. Fail (that
    is, return `nullptr`) if the file doesn''t exist.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"w"`: This is equivalent to POSIX `O_WRONLY | O_CREAT | O_TRUNC`. Open for
    writing. Create the file if it doesn''t exist. Regardless, make the file empty
    before proceeding.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"r+"`: This is equivalent to POSIX `O_RDWR | O_CREAT`. Open for both reading
    *and* writing. Create the file empty if it doesn''t exist.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"w+"`: This is equivalent to POSIX `O_RDWR | O_CREAT | O_TRUNC`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open for both reading and writing. Create the file if it doesn't exist. Regardless,
    make the file empty before proceeding.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"a"`: This is equivalent to POSIX `O_WRONLY | O_CREAT | O_APPEND`. Open for
    writing. Create the file empty if it doesn''t exist. Enter append mode.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"a+"`: This is equivalent to POSIX `O_RDWR | O_CREAT | O_APPEND`. Open for
    both reading *and* writing. Create the file empty if it doesn''t exist. Enter
    append mode.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that there is some pattern to the preceding strings--strings with `'+'`
    always map to `O_RDWR`, strings with `'w'` always map to `O_TRUNC`, and strings
    with `'a'` always map to `O_APPEND`; however, there is no perfectly regular pattern
    that describes the mapping from `fopen` mode strings into POSIX `open` flags.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Some platforms support appending additional characters to the mode string; for
    example, a common extension on POSIX platforms is that an added `'x'` means `O_EXCL`;
    on GNU platforms, an added `'e'` means `O_CLOEXEC`; and on Windows, a similar
    behavior can be gotten by adding a capital `'N'`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The one character that can be appended to the mode string on any platform (that
    is, it's guaranteed by the C++ standard to be available everywhere) is `'b'`,
    for "binary." This matters only on Windows, where, if you do *not* specify this
    character, the library will automatically translate every `'\n'` byte you output
    into the Windows line terminator sequence, `'\r', '\n'`. If you specifically do
    want this translation when running on Windows, a useful convention is to add `'t'`
    to your mode string. All vendors' libraries will recognize and ignore this character;
    it merely serves as an indication to the human reader that indeed you meant to
    open the file in "text" mode, and didn't accidentally omit an intended `'b'`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: When you're done using a file, you must call `fclose(fp)`, which corresponds
    to calling `close(fd)` on the underlying file descriptor handle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with the bookkeeping on C-style `FILE` pointers, you may want to use
    the RAII smart pointers from [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*. You can write a "unique `FILE` pointer" like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Moreover, remember that you can always move `unique_ptr` into `shared_ptr`
    if you want the reference-counted, "last person out of the room turns out the
    lights" semantics:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Buffering in the standard C API
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard C API offers a family of functions that look just like the POSIX
    functions,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: but with the letter `f` on the front.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The `fread(buffer, 1, count, fp)` method reads raw bytes from the underlying
    file and stores them in the given buffer--up to `count` bytes, or until it encounters
    some sort of permanent error (for example, if someone unmounts the underlying
    filesystem in the middle of the read). It returns the number of bytes read and
    advances the cursor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The literal `1` in that call is not a mistake! Technically, the function signature
    is `fread(buffer, k, count, fp)`. It reads up to `k * count` bytes, or until it
    encounters a permanent error and returns the number of bytes read divided by `k`.
    However, in your own code, `k` should always be the literal `1`; using anything
    else is a mistake, for at least two reasons. First, since the return value is
    always divided by `k`, and if `k` is anything but `1`, you will lose information.
    For example, if `k` is 8, a return value of 3 indicates that "somewhere between
    24 and 31" bytes were read and stored into the buffer, but `buffer[3]` may now
    contain a partially written value--that is to say, garbage--and you have no way
    of detecting that. Second, since the library internally multiplies `k * count`,
    passing any `k` other than 1 runs the risk of overflow and an incorrectly computed
    buffer length. No popular implementation checks that multiplication for overflow;
    this is for performance reasons if nothing else. It doesn't make sense to spend
    CPU time on an expensive division operation if every programmer already knows
    never to pass any other value for `k` but 1!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The `fwrite(buffer, 1, count, fp)` method writes raw bytes from the given buffer
    into the underlying file--up to `count` bytes, or until it encounters some sort
    of permanent error. It returns the number of bytes written, and advances the cursor.
    (And *before* it writes any data, if the file descriptor is in append mode, it
    will seek to the end of the file.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The `fseek(fp, offset, SEEK_SET)` method seeks (that is, moves the cursor) to
    the given offset from the start of the file; `fseek(fp, offset, SEEK_CUR)` seeks
    to the given offset relative to the *current* cursor; and `fseek(fp, offset, SEEK_END)`
    seeks to the given offset relative to the end of the file. Unlike the POSIX `lseek`,
    the standard C version `fseek` does *not* return the value of the current cursor;
    it merely returns `0` on success or `-1` on failure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The `ftell(fp)` method returns the value of the current cursor; that is, it's
    equivalent to the underlying POSIX call `lseek(fd, 0, SEEK_CUR)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of underlying POSIX calls: if you are on a POSIX platform and need
    to do something non-portable with the POSIX file descriptor underlying a standard
    C `FILE *`, you can always retrieve the file descriptor by calling `fileno(fp)`.
    So, for example, we could express `ftell` as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Working with `fread` and `fwrite` is quite possible, but it is not the most
    common way of using the C API. Many programs prefer to deal with input and output
    not in terms of large chunks of data but rather character by character, or byte
    by byte. The original "Unix philosophy" is oriented toward small simple command-line
    utilities that read and transform a "stream" of bytes; these small stream-oriented
    programs are known as "filters," and they really shine when you link them together
    with the Unix shell''s pipes. For example, here is a tiny program that opens a
    file and counts the number of bytes, space-separated "words," and lines in that
    file using the `<stdio.h>` API:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (Do you recognize it? This is the command-line utility `wc`.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'This program introduces two new ideas (besides the standard guarantee that
    all the `FILE` objects are implicitly closed at program exit so that it is safe
    for us to omit the `fclose` bookkeeping and save a few lines in this example).
    The first is the idea of *standard streams*. There are three standard streams
    in C and C++: `stdin`, `stdout`, and `stderr`. In our word-counting program, we
    follow the rule that if the command-line user has not explicitly told us any filename
    to read from, we''ll read from `stdin`, the *standard input stream*, which is
    usually a synonym for the console (or terminal or keyboard--point is, it''s the
    human being sitting there typing). Various mechanisms within the operating system
    and the command-line shell can be used to *redirect* the standard input stream
    from other inputs; these mechanisms (such as typing `wc <myfile.txt` at the shell
    prompt) are far outside the scope of this book. The main things to remember about
    the three standard streams are that they are automatically available to you by
    name without having to `fopen` them; and that it is always an error to `fclose`
    any of them.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The second new idea introduced in our word-counting program is the `getc` function.
    The `getc(fp)` function reads a single byte from the given `FILE *` and returns
    the byte it read. If there was an error, or (more likely) if it hit end-of-file,
    it returns a special value named `EOF`. The numerical value of `EOF` is usually
    `-1;`, but the guaranteed thing about it is that it is completely different from
    any possible *valid* byte. For this reason, `getc(fp)` does not return its return
    value as `char`; it returns it as `int`, which is big enough to store any possible
    `char` and, in addition, big enough to store the value `EOF` distinct from any
    of those `char` values (if `char` is a signed type on your platform--as it is
    on many platforms--then `getc` will convert `char` it read into `unsigned char`
    before returning it; this ensures that if the `0xFF` byte appears in the input
    file, it will be returned as `255`, which is a different integer value than `-1`
    that represents `EOF`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the crucial difference between `fread`/`fwrite` and `read`/`write`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the POSIX API doesn't do any additional buffering of input or output
    bytes;
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: when you call `read`, you're going all the way to the operating system to retrieve
    the
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'next chunk of input bytes. If `getc(fp)` were implemented as `fread(&ch, 1,
    1, fp)`, and `fread(buf, 1, count, fp)` were implemented as `read(fileno(fp),
    buf, count)`, then our word-counting program would be horrendously inefficient--reading
    a file of a million bytes would result in a million system calls! So, when the
    C library wraps a file descriptor handle in a `FILE` object, it also adds one
    more feature: *buffering*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`FILE` streams may be "unbuffered" (meaning that every `fread` really does
    correspond to `read`, and every `fwrite` to `write`); "fully buffered," also known
    as "block buffered" (meaning that writes will be accumulated into a private buffer
    that is sent to the underlying file descriptor only when it becomes full, and
    likewise, reads will be served from a private buffer that is refilled from the
    underlying file descriptor only when it becomes empty); or "line-buffered" (meaning
    that there is a private buffer just like the previous case, but writing `''\n''`
    causes a flush even if the buffer is not yet full). When the program starts up
    and opens its standard streams, `stdin` and `stdout` will be line-buffered, and
    `stderr` will be unbuffered. Any files you open yourself via `fopen` will generally
    be fully buffered, although the operating system may have something to say about
    that as well; for example, if the "file" you''re opening is actually a terminal
    device, it may end up being line-buffered by default.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In the very rare case that you need to control the buffering mode of a `FILE`
    stream, you can do it via the standard `setvbuf` function. You can also use `setvbuf`
    to provide your own buffer, as shown in the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice the discrepancy between `ftell(fp)` and `lseek(fd, 0, SEEK_CUR)` in the
    last line of the example. Ten bytes remain buffered in the buffer of `FILE`; so
    `FILE` reports that your cursor is currently at offset 160, but, in actuality,
    the underlying POSIX file descriptor's cursor is still at offset 150, and will
    remain there until the `FILE`'s buffer fills up and is flushed a second time--at
    which point the underlying POSIX file descriptor's cursor will jump to offset
    300\. This feels awkward, but it's actually exactly what we want! We *want* the
    efficiency that comes with writing the underlying file descriptor in large chunks.
    (Note that 150 bytes is not "large" in reality. A typical default file buffer
    size, if you don't use `setvbuf` at all, would be more like 4096 bytes.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'On some platforms, calling `ftell` will cause the buffer to be flushed as a
    side effect, since that makes the library''s bookkeeping easier; the library doesn''t
    like to be caught telling lies. (Calling `fseek` is also a likely way to cause
    a flush.) However, on other platforms, `ftell` and even `fseek` don''t always
    flush the buffer. To make sure that your `FILE` stream''s buffer has definitely
    been flushed to the underlying file, use `fflush`. Let''s continue the previous
    example as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Putting it all together, we can rewrite our simple program from the *Using
    the POSIX API* section like this, using the `<stdio.h>` API to open, read, write,
    seek, flush, and close file streams:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This concludes our exploration of the *buffering* capabilities of the standard
    `<stdio.h>` API; now, we move on to consider how `<stdio.h>` deals with *formatting*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Formatting with printf and snprintf
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the formatting stage, we start with the high-level data values that we want
    to print out; for example, we might want to print the number of piano tuners in
    Chicago, which our program has computed as 225\. Printing out the *three-byte
    string* `"225"` is easy; we've solved that in the preceding sections. The task
    of *formatting* is to get us from the number 225 (an `int`, let's say) to that
    three-byte string `"225"`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'When printing numbers, we have many possible concerns: should the number be
    printed in base 10, base 16, base 8, base 2, or some other base? If the number
    is negative, presumably, we should prefix it with `-`; if it is positive, should
    we prefix it with `+`? Should we use thousands-separators, and if so, should we
    use commas, periods, or spaces? What about decimal points? Once we''re talking
    about floating-point numbers, how many digits after the decimal point should we
    print? Or should we use scientific notation, and if so, to how many significant
    digits?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Then, there are concerns that extend even to non-numeric input. Should the printed
    value be aligned within a fixed-width column, and if so, should it be left-aligned,
    right-aligned, or even aligned in some other clever way? (And what character should
    we use to fill the unoccupied columns?) What if the value doesn't fit in the given
    column width--should it be truncated left or right or just overflow the column's
    bounds?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when reading formatted input (that is, *parsing*), we have to answer
    many of the same questions about numerics: do we expect thousands-separators?
    Scientific notation? Leading `+` signs? What numeric base do we expect? And even
    for non-numerics: do we expect leading whitespace? If we''re reading in a value
    of type "string," what indicates the end of the value other than `EOF`?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard C API provides a whole family of formatting functions with names
    ending in `printf`, and a matching family of parsing functions with names ending
    in `scanf`. A commonality of every function in this family is that it takes a
    variadic argument list (using C-style varargs, not C++ variadic templates) and,
    prior to the variadic arguments, a single "format string" that answers many of
    the above questions (but not all of them) for each argument to be formatted, and
    also provides a "shape" for the overall message, into which the library will insert
    the formatted arguments:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also `fprintf(fp, "format", args...)` to print to any arbitrary stream
    (not necessarily `stdout`); `snprintf(buf, n, "format", args...)` to write to
    a buffer, about which we''ll discuss more in a moment; and a matching family of
    `vprintf`, `vfprintf`, and `vsnprintf` functions that are useful in building your
    own printf-like functions. As you''ve probably learned to expect in this chapter,
    a complete treatment of C-style format strings is out of the scope of this book.
    However, the C-style "format string language" is widely used even in languages
    that don''t directly descend from C; for example, in Python 2, you can say:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, there are major differences between what's happening in C and what's
    happening in Python!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest difference is that Python is dynamically typed, so if you write
    `"%s tuners" % (tuners)`, it will still be able to do the right thing. With C-style
    variadic argument lists, the original type of `tuners` is lost; if you use the
    `"%s"` format specifier (which expects a `const char *` argument) with an argument
    of type `int`, you''ll get a friendly compiler warning at best and undefined behavior
    at worst. That is to say, when you use `<stdio.h>` formatting functions, the format
    string does double duty: it encodes not only *how to format* each data value,
    but also *the type of* each data value--and if you get one of those types wrong,
    such as by using `"%s"` when you meant `"%d"`, then your program will have a bug.
    Fortunately, all major compilers can detect and diagnose such mismatches these
    days, as long as your format string is passed directly to `printf` or to a function
    annotated with the (non-standard) `format` attribute, as demonstrated in the code
    sample we''ll see shortly. Unfortunately, these diagnostics can be unreliable
    when you''re dealing with typedefs for platform-dependent types; for example,
    some 64-bit compilers will not diagnose an attempt to format a `size_t` value
    with the `"%llu"` format specifier, even though the properly portable specifier
    would be `"%zu"`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that in C, `printf` is effectively writing directly to
    the standard output stream, `stdout`; the formatting of the data is interleaved
    with the buffering of the output bytes. In Python, the `"There are %d piano tuners
    in %s." % (tuners, where)` construct is actually an *expression* of type `str`
    (string); all of the formatting happens right there, producing a single string
    value with the proper bytes, before we decide that the string is to be printed
    to `stdout` at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce a formatted string using the `<stdio.h>` API, we will use `snprintf`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that `snprintf` always null-terminates its buffer, even if it means
    not writing the entire message into it; and it returns `strlen` of the message
    that it *wanted* to write. A common idiom to format an arbitrarily long message
    is to call `snprintf` first with `nullptr`, to learn the message''s final size;
    and then call it a second time with a buffer of that size:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding implementation of `format` uses a variadic function template,
    which will tend to produce a lot of similar copies of the code. A more efficient
    implementation (in terms of compile time and code bloat) would be to use a single
    (non-template) function with a C-style variadic argument list, and use `vsnprintf`
    for formatting. Sadly, further discussion of `va_list` and `vsnprintf` is far
    outside the scope of this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll defer the discussion of the `scanf` format strings until the *recipes*
    portion of this chapter. For a complete treatment of `scanf`, consult [cppreference.com](https://cppreference.com)
    or a book on the C standard library.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Having seen how both buffering and formatting (at least, output formatting)
    work in the `<stdio.h>` regime, we now move on to the standard C++ `<iostream>`
    API.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The classical iostreams hierarchy
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<stdio.h>` API suffers from at least three problems. First, the formatting
    functionality is far from type-safe. Second, the buffering functionality is awkwardly
    split up into "buffering into a file stream" (`FILE *` and `fprintf`) and "buffering
    into a character buffer" (`snprintf`). (Okay, technically, the GNU C library provides
    `fopencookie` to construct `FILE *` that buffers into anything you want; but this
    is fairly obscure and extremely non-standard.) Third, there is no easy way to
    extend the formatting functionality for user-defined classes; I cannot even `printf`
    a `std::string`, let alone `my::Widget`!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When C++ was being developed in the mid-1980s, the designers felt a need for
    a type-safe, composable, and extensible I/O library. Thus was born the feature
    known as "iostreams," or simply as "C++ streams" (not to be confused with the
    `<stdio.h>` streams we just finished talking about). The fundamental architecture
    of iostreams has not changed since the mid-1980s, which makes it very different
    from anything else in the standard library with the possible exception (no pun
    intended) of the `std::exception` hierarchy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ iostreams library consists of two major pieces: *streams*, which are
    concerned with formatting, and `streambufs`, which are concerned with buffering.
    The majority of C++ programmers will never interact with streambufs; only with
    streams. However, let''s very quickly explain what a streambuf is.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: A streambuf is very similar to `FILE` in the C API. It tells the program where
    the input (in the form of raw bytes) should come from, and where the output should
    go to. It also maintains a buffer of bytes to reduce the number of round-trips
    to those destinations (such as the POSIX `read` and `write` functions). In order
    to allow different kinds of streambufs with the same interface--well, remember
    my promise that we'd see classical polymorphism in this chapter? We've finally
    gotten to it!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '`std::streambuf` (which is actually an alias for `std::basic_streambuf<char,
    char_traits<char>>`, but let''s not make this any more complicated) is the base
    class of an inheritance hierarchy whose derived classes are `std::filebuf` and
    `std::stringbuf`. The virtual methods provided by the `streambuf` interface are
    too many to list, but they include `sb.setbuf(buf, n)` (corresponding to `setvbuf(fp,
    buf, _IO_FBF, n)`), `sb.overflow()` (corresponding to `fflush(fp)`), and `sb.seekpos(offset,
    whence)` (corresponding to `fseek(fp, offset, whence)`). When I say corresponding,
    I mean corresponding for `std::filebuf`, of course. These methods have implementation-defined
    (and in practice, non-portable) behavior when called on `std::stringbuf`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Any `streambuf` derived class must also support some primitive operations to
    interact with its buffer (to put in and take out bytes). These primitive operations
    are not for use by normal programmers, though; they're for use by the *stream*
    object that wraps this streambuf and provides a more programmer-friendly interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'A C++ *stream* encapsulates a streambuf and restricts the set of operations
    you can do on it. For example, notice that `streambuf` doesn''t have any conception
    of "access mode": you can put bytes into it ("write") as easily as you can take
    bytes out ("read"). However, when we take that `streambuf` and wrap it in a `std::ostream`,
    the `ostream` object exposes only a `write` method; there is no `read` method
    on `ostream`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram expresses the class hierarchy of streams and streambufs
    in C++17, as defined in the standard `<iostream>`, `<fstream>`, and/or `<sstream>`
    headers. The `streambuf`, `istream`, `ostream`, and `iostream` base classes are
    "abstract-ish": while they have no pure virtual methods, they contain only the
    `streambuf*` member variable inherited from `ios`. To protect you from accidentally
    constructing instances of these "abstract-ish" types, the standard library defines
    their constructors as `protected`. Contrariwise, the classes with names containing
    `stringstream` and `fstream` actually contain instances of `stringbuf` and `filebuf`
    respectively, to which their constructors initialize the inherited `streambuf*`
    member to point. Later in this chapter, in the *Solving the sticky-manipulator
    problem* section, we''ll see how to construct an `ostream` object whose `streambuf*`
    member points to a streambuf instance not owned by `*this`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'The stream classes expose a motley collection of methods that correspond, more
    or less exactly, to the functions we''ve seen twice before. In particular, the
    `fstream` class wraps `filebuf` and, together, they behave a lot like `FILE` from
    the C API: `filebuf` has a "cursor" that you can manipulate with the `seekp` method
    of `fstream`. (The name `seekp` is inherited from the `ostream` class. On `ifstream`,
    the method is named `seekg`: "g" for "get" and "p" for "put." On a full `fstream`,
    you can use either `seekg` or `seekp`; they are synonyms in that case. As always,
    remember that there is just a single cursor, even though the iostreams API has
    two different *names* for the cursor in this case!)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of `fstream` takes a bitmask or''ed together from the `std::ios_base::in`,
    `out`, `app` (for "append mode"), `trunc`, `ate`, and `binary` flag values; however,
    just as we saw with `fopen`, there is only a very small dash of rhyme and reason
    as to how those flags are translated into POSIX `open` flags:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`in`: This is equivalent to `fopen("r")`, or POSIX `O_RDONLY`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`out`: This is equivalent to `fopen("w")`, or POSIX `O_WRONLY | O_CREAT | O_TRUNC`.
    (Notice that `out` alone means `O_TRUNC` even if `trunc` was not passed!)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in|out`: This is equivalent to `fopen("r+")`, or POSIX `O_RDWR | O_CREAT`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in|out|trunc`: This is equivalent to `fopen("w+")`, or POSIX `O_RDWR | O_CREAT
    | O_TRUNC`. (Notice that the iostreams syntax makes more sense than the `fopen`
    syntax, in this case.)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`out|app`: This is equivalent to `fopen("a")`, or POSIX `O_WRONLY | O_CREAT
    | O_APPEND`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in|out|app`: This is equivalent to `fopen("a+")`, or POSIX `O_RDWR | O_CREAT
    | O_APPEND`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `binary` to the bitmask is just like adding `"b"` to `fopen`. Adding
    `ate` tells the stream to begin with a seek to the end of the file, even if the
    file is not being opened in `O_APPEND` mode.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Passing an unsupported set of flags, such as `app|trunc`, will still construct
    the stream object, but place it into the "fail" state, which we'll discuss soon.
    In general, you should design your own classes' constructors so that failure is
    indicated by an exception. That rule is broken here partly because this class
    hierarchy was designed almost forty years ago, and partly because we need a "failure"
    mechanism anyway, to deal with the relatively likely possibility that the named
    file cannot be opened (for example, if it doesn't exist).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we can rewrite our simple program from "Using the
    POSIX API" like this, using the `<fstream>` API to open, read, write, seek, flush,
    and close file streams:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One odd thing about the preceding example is that `fsr.read(buffer.data(), 14)`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: does not return any indication of how many bytes were read! Instead, it stores
    the count of bytes read in a member variable, and you must retrieve the count
    yourself via the accessor `fsr.gcount()` function. And the `write` method doesn't
    even allow you to find out how many bytes were written. This may seem like a problem;
    but, in general, if a stream encounters an error on reading or writing, the error
    is often essentially "unrecoverable" anyway, due to the uncertain number of bytes
    *actually* read from or written to the underlying file descriptor and due to the
    several layers of buffers between the application program and hardware. When a
    read or write error is encountered, we pretty much have to give up on understanding
    the state of that stream at all--*except* in the special case of "end of file"
    on input. If we intended to read 100 bytes and instead hit "end of file," it is
    meaningful to ask, "How many bytes did we succeed at reading?" However, if we
    intended to *write* 100 bytes and instead received a network error, or a disk
    error, it's not so meaningful to ask, "How many bytes did we succeed at writing?"
    We simply cannot tell whether our "written" bytes managed to reach their destination
    or not.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If we asked for 100 bytes and only read 99 (or fewer) before hitting end-of-file,
    then not only will `fs.gcount()` report a number less than 100, but also the *eof
    indicator* will be set on the stream object's state. You can ask any stream about
    its current state with the accessor functions `fs.good()` (is it hunky-dory?),
    `fs.bad()` (did the underlying stream encounter an unrecoverable error?), `fs.eof()`
    (did the last input operation hit end-of-file?), and `fs.fail()` (did the last
    operation "fail" for any reason?). Notice that `fs.good()` is not the inverse
    of `fs.bad()`; it is possible for a stream to be in a state, such as *eof,* that
    is, `!good() && !bad()`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen the simplest, most primitive way to do buffered input and output
    using `fstream` streams. However, if you're using C++ streams like this, you may
    as well just be using `FILE *`, or even the POSIX API. The "new and (arguably)
    improved" thing about C++ streams is the way they handle *formatting*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Streaming and manipulators
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that with `printf`, the original types of the arguments are lost, and
    so the format string must do double duty, encoding not only *how to format* each
    data value, but also *the type of* each data value. When we use iostreams, this
    disadvantage goes away. Formatting with iostreams looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `std::cout` is a global variable of type `ostream`, corresponding to `stdout`
    or POSIX file descriptor 1\. There's also `std::cerr`, corresponding to unbuffered
    `stderr` or POSIX file descriptor 2; `std::clog`, again corresponding to file
    descriptor 2 but fully buffered this time; and `std::cin`, a global variable of
    type `istream`, corresponding to `stdin` or POSIX file descriptor 0.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard `ostream` class, which, again, is really `basic_ostream<char,
    char_traits<char>>`, but let''s ignore that) has many, many non-member overloads
    of `operator<<`. For example, here''s the simplest possible overloaded `operator<<`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As this function returns a reference to the same `os` it received, we can chain
    the `<<` operators together, as shown in the previous example. This allows us
    to format complicated messages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, our simple `operator<<(ostream&, const string&)` is not nearly
    sufficient to satisfy the variety of formatting concerns described in the *Formatting
    with printf and snprintf* section. Suppose we wanted to print that left-aligned
    string in a column of width 7; how would we do that? The `operator<<` syntax doesn''t
    allow us to pass any additional "formatting option" parameters, which means that
    we simply *cannot* do complicated formatting unless the formatting options are
    carried along in either the left-hand side of `<<` (the ostream object itself)
    or the right-hand side (the object to be formatted). The standard library uses
    a mix of both approaches. Generally, functionality that first appeared in the
    1980s and 1990s carried its formatting options in the ostream object itself; and
    anything added later--not being able to add new member variables to `ostream`
    without breaking binary compatibility--has had to make do by fiddling with the
    right-hand side of the `<<` operator. Let''s look at alignment within a column,
    as an example of the 1980s approach. This is a slightly more full-featured version
    of our `operator<<` for `std::string`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `os.width()`, `os.flags()`, and `os.fill()` are all built-in members of
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: the `std::ostream` class. There's also `os.precision()` for floating-point numbers,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'and `os.flags()` can indicate the base-10, base-16, or base-8 output for some
    numeric types as well. You can set the "column width" state on a stream by calling
    `os.width(n)`; however, it would be quite painful (and silly!) if we had to set
    up by writing `std::cout.width(10)`, `std::cout.setfill(''.'')`, and so on, before
    each output operation. So, the iostreams library provides some standard *stream
    manipulators* that can be used to get the effect of these member functions but
    in a more "fluent" manner. These manipulators are generally defined in a standard
    header, `<iomanip>`, not in `<iostream>` proper. For example, here''s a manipulator
    that sets the column width of a stream:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here are two more standard manipulators, one of which should look very
    familiar to you by now. The `std::endl` manipulator streams a newline to the output
    stream and then flushes it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have `std::setw`; its friends, `std::left`, `std::right`, `std::hex`,
    `std::dec`, `std::oct`, `std::setfill`, and `std::precision`; and all the rest--I
    say once we have all these manipulators--, we can write iostreams code that looks
    almost natural, if extremely verbose. Compare these `<stdio.h>` and `<iostream>`
    snippets:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Bear in mind that every time we use one of these manipulators, we are imperatively
    affecting the state of the stream object itself; this effect may persist for longer
    than just the current output statement. For example, our preceding snippet may
    continue like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `std::hex` manipulator from the previous example set the mode of this stream
    to "hexadecimal output for numbers," and nothing ever set it back to the "default"
    decimal mode. So now we've unintentionally made everything later in the program
    also print in hex! This is a major disadvantage of the iostreams library (and
    of stateful, imperative programming in general).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Streaming and wrappers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The parameters provided by `std::ios_base` (`left`, `right`, `hex`, `width`,
    `precision`, and so on) are a closed set--a set defined in the mid-1980s and basically
    untouched since then. Since each manipulator modifies one of these parameters
    in the state of the stream, the set of manipulators is essentially closed as well.
    The modern way to affect the formatting of a particular data value is to wrap
    it in a *wrapper*. For example, suppose that we have written a generic algorithm
    for quoting values in a data file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '(This algorithm is not part of the standard library.) Having this algorithm
    in hand, we could easily construct a wrapper class, where the wrapper class''
    `operator<<` would invoke the following algorithm:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '(The `std::ostreambuf_iterator<char>` type is part of the standard library;
    it comes from the `<iterator>` header. We''ll see its friend, `istream_iterator`,
    later in this chapter.) Then, having the wrapper class, we''d be able to write
    very reasonable-looking code to print quoted values to an output stream:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The wrapper we just invented bears a deliberate resemblance to the `std::quoted`
    wrapper function found in the standard library's `<iomanip>` header. The major
    difference is that `std::quoted` doesn't use an iterator-based algorithm to produce
    its output; it constructs the entire output in a local `std::string` variable
    and then uses `os << str` to print it out in one fell swoop. This means that `std::quoted`
    is *not allocator-aware* (see [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*) and thus is not suitable for environments where heap allocation
    is forbidden. While the fine details may have been botched in this case,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'the fundamental idea of using a wrapper function or class to adjust the formatting
    of a data value is a good one. You can see it taken to extremes in libraries like
    Boost.Format, where syntax like the following is legal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Prefer to use wrappers that describe self-contained formatting operations instead
    of manipulators, which "stickily" mutate the state of the stream. In the preceding
    code, we saw how an ill-placed `std::hex` can put a curse on everyone "downstream."
    Now, we'll look at two ways to solve that problem--and two new problems that crop
    up in its place!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Solving the sticky-manipulator problem
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our "sticky `std::hex`" problem can be solved by saving and restoring the state
    of the
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'ostream around each complicated output operation, or by creating a brand-new
    ostream each time we want to output something. An example of the former is as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An example of the latter is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice how convenient it is that the iostreams library separates the idea of
    a "streambuf" from the idea of a "stream"; in the preceding example, we easily
    strip all the formatting-related fields away from a stream by extracting just
    its streambuf: `std::cout.rdbuf()`) and then layer a brand new stream (with its
    own formatting-related fields) on top of that same streambuf.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'However, iostreams formatting has another major disadvantage. Each piece of
    our intended message is output "eagerly" as soon as its respective `operator<<`
    is reached--or, if you prefer, each piece of our intended message is computed
    "lazily" only when its respective `operator<<` is reached--so that we have the
    following piece of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We'll see the output `There are An exception was thrown` for the preceding piece
    of code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, iostreams formatting is *intensely* disagreeable to internationalization
    ("i18n"), because the "shape" of the overall message is never present in the source
    code. Instead of a single string literal `"There are %d piano tuners here.\n"`
    representing a complete thought, which could be translated by a human and stored
    in an external file of translated messages; we have two sentence fragments: `"There
    are "` and `"piano tuners here.\n"`, neither of which can be translated in isolation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: For all these reasons, I strongly discourage you from attempting to use iostreams
    as the *foundation* of your codebase. Using `<stdio.h>` or a third-party library
    such as `fmt` for formatting is preferable. Boost.Format is also a possibility,
    although it tends to have very long compile times and poor runtime performance
    compared to either of the other two options. If you find yourself typing `<<`,
    `std::hex`, or `os.rdbuf()` more than once or twice a week, you're doing something
    wrong.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Yet the iostreams library still has some usable and even useful features! Let's
    look at one of them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Formatting with ostringstream
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been talking mostly about `fstream`, which roughly corresponds
    to the `fprintf` and `vfprintf` formatting functions in the C API. There is also
    `stringstream`, which corresponds to `snprintf` and `vsnprintf`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ostringstream` is just like `ostream`, exposing all the usual `operator<<`
    functionality; however, it is backed by `stringbuf` that writes not to a file
    descriptor but to a resizable character buffer--in practice, `std::string`! You
    can use the `oss.str()` method to get a copy of this string for your own use.
    This leads to the following idiom for, for example, "stringifying" an object of
    any type `T`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In C++17, you may even consider a multi-argument version of `to_string`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this version, a call such as `to_string(a, " ", b)` or `to_string(std::hex,
    42)` will have the appropriate semantics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: A note on locales
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is still a pernicious pitfall to beware any time you use either `printf`
    or `ostream` for string formatting (or string parsing). That pitfall is *locales*.
    A full treatment of locales is out of the scope of this book; however, in short,
    the *locale* is "the subset of a user's environment that depends on language and
    cultural conventions." Locale information is exposed programmatically via the
    operating system, allowing a single program to adjust its behavior depending on
    the current user's preferred locale, for example, to control whether "á" is considered
    an alphabetic character, whether the week begins with Sunday or Monday, whether
    dates print as "23-01-2017" or "01-23-2017", and whether floating-point numbers
    print as "1234.56" or "1.234,56". Now, a programmer from the 21st century may
    look at all of those examples and say, "This is crazy! You mean, not one of these
    things is specified by a *standard*? It seems like this situation would inevitably
    lead to subtle and painful bugs!" And you'd be correct!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By changing the *global locale* to `"en_DK.UTF-8"`, we've made it so that none
    of our JSON printing works anymore. Woe betide the hapless user who attempts to
    run a web server or a database in any locale other than `"C.UTF-8"`!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Besides the correctness costs of locale-specific programming, we must also contend
    with the performance costs. Notice that "current locale" is a *global variable*,
    which means that every access to it must be guarded by either an atomic access
    or--worse--a global mutex lock. And, every call to `snprintf` or `operator<<(ostream&,
    double)` must access the current locale. This is a horrendous performance cost,
    and, in certain scenarios, can actually be the performance bottleneck in multi-threaded
    code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: As an application programmer, for applications above a certain level of complexity,
    you should get in the habit of writing `std::locale::global(std::locale("C"))`
    as the first line of `main()`. (If you write only `setlocale(LC_ALL, "C")`, as
    you would in a C program, you'll make `<stdio.h>` work correctly but not affect
    the locale used by `<iostream>`. In other words, setting the C++ library's "global
    locale" also modifies the C library's "global locale," but not vice versa.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t even trust your users to be using UTF-8, perhaps prefer the locale
    name `"C.UTF-8"` instead of just `"C"`; however, be aware that the name `"C.UTF-8"`
    has been around only since about 2015, and may not be available on older systems.
    In fact, the availability of *any* locale other than `"C"` depends on the user.
    Locales are similar to time zones in this way: there is only one locale and one
    timezone that is *guaranteed* to be available on any platform in the world, and
    not coincidentally, it''s the one you should always be using.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As a programmer of third-party libraries, you have two possible paths. The easier
    path is to assume that your library will only ever be used in applications that
    have set their global locale to `"C"`, and so you don't need to worry about locales;
    go ahead and use `snprintf` and `operator<<` to your heart's content. (However,
    notice that this does not solve the performance problem associated with locale-aware
    programming. That global mutex lock will still be there, taking up valuable cycles.)
    The harder path--harder because it requires conscientious adherence to a subtle
    guideline--is to avoid all use of locale-aware formatting functions. This path
    has only really become feasible as of C++17, with some of the very newest library
    facilities, to which we will turn now.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers to strings
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following declarations:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To convert the `intvalue` integer to a string of digits, C++17 offers us the
    following options:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All four alternatives have their advantages. The main advantage of `std::to_string`
    is that it is conveniently composable into larger messages in a high-level code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The main advantages of `std::to_chars` are that it is locale-independent and
    that it can easily be composed in low-level code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The main disadvantage of `std::to_chars` is that it is a very new feature of
    C++17; as of this writing, the `<charconv>` header is not present in any major
    implementation of the standard library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the floating-point `floatvalue` number to a string of digits, C++17
    offers us the following options:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that when printing the floating-point, every method except `std::to_string`
    offers the possibility of adjusting the formatting; and every method except `std::to_chars`
    is locale-aware and thus problematic in a portable code. All of these methods
    are available for the `double` and `long double` data types, as well as for `float`.
    In any case, the same respective advantages and disadvantages apply for integer
    formatting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reverse problem of formatting numbers for output is *parsing* numbers from
    the user's input. Parsing is intrinsically much more subtle and difficult than
    formatting, because we must account for the possibility of error. Every number
    can plausibly be turned into a string of digits, but not every string (or even
    every string of digits!) can plausibly be turned into a number. So, any function
    that purports to parse numbers must have some way of dealing with strings that
    do not represent valid numbers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following declarations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To convert the string in `buffer` or `str` to an `intvalue` integer, C++17
    offers us the following options:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are more parsing methods here than there were formatting methods in the
    previous section; this is because the C standard library alone offers us three
    different methods: `atoi`, the oldest method, and the only one whose behavior
    on invalid input is *literally undefined*, so avoid it in production code; `strtol`,
    the standard replacement for `atoi`, it communicates overflow errors via the global
    variable `errno`, which may be inappropriate for threaded or high-performance
    code); and `sscanf`, a function in the same family as `snprintf`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`std::stoi` is a very good replacement for `atoi` in one-off parsing of user
    input, and a very bad option for high-performance work. It does a very good job
    of detecting errors--`std::stoi("2147483648")` throws `std::out_of_range` and
    `std::stoi("abc")` throws `std::invalid_argument`. (And, although `std::stoi("42abc")`
    returns 42 without complaint, the `std::stoi("42abc", &endidx)` invocation will
    set `endidx` to 2 instead of 5, indicating that something may be amiss.) The major
    disadvantage of `std::stoi` is that it works only on the exact type `std::string`--there
    is no overload of `std::stoi` for `string_view`, no overload for `std::pmr::string`,
    and *certainly* no overload for `const char *`!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`std::from_chars` is the most modern and performant option to parse integers.
    Its main advantage is that unlike any of the other contenders, `from_chars` does
    not require its input buffer to be null-terminated--it takes a pair of `begin,
    end` pointers to indicate the range of characters to be parsed, and will never
    read past `end`. It still has some unfortunate limitations--for example, it cannot
    be taught not to skip whitespace, nor can it be taught to parse uppercase hexadecimal
    input. The idiom to test `r.ec` for error is shown near the beginning of [Chapter
    12](part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d), *Filesystem*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strtol`, `sscanf`, and `stoi` functions indicate that they recognize "base
    0." This is a special-case syntax in the library, where passing a base of `0`
    (or, in the case of `sscanf`, a format specifier of `"%i"`) tells the library
    to parse the input as if it were a C integer literal: `0123` will parse as the
    octal representation of decimal 83, `0x123` will parse as the hexadecimal representation
    of 291, and `019` will parse as the octal representation of the integer 1, with
    the character `9` left unparsed because it is not a valid octal. "Base 0" is never
    an appropriate behavior for a computer program, and `from_chars` wisely chucks
    it to the trash can, where it belongs.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a string to a floating-point `floatvalue`, C++17 offers the following
    options:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All of these parsers--even `std::from_chars`--accept input strings, `"Infinity"`
    and `"Nan"` (case-insensitively), and also accept "hex float" inputs so that,
    for example, `"0x1.c"` parses as the decimal number 1.75\. All but `std::from_chars`
    are locale-aware, and thus problematic in portable code. Where the locale problems
    with integer parsing are largely theoretical, the widespread real-world use of
    locales where `.` is not the decimal separator means that it is very easy to run
    into cases where `std::stof` and `std::stod` don''t work as expected:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice in passing the "non-portable behavior on trailing text" mentioned in
    connection with `istringstream`. Different library vendors do different things
    with stream input, and it''s not always clear which should be considered "correct":'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because of these portability issues--symptoms of the subtle complexity of stream
    input in general--, I recommend you avoid using `istringstream` for input parsing,
    even though `ostringstream` may sometimes be the most appropriate choice for output
    formatting.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Another good rule of thumb is to separate the *validation* (or *lexing*) of
    input from the *parsing* of input. If you can validate beforehand that a certain
    string contains all digits, or matches the regular-expression syntax of a valid
    floating-point number, then you merely have to pick a parsing method that can
    detect overflow and/or trailing text; for example, `std::stof` or `std::from_chars`.
    For more on lexing input with regular expressions, see [Chapter 10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d),
    *Regular Expressions*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Reading a line or word at a time
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reading from standard input one line at a time is a very common task in simple
    scripts, and most scripting languages make it a one-liner. For example, in Python:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And in Perl:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In C++, the task is almost as easy. Notice that C++''s `std::getline` function,
    unlike the other languages'' idioms, removes the trailing newline (if any) from
    each line it reads:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In each of these cases, the entire input never lives in memory at once; we are
    indeed "streaming" the lines through our program in an efficient manner. (And
    the `std::getline` function is allocator-aware; if we absolutely need to avoid
    heap allocation, we can exchange `std::string line` for `std::pmr::string`.) The
    `process` function may take each line and use a regular expression (see [Chapter
    10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d), *Regular Expressions*)
    to validate and split the line into fields for further parsing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`std::istream_iterator<T>` is a standard library type, defined in the `<iterator>`
    header, which wraps a pointer to `istream`. The iterator''s `operator++` reads
    a value of type `T` from the istream, as if by `operator>>`, and that value is
    returned by the iterator''s `operator*`. Putting it all together, this allows
    us to read a whole sequence of whitespace-delimited words from `std::cin` by relying
    on the fact that `std::istream::operator>>(std::string&)` reads a single whitespace-delimited
    word.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse our `streamer` class template to read a whole sequence of integers
    from `std::cin` and do something with each of them:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While the I/O facilities of C++ are certainly very complicated, as befits a
    system's programming language with its roots in the 1980s, we see from these last
    few examples that it is nonetheless possible to hide this complexity under a layer
    of abstraction and end up with code that looks almost as simple as Python.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data output can be divided roughly into *formatting* and *buffering*. Data input
    can be divided just as roughly into *buffering* and *parsing*; although, the parsing
    step gets easier if you can put a *lexing* step in front. (We'll talk more about
    lexing in the very next chapter!)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The classical iostreams API is built on top of `<stdio.h>`, which in turn is
    built on top of the POSIX file-descriptor API. You can't understand the higher
    levels without a good understanding of the levels beneath it. In particular, the
    mess of `fopen` mode strings and `fstream` constructor flags can be understood
    only by reference to lookup tables mapping them onto the actual underlying POSIX
    `open` flags.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 iostreams API 是建立在 `<stdio.h>` 之上的，而 `<stdio.h>` 又是建立在 POSIX 文件描述符 API 之上的。如果不了解其下层的级别，就无法理解更高层的级别。特别是，`fopen`
    模式字符串和 `fstream` 构造函数标志的混乱只能通过参考将它们映射到实际底层 POSIX `open` 标志的查找表来理解。
- en: The POSIX API is concerned only with moving chunks of data to and from file
    descriptors; it does not "buffer" data in the naive sense. The `<stdio.h>` API
    adds a layer of buffering on top of POSIX; the C `FILE` may be fully buffered,
    line-buffered, or unbuffered. Furthermore, `<stdio.h>` provides performant (but
    locale-aware) formatting routines, of which the most important are `fprintf`,
    `snprintf`, and `sscanf`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX API 仅关注将数据块在文件描述符之间移动；它并不在直观意义上“缓冲”数据。`<stdio.h>` API 在 POSIX 之上添加了一层缓冲；C
    的 `FILE` 可以是完全缓冲、行缓冲或无缓冲。此外，`<stdio.h>` 提供了性能良好的（但考虑地区设置的）格式化例程，其中最重要的是 `fprintf`、`snprintf`
    和 `sscanf`。
- en: The `<iostream>` API separates the "streambuf", (which identifies the source
    or sink of raw bytes, and its buffering mode) from the "stream" (which holds the
    state related to formatting). The different kinds of streams (input or output?
    file or string?) form a classical polymorphic hierarchy with complicated and,
    at times, unintuitive inheritance relationships. Avoiding `<iostream>` in production
    code is preferable as it is slow and opaque compared to the `<stdio.h>` or POSIX
    interfaces. Either way, beware of locale-dependent formatting routines.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iostream>` API 将“streambuf”（它标识原始字节的来源或目的地及其缓冲模式）与“stream”（它持有与格式化相关的状态）分开。不同类型的流（输入或输出？文件或字符串？）形成一个经典的泛型层次结构，具有复杂且有时不直观的继承关系。在生产代码中避免使用
    `<iostream>` 是更好的选择，因为它与 `<stdio.h>` 或 POSIX 接口相比既慢又透明。无论如何，要小心地区依赖的格式化例程。'
- en: For one-off quick tasks, prefer parsing numbers via `std::stoi`, which detects
    and throws on error, and formatting with `std::to_string` or `snprintf`. For high-performance
    situations, parsing with `std::from_chars` and formatting with `std::to_chars`
    is preferable if you can find a library implementation that supports these brand
    new functions from the `<charconv>` header.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性快速任务，建议通过 `std::stoi` 解析数字，它会检测错误并抛出异常，并通过 `std::to_string` 或 `snprintf`
    进行格式化。对于高性能情况，如果可以找到支持这些来自 `<charconv>` 头文件的新函数的库实现，则使用 `std::from_chars` 进行解析和
    `std::to_chars` 进行格式化是更好的选择。
