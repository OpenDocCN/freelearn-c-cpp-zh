- en: Iostreams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iostreams
- en: So far, we've seen classical polymorphism in just a couple of places in the
    standard library. We just saw the classically polymorphic `std::pmr::memory_resource`
    in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d), *Allocators*;
    and polymorphism is used "behind the scenes" in the type-erased types `std::any`
    and `std::function`, as detailed in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*. However, by and large, the standard library gets by without
    classical polymorphism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在标准库的几个地方看到了经典的泛型。我们刚刚在 [第 8 章](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d)
    的 *分配器* 中看到了经典的泛型 `std::pmr::memory_resource`；泛型在类型擦除类型 `std::any` 和 `std::function`
    中被“幕后”使用，这在 [第 5 章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d) 的 *词汇类型*
    中有详细说明。然而，总的来说，标准库没有使用经典的泛型。
- en: Two places in the standard library, however, make *massive* use of classical
    polymorphism. One is the standard exception hierarchy--for convenience, all exceptions
    thrown by the standard library are subclasses of `std::exception`. (We don't cover
    the exception hierarchy in this book.) The other is the contents of the standard
    `<iostream>` header, which we will cover in this chapter. However, we have a lot
    of background to cover before we get there!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标准库中的两个地方大量使用了经典的泛型。一个是标准的异常层次结构--为了方便，标准库抛出的所有异常都是 `std::exception` 的子类。（我们在这本书中不介绍异常层次结构。）另一个是标准
    `<iostream>` 头文件的内容，我们将在本章中介绍。然而，在我们到达那里之前，我们还有很多背景知识要介绍！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The division of output into buffering and formatting; and of input into buffering,
    lexing, and parsing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出分为缓冲和格式化；输入分为缓冲、词法分析和解析
- en: The POSIX API for unformatted file I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX API 用于无格式文件 I/O
- en: The "C" API in `<stdio.h>`, which adds both buffering and formatting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<stdio.h>` 中的 "C" API，它增加了缓冲和格式化功能'
- en: The pros and cons of the classical `<iostream>` API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的 `<iostream>` API 的优缺点
- en: The dangers of *locale-dependent* formatting, and new C++17 features that can
    help avoid them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*locale-dependent* 格式的危险，以及可以帮助避免这些危险的新的 C++17 功能'
- en: Many ways to convert numeric data to and from strings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字数据转换为字符串以及从字符串转换回数字的多种方法
- en: The trouble with I/O in C++
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中 I/O 的问题
- en: 'A common measure of a programming language''s ease of use is what''s called
    **TTHW**--"**time to hello world**." Many popular programming languages have a
    very low TTHW: in many scripting languages, such as Python and Perl, the "hello
    world" program is literally the single line: `print "hello world"`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量一种编程语言易用性的一个常见指标是所谓的 **TTHW**--"**time to hello world**"。许多流行的编程语言具有非常低的 TTHW：在许多脚本语言中，如
    Python 和 Perl，"hello world" 程序实际上只有一行：`print "hello world"`。
- en: 'C++ and its ancestor C are systems programming languages, which is to say that
    their primary concerns are with "power": control over the machine, speed, and
    (in C++''s case) the ability to leverage the type system with generic algorithms.
    This is a mixture of concerns not suited to small "hello world" programs.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 和其祖先 C 都是系统编程语言，这意味着它们的主要关注点是“力量”：对机器的控制、速度，以及在 C++ 的情况下，利用泛型算法的能力。这不是适合小型
    "hello world" 程序的关注点组合。
- en: 'The canonical "hello world" program in C is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C 中的标准 "hello world" 程序如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In C++, it is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，情况如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The canonical C++ source code is not much longer than the canonical C source
    code, but it has many more "parameters" or "knobs" that can be adjusted--knobs
    that the novice user must learn about even if all he learns is not to adjust them.
    For example, where, in C, we called a function named `puts` (informally, a "verb"),
    in C++, we apply an *operator* to an object named `std::cout` (so, informally,
    we have both a "verb" and an "indirect object"). In the C++ example, we also had
    to learn a special name for the end-of-line (newline) character--`std::endl`--a
    detail that C's `puts` function hid from us.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 C++ 源代码并不比标准的 C 源代码长多少，但它有更多的“参数”或“旋钮”可以调整--即使是新手用户也必须了解这些旋钮，即使他们不知道如何调整它们。例如，在
    C 中，我们调用名为 `puts` 的函数（非正式地，一个“动词”），在 C++ 中，我们向名为 `std::cout` 的对象应用一个 *运算符*（因此，非正式地，我们既有“动词”又有“间接宾语”）。在
    C++ 的例子中，我们还必须学习一个特殊的行结束（换行）字符的名称--`std::endl`--这是 C 的 `puts` 函数没有向我们隐藏的细节。
- en: Sometimes, this complexity "turns off" newcomers to C++, especially if they're
    learning C++ in school and maybe aren't sure they want to be learning it in the
    first place. However, this is an unfortunate misunderstanding! You see, the preceding
    "C" source code (using `puts`) is also perfectly valid C++, and there is nothing
    wrong with using the facilities of the `<stdio.h>` header. In fact, in this chapter,
    we'll explain the facilities of `<stdio.h>` before we even tackle the facilities
    of `<iostream>`. However, we'll see that C++14 and C++17 have introduced some
    little-known new features--in headers such as `<string>` and `<utility>`--that
    help with some common I/O tasks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这种复杂性会让C++的新手望而却步，尤其是如果他们在学校学习C++，也许他们根本不确定是否想学习它。然而，这是一个不幸的误解！你看，前面的“C”源代码（使用`puts`）也是完全有效的C++，使用`<stdio.h>`头文件中的功能也没有什么问题。实际上，在本章中，我们将在介绍`<iostream>`功能之前解释`<stdio.h>`的功能。然而，我们将看到C++14和C++17引入了一些鲜为人知的新特性--在`<string>`和`<utility>`等头文件中--这些特性有助于一些常见的I/O任务。
- en: 'A note on header naming: I''ve been using the `<stdio.h>` name for the header
    that contains "C-style" I/O facilities. Ever since C++03, there has been a similar
    standard header named `<cstdio>`. The only difference between `<stdio.h>` and
    `<cstdio>` is that in `<stdio.h>`, all of the facilities are guaranteed to be
    in the global namespace (for example, `::printf`) and may or may not be in the
    `std` namespace (for example, `std::printf`); whereas, in `<cstdio>`, they are
    guaranteed to be in `std` (for example, `std::printf`), but not necessarily in
    the global namespace (for example, `::printf`). In practice, there is no difference
    at all, because all major vendors put the facilities in both namespaces, no matter
    which header you include. My recommendation is merely to pick a style and stick
    with it. If your code base uses a lot of POSIX headers, such as `<unistd.h>`,
    which only ever have names with `.h`; it may be aesthetically preferable to stick
    with the `.h` names of the standard "C-style" headers as well.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于头文件命名的说明：我一直在使用`<stdio.h>`这个名字来指代包含“C风格”I/O功能的头文件。自从C++03以来，就有一个类似的标准头文件名为`<cstdio>`。`<stdio.h>`和`<cstdio>`之间的唯一区别在于，在`<stdio.h>`中，所有的功能都保证在全局命名空间中（例如，`::printf`）并且可能或可能不在`std`命名空间中（例如，`std::printf`）；而在`<cstdio>`中，它们保证在`std`（例如，`std::printf`）中，但并不一定在全局命名空间中（例如，`::printf`）。实际上，两者之间没有任何区别，因为所有的主要供应商都将功能放在这两个命名空间中，无论你包含哪个头文件。我的建议只是选择一种风格并坚持下去。如果你的代码库使用了大量的POSIX头文件，如`<unistd.h>`，它只具有`.h`的名称；那么，坚持使用标准“C风格”头文件的`.h`名称可能从美学上更可取。
- en: Buffering versus formatting
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区与格式化
- en: It will be easier for you to understand both "C-style" I/O and "iostream-style"
    I/O if you remember that there are at least two fundamentally different things
    going on when you "output" some data (and likewise, in reverse, when you input
    some data). Just to have some sort of name for them, let's refer to them as *formatting*
    and *buffering:*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记住，在“输出”一些数据时（以及相应地，在“输入”一些数据时）至少有两件根本不同的事情在进行，这将有助于你理解“C风格”I/O和“iostream风格”I/O。为了给它们起个名字，让我们称它们为*格式化*和*缓冲区*：
- en: '*Formatting* is the task of taking a bunch of strongly typed data values from
    the'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*格式化*是将一些强类型数据值从'
- en: program--ints, strings, floating-point numbers, user-defined class types--and
    translating or serializing them into "text." For example, when the number 42 is
    printed out as `"42"` (or `"+42"` or `"0x002A"`), that's *formatting*. Generally,
    a formatting library will have its own "mini-language" to describe how you want
    each value to be formatted.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序--整数、字符串、浮点数、用户定义的类类型--并将它们转换或序列化为“文本”。例如，当数字42以`"42"`（或`"+42"`或`"0x002A"`）的形式打印出来时，这就是*格式化*。通常，一个格式化库将拥有自己的“迷你语言”来描述你希望每个值如何格式化。
- en: '*Buffering* is the task of taking a bunch of raw bytes from the program and
    sending them to some output device (on output), or collecting data from some input
    device and making it available to the program as a bunch of raw bytes (on input).
    The part of the library concerned with buffering may do things such as "collect
    4096 bytes of data at a time, then flush"; or it might be concerned with *where*
    the data is going: to a file in the filesystem, a network socket, or an array
    of bytes in memory?'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓冲*是将一串原始字节从程序发送到某个输出设备（在输出时），或者从某个输入设备收集数据并将其作为一串原始字节提供给程序的任务（在输入时）。与缓冲相关的库部分可能执行诸如“一次收集4096字节数据，然后刷新”的操作；或者它可能关注数据*去向*：文件系统中的文件、网络套接字，或者内存中的字节数组？'
- en: Now, I deliberately said that the output of the *formatting* stage is "text"
    and the input to the *buffering* stage is "a bunch of bytes." On sensible operating
    systems, "text" and "bytes" are the same thing. However, if you're on one of those
    strange operating systems where newlines are encoded as two bytes, or where the
    expected encoding for text files is not UTF-8, then there must be some additional
    processing going on in one or both of these stages, or even further downstream
    (such as in the operating system syscall that writes the data to the file). We
    won't talk much more about that kind of thing, because my hope is that you're
    not using that kind of operating system (or locale) for actual production use.
    In production, you should *always* be using UTF-8 for character encoding, and
    UTC for your time zone, and `"C.UTF-8"` for your locale. So, for our purposes,
    we can pretend that "formatting" and "buffering" are the only pieces of the pipeline
    we need to worry about.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我故意说“格式化”阶段的输出是“文本”，“缓冲”阶段的输入是“一串字节”。在合理的操作系统上，“文本”和“字节”是同一件事。然而，如果你使用的是那些奇怪的操作系统，其中换行符被编码为两个字节，或者文本文件的预期编码不是UTF-8，那么在这些阶段之一或两个中，甚至更下游（例如在操作系统系统调用中将数据写入文件时），必须进行一些额外的处理。我们不会过多地讨论这类事情，因为我的希望是，你不会在实际生产中使用这种类型的操作系统（或区域设置）。在生产中，你应该*始终*使用UTF-8进行字符编码，使用UTC作为时区，以及使用`"C.UTF-8"`作为你的区域设置。因此，就我们的目的而言，我们可以假设“格式化”和“缓冲”是管道中我们需要关注的唯一部分。
- en: When we're doing input, we do the "buffering" first, to read some unformatted
    bytes from the input device; and then we do "formatting" to turn the bytes into
    strongly typed data values. The "formatting" stage for input may be subdivided
    further into *lexing* (to determine the length of an individual data item in the
    stream) and *parsing* (to determine the actual value of the item from those bytes).
    We'll talk more about lexing in [Chapter 10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d),
    *Regular Expressions*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行输入时，首先进行“缓冲”，从输入设备读取一些未格式化的字节；然后进行“格式化”，将字节转换为强类型的数据值。输入阶段的“格式化”可以进一步细分为*词法分析*（确定流中单个数据项的长度）和*解析*（从这些字节中确定项的实际值）。我们将在[第10章](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d)“正则表达式”中更多地讨论词法分析。
- en: Using the POSIX API
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POSIX API
- en: The most important thing to keep in mind whenever we're talking about file I/O
    is that everything I/O-related in C and C++ is built on top of the POSIX standard.
    POSIX is a very low-level specification, almost at the level of Linux system calls,
    that has quite a bit of overlap with the C and C++ standards for I/O; and, if
    you don't understand the gist of the POSIX layer, you'll have a very hard time
    understanding the concepts that come later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论文件I/O时，最重要的是记住，C和C++中所有与I/O相关的都是建立在POSIX标准之上的。POSIX是一个非常底层的规范，几乎与Linux系统调用处于同一级别，它与C和C++的I/O标准有相当大的重叠；如果你不理解POSIX层的主旨，你将很难理解后续的概念。
- en: 'Bear in mind that technically, *none* of what follows is standard C++! It is,
    rather, *valid* C++ that conforms to a *non-C++ standard*: the POSIX standard.
    In practice, this means that it''ll work on any operating system except Windows,
    and may even work on modern Windows systems via the **Windows Subsystem for Linux**
    (**WSL**). Regardless, all the standard APIs (both `<stdio.h>` and `<iostream>`)
    are built on top of this model.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从技术上来说，以下内容都不是标准的C++！它实际上是符合*非C++标准*的*有效*C++：POSIX标准。在实践中，这意味着它将在除了Windows以外的任何操作系统上工作，甚至可能通过**Windows子系统用于Linux**（**WSL**）在现代Windows系统上工作。无论如何，所有标准API（包括`<stdio.h>`和`<iostream>`）都是建立在上述模型之上的。
- en: The non-standard headers that define most of what follows are `<unistd.h>` and
    `<fcntl.h>`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义以下大部分内容的非标准头文件是`<unistd.h>`和`<fcntl.h>`。
- en: In POSIX, the term *file* refers to an actual file on disk (or at least in some
    sort of *file system*; forgive me if I occasionally use the word "disk" to refer
    to the file system). Multiple programs can read or write the same file concurrently,
    via operating system resources known as *file descriptors*. In a C or C++ program,
    you'll never see a file descriptor object itself; all you'll see is a handle (or
    pointer) to a file descriptor. These handles (or pointers) present themselves
    not as pointer types, but as small integers--literally, values of type `int`.
    (The committee behind POSIX is not nearly as obsessed with type-safety as your
    average C++ programmer!)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在POSIX中，术语*文件*指的是磁盘上的实际文件（或者至少在某种*文件系统*中；如果偶尔用“磁盘”这个词来指代文件系统，请原谅我）。多个程序可以通过操作系统资源（称为*文件描述符*）并发地读取或写入同一文件。在C或C++程序中，您永远不会看到文件描述符对象本身；您看到的是文件描述符的句柄（或指针）。这些句柄（或指针）不是以指针类型呈现，而是以小的整数形式呈现--实际上是`int`类型的值。（POSIX背后的委员会并不像平均的C++程序员那样痴迷于类型安全！）
- en: 'To create a new file descriptor and get an integer handle to it, you use the
    `open` function; for example, `int fd = open("myfile.txt", O_RDONLY)`. The second
    argument is a bitmask, which may contain any of the following bit-flags, or''ed
    together:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的文件描述符并获取其整数句柄，您使用`open`函数；例如，`int fd = open("myfile.txt", O_RDONLY)`。第二个参数是一个掩码，可能包含以下任何一个位标志，或运算在一起：
- en: '**Required**: One and only one "access mode." The possible "access modes" are
    `O_RDONLY` (read only), `O_WRONLY` (write only), and `O_RDWR` (both read and write).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必需**：一个且仅有一个“访问模式”。可能的“访问模式”是`O_RDONLY`（只读）、`O_WRONLY`（只写）和`O_RDWR`（读写）。'
- en: '**Optionally**: Some "open-time flags," describing actions you want the system
    to take at the time the file is opened. For example, `O_CREAT` means "if the named
    file doesn''t exist, please create it for me" (as opposed to returning failure);
    and you can even add `O_EXCL`, which means "...and if the named file *does* exist
    already, then *do* return failure." The other important open-time flag is `O_TRUNC`,
    which means "truncate--clear out, empty, reset--the file after opening it."'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选**：一些“打开时标志”，描述了在文件打开时系统要执行的操作。例如，`O_CREAT`表示“如果指定的文件不存在，请为我创建它”（与返回失败相反）；您甚至可以添加`O_EXCL`，这意味着“...如果指定的文件*确实*已经存在，那么*确实*返回失败。”另一个重要的打开时标志是`O_TRUNC`，表示“截断--清除、清空、重置--在打开文件后的文件。”'
- en: '**Optionally**: Some "operating modes," describing the manner in which I/O
    is to be'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选**：一些“操作模式”，描述了I/O应该如何进行'
- en: done via this file descriptor. The important one here is `O_APPEND`.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这个文件描述符完成。这里重要的是`O_APPEND`。
- en: '`O_APPEND` indicates "append mode." When a file is in "append mode," you can
    seek around in it (as you''ll see next) as usual, but every time you write to
    the file, your write is implicitly preceded by a seek to the end of the file (which
    means that after the write, your cursor will be located at the end of the file,
    even if you had just been reading from a different position). Opening a file descriptor
    in append mode is useful if you''re using it for logging, especially if you''re
    using it for logging from different threads. Some standard utility programs, such
    as `logrotate`, work best when the program doing the logging has correctly opened
    their log file in "append mode." In short, append mode is so broadly useful that
    we''ll see it coming back again and again in every one of the higher-level APIs.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_APPEND`表示“追加模式”。当一个文件处于“追加模式”时，您可以像往常一样在其中进行搜索（您将在下一节看到），但每次您向文件写入时，您的写入都会隐式地先进行到文件末尾的搜索（这意味着在写入后，光标将位于文件末尾，即使您刚刚从不同的位置读取）。以追加模式打开文件描述符对于您使用它进行日志记录非常有用，尤其是如果您使用它从不同的线程进行日志记录。一些标准实用程序，如`logrotate`，在程序正确以“追加模式”打开其日志文件时工作得最好。简而言之，追加模式非常广泛地有用，我们将在每个高级API中一次又一次地看到它。'
- en: Now to explain "cursor" and "seek." Each POSIX file descriptor has some associated
    data--basically its "member variables." One of those pieces of associated data
    is the descriptor's current operating mode; another is the descriptor's current
    *file position indicator*, henceforth referred to as a "cursor." Like the cursor
    in a text editor, this cursor points to the place in the underlying file where
    the next read or write will take place. Using `read` or `write` on a descriptor
    advances its cursor. And, as described in the previous paragraph, using `write`
    on a file descriptor in "append mode" will reset the cursor to the very end of
    the file. Notice that there is only a single cursor per file descriptor! If you
    open a file descriptor with `O_RDWR`, you don't get a read cursor and a write
    cursor; you get just a single cursor that is advanced by reading *and* by writing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来解释“光标”和“定位”。每个POSIX文件描述符都有一些相关数据——基本上是其“成员变量”。这些相关数据之一是描述符的当前操作模式；另一个是描述符的当前*文件位置指示器*，以下简称“光标”。就像文本编辑器中的光标一样，这个光标指向底层文件中下一次读取或写入将发生的位置。在描述符上使用`read`或`write`会移动其光标。而且，如前一段所述，在“追加模式”下对文件描述符使用`write`将重置光标到文件的末尾。请注意，每个文件描述符只有一个光标！如果你使用`O_RDWR`打开文件描述符，你不会得到一个读取光标和一个写入光标；你只会得到一个单一的、通过读取和写入都会移动的光标。
- en: '`read(fd, buffer, count)`: This reads raw bytes from the underlying file and
    stores them in the given buffer--up to `count` bytes, or until it encounters some
    sort of temporary or permanent error (for example, if we''d need to wait for more
    data over a network connection, or if someone unmounts the underlying filesystem
    in the middle of the read). It returns the number of bytes read; and remember,
    it advances the cursor.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read(fd, buffer, count)`: 这将从底层文件读取原始字节并将它们存储在给定的缓冲区中——最多`count`字节，或者直到遇到某种临时或永久错误（例如，如果我们需要在网络连接上等待更多数据，或者如果在读取过程中卸载了底层文件系统）。它返回读取的字节数；并且记住，它将光标向前移动。'
- en: '`write(fd, buffer, count)`: This writes raw bytes from the given buffer into
    the underlying file--up to `count` bytes, or until it encounters some sort of
    temporary or permanent error. It returns the number of bytes written; and remember,
    it advances the cursor. (And *before* it writes any data, if the file descriptor
    is in append mode, it will seek to the end of the file.)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write(fd, buffer, count)`: 这将从给定的缓冲区将原始字节写入底层文件——最多`count`字节，或者直到遇到某种临时或永久错误。它返回写入的字节数；并且记住，它将光标向前移动。（并且在写入任何数据之前，如果文件描述符处于追加模式，它将定位到文件的末尾。）'
- en: '`lseek(fd, offset, SEEK_SET)`: This seeks (that is, moves the cursor) to the
    given offset from the start of the file, and returns that offset (or `-1` if the
    operation fails, for example, by running off the end of the file).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lseek(fd, offset, SEEK_SET)`: 这将（即移动光标）定位到文件开头的给定偏移量，并返回该偏移量（如果操作失败，例如超出文件末尾，则返回`-1`）。'
- en: '`lseek(fd, offset, SEEK_CUR)`: This seeks to the given offset relative to the
    *current* cursor. Relative movements like this generally aren''t important, but
    the special case of `lseek(fd, 0, SEEK_CUR)` is very important because that''s
    how you find out the current position of your cursor!'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lseek(fd, offset, SEEK_CUR)`: 这将定位到相对于当前光标的给定偏移量。这种相对移动通常并不重要，但`lseek(fd,
    0, SEEK_CUR)`的特殊情况非常重要，因为这是找出光标当前位置的方法！'
- en: '`lseek(fd, offset, SEEK_END)`: This seeks to the given offset relative to the
    end of the file. Again, this version is most useful when `offset` is zero.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lseek(fd, offset, SEEK_END)`: 这将定位到文件末尾的给定偏移量。同样，当`offset`为零时，这个版本最为有用。'
- en: Incidentally, there is no way to "copy-construct" a POSIX file descriptor so
    that you can get a second cursor to the same file. If you want two cursors, you'll
    need to `open` the file twice. Confusingly, there *is* a POSIX function named
    `dup`, which takes an integer file descriptor handle and returns a different integer
    that can be used as a second handle to the *same* descriptor; this is a kind of
    primitive reference-counting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，没有方法可以“复制构造”一个POSIX文件描述符，以便你可以获得指向同一文件的第二个光标。如果你想有两个光标，你需要将文件打开两次。令人困惑的是，确实有一个名为`dup`的POSIX函数，它接受一个整数文件描述符句柄并返回一个不同的整数，该整数可以用作第二个句柄来访问*相同的*描述符；这是一种原始的引用计数。
- en: When you're done with a file descriptor, you call `close(fd)` to release your
    handle; if this was the last handle to the descriptor (that is, if nobody has
    called `dup` on it in the meantime), then the file descriptor itself will be reclaimed
    by the operating system--which is to say, the underlying file will be "closed."
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成文件描述符的使用后，你可以调用`close(fd)`来释放你的句柄；如果这是对描述符的最后一个句柄（也就是说，在此期间没有人调用`dup`），那么文件描述符本身将被操作系统回收——也就是说，底层的文件将被“关闭”。
- en: 'Putting it all together, we can write a simple program like this using the
    POSIX API to open, read, write, seek, and close file descriptors:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们可以使用POSIX API编写一个简单的程序来打开、读取、写入、定位和关闭文件描述符：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the POSIX API doesn't bother with anything related to *formatting*.
    It is merely concerned with making sure that we can get raw bytes into and out
    of files on disk; that is, with about half of the *buffering* stage--the "where
    the data is going" half. POSIX doesn't bother with the "buffered output"; when
    you call `write`, your data will be written out. That is, it may still be sitting
    in a buffer at the OS level, or at the disk-controller level, or in the hardware,
    but as far as your program is concerned, the data is *on its way*. Any further
    delay in the output is out of your control and not your fault. This, in turn,
    means that if you need to write a lot of data efficiently using the POSIX API,
    your program must take charge of writing data to a buffer and then sending that
    whole buffer to `write` at once. A single 4096-byte `write` will be much faster
    than a 4,096 one-byte `write`!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，POSIX API不关心任何与*格式化*相关的事情。它只关心确保我们可以将原始字节从磁盘上的文件中读入和读出；也就是说，关于*缓冲*阶段的一半——“数据去向”的一半。POSIX不关心“缓冲输出”；当你调用`write`时，你的数据将被写入。也就是说，它可能仍然坐在操作系统级别、磁盘控制器级别或硬件中的缓冲区中，但对你程序来说，数据已经在路上了。任何进一步的输出延迟都不在你的控制范围内，也不是你的错。这反过来意味着，如果你需要使用POSIX
    API高效地写入大量数据，你的程序必须负责将数据写入缓冲区，然后一次性将整个缓冲区发送到`write`。单个4096字节的`write`将比4,096个单字节`write`快得多！
- en: Or, instead of writing your own buffer-management code, you could step up one
    level of abstraction and use the C API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你不必编写自己的缓冲区管理代码，可以提升一个抽象级别，使用C API。
- en: Using the standard C API
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准C API
- en: This description is necessarily almost as brief and incomplete as our discussion
    of POSIX earlier. For a complete description of the facilities in `<stdio.h>`,
    you'll have to consult another source, such as [cppreference.com](https://cppreference.com)
    or your local `man` pages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述必然和我们在前面讨论POSIX时一样简短且不完整。要完整描述`<stdio.h>`中的功能，你必须查阅其他资料，例如[cppreference.com](https://cppreference.com)或你本地的`man`页面。
- en: 'In the "C-style" API, POSIX *file descriptors* are given a new name: the thing
    corresponding to a file descriptor is called `FILE`, and the thing corresponding
    to an integer file descriptor handle is (naturally) called `FILE*`. Just as in
    the POSIX API, though, you''ll never construct an instance of `FILE` yourself.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在“C风格”API中，POSIX的*文件描述符*被赋予了一个新名字：对应文件描述符的东西被称为`FILE`，对应整数文件描述符句柄的东西（自然地）被称为`FILE*`。尽管如此，就像在POSIX
    API中一样，你永远不会自己构造`FILE`的实例。
- en: 'To create a new `FILE` object and get a pointer to it, you use the `fopen`
    function; for example, `FILE *fp = fopen("myfile.txt", "r")`. The second argument
    is a string (that is, a pointer to a null-terminated array of characters--generally,
    you''ll just use a string literal, as I did here), which must be one of the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`FILE`对象并获取其指针，你使用`fopen`函数；例如，`FILE *fp = fopen("myfile.txt", "r")`。第二个参数是一个字符串（即指向以空字符终止的字符数组的指针——通常，你只需使用一个字符串字面量，就像我这里所做的那样），它必须是以下之一：
- en: '`"r"`: This is equivalent to POSIX `O_RDONLY`. Open for reading. Fail (that
    is, return `nullptr`) if the file doesn''t exist.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"r"`：这相当于POSIX的`O_RDONLY`。以读取方式打开。如果文件不存在，则失败（即返回`nullptr`）。'
- en: '`"w"`: This is equivalent to POSIX `O_WRONLY | O_CREAT | O_TRUNC`. Open for
    writing. Create the file if it doesn''t exist. Regardless, make the file empty
    before proceeding.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"w"`：这相当于POSIX的`O_WRONLY | O_CREAT | O_TRUNC`。以写入方式打开。如果文件不存在，则创建文件。无论如何，在继续之前将文件清空。'
- en: '`"r+"`: This is equivalent to POSIX `O_RDWR | O_CREAT`. Open for both reading
    *and* writing. Create the file empty if it doesn''t exist.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"r+"`：这相当于POSIX的`O_RDWR | O_CREAT`。以读取和写入方式打开。如果文件不存在，则创建一个空文件。'
- en: '`"w+"`: This is equivalent to POSIX `O_RDWR | O_CREAT | O_TRUNC`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"w+"`：这相当于POSIX的`O_RDWR | O_CREAT | O_TRUNC`。'
- en: Open for both reading and writing. Create the file if it doesn't exist. Regardless,
    make the file empty before proceeding.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以读写方式打开。如果文件不存在，则创建文件。无论如何，在继续之前将文件清空。
- en: '`"a"`: This is equivalent to POSIX `O_WRONLY | O_CREAT | O_APPEND`. Open for
    writing. Create the file empty if it doesn''t exist. Enter append mode.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"a"`：这等价于 POSIX 的 `O_WRONLY | O_CREAT | O_APPEND`。以写入方式打开。如果文件不存在，则创建一个空文件。进入追加模式。'
- en: '`"a+"`: This is equivalent to POSIX `O_RDWR | O_CREAT | O_APPEND`. Open for
    both reading *and* writing. Create the file empty if it doesn''t exist. Enter
    append mode.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"a+"`：这等价于 POSIX 的 `O_RDWR | O_CREAT | O_APPEND`。以读写方式打开。如果文件不存在，则创建文件。无论如何，在继续之前将文件清空。'
- en: Notice that there is some pattern to the preceding strings--strings with `'+'`
    always map to `O_RDWR`, strings with `'w'` always map to `O_TRUNC`, and strings
    with `'a'` always map to `O_APPEND`; however, there is no perfectly regular pattern
    that describes the mapping from `fopen` mode strings into POSIX `open` flags.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的字符串有一些模式——带有 `'+'` 的字符串始终映射到 `O_RDWR`，带有 `'w'` 的字符串始终映射到 `O_TRUNC`，带有
    `'a'` 的字符串始终映射到 `O_APPEND`；然而，没有完美的规则可以描述从 `fopen` 模式字符串到 POSIX `open` 标志的映射。
- en: Some platforms support appending additional characters to the mode string; for
    example, a common extension on POSIX platforms is that an added `'x'` means `O_EXCL`;
    on GNU platforms, an added `'e'` means `O_CLOEXEC`; and on Windows, a similar
    behavior can be gotten by adding a capital `'N'`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台支持在模式字符串中附加额外的字符；例如，在POSIX平台上，常见的扩展是添加 `'x'` 表示 `O_EXCL`；在GNU平台上，添加 `'e'`
    表示 `O_CLOEXEC`；在Windows上，可以通过添加大写 `'N'` 获得类似的行为。
- en: The one character that can be appended to the mode string on any platform (that
    is, it's guaranteed by the C++ standard to be available everywhere) is `'b'`,
    for "binary." This matters only on Windows, where, if you do *not* specify this
    character, the library will automatically translate every `'\n'` byte you output
    into the Windows line terminator sequence, `'\r', '\n'`. If you specifically do
    want this translation when running on Windows, a useful convention is to add `'t'`
    to your mode string. All vendors' libraries will recognize and ignore this character;
    it merely serves as an indication to the human reader that indeed you meant to
    open the file in "text" mode, and didn't accidentally omit an intended `'b'`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何平台上都可以附加到模式字符串上的一个字符（即，C++标准保证它在任何地方都可用）是 `'b'`，表示“二进制”。这仅在Windows上才有意义，如果你没有指定这个字符，库会自动将你输出的每个
    `'\n'` 字节转换为Windows行结束符序列，`'\r', '\n'`。如果你在Windows上运行时确实需要这种转换，一个有用的约定是在模式字符串中添加
    `'t'`。所有供应商的库都会识别并忽略这个字符；它仅仅作为对人类读者的指示，表明你确实打算以“文本”模式打开文件，而不是不小心遗漏了预期的 `'b'`。
- en: When you're done using a file, you must call `fclose(fp)`, which corresponds
    to calling `close(fd)` on the underlying file descriptor handle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成文件的使用时，你必须调用 `fclose(fp)`，这相当于在底层文件描述符句柄上调用 `close(fd)`。
- en: 'To deal with the bookkeeping on C-style `FILE` pointers, you may want to use
    the RAII smart pointers from [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*. You can write a "unique `FILE` pointer" like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理C风格 `FILE` 指针的簿记，你可能想使用来自[第5章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d)，“词汇类型”的RAII智能指针。你可以这样写一个“唯一的
    `FILE` 指针”：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Moreover, remember that you can always move `unique_ptr` into `shared_ptr`
    if you want the reference-counted, "last person out of the room turns out the
    lights" semantics:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记住，如果你想具有引用计数，“最后一个人离开房间关灯”的语义，你总是可以将 `unique_ptr` 移动到 `shared_ptr`：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Buffering in the standard C API
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准C API中的缓冲区
- en: The standard C API offers a family of functions that look just like the POSIX
    functions,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C API提供了一组看起来与POSIX函数相似的函数，
- en: but with the letter `f` on the front.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但在前面加上字母 `f`。
- en: The `fread(buffer, 1, count, fp)` method reads raw bytes from the underlying
    file and stores them in the given buffer--up to `count` bytes, or until it encounters
    some sort of permanent error (for example, if someone unmounts the underlying
    filesystem in the middle of the read). It returns the number of bytes read and
    advances the cursor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`fread(buffer, 1, count, fp)` 方法从底层文件读取原始字节并将它们存储在给定的缓冲区中——最多 `count` 个字节，或者直到遇到某种永久错误（例如，如果在读取过程中有人卸载了底层文件系统）。它返回读取的字节数并前进光标。'
- en: The literal `1` in that call is not a mistake! Technically, the function signature
    is `fread(buffer, k, count, fp)`. It reads up to `k * count` bytes, or until it
    encounters a permanent error and returns the number of bytes read divided by `k`.
    However, in your own code, `k` should always be the literal `1`; using anything
    else is a mistake, for at least two reasons. First, since the return value is
    always divided by `k`, and if `k` is anything but `1`, you will lose information.
    For example, if `k` is 8, a return value of 3 indicates that "somewhere between
    24 and 31" bytes were read and stored into the buffer, but `buffer[3]` may now
    contain a partially written value--that is to say, garbage--and you have no way
    of detecting that. Second, since the library internally multiplies `k * count`,
    passing any `k` other than 1 runs the risk of overflow and an incorrectly computed
    buffer length. No popular implementation checks that multiplication for overflow;
    this is for performance reasons if nothing else. It doesn't make sense to spend
    CPU time on an expensive division operation if every programmer already knows
    never to pass any other value for `k` but 1!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那个调用中的字面量 `1` 并非错误！技术上，函数签名是 `fread(buffer, k, count, fp)`。它读取最多 `k * count`
    个字节，或者直到遇到永久性错误并返回读取的字节数除以 `k`。然而，在你的代码中，`k` 应始终是字面量 `1`；使用其他任何值都是错误，至少有两个原因。首先，因为返回值总是除以
    `k`，如果 `k` 不是 `1`，你将丢失信息。例如，如果 `k` 是 8，返回值 3 表示“在 24 到 31 个字节之间”读取并存储到缓冲区中，但 `buffer[3]`
    可能现在包含一个部分写入的值——也就是说，垃圾数据——而你无法检测到这一点。其次，由于库内部会乘以 `k * count`，传递除 `1` 以外的任何 `k`
    都会存在溢出和计算错误缓冲区长度的风险。没有流行的实现会检查乘法是否溢出；这如果不是为了性能原因，至少也是出于其他原因。如果每个程序员都知道永远不要为 `k`
    传递除 `1` 以外的任何值，那么在昂贵的除法操作上花费 CPU 时间是没有意义的！
- en: The `fwrite(buffer, 1, count, fp)` method writes raw bytes from the given buffer
    into the underlying file--up to `count` bytes, or until it encounters some sort
    of permanent error. It returns the number of bytes written, and advances the cursor.
    (And *before* it writes any data, if the file descriptor is in append mode, it
    will seek to the end of the file.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`fwrite(buffer, 1, count, fp)` 方法将给定缓冲区中的原始字节写入底层文件——最多 `count` 个字节，或者直到遇到某种永久性错误。它返回写入的字节数，并前进光标。（并且*在写入任何数据之前，如果文件描述符处于追加模式，它将移动到文件的末尾。）'
- en: The `fseek(fp, offset, SEEK_SET)` method seeks (that is, moves the cursor) to
    the given offset from the start of the file; `fseek(fp, offset, SEEK_CUR)` seeks
    to the given offset relative to the *current* cursor; and `fseek(fp, offset, SEEK_END)`
    seeks to the given offset relative to the end of the file. Unlike the POSIX `lseek`,
    the standard C version `fseek` does *not* return the value of the current cursor;
    it merely returns `0` on success or `-1` on failure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`fseek(fp, offset, SEEK_SET)` 方法将光标（即移动光标）移动到文件开头的给定偏移量；`fseek(fp, offset,
    SEEK_CUR)` 将光标移动到相对于当前光标的给定偏移量；而 `fseek(fp, offset, SEEK_END)` 将光标移动到相对于文件末尾的给定偏移量。与
    POSIX 的 `lseek` 不同，标准的 C 版本 `fseek` 并不返回当前光标的位置；它仅在成功时返回 `0` 或在失败时返回 `-1`。'
- en: The `ftell(fp)` method returns the value of the current cursor; that is, it's
    equivalent to the underlying POSIX call `lseek(fd, 0, SEEK_CUR)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftell(fp)` 方法返回当前光标的位置；也就是说，它与底层 POSIX 调用 `lseek(fd, 0, SEEK_CUR)` 等效。'
- en: 'Speaking of underlying POSIX calls: if you are on a POSIX platform and need
    to do something non-portable with the POSIX file descriptor underlying a standard
    C `FILE *`, you can always retrieve the file descriptor by calling `fileno(fp)`.
    So, for example, we could express `ftell` as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 说到底层的 POSIX 调用：如果你在一个 POSIX 平台上，并且需要使用 POSIX 文件描述符执行与标准 C `FILE *` 相关的非可移植操作，你总是可以通过调用
    `fileno(fp)` 来检索文件描述符。因此，例如，我们可以将 `ftell` 表达如下：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Working with `fread` and `fwrite` is quite possible, but it is not the most
    common way of using the C API. Many programs prefer to deal with input and output
    not in terms of large chunks of data but rather character by character, or byte
    by byte. The original "Unix philosophy" is oriented toward small simple command-line
    utilities that read and transform a "stream" of bytes; these small stream-oriented
    programs are known as "filters," and they really shine when you link them together
    with the Unix shell''s pipes. For example, here is a tiny program that opens a
    file and counts the number of bytes, space-separated "words," and lines in that
    file using the `<stdio.h>` API:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fread`和`fwrite`是可能的，但并不是使用C API的最常见方式。许多程序更愿意以字符或字节为单位处理输入和输出，而不是处理大量数据。原始的“Unix哲学”倾向于小型简单的命令行工具，这些工具读取并转换字节流；这些小型面向流的程序被称为“过滤器”，当与Unix
    shell的管道链接在一起时，它们表现得尤为出色。例如，这里有一个小程序，它使用`<stdio.h>` API打开一个文件，并计算该文件中的字节数、空格分隔的“单词”数和行数：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (Do you recognize it? This is the command-line utility `wc`.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （你认出它了吗？这是命令行工具`wc`。）
- en: 'This program introduces two new ideas (besides the standard guarantee that
    all the `FILE` objects are implicitly closed at program exit so that it is safe
    for us to omit the `fclose` bookkeeping and save a few lines in this example).
    The first is the idea of *standard streams*. There are three standard streams
    in C and C++: `stdin`, `stdout`, and `stderr`. In our word-counting program, we
    follow the rule that if the command-line user has not explicitly told us any filename
    to read from, we''ll read from `stdin`, the *standard input stream*, which is
    usually a synonym for the console (or terminal or keyboard--point is, it''s the
    human being sitting there typing). Various mechanisms within the operating system
    and the command-line shell can be used to *redirect* the standard input stream
    from other inputs; these mechanisms (such as typing `wc <myfile.txt` at the shell
    prompt) are far outside the scope of this book. The main things to remember about
    the three standard streams are that they are automatically available to you by
    name without having to `fopen` them; and that it is always an error to `fclose`
    any of them.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序引入了两个新想法（除了标准保证在程序退出时所有`FILE`对象都隐式关闭，这样我们就可以省略`fclose`的记录并在这个例子中节省几行之外）。第一个是*标准流*的概念。在C和C++中有三个标准流：`stdin`、`stdout`和`stderr`。在我们的单词计数程序中，我们遵循规则，如果命令行用户没有明确告诉我们要读取的任何文件名，我们将从`stdin`，即*标准输入流*读取，这通常等同于控制台（或终端或键盘——也就是说，是坐在那里打字的人）。操作系统和命令行shell中的各种机制可以用来*重定向*标准输入流到其他输入；这些机制（如在shell提示符下键入`wc
    <myfile.txt`）远远超出了本书的范围。关于这三个标准流的主要事情是要记住，它们可以通过名称自动供您使用，而无需`fopen`它们；并且关闭它们中的任何一个都是错误的。
- en: The second new idea introduced in our word-counting program is the `getc` function.
    The `getc(fp)` function reads a single byte from the given `FILE *` and returns
    the byte it read. If there was an error, or (more likely) if it hit end-of-file,
    it returns a special value named `EOF`. The numerical value of `EOF` is usually
    `-1;`, but the guaranteed thing about it is that it is completely different from
    any possible *valid* byte. For this reason, `getc(fp)` does not return its return
    value as `char`; it returns it as `int`, which is big enough to store any possible
    `char` and, in addition, big enough to store the value `EOF` distinct from any
    of those `char` values (if `char` is a signed type on your platform--as it is
    on many platforms--then `getc` will convert `char` it read into `unsigned char`
    before returning it; this ensures that if the `0xFF` byte appears in the input
    file, it will be returned as `255`, which is a different integer value than `-1`
    that represents `EOF`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单词计数程序中引入的第二个新想法是`getc`函数。`getc(fp)`函数从给定的`FILE *`读取一个字节，并返回它所读取的字节。如果发生错误，或者（更可能的是）如果遇到文件末尾，它将返回一个特殊值，称为`EOF`。`EOF`的数值通常是`-1`，但关于它的保证是，它与任何可能的*有效*字节都完全不同。因此，`getc(fp)`不将其返回值作为`char`返回；它将其作为`int`返回，这足以存储任何可能的`char`，并且，此外，足以存储与这些`char`值不同的值`EOF`（如果`char`在您的平台上是带符号的类型——在许多平台上都是这样——那么`getc`将在返回之前将其读取的`char`转换为`unsigned
    char`；这确保了如果输入文件中出现`0xFF`字节，它将被返回为`255`，这是一个与表示`EOF`的`-1`不同的整数值）。
- en: Now, for the crucial difference between `fread`/`fwrite` and `read`/`write`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`fread`/`fwrite`和`read`/`write`之间的关键区别。
- en: Recall that the POSIX API doesn't do any additional buffering of input or output
    bytes;
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，POSIX API 并不会对输入或输出字节进行任何额外的缓冲；
- en: when you call `read`, you're going all the way to the operating system to retrieve
    the
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `read` 时，你实际上是在调用操作系统来检索
- en: 'next chunk of input bytes. If `getc(fp)` were implemented as `fread(&ch, 1,
    1, fp)`, and `fread(buf, 1, count, fp)` were implemented as `read(fileno(fp),
    buf, count)`, then our word-counting program would be horrendously inefficient--reading
    a file of a million bytes would result in a million system calls! So, when the
    C library wraps a file descriptor handle in a `FILE` object, it also adds one
    more feature: *buffering*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个输入字节的块。如果 `getc(fp)` 被实现为 `fread(&ch, 1, 1, fp)`，并且 `fread(buf, 1, count,
    fp)` 被实现为 `read(fileno(fp), buf, count)`，那么我们的单词计数程序将非常低效——读取一个百万字节的文件将导致一百万个系统调用！所以，当
    C 库将文件描述符句柄包装在 `FILE` 对象中时，它还添加了一个额外的功能：**缓冲**。
- en: '`FILE` streams may be "unbuffered" (meaning that every `fread` really does
    correspond to `read`, and every `fwrite` to `write`); "fully buffered," also known
    as "block buffered" (meaning that writes will be accumulated into a private buffer
    that is sent to the underlying file descriptor only when it becomes full, and
    likewise, reads will be served from a private buffer that is refilled from the
    underlying file descriptor only when it becomes empty); or "line-buffered" (meaning
    that there is a private buffer just like the previous case, but writing `''\n''`
    causes a flush even if the buffer is not yet full). When the program starts up
    and opens its standard streams, `stdin` and `stdout` will be line-buffered, and
    `stderr` will be unbuffered. Any files you open yourself via `fopen` will generally
    be fully buffered, although the operating system may have something to say about
    that as well; for example, if the "file" you''re opening is actually a terminal
    device, it may end up being line-buffered by default.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILE` 流可以是“无缓冲”的（这意味着每个 `fread` 确实对应于 `read`，每个 `fwrite` 对应于 `write`）；“完全缓冲”的，也称为“块缓冲”（这意味着写入将累积到一个私有缓冲区中，只有当它填满时才会发送到底层的文件描述符，同样，读取也将从私有缓冲区中提供，只有当它为空时才会从底层的文件描述符中重新填充）；或者“行缓冲”的（这意味着有一个与之前情况相同的私有缓冲区，但写入
    `''\n''` 会导致刷新，即使缓冲区还没有满）。当程序启动并打开其标准流时，`stdin` 和 `stdout` 将是行缓冲的，而 `stderr` 将是无缓冲的。你通过
    `fopen` 打开的任何文件通常将是完全缓冲的，尽管操作系统也可能对此有所说法；例如，如果你打开的“文件”实际上是一个终端设备，它可能默认就是行缓冲的。'
- en: 'In the very rare case that you need to control the buffering mode of a `FILE`
    stream, you can do it via the standard `setvbuf` function. You can also use `setvbuf`
    to provide your own buffer, as shown in the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常罕见的情况下，如果你需要控制 `FILE` 流的缓冲模式，你可以通过标准的 `setvbuf` 函数来实现。你还可以使用 `setvbuf` 来提供自己的缓冲区，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice the discrepancy between `ftell(fp)` and `lseek(fd, 0, SEEK_CUR)` in the
    last line of the example. Ten bytes remain buffered in the buffer of `FILE`; so
    `FILE` reports that your cursor is currently at offset 160, but, in actuality,
    the underlying POSIX file descriptor's cursor is still at offset 150, and will
    remain there until the `FILE`'s buffer fills up and is flushed a second time--at
    which point the underlying POSIX file descriptor's cursor will jump to offset
    300\. This feels awkward, but it's actually exactly what we want! We *want* the
    efficiency that comes with writing the underlying file descriptor in large chunks.
    (Note that 150 bytes is not "large" in reality. A typical default file buffer
    size, if you don't use `setvbuf` at all, would be more like 4096 bytes.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到示例的最后一条中 `ftell(fp)` 和 `lseek(fd, 0, SEEK_CUR)` 之间的差异。在 `FILE` 的缓冲区中还有 10
    个字节未被读取；因此 `FILE` 报告说你的光标目前位于偏移量 160，但实际上，底层的 POSIX 文件描述符的光标仍然位于偏移量 150，并且将保持在那里，直到
    `FILE` 的缓冲区填满并第二次刷新——此时底层的 POSIX 文件描述符的光标将跳转到偏移量 300。这感觉有些不自然，但实际上这正是我们想要的！我们**想要**的是通过以大块写入底层文件描述符所带来的效率。（注意，在现实中
    150 个字节并不算“大”。如果你根本不使用 `setvbuf`，典型的默认文件缓冲区大小可能更像是 4096 字节。）
- en: 'On some platforms, calling `ftell` will cause the buffer to be flushed as a
    side effect, since that makes the library''s bookkeeping easier; the library doesn''t
    like to be caught telling lies. (Calling `fseek` is also a likely way to cause
    a flush.) However, on other platforms, `ftell` and even `fseek` don''t always
    flush the buffer. To make sure that your `FILE` stream''s buffer has definitely
    been flushed to the underlying file, use `fflush`. Let''s continue the previous
    example as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些平台上，调用`ftell`可能会导致缓冲区作为副作用被刷新，因为这使得库的记账更容易；库不喜欢被抓住说谎。（调用`fseek`也可能是导致刷新的原因。）然而，在其他平台上，`ftell`甚至`fseek`并不总是刷新缓冲区。为了确保你的`FILE`流缓冲区确实已经刷新到底层文件，请使用`fflush`。让我们继续上一个示例，如下所示：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Putting it all together, we can rewrite our simple program from the *Using
    the POSIX API* section like this, using the `<stdio.h>` API to open, read, write,
    seek, flush, and close file streams:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们可以像这样重写我们在*使用POSIX API*部分中的简单程序，使用`<stdio.h>` API来打开、读取、写入、定位、刷新和关闭文件流：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This concludes our exploration of the *buffering* capabilities of the standard
    `<stdio.h>` API; now, we move on to consider how `<stdio.h>` deals with *formatting*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对标准`<stdio.h>` API的*缓冲*能力的探索；现在，我们将继续考虑`<stdio.h>`如何处理*格式化*。
- en: Formatting with printf and snprintf
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用printf和snprintf进行格式化
- en: In the formatting stage, we start with the high-level data values that we want
    to print out; for example, we might want to print the number of piano tuners in
    Chicago, which our program has computed as 225\. Printing out the *three-byte
    string* `"225"` is easy; we've solved that in the preceding sections. The task
    of *formatting* is to get us from the number 225 (an `int`, let's say) to that
    three-byte string `"225"`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化阶段，我们开始于我们想要打印出的高级数据值；例如，我们可能想要打印芝加哥钢琴调音师的数量，我们的程序计算为225。打印出*三字节字符串* `"225"`很容易；我们在前面的章节中已经解决了这个问题。*格式化*的任务是将数字225（一个`int`，比如说）转换成那个三字节字符串`"225"`。
- en: 'When printing numbers, we have many possible concerns: should the number be
    printed in base 10, base 16, base 8, base 2, or some other base? If the number
    is negative, presumably, we should prefix it with `-`; if it is positive, should
    we prefix it with `+`? Should we use thousands-separators, and if so, should we
    use commas, periods, or spaces? What about decimal points? Once we''re talking
    about floating-point numbers, how many digits after the decimal point should we
    print? Or should we use scientific notation, and if so, to how many significant
    digits?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印数字时，我们有许多可能的问题：数字应该以10进制、16进制、8进制、2进制或其他进制打印吗？如果数字是负数，我们可能需要在前面加上`-`；如果是正数，我们应该在前面加上`+`吗？我们应该使用千位分隔符吗？如果是这样，我们应该使用逗号、句号还是空格？关于小数点呢？一旦我们谈论到浮点数，我们应该打印小数点后多少位数字？或者我们应该使用科学记数法，如果是这样，我们应该保留多少有效数字？
- en: Then, there are concerns that extend even to non-numeric input. Should the printed
    value be aligned within a fixed-width column, and if so, should it be left-aligned,
    right-aligned, or even aligned in some other clever way? (And what character should
    we use to fill the unoccupied columns?) What if the value doesn't fit in the given
    column width--should it be truncated left or right or just overflow the column's
    bounds?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有一些问题甚至涉及到非数值输入。打印的值是否应该在一个固定宽度的列中对齐，如果是的话，应该左对齐、右对齐，还是以某种其他巧妙的方式进行对齐？（我们该使用什么字符来填充未占用的列呢？）如果值不适合给定的列宽，应该左截断、右截断，还是直接超出列的边界？
- en: 'Similarly, when reading formatted input (that is, *parsing*), we have to answer
    many of the same questions about numerics: do we expect thousands-separators?
    Scientific notation? Leading `+` signs? What numeric base do we expect? And even
    for non-numerics: do we expect leading whitespace? If we''re reading in a value
    of type "string," what indicates the end of the value other than `EOF`?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当读取格式化输入（即*解析*）时，我们必须回答许多关于数字的相同问题：我们是否期望千位分隔符？科学记数法？前导`+`符号？我们期望什么数字进制？甚至对于非数字：我们是否期望前导空白？如果我们正在读取类型为“字符串”的值，除了`EOF`之外，什么表示值的结束？
- en: 'The standard C API provides a whole family of formatting functions with names
    ending in `printf`, and a matching family of parsing functions with names ending
    in `scanf`. A commonality of every function in this family is that it takes a
    variadic argument list (using C-style varargs, not C++ variadic templates) and,
    prior to the variadic arguments, a single "format string" that answers many of
    the above questions (but not all of them) for each argument to be formatted, and
    also provides a "shape" for the overall message, into which the library will insert
    the formatted arguments:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C API提供了一系列以`printf`结尾的格式化函数，以及一系列以`scanf`结尾的匹配解析函数。这个系列中每个函数的共同点是它接受一个变长参数列表（使用C风格的变长参数，而不是C++变长模板），并且在变长参数之前有一个单一的“格式字符串”，为要格式化的每个参数回答许多上述问题（但不是所有问题），并为整体消息提供一个“形状”，库将在这个形状中插入格式化的参数：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also `fprintf(fp, "format", args...)` to print to any arbitrary stream
    (not necessarily `stdout`); `snprintf(buf, n, "format", args...)` to write to
    a buffer, about which we''ll discuss more in a moment; and a matching family of
    `vprintf`, `vfprintf`, and `vsnprintf` functions that are useful in building your
    own printf-like functions. As you''ve probably learned to expect in this chapter,
    a complete treatment of C-style format strings is out of the scope of this book.
    However, the C-style "format string language" is widely used even in languages
    that don''t directly descend from C; for example, in Python 2, you can say:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有`fprintf(fp, "format", args...)`，用于打印到任何任意流（不一定是`stdout`）；`snprintf(buf,
    n, "format", args...)`用于写入缓冲区，我们将在稍后讨论这个问题；还有一组`vprintf`、`vfprintf`和`vsnprintf`函数，这些函数在构建自己的printf-like函数时很有用。正如你可能在本章中学到的，C风格格式字符串的完整处理超出了本书的范围。然而，C风格的“格式字符串语言”即使在不是直接从C派生的语言中也被广泛使用；例如，在Python
    2中，你可以这样写：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, there are major differences between what's happening in C and what's
    happening in Python!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C和Python中发生的事情之间有重大差异！
- en: 'The biggest difference is that Python is dynamically typed, so if you write
    `"%s tuners" % (tuners)`, it will still be able to do the right thing. With C-style
    variadic argument lists, the original type of `tuners` is lost; if you use the
    `"%s"` format specifier (which expects a `const char *` argument) with an argument
    of type `int`, you''ll get a friendly compiler warning at best and undefined behavior
    at worst. That is to say, when you use `<stdio.h>` formatting functions, the format
    string does double duty: it encodes not only *how to format* each data value,
    but also *the type of* each data value--and if you get one of those types wrong,
    such as by using `"%s"` when you meant `"%d"`, then your program will have a bug.
    Fortunately, all major compilers can detect and diagnose such mismatches these
    days, as long as your format string is passed directly to `printf` or to a function
    annotated with the (non-standard) `format` attribute, as demonstrated in the code
    sample we''ll see shortly. Unfortunately, these diagnostics can be unreliable
    when you''re dealing with typedefs for platform-dependent types; for example,
    some 64-bit compilers will not diagnose an attempt to format a `size_t` value
    with the `"%llu"` format specifier, even though the properly portable specifier
    would be `"%zu"`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别在于Python是动态类型的，所以如果你写`"%s tuners" % (tuners)`，它仍然能够正确执行。使用C风格的变长参数列表时，`tuners`的原始类型会丢失；如果你使用`"%s"`格式说明符（它期望一个`const
    char *`类型的参数）并传递一个`int`类型的参数，你最多会得到友好的编译器警告，最坏的情况下会有未定义的行为。也就是说，当你使用`<stdio.h>`格式化函数时，格式字符串承担双重职责：它不仅编码了如何格式化每个数据值，还编码了每个数据值的类型——如果你弄错了其中一个类型，比如当你想用`"%s"`时实际上应该用`"%d"`，那么你的程序就会出现错误。幸运的是，如今所有主要的编译器都可以检测并诊断这种不匹配，只要你的格式字符串是直接传递给`printf`或带有（非标准的）`format`属性的函数，就像我们将在接下来的代码示例中看到的那样。不幸的是，当你处理平台相关类型的`typedef`时，这些诊断可能不可靠；例如，一些64位编译器不会诊断尝试使用`"%llu"`格式说明符格式化`size_t`值的情况，尽管正确的可移植格式说明符应该是`"%zu"`。
- en: Another difference is that in C, `printf` is effectively writing directly to
    the standard output stream, `stdout`; the formatting of the data is interleaved
    with the buffering of the output bytes. In Python, the `"There are %d piano tuners
    in %s." % (tuners, where)` construct is actually an *expression* of type `str`
    (string); all of the formatting happens right there, producing a single string
    value with the proper bytes, before we decide that the string is to be printed
    to `stdout` at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，在 C 中，`printf` 实际上是直接写入标准输出流 `stdout`；数据的格式化与输出字节的缓冲是交织在一起的。在 Python
    中，`"There are %d piano tuners in %s." % (tuners, where)` 结构实际上是一个 `str` 类型（字符串）的
    *表达式*；所有的格式化都直接在那里完成，生成一个包含正确字节的单个字符串值，在我们决定将字符串打印到 `stdout` 之前。
- en: 'To produce a formatted string using the `<stdio.h>` API, we will use `snprintf`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `<stdio.h>` API 生成格式化的字符串，我们将使用 `snprintf`：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that `snprintf` always null-terminates its buffer, even if it means
    not writing the entire message into it; and it returns `strlen` of the message
    that it *wanted* to write. A common idiom to format an arbitrarily long message
    is to call `snprintf` first with `nullptr`, to learn the message''s final size;
    and then call it a second time with a buffer of that size:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `snprintf` 总是会以空字符终止其缓冲区，即使这意味着不能将整个消息写入其中；它返回它 *想要* 写入的消息的 `strlen`。格式化任意长消息的常见方法是首先用
    `nullptr` 调用 `snprintf`，以了解消息的最终大小；然后再次调用它，这次使用相应大小的缓冲区：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding implementation of `format` uses a variadic function template,
    which will tend to produce a lot of similar copies of the code. A more efficient
    implementation (in terms of compile time and code bloat) would be to use a single
    (non-template) function with a C-style variadic argument list, and use `vsnprintf`
    for formatting. Sadly, further discussion of `va_list` and `vsnprintf` is far
    outside the scope of this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `format` 的实现使用了一个变长参数函数模板，这往往会产生大量类似的代码副本。一个更有效的实现（从编译时间和代码膨胀的角度来看）是使用一个单一的非模板函数，具有
    C 风格的变长参数列表，并使用 `vsnprintf` 进行格式化。遗憾的是，关于 `va_list` 和 `vsnprintf` 的进一步讨论远远超出了本书的范围。
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll defer the discussion of the `scanf` format strings until the *recipes*
    portion of this chapter. For a complete treatment of `scanf`, consult [cppreference.com](https://cppreference.com)
    or a book on the C standard library.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把对 `scanf` 格式字符串的讨论推迟到本章的 *食谱* 部分。关于 `scanf` 的完整介绍，请参考 [cppreference.com](https://cppreference.com)
    或关于 C 标准库的书籍。
- en: Having seen how both buffering and formatting (at least, output formatting)
    work in the `<stdio.h>` regime, we now move on to the standard C++ `<iostream>`
    API.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 `<stdio.h>` 环境中缓冲和格式化（至少是输出格式化）是如何工作的之后，我们现在转向标准 C++ `<iostream>` API。
- en: The classical iostreams hierarchy
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的 iostreams 层次结构
- en: The `<stdio.h>` API suffers from at least three problems. First, the formatting
    functionality is far from type-safe. Second, the buffering functionality is awkwardly
    split up into "buffering into a file stream" (`FILE *` and `fprintf`) and "buffering
    into a character buffer" (`snprintf`). (Okay, technically, the GNU C library provides
    `fopencookie` to construct `FILE *` that buffers into anything you want; but this
    is fairly obscure and extremely non-standard.) Third, there is no easy way to
    extend the formatting functionality for user-defined classes; I cannot even `printf`
    a `std::string`, let alone `my::Widget`!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdio.h>` API 至少有三个问题。首先，格式化功能远非类型安全。其次，缓冲功能尴尬地分为 "将缓冲写入文件流"（`FILE *` 和 `fprintf`）和
    "将缓冲写入字符缓冲区"（`snprintf`）。（好吧，技术上，GNU C 库提供了 `fopencookie` 来构建 `FILE *`，它可以缓冲到任何你想要的地方；但这相当不为人知，并且非常非标准。）第三，没有简单的方法来扩展用户定义类的格式化功能；我甚至不能
    `printf` 一个 `std::string`，更不用说 `my::Widget` 了！'
- en: When C++ was being developed in the mid-1980s, the designers felt a need for
    a type-safe, composable, and extensible I/O library. Thus was born the feature
    known as "iostreams," or simply as "C++ streams" (not to be confused with the
    `<stdio.h>` streams we just finished talking about). The fundamental architecture
    of iostreams has not changed since the mid-1980s, which makes it very different
    from anything else in the standard library with the possible exception (no pun
    intended) of the `std::exception` hierarchy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1980 年代中期 C++ 被开发时，设计者感到需要一个类型安全、可组合和可扩展的 I/O 库。因此诞生了被称为 "iostreams" 或简单地称为
    "C++ streams"（不要与刚刚讨论过的 `<stdio.h>` streams 混淆）的功能。自 1980 年代中期以来，iostreams 的基本架构没有改变，这使得它与标准库中的其他任何东西都大不相同，可能唯一的例外是（无意中）`std::exception`
    层次结构。
- en: 'The C++ iostreams library consists of two major pieces: *streams*, which are
    concerned with formatting, and `streambufs`, which are concerned with buffering.
    The majority of C++ programmers will never interact with streambufs; only with
    streams. However, let''s very quickly explain what a streambuf is.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的 iostreams 库由两个主要部分组成：*streams*，它们关注格式化，以及 `streambufs`，它们关注缓冲。大多数 C++
    程序员永远不会与 `streambufs` 交互；只有与 `streams` 交互。然而，让我们快速解释一下什么是 `streambuf`。
- en: A streambuf is very similar to `FILE` in the C API. It tells the program where
    the input (in the form of raw bytes) should come from, and where the output should
    go to. It also maintains a buffer of bytes to reduce the number of round-trips
    to those destinations (such as the POSIX `read` and `write` functions). In order
    to allow different kinds of streambufs with the same interface--well, remember
    my promise that we'd see classical polymorphism in this chapter? We've finally
    gotten to it!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`streambuf` 在 C API 中非常类似于 `FILE`。它告诉程序输入（以原始字节的形式）应该来自哪里，输出应该去哪里。它还维护一个字节缓冲区以减少到达这些目的地（如
    POSIX 的 `read` 和 `write` 函数）的往返次数。为了允许具有相同接口的不同类型的 `streambuf` -- 嗯，记得我在本章中提到的承诺，我们会看到经典的多态吗？我们终于到达那里了！'
- en: '`std::streambuf` (which is actually an alias for `std::basic_streambuf<char,
    char_traits<char>>`, but let''s not make this any more complicated) is the base
    class of an inheritance hierarchy whose derived classes are `std::filebuf` and
    `std::stringbuf`. The virtual methods provided by the `streambuf` interface are
    too many to list, but they include `sb.setbuf(buf, n)` (corresponding to `setvbuf(fp,
    buf, _IO_FBF, n)`), `sb.overflow()` (corresponding to `fflush(fp)`), and `sb.seekpos(offset,
    whence)` (corresponding to `fseek(fp, offset, whence)`). When I say corresponding,
    I mean corresponding for `std::filebuf`, of course. These methods have implementation-defined
    (and in practice, non-portable) behavior when called on `std::stringbuf`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::streambuf`（实际上是对 `std::basic_streambuf<char, char_traits<char>>` 的别称，但让我们不要使事情变得更复杂）是一个继承层次结构的基类，其派生类是
    `std::filebuf` 和 `std::stringbuf`。`streambuf` 接口提供的虚拟方法太多，无法一一列出，但包括 `sb.setbuf(buf,
    n)`（对应于 `setvbuf(fp, buf, _IO_FBF, n)`），`sb.overflow()`（对应于 `fflush(fp)`），以及 `sb.seekpos(offset,
    whence)`（对应于 `fseek(fp, offset, whence)`）。当我说对应时，当然是指对应于 `std::filebuf`。这些方法在调用
    `std::stringbuf` 时具有实现定义的（在实践中，不可移植的）行为。'
- en: Any `streambuf` derived class must also support some primitive operations to
    interact with its buffer (to put in and take out bytes). These primitive operations
    are not for use by normal programmers, though; they're for use by the *stream*
    object that wraps this streambuf and provides a more programmer-friendly interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何由 `streambuf` 派生的类都必须支持一些原始操作来与其缓冲区交互（用于放入和取出字节）。这些原始操作不是供普通程序员使用的；它们是为封装此
    `streambuf` 并提供更友好的程序员接口的 *stream* 对象使用的。
- en: 'A C++ *stream* encapsulates a streambuf and restricts the set of operations
    you can do on it. For example, notice that `streambuf` doesn''t have any conception
    of "access mode": you can put bytes into it ("write") as easily as you can take
    bytes out ("read"). However, when we take that `streambuf` and wrap it in a `std::ostream`,
    the `ostream` object exposes only a `write` method; there is no `read` method
    on `ostream`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的 *stream* 封装了一个 `streambuf` 并限制了你可以对其执行的操作集。例如，请注意 `streambuf` 并没有“访问模式”的概念：你可以像取出字节（“读取”）一样容易地将其放入字节（“写入”）。然而，当我们用
    `std::ostream` 封装那个 `streambuf` 时，`ostream` 对象只暴露了一个 `write` 方法；在 `ostream` 上没有
    `read` 方法。
- en: 'The following diagram expresses the class hierarchy of streams and streambufs
    in C++17, as defined in the standard `<iostream>`, `<fstream>`, and/or `<sstream>`
    headers. The `streambuf`, `istream`, `ostream`, and `iostream` base classes are
    "abstract-ish": while they have no pure virtual methods, they contain only the
    `streambuf*` member variable inherited from `ios`. To protect you from accidentally
    constructing instances of these "abstract-ish" types, the standard library defines
    their constructors as `protected`. Contrariwise, the classes with names containing
    `stringstream` and `fstream` actually contain instances of `stringbuf` and `filebuf`
    respectively, to which their constructors initialize the inherited `streambuf*`
    member to point. Later in this chapter, in the *Solving the sticky-manipulator
    problem* section, we''ll see how to construct an `ostream` object whose `streambuf*`
    member points to a streambuf instance not owned by `*this`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 C++17 中流和流缓冲区的类层次结构，如标准 `<iostream>`、`<fstream>` 和/或 `<sstream>` 头文件中定义的那样。`streambuf`、`istream`、`ostream`
    和 `iostream` 基类是“抽象的”：虽然它们没有纯虚方法，但只包含从 `ios` 继承的 `streambuf*` 成员变量。为了防止你意外构造这些“抽象的”类型的实例，标准库定义了它们的构造函数为
    `protected`。相反，名称中包含 `stringstream` 和 `fstream` 的类实际上分别包含 `stringbuf` 和 `filebuf`
    的实例，它们的构造函数初始化继承的 `streambuf*` 成员变量以指向这些实例。在本章的后续部分，在 *解决粘性操纵器问题* 节中，我们将看到如何构造一个
    `ostream` 对象，其 `streambuf*` 成员变量指向一个不属于 `*this` 的流缓冲区实例：
- en: '![](img/00024.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: 'The stream classes expose a motley collection of methods that correspond, more
    or less exactly, to the functions we''ve seen twice before. In particular, the
    `fstream` class wraps `filebuf` and, together, they behave a lot like `FILE` from
    the C API: `filebuf` has a "cursor" that you can manipulate with the `seekp` method
    of `fstream`. (The name `seekp` is inherited from the `ostream` class. On `ifstream`,
    the method is named `seekg`: "g" for "get" and "p" for "put." On a full `fstream`,
    you can use either `seekg` or `seekp`; they are synonyms in that case. As always,
    remember that there is just a single cursor, even though the iostreams API has
    two different *names* for the cursor in this case!)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 流类公开了一系列方法，这些方法大致对应于我们之前两次看到过的函数。特别是，`fstream` 类封装了 `filebuf`，并且它们一起的行为与 C API
    中的 `FILE` 非常相似：`filebuf` 有一个“游标”，你可以使用 `fstream` 的 `seekp` 方法来操作它。（`seekp` 的名称是从
    `ostream` 类继承的。在 `ifstream` 上，该方法的名称是 `seekg`：“g”代表“获取”，“p”代表“放置。”在完整的 `fstream`
    上，你可以使用 `seekg` 或 `seekp`；在这种情况下，它们是同义词。一如既往，记住，即使 iostreams API 在这种情况下有两个不同的
    *名称*，但只有一个游标！）
- en: 'The constructor of `fstream` takes a bitmask or''ed together from the `std::ios_base::in`,
    `out`, `app` (for "append mode"), `trunc`, `ate`, and `binary` flag values; however,
    just as we saw with `fopen`, there is only a very small dash of rhyme and reason
    as to how those flags are translated into POSIX `open` flags:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`fstream` 构造函数接受一个由 `std::ios_base::in`、`out`、`app`（表示“追加模式”）、`trunc`、`ate`
    和 `binary` 标志值组成的位掩码；然而，正如我们在 `fopen` 中所看到的，这些标志如何转换为 POSIX `open` 标志之间只有很少的韵律和逻辑关系：'
- en: '`in`: This is equivalent to `fopen("r")`, or POSIX `O_RDONLY`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`: 这与 `fopen("r")` 或 POSIX 的 `O_RDONLY` 等效。'
- en: '`out`: This is equivalent to `fopen("w")`, or POSIX `O_WRONLY | O_CREAT | O_TRUNC`.
    (Notice that `out` alone means `O_TRUNC` even if `trunc` was not passed!)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out`: 这与 `fopen("w")` 或 POSIX 的 `O_WRONLY | O_CREAT | O_TRUNC` 等效。（注意，即使没有传递
    `trunc`，`out` 单独也意味着 `O_TRUNC`！）'
- en: '`in|out`: This is equivalent to `fopen("r+")`, or POSIX `O_RDWR | O_CREAT`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in|out`: 这与 `fopen("r+")` 或 POSIX 的 `O_RDWR | O_CREAT` 等效。'
- en: '`in|out|trunc`: This is equivalent to `fopen("w+")`, or POSIX `O_RDWR | O_CREAT
    | O_TRUNC`. (Notice that the iostreams syntax makes more sense than the `fopen`
    syntax, in this case.)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in|out|trunc`: 这与 `fopen("w+")` 或 POSIX 的 `O_RDWR | O_CREAT | O_TRUNC` 等效。（注意，在这种情况下，iostreams
    语法比 `fopen` 语法更有意义。）'
- en: '`out|app`: This is equivalent to `fopen("a")`, or POSIX `O_WRONLY | O_CREAT
    | O_APPEND`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out|app`: 这与 `fopen("a")` 或 POSIX 的 `O_WRONLY | O_CREAT | O_APPEND` 等效。'
- en: '`in|out|app`: This is equivalent to `fopen("a+")`, or POSIX `O_RDWR | O_CREAT
    | O_APPEND`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in|out|app`: 这与 `fopen("a+")` 或 POSIX 的 `O_RDWR | O_CREAT | O_APPEND` 等效。'
- en: Adding `binary` to the bitmask is just like adding `"b"` to `fopen`. Adding
    `ate` tells the stream to begin with a seek to the end of the file, even if the
    file is not being opened in `O_APPEND` mode.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `binary` 添加到位掩码中就像在 `fopen` 中添加 `"b"` 一样。添加 `ate` 告诉流从文件的末尾开始搜索，即使文件不是以 `O_APPEND`
    模式打开。
- en: Passing an unsupported set of flags, such as `app|trunc`, will still construct
    the stream object, but place it into the "fail" state, which we'll discuss soon.
    In general, you should design your own classes' constructors so that failure is
    indicated by an exception. That rule is broken here partly because this class
    hierarchy was designed almost forty years ago, and partly because we need a "failure"
    mechanism anyway, to deal with the relatively likely possibility that the named
    file cannot be opened (for example, if it doesn't exist).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个不支持的标志集，例如 `app|trunc`，仍然会构建流对象，但将其置于“失败”状态，我们将在后面讨论。一般来说，你应该设计自己类的构造函数，以便通过异常来指示失败。这个规则在这里被打破，部分原因是因为这个类层次结构是在大约四十年前设计的，部分原因是因为我们无论如何都需要一个“失败”机制，以处理相对可能的情况，即无法打开指定的文件（例如，如果它不存在）。
- en: 'Putting it all together, we can rewrite our simple program from "Using the
    POSIX API" like this, using the `<fstream>` API to open, read, write, seek, flush,
    and close file streams:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合起来，我们可以用 `<fstream>` API 重写我们的简单程序，如下所示，使用该API打开、读取、写入、定位、刷新和关闭文件流：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One odd thing about the preceding example is that `fsr.read(buffer.data(), 14)`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个例子中有一个奇怪的地方，那就是 `fsr.read(buffer.data(), 14)`
- en: does not return any indication of how many bytes were read! Instead, it stores
    the count of bytes read in a member variable, and you must retrieve the count
    yourself via the accessor `fsr.gcount()` function. And the `write` method doesn't
    even allow you to find out how many bytes were written. This may seem like a problem;
    but, in general, if a stream encounters an error on reading or writing, the error
    is often essentially "unrecoverable" anyway, due to the uncertain number of bytes
    *actually* read from or written to the underlying file descriptor and due to the
    several layers of buffers between the application program and hardware. When a
    read or write error is encountered, we pretty much have to give up on understanding
    the state of that stream at all--*except* in the special case of "end of file"
    on input. If we intended to read 100 bytes and instead hit "end of file," it is
    meaningful to ask, "How many bytes did we succeed at reading?" However, if we
    intended to *write* 100 bytes and instead received a network error, or a disk
    error, it's not so meaningful to ask, "How many bytes did we succeed at writing?"
    We simply cannot tell whether our "written" bytes managed to reach their destination
    or not.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 并不返回读取了多少字节的任何指示！相反，它将读取的字节数存储在一个成员变量中，你必须通过访问器 `fsr.gcount()` 函数自己检索这个计数。而且，`write`
    方法甚至不允许你找出写入了多少字节。这看起来可能像是一个问题；但，一般来说，如果一个流在读取或写入时遇到错误，由于从底层文件描述符实际读取或写入的字节数不确定，以及应用程序程序和硬件之间的几个缓冲层，错误往往是“不可恢复”的。当遇到读取或写入错误时，我们基本上必须放弃了解那个流的状态——*除了*在输入遇到“文件末尾”的特殊情况之外。如果我们打算读取100个字节，但意外地遇到了“文件末尾”，那么询问“我们成功读取了多少字节？”是有意义的。然而，如果我们打算
    *写入* 100个字节，但收到了网络错误或磁盘错误，那么询问“我们成功写入了多少字节？”就没有那么有意义了。我们根本无法判断我们的“写入”字节是否成功到达了目的地。
- en: If we asked for 100 bytes and only read 99 (or fewer) before hitting end-of-file,
    then not only will `fs.gcount()` report a number less than 100, but also the *eof
    indicator* will be set on the stream object's state. You can ask any stream about
    its current state with the accessor functions `fs.good()` (is it hunky-dory?),
    `fs.bad()` (did the underlying stream encounter an unrecoverable error?), `fs.eof()`
    (did the last input operation hit end-of-file?), and `fs.fail()` (did the last
    operation "fail" for any reason?). Notice that `fs.good()` is not the inverse
    of `fs.bad()`; it is possible for a stream to be in a state, such as *eof,* that
    is, `!good() && !bad()`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求读取100个字节，但在遇到文件末尾之前只读取了99个（或更少），那么不仅 `fs.gcount()` 会报告一个小于100的数字，而且流对象的状态上还会设置
    *eof指示器*。你可以使用访问器函数 `fs.good()`（是否一切顺利？），`fs.bad()`（底层流是否遇到了不可恢复的错误？），`fs.eof()`（最后的输入操作是否遇到了文件末尾？），和
    `fs.fail()`（最后的操作是否由于任何原因而“失败”？）来询问任何流的状态。请注意，`fs.good()` 并不是 `fs.bad()` 的逆；一个流可能处于某种状态，例如
    *eof*，即 `!good() && !bad()`。
- en: We have now seen the simplest, most primitive way to do buffered input and output
    using `fstream` streams. However, if you're using C++ streams like this, you may
    as well just be using `FILE *`, or even the POSIX API. The "new and (arguably)
    improved" thing about C++ streams is the way they handle *formatting*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了使用 `fstream` 流进行缓冲输入和输出的最简单、最原始的方法。然而，如果你像这样使用 C++ 流，你不妨直接使用 `FILE
    *`，甚至 POSIX API。C++ 流的“新且（有争议地）改进”之处在于它们处理 *格式化* 的方式。
- en: Streaming and manipulators
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流和操纵符
- en: 'Recall that with `printf`, the original types of the arguments are lost, and
    so the format string must do double duty, encoding not only *how to format* each
    data value, but also *the type of* each data value. When we use iostreams, this
    disadvantage goes away. Formatting with iostreams looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，使用 `printf` 时，原始参数类型会丢失，因此格式化字符串必须承担双重任务，不仅编码每个数据值的 *格式化* 方式，还要编码每个数据值的
    *类型*。当我们使用 iostreams 时，这种缺点就消失了。使用 iostreams 的格式化看起来像这样：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `std::cout` is a global variable of type `ostream`, corresponding to `stdout`
    or POSIX file descriptor 1\. There's also `std::cerr`, corresponding to unbuffered
    `stderr` or POSIX file descriptor 2; `std::clog`, again corresponding to file
    descriptor 2 but fully buffered this time; and `std::cin`, a global variable of
    type `istream`, corresponding to `stdin` or POSIX file descriptor 0.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`std::cout` 是一个全局变量，类型为 `ostream`，对应于 `stdout` 或 POSIX 文件描述符 1。还有 `std::cerr`，对应于无缓冲的
    `stderr` 或 POSIX 文件描述符 2；`std::clog`，再次对应于文件描述符 2，但这次是完全缓冲的；以及 `std::cin`，是一个全局变量，类型为
    `istream`，对应于 `stdin` 或 POSIX 文件描述符 0。
- en: 'The standard `ostream` class, which, again, is really `basic_ostream<char,
    char_traits<char>>`, but let''s ignore that) has many, many non-member overloads
    of `operator<<`. For example, here''s the simplest possible overloaded `operator<<`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `ostream` 类，再次强调，实际上是 `basic_ostream<char, char_traits<char>>`，但让我们忽略这一点）有大量的非成员重载的
    `operator<<`。例如，这里是最简单的重载 `operator<<`：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As this function returns a reference to the same `os` it received, we can chain
    the `<<` operators together, as shown in the previous example. This allows us
    to format complicated messages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数返回了对它接收到的相同 `os` 的引用，我们可以将 `<<` 操作符链接在一起，就像前面的例子所示。这允许我们格式化复杂的信息。
- en: 'Unfortunately, our simple `operator<<(ostream&, const string&)` is not nearly
    sufficient to satisfy the variety of formatting concerns described in the *Formatting
    with printf and snprintf* section. Suppose we wanted to print that left-aligned
    string in a column of width 7; how would we do that? The `operator<<` syntax doesn''t
    allow us to pass any additional "formatting option" parameters, which means that
    we simply *cannot* do complicated formatting unless the formatting options are
    carried along in either the left-hand side of `<<` (the ostream object itself)
    or the right-hand side (the object to be formatted). The standard library uses
    a mix of both approaches. Generally, functionality that first appeared in the
    1980s and 1990s carried its formatting options in the ostream object itself; and
    anything added later--not being able to add new member variables to `ostream`
    without breaking binary compatibility--has had to make do by fiddling with the
    right-hand side of the `<<` operator. Let''s look at alignment within a column,
    as an example of the 1980s approach. This is a slightly more full-featured version
    of our `operator<<` for `std::string`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们简单的 `operator<<(ostream&, const string&)` 并不足以满足在 *Formatting with printf
    and snprintf* 部分描述的各种格式化关注点。假设我们想要在一个宽度为 7 的列中打印左对齐的字符串；我们该如何做呢？`operator<<` 语法不允许我们传递任何额外的“格式化选项”参数，这意味着我们**无法**进行复杂的格式化，除非格式化选项被携带在
    `<<` 的左侧（`ostream` 对象本身）或右侧（要格式化的对象）。标准库使用了这两种方法的混合。一般来说，1980 年代和 1990 年代首次出现的功能将它们的格式化选项携带在
    `ostream` 对象本身中；而后来添加的任何内容——由于不能在不破坏二进制兼容性的情况下向 `ostream` 添加新的成员变量——不得不通过调整 `<<`
    操作符的右侧来凑合。以列内的对齐为例，这是 `std::string` 的 `operator<<` 的一个稍微更完整的版本：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `os.width()`, `os.flags()`, and `os.fill()` are all built-in members of
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`os.width()`、`os.flags()` 和 `os.fill()` 都是 `std::ostream` 类的内置成员。
- en: the `std::ostream` class. There's also `os.precision()` for floating-point numbers,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ostream` 类。还有 `os.precision()` 用于浮点数，'
- en: 'and `os.flags()` can indicate the base-10, base-16, or base-8 output for some
    numeric types as well. You can set the "column width" state on a stream by calling
    `os.width(n)`; however, it would be quite painful (and silly!) if we had to set
    up by writing `std::cout.width(10)`, `std::cout.setfill(''.'')`, and so on, before
    each output operation. So, the iostreams library provides some standard *stream
    manipulators* that can be used to get the effect of these member functions but
    in a more "fluent" manner. These manipulators are generally defined in a standard
    header, `<iomanip>`, not in `<iostream>` proper. For example, here''s a manipulator
    that sets the column width of a stream:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.flags()` 可以指示某些数值类型的十进制、十六进制或八进制输出。您可以通过调用 `os.width(n)` 在流上设置“列宽”状态；然而，如果我们不得不在每次输出操作之前编写
    `std::cout.width(10)`、`std::cout.setfill(''.'')` 等来设置，那将会非常痛苦（而且愚蠢！）所以，iostreams
    库提供了一些标准 *流操作符*，可以用来获取这些成员函数的效果，但方式更加“流畅”。这些操作符通常定义在标准头文件 `<iomanip>` 中，而不是 `<iostream>`
    本身。例如，这里有一个设置流列宽的操作符：'
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here are two more standard manipulators, one of which should look very
    familiar to you by now. The `std::endl` manipulator streams a newline to the output
    stream and then flushes it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里还有两个更多的标准操作符，其中一个现在应该非常熟悉您。`std::endl` 操作符将换行符流到输出流，然后刷新它：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have `std::setw`; its friends, `std::left`, `std::right`, `std::hex`,
    `std::dec`, `std::oct`, `std::setfill`, and `std::precision`; and all the rest--I
    say once we have all these manipulators--, we can write iostreams code that looks
    almost natural, if extremely verbose. Compare these `<stdio.h>` and `<iostream>`
    snippets:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `std::setw`；它的朋友 `std::left`、`std::right`、`std::hex`、`std::dec`、`std::oct`、`std::setfill`
    和 `std::precision`；以及所有其余的——我说一旦我们有了所有这些操作符——我们就可以编写出看起来几乎自然的iostreams代码，尽管非常冗长。比较这些
    `<stdio.h>` 和 `<iostream>` 片段：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Bear in mind that every time we use one of these manipulators, we are imperatively
    affecting the state of the stream object itself; this effect may persist for longer
    than just the current output statement. For example, our preceding snippet may
    continue like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次我们使用这些操作符之一时，我们都在命令式地影响流对象的状态；这种影响可能持续的时间比当前输出语句更长。例如，我们前面的片段可能继续如下：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `std::hex` manipulator from the previous example set the mode of this stream
    to "hexadecimal output for numbers," and nothing ever set it back to the "default"
    decimal mode. So now we've unintentionally made everything later in the program
    also print in hex! This is a major disadvantage of the iostreams library (and
    of stateful, imperative programming in general).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的 `std::hex` 操作符将此流的模式设置为“数字的十六进制输出”，并且没有任何东西将其设置回“默认”的十进制模式。因此，现在我们无意中使程序后面的所有内容都打印为十六进制！这是iostreams库（以及状态式、命令式编程的一般缺点）的一个主要缺点。
- en: Streaming and wrappers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流和包装
- en: 'The parameters provided by `std::ios_base` (`left`, `right`, `hex`, `width`,
    `precision`, and so on) are a closed set--a set defined in the mid-1980s and basically
    untouched since then. Since each manipulator modifies one of these parameters
    in the state of the stream, the set of manipulators is essentially closed as well.
    The modern way to affect the formatting of a particular data value is to wrap
    it in a *wrapper*. For example, suppose that we have written a generic algorithm
    for quoting values in a data file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ios_base` 提供的参数（`left`、`right`、`hex`、`width`、`precision` 等）是一个封闭集——一个在1980年代中期定义的集，自那时以来基本上没有改变。由于每个操作符都修改流状态中的一个参数，因此操作符集本质上也是封闭的。影响特定数据值格式的现代方法是将其包装在
    *包装器* 中。例如，假设我们已经编写了一个通用的算法，用于在数据文件中引用值：'
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '(This algorithm is not part of the standard library.) Having this algorithm
    in hand, we could easily construct a wrapper class, where the wrapper class''
    `operator<<` would invoke the following algorithm:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: （此算法不是标准库的一部分。）有了这个算法，我们可以轻松地构造一个包装类，其中包装类的 `operator<<` 将调用以下算法：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '(The `std::ostreambuf_iterator<char>` type is part of the standard library;
    it comes from the `<iterator>` header. We''ll see its friend, `istream_iterator`,
    later in this chapter.) Then, having the wrapper class, we''d be able to write
    very reasonable-looking code to print quoted values to an output stream:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: （`std::ostreambuf_iterator<char>` 类型是标准库的一部分；它来自 `<iterator>` 头文件。我们将在本章后面看到它的朋友
    `istream_iterator`。）然后，有了包装类，我们就能编写出非常合理的代码来将引号内的值打印到输出流中：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The wrapper we just invented bears a deliberate resemblance to the `std::quoted`
    wrapper function found in the standard library's `<iomanip>` header. The major
    difference is that `std::quoted` doesn't use an iterator-based algorithm to produce
    its output; it constructs the entire output in a local `std::string` variable
    and then uses `os << str` to print it out in one fell swoop. This means that `std::quoted`
    is *not allocator-aware* (see [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*) and thus is not suitable for environments where heap allocation
    is forbidden. While the fine details may have been botched in this case,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚发明的包装器与标准库 `<iomanip>` 头文件中找到的 `std::quoted` 包装函数有故意的相似之处。主要区别在于 `std::quoted`
    不使用基于迭代器的算法来生成其输出；它在一个局部的 `std::string` 变量中构建整个输出，然后使用 `os << str` 一次性将其打印出来。这意味着
    `std::quoted` 是*非分配器感知的*（见第 8 章，*分配器*），因此不适合禁止堆分配的环境。虽然在这个案例中细节可能处理不当，
- en: 'the fundamental idea of using a wrapper function or class to adjust the formatting
    of a data value is a good one. You can see it taken to extremes in libraries like
    Boost.Format, where syntax like the following is legal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包装函数或类调整数据值格式的根本思想是好的。你可以在像 Boost.Format 这样的库中看到它被推向极致，其中以下语法是合法的：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Prefer to use wrappers that describe self-contained formatting operations instead
    of manipulators, which "stickily" mutate the state of the stream. In the preceding
    code, we saw how an ill-placed `std::hex` can put a curse on everyone "downstream."
    Now, we'll look at two ways to solve that problem--and two new problems that crop
    up in its place!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更倾向于使用描述自包含格式化操作的包装器，而不是那些"粘性"地改变流状态的操纵器。在前面的代码中，我们看到了一个放置不当的 `std::hex` 如何给所有"下游"的人带来诅咒。现在，我们将探讨两种解决该问题的方法——以及随之出现的新问题！
- en: Solving the sticky-manipulator problem
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决粘性操作器问题
- en: Our "sticky `std::hex`" problem can be solved by saving and restoring the state
    of the
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过保存和恢复 `std::hex` 的状态来解决我们的"粘性 `std::hex`"问题
- en: 'ostream around each complicated output operation, or by creating a brand-new
    ostream each time we want to output something. An example of the former is as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个复杂的输出操作周围使用 ostream，或者每次我们想要输出某些内容时创建一个新的 ostream。前者的一个例子如下：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An example of the latter is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的一个例子如下：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice how convenient it is that the iostreams library separates the idea of
    a "streambuf" from the idea of a "stream"; in the preceding example, we easily
    strip all the formatting-related fields away from a stream by extracting just
    its streambuf: `std::cout.rdbuf()`) and then layer a brand new stream (with its
    own formatting-related fields) on top of that same streambuf.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意iostreams库如何将"streambuf"的概念与"stream"的概念分开；在前面的例子中，我们很容易通过提取其流buf：`std::cout.rdbuf()`）来从流中剥离所有与格式化相关的字段，然后在同一流buf上叠加一个新的流（带有自己的与格式化相关的字段）。
- en: 'However, iostreams formatting has another major disadvantage. Each piece of
    our intended message is output "eagerly" as soon as its respective `operator<<`
    is reached--or, if you prefer, each piece of our intended message is computed
    "lazily" only when its respective `operator<<` is reached--so that we have the
    following piece of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，iostreams 格式化还有一个主要的缺点。我们意图中的每一条消息都会在相应的 `operator<<` 被达到时"急切"地输出——或者，如果你愿意，每一条意图中的消息只在其相应的
    `operator<<` 被达到时"懒惰"地计算——因此我们有以下这段代码：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We'll see the output `There are An exception was thrown` for the preceding piece
    of code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到前面那段代码的输出为 `There are An exception was thrown`。
- en: 'Also, iostreams formatting is *intensely* disagreeable to internationalization
    ("i18n"), because the "shape" of the overall message is never present in the source
    code. Instead of a single string literal `"There are %d piano tuners here.\n"`
    representing a complete thought, which could be translated by a human and stored
    in an external file of translated messages; we have two sentence fragments: `"There
    are "` and `"piano tuners here.\n"`, neither of which can be translated in isolation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，iostreams 格式化对国际化（"i18n"）来说非常令人不悦，因为整体消息的"形状"从未出现在源代码中。我们不是有一个代表完整思想的单个字符串字面量
    `"There are %d piano tuners here.\n"`，它可以由人类翻译并存储在外部翻译消息文件中；我们有两个句子片段："There are
    " 和 `"piano tuners here.\n"`，它们都不能单独翻译。
- en: For all these reasons, I strongly discourage you from attempting to use iostreams
    as the *foundation* of your codebase. Using `<stdio.h>` or a third-party library
    such as `fmt` for formatting is preferable. Boost.Format is also a possibility,
    although it tends to have very long compile times and poor runtime performance
    compared to either of the other two options. If you find yourself typing `<<`,
    `std::hex`, or `os.rdbuf()` more than once or twice a week, you're doing something
    wrong.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，我强烈建议你不要尝试将 iostreams 作为你代码库的 *基础*。使用 `<stdio.h>` 或第三方库如 `fmt` 进行格式化是更好的选择。Boost.Format
    也是一个选择，尽管与另外两种选择相比，它往往具有非常长的编译时间和较差的运行时性能。如果你发现自己一周内不止一次或两次输入 `<<`、`std::hex`
    或 `os.rdbuf()`，那么你可能在做错事。
- en: Yet the iostreams library still has some usable and even useful features! Let's
    look at one of them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，iostreams 库仍然有一些可用甚至有用的功能！让我们看看其中之一。
- en: Formatting with ostringstream
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ostringstream 进行格式化
- en: So far, we've been talking mostly about `fstream`, which roughly corresponds
    to the `fprintf` and `vfprintf` formatting functions in the C API. There is also
    `stringstream`, which corresponds to `snprintf` and `vsnprintf`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了 `fstream`，它大致对应于 C API 中的 `fprintf` 和 `vfprintf` 格式化函数。还有一个 `stringstream`，它对应于
    `snprintf` 和 `vsnprintf`。
- en: 'An `ostringstream` is just like `ostream`, exposing all the usual `operator<<`
    functionality; however, it is backed by `stringbuf` that writes not to a file
    descriptor but to a resizable character buffer--in practice, `std::string`! You
    can use the `oss.str()` method to get a copy of this string for your own use.
    This leads to the following idiom for, for example, "stringifying" an object of
    any type `T`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostringstream` 就像 `ostream`，公开了所有常见的 `operator<<` 功能；然而，它背后是由 `stringbuf`
    支持的，它不是写入文件描述符，而是写入可调整大小的字符缓冲区——在实践中，就是 `std::string`！你可以使用 `oss.str()` 方法来获取这个字符串的副本供自己使用。这导致了以下习惯用法，例如，“stringifying”任何类型
    `T` 的对象：'
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In C++17, you may even consider a multi-argument version of `to_string`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，你甚至可以考虑 `to_string` 的多参数版本：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this version, a call such as `to_string(a, " ", b)` or `to_string(std::hex,
    42)` will have the appropriate semantics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个版本，调用 `to_string(a, " ", b)` 或 `to_string(std::hex, 42)` 将具有适当的语义。
- en: A note on locales
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于区域设置的一则笔记
- en: There is still a pernicious pitfall to beware any time you use either `printf`
    or `ostream` for string formatting (or string parsing). That pitfall is *locales*.
    A full treatment of locales is out of the scope of this book; however, in short,
    the *locale* is "the subset of a user's environment that depends on language and
    cultural conventions." Locale information is exposed programmatically via the
    operating system, allowing a single program to adjust its behavior depending on
    the current user's preferred locale, for example, to control whether "á" is considered
    an alphabetic character, whether the week begins with Sunday or Monday, whether
    dates print as "23-01-2017" or "01-23-2017", and whether floating-point numbers
    print as "1234.56" or "1.234,56". Now, a programmer from the 21st century may
    look at all of those examples and say, "This is crazy! You mean, not one of these
    things is specified by a *standard*? It seems like this situation would inevitably
    lead to subtle and painful bugs!" And you'd be correct!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时使用 `printf` 或 `ostream` 进行字符串格式化（或字符串解析），都应小心一个潜在的陷阱。这个陷阱就是 *区域设置*。区域设置的全面处理超出了本书的范围；然而，简而言之，*区域设置*
    是“用户环境的一个子集，它依赖于语言和文化惯例。”区域信息通过操作系统以编程方式公开，允许单个程序根据当前用户的偏好区域调整其行为，例如，控制“á”是否被视为字母字符，一周是否从星期日开始或星期一开始，日期是否打印为“23-01-2017”或“01-23-2017”，以及浮点数是否打印为“1234.56”或“1.234,56”。现在，21世纪的程序员可能会看到所有这些例子，然后说，“这太疯狂了！我的意思是，这些都不是由一个
    *标准* 指定的？这种情况似乎不可避免地会导致微妙的和痛苦的错误！”你的看法是正确的！
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By changing the *global locale* to `"en_DK.UTF-8"`, we've made it so that none
    of our JSON printing works anymore. Woe betide the hapless user who attempts to
    run a web server or a database in any locale other than `"C.UTF-8"`!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 *全局区域设置* 改为 `"en_DK.UTF-8"`，我们已经使得我们的 JSON 打印不再工作。不幸的用户如果尝试在任何不是 `"C.UTF-8"`
    的区域设置中运行网络服务器或数据库，那可就糟了！
- en: Besides the correctness costs of locale-specific programming, we must also contend
    with the performance costs. Notice that "current locale" is a *global variable*,
    which means that every access to it must be guarded by either an atomic access
    or--worse--a global mutex lock. And, every call to `snprintf` or `operator<<(ostream&,
    double)` must access the current locale. This is a horrendous performance cost,
    and, in certain scenarios, can actually be the performance bottleneck in multi-threaded
    code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了区域特定编程的正确性成本外，我们还必须应对性能成本。请注意，“当前区域”是一个 *全局变量*，这意味着每次访问它都必须由原子访问或——更糟糕的是——全局互斥锁来保护。此外，每次调用
    `snprintf` 或 `operator<<(ostream&, double)` 都必须访问当前区域。这是一个巨大的性能成本，在特定场景中，这实际上可能是多线程代码的性能瓶颈。
- en: As an application programmer, for applications above a certain level of complexity,
    you should get in the habit of writing `std::locale::global(std::locale("C"))`
    as the first line of `main()`. (If you write only `setlocale(LC_ALL, "C")`, as
    you would in a C program, you'll make `<stdio.h>` work correctly but not affect
    the locale used by `<iostream>`. In other words, setting the C++ library's "global
    locale" also modifies the C library's "global locale," but not vice versa.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序程序员，对于具有一定复杂度的应用程序，你应该养成在 `main()` 的第一行写入 `std::locale::global(std::locale("C"))`
    的习惯。（如果你只写 `setlocale(LC_ALL, "C")`，就像在 C 程序中那样，你会使 `<stdio.h>` 正确工作，但不会影响 `<iostream>`
    使用的区域设置。换句话说，设置 C++ 库的“全局区域设置”也会修改 C 库的“全局区域设置”，但反之则不然。）
- en: 'If you don''t even trust your users to be using UTF-8, perhaps prefer the locale
    name `"C.UTF-8"` instead of just `"C"`; however, be aware that the name `"C.UTF-8"`
    has been around only since about 2015, and may not be available on older systems.
    In fact, the availability of *any* locale other than `"C"` depends on the user.
    Locales are similar to time zones in this way: there is only one locale and one
    timezone that is *guaranteed* to be available on any platform in the world, and
    not coincidentally, it''s the one you should always be using.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你甚至不信任你的用户使用 UTF-8，可能更喜欢 `"C.UTF-8"` 而不是仅仅 `"C"`；然而，请注意，`"C.UTF-8"` 的名称自 2015
    年左右以来才出现，可能在较旧的系统上不可用。实际上，除了 `"C"` 以外的任何区域设置的可用性取决于用户。在这方面，区域设置类似于时区：世界上只有一个区域设置和一个时区是
    *保证* 可在任何平台上使用的，而且不是巧合的是，它就是你应该始终使用的那个。
- en: As a programmer of third-party libraries, you have two possible paths. The easier
    path is to assume that your library will only ever be used in applications that
    have set their global locale to `"C"`, and so you don't need to worry about locales;
    go ahead and use `snprintf` and `operator<<` to your heart's content. (However,
    notice that this does not solve the performance problem associated with locale-aware
    programming. That global mutex lock will still be there, taking up valuable cycles.)
    The harder path--harder because it requires conscientious adherence to a subtle
    guideline--is to avoid all use of locale-aware formatting functions. This path
    has only really become feasible as of C++17, with some of the very newest library
    facilities, to which we will turn now.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第三方库的程序员，你有两条可能的路径。较容易的路径是假设你的库将只会在将全局区域设置设置为 `"C"` 的应用程序中使用，因此你不需要担心区域设置；尽情地使用
    `snprintf` 和 `operator<<` 吧。（然而，请注意，这并不能解决与区域感知编程相关的性能问题。那个全局互斥锁仍然存在，占用宝贵的周期。）较难的路径——之所以困难，是因为它要求对细微的指南进行负责任的遵守——是避免使用所有区域感知的格式化函数。这条路径直到
    C++17 才真正可行，得益于一些最新的库功能，我们现在将转向这些功能。
- en: Converting numbers to strings
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为字符串
- en: 'Consider the following declarations:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下声明：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To convert the `intvalue` integer to a string of digits, C++17 offers us the
    following options:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `intvalue` 整数转换为数字字符串，C++17 给我们提供了以下选项：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All four alternatives have their advantages. The main advantage of `std::to_string`
    is that it is conveniently composable into larger messages in a high-level code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四种替代方案都有其优点。`std::to_string` 的主要优点是它方便地组合成高层代码中的更大消息：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The main advantages of `std::to_chars` are that it is locale-independent and
    that it can easily be composed in low-level code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::to_chars` 的主要优点是它是区域无关的，并且它可以在底层代码中轻松组合：'
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The main disadvantage of `std::to_chars` is that it is a very new feature of
    C++17; as of this writing, the `<charconv>` header is not present in any major
    implementation of the standard library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::to_chars` 的主要缺点是它是 C++17 的一个非常新的特性；截至本文撰写时，`<charconv>` 头文件尚未出现在任何主要标准库的实现中。'
- en: 'To convert the floating-point `floatvalue` number to a string of digits, C++17
    offers us the following options:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要将浮点数`floatvalue`转换为数字字符串，C++17为我们提供了以下选项：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that when printing the floating-point, every method except `std::to_string`
    offers the possibility of adjusting the formatting; and every method except `std::to_chars`
    is locale-aware and thus problematic in a portable code. All of these methods
    are available for the `double` and `long double` data types, as well as for `float`.
    In any case, the same respective advantages and disadvantages apply for integer
    formatting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在打印浮点数时，除了`std::to_string`之外的所有方法都提供了调整格式的可能性；除了`std::to_chars`之外的所有方法都是区域感知的，因此在可移植代码中可能存在问题。所有这些方法都适用于`double`和`long
    double`数据类型，以及`float`。在任何情况下，整数格式化相同的相应优点和缺点都适用。
- en: Converting strings to numbers
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: The reverse problem of formatting numbers for output is *parsing* numbers from
    the user's input. Parsing is intrinsically much more subtle and difficult than
    formatting, because we must account for the possibility of error. Every number
    can plausibly be turned into a string of digits, but not every string (or even
    every string of digits!) can plausibly be turned into a number. So, any function
    that purports to parse numbers must have some way of dealing with strings that
    do not represent valid numbers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化数字以供输出的反向问题是解析用户输入中的数字。解析本质上比格式化更微妙和困难，因为我们必须考虑到错误的可能性。每个数字都可以合理地转换为一个数字字符串，但并非每个字符串（甚至每个数字字符串！）都可以合理地转换为一个数字。因此，任何声称可以解析数字的函数都必须有一种处理不表示有效数字的字符串的方法。
- en: 'Consider the following declarations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下声明：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To convert the string in `buffer` or `str` to an `intvalue` integer, C++17
    offers us the following options:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`buffer`或`str`中的字符串转换为`intvalue`整数，C++17为我们提供了以下选项：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are more parsing methods here than there were formatting methods in the
    previous section; this is because the C standard library alone offers us three
    different methods: `atoi`, the oldest method, and the only one whose behavior
    on invalid input is *literally undefined*, so avoid it in production code; `strtol`,
    the standard replacement for `atoi`, it communicates overflow errors via the global
    variable `errno`, which may be inappropriate for threaded or high-performance
    code); and `sscanf`, a function in the same family as `snprintf`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的解析方法比上一节中提供的格式化方法要多；这是因为C标准库本身就提供了三种不同的方法：`atoi`，这是最老的方法，也是唯一一个在无效输入上行为**实际上未定义**的方法，因此在生产代码中应避免使用；`strtol`，是`atoi`的标准替代品，它通过全局变量`errno`来传达溢出错误，这可能不适合线程或高性能代码）；以及`sscanf`，这是一个与`snprintf`同族的函数。
- en: '`std::stoi` is a very good replacement for `atoi` in one-off parsing of user
    input, and a very bad option for high-performance work. It does a very good job
    of detecting errors--`std::stoi("2147483648")` throws `std::out_of_range` and
    `std::stoi("abc")` throws `std::invalid_argument`. (And, although `std::stoi("42abc")`
    returns 42 without complaint, the `std::stoi("42abc", &endidx)` invocation will
    set `endidx` to 2 instead of 5, indicating that something may be amiss.) The major
    disadvantage of `std::stoi` is that it works only on the exact type `std::string`--there
    is no overload of `std::stoi` for `string_view`, no overload for `std::pmr::string`,
    and *certainly* no overload for `const char *`!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stoi`是`atoi`在一次性解析用户输入时的一个非常好的替代品，但在高性能工作中则是一个很糟糕的选择。它能够很好地检测错误--`std::stoi("2147483648")`会抛出`std::out_of_range`，而`std::stoi("abc")`会抛出`std::invalid_argument`。(尽管`std::stoi("42abc")`会无声地返回42，但`std::stoi("42abc",
    &endidx)`调用会将`endidx`设置为2而不是5，这表明可能存在问题。) `std::stoi`的主要缺点是它只适用于精确的`std::string`类型--没有为`string_view`提供`std::stoi`的重载，也没有为`std::pmr::string`提供重载，当然也没有为`const
    char *`提供重载！'
- en: '`std::from_chars` is the most modern and performant option to parse integers.
    Its main advantage is that unlike any of the other contenders, `from_chars` does
    not require its input buffer to be null-terminated--it takes a pair of `begin,
    end` pointers to indicate the range of characters to be parsed, and will never
    read past `end`. It still has some unfortunate limitations--for example, it cannot
    be taught not to skip whitespace, nor can it be taught to parse uppercase hexadecimal
    input. The idiom to test `r.ec` for error is shown near the beginning of [Chapter
    12](part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d), *Filesystem*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::from_chars`是最新且性能最优的解析整数选项。其主要优势在于，与其他任何竞争者不同，`from_chars`不需要其输入缓冲区以空字符终止--它通过一对`begin,
    end`指针来指示要解析的字符范围，并且永远不会读取超过`end`。它仍然存在一些不幸的限制--例如，它不能被教会不跳过空白字符，也不能被教会解析大写十六进制输入。测试`r.ec`是否出现错误的惯用方法在[第12章](part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d)的开头部分展示，*文件系统*。'
- en: 'The `strtol`, `sscanf`, and `stoi` functions indicate that they recognize "base
    0." This is a special-case syntax in the library, where passing a base of `0`
    (or, in the case of `sscanf`, a format specifier of `"%i"`) tells the library
    to parse the input as if it were a C integer literal: `0123` will parse as the
    octal representation of decimal 83, `0x123` will parse as the hexadecimal representation
    of 291, and `019` will parse as the octal representation of the integer 1, with
    the character `9` left unparsed because it is not a valid octal. "Base 0" is never
    an appropriate behavior for a computer program, and `from_chars` wisely chucks
    it to the trash can, where it belongs.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`strtol`、`sscanf`和`stoi`函数表明它们识别“基数0”。这是库中的特殊案例语法，其中传递基数`0`（或者在`sscanf`的情况下，格式说明符为`"%i"`）告诉库将输入解析为C整数字面量：`0123`将被解析为十进制83的八进制表示，`0x123`将被解析为291的十六进制表示，`019`将被解析为整数1的八进制表示，字符`9`未被解析，因为它不是有效的八进制数字。对于计算机程序来说，“基数0”永远不会是适当的行为，而`from_chars`明智地将它扔进了垃圾桶，那里才是它应该去的地方。'
- en: 'To convert a string to a floating-point `floatvalue`, C++17 offers the following
    options:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为浮点数`floatvalue`，C++17提供了以下几种选择：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All of these parsers--even `std::from_chars`--accept input strings, `"Infinity"`
    and `"Nan"` (case-insensitively), and also accept "hex float" inputs so that,
    for example, `"0x1.c"` parses as the decimal number 1.75\. All but `std::from_chars`
    are locale-aware, and thus problematic in portable code. Where the locale problems
    with integer parsing are largely theoretical, the widespread real-world use of
    locales where `.` is not the decimal separator means that it is very easy to run
    into cases where `std::stof` and `std::stod` don''t work as expected:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解析器--甚至包括`std::from_chars`--都接受输入字符串`"Infinity"`和`"Nan"`（不区分大小写），并且也接受“十六进制浮点数”输入，例如，`"0x1.c"`将被解析为十进制数1.75。除了`std::from_chars`之外，所有这些解析器都是区域感知的，因此在可移植代码中存在问题。在整数解析中遇到区域问题的理论性很大，但在实际应用中，广泛使用`.`不是小数分隔符的区域意味着，很容易遇到`std::stof`和`std::stod`不按预期工作的案例：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice in passing the "non-portable behavior on trailing text" mentioned in
    connection with `istringstream`. Different library vendors do different things
    with stream input, and it''s not always clear which should be considered "correct":'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，与`istringstream`相关的“在尾部文本上的不可移植行为”。不同的库供应商对流输入的处理方式不同，并不总是清楚哪一种应该被认为是“正确的”：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because of these portability issues--symptoms of the subtle complexity of stream
    input in general--, I recommend you avoid using `istringstream` for input parsing,
    even though `ostringstream` may sometimes be the most appropriate choice for output
    formatting.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些可移植性问题--这是流输入在一般情况下微妙复杂性的症状--我建议您避免使用`istringstream`进行输入解析，尽管`ostringstream`有时可能是输出格式化的最佳选择。
- en: Another good rule of thumb is to separate the *validation* (or *lexing*) of
    input from the *parsing* of input. If you can validate beforehand that a certain
    string contains all digits, or matches the regular-expression syntax of a valid
    floating-point number, then you merely have to pick a parsing method that can
    detect overflow and/or trailing text; for example, `std::stof` or `std::from_chars`.
    For more on lexing input with regular expressions, see [Chapter 10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d),
    *Regular Expressions*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的经验法则是将输入的 *验证*（或 *词法分析*）与输入的 *解析* 分开。如果你可以在事先验证某个字符串包含所有数字，或者与有效浮点数的正则表达式语法匹配，那么你只需要选择一个可以检测溢出和/或尾随文本的解析方法；例如，`std::stof`
    或 `std::from_chars`。有关使用正则表达式进行词法分析输入的更多信息，请参阅第 10 章，*正则表达式*。
- en: Reading a line or word at a time
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐行或逐词读取
- en: 'Reading from standard input one line at a time is a very common task in simple
    scripts, and most scripting languages make it a one-liner. For example, in Python:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准输入逐行读取是一个非常常见的简单脚本任务，大多数脚本语言都将其简化为一行代码。例如，在 Python 中：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And in Perl:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Perl 中：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In C++, the task is almost as easy. Notice that C++''s `std::getline` function,
    unlike the other languages'' idioms, removes the trailing newline (if any) from
    each line it reads:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，这项任务几乎同样简单。请注意，与其它语言的惯用方法不同，C++ 的 `std::getline` 函数从它读取的每一行中移除了尾随的换行符（如果有的话）：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In each of these cases, the entire input never lives in memory at once; we are
    indeed "streaming" the lines through our program in an efficient manner. (And
    the `std::getline` function is allocator-aware; if we absolutely need to avoid
    heap allocation, we can exchange `std::string line` for `std::pmr::string`.) The
    `process` function may take each line and use a regular expression (see [Chapter
    10](part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d), *Regular Expressions*)
    to validate and split the line into fields for further parsing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，整个输入一次不会全部存储在内存中；我们确实是以一种有效的方式通过程序“流式传输”这些行。（并且 `std::getline` 函数是分配器感知的；如果我们绝对需要避免堆分配，我们可以将
    `std::string line` 交换为 `std::pmr::string`。）`process` 函数可以取每一行，并使用正则表达式（见第 10 章，*正则表达式*）进行验证并将行分割成字段以进行进一步解析。
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`std::istream_iterator<T>` is a standard library type, defined in the `<iterator>`
    header, which wraps a pointer to `istream`. The iterator''s `operator++` reads
    a value of type `T` from the istream, as if by `operator>>`, and that value is
    returned by the iterator''s `operator*`. Putting it all together, this allows
    us to read a whole sequence of whitespace-delimited words from `std::cin` by relying
    on the fact that `std::istream::operator>>(std::string&)` reads a single whitespace-delimited
    word.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::istream_iterator<T>` 是一个标准库类型，定义在 `<iterator>` 头文件中，它封装了一个指向 `istream`
    的指针。迭代器的 `operator++` 从 istream 中读取类型为 `T` 的值，就像通过 `operator>>` 一样，并且这个值由迭代器的
    `operator*` 返回。将所有这些放在一起，这允许我们通过依赖于 `std::istream::operator>>(std::string&)` 读取单个空白分隔的单词的事实，从
    `std::cin` 中读取一系列由空白分隔的单词。'
- en: 'We can reuse our `streamer` class template to read a whole sequence of integers
    from `std::cin` and do something with each of them:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们的 `streamer` 类模板来从 `std::cin` 中读取一系列整数并对每个整数进行处理：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While the I/O facilities of C++ are certainly very complicated, as befits a
    system's programming language with its roots in the 1980s, we see from these last
    few examples that it is nonetheless possible to hide this complexity under a layer
    of abstraction and end up with code that looks almost as simple as Python.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C++ 的 I/O 功能确实非常复杂，正如其根源在 1980 年代的系统编程语言所应具备的那样，但我们从这些最后的几个例子中看到，仍然可以在抽象层下面隐藏这种复杂性，并最终得到几乎与
    Python 一样简单的代码。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Data output can be divided roughly into *formatting* and *buffering*. Data input
    can be divided just as roughly into *buffering* and *parsing*; although, the parsing
    step gets easier if you can put a *lexing* step in front. (We'll talk more about
    lexing in the very next chapter!)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 数据输出可以大致分为 *格式化* 和 *缓冲*。数据输入可以同样大致分为 *缓冲* 和 *解析*；尽管，如果你可以在前面加入一个 *词法分析* 步骤，解析步骤会更容易。（我们将在下一章中更多地讨论词法分析！）
- en: The classical iostreams API is built on top of `<stdio.h>`, which in turn is
    built on top of the POSIX file-descriptor API. You can't understand the higher
    levels without a good understanding of the levels beneath it. In particular, the
    mess of `fopen` mode strings and `fstream` constructor flags can be understood
    only by reference to lookup tables mapping them onto the actual underlying POSIX
    `open` flags.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 iostreams API 是建立在 `<stdio.h>` 之上的，而 `<stdio.h>` 又是建立在 POSIX 文件描述符 API 之上的。如果不了解其下层的级别，就无法理解更高层的级别。特别是，`fopen`
    模式字符串和 `fstream` 构造函数标志的混乱只能通过参考将它们映射到实际底层 POSIX `open` 标志的查找表来理解。
- en: The POSIX API is concerned only with moving chunks of data to and from file
    descriptors; it does not "buffer" data in the naive sense. The `<stdio.h>` API
    adds a layer of buffering on top of POSIX; the C `FILE` may be fully buffered,
    line-buffered, or unbuffered. Furthermore, `<stdio.h>` provides performant (but
    locale-aware) formatting routines, of which the most important are `fprintf`,
    `snprintf`, and `sscanf`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX API 仅关注将数据块在文件描述符之间移动；它并不在直观意义上“缓冲”数据。`<stdio.h>` API 在 POSIX 之上添加了一层缓冲；C
    的 `FILE` 可以是完全缓冲、行缓冲或无缓冲。此外，`<stdio.h>` 提供了性能良好的（但考虑地区设置的）格式化例程，其中最重要的是 `fprintf`、`snprintf`
    和 `sscanf`。
- en: The `<iostream>` API separates the "streambuf", (which identifies the source
    or sink of raw bytes, and its buffering mode) from the "stream" (which holds the
    state related to formatting). The different kinds of streams (input or output?
    file or string?) form a classical polymorphic hierarchy with complicated and,
    at times, unintuitive inheritance relationships. Avoiding `<iostream>` in production
    code is preferable as it is slow and opaque compared to the `<stdio.h>` or POSIX
    interfaces. Either way, beware of locale-dependent formatting routines.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iostream>` API 将“streambuf”（它标识原始字节的来源或目的地及其缓冲模式）与“stream”（它持有与格式化相关的状态）分开。不同类型的流（输入或输出？文件或字符串？）形成一个经典的泛型层次结构，具有复杂且有时不直观的继承关系。在生产代码中避免使用
    `<iostream>` 是更好的选择，因为它与 `<stdio.h>` 或 POSIX 接口相比既慢又透明。无论如何，要小心地区依赖的格式化例程。'
- en: For one-off quick tasks, prefer parsing numbers via `std::stoi`, which detects
    and throws on error, and formatting with `std::to_string` or `snprintf`. For high-performance
    situations, parsing with `std::from_chars` and formatting with `std::to_chars`
    is preferable if you can find a library implementation that supports these brand
    new functions from the `<charconv>` header.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性快速任务，建议通过 `std::stoi` 解析数字，它会检测错误并抛出异常，并通过 `std::to_string` 或 `snprintf`
    进行格式化。对于高性能情况，如果可以找到支持这些来自 `<charconv>` 头文件的新函数的库实现，则使用 `std::from_chars` 进行解析和
    `std::to_chars` 进行格式化是更好的选择。
