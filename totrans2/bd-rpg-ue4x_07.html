<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Gold, Items, and a Shop</h1></div></div></div><p>Now that you have created an NPC that talks to the player, it is time to allow the NPC to help the player. In this chapter, we will use the NPC as a shop owner, displaying items for the user to buy. Before we do this, the user is going to need some sort of currency to buy the items. We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting and getting gold instances</li><li class="listitem" style="list-style-type: disc">Item data</li><li class="listitem" style="list-style-type: disc">The shop screen framework</li><li class="listitem" style="list-style-type: disc">The item button framework</li><li class="listitem" style="list-style-type: disc">Linking the item data</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Setting and getting gold instances</h1></div></div></div><p>While we move <a id="id425" class="indexterm"/>on to making a shopping interface, via the <strong>Shop</strong> button, we must first be able to pull the currency in order to pay for items in the shop. In a previous chapter, we discussed and made placeholders for gold, but we did not actually create gold <a id="id426" class="indexterm"/>values. In this game, we would like gold to be dropped by enemies at the end of battle. In this case, enemies will need some sort of gold data that we can add to the player's gold data (eventually, items will need this gold data that is tied to them as well). In <a class="link" href="ch04.html" title="Chapter 4. Pause Menu Framework">Chapter 4</a>, <em>Pause Menu Framework</em>, we created a pause menu that has a gold placeholder, and we will now add gold to this pause menu.</p><p>First, let's add a <code class="literal">Gold</code> property to <code class="literal">FEnemyInfo.h</code>. Navigate to <strong>Source</strong> | <strong>RPG</strong> | <strong>Data</strong>, open <code class="literal">FEnemyInfo.h</code>, and add a <code class="literal">Gold</code> property of an integer data type to your <code class="literal">EnemyInfo</code> table, as follows:</p><div><pre class="programlisting">UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "EnemyInfo" )
  int32 Gold;</pre></div><p>We now need to tie the <code class="literal">Gold</code> property with our standard <code class="literal">GameCharacter</code> properties so that we can update any instance of an enemy with the proper gold value. Next, you will open <code class="literal">GameCharacter.h</code>, which is located in <strong>RPG </strong>under <strong>Source</strong>, and add a public <code class="literal">UProperty</code> to the <code class="literal">UCharacter</code> class for gold similar to that in <code class="literal">FEnemyInfo.h</code>:</p><div><pre class="programlisting">UPROPERTY(BlueprintReadWrite,EditAnywhere, Category = CharacterInfo)
  int32 Gold;</pre></div><p>Then, head <a id="id427" class="indexterm"/>into <code class="literal">GameCharacter.cpp</code> to set the return value of the gold <a id="id428" class="indexterm"/>that is equal to the value set in <code class="literal">EnemyInfo</code>, so that each instance of this particular enemy will return the amount of gold set in the enemy's data table:</p><div><pre class="programlisting">character-&gt;Gold = enemyInfo-&gt;Gold;</pre></div><p>When you are finished, the enemy's character information in <code class="literal">GameCharacter.cpp</code> will look like this:</p><div><pre class="programlisting">UGameCharacter* UGameCharacter::CreateGameCharacter(FEnemyInfo* enemyInfo, UObject* outer)
{
 UGameCharacter* character = NewObject&lt;UGameCharacter&gt;(outer);

 character-&gt;CharacterName = enemyInfo-&gt;EnemyName;
 character-&gt;ClassInfo = nullptr;

 character-&gt;MHP = enemyInfo-&gt;MHP;
 character-&gt;MMP = 0;
 character-&gt;HP = enemyInfo-&gt;MHP;
 character-&gt;MP = 0;

 character-&gt;ATK = enemyInfo-&gt;ATK;
 character-&gt;DEF = enemyInfo-&gt;DEF;
 character-&gt;LUCK = enemyInfo-&gt;Luck;
 character-&gt;Gold = enemyInfo-&gt;Gold;

 character-&gt;decisionMaker = new TestDecisionMaker();
 character-&gt;isPlayer = false;
 return character;
}</pre></div><p>We now need to choose when to accumulate the gold, and in this case, we will accumulate the gold from combat. So, navigate to <strong>Source</strong> | <strong>RPG</strong> | <strong>Combat</strong>, open <code class="literal">CombatEngine.h</code>, and create a public gold variable that we will use to store all the gold won in the battle:</p><div><pre class="programlisting">int32 GoldTotal;</pre></div><p>When you have<a id="id429" class="indexterm"/> finished declaring the <code class="literal">GoldTotal</code> variable, the <code class="literal">CombatEngine.h</code> file will <a id="id430" class="indexterm"/>look like this:</p><div><pre class="programlisting">#pragma once
#include "RPG.h"
#include "GameCharacter.h"


/**
 * 
 */
enum class CombatPhase : uint8
{
 CPHASE_Decision,
 CPHASE_Action,
 CPHASE_Victory,
 CPHASE_GameOver,
};

class RPG_API CombatEngine
{
public:
 TArray&lt;UGameCharacter*&gt; combatantOrder;

 TArray&lt;UGameCharacter*&gt; playerParty;
 TArray&lt;UGameCharacter*&gt; enemyParty;

 CombatPhase phase;
 int32 GoldTotal;

protected:
 UGameCharacter* currentTickTarget;
 int tickTargetIndex;
 bool waitingForCharacter;

public:
 CombatEngine(TArray&lt;UGameCharacter*&gt; playerParty,
  TArray&lt;UGameCharacter*&gt; enemyParty);
 ~CombatEngine();

 bool Tick(float DeltaSeconds);

protected:
 void SetPhase(CombatPhase phase);
 void SelectNextCharacter();
};</pre></div><p>The next step that we need to perform is telling the engine when to give the gold to the player. As mentioned <a id="id431" class="indexterm"/>earlier, we want players to win gold from enemies that can easily be integrated into our combat engine. Navigate to <strong>Source</strong> | <strong>RPG</strong> | <strong>Combat</strong>, and open <code class="literal">CombatEngine.cpp</code>. Let's <a id="id432" class="indexterm"/>first scroll down to the <code class="literal">for</code> loop that we created in <a class="link" href="ch03.html" title="Chapter 3. Exploration and Combat">Chapter 3</a>, <em>Exploration and Combat</em>, to check for a victory. Just above this <code class="literal">for</code> loop, declare a new <code class="literal">Gold</code> integer, and set it to <code class="literal">0</code>:</p><div><pre class="programlisting">int32 Gold = 0;</pre></div><p>This will assure that, if we don't have a victory and need to cycle through the <code class="literal">for</code> loop again, the gold gained in battle will reset to 0. Next, we need to accumulate the gold from every enemy killed; thus, within the <code class="literal">for</code> loop, we have <code class="literal">Gold</code> increment by each enemy's gold:</p><div><pre class="programlisting">Gold += this-&gt;enemyParty[i]-&gt;Gold;</pre></div><p>Your <code class="literal">for</code> loop will now look like this:</p><div><pre class="programlisting">for( int i = 0; i &lt; this-&gt;enemyParty.Num(); i++ )
{
  if( this-&gt;enemyParty[i]-&gt;HP &lt;= 0 ) deadCount++;
  Gold += this-&gt;enemyParty[i]-&gt;Gold;
}</pre></div><p>After the <code class="literal">for</code> loop, you will still have an <code class="literal">if</code> condition that checks whether the enemy party is dead; if the enemy party is dead, the combat phase will change to the victory phase. If the condition is <code class="literal">true</code>, it means that we won the battle; therefore, we should be rewarded with the gold from the <code class="literal">for</code> loop. Since the <code class="literal">Gold</code> variable that we want to add is in the <code class="literal">GoldTotal</code> variable, we simply set the local <code class="literal">Gold</code> variable to the new value of <code class="literal">GoldTotal</code>:</p><div><pre class="programlisting">GoldTotal = Gold;</pre></div><p>When you are finished, your <code class="literal">if</code> condition will now look like this:</p><div><pre class="programlisting">if (deadCount == this-&gt;enemyParty.Num())
 {
  this-&gt;SetPhase(CombatPhase::CPHASE_Victory);
  GoldTotal = Gold;
  return false;
 }</pre></div><p>Now that we have set enemies to drop gold after the player is victorious in battle, the next thing that we need to do is add gold to our game data; more specifically, it would be best to add it in <code class="literal">RPGGameInstance.h</code>, since an instance of the game will always be active. It would be unwise to add the gold data to a party member unless there is a specific party member who will always be in the game. So, let's open <code class="literal">RPGGameInstance.h</code> located in <strong>RPG</strong> under <strong>Source</strong>.</p><p>As a public property, add another integer to <code class="literal">Game Data</code> that we will call <code class="literal">GameGold</code>. Also, ensure that <code class="literal">GameGold</code> is read- and write-enabled because we want to be able to add and subtract gold; therefore editing of <code class="literal">GameGold</code> must be enabled:</p><div><pre class="programlisting">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Game Data")
    int32 GameGold;</pre></div><p>Now that we <a id="id433" class="indexterm"/>can <a id="id434" class="indexterm"/>create instances of <code class="literal">GameGold</code>, go to your <code class="literal">RPGGameMode.cpp</code> file where you originally set up the logic for the game over and victory conditions; in the victory condition, create a pointer to <code class="literal">URPGGameInstance</code> that we will call <code class="literal">gameInstance</code>, and set it equal to a cast to <code class="literal">GetGameInstance</code>:</p><div><pre class="programlisting">URPGGameInstance* gameInstance = Cast&lt;URPGGameInstance&gt;(GetGameInstance());</pre></div><p>We can now use <code class="literal">gameInstance</code> to add the total gold that we got from the battle to <code class="literal">GameGold</code>:</p><div><pre class="programlisting">gameInstance-&gt;GameGold += this-&gt;currentCombatInstance-&gt;GoldTotal;</pre></div><p>At this point, the value of <code class="literal">GameGold</code> that we are using as the player's gold will now be incremented by the gold won in the battle. The <code class="literal">tick</code> function in <code class="literal">RPGGameMode.cpp</code> will now look like this:</p><div><pre class="programlisting">void ARPGGameMode::Tick( float DeltaTime )
{
  if( this-&gt;currentCombatInstance != nullptr )
  {
    bool combatOver = this-&gt;currentCombatInstance-&gt;Tick( DeltaTime );
    if( combatOver )
    {
      if( this-&gt;currentCombatInstance-&gt;phase == CombatPhase::CPHASE_GameOver )
      {
        UE_LOG( LogTemp, Log, TEXT( "Player loses combat, game over" ) );

        Cast&lt;URPGGameInstance&gt;( GetGameInstance() )-&gt;PrepareReset();

        UUserWidget* GameOverUIInstance = CreateWidget&lt;UUserWidget&gt;( GetGameInstance(), this-&gt;GameOverUIClass );
        GameOverUIInstance-&gt;AddToViewport();
      }
      else if( this-&gt;currentCombatInstance-&gt;phase == CombatPhase::CPHASE_Victory )
      {
        UE_LOG( LogTemp, Log, TEXT( "Player wins combat" ) );
        //add gold to total gold
        URPGGameInstance* gameInstance = Cast&lt;URPGGameInstance&gt;(GetGameInstance());
        gameInstance-&gt;GameGold += this-&gt;currentCombatInstance-&gt;GoldTotal;

        // enable player actor
        UGameplayStatics::GetPlayerController( GetWorld(), 0 )-&gt;SetActorTickEnabled( true );
      }

      for( int i = 0; i &lt; this-&gt;currentCombatInstance-&gt;playerParty.Num(); i++ )
      {
        this-&gt;currentCombatInstance-&gt;playerParty[i]-&gt;decisionMaker = nullptr;
      }

      this-&gt;CombatUIInstance-&gt;RemoveFromViewport();
      this-&gt;CombatUIInstance = nullptr;

      delete( this-&gt;currentCombatInstance );
      this-&gt;currentCombatInstance = nullptr;
      this-&gt;enemyParty.Empty();
    }
  }
}</pre></div><p>Now, you <a id="id435" class="indexterm"/>need to <a id="id436" class="indexterm"/>make sure that all your changes are saved and recompile your entire project (you may need to restart UE4).</p><p>We can now adjust the gold value of each enemy character that we have from the enemy's Data Table. In <strong>Content Browser</strong>, navigate to the <strong>Enemies</strong> Data Table located at <strong>Data </strong>under <strong>Content</strong>. In the Data Table, you will now see a <strong>Gold</strong> row. Add any value that you want to the <strong>Gold</strong> row, and save the Data Table:</p><div><img src="img/B04548_07_01.jpg" alt="Setting and getting gold instances"/></div><p>Now that an enemy <a id="id437" class="indexterm"/>has a gold value, there is a real value that is bound to the <code class="literal">Gold</code> variable in <code class="literal">EnemyInfo</code> that gets added to <code class="literal">GameGold</code> if the player is victorious in battle. However, we need to display that gold; luckily, we still have a placeholder for the gold in <a id="id438" class="indexterm"/>our pause menu. Open the <strong>Pause_Main</strong> Widget Blueprint, and click on the <strong>Editable_Gold</strong> Text Block that we created in <a class="link" href="ch04.html" title="Chapter 4. Pause Menu Framework">Chapter 4</a>, <em>Pause Menu Framework</em>. In the <strong>Details</strong> panel, go to <strong>Content</strong> and create a binding for the Text Block, which will open the graph for <strong>Get Editable Gold Text</strong>:</p><div><img src="img/B04548_07_02.jpg" alt="Setting and getting gold instances"/></div><p>The first thing that we need to do is get the game instance of <strong>RPGGameInstance</strong> by creating a <strong>Get Game Instance</strong> function located under <strong>Game</strong> and setting it as an object of <strong>Cast To RPGGameInstance</strong>:</p><div><img src="img/B04548_07_03.jpg" alt="Setting and getting gold instances"/></div><p>We can then get <a id="id439" class="indexterm"/>the <code class="literal">GameGold</code> variable from <strong>RPGGameInstance</strong>, which<a id="id440" class="indexterm"/> is the variable that stores the current gold total for the game. It is located in <strong>Game Data </strong>under <strong>Variables</strong>. Link it to the <strong>As RPGGameInstance</strong> pin in <strong>Cast To RPGGameInstance</strong>:</p><div><img src="img/B04548_07_04.jpg" alt="Setting and getting gold instances"/></div><p>Lastly, link <strong>Game Gold</strong> to <strong>Return Value</strong> in <strong>ReturnNode</strong> and allow <strong>Get Editable Gold Text</strong> to trigger <strong>Cast To RPGGameInstance</strong>, which will<a id="id441" class="indexterm"/> trigger <strong>ReturnNode</strong>. Your <strong>Get Editable Gold Text</strong> binding <a id="id442" class="indexterm"/>will now look like this:</p><div><img src="img/B04548_07_05.jpg" alt="Setting and getting gold instances"/></div><p>If you test this now, you will be able to get into battle, win gold from your enemies on victory, and now you will be able to see your gold accumulate in your pause menu. We can use these same variables to add to any menu system, including a shop.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Item data</h1></div></div></div><p>Now that we are<a id="id443" class="indexterm"/> finished with the gold creation, we need to create one more thing before we make a shop, that is, items. There are many ways to make items, but it is best to keep an inventory and stats of items through the use of Data Tables. So, let's first create a new C++ <code class="literal">FTableRowBase</code> struct similar to the <code class="literal">CharacterInfo</code> structs that you previously created. Our files will be called <code class="literal">ItemsData.h</code> and <code class="literal">ItemsData.cpp</code>, and we will put these files where our other data is; that is, by navigating to <strong>Source</strong> | <strong>RPG</strong> | <strong>Data</strong>. The <code class="literal">ItemsData.cpp</code> source file will include the following two header files:</p><div><pre class="programlisting">#include "RPG.h"
#include "ItemsData.h"</pre></div><p>The <code class="literal">ItemsData.h</code> header file will contain definitions of all the item data that we will need. In this case, the item data will be stats that the player has, since items will most likely affect stats. The stats only need to be of the integer type and read-enabled since we won't be changing the value of any of the items directly. Your <code class="literal">ItemsData.h</code> file will look something like this:</p><div><pre class="programlisting">#pragma once

#include "GameFramework/Actor.h"
#include "ItemsData.generated.h"

/**
 *
 */

USTRUCT( BlueprintType )
struct FItemsData : public FTableRowBase
{
  GENERATED_USTRUCT_BODY()

  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "ItemData" )
    int32 HP;

  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "ItemData" )
    int32 MP;

  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "ItemData" )
    int32 ATK;

  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "ItemData" )
    int32 DEF;

  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "ItemData" )
    int32 Luck;

  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = "ItemData" )
    int32 Gold;
};</pre></div><p>At this point, you can<a id="id444" class="indexterm"/> recompile, and you are now ready to create your own Data Table. Since we are creating a shop, let's create a Data Table for the shop in <strong>Content Browser</strong> and in the <code class="literal">Data</code> folder by navigating to <strong>Miscellaneous</strong> | <strong>Data Table</strong>, and then using <strong>Items Data</strong> as the structure.</p><div><img src="img/B04548_07_06.jpg" alt="Item data"/></div><p>Name your new <a id="id445" class="indexterm"/>Data Table <strong>Items_Shop</strong>, and then open the Data Table. Here, you can add as many items as you want with whatever kinds of stat you would like using the <strong>Row Editor</strong> tab. To make an item, first click on the <strong>Add</strong> button in <strong>Row Editor</strong> to add a new row. Then, click on the textbox next to <strong>Rename</strong> and type in <strong>Potion</strong>. You will see that you have a potion item with all the other stats zeroed out:</p><div><img src="img/B04548_07_07.jpg" alt="Item data"/></div><p>Next, give it some <a id="id446" class="indexterm"/>values. I will make this a healing potion; therefore, I will give it an <strong>HP</strong> value of <strong>50</strong> and a <strong>Gold</strong> value of <strong>10</strong>.</p><div><img src="img/B04548_07_08.jpg" alt="Item data"/></div><p>The purpose of this Data Table is also to store every item that our shop owner will carry. So, feel free to add more items to this Data Table:</p><div><img src="img/B04548_07_09.jpg" alt="Item data"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>The shop screen framework</h1></div></div></div><p>Now <a id="id447" class="indexterm"/>that we are done with creating items, we can move on to creating the shop. In the previous chapter, we created dialog boxes for our shop owner, and in one of the dialog boxes, we created a <strong>Shop</strong> button that, when clicked, will open up a shop menu. Let's create this shop menu by first creating a new Widget Blueprint by navigating to <strong>Content</strong> | <strong>Blueprints</strong> | <strong>UI</strong> | <strong>NPC</strong>. We will call this Widget Blueprint <strong>Shop</strong> and open it:</p><div><img src="img/B04548_07_10.jpg" alt="The shop screen framework"/></div><p>We will make the <a id="id448" class="indexterm"/>shop in a similar format to that of our pause menu, but we will keep it simple because all we need for now is a Scroll Box that will hold the shop's items, as well as an area for gold, and an <strong>Exit</strong> button.</p><p>To expedite this process, you can simply copy and paste the elements from your existing menu systems that you wish to reuse into the <strong>Shop</strong> Widget Blueprint. We can do this by navigating to <strong>Content</strong> | <strong>Blueprints</strong> | <strong>UI</strong> and opening the <strong>Pause_Main</strong> and <strong>Pause_Inventory</strong> Widget Blueprints, which we created in the previous chapters. From <strong>Pause_Main</strong>, we can copy the <strong>Menu_Gold</strong>, <strong>Editable_Gold</strong>, <strong>Button_Exit</strong>, <strong>Menu_Exit</strong>, and <strong>BG_Color</strong>, and paste them into the <strong>Shop</strong> Widget Blueprint.</p><p>We can also copy the <strong>ScrollBox_Inventory</strong> and <strong>Title_Inventory</strong> from the <strong>Pause_Inventory</strong> Widget Blueprint and paste them into the <strong>Shop</strong> Widget Blueprint. When you are done, your <strong>Shop</strong> Widget Blueprint will look like this:</p><div><img src="img/B04548_07_11.jpg" alt="The shop screen framework"/></div><p>Here, edit the <strong>Shop</strong> Widget <a id="id449" class="indexterm"/>Blueprint so that the title reads as <strong>Shop</strong> instead of <strong>Inventory</strong>:</p><div><img src="img/B04548_07_12.jpg" alt="The shop screen framework"/></div><p>You will now need<a id="id450" class="indexterm"/> to link the <strong>Shop</strong> Widget Blueprint to the Shop button in the <strong>Shop_Welcome</strong> Widget Blueprint. To do this, open the <strong>Shop_Welcome</strong> Widget Blueprint by navigating to <strong>Content</strong> | <strong>Blueprints</strong> | <strong>UI</strong> | <strong>NPC</strong>, select <strong>Button_Shop</strong>, and then click on the <strong>+</strong> button to the right of the <strong>OnClicked</strong> event by navigating to <strong>Details</strong> | <strong>Events</strong>:</p><div><img src="img/B04548_07_13.jpg" alt="The shop screen framework"/></div><p>This will <a id="id451" class="indexterm"/>automatically open the graph with a newly created <strong>OnClicked</strong> event for <strong>Button_Shop</strong>:</p><div><img src="img/B04548_07_14.jpg" alt="The shop screen framework"/></div><p>Here, you can simply mimic the same actions you used to open the dialog boxes when the player clicks on the <strong>Talk</strong> button. The only difference is that, instead of creating a new <strong>Shop_Talk</strong> widget, the <strong>Shop</strong> widget will create the <strong>Create Shop Widget</strong> for you. The graph for <strong>Button_Shop</strong> will look like the following screenshot:</p><div><img src="img/B04548_07_15.jpg" alt="The shop screen framework"/></div><p>You will now <a id="id452" class="indexterm"/>be able to test the shop by talking to the NPC and clicking on the <strong>Shop</strong> button, which will now open the shop:</p><div><img src="img/B04548_07_16.jpg" alt="The shop screen framework"/></div><p>You will <a id="id453" class="indexterm"/>notice that nothing is yet visible in the shop, not even the gold. To display the gold on the screen, you need to repeat the steps you performed earlier in this chapter when you displayed the gold in the <strong>Pause_Main</strong> Widget Blueprint. But this time, open the graph in the <strong>Shop</strong> Widget Blueprint, and then create a binding for the <strong>Editable_Gold</strong> Text Block by navigating to <strong>Details</strong> | <strong>Context</strong>:</p><div><img src="img/B04548_07_17.jpg" alt="The shop screen framework"/></div><p>Your graph will <a id="id454" class="indexterm"/>automatically open, and you will notice a <strong>Get Editable Gold Text</strong> function with a <strong>ReturnNode</strong>. Since you will be getting the gold from the same game instance that you did when getting the gold from the <strong>Pause_Main</strong> Widget Blueprint, you can simply copy and paste all the nodes from the <strong>Get Editable Gold Text</strong> function into <strong>Pause_Main</strong>, and link them to the <strong>Get Editable Text</strong> function in the <strong>Shop</strong> Widget Blueprint. When you are done, the <strong>Get Editable Gold Text</strong> function in the <strong>Shop</strong> Widget Blueprint will look like this:</p><div><img src="img/B04548_07_18.jpg" alt="The shop screen framework"/></div><p>Next, we will create<a id="id455" class="indexterm"/> the <strong>Button_Exit</strong> functionality in the <strong>Shop</strong> Widget Blueprint by creating an <strong>OnClicked</strong> event (by navigating to <strong>Details</strong> | <strong>Events</strong>) for <strong>Button_Exit</strong>:</p><div><img src="img/B04548_07_19.jpg" alt="The shop screen framework"/></div><p>When the graph opens, link the <strong>OnClicked</strong> event to the <strong>Remove from Parent</strong> function:</p><div><img src="img/B04548_07_20.jpg" alt="The shop screen framework"/></div><p>At this point, when <a id="id456" class="indexterm"/>you test the shop, you will see the gold and be able to exit the shop screen.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>The item button framework</h1></div></div></div><p>Before we <a id="id457" class="indexterm"/>link our items to the shop, we will first need to create a framework in which the items are placed in the shop. What we would like to do is create a button for each item that the shop owner sells but, in order to make the interface scalable in such a way that NPCs can hold different selectable items, it would be wise to create a Scroll Box framework that holds a single button with a default value for the item's text/description. We can then dynamically draw the button for as many items as the shop owner carries, as well as dynamically draw the text on each button.</p><p>To do this, we must first create a Widget Blueprint by navigating to <strong>Content</strong> | <strong>Blueprints</strong> | <strong>UI</strong> and call it <strong>Item</strong>:</p><div><img src="img/B04548_07_21.jpg" alt="The item button framework"/></div><p>Open <strong>Item</strong>. Since we<a id="id458" class="indexterm"/> are going to make the items clickable, we will program a button. To make the button, all that we will need is the button itself and text for the button; we will not need a Canvas Panel because we will eventually be adding this button to the Scroll Box of our shop. So, from the <strong>Hierarchy</strong> tab, delete the Canvas Panel, and drag a button from <strong>Palette</strong>. We will name this button, <strong>Button_Item</strong>:</p><div><img src="img/B04548_07_24.jpg" alt="The item button framework"/></div><p>Finally, we will place a Text Block in the button that we just created and name it <strong>TextBlock_Item</strong>:</p><div><img src="img/B04548_07_25.jpg" alt="The item button framework"/></div><p>Once done, navigate<a id="id459" class="indexterm"/> to <strong>Details</strong> | <strong>Content</strong>, and create a binding for the text in the Text Block. This will automatically open the graph with a <strong>Get Text</strong> function:</p><div><img src="img/B04548_07_26.jpg" alt="The item button framework"/></div><p>Create a <a id="id460" class="indexterm"/>new <strong>Item</strong> variable of the <strong>Text</strong> type:</p><div><img src="img/B04548_07_27.jpg" alt="The item button framework"/></div><p>Drag the <strong>Item</strong> variable into<a id="id461" class="indexterm"/> the graph, select <strong>Get</strong> to drop in a getter for the <strong>Item</strong> variable, and then link it to the <strong>Return Value</strong> pin of <strong>ReturnNode</strong>:</p><div><img src="img/B04548_07_28.jpg" alt="The item button framework"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Linking the item data</h1></div></div></div><p>It is now time to<a id="id462" class="indexterm"/> link the item data that we created at the beginning of this chapter to the shop using the <strong>Item</strong> button framework we just created. To do this, we will add a functionality to display every item in our <strong>Items_Shop</strong> Data Table using the <strong>Item</strong> button framework that we created in the previous section. First, open <strong>Event Graph</strong> in the <strong>Shop</strong> Widget Blueprint. Link the <strong>Get Data Table Row Names</strong> function located in Data Tables to <strong>Event Construct</strong>:</p><div><img src="img/B04548_07_29.jpg" alt="Linking the item data"/></div><p>Then, from the <strong>Select Asset</strong> drop-down menu, select <strong>Items_Shop</strong>:</p><div><img src="img/B04548_07_30.jpg" alt="Linking the item data"/></div><p>This will get the names <a id="id463" class="indexterm"/>of every item in the <strong>Items_Shop</strong> Data table that we created earlier in this chapter. Here, we need to create an instance of the <strong>Item</strong> Widget Blueprint for every item row. This will create a button for every item with the correct corresponding item name. To do this, create a <strong>ForEachLoop</strong> located at <strong>Array</strong> under <strong>Utilities</strong> and allow the <strong>Get Data Table Row Names</strong> function to execute it. Link the <strong>Out Row Names</strong> pin to the <strong>Array</strong> pin of the <strong>ForEachLoop</strong> so that every row in the Data Table becomes an element of the array in the <strong>ForEachLoop</strong>:</p><div><img src="img/B04548_07_31.jpg" alt="Linking the item data"/></div><p>Next, we need to<a id="id464" class="indexterm"/> loop through each element of the array of row names and, for each row, we need to create a new instance of the <strong>Item</strong> Widget Blueprint. To do this, link the <strong>Create Item Widget</strong> action located under <strong>User Interface</strong> to the <strong>Loop Body</strong> pin in the <strong>ForEachLoop</strong>. Let the class instance be <strong>Item</strong> that can be selected from the <strong>Class</strong> drop-down menu in the <strong>Create Item Widget</strong> action:</p><div><img src="img/B04548_07_41.jpg" alt="Linking the item data"/></div><p>Then, for every item created, set the <strong>Item</strong> variable that is created for every <strong>Item</strong> widget instance to the value of each element in the array. You can create the <strong>Set Item</strong> action, by right-clicking anywhere in <strong>Event Graph</strong>, unchecking <strong>Context Sensitive</strong>, and locating <strong>Set Item</strong> by navigating to <strong>Class</strong> | <strong>Item</strong>:</p><div><img src="img/B04548_07_33.jpg" alt="Linking the item data"/></div><p>
<strong>Create Item Widget</strong> can <a id="id465" class="indexterm"/>now launch <strong>Set Item</strong>, and set the <strong>Return Value</strong> pin value of <strong>Create Item Widget</strong> to the <strong>Target</strong> pin value of <strong>Item</strong>:</p><div><img src="img/B04548_07_32.jpg" alt="Linking the item data"/></div><p>At this point, we have not yet set the element of the array to the item that we set in the <strong>Item</strong> widget; so, to do this, we can simply link the <strong>Array Element</strong> pin from the <strong>ForEachLoop</strong> to the <strong>Item</strong> pin in the <strong>Set Item</strong> action:</p><div><img src="img/B04548_07_36.jpg" alt="Linking the item data"/></div><p>Lastly, we are <a id="id466" class="indexterm"/>going to have our Scroll Box that we created in the <strong>Shop</strong> Widget Blueprint hold all of our item instances. To do this, after we set each item to the correct name, we will add the item instance as a child to the <strong>ScrollBox_Inventory</strong> Scroll Box that we created earlier in this chapter. This is done by simply calling the <strong>Add Child</strong> function located in <strong>Panel</strong> under <strong>Widget</strong> after we set the item:</p><div><img src="img/B04548_07_37.jpg" alt="Linking the item data"/></div><p>Then, we set the <strong>Content</strong> value of the child to the <strong>Return Value</strong> pin of the item:</p><div><img src="img/B04548_07_38.jpg" alt="Linking the item data"/></div><p>Lastly, the <strong>Target</strong> pin <a id="id467" class="indexterm"/>of the child needs to be linked to <strong>ScrollBox_Inventory</strong>, which can be dragged into your <strong>Event Graph</strong> from <strong>Variables</strong>. If you do not see the <strong>ScrollBox_Inventory</strong> variable in your variables, go back to the <strong>Designer View</strong>, select the <strong>ScrollBox_Inventory</strong>, and make sure <strong>is variable</strong> is checked:</p><div><img src="img/B04548_07_39.jpg" alt="Linking the item data"/></div><p>At this point, if you test your shop, you will see the shop populated with every item listed in your Data Table:</p><div><img src="img/B04548_07_40.jpg" alt="Linking the item data"/></div><p>You will be able to <a id="id468" class="indexterm"/>add even more items to your Data Table and these items will automatically appear in your shop.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we created a currency system for our game along with the ability for our enemies to drop gold. We also created a new set of data that contains items and their stats, and we have now populated the shop owner's store to display the items currently for sale in the shop.</p><p>In the next chapter, we will add the buying functionality to the shop along with the usage of an item and consumption.</p></div></body></html>