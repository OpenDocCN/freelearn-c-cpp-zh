<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Networking"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Networking</h1></div></div></div><p>In this chapter we are going to talk about linking objects and making them talk by creating communication networks. We are going to learn how we can make multiple Arduinos and computers communicate using network links and protocols.</p><p>After defining what a network is (specifically, a data network), we'll describe ways to use wired Ethernet links between Arduinos and computers. This will open the Arduino world to the Internet. Then, we'll discover how to create Bluetooth communications.</p><p>We will learn how to use Ethernet Wi-Fi in order to connect the Arduino to computers or other Arduinos without being tethered by network cables.</p><p>At last, we will study a couple of examples from the one in which we will fire message to the micro-blogging service Twitter, to the one in which we will parse and react to data received from the Internet.</p><p>We will also introduce the OSC exchange protocol, widely used in anything related to interaction design, music, and multimedia.</p><div class="section" title="An overview of networks"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec77"/>An overview of networks</h1></div></div></div><p>A <a id="id1271" class="indexterm"/>network is a system of elements linked together. There are many networks around us such as highway systems, electrical grids, and data networks. Data networks surround us. They relate to video services networks, phone and global telecommunication networks, computer networks, and so on. We are going to focus on these types of networks by talking about how we can share data over different types of media such as wires transporting electric pulses or electromagnetic waves facilitating wireless communication.</p><p>Before we dive into the details of network implementations for Arduino boards, we are going to describe a model named the OSI model. It is a very useful representation of what a data network is and what it involves.</p><div class="section" title="Overview of the OSI model"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec165"/>Overview of the OSI model</h2></div></div></div><p>The <span class="strong"><strong>Open</strong></span> <span class="strong"><strong>Systems</strong></span> <span class="strong"><strong>Interconnection</strong></span> model (<span class="strong"><strong>OSI</strong></span> model) has been<a id="id1272" class="indexterm"/> initiated in 1977 by the International Organization for Standardization in order to define prescriptions and requirements around the functions of communication systems in terms of abstract layers.</p><p>Basically, this is a layers-based model describing what features are necessary to design communicating systems. Here is the OSI model with seven layers:</p><div class="mediaobject"><img src="graphics/7584_11_001.jpg" alt="Overview of the OSI model"/><div class="caption"><p>OSI model describing communication system requirements with seven abstraction layers</p></div></div></div><div class="section" title="Protocols and communications"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec166"/>Protocols and communications</h2></div></div></div><p>A communications protocol is<a id="id1273" class="indexterm"/> a set of message formats and rules providing a way of communication between at least two participants. Within each layer, one or more entities implements its functionality and each entity interacts directly and only with the layer just beneath it and at the same time provides facilities for use by the layer above it. A protocol enables an entity in one host to interact with a corresponding entity at the same layer in another host. This can be represented by the following diagram:</p><div class="mediaobject"><img src="graphics/7584_11_002.jpg" alt="Protocols and communications"/><div class="caption"><p>Protocols helping hosts' layers to communicate together</p></div></div></div><div class="section" title="Data encapsulation and decapsulation"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec167"/>Data encapsulation and decapsulation</h2></div></div></div><p>If the application of one host needs to send data to another application of another host, the effective data, also named the payload, is passed down directly to the layer beneath it. In order to make the application able to retrieve its data, a header and footer are added to this data depending on the protocol used at each layer. This is called <a id="id1274" class="indexterm"/>
<span class="strong"><strong>encapsulation</strong></span> and it happens until the lowest layer, which is the physical one. At this point, a flow of bits is modulated on the medium for the receiver.</p><p>The receiver has to make the data progressively climb the layer stack, passing data from a layer to a higher layer and addressing it to the right entities in each layer using previously added headers and footers. These headers and footers are removed all along the path; this is called <a id="id1275" class="indexterm"/>
<span class="strong"><strong>decapsulation</strong></span>.</p><p>At the end of the journey, the application of the receiver receives its data and can process it. This whole process can be represented by the following diagram:</p><div class="mediaobject"><img src="graphics/7584_11_003.jpg" alt="Data encapsulation and decapsulation"/><div class="caption"><p>Encapsulation and decapsulation all along the layers' stack</p></div></div><p>We can also represent these processes as shown in the following figure. The small gray rectangle is the data payload for the layer N+1.</p><div class="mediaobject"><img src="graphics/7584_11_004.jpg" alt="Data encapsulation and decapsulation"/><div class="caption"><p>Adding and removing specific headers and footers according to the protocols used</p></div></div><p>At each level, two hosts interact using a protocol transmitted, which we call <span class="strong"><strong>Protocol Data Unit</strong></span> or <a id="id1276" class="indexterm"/>
<span class="strong"><strong>PDU</strong></span>. We also call <span class="strong"><strong>Service Data Unit</strong></span> or <a id="id1277" class="indexterm"/>
<span class="strong"><strong>SDU</strong></span>, a specific unit of data passed down from a layer to a lower layer and that has not yet been encapsulated.</p><p>Each layer considers the data received as data for it and adds/removes headers and footers according to the protocol used.</p><p>We are now going to illustrate each layer and protocol by examples.</p></div><div class="section" title="The roles of each layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec168"/>The roles of each layer</h2></div></div></div><p>We are going to describe<a id="id1278" class="indexterm"/> the purpose and roles of each layer here.</p><div class="section" title="Physical layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec131"/>Physical layer</h3></div></div></div><p>The <a id="id1279" class="indexterm"/>physical layer <a id="id1280" class="indexterm"/>defines electrical and physical specifications required for communication.</p><p>Pin layout, voltages and line impedance, signal timing, network adapters, or host bus adapters are defined in this layer. Basically, this <a id="id1281" class="indexterm"/>layer performs three major functions/services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initialization and termination of a connection to a communication medium</li><li class="listitem" style="list-style-type: disc">Participation in shared resources control processes</li><li class="listitem" style="list-style-type: disc">Conversion between the data communicated and the electrical signals which carry them</li></ul></div><p>We can quote <a id="id1282" class="indexterm"/>some known standards being in this physical layer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ADSL<a id="id1283" class="indexterm"/> and<a id="id1284" class="indexterm"/> ISDN (network and phony provider services)</li><li class="listitem" style="list-style-type: disc">Bluetooth<a id="id1285" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">IEEE 1394 (FireWire)<a id="id1286" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">USB</li><li class="listitem" style="list-style-type: disc">IrDA (data transfer <a id="id1287" class="indexterm"/>over infrared links)</li><li class="listitem" style="list-style-type: disc">SONET<a id="id1288" class="indexterm"/>, <a id="id1289" class="indexterm"/>SDH (wide area optic fiber networks operated by providers)</li></ul></div></div><div class="section" title="Data link layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec132"/>Data link layer</h3></div></div></div><p>This <a id="id1290" class="indexterm"/>layer<a id="id1291" class="indexterm"/> is made of two sublayers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Logical<a id="id1292" class="indexterm"/> Link Control (LLC)</li><li class="listitem" style="list-style-type: disc">Media Access <a id="id1293" class="indexterm"/>Control (MAC)</li></ul></div><p>Both are responsible for transferring data between network entities and to detect errors that may occur at the physical layer, and eventually to fix them. Basically, this layer provides these <a id="id1294" class="indexterm"/>functions/services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Framing</li><li class="listitem" style="list-style-type: disc">Physical addressing</li><li class="listitem" style="list-style-type: disc">Flow control</li><li class="listitem" style="list-style-type: disc">Error control</li><li class="listitem" style="list-style-type: disc">Access control</li><li class="listitem" style="list-style-type: disc">Media <a id="id1295" class="indexterm"/>access control</li></ul></div><p>We can quote some <a id="id1296" class="indexterm"/>known standards of this data link layer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ethernet<a id="id1297" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Wi-Fi<a id="id1298" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">PPP<a id="id1299" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">I2C<a id="id1300" class="indexterm"/></li></ul></div><p>We have to keep in mind that the second layer is also the domain of local area networks with only physical addresses. It can be federated using LAN switches.</p><p>By the way, we often need to segment networks and also communicate wider and so we need another addressing concept; this introduces the network layer.</p></div><div class="section" title="Network layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec133"/>Network layer</h3></div></div></div><p>This<a id="id1301" class="indexterm"/> layer<a id="id1302" class="indexterm"/> provides the way to transfer data sequences between hosts that can be in different networks. It provides the following<a id="id1303" class="indexterm"/> functions/services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Routing</li><li class="listitem" style="list-style-type: disc">Fragmentation and reassembly</li><li class="listitem" style="list-style-type: disc">Delivery error reports</li></ul></div><p>Routing provides a way to make hosts on a different network able to communicate by using a network addressing system.</p><p>Fragmentation and reassembly also occur at this level. These provide a way to chop data streams into pieces and to be able to reassemble parts after the transmission. We can quote some known <a id="id1304" class="indexterm"/>standards in this layer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ARP<a id="id1305" class="indexterm"/> (resolving and translating physical MAC address into network address)</li><li class="listitem" style="list-style-type: disc">BOOTP<a id="id1306" class="indexterm"/> (providing a way for the host to boot over the network)</li><li class="listitem" style="list-style-type: disc">BGP<a id="id1307" class="indexterm"/>, <a id="id1308" class="indexterm"/>OSPF, <a id="id1309" class="indexterm"/>RIP, and other routing protocols</li><li class="listitem" style="list-style-type: disc">IPv4 <a id="id1310" class="indexterm"/>and IPv6<a id="id1311" class="indexterm"/> (Internet Protocol)</li></ul></div><p>Routers<a id="id1312" class="indexterm"/> are<a id="id1313" class="indexterm"/> usually the gear where the routing occurs. They are connected to more than one network and make data going from one network to another. This is also the place where we can put some access lists in order to control access based on IP addresses.</p></div><div class="section" title="Transport layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec134"/>Transport layer</h3></div></div></div><p>This <a id="id1314" class="indexterm"/>layer is in <a id="id1315" class="indexterm"/>charge of the data transfer between end users, being at the crossroads of network layers and application layers. This layer provides the <a id="id1316" class="indexterm"/>following functions/services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flow control to assure reliability of the link used</li><li class="listitem" style="list-style-type: disc">Segmentation/desegmentation of data units</li><li class="listitem" style="list-style-type: disc">Error control</li></ul></div><p>Usually, we order protocols in two categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">State-oriented</li><li class="listitem" style="list-style-type: disc">Connection-oriented</li></ul></div><p>This means this layer can keep track of segments emitted and eventually retransmit them in case of previously failed transmission.</p><p>We can quote the two well-known <a id="id1317" class="indexterm"/>standards of the IP suite in this layer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">TCP</li><li class="listitem" style="list-style-type: disc">UDP</li></ul></div><p>TCP <a id="id1318" class="indexterm"/>is the connection-oriented one. It keeps the communication reliable by checking a lot of elements at each transmission or at each x segments transmitted.</p><p>UDP<a id="id1319" class="indexterm"/> is simpler and stateless. It doesn't provide a communication state control and thus is lighter. It is more suited for transaction-oriented query/response protocol such as DNS (Domain Name System) or<a id="id1320" class="indexterm"/> NTP (Network Time Protocol). If there is something wrong, such as a segment not transmitted well, the above layer has to take care of resending a request, for instance.</p></div><div class="section" title="Application/Host layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec135"/>Application/Host layers</h3></div></div></div><p>I grouped <a id="id1321" class="indexterm"/>the highest three layers under the terms application and host.</p><p>Indeed, they<a id="id1322" class="indexterm"/> aren't considered as network layers, but they are part of OSI model because they are often the final purpose of any network communication.</p><p>We find a lot of client/server applications there:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">FTP for basic and light file transfers</li><li class="listitem" style="list-style-type: disc">POP3, IMAP, and SMTP for mail services</li><li class="listitem" style="list-style-type: disc">SSH for secure remote shell communication</li><li class="listitem" style="list-style-type: disc">HTTP for web server browsing and downloading (and nowadays much more)</li></ul></div><p>We also find a lot of standards related to encryption and security such as TLS (Transport Layer Security). Our firmware, an executing Processing code, Max 6 running a patch are in this layer.</p><p>If we want to make them communicate through a wide variety of networks, we need some OSI stack. I mean, we need a transport and network protocol and a medium to transport our data.</p><p>If our modern computers own the whole network stack ready to use, we have to build this later in our Arduino's firmware if we want them to be able to communicate with the world. This is what we are going to do in the next subchapter.</p></div></div><div class="section" title="Some aspects of IP addresses and ports"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec169"/>Some aspects of IP addresses and ports</h2></div></div></div><p>One of the protocol stacks we tend to use each day is the TCP/IP one. TCP is the layer 4 transport protocol, and IP the layer 3 network.</p><p>This is the most used network protocol in the world both for end users and for companies.</p><p>We are going to explain a little bit more about the IP addressing system, subnet masks, and communication ports. I won't be describing a complete network course.</p><div class="section" title="The IP address"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec136"/>The IP address</h3></div></div></div><p>An IP address <a id="id1323" class="indexterm"/>is a numerical address referenced by any devices wanting to communicate over an IP network. IP is currently used in 2 versions: IPv4 and IPv6. We are considering IPv4 here because it is currently the only one used by end users. IPv4 addresses are coded over 32 bits. They are often written as a human-readable set of 4 bytes separated by a point. 192.168.1.222 is the current IP address of my computer. There are 2<sup>32</sup> possible unique addresses and all aren't routable over the Internet. Some are reserved for <a id="id1324" class="indexterm"/>private use. Some companies assign Internet-routable addresses. Indeed, we cannot use both addresses as this is handled by global organizations. Each country has sets of addresses attributed for their own purposes.</p></div><div class="section" title="The subnet"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec137"/>The subnet</h3></div></div></div><p>A <a id="id1325" class="indexterm"/>subnet is a way to segment our network into multiple smaller ones. A device network's configuration contains usually the address, the subnet mask, and a gateway.</p><p>The address and the subnet mask define the network range. It is necessary to know if a transmitter can communicate directly with a receiver. Indeed, if the latter is inside the same network, communication can occur directly; if it is on another network, the transmitter has to send its data to the gateway that will route data to the correct next node on the networks in order to reach, if possible, the receiver.</p><p>The gateway knows about the networks to which it is connected. It can route data across different networks and eventually filter some data according to some rules.</p><p>Usually, the subnet mask is written as a human-readable set of 4 bytes too. There is obviously a bit notation, more difficult for those not used to manipulating the numbers.</p><p>The subnet mask of my computer is 255.255.255.0. This information and my IP address defines that my home network begins at 192.168.1.0 (which is the base network address) and finish at 192.168.1.255 (which is the broadcast address). I cannot use these addresses for my device, but only those from 192.168.1.1 to 192.168.1.254.</p></div><div class="section" title="The communication port"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec138"/>The communication port</h3></div></div></div><p>A communication port <a id="id1326" class="indexterm"/>is something defined and related to layer 4, the transport layer.</p><p>Imagine you want to address a message to a host for a particular application. The receiver has to be in a listening mode for the message he wants to receive.</p><p>This means it has to open and reserve a specific socket for the connection, and that is a communication port. Usually, applications open specific ports for their own purpose, and once a port has been opened and reserved by an application, it cannot be used by another application while it is opened by the first one.</p><p>This provides a powerful system for data exchange. Indeed, if we want to send data to a host for more than one application, we can specifically address our messages to this host on a different port to reach different applications.</p><p>Of course, standards had to be defined for global communications.</p><p>TCP port 80 <a id="id1327" class="indexterm"/>is used for the HTTP protocol related to data exchange with web-servers.</p><p>UDP port 53 <a id="id1328" class="indexterm"/>is used for anything related to DNS.</p><p>If you are curious, you can read the following huge official text file containing all declared and reserved port and the related services: <a class="ulink" href="http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt">http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt</a>.</p><p>These are conventions. Someone can easily run a web server on a port other than 80. Then, the specific clients of this web server would have to know about the port used. This is why conventions and standards are useful.</p></div></div></div></div>
<div class="section" title="Wiring Arduino to wired Ethernet"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Wiring Arduino to wired Ethernet</h1></div></div></div><p>Ethernet <a id="id1329" class="indexterm"/>is the local area network most used nowadays.</p><p>Usual Arduino boards don't provide Ethernet ability. There is one board named Arduino Ethernet that provides native Ethernet and network features. By the way, it doesn't provide any USB-native features.</p><p>You can find the reference page here: <a class="ulink" href="http://arduino.cc/en/Main/ArduinoBoardEthernet">http://arduino.cc/en/Main/ArduinoBoardEthernet</a>.</p><div class="mediaobject"><img src="graphics/7584_11_005.jpg" alt="Wiring Arduino to wired Ethernet"/><div class="caption"><p>Arduino Ethernet board with the Ethernet connector</p></div></div><p>We are going to use the Arduino Ethernet Shield<a id="id1330" class="indexterm"/> and a 100BASE-T cable <a id="id1331" class="indexterm"/>with the <a id="id1332" class="indexterm"/>Arduino UNO R3. It keeps the USB features and adds Ethernet network connectivity and provides a nice way to link our computer to the Arduino with a much longer cable that USB ones.</p><div class="mediaobject"><img src="graphics/7584_11_006.jpg" alt="Wiring Arduino to wired Ethernet"/><div class="caption"><p>The Arduino Ethernet Shield</p></div></div><p>If you look for the Arduino Ethernet module, you must know they are sold either with or without the PoE module.</p><p>
<span class="strong"><strong>PoE</strong></span> <a id="id1333" class="indexterm"/>stands for <span class="strong"><strong>Power</strong></span> <span class="strong"><strong>over</strong></span> <span class="strong"><strong>Ethernet</strong></span> and is a way to supply power to devices through Ethernet connections. This requires two parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A module on the device that has to be supplied</li><li class="listitem" style="list-style-type: disc">A network equipment able to provide PoE support</li></ul></div><p>In our case here, we won't use PoE.</p><div class="section" title="Making Processing and Arduino communicate over Ethernet"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec170"/>Making Processing and Arduino communicate over Ethernet</h2></div></div></div><p>Let's design a basic system<a id="id1334" class="indexterm"/> showing how to set up a communication over Ethernet between the Arduino board and a processing applet.</p><p>Here, we are going to use an Arduino board wired to our computer using Ethernet. We push a button that triggers the Arduino to send a message over UDP to the Processing applet on the computer. The applet reacts by drawing something and sends back a message to the Arduino, which switches on its built-in LED.</p><div class="section" title="Basic wiring"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec139"/>Basic wiring</h3></div></div></div><p>Here, we are wiring a switch and using the built-in LED board. We have to connect our Arduino board to our computer using an Ethernet cable.</p><p>This wiring is very similar to the MonoSwitch project in <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a> except that we are wiring the Arduino Ethernet Shield here instead of the Arduino board itself.</p><div class="mediaobject"><img src="graphics/7584_11_007.jpg" alt="Basic wiring"/><div class="caption"><p>The switch and the pull-down resistor wired to the Arduino Ethernet Shield</p></div></div><p>The corresponding circuit diagram is as follows:</p><div class="mediaobject"><img src="graphics/7584_11_008.jpg" alt="Basic wiring"/><div class="caption"><p>The switch and the pull-down resistor wired to the Arduino Ethernet Shield</p></div></div></div><div class="section" title="Coding network connectivity implementation in Arduino"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec140"/>Coding network connectivity implementation in Arduino</h3></div></div></div><p>As we described, if <a id="id1335" class="indexterm"/>we want to give our <a id="id1336" class="indexterm"/>Arduino the ability to communicate over the Ethernet cable, and more generally over an Ethernet network, we have to implement the required standards in the firmware.</p><p>There is a library called <code class="literal">Ethernet</code> that can provide a great number of features.</p><p>As usual, we have to include this native library itself. You can choose to do that by navigating to <span class="strong"><strong>Sketch</strong></span> <span class="strong"><strong>|</strong></span> <span class="strong"><strong>Import</strong></span> <span class="strong"><strong>Library</strong></span>, which includes almost everything you need.</p><p>However, since Arduino version 0018, because of the implementation of SPI and because the Arduino Ethernet Shield communicates with the Arduino board through SPI, we have to include something more. Be careful about that.</p><p>For this code, you need:</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;         
#include &lt;Ethernet.h&gt;
#include &lt;EthernetUdp.h&gt;</pre></div><p>This is a example of the Arduino code, followed by an explanation.</p><p>You can <a id="id1337" class="indexterm"/>find the complete<a id="id1338" class="indexterm"/> Arduino code at <code class="literal">Chapter11/WiredEthernet</code>.</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;EthernetUdp.h&gt;

// Switch &amp; LED stuff
const int switchPin = 2;     // switch pin
const int ledPin =  13;      // built-in LED pin
int switchState = 0;         // storage variable for current switch state
int lastSwitchState = LOW;
long lastDebounceTime = 0;
long debounceDelay = 50;


// Network related stuff

// a MAC address, an IP address and a port for the Arduino
byte mac[] = { 
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ipArduino(192, 168, 1, 123);
unsigned int ArduinoPort = 9999;

// an IP address and a UDP port for the Computer
// modify these according to your configuration
IPAddress ipComputer(192, 168, 1, 222);
unsigned int ComputerPort = 10000;

// Send/receive buffer
char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; //buffer for incoming packets

// Instantiate EthernetUDP instance to send/receive packets over UDP
EthernetUDP Udp;


void setup() {
  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output
  pinMode(switchPin, INPUT); // the switch pin is setup as an input

  // start Ethernet and UDP:
  Ethernet.begin(mac,ipArduino);
  Udp.begin(ArduinoPort);
}

void loop(){

  // if a packet has been received read a packet into packetBufffer
  if (Udp.parsePacket()) Udp.read(packetBuffer,UDP_TX_PACKET_MAX_SIZE);
  if (packetBuffer == "Light") digitalWrite(ledPin, HIGH);
  else if (packetBuffer == "Dark") digitalWrite(ledPin, LOW);

  // read the state of the digital pin
  int readInput = digitalRead(switchPin);
  if (readInput != lastSwitchState)
  {
    lastDebounceTime = millis(); 
  }

  if ( (millis() - lastDebounceTime) &gt; debounceDelay )
  { 
    switchState = readInput; 
  }

  lastSwitchState = readInput;
  if (switchState == HIGH)
  {
    // If switch is pushed, a packet is sent to Processing
    Udp.beginPacket(ipComputer, ComputerPort);
    Udp.write('Pushed');
    Udp.endPacket();
  }
  else
  {
    // If switch is pushed, a packet is sent to Processing
    Udp.beginPacket(ipComputer, ComputerPort);
    Udp.write('Released');
    Udp.endPacket();
  }

  delay(10);
}</pre></div><p>In the previous block of code, at first we include the <code class="literal">Ethernet</code> library. Then we declare the complete set of variables related to switch debouncing and LED handling. After these statements, we define some variables related to network features.</p><p>At first, we have to set the MAC address related to our own shield. This unique identifier is usually indicated on a sticker on your Ethernet shield. Please don't forget to put yours in the code.</p><p>Then, <a id="id1339" class="indexterm"/>we set up the IP address <a id="id1340" class="indexterm"/>of the Arduino. We can use any address as long as it respects the IP address schema and as long as it is reachable by our computer. That means on the same network or on another network, but with a router between both. However, be careful, as the IP address you chose has to be unique on a local network segment.</p><p>We also choose a UDP port for our communication. We are using the same definition with network parameters related to our computer, the second set of participants in the communication.</p><p>We declare a buffer to store the current received messages at each time. Notice the constant <code class="literal">UDP_TX_PACKET_MAX_SIZE</code>. It is defined in the Ethernet library. Basically, it is defined as 24 bytes in order to save memory. We could change that. Then, we instantiate the <code class="literal">EthernetUDP</code> object in order to receive and send datagram over UDP. The <code class="literal">setup()</code> function block contains statements for switch and LED, then for Ethernet itself.</p><p>We begin the Ethernet communication using the MAC and IP addresses. Then we open and listen at the UDP port defined in the definition, which is 9999 in our case. The <code class="literal">loop()</code> function seems a bit thick, but we can divide it in 2 parts.</p><p>In the first part, we check if the Arduino has received a packet. If it has, it is checked by calling the <code class="literal">parsePacket()</code> function <a id="id1341" class="indexterm"/>of the Ethernet library and checking if that one returns a packet size different than zero. We read the data and store it into the<a id="id1342" class="indexterm"/> <code class="literal">packetBuffer</code> variable.</p><p>Then we check if this variable equals <code class="literal">Light</code> or <code class="literal">Dark</code> and act accordingly by switching on or off the LED on the Arduino board.</p><p>In the second part, we can see the same debouncing structure as we have seen in <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>. At the end of this part, we check if the switch is pushed or released and depending on the state send a UDP message to the computer.</p><p>Let's check the Processing/Computer part now.</p></div><div class="section" title="Coding a Processing Applet communicating on Ethernet"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec141"/>Coding a Processing Applet communicating on Ethernet</h3></div></div></div><p>Let's check <a id="id1343" class="indexterm"/>the <a id="id1344" class="indexterm"/>code at <code class="literal">Chapter11/WiredEthernetProcessing</code>.</p><p>We need the library hypermedia. We can find it at <a class="ulink" href="http://ubaa.net/shared/processing/udp">http://ubaa.net/shared/processing/udp</a>.</p><div class="informalexample"><pre class="programlisting">import hypermedia.net.*;

UDP udp;  // define the UDP object
String currentMessage;

String ip       = "192.168.1.123"; // the Arduino IP address
int port        = 9999;        // the Arduino UDP port

void setup() {
  size(700, 700);
  noStroke();
  fill(0);

  udp = new UDP( this, 10000 );  // create UDP socket
  udp.listen( true );           // wait for incoming message
}

void draw()
{
  ellipse(width/2, height/2, 230, 230);
}

void receive( byte[] data ) {

  // if the message could be "Pushed" or "Released"
  if ( data.length == 6 || data.length == 8 ) 
  {
    for (int i=0; i &lt; data.length; i++) 
    { 
      currentMessage += data[i];
    }

    // if the message is really Pushed
    // then answer back by sending "Light"
    if (currentMessage == "Pushed")
    {
      udp.send("Light", ip, port );
      fill(255);
    }
    else if (currentMessage == "Released")
    {
      udp.send("Dark", ip, port );
      fill(0);
    }
  }
}</pre></div><p>We import the <a id="id1345" class="indexterm"/>library first. Then we define <a id="id1346" class="indexterm"/>the UDP object and a String variable for the current received message.</p><p>Here too, we have to define the IP address of the remote participant, the Arduino. We also define the port opened and available for the communication on the Arduino side, here it is 9999.</p><p>Of course, this has to match the one defined in the Arduino firmware. In the <code class="literal">setup()</code> function, we define some drawing parameters and then instantiate the UDP socket on the UDP port 10000 and we set it to listening mode, waiting for incoming messages.</p><p>In the<a id="id1347" class="indexterm"/> <code class="literal">draw()</code> function, we draw a circle. The <code class="literal">receive()</code> function <a id="id1348" class="indexterm"/>is a callback used by the code when packets are incoming. We test the length of packets in bytes because we want to react to only two different messages here (<code class="literal">Pushed</code> or <code class="literal">Released</code>), so we check if the length is 6 or 8 bytes. All other packets won't be processed. We could implement a better checking mechanism, but this one works fine.</p><p>As soon as one of these lengths match, we concatenate each byte into the String variable <code class="literal">currentMessage</code>. This provides an easy way to compare the content to any other string.</p><p>Then, we compare it to <code class="literal">Pushed</code> and <code class="literal">Released</code> and act accordingly by sending back the message <code class="literal">Light</code> to the Arduino and filling our drawn circle with white color, or by sending back the message <code class="literal">Dark</code> to the Arduino and filling our drawn circle with black color.</p><p>We just designed our first basic communication protocol using Ethernet and UDP.</p></div></div><div class="section" title="Some words about TCP"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec171"/>Some words about TCP</h2></div></div></div><p>In my own design, I often use UDP <a id="id1349" class="indexterm"/>for communication between systems. It is much lighter than <a id="id1350" class="indexterm"/>TCP and is quite sufficient for our purposes.</p><p>In some cases, you would need to have the flow control provided by TCP. The Ethernet library we just used provides TCP features too. You can find the reference page at <a class="ulink" href="http://arduino.cc/en/Reference/Ethernet">http://arduino.cc/en/Reference/Ethernet</a>.</p><p>
<code class="literal">Server</code> and <code class="literal">Client</code> classes can be used for this purpose especially, implementing function testing if a connection has been opened, if it is still valid, and so on.</p><p>We will learn how to connect our Arduino to some live server on the Internet at the end of this chapter.</p></div></div>
<div class="section" title="Bluetooth communications"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Bluetooth communications</h1></div></div></div><p>Bluetooth<a id="id1351" class="indexterm"/> is a wireless technology standard. It provides a way to exchange data over short distances using short-wavelength radio transmissions in the band 2,400 to 2,480 MHz.</p><p>It allows to create PANs (Personal Area Networks) <a id="id1352" class="indexterm"/>with the "correct" level of security. It is implemented on various types of devices such as computers, smartphones, sound systems that can read digital audio from a remote source, and so on.</p><p>Arduino BT board natively implements this technology. It is now supplied with ATmega328 <a id="id1353" class="indexterm"/>and a Bluegiga WT11 <a id="id1354" class="indexterm"/>Bluetooth module. The reference page is <code class="literal">http://www.arduino.cc/en/Main/ArduinoBoardBluetooth</code>.</p><p>In my opinion, the best way to proceed in many projects is to keep a general purpose board at the core of our designs and to add new features by adding only what we need as external modules. Following this, we are going to use the Arduino UNO R3 here with an external Bluetooth module.</p><p>We are going to make a small project using Processing again. You click somewhere over the Processing canvas and the Processing applet sends a message over Bluetooth to the Arduino, which reacts by switching its built-in LED on or off.</p><div class="section" title="Wiring the Bluetooth module"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec172"/>Wiring the Bluetooth module</h2></div></div></div><p>Check the<a id="id1355" class="indexterm"/> following figures:</p><div class="mediaobject"><img src="graphics/7584_11_009.jpg" alt="Wiring the Bluetooth module"/><div class="caption"><p>RN41 Bluetooth module wired to the Arduino via a serial link</p></div></div><p>The <a id="id1356" class="indexterm"/>corresponding circuit diagram is as follows:</p><div class="mediaobject"><img src="graphics/7584_11_010.jpg" alt="Wiring the Bluetooth module"/><div class="caption"><p>Roving Networks RN41 module wired to the Arduino board</p></div></div><p>There is a <a id="id1357" class="indexterm"/>Roving Networks RN41<a id="id1358" class="indexterm"/> Bluetooth module wired to the Arduino board.</p><p>You can find it at<code class="literal"> </code>
<a class="ulink" href="https://www.sparkfun.com/products/10559">https://www.sparkfun.com/products/10559</a>.</p><p>Here we are using the basic serial link communication between the Arduino itself and the Bluetooth module.</p><p>We suppose our computer has Bluetooth capabilities and that those are activated.</p></div><div class="section" title="Coding the firmware and the Processing applet"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec173"/>Coding the firmware and the Processing applet</h2></div></div></div><p>The<a id="id1359" class="indexterm"/> firmware<a id="id1360" class="indexterm"/> is as follows. You can find it in at <code class="literal">Chapter11/Bluetooth</code>.</p><div class="informalexample"><pre class="programlisting">// LED stuff
const int ledPin =  13;      // pin of the board built-in LED

void setup() {
  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output

  Serial.begin(9600);       // start serial communication at 9600bps
}

void loop()
{
  if (Serial.available() &gt; 0) {

    incomingByte = Serial.read();

    if (incomingByte == 1) digitalWrite(ledPin, HIGH);
    else if (incomingByte == 0) digitalWrite(ledPin, LOW);
  }
}</pre></div><p>We <a id="id1361" class="indexterm"/>basically instantiate the <code class="literal">Serial</code> communication with the <a id="id1362" class="indexterm"/>Bluetooth module, then we check if any bytes are available from it and parse them. If a message is available and equals 1, we switch on the LED; if it equals 0, we switch off the LED.</p><p>The processing code is as follows:</p><div class="informalexample"><pre class="programlisting">import processing.serial.*;
Serial port;

int bgcolor, fgcolor;

void setup() {
  size(700, 700);
  background(0);
  stroke(255);
  bgcolor = 0;
  fgcolor = 255;
  
  println(Serial.list()); 
  port = new Serial(this, Serial.list()[2], 9600);
 
}
void draw() {
  background(bgcolor);
  stroke(fgcolor);
  fill(fgcolor);
  rect(100, 100, 500, 500);
}

void mousePressed() {
  if (mouseX &gt; 100 &amp;&amp; mouseX &lt; 600 &amp;&amp; mouseY &gt; 100 &amp;&amp; mouseY &lt; 600)
  {
      bgcolor = 255;
      fgcolor = 0;
      port.write('1');
  }
}

void mouseReleased() {
 
      bgcolor = 0;
      fgcolor = 255;
      port.write('0');
}</pre></div><p>We first <a id="id1363" class="indexterm"/>include the serial library. In the <code class="literal">setup()</code> function, we define some<a id="id1364" class="indexterm"/> drawing bits, then we print the list of serial device to the Processing log area. This displays a list and we have to find the right Bluetooth module of our computer. In my case, this was the third one and I used this to instantiate the <code class="literal">Serial</code> communication in the latest statement of the <code class="literal">setup()</code> function:</p><div class="informalexample"><pre class="programlisting">port = new Serial(this, Serial.list()[2], 9600);</pre></div><p>The <code class="literal">draw()</code> function only sets up:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Background color according to the variable <code class="literal">bgcolor</code></li><li class="listitem" style="list-style-type: disc">Stroke color according to the variable <code class="literal">fgcolor</code></li><li class="listitem" style="list-style-type: disc">Fill color according to the variable <code class="literal">fgcolor</code></li></ul></div><p>Then we draw a square.</p><p>The <code class="literal">mousePressed()</code> <a id="id1365" class="indexterm"/>and <code class="literal">mouseReleased()</code> functions are <a id="id1366" class="indexterm"/>two Processing callbacks respectively which are called when a mouse event occurs, when you push a button on the mouse and release it.</p><p>As soon as the mouse is pressed, we check where the cursor was when it was pressed. In my case, I defined the area inside the square.</p><p>If we press the button in the square, a visual feedback occurs in order to tell us the order has been received, but the most important thing is the <code class="literal">digitalWrite('1')</code> function of course.</p><p>We write the value 1 to the Bluetooth module.</p><p>In the same way, as soon as we release the mouse button, a "0" is written to the Bluetooth module of the computer. Of course, these messages are sent to the Arduino and the latter switches the LED on or off.</p><p>We just checked a <a id="id1367" class="indexterm"/>nice example of an external module providing wireless Bluetooth communication feature to the Arduino.</p><p>As we noticed, we don't <a id="id1368" class="indexterm"/>have to use a particular library for this purpose because the module itself is able to connect and send/receive data by itself only if we send serial data to it. Indeed, the communication between Arduino and the module is a basic serial one.</p><p>Let's improve our data communication over the air using Ethernet Wi-Fi.</p></div></div>
<div class="section" title="Playing with Wi-Fi"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec80"/>Playing with Wi-Fi</h1></div></div></div><p>We previously learned how to use the Ethernet library. Then, we tested Bluetooth for short-range network communications. Now, let's test Wi-Fi for medium range communications still without any wire.</p><div class="section" title="What is Wi-Fi?"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec174"/>What is Wi-Fi?</h2></div></div></div><p>Wi-Fi is<a id="id1369" class="indexterm"/> a set of communication protocols wireless driven by standards of IEEE 802.11. These standards describe characteristics of <a id="id1370" class="indexterm"/>Wireless Local Area Networks (WLANs).</p><p>Basically, multiple hosts having Wi-Fi modules can communicate using their IP stacks without wire. There are multiple networking modes used by Wi-Fi.</p><div class="section" title="Infrastructure mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec142"/>Infrastructure mode</h3></div></div></div><p>In that mode, Wi-Fi <a id="id1371" class="indexterm"/>hosts can communicate between each other via an<a id="id1372" class="indexterm"/> access point.</p><p>This access point and hosts have to be set up with the same <a id="id1373" class="indexterm"/>
<span class="strong"><strong>Service</strong></span> <span class="strong"><strong>Set</strong></span> <span class="strong"><strong>Identifier</strong></span> (SSID), which is a network name used as a reference.</p><p>This mode is interesting because it provides security by the fact that each host has to pass by the access point in order to access the global network. We can configure some access lists in order to control which host can connect and which cannot.</p><div class="mediaobject"><img src="graphics/7584_11_011.jpg" alt="Infrastructure mode"/><div class="caption"><p>Hosts exchanging data through an access point in infrastructure mode</p></div></div></div><div class="section" title="Ad hoc mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec143"/>Ad hoc mode</h3></div></div></div><p>In this <a id="id1374" class="indexterm"/>mode, each <a id="id1375" class="indexterm"/>host can connect to each one directly without access points. It is very useful to quickly connect two hosts in order to share documents and exchange data.</p><div class="mediaobject"><img src="graphics/7584_11_012.jpg" alt="Ad hoc mode"/><div class="caption"><p>Two hosts directly connected in ad hoc mode</p></div></div></div><div class="section" title="Other modes"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec144"/>Other modes</h3></div></div></div><p>There are also two <a id="id1376" class="indexterm"/>other modes. <span class="strong"><strong>Bridge</strong></span> <span class="strong"><strong>mode</strong></span>
<a id="id1377" class="indexterm"/> is a way to link multiple access points. We can imagine a work group sparse in two buildings; we could use two different access points and connect them together using a bridge mode.</p><p>There is also a<a id="id1378" class="indexterm"/> trivial mode named <a id="id1379" class="indexterm"/>
<span class="strong"><strong>range-extender mode</strong></span>. It is used to repeat the signal and provide a connection between two hosts, two access points or a host, and an access point when those are too far.</p></div></div><div class="section" title="The Arduino Wi-Fi shield"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec175"/>The Arduino Wi-Fi shield</h2></div></div></div><p>This<a id="id1380" class="indexterm"/> shield adds the wireless networking capabilities to the Arduino board. The official shield also contains an SD card slot providing storing features too. It provides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connection <a id="id1381" class="indexterm"/>via 802.11b/g networks</li><li class="listitem" style="list-style-type: disc">Encryption using WEP or WPA2 personal</li><li class="listitem" style="list-style-type: disc">FTDI connection for serial debugging of the shield itself</li><li class="listitem" style="list-style-type: disc">Mini-USB to update the Wi-Fi shield firmware itself</li></ul></div><div class="mediaobject"><img src="graphics/7584_11_013.jpg" alt="The Arduino Wi-Fi shield"/><div class="caption"><p>The Arduino Wi-Fi Shield</p></div></div><p>It is based on the HDG104 Wireless LAN 802.11b/g system in-package. A proper Atmega 32 UC3 provides the network IP stack.</p><p>A dedicated <a id="id1382" class="indexterm"/>native library named <span class="strong"><strong>WiFi library</strong></span>
<a id="id1383" class="indexterm"/> provides all that we need to connect our board wireless to any network. The reference is provided at <a class="ulink" href="http://arduino.cc/en/Reference/WiFi">http://arduino.cc/en/Reference/WiFi</a>.</p><p>This shield is available from many distributors as well as from the Arduino store:<a class="ulink" href="http://store.arduino.cc/ww/index.php?main_page=product_info&amp;cPath=11_5&amp;products_id=237"> http://store.arduino.cc/ww/index.php?main_page=product_info&amp;cPath=11_5&amp;products_id=237</a>.</p><p>Let's try to connect our Arduino to our Wi-Fi network.</p></div><div class="section" title="Basic Wi-Fi connection without encryption"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec176"/>Basic Wi-Fi connection without encryption</h2></div></div></div><p>Here, we don't have<a id="id1384" class="indexterm"/> to draw any schematic. Basically, we connect the shield to the Arduino and upload our code to it. We are going to test a basic connection without encrypting anything, at first.</p><p>The Accept Point has to provide a DHCP server; the latter will deliver an IP address to our Arduino-based system.</p><p>Let's check the example <code class="literal">ConnectNoEncryption</code> provided with the <code class="literal">WiFi</code> library.</p><div class="informalexample"><pre class="programlisting">#include &lt;WiFi.h&gt;

char ssid[] = "yourNetwork";     // the name of your network
int status = WL_IDLE_STATUS;     // the Wifi radio's status

void setup() {
  //Initialize serial and wait for port to open:
  Serial.begin(9600); 

  // check for the presence of the shield:
  if (WiFi.status() == WL_NO_SHIELD) {
    Serial.println("WiFi shield not present"); 
    // don't continue:
    while(true)
delay(30) ;
  } 

  // attempt to connect to Wifi network:
  while ( status != WL_CONNECTED) { 
    Serial.print("Attempting to connect to open SSID: ");
    Serial.println(ssid);
    status = WiFi.begin(ssid);

    // wait 10 seconds for connection:
    delay(10000);
  }

  // you're connected now, so print out the data:
  Serial.print("You're connected to the network");
  printCurrentNet();
  printWifiData();
}

void loop() {
  // check the network connection once every 10 seconds:
  delay(10000);
  printCurrentNet();
}

void printWifiData() {
  // print your WiFi shield's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);
  Serial.println(ip);

  // print your MAC address:
  byte mac[6];  
  WiFi.macAddress(mac);
  Serial.print("MAC address: ");
  Serial.print(mac[5],HEX);
  Serial.print(":");
  Serial.print(mac[4],HEX);
  Serial.print(":");
  Serial.print(mac[3],HEX);
  Serial.print(":");
  Serial.print(mac[2],HEX);
  Serial.print(":");
  Serial.print(mac[1],HEX);
  Serial.print(":");
  Serial.println(mac[0],HEX);

  // print your subnet mask:
  IPAddress subnet = WiFi.subnetMask();
  Serial.print("NetMask: ");
  Serial.println(subnet);

  // print your gateway address:
  IPAddress gateway = WiFi.gatewayIP();
  Serial.print("Gateway: ");
  Serial.println(gateway);
}

void printCurrentNet() {
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  // print the MAC address of the router you're attached to:
  byte bssid[6];
  WiFi.BSSID(bssid);    
  Serial.print("BSSID: ");
  Serial.print(bssid[5],HEX);
  Serial.print(":");
  Serial.print(bssid[4],HEX);
  Serial.print(":");
  Serial.print(bssid[3],HEX);
  Serial.print(":");
  Serial.print(bssid[2],HEX);
  Serial.print(":");
  Serial.print(bssid[1],HEX);
  Serial.print(":");
  Serial.println(bssid[0],HEX);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print("signal strength (RSSI):");
  Serial.println(rssi);

  // print the encryption type:
  byte encryption = WiFi.encryptionType();
  Serial.print("Encryption Type:");
  Serial.println(encryption,HEX);
}</pre></div><p>At first, we <a id="id1385" class="indexterm"/>include the <code class="literal">WiFi</code> library. Then, we set the name of our network, the SSID. Please be careful to change it to your own SSID.</p><p>In the <code class="literal">setup()</code> function, we instantiate the <code class="literal">Serial</code> connection. Then, we check the presence of the shield by calling the function <code class="literal">WiFi.status()</code>.</p><p>If the latter returns the value <code class="literal">WL_NO_SHIELD</code> (which is a constant defined inside the WiFi library), that means there is no shield. In that case, an infinite loop is executed with a <code class="literal">while(true)</code> statement without the <code class="literal">break</code> keyword inside.</p><p>If it returns a value different than <code class="literal">WL_CONNECTED</code>, then we print a statement in order to inform that it is trying to connect. Then, <code class="literal">WiFi.begin()</code> tries to connect. This is a usual structure providing a way to try to connect while it isn't connected, constantly, and each 10 s considering the <code class="literal">delay()</code> function is called.</p><p>Then, if the connection occurs, the status becomes <code class="literal">WL_CONNECTED</code>, we exit from the <code class="literal">while</code> loop and continue.</p><p>There is something printed to serial too, saying the board has achieved connection status.</p><p>We also call two functions. These functions print to serial many elements related to network parameters and status. I'll let you discover each of them using the <a class="ulink" href="http://arduino.cc/en/Reference/WiFi">http://arduino.cc/en/Reference/WiFi</a> reference quoted earlier.</p><p>After this connection, we can begin to exchange data. As you probably know, using Wi-Fi especially without security can lead to problems. Indeed, it is very easy to capture packets from an unprotected Wi-Fi network.</p><p>Let's use the <code class="literal">WiFi</code> library with more security.</p></div><div class="section" title="Arduino Wi-Fi connection using WEP or WPA2"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec177"/>Arduino Wi-Fi connection using WEP or WPA2</h2></div></div></div><p>If you open both code <code class="literal">ConnectWithWEP</code> and <code class="literal">ConnectWithWPA</code>, there are minor differences with the preceding example.</p><div class="section" title="Using WEP with Wi-Fi library"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec145"/>Using WEP with Wi-Fi library</h3></div></div></div><p>If we use a <a id="id1386" class="indexterm"/>40-bit WEP, we need a key containing <a id="id1387" class="indexterm"/>10 characters that must be hexadecimal. If we use 128-bit WEP, we need a key containing 26 characters, also hexadecimal. This key must be specified within the code.</p><p>We replaced the<a id="id1388" class="indexterm"/> call to <code class="literal">WiFi.begin()</code>, which had only one argument, by two new arguments related to WEP encryption. This is the only difference.</p><p>For many reasons that we won't discuss here, WEP is considered too weak in terms of security, so most people and organizations have moved to the more secure WPA2 alternative.</p></div><div class="section" title="Using WPA2 with Wi-Fi library"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec146"/>Using WPA2 with Wi-Fi library</h3></div></div></div><p>Following<a id="id1389" class="indexterm"/> the same schema, we need only a <a id="id1390" class="indexterm"/>password here. Then, we call <code class="literal">WiFi.begin()</code> with 2 arguments: the SSID and the password.</p><p>In both cases we just checked, we only had to pass some additional arguments with <code class="literal">WiFi.begin()</code> in order to secure things a bit more.</p></div></div><div class="section" title="Arduino has a (light) web server"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec178"/>Arduino has a (light) web server</h2></div></div></div><p>Here, we use<a id="id1391" class="indexterm"/> the<a id="id1392" class="indexterm"/> code <code class="literal">WifiWebServer</code> provided with the library.</p><p>In this example, Arduino acts as a web server after having been connected to a WEP or WPA Wi-Fi network.</p><div class="informalexample"><pre class="programlisting">#include &lt;WiFi.h&gt;

char ssid[] = "yourNetwork";      //  your network SSID (name) 
char pass[] = "secretPassword";   // your network password
int keyIndex = 0;                 // your network key Index number (needed only for WEP)

int status = WL_IDLE_STATUS;

WiFiServer server(80);

void setup() {
  //Initialize serial and wait for port to open:
  Serial.begin(9600); 
  while (!Serial) {
    ; // wait for serial port to connect. Needed for Leonardo only
  }
  
  // check for the presence of the shield:
  if (WiFi.status() == WL_NO_SHIELD) {
    Serial.println("WiFi shield not present"); 
    // don't continue:
    while(true);
  } 
  
  // attempt to connect to Wifi network:
  while ( status != WL_CONNECTED) { 
    Serial.print("Attempting to connect to SSID: ");
    Serial.println(ssid);
    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:    
    status = WiFi.begin(ssid, pass);

    // wait 10 seconds for connection:
    delay(10000);
  } 
  server.begin();
  // you're connected now, so print out the status:
  printWifiStatus();
}


void loop() {
  // listen for incoming clients
  WiFiClient client = server.available();
  if (client) {
    Serial.println("new client");
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the http request has ended,
        // so you can send a reply
        if (c == '\n' &amp;&amp; currentLineIsBlank) {
          // send a standard http response header
          client.println("HTTP/1.1 200 OK");
          client.println("Content-Type: text/html");
          client.println("Connnection: close");
          client.println();
          client.println("&lt;!DOCTYPE HTML&gt;");
          client.println("&lt;html&gt;");
          // add a meta refresh tag, so the browser pulls again every 5 seconds:
          client.println("&lt;meta http-equiv=\"refresh\" content=\"5\"&gt;");
          // output the value of each analog input pin
          for (int analogChannel = 0; analogChannel &lt; 6; analogChannel++) {
            int sensorReading = analogRead(analogChannel);
            client.print("analog input ");
            client.print(analogChannel);
            client.print(" is ");
            client.print(sensorReading);
            client.println("&lt;br /&gt;");       
          }
          client.println("&lt;/html&gt;");
           break;
        }
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } 
        else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
      // close the connection:
      client.stop();
      Serial.println("client disonnected");
  }
}


void printWifiStatus() {
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  // print your WiFi shield's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print("signal strength (RSSI):");
  Serial.print(rssi);
  Serial.println(" dBm");
}</pre></div><p>Let's<a id="id1393" class="indexterm"/> explain <a id="id1394" class="indexterm"/>the underlying concepts in these statements.</p><p>We explain only the new part of the code, not the autoconnect and encryption statements, because we did that earlier.</p><p>The <code class="literal">WiFiServer server(80)</code> statement instantiates a server on a specific port. Here, the TCP port chosen is 80, the standard HTTP server TCP port.</p><p>In the <code class="literal">setup()</code> function, we auto-connect the Arduino to the Wi-Fi network, then we start the server. Basically, it opens a socket on TCP port 80 and begins to listen on this port.</p><p>In the <code class="literal">loop()</code> function, we check if there is an incoming client to our web server embedded on the Arduino. This is done with <code class="literal">WiFiClient client = server.available();</code>
</p><p>Then, we have a condition on client instance. If there is no client, we basically do nothing, and execute the loop again until we have a client.</p><p>As soon as we have one, we print this to serial in order to give feedback. Then, we check if the client is effectively connected and if there is data in the reading buffer. We then print this data if it is available and answer the client by sending the standard HTTP response header. This is done basically by printing bytes to the client instance itself.</p><p>The code includes some dynamic features and sends some values read on the board itself like the value coming from the ADC of each analog input.</p><p>We could try to connect some sensors and provide values of each of them through a webpage directly handled by the Arduino itself. I'll let you check the other part of the code. This deals with standard HTTP messages.</p></div></div>
<div class="section" title="Tweeting by pushing a switch"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Tweeting by pushing a switch</h1></div></div></div><p>Connecting the Arduino to networks obviously brings the Internet to mind. We could try to create a small system that can send messages over the Internet. I choose to use the micro-blogging service Twitter because it provides a nice communication API.</p><p>We are going to use the same circuit that we used in the <span class="emphasis"><em>Wiring Arduino to wired Ethernet</em></span> section except that here we are using the Arduino MEGA related to some memory constraints with a smaller board.</p><div class="section" title="An overview of APIs"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec179"/>An overview of APIs</h2></div></div></div><p>
<span class="strong"><strong>API</strong></span> <a id="id1395" class="indexterm"/>stands for <span class="strong"><strong>Application</strong></span> <span class="strong"><strong>Programming</strong></span> <span class="strong"><strong>Interface</strong></span>. Basically, it defines ways to exchange data with the considered system. We can define APIs in our systems in order to make them communicate with others.</p><p>For instance, we could define an API in our Arduino firmware that would explain how and what to send in order to make the LED on the board switch on and off. We won't describe the whole firmware, but we would provide to the world a basic document explaining precisely the format and data to send from the Internet, for instance, to use it remotely. That would be an API.</p></div><div class="section" title="Twitters API"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec180"/>Twitters API</h2></div></div></div><p>Twitter,<a id="id1396" class="indexterm"/> as do many other social network-related systems on the Internet, provides an API. Other programmers can use it to get data and send data too. All data specifications related to Twitters API are available at <a class="ulink" href="https://dev.twitter.com">https://dev.twitter.com</a>.</p><p>In order to use the <a id="id1397" class="indexterm"/>API, we have to create an application on Twitters developer website. There are some special security parameters to set up, and we have to agree upon some rules of use that respect data requests rate and other technical specifications.</p><p>We can create an application by going to <a class="ulink" href="https://dev.twitter.com/apps/new">https://dev.twitter.com/apps/new</a>.</p><p>That will provide us with some credential information, in particular an access token and a token secret. These are strings of characters that have to be used following some protocols to be able to access the API.</p></div><div class="section" title="Using the Twitter library with OAuth support"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec181"/>Using the Twitter library with OAuth support</h2></div></div></div><p>
<span class="emphasis"><em>Markku Rossi</em></span> created <a id="id1398" class="indexterm"/>a very powerful and reliable library embedding the <a id="id1399" class="indexterm"/>OAuth support and intended for sending tweets directly from the Arduino. The official library website is <a class="ulink" href="http://www.markkurossi.com/ArduinoTwitter">http://www.markkurossi.com/ArduinoTwitter</a>.</p><p>This library needs to be used with a board with more than the usual amount of memory. The Arduino MEGA runs it perfectly.</p><p>OAuth is an open protocol to allow secure authorization in a simple and standard method from web, mobile, and desktop applications. This is defined at <a class="ulink" href="http://oauth.net">http://oauth.net</a>.</p><p>Basically, this is a <a id="id1400" class="indexterm"/>way to enable third-party application to obtain<a id="id1401" class="indexterm"/> limited access to an HTTP service. By sending some specific string of characters, we can grant access to a host and make it communicate with the API.</p><p>This is what we are going to do together as a nice example that you could reuse for other APIs on the Web.</p><div class="section" title="Grabbing credentials from Twitter"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec147"/>Grabbing credentials from Twitter</h3></div></div></div><p>Markku's library <a id="id1402" class="indexterm"/>implements the <a id="id1403" class="indexterm"/>OAuth request signing, but it doesn't implement the OAuth Access Token retrieval flow. We can retrieve our token by using this guide on the Twitter website where we created our application: <a class="ulink" href="https://dev.twitter.com/docs/auth/tokens-devtwittercom">https://dev.twitter.com/docs/auth/tokens-devtwittercom</a>.</p><p>You need to keep handy the Access token and Access token secret, as we are going to include them in our firmware.</p></div><div class="section" title="Coding a firmware connecting to Twitter"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec148"/>Coding a firmware connecting to Twitter</h3></div></div></div><p>Markku's library<a id="id1404" class="indexterm"/> is <a id="id1405" class="indexterm"/>easy to use. Here is a possible code connecting the Arduino to your Ethernet network so that you can tweet messages directly.</p><p>You can find it at <code class="literal">Chapter11/tweetingButton/</code>.</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;sha1.h&gt;
#include &lt;Time.h&gt;
#include &lt;EEPROM.h&gt;
#include &lt;Twitter.h&gt;

// Switch 
const int switchPin = 2;     
int switchState = 0;        
int lastSwitchState = LOW;
long lastDebounceTime = 0;
long debounceDelay = 50;


// Local network configuration
uint8_t mac[6] =     {
  0xc4, 0x2c, 0x03, 0x0a, 0x3b, 0xb5};    // USE YOUR MAC ADDRESS
IPAddress ip(192, 168, 1, 43);            // USE IP ON YOUR NETWORK
IPAddress gateway(192, 168, 1, 1);        // USE YOUR GATWEWAY IP ADDRESS
IPAddress subnet(255, 255, 255, 0);       // USE YOUR SUBNET MASK

// IP address to Twitter
IPAddress twitter_ip(199, 59, 149, 232);
uint16_t twitter_port = 80;

unsigned long last_tweet = 0;
#define TWEET_DELTA (60L * 60L)

// Store the credentials
const static char consumer_key[] PROGMEM = "xxxxxxxxxxxxx";
const static char consumer_secret[] PROGMEM
= "yyyyyyyyyyyyy";

#DEFINE ALREADY_TOKENS 0 ; // Change it at 1 when you put your tokens

char buffer[512];
Twitter twitter(buffer, sizeof(buffer));


void setup() {
  Serial.begin(9600);
  Serial.println("Arduino Twitter demo");

  // the switch pin is setup as an input
  pinMode(switchPin, INPUT); 

  // start the network connection
  Ethernet.begin(mac, ip, dns, gateway, subnet);

  // define twitter entry point
  twitter.set_twitter_endpoint(PSTR("api.twitter.com"),
  PSTR("/1/statuses/update.json"),
  twitter_ip, twitter_port, false);
  twitter.set_client_id(consumer_key, consumer_secret);

  // Store or read credentials in EEPROM part of the board
#if ALREADY_TOKENS
  /* Read OAuth account identification from EEPROM. */
  twitter.set_account_id(256, 384);
#else
  /* Set OAuth account identification from program memory. */
  twitter.set_account_id(PSTR("*** set account access token here ***"),
  PSTR("*** set account token secret here ***"));
#endif

  delay(500);
}

void loop() {
  if (twitter.is_ready()) // if the twitter connection is okay
  {
    unsigned long now = twitter.get_time();
    if (last_tweet == 0) last_tweet = now - TWEET_DELTA + 15L;

    // read the state of the digital pin
    int readInput = digitalRead(switchPin);
    if (readInput != lastSwitchState)
    {
      lastDebounceTime = millis(); 
    }

    if ( (millis() - lastDebounceTime) &gt; debounceDelay )
    { 
      switchState = readInput; 
    }

    lastSwitchState = readInput;
    if (switchState == HIGH)  // if you push the button
    {
      if (now &gt; last_tweet + TWEET_DELTA) // if you didn't tweet for a while
      {

        char msg[32];
        sprintf(msg, "Tweeting from #arduino by pushing a button is cool, thanks to @julienbayle");

        // feedback to serial monitor
        Serial.print("Posting to Twitter: ");
        Serial.println(msg);

        last_tweet = now;

        if (twitter.post_status(msg))
          Serial.println("Status updated");
        else
          Serial.println("Update failed");
      }
      else Serial.println("Wait a bit before pushing it again!");
    }
  }
  delay(5000); // waiting a bit, just in case
}</pre></div><p>Let's <a id="id1406" class="indexterm"/>explain things here. Please note, this is a code including many things we already discovered and learned together:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Button push with debouncing system</li><li class="listitem" style="list-style-type: disc">Ethernet connection with the Arduino Ethernet Shield</li><li class="listitem" style="list-style-type: disc">Twitter library example</li></ul></div><p>We first<a id="id1407" class="indexterm"/> include a lot of library headers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SPI and Ethernet for network connection</li><li class="listitem" style="list-style-type: disc">Sha1 for credentials encryption</li><li class="listitem" style="list-style-type: disc">Time for time and date specific functions used by Twitter library</li><li class="listitem" style="list-style-type: disc">EEPROM to store credentials in EEPROM of the board</li><li class="listitem" style="list-style-type: disc">Twitter library itself</li></ul></div><p>Then, we include the variable related to the button itself and the debouncing system.</p><p>We configure the network parameters. Please notice you have to put your own elements here, considering your network and Ethernet shield. Then, we define the IP address of Twitter.</p><p>We define the <code class="literal">TWEET_DELTA</code> constant for further use, with respect to the Twitter API use that forbids us from sending too many tweets at a time. Then, we store our credentials. Please use yours, related to the application you created on the Twitter website for our purpose. At last we create the object twitter. </p><p>In the <code class="literal">setup()</code> function, we start the <code class="literal">Serial</code> connection in order to send some feedback to us. We configure the digital pin of the switch and start the Ethernet connection. Then, we have all the wizardry about Twitter. We first choose the entry point defined by the Twitter API docs itself. We have to put our Access token and Token secret here too. Then, we have a compilation condition: <code class="literal">#if TOKEN_IN_MEMORY</code>.</p><p>
<code class="literal">TOKEN_IN_MEMORY</code> is defined before as 0 or 1. Depending on its value, the compilation occurs in one manner or another.</p><p>In order to store credentials to the EEPROM of the board, we first have to put the value 0. We compile it and run it on the board. The firmware runs and writes the tokens in memory. Then, we change the value to 1 (because tokens are now in memory) and we compile it and run it on the board. From now, the firmware will read credentials from EEPROM.</p><p>Then, the <code class="literal">loop()</code> function is quite simple considering what we learned before.</p><p>We first test if the twitter connection to the API is okay. If it is okay, we store the time and the time of the last tweet at an initial value. We read the debounce value of the digital input.</p><p>If we push <a id="id1408" class="indexterm"/>the button, we test to see if we did that in less than the <code class="literal">TWEET_DELTA</code> amount of time. If it is the case, we are safe with respect to the Twitter API rules and we can tweet.</p><p>At last, we store <a id="id1409" class="indexterm"/>a message in the char array <code class="literal">msg</code>. And we tweet the message by using <code class="literal">twitter.post_status()</code> function. While using it, we also test what it returns. If it returns <code class="literal">1</code>, it means the tweet occurred. That provides this information to the user through serial monitor.</p><p>All API providers work in the same way. Here, we were very helped by the Twitter library we used, but there are other libraries also for other services on the Internet. Also, each service provides the complete documentation to use their API. Facebook API resources are available here: <a class="ulink" href="https://developers.facebook.com/">https://developers.facebook.com/</a>. Google+ API resources are available here: <a class="ulink" href="https://developers.google.com/+/api/">https://developers.google.com/+/api/</a>. Instagram API resources are available here: <a class="ulink" href="http://instagram.com/developer">http://instagram.com/developer</a>. And we could find a lot of others.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec82"/>Summary</h1></div></div></div><p>In this chapter, we learned how to extend the area of communication of our Arduino boards. We were used to making very local connections; we are now able to connect our board to the Internet and potentially communicate with the whole planet.</p><p>We described Wired Ethernet, Wi-Fi, Bluetooth connections, and how to use Twitters API.</p><p>We could have described the Xbee board, which uses radio frequencies, too, but I preferred to describe IP-related stuff because I consider them to be the safest way to transmit data. Of course, Xbees shield solution is a very nice one too and I used it myself in many projects.</p><p>In the next chapter, we are going to describe and dig into the Max 6 framework. This is a very powerful programming tool that can generate and parse data and we are going to explain how we can use it with Arduino.</p></div></body></html>