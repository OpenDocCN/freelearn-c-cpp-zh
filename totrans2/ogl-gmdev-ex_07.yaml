- en: Chapter 7. Audio Adrenaline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final chapter on the 2D game that we have been working on. Although
    our Robo Racer 2D game is almost complete, there is one element that we have yet
    to include to make it a complete game. Unless you like silent movies, you have
    probably noticed that we don't have any audio in this game. Most games depend
    on audio, and ours is no exception. In this chapter, we will cover audio and a
    few other housekeeping items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio formats**: It is important to understand how audio is represented in
    computers and how it is used in games. We will discuss sample rates and bits and
    help you understand how audio works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audio engine**: We need some kind of audio engine to integrate audio into
    our game. We will discuss FMOD, a very popular engine that allows you to easily
    integrate audio using C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SFX**: Sound effects play a huge role in most games and, we will add sound
    effects to our game to bring it to life.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Music**: Most games utilize some kind of music. Music is handled in a different
    way than sound effects, and you will learn the differences between the two.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Final housekeeping**: On a final note, for our game, we have left the game
    shutdown for this chapter. We have not been good programmers in that we have not
    properly released the objects in our game. We will learn why it is important to
    do so, and how to do it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bits and bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Audio is inherently an analog experience. Sound is created as compressed waves
    travel through the air and interact with our ear drums. Until recently, the techniques
    used to reproduce audio were also strictly audio as well. For example, a microphone
    records sound similarly to how our ears do by capturing changes in air pressure
    and converting them to electrical impulses. Speakers do the reverse by converting
    the electrical signals back into waves of air pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Computers, on the other hand, are digital. Computers convert audio samples into
    bits and bytes by taking samples of the audio. To keep it simple, let's consider
    a system where the current frequency of the sound wave (that is, how fast the
    wave is moving) is captured as a 16 bit (2 byte) number. It turns out that a 16
    bit number can capture numbers in a range from 0 to 65,536\. Each sample of the
    sound wave must be encoded as a number in this range. Also, as we actually capture
    two samples each time (for stereo sound), we need 4 bytes to capture each sample.
  prefs: []
  type: TYPE_NORMAL
- en: The next important factor is how often you sample the sound. The range of audio
    frequencies run roughly from 20 to 20,000 Hz (*Hz = cycles per second*). A very
    smart person named Nyquist figured out that we have to sample audio at twice the
    frequency to accurately capture the wave. This means that we have to capture at
    least 40,000 samples each second to accurately capture a sound. Conversely, we
    have to play the sound back at the same frequency. This is why audio on compact
    discs are sampled at 44,100 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to see by now that it is going to take a lot of disk space
    and a lot of memory to work with sound. A one minute piece of audio will take
    about 10 MB of storage! This means that the same audio would require 10 MB of
    memory if we were to load the entire audio file at once.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder how modern games function at all. The music scores of some games
    are measured in hours, not minutes. Similarly, there may be hundreds or even thousands
    of sound effects, not to mention voice, which is also recorded as audio.
  prefs: []
  type: TYPE_NORMAL
- en: A sound by any other name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many formats that audio files can be stored in. We will deal with
    two common formats that are used in games: WAV files and MP3 files. A WAV file
    stores the audio data in an uncompressed format.'
  prefs: []
  type: TYPE_NORMAL
- en: Although WAV files can be used for all of your audio, they are typically used
    for sound effects. Sound effects are typically very short, often less than 1 second.
    This means that the size of the file is going to be relatively small because the
    audio file is very short.
  prefs: []
  type: TYPE_NORMAL
- en: While sound effects are often saved as WAV files, music, typically, is not.
    This is because the length of music tends to be much longer than the length of
    sound effects. Loading a music file into memory that is three-to-five minutes
    long would take an exorbitant amount of memory.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main techniques that are used to deal with larger audio files.
    First, data compression can be used to make the audio files smaller. One of the
    most common audio formats that provides data compression is the MP3 format. Using
    mathematical trickery, MP3 files store the sound data in less space without sacrificing
    any sound quality.
  prefs: []
  type: TYPE_NORMAL
- en: The second technique that is used to handle large files is streaming. Instead
    of loading the entire sound file into memory, the file is sent a piece at a time
    as a continuous stream of data, which is then played in the game.
  prefs: []
  type: TYPE_NORMAL
- en: There are some limitations to streaming. First, the transfer of data from a
    hard drive or another storage device is much slower that the transfer of data
    from memory. Streamed audio can suffer from lag, which is the amount of time that
    it takes for a sound to play from the time that the sound was triggered to play
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: Lag is more critical for sound effects than it is for music. This is because
    a particular sound effect often coincides with something that just happened in
    the game. It would be disconcerting if the sound of a bullet occurred a half second
    after the bullet was fired! Music, on the other hand, often starts and runs for
    several minutes. A small lag in the start of the music can often be overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: Making noise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going into a full-blown course on creating sounds and music is, of course, beyond
    the scope of this book. However, I did want to give you a few resources to get
    you started.
  prefs: []
  type: TYPE_NORMAL
- en: The first question you may ask is where to find sounds. There are literally
    thousands of sites on the Web that provide sounds and music that can be used in
    games. Many charge a fee, while a few offer free audio.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that *royalty-free* doesn't necessarily mean free.
    Royalty-free audio means that once you obtain a license to use the audio, you
    won't have to pay any additional fees to use the music.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s my big tip. Every site that I have found charges a small fee for
    both sound effects and music. But there is one way that I have found to obtain
    sounds for free using the **Unity Asset Store**. Go to [http://unity3d.com](http://unity3d.com)
    and install the free version of Unity. Once you have started Unity, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project by clicking **Create New Project** tab from the **Unity
    Project Wizard**. Click **Browse** and navigate to or create a folder to store
    your project in. Then click **Select Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Unity loads the project, click **Window** and then **Asset Store** from
    the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the **Asset Store** window appears, enter a relevant search term (for example,
    music or SFX) in the **Search Asset Store** text box and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the results for free assets. Click on any listing for more details. If
    you find something that you like, click the **Download** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Unity has downloaded the asset, the **Importing Package** screen will appear
    titled. Click the **Import** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now exit Unity and navigate to the folder where you created the new
    project. Then navigate inside the `Assets` folder. From here, it depends on the
    structure of the package that you imported, but if you browse around, you should
    be able to locate the audio files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, we are using a musical piece titled Jolly Bot provided by Robson Cozendey
    ([www.cozendey.com](http://www.cozendey.com)). We also found a great SFX package
    from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now copy the audio files into your project!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As you browse around for audio files, you will run across some files with the
    `ogg` extension. This is a common audio format similar to MP3\. However, the engine
    that we will use does not support ogg files, so you will need to convert them
    to MP3 files. Audacity, which is described next, will allow you to convert audio
    files from one format to another.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may find that you want to edit or mix your audio files. Or, you may need
    to convert your audio files from one format to another. The best free tool that
    I found to work with audio is **Audacity**, and you can download it at [http://audacity.sourceforge.net/](http://audacity.sourceforge.net/).
    Audacity is a full-featured audio mixer that will allow you to play, edit, and
    convert audio files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To export files to the MP3 format, you will need a copy of **LAME** installed
    on your system. You can download LAME from [http://lame.buanzo.org/#lamewindl](http://lame.buanzo.org/#lamewindl).
  prefs: []
  type: TYPE_NORMAL
- en: Revving up your engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a better understanding of how audio works in your computer,
    it's time to write some code to bring audio into your game. We generally don't
    work with audio directly. Instead, there are audio engines that do all of the
    hard work for us, and one of the most popular ones is **FMOD**.
  prefs: []
  type: TYPE_NORMAL
- en: 'FMOD is a C and C++ API that allows us to load, manage, and play audio sources.
    FMOD is free to use for student and independent projects, so it is the perfect
    audio engine for our game. To use FMOD, you will have to go to the FMOD website,
    download the appropriate version of the API, and install it on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: To download FMOD, go to [http://www.FMOD.org/download/](http://www.FMOD.org/download/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There several downloads to choose from. Scroll down to the **FMOD Ex Programmer's
    API,** and click the **Download** button for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will have to locate the exe file that you just downloaded and install it.
    Make a note of the folder that FMOD is installed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have downloaded FMOD, you will have to incorporate it into the game
    project. Start by opening the `RoboRacer2D` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'm sure that you would like to see the full documentation for the **FMOD API**.
    If you installed FMOD in the default location, you will find the documentation
    at `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\documentation`.
    The main documentation is found in the file fmodex.chm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to set up our game to use FMOD. Similar to most third-party
    libraries, there are three steps to hooking things up:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the `.dll` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linking to the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point to the include files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let' walk through this process.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the FMOD .dll file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several `.dll` files that are included with FMOD, and it is important
    to use the correct file. The following table summarizes the dll files that come
    with FMOD and their associated library file:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dll | Description | Library |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fmodex.dll` | 32 bit FMOD API | `fmodex_vc.lib` |'
  prefs: []
  type: TYPE_TB
- en: '| `fmodexL.dll` | 32 bit FMOD API with debug logging | `fmodexL_vc.lib` |'
  prefs: []
  type: TYPE_TB
- en: '| `fmodex64.dll` | 64 bit FMOD API | `fmodex64_vc.lib` |'
  prefs: []
  type: TYPE_TB
- en: '| `fmodexL64.dll` | 64 bit FMOD API with debug logging | `fmodexL64_vc.lib`
    |'
  prefs: []
  type: TYPE_TB
- en: It's up to you to decide whether or not to use the 32-bit or 64-bit versions
    of the library. The debug versions of the library write logging information out
    to a file. You can find more information in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the 32-bit file in our game. There are several places where
    we can place the file, but the simplest method is to simply copy the `.dll` file
    into our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding path assumes that you used the default install location. You may
    have to modify the path if you chose another location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy `fmodex.dll` to the project folder that contains the `RoboRacer2D` source
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linking to the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to tell Visual Studio that we want to access the FMOD library.
    This is done by adding the library to the project properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project and choose **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Linker** branch under **Configuration Properties** and click on **Input**.![Linking
    to the library](img/8199OS_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the **Addition Dependencies** entry, then click the drop-down arrow
    and choose **<Edit…>**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `fmodex_vc.lib` to the list of dependencies.![Linking to the library](img/8199OS_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to close the `Additional Dependencies` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to close the `Property Pages` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have to tell Visual Studio where to find the library:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project and choose **Properties**.![Linking to the library](img/8199OS_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Linker** branch under **Configuration Properties** and click on **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the **Additional Library Directories** entry, then click the drop-down
    arrow and choose **<Edit…>**:![Linking to the library](img/8199OS_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New Line** icon, and then click the ellipses (**…**) that appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\lib`
    and click **Select Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to close the **Additional Library Directories** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to close the **Property Pages** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point to the include files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you use third-party code, you generally have to include C++ header
    files in your code. Sometimes, we just copy the relevant header files into the
    project folder (for example, this is what we did with `SOIL.h`).
  prefs: []
  type: TYPE_NORMAL
- en: 'With larger code bases, such as FMOD, we point Visual Studio to the location
    where the header files are installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project and choose **Properties**.![Point to the include
    files](img/8199OS_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **C/C++** branch under **Configuration Properties** and click on **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Additional Include Directories** entry, then click the drop-down
    arrow, and choose **<Edit…>**.![Point to the include files](img/8199OS_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **New Line** icon, and then click the ellipses (**…**) that appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\inc`
    and click **Select Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to close the **Additional Include Directories** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to close the **Property Pages** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final step is to include the header files into our program. Open `RoboRacer2D.cpp`
    and add the following line to include the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You are finally ready to use our audio engine!
  prefs: []
  type: TYPE_NORMAL
- en: Initializing FMOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first code that we need to add is the code that will initialize the audio
    engine. Just like we must initialize OpenGL, the code will set up FMOD and check
    to see if there are any errors along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `RoboRacer2D.cpp` and add the following code to the variable declarations
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates the FMOD system and initializes it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a variable to catch FMOD error codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `System_Create` call creates the engine and stores the results in `audiomgr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then initialize FMOD with 50 virtual channels, normal mode, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we need call the `InitAudio` function. Modify the `GameLoop` function,
    adding the highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Virtual channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most significant feature that FMOD provides for us is **virtual channels**.
    Each sound that you play has to have its own channel to play on. The number of
    physical channels to play audio varies from device to device. Early sound cards
    could only handle two to four channels of sound at a time. Modern sound cards
    may be able to handle eight, sixteen, or even more.
  prefs: []
  type: TYPE_NORMAL
- en: It used to be up to the developer to make sure that the number of sounds playing
    at any one time did not exceed the number of channels on the hardware. If the
    game triggered a new sound and no channel was available, then the sound wouldn't
    play. This led to choppy, unpredictable audio.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, FMOD handles all of this for us. FMOD uses virtual channels, and
    allows you to decide how many virtual channels you want to use. Behind the scenes,
    FMOD decides which virtual channels need to be assigned to a hardware channel
    at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: In our code example, we initialized FMOD with 50 virtual channels. This is actually
    way more that we will use in this game, but it wouldn't be outrageous for a full
    game. When considering how many virtual channels to assign, you should think about
    how many audio sources will be loaded at any particular time. These sounds won't
    all be playing at one time, just available to play.
  prefs: []
  type: TYPE_NORMAL
- en: Channel priority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FMOD can't make your hardware play more simultaneous sounds than it has physical
    sound channels, so you may wonder why you would ever assign more virtual channels
    than there are hardware channels.
  prefs: []
  type: TYPE_NORMAL
- en: The first answer to this question is that you really don't know how many hardware
    channels will be available on the system where a player is actually playing your
    game. The use of virtual channels takes this concern away from you.
  prefs: []
  type: TYPE_NORMAL
- en: The second answer is that virtual channels allow you to design your audio as
    if you really had 50 (or 100) channels available to you. FMOD then takes care
    of managing those channels behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens if your game needs to play a ninth sound and there are only
    eight physical channels? FMOD uses a priority system to decide which of the current
    eight channels is no longer needed. For example, channel seven may be assigned
    to a sound effect that is no longer playing. FMOD then assigns channel seven to
    the new sound that wants to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all physical channels are actually playing a sound right now and FMOD needs
    to play a new sound, then it chooses the channel with the lowest priority, stops
    playing the sound on that channel, and plays the new sound. Factors that determine
    priority include:'
  prefs: []
  type: TYPE_NORMAL
- en: How long ago the sound was triggered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a sound is set to loop continuously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The priority assigned by the programmer using the `Channel:setPriority` or `Sound::setDefaults`
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 3D sound, how far away the sound is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current volume of the sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you can still end up with sounds that drop out if your sound design exceeds
    the number of simultaneous, physical channels. But FMOD does its best to limit
    the impact this will have.
  prefs: []
  type: TYPE_NORMAL
- en: Bleeps and bloops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine watching a move that has no sound. As the main character runs down the
    alley, there are no footsteps. There is no swishing sound as his arms rub his
    jacket. There is no screech as a car comes to a halt just before hitting him.
  prefs: []
  type: TYPE_NORMAL
- en: A movie without sound would be pretty boring, and so would most games. Sounds
    bring games to life. The best sound design is one where the player doesn't actually
    realize there is a sound design. This means crafting sound effects and music in
    a way that complement the game without being obnoxious.
  prefs: []
  type: TYPE_NORMAL
- en: Sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sound effects generally correspond to some event or action that is happening
    in the game. A particular sound often corresponds to something that the player
    can see, but sound effects may also occur for something that the player cannot
    see, perhaps just round the corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our first sound effects to the game. We''ll keep it simple and add
    the following sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: A rolling sound as Robo moves across the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sound when Robo jumps up or jumps down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A happy sound when he collides with an oil can
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A not-so-happy sound when he collides with a water bottle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the sounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start by setting up some variables to act as pointers to our sounds.
    Open `RoboRacer2D.cpp` and add the following code in the variable declarations
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have three pointers to sound and one pointer to a channel. We only need one
    channel pointer because only one sound (`sfxMovement`) will be a looping sound.
    Looping sounds need a persistent channel pointer while one-shot sounds do not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will load these sounds. Add the following function to `RoboRacer2D.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download these sounds from the book's website or you can replace them
    with your own. Just be sure that you are using very short sounds for oil, water,
    and jump because they are intended to play quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This function loads our three sound effects files into the audio system.
  prefs: []
  type: TYPE_NORMAL
- en: The `createSound` function allocates memory for the sound and sets the FMOD
    properties for the sound.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_DEFAULT` sets up the following FMOD properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_LOOP_OFF`: The sound plays once and does not loop'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_2D`: This is a 2D sound'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_HARDWARE`: This uses the hardware features of the device to handle audio'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The result variable catches return value. In production games, you would test
    this each time to make sure that the sound had successfully loaded (we leave those
    error checks off here to save space).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we call `playSound` on the movement SFX. We are going to start this
    sound, assign it to the next free hardware channel (`FMOD_CHANNEL_FREE`), but
    tell FMOD to immediately pause it (thus the `true` parameter). When we want to
    play the sound, we will play it, and when we want it to stop, we will pause it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will call `playSound` on the other SFX as needed. As they are not looping
    sounds, we do not have to manage their paused state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we set `sfxJump`, `sfxOilcan`, and `sfxWater` to use the `FMOD_DEFAULT`
    settings. However, we will need `sfxMovement` to loop, so we had to set its setting
    flags individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several flags that you can use to set the properties of a sound,
    and you can use the OR operator (`|`) to combine flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FMOD_HARDWARE`: This uses the device hardware to handle the audio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_SOFTWARE`: This uses FMOD''s software emulation to handle the audio (slower,
    but could give access to features not supported by the device).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_2D`: This is a 2D sound. This is the format we will use for this game!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_3D`: This is a 3D sound. 3D sounds can be placed in 3D space and appear
    to have both distance (for example, the sound gets softer as it is further away)
    and position (left, right, in front of, behind).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_LOOP_OFF`: The sound plays once and does not loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOD_LOOP_NORMAL`: The sound plays and then starts over again, looping indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other flags that can be set. Take a look at the FMOD documentation
    for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a function to load our sounds, we have to wire it into the
    initialization for the game. Modify the `GameLoop` function, adding the following
    highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Playing sounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we need to trigger the sound effects at the appropriate time. Let's start
    with Robo's movement SFX. Basically, we want to play this sound any time Robo
    is actually moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to modify the `CM_STOP`, `CM_LEFT`, and `CM_RIGHT` cases in the
    `ProcessInput` function. Update the code inserting the highlighted lines indicated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we already loaded `sfxMovement` and assigned it to a virtual channel
    (`chMovement`), then told it to start playing as a paused sound. Actually, in
    FMOD, you pause and play the channel, not the sound. So, all we have to do now
    is call `chMovement->setPaused(true)` when Robo is moving and `chMovement->setPaused(false)`
    when he is not moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to handle the oil and water pickups. These can both be handled
    in the `CheckCollisions` function. Modify `CheckCollisions` by adding the following
    highlighted lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add a sound effect for Robo when he jumps up or jumps down.
    These changes will be applied to the `CM_UP` and `CM_DOWN` cases in the `ProcessInput`
    function. Modify the existing code with the following highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These sound effects are one-shot sounds. When they are done playing, we don''t
    need to worry about them any more until it is time to play them again. For this
    type of sound, we create a channel (`FMOD::channel* channel`), then call `playSound`
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FMOD_CHANNEL_FREE`: This lets FMOD pick the next available hardware sound
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sound pointer: `sfxWater` for the water bottle, `sfxOilcan` for the oil, and
    `sfxJump` for the jump SFX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`: Don''t pause the sound!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&channel`: This is the virtual channel handle. Notice that this is just a
    local variable. We don''t need to store this anywhere for one-shot SFX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it! If you play the game now, the four SFX should trigger according to
    our design.
  prefs: []
  type: TYPE_NORMAL
- en: UI feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we created sound effects to respond to events and actions in the game.
    Sound effects are also used to provide feedback from the user interface. For example,
    when the player clicks a button, there should be some kind of audio that plays
    so that the player immediately knows that the click was registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we already trap each time the user has clicked a UI button, so
    it''s easy to trigger a sound each time it happens. Let''s start by adding a new
    sound pointer. In `RoboRacer2D.cpp`, add the following line to the variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code to `LoadAudio`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following highlighted lines of code to the `CM_UI` case in
    `ProcessInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point, when you run the game you will now hear an SFX each time a button
    is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The sound of music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now turn to the audio soundtrack for our game. Just like a movie soundtrack,
    the music that is played during a game sets the tone for the game. Many games
    have huge, orchestrated productions, while others have synthesized or 8-bit music.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed, music files are handled in a different manner
    from sound effects. This is because sound effects are usually very short sounds
    that can be best stored as wav files. Music files tend to be much longer, and
    are stored as MP3 files because the data can be compressed, taking less storage
    and less memory.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add a single music track to our game. To keep things simple,
    we will tell the track to loop so that it runs continuously throughout the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by adding a sound pointer. Open `RoboRacer2D.cpp` and add the
    following line of code to the variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go to the `LoadAudio` function and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use `createStream` instead of `createSound` to load our music
    file. As music is so much longer than sound effects, music is streamed from storage
    rather than loaded directly into memory.
  prefs: []
  type: TYPE_NORMAL
- en: We want the sound track to start when the game starts, so we start playing the
    music in right after it is loaded using `playSound`.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it! Our game is now enhanced by a vibrant soundscape.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the house
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a pretty complete game. Sure, it's not going to set any records or make
    anyone rich, but if this is your first game, then congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been remiss in one area: good programming dictates that any time we
    create an object, we delete it when we are done using it. Up to now, you may be
    wondering if we were ever going to do this! Well, now is the time.'
  prefs: []
  type: TYPE_NORMAL
- en: We made a placeholder for all of these operations in the `EndGame` function.
    Now, we will add the necessary code to properly release our resources.
  prefs: []
  type: TYPE_NORMAL
- en: Release sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by clearing out our sprites. It is important to remember that
    when we remove any resource, we need to make sure that it is also releasing its
    own resources. This is the purpose of the class destructor. Let''s use the `Sprite`
    class as an example. Open `Sprite.cpp` and you should see a destructor defined
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We first want to release all of the textures in the `m_textures` array. Then
    we use `delete[]` to release the `m_textures` array. It is also good programming
    practice to set the variable to `NULL` once an object has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Sprite` destructor will be called when we call `delete` on a sprite object.
    So, the first thing we need to add to `EndGame` is a `delete` operation for each
    sprite that was created for our game. Add the following lines of code to the `EndGame`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look closely, you will notice that we did not delete the player object.
    This is because player was only used as a pointer to sprites that had already
    been created. Put another way, we never used player to create a new Sprite. A
    good rule of thumb is that there should be exactly one delete for every new.
  prefs: []
  type: TYPE_NORMAL
- en: Release input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next system to shut down is the input system. First, let''s complete the
    `Input` destructor. Add the highlighted code to the destructor in the `Input`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have to delete the `uiElements` array, which was an array of pointers to
    the sprites that were part of the input system. Note that we did not delete the
    actual sprites here because they were not created by the input system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following line of code to `EndGame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Releasing fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add this line to release the display lists we used to store our fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Releasing audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final cleanup is the audio system. Add the following lines of code to `EndGame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Your house is all cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of material in this chapter, and in the process, we completed
    our 2D game. You learned a little about how audio is represented in the computer.
    Then we installed the FMOD API and learned how to integrate it into our project.
    Finally, we used FMOD to set up and play sound effects and music in our game.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter completes our discussion of game programming in 2D. As you should
    now be aware, there is a lot more to completing a game than using the OpenGL library.
    Remember, OpenGL is a rendering library. We had to write our own class to handle
    input and we used a third-party class to handle audio.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we begin our foray into the world of 3D programming!
  prefs: []
  type: TYPE_NORMAL
