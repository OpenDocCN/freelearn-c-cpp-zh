- en: Vocabulary Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词汇类型
- en: It has been increasingly recognized over the past decade that one of the important
    roles of a standard language or standard library is to provide *vocabulary types*.
    A "vocabulary" type is a type that purports to provide a single *lingua franca*,
    a common language, for dealing with its domain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，人们越来越认识到，标准语言或标准库的一个重要角色是提供*词汇类型*。一个“词汇”类型是一个声称为处理其领域提供一个单一*通用语言*的类型，一个共同的语言。
- en: Notice that even before C++ existed, the C programming language had already
    made a decent shot at the vocabulary of some areas, providing standard types or
    type aliases for integer math (`int`), floating-point math (`double`), timepoints
    expressed in the Unix epoch (`time_t`), and byte counts (`size_t`).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，甚至在C++存在之前，C编程语言就已经在某个领域的词汇方面做出了相当不错的尝试，为整数数学（`int`）、浮点数学（`double`）、以Unix纪元表示的时间点（`time_t`）和字节计数（`size_t`）提供了标准类型或类型别名。
- en: 'In this chapter we''ll learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: The history of vocabulary types in C++, from `std::string` to `std::any`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中词汇类型的演变历史，从`std::string`到`std::any`
- en: The definitions of *algebraic data type*, *product type*, and *sum type*
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数数据类型、乘积类型和求和类型的定义
- en: How to manipulate tuples and visit variants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何操作元组和访问变体
- en: The role of `std::optional<T>` as "maybe a `T`" or "not yet a `T`"
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::optional<T>`作为“可能有`T`”或“尚未有`T`”的作用'
- en: '`std::any` as the algebraic-data-type equivalent of "infinity"'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::any`作为“无限”的代数数据类型等价物'
- en: How to implement type erasure, how it's used in `std::any` and `std::function`,
    and its intrinsic limitations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现类型擦除，它在`std::any`和`std::function`中的使用以及其固有的限制
- en: Some pitfalls with `std::function`, and third-party libraries that fix them
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::function`的一些陷阱以及修复它们的第三方库'
- en: The story of std::string
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::string`的故事'
- en: 'Consider the domain of character strings; for example, the phrase `hello world`.
    In C, the *lingua franca* for dealing with strings was `char *`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑字符字符串的领域；例如，短语`hello world`。在C中，处理字符串的通用语言是`char *`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This was all right for a while, but dealing with raw `char *`s had some problems
    for the users of the language and the creators of third-party libraries and routines.
    For one thing, the C language was so old that `const` had not been invented at
    the outset, which meant that certain old routines would expect their strings as
    `char *` and certain newer ones expect `const char *`. For another thing, `char
    *` didn't carry a *length* with it; so some functions expected both a pointer
    and a length, and some functions expected only the pointer and simply couldn't
    deal with embedded bytes of value `'\0'`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一段时间内是可行的，但是处理原始的`char *`对于语言的用户以及第三方库和例程的创建者来说存在一些问题。一方面，C语言如此古老，以至于一开始就没有发明出`const`，这意味着某些旧的例程会期望它们的字符串为`char
    *`，而某些较新的则期望`const char *`。另一方面，`char *`没有携带一个*长度*；因此，一些函数期望一个指针和一个长度，而一些函数只期望指针，并且根本无法处理值`'\0'`嵌入的字节。
- en: 'The most vital piece missing from the `char *` puzzle was *lifetime management*
    and *ownership* (as discussed at the start of [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*). When a C function wants to receive a string from its caller,
    it takes `char *` and generally leaves it up to the caller to manage the ownership
    of the characters involved. But what if it wants to *return* a string? Then it
    has to return `char *` and hope that the caller remembers to free it (`strdup`,
    `asprintf`), or take in a buffer from the caller and hope it''s big enough for
    the output (`sprintf`, `snprintf`, `strcat`). The difficulty of managing the ownership
    of strings in C (and in pre-standard C++) was so great that there was a proliferation
    of "string libraries" to deal with the problem: Qt''s `QString`, glib''s `GString`,
    and so on.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`char *`谜团中缺失的最重要部分是*生命周期管理*和*所有权*（如[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，*容器动物园*开头所述）。当一个C函数想要从其调用者那里接收一个字符串时，它接受`char
    *`，并且通常将字符的所有权管理留给调用者。但是，如果它想要*返回*一个字符串呢？那么它必须返回`char *`并希望调用者记得释放它（`strdup`、`asprintf`），或者从调用者那里接收一个缓冲区并希望它足够大以容纳输出（`sprintf`、`snprintf`、`strcat`）。在C（以及在预标准的C++）中管理字符串所有权的困难如此之大，以至于出现了大量的“字符串库”来解决这个问题：Qt的`QString`、glib的`GString`等等。'
- en: 'Into this chaos stepped C++ in 1998 with a miracle: a *standard* string class!
    The new `std::string` encapsulated the bytes of a string *and* its length, in
    a natural way; it could deal correctly with embedded null bytes; it supported
    formerly complicated operations such as `hello + world` by quietly allocating
    exactly as much memory as it needed; and because of RAII, it would never leak
    memory or incite confusion about who owned the underlying bytes. Best of all,
    it had an implicit conversion from `char *`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 1998 年，C++ 以一个奇迹般的方式进入了这个混乱：一个 *标准* 字符串类！新的 `std::string` 以自然的方式封装了字符串的字节和长度；它可以正确处理嵌入的空字节；它支持以前复杂的操作，如
    `hello + world`，通过静默地分配所需的精确内存量；而且由于 RAII，它永远不会泄漏内存或引起关于谁拥有底层字节的混淆。最好的是，它从 `char
    *` 有隐式转换：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now C++ functions dealing with strings (such as `greet()` in the preceding code)
    could take `std::string` parameters and return `std::string` results. Even better,
    because the string type was *standardized*, within a few years you could be reasonably
    confident that when you picked up some third-party library to integrate it into
    your codebase, any of its functions that took strings (filenames, error messages,
    what-have-you) would be using `std::string`. Everybody could communicate more
    efficiently and effectively by sharing the *lingua franca* of `std::string`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，C++ 函数处理字符串（如前述代码中的 `greet()`）可以接受 `std::string` 参数并返回 `std::string` 结果。甚至更好，因为字符串类型是
    *标准化的*，几年后你可能会相当有信心，当你选择一些第三方库将其集成到你的代码库中时，它的任何接受字符串（文件名、错误消息等）的函数都会使用 `std::string`。通过共享
    `std::string` 的 *通用语言*，每个人都可以更有效地进行沟通。
- en: Tagging reference types with reference_wrapper
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 reference_wrapper 标记引用类型
- en: 'Another vocabulary type introduced in C++03 was `std::reference_wrapper<T>`.
    It has a simple implementation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++03 中引入的另一个词汇类型是 `std::reference_wrapper<T>`。它有一个简单的实现：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`std::reference_wrapper` has a slightly different purpose from vocabulary types
    such as `std::string` and `int`; it''s meant specifically as a way to the "tag"
    values that we''d like to behave as references in contexts where passing native
    C++ references doesn''t work the way we''d like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::reference_wrapper` 的用途与 `std::string` 和 `int` 等词汇类型略有不同；它专门作为将我们希望在其上下文中作为引用行为的“标记”值的方式：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constructor of `std::thread` is written with specific special cases to handle
    `reference_wrapper` parameters by "decaying" them into native references. The
    same special cases apply to the standard library functions `make_pair`, `make_tuple`,
    `bind`, `invoke`, and everything based on `invoke` (such as `std::apply`, `std::function::operator()`,
    and `std::async`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread` 的构造函数编写了特定的特殊情况来处理 `reference_wrapper` 参数，通过“退化”为原生引用来处理。相同的特殊情况适用于标准库函数
    `make_pair`、`make_tuple`、`bind`、`invoke` 以及基于 `invoke` 的所有内容（如 `std::apply`、`std::function::operator()`
    和 `std::async`）。'
- en: C++11 and algebraic types
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++11 和代数类型
- en: 'As C++11 took shape, there was growing recognition that another area ripe for
    vocabularization was that of the so-called *algebraic data types*. Algebraic types
    arise naturally in the functional-programming paradigm. The essential idea is
    to think about the domain of a type--that is, the set of all possible values of
    that type. To keep things simple, you might want to think about C++ `enum` types,
    because it''s easy to talk about the number of different values that an object
    of `enum` type might assume at one time or another:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++11 的形成，越来越多的人认识到另一个适合词汇化的领域是所谓的 *代数数据类型*。代数类型在函数式编程范式中自然出现。基本思想是考虑类型的域——即该类型所有可能值的集合。为了使事情简单，你可能想要考虑
    C++ 的 `enum` 类型，因为很容易谈论 `enum` 类型的对象在某个时刻可能具有的不同值的数量：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Given the types `Color` and `Size`, can you create a data type whose instances
    might assume any of 2 × 3 = 6 values? Yes; this type represents "one of each"
    of `Color` and `Size`, and is called a *product type*, because its set of possible
    values is the *Cartesian product* of its elements' sets of possible values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 给定类型 `Color` 和 `Size`，你能创建一个实例可能具有 2 × 3 = 6 个值的类型吗？是的；这种类型代表 `Color` 和 `Size`
    的“每个都只有一个”，被称为 *积类型*，因为其可能值的集合是其元素可能值集合的 *笛卡尔积*。
- en: How about a data type whose instances might assume any of 2 + 3 = 5 different
    values? Also yes; this type represents "either a `Color` or a `Size` but never
    both at once," and is called a *sum type*. (Confusingly, mathematicians do not
    use the term *Cartesian sum* for this concept.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个实例可能具有 2 + 3 = 5 个不同值的类型呢？也是；这种类型表示“要么是 `Color` 或 `Size`，但不会同时两者都是”，这被称为
    *求和类型*。（令人困惑的是，数学家并不使用 *笛卡尔和* 这个术语来表示这个概念。）
- en: 'In a functional-programming language such as Haskell, these two exercises would
    be spelled like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Haskell 这样的函数式编程语言中，这两个练习的拼写如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In C++, they''re spelled like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，它们的拼写如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The class template `std::pair<A, B>` represents an ordered pair of elements:
    one of type `A`, followed by one of type `B`. It''s very similar to a plain old
    `struct` with two elements, except that you don''t have to write the struct definition
    yourself:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::pair<A, B>` 表示一个有序元素对：一个类型为 `A` 的元素，后面跟着一个类型为 `B` 的元素。它与一个包含两个元素的普通
    `struct` 非常相似，只是你不需要自己编写 `struct` 定义：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that there are only cosmetic differences between `std::pair<A, A>` and
    `std::array<A, 2>`. We might say that `pair` is a *heterogeneous* version of `array`
    (except that `pair` is restricted to holding only two elements).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `std::pair<A, A>` 和 `std::array<A, 2>` 之间只有细微的表面差异。我们可能会说 `pair` 是 `array`
    的一个 *异构* 版本（除了 `pair` 只能持有两个元素的限制）。
- en: Working with std::tuple
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::tuple
- en: C++11 introduced a full-fledged heterogeneous array; it's called `std::tuple<Ts...>`.
    A tuple of only two element types--for example, `tuple<int, double>`--is no different
    from `pair<int, double>`. But tuples can hold more than just a pair of elements;
    though the magic of C++11 variadic templates they can hold triples, quadruples,
    quintuples,... hence the generic name `tuple`. For example, `tuple<int, int, char,
    std::string>` is analogous to a `struct` whose members are an `int`, another `int`,
    a `char`, and finally a `std::string`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 引入了一个完整的异构数组；它被称为 `std::tuple<Ts...>`。仅包含两种元素类型的元组——例如，`tuple<int, double>`——与
    `pair<int, double>` 没有区别。但元组可以持有比一对元素更多的内容；通过 C++11 可变参数模板的魔力，它们可以持有三元组、四元组、五元组等，因此具有通用的名称
    `tuple`。例如，`tuple<int, int, char, std::string>` 与一个成员分别为 `int`、另一个 `int`、一个 `char`
    和最后的 `std::string` 的 `struct` 相似。
- en: Because the first element of a tuple has a different type from the second element,
    we can't use the "normal" `operator[](size_t)` to access the elements by indices
    that might vary at runtime. Instead, we must tell the compiler *at compile time*
    which element of the tuple we're planning to access, so that the compiler can
    figure out what type to give the expression. The C++ way to provide information
    at compile time is to force it into the type system via template parameters, and
    so that's what we do. When we want to access the first element of a tuple `t`,
    we call `std::get<0>(t)`. To access the second element, we call `std::get<1>(t)`,
    and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为元组的第一个元素与第二个元素类型不同，我们不能使用“正常”的 `operator[](size_t)` 通过可能随运行时变化的索引来访问元素。相反，我们必须在
    *编译时* 告诉编译器我们打算访问元组的哪个元素，这样编译器才能确定要给表达式赋予什么类型。C++ 在编译时提供信息的方法是通过模板参数强制将其纳入类型系统，这就是我们这样做的原因。当我们想访问元组
    `t` 的第一个元素时，我们调用 `std::get<0>(t)`。要访问第二个元素，我们调用 `std::get<1>(t)`，依此类推。
- en: This becomes the pattern for dealing with `std::tuple`--where the homogeneous
    container types tend to have *member functions* for accessing and manipulating
    them, the heterogeneous algebraic types tend to have *free function templates*
    for accessing and manipulating them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就成为了处理 `std::tuple` 的模式——在具有访问和操作它们的 *成员函数* 的同构容器类型中，异构代数类型倾向于有 *自由函数模板* 用于访问和操作它们。
- en: 'However, generally speaking, you won''t do a lot of *manipulating* of tuples.
    Their primary use-case, outside of template metaprogramming, is as an economical
    way to temporarily bind a number of values together in a context that requires
    a single value. For example, you might remember `std::tie` from the example in
    section "The simplest container" in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*. It''s a cheap way of binding together an arbitrary number
    of values into a single unit that can be compared lexicographically with `operator<`.
    The "sense" of the lexicographical comparison depends on the order in which you
    bind the values together:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一般来说，你不会对元组进行很多**操作**。它们的主要用途，除了模板元编程之外，是在需要单个值的上下文中以经济的方式暂时将多个值绑定在一起。例如，你可能还记得从第4章[part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d]中“最简单的容器”部分中的示例中了解到的`std::tie`。这是一种将任意数量的值绑定到单个单元的便宜方法，该单元可以用`operator<`进行字典序比较。字典序比较的“感觉”取决于你绑定值的顺序：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The reason that `std::tie` is so cheap is that it actually creates a tuple
    of *references* to its arguments'' memory locations, rather than copying its arguments''
    values. This leads to a second common use for `std::tie`: simulating the "multiple
    assignment" found in languages such as Python:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::tie`之所以如此便宜，是因为它实际上创建了一个对其参数内存位置的**引用**元组，而不是复制其参数的值。这导致了`std::tie`的第二种常见用途：模拟像Python这样的语言中发现的“多重赋值”：'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the phrase "at once" in the preceding comment doesn't have any bearing
    on concurrency (see [Chapter 7](part0108.html#36VSO0-2fdac365b8984feebddfbb9250eaf20d),
    *Concurrency*) or the order in which the side effects are performed; I just mean
    that both values can be assigned in a single assignment statement, instead of
    taking two or more lines.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前述注释中的“一次”短语与并发（见第7章[part0108.html#36VSO0-2fdac365b8984feebddfbb9250eaf20d]，*并发*）或副作用执行的顺序无关；我的意思是，两个值可以在单个赋值语句中赋值，而不是占用两行或多行。
- en: As the preceding example illustrates, `std::make_tuple(a, b, c...)` can be used
    to create a tuple of *values*; that is, `make_tuple` does construct copies of
    its arguments' values, rather than merely taking their addresses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`std::make_tuple(a, b, c...)`可以用来创建一个包含**值**的元组；也就是说，`make_tuple`确实会构造其参数值的副本，而不仅仅是获取它们的地址。
- en: 'Lastly, in C++17 we are allowed to use constructor template parameter deduction
    to write simply `std::tuple(a, b, c...)`; but it''s probably best to avoid this
    feature unless you know specifically that you want its behaviour. The only thing
    that template parameter deduction will do differently from `std::make_tuple` is
    that it will preserve `std::reference_wrapper` arguments rather than decaying
    them to native C++ references:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在C++17中，我们可以使用构造函数模板参数推导来简单地编写`std::tuple(a, b, c...)`；但除非你确切知道你想要它的行为，否则最好避免使用这个特性。模板参数推导与`std::make_tuple`的不同之处仅在于它将保留`std::reference_wrapper`参数而不是将它们退化到原生C++引用：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Manipulating tuple values
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作元组值
- en: 'Most of these functions and templates are useful only in the context of template
    metaprogramming; you''re unlikely to use them on a daily basis:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些函数和模板仅在模板元编程的上下文中有用；你不太可能每天都会使用它们：
- en: '`std::get<I>(t)`: Retrieves a reference to the `I`th element of `t`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::get<I>(t)`: 获取对`t`的第`I`个元素的引用。'
- en: '`std::tuple_size_v<decltype(t)>`: Tells the *size* of the given tuple. Because
    this is a compile-time constant property of the tuple''s type, this is expressed
    as a variable template parameterized on that type. If you''d rather use more natural-looking
    syntax, you can write a helper function in either of the following ways:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::tuple_size_v<decltype(t)>`: 表示给定元组的**大小**。因为这是元组类型的编译时常量属性，所以它被表示为一个以该类型为参数的变量模板。如果你更愿意使用更自然的语法，你可以以以下两种方式之一编写辅助函数：'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`std::tuple_element_t<I, decltype(t)>`: Tells the *type* of the `I`th element
    of the given tuple type. Again, the standard library exposes this information
    in a more awkward way than the core language does. Generally, to find the type
    of the `I`th element of a tuple, you''d just write `decltype(std::get<I>(t))`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::tuple_element_t<I, decltype(t)>`: 表示给定元组类型的第`I`个元素的**类型**。同样，标准库以一种比核心语言更不优雅的方式公开了这项信息。通常，要找到元组的第`I`个元素的类型，你只需编写`decltype(std::get<I>(t))`。'
- en: '`std::tuple_cat(t1, t2, t3...)`: Concatenates all the given tuples together,
    end to end.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::tuple_cat(t1, t2, t3...)`: 将所有给定的元组从头到尾连接起来。'
- en: '`std::forward_as_tuple(a, b, c...)`: Creates a tuple of references, just like
    `std::tie`; but whereas `std::tie` demands lvalue references, `std::forward_as_tuple`
    will accept any kind of references as input, and perfectly forward them into the
    tuple so that they can later be extracted by `std::get<I>(t)...`:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_as_tuple(a, b, c...)`: 创建一个引用元组，就像`std::tie`；但与`std::tie`要求左值引用不同，`std::forward_as_tuple`将接受任何类型的引用作为输入，并将它们完美地转发到元组中，以便稍后可以通过`std::get<I>(t)...`提取它们：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A note about named classes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于命名类的说明
- en: As we saw in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, when we compared `std::array<double, 3>` to `struct Vec3`,
    using an STL class template can shorten your development time and eliminate sources
    of error by reusing well-tested STL components; but it can also make your code
    less readable or give your types *too much* functionality. In our example from
    [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container
    Zoo,* `std::array<double, 3>` turned out to be a poor choice for `Vec3` because
    it exposed an unwanted `operator<`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)“容器动物园”中看到的那样，当我们比较`std::array<double,
    3>`和`struct Vec3`时，使用STL类模板可以缩短你的开发时间，并通过重用经过良好测试的STL组件来消除错误来源；但它也可能使你的代码可读性降低或给你的类型赋予*过多的*功能。在我们的[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)“容器动物园”的例子中，`std::array<double,
    3>`对于`Vec3`来说是一个糟糕的选择，因为它暴露了一个不想要的`operator<`。
- en: Using any of the algebraic types (`tuple`, `pair`, `optional`, or `variant`)
    directly in your interfaces and APIs is probably a mistake. You'll find that your
    code is easier to read, understand, and maintain if you write named classes for
    your own "domain-specific vocabulary" types, even if--*especially* if--they end
    up being thin wrappers around the algebraic types.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的接口和API中使用任何代数类型（`tuple`、`pair`、`optional`或`variant`）可能是错误的。你会发现，如果你为自己的“特定领域词汇”类型编写命名类，你的代码将更容易阅读、理解和维护，即使它们最终只是代数类型的薄包装——尤其是如果它们最终只是代数类型的薄包装。
- en: Expressing alternatives with std::variant
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::variant表达备选方案
- en: 'Whereas `std::tuple<A,B,C>` is a *product type*, `std::variant<A,B,C>` is a
    *sum type*. A variant is allowed to hold either an `A`, a `B`, or a `C`--but never
    more (or less) than one of those at a time. Another name for this concept is *discriminated
    union*, because a variant behaves a lot like a native C++ `union`; but unlike
    a native `union`, a variant is always able to tell you which of its elements,
    `A`, `B`, or `C`, is "active" at any given time. The official name for these elements
    is "alternatives," since only one can be active at once:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 而`std::tuple<A,B,C>`是一个*积类型*，`std::variant<A,B,C>`是一个*和类型*。一个变体可以同时持有`A`、`B`或`C`中的一个——但一次不能同时持有（或少于）一个。这个概念的另一个名字是*有区别的联合*，因为变体在很多方面都像原生C++的`union`；但与原生`union`不同，变体总是能够告诉你它的哪个元素，`A`、`B`或`C`，在任何给定时间点是“活跃”的。这些元素的官方名称是“备选方案”，因为一次只能有一个是活跃的：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As with `tuple`, you can get a specific element of the `variant` using `std::get<I>(v)`.
    If your variant object''s alternatives are all distinct (which should be the most
    common case, unless you''re doing deep metaprogramming), you can use `std::get<T>(v)`
    with types as well as with indices--for an example, look at the preceding code
    sample, where `std::get<0>(v1)` and `std::get<int>(v1)` work interchangeably because
    the zeroth alternative in the variant `v1` is of type `int`. Unlike `tuple`, however,
    `std::get` on a variant is allowed to fail! If you call `std::get<double>(v1)`
    while `v1` currently holds a value of type `int`, then you''ll get an exception
    of type `std::bad_variant_access`. `std::get_if` is the "non-throwing" version
    of `std::get`. As shown in the preceding example, `get_if` returns a *pointer*
    to the specified alternative if it''s the active one, and otherwise returns a
    null pointer. Therefore the following code snippets are all equivalent:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与`tuple`一样，你可以使用`std::get<I>(v)`获取`variant`的特定元素。如果你的变体对象的备选方案都是不同的（除非你在进行深度元编程，这应该是最常见的用例），你可以使用`std::get<T>(v)`与类型以及索引一起使用——例如，查看前面的代码示例，其中`std::get<0>(v1)`和`std::get<int>(v1)`可以互换使用，因为变体`v1`中的零索引备选方案是`int`类型。然而，与`tuple`不同，变体上的`std::get`允许失败！如果你在`v1`当前持有`int`类型值时调用`std::get<double>(v1)`，那么你会得到一个`std::bad_variant_access`类型的异常。`std::get_if`是`std::get`的“非抛出”版本。正如前面的示例所示，如果指定的备选方案是活跃的，`get_if`返回指向该备选方案的指针，否则返回空指针。因此，以下代码片段都是等效的：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Visiting variants
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问变体
- en: In the preceding example, we showed how when we had a variable `std::variant<int,
    double> v`, calling `std::get<double>(v)` would give us the current value *if*
    the variant currently held a `double`, but would throw an exception if the variant
    held an `int`. This might have struck you as odd--since `int` is convertible to
    `double`, why couldn't it just have given us the converted value?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们展示了当有一个变量 `std::variant<int, double> v` 时，调用 `std::get<double>(v)`
    会给我们当前的值，前提是变体当前持有 `double`，但如果变体持有 `int`，则会抛出异常。这可能会让你觉得有些奇怪——因为 `int` 可以转换为
    `double`，为什么它不能直接给我们转换后的值呢？
- en: 'We can get that behaviour if we want it, but not from `std::get`. We have to
    re-express our desire this way: "I have a variant. If it currently holds a `double`,
    call it `d`, then I want to get `double(d)`. If it holds an `int i`, then I want
    to get `double(i)`." That is, we have a list of behaviors in mind, and we want
    to invoke exactly one of those behaviors on whichever alternative is currently
    held by our variant `v`. The standard library expresses this algorithm by the
    perhaps obscure name `std::visit`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要这种行为，我们不能从 `std::get` 获取。我们必须以这种方式重新表达我们的需求：“我有一个变体。如果它当前持有 `double`，称为
    `d`，那么我想获取 `double(d)`。如果它持有 `int i`，那么我想获取 `double(i)`。”也就是说，我们有一个行为列表在心中，我们想要在当前由我们的变体
    `v` 持有的任何替代方案上调用这其中的一个行为。标准库通过可能有些晦涩的名字 `std::visit` 来表达这个算法：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Generally speaking, when we `visit` a variant, all of the behaviors that we
    have in mind are fundamentally similar. Because we''re writing in C++, with its
    overloading of functions and operators, we can generally express our similar behaviors
    using exactly identical syntax. If we can express them with identical syntax,
    we can wrap them up into a template function or--the most common case--a C++14
    generic lambda, like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，当我们 `visit` 一个变体时，我们心中所想的全部行为在本质上都是相似的。因为我们是用 C++ 编写的，它具有函数和运算符的重载，我们可以一般地使用完全相同的语法来表达我们的相似行为。如果我们可以用相同的语法来表达它们，我们就可以将它们封装到一个模板函数中，或者——最常见的情况——一个
    C++14 泛型 lambda，如下所示：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the use of C++17 `if constexpr` to take care of the one case that's fundamentally
    unlike the others. It's somewhat a matter of taste whether you prefer to use explicit
    switching on `decltype` like this, or to make a helper class such as the previous
    code sample's `Visitor` and rely on overload resolution to pick out the correct
    overload of `operator()` for each possible alternative.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了 C++17 的 `if constexpr` 来处理与其他情况根本不同的一种情况。是否更喜欢使用这种明确的 `decltype` 切换，或者创建一个辅助类，例如前面代码示例中的
    `Visitor`，并依赖重载解析来选择每个可能替代的 `operator()` 的正确重载，这更多是一个个人喜好问题。
- en: 'There is also a variadic version of `std::visit` taking two, three, or even
    more `variant` objects, of the same or different types. This version of `std::visit`
    can be used to implement a kind of "multiple dispatch," as shown in the following
    code. However, you almost certainly will never need this version of `std::visit`
    unless you''re doing really intense metaprogramming:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::visit` 也有一个可变参数版本，它接受两个、三个甚至更多的 `variant` 对象，这些对象可以是相同类型或不同类型。这个版本的 `std::visit`
    可以用来实现一种“多重分派”，如下面的代码所示。然而，除非你正在进行真正的密集型元编程，否则你几乎肯定不需要这个版本的 `std::visit`：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What about make_variant? and a note on value semantics
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么 `make_variant` 呢？以及关于值语义的注意事项
- en: 'Since you can create a tuple object with `std::make_tuple`, or a pair with
    `make_pair`, you might reasonably ask, "Where is `make_variant`?" It turns out
    that there is none. The primary reason for its absence is that whereas `tuple`
    and `pair` are product types, `variant` is a sum type. To create a tuple, you
    always have to provide all *n* of its elements'' values, and so the element types
    can always be inferred. With `variant`, you only have to provide one of its values--of
    type let''s say `A`--but the compiler can''t create a `variant<A,B,C>` object
    without knowing the identities of types `B` and `C` as well. So there''d be no
    point in providing a function `my::make_variant<A,B,C>(a)`, given that the actual
    class constructor can be spelled more concisely than that: `std::variant<A,B,C>(a)`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以使用 `std::make_tuple` 创建一个元组对象，或者使用 `make_pair` 创建一个对，你可能会合理地问：“`make_variant`
    呢？”实际上，并没有这样的函数。它不存在的主要原因在于，虽然 `tuple` 和 `pair` 是积类型，但 `variant` 是和类型。要创建一个元组，你必须始终提供其所有
    *n* 个元素的值，因此元素类型总是可以推断出来的。对于 `variant`，你只需要提供其一个值——假设为类型 `A`——但编译器在不知道类型 `B` 和
    `C` 的身份的情况下，无法创建一个 `variant<A,B,C>` 对象。因此，提供 `my::make_variant<A,B,C>(a)` 这样的函数是没有意义的，因为实际的类构造函数可以更简洁地写成：`std::variant<A,B,C>(a)`。
- en: 'We have already alluded to the secondary reason for the existence of `make_pair`
    and `make_tuple`: They automatically decay the special vocabulary type `std::reference_wrapper<T>`
    into `T&`, so that `std::make_pair(std::ref(a), std::cref(b))` creates an object
    of type `std::pair<A&, const B&>`. Objects of "pair-of-reference" or "tuple-of-reference"
    type behave very strangely: you can compare and copy them with the usual semantics,
    but when you assign to an object of this type, rather than "rebinding" the reference
    elements (so that they refer to the objects on the right-hand side), the assignment
    operator actually "assigns through," changing the values of the referred-to objects.
    As we saw in the code sample in section "Working with `std::tuple`", this deliberate
    oddity allows us to use `std::tie` as a sort of "multiple assignment" statement.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了`make_pair`和`make_tuple`存在的次要原因：它们自动将特殊词汇类型`std::reference_wrapper<T>`衰减为`T&`，因此`std::make_pair(std::ref(a),
    std::cref(b))`创建了一个类型为`std::pair<A&, const B&>`的对象。具有“引用对”或“引用元组”类型的对象表现得非常奇怪：你可以使用通常的语义比较和复制它们，但当你将值赋给这种类型的对象时，而不是“重新绑定”引用元素（以便它们引用右侧的对象），赋值运算符实际上“通过”赋值，改变所引用对象的值。正如我们在“使用`std::tuple`”部分的代码示例中所看到的，这种故意的奇怪性允许我们使用`std::tie`作为一种“多重赋值”语句。
- en: So another reason that we might expect or desire to see a `make_variant` function
    in the standard library would be for its reference-decaying ability. However,
    this is a moot point for one simple reason--the standard forbids making variants
    whose elements are reference types! We will see later in this chapter that `std::optional`
    and `std::any` are likewise forbidden from holding reference types. (However,
    `std::variant<std::reference_wrapper<T>, ...>` is perfectly legitimate.) This
    prohibition comes because the designers of the library have not come to a consensus
    as to what a variant of references should mean. Or, for that matter, what a *tuple*
    of references should mean! only reason we have tuples of references in the language
    today is because `std::tie` seemed like such a good idea in 2011\. In 2017, nobody
    is particularly eager to compound the confusion by introducing variants, optionals,
    or "anys" of references.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可能期望或希望看到标准库中有一个`make_variant`函数的另一个原因可能是它的引用衰减能力。然而，这仅仅是因为一个简单的原因——标准禁止创建元素为引用类型的变体！我们将在本章后面看到，`std::optional`和`std::any`同样被禁止持有引用类型。（然而，`std::variant<std::reference_wrapper<T>,
    ...>`是完全合法的。）这种禁止的原因是库的设计者还没有就引用的变体应该意味着什么达成共识。或者，更确切地说，一个引用的*元组*应该意味着什么！我们今天在语言中拥有引用元组的原因仅仅是因为`std::tie`在2011年看起来是一个非常好的主意。到了2017年，没有人特别渴望通过引入变体、可选或引用的“任何”来增加混淆。
- en: 'We have established that a `std::variant<A,B,C>` always holds exactly one value
    of type `A`, `B`, or `C`--no more and no less. Well, that''s not technically correct.
    *Under very unusual circumstances,* it is possible to construct a variant with
    no value whatsoever. The only way to make this happen is to construct the variant
    with a value of type `A`, and then assign it a value of type `B` in such a way
    that the `A` is successfully destroyed but the constructor `B` throws an exception
    and the `B` is never actually emplaced. When this happens, the variant object
    enters a state known as "valueless by exception":'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了`std::variant<A,B,C>`始终恰好持有类型`A`、`B`或`C`的一个值——不多也不少。嗯，这实际上并不完全正确。*在非常罕见的情况下，*有可能构造一个没有任何值的变体。唯一使这种情况发生的方法是使用类型`A`的值来构造变体，然后以这种方式给它分配一个类型`B`的值，即`A`被成功销毁，但构造函数`B`抛出异常，而`B`实际上从未被放置。当这种情况发生时，变体对象进入一个被称为“无值异常”的状态：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will never happen to you, unless you are writing code where your constructors
    or conversion operators throw exceptions. Furthermore, by using `operator=` instead
    of `emplace`, you can avoid valueless variants in every case except when you have
    a move constructor that throws:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况永远不会发生在你身上，除非你正在编写构造函数或转换运算符会抛出异常的代码。此外，通过使用`operator=`而不是`emplace`，你可以避免在除了你有抛出异常的移动构造函数之外的所有情况下出现无值的变体：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Recall from the discussion of `std::vector` in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, that your types' move constructors should always be marked
    `noexcept`; so, if you follow that advice religiously, you'll be able to avoid
    dealing with `valueless_by_exception` at all.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)“容器动物园”中关于`std::vector`的讨论中回忆起来，你的类型的移动构造函数应该始终标记为`noexcept`；因此，如果你虔诚地遵循这条建议，你将能够完全避免处理`valueless_by_exception`。
- en: Anyway, when a variant *is* in this state, its `index()` method returns `size_t(-1)`
    (a constant also known as `std::variant_npos`) and any attempt to `std::visit`
    it will throw an exception of type `std::bad_variant_access`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，当一个变体处于这种状态时，它的`index()`方法返回`size_t(-1)`（一个也称为`std::variant_npos`的常量）并且任何尝试`std::visit`它的操作都将抛出一个类型为`std::bad_variant_access`的异常。
- en: Delaying initialization with std::optional
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`std::optional`延迟初始化
- en: 'You might already be thinking that one potential use for `std::variant` would
    be to represent the notion of "Maybe I have an object, and maybe I don''t." For
    example, we could represent the "maybe I don''t" state using the standard tag
    type `std::monostate`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在想，`std::variant`的一个潜在用途可能是表示“也许我有一个对象，也许我没有。”例如，我们可以使用标准的标签类型`std::monostate`来表示“也许我没有”的状态：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You'll be pleased to know that this is *not* the best way to accomplish that
    goal! The standard library provides the *vocabulary type* `std::optional<T>` specifically
    to deal with the notion of "maybe I have an object, maybe I don't."
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很高兴地知道，这*不是*实现该目标的最佳方式！标准库提供了专门用于处理“也许我有一个对象，也许我没有”这一概念的*vocabulary type*
    `std::optional<T>`。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the logic of algebraic data types, `std::optional<T>` is a sum type: it
    has exactly as many possible values as `T` does, plus one. This one additional
    value is called the "null," "empty," or "disengaged" state, and is represented
    in source code by the special constant `std::nullopt`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数数据类型的逻辑中，`std::optional<T>`是一个和类型：它具有与`T`一样多的可能值，再加上一个。这个额外值被称为“null”，“empty”或“disengaged”状态，并在源代码中由特殊常量`std::nullopt`表示。
- en: Do not confuse `std::nullopt` with the similarly named `std::nullptr`! They
    have nothing in common except that they're both vaguely null-ish.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将`std::nullopt`与同名的`std::nullptr`混淆！它们除了都是模糊的null-like之外，没有共同之处。
- en: Unlike `std::tuple` and `std::variant` with their mess of free (non-member)
    functions, the `std::optional<T>` class is full of convenient member functions.
    `o.has_value()` is true if the optional object `o` currently holds a value of
    type `T`. The "has-value" state is commonly known as the "engaged" state; an optional
    object containing a value is "engaged" and an optional object in the empty state
    is "disengaged."
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有混乱的免费（非成员）函数的`std::tuple`和`std::variant`不同，`std::optional<T>`类充满了方便的成员函数。`o.has_value()`为真，如果可选对象`o`当前持有类型为`T`的值。通常将“有值”状态称为“参与”状态；包含值的可选对象是“参与”的，而处于空状态的可选对象是“分离”的。
- en: The comparison operators `==`, `!=`, `<`, `<=`, `>`, and `>=` are all overloaded
    for `optional<T>` if they are valid for `T`. To compare two optionals, or to compare
    an optional to a value of type `T`, all you need to remember is that an optional
    in the disengaged state compares "less than" any real value of `T`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比较运算符`==`, `!=`, `<`, `<=`, `>`, 和 `>=`对于`T`是有效的，那么它们都会为`optional<T>`重载。要比较两个可选对象，或者将一个可选对象与类型为`T`的值进行比较，你需要记住的是，在分离状态下，可选对象与`T`的任何实际值比较时都“小于”。
- en: '`bool(o)` is a synonym for `o.has_value()`, and `!o` is a synonym for `!o.has_value()`.
    Personally, I recommend that you always use `has_value`, since there''s no difference
    in runtime cost; the only difference is in the readability of your code. If you
    do use the abbreviated conversion-to-`bool` form, be aware that for a `std::optional<bool>`,
    `o == false` and `!o` mean very different things!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(o)`是`o.has_value()`的同义词，而`!o`是`!o.has_value()`的同义词。我个人建议你始终使用`has_value`，因为它们在运行时成本上没有区别；唯一的区别在于代码的可读性。如果你确实使用了简化的转换到`bool`的形式，请注意，对于`std::optional<bool>`，`o
    == false`和`!o`意味着非常不同的事情！'
- en: '`o.value()` returns a reference to the value contained by `o`. If `o` is currently
    disengaged, then `o.value()` throws an exception of type `std::bad_optional_access`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.value()`返回一个指向`o`包含的值的引用。如果`o`当前处于分离状态，则`o.value()`会抛出一个类型为`std::bad_optional_access`的异常。'
- en: '`*o` (using the overloaded unary `operator*`) returns a reference to the value
    contained by `o`, without checking for engagement. If `o` is currently disengaged
    and you call `*o`, that''s undefined behavior, just as if you called `*p` on a
    null pointer. You can remember this behavior by noticing that the C++ standard
    library likes to use punctuation for its most efficient, least sanity-checked
    operations. For example, `std::vector::operator[]` does less bounds-checking than
    `std::vector::at()`. Therefore, by the same logic, `std::optional::operator*`
    does less bounds-checking than `std::optional::value()`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重载的单目运算符 `operator*`，`*o` 返回 `o` 包含的值的引用，而不检查是否已连接。如果 `o` 当前未连接，并且你调用 `*o`，则这是未定义的行为，就像你调用
    `*p` 在空指针上一样。你可以通过注意 C++ 标准库喜欢使用标点符号来表示其最有效、最少检查理智的操作来记住这种行为。例如，`std::vector::operator[]`
    的边界检查比 `std::vector::at()` 少。因此，按照同样的逻辑，`std::optional::operator*` 的边界检查比 `std::optional::value()`
    少。
- en: '`o.value_or(x)` returns a copy of the value contained by `o`, or, if `o` is
    disengaged, it returns a copy of `x` converted to type `T`. We can use `value_or`
    to rewrite the preceding code sample into a one-liner of utter simplicity and
    readability:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.value_or(x)` 返回 `o` 包含的值的副本，或者如果 `o` 未连接，则返回将 `x` 转换为类型 `T` 的副本。我们可以使用 `value_or`
    将前面的代码示例重写为一行简单且易于阅读的代码：'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding examples have shown how to use `std::optional<T>` as a way to
    handle "maybe a `T`" in flight (as a function return type, or as a parameter type).
    Another common and useful way to use `std::optional<T>` is as a way to handle
    "not yet a `T`" at rest, as a class data member. For example, suppose we have
    some type `L` which is not default-constructible, such as the closure type produced
    by a lambda expression:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子已经展示了如何使用 `std::optional<T>` 作为处理“可能是一个 `T`”在飞行中的方式（作为函数返回类型或参数类型）。另一种常见且有用的使用
    `std::optional<T>` 的方式是作为处理“尚未是一个 `T`”在静止中的方式，作为类数据成员。例如，假设我们有一些类型 `L`，它不是默认可构造的，例如由
    lambda 表达式产生的闭包类型：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then a class with a member of that type would also fail to be default-constructible:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，具有该类型成员的类也将无法默认构造：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But, by giving our class a member of type `std::optional<L>`, we allow it to
    be used in contexts that require default-constructibility:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过向我们的类提供一个类型为 `std::optional<L>` 的成员，我们允许它在需要默认构造性的上下文中使用：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It would be very difficult to implement this behavior without `std::optional`.
    You could do it with placement-new syntax, or using a `union`, but essentially
    you'd have to reimplement at least half of `optional` yourself. Much better to
    use `std::optional`!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `std::optional`，要实现这种行为是非常困难的。你可以使用 placement-new 语法或使用 `union` 来做，但本质上你必须至少重新实现
    `optional` 的一半。使用 `std::optional` 会更好！
- en: And notice that if for some reason we wanted to get undefined behavior instead
    of the possibility of throwing from `call()`, we could just replace `fn_.value()`
    with `*fn_`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果出于某种原因我们想要得到未定义的行为而不是从 `call()` 抛出异常的可能性，我们只需将 `fn_.value()` 替换为 `*fn_`。
- en: '`std::optional` is truly one of the biggest wins among the new features of
    C++17, and you''ll benefit immensely by getting familiar with it.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional` 真的是 C++17 新特性中最大的胜利之一，通过熟悉它，你将受益匪浅。'
- en: 'From `optional`, which could be described as a sort of limited one-type `variant`,
    we now approach the other extreme: the algebraic-data-type equivalent of *infinity*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `optional`，可以将其描述为一种有限的单类型 `variant`，我们现在转向另一个极端：无限代数数据类型的等价物。
- en: Revisiting variant
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重访变体
- en: 'The `variant` data type is good at representing simple alternatives, but as
    of C++17, it is not particularly suitable for representing *recursive* data types
    such as JSON lists. That is, the following C++17 code will fail to compile:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant` 数据类型擅长表示简单的选择，但截至 C++17，它并不特别适合表示如 JSON 列表之类的递归数据类型。也就是说，以下 C++17
    代码将无法编译：'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are several possible workarounds. The most robust and correct is to continue
    using the C++11 Boost library `boost::variant`, which specifically supports recursive
    variant types via the marker type `boost::recursive_variant_`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的解决方案。最稳健和正确的方法是继续使用 C++11 的 Boost 库 `boost::variant`，该库通过标记类型 `boost::recursive_variant_`
    特定地支持递归变体类型：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You could also get around the problem by introducing a new class type called
    `JSONValue`, which either **HAS-A** or **IS-A** `std::variant` of the recursive
    type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过引入一个新的类类型 `JSONValue` 来解决这个问题，该类型要么 **包含** 要素，要么 **是** 递归类型的 `std::variant`。
- en: Notice that in the following example I chose HAS-A rather than IS-A; inheriting
    from non-polymorphic standard library types is almost always a really bad idea.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在下面的例子中，我选择了HAS-A而不是IS-A；从非多态的标准库类型继承几乎总是一个非常糟糕的想法。
- en: 'Since forward references to class types are acceptable to C++, this will compile:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++接受对类类型的转发引用，这将编译：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The final possibility is to switch to an algebraic type from the standard library
    that is even more powerful than `variant`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的可能性是切换到标准库中的一个比`variant`更强大的代数类型。
- en: Infinite alternatives with std::any
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::any的无限备选方案
- en: To paraphrase Henry Ford, an object of type `std::variant<A, B, C>` can hold
    a value
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用亨利·福特的话来说，类型为`std::variant<A, B, C>`的对象可以存储一个值
- en: of any type--as long as it's `A`, `B`, or `C`. But suppose we wanted to hold
    a value of *truly* any type? Perhaps our program will load plugins at runtime
    that might contain new types impossible to predict. We can't specify those types
    in a `variant`. Or perhaps we are in the "recursive data type" situation detailed
    in the preceding section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型--只要它是`A`、`B`或`C`。但是，假设我们想要存储一个*真正*任何类型的值？也许我们的程序将在运行时加载插件，这些插件可能包含无法预测的新类型。我们无法在`variant`中指定这些类型。或者，也许我们处于前一节详细描述的“递归数据类型”情况。
- en: 'For these situations, the C++17 standard library provides an algebraic-data-type
    version of "infinity": the type `std::any`. This is a sort of a container (see
    [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container
    Zoo*) for a single object of any type at all. The container may be empty, or it
    may contain an object. You can perform the following fundamental operations on
    an `any` object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，C++17标准库提供了一个代数数据类型的“无穷大”版本：类型`std::any`。这是一种容器（见[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，*容器动物园*），用于存储任何类型的单个对象。容器可能是空的，也可能包含一个对象。您可以对`any`对象执行以下基本操作：
- en: Ask if it currently holds an object
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问它当前是否持有对象
- en: Put a new object into it (destroying the old object, whatever it was)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其中放入一个新的对象（销毁旧对象，无论它是什么）
- en: Ask the type of the held object
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问所持有对象的类型
- en: Retrieve the held object, by correctly naming its type
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过正确命名其类型来检索所持有的对象
- en: 'In code the first three of these operations look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这三个操作的前三个看起来像这样：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The fourth operation is a little more fiddly. It is spelled `std::any_cast`,
    and, like `std::get` for variants, it comes in two flavors: a `std::get`-like
    flavor that throws `std::bad_any_cast` on failure, and a `std::get_if`-like flavor
    that returns a null pointer on failure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种操作稍微有些复杂。它被称作`std::any_cast`，并且，就像`std::get`对变体一样，它有两种风味：一种类似于`std::get`的风味，在失败时抛出`std::bad_any_cast`异常，以及一种类似于`std::get_if`的风味，在失败时返回一个空指针：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Observe that in either case, you must name the type that you want to retrieve
    from the `any` object. If you get the type wrong, then you'll get an exception
    or a null pointer. There is no way to say "Give me the held object, no matter
    what type it is," since then what would be the type of that expression?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在两种情况下，您都必须命名您想要从`any`对象中检索的类型。如果您类型错误，那么您将得到一个异常或空指针。没有办法说“给我一个所持有的对象，无论它的类型是什么”，因为那样这个表达式的类型又是什么呢？
- en: 'Recall that when we faced a similar problem with `std::variant` in the preceding
    section, we solved it by using `std::visit` to visit some generic code onto the
    held alternative. Unfortunately, there is no equivalent `std::visit` for `any`.
    The reason is simple and insurmountable: separate compilation. Suppose in one
    source file, `a.cc`, I have:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们在前一节遇到与`std::variant`类似的问题时，我们通过使用`std::visit`将一些泛型代码访问到所持有的备选方案上解决了它。不幸的是，对于`any`没有等效的`std::visit`。原因是简单且无法克服的：分离编译。假设在一个源文件`a.cc`中，我有：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And in another source file, `b.cc`, (perhaps compiled into a different plugin,
    `.dll`, or shared object file) I have:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个源文件`b.cc`中（可能编译成不同的插件，`.dll`或共享对象文件）我有：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How should the compiler know, when compiling `b.cc`, that it needs to output
    a template instantiation for `size(Widget<int>&)` as opposed to, let's say, `size(Widget<double>&)`?
    When someone changes `a.cc` to return `make_any(Widget<char>&)`, how should the
    compiler know that it needs to recompile `b.cc` with a fresh instantiation of
    `size(Widget<char>&)` and that the instantiation of `size(Widget<int>&)` is no
    longer needed--unless of course we're anticipating being linked against a `c.cc`
    that *does* require that instantiation! Basically, there's no way for the compiler
    to figure out what kind of code-generation might possibly be needed by visitation,
    on a container that can by definition contain *any* type and trigger *any* code-generation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译 `b.cc` 时，编译器如何知道它需要输出 `size(Widget<int>&)` 的模板实例化，而不是，比如说，`size(Widget<double>&)`？当有人将
    `a.cc` 改为返回 `make_any(Widget<char>&)` 时，编译器应该如何知道它需要使用新的 `size(Widget<char>&)`
    实例重新编译 `b.cc`，而 `size(Widget<int>&)` 的实例不再需要——除非我们预计要链接到一个确实需要该实例化的 `c.cc`！基本上，编译器无法确定在可以定义为包含任何类型并触发任何代码生成的容器上，可能需要什么样的代码生成。
- en: Therefore, in order to extract any function of the contained value of an `any`,
    you must know up front what the type of that contained value might be. (And if
    you guess wrong--go fish!)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了提取 `any` 中包含值的任何函数，你必须事先知道该包含值的类型可能是什么。（如果你猜错了——去钓鱼吧！）
- en: std::any versus polymorphic class types
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::any` 与多态类类型'
- en: '`std::any` occupies a position in between the compile-time polymorphism of
    `std::variant<A, B, C>` and the runtime polymorphism of polymorphic inheritance
    hierarchies and `dynamic_cast`. You might wonder whether `std::any` interacts
    with the machinery of `dynamic_cast` at all. The answer is "no, it does not"--nor
    is there any standard way to get that behavior. `std::any` is one hundred percent
    statically type-safe: there is no way to break into it and get a "pointer to the
    data" (for example, a `void *`) without knowing the exact static type of that
    data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any` 处于 `std::variant<A, B, C>` 的编译时多态和具有多态继承层次结构和 `dynamic_cast` 的运行时多态之间。你可能想知道
    `std::any` 是否与 `dynamic_cast` 的机制有任何交互。答案是“没有，它没有”——也没有任何标准方法来获得这种行为。`std::any`
    是百分之百的静态类型安全：没有方法可以突破它并获得“指向数据的指针”（例如，`void *`），除非你知道数据的确切静态类型：'
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Type erasure in a nutshell
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，类型擦除
- en: Let's look briefly at how `std::any` might be implemented by the standard library.
    The core idea is called "type erasure," and the way we achieve it is to identify
    the salient or relevant operations that we want to support for *all* types `T`,
    and then "erase" every other idiosyncratic operation that might be supported by
    any specific type `T`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看标准库如何实现 `std::any`。其核心思想被称为“类型擦除”，我们实现它的方法是通过识别我们想要支持的所有类型 `T` 的显著或相关操作，然后“擦除”任何特定类型
    `T` 可能支持的任何其他独特操作。
- en: 'For `std::any`, the salient operations are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `std::any`，其显著的操作如下：
- en: Constructing a copy of the contained object
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移动构造包含对象
- en: Constructing a copy of the contained object "by move"
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移动构造包含对象
- en: Getting `typeid` of the contained object
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取包含对象的 `typeid`
- en: Construction and destruction are also required, but those two operations are
    concerned with the lifetime management of the contained object itself, not "what
    you can do with it," so at least in this case we don't need to consider them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 构造和销毁也是必需的，但这两个操作与包含对象本身的生存期管理有关，而不是“你可以用它做什么”，所以至少在这个情况下，我们不需要考虑它们。
- en: 'So we invent a polymorphic class type (call it `AnyBase`) which supports only
    those three operations as overrideable `virtual` methods, and then we create a
    brand-new derived class (call it `AnyImpl<T>`) each time the programmer actually
    stores an object of a specific type `T` into `any`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们发明了一个支持仅这三种操作的多态类类型（称之为 `AnyBase`），这些操作作为可重写的 `virtual` 方法，然后每次程序员实际上将特定类型
    `T` 的对象存储到 `any` 中时，我们创建一个新的派生类（称之为 `AnyImpl<T>`）：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With these helper classes, the code to implement `std::any` becomes fairly
    trivial, especially when we use a smart pointer (see [Chapter 6](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d),
    *Smart Pointers*) to manage the lifetime of our `AnyImpl<T>` object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些辅助类，实现 `std::any` 的代码变得相当简单，尤其是当我们使用智能指针（见第 6 章，*智能指针*）来管理 `AnyImpl<T>`
    对象的生存期时：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code sample omits the implementation of move-assignment. It can
    be done in the same way as copy-assignment, or it can be done by simply swapping
    the pointers. The standard library actually prefers to swap pointers when possible,
    because that is guaranteed to be `noexcept`; the only reason that you might see
    `std::any` *not* swapping pointers is if it uses a "small object optimization"
    to avoid heap allocation altogether for very small, nothrow-move-constructible
    types `T`. As of this writing, libstdc++ (the library used by GCC) will use small
    object optimization and avoid heap allocation for types up to 8 bytes in size;
    libc++ (the library used by Clang) will use small object optimization for types
    up to 24 bytes in size.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例省略了移动赋值的实现。它可以像复制赋值一样完成，或者可以通过简单地交换指针来完成。标准库实际上在可能的情况下更喜欢交换指针，因为这保证是
    `noexcept`；你可能会看到 `std::any` 不交换指针的唯一原因可能是它使用“小对象优化”来避免为非常小的、不可抛出移动构造的类型 `T` 进行堆分配。截至本文撰写时，libstdc++（GCC
    使用的库）将使用小对象优化，并避免为大小最多为 8 字节类型的堆分配；libc++（Clang 使用的库）将使用小对象优化，适用于大小最多为 24 字节类型的类型。
- en: Unlike the standard containers discussed in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, `std::any` does *not* take an allocator parameter and does
    *not* allow you to customize or configure the source of its heap memory. If you
    use C++ on a real-time or memory-constrained system where heap allocation is not
    allowed, then you should not use `std::any`. Consider an alternative such as Tiemo
    Jung's `tj::inplace_any<Size, Alignment>`. If all else fails, you have now seen
    how to roll your own!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与第 4 章中讨论的标准容器不同，[《容器动物园》](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，`std::any`
    不接受分配器参数，也不允许你自定义或配置其堆内存的来源。如果你在实时或内存受限的系统上使用 C++，其中不允许堆分配，那么你不应该使用 `std::any`。考虑一个替代方案，例如
    Tiemo Jung 的 `tj::inplace_any<Size, Alignment>`。如果所有其他方法都失败了，你现在已经看到了如何自己实现它！
- en: std::any and copyability
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::any 和可复制性
- en: 'Notice that our definition of `AnyImpl<T>::copy_to` required `T` to be copy-constructible.
    This is true of the standard `std::any` as well; there is simply no way to store
    a move-only type into a `std::any` object. The way to work around this is with
    a sort of a "shim" wrapper, whose purpose is to make its move-only object conform
    to the syntactic requirement of copy-constructibility while eschewing any actual
    copying:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的 `AnyImpl<T>::copy_to` 定义要求 `T` 可复制构造。这对于标准的 `std::any` 也是正确的；没有方法可以将移动唯一类型存储到
    `std::any` 对象中。绕过这个问题的方法是使用一种“适配器”包装器，其目的是使其移动唯一对象符合可复制构造的语法要求，同时避免任何实际的复制：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice the use of `std::optional<T>` in the preceding code sample; this guards
    our fake copy constructor against the possibility that `T` might not be default-constructible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前一个代码示例中 `std::optional<T>` 的使用；这保护了我们的假复制构造函数免受 `T` 可能不可默认构造的可能性。
- en: 'Again with the type erasure: std::function'
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次提到类型擦除：std::function
- en: 'We observed that for `std::any`, the salient operations were as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到对于 `std::any`，显著的操作如下：
- en: Constructing a copy of the contained object
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包含对象的副本
- en: Constructing a copy of the contained object "by move"
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移动构造函数构建包含对象的副本
- en: Getting the `typeid` of the contained object
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取包含对象的 `typeid`
- en: 'Suppose we were to add one to this set of salient operations? Let''s say our
    set is:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要添加一个到这组显著的操作中？让我们说我们的集合是：
- en: Constructing a copy of the contained object
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包含对象的副本
- en: Constructing a copy of the contained object "by move"
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移动构造函数构建包含对象的副本
- en: Getting the `typeid` of the contained object
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取包含对象的 `typeid`
- en: Calling the contained object with a particular fixed sequence of argument types
    `A...`, and converting the result to some particular fixed type `R`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定的固定参数类型序列 `A...` 调用包含的对象，并将结果转换为某种特定的固定类型 `R`
- en: The type-erasure of this set of operations corresponds to the standard library
    type `std::function<R(A...)>`!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这组操作的类型擦除对应于标准库类型 `std::function<R(A...)>`！
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Copying `std::function` always makes a copy of the contained object, if the
    contained object has state. Of course if the contained object is a function pointer,
    you won''t observe any difference; but you can see the copying happen if you try
    it with an object of user-defined class type, or with a stateful lambda:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含的对象具有状态，则复制 `std::function` 总是会复制包含的对象。当然，如果包含的对象是函数指针，你不会观察到任何差异；但如果你尝试使用用户定义类类型的对象或具有状态的
    lambda 表达式，你可以看到复制发生：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Just as with `std::any`, `std::function<R(A...)` allows you to retrieve the
    `typeid` of the contained object, or to retrieve a pointer to the object itself
    as long as you statically know (or can guess) its type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `std::any` 一样，`std::function<R(A...)` 允许你检索包含对象的 `typeid`，或者如果你静态地知道（或可以猜测）其类型，可以检索指向该对象的指针：
- en: '`f.target_type()` is the equivalent of `a.type()`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f.target_type()` 等同于 `a.type()`'
- en: '`f.target<T>()` is the equivalent of `std::any_cast<T*>(&a)`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f.target<T>()` 等同于 `std::any_cast<T*>(&a)`'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That said, I have never seen a use-case for these methods in real life. Generally,
    if you have to ask what the contained type of a `std::function` is, you've already
    done something wrong.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我在现实生活中从未见过这些方法的实际用例。通常，如果你必须询问 `std::function` 的包含类型，那么你已经做错了什么。
- en: 'The most important use-case for `std::function` is as a vocabulary type for
    passing "behaviors" across module boundaries, where using a template would be
    impossible--for example, when you need to pass a callback to a function in an
    external library, or when you''re writing a library that needs to receive a callback
    from its caller:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::function` 最重要的用例是作为跨越模块边界的“行为”传递的词汇类型，在这种情况下使用模板是不可能的——例如，当你需要将回调传递给外部库中的函数时，或者当你编写需要从其调用者接收回调的库时：'
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We started this chapter talking about `std::string`, the standard vocabulary
    type for passing strings between functions; now, as the end of the chapter draws
    near, we're talking about `std::function`, the standard vocabulary type for passing
    *functions* between functions!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时讨论了 `std::string`，这是在函数之间传递字符串的标准词汇类型；现在，随着本章的结束，我们正在讨论 `std::function`，这是在函数之间传递
    *函数* 的标准词汇类型！
- en: std::function, copyability, and allocation
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::function, 可复制性和分配
- en: 'Just like `std::any`, `std::function` requires that whatever object you store
    in it must be copy-constructible. This can present a problem if you are using
    a lot of lambdas that capture `std::future<T>`, `std::unique_ptr<T>`, or other
    move-only types: such lambda types will be move-only themselves. One way to fix
    that was demonstrated in the *std::any and copyability* section in this chapter:
    we could introduce a shim that is syntactically copyable but throws an exception
    if you try to copy it.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `std::any` 一样，`std::function` 要求存储在其内的任何对象都必须是可复制的。如果你使用了很多捕获 `std::future<T>`、`std::unique_ptr<T>`
    或其他只能移动的类型（move-only types）的 lambda 表达式，这可能会带来问题：这样的 lambda 类型本身也将是只能移动的。解决这个问题的一种方法在本章的
    *std::any and copyability* 部分已经演示过：我们可以引入一个在语法上可复制的适配器（shim），但如果你尝试复制它，它会抛出一个异常。
- en: 'When working with `std::function` and lambda captures, it might often be preferable
    to capture your move-only lambda captures by `shared_ptr`. We''ll cover `shared_ptr`
    in the next chapter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `std::function` 和 lambda 捕获一起工作时，可能更倾向于通过 `shared_ptr` 捕获只能移动的 lambda 捕获。我们将在下一章介绍
    `shared_ptr`：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Like `std::any`, `std::function` does *not* take an allocator parameter and
    does *not* allow you to customize or configure the source of its heap memory.
    If you use C++ on a real-time or memory-constrained system where heap allocation
    is not allowed, then you should not use `std::function`. Consider an alternative
    such as Carl Cook's `sg14::inplace_function<R(A...), Size, Alignment>`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `std::any` 一样，`std::function` 不接受分配器参数，也不允许你自定义或配置其堆内存的来源。如果你在实时或内存受限的系统上使用
    C++，其中不允许堆分配，那么你不应该使用 `std::function`。考虑使用如 Carl Cook 的 `sg14::inplace_function<R(A...),
    Size, Alignment>` 这样的替代方案。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Vocabulary types like `std::string` and `std::function` allow us to share a
    *lingua franca* for dealing with common programming concepts. In C++17, we have
    a rich set of vocabulary types for dealing with the *algebraic data types*: `std::pair`
    and `std::tuple` (product types), `std::optional` and `std::variant` (sum types),
    and `std::any` (the ultimate in sum types--it can store almost anything). However,
    don''t get carried away and start using `std::tuple` and `std::variant` return
    types from every function! Named class types are still the most effective way
    to keep your code readable.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `std::string` 和 `std::function` 这样的词汇类型（vocabulary types）允许我们共享一个 *通用语言*
    来处理常见的编程概念。在 C++17 中，我们有一套丰富的词汇类型来处理 *代数数据类型*：`std::pair` 和 `std::tuple`（积类型），`std::optional`
    和 `std::variant`（和类型），以及 `std::any`（和类型的终极形式——它可以存储几乎任何东西）。然而，不要沉迷于使用 `std::tuple`
    和 `std::variant` 作为每个函数的返回类型！命名类类型仍然是保持代码可读性最有效的方法。
- en: Use `std::optional` to signal the possible lack of a value, or to signal the
    "not-yet-ness" of a data member.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::optional` 来表示可能缺少的值，或者表示数据成员的“尚未存在”状态。
- en: Use `std::get_if<T>(&v)` to query the type of a `variant`; use `std::any_cast<T>(&a)`
    to query the type of an `any`. Remember that the type you provide must be an exact
    match; if it's not, you'll get `nullptr`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::get_if<T>(&v)` 来查询 `variant` 的类型；使用 `std::any_cast<T>(&a)` 来查询 `any`
    的类型。请记住，您提供的类型必须与目标类型完全匹配；如果不匹配，您将得到 `nullptr`。
- en: Be aware that `make_tuple` and `make_pair` do more than construct `tuple` and
    `pair` objects; they also decay `reference_wrapper` objects into native references.
    Use `std::tie` and `std::forward_as_tuple` to create tuples of references. `std::tie`
    is particularly useful for multiple assignment and for writing comparison operators.
    `std::forward_as_tuple` is useful for metaprogramming.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`make_tuple` 和 `make_pair` 不仅构造 `tuple` 和 `pair` 对象；它们还将 `reference_wrapper`
    对象解引用为原生引用。使用 `std::tie` 和 `std::forward_as_tuple` 来创建引用的元组。`std::tie` 特别适用于多重赋值和编写比较运算符。`std::forward_as_tuple`
    对于元编程很有用。
- en: 'Be aware that `std::variant` always has the possibility of being in a "valueless
    by exception" state; but know that you don''t have to worry about that case unless
    you write classes with throwing move-constructors. Separately: don''t write classes
    with throwing move-constructors!'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`std::variant` 总是有可能处于“异常无值”状态；但要知道，除非您编写具有抛出移动构造函数的类，否则您不必担心这种情况。另外：不要编写具有抛出移动构造函数的类！
- en: Be aware that the *type-erased* types `std::any` and `std::function` implicitly
    use the heap. Third-party libraries provide non-standard `inplace_` versions of
    these types. Be aware that `std::any` and `std::function` require copyability
    of their contained types. Use "capture by `shared_ptr`" to deal with this case
    if it arises.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类型擦除的类型 `std::any` 和 `std::function` 隐式地使用了堆。第三方库提供了这些类型的非标准 `inplace_`
    版本。请注意，`std::any` 和 `std::function` 要求其包含的类型必须是可复制的。如果出现这种情况，请使用 "通过 `shared_ptr`
    捕获" 来处理。
