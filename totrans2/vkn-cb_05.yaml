- en: Descriptor Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符集
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a sampler
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建采样器
- en: Creating a sampled image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建采样图像
- en: Creating a combined image sampler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组合图像采样器
- en: Creating a storage image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储镜像
- en: Creating a uniform texel buffer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建统一纹理缓冲区
- en: Creating a storage texel buffer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储纹理缓冲区
- en: Creating a uniform buffer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建统一缓冲区
- en: Creating a storage buffer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储缓冲区
- en: Creating an input attachment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建输入附加
- en: Creating a descriptor set layout
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建描述符集布局
- en: Creating a descriptor pool
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建描述符池
- en: Allocating descriptor sets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配描述符集
- en: Updating descriptor sets
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新描述符集
- en: Binding descriptor sets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定描述符集
- en: Creating descriptors with a texture and a uniform buffer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理和统一缓冲区创建描述符
- en: Freeing descriptor sets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放描述符集
- en: Resetting a descriptor pool
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置描述符池
- en: Destroying a descriptor pool
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁描述符池
- en: Destroying a descriptor set layout
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁描述符集布局
- en: Destroying a sampler
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁采样器
- en: Introduction
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In modern computer graphics, most of the rendering and processing of image data
    (such as vertices, pixels, or fragments) is done with a programmable pipeline
    and shaders. Shaders, to operate properly and to generate appropriate results,
    need to access additional data sources such as textures, samplers, buffers, or
    uniform variables. In Vulkan, these are provided through sets of descriptors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机图形学中，大多数图像数据（如顶点、像素或片段）的渲染和处理都是通过可编程管道和着色器完成的。为了正确运行并生成适当的结果，着色器需要访问额外的数据源，如纹理、采样器、缓冲区或统一变量。在Vulkan中，这些通过描述符集提供。
- en: Descriptors are opaque data structures that represent shader resources. They
    are organized into groups or sets and their contents are specified by descriptor
    set layouts. To provide resources to shaders, we bind descriptor sets to pipelines.
    We can bind multiple sets at once. To access resources from within shaders, we
    need to specify from which set and from which location within a set (called a
    **binding**) the given resource is acquired.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是表示着色器资源的不可见数据结构。它们被组织成组或集，其内容由描述符集布局指定。为了向着色器提供资源，我们将描述符集绑定到管道上。我们可以一次绑定多个集。要从着色器内部访问资源，我们需要指定从哪个集以及从集内的哪个位置（称为**绑定**）获取给定的资源。
- en: In this chapter, we will learn about the various descriptor types. We will see
    how to prepare resources (samplers, buffers, and images) so they can be used inside
    shaders. We will also look at how to set up an interface between an application
    and shaders and use resources inside shaders.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习各种描述符类型。我们将了解如何准备资源（采样器、缓冲区和图像），以便它们可以在着色器中使用。我们还将探讨如何设置应用程序和着色器之间的接口，并在着色器中使用资源。
- en: Creating a sampler
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建采样器
- en: Samplers define a set of parameters that control how image data is loaded inside
    shaders (sampled). These parameters include address calculations (that is, wrapping
    or repeating), filtering (linear or nearest), or using mipmaps. To use samplers
    from within shaders, we first need to create them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器定义了一组参数，这些参数控制着色器内部如何加载图像数据（采样）。这些参数包括地址计算（即，环绕或重复）、过滤（线性或最近）或使用米普映射。要从着色器内部使用采样器，我们首先需要创建它们。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take a handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: 'Create a variable of type `VkSamplerCreateInfo` named `sampler_create_info`
    and use the following values for its members:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sampler_create_info`的`VkSamplerCreateInfo`类型变量，并为其成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO` value for `sType`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType`的值为`VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO`'
- en: '`nullptr` value for `pNext`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的值为`nullptr`'
- en: '`0` value for `flags`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的值为`0`'
- en: The desired magnification and minification filtering mode (`VK_FILTER_NEAREST`
    or `VK_FILTER_LINEAR`) for `magFilter` and `minFilter`
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`magFilter`和`minFilter`指定的所需放大和缩小过滤模式（`VK_FILTER_NEAREST`或`VK_FILTER_LINEAR`）
- en: The selected mipmap filtering mode (`VK_SAMPLER_MIPMAP_MODE_NEAREST` or `VK_SAMPLER_MIPMAP_MODE_LINEAR`)
    for `mipmapMode`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`mipmapMode`选择的米普映射过滤模式（`VK_SAMPLER_MIPMAP_MODE_NEAREST`或`VK_SAMPLER_MIPMAP_MODE_LINEAR`）
- en: The selected image addressing mode for image U, V, and W coordinates outside
    of the `0.0 - 1.0` range (`VK_SAMPLER_ADDRESS_MODE_REPEAT``,` `VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT``,`
    `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE``VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`,
    or `VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`) for `addressModeU`, `addressModeV`
    and `addressModeW`
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于图像U、V和W坐标超出`0.0 - 1.0`范围（`VK_SAMPLER_ADDRESS_MODE_REPEAT`、`VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT`、`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`、`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`或`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`）的选定图像寻址模式，对于`addressModeU`、`addressModeV`和`addressModeW`
- en: The desired value to be added to the mipmap level of detail calculations for
    `mipLodBias`
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要添加到mipmap细节级别计算的期望值，对于`mipLodBias`
- en: '`true` value if anisotropic filtering should be enabled or otherwise `false` for
    `anisotropyEnable`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应启用各向异性过滤，则为`true`值，否则对于`anisotropyEnable`为`false`
- en: The maximal value of the anisotropy for `maxAnisotropy`
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`maxAnisotropy`的各向异性最大值
- en: '`true` value if comparison against a reference value should be enabled during
    image lookups or, otherwise `false` for `compareEnable`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在图像查找期间应启用与参考值的比较，则为`true`值，否则对于`compareEnable`为`false`
- en: The selected comparison function applied to the fetched data (`VK_COMPARE_OP_NEVER``,`
    `VK_COMPARE_OP_LESS``,` `VK_COMPARE_OP_EQUAL``,` `VK_COMPARE_OP_LESS_OR_EQUAL``,`
    `VK_COMPARE_OP_GREATER``,` `VK_COMPARE_OP_NOT_EQUAL``,` `VK_COMPARE_OP_GREATER_OR_EQUAL`,
    or `VK_COMPARE_OP_ALWAYS`) for `compareOp`
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于`compareOp`的选定比较函数应用于获取的数据（`VK_COMPARE_OP_NEVER`、`VK_COMPARE_OP_LESS`、`VK_COMPARE_OP_EQUAL`、`VK_COMPARE_OP_LESS_OR_EQUAL`、`VK_COMPARE_OP_GREATER`、`VK_COMPARE_OP_NOT_EQUAL`、`VK_COMPARE_OP_GREATER_OR_EQUAL`或`VK_COMPARE_OP_ALWAYS`）
- en: The minimal and maximal values to clamp the calculated image's level of detail
    value (mipmap number) for `minLod` and `maxLod`
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于`minLod`和`maxLod`的将计算出的图像的细节级别值（mipmap编号）夹断的最小和最大值
- en: One of the predefined border color values (`VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK``,`
    `VK_BORDER_COLOR_INT_TRANSPARENT_BLACK``,` `VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK``,`
    `VK_BORDER_COLOR_INT_OPAQUE_BLACK``,` `VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE`, or
    `VK_BORDER_COLOR_INT_OPAQUE_WHITE`) for `borderColor`
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于`borderColor`的预定义边界颜色值之一（`VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK`、`VK_BORDER_COLOR_INT_TRANSPARENT_BLACK`、`VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK`、`VK_BORDER_COLOR_INT_OPAQUE_BLACK`、`VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE`或`VK_BORDER_COLOR_INT_OPAQUE_WHITE`）
- en: The `true` value if addressing should be performed using the image's dimensions
    or `false` if addressing should use normalized coordinates (in the `0.0`-`1.0`
    range) for `unnormalizedCoordinates`
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果寻址应使用图像的维度，则为`true`值，如果寻址应使用归一化坐标（在`0.0`-`1.0`范围内），则为`false`值，对于`unnormalizedCoordinates`
- en: Create a variable of type `VkSampler` named `sampler` in which the created sampler
    will be stored.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sampler`的`VkSampler`类型变量，其中将存储创建的采样器。
- en: Call `vkCreateSampler( logical_device, &sampler_create_info, nullptr, &sampler
    )` and provide the `logical_device` variable, a pointer to the `sampler_create_info`
    variable, a `nullptr` value, and a pointer to the `sampler` variable.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateSampler(logical_device, &sampler_create_info, nullptr, &sampler)`，并提供`logical_device`变量、`sampler_create_info`变量的指针、`nullptr`值和`sampler`变量的指针。
- en: Make sure the call was successful by checking whether the returned value was
    equal to `VK_SUCCESS`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查返回值是否等于`VK_SUCCESS`来确保调用成功。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Samplers control the way images are read inside shaders. They can be used separately
    or combined with a sampled image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器控制着色器内读取图像的方式。它们可以单独使用或与采样图像结合使用。
- en: Samplers are used for a `VK_DESCRIPTOR_TYPE_SAMPLER` descriptor type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器用于`VK_DESCRIPTOR_TYPE_SAMPLER`描述符类型。
- en: 'Sampling parameters are specified with a variable of type `VkSamplerCreateInfo`
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型为`VkSamplerCreateInfo`的变量指定采样参数，如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This variable is then provided to the function that creates the sampler:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此变量提供给创建采样器的函数：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To specify a sampler inside shaders, we need to create a uniform variable with
    a `sampler` keyword.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在着色器中指定采样器，我们需要创建一个带有`sampler`关键字的统一变量。
- en: 'An example of a GLSL code that uses a sampler, from which SPIR-V assembly can
    be generated, may look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用采样器的GLSL代码示例，从中可以生成SPIR-V汇编，可能看起来像这样：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipe in this chapter:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的以下配方：
- en: '*Destroying a sampler*'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁采样器*'
- en: Creating a sampled image
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个采样图像
- en: Sampled images are used to read data from images (textures) inside shaders.
    Usually, they are used together with samplers. And to be able to use an image
    as a sampled image, it must be created with a `VK_IMAGE_USAGE_SAMPLED_BIT` usage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 采样图像用于在着色器内部读取图像（纹理）中的数据。通常，它们与采样器一起使用。为了能够将图像用作采样图像，它必须使用`VK_IMAGE_USAGE_SAMPLED_BIT`使用创建。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a physical device stored in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为`physical_device`的`VkPhysicalDevice`类型变量中的物理设备的句柄。
- en: Select a format that will be used for an image. Initialize a variable of type
    `VkFormat` named `format` with the selected image format.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用于图像的格式。使用所选的图像格式初始化一个名为`format`的`VkFormat`类型变量。
- en: Create a variable of type `VkFormatProperties` named `format_properties`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`format_properties`的`VkFormatProperties`类型变量。
- en: Call `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )`, for which to provide the `physical_device` variable, the `format` variable,
    and a pointer to the `format_properties` variable.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )`，为它提供`physical_device`变量、`format`变量和`format_properties`变量的指针。
- en: Make sure the selected image format is suitable for a sampled image. Do that
    by checking whether the `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT` bit of an `optimalTilingFeatures`
    member of the `format_properties` variable is set.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所选的图像格式适合采样图像。通过检查`format_properties`变量中`optimalTilingFeatures`成员的`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`位是否设置来完成此操作。
- en: If the sampled image will be linearly filtered or if its mipmaps will be linearly
    filtered, make sure the selected format is suitable for a linearly filtered sampled
    image. Do that by checking whether the `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
    bit of an `optimalTilingFeatures` member of the `format_properties` variable is
    set.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果采样图像将被线性过滤或如果其mipmap将被线性过滤，请确保所选格式适合线性过滤的采样图像。通过检查`format_properties`变量中`optimalTilingFeatures`成员的`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`位是否设置来完成此操作。
- en: Take the handle of the logical device created from the handle stored in the
    `physical_device` variable and use it to initialize a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储在`physical_device`变量中的句柄获取逻辑设备的句柄，并使用它来初始化一个名为`logical_device`的`VkDevice`类型变量。
- en: Create an image using the `logical_device` and `format` variables and choose
    the rest of the image parameters. Don't forget to provide a `VK_IMAGE_USAGE_SAMPLED_BIT`
    usage during the image creation. Store the image's handle in a variable of type
    `VkImage` named `sampled_image` (refer to the *Creating an image* recipe from
    [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`和`format`变量创建一个图像，并选择其余的图像参数。在创建图像时，不要忘记提供`VK_IMAGE_USAGE_SAMPLED_BIT`使用。将图像的句柄存储在一个名为`sampled_image`的`VkImage`类型变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建图像*配方）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use a range of an existing memory object) and bind it to the created image
    (refer to the *Allocating and binding memory object to an image* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个具有`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`属性的内存对象（或使用现有内存对象的范围），并将其绑定到创建的图像上（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*分配和绑定内存对象到图像*配方）。
- en: Create an image view using the `logical_device`, `sampled_image`, and `format`
    variables and select the rest of the view parameters. Store the image view's handle
    in a variable of type `VkImageView` named `sampled_image_view` (refer to the *Creating
    an image view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`、`sampled_image`和`format`变量创建一个图像视图，并选择其余的视图参数。将图像视图的句柄存储在一个名为`sampled_image_view`的`VkImageView`类型变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建图像视图*配方）。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Sampled images are used as a source of image data (textures) inside shaders.
    To fetch data from the image, usually we need a sampler object, which defines
    how the data should be read (refer to the *Creating a sampler* recipe).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 采样图像用作着色器内部图像数据（纹理）的来源。要从图像中获取数据，通常需要一个采样器对象，该对象定义了数据应该如何读取（参考*创建采样器*配方）。
- en: Sampled images are used for a `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` descriptor
    type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 采样图像用于`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`描述符类型。
- en: Inside shaders, we can use multiple samplers to read data from the same image
    in a different way. We can also use the same sampler with multiple images. But
    on some platforms, it may be more optimal to use combined image sampler objects,
    which gather a sampler and a sampled image in one object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all image formats are supported for sampled images; this depends on the
    platform on which the application is executed. But there is a set of mandatory
    formats that can always be used for sampled images and linearly filtered sampled
    images. Examples of such formats include (but are not limited to) the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_FORMAT_B4G4R4A4_UNORM_PACK16`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R5G6B5_UNORM_PACK16`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_A1R5G5B5_UNORM_PACK16`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R8_UNORM` and `VK_FORMAT_R8_SNORM`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R8G8_UNORM` and `VK_FORMAT_R8G8_SNORM`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R8G8B8A8_UNORM`, `VK_FORMAT_R8G8B8A8_SNORM`, and `VK_FORMAT_R8G8B8A8_SRGB`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_B8G8R8A8_UNORM` and `VK_FORMAT_B8G8R8A8_SRGB`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_A8B8G8R8_UNORM_PACK32`, `VK_FORMAT_A8B8G8R8_SNORM_PACK32`, and `VK_FORMAT_A8B8G8R8_SRGB_PACK32`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_A2B10G10R10_UNORM_PACK32`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R16_SFLOAT`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R16G16_SFLOAT`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R16G16B16A16_SFLOAT`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_B10G11R11_UFLOAT_PACK32`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_E5B9G9R9_UFLOAT_PACK32`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to use some less typical format, we need to check whether it can
    be used for sampled images. This can be done like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we are sure the selected format is suitable for our needs, we can create
    an image, a memory object for it, and an image view (in Vulkan, images are represented
    with image views most of the time). We need to specify a `VK_IMAGE_USAGE_SAMPLED_BIT`
    usage during the image creation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we want to use an image as a sampled image, before we load data from it
    inside shaders, we need to transition the image's layout to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: To create a uniform variable that represents a sampled image inside shaders,
    we need to use a `texture` keyword (possibly with a prefix) with an appropriate
    dimensionality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a GLSL code from which SPIR-V assembly can be generated, that
    uses a sampled image, may look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image*'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding memory object to an image*'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an image view*'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image view*'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying an image*'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, see the following recipe:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a sampler*'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a combined image sampler
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the application (API) perspective, samplers and sampled images are always
    separate objects. But inside shaders, they can be combined into one object. On
    some platforms, sampling from combined image samplers inside shaders may be more
    optimal than using separate samplers and sampled images.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a sampler object and store its handle in a variable of type `VkSampler`
    named `sampler` (refer to the *Creating a sampler* recipe).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sampled image. Store the handle of the created image in a variable
    of type `VkImage` named `sampled_image`. Create an appropriate view for the sampled
    image and store its handle in a variable of type `VkImageView` named `sampled_image_view`
    (refer to the *Creating a sampled image* recipe).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个采样图像。将创建的图像句柄存储在名为 `sampled_image` 的 `VkImage` 类型变量中。为采样图像创建一个适当的视图，并将它的句柄存储在名为
    `sampled_image_view` 的 `VkImageView` 类型变量中（参考 *创建一个采样图像* 的配方）。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Combined image samplers are created in our application in the same way as normal
    samplers and sampled images. They are just used differently inside shaders.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，组合图像采样器与普通采样器和采样图像的创建方式相同。它们在着色器内部的使用方式不同。
- en: Combined image samplers can be bound to descriptors of a `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`
    type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 组合图像采样器可以绑定到 `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` 类型的描述符。
- en: 'The following code uses the *Creating a sampler* and *Creating a sampled image*
    recipes to create necessary objects:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 *创建一个采样器* 和 *创建一个采样图像* 的配方来创建必要的对象：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The difference is inside the shaders.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于着色器内部。
- en: To create a variable that represents a combined image sampler inside GLSL shaders,
    we need to use a `sampler` keyword (possibly with a prefix) with an appropriate
    dimensionality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 GLSL 着色器内部创建表示组合图像采样器的变量，我们需要使用一个 `sampler` 关键字（可能带有前缀）并指定适当的维度。
- en: 'Don''t confuse samplers and combined image samplers--both use a `sampler` keyword
    inside shaders, but combined image samplers additionally have a dimensionality
    specified like in the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆采样器和组合图像采样器--两者在着色器内部都使用 `sampler` 关键字，但组合图像采样器还额外指定了维度，如下例所示：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Combined image samplers deserve a separate treatment, because applications that
    use them may have a better performance on some platforms. So if there is no specific
    reason to use separate samplers and sampled images, we should try to combine them
    into single objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 组合图像采样器需要单独处理，因为使用它们的应用程序在某些平台上可能会有更好的性能。因此，如果没有特定原因需要使用单独的采样器和采样图像，我们应该尝试将它们组合成单个对象。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存* 中，查看以下配方：
- en: '*Creating an image*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像*'
- en: '*Allocating and binding memory object to an image*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到图像*'
- en: '*Creating an image view*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像视图*'
- en: '*Destroying an image view*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个图像视图*'
- en: '*Destroying an image*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个图像*'
- en: '*Freeing a memory object*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: 'See the following recipes in this chapter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看以下配方：
- en: '*Creating a sampler*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个采样器*'
- en: '*Creating a sampled image*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个采样图像*'
- en: '*Destroying a sampler*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个采样器*'
- en: Creating a storage image
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个存储图像
- en: Storage images allow us to load (unfiltered) data from images bound to pipelines.
    But, what's more important, they also allow us to store data from shaders in the
    images. Such images must be created with a `VK_IMAGE_USAGE_STORAGE_BIT` usage
    flag specified.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 存储图像允许我们从绑定到管道的图像中加载（未过滤的）数据。但更重要的是，它们还允许我们在图像中存储着色器中的数据。此类图像必须使用指定了 `VK_IMAGE_USAGE_STORAGE_BIT`
    使用标志来创建。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a physical device and store it in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取物理设备的句柄并将其存储在名为 `physical_device` 的 `VkPhysicalDevice` 类型变量中。
- en: Select a format that will be used for a storage image. Initialize a variable
    of type `VkFormat` named `format` with the selected format.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用于存储图像的格式。使用所选格式初始化名为 `format` 的 `VkFormat` 类型变量。
- en: Create a variable of type `VkFormatProperties` named `format_properties`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `format_properties` 的 `VkFormatProperties` 类型变量。
- en: Call `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )` and provide the `physical_device` variable, the `format` variable, and a pointer
    to the `format_properties` variable.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )` 并提供 `physical_device` 变量、`format` 变量和 `format_properties` 变量的指针。
- en: Check whether the selected image format is suitable for a storage image. Do
    that by checking whether the `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT` bit of an `optimalTilingFeatures`
    member of the `format_properties` variable is set.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查所选图像格式是否适合存储图像。通过检查 `format_properties` 变量的 `optimalTilingFeatures` 成员的 `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT`
    位是否设置来完成此操作。
- en: If atomic operations will be performed on the storage image, make sure the selected
    format supports them. Do that by checking whether the `VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
    bit of an `optimalTilingFeatures` member of the `format_properties` variable is
    set.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将在存储图像上执行原子操作，请确保所选格式支持这些操作。通过检查 `format_properties` 变量的 `optimalTilingFeatures`
    成员的 `VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT` 位是否设置来完成此操作。
- en: Take the handle of the logical device created from a `physical_device` and use
    it to initialize a variable of type `VkDevice` named `logical_device`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由 `physical_device` 创建的逻辑设备的句柄，并使用它来初始化一个名为 `logical_device` 的 `VkDevice`
    类型变量。
- en: Create an image using the `logical_device` and `format` variables and choose
    the rest of the image parameters. Make sure the `VK_IMAGE_USAGE_STORAGE_BIT` usage
    is specified during the image creation. Store the created handle in a variable
    of type `VkImage` named `storage_image` (refer to the *Creating an image* recipe
    from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device` 和 `format` 变量创建一个图像，并选择其余的图像参数。确保在创建图像时指定 `VK_IMAGE_USAGE_STORAGE_BIT`
    用法。将创建的句柄存储在一个名为 `storage_image` 的 `VkImage` 类型变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建图像*配方）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use a range of an existing memory object) and bind it to the image (refer
    to the *Allocating and binding memory object to an image* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个具有 `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` 属性的内存对象（或使用现有内存对象的一个范围）并将其绑定到图像（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*将内存对象分配和绑定到图像*配方）。
- en: Create an image view using the `logical_device`, `storage_image`, and `format`
    variables and select the rest of the view parameters. Store the image view's handle
    in a variable of type `VkImageView` named `storage_image_view` (refer to the *Creating
    an image view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device`、`storage_image` 和 `format` 变量创建一个图像视图，并选择其余的视图参数。将图像视图的句柄存储在一个名为
    `storage_image_view` 的 `VkImageView` 类型变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建图像视图*配方）。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we want to store data in images from within shaders, we need to use storage
    images. We can also load data from such images, but these loads are unfiltered
    (we can't use samplers for storage images).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在着色器内部存储图像数据时，我们需要使用存储图像。我们也可以从这样的图像中加载数据，但这些加载是不过滤的（我们不能为存储图像使用采样器）。
- en: Storage images correspond to descriptors of a `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`
    type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 存储图像对应于 `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` 类型的描述符。
- en: 'Storage images are created with a `VK_IMAGE_USAGE_STORAGE_BIT` usage. We also
    can''t forget about specifying a proper format. Not all formats may always be
    used for storage images. This depends on the platform our application is executed
    on. But there is a list of mandatory formats that all Vulkan drivers must support.
    It includes (but is not limited to) the following formats:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 存储图像是以 `VK_IMAGE_USAGE_STORAGE_BIT` 用法创建的。我们也不能忘记指定适当的格式。并非所有格式都可以始终用于存储图像。这取决于我们的应用程序执行的平台。但是，有一个必需格式的列表，所有
    Vulkan 驱动程序都必须支持。它包括（但不限于）以下格式：
- en: '`VK_FORMAT_R8G8B8A8_UNORM`, `VK_FORMAT_R8G8B8A8_SNORM`, `VK_FORMAT_R8G8B8A8_UINT`,
    and `VK_FORMAT_R8G8B8A8_SINT`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R8G8B8A8_UNORM`, `VK_FORMAT_R8G8B8A8_SNORM`, `VK_FORMAT_R8G8B8A8_UINT`,
    和 `VK_FORMAT_R8G8B8A8_SINT`'
- en: '`VK_FORMAT_R16G16B16A16_UINT`, `VK_FORMAT_R16G16B16A16_SINT` and `VK_FORMAT_R16G16B16A16_SFLOAT`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R16G16B16A16_UINT`, `VK_FORMAT_R16G16B16A16_SINT` 和 `VK_FORMAT_R16G16B16A16_SFLOAT`'
- en: '`VK_FORMAT_R32_UINT`, `VK_FORMAT_R32_SINT` and `VK_FORMAT_R32_SFLOAT`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32_UINT`, `VK_FORMAT_R32_SINT` 和 `VK_FORMAT_R32_SFLOAT`'
- en: '`VK_FORMAT_R32G32_UINT`, `VK_FORMAT_R32G32_SINT` and `VK_FORMAT_R32G32_SFLOAT`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32G32_UINT`, `VK_FORMAT_R32G32_SINT` 和 `VK_FORMAT_R32G32_SFLOAT`'
- en: '`VK_FORMAT_R32G32B32A32_UINT`, `VK_FORMAT_R32G32B32A32_SINT` and `VK_FORMAT_R32G32B32A32_SFLOAT`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32G32B32A32_UINT`, `VK_FORMAT_R32G32B32A32_SINT` 和 `VK_FORMAT_R32G32B32A32_SFLOAT`'
- en: 'If we want to perform atomic operations on storage images, the list of mandatory
    formats is much shorter and includes only the following ones:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在存储图像上执行原子操作，则必需格式的列表要短得多，并且仅包括以下几种：
- en: '`VK_FORMAT_R32_UINT`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32_UINT`'
- en: '`VK_FORMAT_R32_SINT`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32_SINT`'
- en: 'If another format is required for storage images or if we need to use another
    format to perform atomic operations on storage images, we must check whether the
    selected format is supported on a platform our application is executed on. This
    can be done with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储图像需要其他格式，或者如果我们需要使用其他格式在存储图像上执行原子操作，我们必须检查所选格式是否在应用程序执行的平台上是受支持的。这可以通过以下代码完成：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the format is supported, we create images as usual, but we need to specify
    a `VK_IMAGE_USAGE_STORAGE_BIT` usage. After the image is ready, we need to create
    a memory object, bind it to the image, and we also need an image view. These operations
    can be performed like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果格式受支持，我们像往常一样创建图像，但我们需要指定 `VK_IMAGE_USAGE_STORAGE_BIT` 使用方式。图像准备好后，我们需要创建一个内存对象，将其绑定到图像，并且我们还需要一个图像视图。这些操作可以像这样执行：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we can load or store data in storage images from shaders, we must perform
    a transition to a `VK_IMAGE_LAYOUT_GENERAL` layout. It is the only layout in which
    these operations are supported.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够从着色器中加载或存储存储图像中的数据之前，我们必须执行到 `VK_IMAGE_LAYOUT_GENERAL` 布局的转换。这是唯一支持这些操作的布局。
- en: Inside GLSL shaders, storage images are specified with an `image` keyword (possibly
    with a prefix) and an appropriate dimensionality. We also need to provide the
    image's format inside the `layout` qualifier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GLSL 着色器内部，存储图像使用 `image` 关键字（可能带有前缀）和适当的维度来指定。我们还需要在 `layout` 限定符内提供图像的格式。
- en: 'An example of a storage image''s definition in a GLSL shader is provided as
    follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面提供了一个在 GLSL 着色器中定义存储图像的示例：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存* 中，查看以下食谱：
- en: '*Creating an image*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding memory object to an image*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象分配和绑定到图像*'
- en: '*Creating an image view*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像视图*'
- en: '*Destroying an image view*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像视图*'
- en: '*Destroying an image*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁图像*'
- en: '*Freeing a memory object*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: Creating a uniform texel buffer
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建均匀的 texel 缓冲区
- en: Uniform texel buffers allow us to read data in a way similar to reading data
    from images--their contents are interpreted not as an array of single (scalar)
    values but as formatted pixels (texel) with one, two, three, or four components.
    But through such buffers, we can access data that is much larger than the data
    provided through usual images.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀的 texel 缓冲区允许我们以类似于从图像读取数据的方式读取数据--它们的内 容不是解释为单个（标量）值的数组，而是解释为具有一个、两个、三个或四个组件的格式化像素（texel）。但是，通过这样的缓冲区，我们可以访问比通过常规图像提供的数据大得多的数据。
- en: We need to specify a `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` usage when we
    want to use a buffer as a uniform texel buffer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将缓冲区用作均匀的 texel 缓冲区时，我们需要指定 `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`
    使用方式。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a physical device and store it in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将物理设备的句柄存储在名为 `physical_device` 的 `VkPhysicalDevice` 类型的变量中。
- en: Select a format in which the buffer data will be stored. Use the format to initialize
    a variable of type `VkFormat` named `format`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个格式，其中将存储缓冲区数据。使用该格式初始化一个名为 `format` 的 `VkFormat` 类型的变量。
- en: Create a variable of type `VkFormatProperties` named `format_properties`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `format_properties` 的 `VkFormatProperties` 类型的变量。
- en: Call `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )` and provide the handle of the physical device, the `format` variable, and a
    pointer to the `format_properties` variable.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )` 并提供物理设备的句柄、`format` 变量以及 `format_properties` 变量的指针。
- en: Make sure the selected format is suitable for a uniform texel buffer by checking
    whether the `bufferFeatures` member of the `format_properties` variable has a
    `VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT` bit set.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `format_properties` 变量的 `bufferFeatures` 成员是否设置了 `VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT`
    位，确保所选格式适合均匀的 texel 缓冲区。
- en: Take the handle of a logical device created from the handle of the selected
    physical device. Store it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从所选物理设备的句柄创建一个逻辑设备。将其存储在名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Create a variable of type `VkBuffer` named `uniform_texel_buffer`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `uniform_texel_buffer` 的 `VkBuffer` 类型的变量。
- en: Create a buffer, using the `logical_device` variable, with a desired size and
    usage. Don't forget to include a `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` usage
    during the buffer's creation. Store the created handle in the `uniform_texel_buffer`
    variable (refer to the *Creating a buffer* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use an existing one) and bind it to the buffer. If the new memory object is
    allocated, store it in a variable of type `VkDeviceMemory` named `memory_object`
    (refer to the *Allocating and binding memory object to a buffer* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a buffer view using the `logical_device`, `uniform_texel_buffer`, and
    `format` variables, and the desired offset and memory range. Store the resulting
    handle in a variable of type `VkBufferView` named `uniform_texel_buffer_view`
    (refer to the *Creating a buffer view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uniform texel buffers allow us to provide data interpreted as one-dimensional
    images. But this data may be much larger than typical images. Vulkan specification
    requires every driver to support 1D images of at least 4,096 texels. But for texel
    buffers, this minimal required limit goes up to 65,536 elements.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Uniform texel buffers are bound to descriptors of a `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`
    type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Uniform texel buffers are created with a `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`
    usage. But apart from that, we need to select an appropriate format. Not all formats
    are compatible with such buffers. The list of mandatory formats that can be used
    with uniform texel buffers includes (but is not limited to) the following ones:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R8_UNORM`, `VK_FORMAT_R8_SNORM`, `VK_FORMAT_R8_UINT`, and `VK_FORMAT_R8_SINT`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R8G8_UNORM`, `VK_FORMAT_R8G8_SNORM`, `VK_FORMAT_R8G8_UINT`, and
    `VK_FORMAT_R8G8_SINT`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R8G8B8A8_UNORM`, `VK_FORMAT_R8G8B8A8_SNORM`, `VK_FORMAT_R8G8B8A8_UINT`,
    and `VK_FORMAT_R8G8B8A8_SINT`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_B8G8R8A8_UNORM`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_A8B8G8R8_UNORM_PACK32`, `VK_FORMAT_A8B8G8R8_SNORM_PACK32`, `VK_FORMAT_A8B8G8R8_UINT_PACK32`,
    and `VK_FORMAT_A8B8G8R8_SINT_PACK32`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_A2B10G10R10_UNORM_PACK32` and `VK_FORMAT_A2B10G10R10_UINT_PACK32`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R16_UINT`, `VK_FORMAT_R16_SINT` and `VK_FORMAT_R16_SFLOAT`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R16G16_UINT`, `VK_FORMAT_R16G16_SINT` and `VK_FORMAT_R16G16_SFLOAT`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R16G16B16A16_UINT`, `VK_FORMAT_R16G16B16A16_SINT` and `VK_FORMAT_R16G16B16A16_SFLOAT`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32_UINT`, `VK_FORMAT_R32_SINT` and `VK_FORMAT_R32_SFLOAT`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32_UINT`, `VK_FORMAT_R32G32_SINT` and `VK_FORMAT_R32G32_SFLOAT`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_R32G32B32A32_UINT`, `VK_FORMAT_R32G32B32A32_SINT` and `VK_FORMAT_R32G32B32A32_SFLOAT`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_FORMAT_B10G11R11_UFLOAT_PACK32`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check whether other formats can be used with uniform texel buffers, we need
    to prepare the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the selected format is suitable for our needs, we can create a buffer, allocate
    a memory object for it, and bind it to the buffer. What is very important, is
    that we also need to create a buffer view:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the API perspective, the structure of the buffer's contents doesn't matter.
    But in the case of uniform texel buffers, we need to specify a data format which
    will allow shaders to interpret the buffer's contents in an appropriate way. That's
    why a buffer view is required.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the GLSL shaders, uniform texel buffers are defined through variables of
    type `samplerBuffer` (possibly with a prefix).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a uniform texel buffer variable defined in a GLSL shader is provided
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a buffer*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating and binding memory object to a buffer*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a buffer view*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a buffer view*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freeing a memory object*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a buffer*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a storage texel buffer
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage texel buffers, like uniform texel buffers, are a way to provide large
    amount of image-like data to shaders. But they also allow us to store data in
    them and perform atomic operations on them. For this purpose, we need to create
    a buffer with a `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a physical device. Store it in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a format for the texel buffer's data and use it to initialize a variable
    of type `VkFormat` named `format`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkFormatProperties` named `format_properties`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )` and provide the handle of the selected physical device, the `format` variable,
    and a pointer to the `format_properties` variable.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the selected format is suitable for a storage texel buffer by checking
    whether the `bufferFeatures` member of the `format_properties` variable has a
    `VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT` bit set.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If atomic operations will be performed on a created storage texel buffer, make
    sure the selected format is also suitable for atomic operations. For this purpose,
    check whether a `VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT` bit of the
    `bufferFeatures` member of the `format_properties` variable is set.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a logical device created from the handle of the selected
    physical device. Store it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable of type `VkBuffer` named `storage_texel_buffer`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `logical_device` variable, create a buffer with the chosen size and
    usage. Make sure a `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` usage is specified
    during the buffer's creation. Store the buffer's handle in the `storage_texel_buffer`
    variable (refer to the *Creating a buffer* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device` 变量，创建一个具有所选大小和用途的缓冲区。确保在创建缓冲区时指定了 `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`
    用途。将缓冲区的句柄存储在 `storage_texel_buffer` 变量中（参考第 4 章 *创建缓冲区* 的配方，*资源和内存*）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use an existing one) and bind it to the buffer. If a new memory object is
    allocated, store it in a variable of type `VkDeviceMemory` named `memory_object`
    (refer to the *Allocating and binding memory object to a buffer* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个具有 `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` 属性的内存对象（或使用现有的一个）并将其绑定到缓冲区。如果分配了新的内存对象，将其存储在名为
    `memory_object` 的 `VkDeviceMemory` 类型的变量中（参考第 4 章 *分配和绑定内存对象到缓冲区* 的配方，*资源和内存*）。
- en: Create a buffer view using the `logical_device`, `storage_texel_buffer`, and
    `format` variables, and the desired offset and memory range. Store the resulting
    handle in a variable of type `VkBufferView` named `storage_texel_buffer_view`
    (refer to the *Creating a buffer view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device`，`storage_texel_buffer` 和 `format` 变量，以及所需的偏移量和内存范围创建一个缓冲区视图，并将结果句柄存储在名为
    `storage_texel_buffer_view` 的 `VkBufferView` 类型的变量中（参考第 4 章 *创建缓冲区视图* 的配方，*资源和内存*）。
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Storage texel buffers allow us to access and to store data in very large arrays.
    Data is interpreted as if it was read or stored inside one-dimensional images.
    Additionally, we can perform atomic operations on such buffers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 存储 texel 缓冲区允许我们访问和存储非常大的数组中的数据。数据被解释为如果它是在一维图像内部读取或存储的。此外，我们还可以对这些缓冲区执行原子操作。
- en: Storage texel buffers can fill descriptors of a type equal to `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 存储 texel 缓冲区可以填充类型等于 `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` 的描述符。
- en: 'To use a buffer as a storage texel buffer, it needs to be created with a `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`
    usage. A buffer view with an appropriate format is also required. For storage
    texel buffers, we can select one of the mandatory formats that include the following
    ones:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓冲区用作存储 texel 缓冲区，它需要以 `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` 用途创建。还需要一个具有适当格式的缓冲区视图。对于存储
    texel 缓冲区，我们可以选择包括以下在内的强制格式之一：
- en: '`VK_FORMAT_R8G8B8A8_UNORM`, `VK_FORMAT_R8G8B8A8_SNORM`, `VK_FORMAT_R8G8B8A8_UINT`,
    and `VK_FORMAT_R8G8B8A8_SINT`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R8G8B8A8_UNORM`，`VK_FORMAT_R8G8B8A8_SNORM`，`VK_FORMAT_R8G8B8A8_UINT`
    和 `VK_FORMAT_R8G8B8A8_SINT`'
- en: '`VK_FORMAT_A8B8G8R8_UNORM_PACK32`, `VK_FORMAT_A8B8G8R8_SNORM_PACK32`, `VK_FORMAT_A8B8G8R8_UINT_PACK32`,
    and `VK_FORMAT_A8B8G8R8_SINT_PACK32`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_A8B8G8R8_UNORM_PACK32`，`VK_FORMAT_A8B8G8R8_SNORM_PACK32`，`VK_FORMAT_A8B8G8R8_UINT_PACK32`
    和 `VK_FORMAT_A8B8G8R8_SINT_PACK32`'
- en: '`VK_FORMAT_R32_UINT`, `VK_FORMAT_R32_SINT`, and `VK_FORMAT_R32_SFLOAT`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32_UINT`，`VK_FORMAT_R32_SINT` 和 `VK_FORMAT_R32_SFLOAT`'
- en: '`VK_FORMAT_R32G32_UINT`, `VK_FORMAT_R32G32_SINT`, and `VK_FORMAT_R32G32_SFLOAT`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32G32_UINT`，`VK_FORMAT_R32G32_SINT` 和 `VK_FORMAT_R32G32_SFLOAT`'
- en: '`VK_FORMAT_R32G32B32A32_UINT`, `VK_FORMAT_R32G32B32A32_SINT`, and `VK_FORMAT_R32G32B32A32_SFLOAT`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32G32B32A32_UINT`，`VK_FORMAT_R32G32B32A32_SINT`，和 `VK_FORMAT_R32G32B32A32_SFLOAT`'
- en: 'For atomic operations, the list of mandatory formats is much shorter and includes
    only the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原子操作，强制格式的列表要短得多，仅包括以下内容：
- en: '`VK_FORMAT_R32_UINT` and `VK_FORMAT_R32_SINT`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32_UINT` 和 `VK_FORMAT_R32_SINT`'
- en: 'Other formats may also be supported for storage texel buffers, but the support
    is not guaranteed and must be confirmed on the platform our application is executed
    on like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 其他格式也可能支持存储 texel 缓冲区，但支持并不保证，必须在应用程序执行的平台上进行确认，如下所示：
- en: '[PRE14]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For a storage texel buffer, we need to create a buffer, allocate and bind a
    memory object to the buffer, and also we need to create a buffer view that will
    define the format of the buffer''s data:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储 texel 缓冲区，我们需要创建一个缓冲区，为缓冲区分配和绑定一个内存对象，还需要创建一个定义缓冲区数据格式的缓冲区视图：
- en: '![](img/image_05_001.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_001.png)'
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can also use an existing memory object and bind a range of its memory to
    the storage texel buffer.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用现有的内存对象并将它的内存范围绑定到存储 texel 缓冲区。
- en: From the GLSL perspective, storage texel buffer variables are defined using
    an `imageBuffer` (possibly with a prefix) keyword.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从GLSL的角度来看，存储纹理缓冲区变量使用`imageBuffer`（可能带有前缀）关键字定义。
- en: 'An example of a storage texel buffer defined in a GLSL shader looks like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL着色器中定义的存储纹理缓冲区的一个例子如下所示：
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看以下配方：
- en: '*Creating a buffer*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding memory object to a buffer*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Creating a buffer view*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区视图*'
- en: '*Destroying a buffer view*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区视图*'
- en: '*Freeing a memory object*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: '*Destroying a buffer*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区*'
- en: Creating a uniform buffer
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个统一的缓冲区
- en: In Vulkan, uniform variables used inside shaders cannot be placed in a global
    namespace. They can be defined only inside uniform buffers. For these, we need
    to create buffers with a `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` usage.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，着色器内部使用的统一变量不能放置在全局命名空间中。它们只能定义在统一缓冲区内部。对于这些，我们需要创建具有`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`用途的缓冲区。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the created logical device and use its handle to initialize a variable
    of type `VkDevice` named `logical_device`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的逻辑设备及其句柄初始化一个名为`logical_device`的`VkDevice`类型的变量。
- en: Create a variable of type `VkBuffer` named `uniform_buffer`. It will hold the
    handle of the created buffer.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`uniform_buffer`的`VkBuffer`类型的变量。它将保存创建的缓冲区的句柄。
- en: Create a buffer using a `logical_device` variable and specifying the desired
    size and usage. The latter must contain at least a `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`
    flag. Store the handle of the buffer in the `uniform_buffer` variable (refer to
    the *Creating a buffer* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`变量创建一个缓冲区，并指定所需的大小和用途。后者必须包含至少一个`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`标志。将缓冲区的句柄存储在`uniform_buffer`变量中（请参阅[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建缓冲区*配方）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use a range of an existing memory object) and bind it to the buffer (refer
    to the *Allocating and binding memory object to a buffer* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`属性（或使用现有内存对象的范围）的内存对象进行分配，并将其绑定到缓冲区（请参阅[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*分配和绑定内存对象到缓冲区*配方）。
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Uniform buffers are used to provide values for read-only uniform variables inside
    shaders.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 统一缓冲区用于在着色器内部提供只读统一变量的值。
- en: Uniform buffers can be used for `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`
    descriptor types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 统一缓冲区可用于`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`或`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`描述符类型。
- en: Typically, uniform buffers contain data for parameters that don't change too
    often, that is, matrices (for small amounts of data, **push constants** are recommended
    as updating them is usually much faster; information about push constants can
    be found in the *Providing data to shaders through push constants* recipe in [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，统一缓冲区包含不经常更改的参数数据，即矩阵（对于少量数据，建议使用**推送常量**，因为更新它们通常要快得多；有关推送常量的信息，请参阅[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*通过推送常量向着色器提供数据*配方）。
- en: 'Creating a buffer in which data for uniform variables will be stored requires
    us to specify a `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` flag during buffer creation.
    When the buffer is created, we need to prepare a memory object and bind it to
    the created buffer (we can also use an existing memory object and bind the part
    of its memory store to the buffer):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于存储统一变量数据的缓冲区需要我们在创建缓冲区时指定`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`标志。当缓冲区创建时，我们需要准备一个内存对象并将其绑定到创建的缓冲区（我们也可以使用现有的内存对象并将它的内存存储的一部分绑定到缓冲区）：
- en: '[PRE17]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the buffer and its memory objects are ready, we can upload data to them
    as we do with any other kinds of buffers. We just need to remember that uniform
    variables must be placed at appropriate offsets. These offsets are the same as
    in the std140 layout from the GLSL language and are defined as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区和其内存对象准备就绪后，我们可以像对其他类型的缓冲区一样将数据上传到它们。我们只需记住，统一变量必须放置在适当的偏移量处。这些偏移量与GLSL语言中的std140布局相同，定义如下：
- en: A scalar variable of size `N` must be placed at offsets that are a multiple
    of `N`
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小为`N`的标量变量必须放置在偏移量为`N`的倍数的位置。
- en: A vector with two components, where each component has a size of `N`, must be
    placed at offsets that are a multiple of `2N`
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有两个组件的向量，其中每个组件的大小为`N`，必须放置在偏移量为`2N`的倍数的位置。
- en: A vector with three or four components, where each component has a size of `N`,
    must be placed at offsets that are a multiple of `4N`
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有三个或四个组件的向量，其中每个组件的大小为`N`，必须放置在偏移量为`4N`的倍数的位置。
- en: An array with elements of size `N` must be placed at offsets that are a multiple
    of `N` rounded up to the multiple of `16`
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大小为`N`的数组必须放置在偏移量为`N`的倍数的位置，且向上取整到`16`的倍数。
- en: A structure must be placed at an offset that is the same as the biggest offset
    of its members, rounded up to a multiple of `16` (offset of a member with the
    biggest offset requirement, rounded up to the multiple of `16`)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构必须放置在与其成员的最大偏移量相同的偏移量处，向上取整到`16`的倍数（具有最大偏移量要求的成员的偏移量，向上取整到`16`的倍数）。
- en: A row-major matrix must be placed at an offset equal to the offset of a vector
    with the number of components equal to the number of columns in the matrix
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行主序矩阵必须放置在偏移量等于具有与矩阵列数相同组件数的向量的偏移量处。
- en: A column-major matrix must be placed at the same offsets as its columns
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列主序矩阵必须放置在其列相同的偏移量处。
- en: Dynamic uniform buffers differ from normal uniform buffers in the way their
    address is specified. During a descriptor set update, we specify the size of memory
    that should be used for a uniform buffer and an offset from the beginning of the
    buffer's memory. For normal uniform buffers, these parameters remain unchanged.
    For dynamic uniform buffers, the specified offset becomes a base offset that can
    be later modified by the dynamic offset which is added when a descriptor set is
    bound to a command buffer.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 动态统一缓冲区与普通统一缓冲区在指定其地址的方式上有所不同。在描述符集更新期间，我们指定用于统一缓冲区的内存大小以及从缓冲区内存开始的偏移量。对于普通统一缓冲区，这些参数保持不变。对于动态统一缓冲区，指定的偏移量成为一个基偏移量，可以在将描述符集绑定到命令缓冲区时通过动态偏移量进行修改。
- en: Inside GLSL shaders, both uniform buffers and dynamic uniform buffers are defined
    with a `uniform` qualifier and a block syntax.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL着色器内部，统一缓冲区和动态统一缓冲区都使用`uniform`限定符和块语法定义。
- en: 'An example of a uniform buffer''s definition in a GLSL shader is provided as
    follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提供了一个在GLSL着色器中定义统一缓冲区的示例：
- en: '[PRE18]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看以下配方：
- en: '*Creating a buffer*'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding memory object to a buffer*'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Freeing a memory object*'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: '*Destroying a buffer*'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区*'
- en: Creating a storage buffer
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储缓冲区
- en: When we want to not only read data from a buffer inside shaders, but we would
    also like to store data in it, we need to use storage buffers. These are created
    with a `VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` usage.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不仅想要从着色器内部的缓冲区中读取数据，还希望在其中存储数据时，我们需要使用存储缓冲区。这些缓冲区使用`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`用途创建。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为`physical_device`的类型为`VkPhysicalDevice`的变量中。
- en: Create a variable of type `VkBuffer` named `storage_buffer` in which a handle
    of a created buffer will be stored.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`storage_buffer`的类型为`VkBuffer`的变量，其中将存储创建的缓冲区的句柄。
- en: Create a buffer of a desired size and usage using the `logical_device` variable.
    Specified usage must contain at least a `VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` flag.
    Store the created handle in the `storage_buffer` variable (refer to the *Creating
    a buffer* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`变量创建一个所需大小和用途的缓冲区。指定的用途必须包含至少一个`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`标志。将创建的句柄存储在`storage_buffer`变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建缓冲区*配方）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use a range of an existing memory object) and bind it to the created buffer
    (refer to the *Allocating and binding memory object to a buffer* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个具有 `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` 属性的内存对象（或使用现有内存对象的范围）并将其绑定到创建的缓冲区（请参阅
    [第 4 章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*分配并将内存对象绑定到缓冲区*配方）。
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Storage buffers support both read and write operations. We can also perform
    atomic operations on storage buffers' members which have unsigned integer formats.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 存储缓冲区支持读写操作。我们还可以对具有无符号整数格式的存储缓冲区成员执行原子操作。
- en: Storage buffers correspond to `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`
    descriptor types.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 存储缓冲区对应于 `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` 或 `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`
    描述符类型。
- en: 'Data for members of storage buffers must be placed at appropriate offsets.
    The easiest way to fulfill the requirements is to follow the rules for the std430
    layout in the GLSL language. Base alignment rules for storage buffers are similar
    to the rules of uniform buffers with the exception of arrays and structures--their
    offsets don''t need to be rounded up to a multiple of 16\. For convenience, these
    rules are specified as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 存储缓冲区成员的数据必须放置在适当的偏移处。满足要求的最简单方法是遵循 GLSL 语言中 std430 布局的规则。存储缓冲区的基对齐规则与统一缓冲区的规则类似，除了数组和结构--它们的偏移量不需要向上舍入到
    16 的倍数。为了方便，这些规则如下指定：
- en: A scalar variable of size `N` must be placed at offsets that are a multiple
    of `N`
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小为 `N` 的标量变量必须放置在 `N` 的倍数偏移处
- en: A vector with two components, where each component has a size of `N`, must be
    placed at offsets that are a multiple of `2N`
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有两个分量的向量，其中每个分量的大小为 `N`，必须放置在 `2N` 的倍数偏移处
- en: A vector with three or four components, where each component has a size of `N`,
    must be placed at offsets that are a multiple of `4N`
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有三个或四个分量的向量，其中每个分量的大小为 `N`，必须放置在 `4N` 的倍数偏移处
- en: An array with elements of size `N` must be placed at offsets that are a multiple
    of `N`
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大小为 `N` 的元素数组必须放置在 `N` 的倍数偏移处
- en: A structure must be placed at offsets that are a multiple of the biggest offset
    of any of its members (a member with the biggest offset requirement)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个结构必须放置在其成员中最大偏移量的倍数偏移处（具有最大偏移量要求的成员）
- en: A row-major matrix must be placed at an offset equal to the offset of a vector
    with the number of components equal to the number of columns in the matrix
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行主序矩阵必须放置在一个偏移量等于具有与矩阵列数相同分量的向量偏移量
- en: A column-major matrix must be placed at the same offsets as its columns
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列主序矩阵必须放置在其列相同的偏移处
- en: Dynamic storage buffers differ in the way their base memory offset is defined.
    The offset and range specified during descriptor set updates remain unchanged
    for the normal storage buffers until the next update. In the case of their dynamic
    variations, the specified offset becomes a base address which is later modified
    by the dynamic offset specified when a descriptor set is bound to a command buffer.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 动态存储缓冲区在定义其基内存偏移的方式上有所不同。在描述符集更新期间指定的偏移量和范围对于正常存储缓冲区保持不变，直到下一次更新。对于它们的动态变体，指定的偏移量成为一个基地址，稍后由将描述符集绑定到命令缓冲区时指定的动态偏移量修改。
- en: In GLSL shaders, storage buffers and dynamic storage buffers are defined identically
    with a `buffer` qualifier and a block syntax.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GLSL 着色器中，存储缓冲区和动态存储缓冲区使用 `buffer` 限定符和块语法定义相同。
- en: 'An example of a storage buffer used in a GLSL shader is provided as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下面提供了一个在 GLSL 着色器中使用的存储缓冲区的示例：
- en: '[PRE19]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看以下配方：
- en: '*Creating a buffer*'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding memory object to a buffer*'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配并将内存对象绑定到缓冲区*'
- en: '*Freeing a memory object*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: '*Destroying a buffer*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁缓冲区*'
- en: Creating an input attachment
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建输入附件
- en: Attachments are images into which we render during drawing commands, inside
    render passes. In other words, they are render targets.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 附件是在绘制命令期间，在渲染通道中渲染到其中的图像。换句话说，它们是渲染目标。
- en: Input attachments are image resources from which we can read (unfiltered) data
    inside fragment shaders. We just need to remember that we can access only one
    location corresponding to a processed fragment.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 输入附件是我们可以在片段着色器内部读取（未过滤）数据的图像资源。我们只需记住，我们只能访问与处理过的片段相对应的一个位置。
- en: Usually, for input attachments, resources that were previously color or depth/stencil
    attachments are used. But we can also use other images (and their image views).
    We just need to create them with a `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` usage.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于输入附件，使用之前用作颜色或深度/模板附件的资源。但我们也可以使用其他图像（及其图像视图）。我们只需使用具有`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`使用位的`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`来创建它们。
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take the physical device on which operations are performed and store its handle
    in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取执行操作的物理设备，并将其句柄存储在名为`physical_device`的`VkPhysicalDevice`类型变量中。
- en: Select a format for an image and use it to initialize a variable of type `VkFormat`
    named `format`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为图像选择一个格式，并使用它初始化一个名为`format`的`VkFormat`类型变量。
- en: Create a variable of type `VkFormatProperties` named `format_properties`.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`format_properties`的`VkFormatProperties`类型变量。
- en: Call `vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )` and provide the `physical_device` and `format` variables, and a pointer to
    the `format_properties` variable.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties
    )`，并提供`physical_device`和`format`变量，以及`format_properties`变量的指针。
- en: If the image's color data will be read, make sure the selected format is suitable
    for such usage. For this, check whether a `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
    bit is set in an `optimalTilingFeatures` member of the `format_properties` variable.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将读取图像的颜色数据，请确保所选格式适合此类使用。为此，请检查`format_properties`变量的`optimalTilingFeatures`成员中是否设置了`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`位。
- en: If the image's depth or stencil data will be read, check whether the selected
    format can be used for reading depth or stencil data. Do that by making sure that
    a `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT` bit is set in an `optimalTilingFeatures`
    member of the `format_properties` variable.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将读取图像的深度或模板数据，请检查所选格式是否可用于读取深度或模板数据。通过确保`format_properties`变量的`optimalTilingFeatures`成员中设置了`VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`位来完成此操作。
- en: Take the handle of a logical device created from the used physical device. Store
    it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从使用的物理设备创建一个逻辑设备，并将其句柄存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Create an image using the `logical_device` and `format` variables, and select
    appropriate values for the rest of the image's parameters. Make sure the `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
    usage is specified during the image creation. Store the created handle in a variable
    of type `VkImage` named `input_attachment` (refer to the *Creating an image* recipe
    from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`和`format`变量创建一个图像，并为图像的其余参数选择适当的值。确保在创建图像期间指定`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`使用位。将创建的句柄存储在名为`input_attachment`的`VkImage`类型变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)中的*创建一个图像*配方，*资源和内存*）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    (or use a range of an existing memory object) and bind it to the image (refer
    to the *Allocating and binding memory object to an image* recipe from Chapter
    4, *Resources and Memory*).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个具有`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`属性的内存对象（或使用现有内存对象的范围），并将其绑定到图像上（参考第4章*资源和内存*中的*分配和绑定内存对象到图像*配方）。
- en: Create an image view using the `logical_device`, `input_attachment`, and `format`
    variables, and choose the rest of the image view's parameters. Store the created
    handle in a variable of type `VkImageView` named `input_attachment_image_view`
    (refer to the *Creating an image view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`、`input_attachment`和`format`变量创建一个图像视图，并选择图像视图的其余参数。将创建的句柄存储在名为`input_attachment_image_view`的`VkImageView`类型变量中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)中的*创建图像视图*配方，*资源和内存*）。
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Input attachments allow us to read data inside fragment shaders from images
    used as render pass attachments (typically, for input attachments, images that
    were previously color or depth stencil attachments will be used).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 输入附件使我们能够从用作渲染通道附件的图像中读取片段着色器内的数据（通常，对于输入附件，将使用之前用作颜色或深度/模板附件的图像）。
- en: Input attachments are used for descriptors of a `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
    type.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 输入附件用于 `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` 类型的描述符。
- en: In Vulkan, rendering operations are gathered into render passes. Each render
    pass has at least one subpass, but can have more. If we render to an attachment
    in one subpass, we can then use it as an input attachment and read data from it
    in subsequent subpasses of the same render pass. It is in fact the only way to
    read data from attachments in a given render pass--images serving as attachments
    in a given render pass can only be accessed through input attachments inside shaders
    (they cannot be bound to descriptor sets for purposes other than input attachments).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，渲染操作被收集到渲染通道中。每个渲染通道至少有一个子通道，但可以有更多。如果我们在一个子通道中将渲染到附件，然后我们可以将其用作输入附件，并在同一渲染通道的后续子通道中从中读取数据。实际上，这是从给定渲染通道的附件中读取数据的唯一方法--在给定渲染通道中作为附件的图像只能通过着色器中的输入附件访问（它们不能绑定到描述符集用于除输入附件以外的目的）。
- en: When reading data from input attachments, we are confined only to the location
    corresponding to the location of a processed fragment. But such an approach may
    be more optimal than rendering into an attachment, ending a render pass, binding
    an image to a descriptor set as a sampled image (texture), and starting another
    render pass which doesn't use the given image as any of its attachments.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当从输入附件读取数据时，我们仅限于对应于处理片段位置的地点。但这种方法可能比渲染到附件、结束渲染通道、将图像绑定到描述符集作为采样图像（纹理）并开始另一个不使用给定图像作为任何附件的渲染通道更优。
- en: 'For input attachments, we can also use other images (we don''t have to use
    them as color or depth/stencil attachments). We just need to create them with
    a `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` usage and a proper format. The following
    formats are mandatory for input attachments from which color data will be read:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入附件，我们还可以使用其他图像（我们不必将它们用作颜色或深度/模板附件）。我们只需用 `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
    用法和适当的格式创建它们。以下格式对于从读取颜色数据的输入附件是强制性的：
- en: '`VK_FORMAT_R5G6B5_UNORM_PACK16`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R5G6B5_UNORM_PACK16`'
- en: '`VK_FORMAT_A1R5G5B5_UNORM_PACK16`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_A1R5G5B5_UNORM_PACK16`'
- en: '`VK_FORMAT_R8_UNORM`, `VK_FORMAT_R8_UINT` and `VK_FORMAT_R8_SINT`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R8_UNORM`、`VK_FORMAT_R8_UINT` 和 `VK_FORMAT_R8_SINT`'
- en: '`VK_FORMAT_R8G8_UNORM`, `VK_FORMAT_R8G8_UINT`, and `VK_FORMAT_R8G8_SINT`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R8G8_UNORM`、`VK_FORMAT_R8G8_UINT` 和 `VK_FORMAT_R8G8_SINT`'
- en: '`VK_FORMAT_R8G8B8A8_UNORM`, `VK_FORMAT_R8G8B8A8_UINT`, `VK_FORMAT_R8G8B8A8_SINT`,
    and `VK_FORMAT_R8G8B8A8_SRGB`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R8G8B8A8_UNORM`、`VK_FORMAT_R8G8B8A8_UINT`、`VK_FORMAT_R8G8B8A8_SINT`
    和 `VK_FORMAT_R8G8B8A8_SRGB`'
- en: '`VK_FORMAT_B8G8R8A8_UNORM` and `VK_FORMAT_B8G8R8A8_SRGB`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_B8G8R8A8_UNORM` 和 `VK_FORMAT_B8G8R8A8_SRGB`'
- en: '`VK_FORMAT_A8B8G8R8_UNORM_PACK32`, `VK_FORMAT_A8B8G8R8_UINT_PACK32`, `VK_FORMAT_A8B8G8R8_SINT_PACK32`,
    and `VK_FORMAT_A8B8G8R8_SRGB_PACK32`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_A8B8G8R8_UNORM_PACK32`、`VK_FORMAT_A8B8G8R8_UINT_PACK32`、`VK_FORMAT_A8B8G8R8_SINT_PACK32`
    和 `VK_FORMAT_A8B8G8R8_SRGB_PACK32`'
- en: '`VK_FORMAT_A2B10G10R10_UNORM_PACK32` and `VK_FORMAT_A2B10G10R10_UINT_PACK32`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_A2B10G10R10_UNORM_PACK32` 和 `VK_FORMAT_A2B10G10R10_UINT_PACK32`'
- en: '`VK_FORMAT_R16_UINT`, `VK_FORMAT_R16_SINT` and `VK_FORMAT_R16_SFLOAT`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R16_UINT`、`VK_FORMAT_R16_SINT` 和 `VK_FORMAT_R16_SFLOAT`'
- en: '`VK_FORMAT_R16G16_UINT`, `VK_FORMAT_R16G16_SINT` and `VK_FORMAT_R16G16_SFLOAT`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R16G16_UINT`、`VK_FORMAT_R16G16_SINT` 和 `VK_FORMAT_R16G16_SFLOAT`'
- en: '`VK_FORMAT_R16G16B16A16_UINT`, `VK_FORMAT_R16G16B16A16_SINT`, and `VK_FORMAT_R16G16B16A16_SFLOAT`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R16G16B16A16_UINT`、`VK_FORMAT_R16G16B16A16_SINT` 和 `VK_FORMAT_R16G16B16A16_SFLOAT`'
- en: '`VK_FORMAT_R32_UINT`, `VK_FORMAT_R32_SINT`, and `VK_FORMAT_R32_SFLOAT`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32_UINT`、`VK_FORMAT_R32_SINT` 和 `VK_FORMAT_R32_SFLOAT`'
- en: '`VK_FORMAT_R32G32_UINT`, `VK_FORMAT_R32G32_SINT`, and `VK_FORMAT_R32G32_SFLOAT`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32G32_UINT`、`VK_FORMAT_R32G32_SINT` 和 `VK_FORMAT_R32G32_SFLOAT`'
- en: '`VK_FORMAT_R32G32B32A32_UINT`, `VK_FORMAT_R32G32B32A32_SINT`, and `VK_FORMAT_R32G32B32A32_SFLOAT`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R32G32B32A32_UINT`、`VK_FORMAT_R32G32B32A32_SINT` 和 `VK_FORMAT_R32G32B32A32_SFLOAT`'
- en: 'For input attachments from which depth/stencil data will be read, the following
    formats are mandatory:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将读取深度/模板数据的输入附件，以下格式是强制性的：
- en: '`VK_FORMAT_D16_UNORM`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_D16_UNORM`'
- en: '`VK_FORMAT_X8_D24_UNORM_PACK32` or `VK_FORMAT_D32_SFLOAT` (at least one of
    these two formats must be supported)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_X8_D24_UNORM_PACK32` 或 `VK_FORMAT_D32_SFLOAT`（至少必须支持这两种格式之一）'
- en: '`VK_FORMAT_D24_UNORM_S8_UINT` or `VK_FORMAT_D32_SFLOAT_S8_UINT` (at least one
    of these two formats must be supported)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_D24_UNORM_S8_UINT` 或 `VK_FORMAT_D32_SFLOAT_S8_UINT`（至少必须支持这两种格式之一）'
- en: 'Other formats may also be supported but support for them is not guaranteed.
    We can check whether a given format is supported on the platform on which our
    application is executed like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 其他格式也可能被支持，但对它们的支持不能保证。我们可以检查在应用程序执行的平台上的给定格式是否被支持，如下所示：
- en: '[PRE20]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we just need to create an image, allocate a memory object (or use an
    existing one) and bind it to the image, and create an image view. We can do it
    like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要创建一个图像，分配一个内存对象（或使用现有的一个）并将其绑定到图像上，然后创建一个图像视图。我们可以这样做：
- en: '[PRE21]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Images and their views that are created like this can be used as input attachments.
    For this, we need to prepare a proper description of a render pass, and include
    the image views in framebuffers (refer to the *Specifying subpass descriptions*
    and *Creating a framebuffer* recipes from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的图像及其视图可以用作输入附件。为此，我们需要准备一个适当的渲染通道描述，并将图像视图包含在帧缓冲区中（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的*指定子通道描述*和*创建帧缓冲区*配方）。
- en: Inside the GLSL shader code, variables that refer to input attachments are defined
    with a `subpassInput` (possibly with a prefix) keyword.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL着色器代码中，使用`subpassInput`（可能带有前缀）关键字定义引用输入附件的变量。
- en: 'An example of an input attachment defined in a GLSL is provided as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在GLSL中定义的输入附件的示例：
- en: '[PRE22]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看以下配方：
- en: '*Creating an image*'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像*'
- en: '*Allocating and binding memory object to an image*'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象分配和绑定到图像上*'
- en: '*Creating an image view*'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像视图*'
- en: '*Destroying an image view*'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个图像视图*'
- en: '*Destroying an image*'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个图像*'
- en: '*Freeing a memory object*'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放内存对象*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and **Framebuffers*, see the following recipes:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和**帧缓冲区*，查看以下配方：
- en: '*Specifying subpass descriptions*'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a framebuffer*'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个帧缓冲区*'
- en: Creating a descriptor set layout
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建描述符集布局
- en: Descriptor sets gather many resources (descriptors) in one object. They are
    later bound to a pipeline to establish an interface between our application and
    the shaders. But for the hardware to know what resources are grouped in a set,
    how many resources of each type there are, and what their order is, we need to
    create a descriptor set layout.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集在一个对象中聚集了许多资源（描述符）。它们稍后绑定到管道以建立我们的应用程序和着色器之间的接口。但是，为了让硬件知道哪些资源被分组在一个集中，每种类型的资源有多少个，以及它们的顺序是什么，我们需要创建一个描述符集布局。
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a logical device and assign it to a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其分配给名为`logical_device`的`VkDevice`类型变量。
- en: Create a vector variable with elements of type `VkDescriptorSetLayoutBinding`
    and call it `bindings`.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个元素类型为`VkDescriptorSetLayoutBinding`的向量变量，并命名为`bindings`。
- en: 'For each resource you want to create and assign later to a given descriptor
    set, add an element to the `bindings` vector. Use the following values for members
    of each new element:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于您想要创建并稍后分配给给定描述符集的每个资源，向`bindings`向量中添加一个元素。为每个新元素的成员使用以下值：
- en: The selected index of the given resource within a descriptor set for `binding`.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定资源在描述符集中的选择索引用于`binding`
- en: Desired type of a given resource for `descriptorType`
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定资源的期望类型用于`descriptorType`
- en: The number of resources of a specified type accessed through an array inside
    the shader (or 1 if the given resource is not accessed through an array) for `descriptorCount`
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过着色器内部数组访问的指定类型的资源数量（如果给定资源不是通过数组访问，则为1）用于`descriptorCount`
- en: The logical `OR` of all shader stages in which the resource will be accessed
    for `stageFlags`
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源将被访问的所有着色器阶段的逻辑“或”用于`stageFlags`
- en: The `nullptr` value for `pImmutableSamplers`
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`的值用于`pImmutableSamplers`'
- en: 'Create a variable of type `VkDescriptorSetLayoutCreateInfo` named `descriptor_set_layout_create_info`.
    Initialize its members with the following values:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_set_layout_create_info`的`VkDescriptorSetLayoutCreateInfo`类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO` value for `sType`'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO`的值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`的值用于`pNext`'
- en: '`0` value for `flags`'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`的值用于`flags`'
- en: The number of elements in the `bindings` vector for `bindingCount`
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindings`向量中元素的数量用于`bindingCount`'
- en: The pointer to the first element of the `bindings` vector for `pBindings`
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向`bindings`向量第一个元素的指针用于`pBindings`
- en: Create a variable of type `VkDescriptorSetLayout` named `descriptor_set_layout`,
    in which the created layout will be stored.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_set_layout`的`VkDescriptorSetLayout`类型的变量，其中将存储创建的布局。
- en: Call `vkCreateDescriptorSetLayout( logical_device, &descriptor_set_layout_create_info,
    nullptr, &descriptor_set_layout )` and provide the handle of the logical device,
    a pointer to the `descriptor_set_layout_create_info` variable, a `nullptr` value,
    and a pointer to the `descriptor_set_layout variable`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateDescriptorSetLayout(logical_device, &descriptor_set_layout_create_info,
    nullptr, &descriptor_set_layout)`并提供逻辑设备的句柄、`descriptor_set_layout_create_info`变量的指针、一个`nullptr`值以及`descriptor_set_layout`变量的指针。
- en: Make sure the call was successful by checking whether the return value is equal
    to `VK_SUCCESS`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查返回值是否等于`VK_SUCCESS`来确保调用成功。
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The descriptor set layout specifies the internal structure of a descriptor set
    and, at the same time, strictly defines what resources can be bound to the descriptor
    set (we can't use resources other than those specified in the layout).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集布局指定了描述符集的内部结构，同时严格定义了可以绑定到描述符集上的资源（我们不能使用布局中未指定的资源）。
- en: 'When we want to create layouts, we need to know what resources (descriptor
    types) will be used and what their order will be. The order is specified through
    bindings--they define the index (position) of a resource within a given set and
    are also used inside shaders (with a set number through a `layout` qualifier)
    to specify a resource we want to access:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建布局时，我们需要知道将使用哪些资源（描述符类型）以及它们的顺序。顺序通过绑定来指定——它们定义了资源在给定集中的索引（位置），并在着色器内部（通过`layout`限定符的集合号）用于指定我们想要访问的资源：
- en: '[PRE23]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can choose any values for bindings, but we should keep in mind that unused
    indices may consume memory and impact the performance of our application.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为绑定选择任何值，但我们应该记住，未使用的索引可能会消耗内存并影响我们应用程序的性能。
- en: To avoid unnecessary memory overhead and a negative performance impact, we should
    keep descriptor bindings as compact and as close to `0` as possible.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不必要的内存开销和负面的性能影响，我们应该保持描述符绑定尽可能紧凑，尽可能接近`0`。
- en: 'To create a descriptor set layout, we first need to specify a list of all the
    resources used in a given set:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建描述符集布局，我们首先需要指定给定集中使用的所有资源的列表：
- en: '[PRE24]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we can create the layout like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建如下布局：
- en: '[PRE25]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Descriptor set layouts (along with push constant ranges) also form a pipeline
    layout, which defines what type of resources can be accessed by a given pipeline.
    Created layouts, apart from pipeline layout creation, are also required during
    descriptor set allocation.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集布局（以及推送常量范围）也形成了一个管线布局，它定义了给定管线可以访问的资源类型。除了管线布局创建之外，创建的布局在描述符集分配期间也是必需的。
- en: See also
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipe:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)“图形和计算管线”中，查看以下配方：
- en: '*Creating a pipeline layout*'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*'
- en: 'In this chapter, see the following recipe:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，查看以下配方：
- en: '*Allocating descriptor sets*'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: Creating a descriptor pool
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建描述符池
- en: Descriptors, gathered into sets, are allocated from descriptor pools. When we
    create a pool, we must define which descriptors, and how many of them, can be
    allocated from the created pool.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符，收集到集合中，是从描述符池中分配的。当我们创建一个池时，我们必须定义哪些描述符，以及它们中可以有多少可以从创建的池中分配。
- en: How to do it...
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a logical device on which the descriptor pool should be created.
    Store it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应该在之上创建描述符池的逻辑设备的句柄。将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Create a vector variable named `descriptor_types` with elements of type `VkDescriptorPoolSize`.
    For each type of descriptor that will be allocated from the pool, add a new element
    to the `descriptor_types` variable defining the specified type of descriptor and
    the number of descriptors of a given type that will be allocated from the pool.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_types`的向量变量，其元素类型为`VkDescriptorPoolSize`。对于将从池中分配的每种描述符类型，向`descriptor_types`变量添加一个新元素，定义指定的描述符类型以及将从池中分配的给定类型的描述符数量。
- en: 'Create a variable of type `VkDescriptorPoolCreateInfo` named `descriptor_pool_create_info`.
    Use the following values for members of this variable:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_pool_create_info`的`VkDescriptorPoolCreateInfo`类型的变量。为此变量的成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO` value for `sType`'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO`的`sType`值'
- en: '`nullptr` value for `pNext`'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的值为`nullptr`'
- en: '`VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT` value if it should be possible
    to free individual sets allocated from this pool or a `0` value to only allow
    for freeing all the sets at once (through a pool reset operation) for `flags`'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应该可能释放从该池分配的单独的集，则`VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT`值为`1`，或者为`0`值以仅允许通过池重置操作一次性释放所有集（对于`flags`）。
- en: The maximal number of sets that can be allocated from the pool for `maxSets`
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 池中可以分配的最大集数`maxSets`
- en: Number of elements in the `descriptor_types` vector for `poolSizeCount`
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poolSizeCount`的`descriptor_types`向量中的元素数量'
- en: Pointer to the first element of the `descriptor_types` vector for `pPoolSizes`
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pPoolSizes`的`descriptor_types`向量的第一个元素的指针'
- en: Create a variable of type `VkDescriptorPool` named `descriptor_pool` in which
    the handle of the created pool will be stored.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_pool`的`VkDescriptorPool`类型的变量，其中将存储创建的池的句柄。
- en: Call `vkCreateDescriptorPool( logical_device, &descriptor_pool_create_info,
    nullptr, &descriptor_pool )` and provide the `logical_device` variable, a pointer
    to the `descriptor_pool_create_info` variable, a `nullptr` value, and a pointer
    to the `descriptor_pool` variable.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateDescriptorPool(logical_device, &descriptor_pool_create_info, nullptr,
    &descriptor_pool)`并提供`logical_device`变量、`descriptor_pool_create_info`变量的指针、一个`nullptr`值和一个指向`descriptor_pool`变量的指针。
- en: Make sure the pool was successfully created by checking whether the call returned
    a `VK_SUCCESS` value.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过检查调用是否返回了`VK_SUCCESS`值来确认池是否成功创建。
- en: How it works...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Descriptor pools manage the resources used for allocating descriptor sets (in
    a similar way to how command pools manage memory for command buffers). During
    descriptor pool creation, we specify the maximal amount of sets that can be allocated
    from a given pool and the maximal number of descriptors of a given type that can
    be allocated across all sets. This information is provided through a variable
    of type `VkDescriptorPoolCreateInfo` like this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符池管理用于分配描述符集的资源（类似于命令池管理命令缓冲区的内存）。在创建描述符池期间，我们指定可以从给定池中分配的最大集数和可以跨所有集分配的给定类型的最大描述符数。此信息通过类型为`VkDescriptorPoolCreateInfo`的变量提供，如下所示：
- en: '[PRE26]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, the types of descriptors and their total number are
    provided through a `descriptor_types` vector variable. It may contain multiple
    elements and the created pool will be big enough to allow for allocation of all
    the specified descriptors.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，描述符的类型及其总数是通过`descriptor_types`向量变量提供的。它可能包含多个元素，创建的池将足够大，可以分配所有指定的描述符。
- en: 'The pool itself is created like this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 池本身创建方式如下：
- en: '[PRE27]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we have created a pool, we can allocate descriptor sets from it. But we
    must remember that we can't do this in multiple threads at the same time.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个池，我们可以从中分配描述符集。但我们必须记住，我们不能同时以多线程的方式做这件事。
- en: We can't allocate descriptor sets from a given pool simultaneously in multiple
    threads.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在多个线程中同时从给定的池中分配描述符集。
- en: See also
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipes in this chapter:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看以下食谱：
- en: '*Allocating descriptor sets*'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Freeing descriptor sets*'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放描述符集*'
- en: '*Resetting a descriptor pool*'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置描述符池*'
- en: '*Destroying a descriptor pool*'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁描述符池*'
- en: Allocating descriptor sets
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配描述符集
- en: Descriptor sets gather shader resources (descriptors) in one container object.
    Its contents, types, and number of resources are defined by a descriptor set layout;
    storage is taken from pools, from which we can allocate descriptor sets.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集在一个容器对象中聚集着着色器资源（描述符）。其内容、类型和资源数量由描述符集布局定义；存储是从池中获取的，我们可以从池中分配描述符集。
- en: How to do it...
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the logical device and store its handle in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取逻辑设备并将其句柄存储在名为`logical_device`的`VkDevice`类型的变量中。
- en: Prepare a descriptor pool from which descriptor sets should be allocated. Use
    the pool's handle to initialize a variable of type `VkDescriptorPool` named `descriptor_pool`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个描述符池，从该池中分配描述符集。使用池的句柄初始化一个名为`descriptor_pool`的`VkDescriptorPool`类型的变量。
- en: Create a variable of type `std::vector<VkDescriptorSetLayout>` named `descriptor_set_layouts`.
    For each descriptor set that should be allocated from the pool, add a handle of
    a descriptor set layout that defines the structure of a corresponding descriptor
    set.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_set_layouts`的`std::vector<VkDescriptorSetLayout>`类型的变量。对于应该从池中分配的每个描述符集，添加一个定义相应描述符集结构的描述符集布局句柄。
- en: 'Create a variable of type `VkDescriptorSetAllocateInfo` named `descriptor_set_allocate_info`
    and use the following values for its members:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `descriptor_set_allocate_info` 的类型为 `VkDescriptorSetAllocateInfo` 的变量，并为其成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO` value for `sType`'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO` 的值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: The `descriptor_pool` variable for `descriptorPool`
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptor_pool` 变量用于 `descriptorPool`'
- en: The number of elements in the `descriptor_set_layouts` vector for `descriptorSetCount`
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptor_set_layouts` 向量中 `descriptorSetCount` 的元素数量'
- en: The pointer to the first element of the `descriptorSetCount` vector for `pSetLayouts`
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptorSetCount` 向量的第一个元素指针用于 `pSetLayouts`'
- en: Create a vector variable of type `std::vector<VkDescriptorSet>` named `descriptor_sets`
    and resize it to match the size of the `descriptor_set_layouts` vector.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `descriptor_sets` 的类型为 `std::vector<VkDescriptorSet>` 的向量变量，并将其大小调整为与
    `descriptor_set_layouts` 向量的大小相匹配。
- en: Call `vkAllocateDescriptorSets( logical_device, &descriptor_set_allocate_info,
    &descriptor_sets[0] )` and provide the `logical_device` variable, a pointer to
    the `descriptor_set_allocate_info` variable, and a pointer to the first element
    of the `descriptor_sets` vector.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkAllocateDescriptorSets( logical_device, &descriptor_set_allocate_info,
    &descriptor_sets[0] )` 并提供 `logical_device` 变量、`descriptor_set_allocate_info`
    变量的指针以及 `descriptor_sets` 向量第一个元素的指针。
- en: Make sure the call was successful and the `VK_SUCCESS` value was returned.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用成功并返回了 `VK_SUCCESS` 值。
- en: How it works...
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Descriptor sets are used to provide resources to shaders. They form an interface
    between the application and programmable pipeline stages. The structure of this
    interface is defined by the descriptor set layouts. And the actual data is provided
    when we update descriptor sets with image or buffer resources and later bind these
    descriptor sets to the command buffer during the recording operation.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集用于向着色器提供资源。它们在应用程序和可编程管道阶段之间形成一个接口。该接口的结构由描述符集布局定义。实际数据是在我们使用图像或缓冲区资源更新描述符集时提供，并在记录操作期间将这些描述符集绑定到命令缓冲区时提供。
- en: Descriptor sets are allocated from pools. When we create a pool, we specify
    how many descriptors (resources) and of what type we can allocate from it across
    all descriptor sets that will be allocated from the pool. We also specify the
    maximum number of descriptor sets that can be allocated from the pool.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集是从池中分配的。当我们创建池时，我们指定可以从池中分配多少描述符（资源）以及其类型，以及可以从中分配的最大描述符集数量。
- en: 'When we want to allocate descriptor sets, we need to specify layouts that will
    describe their internal structure--one layout for each descriptor set. This information
    is specified like this:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要分配描述符集时，我们需要指定将描述其内部结构的布局——每个描述符集一个布局。此信息指定如下：
- en: '[PRE28]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we allocate descriptor sets in the following way:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照以下方式分配描述符集：
- en: '[PRE29]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Unfortunately, the pool''s memory may become fragmented when we allocate and
    free separate descriptor sets. In such situations, we may not be able to allocate
    new sets from a given pool, even if we haven''t reached the specified limits.
    This situation is presented in the following diagram:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们分配和释放单独的描述符集时，池的内存可能会变得碎片化。在这种情况下，我们可能无法从给定的池中分配新的集合，即使我们没有达到指定的限制。这种情况在以下图中展示：
- en: '![](img/B05542-05-02.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05542-05-02.png)'
- en: When we first allocate descriptors sets, the fragmentation problem will not
    occur. Additionally, if all descriptor sets use the same number of resources of
    the same type, it is guaranteed that this problem won't appear either.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次分配描述符集时，不会出现碎片化问题。此外，如果所有描述符集使用相同类型的资源数量，则可以保证不会出现此类问题。
- en: To avoid problems with pool fragmentation, we can free all descriptor sets at
    once (by resetting a pool). Otherwise, if we can't allocate a new descriptor set
    and we don't want to reset the pool, we need to create another pool.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免池碎片化问题，我们可以一次性释放所有描述符集（通过重置池）。否则，如果我们无法分配新的描述符集，并且不想重置池，我们需要创建另一个池。
- en: See also
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipes in this chapter:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看以下食谱：
- en: '*Creating a descriptor set layout*'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Creating a descriptor pool*'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符池*'
- en: '*Freeing descriptor sets*'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放描述符集*'
- en: '*Resetting a descriptor pool*'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置描述符池*'
- en: Updating descriptor sets
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新描述符集
- en: We have created a descriptor pool and allocated descriptor sets from it. We
    know their internal structure thanks to created layouts. Now we want to provide
    specific resources (samplers, image views, buffers, or buffer views) that should
    be later bound to the pipeline through descriptor sets. Defining resources that
    should be used is done through a process of updating descriptor sets.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个描述符池，并从中分配了描述符集。由于创建了布局，我们知道了它们的内部结构。现在我们想要提供特定的资源（采样器、图像视图、缓冲区或缓冲区视图），这些资源稍后应通过描述符集绑定到管线。定义要使用的资源是通过更新描述符集的过程完成的。
- en: Getting ready
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Updating descriptor sets requires us to provide a considerable amount of data
    for each descriptor involved in the process. What's more, the provided data depends
    on the type of descriptor. To simplify the process and lower the number of parameters
    that need to be specified, and also to improve error checking, custom structures
    are introduced in this recipe.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 更新描述符集需要我们为每个参与过程描述符提供相当数量的数据。更重要的是，提供的数据取决于描述符的类型。为了简化过程并减少需要指定的参数数量，以及为了提高错误检查，在此配方中引入了自定义结构。
- en: 'For samplers and all kinds of image descriptors, an `ImageDescriptorInfo` type
    is used which has the following definition:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 对于采样器和各种图像描述符，使用 `ImageDescriptorInfo` 类型，其定义如下：
- en: '[PRE30]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For uniform and storage buffers (and their dynamic variations), a `BufferDescriptorInfo`
    type is used. It has the following definition:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统一和存储缓冲区（及其动态变体），使用 `BufferDescriptorInfo` 类型。其定义如下：
- en: '[PRE31]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For uniform and storage texel buffers, a `TexelBufferDescriptorInfo` type is
    introduced with the following definition:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统一和存储纹理缓冲区，引入了 `TexelBufferDescriptorInfo` 类型，其定义如下：
- en: '[PRE32]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding structures are used when we want to update descriptor sets with
    handles of new descriptors (that haven''t been bound yet). It is also possible
    to copy descriptor data from other, already updated, sets. For this purpose, a
    `CopyDescriptorInfo` type is used that is defined like this:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用新描述符的句柄更新描述符集时，使用前面的结构。也可以从其他已更新的集中复制描述符数据。为此，使用 `CopyDescriptorInfo`
    类型，其定义如下：
- en: '[PRE33]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All the preceding structures define the handle of a descriptor set that should
    be updated, an index of a descriptor within the given set, and an index into an
    array if we want to update descriptors accessed through arrays. The rest of the
    parameters are type-specific.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的结构定义了应更新的描述符集的句柄、给定集中描述符的索引，以及如果我们想通过数组访问描述符，则数组中的索引。其余参数是类型特定的。
- en: How to do it...
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the handle of a logical device to initialize a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用逻辑设备的句柄初始化一个名为 `logical_device` 的 `VkDevice` 类型的变量。
- en: 'Create a variable of type `std::vector<VkWriteDescriptorSet>` named `write_descriptors`.
    For each new descriptor that should be updated, add a new element to the vector
    and use the following values for its members:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `write_descriptors` 的 `std::vector<VkWriteDescriptorSet>` 类型的变量。对于每个需要更新的新描述符，向向量中添加一个新元素，并为其成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET` value for `sType`'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET` 的 `sType` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: The handle of a descriptor set that should be updated for `dstSet`
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应更新的描述符集的句柄为 `dstSet`
- en: Index (binding) of a descriptor within a specified set for `dstBinding`
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定集中描述符的索引（绑定）为 `dstBinding`
- en: The beginning index into an array from which descriptors should be updated if
    the given descriptor is accessed through an array inside shaders (or `0` value
    otherwise) for `dstArrayElement`
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在着色器内部通过数组访问给定的描述符，则从数组中更新的描述符的起始索引为 `dstArrayElement`（否则为 `0` 值）
- en: The number of descriptors to be updated (number of elements in `pImageInfo`,
    `pBufferInfo` or `pTexelBufferView` arrays) for `descriptorCount`
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `descriptorCount`，要更新的描述符数量（`pImageInfo`、`pBufferInfo` 或 `pTexelBufferView`
    数组中的元素数量）
- en: The type of descriptor for `descriptorType`
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述符的类型为 `descriptorType`
- en: 'In the case of sampler or image descriptors, specify an array with the `descriptorCount`
    elements and provide a pointer to its first element in `pImageInfo` (set `pBufferInfo`
    and `pTexelBufferView` members to `nullptr`). Use the following values for each
    array element:'
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在采样器或图像描述符的情况下，指定一个包含 `descriptorCount` 个元素的数组，并在 `pImageInfo` 中提供其第一个元素的指针（将
    `pBufferInfo` 和 `pTexelBufferView` 成员设置为 `nullptr`）。为每个数组元素使用以下值：
- en: The sampler handle in the case of sampler and combined image sampler descriptors
    for `sampler`
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在采样器描述符的情况下，用于`sampler`的组合图像采样器描述符的采样器句柄
- en: The image view handle in the case of the sampled image, storage image, combined
    image sampler, and input attachment descriptors for `imageView`
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在采样图像、存储图像、组合图像采样器和输入附件描述符的情况下，用于`imageView`的图像视图句柄
- en: The layout the given image will be in when a descriptor is accessed through
    shaders in the case of image descriptors for `imageLayout`
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过着色器访问描述符时，给定图像将处于的布局情况，对于图像描述符的`imageLayout`
- en: 'In the case of uniform or storage buffers (and their dynamic variations), specify
    an array with the `descriptorCount` elements and provide a pointer to its first
    element in `pBufferInfo` (set `pImageInfo` and `pTexelBufferView` members to `nullptr`),
    and use the following values for each array element:'
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在均匀或存储缓冲区（及其动态变体）的情况下，指定一个包含`descriptorCount`个元素的数组，并在`pBufferInfo`中提供其第一个元素的指针（将`pImageInfo`和`pTexelBufferView`成员设置为`nullptr`），并为每个数组元素使用以下值：
- en: The buffer's handle for `buffer`
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区的句柄用于`buffer`
- en: The memory offset (or base offset for dynamic descriptors) within a buffer for
    `offset`
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区内的内存偏移量（或动态描述符的基偏移量）用于`offset`
- en: The buffer's memory size that should be used for a given descriptor for `range`
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定描述符的`range`，应使用的缓冲区内存大小
- en: In the case of uniform texel buffers or storage texel buffers, specify an array
    with the `descriptorCount` number of texel view handles, and provide a pointer
    to its first element in `pTexelBufferView` (set `pImageInfo` and `pBufferInfo`
    members to `nullptr`).
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在均匀的texel缓冲区或存储texel缓冲区的情况下，指定一个包含`descriptorCount`个texel视图句柄的数组，并在`pTexelBufferView`中提供其第一个元素的指针（将`pImageInfo`和`pBufferInfo`成员设置为`nullptr`）。
- en: 'Create a variable of type `std::vector<VkCopyDescriptorSet>` named `copy_descriptors`.
    Add an element to this vector for each descriptor data that should be copied from
    another, already updated, descriptor. Use the following values for the members
    of each new element:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`copy_descriptors`的`std::vector<VkCopyDescriptorSet>`类型的变量。对于应从另一个已更新的描述符复制的数据，向此向量添加一个元素。为每个新元素的成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET` value for `sType`'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET`值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`值用于`pNext`'
- en: The handle of a descriptor set from which data should be copied for `srcSet`
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应从其中复制数据的描述符集的句柄用于`srcSet`
- en: The binding number from within a source descriptor set for `srcBinding`
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源描述符集中用于`srcBinding`的绑定编号
- en: The index into an array in the source descriptor set for `srcArrayElement`
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源描述符集中用于`srcArrayElement`的数组索引
- en: The handle of a descriptor set in which data should be updated for `dstSet`
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在其中更新数据的描述符集的句柄用于`dstSet`
- en: The binding number in the target descriptor set for `dstBinding`
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标描述符集中用于`dstBinding`的绑定编号
- en: The array index in the target descriptor set for `dstArrayElement`
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标描述符集中用于`dstArrayElement`的数组索引
- en: The number of descriptors that should be copied from the source set and updated
    in the target set for `descriptorCount`
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应从源集复制并更新到目标集的描述符数量用于`descriptorCount`
- en: Call `vkUpdateDescriptorSets( logical_device, static_cast<uint32_t>(write_descriptors.size()),
    &write_descriptors[0], static_cast<uint32_t>(copy_descriptors.size()), &copy_descriptors[0]
    )` and provide the `logical_device` variable, the number of elements in the `write_descriptors`
    vector, a pointer to the first element of the `write_descriptors`, the number
    of elements in the `copy_descriptors` vector, and a pointer to the first element
    of the `copy_descriptors` vector.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkUpdateDescriptorSets(logical_device, static_cast<uint32_t>(write_descriptors.size()),
    &write_descriptors[0], static_cast<uint32_t>(copy_descriptors.size()), &copy_descriptors[0])`并提供`logical_device`变量、`write_descriptors`向量的元素数量、`write_descriptors`的第一个元素的指针、`copy_descriptors`向量的元素数量和`copy_descriptors`向量的第一个元素的指针。
- en: How it works...
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Updating descriptor sets causes specified resources (samplers, image views,
    buffers, or buffer views) to populate entries in the indicated sets. When the
    updated set is bound to a pipeline, such resources can be accessed through shaders.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 更新描述符集会导致指定的资源（采样器、图像视图、缓冲区或缓冲区视图）填充指示集中的条目。当更新的集被绑定到管线时，这些资源可以通过着色器访问。
- en: 'We can write new (not used yet) resources to a descriptor set. In the following
    example, we do this by using the custom structures mentioned in the *Getting ready*
    section:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将新的（尚未使用）资源写入描述符集。在以下示例中，我们通过使用*准备就绪*部分中提到的自定义结构来实现这一点：
- en: '[PRE34]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also reuse descriptors from other sets. Copying already populated descriptors
    should be faster than writing new ones. This can be done like this:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重用其他集的描述符。复制已填充的描述符应该比编写新的描述符更快。这可以通过以下方式完成：
- en: '[PRE35]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The operation of updating descriptor sets is performed through a single function
    call:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 更新描述符集的操作通过单个函数调用执行：
- en: '[PRE36]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipes in this chapter:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 参见本章中的以下配方：
- en: '*Allocating descriptor sets*'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Binding descriptor sets*'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: '*Creating descriptors with a texture and a uniform buffer*'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用纹理和统一缓冲区创建描述符*'
- en: Binding descriptor sets
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定描述符集
- en: When a descriptor set is ready (we have updated it with all the resources that
    will be accessed in shaders), we need to bind it to a command buffer during the
    recording operation.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当描述符集准备就绪（我们已使用将在着色器中访问的所有资源更新了它）时，我们需要在记录操作期间将其绑定到命令缓冲区。
- en: How to do it...
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a command buffer that is being recorded. Store the handle
    in a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获正在记录的命令缓冲区的句柄。将句柄存储在名为 `command_buffer` 的 `VkCommandBuffer` 类型变量中。
- en: Create a variable of type `VkPipelineBindPoint` named `pipeline_type` that will
    represent the type of a pipeline (graphics or compute) in which descriptor sets
    will be used.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pipeline_type` 的 `VkPipelineBindPoint` 类型变量，它将表示描述符集将使用的管道类型（图形或计算）。
- en: Take the pipeline's layout and store its handle in a variable of type `VkPipelineLayout`
    named `pipeline_layout` (refer to the *Creating a pipeline layout* recipe from
    [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取管道布局并将句柄存储在名为 `pipeline_layout` 的 `VkPipelineLayout` 类型变量中（参考第 8 章 *创建管道布局*
    配方，*图形和计算管道*）。
- en: Create a variable of type `std::vector<VkDescriptorSet>` named `descriptor_sets`.
    For each descriptor set that should be bound to the pipeline, add a new element
    to the vector and initialize it with the descriptor set's handle.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `descriptor_sets` 的 `std::vector<VkDescriptorSet>` 类型变量。对于每个需要绑定到管道的描述符集，向向量中添加一个新元素，并用描述符集的句柄初始化它。
- en: Select an index to which the first set from the provided list should be bound.
    Store the index in a variable of type `uint32_t` named `index_for_first_set`.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个索引，将提供的列表中的第一个集绑定到该索引。将索引存储在名为 `index_for_first_set` 的 `uint32_t` 类型变量中。
- en: If dynamic uniform or storage buffers are used in any of the sets being bound,
    create a variable of type `std::vector<uint32_t>` named `dynamic_offsets`, through
    which provide memory offset values for each dynamic descriptor defined in all
    the sets being bound. Offsets must be defined in the same order in which their
    corresponding descriptors appear in the layouts of each set (in order of increasing
    bindings).
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在任何被绑定的集中使用了动态统一或存储缓冲区，创建一个名为 `dynamic_offsets` 的 `std::vector<uint32_t>`
    类型变量，通过它提供所有被绑定的集中定义的每个动态描述符的内存偏移量。偏移量必须在每个集的布局中按其对应的描述符出现的顺序定义（按递增的绑定顺序）。
- en: 'Make the following call:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下调用：
- en: '[PRE37]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For this call, provide the `command_buffer`, `pipeline_type`, `pipeline_layout`,
    and `index_for_first_set` variables, the number of elements and a pointer to the
    first element of the `descriptor_sets` vector, and the number of elements and
    a pointer to the first element of the `dynamic_offsets` vector.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此调用，提供 `command_buffer`、`pipeline_type`、`pipeline_layout` 和 `index_for_first_set`
    变量，元素数量以及 `descriptor_sets` 向量第一个元素指针，以及元素数量和 `dynamic_offsets` 向量第一个元素指针。
- en: How it works...
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we start recording a command buffer, its state is (almost entirely) undefined.
    So before we can record drawing operations that reference image or buffer resources,
    we need to bind appropriate resources to the command buffer. This is done by binding
    descriptor sets with the `vkCmdBindDescriptorSets()` function call like this:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始记录命令缓冲区时，其状态（几乎全部）是未定义的。因此，在我们能够记录引用图像或缓冲区资源的绘制操作之前，我们需要将适当的资源绑定到命令缓冲区。这是通过使用
    `vkCmdBindDescriptorSets()` 函数调用绑定描述符集来完成的，如下所示：
- en: '[PRE38]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipes in this chapter:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 参见本章中的以下配方：
- en: '*Creating a descriptor set layout*'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Allocating descriptor sets*'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Updating descriptor sets*'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: Creating descriptors with a texture and a uniform buffer
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理和统一缓冲区创建描述符
- en: 'In this sample recipe, we will see how to create the most commonly used resources:
    a combined image sampler and a uniform buffer. We will prepare a descriptor set
    layout for them, create a descriptor pool, and allocate a descriptor set from
    it. Then we will update the allocated set with the created resources. This way,
    we can later bind the descriptor set to a command buffer and access resources
    in shaders.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例配方中，我们将了解如何创建最常用的资源：组合图像采样器和统一缓冲区。我们将为它们准备描述符集布局，创建描述符池，并从中分配描述符集。然后我们将使用创建的资源更新分配的集。这样，我们就可以稍后绑定描述符集到命令缓冲区，并在着色器中访问资源。
- en: How to do it...
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a combined image sampler (an image, image view, and a sampler) with the
    selected parameters--the most commonly used are `VK_IMAGE_TYPE_2D` image type,
    `VK_FORMAT_R8G8B8A8_UNORM` format, `VK_IMAGE_VIEW_TYPE_2D` view type, `VK_IMAGE_ASPECT_COLOR_BIT`
    aspect, `VK_FILTER_LINEAR` filter mode, and `VK_SAMPLER_ADDRESS_MODE_REPEAT` addressing
    mode for all texture coordinates. Store the created handles in a variable of type
    `VkSampler` named `sampler`, of type `VkImage` named `sampled_image`, and another
    one of type `VkImageView` named `sampled_image_view` (refer to the *Creating a
    combined image sampler* recipe).
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所选参数创建一个组合图像采样器（一个图像、图像视图和一个采样器）--最常用的参数包括`VK_IMAGE_TYPE_2D`图像类型、`VK_FORMAT_R8G8B8A8_UNORM`格式、`VK_IMAGE_VIEW_TYPE_2D`视图类型、`VK_IMAGE_ASPECT_COLOR_BIT`属性、`VK_FILTER_LINEAR`过滤器模式以及所有纹理坐标的`VK_SAMPLER_ADDRESS_MODE_REPEAT`寻址模式。将创建的句柄存储在名为`sampler`的`VkSampler`类型变量中、名为`sampled_image`的`VkImage`类型变量中，以及名为`sampled_image_view`的`VkImageView`类型变量中（参考*创建组合图像采样器*配方）。
- en: Create a uniform buffer with selected parameters and store the buffer's handle
    in a variable of type `VkBuffer` named `uniform_buffer` (refer to the *Creating
    a uniform buffer* recipe).
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所选参数创建一个统一缓冲区，并将缓冲区的句柄存储在名为`uniform_buffer`的`VkBuffer`类型变量中（参考*创建统一缓冲区*配方）。
- en: Create a variable named `bindings` of type `std::vector<VkDescriptorSetLayoutBinding>`.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`bindings`的`std::vector<VkDescriptorSetLayoutBinding>`类型变量。
- en: 'Add one element with the following values to the `bindings` variable:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`bindings`变量添加一个具有以下值的元素：
- en: '`0` value for `binding`'
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`的值为`0`。'
- en: '`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` value for `descriptorType`'
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptorType`的值为`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`。'
- en: '`1` value for `descriptorCount`'
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptorCount`的值为`1`。'
- en: The `VK_SHADER_STAGE_FRAGMENT_BIT` value for `stageFlags`
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stageFlags`的值为`VK_SHADER_STAGE_FRAGMENT_BIT`。'
- en: The `nullptr` value for `stageFlags`
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stageFlags`的值为`nullptr`。'
- en: 'Add another element to the `bindings` vector and use the following values for
    its members:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`bindings`向量添加另一个元素，并为其成员使用以下值：
- en: '`1` value for `binding`'
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`的值为`1`。'
- en: '`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` value for `descriptorType`'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptorType`的值为`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`。'
- en: '`1` value for `descriptorCount`'
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptorCount`的值为`1`。'
- en: The `VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT` value for `stageFlags`
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stageFlags`的值为`VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT`。'
- en: The `nullptr` value for `pImmutableSamplers`
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pImmutableSamplers`的值为`nullptr`。'
- en: Create a descriptor set layout using the `bindings` variable and store its handle
    in a variable of type `VkDescriptorSetLayout` named `descriptor_set_layout` (refer
    to the *Creating a descriptor set layout* recipe).
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`bindings`变量创建一个描述符集布局，并将句柄存储在名为`descriptor_set_layout`的`VkDescriptorSetLayout`类型变量中（参考*创建描述符集布局*配方）。
- en: 'Create a variable of type `std::vector<VkDescriptorPoolSize>` named `descriptor_types`.
    Add two elements to the created vector: one with `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`
    and `1` values, the second with `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` and `1` values.'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_types`的`std::vector<VkDescriptorPoolSize>`类型变量。向创建的向量添加两个元素：一个具有`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`和`1`的值，另一个具有`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`和`1`的值。
- en: Create a descriptor pool in which separate descriptor sets cannot be freed individually
    and only one descriptor set can be allocated. Use the `descriptor_types` variable
    during pool creation and store its handle in a variable of type `VkDescriptorPool`
    named `descriptor_pool` (refer to the *Creating a descriptor pool* recipe).
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符池，其中单独的描述符集不能单独释放，只能分配一个描述符集。在创建池时使用`descriptor_types`变量，并将句柄存储在名为`descriptor_pool`的`VkDescriptorPool`类型变量中（参考*创建描述符池*配方）。
- en: Allocate one descriptor set from `descriptor_pool` using the `descriptor_set_layout`
    layout variable. Store the created handle in a one-element vector of type `std::vector<VkDescriptorSet>`
    named `descriptor_sets` (refer to the *Allocating descriptor sets* recipe).
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<ImageDescriptorInfo>` named `image_descriptor_infos`.
    Add one element to this vector with the following values:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `descriptor_sets[0]` for `TargetDescriptorSet`
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `TargetDescriptorBinding`'
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `TargetArrayElement`'
  id: totrans-583
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` value for `TargetDescriptorType`'
  id: totrans-584
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add one element to the `ImageInfos` member vector with the following values:'
  id: totrans-585
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sampler` variable for `sampler`
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sampled_image_view` variable for `imageView`
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value for `imageLayout`
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a variable of type `std::vector<BufferDescriptorInfo>` named `buffer_descriptor_infos`
    with one element initialized with the following values:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `descriptor_sets[0]` for `TargetDescriptorSet`
  id: totrans-590
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` value for `TargetDescriptorBinding`'
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` value for `TargetArrayElement`'
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` value for `TargetDescriptorType`'
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add one element to the `BufferInfos` member vector and use the following values
    to initialize its members:'
  id: totrans-594
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `uniform_buffer` variable for `buffer`
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `0` for `offset`
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VK_WHOLE_SIZE` value for `range`
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the descriptor sets using the `image_descriptor_infos` and `buffer_descriptor_infos`
    vectors.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prepare the typically used descriptors, a combined image sampler and a uniform
    buffer, we first need to create them:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we prepare a layout that will define the internal structure of a descriptor
    set:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, we create a descriptor pool and allocate a descriptor set from
    it:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last thing to do is to update the descriptor set with the resources created
    at the beginning:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the following recipes in this chapter:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a combined image sampler*'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a uniform buffer*'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a descriptor set layout*'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a descriptor pool*'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating descriptor sets*'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updating descriptor sets*'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freeing descriptor sets
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to return memory allocated by a descriptor set and give it back to
    the pool, we can free a given descriptor set.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use the handle of a logical device to initialize a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the descriptor pool that was created with a `VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT`
    flag. Store its handle in a variable of type `VkDescriptorPool` named `descriptor_pool`.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a vector of type `std::vector<VkDescriptorSet>` named `descriptor_sets`.
    Add all the descriptor sets that should be freed to the vector.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkFreeDescriptorSets( logical_device, descriptor_pool, static_cast<uint32_t>(descriptor_sets.size()),
    descriptor_sets.data() )`. For the call provide the `logical_device` and `descriptor_pool`
    variables, the number of elements in the `descriptor_sets` vector, and a pointer
    to the first element of the `descriptor_sets` vector.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkFreeDescriptorSets(logical_device, descriptor_pool, static_cast<uint32_t>(descriptor_sets.size()),
    descriptor_sets.data())`。对于调用，提供`logical_device`和`descriptor_pool`变量，`descriptor_sets`向量的元素数量，以及`descriptor_sets`向量第一个元素的指针。
- en: Make sure the call was successful by checking whether it returns a `VK_SUCCESS`
    value.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查它是否返回`VK_SUCCESS`值来确保调用成功。
- en: Clear the `descriptor_sets` vector as we can't use the handles of freed descriptor
    sets any more.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不能再使用已释放描述符集的句柄，因此清除`descriptor_sets`向量。
- en: How it works...
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Freeing a descriptor set releases memory used by it and gives it back to the
    pool. It should be possible to allocate another set of the same type from the
    pool but it may not be possible due to the pool's memory fragmentation (in such
    a situation, we may need to create another pool or reset the one from which the
    set was allocated).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 释放描述符集会释放它所使用的内存并将其归还到池中。应该可以从池中分配相同类型的另一组描述符集，但由于池的内存碎片化，这可能不可行（在这种情况下，我们可能需要创建另一个池或重置分配该集的池）。
- en: 'We can free multiple descriptor sets at once, but all of them must come from
    the same pool. It is done like this:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一次性释放多个描述符集，但所有这些描述符集都必须来自同一池。这样做：
- en: '[PRE43]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We cannot free descriptor sets allocated from the same pool from multiple threads
    at the same time.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能同时从多个线程释放来自同一池的描述符集。
- en: See also
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipes in this chapter:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章中的以下食谱：
- en: '*Creating a descriptor pool*'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符池*'
- en: '*Allocating descriptor sets*'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Resetting a descriptor pool*'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置描述符池*'
- en: '*Destroying a descriptor pool*'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁描述符池*'
- en: Resetting a descriptor pool
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置描述符池
- en: We can free all descriptor sets allocated from a given pool at once without
    destroying the pool itself. To do that, we can reset a descriptor pool.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一次性释放从给定池分配的所有描述符集，而不销毁池本身。为此，我们可以重置描述符池。
- en: How to do it...
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the descriptor pool that should be reset and use its handle to initialize
    a variable of type `VkDescriptorPool` named `descriptor_pool`.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应重置的描述符池并使用其句柄初始化一个名为`descriptor_pool`的`VkDescriptorPool`类型变量。
- en: Take the handle of a logical device on which the descriptor pool was created.
    Store its handle in a variable of type `VkDevice` named `logical_device`.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建描述符池的逻辑设备的句柄。将其句柄存储在名为`logical_device`的`VkDevice`类型变量中。
- en: 'Make the following call: `vkResetDescriptorPool( logical_device, descriptor_pool,
    0 )`, for which use the `logical_device` and `descriptor_pool` variables and a
    `0` value.'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下调用：`vkResetDescriptorPool(logical_device, descriptor_pool, 0)`，其中使用`logical_device`和`descriptor_pool`变量以及一个`0`值。
- en: Check for any error returned by the call. As successful operation should return
    `VK_SUCCESS`.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查调用返回的任何错误。因为成功的操作应该返回`VK_SUCCESS`。
- en: How it works...
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Resetting a descriptor pool returns all the descriptor sets allocated from it
    back to the pool. All descriptor sets allocated from the pool are implicitly freed
    and they can't be used any more (their handles become invalid).
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 重置描述符池会将从该池分配的所有描述符集返回到池中。从池中分配的所有描述符集都将隐式释放，并且不能再使用（它们的句柄变为无效）。
- en: If the pool is created without a `VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT`
    flag set, it is the only way to free descriptor sets allocated from it (apart
    from destroying the pool), as in such a situation, we can't free them individually.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 如果池是在没有设置`VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT`标志的情况下创建的，那么这是释放从该池分配的描述符集的唯一方法（除了销毁池之外），因为在这样的情况下，我们无法单独释放它们。
- en: 'To reset the pool, we can write code similar to the following:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 要重置池，我们可以编写类似于以下代码的代码：
- en: '[PRE44]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the following recipes in this chapter:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章中的以下食谱：
- en: '*Creating a descriptor pool*'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符池*'
- en: '*Allocating descriptor sets*'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Freeing descriptor sets*'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放描述符集*'
- en: '*Destroying a descriptor pool*'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁描述符池*'
- en: Destroying a descriptor pool
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁描述符池
- en: When we don't need a descriptor pool any more, we can destroy it (with all descriptor
    sets allocated from the pool).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要描述符池时，我们可以销毁它（包括从池中分配的所有描述符集）。
- en: How to do it...
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a created logical device and store it in a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的逻辑设备的句柄并将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Provide the handle of the descriptor pool through a variable of type `VkDescriptorPool`
    named `descriptor_pool`.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroyDescriptorPool( logical_device, descriptor_pool, nullptr )` and
    provide the `logical_device` and `descriptor_pool` variables and a `nullptr` value.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety, assign the `VK_NULL_HANDLE` value to the `descriptor_pool` variable.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-661
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destroying a descriptor pool implicitly frees all descriptor sets allocated
    from it. We don't need to free individual descriptor sets first. But because of
    this, we need to make sure that none of the descriptor sets allocated from the
    pool are referenced by the commands that are currently processed by the hardware.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are ready, we can destroy a descriptor pool like this:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See also
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the following recipe in this chapter:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a descriptor pool*'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying a descriptor set layout
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptor set layouts that are no longer used should be destroyed.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provide a logical device's handle using a variable of type `VkDevice` named
    `logical_device`.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a created descriptor set layout and use it to initialize
    a variable of type `VkDescriptorSetLayout` named `descriptor_set_layout`.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroyDescriptorSetLayout( logical_device, descriptor_set_layout, nullptr
    )` and provide handles of the logical device and descriptor set layout, and a
    `nullptr` value.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety, assign the `VK_NULL_HANDLE` value to the `descriptor_set_layout`
    variable.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-675
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Descriptor set layouts are destroyed with the `vkDestroyDescriptorSetLayout()`
    function like this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the following recipe in this chapter:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a descriptor set layout*'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying a sampler
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we no longer need a sampler and we are sure it is not used anymore by the
    pending commands, we can destroy it.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a logical device on which the sampler was created and store
    it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of the sampler that should be destroyed. Provide it through
    a variable of type `VkSampler` named `sampler`.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkDestroySampler( logical_device, sampler, nullptr )` and provide the `logical_device`
    and `sampler` variables, and a `nullptr` value.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For safety, assign the `VK_NULL_HANDLE` value to the `sampler` variable.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Samplers are destroyed like this:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We don't have to check whether the sampler's handle is not empty, because a
    deletion of a `VK_NULL_HANDLE` is ignored. We do this just to avoid an unnecessary
    function call. But when we delete a sampler, we must be sure that the handle (if
    not empty) is valid.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the following recipe in this chapter:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a sampler*'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
