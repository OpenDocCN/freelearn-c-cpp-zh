<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 7.  One Step Forward, One Level Down - OpenGL Basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/><span class="koboSpan" id="kobo.1.1">Chapter 7.  One Step Forward, One Level Down - OpenGL Basics </span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Often times it's easy to take a library like SFML for granted. </span><span class="koboSpan" id="kobo.2.2">After all, the ideas and concepts offered by it seem quite intuitive. </span><span class="koboSpan" id="kobo.2.3">Building something rather simple can take as little as a couple of minutes, and there are no major headaches to deal with. </span><span class="koboSpan" id="kobo.2.4">In a perfect world, we could just offload those troubles to someone else and simply rely on increasingly higher levels of abstraction to get the job done. </span><span class="koboSpan" id="kobo.2.5">However, what happens when certain limitations make us slam face-first into a brick wall? </span><span class="koboSpan" id="kobo.2.6">In order to know the way around them, it's necessary to know the fundamentals that SFML was built on. </span><span class="koboSpan" id="kobo.2.7">In other words, at that point, downward is the only way forward.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to be covering:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Setting up and using OpenGL with a window from SFML</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Shaping and submitting data to the GPU</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Creating, building, and using shaders for rendering</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Applying textures to geometry</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Looking at various coordinate spaces and model transformations</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.9.1">Implementing a camera</span></li></ul></div><p><span class="koboSpan" id="kobo.10.1">That is quite a laundry list of things to do, so let us not waste any time and jump right in!</span></p><div class="section" title="Use of copyrighted resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/><span class="koboSpan" id="kobo.11.1">Use of copyrighted resources</span></h1></div></div></div><p><span class="koboSpan" id="kobo.12.1">As always, let us acknowledge those who deserve to be acknowledged, and give credit where credit's due. </span><span class="koboSpan" id="kobo.12.2">These are the resources used in this chapter:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.13.1">Old wall texture by </span><code class="literal"><span class="koboSpan" id="kobo.14.1">texturelib.com
</span></code><span class="koboSpan" id="kobo.15.1"> under the CC0: </span><a class="ulink" href="http://texturelib.com/texture/?path=/Textures/brick/medieval/brick_medieval_0121"><span class="koboSpan" id="kobo.16.1">license:http://texturelib.com/texture/?path=/Textures/brick/medieval/brick_medieval_0121</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.17.1">STB public domain image loader by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">Sean Barrett</span></em></span><span class="koboSpan" id="kobo.19.1"> under the CC0 license: </span><a class="ulink" href="https://github.com/nothings/stb/blob/master/stb_image.h"><span class="koboSpan" id="kobo.20.1">https://github.com/nothings/stb/blob/master/stb_image.h</span></a></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Setting up OpenGL"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/><span class="koboSpan" id="kobo.1.1">Setting up OpenGL</span></h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.2.1">In order to have access to the latest version of OpenGL, we need to download two libraries. </span><span class="koboSpan" id="kobo.2.2">One is named the OpenGL Extension Wrangler Library. </span><span class="koboSpan" id="kobo.2.3">It loads and makes available all OpenGL extensions that are supported on the target platform. </span><span class="koboSpan" id="kobo.2.4">The library can be downloaded here </span><a class="ulink" href="http://glew.sourceforge.net/"><span class="koboSpan" id="kobo.3.1">http://glew.sourceforge.net/</span></a><span class="koboSpan" id="kobo.4.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">The other library we need is called OpenGL Mathematics, or GLM for short. </span><span class="koboSpan" id="kobo.5.2">It is a header-only library that adds a lot of extra data types and functions, which come in handy more often than not. </span><span class="koboSpan" id="kobo.5.3">Anything from simple vector data types to functions used to calculate cross products are added in by this library. </span><span class="koboSpan" id="kobo.5.4">It can be found here </span><a class="ulink" href="http://glm.g-truc.net/0.9.8/index.html"><span class="koboSpan" id="kobo.6.1">http://glm.g-truc.net/0.9.8/index.html</span></a><span class="koboSpan" id="kobo.7.1">.</span></li></ul></div><div class="section" title="Setting up a Visual Studio project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec55"/><span class="koboSpan" id="kobo.8.1">Setting up a Visual Studio project</span></h2></div></div></div><p><span class="koboSpan" id="kobo.9.1">Alongside the usual SFML includes, which we are still going to need for creating a window, we also need to add the GLEW and GLM </span><code class="literal"><span class="koboSpan" id="kobo.10.1">include</span></code><span class="koboSpan" id="kobo.11.1"> folders in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.12.1">Include Directories</span></strong></span><span class="koboSpan" id="kobo.13.1"> field under </span><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">VC++ Directories</span></strong></span><span class="koboSpan" id="kobo.15.1">.</span></p><p><span class="koboSpan" id="kobo.16.1">The GLEW </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">Additional Library Directory</span></strong></span><span class="koboSpan" id="kobo.18.1"> must be added in as well in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">General</span></strong></span><span class="koboSpan" id="kobo.20.1"> section under </span><span class="strong"><strong><span class="koboSpan" id="kobo.21.1">Linker</span></strong></span><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">The library files are located inside the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">Release</span></code><span class="koboSpan" id="kobo.24.1"> folder, which holds a couple of directories: </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Win32</span></code><span class="koboSpan" id="kobo.26.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.27.1">x64</span></code><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">These need to be set up correctly for different build configurations.</span></p><p><span class="koboSpan" id="kobo.29.1">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">glew32.lib</span></code><span class="koboSpan" id="kobo.31.1"> file has to be added to the </span><span class="strong"><strong><span class="koboSpan" id="kobo.32.1">Additional Dependencies</span></strong></span><span class="koboSpan" id="kobo.33.1"> field in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.34.1">Input</span></strong></span><span class="koboSpan" id="kobo.35.1"> section under </span><span class="strong"><strong><span class="koboSpan" id="kobo.36.1">Linker</span></strong></span><span class="koboSpan" id="kobo.37.1">, as well as the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">OpenGL32.lib</span></code><span class="koboSpan" id="kobo.39.1"> file. </span><span class="koboSpan" id="kobo.39.2">It can be linked statically, in which case, </span><code class="literal"><span class="koboSpan" id="kobo.40.1">glew32s.lib</span></code><span class="koboSpan" id="kobo.41.1"> needs to be added instead of the regular </span><code class="literal"><span class="koboSpan" id="kobo.42.1">glew32.lib</span></code><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">If linking statically, the </span><code class="literal"><span class="koboSpan" id="kobo.44.1">GLEW_STATIC</span></code><span class="koboSpan" id="kobo.45.1"> </span><span class="strong"><strong><span class="koboSpan" id="kobo.46.1">Preprocessor Definition</span></strong></span><span class="koboSpan" id="kobo.47.1"> in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1">Preprocessor</span></strong></span><span class="koboSpan" id="kobo.49.1"> section under </span><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">C/C++</span></strong></span><span class="koboSpan" id="kobo.51.1"> needs to be added as well.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using GLEW"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec56"/><span class="koboSpan" id="kobo.1.1">Using GLEW</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The first thing we are going to need if we are working with OpenGL is a window. </span><span class="koboSpan" id="kobo.2.2">Luckily, window creation isn't OpenGL specific, so one can be made using almost any library out there that supports it, including SFML. </span><span class="koboSpan" id="kobo.2.3">For our purposes, we'll be reusing the Window class with some minor adjustments to it, including the actual SFML window type:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class GL_Window { 
  ... 
</span><span class="koboSpan" id="kobo.3.2">private: 
  ... 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1">sf::Window</span></strong></span><span class="koboSpan" id="kobo.5.1"> m_window; 
  ... 
</span><span class="koboSpan" id="kobo.5.2">}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">Note the data type of the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">m_window</span></code><span class="koboSpan" id="kobo.8.1"> data member. </span><span class="koboSpan" id="kobo.8.2">If actual SFML is not used to draw anything, we do not need an instance of </span><code class="literal"><span class="koboSpan" id="kobo.9.1">sf::RenderWindow</span></code><span class="koboSpan" id="kobo.10.1"> and can instead work with </span><code class="literal"><span class="koboSpan" id="kobo.11.1">sf::Window</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">This means that any task that does not have anything to do with the actual window has to be handled separately. </span><span class="koboSpan" id="kobo.12.3">This even includes clearing the window:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">void GL_Window::BeginDraw() { 
  glClearColor(0.f, 0.f, 0.f, 1.f); // BLACK 
  glClear(GL_COLOR_BUFFER_BIT); 
} 
</span></pre><p><span class="koboSpan" id="kobo.14.1">Here we get a glimpse at the first two GL functions we are going to be using. </span><span class="koboSpan" id="kobo.14.2">Because GLEW is a C API, code that looks like this will be quite common. </span><span class="koboSpan" id="kobo.14.3">There are no classes to manage, as every task is performed via function calls and a shared state. </span><span class="koboSpan" id="kobo.14.4">Case in point, our first function </span><code class="literal"><span class="koboSpan" id="kobo.15.1">glClearColor()</span></code><span class="koboSpan" id="kobo.16.1"> actually sets up the color that the screen will be cleared with, including the alpha channel.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/><span class="koboSpan" id="kobo.17.1">Note</span></h3><p><span class="koboSpan" id="kobo.18.1">This specific function, as well as many others, takes in what is known as a </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">normalized</span></strong></span><span class="koboSpan" id="kobo.20.1"> vector. </span><span class="koboSpan" id="kobo.20.2">It is useful when representing proportion. </span><span class="koboSpan" id="kobo.20.3">For example, clearing the screen to the color purple would mean passing the value </span><span class="emphasis"><em><span class="koboSpan" id="kobo.21.1">0.5f </span></em></span><span class="koboSpan" id="kobo.22.1">as the first and the third parameter, which would mean half of the colour is red, and the other half is blue.</span></p></div></div><p><span class="koboSpan" id="kobo.23.1">The second function call actually performs the clearing with the stored value. </span><span class="koboSpan" id="kobo.23.2">It takes in a single argument, which is essentially just a bitmask, defined using the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">#define</span></code><span class="koboSpan" id="kobo.25.1"> pre-processor directive. </span><span class="koboSpan" id="kobo.25.2">This specific implementation detail allows more masks to be passed into the function call by utilizing </span><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">bitwise</span></strong></span><span class="koboSpan" id="kobo.27.1"> or operations, represented by the pipe </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">|</span></em></span><span class="koboSpan" id="kobo.29.1"> symbol. </span><span class="koboSpan" id="kobo.29.2">This concept will be revisited by us eventually.</span></p><p><span class="koboSpan" id="kobo.30.1">With that out of the way, let us actually create the window and initialize the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">GLEW</span></code><span class="koboSpan" id="kobo.32.1"> library:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">Game::Game() : m_window("Chapter 7", sf::Vector2u(800, 600)) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.33.2">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl; 
  GLenum status = glewInit(); 
  if (status != GLEW_OK) { 
    std::cout &lt;&lt; "GLEW failed!" </span><span class="koboSpan" id="kobo.33.3">&lt;&lt; std::endl; 
  } 
  ... 
</span><span class="koboSpan" id="kobo.33.4">} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">All we need to do in order to initialize GLEW is to call a single function </span><code class="literal"><span class="koboSpan" id="kobo.35.1">glewInit()</span></code><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">It returns a value, which represents the success/failure of the operation. </span><span class="koboSpan" id="kobo.36.3">Another useful function to keep around is </span><code class="literal"><span class="koboSpan" id="kobo.37.1">glGetString()</span></code><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">It returns a static string that represents specific information about the OpenGL version that is supported by the computer it is executed on. </span><span class="koboSpan" id="kobo.38.3">In this case, we specifically want to check the version of OpenGL and print it out, but it can also be used to determine the OpenGL extensions, the supported GLSL version, the name of the hardware rendering platform, and so on.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The rendering pipeline"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec57"/><span class="koboSpan" id="kobo.1.1">The rendering pipeline</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">When drawing something on the screen, a certain sequence of steps must be followed in order to submit the geometry, convert it to pixels, and color them all appropriately. </span><span class="koboSpan" id="kobo.2.2">This particular sequence of steps is often referred to as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">rendering pipeline</span></strong></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">How it functions depends entirely on the version of OpenGL you are using. </span><span class="koboSpan" id="kobo.4.3">Versions below </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">3.0</span></em></span><span class="koboSpan" id="kobo.6.1"> use what is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">fixed function pipeline</span></strong></span><span class="koboSpan" id="kobo.8.1">, while newer OpenGL releases of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">3.0 +</span></em></span><span class="koboSpan" id="kobo.10.1"> utilize the </span><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">programmable pipeline</span></strong></span><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">The former is now deprecated and is referred to as </span><span class="strong"><strong><span class="koboSpan" id="kobo.13.1">legacy</span></strong></span><span class="koboSpan" id="kobo.14.1"> OpenGL, while the latter is widely used and applied, even on mobile devices, and has become the standard.</span></p><div class="section" title="Fixed function pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/><span class="koboSpan" id="kobo.15.1">Fixed function pipeline</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">Actually drawing things on screen with the fixed function pipeline is much easier than the modern way of doing things, but it comes at a price. </span><span class="koboSpan" id="kobo.16.2">Consider the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">glBegin(GL_TRIANGLES); 
  
glColor3f(1.0f, 0.0f, 0.0f); // Red 
glVertex3f(-0.5f, -0.5f, 0.5f); 
  
glColor3f(0.0f, 1.0f, 0.0f); // Green 
glVertex3f(-0.5f, 0.5f, 0.5f); 
    
glColor3f(0.0f, 0.0f, 1.0f); // Blue 
glVertex3f(0.5f,  0.5f, 0.5f); 
  
glEnd(); 
</span></pre><p><span class="koboSpan" id="kobo.18.1">This particular block of code is quite easily readable, which is one advantage of the legacy method. </span><span class="koboSpan" id="kobo.18.2">We begin by invoking the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">glBegin()</span></code><span class="koboSpan" id="kobo.20.1"> method and passing in a value, which signifies how the actual vertices should be interpreted as they are being submitted. </span><span class="koboSpan" id="kobo.20.2">We are working with triangles, which means that every three vertices submitted in a row will be connected and turned into a triangle. </span><span class="koboSpan" id="kobo.20.3">Note the calls to </span><code class="literal"><span class="koboSpan" id="kobo.21.1">glColor3f</span></code><span class="koboSpan" id="kobo.22.1"> as well. </span><span class="koboSpan" id="kobo.22.2">The color of the vertices is set as they are being submitted, and the same can be done with texture coordinates as well. </span><span class="koboSpan" id="kobo.22.3">The final call to the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">glEnd()</span></code><span class="koboSpan" id="kobo.24.1"> method flushes all of the submitted data to the GPU for rendering.</span></p><p><span class="koboSpan" id="kobo.25.1">While this is very readable and easy to understand for newcomers, the vertex data has to be resubmitted to the GPU every frame, which heavily impacts performance. </span><span class="koboSpan" id="kobo.25.2">Small applications would not notice the difference, but the memory transfer overhead really starts to add up after a significant number of primitives have been submitted.</span></p><p><span class="koboSpan" id="kobo.26.1">Another issue with this approach is how limited it is. </span><span class="koboSpan" id="kobo.26.2">Certain effects, if at all possible, can be extremely slow to pull off with the fixed function pipeline.</span></p></div><div class="section" title="Programmable pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/><span class="koboSpan" id="kobo.27.1">Programmable pipeline</span></h2></div></div></div><p><span class="koboSpan" id="kobo.28.1">Using the programmable pipeline is quite a bit more complicated for small tasks, but it proves invaluable for larger projects. </span><span class="koboSpan" id="kobo.28.2">Just like the fixed function pipeline, there are steps that are static and unchanging. </span><span class="koboSpan" id="kobo.28.3">The programmable pipeline does, however, provide a way to customize certain aspects of how the data submitted to the GPU is processed. </span><span class="koboSpan" id="kobo.28.4">This is where </span><span class="strong"><strong><span class="koboSpan" id="kobo.29.1">shaders</span></strong></span><span class="koboSpan" id="kobo.30.1"> come in. </span><span class="koboSpan" id="kobo.30.2">Shaders have already been briefly covered in the previous chapter; however, there is much more to them that has not yet been explained. </span><span class="koboSpan" id="kobo.30.3">They are the programs that can be written in a C-like language and executed on the GPU instead of the CPU. </span><span class="koboSpan" id="kobo.30.4">As it turns out, shaders are used to customize certain parts of the programmable pipeline. </span><span class="koboSpan" id="kobo.30.5">Consider the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.31.1"><img src="graphics/image_07_001.jpg" alt="Programmable pipeline"/></span></div><p><span class="koboSpan" id="kobo.32.1">Just like the fixed-function pipeline, vertex data is submitted to the GPU. </span><span class="koboSpan" id="kobo.32.2">However, this data is not re-submitted every frame. </span><span class="koboSpan" id="kobo.32.3">Instead, the vertex data lives on the GPU and can be referred to when it needs to be rendered. </span><span class="koboSpan" id="kobo.32.4">Once a call has been made to draw a specific set of vertices, they're passed in to be processed and relayed to the vertex shader.</span></p><p><span class="koboSpan" id="kobo.33.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.34.1">Vertex shader</span></strong></span><span class="koboSpan" id="kobo.35.1"> is one of few programmable bits of this pipeline. </span><span class="koboSpan" id="kobo.35.2">It is often used to calculate the positions of vertices in the appropriate coordinate system, and pass these vertices down the pipeline to be processed further.</span></p><p><span class="koboSpan" id="kobo.36.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.37.1">Tessellation</span></strong></span><span class="koboSpan" id="kobo.38.1"> stage essentially is responsible for performing sub-divisions of our existing geometry into smaller primitives. </span><span class="koboSpan" id="kobo.38.2">It actually ends up connecting the vertices and passing these primitives further down the pipeline. </span><span class="koboSpan" id="kobo.38.3">There are two shaders in this stage that can be written and used; however, we are not going to be doing that.</span></p><p><span class="koboSpan" id="kobo.39.1">All of the primitive data is then passed down to a </span><span class="strong"><strong><span class="koboSpan" id="kobo.40.1">Geometry shader</span></strong></span><span class="koboSpan" id="kobo.41.1">, which just like the two tessellation shaders is optional. </span><span class="koboSpan" id="kobo.41.2">It can be used to generate more vertices from the existing geometry.</span></p><p><span class="koboSpan" id="kobo.42.1">After the primitives have been properly assembled, they are passed further down and handled by the rasterizer.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.43.1">Rasterization</span></strong></span><span class="koboSpan" id="kobo.44.1"> is the actual process of turning vertex and primitive information into pixel data. </span><span class="koboSpan" id="kobo.44.2">These pixels are then passed further down the pipeline.</span></p><p><span class="koboSpan" id="kobo.45.1">The last programmable bit of this pipeline receives all of the pixel information from the previous stage. </span><span class="koboSpan" id="kobo.45.2">It is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.46.1">Fragment shader</span></strong></span><span class="koboSpan" id="kobo.47.1"> (that is, pixel shader), and can be used to determine the value of each individual pixel within the geometry we are rendering. </span><span class="koboSpan" id="kobo.47.2">Anything from assigning specific colors, to actually sampling pixels of a texture is done at this stage. </span><span class="koboSpan" id="kobo.47.3">These pixels are then pushed further down to be handled by other stages.</span></p><p><span class="koboSpan" id="kobo.48.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.49.1">Depth &amp; Stencil</span></strong></span><span class="koboSpan" id="kobo.50.1"> stage performs various tests in order to clip unneeded pixels that should not be drawn on screen. </span><span class="koboSpan" id="kobo.50.2">If a pixel is outside of the window area or even behind another bit of geometry, it is dropped at this stage.</span></p><p><span class="koboSpan" id="kobo.51.1">Unclipped pixels are then blended onto the existing frame buffer, which is used to draw everything on screen. </span><span class="koboSpan" id="kobo.51.2">Before they are blended, however, the </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">Dithering</span></strong></span><span class="koboSpan" id="kobo.53.1"> process takes place, making sure pixels are correctly rounded up or down if the render image has less or more precision than the value we have.</span></p><p><span class="koboSpan" id="kobo.54.1">Although it may be hard to grasp this concept at first, the programmable pipeline is a superior approach to modern rendering. </span><span class="koboSpan" id="kobo.54.2">Out of all of these stages covered, we only really need to write the vertex and fragment shaders to get started. </span><span class="koboSpan" id="kobo.54.3">We will be covering that very soon.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Storing and drawing primitives"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec58"/><span class="koboSpan" id="kobo.1.1">Storing and drawing primitives</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">All of our primitive data has to be represented as a set of vertices. </span><span class="koboSpan" id="kobo.2.2">Whether we are dealing with a triangle or a sprite on screen, or if it is a huge, complex model of a monster, it can all be broken down to this fundamental type. </span><span class="koboSpan" id="kobo.2.3">Let us take a look at a class that represents it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class VertexAttribute{ Position, COUNT }; 
 
struct GL_Vertex { 
  GL_Vertex(const glm::vec3&amp; l_pos): m_pos(l_pos) {} 
 
  glm::vec3 m_pos; // Attribute 1. 
  </span><span class="koboSpan" id="kobo.3.2">// ... 
</span><span class="koboSpan" id="kobo.3.3">}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">As you can see, it is only a simple </span><code class="literal"><span class="koboSpan" id="kobo.5.1">struct</span></code><span class="koboSpan" id="kobo.6.1"> that holds a 3D vector that represents a position. </span><span class="koboSpan" id="kobo.6.2">Later on, we might want to store other information about a vertex, such as texture coordinates, its color, and so on. </span><span class="koboSpan" id="kobo.6.3">These different pieces of information about a specific vertex are usually referred to as </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">attributes</span></strong></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">For convenience, we are also enumerating different attributes to make the rest of our code more clear.</span></p><div class="section" title="Vertex storage"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/><span class="koboSpan" id="kobo.9.1">Vertex storage</span></h2></div></div></div><p><span class="koboSpan" id="kobo.10.1">Before any primitives can be drawn, their data must be stored on the GPU. </span><span class="koboSpan" id="kobo.10.2">In OpenGL, this task is achieved by utilizing </span><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">Vertex Array Objects </span></strong></span><span class="koboSpan" id="kobo.12.1">(</span><span class="strong"><strong><span class="koboSpan" id="kobo.13.1">VAO</span></strong></span><span class="koboSpan" id="kobo.14.1">) and </span><span class="strong"><strong><span class="koboSpan" id="kobo.15.1">Vertex Buffer Objects </span></strong></span><span class="koboSpan" id="kobo.16.1">(</span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">VBO</span></strong></span><span class="koboSpan" id="kobo.18.1">).</span></p><p><span class="koboSpan" id="kobo.19.1">A vertex buffer object can simply be thought of as space that gets allocated on the GPU for storing data. </span><span class="koboSpan" id="kobo.19.2">That data can be anything. </span><span class="koboSpan" id="kobo.19.3">It could be vertex positions, colors, texture coordinates, and so on. </span><span class="koboSpan" id="kobo.19.4">We are going to use VBOs to store all of our primitive information.</span></p><p><span class="koboSpan" id="kobo.20.1">A vertex array object is like a parent to a VBO, or even multiple VBOs. </span><span class="koboSpan" id="kobo.20.2">It stores information about how data that lives inside a VBO should be accessed, how information can be passed into various shader stages, and many more details that together form a state. </span><span class="koboSpan" id="kobo.20.3">If a VBO is the actual data pool, a VAO can be thought of as an instruction set of how to access that data.</span></p><p><span class="koboSpan" id="kobo.21.1">Both VAO and VBO instances are identified by simple integers, which get returned after the space is allocated. </span><span class="koboSpan" id="kobo.21.2">These integers will be used to differentiate different buffers and array objects.</span></p></div><div class="section" title="The model class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec59"/><span class="koboSpan" id="kobo.22.1">The model class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.23.1">With that bit of information out of the way, we can finally get down to actually implementing a model class! </span><span class="koboSpan" id="kobo.23.2">A model, in our case, is any set of triangles that can form a shape. </span><span class="koboSpan" id="kobo.23.3">With enough triangles, any shape can be modelled. </span><span class="koboSpan" id="kobo.23.4">Let us take a look at the class header:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">class GL_Model { 
public: 
  GL_Model(GL_Vertex* l_vertices, unsigned int l_vertCount); 
  ~GL_Model(); 
 
  void Draw(); 
private: 
  GLuint m_VAO; 
  GLuint m_vertexVBO; 
  unsigned int m_drawCount; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.25.1">As you can tell, it is quite simple. </span><span class="koboSpan" id="kobo.25.2">The constructor takes in two arguments for now: a pointer to the first instance of a vertex, and the number of vertices we are actually submitting. </span><span class="koboSpan" id="kobo.25.3">This makes it easy for us to load a model quickly from a simple array of vertices, although it may not be the best way of loading more complex meshes.</span></p><p><span class="koboSpan" id="kobo.26.1">Note that the class also has a </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Draw()</span></code><span class="koboSpan" id="kobo.28.1"> method, which will be used later on to actually submit its vertices to the rendering pipeline and begin the drawing process.</span></p><p><span class="koboSpan" id="kobo.29.1">Lastly, we have the two </span><span class="emphasis"><em><span class="koboSpan" id="kobo.30.1">GL unsigned integer</span></em></span><span class="koboSpan" id="kobo.31.1"> types: </span><code class="literal"><span class="koboSpan" id="kobo.32.1">m_VAO</span></code><span class="koboSpan" id="kobo.33.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.34.1">m_vertexVBO</span></code><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">These integers will refer to the actual vertex array object that is used with this model, as well as the vertex buffer object, used to store all of the vertex information. </span><span class="koboSpan" id="kobo.35.3">We also have an </span><span class="emphasis"><em><span class="koboSpan" id="kobo.36.1">unsigned integer</span></em></span><span class="koboSpan" id="kobo.37.1">, </span><code class="literal"><span class="koboSpan" id="kobo.38.1">m_drawCount</span></code><span class="koboSpan" id="kobo.39.1">, which is going to store the number of vertices this particular model has in order to draw them all.</span></p><div class="section" title="Implementing the model class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec9"/><span class="koboSpan" id="kobo.40.1">Implementing the model class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.41.1">With that out of the way, let us begin allocating and filling in our data structures! </span><span class="koboSpan" id="kobo.41.2">The constructor of the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">GL_Model</span></code><span class="koboSpan" id="kobo.43.1"> class is going to be helping us with that task:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.44.1">GL_Model::GL_Model(GL_Vertex* l_vertices, 
  unsigned int l_vertCount) 
{ 
  m_drawCount = l_vertCount; 
 
  glGenVertexArrays(1, &amp;m_VAO); 
  glBindVertexArray(m_VAO); 
  glGenBuffers(1, &amp;m_vertexVBO); 
 
  glBindBuffer(GL_ARRAY_BUFFER, m_vertexVBO); 
  glBufferData(GL_ARRAY_BUFFER, 
    l_vertCount * sizeof(l_vertices[0]), 
    l_vertices, GL_STATIC_DRAW); 
  glEnableVertexAttribArray( 
    static_cast&lt;GLuint&gt;(VertexAttribute::Position)); 
  glVertexAttribPointer( 
    static_cast&lt;GLuint&gt;(VertexAttribute::Position), 3, GL_FLOAT, 
    GL_FALSE, 0, 0); 
 
  glBindVertexArray(0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.45.1">We begin by copying the amount of vertices to the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">m_drawCount</span></code><span class="koboSpan" id="kobo.47.1"> data member. </span><span class="koboSpan" id="kobo.47.2">This is going to be useful later, as we need to know exactly how many vertices need to be drawn before actually rendering them. </span><span class="koboSpan" id="kobo.47.3">Some space for a VAO is then allocated, using the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">glGenVertexArrays</span></code><span class="koboSpan" id="kobo.49.1"> function. </span><span class="koboSpan" id="kobo.49.2">Its first argument is the amount of objects that need to be created, while the second one takes a pointer to a variable that is going to store the returned identifiers.</span></p><p><span class="koboSpan" id="kobo.50.1">The next function call, </span><code class="literal"><span class="koboSpan" id="kobo.51.1">glBindVertexArray()</span></code><span class="koboSpan" id="kobo.52.1">, actually enables a vertex array object with the provided identifier, so that any subsequent function call after this one modifies the vertex array object that was passed in as the argument. </span><span class="koboSpan" id="kobo.52.2">Any vertex array object manipulation from this point on will be performed on the VAO with the identifier, </span><code class="literal"><span class="koboSpan" id="kobo.53.1">m_VAO</span></code><span class="koboSpan" id="kobo.54.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/><span class="koboSpan" id="kobo.55.1">Note</span></h3><p><span class="koboSpan" id="kobo.56.1">Because GLEW is a C API, the idea of binding and unbinding something dominates most aspects of it. </span><span class="koboSpan" id="kobo.56.2">In order to modify or do anything with certain data that lives on the GPU, the appropriate buffer must be bound first.</span></p></div></div><p><span class="koboSpan" id="kobo.57.1">Just like the VAO, the vertex buffer object also needs to be generated. </span><span class="koboSpan" id="kobo.57.2">The function </span><code class="literal"><span class="koboSpan" id="kobo.58.1">glGenBuffers</span></code><span class="koboSpan" id="kobo.59.1"> does just that. </span><span class="koboSpan" id="kobo.59.2">In this case, we only need one buffer object, which is what the first argument denotes. </span><span class="koboSpan" id="kobo.59.3">Once it is generated, just like the VAO, we need to bind to this buffer in order to modify it. </span><span class="koboSpan" id="kobo.59.4">This is where the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">glBindBuffer</span></code><span class="koboSpan" id="kobo.61.1"> function comes in. </span><span class="koboSpan" id="kobo.61.2">As it is bound to, we also need to specify the type of buffer we are going to treat it as. </span><span class="koboSpan" id="kobo.61.3">Because we just want an array of data, </span><code class="literal"><span class="koboSpan" id="kobo.62.1">GL_ARRAY_BUFFER</span></code><span class="koboSpan" id="kobo.63.1"> is used.</span></p><p><span class="koboSpan" id="kobo.64.1">Now that we have a buffer created, we can push some data to it! </span><span class="koboSpan" id="kobo.64.2">A call to </span><code class="literal"><span class="koboSpan" id="kobo.65.1">glBufferData</span></code><span class="koboSpan" id="kobo.66.1"> does just that. </span><span class="koboSpan" id="kobo.66.2">The first argument, just like the previous function, determines what kind of buffer we are dealing with. </span><span class="koboSpan" id="kobo.66.3">The second argument is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.67.1">byte</span></strong></span><span class="koboSpan" id="kobo.68.1"> size of the data chunk we want to submit, which OpenGL has to know in order to allocate enough space for the buffer to hold all of the data. </span><span class="koboSpan" id="kobo.68.2">In this case, it is just the number of vertices multiplied by the number of bytes the first element takes up. </span><span class="koboSpan" id="kobo.68.3">The third argument is just a pointer to the actual data structure we want to submit. </span><span class="koboSpan" id="kobo.68.4">How much of that is read in is determined by the second argument, which, in this case, is all of it. </span><span class="koboSpan" id="kobo.68.5">Finally, the last argument is used as a hint for OpenGL to manage the data storage as efficiently as possible depending on its use. </span><span class="koboSpan" id="kobo.68.6">It stores the data differently depending on what we do with it. </span><code class="literal"><span class="koboSpan" id="kobo.69.1">GL_STATIC_DRAW</span></code><span class="koboSpan" id="kobo.70.1"> means we are not going to be modifying the data, so that it can store it a certain way that is most efficient for this situation.</span></p><p><span class="koboSpan" id="kobo.71.1">With all of the data buffered, we can begin working with the VAO again and give it information about how the vertex information should be accessed. </span><span class="koboSpan" id="kobo.71.2">Because the vertex position has to be passed to the fragment shader, we need to enable it as an attribute and store information about how it should be processed in the VAO. </span><span class="koboSpan" id="kobo.71.3">This is where </span><code class="literal"><span class="koboSpan" id="kobo.72.1">glEnableVertexAttribArray()</span></code><span class="koboSpan" id="kobo.73.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.74.1">glVertexAttribPointer()</span></code><span class="koboSpan" id="kobo.75.1"> functions come in.</span></p><p><span class="koboSpan" id="kobo.76.1">The former function simply enables a certain attribute to be used by the vertex shader. </span><code class="literal"><span class="koboSpan" id="kobo.77.1">VertexAttribute::Position</span></code><span class="koboSpan" id="kobo.78.1"> evaluates to </span><code class="literal"><span class="koboSpan" id="kobo.79.1">0</span></code><span class="koboSpan" id="kobo.80.1">, so the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.81.1">0th</span></em></span><span class="koboSpan" id="kobo.82.1"> attribute in the vertex shader is enabled for use. </span><span class="koboSpan" id="kobo.82.2">The latter, however, actually specifies how this data is read and processed before it gets piped down the vertex shader. </span><span class="koboSpan" id="kobo.82.3">In this case, the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.83.1">0th</span></em></span><span class="koboSpan" id="kobo.84.1"> attribute is defined as a set of three variables, all of which are floats. </span><span class="koboSpan" id="kobo.84.2">The next argument can be useful if we want to normalize the data before it gets sent to the vertex shader. </span><span class="koboSpan" id="kobo.84.3">In this case, we do not need to do that, so </span><code class="literal"><span class="koboSpan" id="kobo.85.1">GL_FALSE</span></code><span class="koboSpan" id="kobo.86.1"> is passed in instead. </span><span class="koboSpan" id="kobo.86.2">The last two arguments are the byte stride and byte offset of the data we are interested in inside the buffer. </span><span class="koboSpan" id="kobo.86.3">Because we are only storing the vertexes position inside the </span><code class="literal"><span class="koboSpan" id="kobo.87.1">GL_Vertex</span></code><span class="koboSpan" id="kobo.88.1"> structure so far, both of these values are </span><code class="literal"><span class="koboSpan" id="kobo.89.1">0</span></code><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">However, what would happen if we had more attributes? </span><span class="koboSpan" id="kobo.90.3">Consider the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.91.1"><img src="graphics/image_07_002.jpg" alt="Implementing the model class"/></span></div><p><span class="koboSpan" id="kobo.92.1">Imagine we have all of the data inside a buffer, which was shown previously. </span><span class="koboSpan" id="kobo.92.2">For each vertex in there, its position is followed by its color, and then by another vertexes position. </span><span class="koboSpan" id="kobo.92.3">If we just want to filter out the position data, for example, stride and offset can be very useful. </span><span class="koboSpan" id="kobo.92.4">The stride argument is the number of bytes that have to be jumped from the beginning of one data segment to another. </span><span class="koboSpan" id="kobo.92.5">Effectively, stride can be thought of as the size of the entire vertex's data structure, which, in this case, is the sum of the size of the position vector, as well as the color vector. </span><span class="koboSpan" id="kobo.92.6">To put it simply, it's the number of bytes from the beginning of one vertex, to the beginning of another.</span></p><p><span class="koboSpan" id="kobo.93.1">Offset, on the other hand, is just the number of bytes we need to move from the beginning of whichever structure we happen to be reading in order to reach the desired element. </span><span class="koboSpan" id="kobo.93.2">Accessing the color element would mean the offset would have to be the size of the position vector. </span><span class="koboSpan" id="kobo.93.3">To put it simply, the offset is the number of bytes from the beginning of the structure to the beginning of the desired element.</span></p><p><span class="koboSpan" id="kobo.94.1">After our data is submitted and accounted for, we can use </span><code class="literal"><span class="koboSpan" id="kobo.95.1">glBindVertexArray</span></code><span class="koboSpan" id="kobo.96.1"> again to bind to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.97.1">0</span></em></span><span class="koboSpan" id="kobo.98.1">, which would show that we're done with the VAO.</span></p><p><span class="koboSpan" id="kobo.99.1">All of this allocated data actually has to be disposed of when it's no longer needed. </span><span class="koboSpan" id="kobo.99.2">The destructor can help us here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.100.1">GL_Model::~GL_Model() { 
  glDeleteBuffers(1, &amp;m_vertexVBO); 
  glDeleteVertexArrays(1, &amp;m_VAO); 
} 
</span></pre><p><span class="koboSpan" id="kobo.101.1">First, the vertex buffer object needs to be disposed of. </span><span class="koboSpan" id="kobo.101.2">We pass the number of VBOs, as well as the pointer to the first identifier to the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">glDeleteBuffers</span></code><span class="koboSpan" id="kobo.103.1"> function, which purges all of the buffer data on the GPU. </span><span class="koboSpan" id="kobo.103.2">The VAO follows a similar procedure afterwards.</span></p><p><span class="koboSpan" id="kobo.104.1">Finally, we can implement the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">Draw</span></code><span class="koboSpan" id="kobo.106.1"> method of our </span><code class="literal"><span class="koboSpan" id="kobo.107.1">Model</span></code><span class="koboSpan" id="kobo.108.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.109.1">void GL_Model::Draw() { 
  glBindVertexArray(m_VAO); 
  glDrawArrays(GL_TRIANGLES, 0, m_drawCount); 
  glBindVertexArray(0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.110.1">Before drawing something, we need to specify which data the pipeline should use. </span><span class="koboSpan" id="kobo.110.2">All of the vertex information sits safely in our buffer object that is managed by the VAO, so we bind it. </span><span class="koboSpan" id="kobo.110.3">The </span><code class="literal"><span class="koboSpan" id="kobo.111.1">glDrawArrays</span></code><span class="koboSpan" id="kobo.112.1"> function is then invoked. </span><span class="koboSpan" id="kobo.112.2">As the name states, it draws arrays of vertices. </span><span class="koboSpan" id="kobo.112.3">Its first argument is the type of primitive we want to draw, which in this case is triangles. </span><span class="koboSpan" id="kobo.112.4">Lines, points, and other types can also be drawn like this. </span><span class="koboSpan" id="kobo.112.5">The second argument is the starting index inside the buffer array object. </span><span class="koboSpan" id="kobo.112.6">Since we want to draw everything from the beginning, this is set to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.113.1">0</span></em></span><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">Lastly, the number of vertices to be drawn is passed in. </span><span class="koboSpan" id="kobo.114.3">The call to this function actually initiates the rendering pipeline, sending all of the vertex data into the vertex shader. </span><span class="koboSpan" id="kobo.114.4">The final call is to the </span><code class="literal"><span class="koboSpan" id="kobo.115.1">glBindVertexArray()</span></code><span class="koboSpan" id="kobo.116.1"> function that simply unbinds our VAO.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using shaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/><span class="koboSpan" id="kobo.1.1">Using shaders</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The standardization of the programmable pipeline now means shaders have to be written for certain tasks, including the basic ones. </span><span class="koboSpan" id="kobo.2.2">This means that simply submitting our vertex data and rendering it would do nothing, as the two fundamental chunks of the rendering pipeline, the vertex and fragment shaders, are non-existent. </span><span class="koboSpan" id="kobo.2.3">In this section, we are going to cover how shaders are loaded, built, and applied to our virtual geometry, in turn producing those glorious pixels on the screen.</span></p><div class="section" title="Loading shader files"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec60"/><span class="koboSpan" id="kobo.3.1">Loading shader files</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Before we can use shaders, we must first discuss how they are loaded. </span><span class="koboSpan" id="kobo.4.2">All we technically need to create a shader is a string, containing all of its code. </span><span class="koboSpan" id="kobo.4.3">A very simple helper function can be written to parse a file and return it as a string, as shown here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">inline std::string ReadFile(const std::string&amp; l_filename) { 
  std::ifstream file(l_filename); 
  if (!file.is_open()) { return ""; } 
  std::string output; 
  std::string line; 
  while (std::getline(file, line)) { 
    output.append(line + "\n"); 
  } 
  file.close(); 
  return output; 
} 
</span></pre><p><span class="koboSpan" id="kobo.6.1">This is nothing we have not seen before, when it comes to file reading and parsing. </span><span class="koboSpan" id="kobo.6.2">A string is created, then appended to with each new line of the file being read, and finally returned.</span></p></div><div class="section" title="Creating shader programs"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec61"/><span class="koboSpan" id="kobo.7.1">Creating shader programs</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">OpenGL shaders themselves are part of programs that are used throughout the rendering pipeline. </span><span class="koboSpan" id="kobo.8.2">If we have a vertex shader and a fragment shader we wish to utilize, both of them are actually joined into one program, which is then bound to so that the pipeline can use the appropriate shader at the right time. </span><span class="koboSpan" id="kobo.8.3">This is important, because it shapes the way the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">GL_Shader</span></code><span class="koboSpan" id="kobo.10.1"> data structure is built:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">enum class ShaderType{ Vertex, Fragment, COUNT }; 
 
class GL_Shader { 
public: 
  GL_Shader(const std::string&amp; l_fileName); 
  ~GL_Shader(); 
 
  void Bind() const; 
private: 
  static void CheckError(GLuint l_shader, GLuint l_flag, 
    bool l_program, const std::string&amp; l_errorMsg); 
  static GLuint BuildShader(const std::string&amp; l_src, 
    unsigned int l_type); 
 
  GLuint m_program; 
  GLuint m_shader[static_cast&lt;unsigned int&gt;(ShaderType::COUNT)]; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.12.1">First, we enumerate the shader types we are going to be using. </span><span class="koboSpan" id="kobo.12.2">For basic purposes, vertex and fragment shaders are more than enough.</span></p><p><span class="koboSpan" id="kobo.13.1">The constructor of the class takes a filename of the shader(s) we are going to be loading. </span><span class="koboSpan" id="kobo.13.2">There is also a </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Bind()</span></code><span class="koboSpan" id="kobo.15.1"> method, which will be used to enable a specific shader program before rendering begins.</span></p><p><span class="koboSpan" id="kobo.16.1">We also have two static helper methods, used for printing out errors inside shaders, and actually building them. </span><span class="koboSpan" id="kobo.16.2">Yes, shaders need to be compiled and linked before they can be used, much like C/C++.</span></p><p><span class="koboSpan" id="kobo.17.1">Finally, we need two </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">GL unsigned integer</span></em></span><span class="koboSpan" id="kobo.19.1"> data members, the latter of which is an array. </span><span class="koboSpan" id="kobo.19.2">The first integer is going to represent the shader program, which contains all attached shaders. </span><span class="koboSpan" id="kobo.19.3">The array of integers keeps track of identifiers of all types of shaders that are in the program.</span></p><div class="section" title="Implementing the shader class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec10"/><span class="koboSpan" id="kobo.20.1">Implementing the shader class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.21.1">Let us get down to actually creating some shaders! </span><span class="koboSpan" id="kobo.21.2">As always, a good place to start is the constructor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">GL_Shader::GL_Shader(const std::string&amp; l_fileName) { 
  auto src_vert = Utils::ReadFile(l_fileName + ".vert"); 
  auto src_frag = Utils::ReadFile(l_fileName + ".frag"); 
  if (src_vert.empty() &amp;&amp; src_frag.empty()) { return; } 
 
  m_program = glCreateProgram(); // Create a new program. 
  </span><span class="koboSpan" id="kobo.22.2">m_shader[static_cast&lt;GLuint&gt;(ShaderType::Vertex)] = 
    BuildShader(src_vert, GL_VERTEX_SHADER); 
  m_shader[static_cast&lt;GLuint&gt;(ShaderType::Fragment)] = 
    BuildShader(src_frag, GL_FRAGMENT_SHADER); 
 
  for (GLuint i = 0; 
    i &lt; static_cast&lt;GLuint&gt;(ShaderType::COUNT); ++i) 
  { 
    glAttachShader(m_program, m_shader[i]); 
  } 
 
  glBindAttribLocation(m_program, 
    static_cast&lt;GLuint&gt;(VertexAttribute::Position), "position"); 
 
  glLinkProgram(m_program); 
  CheckError(m_program,GL_LINK_STATUS,</span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">true</span></strong></span><span class="koboSpan" id="kobo.24.1">,"Shader link error:"); 
  glValidateProgram(m_program); 
  CheckError(m_program,GL_VALIDATE_STATUS,</span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">true</span></strong></span><span class="koboSpan" id="kobo.26.1">,"Invalid shader:"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">Before any shader compilation is done, we first need to have the actual source code loaded in memory. </span><span class="koboSpan" id="kobo.27.2">OpenGL does not do this for you, so we are going to be utilizing the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">ReadFile</span></code><span class="koboSpan" id="kobo.29.1"> function implemented earlier. </span><span class="koboSpan" id="kobo.29.2">Once both types of shaders are loaded and checked for not being empty, a new shader program is created using </span><code class="literal"><span class="koboSpan" id="kobo.30.1">glCreateProgram()</span></code><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">It returns an identifier that we need to keep track of if we want to use the shaders when rendering.</span></p><p><span class="koboSpan" id="kobo.32.1">For the actual vertex and fragment shaders the static </span><code class="literal"><span class="koboSpan" id="kobo.33.1">BuildShader()</span></code><span class="koboSpan" id="kobo.34.1"> method is invoked, and the returned identifier is stored inside the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">m_shader</span></code><span class="koboSpan" id="kobo.36.1"> array for the relevant type of shader. </span><span class="koboSpan" id="kobo.36.2">Note the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">GL_VERTEX_SHADER</span></code><span class="koboSpan" id="kobo.38.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.39.1">GL_FRAGMENT_SHADER</span></code><span class="koboSpan" id="kobo.40.1"> definitions being passed to the method call. </span><span class="koboSpan" id="kobo.40.2">These are the shader types OpenGL needs in order to build the shaders.</span></p><p><span class="koboSpan" id="kobo.41.1">After the shaders have been built, they need to be attached to our created program. </span><span class="koboSpan" id="kobo.41.2">For this we can simply use a loop and invoke </span><code class="literal"><span class="koboSpan" id="kobo.42.1">glAttachShader</span></code><span class="koboSpan" id="kobo.43.1">, which takes the ID of the program, as well as an ID of the shader to be attached to said program.</span></p><p><span class="koboSpan" id="kobo.44.1">Shaders need to have some sort of input as they are being executed. </span><span class="koboSpan" id="kobo.44.2">Remember that our model rendering begins with a binding to a VAO, which holds the information about how certain attributes of a VBO should be accessed, followed by a draw call. </span><span class="koboSpan" id="kobo.44.3">In order for the data feeding to work properly, our shader class needs to bind a name and attribute location. </span><span class="koboSpan" id="kobo.44.4">This can be done by calling </span><code class="literal"><span class="koboSpan" id="kobo.45.1">glBindAttribLocation</span></code><span class="koboSpan" id="kobo.46.1">, and passing in the ID of the program, the actual attribute location, which is enumerated as </span><code class="literal"><span class="koboSpan" id="kobo.47.1">VertexAttribute</span></code><span class="koboSpan" id="kobo.48.1">, and the name of the attribute variable that's going to be used inside the shader program. </span><span class="koboSpan" id="kobo.48.2">This step ensures that the data being fed into the vertex shader will be accessible through a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.49.1">position</span></em></span><span class="koboSpan" id="kobo.50.1"> variable. </span><span class="koboSpan" id="kobo.50.2">This will be covered more in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">Writing basic shaders</span></em></span><span class="koboSpan" id="kobo.52.1"> section.</span></p><p><span class="koboSpan" id="kobo.53.1">After the shaders are built and have their attributes bound, all we have left is linking and validation, the latter of which determines if the shader executable can run given the current OpenGL state. </span><span class="koboSpan" id="kobo.53.2">Both </span><code class="literal"><span class="koboSpan" id="kobo.54.1">glLinkProgram</span></code><span class="koboSpan" id="kobo.55.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.56.1">glValidateProgram</span></code><span class="koboSpan" id="kobo.57.1"> simply take the ID of the program. </span><span class="koboSpan" id="kobo.57.2">After each of these function calls, we also invoke the other static helper method, </span><code class="literal"><span class="koboSpan" id="kobo.58.1">CheckError</span></code><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">It is responsible for actually fetching a string of information, pertaining to any sort of errors during the linking and compilation stages. </span><span class="koboSpan" id="kobo.59.3">This method takes in the program ID, a flag that is used to determine what stage of the shader building process we are actually interested in, a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.60.1">Boolean</span></em></span><span class="koboSpan" id="kobo.61.1"> value that signifies whether the whole shader program is being checked or if it is just an individual shader, and a string to be split out into the console window before the actual error is printed.</span></p><p><span class="koboSpan" id="kobo.62.1">Shaders, just like any resource, need to be cleaned up once we are done with them:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.63.1">GL_Shader::~GL_Shader() { 
  for (GLuint i = 0; 
    i &lt; static_cast&lt;GLuint&gt;(ShaderType::COUNT); ++i) 
  { 
    glDetachShader(m_program, m_shader[i]); 
    glDeleteShader(m_shader[i]); 
  } 
  glDeleteProgram(m_program); 
} 
</span></pre><p><span class="koboSpan" id="kobo.64.1">Thanks to the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">ShaderType</span></code><span class="koboSpan" id="kobo.66.1"> enumeration, we know exactly how many shader types we support, and so we are able to simply run a loop for each one during cleanup. </span><span class="koboSpan" id="kobo.66.2">For each shader type, we must first detach it from the shader program using </span><code class="literal"><span class="koboSpan" id="kobo.67.1">glDetachShader</span></code><span class="koboSpan" id="kobo.68.1">, which takes the program ID and the shader ID, and then deletes it using </span><code class="literal"><span class="koboSpan" id="kobo.69.1">glDeleteShader</span></code><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Once all the shaders are removed, the program itself is deleted through the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">glDeleteProgram()</span></code><span class="koboSpan" id="kobo.72.1"> function call.</span></p><p><span class="koboSpan" id="kobo.73.1">As discussed previously, OpenGL operates using function calls and a shared state. </span><span class="koboSpan" id="kobo.73.2">This means that certain resources such as shaders, for example, must be bound to before being used for rendering:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.74.1">void GL_Shader::Bind() const { glUseProgram(m_program); } 
</span></pre><p><span class="koboSpan" id="kobo.75.1">In order to use a shader for a specific set of primitives to be drawn, we simply need to call </span><code class="literal"><span class="koboSpan" id="kobo.76.1">glUseProgram</span></code><span class="koboSpan" id="kobo.77.1"> and pass in the ID of the shader program.</span></p><p><span class="koboSpan" id="kobo.78.1">Let us take a look at one of our helper methods, used to determine if there were any errors during the various stages of the shader program setup:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.79.1">void GL_Shader::CheckError(GLuint l_shader, GLuint l_flag, 
  bool l_program, const std::string&amp; l_errorMsg) 
{ 
  GLint success = 0; 
  GLchar error[1024] = { 0 }; 
  if (l_program) { glGetProgramiv(l_shader, l_flag, &amp;success); } 
  else { glGetShaderiv(l_shader, l_flag, &amp;success); } 
 
  if (success) { return; } 
  if (l_program) { 
    glGetProgramInfoLog(l_shader, sizeof(error), nullptr, error); 
  } else { 
    glGetShaderInfoLog(l_shader, sizeof(error), nullptr, error); 
  } 
  std::cout &lt;&lt; l_errorMsg &lt;&lt; error &lt;&lt; std::endl; 
} 
</span></pre><p><span class="koboSpan" id="kobo.80.1">First, a few local variables are set up for storing the state information: a success flag, and a buffer for an error message to be put in. </span><span class="koboSpan" id="kobo.80.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.81.1">l_program</span></code><span class="koboSpan" id="kobo.82.1"> flag is true, it means we are trying to fetch information about the actual shader program. </span><span class="koboSpan" id="kobo.82.2">Otherwise, we are only interested in an individual shader. </span><span class="koboSpan" id="kobo.82.3">To obtain the parameter that signifies success or failure of link/validation/compilation stages of a shader/program, we need to use </span><code class="literal"><span class="koboSpan" id="kobo.83.1">glGetProgramiv</span></code><span class="koboSpan" id="kobo.84.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.85.1">glGetShaderiv</span></code><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">Both of them take an ID to a shader or program being checked, a flag of the parameter we are interested in, and a pointer to the return value that is to be overwritten with either </span><code class="literal"><span class="koboSpan" id="kobo.87.1">GL_TRUE</span></code><span class="koboSpan" id="kobo.88.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.89.1">GL_FALSE</span></code><span class="koboSpan" id="kobo.90.1"> in this case.</span></p><p><span class="koboSpan" id="kobo.91.1">If whichever stage of the shader building process we are interested in finished successfully, we simply return from the method. </span><span class="koboSpan" id="kobo.91.2">Otherwise, we invoke either  </span><code class="literal"><span class="koboSpan" id="kobo.92.1">glGetProgramInfoLog()</span></code><span class="koboSpan" id="kobo.93.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.94.1">glGetShaderInfoLog()</span></code><span class="koboSpan" id="kobo.95.1"> to fetch the error information of the program or individual shader. </span><span class="koboSpan" id="kobo.95.2">Both of these functions take the identifier of either the program or shader being checked, the size of the error message buffer we have allocated, a pointer to a variable that would be used to store the length of the string returned, which we do not really need so </span><code class="literal"><span class="koboSpan" id="kobo.96.1">nullptr</span></code><span class="koboSpan" id="kobo.97.1"> is passed in, and a pointer to the error message buffer that is to be written to. </span><span class="koboSpan" id="kobo.97.2">Afterwards, it is as simple as printing out our </span><code class="literal"><span class="koboSpan" id="kobo.98.1">l_errorMsg</span></code><span class="koboSpan" id="kobo.99.1"> prefix, followed by the actual error written to the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">error</span></code><span class="koboSpan" id="kobo.101.1"> message buffer.</span></p><p><span class="koboSpan" id="kobo.102.1">Last, but definitely not least, let us see what it takes to build an individual shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.103.1">GLuint GL_Shader::BuildShader(const std::string&amp; l_src, 
  unsigned int l_type) 
{ 
  GLuint shaderID = glCreateShader(l_type); 
  if (!shaderID) { 
    std::cout &lt;&lt; "Bad shader type!" </span><span class="koboSpan" id="kobo.103.2">&lt;&lt; std::endl; return 0; 
  } 
  const GLchar* sources[1]; 
  GLint lengths[1]; 
  sources[0] = l_src.c_str(); 
  lengths[0] = l_src.length(); 
  glShaderSource(shaderID, 1, sources, lengths); 
  glCompileShader(shaderID); 
  CheckError(shaderID, GL_COMPILE_STATUS, false, 
    "Shader compile error: "); 
  return shaderID; 
} 
</span></pre><p><span class="koboSpan" id="kobo.104.1">First, an individual shader has to be created using the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">glCreateShader()</span></code><span class="koboSpan" id="kobo.106.1"> method. </span><span class="koboSpan" id="kobo.106.2">It takes in a shader type, such as </span><code class="literal"><span class="koboSpan" id="kobo.107.1">GL_VERTEX_SHADER</span></code><span class="koboSpan" id="kobo.108.1">, which we used in the constructor of this class. </span><span class="koboSpan" id="kobo.108.2">If, for some reason, the shader creation failed, an error message is written to the console window and the method returns a </span><code class="literal"><span class="koboSpan" id="kobo.109.1">0</span></code><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Otherwise, two arrays of GL types are set up: one for the sources of potentially multiple shaders, and one for the lengths of each source string. </span><span class="koboSpan" id="kobo.110.3">For now we're only going to be dealing with one source per shader, but it is possible to handle multiple sources later on, should we ever want to.</span></p><p><span class="koboSpan" id="kobo.111.1">After the source code and its length have been written to the arrays we just set up, </span><code class="literal"><span class="koboSpan" id="kobo.112.1">glShaderSource</span></code><span class="koboSpan" id="kobo.113.1"> is used to submit the code to a buffer before it gets compiled. </span><span class="koboSpan" id="kobo.113.2">The function takes in the ID of the newly created shader, the number of source strings we're passing in, a pointer to the source array, as well as a pointer to the source length array. </span><span class="koboSpan" id="kobo.113.3">The shader is then actually compiled using </span><code class="literal"><span class="koboSpan" id="kobo.114.1">glCompileShader</span></code><span class="koboSpan" id="kobo.115.1">, and the </span><code class="literal"><span class="koboSpan" id="kobo.116.1">CheckError</span></code><span class="koboSpan" id="kobo.117.1"> helper method is invoked to print out any possible compilation errors. </span><span class="koboSpan" id="kobo.117.2">Note the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">GL_COMPILE_STATUS</span></code><span class="koboSpan" id="kobo.119.1"> flag being passed in, as well as the false flag, showing that we're interested in checking the status of an individual shader, rather than the whole shader program.</span></p></div></div><div class="section" title="Writing basic shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec62"/><span class="koboSpan" id="kobo.120.1">Writing basic shaders</span></h2></div></div></div><p><span class="koboSpan" id="kobo.121.1">As our </span><code class="literal"><span class="koboSpan" id="kobo.122.1">GL_Shader</span></code><span class="koboSpan" id="kobo.123.1"> class is done, we can finally get to write some basic shaders for our application! </span><span class="koboSpan" id="kobo.123.2">Let us get started by taking a look at a file named </span><code class="literal"><span class="koboSpan" id="kobo.124.1">basic.vert</span></code><span class="koboSpan" id="kobo.125.1">, which is our vertex shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.126.1">#version 450
attribute vec3 position; 
 
void main(){ 
   gl_Position = vec4(position, 1.0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.127.1">First, we set up the </span><code class="literal"><span class="koboSpan" id="kobo.128.1">attribute</span></code><span class="koboSpan" id="kobo.129.1"> of the shader that is going to be written to by OpenGL. </span><span class="koboSpan" id="kobo.129.2">It is an attribute of type </span><code class="literal"><span class="koboSpan" id="kobo.130.1">vec3</span></code><span class="koboSpan" id="kobo.131.1">, and is going to represent our </span><span class="strong"><strong><span class="koboSpan" id="kobo.132.1">vertex position</span></strong></span><span class="koboSpan" id="kobo.133.1"> information that gets fed into this shader one by one. </span><span class="koboSpan" id="kobo.133.2">This type was set up inside the </span><code class="literal"><span class="koboSpan" id="kobo.134.1">GL_Model</span></code><span class="koboSpan" id="kobo.135.1"> class constructor using the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">glVertexAttribPointer</span></code><span class="koboSpan" id="kobo.137.1">, and then named in the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">GL_Shader</span></code><span class="koboSpan" id="kobo.139.1"> class constructor, using the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">glBindVertexAttribLocation</span></code><span class="koboSpan" id="kobo.141.1"> function.</span></p><p><span class="koboSpan" id="kobo.142.1">The body of the shader has to have a main function, where all of the magic happens. </span><span class="koboSpan" id="kobo.142.2">In this case, all we need to do is set the internal OpenGL variable </span><code class="literal"><span class="koboSpan" id="kobo.143.1">gl_Position</span></code><span class="koboSpan" id="kobo.144.1"> to the position we want our vertex to have. </span><span class="koboSpan" id="kobo.144.2">It requires a </span><code class="literal"><span class="koboSpan" id="kobo.145.1">vec4</span></code><span class="koboSpan" id="kobo.146.1"> type, so the position attribute is converted to it, with the last vector value, which is used for clipping purposes, being set to </span><code class="literal"><span class="koboSpan" id="kobo.147.1">1.0</span></code><span class="koboSpan" id="kobo.148.1">. </span><span class="koboSpan" id="kobo.148.2">For now, we do not need to worry about this. </span><span class="koboSpan" id="kobo.148.3">Just keep in mind that the actual vertex position in normalized device coordinates (coordinates in a range of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.149.1">(-1,-1)</span></em></span><span class="koboSpan" id="kobo.150.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.151.1">(1,1)</span></em></span><span class="koboSpan" id="kobo.152.1">) are set here.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/><span class="koboSpan" id="kobo.153.1">Tip</span></h3><p><span class="koboSpan" id="kobo.154.1">Note the version number on the very first line. </span><span class="koboSpan" id="kobo.154.2">If your computer does not support OpenGL 4.5, this can be changed to anything else, especially because we are not doing anything that older versions do not support.</span></p></div></div><p><span class="koboSpan" id="kobo.155.1">After the vertex information is processed, we also need to worry about shading the individual pixels that make up our geometry correctly. </span><span class="koboSpan" id="kobo.155.2">This is where the fragment shader comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.156.1">#version 450 
 
void main(){ 
   gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // White. 
</span><span class="koboSpan" id="kobo.156.2">} 
</span></pre><p><span class="koboSpan" id="kobo.157.1">This shader also uses an internal OpenGL variable. </span><span class="koboSpan" id="kobo.157.2">This time it is named </span><code class="literal"><span class="koboSpan" id="kobo.158.1">gl_FragColor</span></code><span class="koboSpan" id="kobo.159.1">, and, predictably enough, is used for setting the color of the pixel we are processing. </span><span class="koboSpan" id="kobo.159.2">For now, let us just shade all of the pixels of our geometry white.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Drawing our first triangle"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/><span class="koboSpan" id="kobo.1.1">Drawing our first triangle</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">We have our model class that handles all of the geometry data, as well as the shader class, which deals with processing our data at various points of the programmable rendering pipeline. </span><span class="koboSpan" id="kobo.2.2">With that out of the way, all we have left to do is actually set up and use these classes. </span><span class="koboSpan" id="kobo.2.3">Let us start by adding them as data members to the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Game</span></code><span class="koboSpan" id="kobo.4.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class Game{ 
  ... 
</span><span class="koboSpan" id="kobo.5.2">private: 
  ... 
  </span><span class="koboSpan" id="kobo.5.3">std::unique_ptr&lt;GL_Shader&gt; m_shader; 
  std::unique_ptr&lt;GL_Model&gt; m_model; 
  ... 
</span><span class="koboSpan" id="kobo.5.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">They can then be set up in the constructor of our </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Game</span></code><span class="koboSpan" id="kobo.8.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">Game::Game() ... </span><span class="koboSpan" id="kobo.9.2">{ 
  ... 
  </span><span class="koboSpan" id="kobo.9.3">m_shader = std::make_unique&lt;GL_Shader&gt;( 
    Utils::GetWorkingDirectory() + "GL/basic"); 
 
  GL_Vertex vertices[] = { 
    //        |-----POSITION----| 
    //            X     Y    Z 
    GL_Vertex({ -0.5, -0.5, 0.5 }, // 0 
    GL_Vertex({ -0.5, 0.5, 0.5 }, // 1 
    GL_Vertex({ 0.5, 0.5, 0.5 }, // 2 
  }; 
 
  m_model = std::make_unique&lt;GL_Model&gt;(vertices, 3); 
} 
</span></pre><p><span class="koboSpan" id="kobo.10.1">First, the shader class is created and a path with a filename is passed to it, so that the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">basic.vert</span></code><span class="koboSpan" id="kobo.12.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.13.1">basic.frag</span></code><span class="koboSpan" id="kobo.14.1"> shaders inside the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">GL</span></code><span class="koboSpan" id="kobo.16.1"> directory of our executable directory can be loaded. </span><span class="koboSpan" id="kobo.16.2">An array of vertices is then set up, with each one being initialized to a particular position in normalized device coordinates. </span><span class="koboSpan" id="kobo.16.3">This particular arrangement creates three vertices in the middle of the screen, which will be connected into a triangle. </span><span class="koboSpan" id="kobo.16.4">The coordinates here fall within the range of what is known as </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">normalized device coordinates</span></strong></span><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">It is the coordinate system that the window uses, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.19.1"><img src="graphics/image_07_003.jpg" alt="Drawing our first triangle"/></span></div><p><span class="koboSpan" id="kobo.20.1">A </span><code class="literal"><span class="koboSpan" id="kobo.21.1">GL_Model</span></code><span class="koboSpan" id="kobo.22.1"> object is then created, with the vertex array and vertex count being passed in as arguments. </span><span class="koboSpan" id="kobo.22.2">The </span><code class="literal"><span class="koboSpan" id="kobo.23.1">GL_Model</span></code><span class="koboSpan" id="kobo.24.1"> then goes on to push this data to the GPU, as discussed previously.</span></p><p><span class="koboSpan" id="kobo.25.1">Lastly, let us take a look at how we can render our triangle on screen:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">void Game::Render() { 
  m_window.BeginDraw(); 
  // Render here. 
  </span><span class="koboSpan" id="kobo.26.2">m_shader-&gt;Bind(); 
  m_model-&gt;Draw(); 
  // Finished rendering. 
  </span><span class="koboSpan" id="kobo.26.3">m_window.EndDraw(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">After the window is cleared inside the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">BeginDraw()</span></code><span class="koboSpan" id="kobo.29.1"> method, the shader program is bound to, so that the vertex and fragment shaders we wrote earlier are used when the vertex data of our </span><code class="literal"><span class="koboSpan" id="kobo.30.1">GL_Model</span></code><span class="koboSpan" id="kobo.31.1"> is being pushed through the rendering pipeline. </span><span class="koboSpan" id="kobo.31.2">The models </span><code class="literal"><span class="koboSpan" id="kobo.32.1">Draw()</span></code><span class="koboSpan" id="kobo.33.1"> method is then invoked, to begin the rendering process. </span><span class="koboSpan" id="kobo.33.2">After successful program compilation and execution, this is what we should see on screen:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.34.1"><img src="graphics/image_07_004.jpg" alt="Drawing our first triangle"/></span></div><p><span class="koboSpan" id="kobo.35.1">Hooray! </span><span class="koboSpan" id="kobo.35.2">After about 20 pages of theory, we have a triangle. </span><span class="koboSpan" id="kobo.35.3">This may be a little bit discouraging, but keep in mind that everything from this point on is going to get much, much easier. </span><span class="koboSpan" id="kobo.35.4">Congratulations on making it this far!</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using textures"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/><span class="koboSpan" id="kobo.1.1">Using textures</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">A basic, white triangle is not very exciting to look at. </span><span class="koboSpan" id="kobo.2.2">The next obvious improvement to make to our code is making textures available to the fragment shader, so that they can be sampled and applied to our geometry. </span><span class="koboSpan" id="kobo.2.3">Unfortunately, OpenGL does not provide a way of actually loading image data, especially since there are so many different formats to keep up with. </span><span class="koboSpan" id="kobo.2.4">For that, we are going to use one of our resources listed at the beginning of this chapter, the STB image loader. </span><span class="koboSpan" id="kobo.2.5">It is a small, single header C library, used to load image data into a buffer that can later be used by OpenGL, or any other library for that matter.</span></p><div class="section" title="The texture class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec63"/><span class="koboSpan" id="kobo.3.1">The texture class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Remember the remark that everything is going to get much easier at this point? </span><span class="koboSpan" id="kobo.4.2">It is true. </span><span class="koboSpan" id="kobo.4.3">Let us breeze through the texturing process, starting with a class definition for a texture object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class GL_Texture { 
public: 
  GL_Texture(const std::string&amp; l_fileName); 
  ~GL_Texture(); 
 
  void Bind(unsigned int l_unit); 
private: 
  GLuint m_texture; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">Although OpenGL does not actually handle loading texture data, it is still going to be handled within the confines of this class. </span><span class="koboSpan" id="kobo.6.2">Because of that, the constructor of our texture class is still going to take a path to the texture file to be loaded. </span><span class="koboSpan" id="kobo.6.3">Also, much like the shader class, we are going to need to bind to a specific texture before it can be used when rendering geometry. </span><span class="koboSpan" id="kobo.6.4">For now, ignore the argument it takes. </span><span class="koboSpan" id="kobo.6.5">It will be explained down the line.</span></p><p><span class="koboSpan" id="kobo.7.1">The OpenGL textures, just like shaders or geometry data, have to be stored on the GPU. </span><span class="koboSpan" id="kobo.7.2">Because of that, it stands to reason that texture data will be referred to by a </span><code class="literal"><span class="koboSpan" id="kobo.8.1">GLuint</span></code><span class="koboSpan" id="kobo.9.1"> identifier, just like shaders or buffers.</span></p><div class="section" title="Implementing the texture class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec11"/><span class="koboSpan" id="kobo.10.1">Implementing the texture class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.11.1">Let us take a look at what needs to be done in order to successfully load textures from the hard disk, and push them into the GPU:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">GL_Texture::GL_Texture(const std::string&amp; l_fileName) { 
  int width, height, nComponents; 
  unsigned char* imageData = stbi_load(l_fileName.c_str(), 
    &amp;width, &amp;height, &amp;nComponents, 4); 
  if (!imageData) { return; } 
 
  glGenTextures(1, &amp;m_texture); 
  glBindTexture(GL_TEXTURE_2D, m_texture); 
 
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); 
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,GL_LINEAR); 
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,GL_LINEAR); 
 
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, 
    GL_RGBA, GL_UNSIGNED_BYTE, imageData); 
 
  stbi_image_free(imageData); 
} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">First, a few integers are created in order to be filled in with information about the texture that is going to be loaded. </span><span class="koboSpan" id="kobo.13.2">We then invoke the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">stbi_load()</span></code><span class="koboSpan" id="kobo.15.1"> function, which is part of the STB image loading library, passing in a path to the texture file, pointers to the width, height, and the component count variables that are about to be written to, as well as the number of components the file is expected to have. </span><span class="koboSpan" id="kobo.15.2">The data is stored in the form of an </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">unsigned char</span></em></span><span class="koboSpan" id="kobo.17.1">, a pointer to which is returned by the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">stbi_load()</span></code><span class="koboSpan" id="kobo.19.1"> function. </span><span class="koboSpan" id="kobo.19.2">If </span><code class="literal"><span class="koboSpan" id="kobo.20.1">nullptr</span></code><span class="koboSpan" id="kobo.21.1"> was returned, we obviously need to return, as the loading process failed.</span></p><p><span class="koboSpan" id="kobo.22.1">The number of components an image has is simply the number of color channels. </span><span class="koboSpan" id="kobo.22.2">Passing in a value of 0 would mean the image data is loaded as is, while any other value </span><span class="emphasis"><em><span class="koboSpan" id="kobo.23.1">forces</span></em></span><span class="koboSpan" id="kobo.24.1"> the data to contain other color channel information. </span><span class="koboSpan" id="kobo.24.2">The component number to channel configuration can be evaluated like so:</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">Components</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">Channels</span></strong></span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.27.1">1</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.28.1">Gray</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.29.1">2</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.30.1">Gray, alpha</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.31.1">3</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.32.1">Red, green, blue</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.33.1">4</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.34.1">Red, green, blue, alpha</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.35.1">From this point on, we follow what should be a familiar pattern by now. </span><span class="koboSpan" id="kobo.35.2">First, a texture object is generated using </span><code class="literal"><span class="koboSpan" id="kobo.36.1">glGenTextures</span></code><span class="koboSpan" id="kobo.37.1">, to which the number of textures we want is passed as the first argument, and the pointer to the texture identifier or a list of them as the second argument. </span><span class="koboSpan" id="kobo.37.2">We then bind to the newly created texture using </span><code class="literal"><span class="koboSpan" id="kobo.38.1">glBindTexture</span></code><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">The first argument of this function simply lets OpenGL know what kind of texture we are dealing with. </span><span class="koboSpan" id="kobo.39.3">In this case, </span><code class="literal"><span class="koboSpan" id="kobo.40.1">GL_TEXTURE_2D</span></code><span class="koboSpan" id="kobo.41.1"> is used, because it is a basic 2D image.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/><span class="koboSpan" id="kobo.42.1">Tip</span></h3><p><span class="koboSpan" id="kobo.43.1">OpenGL supports a myriad of different types of textures for various tasks, including 3D textures, cube maps, and so on.</span></p></div></div><p><span class="koboSpan" id="kobo.44.1">Once a texture is bound to, we can manipulate various details it comes with. </span><span class="koboSpan" id="kobo.44.2">For textures, the parameter manipulation function is named </span><code class="literal"><span class="koboSpan" id="kobo.45.1">glTexParameter()</span></code><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">There are many different types of this single function, all with different suffixes that give a hint to the programmer of what data type it is expecting. </span><span class="koboSpan" id="kobo.46.3">For our purposes, we are going to be using two types: </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">integer</span></em></span><span class="koboSpan" id="kobo.48.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.49.1">float</span></em></span><span class="koboSpan" id="kobo.50.1">, appropriately ended by letters </span><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">i</span></em></span><span class="koboSpan" id="kobo.52.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.53.1">f</span></em></span><span class="koboSpan" id="kobo.54.1">.</span></p><p><span class="koboSpan" id="kobo.55.1">The first two lines deal with defining behavior for cases when texture data is being read outside of the boundaries of its size, that is, how the texture is wrapped. </span><span class="koboSpan" id="kobo.55.2">The </span><code class="literal"><span class="koboSpan" id="kobo.56.1">GL_TEXTURE_WRAP_S</span></code><span class="koboSpan" id="kobo.57.1"> parameter deals with wrapping on the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">X</span></em></span><span class="koboSpan" id="kobo.59.1"> axis, while the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">GL_TEXTURE_WRAP_T</span></code><span class="koboSpan" id="kobo.61.1"> parameter deals with the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.62.1">Y</span></em></span><span class="koboSpan" id="kobo.63.1"> axis. </span><span class="koboSpan" id="kobo.63.2">Why </span><span class="emphasis"><em><span class="koboSpan" id="kobo.64.1">S</span></em></span><span class="koboSpan" id="kobo.65.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.66.1">T</span></em></span><span class="koboSpan" id="kobo.67.1"> you may ask? </span><span class="koboSpan" id="kobo.67.2">The answer to that is simple. </span><span class="koboSpan" id="kobo.67.3">Positional vectors, color data, and texture coordinates are enumerated differently, but they both mean roughly the same thing. </span><span class="koboSpan" id="kobo.67.4">Consider the following table:</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td>
</td><td>
<p><span class="koboSpan" id="kobo.68.1">1</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.69.1">2</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.70.1">3</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.71.1">4</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.72.1">Position</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.73.1">X</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.74.1">Y</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.75.1">Z</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.76.1">W</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.77.1">Color</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.78.1">R</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.79.1">G</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.80.1">B</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.81.1">A</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.82.1">Textures</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.83.1">S</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.84.1">T</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.85.1">P</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.86.1">Q</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.87.1">They are all vectors of four values. </span><span class="koboSpan" id="kobo.87.2">Accessing the position </span><span class="emphasis"><em><span class="koboSpan" id="kobo.88.1">X</span></em></span><span class="koboSpan" id="kobo.89.1"> value is the same as accessing the red channel of a color structure, and so on.</span></p><p><span class="koboSpan" id="kobo.90.1">The next two function calls deal with how the texture is interpolated when being sized down or up. </span><span class="koboSpan" id="kobo.90.2">Both cases specify the </span><code class="literal"><span class="koboSpan" id="kobo.91.1">GL_LINEAR</span></code><span class="koboSpan" id="kobo.92.1"> parameter, which means the pixels will be linearly interpolated.</span></p><p><span class="koboSpan" id="kobo.93.1">Finally, we actually submit the loaded pixel information to the GPU by invoking the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">glTexImage2D()</span></code><span class="koboSpan" id="kobo.95.1"> method. </span><span class="koboSpan" id="kobo.95.2">Its first argument, once again, lets OpenGL know what type of texture we are submitting. </span><span class="koboSpan" id="kobo.95.3">The second argument is the texture's level of detail, which will be used for mip-mapping. </span><span class="koboSpan" id="kobo.95.4">The value </span><code class="literal"><span class="koboSpan" id="kobo.96.1">0</span></code><span class="koboSpan" id="kobo.97.1"> simply means it is the base level texture.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/><span class="koboSpan" id="kobo.98.1">Note</span></h3><p><span class="koboSpan" id="kobo.99.1">Mip-mapping is an optional technique that can be utilized by OpenGL, in which multiple versions of the same texture, but of different resolutions, are loaded and submitted to the GPU, and later applied to geometry depending on how far it is from the viewer. </span><span class="koboSpan" id="kobo.99.2">If it is further away, a lower resolution texture (with a higher mip-mapping level) is used. </span><span class="koboSpan" id="kobo.99.3">This can be done for performance reasons, when necessary.</span></p></div></div><p><span class="koboSpan" id="kobo.100.1">The third argument lets OpenGL know what arrangement the pixel information data is in. </span><span class="koboSpan" id="kobo.100.2">This is necessary, because certain formats may store it in varying configurations. </span><span class="koboSpan" id="kobo.100.3">The width and height information is passed in next, along with a number of pixels that can be used to add a border to the texture. </span><span class="koboSpan" id="kobo.100.4">We are not going to be using that feature, which is why </span><code class="literal"><span class="koboSpan" id="kobo.101.1">0</span></code><span class="koboSpan" id="kobo.102.1"> is passed in. </span><span class="koboSpan" id="kobo.102.2">The next argument is, once again, a flag for a certain arrangement of pixels. </span><span class="koboSpan" id="kobo.102.3">This time it lets OpenGL know which arrangement we want it to store the pixel data in. </span><span class="koboSpan" id="kobo.102.4">Finally, a flag for the type that our loaded texture is in is passed, along with a pointer to the actual texture data. </span><span class="koboSpan" id="kobo.102.5">We are using the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">GL_UNSIGNED_BYTE</span></code><span class="koboSpan" id="kobo.104.1"> parameter, because that is what the STB image loader returns, and the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.105.1">char</span></em></span><span class="koboSpan" id="kobo.106.1"> type is exactly one byte long.</span></p><p><span class="koboSpan" id="kobo.107.1">After the texture information is submitted to the GPU, we no longer need to keep the image data buffer around. </span><span class="koboSpan" id="kobo.107.2">It's destroyed by calling </span><code class="literal"><span class="koboSpan" id="kobo.108.1">stbi_image_free</span></code><span class="koboSpan" id="kobo.109.1">, and passing in the pointer to the buffer.</span></p><p><span class="koboSpan" id="kobo.110.1">The data we submitted to the GPU needs to be released once we no longer need the texture:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.111.1">GL_Texture::~GL_Texture() { glDeleteTextures(1, &amp;m_texture); } 
</span></pre><p><span class="koboSpan" id="kobo.112.1">The </span><code class="literal"><span class="koboSpan" id="kobo.113.1">glDeleteTextures</span></code><span class="koboSpan" id="kobo.114.1"> function takes the number of textures we want to dispose of, as well as a pointer to an array of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.115.1">GLuint</span></em></span><span class="koboSpan" id="kobo.116.1"> identifiers.</span></p><p><span class="koboSpan" id="kobo.117.1">Finally, let's implement the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Bind()</span></code><span class="koboSpan" id="kobo.119.1"> method, which is going to give us the ability to use the texture when rendering:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.120.1">void GL_Texture::Bind(unsigned int l_unit) { 
  assert(l_unit &gt;= 0 &amp;&amp; l_unit &lt; 32); 
  glActiveTexture(GL_TEXTURE0 + l_unit); 
  glBindTexture(GL_TEXTURE_2D, m_texture); 
} 
</span></pre><p><span class="koboSpan" id="kobo.121.1">OpenGL actually supports the ability for multiple textures to be bound all at once while rendering, so that complex geometry can be textured more efficiently. </span><span class="koboSpan" id="kobo.121.2">The exact number, at least at the time of writing, is </span><code class="literal"><span class="koboSpan" id="kobo.122.1">32</span></code><span class="koboSpan" id="kobo.123.1"> units. </span><span class="koboSpan" id="kobo.123.2">Most of the time we are not going to need that many, but it is nice to have the option. </span><span class="koboSpan" id="kobo.123.3">The identifier of the unit we want to use is passed in as an argument to the </span><code class="literal"><span class="koboSpan" id="kobo.124.1">Bind()</span></code><span class="koboSpan" id="kobo.125.1"> method. </span><span class="koboSpan" id="kobo.125.2">In order to avoid confusion, we are going to perform an </span><code class="literal"><span class="koboSpan" id="kobo.126.1">assert()</span></code><span class="koboSpan" id="kobo.127.1"> method and make sure that the </span><code class="literal"><span class="koboSpan" id="kobo.128.1">l_unit</span></code><span class="koboSpan" id="kobo.129.1"> value is in the right range first.</span></p><p><span class="koboSpan" id="kobo.130.1">In order to enable a specific unit for a texture, the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">glActiveTexture()</span></code><span class="koboSpan" id="kobo.132.1"> method needs to be called. </span><span class="koboSpan" id="kobo.132.2">It takes a single argument, which is the enumerated texture unit. </span><span class="koboSpan" id="kobo.132.3">It ranges from </span><code class="literal"><span class="koboSpan" id="kobo.133.1">GL_TEXTURE0</span></code><span class="koboSpan" id="kobo.134.1"> all the way to </span><code class="literal"><span class="koboSpan" id="kobo.135.1">GL_TEXTURE31</span></code><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">Because those values are sequential, a neat trick is to simply add the </span><code class="literal"><span class="koboSpan" id="kobo.137.1">l_unit</span></code><span class="koboSpan" id="kobo.138.1"> to the </span><code class="literal"><span class="koboSpan" id="kobo.139.1">GL_TEXTURE0</span></code><span class="koboSpan" id="kobo.140.1"> definition, which will give us the right unit enumeration. </span><span class="koboSpan" id="kobo.140.2">After that, we simply bind to the texture as before, using the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">glBindTexture()</span></code><span class="koboSpan" id="kobo.142.1"> method and passing in the type of texture we have, along with its identifier.</span></p></div></div><div class="section" title="Model and shader class changes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec64"/><span class="koboSpan" id="kobo.143.1">Model and shader class changes</span></h2></div></div></div><p><span class="koboSpan" id="kobo.144.1">To add support for textured geometry, we first need to make some changes to the vertex information that gets stored. </span><span class="koboSpan" id="kobo.144.2">Let us take a look at the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">GL_Vertex</span></code><span class="koboSpan" id="kobo.146.1"> structure to see what needs to be added:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.147.1">enum class VertexAttribute{ Position, TexCoord, COUNT }; 
 
struct GL_Vertex { 
  GL_Vertex(const glm::vec3&amp; l_pos, 
    </span><span class="strong"><strong><span class="koboSpan" id="kobo.148.1">const glm::vec2&amp; l_texCoord</span></strong></span><span class="koboSpan" id="kobo.149.1">) 
    : m_pos(l_pos), </span><span class="strong"><strong><span class="koboSpan" id="kobo.150.1">m_texCoord(l_texCoord</span></strong></span><span class="koboSpan" id="kobo.151.1">) {} 
 
  glm::vec3 m_pos; // Attribute 1. 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.152.1">glm::vec2 m_texCoord;</span></strong></span><span class="koboSpan" id="kobo.153.1"> // Attribute 2. 
  </span><span class="koboSpan" id="kobo.153.2">// ... 
</span><span class="koboSpan" id="kobo.153.3">}; 
</span></pre><p><span class="koboSpan" id="kobo.154.1">As you can see, we need an additional vertex attribute, which is the coordinate of the texture a vertex is associated with. </span><span class="koboSpan" id="kobo.154.2">It is a simple two-dimensional vector that represents the texture coordinates, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.155.1"><img src="graphics/image_07_005.jpg" alt="Model and shader class changes"/></span></div><p><span class="koboSpan" id="kobo.156.1">The great thing about representing texture coordinates in this fashion is the fact that it makes the coordinates resolution-independent. </span><span class="koboSpan" id="kobo.156.2">A point </span><span class="emphasis"><em><span class="koboSpan" id="kobo.157.1">(0.5,0.5)</span></em></span><span class="koboSpan" id="kobo.158.1"> on a smaller texture is going to be the exact same point on its larger counterpart.</span></p><p><span class="koboSpan" id="kobo.159.1">Because we now have more information about a single vertex that needs to be stored and accessed, the VAO needs to know exactly how to do so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.160.1">GL_Model::GL_Model(GL_Vertex* l_vertices,unsigned int l_vertCount) 
{ 
  ... 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.161.1">auto stride = sizeof(l_vertices[0]);</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.162.1">  auto texCoordOffset = sizeof(l_vertices[0].m_pos);</span></strong></span><span class="koboSpan" id="kobo.163.1"> 
 
  glBindBuffer(GL_ARRAY_BUFFER, m_vertexVBO); 
  glBufferData(GL_ARRAY_BUFFER, 
    l_vertCount * sizeof(l_vertices[0]), 
    l_vertices, GL_STATIC_DRAW); 
  glEnableVertexAttribArray( 
    static_cast&lt;GLuint&gt;(VertexAttribute::Position)); 
  glVertexAttribPointer( 
    static_cast&lt;GLuint&gt;(VertexAttribute::Position), 3, GL_FLOAT, 
    GL_FALSE, </span><span class="strong"><strong><span class="koboSpan" id="kobo.164.1">stride</span></strong></span><span class="koboSpan" id="kobo.165.1">, </span><span class="strong"><strong><span class="koboSpan" id="kobo.166.1">0</span></strong></span><span class="koboSpan" id="kobo.167.1">); 
  glEnableVertexAttribArray( 
    static_cast&lt;GLuint&gt;(VertexAttribute::TexCoord)); 
  glVertexAttribPointer( 
    static_cast&lt;GLuint&gt;(VertexAttribute::TexCoord), 2, GL_FLOAT, 
    GL_FALSE, </span><span class="strong"><strong><span class="koboSpan" id="kobo.168.1">stride</span></strong></span><span class="koboSpan" id="kobo.169.1">, </span><span class="strong"><strong><span class="koboSpan" id="kobo.170.1">(void*)texCoordOffset</span></strong></span><span class="koboSpan" id="kobo.171.1">); 
  ... 
</span><span class="koboSpan" id="kobo.171.2">} 
</span></pre><p><span class="koboSpan" id="kobo.172.1">We now get to utilize the stride and offset parameters that were discussed previously! </span><span class="koboSpan" id="kobo.172.2">The stride is, of course, the full size of a </span><code class="literal"><span class="koboSpan" id="kobo.173.1">GL_Vertex</span></code><span class="koboSpan" id="kobo.174.1"> structure, while the offset to obtain texture coordinates is the size of the vertex position vector, because that is the amount by which the pointer needs to be offset.</span></p><p><span class="koboSpan" id="kobo.175.1">After the data is submitted to the buffer, we enable the vertex position attribute and provide its pointer with the </span><code class="literal"><span class="koboSpan" id="kobo.176.1">stride</span></code><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">The offset remains </span><code class="literal"><span class="koboSpan" id="kobo.178.1">0</span></code><span class="koboSpan" id="kobo.179.1">, because </span><code class="literal"><span class="koboSpan" id="kobo.180.1">Position</span></code><span class="koboSpan" id="kobo.181.1"> is the first attribute.</span></p><p><span class="koboSpan" id="kobo.182.1">We also need to enable the </span><code class="literal"><span class="koboSpan" id="kobo.183.1">TexCoord</span></code><span class="koboSpan" id="kobo.184.1"> attribute, because it will be passed to the shaders as well. </span><span class="koboSpan" id="kobo.184.2">Its pointer is set up similarly to that of position, except we have </span><code class="literal"><span class="koboSpan" id="kobo.185.1">2</span></code><span class="koboSpan" id="kobo.186.1"> floats instead of </span><code class="literal"><span class="koboSpan" id="kobo.187.1">3</span></code><span class="koboSpan" id="kobo.188.1">, and the offset now needs to be applied, so that the position data is skipped.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/><span class="koboSpan" id="kobo.189.1">Note</span></h3><p><span class="koboSpan" id="kobo.190.1">Note the </span><code class="literal"><span class="koboSpan" id="kobo.191.1">void*</span></code><span class="koboSpan" id="kobo.192.1"> cast for the last argument. </span><span class="koboSpan" id="kobo.192.2">This is because the offset actually takes a pointer, rather than a number of bytes. </span><span class="koboSpan" id="kobo.192.3">It is one of the leftover </span><span class="emphasis"><em><span class="koboSpan" id="kobo.193.1">legacy</span></em></span><span class="koboSpan" id="kobo.194.1"> details, and only means the number of bytes in newer versions.</span></p></div></div><p><span class="koboSpan" id="kobo.195.1">The final change to our C++ code pertains to updating the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">GL_Shader</span></code><span class="koboSpan" id="kobo.197.1"> class, in order to register the new attribute that is going to be passed in to the vertex shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.198.1">GL_Shader::GL_Shader(const std::string&amp; l_fileName) { 
  ... 
  </span><span class="koboSpan" id="kobo.198.2">glBindAttribLocation(m_program, 
    static_cast&lt;GLuint&gt;(VertexAttribute::Position), "position"); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.199.1">glBindAttribLocation(m_program, 
    static_cast&lt;GLuint&gt;(VertexAttribute::TexCoord), 
    "texCoordVert");</span></strong></span><span class="koboSpan" id="kobo.200.1"> 
  ... 
</span><span class="koboSpan" id="kobo.200.2">} 
</span></pre><p><span class="koboSpan" id="kobo.201.1">It simply establishes a name for our texture coordinate attribute, which is now </span><code class="literal"><span class="koboSpan" id="kobo.202.1">"texCoordVert"</span></code><span class="koboSpan" id="kobo.203.1">.</span></p></div><div class="section" title="Updating the shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec65"/><span class="koboSpan" id="kobo.204.1">Updating the shaders</span></h2></div></div></div><p><span class="koboSpan" id="kobo.205.1">The actual sampling of the texture takes place inside the fragment shader. </span><span class="koboSpan" id="kobo.205.2">However, as the data is actually received in the vertex shader first, let us see how it needs to be updated to cater to our needs:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.206.1">#version 450 
 
attribute vec3 position; 
</span><span class="strong"><strong><span class="koboSpan" id="kobo.207.1">attribute vec2 texCoordVert;</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.208.1">varying vec2 texCoord; // Pass to fragment shader.</span></strong></span><span class="koboSpan" id="kobo.209.1"> 
void main(){ 
  gl_Position = vec4(position, 1.0); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.210.1">texCoord = texCoordVert; // Pass to fragment shader. </span></strong></span><span class="koboSpan" id="kobo.211.1">
} 
</span></pre><p><span class="koboSpan" id="kobo.212.1">As you can see, the </span><code class="literal"><span class="koboSpan" id="kobo.213.1">texCoordVert</span></code><span class="koboSpan" id="kobo.214.1"> attribute is established here, along with a </span><code class="literal"><span class="koboSpan" id="kobo.215.1">varying</span></code><span class="koboSpan" id="kobo.216.1"> 2D vector named </span><code class="literal"><span class="koboSpan" id="kobo.217.1">texCoord</span></code><span class="koboSpan" id="kobo.218.1">. </span><span class="koboSpan" id="kobo.218.2">A varying type simply means that its data is going to be passed down the rendering pipeline and received by the next shader in line. </span><span class="koboSpan" id="kobo.218.3">In our case, </span><code class="literal"><span class="koboSpan" id="kobo.219.1">texCoord</span></code><span class="koboSpan" id="kobo.220.1"> is going to be accessible inside the fragment shader. </span><span class="koboSpan" id="kobo.220.2">Its value is set to the input attribute of </span><code class="literal"><span class="koboSpan" id="kobo.221.1">texCoordVert</span></code><span class="koboSpan" id="kobo.222.1">. </span><span class="koboSpan" id="kobo.222.2">Why? </span><span class="koboSpan" id="kobo.222.3">Because varying data received by any shader down the line is </span><span class="strong"><strong><span class="koboSpan" id="kobo.223.1">interpolated</span></strong></span><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">That's right. </span><span class="koboSpan" id="kobo.224.3">Take a look at the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.225.1"><img src="graphics/image_07_006.jpg" alt="Updating the shaders"/></span></div><p><span class="koboSpan" id="kobo.226.1">In order to accurately sample color information for each pixel of our geometry, we do not really need to do any math by ourselves. </span><span class="koboSpan" id="kobo.226.2">Interpolation, or weighted averaging, takes care of that for us. </span><span class="koboSpan" id="kobo.226.3">If one vertex has texture coordinates of, let's say </span><span class="strong"><strong><span class="koboSpan" id="kobo.227.1">(1,1)</span></strong></span><span class="koboSpan" id="kobo.228.1">, and the opposite vertex has the coordinates </span><span class="strong"><strong><span class="koboSpan" id="kobo.229.1">(0,0)</span></strong></span><span class="koboSpan" id="kobo.230.1">, the fragment shader executing on a pixel somewhere in between those vertices will receive the </span><span class="strong"><strong><span class="koboSpan" id="kobo.231.1">interpolated</span></strong></span><span class="koboSpan" id="kobo.232.1"> value of </span><span class="strong"><strong><span class="koboSpan" id="kobo.233.1">(0.5, 0.5)</span></strong></span><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">This makes coloring a pixel as easy as this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.235.1">#version 450 
</span><span class="strong"><strong><span class="koboSpan" id="kobo.236.1">uniform sampler2D texture; 
varying vec2 texCoord; // Receiving it from vertex shader.</span></strong></span><span class="koboSpan" id="kobo.237.1"> 
 
void main(){ 
  gl_FragColor = </span><span class="strong"><strong><span class="koboSpan" id="kobo.238.1">texture2D</span></strong></span><span class="koboSpan" id="kobo.239.1">(texture, texCoord); 
} 
</span></pre><p><span class="koboSpan" id="kobo.240.1">First, note the </span><code class="literal"><span class="koboSpan" id="kobo.241.1">uniform</span></code><span class="koboSpan" id="kobo.242.1"> variable of type </span><code class="literal"><span class="koboSpan" id="kobo.243.1">sampler2D</span></code><span class="koboSpan" id="kobo.244.1">, called </span><code class="literal"><span class="koboSpan" id="kobo.245.1">texture</span></code><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">We do not need to manually pass this into our shaders as it is done behind the scenes. </span><span class="koboSpan" id="kobo.246.3">It simply provides access to the data of the current texture that it is bound to. </span><span class="koboSpan" id="kobo.246.4">Next, we set up the varying variable </span><code class="literal"><span class="koboSpan" id="kobo.247.1">texCoord</span></code><span class="koboSpan" id="kobo.248.1">, which completes the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.249.1">piping</span></em></span><span class="koboSpan" id="kobo.250.1"> of data from the vertex shader to the fragment shader. </span><span class="koboSpan" id="kobo.250.2">The fragment color is then set to a </span><code class="literal"><span class="koboSpan" id="kobo.251.1">vec4</span></code><span class="koboSpan" id="kobo.252.1">, which gets returned from the </span><code class="literal"><span class="koboSpan" id="kobo.253.1">texture2D()</span></code><span class="koboSpan" id="kobo.254.1"> function that takes in the texture received by the fragment shader, as well as the coordinates we want to sample. </span><span class="koboSpan" id="kobo.254.2">Since the </span><code class="literal"><span class="koboSpan" id="kobo.255.1">vec4</span></code><span class="koboSpan" id="kobo.256.1"> that gets returned represents the color of the pixel, that is all that it takes to texture geometry!</span></p></div><div class="section" title="Using a texture"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec66"/><span class="koboSpan" id="kobo.257.1">Using a texture</span></h2></div></div></div><p><span class="koboSpan" id="kobo.258.1">Applying the texture to our geometry is quite simple at this point. </span><span class="koboSpan" id="kobo.258.2">First, the </span><code class="literal"><span class="koboSpan" id="kobo.259.1">GL_Texture</span></code><span class="koboSpan" id="kobo.260.1"> class needs to be added as a data member to the </span><code class="literal"><span class="koboSpan" id="kobo.261.1">Game</span></code><span class="koboSpan" id="kobo.262.1"> object. </span><span class="koboSpan" id="kobo.262.2">We can then proceed to set everything else up as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.263.1">Game::Game() ... </span><span class="koboSpan" id="kobo.263.2">{ 
  ... 
  </span><span class="koboSpan" id="kobo.263.3">GL_Vertex vertices[] = { 
    //           |---POSITION----| |TEXTURE| 
    //            X     Y    Z      X  Y 
    GL_Vertex({ -0.5, -0.5, 0.5 }, { 0, 0 }), // 0 
    GL_Vertex({ -0.5, 0.5, 0.5 }, { 0, 1 }), // 1 
    GL_Vertex({ 0.5, 0.5, 0.5 }, { 1, 1 }), // 2 
  }; 
  m_texture = std::make_unique&lt;GL_Texture&gt;( 
    Utils::GetWorkingDirectory() + "GL/brick.jpg"); 
  ... 
</span><span class="koboSpan" id="kobo.263.4">} 
 
void Game::Render() { 
  m_window.BeginDraw(); 
  // Render here. 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.264.1">m_texture-&gt;Bind(0);</span></strong></span><span class="koboSpan" id="kobo.265.1"> 
  m_shader-&gt;Bind(); 
  m_model-&gt;Draw(); 
  m_window.EndDraw(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.266.1">The </span><code class="literal"><span class="koboSpan" id="kobo.267.1">GL_Vertex</span></code><span class="koboSpan" id="kobo.268.1"> objects now take an additional argument, which represents the texture coordinates of the vertex. </span><span class="koboSpan" id="kobo.268.2">We also load the brick texture in the constructor, which is then bound to in the </span><code class="literal"><span class="koboSpan" id="kobo.269.1">Render()</span></code><span class="koboSpan" id="kobo.270.1"> method, right before the shader. </span><span class="koboSpan" id="kobo.270.2">When our model is rendered, it should look as follows:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.271.1"><img src="graphics/image_07_007.jpg" alt="Using a texture"/></span></div><p><span class="koboSpan" id="kobo.272.1">We now have a motionless model with a texture applied. </span><span class="koboSpan" id="kobo.272.2">Still not very exciting, but we are getting there!</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Applying transformations"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/><span class="koboSpan" id="kobo.1.1">Applying transformations</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Moving, rotating, and otherwise manipulating vertex data may seem quite straight forward. </span><span class="koboSpan" id="kobo.2.2">One may even be tempted to simply update the vertex position information and simply resubmit that data back to the VBO. </span><span class="koboSpan" id="kobo.2.3">While things may have been done that way for a while in the past, there are much more efficient, albeit more math-intensive ways of performing this task. </span><span class="koboSpan" id="kobo.2.4">Displacing vertices is now done in the vertex shader by simply multiplying the vertex positions by something called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">matrix</span></strong></span><span class="koboSpan" id="kobo.4.1">.</span></p><div class="section" title="Matrix basics"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec67"/><span class="koboSpan" id="kobo.5.1">Matrix basics</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">Matrices are extremely useful in graphics programming, because they can represent any kind of rotation, scale, or displacement manipulation that can be applied to a vector. </span><span class="koboSpan" id="kobo.6.2">There are many different types of matrices, but they are all just blocks of information that look similar to this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.7.1"><img src="graphics/image_07_008.jpg" alt="Matrix basics"/></span></div><p><span class="koboSpan" id="kobo.8.1">This particular matrix is a 4x4 identity matrix, but a variety of differently sized matrices exist, such as 3x3, 2x3, 3x2, and so on. </span><span class="koboSpan" id="kobo.8.2">There are rules when it comes to adding, subtracting, multiplying, or dividing them. </span><span class="koboSpan" id="kobo.8.3">We are not really going to get into that as it is beyond the scope of this chapter. </span><span class="koboSpan" id="kobo.8.4">The nice thing is that the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">glm</span></code><span class="koboSpan" id="kobo.10.1"> library abstracts all of this away for us, so it is not absolutely necessary to know much about this for now. </span><span class="koboSpan" id="kobo.10.2">A thing to take away from this is that positional vectors can be transformed when added to or multiplied by matrices.</span></p></div><div class="section" title="The world space"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec68"/><span class="koboSpan" id="kobo.11.1">The world space</span></h2></div></div></div><p><span class="koboSpan" id="kobo.12.1">Up until this point, we have been working with vertex positions that are specified in the normalized device coordinate space. </span><span class="koboSpan" id="kobo.12.2">This means that each vertex coordinate is actually relative to the center of the screen. </span><span class="koboSpan" id="kobo.12.3">In order to properly deal with transformations; however, we want to treat our geometry as being relative to an origin point that falls within the </span><span class="strong"><strong><span class="koboSpan" id="kobo.13.1">model space</span></strong></span><span class="koboSpan" id="kobo.14.1">, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.15.1"><img src="graphics/image_07_009.jpg" alt="The world space"/></span></div><p><span class="koboSpan" id="kobo.16.1">If a model has an origin, it can also have a global position within our world, where its origin is relative to some arbitrary point within the game world we have constructed. </span><span class="koboSpan" id="kobo.16.2">This global position, as well as some other attributes, such as the scale and rotation of the object, can be represented by a matrix. </span><span class="koboSpan" id="kobo.16.3">Applying these attributes to the vertex coordinates that are in model space, which is exactly what happens when they are multiplied by the </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">model matrix</span></strong></span><span class="koboSpan" id="kobo.18.1">, allows us to bring those coordinates into what is known as </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">world space</span></strong></span><span class="koboSpan" id="kobo.20.1">, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.21.1"><img src="graphics/image_07_010.jpg" alt="The world space"/></span></div><p><span class="koboSpan" id="kobo.22.1">This transformation simply means that the vertices are now relative to the world's origin, rather than the model origin, allowing us to accurately represent models in our own coordinate system before drawing them on screen.</span></p></div><div class="section" title="The transform class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/><span class="koboSpan" id="kobo.23.1">The transform class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.24.1">Before any transformations can be applied, they should be properly grouped together and represented by a single data structure. </span><span class="koboSpan" id="kobo.24.2">The </span><code class="literal"><span class="koboSpan" id="kobo.25.1">GL_Transform</span></code><span class="koboSpan" id="kobo.26.1"> class is going to do exactly that for us:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.27.1">#include &lt;glm.hpp&gt; 
#include &lt;gtx/transform.hpp&gt;</span></strong></span><span class="koboSpan" id="kobo.28.1"> 
class GL_Transform { 
public: 
  GL_Transform(const glm::vec3&amp; l_pos = { 0.f, 0.f, 0.f }, 
    const glm::vec3&amp; l_rot = { 0.f, 0.f, 0.f }, 
    const glm::vec3&amp; l_scale = { 1.f, 1.f, 1.f }); 
 
  glm::vec3 GetPosition()const; 
  glm::vec3 GetRotation()const; 
  glm::vec3 GetScale()const; 
 
  void SetPosition(const glm::vec3&amp; l_pos); 
  void SetRotation(const glm::vec3&amp; l_rot); 
  void SetScale(const glm::vec3&amp; l_scale); 
 
  glm::mat4 GetModelMatrix(); 
private: 
  void RecalculateMatrix(); 
  glm::vec3 m_position; 
  glm::vec3 m_rotation; 
  glm::vec3 m_scale; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.29.1">First, note the included headers on top. </span><span class="koboSpan" id="kobo.29.2">These are necessary for the data types and transformation functions that are going to be used in this class. </span><span class="koboSpan" id="kobo.29.3">Outside of that, we have three vectors that are going to represent the model's position, rotation, and scale, which are going to be used for calculating the model matrix that transforms vertices into world coordinates.</span></p><div class="section" title="Implementing the transform class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec12"/><span class="koboSpan" id="kobo.30.1">Implementing the transform class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.31.1">The constructor simply takes in the appropriate arguments and sets up some data members using the initializer list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">GL_Transform::GL_Transform(const glm::vec3&amp; l_pos, 
  const glm::vec3&amp; l_rot, const glm::vec3&amp; l_scale) 
  : m_position(l_pos), m_rotation(l_rot), m_scale(l_scale) 
{} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">The meat of this class is the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">GetModelMatrix()</span></code><span class="koboSpan" id="kobo.35.1"> method, as it deals with all the necessary math:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.36.1">glm::mat4 GL_Transform::GetModelMatrix() { 
  glm::mat4 matrix_pos = glm::translate(m_position); 
  glm::mat4 matrix_scale = glm::scale(m_scale); 
  // Represent each stored rotation as a different matrix, because 
  // we store angles. 
  </span><span class="koboSpan" id="kobo.36.2">//          x  y  z 
  glm::mat4 matrix_rotX = glm::rotate(m_rotation.x, 
    glm::vec3(1, 0, 0)); 
  glm::mat4 matrix_rotY = glm::rotate(m_rotation.y, 
    glm::vec3(0, 1, 0)); 
  glm::mat4 matrix_rotZ = glm::rotate(m_rotation.z, 
    glm::vec3(0, 0, 1)); 
  // Create a rotation matrix. 
  </span><span class="koboSpan" id="kobo.36.3">// Multiply in reverse order it needs to be applied. 
  </span><span class="koboSpan" id="kobo.36.4">glm::mat4 matrix_rotation = matrix_rotZ*matrix_rotY*matrix_rotX; 
  // Apply transforms in reverse order they need to be applied in. 
  </span><span class="koboSpan" id="kobo.36.5">return matrix_pos * matrix_rotation * matrix_scale; 
} 
</span></pre><p><span class="koboSpan" id="kobo.37.1">The model matrix is going to be a result of many other matrices being multiplied together, thus making it contain all of the necessary transformation information. </span><span class="koboSpan" id="kobo.37.2">We begin by creating what is known as a </span><span class="strong"><strong><span class="koboSpan" id="kobo.38.1">translation matrix</span></strong></span><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">Calling </span><code class="literal"><span class="koboSpan" id="kobo.40.1">glm::translate</span></code><span class="koboSpan" id="kobo.41.1"> creates one for us, with the position information of </span><code class="literal"><span class="koboSpan" id="kobo.42.1">m_position</span></code><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">It is used to bring the positions of our vertices into world space.</span></p><p><span class="koboSpan" id="kobo.44.1">We then create a </span><span class="strong"><strong><span class="koboSpan" id="kobo.45.1">scale matrix</span></strong></span><span class="koboSpan" id="kobo.46.1">, which is responsible for representing scaling or shrinking of a model. </span><span class="koboSpan" id="kobo.46.2">For example, if a model should be drawn as twice as big as it's stored on the GPU, the scale matrix will be used to adjust the positions of all vertices to make it look that way. </span><span class="koboSpan" id="kobo.46.3">Using </span><code class="literal"><span class="koboSpan" id="kobo.47.1">glm::scale</span></code><span class="koboSpan" id="kobo.48.1"> and passing in the scale vector as the argument will construct one for us.</span></p><p><span class="koboSpan" id="kobo.49.1">The final type of matrix we need is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">rotation matrix</span></strong></span><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">It obviously represents different rotation values of an object, thus displacing all the vertices around an origin point. </span><span class="koboSpan" id="kobo.51.3">This one, however, is not quite so straightforward due to the fact that we are storing rotation information as a vector of </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">degrees</span></strong></span><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">Because of that, matrices of each axis need to be created using the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">glm::rotate</span></code><span class="koboSpan" id="kobo.55.1"> function, which takes the degree of rotation, as well as a </span><span class="strong"><strong><span class="koboSpan" id="kobo.56.1">directional vector</span></strong></span><span class="koboSpan" id="kobo.57.1">, representing the axis around which the rotation is desired. </span><span class="koboSpan" id="kobo.57.2">It simply means setting a value of </span><code class="literal"><span class="koboSpan" id="kobo.58.1">1</span></code><span class="koboSpan" id="kobo.59.1"> for the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.60.1">x</span></em></span><span class="koboSpan" id="kobo.61.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.62.1">y</span></em></span><span class="koboSpan" id="kobo.63.1">, or </span><span class="emphasis"><em><span class="koboSpan" id="kobo.64.1">z</span></em></span><span class="koboSpan" id="kobo.65.1"> component, depending on which axis we are dealing with. </span><span class="koboSpan" id="kobo.65.2">The final rotational matrix is then calculated by multiplying all three previous matrices together. </span><span class="koboSpan" id="kobo.65.3">Using a different multiplication order will produce different results. </span><span class="koboSpan" id="kobo.65.4">Generally, a rule of thumb is to multiply all matrices in reverse order of application.</span></p><p><span class="koboSpan" id="kobo.66.1">Finally, we can calculate the model matrix by multiplying all previous matrices together like so:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.67.1"><img src="graphics/image_07_011.jpg" alt="Implementing the transform class"/></span></div><p><span class="koboSpan" id="kobo.68.1">The resulting model matrix is then returned.</span></p><p><span class="koboSpan" id="kobo.69.1">The rest of this class is fairly straightforward, as there is nothing else except setters and getters left:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.70.1">glm::vec3 GL_Transform::GetPosition() const { return m_position; } 
glm::vec3 GL_Transform::GetRotation() const { return m_rotation; } 
glm::vec3 GL_Transform::GetScale() const { return m_scale; } 
 
void GL_Transform::SetPosition(const glm::vec3&amp; l_pos) 
{ m_position = l_pos; } 
void GL_Transform::SetRotation(const glm::vec3&amp; l_rot) 
{ m_rotation = l_rot; } 
void GL_Transform::SetScale(const glm::vec3&amp; l_scale) 
{ m_scale = l_scale; } 
</span></pre></div></div><div class="section" title="Updating the shader class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/><span class="koboSpan" id="kobo.71.1">Updating the shader class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.72.1">Once again, we are going to be using the shader class to submit the necessary matrix information to the vertex shader, where it will be used. </span><span class="koboSpan" id="kobo.72.2">The reason this is done inside the vertex shader is because the GPU is optimized for operations like this. </span><span class="koboSpan" id="kobo.72.3">Let us take a look at what we need to change:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.73.1">enum class UniformType{ Transform, COUNT };</span></strong></span><span class="koboSpan" id="kobo.74.1"> 
 
class GL_Shader { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.74.2">void Update(GL_Transform&amp; l_transform); 
  ... 
</span><span class="koboSpan" id="kobo.74.3">private: 
  ... 
  </span><span class="koboSpan" id="kobo.74.4">GLuint m_uniform[static_cast&lt;unsigned int&gt;(UniformType::COUNT)]; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.75.1">First, note a new enumeration that we have established. </span><span class="koboSpan" id="kobo.75.2">It enumerates all the uniform variable types that our shaders need, which, for now, consists of only one.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/><span class="koboSpan" id="kobo.76.1">Note</span></h3><p><span class="koboSpan" id="kobo.77.1">A uniform performs a different task from the usual shader attributes or varying variables. </span><span class="koboSpan" id="kobo.77.2">Attributes are </span><span class="emphasis"><em><span class="koboSpan" id="kobo.78.1">filled in</span></em></span><span class="koboSpan" id="kobo.79.1"> by OpenGL behind the scenes, using data from the VBO. </span><span class="koboSpan" id="kobo.79.2">Varying shader variables are passed between shaders. </span><span class="koboSpan" id="kobo.79.3">A uniform variable is actually passed into the shader by our C++ code, which is why we need to treat it differently.</span></p></div></div><p><span class="koboSpan" id="kobo.80.1">The </span><code class="literal"><span class="koboSpan" id="kobo.81.1">GL_Shader</span></code><span class="koboSpan" id="kobo.82.1"> class now also needs an </span><code class="literal"><span class="koboSpan" id="kobo.83.1">Update()</span></code><span class="koboSpan" id="kobo.84.1"> method, which is going to take in a reference to the </span><code class="literal"><span class="koboSpan" id="kobo.85.1">GL_Transform</span></code><span class="koboSpan" id="kobo.86.1"> class and use it to pass the model matrix to the vertex shader. </span><span class="koboSpan" id="kobo.86.2">Lastly, we need to store identifiers that are used to locate uniform variables within shaders, so that they can be used. </span><span class="koboSpan" id="kobo.86.3">The </span><code class="literal"><span class="koboSpan" id="kobo.87.1">m_uniform </span></code><span class="koboSpan" id="kobo.88.1">data member exists for that exact purpose.</span></p><p><span class="koboSpan" id="kobo.89.1">Let's see how a uniform variable location can be obtained and stored:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">GL_Shader::GL_Shader(const std::string&amp; l_fileName) { 
  ... 
  </span><span class="koboSpan" id="kobo.90.2">m_uniform[static_cast&lt;unsigned int&gt;(UniformType::Transform)] = 
    glGetUniformLocation(m_program, "transform"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.91.1">As you can see, OpenGL provides a nice function for that, called </span><code class="literal"><span class="koboSpan" id="kobo.92.1">glGetUniformLocation</span></code><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">It takes an identifier of the program we are using, as well as the name of the uniform variable inside the shader, which is </span><code class="literal"><span class="koboSpan" id="kobo.94.1">"transform"</span></code><span class="koboSpan" id="kobo.95.1">.</span></p><p><span class="koboSpan" id="kobo.96.1">Setting the value of a uniform variable also comes down to a single function call:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.97.1">void GL_Shader::Update(GL_Transform&amp; l_transform) { 
  glm::mat4 modelMatrix = l_transform.GetModelMatrix(); 
   
  glUniformMatrix4fv(static_cast&lt;GLint&gt;( 
    m_uniform[static_cast&lt;unsigned int&gt;(UniformType::Transform)]), 
    1, GL_FALSE, &amp;modelMatrix[0][0]); 
} 
</span></pre><p><span class="koboSpan" id="kobo.98.1">First, we obtain the model matrix from the transform class. </span><span class="koboSpan" id="kobo.98.2">The </span><code class="literal"><span class="koboSpan" id="kobo.99.1">glUniform</span></code><span class="koboSpan" id="kobo.100.1"> function is then called. </span><span class="koboSpan" id="kobo.100.2">It has a suffix of the exact data type we are submitting, which, in this case, is a 4x4 matrix of floats. </span><span class="koboSpan" id="kobo.100.3">The uniform ID we stored earlier is used as the first argument. </span><span class="koboSpan" id="kobo.100.4">The amount of data being submitted is the second argument, which in this case is only </span><code class="literal"><span class="koboSpan" id="kobo.101.1">1</span></code><span class="koboSpan" id="kobo.102.1">, as one matrix is being submitted. </span><span class="koboSpan" id="kobo.102.2">The third argument is a flag that lets us transpose the matrix. </span><span class="koboSpan" id="kobo.102.3">We do not need to do that, so </span><code class="literal"><span class="koboSpan" id="kobo.103.1">GL_FALSE</span></code><span class="koboSpan" id="kobo.104.1"> is passed in. </span><span class="koboSpan" id="kobo.104.2">Finally, a pointer to the first element of the matrix is passed as the last argument. </span><span class="koboSpan" id="kobo.104.3">OpenGL knows exactly how big the matrix is, as we are calling the appropriate function, which allows it to read the entire matrix.</span></p><p><span class="koboSpan" id="kobo.105.1">Lastly, we need to modify the vertex shader in order to actually perform the transformation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.106.1">#version 450 
 
attribute vec3 position; 
attribute vec2 texCoordVert; 
varying vec2 texCoord; // Pass to fragment shader. 
 
</span><span class="strong"><strong><span class="koboSpan" id="kobo.107.1">uniform mat4 transform; // Passed in by the shader class.</span></strong></span><span class="koboSpan" id="kobo.108.1"> 
 
void main(){ 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.109.1"> gl_Position = transform * vec4(position, 1.0);</span></strong></span><span class="koboSpan" id="kobo.110.1"> 
  texCoord = texCoordVert; // Pass to fragment shader. 
</span><span class="koboSpan" id="kobo.110.2">} 
</span></pre><p><span class="koboSpan" id="kobo.111.1">Note the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">uniform</span></code><span class="koboSpan" id="kobo.113.1"> of type </span><code class="literal"><span class="koboSpan" id="kobo.114.1">mat4</span></code><span class="koboSpan" id="kobo.115.1"> being added. </span><span class="koboSpan" id="kobo.115.2">We simply need to multiply it by the position in the main function, which gives us our transformed vertex position.</span></p></div><div class="section" title="Manipulating the triangle"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/><span class="koboSpan" id="kobo.116.1">Manipulating the triangle</span></h2></div></div></div><p><span class="koboSpan" id="kobo.117.1">Once again, all we have left to do in order to apply the code we have written is add it to the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Game</span></code><span class="koboSpan" id="kobo.119.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.120.1">class Game{ 
  ... 
</span><span class="koboSpan" id="kobo.120.2">private: 
  ... 
  </span><span class="koboSpan" id="kobo.120.3">GL_Transform m_transform; 
  ... 
</span><span class="koboSpan" id="kobo.120.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.121.1">It really does not need any more setting up than that. </span><span class="koboSpan" id="kobo.121.2">We can jump straight to manipulation of the transform's properties, by editing the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">Update()</span></code><span class="koboSpan" id="kobo.123.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.124.1">void Game::Update() { 
  ... 
  </span><span class="koboSpan" id="kobo.124.2">auto rotation = m_transform.GetRotation(); 
  rotation.x += 0.001f; 
  rotation.y += 0.0002f; 
  rotation.z += 0.002f; 
  if (rotation.x &gt;= 360.f) { rotation.x = 0.f; } 
  if (rotation.y &gt;= 360.f) { rotation.y = 0.f; } 
  if (rotation.z &gt;= 360.f) { rotation.z = 0.f; } 
  m_transform.SetRotation(rotation); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.125.1">m_shader-&gt;Update(m_transform);</span></strong></span><span class="koboSpan" id="kobo.126.1"> 
} 
</span></pre><p><span class="koboSpan" id="kobo.127.1">In this case, we are simply playing around with rotations along all axes. </span><span class="koboSpan" id="kobo.127.2">After making those modifications, it is important to pass the transform object to the </span><code class="literal"><span class="koboSpan" id="kobo.128.1">GL_ShaderUpdate()</span></code><span class="koboSpan" id="kobo.129.1"> method, so that the vertices can be properly transformed, giving us this resulting rotation:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.130.1"><img src="graphics/image_07_012.jpg" alt="Manipulating the triangle"/></span></div><p><span class="koboSpan" id="kobo.131.1">Now we are getting somewhere! </span><span class="koboSpan" id="kobo.131.2">Still, we have no interaction with the scene. </span><span class="koboSpan" id="kobo.131.3">This whole time we are just sitting still while the geometry just spins around. </span><span class="koboSpan" id="kobo.131.4">At best, this is just a very elaborate screensaver. </span><span class="koboSpan" id="kobo.131.5">Let's actually implement something that will give us some </span><span class="emphasis"><em><span class="koboSpan" id="kobo.132.1">mobility</span></em></span><span class="koboSpan" id="kobo.133.1">.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Creating a camera"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/><span class="koboSpan" id="kobo.1.1">Creating a camera</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">OpenGL, unlike SFML, does not offer any means of actually moving around the view or the camera. </span><span class="koboSpan" id="kobo.2.2">While this may seem odd at first, that is mainly because there is no camera or view to move around. </span><span class="koboSpan" id="kobo.2.3">Yes, you heard that right. </span><span class="koboSpan" id="kobo.2.4">No camera, no views, just vertex data, shaders, and raw math to the rescue. </span><span class="koboSpan" id="kobo.2.5">How? </span><span class="koboSpan" id="kobo.2.6">Let's take a look!</span></p><div class="section" title="View projection essentials"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/><span class="koboSpan" id="kobo.3.1">View projection essentials</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">All of the rendering and programming trickery that lots of libraries abstract away is exactly that - tricks. </span><span class="koboSpan" id="kobo.4.2">When it comes to moving around the game world, there is no real </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">camera</span></em></span><span class="koboSpan" id="kobo.6.1"> that conveniently films the right sides of geometry to be rendered. </span><span class="koboSpan" id="kobo.6.2">The camera is just an illusion, used to abstract away concepts that are not intuitive. </span><span class="koboSpan" id="kobo.6.3">Moving around a game world involves nothing else except additional matrix math that is performed on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">vertices themselves</span></strong></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">The act of rotating the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">camera</span></em></span><span class="koboSpan" id="kobo.10.1"> around the scene simply comes down to the exact opposite of that: rotating the scene around a point in space that is referred to as the camera. </span><span class="koboSpan" id="kobo.10.2">Once again, we are going to be transforming our vertices to be relative to yet another point of origin, and this time, it is the camera itself. </span><span class="koboSpan" id="kobo.10.3">Consider the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_07_013.jpg" alt="View projection essentials"/></span></div><p><span class="koboSpan" id="kobo.12.1">In order to implement the camera class and be able to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">move around</span></em></span><span class="koboSpan" id="kobo.14.1"> the world, we need to know a few basics. </span><span class="koboSpan" id="kobo.14.2">First of all, we have to decide how wide the view angle of the camera should be. </span><span class="koboSpan" id="kobo.14.3">This affects how much we can actually see. </span><span class="koboSpan" id="kobo.14.4">The other important detail is correctly setting up the </span><span class="strong"><strong><span class="koboSpan" id="kobo.15.1">view frustum</span></strong></span><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">Think of it as a pyramid shaped piece of geometry that defines the range of the camera's view. </span><span class="koboSpan" id="kobo.16.3">It determines how close certain things can be until they are no longer seen, as well as what's the maximum distance of an object from the camera until it's no longer rendered.</span></p><p><span class="koboSpan" id="kobo.17.1">The aspect ratio of our window, as well as the field of view, near/far distances of the view frustum, and the position of the camera all add up to a total of two matrices we are going to calculate: the </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">view matrix</span></strong></span><span class="koboSpan" id="kobo.19.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.20.1">projection matrix</span></strong></span><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">The former deals with positioning vertices relative to the camera's position, while the latter adjusts and warps them, which depends on how close or far away they are from the view frustum, the field of view, and other attributes.</span></p><p><span class="koboSpan" id="kobo.22.1">There are mainly two projection types we can work with: </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">perspective</span></strong></span><span class="koboSpan" id="kobo.24.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">orthographic</span></strong></span><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">The perspective projection offers a realistic result where objects can appear to be further away from the camera, while orthographic projection is more of a fixed depth feel, making objects look the same size regardless of their distances. </span><span class="koboSpan" id="kobo.26.3">We are going to be using the perspective projection for our purposes.</span></p></div><div class="section" title="The camera class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec73"/><span class="koboSpan" id="kobo.27.1">The camera class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.28.1">With all of this information covered, we are finally ready for the smoke and mirrors that is the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">GL_Camera</span></code><span class="koboSpan" id="kobo.30.1"> class. </span><span class="koboSpan" id="kobo.30.2">Let us see what it takes in order to manoeuvre around our world:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">class GL_Camera { 
public: 
  GL_Camera(const glm::vec3&amp; l_pos, float l_fieldOfView, 
    float l_aspectRatio, float l_frustumNear, float l_frustumFar); 
 
  glm::mat4 GetViewProjectionMatrix(); 
private: 
  void RecalculatePerspective(); 
 
  float m_fov; 
  float m_aspect; 
  float m_frustumNear; 
  float m_frustumFar; 
 
  glm::vec3 m_position; 
  glm::vec3 m_forwardDir; 
  glm::vec3 m_upDir; 
 
  glm::mat4 m_perspectiveMatrix; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.32.1">As you can see, we are storing all of the covered details, as well as a couple of new ones. </span><span class="koboSpan" id="kobo.32.2">Along with the field of view angle, the aspect ratio, and the near and far frustum values, we also need to keep around the position, a forward direction vector, and the up direction vector. </span><span class="koboSpan" id="kobo.32.3">The </span><code class="literal"><span class="koboSpan" id="kobo.33.1">m_forwardDir</span></code><span class="koboSpan" id="kobo.34.1"> is a normalized directional vector that represents which way the camera is looking. </span><span class="koboSpan" id="kobo.34.2">The </span><code class="literal"><span class="koboSpan" id="kobo.35.1">m_upDir</span></code><span class="koboSpan" id="kobo.36.1"> is also a normalized directional vector, but it simply stores the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.37.1">up</span></em></span><span class="koboSpan" id="kobo.38.1"> direction. </span><span class="koboSpan" id="kobo.38.2">This will all start to make sense soon.</span></p><div class="section" title="Implementing the camera class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec13"/><span class="koboSpan" id="kobo.39.1">Implementing the camera class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.40.1">Let us see what the constructor of this class looks like:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">GL_Camera::GL_Camera(const glm::vec3&amp; l_pos, float l_fieldOfView, 
  float l_aspectRatio, float l_frustumNear, float l_frustumFar) 
  : m_position(l_pos), m_fov(l_fieldOfView), 
  m_aspect(l_aspectRatio), m_frustumNear(l_frustumNear), 
  m_frustumFar(l_frustumFar) 
{ 
  RecalculatePerspective(); 
  m_forwardDir = glm::vec3(0.f, 0.f, 1.f); 
  m_upDir = glm::vec3(0.f, 1.f, 0.f); 
} 
</span></pre><p><span class="koboSpan" id="kobo.42.1">Outside of initializing our data members, the constructor has three tasks. </span><span class="koboSpan" id="kobo.42.2">It recalculates the perspective matrix, which only needs to be done once unless the window is resized, and it sets up both the forward direction, and the up direction. </span><span class="koboSpan" id="kobo.42.3">The camera starts out looking towards the positive </span><span class="emphasis"><em><span class="koboSpan" id="kobo.43.1">Z</span></em></span><span class="koboSpan" id="kobo.44.1"> axis, which is literally </span><span class="emphasis"><em><span class="koboSpan" id="kobo.45.1">towards</span></em></span><span class="koboSpan" id="kobo.46.1"> the screen, if you imagine it in those terms. </span><span class="koboSpan" id="kobo.46.2">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">up</span></em></span><span class="koboSpan" id="kobo.48.1"> direction is the positive Y axis.</span></p><p><span class="koboSpan" id="kobo.49.1">Calculating the perspective matrix is quite simple, thanks to the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">glm</span></code><span class="koboSpan" id="kobo.51.1"> library:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">void GL_Camera::RecalculatePerspective() { 
  m_perspectiveMatrix = glm::perspective(m_fov, m_aspect, 
    m_frustumNear, m_frustumFar); 
} 
</span></pre><p><span class="koboSpan" id="kobo.53.1">Our matrix is constructed by the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">glm::perspective</span></code><span class="koboSpan" id="kobo.55.1"> function, which takes in the field of view, the aspect ratio, and both frustum distances.</span></p><p><span class="koboSpan" id="kobo.56.1">Finally, we can obtain the </span><span class="strong"><strong><span class="koboSpan" id="kobo.57.1">view projection matrix</span></strong></span><span class="koboSpan" id="kobo.58.1">, which is simply a combination of the view and projection matrix:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.59.1">glm::mat4 GL_Camera::GetViewProjectionMatrix() { 
  glm::mat4 viewMatrix = glm::lookAt(m_position, 
    m_position + m_forwardDir, m_upDir); 
  return m_perspectiveMatrix * viewMatrix; 
} 
</span></pre><p><span class="koboSpan" id="kobo.60.1">We begin by calculating the view matrix, using the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">glm::lookAt</span></code><span class="koboSpan" id="kobo.62.1"> function. </span><span class="koboSpan" id="kobo.62.2">It takes in the position of the camera, the point the camera is looking at, and the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.63.1">up</span></em></span><span class="koboSpan" id="kobo.64.1"> direction. </span><span class="koboSpan" id="kobo.64.2">Afterwards, the multiplication of our perspective matrix and the view matrix results in obtaining the view projection matrix, which is returned for later use.</span></p></div></div><div class="section" title="Updating the rest of the code"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec74"/><span class="koboSpan" id="kobo.65.1">Updating the rest of the code</span></h2></div></div></div><p><span class="koboSpan" id="kobo.66.1">Because our geometry needs to, once again, be transformed relative to yet another origin, we need to update the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">GL_Shader</span></code><span class="koboSpan" id="kobo.68.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.69.1">void GL_Shader::Update(GL_Transform&amp; l_transform, 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.70.1"> GL_Camera&amp; l_camera</span></strong></span><span class="koboSpan" id="kobo.71.1">) 
{ 
  glm::mat4 modelMatrix = l_transform.GetModelMatrix(); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.72.1">glm::mat4 viewProjMatrix = l_camera.GetViewProjectionMatrix();</span></strong></span>
  
  <span class="strong"><strong><span class="koboSpan" id="kobo.73.1">glm::mat4 modelViewMatrix = viewProjMatrix * modelMatrix;</span></strong></span><span class="koboSpan" id="kobo.74.1"> 
  glUniformMatrix4fv(static_cast&lt;GLint&gt;( 
    m_uniform[static_cast&lt;unsigned int&gt;(UniformType::Transform)]), 
    1, GL_FALSE, </span><span class="strong"><strong><span class="koboSpan" id="kobo.75.1">&amp;modelViewMatrix[0][0]</span></strong></span><span class="koboSpan" id="kobo.76.1">); 
} 
</span></pre><p><span class="koboSpan" id="kobo.77.1">Because the vertex shader is already multiplying its position by a transform, we can simply change which matrix it uses inside the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">Update()</span></code><span class="koboSpan" id="kobo.79.1"> method. </span><span class="koboSpan" id="kobo.79.2">After the model matrix is obtained, we also grab the view projection matrix and multiply the two together. </span><span class="koboSpan" id="kobo.79.3">The resulting </span><span class="strong"><strong><span class="koboSpan" id="kobo.80.1">model view matrix</span></strong></span><span class="koboSpan" id="kobo.81.1"> is then passed down to the vertex shader.</span></p><p><span class="koboSpan" id="kobo.82.1">Finally, the camera needs to be created inside the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">Game</span></code><span class="koboSpan" id="kobo.84.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.85.1">class Game{ 
  ... 
</span><span class="koboSpan" id="kobo.85.2">private: 
  ... 
  </span><span class="koboSpan" id="kobo.85.3">std::unique_ptr&lt;GL_Camera&gt; m_camera; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.86.1">It also needs to be set up with the appropriate information:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.87.1">Game::Game() ... </span><span class="koboSpan" id="kobo.87.2">{ 
  ... 
  </span><span class="koboSpan" id="kobo.87.3">float aspectRatio = 
    static_cast&lt;float&gt;(m_window.GetWindowSize().x) / 
    static_cast&lt;float&gt;(m_window.GetWindowSize().y); 
  float frustum_near = 1.f; 
  float frustum_far = 100.f; 
 
  m_camera = std::make_unique&lt;GL_Camera&gt;( 
    glm::vec3(0.f, 0.f, -5.f), 70.f, aspectRatio, 
    frustum_near, frustum_far); 
} 
</span></pre><p><span class="koboSpan" id="kobo.88.1">We begin by calculating the window's aspect ratio, which is its width divided by its height. </span><span class="koboSpan" id="kobo.88.2">After the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">frustum_near</span></code><span class="koboSpan" id="kobo.90.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.91.1">frustum_far</span></code><span class="koboSpan" id="kobo.92.1"> values are set up, they get passed in to the camera's constructor, along with its initial position, the field of view angle, and the aspect ratio of the window.</span></p><p><span class="koboSpan" id="kobo.93.1">Finally, we just need to update the shader class with the camera's information:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.94.1">void Game::Update() { 
  ... 
  </span><span class="koboSpan" id="kobo.94.2">m_shader-&gt;Update(m_transform, *m_camera); 
} 
</span></pre><p><span class="koboSpan" id="kobo.95.1">Upon successful compilation and execution, we should see our triangle slightly further away from the camera, because its position was set to </span><code class="literal"><span class="koboSpan" id="kobo.96.1">-5.f</span></code><span class="koboSpan" id="kobo.97.1">on the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.98.1">Z</span></em></span><span class="koboSpan" id="kobo.99.1"> axis.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Moving the camera around"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/><span class="koboSpan" id="kobo.1.1">Moving the camera around</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having a programmable camera is nice, but it still does not allow us to freely roam the scene. </span><span class="koboSpan" id="kobo.2.2">Let 's actually give our camera class the ability to be manipulated in real time, so that we can have the illusion of floating around the world:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class GL_Direction{ Up, Down, Left, Right, Forward, Back }; 
 
class GL_Camera { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">void MoveBy(GL_Direction l_dir, float l_amount); 
  void OffsetLookBy(float l_speed, float l_x, float l_y); 
  ... 
</span><span class="koboSpan" id="kobo.3.3">}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">As you can see, we are going to use two methods for that: one for moving the camera, and another for rotating it. </span><span class="koboSpan" id="kobo.4.2">We are also defining a helpful enumeration of all six possible directions.</span></p><p><span class="koboSpan" id="kobo.5.1">Moving a position vector is fairly simple. </span><span class="koboSpan" id="kobo.5.2">Assume we have a scalar value that represents the speed of the camera. </span><span class="koboSpan" id="kobo.5.3">If we multiply it by a direction vector, we get a proportional position change based on which direction the vector was pointed at, like so:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.6.1"><img src="graphics/image_07_014.jpg" alt="Moving the camera around"/></span></div><p><span class="koboSpan" id="kobo.7.1">With that in mind, let us implement the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">MoveBy()</span></code><span class="koboSpan" id="kobo.9.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">void GL_Camera::MoveBy(GL_Direction l_dir, float l_amount) { 
  if (l_dir == GL_Direction::Forward) { 
    m_position += m_forwardDir * l_amount; 
  } else if (l_dir == GL_Direction::Back) { 
    m_position -= m_forwardDir * l_amount; 
  } else if (l_dir == GL_Direction::Up) { 
    m_position += m_upDir * l_amount; 
  } else if (l_dir == GL_Direction::Down) { 
    m_position -= m_upDir * l_amount; 
  } ... 
</span><span class="koboSpan" id="kobo.10.2">} 
</span></pre><p><span class="koboSpan" id="kobo.11.1">If we are moving the camera forwards or backwards, the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">l_amount</span></code><span class="koboSpan" id="kobo.13.1"> scalar value is multiplied by the forward direction. </span><span class="koboSpan" id="kobo.13.2">Moving the camera up and down is equally as simple, since the up direction can be used for that.</span></p><p><span class="koboSpan" id="kobo.14.1">Moving left or right is slightly more complex. </span><span class="koboSpan" id="kobo.14.2">We cannot just statically change the position, because the camera's idea of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">left</span></em></span><span class="koboSpan" id="kobo.16.1"> or </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">right</span></em></span><span class="koboSpan" id="kobo.18.1"> depends on which way we are looking. </span><span class="koboSpan" id="kobo.18.2">This is where the </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">cross product</span></strong></span><span class="koboSpan" id="kobo.20.1"> comes in:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.21.1"><img src="graphics/image_07_015.jpg" alt="Moving the camera around"/></span></div><p><span class="koboSpan" id="kobo.22.1">The cross product of two vectors is a slightly harder formula to memorize, but it is very useful. </span><span class="koboSpan" id="kobo.22.2">It gives us a vector that is </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">orthogonal</span></strong></span><span class="koboSpan" id="kobo.24.1"> to the vectors </span><span class="emphasis"><em><span class="koboSpan" id="kobo.25.1">a</span></em></span><span class="koboSpan" id="kobo.26.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.27.1">b</span></em></span><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">Consider the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.29.1"><img src="graphics/image_07_016.jpg" alt="Moving the camera around"/></span></div><p><span class="koboSpan" id="kobo.30.1">An orthogonal vector is one way of saying that the direction of that vector is </span><span class="strong"><strong><span class="koboSpan" id="kobo.31.1">perpendicular</span></strong></span><span class="koboSpan" id="kobo.32.1"> to the plane the other two vectors form. </span><span class="koboSpan" id="kobo.32.2">Knowing that, we can implement left and right strafing with relative ease:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">} else if (l_dir == GL_Direction::Left) { 
  glm::vec3 cross = glm::cross(m_forwardDir, m_upDir); 
  m_position -= cross * l_amount; 
} else if (l_dir == GL_Direction::Right) { 
  glm::vec3 cross = glm::cross(m_forwardDir, m_upDir); 
  m_position += cross * l_amount; 
} ... 
</span></pre><p><span class="koboSpan" id="kobo.34.1">After obtaining the cross product of the forward and up vectors, we simply multiply it by the scalar and add the result to the camera's position, creating left and right movement.</span></p><p><span class="koboSpan" id="kobo.35.1">Rotating the camera is slightly more involved, but not trivial:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.36.1">void GL_Camera::OffsetLookBy(float l_speed, float l_x, float l_y) 
{ 
  glm::vec3 rotVector = glm::cross(m_forwardDir, m_upDir); 
  glm::mat4 rot_matrix = glm::rotate(-l_x * l_speed, m_upDir) * 
               glm::rotate(-l_y * l_speed, rotVector); 
  m_forwardDir = glm::mat3(rot_matrix) * m_forwardDir; 
} 
</span></pre><p><span class="koboSpan" id="kobo.37.1">Once again, we use the cross product to obtain the orthogonal vector of the forward direction and up direction vectors plane. </span><span class="koboSpan" id="kobo.37.2">A rotation matrix is then calculated, by multiplying two rotation matrices of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.38.1">X</span></em></span><span class="koboSpan" id="kobo.39.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.40.1">Y</span></em></span><span class="koboSpan" id="kobo.41.1"> axes. </span><span class="koboSpan" id="kobo.41.2">For the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.42.1">X</span></em></span><span class="koboSpan" id="kobo.43.1"> axis, we are simply rotating around the up direction vector, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.44.1"><img src="graphics/image_07_017.jpg" alt="Moving the camera around"/></span></div><p><span class="koboSpan" id="kobo.45.1">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.46.1">Y</span></em></span><span class="koboSpan" id="kobo.47.1"> axis rotation is made available by rotating along the orthogonal vector of the view direction and up vector's plane:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.48.1"><img src="graphics/image_07_018.jpg" alt="Moving the camera around"/></span></div><p><span class="koboSpan" id="kobo.49.1">Having this functionality now allows us to program in actual camera movement, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">void Game::Update() { 
  ... 
  </span><span class="koboSpan" id="kobo.50.2">m_mouseDifference = sf::Mouse::getPosition( 
    *m_window.GetRenderWindow()) - m_mousePosition; 
  m_mousePosition = sf::Mouse::getPosition( 
    *m_window.GetRenderWindow()); 
 
  float moveAmount = 0.005f; 
  float rotateSpeed = 0.004f; 
 
  if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) { 
    // Forward. 
    </span><span class="koboSpan" id="kobo.50.3">m_camera-&gt;MoveBy(GL_Direction::Forward, moveAmount); 
  } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) { 
    // Back. 
    </span><span class="koboSpan" id="kobo.50.4">m_camera-&gt;MoveBy(GL_Direction::Back, moveAmount); 
  } 
   
  if (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) { 
    // Left. 
    </span><span class="koboSpan" id="kobo.50.5">m_camera-&gt;MoveBy(GL_Direction::Left, moveAmount); 
  } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) { 
    // Right. 
    </span><span class="koboSpan" id="kobo.50.6">m_camera-&gt;MoveBy(GL_Direction::Right, moveAmount); 
  } 
   
  if (sf::Keyboard::isKeyPressed(sf::Keyboard::Q)) { 
    // Up. 
    </span><span class="koboSpan" id="kobo.50.7">m_camera-&gt;MoveBy(GL_Direction::Up, moveAmount); 
  } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Z)) { 
    // Down. 
    </span><span class="koboSpan" id="kobo.50.8">m_camera-&gt;MoveBy(GL_Direction::Down, moveAmount); 
  } 
 
  if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) { 
    m_camera-&gt;OffsetLookBy(rotateSpeed, 
      static_cast&lt;float&gt;(m_mouseDifference.x), 
      static_cast&lt;float&gt;(m_mouseDifference.y)); 
  } 
  ... 
</span><span class="koboSpan" id="kobo.50.9">} 
</span></pre><p><span class="koboSpan" id="kobo.51.1">We are using the keyboard keys </span><span class="emphasis"><em><span class="koboSpan" id="kobo.52.1">W</span></em></span><span class="koboSpan" id="kobo.53.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">S</span></em></span><span class="koboSpan" id="kobo.55.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.56.1">A</span></em></span><span class="koboSpan" id="kobo.57.1">, and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">D</span></em></span><span class="koboSpan" id="kobo.59.1"> to move around the camera, and mouse position changes as scalar values to rotate it, provided the left mouse button is pressed.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Drawing with vertex indices"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/><span class="koboSpan" id="kobo.1.1">Drawing with vertex indices</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">One last thing that is quite important for us before moving on is covering a more efficient way of rendering shapes. </span><span class="koboSpan" id="kobo.2.2">Our current method is fine for rendering a single triangle, but it can get inefficient really quickly when rendering something more complex, like a cube. </span><span class="koboSpan" id="kobo.2.3">If we are using vertices only, it would require a grand total of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">36</span></em></span><span class="koboSpan" id="kobo.4.1"> to render </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">six</span></em></span><span class="koboSpan" id="kobo.6.1"> cube faces. </span><span class="koboSpan" id="kobo.6.2">A much more efficient approach would obviously be submitting </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">eight</span></em></span><span class="koboSpan" id="kobo.8.1"> vertices for each corner of the cube and then reusing them to draw each face. </span><span class="koboSpan" id="kobo.8.2">Luckily, there is a way to do just that by using an </span><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">index array</span></strong></span><span class="koboSpan" id="kobo.10.1">.</span></p><p><span class="koboSpan" id="kobo.11.1">Using indices simply means that for each model we are drawing, we also need to store an array of indices that represent the draw order of vertices. </span><span class="koboSpan" id="kobo.11.2">Each vertex in a model is given an index, starting from </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">0</span></em></span><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">An array of these indices would then be used to connect the vertices, instead of having to re-submit them. </span><span class="koboSpan" id="kobo.13.3">Let's implement this functionality, starting with the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">GL_Model</span></code><span class="koboSpan" id="kobo.15.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">class GL_Model { 
  ... 
</span><span class="koboSpan" id="kobo.16.2">private: 
  ... 
  </span><span class="koboSpan" id="kobo.16.3">GLuint m_indexVBO; 
  ... 
</span><span class="koboSpan" id="kobo.16.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.17.1">As the new data member suggests, we need to store these indices in their own VBO, all of which happens inside the constructor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">GL_Model::GL_Model(GL_Vertex* l_vertices, 
  unsigned int l_vertCount, </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">unsigned int* l_indices,</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.20.1">unsigned int l_indexCount</span></strong></span><span class="koboSpan" id="kobo.21.1">) 
{ 
  m_drawCount = </span><span class="strong"><strong><span class="koboSpan" id="kobo.22.1">l_indexCount</span></strong></span><span class="koboSpan" id="kobo.23.1">; 
 
  glGenVertexArrays(1, &amp;m_VAO); 
  glBindVertexArray(m_VAO); 
  glGenBuffers(1, &amp;m_vertexVBO); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.24.1">glGenBuffers(1, &amp;m_indexVBO);</span></strong></span><span class="koboSpan" id="kobo.25.1"> 
  ... 
  </span><span class="koboSpan" id="kobo.25.2">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); 
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 
    l_indexCount * (sizeof(l_indices[0])), 
    l_indices, GL_STATIC_DRAW); 
  ... 
</span><span class="koboSpan" id="kobo.25.3">} 
</span></pre><p><span class="koboSpan" id="kobo.26.1">The constructor needs to take two extra arguments: a pointer to an array of indices, and the count of indices in that array. </span><span class="koboSpan" id="kobo.26.2">Note that </span><code class="literal"><span class="koboSpan" id="kobo.27.1">m_drawCount</span></code><span class="koboSpan" id="kobo.28.1"> is now being set to </span><code class="literal"><span class="koboSpan" id="kobo.29.1">l_indexCount</span></code><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">This is because we only need </span><span class="emphasis"><em><span class="koboSpan" id="kobo.31.1">eight</span></em></span><span class="koboSpan" id="kobo.32.1"> vertices for a cube model, but there are </span><span class="emphasis"><em><span class="koboSpan" id="kobo.33.1">36</span></em></span><span class="koboSpan" id="kobo.34.1"> indices that describe how to draw it.</span></p><p><span class="koboSpan" id="kobo.35.1">After a new VBO is generated for the indices, we bind to it and submit the index data pretty much in the same way as before. </span><span class="koboSpan" id="kobo.35.2">The main difference here is the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">GL_ELEMENT_ARRAY_BUFFER</span></code><span class="koboSpan" id="kobo.37.1"> flag. </span><span class="koboSpan" id="kobo.37.2">We cannot use </span><code class="literal"><span class="koboSpan" id="kobo.38.1">GL_ARRAY_BUFFER</span></code><span class="koboSpan" id="kobo.39.1">, as the indices actually refer to the vertex data, which is located inside another VBO.</span></p><p><span class="koboSpan" id="kobo.40.1">Obviously, this new data needs to be released once the model is no longer needed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">GL_Model::~GL_Model() { 
  glDeleteBuffers(1, &amp;m_vertexVBO); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.42.1">glDeleteBuffers(1, &amp;m_indexVBO);</span></strong></span><span class="koboSpan" id="kobo.43.1"> 
  glDeleteVertexArrays(1, &amp;m_VAO); 
} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">Drawing our model using indices requires a different </span><code class="literal"><span class="koboSpan" id="kobo.45.1">Draw()</span></code><span class="koboSpan" id="kobo.46.1"> call altogether:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">void GL_Model::Draw() { 
  glBindVertexArray(m_VAO); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1">glDrawElements(GL_TRIANGLES, m_drawCount, GL_UNSIGNED_INT, 0);</span></strong></span><span class="koboSpan" id="kobo.49.1"> 
  glBindVertexArray(0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">The call to the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">glDrawElements()</span></code><span class="koboSpan" id="kobo.52.1"> method takes four arguments: the type of primitives we are going to be drawing, the total number of indices, the data type that these indices are represented by, and an offset that can be used to skip them.</span></p><p><span class="koboSpan" id="kobo.53.1">That is all there is to drawing geometry using indices! </span><span class="koboSpan" id="kobo.53.2">Now let's set up a more exciting model to show it off:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">Game::Game() ... </span><span class="koboSpan" id="kobo.54.2">{ 
  ... 
  </span><span class="koboSpan" id="kobo.54.3">GL_Vertex vertices[] = { 
    //      |---POSITION----| |TEXTURE| 
    //        X    Y  Z      X, Y 
    GL_Vertex({ -0.5, -0.5, 0.5 }, { 0, 0 }), // 0 
    GL_Vertex({ -0.5, 0.5, 0.5 }, { 0, 1 }), // 1 
    GL_Vertex({ 0.5, 0.5, 0.5 }, { 1, 1 }), // 2 
    GL_Vertex({ 0.5, -0.5, 0.5 }, { 1, 0 }), // 3 
    GL_Vertex({ -0.5, -0.5, -0.5f }, { 1, 0 }), // 4 
    GL_Vertex({ -0.5, 0.5, -0.5f }, { 1, 1 }), // 5 
    GL_Vertex({ 0.5, 0.5, -0.5f }, { 0, 0 }), // 6 
    GL_Vertex({ 0.5, -0.5, -0.5f }, { 0, 1 }) // 7 
  }; 
 
  unsigned int indices[] = { 
    2, 1, 0, 0, 3, 2, // Back 
    5, 4, 0, 0, 1, 5, // Right 
    3, 7, 6, 6, 2, 3, // Left 
    6, 7, 4, 4, 5, 6, // Front 
    1, 2, 6, 6, 5, 1, // Top 
    0, 4, 7, 7, 3, 0 // Bottom 
  }; 
 
  m_model = std::make_unique&lt;GL_Model&gt;(vertices, 8, indices, 36); 
  ... 
</span><span class="koboSpan" id="kobo.54.4">} 
</span></pre><p><span class="koboSpan" id="kobo.55.1">As you can see, we've now set up </span><code class="literal"><span class="koboSpan" id="kobo.56.1">8</span></code><span class="koboSpan" id="kobo.57.1"> vertices, and we've created another array for indices. </span><span class="koboSpan" id="kobo.57.2">Once the model is rendered, we would see something like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.58.1"><img src="graphics/image_07_019.jpg" alt="Drawing with vertex indices"/></span></div><p><span class="koboSpan" id="kobo.59.1">Note that the bottom face is actually rendered on top for some reason. </span><span class="koboSpan" id="kobo.59.2">This is caused by OpenGL not knowing which geometry to render on top, and this will be solved in the next section.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Face culling and depth buffer"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/><span class="koboSpan" id="kobo.1.1">Face culling and depth buffer</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">One way of solving the draw order issues is by using a </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">depth buffer</span></strong></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">In the simplest terms, a depth buffer, also commonly known as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">Z-buffer</span></strong></span><span class="koboSpan" id="kobo.6.1">, is basically a texture managed by OpenGL in the background that contains depth information of each pixel. </span><span class="koboSpan" id="kobo.6.2">When a pixel is being rendered, its depth (</span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Z</span></em></span><span class="koboSpan" id="kobo.8.1"> value) is checked against that on the depth buffer. </span><span class="koboSpan" id="kobo.8.2">If a pixel being rendered has a lower </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">Z</span></em></span><span class="koboSpan" id="kobo.10.1"> value, the pixel is overwritten, as it is clearly on top.</span></p><p><span class="koboSpan" id="kobo.11.1">Enabling the depth buffer only comes down to a single </span><code class="literal"><span class="koboSpan" id="kobo.12.1">glEnable()</span></code><span class="koboSpan" id="kobo.13.1"> method call:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">Game::Game() ... </span><span class="koboSpan" id="kobo.14.2">{ 
  ... 
  </span><span class="koboSpan" id="kobo.14.3">glEnable(GL_DEPTH_TEST); 
  ... 
</span><span class="koboSpan" id="kobo.14.4">} 
</span></pre><p><span class="koboSpan" id="kobo.15.1">Keep in mind that the depth buffer is a texture. </span><span class="koboSpan" id="kobo.15.2">It is imperative to make sure it gets allocated when the window is created, and it has enough data to work with. </span><span class="koboSpan" id="kobo.15.3">We can make sure of that by creating an </span><code class="literal"><span class="koboSpan" id="kobo.16.1">sf::ContextSettings</span></code><span class="koboSpan" id="kobo.17.1"> structure and filling out its </span><code class="literal"><span class="koboSpan" id="kobo.18.1">depthBits</span></code><span class="koboSpan" id="kobo.19.1"> data member before passing it to the SFML's window </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Create()</span></code><span class="koboSpan" id="kobo.21.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void GL_Window::Create() { 
  ... 
  </span><span class="koboSpan" id="kobo.22.2">sf::ContextSettings settings; 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">settings.depthBits = 32; // 32 bits.</span></strong></span><span class="koboSpan" id="kobo.24.1"> 
  settings.stencilBits = 8; 
  settings.antialiasingLevel = 0; 
  settings.majorVersion = 4; 
  settings.minorVersion = 5; 
 
  m_window.create(sf::VideoMode(m_windowSize.x, 
    m_windowSize.y, 32), m_windowTitle, style, </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">settings</span></strong></span><span class="koboSpan" id="kobo.26.1">); 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">If we just ran the code as is, the screen would be completely blank. </span><span class="koboSpan" id="kobo.27.2">Why? </span><span class="koboSpan" id="kobo.27.3">Well, remember that the Z-buffer is a texture. </span><span class="koboSpan" id="kobo.27.4">A texture, just like the display, needs to be cleared every cycle. </span><span class="koboSpan" id="kobo.27.5">We can accomplish that like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">void GL_Window::BeginDraw() { 
  glClearColor(0.f, 0.f, 0.f, 1.f); // BLACK 
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">Adding the pipe symbol allows us to perform a bitwise or operation on the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">glClear</span></code><span class="koboSpan" id="kobo.31.1">'s argument, joining in the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">GL_DEPTH_BUFFER_BIT</span></code><span class="koboSpan" id="kobo.33.1"> definition. </span><span class="koboSpan" id="kobo.33.2">This ensures that the depth buffer is also cleared to black, and we can finally enjoy our cube:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.34.1"><img src="graphics/image_07_020.jpg" alt="Face culling and depth buffer"/></span></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Back face culling"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/><span class="koboSpan" id="kobo.1.1">Back face culling</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In order to save on performance, it is a good idea to let OpenGL know that we would like to cull faces that are not visible from the current perspective. </span><span class="koboSpan" id="kobo.2.2">This feature can be enabled like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">Game::Game() ... </span><span class="koboSpan" id="kobo.3.2">{ 
  ... 
  </span><span class="koboSpan" id="kobo.3.3">glEnable(GL_DEPTH_TEST); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1">glEnable(GL_CULL_FACE); 
  glCullFace(GL_BACK);</span></strong></span><span class="koboSpan" id="kobo.5.1"> 
  ... 
</span><span class="koboSpan" id="kobo.5.2">} 
</span></pre><p><span class="koboSpan" id="kobo.6.1">After we </span><code class="literal"><span class="koboSpan" id="kobo.7.1">glEnable</span></code><span class="koboSpan" id="kobo.8.1"> face culling, the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">glCullFace</span></code><span class="koboSpan" id="kobo.10.1"> function is invoked to let OpenGL know which faces to cull. </span><span class="koboSpan" id="kobo.10.2">This will work right out of the box, but we may notice weird artifacts like this if our model data is not set up correctly:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_07_021.jpg" alt="Back face culling"/></span></div><p><span class="koboSpan" id="kobo.12.1">This is because the order our vertices are rendered in actually defines whether a face of a piece of geometry is facing inwards or outwards. </span><span class="koboSpan" id="kobo.12.2">For example, if the vertices of a face are rendered in a clockwise sequence, the face, by default, is considered to be facing </span><span class="strong"><strong><span class="koboSpan" id="kobo.13.1">inwards</span></strong></span><span class="koboSpan" id="kobo.14.1"> of the model and vice versa. </span><span class="koboSpan" id="kobo.14.2">Consider the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.15.1"><img src="graphics/image_07_022.jpg" alt="Back face culling"/></span></div><p><span class="koboSpan" id="kobo.16.1">Setting up the model draw order correctly allows us to save on performance by not drawing invisible faces, and having our cube back just the way it was.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">That may have been quite a lot to take in, but if you have made it all the way to the end, congratulations! </span><span class="koboSpan" id="kobo.2.2">The hard part is now over, and you are familiar with the modern versions of OpenGL, the programmable pipeline and general-purpose rendering. </span><span class="koboSpan" id="kobo.2.3">Even SFML itself was built around basic principles like the ones we have gone over, some of which we have already covered extensively.</span></p><p><span class="koboSpan" id="kobo.3.1">In the next chapter, we are going to be covering the basics of lighting to create a more dynamic feel to our world. </span><span class="koboSpan" id="kobo.3.2">See you there!</span></p></div></div></div></body></html>