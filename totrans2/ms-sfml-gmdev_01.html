<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 1. Under the Hood - Setting up the Backend"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/><span class="koboSpan" id="kobo.1.1">Chapter 1. Under the Hood - Setting up the Backend</span></h1></div></div></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"/><span class="koboSpan" id="kobo.2.1">Introduction</span></h1></div></div></div><p><span class="koboSpan" id="kobo.3.1">What is the heart of any given piece of software? </span><span class="koboSpan" id="kobo.3.2">The answer to this question becomes apparent gradually while building a full-scale project, which can be a daunting task to undertake, especially when starting from scratch. </span><span class="koboSpan" id="kobo.3.3">It’s the design and capability of the back-end that either drives a game forward with full force by utilizing its power, or crashes it into obscurity through unrealized potential. </span><span class="koboSpan" id="kobo.3.4">Here, we’re going to be talking about that very foundation that keeps any given project up and standing.</span></p><p><span class="koboSpan" id="kobo.4.1">In this chapter, we're going to be covering the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Utility functions and filesystem specifics for Windows and Linux operating systems</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">The basics of the entity component system pattern</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Window, event, and resource management techniques</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Creating and maintaining application states</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.9.1">Graphical user interface basics</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.10.1">Essentials for the 2D RPG game project</span></li></ul></div><p><span class="koboSpan" id="kobo.11.1">There's a lot to cover, so let's not waste any time!</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Pacing and source code examples"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"/><span class="koboSpan" id="kobo.1.1">Pacing and source code examples</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">All of the systems we're going to be talking about here could have entire volumes dedicated to them. </span><span class="koboSpan" id="kobo.2.2">Since time, as well as paper, is limited, we're only going to be briefly reviewing their very basics, which is just enough to feel comfortable with the rest of the information presented here.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note3"/><span class="koboSpan" id="kobo.3.1">Note</span></h3><p><span class="koboSpan" id="kobo.4.1">Keep in mind that, although we won't be going into too much detail in this particular chapter, the code that accompanies this book is a great resource to look through and experiment with for more detail and familiarity. </span><span class="koboSpan" id="kobo.4.2">It's greatly recommended to review it while reading this chapter in order to get a full grasp of it.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Common utility functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec9"/><span class="koboSpan" id="kobo.1.1">Common utility functions</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Let's start by taking a look at a common function, which is going to be used to determine the full absolute path to the directory our executable is in. </span><span class="koboSpan" id="kobo.2.2">Unfortunately, there is no unified way of doing this across all platforms, so we're going to have to implement a version of this utility function for each one, starting with Windows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">#ifdef RUNNING_WINDOWS 
#define WIN32_LEAN_AND_MEAN 
#include &lt;windows.h&gt; 
#include &lt;Shlwapi.h&gt; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">First, we check if the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">RUNNING_WINDOWS</span></code><span class="koboSpan" id="kobo.6.1"> macro is defined. </span><span class="koboSpan" id="kobo.6.2">This is the basic technique that can be used to actually let the rest of the code base know which OS it's running on. </span><span class="koboSpan" id="kobo.6.3">Next, another definition is made, specifically for the Windows header files we're including. </span><span class="koboSpan" id="kobo.6.4">It greatly reduces the number of other headers that get included in the process.</span></p><p><span class="koboSpan" id="kobo.7.1">With all of the necessary headers for the Windows OS included, let us take a look at how the actual function can be implemented:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">inline std::string GetWorkingDirectory() 
{ 
   HMODULE hModule = GetModuleHandle(nullptr); 
   if (!hModule) { return ""; } 
   char path[256]; 
   GetModuleFileName(hModule,path,sizeof(path)); 
   PathRemoveFileSpec(path); 
   strcat_s(path,""); 
   return std::string(path); 
} 
</span></pre><p><span class="koboSpan" id="kobo.9.1">First, we obtain the handle to the process that was created by our executable file. </span><span class="koboSpan" id="kobo.9.2">After the temporary path buffer is constructed and filled with the path string, the name, and extension of our executable is removed. </span><span class="koboSpan" id="kobo.9.3">We top it off by adding a trailing slash to the end of the path and returning it as a </span><code class="literal"><span class="koboSpan" id="kobo.10.1">std::string</span></code><span class="koboSpan" id="kobo.11.1">.</span></p><p><span class="koboSpan" id="kobo.12.1">It will also come in handy to have a way of obtaining a list of files inside a specified directory:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">inline std::vector&lt;std::string&gt; GetFileList( 
   const std::string&amp; l_directory, 
   const std::string&amp; l_search = "*.*") 
{ 
   std::vector&lt;std::string&gt; files; 
   if(l_search.empty()) { return files; } 
   std::string path = l_directory + l_search; 
   WIN32_FIND_DATA data; 
   HANDLE found = FindFirstFile(path.c_str(), &amp;data); 
   if (found == INVALID_HANDLE_VALUE) { return files; } 
   do{ 
       if (!(data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)) 
       { 
          files.emplace_back(data.cFileName); 
       } 
     }while (FindNextFile(found, &amp;data)); 
   FindClose(found); 
   return files; 
} 
</span></pre><p><span class="koboSpan" id="kobo.14.1">Just like the directory function, this is specific to the Windows OS. </span><span class="koboSpan" id="kobo.14.2">It returns a vector of strings that represent file names and extensions. </span><span class="koboSpan" id="kobo.14.3">Once one is constructed, a path string is cobbled together. </span><span class="koboSpan" id="kobo.14.4">The </span><code class="literal"><span class="koboSpan" id="kobo.15.1">l_search</span></code><span class="koboSpan" id="kobo.16.1"> argument is provided with a default value, in case one is not specified. </span><span class="koboSpan" id="kobo.16.2">All files are listed by default.</span></p><p><span class="koboSpan" id="kobo.17.1">After creating a structure that will hold our search data, we pass it to another Windows specific function that will find the very first file inside a directory. </span><span class="koboSpan" id="kobo.17.2">The rest of the work is done inside a </span><code class="literal"><span class="koboSpan" id="kobo.18.1">do-while</span></code><span class="koboSpan" id="kobo.19.1"> loop, which checks if the located item isn't in fact a directory. </span><span class="koboSpan" id="kobo.19.2">The appropriate items are then pushed into a vector, which gets returned later on.</span></p><div class="section" title="The Linux version"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec6"/><span class="koboSpan" id="kobo.20.1">The Linux version</span></h2></div></div></div><p><span class="koboSpan" id="kobo.21.1">As mentioned previously, both of the preceding functions are only functional on Windows. </span><span class="koboSpan" id="kobo.21.2">In order to add support for systems running Linux-based OSes, we're going to need to implement them differently. </span><span class="koboSpan" id="kobo.21.3">Let's start by including proper header files:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">#elif defined RUNNING_LINUX 
#include &lt;unistd.h&gt; 
#include &lt;dirent.h&gt; 
</span></pre><p><span class="koboSpan" id="kobo.23.1">As luck would have it, Linux does offer a single-call solution to finding exactly where our executable is located:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">inline std::string GetWorkingDirectory() 
{ 
   char cwd[1024]; 
   if(!getcwd(cwd, sizeof(cwd))){ return ""; } 
   return std::string(cwd) + std::string("/"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.25.1">Note that we're still adding a trailing slash to the end.</span></p><p><span class="koboSpan" id="kobo.26.1">Obtaining a file list of a specific directory is slightly more complicated this time around:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">inline std::vector&lt;std::string&gt; GetFileList( 
   const std::string&amp; l_directory, 
   const std::string&amp; l_search = "*.*") 
{ 
   std::vector&lt;std::string&gt; files; 
    
   DIR *dpdf; 
   dpdf = opendir(l_directory.c_str()); 
   if (!dpdf) { return files; } 
   if(l_search.empty()) { return files; } 
   std::string search = l_search; 
   if (search[0] == '*') { search.erase(search.begin()); } 
   if (search[search.length() - 1] == '*') { search.pop_back(); } 
  struct dirent *epdf; 
  while (epdf = readdir(dpdf)) { 
    std::string name = epdf-&gt;d_name; 
    if (epdf-&gt;d_type == DT_DIR) { continue; } 
    if (l_search != "*.*") { 
      if (name.length() &lt; search.length()) { continue; } 
      if (search[0] == '.') { 
        if (name.compare(name.length() - search.length(), 
          search.length(), search) != 0) 
        { continue; } 
      } else if (name.find(search) == std::string::npos) { 
        continue; 
      } 
    } 
    files.emplace_back(name); 
  } 
  closedir(dpdf); 
  return files; 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">We start off in the same fashion as before, by creating a vector of strings. </span><span class="koboSpan" id="kobo.28.2">A pointer to the directory stream is then obtained through the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">opendir()</span></code><span class="koboSpan" id="kobo.30.1"> function. </span><span class="koboSpan" id="kobo.30.2">Provided it isn't </span><code class="literal"><span class="koboSpan" id="kobo.31.1">NULL</span></code><span class="koboSpan" id="kobo.32.1">, we begin modifying the search string. </span><span class="koboSpan" id="kobo.32.2">Unlike the fancier Windows alternative, we can't just pass a search string into a function and let the OS do all of the matching. </span><span class="koboSpan" id="kobo.32.3">In this case, it falls more under the category of matching a specific search string inside a filename that gets returned, so star symbols that mean anything need to be trimmed out.</span></p><p><span class="koboSpan" id="kobo.33.1">Next, we utilize the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">readdir()</span></code><span class="koboSpan" id="kobo.35.1"> function inside a </span><code class="literal"><span class="koboSpan" id="kobo.36.1">while</span></code><span class="koboSpan" id="kobo.37.1"> loop that's going to return a pointer to directory entry structures one by one. </span><span class="koboSpan" id="kobo.37.2">We also want to exclude any directories from the file list, so the entry's type is checked for not being equal to </span><code class="literal"><span class="koboSpan" id="kobo.38.1">DT_DIR</span></code><span class="koboSpan" id="kobo.39.1">.</span></p><p><span class="koboSpan" id="kobo.40.1">Finally, the string matching begins. </span><span class="koboSpan" id="kobo.40.2">Presuming we're not just looking for any file with any extension (represented by </span><code class="literal"><span class="koboSpan" id="kobo.41.1">"*.*"</span></code><span class="koboSpan" id="kobo.42.1">), the entry's name will be compared to the search string by length first. </span><span class="koboSpan" id="kobo.42.2">If the length of the string we're searching is longer than the filename itself, it's safe to assume we don't have a match. </span><span class="koboSpan" id="kobo.42.3">Otherwise, the search string is analyzed again to determine whether the filename is important for a positive match. </span><span class="koboSpan" id="kobo.42.4">Its first character being a period would denote that it isn't, so the file name's ending segment of the same length as the search string is compared to the search string itself. </span><span class="koboSpan" id="kobo.42.5">If, however, the name is important, we simply search the filename for the search string.</span></p><p><span class="koboSpan" id="kobo.43.1">Once the procedure is complete, the directory is closed and the vector of strings representing files is returned.</span></p></div><div class="section" title="Other miscellaneous helper functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec7"/><span class="koboSpan" id="kobo.44.1">Other miscellaneous helper functions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.45.1">Sometimes, as text files are being read, it's nice to grab a string that includes spaces while still maintaining a whitespace delimiter. </span><span class="koboSpan" id="kobo.45.2">In cases like that, we can use quotes along with this special function that helps us read the entire quoted segment from a whitespace delimited file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.46.1">inline void ReadQuotedString(std::stringstream&amp; l_stream, 
  std::string&amp; l_string) 
{ 
  l_stream &gt;&gt; l_string; 
  if (l_string.at(0) == '"'){ 
    while (l_string.at(l_string.length() - 1) != '"' || 
      !l_stream.eof()) 
    { 
      std::string str; 
      l_stream &gt;&gt; str; 
      l_string.append(" " + str); 
    } 
  } 
  l_string.erase(std::remove( 
    l_string.begin(), l_string.end(), '"'), l_string.end()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.47.1">The first segment of the stream is fed into the argument string. </span><span class="koboSpan" id="kobo.47.2">If it does indeed start with a double quote, a </span><code class="literal"><span class="koboSpan" id="kobo.48.1">while</span></code><span class="koboSpan" id="kobo.49.1"> loop is initiated to append to said string until it ends with another double quote, or until the stream reaches the end. </span><span class="koboSpan" id="kobo.49.2">Lastly, all double quotes from the string are erased, giving us the final result.</span></p><p><span class="koboSpan" id="kobo.50.1">Interpolation is another useful tool in a programmer's belt. </span><span class="koboSpan" id="kobo.50.2">Imagine having two different values of something at two different points in time, and then wanting to predict what the value would be somewhere in between those two time frames. </span><span class="koboSpan" id="kobo.50.3">This simple calculation makes that possible:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">template&lt;class T&gt; 
inline T Interpolate(float tBegin, float tEnd, 
   const T&amp; begin_val, const T&amp; end_val, float tX) 
{ 
   return static_cast&lt;T&gt;(( 
      ((end_val - begin_val) / (tEnd - tBegin)) * 
      (tX - tBegin)) + begin_val); 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">Next, let's take a look at a few functions that can help us center instances of </span><code class="literal"><span class="koboSpan" id="kobo.53.1">sf::Text</span></code><span class="koboSpan" id="kobo.54.1"> better:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.55.1">inline float GetSFMLTextMaxHeight(const sf::Text&amp; l_text) { 
  auto charSize = l_text.getCharacterSize(); 
  auto font = l_text.getFont(); 
  auto string = l_text.getString().toAnsiString(); 
  bool bold = (l_text.getStyle() &amp; sf::Text::Bold); 
  float max = 0.f; 
  for (size_t i = 0; i &lt; string.length(); ++i) { 
    sf::Uint32 character = string[i]; 
    auto glyph = font-&gt;getGlyph(character, charSize, bold); 
    auto height = glyph.bounds.height; 
    if (height &lt;= max) { continue; } 
    max = height; 
  } 
  return max; 
} 
 
inline void CenterSFMLText(sf::Text&amp; l_text) { 
  sf::FloatRect rect = l_text.getLocalBounds(); 
  auto maxHeight = Utils::GetSFMLTextMaxHeight(l_text); 
  l_text.setOrigin( 
    rect.left + (rect.width * 0.5f), 
    rect.top + ((maxHeight &gt;= rect.height ? 
      </span><span class="koboSpan" id="kobo.55.2">maxHeight * 0.5f : rect.height * 0.5f))); 
} 
</span></pre><p><span class="koboSpan" id="kobo.56.1">Working with SFML text can be tricky sometimes, especially when centering it is of paramount importance. </span><span class="koboSpan" id="kobo.56.2">Some characters, depending on the font and other different attributes, can actually exceed the height of the bounding box that surrounds the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">sf::Text</span></code><span class="koboSpan" id="kobo.58.1"> instance. </span><span class="koboSpan" id="kobo.58.2">To combat that, the first function iterates through every single character of a specific text instance and fetches the font glyph used to represent it. </span><span class="koboSpan" id="kobo.58.3">Its height is then checked and kept track of, so that the maximum height of the entire text can be determined and returned.</span></p><p><span class="koboSpan" id="kobo.59.1">The second function can be used for setting the absolute center of a </span><code class="literal"><span class="koboSpan" id="kobo.60.1">sf::Text</span></code><span class="koboSpan" id="kobo.61.1"> instance as its origin, in order to achieve perfect results. </span><span class="koboSpan" id="kobo.61.2">After its local bounding box is obtained and the maximum height is calculated, this information is used to move the original point of our text to its center.</span></p></div><div class="section" title="Generating random numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec8"/><span class="koboSpan" id="kobo.62.1">Generating random numbers</span></h2></div></div></div><p><span class="koboSpan" id="kobo.63.1">Most games out there rely on some level of randomness. </span><span class="koboSpan" id="kobo.63.2">While it may be tempting to simply use the classical approach of </span><code class="literal"><span class="koboSpan" id="kobo.64.1">rand()</span></code><span class="koboSpan" id="kobo.65.1">, it can only take you so far. </span><span class="koboSpan" id="kobo.65.2">Generating random negative or floating point numbers isn't straightforward, to say the least, plus it has a very lousy range. </span><span class="koboSpan" id="kobo.65.3">Luckily, newer versions of C++ provide the answer in the form of uniform distributions and random number engines:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.66.1">#include &lt;random&gt; 
#include &lt;SFML/System/Mutex.hpp&gt; 
#include &lt;SFML/System/Lock.hpp&gt; 
 
class RandomGenerator { 
public: 
  RandomGenerator() : m_engine(m_device()){} 
  ... 
  </span><span class="koboSpan" id="kobo.66.2">float operator()(float l_min, float l_max) { 
    return Generate(l_min, l_max); 
  } 
  int operator()(int l_min, int l_max) { 
    return Generate(l_min, l_max); 
  } 
private: 
  std::random_device m_device; 
  std::mt19937 m_engine; 
  std::uniform_int_distribution&lt;int&gt; m_intDistribution; 
  std::uniform_real_distribution&lt;float&gt; m_floatDistribution; 
  sf::Mutex m_mutex; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.67.1">First, note the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">include</span></code><span class="koboSpan" id="kobo.69.1"> statements. </span><span class="koboSpan" id="kobo.69.2">The </span><code class="literal"><span class="koboSpan" id="kobo.70.1">random</span></code><span class="koboSpan" id="kobo.71.1"> library provides us with everything we need as far as number generation goes. </span><span class="koboSpan" id="kobo.71.2">On top of that, we're also going to be using SFML's mutexes and locks, in order to prevent a huge mess in case our code is being accessed by several separate threads.</span></p><p><span class="koboSpan" id="kobo.72.1">The </span><code class="literal"><span class="koboSpan" id="kobo.73.1">std::random_device</span></code><span class="koboSpan" id="kobo.74.1"> class is a random number generator that is used to seed the engine, which will be used for further generations. </span><span class="koboSpan" id="kobo.74.2">The engine itself is based on the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.75.1">Marsenne Twister</span></em></span><span class="koboSpan" id="kobo.76.1"> algorithm, and produces high-quality random </span><span class="emphasis"><em><span class="koboSpan" id="kobo.77.1">unsigned integers</span></em></span><span class="koboSpan" id="kobo.78.1"> that can later be filtered through a </span><span class="strong"><strong><span class="koboSpan" id="kobo.79.1">uniform distribution</span></strong></span><span class="koboSpan" id="kobo.80.1"> object in order to obtain a number that falls within a specific range. </span><span class="koboSpan" id="kobo.80.2">Ideally, since it is quite expensive to keep constructing and destroying these objects, we're going to want to keep a single copy of this class around. </span><span class="koboSpan" id="kobo.80.3">For this very reason, we have integer and float distributions together in the same class.</span></p><p><span class="koboSpan" id="kobo.81.1">For convenience, the parenthesis operators are overloaded to take in ranges of numbers of both </span><span class="emphasis"><em><span class="koboSpan" id="kobo.82.1">integer</span></em></span><span class="koboSpan" id="kobo.83.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.84.1">floating point</span></em></span><span class="koboSpan" id="kobo.85.1"> types. </span><span class="koboSpan" id="kobo.85.2">They invoke the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">Generate</span></code><span class="koboSpan" id="kobo.87.1"> method, which is also overloaded to handle both data types:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.88.1">int Generate(int l_min, int l_max) { 
  sf::Lock lock(m_mutex); 
  if (l_min &gt; l_max) { std::swap(l_min, l_max); } 
  if (l_min != m_intDistribution.min() || 
    l_max != m_intDistribution.max()) 
  { 
    m_intDistribution = 
      std::uniform_int_distribution&lt;int&gt;(l_min, l_max); 
  } 
  return m_intDistribution(m_engine); 
} 
 
float Generate(float l_min, float l_max) { 
  sf::Lock lock(m_mutex); 
  if (l_min &gt; l_max) { std::swap(l_min, l_max); } 
  if (l_min != m_floatDistribution.min() || 
    l_max != m_floatDistribution.max()) 
  { 
    m_floatDistribution = 
      std::uniform_real_distribution&lt;float&gt;(l_min, l_max); 
  } 
  return m_floatDistribution(m_engine); 
} 
</span></pre><p><span class="koboSpan" id="kobo.89.1">Before generation can begin, we must establish a lock in order to be thread-safe. </span><span class="koboSpan" id="kobo.89.2">Because the order of </span><code class="literal"><span class="koboSpan" id="kobo.90.1">l_min</span></code><span class="koboSpan" id="kobo.91.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.92.1">l_max</span></code><span class="koboSpan" id="kobo.93.1"> values matters, we must check if the provided values aren't in reverse, and swap them if they are. </span><span class="koboSpan" id="kobo.93.2">Also, the uniform distribution object has to be reconstructed if a different range needs to be used, so a check for that is in place as well. </span><span class="koboSpan" id="kobo.93.3">Finally, after all of that trouble, we're ready to return the random number by utilizing the parenthesis operator of a distribution, to which the engine instance is fed in.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Service locator pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/><span class="koboSpan" id="kobo.1.1">Service locator pattern</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Often, one or more of our classes will need access to another part of our code base. </span><span class="koboSpan" id="kobo.2.2">Usually, it's not a major issue. </span><span class="koboSpan" id="kobo.2.3">All you would have to do is pass a pointer or two around, or maybe store them once as data members of the class in need. </span><span class="koboSpan" id="kobo.2.4">However, as the amount of code grows, relationships between classes get more and more complex. </span><span class="koboSpan" id="kobo.2.5">Dependencies can increase to a point, where a specific class will have more arguments/setters than actual methods. </span><span class="koboSpan" id="kobo.2.6">For convenience's sake, sometimes it's better to pass around a single pointer/reference instead of ten. </span><span class="koboSpan" id="kobo.2.7">This is where the </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">service locator</span></strong></span><span class="koboSpan" id="kobo.4.1"> pattern comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class Window; 
class EventManager; 
class TextureManager; 
class FontManager; 
... 
</span><span class="koboSpan" id="kobo.5.2">struct SharedContext{ 
  SharedContext(): 
    m_wind(nullptr), 
    m_eventManager(nullptr), 
    m_textureManager(nullptr), 
    m_fontManager(nullptr), 
    ... 
  </span><span class="koboSpan" id="kobo.5.3">{} 
 
  Window* m_wind; 
  EventManager* m_eventManager; 
  TextureManager* m_textureManager; 
  FontManager* m_fontManager; 
  ... 
</span><span class="koboSpan" id="kobo.5.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">As you can see, it's just a </span><code class="literal"><span class="koboSpan" id="kobo.7.1">struct</span></code><span class="koboSpan" id="kobo.8.1"> with multiple pointers to the core classes of our project. </span><span class="koboSpan" id="kobo.8.2">All of those classes are forward-declared in order to avoid unnecessary </span><code class="literal"><span class="koboSpan" id="kobo.9.1">include</span></code><span class="koboSpan" id="kobo.10.1"> statements, and thus a bloated compilation process.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Entity component system core"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/><span class="koboSpan" id="kobo.1.1">Entity component system core</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Let's get to the essence of how our game entities are going to be represented. </span><span class="koboSpan" id="kobo.2.2">In order to achieve highest maintainability and code compartmentalization, it's best to use composition. </span><span class="koboSpan" id="kobo.2.3">The entity component system allows just that. </span><span class="koboSpan" id="kobo.2.4">For the sake of keeping this short and sweet, we're not going to be delving too deep into the implementation. </span><span class="koboSpan" id="kobo.2.5">This is simply a quick overview for the sake of being familiar with the code that will be used down the line.</span></p><p><span class="koboSpan" id="kobo.3.1">The ECS pattern consists of three cornerstones that make it possible: entities, components, and systems. </span><span class="koboSpan" id="kobo.3.2">An entity, ideally, is simply an identifier, as basic as an integer. </span><span class="koboSpan" id="kobo.3.3">Components are containers of data that have next to no logic inside them. </span><span class="koboSpan" id="kobo.3.4">There would be multiple types of components, such as position, movable, drawable, and so on, that don't really mean much by themselves, but when composed, will form complex entities. </span><span class="koboSpan" id="kobo.3.5">Such composition would make it incredibly easy to save the state of any entity at any given time.</span></p><p><span class="koboSpan" id="kobo.4.1">There are many ways to implement components. </span><span class="koboSpan" id="kobo.4.2">One of them is simply having a base component class, and inheriting from it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class C_Base{ 
public: 
  C_Base(const Component&amp; l_type): m_type(l_type){} 
  virtual ~C_Base(){} 
 
  Component GetType() const { return m_type; } 
 
  friend std::stringstream&amp; operator &gt;&gt;( 
    std::stringstream&amp; l_stream, C_Base&amp; b) 
    { 
      b.ReadIn(l_stream); 
      return l_stream; 
    } 
 
  virtual void ReadIn(std::stringstream&amp; l_stream) = 0; 
protected: 
  Component m_type; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">The </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Component</span></code><span class="koboSpan" id="kobo.8.1"> type is simply an </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">enum class</span></em></span><span class="koboSpan" id="kobo.10.1"> that lists different types of components we can have in a project. </span><span class="koboSpan" id="kobo.10.2">In addition to that, this base class also offers a means of filling in component data from a string stream, in order to load them more easily when files are being read.</span></p><p><span class="koboSpan" id="kobo.11.1">In order to properly manage sets of components that belong to entities, we would need some sort of manager class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">class EntityManager{ 
public: 
  EntityManager(SystemManager* l_sysMgr, 
    TextureManager* l_textureMgr); 
  ~EntityManager(); 
 
  int AddEntity(const Bitmask&amp; l_mask); 
  int AddEntity(const std::string&amp; l_entityFile); 
  bool RemoveEntity(const EntityId&amp; l_id); 
 
  bool AddComponent(const EntityId&amp; l_entity, 
    const Component&amp; l_component); 
 
  template&lt;class T&gt; 
  void AddComponentType(const Component&amp; l_id) { ... </span><span class="koboSpan" id="kobo.12.2">} 
 
  template&lt;class T&gt; 
  T* GetComponent(const EntityId&amp; l_entity, 
    const Component&amp; l_component){ ... </span><span class="koboSpan" id="kobo.12.3">} 
 
  bool RemoveComponent(const EntityId&amp; l_entity, 
    const Component&amp; l_component); 
  bool HasComponent(const EntityId&amp; l_entity, 
    const Component&amp; l_component) const; 
  void Purge(); 
private: 
  ... 
</span><span class="koboSpan" id="kobo.12.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.13.1">As you can see, this is a fairly basic approach at managing these sets of data we call entities. </span><span class="koboSpan" id="kobo.13.2">The </span><code class="literal"><span class="koboSpan" id="kobo.14.1">EntityId</span></code><span class="koboSpan" id="kobo.15.1"> data type is simply a type definition for an </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">unsigned integer</span></strong></span><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Creation of components happens by utilizing a factory pattern, lambdas and templates. </span><span class="koboSpan" id="kobo.17.3">This class is also responsible for loading entities from files that may look a little like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">Name Player 
Attributes 255 
|Component|ID|Individual attributes| 
Component 0 0 0 1 
Component 1 Player 
Component 2 0 
Component 3 128.0 1024.0 1024.0 1 
Component 4 
Component 5 20.0 20.0 0.0 0.0 2 
Component 6 footstep:1,4 
Component 7 
</span></pre><p><span class="koboSpan" id="kobo.19.1">The </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Attributes</span></code><span class="koboSpan" id="kobo.21.1"> field is a bit mask, the value of which is used to figure out which component types an entity has. </span><span class="koboSpan" id="kobo.21.2">The actual component data is stored in this file as well, and later loaded through the </span><code class="literal"><span class="koboSpan" id="kobo.22.1">ReadIn</span></code><span class="koboSpan" id="kobo.23.1"> method of our component base class.</span></p><p><span class="koboSpan" id="kobo.24.1">The last piece of the puzzle in ECS design is systems. </span><span class="koboSpan" id="kobo.24.2">This is where all of the logic happens. </span><span class="koboSpan" id="kobo.24.3">Just like components, there can be many types of systems responsible for collisions, rendering, movement, and so on. </span><span class="koboSpan" id="kobo.24.4">Each system must inherit from the system's base class and implement all of the pure virtual methods:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">class S_Base : </span><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">public Observer</span></strong></span><span class="koboSpan" id="kobo.27.1">{ 
public: 
  S_Base(const System&amp; l_id, SystemManager* l_systemMgr); 
  virtual ~S_Base(); 
 
  bool AddEntity(const EntityId&amp; l_entity); 
  bool HasEntity(const EntityId&amp; l_entity) const; 
  bool RemoveEntity(const EntityId&amp; l_entity); 
 
  System GetId() const; 
 
  bool FitsRequirements(const Bitmask&amp; l_bits) const; 
  void Purge(); 
 
  virtual void Update(float l_dT) = 0; 
  virtual void HandleEvent(const EntityId&amp; l_entity, 
    const EntityEvent&amp; l_event) = 0; 
protected: 
  ... 
</span><span class="koboSpan" id="kobo.27.2">}; 
</span></pre><p><span class="koboSpan" id="kobo.28.1">Systems have signatures of components they use, as well as a list of entities that meet the requirements of said signatures. </span><span class="koboSpan" id="kobo.28.2">When an entity is being modified by the addition or removal of a component, every system runs a check on it in order to add it to or remove it from itself. </span><span class="koboSpan" id="kobo.28.3">Note the inheritance from the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Observer</span></code><span class="koboSpan" id="kobo.30.1"> class. </span><span class="koboSpan" id="kobo.30.2">This is another pattern that aids in communication between entities and systems.</span></p><p><span class="koboSpan" id="kobo.31.1">An </span><code class="literal"><span class="koboSpan" id="kobo.32.1">Observer</span></code><span class="koboSpan" id="kobo.33.1"> class by itself is simply an interface with one purely virtual method that must be implemented by all derivatives:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">class Observer{ 
public: 
  virtual ~Observer(){} 
  virtual void Notify(const Message&amp; l_message) = 0; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.35.1">It utilizes messages that get sent to all observers of a specific target. </span><span class="koboSpan" id="kobo.35.2">How the derivative of this class reacts to the message is completely dependent on what it is.</span></p><p><span class="koboSpan" id="kobo.36.1">Systems, which come in all shapes and sizes, need to be managed just as entities do. </span><span class="koboSpan" id="kobo.36.2">For that, we have another manager class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">class SystemManager{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.37.2">template&lt;class T&gt; 
  void AddSystem(const System&amp; l_system) { ... </span><span class="koboSpan" id="kobo.37.3">} 
 
  template&lt;class T&gt; 
  T* GetSystem(const System&amp; l_system){ ... </span><span class="koboSpan" id="kobo.37.4">} 
  void AddEvent(const EntityId&amp; l_entity, const EventID&amp; l_event); 
 
  void Update(float l_dT); 
  void HandleEvents(); 
  void Draw(Window* l_wind, unsigned int l_elevation); 
 
  void EntityModified(const EntityId&amp; l_entity, 
    const Bitmask&amp; l_bits); 
  void RemoveEntity(const EntityId&amp; l_entity); 
   
  void PurgeEntities(); 
  void PurgeSystems(); 
private: 
  ... 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.38.1">MessageHandler m_messages;</span></strong></span><span class="koboSpan" id="kobo.39.1"> 
}; 
</span></pre><p><span class="koboSpan" id="kobo.40.1">This too utilizes the factory pattern, in that types of different classes are </span><span class="emphasis"><em><span class="koboSpan" id="kobo.41.1">registered</span></em></span><span class="koboSpan" id="kobo.42.1"> by using templates and lambdas, so that they can be constructed later, simply by using a </span><code class="literal"><span class="koboSpan" id="kobo.43.1">System</span></code><span class="koboSpan" id="kobo.44.1"> data type, which is an </span><code class="literal"><span class="koboSpan" id="kobo.45.1">enum class</span></code><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Starting to see the pattern?</span></p><p><span class="koboSpan" id="kobo.47.1">The system manager owns a data member of type </span><code class="literal"><span class="koboSpan" id="kobo.48.1">MessageHandler</span></code><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">This is another part of the observer pattern. </span><span class="koboSpan" id="kobo.49.3">Let us take a look at what it does:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">class MessageHandler{ 
public: 
  bool Subscribe(const EntityMessage&amp; l_type, 
    Observer* l_observer){ ... </span><span class="koboSpan" id="kobo.50.2">} 
  bool Unsubscribe(const EntityMessage&amp; l_type, 
    Observer* l_observer){ ... </span><span class="koboSpan" id="kobo.50.3">} 
  void Dispatch(const Message&amp; l_msg){ ... </span><span class="koboSpan" id="kobo.50.4">} 
private: 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.51.1"> Subscribtions</span></strong></span><span class="koboSpan" id="kobo.52.1"> m_communicators; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.53.1">Message handlers are simply collections of </span><code class="literal"><span class="koboSpan" id="kobo.54.1">Communicator</span></code><span class="koboSpan" id="kobo.55.1"> objects, as shown here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">using Subscribtions = 
  std::unordered_map&lt;EntityMessage,</span><span class="strong"><strong><span class="koboSpan" id="kobo.57.1">Communicator</span></strong></span><span class="koboSpan" id="kobo.58.1">&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.59.1">Each possible type of </span><code class="literal"><span class="koboSpan" id="kobo.60.1">EntityMessage</span></code><span class="koboSpan" id="kobo.61.1">, which is just another </span><span class="emphasis"><em><span class="koboSpan" id="kobo.62.1">enum class</span></em></span><span class="koboSpan" id="kobo.63.1">, is tied to a communicator that is responsible for sending out a message to all of its observers. </span><span class="koboSpan" id="kobo.63.2">Observers can subscribe to or unsubscribe from a specific message type. </span><span class="koboSpan" id="kobo.63.3">If they are subscribed to said type, they will receive the message when the </span><code class="literal"><span class="koboSpan" id="kobo.64.1">Dispatch</span></code><span class="koboSpan" id="kobo.65.1"> method is invoked.</span></p><p><span class="koboSpan" id="kobo.66.1">The </span><code class="literal"><span class="koboSpan" id="kobo.67.1">Communicator</span></code><span class="koboSpan" id="kobo.68.1"> class itself is fairly simple:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.69.1">class Communicator{ 
public: 
  virtual ~Communicator(){ m_observers.clear(); } 
  bool AddObserver(Observer* l_observer){ ... </span><span class="koboSpan" id="kobo.69.2">} 
  bool RemoveObserver(Observer* l_observer){ ... </span><span class="koboSpan" id="kobo.69.3">} 
  bool HasObserver(const Observer* l_observer) const { ... </span><span class="koboSpan" id="kobo.69.4">} 
  void Broadcast(const Message&amp; l_msg){ ... </span><span class="koboSpan" id="kobo.69.5">} 
private: 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.70.1"> ObserverContainer</span></strong></span><span class="koboSpan" id="kobo.71.1"> m_observers; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.72.1">As you can gather, it supports the addition and removal of observers, and offers a way to broadcast a message to all of them. </span><span class="koboSpan" id="kobo.72.2">The actual container of observers is simply a vector of pointers:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">// Not memory-owning pointers. 
</span><span class="koboSpan" id="kobo.73.2">using ObserverContainer = std::vector&lt;Observer*&gt;; 
</span></pre></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Resource management"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/><span class="koboSpan" id="kobo.1.1">Resource management</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Another vital part of larger projects is an efficient way of managing resources. </span><span class="koboSpan" id="kobo.2.2">Since we're going to have several types of resources, such as textures, fonts, and sounds, it would make sense to have separate managers for all of them. </span><span class="koboSpan" id="kobo.2.3">It's time for a base class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">template&lt;typename Derived, typename T&gt; 
class ResourceManager{ 
public: 
  ResourceManager(const std::string&amp; l_pathsFile){ 
    LoadPaths(l_pathsFile); 
  } 
  virtual ~ResourceManager(){ ... </span><span class="koboSpan" id="kobo.3.2">} 
  T* GetResource(const std::string&amp; l_id){ ... </span><span class="koboSpan" id="kobo.3.3">} 
  std::string GetPath(const std::string&amp; l_id){ ... </span><span class="koboSpan" id="kobo.3.4">} 
  bool RequireResource(const std::string&amp; l_id){ ... </span><span class="koboSpan" id="kobo.3.5">} 
  bool ReleaseResource(const std::string&amp; l_id){ ... </span><span class="koboSpan" id="kobo.3.6">} 
  void PurgeResources(){ ... </span><span class="koboSpan" id="kobo.3.7">} 
protected: 
  bool Load(T* l_resource, const std::string&amp; l_path) { 
    return static_cast&lt;Derived*&gt;(this)-&gt;Load(l_resource, l_path); 
  } 
private: 
  ... 
</span><span class="koboSpan" id="kobo.3.8">}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">The idea behind this particular resource management system is certain segments of code </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">requiring</span></em></span><span class="koboSpan" id="kobo.6.1"> and later </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">releasing</span></em></span><span class="koboSpan" id="kobo.8.1"> a certain resource identifier. </span><span class="koboSpan" id="kobo.8.2">The first time a resource is required it will be loaded into memory and kept there. </span><span class="koboSpan" id="kobo.8.3">Every time it's required after that will simply increment an integer that gets stored with it. </span><span class="koboSpan" id="kobo.8.4">The integer represents how many instances of code rely on this resource being loaded. </span><span class="koboSpan" id="kobo.8.5">Once they are done using the resource, it begins being released, which brings the counter down each time. </span><span class="koboSpan" id="kobo.8.6">When it reaches zero, the resource is removed from memory.</span></p><p><span class="koboSpan" id="kobo.9.1">It's fair to point out that our resource manager base class utilizes the </span><span class="strong"><strong><span class="koboSpan" id="kobo.10.1">Curiously Recurring Template Pattern</span></strong></span><span class="koboSpan" id="kobo.11.1"> for setting up the resource instances after they're created. </span><span class="koboSpan" id="kobo.11.2">As manager classes don't really need to be stored together in the same container anywhere, static polymorphism makes a lot more sense than using virtual methods. </span><span class="koboSpan" id="kobo.11.3">Since textures, fonts, and sounds may be loaded in different ways, each subsequent manager must implement their own version of the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Load</span></code><span class="koboSpan" id="kobo.13.1"> method, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">class TextureManager : public ResourceManager&lt;TextureManager, 
  sf::Texture&gt; 
{ 
public: 
  TextureManager() : ResourceManager("textures.cfg"){} 
 
  bool Load(sf::Texture* l_resource, const std::string&amp; l_path){ 
    return l_resource-&gt;loadFromFile( 
      Utils::GetWorkingDirectory() + l_path); 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.15.1">Each single manager also has its own file, listing the relationships between names of resources and their paths. </span><span class="koboSpan" id="kobo.15.2">For textures, it can look something like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">Intro media/Textures/intro.png 
PlayerSprite media/Textures/PlayerSheet.png 
... 
</span></pre><p><span class="koboSpan" id="kobo.17.1">It simply avoids the need to pass around paths and filenames, by instead relating a name to each resource.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Windows system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/><span class="koboSpan" id="kobo.1.1">Windows system</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There's a lot that goes on behind the scenes when it comes to dealing with open windows. </span><span class="koboSpan" id="kobo.2.2">Everything from window dimensions and titles to keeping track of and dealing with special events is centralized within a designated window class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class Window{
public:
  Window(const std::string&amp; l_title = "Window",
    const sf::Vector2u&amp; l_size = {640,480},
    bool l_useShaders = true);
  ~Window();

  void BeginDraw();
  void EndDraw();

  void Update();

  bool IsDone() const;
  bool IsFullscreen() const;
  bool IsFocused() const;

 </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1"> void ToggleFullscreen(EventDetails* l_details);</span></strong></span><span class="koboSpan" id="kobo.5.1">
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.6.1"> void Close(EventDetails* l_details = nullptr);</span></strong></span><span class="koboSpan" id="kobo.7.1">

  sf::RenderWindow* GetRenderWindow();
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">Renderer* GetRenderer();</span></strong></span><span class="koboSpan" id="kobo.9.1">
  EventManager* GetEventManager();
  sf::Vector2u GetWindowSize();
  sf::FloatRect GetViewSpace();
private:
  ...
</span><span class="koboSpan" id="kobo.9.2">};

</span></pre><p><span class="koboSpan" id="kobo.10.1">Note the two highlighted methods. </span><span class="koboSpan" id="kobo.10.2">They will be used as call-backs in the event manager we'll discuss in the near future. </span><span class="koboSpan" id="kobo.10.3">Also note the return method for an object type </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Renderer</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">It’s a utility class that simply invokes the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">.draw</span></code><span class="koboSpan" id="kobo.14.1"> call on a </span><code class="literal"><span class="koboSpan" id="kobo.15.1">RenderWindow</span></code><span class="koboSpan" id="kobo.16.1">, thus localizing it and making it much easier to use shaders. </span><span class="koboSpan" id="kobo.16.2">More information on that will be revealed in </span><a class="link" href="ch06.html" title="Chapter 6. Adding Some Finishing Touches - Using Shaders"><span class="koboSpan" id="kobo.17.1">Chapter 6</span></a><span class="koboSpan" id="kobo.18.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Adding Some Finishing Touches – Using Shaders</span></em></span><span class="koboSpan" id="kobo.20.1">.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Application states"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/><span class="koboSpan" id="kobo.1.1">Application states</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Another important aspect of a more complex application is keeping track of and managing its states. </span><span class="koboSpan" id="kobo.2.2">Whether the player is in the thick of the game, or simply browsing through the main menu, we want it to be handled seamlessly, and more importantly, be self-contained. </span><span class="koboSpan" id="kobo.2.3">We can start this by first defining different types of states we'll be dealing with:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class StateType { Intro = 1, MainMenu, Game, Loading }; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">For seamless integration, we want each state to behave in a predictable manner. </span><span class="koboSpan" id="kobo.4.2">This means that a state has to adhere to an interface we provide:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class BaseState{ 
friend class StateManager; 
public: 
  BaseState(StateManager* l_stateManager)  
    :m_stateMgr(l_stateManager), m_transparent(false), 
    m_transcendent(false){} 
  virtual ~BaseState(){} 
 
  virtual void OnCreate() = 0; 
  virtual void OnDestroy() = 0; 
 
  virtual void Activate() = 0; 
  virtual void Deactivate() = 0; 
 
  virtual void Update(const sf::Time&amp; l_time) = 0; 
  virtual void Draw() = 0; 
  ... 
  </span><span class="koboSpan" id="kobo.5.2">sf::View&amp; GetView(){ return m_view; } 
  StateManager* GetStateManager(){ return m_stateMgr; } 
protected: 
  StateManager* m_stateMgr; 
  bool m_transparent; 
  bool m_transcendent; 
  sf::View m_view; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">Every state in the game will have its own view that it can alter. </span><span class="koboSpan" id="kobo.6.2">In addition to that, it is given the hooks to implement logic for various different scenarios, such as the state's creation, destruction, activation, deactivation, updating, and rendering. </span><span class="koboSpan" id="kobo.6.3">Lastly, it enables the possibility of being blended with other states during updating and rendering, by providing the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">m_transparent</span></code><span class="koboSpan" id="kobo.8.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.9.1">m_transcendent</span></code><span class="koboSpan" id="kobo.10.1"> flags.</span></p><p><span class="koboSpan" id="kobo.11.1">Managing these states is pretty straightforward:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">class StateManager{ 
public: 
  StateManager(SharedContext* l_shared); 
  ~StateManager(); 
  void Update(const sf::Time&amp; l_time); 
  void Draw(); 
  void ProcessRequests(); 
  SharedContext* GetContext(); 
  bool HasState(const StateType&amp; l_type) const; 
  StateType GetNextToLast() const; 
  void SwitchTo(const StateType&amp; l_type); 
  void Remove(const StateType&amp; l_type); 
  template&lt;class T&gt; 
  T* GetState(const StateType&amp; l_type){ ... </span><span class="koboSpan" id="kobo.12.2">} 
  template&lt;class T&gt; 
  void RegisterState(const StateType&amp; l_type) { ... </span><span class="koboSpan" id="kobo.12.3">} 
  void AddDependent(StateDependent* l_dependent); 
  void RemoveDependent(StateDependent* l_dependent); 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.12.4">State_Loading* m_loading; 
  StateDependents m_dependents; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.13.1">The </span><code class="literal"><span class="koboSpan" id="kobo.14.1">StateManager</span></code><span class="koboSpan" id="kobo.15.1"> class is one of the few classes in the project that utilizes the shared context, since the states themselves may need access to any part of the code base. </span><span class="koboSpan" id="kobo.15.2">It also uses the factory pattern to dynamically create any state that is bound to a state type during runtime.</span></p><p><span class="koboSpan" id="kobo.16.1">In order to keep things simple, we're going to be treating the loading state as a special case, and only allow one instance of it to be alive at all times. </span><span class="koboSpan" id="kobo.16.2">Loading might happen during the transition of any state, so it only makes sense.</span></p><p><span class="koboSpan" id="kobo.17.1">One final thing that's worth noting about the state manager is it's keeping a list of state dependants. </span><span class="koboSpan" id="kobo.17.2">It's simply an STL container of classes that inherit from this interface:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">class StateDependent { 
public: 
  StateDependent() : m_currentState((StateType)0){} 
  virtual ~StateDependent(){} 
  virtual void CreateState(const StateType&amp; l_state){} 
  virtual void ChangeState(const StateType&amp; l_state) = 0; 
  virtual void RemoveState(const StateType&amp; l_state) = 0; 
protected: 
  void SetState(const StateType&amp; l_state){m_currentState=l_state;} 
  StateType m_currentState; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.19.1">Because classes that deal with things such as sounds, GUI elements, or entity management need to support different states, they must also define what happens inside them as a state is created, changed, or removed, in order to properly allocate/de-allocate resources, stop updating data that is not in the same state, and so on.</span></p><div class="section" title="Loading state"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec9"/><span class="koboSpan" id="kobo.20.1">Loading state</span></h2></div></div></div><p><span class="koboSpan" id="kobo.21.1">So, how exactly are we going to implement this loading state? </span><span class="koboSpan" id="kobo.21.2">Well, for flexibility and easy progress tracking by means of rendering fancy loading bars, threads are going to prove invaluable. </span><span class="koboSpan" id="kobo.21.3">Data that needs to be loaded into memory can be loaded in a separate thread, while the loading state itself continues to get updated and rendered in order to show us that things are indeed happening. </span><span class="koboSpan" id="kobo.21.4">Just knowing that the application did not hang on us should create a warm and fuzzy feeling.</span></p><p><span class="koboSpan" id="kobo.22.1">First, let us implement the very basics of this system by providing an interface any threaded worker can use:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">class Worker { 
public: 
  Worker() : m_thread(&amp;Worker::Work, this), m_done(false), 
    m_started(false) {} 
  void Begin() { 
    if(m_done || m_started) { return; } 
    m_started = true; 
    m_thread.launch(); 
  } 
  bool IsDone() const { return m_done; } 
  bool HasStarted() const { return m_started; } 
protected: 
  void Done() { m_done = true; } 
  virtual void Work() = 0; 
  sf::Thread m_thread; 
  bool m_done; 
  bool m_started; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.24.1">It has its own thread, which is bound to the pure virtual method called </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Work</span></code><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">The thread is launched whenever the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Begin()</span></code><span class="koboSpan" id="kobo.28.1"> method is invoked. </span><span class="koboSpan" id="kobo.28.2">In order to protect the data from being accessed from multiple threads at once, a </span><code class="literal"><span class="koboSpan" id="kobo.29.1">sf::Mutex</span></code><span class="koboSpan" id="kobo.30.1"> class is used by creating a lock during sensitive calls. </span><span class="koboSpan" id="kobo.30.2">Everything else within this very basic class is simply there to provide information to the outside world about the worker’s state.</span></p></div><div class="section" title="File loader"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/><span class="koboSpan" id="kobo.31.1">File loader</span></h2></div></div></div><p><span class="koboSpan" id="kobo.32.1">With threads out of the way, we can focus on actually loading some files now. </span><span class="koboSpan" id="kobo.32.2">This method is going to focus on working with text files. </span><span class="koboSpan" id="kobo.32.3">However, using binary formats should work in pretty much the exact same way, minus all the text processing.</span></p><p><span class="koboSpan" id="kobo.33.1">Let's take a look at the base class for any file loading class we can think of:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">using LoaderPaths = std::vector&lt;std::pair&lt;std::string, size_t&gt;&gt;; 
 
class FileLoader : public Worker { 
public: 
  FileLoader(); 
  void AddFile(const std::string&amp; l_file);
  virtual void SaveToFile(const std::string&amp; l_file);
  
  size_t GetTotalLines() const; 
  size_t GetCurrentLine() const; 
protected: 
  virtual bool ProcessLine(std::stringstream&amp; l_stream) = 0; 
  virtual void ResetForNextFile(); 
  void Work(); 
  void CountFileLines(); 
 
  LoaderPaths m_files; 
  size_t m_totalLines; 
  size_t m_currentLine; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.35.1">It's a distinct possibility that two or more files may need to be loaded at some point. </span><span class="koboSpan" id="kobo.35.2">The </span><code class="literal"><span class="koboSpan" id="kobo.36.1">FileLoader</span></code><span class="koboSpan" id="kobo.37.1"> class keeps track of all of the paths that get added to it, along with a number that represents the number of lines within that file. </span><span class="koboSpan" id="kobo.37.2">This is useful for determining the amount of progress that has been made while loading. </span><span class="koboSpan" id="kobo.37.3">In addition to the line count for each individual file, a total line count is also kept track of.</span></p><p><span class="koboSpan" id="kobo.38.1">This class provides a single purely virtual method, called </span><code class="literal"><span class="koboSpan" id="kobo.39.1">ProcessLine</span></code><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">It will be the way derivatives can define exactly how the file is loaded and processed.</span></p><p><span class="koboSpan" id="kobo.41.1">First, let us get the basic stuff out of the way:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">FileLoader::FileLoader() : m_totalLines(0), m_currentLine(0) {}
void FileLoader::AddFile(const std::string&amp; l_file) {
  m_files.emplace_back(l_file, 0);
}
size_t FileLoader::GetTotalLines()const {
  sf::Lock lock(m_mutex);
  return m_totalLines;
}
size_t FileLoader::GetCurrentLine()const {
  sf::Lock lock(m_mutex);
  return m_currentLine;
}
void FileLoader::SaveToFile(const std::string&amp; l_file) {}
void FileLoader::ResetForNextFile(){}</span></pre><p><span class="koboSpan" id="kobo.43.1">The </span><code class="literal"><span class="koboSpan" id="kobo.44.1">ResetForNextFile()</span></code><span class="koboSpan" id="kobo.45.1"> virtual method is optional to implement, but can be used in order to clear the state of some internal data that needs to exist while a file is being loaded. </span><span class="koboSpan" id="kobo.45.2">Since file loaders that implement this class will only have the ability to process one line at a time inside a single method, any temporary data that would normally be stored as a local variable within that method would instead need to go somewhere else. </span><span class="koboSpan" id="kobo.45.3">This is why we must make sure that there is actually a way to know when we're done with one file and start loading another, as well as to perform some sort of action, if necessary.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note4"/><span class="koboSpan" id="kobo.46.1">Note</span></h3><p><span class="koboSpan" id="kobo.47.1">Note the mutex locks in the two getter methods above. </span><span class="koboSpan" id="kobo.47.2">They’re there to make sure those variables aren’t written to and read from at the same time.</span></p></div></div><p><span class="koboSpan" id="kobo.48.1">Now, let's get into the code that is going to be executed in a different thread:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">void FileLoader::Work() { 
  CountFileLines(); 
  if (!m_totalLines) { </span><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">Done();</span></strong></span><span class="koboSpan" id="kobo.51.1"> return; } 
  for (auto&amp; path : m_files) { 
    ResetForNextFile(); 
    std::ifstream file(path.first); 
    std::string line; 
    std::string name; 
    auto linesLeft = path.second; 
    while (std::getline(file, line)) { 
      { 
        sf::Lock lock(m_mutex); 
        ++m_currentLine; 
        --linesLeft; 
      } 
      if (line[0] == '|') { continue; } 
      std::stringstream keystream(line); 
      if (!ProcessLine(keystream)) { 
        std::cout &lt;&lt; 
          "File loader terminated due to an internal error." 
          </span><span class="koboSpan" id="kobo.51.2">&lt;&lt; std::endl; 
        { 
          sf::Lock lock(m_mutex); 
          m_currentLine += linesLeft; 
        } 
        break; 
      } 
    } 
    file.close(); 
  } 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1"> Done();</span></strong></span><span class="koboSpan" id="kobo.53.1"> 
} 
</span></pre><p><span class="koboSpan" id="kobo.54.1">A private method for counting all the lines in whatever files are about to be loaded is called first. </span><span class="koboSpan" id="kobo.54.2">If, for any reason, the total line count is zero, there is no purpose in proceeding, so the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Worker::Done()</span></code><span class="koboSpan" id="kobo.56.1"> method is invoked just before a return. </span><span class="koboSpan" id="kobo.56.2">This little bit of code is really easy to forget, but is extremely important in order for this to work. </span><span class="koboSpan" id="kobo.56.3">All it does is set the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">m_done</span></code><span class="koboSpan" id="kobo.58.1"> flag of the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Worker</span></code><span class="koboSpan" id="kobo.60.1"> base class to </span><code class="literal"><span class="koboSpan" id="kobo.61.1">true</span></code><span class="koboSpan" id="kobo.62.1">, which lets outside code know that the process is finished. </span><span class="koboSpan" id="kobo.62.2">Since there is currently no way to check if an SFML thread is actually finished, this is pretty much the only option.</span></p><p><span class="koboSpan" id="kobo.63.1">We begin looping through different files that need to get loaded and invoke the reset method before work begins. </span><span class="koboSpan" id="kobo.63.2">Note the lack of checking as we're attempting to open a file. </span><span class="koboSpan" id="kobo.63.3">This will be explained when we cover the next method.</span></p><p><span class="koboSpan" id="kobo.64.1">As each line of the file is being read, it's important to make sure that all the line count information is updated. </span><span class="koboSpan" id="kobo.64.2">A temporary lock for the current thread is established, in order to prevent two threads from accessing the line count as its modified. </span><span class="koboSpan" id="kobo.64.3">In addition to that, lines that start with a pipe symbol are excluded, since this is our standard comment pragma.</span></p><p><span class="koboSpan" id="kobo.65.1">Finally, a </span><code class="literal"><span class="koboSpan" id="kobo.66.1">stringstream</span></code><span class="koboSpan" id="kobo.67.1"> object is constructed for the current line, and passed into the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">ProcessLine()</span></code><span class="koboSpan" id="kobo.69.1"> method. </span><span class="koboSpan" id="kobo.69.2">For extra points, it returns a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">boolean</span></em></span><span class="koboSpan" id="kobo.71.1"> value that can signal an error and stop the current file from being processed any further. </span><span class="koboSpan" id="kobo.71.2">If that happens, the remaining lines within that specific file are added to the total count, and the loop is broken.</span></p><p><span class="koboSpan" id="kobo.72.1">The final piece of the puzzle is this chunk of code, responsible for verifying file validity and determining the amount of work ahead of us:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">void FileLoader::CountFileLines() {
  m_totalLines = 0;
  m_currentLine = 0;
  for (auto path = m_files.begin(); path != m_files.end();) {
    if (path-&gt;first.empty()) { m_files.erase(path); continue; }
    std::ifstream file(path-&gt;first);
    if (!file.is_open()) {
      std::cerr &lt;&lt; “Failed to load file: “ &lt;&lt; path-&gt;first
        &lt;&lt; std::endl;
      m_files.erase(path);
      continue;
    }
    file.unsetf(std::ios_base::skipws);
    {
      sf::Lock lock(m_mutex);
      path-&gt;second = static_cast&lt;size_t&gt;(std::count(
        std::istreambuf_iterator&lt;char&gt;(file),
        std::istreambuf_iterator&lt;char&gt;(), ‘\n’));
      m_totalLines += path-&gt;second;
    }
    ++path;
    file.close();
  }
}</span></pre><p><span class="koboSpan" id="kobo.74.1">After initial zero values for line counts are set up, all added paths are iterated over and checked. </span><span class="koboSpan" id="kobo.74.2">We first trim out any paths that are empty. </span><span class="koboSpan" id="kobo.74.3">Each path is then attempted to be opened, and erased if that operation fails. </span><span class="koboSpan" id="kobo.74.4">Finally, in order to achieve accurate results, the file input stream is ordered to ignore empty lines. </span><span class="koboSpan" id="kobo.74.5">After a lock is established, </span><code class="literal"><span class="koboSpan" id="kobo.75.1">std::count</span></code><span class="koboSpan" id="kobo.76.1"> is used to count the amount of lines in a file. </span><span class="koboSpan" id="kobo.76.2">That number is then added to the amount of total lines we have, the path iterator is advanced, and the file is properly closed.</span></p><p><span class="koboSpan" id="kobo.77.1">Since this method eliminates files that were either non-existent or unable to be opened, there is no reason to check for that again anywhere else.</span></p></div><div class="section" title="Implementing the loading state"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/><span class="koboSpan" id="kobo.78.1">Implementing the loading state</span></h2></div></div></div><p><span class="koboSpan" id="kobo.79.1">Everything is now in place in order for us to successfully implement the loading state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.80.1">using LoaderContainer = std::vector&lt;FileLoader*&gt;; 
 
class State_Loading : public BaseState { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.80.2">void AddLoader(FileLoader* l_loader); 
  bool HasWork() const; 
  void SetManualContinue(bool l_continue); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.81.1">void Proceed(EventDetails* l_details);</span></strong></span><span class="koboSpan" id="kobo.82.1"> 
private: 
  void UpdateText(const std::string&amp; l_text, float l_percentage); 
  float CalculatePercentage(); 
  LoaderContainer m_loaders; 
  sf::Text m_text; 
  sf::RectangleShape m_rect; 
  unsigned short m_percentage; 
  size_t m_originalWork; 
  bool m_manualContinue; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.83.1">The state itself will keep a vector of pointers to different file loader classes, which will have lists of their own files respectively. </span><span class="koboSpan" id="kobo.83.2">It also provides a way for these objects to be added. </span><span class="koboSpan" id="kobo.83.3">Also, note the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">Proceed()</span></code><span class="koboSpan" id="kobo.85.1"> method. </span><span class="koboSpan" id="kobo.85.2">This is another call-back that will be used in the event manager we're about to cover soon.</span></p><p><span class="koboSpan" id="kobo.86.1">For the visual portion, we will be using the bare essentials of graphics: a bit of text for the progress percentage, and a rectangle shape that represents a loading bar.</span></p><p><span class="koboSpan" id="kobo.87.1">Let's take a look at all of the setup this class will do once it's constructed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.88.1">void State_Loading::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  context-&gt;m_fontManager-&gt;RequireResource("Main"); 
  m_text.setFont(*context-&gt;m_fontManager-&gt;GetResource("Main")); 
  m_text.setCharacterSize(14); 
  m_text.setStyle(sf::Text::Bold); 
 
  sf::Vector2u windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
 
  m_rect.setFillColor(sf::Color(0, 150, 0, 255)); 
  m_rect.setSize(sf::Vector2f(0.f, 32.f)); 
  m_rect.setOrigin(0.f, 16.f); 
  m_rect.setPosition(0.f, windowSize.y / 2.f); 
 
  EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  evMgr-&gt;AddCallback(StateType::Loading, "Key_Space", 
    &amp;State_Loading::Proceed, this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.89.1">First, a font manager is obtained through the shared context. </span><span class="koboSpan" id="kobo.89.2">The font with a name </span><code class="literal"><span class="koboSpan" id="kobo.90.1">"Main"</span></code><span class="koboSpan" id="kobo.91.1"> is required and used to set up the text instance. </span><span class="koboSpan" id="kobo.91.2">After all of the visual bits are set up, the event manager is used to register a call-back for the loading state. </span><span class="koboSpan" id="kobo.91.3">This will be covered soon, but it's quite easy to deduce what's happening by simply looking at the arguments. </span><span class="koboSpan" id="kobo.91.4">Whenever the spacebar is pressed, the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">Proceed</span></code><span class="koboSpan" id="kobo.93.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">State_Loading</span></code><span class="koboSpan" id="kobo.95.1"> class is going to be invoked. </span><span class="koboSpan" id="kobo.95.2">The actual instance of the class is passed in as the last argument.</span></p><p><span class="koboSpan" id="kobo.96.1">Remember that, by design, the resources we require must also be released. </span><span class="koboSpan" id="kobo.96.2">A perfect place to do that for the loading state is exactly as it is destroyed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.97.1">void State_Loading::OnDestroy() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::Loading, "Key_Space"); 
  context-&gt;m_fontManager-&gt;ReleaseResource("Main"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.98.1">In addition to the font being released, the call-back for the spacebar is also removed.</span></p><p><span class="koboSpan" id="kobo.99.1">Next, let us actually write some code that's going to bring the pieces together into a cohesive, functional whole:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.100.1">void State_Loading::Update(const sf::Time&amp; l_time) 
  if (m_loaders.empty()) {
    if (!m_manualContinue) { Proceed(nullptr); }
    return;
  }
  auto windowSize = m_stateMgr-&gt;GetContext()-&gt;
    m_wind-&gt;GetRenderWindow()-&gt;getSize();
  if (m_loaders.back()-&gt;IsDone()) {
    m_loaders.back()-&gt;OnRemove();
    m_loaders.pop_back();
    if (m_loaders.empty()) {
      m_rect.setSize(sf::Vector2f(
        static_cast&lt;float&gt;(windowSize.x), 16.f));
      UpdateText(".Press space to continue.", 100.f);
      return;
    }
  }
  if (!m_loaders.back()-&gt;HasStarted()) {
    m_loaders.back()-&gt;Begin();
  }

  auto percentage = CalculatePercentage();
  UpdateText("", percentage);
  m_rect.setSize(sf::Vector2f(
    (windowSize.x / 100) * percentage, 16.f));
}</span></pre><p><span class="koboSpan" id="kobo.101.1">The first check is used to determine if all of the file loaders have been removed from the vector due to finishing. </span><span class="koboSpan" id="kobo.101.2">The </span><code class="literal"><span class="koboSpan" id="kobo.102.1">m_manualContinue</span></code><span class="koboSpan" id="kobo.103.1"> flag is used to let the loading state know if it should wait for the spacebar to be pressed, or if it should just dispel itself automatically. </span><span class="koboSpan" id="kobo.103.2">If, however, we still have some loaders in the vector, the top one is checked for having concluded its work. </span><span class="koboSpan" id="kobo.103.3">Given that's the case, the loader is popped and the vector is checked again for being empty, which would require us to update the loading text to represent completion.</span></p><p><span class="koboSpan" id="kobo.104.1">To keep this process fully automated, we need to make sure that after the top file loader is removed, the next one is started, which is where the following check comes in. </span><span class="koboSpan" id="kobo.104.2">Finally, the progress percentage is calculated, and the loading text is updated to represent that value, just before the loading bar's size is adjusted to visually aid us.</span></p><p><span class="koboSpan" id="kobo.105.1">Drawing is going to be extremely straightforward for this state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.106.1">void State_Loading::Draw() { 
  sf::RenderWindow* wind = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow(); 
  wind-&gt;draw(m_rect); 
  wind-&gt;draw(m_text); 
} 
</span></pre><p><span class="koboSpan" id="kobo.107.1">The render window is first obtained through the shared context, and then used to draw the text and rectangle shape that represent the loading bar together.</span></p><p><span class="koboSpan" id="kobo.108.1">The </span><code class="literal"><span class="koboSpan" id="kobo.109.1">Proceed</span></code><span class="koboSpan" id="kobo.110.1"> call-back method is equally straightforward:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.111.1">void State_Loading::Proceed(EventDetails* l_details){ 
  if (!m_loaders.empty()) { return; } 
  m_stateMgr-&gt;SwitchTo(m_stateMgr-&gt;GetNextToLast()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.112.1">It has to make a check first, to make sure that we don't switch states before all the work is through. </span><span class="koboSpan" id="kobo.112.2">If that's not the case, the state manager is used to switch to a state that was created </span><span class="strong"><strong><span class="koboSpan" id="kobo.113.1">before</span></strong></span><span class="koboSpan" id="kobo.114.1"> the loading commenced.</span></p><p><span class="koboSpan" id="kobo.115.1">All of the other loading state logic pretty much consists of single lines of code for each method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.116.1">void State_Loading::AddLoader(FileLoader* l_loader) {
 m_loaders.emplace_back(l_loader);
  l_loader-&gt;OnAdd();
}
bool State_Loading::HasWork() const { return !m_loaders.empty(); }
void State_Loading::SetManualContinue(bool l_continue) {
  m_manualContinue = l_continue;
}
void State_Loading::Activate(){m_originalWork = m_loaders.size();}</span></pre><p><span class="koboSpan" id="kobo.117.1">Although this looks fairly simple, the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Activate()</span></code><span class="koboSpan" id="kobo.119.1"> method holds a fairly important role. </span><span class="koboSpan" id="kobo.119.2">Since the loading state is treated as a special case here, one thing has to be kept in mind: it is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.120.1">never</span></em></span><span class="koboSpan" id="kobo.121.1"> going to be removed before the application is closed. </span><span class="koboSpan" id="kobo.121.2">This means that every time we want to use it again, some things have to be reset. </span><span class="koboSpan" id="kobo.121.3">In this case, it's the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">m_originalWork</span></code><span class="koboSpan" id="kobo.123.1"> data member, that's simply the count of all the loader classes. </span><span class="koboSpan" id="kobo.123.2">This number is used to calculate the progress percentage accurately, and the best place to reset it is inside the method, which gets called every time the state is activated again.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Managing application events"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/><span class="koboSpan" id="kobo.1.1">Managing application events</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Event management is one of the cornerstones that provide us with fluid control experience. </span><span class="koboSpan" id="kobo.2.2">Any key presses, window changes, or even custom events created by the GUI system we'll be covering later are going to be processed and handled by this system. </span><span class="koboSpan" id="kobo.2.3">In order to effectively unify event information coming from different sources, we first must unify their types by enumerating them correctly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class EventType { 
  KeyDown = sf::Event::KeyPressed, 
  KeyUp = sf::Event::KeyReleased, 
  MButtonDown = sf::Event::MouseButtonPressed, 
  MButtonUp = sf::Event::MouseButtonReleased, 
  MouseWheel = sf::Event::MouseWheelMoved, 
  WindowResized = sf::Event::Resized, 
  GainedFocus = sf::Event::GainedFocus, 
  LostFocus = sf::Event::LostFocus, 
  MouseEntered = sf::Event::MouseEntered, 
  MouseLeft = sf::Event::MouseLeft, 
  Closed = sf::Event::Closed, 
  TextEntered = sf::Event::TextEntered, 
  Keyboard = sf::Event::Count + 1, Mouse, Joystick, 
  GUI_Click, GUI_Release, GUI_Hover, GUI_Leave 
}; 
 
enum class EventInfoType { Normal, GUI }; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">SFML events come first, since they are the only ones following a strict enumeration scheme. </span><span class="koboSpan" id="kobo.4.2">They are then followed by the live SFML input types and four GUI events. </span><span class="koboSpan" id="kobo.4.3">We also enumerate event information types, which are going to be used inside this structure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">struct EventInfo { 
  EventInfo() : m_type(EventInfoType::Normal), m_code(0) {} 
  EventInfo(int l_event) : m_type(EventInfoType::Normal), 
    m_code(l_event) {} 
  EventInfo(const GUI_Event&amp; l_guiEvent): 
    m_type(EventInfoType::GUI), m_gui(l_guiEvent) {} 
  EventInfo(const EventInfoType&amp; l_type) { 
    if (m_type == EventInfoType::GUI) { DestroyGUIStrings(); } 
    m_type = l_type; 
    if (m_type == EventInfoType::GUI){ CreateGUIStrings("", ""); } 
  } 
 
  EventInfo(const EventInfo&amp; l_rhs) { Move(l_rhs); } 
 
  EventInfo&amp; operator=(const EventInfo&amp; l_rhs) { 
    if (&amp;l_rhs != this) { Move(l_rhs); } 
    return *this; 
  } 
 
  ~EventInfo() { 
    if (m_type == EventInfoType::GUI) { DestroyGUIStrings(); } 
  } 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.6.1">union { 
    int m_code; 
    GUI_Event m_gui; 
  };</span></strong></span><span class="koboSpan" id="kobo.7.1"> 
   
  EventInfoType m_type; 
private: 
  void Move(const EventInfo&amp; l_rhs) { 
    if (m_type == EventInfoType::GUI) { DestroyGUIStrings(); } 
    m_type = l_rhs.m_type; 
    if (m_type == EventInfoType::Normal){ m_code = l_rhs.m_code; } 
    else { 
      CreateGUIStrings(l_rhs.m_gui.m_interface, 
        l_rhs.m_gui.m_element); 
      m_gui = l_rhs.m_gui; 
    } 
  } 
 
  void DestroyGUIStrings() { 
    m_gui.m_interface.~basic_string(); 
    m_gui.m_element.~basic_string(); 
  } 
 
  void CreateGUIStrings(const std::string&amp; l_interface, 
    const std::string&amp; l_element) 
  { 
    new (&amp;m_gui.m_interface) std::string(l_interface); 
    new (&amp;m_gui.m_element) std::string(l_element); 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">Because we care about more than just the event type that took place, there needs to be a good way of storing additional data that comes with it. </span><span class="koboSpan" id="kobo.8.2">C++11's unrestricted union is a perfect candidate for that. </span><span class="koboSpan" id="kobo.8.3">The only downside is that now we have to worry about manually managing the data inside the union, which comes complete with data allocations and direct invocation of destructors.</span></p><p><span class="koboSpan" id="kobo.9.1">As event call-backs are being invoked, it's a good idea to provide them with the actual event information. </span><span class="koboSpan" id="kobo.9.2">Because it's possible to construct more complex requirements for specific call-backs, we can't get away with unions this time. </span><span class="koboSpan" id="kobo.9.3">Any possible information that may be relevant needs to be stored, and that's precisely what is done here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">struct EventDetails { 
  EventDetails(const std::string&amp; l_bindName): m_name(l_bindName){ 
    Clear(); 
  } 
   
  std::string m_name; 
  sf::Vector2i m_size; 
  sf::Uint32 m_textEntered; 
  sf::Vector2i m_mouse; 
  int m_mouseWheelDelta; 
  int m_keyCode; // Single key code. 
 
  </span><span class="koboSpan" id="kobo.10.2">std::string m_guiInterface; 
  std::string m_guiElement; 
  GUI_EventType m_guiEvent; 
 
  void Clear() { ... </span><span class="koboSpan" id="kobo.10.3">} 
}; 
</span></pre><p><span class="koboSpan" id="kobo.11.1">This structure is filled with every single bit of information that is available as the events are processed, and then passed as an argument to the call-back that gets invoked. </span><span class="koboSpan" id="kobo.11.2">It also provides a </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Clear()</span></code><span class="koboSpan" id="kobo.13.1"> method, because instead of being created only for the time during the call-back, it lives inside the binding structure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">using Events = std::vector&lt;std::pair&lt;EventType, EventInfo&gt;&gt;; 
 
struct Binding { 
  Binding(const std::string&amp; l_name) : m_name(l_name), 
    m_details(l_name), c(0) {} 
  void BindEvent(EventType l_type, EventInfo l_info = EventInfo()) 
  { ... </span><span class="koboSpan" id="kobo.14.2">} 
 
  Events m_events; 
  std::string m_name; 
  int c; // Count of events that are "happening". 
 
  </span><span class="koboSpan" id="kobo.14.3">EventDetails m_details; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.15.1">A binding is what actually allows events to be grouped together in order to form more complex requirements. </span><span class="koboSpan" id="kobo.15.2">Think of it in terms of multiple keys needing to be pressed at once in order to perform an action, such as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Ctrl</span></em></span><span class="koboSpan" id="kobo.17.1"> + </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">C</span></em></span><span class="koboSpan" id="kobo.19.1"> for copying a piece of text. </span><span class="koboSpan" id="kobo.19.2">A binding for that type of situation would have two events it's waiting for: the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">Ctrl</span></em></span><span class="koboSpan" id="kobo.21.1"> key and the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">C</span></em></span><span class="koboSpan" id="kobo.23.1"> key.</span></p><div class="section" title="Event manager interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/><span class="koboSpan" id="kobo.24.1">Event manager interface</span></h2></div></div></div><p><span class="koboSpan" id="kobo.25.1">With all of the key pieces being covered, all that's left is actually managing everything properly. </span><span class="koboSpan" id="kobo.25.2">Let's start with some type definitions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">using Bindings = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;Binding&gt;&gt;; 
using CallbackContainer = std::unordered_map&lt;std::string, 
  std::function&lt;void(EventDetails*)&gt;&gt;; 
enum class StateType; 
using Callbacks = std::unordered_map&lt;StateType, 
  CallbackContainer&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.27.1">All bindings are attached to specific names that get loaded from a </span><code class="literal"><span class="koboSpan" id="kobo.28.1">keys.cfg</span></code><span class="koboSpan" id="kobo.29.1"> file when the application is started. </span><span class="koboSpan" id="kobo.29.2">It follows a basic format like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">Window_close 0:0 
Fullscreen_toggle 5:89 
Intro_Continue 5:57 
Mouse_Left 9:0 
</span></pre><p><span class="koboSpan" id="kobo.31.1">Of course these are very basic examples. </span><span class="koboSpan" id="kobo.31.2">More complex bindings would have multiple events separated by white spaces.</span></p><p><span class="koboSpan" id="kobo.32.1">Call-backs are also stored in an </span><span class="emphasis"><em><span class="koboSpan" id="kobo.33.1">unordered map</span></em></span><span class="koboSpan" id="kobo.34.1">, as well as tied to the name of a binding that they're watching. </span><span class="koboSpan" id="kobo.34.2">The actual call-back containers are then grouped by state, in order to avoid multiple functions/methods getting called when similar keys are pressed. </span><span class="koboSpan" id="kobo.34.3">As you can imagine, the event manager is going to be inheriting from a </span><code class="literal"><span class="koboSpan" id="kobo.35.1">StateDependent</span></code><span class="koboSpan" id="kobo.36.1"> class for this very reason:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">class EventManager : public StateDependent{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.37.2">bool AddBinding(std::unique_ptr&lt;Binding&gt; l_binding); 
  bool RemoveBinding(std::string l_name); 
  void ChangeState(const StateType&amp; l_state); 
  void RemoveState(const StateType&amp; l_state); 
  void SetFocus(bool l_focus); 
   
  template&lt;class T&gt; 
  bool AddCallback(const StateType&amp; l_state, 
    const std::string&amp; l_name,  
    void(T::*l_func)(EventDetails*), T* l_instance) 
  { ... </span><span class="koboSpan" id="kobo.37.3">} 
   
  template&lt;class T&gt; 
  bool AddCallback(const std::string&amp; l_name, 
    void(T::*l_func)(EventDetails*), T* l_instance) 
  { ... </span><span class="koboSpan" id="kobo.37.4">} 
 
  bool RemoveCallback(const StateType&amp; l_state, 
    const std::string&amp; l_name){ ... </span><span class="koboSpan" id="kobo.37.5">} 
  void HandleEvent(sf::Event&amp; l_event); 
  void HandleEvent(GUI_Event&amp; l_event); 
  void Update(); 
  sf::Vector2i GetMousePos(sf::RenderWindow* l_wind = nullptr) 
    const { ... </span><span class="koboSpan" id="kobo.37.6">} 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.37.7">Bindings m_bindings; 
  Callbacks m_callbacks; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.38.1">Once again, this is quite simple. </span><span class="koboSpan" id="kobo.38.2">Since this is a state-dependent class, it needs to implement the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">ChangeState()</span></code><span class="koboSpan" id="kobo.40.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.41.1">RemoveState()</span></code><span class="koboSpan" id="kobo.42.1"> methods. </span><span class="koboSpan" id="kobo.42.2">It also keeps track of when the window focus is obtained/lost, in order to avoid polling events of minimized/unfocused windows. </span><span class="koboSpan" id="kobo.42.3">Two versions of </span><code class="literal"><span class="koboSpan" id="kobo.43.1">AddCallback</span></code><span class="koboSpan" id="kobo.44.1"> are provided: one for a specified state, and one for the current state. </span><span class="koboSpan" id="kobo.44.2">Separate </span><code class="literal"><span class="koboSpan" id="kobo.45.1">HandleEvent()</span></code><span class="koboSpan" id="kobo.46.1"> methods are also available for every event type supported. </span><span class="koboSpan" id="kobo.46.2">So far, we only have two: SFML events, and GUI events. </span><span class="koboSpan" id="kobo.46.3">The latter is going to be used in the upcoming section.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Use of graphical user interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/><span class="koboSpan" id="kobo.1.1">Use of graphical user interfaces</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">A friendly way of interfacing with applications in a day and age where computers are basically a necessity inside every household is a must. </span><span class="koboSpan" id="kobo.2.2">The entire subject of GUIs could fill multiple books by itself, so for the sake of keeping this simple, we are only going to scratch the surface of what we have to work with:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class GUI_Manager : public StateDependent{ 
  friend class GUI_Interface; 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">bool AddInterface(const StateType&amp; l_state, 
    const std::string&amp; l_name); 
  bool AddInterface(const std::string&amp; l_name); 
  GUI_Interface* GetInterface(const StateType&amp; l_state, 
    const std::string&amp; l_name); 
  GUI_Interface* GetInterface(const std::string&amp; l_name); 
  bool RemoveInterface(const StateType&amp; l_state, 
    const std::string&amp; l_name); 
  bool RemoveInterface(const std::string&amp; l_name); 
  bool LoadInterface(const StateType&amp; l_state, 
    const std::string&amp; l_interface, const std::string&amp; l_name); 
  bool LoadInterface(const std::string&amp; l_interface, 
    const std::string&amp; l_name); 
  void ChangeState(const StateType&amp; l_state); 
  void RemoveState(const StateType&amp; l_state); 
  SharedContext* GetContext() const; 
  void DefocusAllInterfaces(); 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1"> void HandleClick(EventDetails* l_details); 
  void HandleRelease(EventDetails* l_details); 
  void HandleTextEntered(EventDetails* l_details);</span></strong></span><span class="koboSpan" id="kobo.5.1"> 
  void AddEvent(GUI_Event l_event); 
  bool PollEvent(GUI_Event&amp; l_event); 
  void Update(float l_dT); 
  void Render(sf::RenderWindow* l_wind); 
  template&lt;class T&gt; 
  void RegisterElement(const GUI_ElementType&amp; l_id){ ... </span><span class="koboSpan" id="kobo.5.2">} 
private: 
  ... 
</span><span class="koboSpan" id="kobo.5.3">}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">Interface management, quite predictably, is also dependent on application states. </span><span class="koboSpan" id="kobo.6.2">The interfaces themselves are also assigned names, which is how they are loaded and stored. </span><span class="koboSpan" id="kobo.6.3">Mouse input, as well as text enter events, are both utilized in making the GUI system work, which is why this class actually uses the event manager and registers three call-backs with it. </span><span class="koboSpan" id="kobo.6.4">Not unlike other classes we have discussed, it also uses the factory method, in order to be able to dynamically create different types of elements that populate our interfaces.</span></p><p><span class="koboSpan" id="kobo.7.1">Interfaces are described as groups of elements, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">Interface MainMenu MainMenu.style 0 0 Immovable NoTitle "Main menu" 
Element Label Title 100 0 MainMenuTitle.style "Main menu:" 
Element Label Play 0 32 MainMenuLabel.style "PLAY" 
Element Label Credits 0 68 MainMenuLabel.style "CREDITS" 
Element Label Quit 0 104 MainMenuLabel.style "EXIT" 
</span></pre><p><span class="koboSpan" id="kobo.9.1">Each element also supports styles for the three different states it can be in: neutral, hovered, and clicked. </span><span class="koboSpan" id="kobo.9.2">A single style file describes what an element would look like under all of these conditions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">State Neutral 
Size 300 32 
BgColor 255 0 0 255 
TextColor 255 255 255 255 
TextSize 14 
Font Main 
TextPadding 150 16 
TextOriginCenter 
/State 
 
State Hover 
BgColor 255 100 0 255 
/State 
 
State Clicked 
BgColor 255 150 0 255 
/State 
</span></pre><p><span class="koboSpan" id="kobo.11.1">The </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Neutral</span></code><span class="koboSpan" id="kobo.13.1"> style serves as a base for the other two, which is why they only define attributes that are different from it. </span><span class="koboSpan" id="kobo.13.2">Using this model, interfaces of great complexity can be constructed and customized to do almost anything.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Representing a 2D map"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/><span class="koboSpan" id="kobo.1.1">Representing a 2D map</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Maps are another crucial part of having a decently complex game. </span><span class="koboSpan" id="kobo.2.2">For our purposes, we're going to be representing 2D maps that support different layers in order to fake 3D depth:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class Map : public FileLoader{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">Tile* GetTile(unsigned int l_x, unsigned int l_y, 
    unsigned int l_layer); 
  TileInfo* GetDefaultTile(); 
  TileSet* GetTileSet(); 
  unsigned int GetTileSize()const; 
  sf::Vector2u GetMapSize()const; 
  sf::Vector2f GetPlayerStart()const; 
  int GetPlayerId()const; 
  void PurgeMap(); 
  void AddLoadee(MapLoadee* l_loadee); 
  void RemoveLoadee(MapLoadee* l_loadee); 
  void Update(float l_dT); 
  void Draw(unsigned int l_layer); 
protected: 
  bool ProcessLine(std::stringstream&amp; l_stream); 
  ... 
</span><span class="koboSpan" id="kobo.3.3">}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">As you can see, this class is actually inheriting from the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">FileLoader</span></code><span class="koboSpan" id="kobo.6.1">, which we covered earlier. </span><span class="koboSpan" id="kobo.6.2">It also supports something that's referred to as </span><code class="literal"><span class="koboSpan" id="kobo.7.1">MapLoadee*</span></code><span class="koboSpan" id="kobo.8.1">, which are simply classes that will store certain data inside map files, and need to be notified when such data is encountered during the loading process. </span><span class="koboSpan" id="kobo.8.2">It's simply an interface that they have to implement:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">class MapLoadee { 
public: 
  virtual void ReadMapLine(const std::string&amp; l_type, 
    std::stringstream&amp; l_stream) = 0; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">The map files themselves are fairly straightforward:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">SIZE 64 64 
DEFAULT_FRICTION 1.0 1.0 
|ENTITY|Name|x|y|elevation| 
ENTITY Player 715 360 1 
ENTITY Skeleton 256.0 768.0 1 
|TILE|ID|x|y|layer|solid| 
TILE 0 0 0 0 0 
TILE 0 0 1 0 0 
TILE 0 0 2 0 0 
... 
</span></pre><p><span class="koboSpan" id="kobo.12.1">A good candidate for a </span><code class="literal"><span class="koboSpan" id="kobo.13.1">MapLoadee</span></code><span class="koboSpan" id="kobo.14.1"> here would be a class that handles entities being spawned. </span><span class="koboSpan" id="kobo.14.2">The two entity lines would be directly handled by it, which creates a nice level of separation between codes that shouldn't really overlap.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Sprite system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/><span class="koboSpan" id="kobo.1.1">Sprite system</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Since we're working on a 2D game, the most likely candidate for the way graphics are going to be done is a sprite sheet. </span><span class="koboSpan" id="kobo.2.2">Unifying the way sprite sheet cropping and animations are handled is key to not only minimizing code, but also creating a simple, neat interface that's easy to interact with. </span><span class="koboSpan" id="kobo.2.3">Let us take a look at how that can be done:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class SpriteSheet{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">void CropSprite(const sf::IntRect&amp; l_rect); 
  const sf::Vector2u&amp; GetSpriteSize()const; 
  const sf::Vector2f&amp; GetSpritePosition()const; 
  void SetSpriteSize(const sf::Vector2u&amp; l_size); 
  void SetSpritePosition(const sf::Vector2f&amp; l_pos); 
  void SetDirection(const Direction&amp; l_dir); 
  Direction GetDirection() const; 
  void SetSheetPadding(const sf::Vector2f&amp; l_padding); 
  void SetSpriteSpacing(const sf::Vector2f&amp; l_spacing); 
  const sf::Vector2f&amp; GetSheetPadding()const; 
  const sf::Vector2f&amp; GetSpriteSpacing()const; 
  bool LoadSheet(const std::string&amp; l_file); 
  void ReleaseSheet(); 
  Anim_Base* GetCurrentAnim(); 
  bool SetAnimation(const std::string&amp; l_name, 
    bool l_play = false, bool l_loop = false); 
  void Update(float l_dT); 
  void Draw(sf::RenderWindow* l_wnd); 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.3.3">Animations m_animations; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">The </span><code class="literal"><span class="koboSpan" id="kobo.5.1">SpriteSheet</span></code><span class="koboSpan" id="kobo.6.1"> class itself isn't really that complex. </span><span class="koboSpan" id="kobo.6.2">It offers helper methods for cropping the sheet down to a specific rectangle, altering the stored direction, defining different attributes, such as spacing, padding, and so on, and manipulating the animation data.</span></p><p><span class="koboSpan" id="kobo.7.1">Animations are stored in this class by name:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">using Animations = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;Anim_Base&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.9.1">The interface of an animation class looks like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">class Anim_Base{ 
  friend class SpriteSheet; 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.10.2">void SetSpriteSheet(SpriteSheet* l_sheet); 
  bool SetFrame(Frame l_frame); 
  void SetStartFrame(Frame l_frame); 
  void SetEndFrame(Frame l_frame); 
  void SetFrameRow(unsigned int l_row); 
  void SetActionStart(Frame l_frame); 
  void SetActionEnd(Frame l_frame); 
  void SetFrameTime(float l_time); 
  void SetLooping(bool l_loop); 
  void SetName(const std::string&amp; l_name); 
  SpriteSheet* GetSpriteSheet(); 
  Frame GetFrame() const; 
  Frame GetStartFrame() const; 
  Frame GetEndFrame() const; 
  unsigned int GetFrameRow() const; 
  int GetActionStart() const; 
  int GetActionEnd() const; 
  float GetFrameTime() const; 
  float GetElapsedTime() const; 
  bool IsLooping() const; 
  bool IsPlaying() const; 
  bool IsInAction() const; 
  bool CheckMoved(); 
  std::string GetName() const; 
  void Play(); 
  void Pause(); 
  void Stop(); 
  void Reset(); 
  virtual void Update(float l_dT); 
  friend std::stringstream&amp; operator &gt;&gt;( 
    std::stringstream&amp;l_stream, Anim_Base&amp; a){ ... </span><span class="koboSpan" id="kobo.10.3">} 
protected: 
  virtual void FrameStep() = 0; 
  virtual void CropSprite() = 0; 
  virtual void ReadIn(std::stringstream&amp; l_stream) = 0; 
  ... 
</span><span class="koboSpan" id="kobo.10.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.11.1">First, the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Frame</span></code><span class="koboSpan" id="kobo.13.1"> data type is simply a type definition of an integer. </span><span class="koboSpan" id="kobo.13.2">This class keeps track of all necessary animation data, and even provides a way to set up specific frame ranges (also referred to as actions), which can be used for something such as an entity only </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">attacking</span></em></span><span class="koboSpan" id="kobo.15.1"> something if the attack animation is within that specific action range.</span></p><p><span class="koboSpan" id="kobo.16.1">The obvious thing about this class is that it does not represent any single type of animation, but rather all the common elements of every type. </span><span class="koboSpan" id="kobo.16.2">This is why three different purely virtual methods are provided, so that different types of animation can define how the frame step is handled, define the specific method, the location of cropping, and the exact process of the animation being loaded from a file. </span><span class="koboSpan" id="kobo.16.3">This helps us separate directional animations, where every row represents a character facing a different way, from simple, sequential animations of frames following each other in a linear order.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Sound system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/><span class="koboSpan" id="kobo.1.1">Sound system</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Last, but definitely not least, the sound system deserves a brief overview. </span><span class="koboSpan" id="kobo.2.2">It probably would be a surprise to nobody at this point to learn that sounds are also reliant upon application states, which is why we're inheriting from </span><code class="literal"><span class="koboSpan" id="kobo.3.1">StateDependent</span></code><span class="koboSpan" id="kobo.4.1"> again:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class SoundManager : public StateDependent{ 
public: 
  SoundManager(AudioManager* l_audioMgr); 
  ~SoundManager(); 
 
  void ChangeState(const StateType&amp; l_state); 
  void RemoveState(const StateType&amp; l_state); 
 
  void Update(float l_dT); 
 
  SoundID Play(const std::string&amp; l_sound, 
    const sf::Vector3f&amp; l_position, 
    bool l_loop = false, bool l_relative = false); 
  bool Play(const SoundID&amp; l_id); 
  bool Stop(const SoundID&amp; l_id); 
  bool Pause(const SoundID&amp; l_id); 
 
  bool PlayMusic(const std::string&amp; l_musicId, 
    float l_volume = 100.f, bool l_loop = false); 
  bool PlayMusic(const StateType&amp; l_state); 
  bool StopMusic(const StateType&amp; l_state); 
  bool PauseMusic(const StateType&amp; l_state); 
 
  bool SetPosition(const SoundID&amp; l_id, 
    const sf::Vector3f&amp; l_pos); 
  bool IsPlaying(const SoundID&amp; l_id) const; 
  SoundProps* GetSoundProperties(const std::string&amp; l_soundName); 
 
  static const int Max_Sounds = 150; 
  static const int Sound_Cache = 75; 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.5.2">AudioManager* m_audioManager; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">The </span><code class="literal"><span class="koboSpan" id="kobo.7.1">AudioManager</span></code><span class="koboSpan" id="kobo.8.1"> class is responsible for managing auditory resources, in the same way textures and fonts are managed elsewhere. </span><span class="koboSpan" id="kobo.8.2">One of the bigger differences here is that we can actually play sounds in 3D space, hence the use of a </span><code class="literal"><span class="koboSpan" id="kobo.9.1">sf::Vector3f</span></code><span class="koboSpan" id="kobo.10.1"> structure wherever a position needs to be represented. </span><span class="koboSpan" id="kobo.10.2">Sounds are also grouped by specific names, but there is a slight twist to this system. </span><span class="koboSpan" id="kobo.10.3">SFML can only handle about 255 different sounds playing all at once, which includes </span><code class="literal"><span class="koboSpan" id="kobo.11.1">sf::Music</span></code><span class="koboSpan" id="kobo.12.1"> instances as well. </span><span class="koboSpan" id="kobo.12.2">It's because of this that we have to implement a recycling system that utilizes discarded instances of sounds, as well as a static limit of the maximum number of sounds allowed all at once.</span></p><p><span class="koboSpan" id="kobo.13.1">Every different sound that is loaded and played has specific set up properties that can be tweaked. </span><span class="koboSpan" id="kobo.13.2">They are represented by this data structure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">struct SoundProps{ 
  SoundProps(const std::string&amp; l_name): m_audioName(l_name), 
    m_volume(100), m_pitch(1.f), m_minDistance(10.f), 
    m_attenuation(10.f){} 
  std::string m_audioName; 
  float m_volume; 
  float m_pitch; 
  float m_minDistance; 
  float m_attenuation; 
}; 
</span></pre><p><code class="literal"><span class="koboSpan" id="kobo.15.1">audioName</span></code><span class="koboSpan" id="kobo.16.1"> is simply the identifier of the audio resource that is loaded in memory. </span><span class="koboSpan" id="kobo.16.2">The volume of a sound can obviously be tweaked, as well as its pitch. </span><span class="koboSpan" id="kobo.16.3">The last two properties are slightly more intricate. </span><span class="koboSpan" id="kobo.16.4">A sound at a point in space would begin to grow quieter and quieter, as we begin to move away from it. </span><span class="koboSpan" id="kobo.16.5">The minimum distance property describes the unit distance from the sound source, after which the sound begins to lose its volume. </span><span class="koboSpan" id="kobo.16.6">The rate at which this volume is lost after that point is reached is described by the attenuation factor.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">That was quite a lot of information to take in. </span><span class="koboSpan" id="kobo.2.2">In the span of around forty pages we have managed to summarize the better part of the entire code base that would make any basic to intermediate complexity game tick. </span><span class="koboSpan" id="kobo.2.3">Keep in mind that although many topics got covered here, all of the information was rather condensed. </span><span class="koboSpan" id="kobo.2.4">Feel free to look through the code files we provide until you feel comfortable to proceed to actually building a game, which is precisely what's coming in the next chapter. </span><span class="koboSpan" id="kobo.2.5">See you there!</span></p></div></div></div></body></html>