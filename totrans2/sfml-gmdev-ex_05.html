<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Can I Pause This? – Application States</h1></div></div></div><p>A piece of software like a video game is rarely as simple as the term suggests. Most of the time, it's not just the game mechanics and rendering one has to deal with in such an application. Nowadays, an industry-standard product also includes a nice introduction animation before the game begins. It also has a menu for the player to tinker with in order to start playing the game, manage the different settings it offers, view the credits or quit the application. On top of that, the title of this chapter also suggests the possibility of putting your game on pause for a moment or two. In hindsight, it's simple conveniences like this that draw the line in the sand between a game in its early stages, that's awkward to navigate and possibly confusing, and a product that offers the same level of control as most games on the market. To supply the backbone to such an idea, in this chapter we will be covering:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing the state manager</li><li class="listitem" style="list-style-type: disc">Upgrading the event manager to handle different states</li><li class="listitem" style="list-style-type: disc">Creating different states for the introduction, main menu and game-play sections of our game</li><li class="listitem" style="list-style-type: disc">Providing the means to pause the game</li><li class="listitem" style="list-style-type: disc">Implementing state blending</li><li class="listitem" style="list-style-type: disc">Stringing the states together to create cohesive application flow</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>What is a state?</h1></div></div></div><p>Before we <a id="id127" class="indexterm"/>get into any kind of implementation, it's necessary to understand what we're dealing with. If you've been reading up on any kind of game development <a id="id128" class="indexterm"/>material before, you probably came across the term <strong>state</strong>. It can mean different things, depending on its context. In this case, a state is any one of the many different layers of your game, like the main menu, the intro that plays before the menu is shown, or the actual game-play. Naturally, each one of these layers has its own way of updating itself and rendering its contents onto the screen. The game developer's job when utilizing this system is to break down a given problem into separate, manageable states and transitions between them. This essentially means that if you are presented with the problem<a id="id129" class="indexterm"/> of having a menu in the game, the solution would be creating two states, one for the menu and one for your game-play, and transitioning between the two at appropriate times.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>The most simplistic approach</h1></div></div></div><p>Let's begin <a id="id130" class="indexterm"/>by illustrating the most common approach newcomers take in order to solve this problem. It starts by enumerating all the possible states a game could have:</p><div><pre class="programlisting">enum class StateType{
    Intro = 1, MainMenu, Game, Paused, GameOver, Credits
};</pre></div><p>Good start. Now let's put it to work by simply using a <code class="literal">switch</code> statement:</p><div><pre class="programlisting">void Game::Update(){
  switch(m_state){
    case(StateType::Intro):
      UpdateIntro();
      break;
    case(StateType::Game):
      UpdateGame();
      break;
    case(StateType::MainMenu):
      UpdateMenu();
      break;
    ...
  }
}</pre></div><p>The same goes for drawing it on screen:</p><div><pre class="programlisting">void Game::Render(){
  switch(m_state){
    case(StateType::Intro):
      DrawIntro();
      break;
    case(StateType::Game):
      DrawGame();
      break;
    case(StateType::MainMenu):
      DrawMenu();
      break;
    ...
  }
}</pre></div><p>While this<a id="id131" class="indexterm"/> approach is okay for really small games, scalability here is completely out of the question. First of all, the switch statements are going to continue to grow when more states are added. Assuming we keep the functionality for updating and rendering a specific state localized to just one method, the number of these methods will also continue to grow by at least two methods per state, one of them being used for updating and another for rendering. Keep in mind, that's the <em>minimal</em> amount of expansion needed in order to support an extra state. If we also process events for each state individually or perform some kind of additional logic like <em>late updating</em>, that's four switch statements, one extra switch branch for each state and four extra methods that have to be implemented and added to the branches.</p><p>Next, consider state transitions. If, for whatever reason, you want to render two states at the same time for a short while, this entire approach collapses. It is possible to still somehow string that functionality together by tying up a bunch of flags or creating combination states as follows:</p><div><pre class="programlisting">enum StateType{
    Intro = 1, Intro_MainMenu, MainMenu, Game, MainMenu_Game
    Paused, GameOver, MainMenu_GameOver, Credits, MainMenu_Credits
    ...
    // Crying in the corner.
};</pre></div><p>This just keeps getting messier by the minute, and we haven't even got to expand our already large switch statements yet, let alone implement all the states we want!</p><p>If you still aren't thinking about migrating to a different tactic by now, consider this one final point: resources. If you're keeping all of the data from all of the possible states a game might have loaded at the same time, you may have quite a bit of a problem on your hands from the point of efficiency. You may dynamically allocate classes that represent certain states and check for when they're not in use anymore somehow to de-allocate them, however that's additional clutter in your already mostly unreadable code-base, and since you're already thinking of using classes, why not do it better?</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Introducing the state pattern</h1></div></div></div><p>All of the<a id="id132" class="indexterm"/> problems mentioned previously can be avoided after some careful white-boarding and consideration. The possibility was brought up earlier of different game states simply being localized to their own classes. All of these classes will share the same methods for being updated and rendered, which makes <strong>inheritance</strong> the <a id="id133" class="indexterm"/>word of the hour. Let's take a look at our base state<a id="id134" class="indexterm"/> header:</p><div><pre class="programlisting">class StateManager;

class BaseState{
  friend class StateManager;
public:
  BaseState(StateManager* l_stateManager)
    :m_stateMgr(l_stateManager),m_transparent(false),
    m_transcendent(false){}
  virtual ~BaseState(){}

  virtual void OnCreate() = 0;
  virtual void OnDestroy() = 0;

  virtual void Activate() = 0;
  virtual void Deactivate() = 0;

  virtual void Update(const sf::Time&amp; l_time) = 0;
  virtual void Draw() = 0;

  void SetTransparent(const bool&amp; l_transparent){
    m_transparent = l_transparent;
  }
  bool IsTransparent()const{ return m_transparent; }
  void SetTranscendent(const bool&amp; l_transcendence){
    m_transcendent = l_transcendence;
  }
  bool IsTranscendent()const{ return m_transcendent; }
  StateManager* GetStateManager(){ return m_stateMgr; }
protected:
  StateManager* m_stateMgr;
  bool m_transparent;
  bool m_transcendent;
};</pre></div><p>First, you'll notice we're using a <em>forward declaration</em> of the <code class="literal">StateManager</code> class. The base class doesn't really need to know anything about the way our state manager will be implemented, only that it needs to keep a pointer to it. This is also done in order to avoid <em>recursive definitions</em>, because the <code class="literal">StateManager</code> class header needs to include the <code class="literal">BaseState</code> class header.</p><p>Since we want to enforce the use of the same methods throughout all states, we make them <em>purely virtual</em>, which means that the class inheriting from <code class="literal">BaseState</code> has to implement each and every one of them in order for the project to compile. The methods that any derived class has to implement consist of <code class="literal">OnCreate</code> and <code class="literal">OnDestroy</code>, which get invoked when the state is created and pushed on the stack, and later removed from the stack, <code class="literal">Activate</code> and <code class="literal">Deactivate</code>, which are called once a state is moved to the top of the stack as well as when it gets removed from the top position, and lastly, <code class="literal">Update</code> and <code class="literal">Draw</code>, which <a id="id135" class="indexterm"/>are used for updating the state and drawing its contents.</p><p>One last thing to note about this class is that it has a pair of flags: <code class="literal">m_transparent</code> and <code class="literal">m_transcendent</code>. These flags indicate if this state also needs to render or update a state that came before it. This eliminates the need for countless enumerations of different transitions between states and can be done automatically without any additional expansion.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>Defining common types</h2></div></div></div><p>One <a id="id136" class="indexterm"/>thing that we're definitely going to keep from the previous example is the enumeration table of the state types:</p><div><pre class="programlisting">enum class StateType{
    Intro = 1, MainMenu, Game, Paused, GameOver, Credits
};</pre></div><p>Having the state types enumerated is convenient and it helps with automating the state creation, as you will see later on.</p><p>Another common type we need to keep around is the device context we'll be using with our states. Don't be confused by the name, it simply means having a pointer to some of our most commonly used classes or "devices." Because there's more than one, it's quite useful to define a simple structure that will keep around pointers to the main window class and the event manager:</p><div><pre class="programlisting">struct SharedContext{
    SharedContext():m_wind(nullptr),m_eventManager(nullptr){}
    Window* m_wind;
    EventManager* m_eventManager;
};</pre></div><p>This can and will be expanded later when needed, in order to hold information about the player and other assistant classes that deal with resource allocation, sound and networking.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec16"/>The state manager class</h2></div></div></div><p>Now that<a id="id137" class="indexterm"/> we have our helper structures set up, let's actually define the types that will be used to hold information in our state manager class. As always, we will be using type definitions, the beauty of which is the fact that they reduce the amount of code you have to change in a case of modifying something about the type definition. Let's take a look at the state container type first:</p><div><pre class="programlisting">using StateContainer = std::vector&lt;std::pair&lt;StateType, BaseState*&gt;&gt;;</pre></div><p>Once <a id="id138" class="indexterm"/>again, we're using a vector. The element type is a pair of our state type and a pointer to a <code class="literal">BaseState</code> type object. You might be wondering why a map isn't a better choice, and the answer depends on your idea of implementation, however, one major factor is that a map doesn't keep a stack-like order in the container, which is important if we want our state manager to work correctly.</p><p>One of the design decisions in the state manager class also requires a container of state types, so let's define that:</p><div><pre class="programlisting">using TypeContainer = std::vector&lt;StateType&gt;;</pre></div><p>As you can see, it's simply a vector of the <code class="literal">StateType</code> enumeration types.</p><p>The last type we need to define is a container for custom functions that will serve as a way of automatically producing objects of different types derived from the <code class="literal">BaseState</code> class:</p><div><pre class="programlisting">using StateFactory = std::unordered_map&lt;StateType, std::function&lt;BaseState*(void)&gt;&gt;;</pre></div><p>We're using an unordered map here in order to map a specific state type to a specific function that will generate that type. If that sounds confusing now, be patient. It will be covered more thoroughly when we actually use it.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Defining the state manager class</h3></div></div></div><p>All the <a id="id139" class="indexterm"/>individual bits and pieces we needed to actually bang out a header for the state manager class are now present, so let's write it:</p><div><pre class="programlisting">class StateManager{
public:
    StateManager(SharedContext* l_shared);
    ~StateManager();

    void Update(const sf::Time&amp; l_time);
    void Draw();

    void ProcessRequests();

    SharedContext* GetContext();
    bool HasState(const StateType&amp; l_type);

    void SwitchTo(const StateType&amp; l_type);
    void Remove(const StateType&amp; l_type);
private:
    // Methods.
    void CreateState(const StateType&amp; l_type);
    void RemoveState(const StateType&amp; l_type);

    template&lt;class T&gt;
    void RegisterState(const StateType&amp; l_type){...}

    // Members.
    SharedContext* m_shared;
    StateContainer m_states;
    TypeContainer m_toRemove;
    StateFactory m_stateFactory;
};</pre></div><p>The <a id="id140" class="indexterm"/>constructor takes in a pointer to the <code class="literal">SharedContext</code> type we talked about earlier, which will be created in our main <code class="literal">Game</code> class. Predictably enough, the state manager also employs the use of <code class="literal">Update</code> and <code class="literal">Draw</code> methods, because it will be operated by the <code class="literal">Game</code> class, and it's nice to keep the interface familiar. For convenience sake, it offers helper methods for obtaining the context as well as determining if it currently has a certain state on the stack.</p><p>Concluding the public methods, we have <code class="literal">SwitchTo</code>, which takes in a state type and changes the current state to one that corresponds to said type, and <code class="literal">Remove</code>, for removing a state from the state stack by its type.</p><p>If you looked at the class definition from top to bottom, you may have noticed that we have a <code class="literal">TypeContainer</code> member called <code class="literal">m_toRemove</code>. In order to ensure smooth and error-free transitions, we cannot simply delete any state we want from the state container at any time. A simple solution here is keeping track of the state types we want to remove and only removing them when they're no longer being used, which is what the <code class="literal">ProcessRequests</code> method does. It is called last in the game loop, which ensures that the states in the <code class="literal">m_toRemove</code> container are no longer in use.</p><p>Let's continue with the more advanced private methods and implementation of our state manager class in the next section.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Implementing the state manager</h3></div></div></div><p>In order<a id="id141" class="indexterm"/> to maintain the automated approach of creating our states on the heap, we must have some way of defining how they're created. The <code class="literal">m_stateFactory</code> member is a map that links a state type to a <code class="literal">std::function</code> type, which we can be set to hold a body of a function through use of the lambda expression:</p><div><pre class="programlisting">template&lt;class T&gt;
void RegisterState(const StateType&amp; l_type){
    m_stateFactory[l_type] = [this]() -&gt; BaseState*
    {
        return new T(this);
    };
}</pre></div><p>The code <a id="id142" class="indexterm"/>above maps the type <code class="literal">l_type</code> in the <code class="literal">m_stateFactory</code> map to a function that simply returns a pointer to newly allocated memory. We're using templates here in order to reduce the amount of code. Because each state requires a pointer to the <code class="literal">StateManager</code> class in its constructor, we pass the <em>this pointer</em> in. We can now register different states like so:</p><div><pre class="programlisting">StateManager::StateManager(SharedContext* l_shared): m_shared(l_shared)
{
    RegisterState&lt;State_Intro&gt;(StateType::Intro);
    RegisterState&lt;State_MainMenu&gt;(StateType::MainMenu);
    RegisterState&lt;State_Game&gt;(StateType::Game);
    RegisterState&lt;State_Paused&gt;(StateType::Paused);
}</pre></div><p>It's time to begin implementing the rest of the class now. Let's take a look at the destructor:</p><div><pre class="programlisting">StateManager::~StateManager(){
    for (auto &amp;itr : m_states){
        itr.second-&gt;OnDestroy();
        delete itr.second;
    }
}</pre></div><p>Because we localize all the dynamic memory allocation of any states to this class, it's imperative that we also free the memory appropriately. Iterating over all the states and deleting the second value of the pair which makes up the element does just that.</p><p>Next, let's take a look at how to implement the draw method:</p><div><pre class="programlisting">void StateManager::Draw(){
  if (m_states.empty()){ return; }
  if (m_states.back().second-&gt;IsTransparent() &amp;&amp; m_states.size() &gt; 1)
  {
    auto itr = m_states.end();
    while (itr != m_states.begin()){
      if (itr != m_states.end()){
        if (!itr-&gt;second-&gt;IsTransparent()){
          break;
        }
      }
      --itr;
    }
    for (; itr != m_states.end(); ++itr){
      itr-&gt;second-&gt;Draw();
    }
  } else {
    m_states.back().second-&gt;Draw();
  }
}</pre></div><p>First, just like<a id="id143" class="indexterm"/> the <code class="literal">Update</code> method, we check if the state container has <em>at least one</em> state. If it does, we check the most recently added one's <strong>transparency flag</strong>, as well as if there's more than one state on the stack, otherwise the transparency <a id="id144" class="indexterm"/>would be useless. If there's only one state on the stack or if the current state isn't transparent, we simply invoke its <code class="literal">Draw</code> method. Otherwise, things get a little bit more interesting. </p><p>In order to correctly render transparent states, we must call their respective <code class="literal">Draw</code> methods in a correct order, where the latest state on the stack is drawn on screen last. To do that, it's necessary to iterate through the state vector <em>backwards</em> until a state is found that is either not transparent or is the first state on the stack, which is what the <code class="literal">while</code> loop does. After such state is found, the <code class="literal">Draw</code> calls of all states from and including the one found, up to the very last one are invoked in the <code class="literal">for</code> loop. This effectively renders multiple states at once in correct order.</p><p>A fairly similar procedure is followed when updating states:</p><div><pre class="programlisting">void StateManager::Update(const sf::Time&amp; l_time){
  if (m_states.empty()){ return; }
  if (m_states.back().second-&gt;IsTranscendent() &amp;&amp; m_states.size() &gt; 1)
  {
    auto itr = m_states.end();
    while (itr != m_states.begin()){
      if (itr != m_states.end()){
        if (!itr-&gt;second-&gt;IsTranscendent()){
          break;
        }
      }
      --itr;
    }
    for (; itr != m_states.end(); ++itr){
      itr-&gt;second-&gt;Update(l_time);
    }
  } else {
    m_states.back().second-&gt;Update(l_time);
  }
}</pre></div><p>The state's <em>transcendence</em> flag is checked first, in order to determine whether the top state allows others to be updated. The state or states that need to get updated then have their <code class="literal">Update</code> methods invoked with the elapsed time passed in as the argument, more commonly<a id="id145" class="indexterm"/> known as <strong>delta time</strong>.</p><p>As <a id="id146" class="indexterm"/>always, we need to define some helper methods for a class to be truly flexible and useful:</p><div><pre class="programlisting">SharedContext* StateManager::GetContext(){ return m_shared; }

bool StateManager::HasState(const StateType&amp; l_type){
  for (auto itr = m_states.begin();
    itr != m_states.end(); ++itr)
  {
    if (itr-&gt;first == l_type){
      auto removed = std::find(m_toRemove.begin(),
        m_toRemove.end(), l_type);
      if (removed == m_toRemove.end()){ return true; }
      return false;
    }
  }
  return false;
}</pre></div><p>The first method of obtaining the context is pretty straightforward. All it does is return a pointer to the <code class="literal">m_shared</code> member. The second method simply iterates over the <code class="literal">m_states</code> container until it finds a state with the type <code class="literal">l_type</code> and returns <code class="literal">true</code>. If it doesn't find such state, or if the state is found but it's about to be removed, it returns <code class="literal">false</code>. This gives us a way to check if a certain state is on the stack.</p><p>Having a way to remove a state is just as necessary as having a way of adding one. Let's implement the public method <code class="literal">Remove</code>:</p><div><pre class="programlisting">void StateManager::Remove(const StateType&amp; l_type){
     m_toRemove.push_back(l_type);
}</pre></div><p>This method pushes back a state type into the <code class="literal">m_toRemove</code> vector for later removal, which is then processed by this method:</p><div><pre class="programlisting">void StateManager::ProcessRequests(){
    while (m_toRemove.begin() != m_toRemove.end()){
        RemoveState(*m_toRemove.begin());
        m_toRemove.erase(m_toRemove.begin());
    }
}</pre></div><p>The last method of this class that ever gets called, <code class="literal">ProcessRequests</code>, simply iterates over the <code class="literal">m_toRemove</code> vector and invokes a private method <code class="literal">RemoveState</code> which takes care of actual resource de-allocation. It then removes the element, ensuring the container is cleared.</p><p>Being<a id="id147" class="indexterm"/> able to change the current state is of paramount importance, which is what the <code class="literal">SwitchTo</code> method takes care of:</p><div><pre class="programlisting">void StateManager::SwitchTo(const StateType&amp; l_type){
  m_shared-&gt;m_eventManager-&gt;SetCurrentState(l_type);
  for (auto itr = m_states.begin();
    itr != m_states.end(); ++itr)
  {
    if (itr-&gt;first == l_type){
      m_states.back().second-&gt;Deactivate();
      StateType tmp_type = itr-&gt;first;
      BaseState* tmp_state = itr-&gt;second;
      m_states.erase(itr);
      m_states.emplace_back(tmp_type, tmp_state);
      tmp_state-&gt;Activate();
      return;
    }
  }

  // State with l_type wasn't found.
  if (!m_states.empty()){ m_states.back().second-&gt;Deactivate(); }
  CreateState(l_type);
  m_states.back().second-&gt;Activate();
}</pre></div><p>First, you will notice that we access the event manager through our shared context and call a method <code class="literal">SetCurrentState</code>. We haven't yet gotten around to adding it, however it will be covered shortly. What it does is it simply modifies an internal data member of the event manager class, which keeps track of which state the game is in. </p><p>Next, we must find the state with the type we want to switch to, so we iterate over the state vector. If we have a match, the current state that's about to be pushed back has its <code class="literal">Deactivate</code> method called to perform whatever functionality it has to, in case the state cares about when it gets moved down. Then, we create two temporary variables to hold the state type and the pointer to a state object, so we don't lose that information when the element we're interested in is removed from the vector by calling <code class="literal">erase</code>. After doing that, all the <em>iterators</em> to the state container are invalidated, but it doesn't matter in our case, because we no longer need any. Moving the desired state is now as simple as pushing back another element onto the vector and passing in our temporary variables. Then, we call the <code class="literal">Activate</code> method of the state that just got moved in case it has any logic that is needed to be performed at that time.</p><p>If the state with <code class="literal">l_type</code> isn't found, creating one is necessary. First, however, it's important to check if there's at least one state for which to call the <code class="literal">Deactivate</code> method, and call it, if there is one. After invoking a private method <code class="literal">CreateState</code> and passing in the state<a id="id148" class="indexterm"/> type, we grab the element from the state vector that was added most recently by <code class="literal">CreateState</code>, and call <code class="literal">Activate</code>.</p><p>It's time to see what exactly goes into creating a state:</p><div><pre class="programlisting">void StateManager::CreateState(const StateType&amp; l_type){
    auto newState = m_stateFactory.find(l_type);
    if (newState == m_stateFactory.end()){ return; }
    BaseState* state = newState-&gt;second();
    m_states.emplace_back(l_type, state);
    state-&gt;OnCreate();
}</pre></div><p>A state factory iterator gets created and checked for matching the iterator returned by the <code class="literal">end()</code> method of <code class="literal">std::unordered_map</code>, allowing us to make sure a state with such type can be created. If it can, a pointer of type <code class="literal">BaseState</code>, called <code class="literal">state</code> is created. It catches the return result of our iterator's second value getting invoked as a function, which if you remember was the <code class="literal">std::function</code> type and returns a pointer to a newly created state class. This is how we put the previously mentioned "factory" to work. After retrieving a pointer to the newly allocated memory for a state, we simply push it back onto the state vector and call <code class="literal">OnCreate</code> for the state to do its internal logic regarding being freshly created.</p><p>How do we go about removing a state? Let's take a look:</p><div><pre class="programlisting">void StateManager::RemoveState(const StateType&amp; l_type){
  for (auto itr = m_states.begin();itr != m_states.end(); ++itr)
  {
    if (itr-&gt;first == l_type){
      itr-&gt;second-&gt;OnDestroy();
      delete itr-&gt;second;
      m_states.erase(itr);
      return;
    }
  }
}</pre></div><p>As always when dealing with <code class="literal">std::vector</code> types, we iterate over it until a match is found. Removing the actual state begins by calling the <code class="literal">OnDestroy</code> method of said state, again, just so it can perform whatever logic it needs in order to be ready for removal. Then we simply de-allocate the memory by using the <code class="literal">delete</code> keyword. Finally, we erase the element from the state vector and return from the method.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Improving the Event Manager class</h1></div></div></div><p>Having<a id="id149" class="indexterm"/> different states in a game will, without a shadow of a doubt, create situations where the same key or event will be needed by at least two of the states. Let's say we have a menu, where navigation is done by pressing the arrow keys. That's all fine, but what if the game-play state also registers the use of arrow keys and sets up its own callbacks? The very best case scenario is that callbacks from all states will be invoked at the same time and create weird behavior. Things get worse, however, when you have function pointers to methods that are no longer in memory, especially since nobody likes application crashes. A simple way of dealing with this problem is grouping the callbacks together by state and only invoking them if the current state is that of a callback. This obviously means some re-definition of the types being dealt with:</p><div><pre class="programlisting">using CallbackContainer = std::unordered_map&lt;std::string, std::function&lt;void(EventDetails*)&gt;&gt;;
enum class StateType;
using Callbacks = std::unordered_map&lt;StateType, CallbackContainer&gt;;</pre></div><p>Things are getting a little bit more complicated now. What used to be the <code class="literal">Callback</code> definition is now renamed <code class="literal">CallbackContainer</code>. We only want one of those per state, so it means having to use another map, which is where the new <code class="literal">Callback</code> definition comes in. It maps a state type to a <code class="literal">CallbackContainer</code> type, so that we can have only one <code class="literal">CallbackContainer</code> per state in addition to only one callback function per name.</p><p>Despite these changes, the declaration for <code class="literal">m_callbacks</code> in the event manager header remains the same:</p><div><pre class="programlisting">Callbacks m_callbacks;</pre></div><p>There is one minor addition to the class data member list, and that is the current state:</p><div><pre class="programlisting">StateType m_currentState;</pre></div><p>What does change, however, are the methods for adding, removing and utilizing callbacks. Let's adapt the <code class="literal">AddCallback</code> method to these changes:</p><div><pre class="programlisting">template&lt;class T&gt;
bool AddCallback(StateType l_state, const std::string&amp; l_name,void(T::*l_func)(EventDetails*), T* l_instance)
{
    auto itr = m_callbacks.emplace(l_state, CallbackContainer()).first;
    auto temp = std::bind(l_func, l_instance,std::placeholders::_1);
    return itr-&gt;second.emplace(l_name, temp).second;
}</pre></div><p>The first thing to note is that we have a new argument <code class="literal">l_state</code> in the method's footprint. Next, we attempt to insert a new element to the <code class="literal">m_callbacks</code> map, pairing together the state argument and a new <code class="literal">CallbackContainer</code>. Since a map can only have one element with a specific index, in this case it's the state type, the <code class="literal">emplace</code> method always returns a pair of elements, the first of which is an iterator. If the insertion succeeded, the iterator points to the element that was newly created. On the other hand, if an element with a specified<a id="id150" class="indexterm"/> index already existed, the iterator points to that element instead. This is a good strategy to use, because we need that iterator no matter what, and if there is no element with the index we specified, we're going to want to insert one.</p><p>After the function binding, which remains unchanged, we need to insert the actual callback into the <code class="literal">CallbackContainer</code> type, which is the second value in the pair that makes up the <code class="literal">m_callbacks</code> elements. The second value of a pair that gets returned by the insert method of a map is a Boolean that represents the success of an insertion, and that's what gets returned for error checking.</p><p>Now let's take a look at revising the removal of callbacks:</p><div><pre class="programlisting">bool RemoveCallback(StateType l_state, const std::string&amp; l_name){
    auto itr = m_callbacks.find(l_state);
    if (itr == m_callbacks.end()){ return false; }
    auto itr2 = itr-&gt;second.find(l_name);
    if (itr2 == itr-&gt;second.end()){ return false; }
    itr-&gt;second.erase(l_name);
    return true;
}</pre></div><p>This one's fairly simple. All we do is use the find method twice instead of once. First, we <code class="literal">find</code> the state pair in the first map, then we <code class="literal">erase</code> the actual callback by its name in the second map, just like before.</p><p>The last part of making this work just the way we want is fixing the way callback functions are actually called. Due to the type definitions that got changed, the way we invoke callbacks is also slightly different:</p><div><pre class="programlisting">void EventManager::Update(){
  ...
  if (bind-&gt;m_events.size() == bind-&gt;c){
    auto stateCallbacks = m_callbacks.find(m_currentState);
    auto otherCallbacks = m_callbacks.find(StateType(0));

    if (stateCallbacks != m_callbacks.end()){
      auto callItr = stateCallbacks-&gt;second.find(bind-&gt;m_name);
      if (callItr != stateCallbacks-&gt;second.end()){
        // Pass in information about events.
        callItr-&gt;second(&amp;bind-&gt;m_details);
      }
    }

    if (otherCallbacks != m_callbacks.end()){
      auto callItr = otherCallbacks-&gt;second.find(bind-&gt;m_name);
      if (callItr != otherCallbacks-&gt;second.end()){
        // Pass in information about events.
        callItr-&gt;second(&amp;bind-&gt;m_details);
      }
    }
  }
  ...
}</pre></div><p>The main <a id="id151" class="indexterm"/>difference here is that we have two states for which callbacks get checked now, not just one: <code class="literal">stateCallbacks</code> and <code class="literal">otherCallbacks</code>. The former is quite obvious, we're simply using <code class="literal">find</code> to obtain the map of all callbacks for the current state. The latter, however, passes in a state type value of <code class="literal">0</code>, which isn't a valid state type, since the enumeration starts at <code class="literal">1</code>. This is done because even in the case of having multiple states in a game, we still want to process global callbacks for the <code class="literal">Window</code> class, as well as other classes that extend beyond the scope of simple states and persist all the way throughout the life of an application. Anything with the state type <code class="literal">0</code> will be invoked regardless of which state we're in.</p><p>The rest is fairly straightforward. Just like before, we're using the find method of the second value in the iterator that gets returned from the first search, which is our actual callback map. If a match is found, the function gets invoked.</p><p>One last thing we want to do here is modify the <code class="literal">keys.cfg</code> file to hold some extra keys for us in order to use them later:</p><div><pre class="programlisting">Window_close 0:0
Fullscreen_toggle 5:89
Intro_Continue 5:57
Mouse_Left 9:0
Key_Escape 5:36
Key_P 5:15</pre></div><p>The <code class="literal">Intro_Continue</code> binding represents a Spacebar "key down" event, <code class="literal">Mouse_Left</code> is the mouse left click event, <code class="literal">Key_Escape</code> is bound to the <em>ESC</em> "key down" event, and lastly, <code class="literal">Key_P</code> represents the letter <em>P</em> "key down" event.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Incorporating the state manager</h1></div></div></div><p>While it's<a id="id152" class="indexterm"/> not quite time for fanfare, excitement is definitely in order because we can finally put our brand new <code class="literal">StateManager</code> class to work! The <code class="literal">Game</code> class header modification is a good start:</p><div><pre class="programlisting">...
#include "StateManager.h"
...
class Game{
public:
    ...
    void LateUpdate();
private:
    ...
    StateManager m_stateManager;
};</pre></div><p>Sticking a new data member to the <code class="literal">Game</code> class and adding a new method for late updating are all the adjustments that need to be made in the header. Let's adjust the <code class="literal">Game</code> constructor to initialize the state manager:</p><div><pre class="programlisting">Game::Game(): m_window("Chapter 5", sf::Vector2u(800, 600)), m_stateManager(&amp;m_context)
{
    ...
    m_context.m_wind = &amp;m_window;
    m_context.m_eventManager = m_window.GetEventManager();
    m_stateManager.SwitchTo(StateType::Intro);
}</pre></div><p>Naturally, the first thing we do is create the context that will be used by all of the states and pass it into the constructor of the state manager. We then begin the "domino effect" by switching to the introduction state, which will in due time switch to other states and force the flow of the application.</p><p>Lastly, let's adjust the three most important methods of the <code class="literal">Game</code> class:</p><div><pre class="programlisting">void Game::Update(){
    m_window.Update();
    <strong>m_stateManager.Update(m_elapsed);</strong>
}
void Game::Render(){
    m_window.BeginDraw();
    <strong>m_stateManager.Draw();</strong>
    m_window.EndDraw();
}
void Game::LateUpdate(){
    <strong>m_stateManager.ProcessRequests();</strong>
    RestartClock();
}</pre></div><p>That's about <a id="id153" class="indexterm"/>as straightforward as it can be. One thing to note is that the <code class="literal">RestartClock</code> method is now called by the <code class="literal">LateUpdate</code>, which means we have to adjust the <code class="literal">main.cpp</code> file as  follows:</p><div><pre class="programlisting">#include "Game.h"

void main(int argc, void** argv[]){
    // Program entry point.
    Game game;
    while(!game.GetWindow()-&gt;IsDone()){
        game.Update();
        game.Render();
        game.LateUpdate();
    }
}</pre></div><p>Everything seems to be in order now. Compiling and launching the application should give you a very impressive black screen. Hoorah! Let's actually create some states for the game in order to honor the work that was put into this.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Creating the intro state</h1></div></div></div><p>It seems<a id="id154" class="indexterm"/> rather fitting to start with the intro state, in turn giving the state manager a bit of an introduction at the same time. As always, a good place to start is with the header file, so let's get going:</p><div><pre class="programlisting">class State_Intro : public BaseState{
public:
    ...
    void Continue(EventDetails* l_details);
private:
    sf::Texture m_introTexture;
    sf::Sprite m_introSprite;
    sf::Text m_text;
    float m_timePassed;
};</pre></div><p>The <code class="literal">State_Intro</code> class, just like all the other state classes we'll build, inherits from the <code class="literal">BaseState</code> class. All of the purely virtual methods of the base class have to be implemented here. In addition to that, we have a unique method named <code class="literal">Continue</code> and some private data members that will be used in this state. Predictably enough, we will be rendering a sprite on screen, as well as some text. The floating point data member on the very bottom will be used to keep track of how much time we have spent in this state, in order to present the user with the ability to hit the Spacebar key after a certain interval to proceed into<a id="id155" class="indexterm"/> the main menu. The <code class="literal">Continue</code> method is responsible for handling that transition.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Implementing the intro state</h2></div></div></div><p>We <a id="id156" class="indexterm"/>are getting close to finishing our first functional state! All that needs to be finished now is the actual implementation of the methods declared in the header file, and we're golden. Let's begin by including the header file of our class in <code class="literal">State_Intro.cpp</code>:</p><div><pre class="programlisting">#include "State_Intro.h"
#include "StateManager.h"</pre></div><p>Note the second line. Because the <code class="literal">StateManager</code> class is forwardly declared in the <code class="literal">BaseState</code> header, we <em>must</em> include the state manager header in the implementation file. This is true for any state we build in the future, including this one.</p><p>We will never use constructors and destructors of our states to initialize or allocate anything and instead rely on the <code class="literal">OnCreate</code> and <code class="literal">OnDestroy</code> methods in order to retain maximum control of when the resource allocation and de-allocation actually happens:</p><div><pre class="programlisting">void State_Intro::OnCreate(){
  m_timePassed = 0.0f;

  sf::Vector2u windowSize = m_stateMgr-&gt;GetContext()-&gt;
    m_wind-&gt;GetRenderWindow()-&gt;getSize();

  m_introTexture.loadFromFile("intro.png");
  m_introSprite.setTexture(m_introTexture);
  m_introSprite.setOrigin(m_introTexture.getSize().x / 2.0f,
    m_introTexture.getSize().y / 2.0f);

  m_introSprite.setPosition(windowSize.x / 2.0f, 0);

  m_font.loadFromFile("arial.ttf");
  m_text.setFont(m_font);
  m_text.setString({ "Press SPACE to continue" });
  m_text.setCharacterSize(15);
  sf::FloatRect textRect = m_text.getLocalBounds();
  m_text.setOrigin(textRect.left + textRect.width / 2.0f,
    textRect.top + textRect.height / 2.0f);
  m_text.setPosition(windowSize.x / 2.0f, windowSize.y / 2.0f);

  EventManager* evMgr = m_stateMgr-&gt;
    GetContext()-&gt;m_eventManager;
  evMgr-&gt;AddCallback(StateType::Intro,"Intro_Continue",
    &amp;State_Intro::Continue,this);
}</pre></div><p>There's<a id="id157" class="indexterm"/> quite a bit of code, however, only a tiny portion of it is new to us at this point. First, we must initialize our data member <code class="literal">m_timePassed</code> to zero. Next, we obtain the shared context through the use of the state manager pointer from the base class, and use it to obtain the current window size.</p><p>In order to position the <code class="literal">m_text</code> right in the middle of the screen, we set its origin to be the absolute center first, which is done by first obtaining a <code class="literal">sf::FloatRect</code> data type by calling the <code class="literal">getLocalBounds</code> method of our <code class="literal">sf::text</code> object. The left and top values of the <code class="literal">sf::FloatRect</code> represent the top left corner of the text, which can be used to calculate the center by adding half of the rectangle size to it.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>If any changes are made to the character size, the string or to the font that the <code class="literal">sf::text</code> object is using, the origin has to be re-calculated, because the physical dimensions of the local boundary rectangle are changed too.</p></div></div><p>The basic idea of this intro state is to have a sprite come down from the top of the screen to the middle. After five seconds have passed, some text will appear underneath the sprite notifying the user that they can hit the Spacebar in order to proceed to the main menu. This is the texture we will be using for the descending sprite:</p><div><img src="img/B04284_05_01.jpg" alt="Implementing the intro state"/></div><p>The last thing we need to do is to bind the Spacebar key to the <code class="literal">Continue</code> method of our intro class. We do that by obtaining the event manager instance through the shared context and setting up the callback, pretty much as we did in the previous chapter, except this time we need an additional argument: the state type.</p><p>Even though this class doesn't allocate any memory, it's still important it removes its callback when removed, which can be done here:</p><div><pre class="programlisting">void State_Intro::OnDestroy(){
    EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager;
    evMgr-&gt;RemoveCallback(StateType::Intro,"Intro_Continue");
}</pre></div><p>Just like<a id="id158" class="indexterm"/> the <code class="literal">AddCallback</code> method, removal of callbacks also requires a state type as its first argument.</p><p>Because we're dealing with time and movement here, updating this state will be necessary:</p><div><pre class="programlisting">void State_Intro::Update(const sf::Time&amp; l_time){
  if(m_timePassed &lt; 5.0f){ // Less than five seconds.
    m_timePassed += l_time.asSeconds();
    m_introSprite.setPosition(m_introSprite.getPosition().x,
      m_introSprite.getPosition().y + (48 * l_time.asSeconds()));
  }
}</pre></div><p>Seeing how it's only desired for the sprite to be moving until it reaches the middle, a five second window is defined. If the total time passed is less than that, we add the delta time argument to it for the next iteration and move the sprite by a set number of pixels per second in the y direction, while keeping x the same. This guarantees vertical movement, which is, of course, completely useless, unless we draw everything:</p><div><pre class="programlisting">void State_Intro::Draw(){
    sf::RenderWindow* window = m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow();

    window-&gt;draw(m_introSprite);
    if(m_timePassed &gt;= 5.0f){
        window-&gt;draw(m_text);
    }
}</pre></div><p>After obtaining a pointer to a window through the shared context, we draw the sprite on screen. If more than five seconds have passed, we also draw the text, which notifies the player about the possibility of continuing past the intro state, the final piece of the puzzle:</p><div><pre class="programlisting">void State_Intro::Continue(){
    if(m_timePassed &gt;= 5.0f){
        m_stateMgr-&gt;SwitchTo(StateType::MainMenu);
        m_stateMgr-&gt;Remove(StateType::Intro);
    }
}</pre></div><p>Once again, we check if enough time has passed to continue past this state. The actual switching happens when the <code class="literal">SwitchTo</code> method is called. Because we won't need the introduction state on the stack anymore, it removes itself in the next line.</p><p>Although <a id="id159" class="indexterm"/>we won't be needing the last two methods, we still need to implement empty versions of them, like so:</p><div><pre class="programlisting">void State_Intro::Activate(){}
void State_Intro::Deactivate(){}</pre></div><p>Now it's time to sound the fanfares! Our first state's done and is ready for use. Building and launching your application should leave you with something like this:</p><div><img src="img/B04284_05_02.jpg" alt="Implementing the intro state"/></div><p>As illustrated above, the sprite descends all the way to the middle of the screen and displays the message about continuing underneath after five seconds. Upon hitting Spacebar you will find yourself in a black window because we haven't implemented the main menu state yet.</p><p>From this point on, all the repetitive code will be left out. For complete source code, please take a look at the source files of this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>The main menu state</h1></div></div></div><p>The<a id="id160" class="indexterm"/> main menu of any game out there is a major vein in terms of application flow, even though it's mostly overlooked. It's time we took a stab at building one, albeit a very simplistic version, starting as always with the header file:</p><div><pre class="programlisting">class State_MainMenu : public BaseState{
public:
    ...
    void MouseClick(EventDetails* l_details);
private:
    sf::Text m_text;

    sf::Vector2f m_buttonSize;
    sf::Vector2f m_buttonPos;
    unsigned int m_buttonPadding;

    sf::RectangleShape m_rects[3];
    sf::Text m_labels[3];
};</pre></div><p>The unique<a id="id161" class="indexterm"/> method to this class is the <code class="literal">MouseClick</code>. Since we're dealing with a menu here, predictably enough it will be used to process mouse input. For private data members, we have a text variable for the title, size, position and padding size variables for buttons, drawable rectangles for buttons and text variables for button labels. Let's throw it all together:</p><div><pre class="programlisting">void State_MainMenu::OnCreate(){
  m_font.loadFromFile("arial.ttf");
  m_text.setFont(m_font);
  m_text.setString(sf::String("MAIN MENU:"));
  m_text.setCharacterSize(18);

  sf::FloatRect textRect = m_text.getLocalBounds();
  m_text.setOrigin(textRect.left + textRect.width / 2.0f,
    textRect.top + textRect.height / 2.0f);

  m_text.setPosition(400,100);

  m_buttonSize = sf::Vector2f(300.0f,32.0f);
  m_buttonPos = sf::Vector2f(400,200);
  m_buttonPadding = 4; // 4px.

  std::string str[3];
  str[0] = "PLAY";
  str[1] = "CREDITS";
  str[2] = "EXIT";

  for(int i = 0; i &lt; 3; ++i){
    sf::Vector2f buttonPosition(m_buttonPos.x,m_buttonPos.y + 
      (i * (m_buttonSize.y + m_buttonPadding)));
    m_rects[i].setSize(m_buttonSize);
    m_rects[i].setFillColor(sf::Color::Red);

    m_rects[i].setOrigin(m_buttonSize.x / 2.0f,
      m_buttonSize.y / 2.0f);
    m_rects[i].setPosition(buttonPosition);

    m_labels[i].setFont(m_font);
    m_labels[i].setString(sf::String(str[i]));
    m_labels[i].setCharacterSize(12);

    sf::FloatRect rect = m_labels[i].getLocalBounds();
    m_labels[i].setOrigin(rect.left + rect.width / 2.0f,
      rect.top + rect.height / 2.0f);

    m_labels[i].setPosition(buttonPosition);
  }

  EventManager* evMgr = m_stateMgr-&gt;
    GetContext()-&gt;m_eventManager;
  evMgr-&gt;AddCallback(StateType::MainMenu,"Mouse_Left",
    &amp;State_MainMenu::MouseClick,this);
}</pre></div><p>In the <a id="id162" class="indexterm"/>method above, all of the graphical elements get set up. The text data members get defined, origins are set up, and the labels for individual buttons get named. Lastly, the callback for the mouse left click gets set up. This is by no means a sophisticated GUI system. A more robust way of actually designing one will be covered in later chapters, however, this will suit our needs for now.</p><p>When the state gets destroyed, we need to remove its callbacks, as mentioned before:</p><div><pre class="programlisting">void State_MainMenu::OnDestroy(){
    EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager;
    evMgr-&gt;RemoveCallback(StateType::MainMenu,"Mouse_Left");
}</pre></div><p>Upon the state getting activated, we need to check if the main game-play state exists on the state stack in order to adjust the "play" button to instead say "resume":</p><div><pre class="programlisting">void State_MainMenu::Activate(){
    if(m_stateMgr-&gt;HasState(StateType::Game) &amp;&amp; m_labels[0].getString() == "PLAY")
    {
        m_labels[0].setString(sf::String("RESUME"));
        sf::FloatRect rect = m_labels[0].getLocalBounds();
        m_labels[0].setOrigin(rect.left + rect.width / 2.0f,rect.top + rect.height / 2.0f);
    }
}</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>The text origin has to be recalculated again because the dimensions of the <code class="literal">sf::drawable</code> object are now different.</p></div></div><p>The <code class="literal">MouseClick</code> method <a id="id163" class="indexterm"/>can be implemented as follows:</p><div><pre class="programlisting">void State_MainMenu::MouseClick(EventDetails* l_details){
  sf::Vector2i mousePos = l_details-&gt;m_mouse;

  float halfX = m_buttonSize.x / 2.0f;
  float halfY = m_buttonSize.y / 2.0f;
  for(int i = 0; i &lt; 3; ++i){
    if(mousePos.x &gt;= m_rects[i].getPosition().x - halfX &amp;&amp;
      mousePos.x &lt;= m_rects[i].getPosition().x + halfX &amp;&amp;
      mousePos.y &gt;= m_rects[i].getPosition().y - halfY &amp;&amp;
      mousePos.y &lt;= m_rects[i].getPosition().y + halfY)
    {
      if(i == 0){
        m_stateMgr-&gt;SwitchTo(StateType::Game);
      } else if(i == 1){
        // Credits state.
      } else if(i == 2){
        m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;Close();
      }
    }
  }
}</pre></div><p>First, we obtain the mouse position from the event information structure, which gets passed in as the argument. Then we set up some local floating point type variables that will be used to check the boundaries of the buttons and begin looping over all the buttons. Because the origins of every button are set to the absolute middle, we must adjust the position according to that when checking if the mouse position is within the rectangle. If we have a mouse to button collision, an if-else statement checks which ID has collided and performs an action accordingly. In the case of the "play" button being pressed, we switch to the game state. If the exit button is pressed, we invoke the <code class="literal">Window::Close</code> method through the shared context.</p><p>Finally, let's draw the main menu:</p><div><pre class="programlisting">void State_MainMenu::Draw(){
    sf::RenderWindow* window = m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow();
    window-&gt;draw(m_text);
    for(int i = 0; i &lt; 3; ++i){
        window-&gt;draw(m_rects[i]);
        window-&gt;draw(m_labels[i]);
    }
}</pre></div><p>After <a id="id164" class="indexterm"/>obtaining the render window pointer through the shared context, drawing the entire menu is as easy as iterating a few times to draw a button and a label.</p><p>Upon successful compilation and execution, we're again presented with the intro screen. When hitting spacebar, a main menu opens, looking something like this:</p><div><img src="img/B04284_05_03.jpg" alt="The main menu state"/></div><p>It's not the prettiest sight in the world, but it gets the job done. Clicking the <strong>PLAY</strong> button once again leaves us with a black screen, while hitting <strong>EXIT</strong> closes the application. Neat!</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>A sample game state</h1></div></div></div><p>Just to <a id="id165" class="indexterm"/>demonstrate the full use of our system, let's get something bouncing on the screen that will demonstrate switching between the menu, game, and paused states. For testing purposes, a bouncing mushroom from previous chapters will more than suffice. We also need methods for switching to the menu state, as well as the paused state. Knowing that, let's bang out the header for the game-play state:</p><div><pre class="programlisting">class State_Game : public BaseState{
public:
    ...
    void MainMenu(EventDetails* l_details);
    void Pause(EventDetails* l_details);
private:
    sf::Texture m_texture;
    sf::Sprite m_sprite;
    sf::Vector2f m_increment;
};</pre></div><p>We begin, like<a id="id166" class="indexterm"/> many other times, with resource allocation and set up of data members in the <code class="literal">OnCreate</code> method:</p><div><pre class="programlisting">void State_Game::OnCreate(){
    m_texture.loadFromFile("Mushroom.png");
    m_sprite.setTexture(m_texture);
    m_sprite.setPosition(0,0);
    m_increment = sf::Vector2f(400.0f,400.0f);

    EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager;
    evMgr-&gt;AddCallback(StateType::Game,"Key_Escape",&amp;State_Game::MainMenu,this);
    evMgr-&gt;AddCallback(StateType::Game,"Key_P",&amp;State_Game::Pause,this);
}</pre></div><p>After loading the texture and binding the sprite to it, we set up its position, define the increment vector, much like before, and add callbacks to our extra two methods for switching to different states. Of course, we need to remove them upon destruction of the state, like so:</p><div><pre class="programlisting">void State_Game::OnDestroy(){
    EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager;
    evMgr-&gt;RemoveCallback(StateType::GAME,"Key_Escape");
    evMgr-&gt;RemoveCallback(StateType::GAME,"Key_P");
}</pre></div><p>The update method will hold the same code we've used previously:</p><div><pre class="programlisting">void State_Game::Update(const sf::Time&amp; l_time){
  sf::Vector2u l_windSize = m_stateMgr-&gt;GetContext()-&gt;
    m_wind-&gt;GetWindowSize();
  sf::Vector2u l_textSize = m_texture.getSize();

  if((m_sprite.getPosition().x &gt; l_windSize.x - 
    l_textSize.x &amp;&amp; m_increment.x &gt; 0) ||
    (m_sprite.getPosition().x &lt; 0 &amp;&amp; m_increment.x &lt; 0))
  {
      m_increment.x = -m_increment.x;
  }

  if((m_sprite.getPosition().y &gt; l_windSize.y -
    l_textSize.y &amp;&amp; m_increment.y &gt; 0) ||
    (m_sprite.getPosition().y &lt; 0 &amp;&amp; m_increment.y &lt; 0))
  {
      m_increment.y = -m_increment.y;
  }

  m_sprite.setPosition(m_sprite.getPosition().x + 
    (m_increment.x * l_time.asSeconds()), 
    m_sprite.getPosition().y + 
    (m_increment.y * l_time.asSeconds()));
}</pre></div><p>The sprite <a id="id167" class="indexterm"/>position gets checked, and if it is outside of the window boundaries, the increment vector on the appropriate axis gets inverted. Then, the sprite position is updated, taking into account the time passed between frames. It's as regular as clockwork. Let's draw the sprite on the screen:</p><div><pre class="programlisting">void State_Game::Draw(){
    m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow()-&gt;draw(m_sprite);
}</pre></div><p>Now let's implement the methods for switching states:</p><div><pre class="programlisting">void State_Game::MainMenu(EventDetails* l_details){ 
    m_stateMgr-&gt;SwitchTo(StateType::MAIN_MENU); 
}

void State_Game::Pause(EventDetails* l_details){ 
    m_stateMgr-&gt;SwitchTo(StateType::PAUSED); 
}</pre></div><p>Notice that the game state does not remove itself here, just like the main menu state. This means that it's still alive in memory and is waiting to be pushed back to the front of the vector to be updated and rendered again. This allows the user to pop back to the main menu and resume the game state at any time without losing progress.</p><p>Running the application now will transition us through the intro state into the main menu. Hitting the <strong>PLAY</strong> button will leave us with a bouncing mushroom, just like before:</p><div><img src="img/B04284_05_04.jpg" alt="A sample game state"/></div><p>Hitting <a id="id168" class="indexterm"/>the escape key now will bring you back to the main menu, at which point you can choose to click the <strong>RESUME</strong> button to pop back into the game state, or the <strong>EXIT</strong> button to quit the application. There's just one more state left to implement to fully showcase the abilities of this system!</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>The means to pause</h1></div></div></div><p>One might<a id="id169" class="indexterm"/> simply consider navigating to the main menu from the game state as a way of putting the game on pause. While that's technically true, why not explore a second option, which looks much trendier than simply popping the main menu open? After writing so much code, we deserve a nice looking paused state:</p><div><pre class="programlisting">class State_Paused : public BaseState{
public:
    ...
    void Unpause(EventDetails* l_details);
private:
    sf::Text m_text;
    sf::RectangleShape m_rect;
};</pre></div><p>This one is quite simple. Once more, we define an additional method, in this case <code class="literal">Unpause</code>, to switch to a different state. There's also only two data members used in order to draw the text "PAUSED" on screen, as well as a nice semi-transparent backdrop, represented by the <code class="literal">sf::RectangleShape</code>. Let's implement the <code class="literal">OnCreate</code> method for the last time in this chapter:</p><div><pre class="programlisting">void State_Paused::OnCreate(){
    SetTransparent(true); // Set our transparency flag.
    m_font.loadFromFile("arial.ttf");
    m_text.setFont(m_font);
    m_text.setString(sf::String("PAUSED"));
    m_text.setCharacterSize(14);
    m_text.setStyle(sf::Text::Bold);

    sf::Vector2u windowSize = m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow()-&gt;getSize();

    sf::FloatRect textRect = m_text.getLocalBounds();
    m_text.setOrigin(textRect.left + textRect.width / 2.0f,textRect.top + textRect.height / 2.0f);
    m_text.setPosition(windowSize.x / 2.0f, windowSize.y / 2.0f);

    m_rect.setSize(sf::Vector2f(windowSize));
    m_rect.setPosition(0,0);
    m_rect.setFillColor(sf::Color(0,0,0,150));

    EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager;
    evMgr-&gt;AddCallback(StateType::Paused,"Key_P",&amp;State_Paused::Unpause,this);
}</pre></div><p>A distinct<a id="id170" class="indexterm"/> difference here is the use of <code class="literal">m_transparent</code> flag, which is a protected data member of the <code class="literal">BaseState</code> class. Setting it to true means we're allowing the state manager to render the state directly behind this one on the state stack.</p><p>Besides that, we create a rectangle the size of the entire window and set its fill color to black with the alpha channel value of 150 out of the maximum 255. This makes it nice and translucent while darkening everything that's behind it.</p><p>The final part of the method above, quite like all the other ones, is adding the callback to the <code class="literal">Unpause</code> method. Upon destruction of this state, it needs to be removed like so:</p><div><pre class="programlisting">void State_Paused::OnDestroy(){
    EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager;
    evMgr-&gt;RemoveCallback(StateType::Paused,"Key_P");
}</pre></div><p>Now let's draw the rectangle and text we created:</p><div><pre class="programlisting">void State_Paused::Draw(){
    sf::RenderWindow* wind = m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow();
    wind-&gt;draw(m_rect);
    wind-&gt;draw(m_text);
}</pre></div><p>Also, let's implement the <code class="literal">Unpause</code> method by simply switching to the game-play state:</p><div><pre class="programlisting">void State_Paused::Unpause(EventDetails* l_details){ 
    m_stateMgr-&gt;SwitchTo(StateType::Game); 
}</pre></div><p>Because the main game state is the only state that can be paused so far, simply switching back to it is sufficient.</p><p>Now, take <a id="id171" class="indexterm"/>a deep breath and compile the application again. Getting past the intro state, hitting the <strong>PLAY</strong> button in the main menu, and hitting the <strong>P</strong> key on your keyboard will effectively pause the game-play state and darken the screen subtly, while displaying the text <strong>PAUSED</strong> right in the middle, as shown here:</p><div><img src="img/B04284_05_05.jpg" alt="The means to pause"/></div><p>If you have come this far, congratulations! While this is by no means a finished product, it has come a long way from being a static, immovable class that can barely be controlled.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Common mistakes</h1></div></div></div><p>A likely <a id="id172" class="indexterm"/>mistake that might be made when using this system is the absence of registration of newly added states. If you have built a state and it simply draws a black screen when you switch to it, chances are it was never registered in the constructor of <code class="literal">StateManager</code>.</p><p>The window not responding to the <em>F5</em> key being pressed or the close button being hit is a sign of the global callbacks not being set up right. In order to make sure a callback is invoked no matter which state you're in, it must be set up with the state type of 0, like so:</p><div><pre class="programlisting">m_eventManager-&gt;AddCallback(StateType(0),"Fullscreen_toggle",
    &amp;Window::ToggleFullscreen,this);
m_eventManager-&gt;AddCallback(StateType(0),"Window_close",
    &amp;Window::Close,this);</pre></div><p>Finally, remember that when the mouse position is retrieved in the main menu state, the coordinates stored inside the event are automatically relative to the window. Obtaining coordinates through <code class="literal">sf::Mouse::GetPosition</code> is not going to do the same, unless a reference to a <code class="literal">sf::Window</code> class is provided as an argument.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Summary</h1></div></div></div><p>Upon this chapter concluding, you should have everything you need in your tool belt to fashion states that can be transparent, updated in groups, and supported by the rest of our codebase. There's no reason to stop there. Build it again, make it better, faster and implement different features that didn't get covered in this chapter. Expand it, crash it, fix it and learn from it. Nothing is ever good enough, so build onto the knowledge you've gained here.</p><div><blockquote class="blockquote"><p><em>A famous Chinese proverb states: "Life is like a game of chess, changing with each move".</em></p></blockquote></div><p>While that analogy holds true, life can also be like a game with states. Breaking it down into smaller and more manageable parts makes it a whole lot easier to handle. Whether it is life imitating code or code imitating life is irrelevant. Great ideas come from different backgrounds coming together. Hopefully, by the end of this chapter you are taking off with not only the knowledge of simply how to build yet another manager, but also the wisdom to seek inspiration from every resource and idea available. There is no exclusive knowledge, only inclusive thinking. See you in the next chapter!</p></div></body></html>