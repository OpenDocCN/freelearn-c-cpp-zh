["```cpp\n    sudo port install libtool\n    sudo port install libusb +universal\n\n    ```", "```cpp\n    cd OpenNI2-master\n    make\n    cd Bin/x64-Release/\n\n    ```", "```cpp\n    ./SimpleViewer\n\n    ```", "```cpp\nvoid writeDepthBuffer(openni::VideoFrameRef depthFrame){\n  static int depth_buffer_counter=0;\n  char file_name [512];\n  sprintf(file_name, \"%s%d.bin\", \"depth_frame\", depth_buffer_counter);\n  openni::DepthPixel *depthPixels = new openni::DepthPixel[depthFrame.getHeight()*depthFrame.getWidth()];\n  memcpy(depthPixels, depthFrame.getData(), depthFrame.getHeight()*depthFrame.getWidth()*sizeof(uint16_t));\n  std::fstream myFile (file_name, std::ios::out |std::ios::binary);\n  myFile.write ((char*)depthPixels, depthFrame.getHeight()*depthFrame.getWidth()*sizeof(uint16_t));\n  depth_buffer_counter++;\n  printf(\"Dumped Depth Buffer %d\\n\",depth_buffer_counter);\n  myFile.close();\n  delete depthPixels;\n}\n```", "```cpp\n  void writeColorBuffer(openni::VideoFrameRef colorFrame){\n    static int color_buffer_counter=0;\n    char file_name [512];\n    sprintf(file_name, \"%s%d.bin\", \"color_frame\", color_buffer_counter);\n    //basically unsigned char*\n    const openni::RGB888Pixel* imageBuffer = (const openni::RGB888Pixel*)colorFrame.getData();\n    std::fstream myFile (file_name, std::ios::out | std::ios::binary);\n    myFile.write ((char*)imageBuffer, colorFrame.getHeight()*colorFrame.getWidth()*sizeof(uint8_t)*3);\n    color_buffer_counter++;\n    printf(\"Dumped Color Buffer %d, %d, %d\\n\", colorFrame.getHeight(), colorFrame.getWidth(), color_buffer_counter);\n    myFile.close();\n  }\n```", "```cpp\n#version 150 core\n// Input vertex data\nin vec3 vertexPosition_modelspace;\nin vec2 vertexUV;\n// Output data: interpolated for each fragment.\nout vec2 UV;\nout vec4 color_based_on_position;\n// Values that stay constant for the whole mesh\nuniform mat4 MVP;\n//heat map generator\nvec4 heatMap(float v, float vmin, float vmax){\n  float dv;\n  float r=1.0f, g=1.0f, b=1.0f;\n  if (v < vmin)\n    v = vmin;\n  if (v > vmax)\n    v = vmax;\n  dv = vmax - vmin;\n  if (v < (vmin + 0.25f * dv)) {\n    r = 0.0f;\n    g = 4.0f * (v - vmin) / dv;\n  } else if (v < (vmin + 0.5f * dv)) {\n    r = 0.0f;\n    b = 1.0f+4.0f*(vmin+0.25f*dv-v)/dv;\n  } else if (v < (vmin + 0.75f * dv)) {\n    r = 4.0f*(v-vmin-0.5f*dv)/dv;\n    b = 0.0f;\n  } else {\n    g = 1.0f+4.0f*(vmin+0.75f*dv-v)/dv;\n    b = 0.0f;\n  }\n  return vec4(r, g, b, 1.0);\n}\nvoid main(){\n  // Output position of the vertex, in clip space: MVP * position\n  gl_Position =  MVP * vec4(vertexPosition_modelspace,1);\n  color_based_on_position = heatMap(vertexPosition_modelspace.z, -3.0, 0.0f);\n  UV = vertexUV;\n}\n```", "```cpp\n#version 150 core\nin vec2 UV;\nout vec4 color;\nuniform sampler2D textureSampler;\nin vec4 color_based_on_position;\nvoid main(){\n  //blend the depth map color with RGB\n  color = 0.5f*texture(textureSampler, UV).rgba+0.5f*color_based_on_position;\n}\n```", "```cpp\n    #include <stdio.h>\n    #include <stdlib.h>\n    //GLFW and GLEW libraries\n    #include <GL/glew.h>\n    #include <GLFW/glfw3.h>\n    //GLM library\n    #include <glm/glm.hpp>\n    #include <glm/gtc/matrix_transform.hpp>\n    #include \"../common/shader.hpp\"\n    #include \"../common/texture.hpp\"\n    #include \"../common/controls.hpp\"\n    #include \"../common/common.h\"\n    #include <fstream>\n    ```", "```cpp\n    GLFWwindow* window;\n    ```", "```cpp\n    const int WINDOWS_WIDTH = 640;\n    const int WINDOWS_HEIGHT = 480;\n    const int IMAGE_WIDTH = 320;\n    const int IMAGE_HEIGHT = 240;\n    float z_offset = 0.0f;\n    float rotateY = 0.0f;\n    float rotateX = 0.0f;\n    ```", "```cpp\n    unsigned short *readDepthFrame(const char *file_path){\n      int depth_buffer_size = DEPTH_WIDTH*DEPTH_HEIGHT*sizeof(unsigned short);\n      unsigned short *depth_frame = (unsigned short*)malloc(depth_buffer_size);\n      char *depth_frame_pointer = (char*)depth_frame;\n      //read the binary file\n      ifstream myfile;\n      myfile.open (file_path, ios::binary | ios::in);\n      myfile.read(depth_frame_pointer, depth_buffer_size);\n      return depth_frame;\n    }\n    unsigned char *readColorFrame(const char *file_path){\n      int color_buffer_size = DEPTH_WIDTH*DEPTH_HEIGHT*sizeof(unsigned char)*3;\n      unsigned char *color_frame = (unsigned char*)malloc(color_buffer_size);\n      //read the binary file\n      ifstream myfile;\n      myfile.open (file_path, ios::binary | ios::in);\n      myfile.read((char *)color_frame, color_buffer_size);\n      return color_frame;\n    }\n    ```", "```cpp\n    static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)\n    {\n      if (action != GLFW_PRESS && action != GLFW_REPEAT)\n        return;\n      switch (key)\n      {\n        case GLFW_KEY_ESCAPE:\n          glfwSetWindowShouldClose(window, GL_TRUE);\n          break;\n        case GLFW_KEY_SPACE:\n          rotateX=0;\n          rotateY=0;\n          break;\n        case GLFW_KEY_Z:\n          rotateX+=0.01;\n          break;\n        case GLFW_KEY_X:\n          rotateX-=0.01;\n          break;\n        case GLFW_KEY_A:\n          rotateY+=0.01;\n          break;\n        case GLFW_KEY_S:\n          rotateY-=0.01;\n          break;\n        default:\n          break;\n      }\n    }\n    ```", "```cpp\n    int main(int argc, char **argv)\n    {\n      if(!glfwInit()){\n        fprintf( stderr, \"Failed to initialize GLFW\\n\" );\n        exit(EXIT_FAILURE);\n      }\n    ```", "```cpp\n      glfwWindowHint(GLFW_SAMPLES, 4);\n      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n      glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    ```", "```cpp\n      g_window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, \"Chapter 5 - 3D Point Cloud Rendering\", NULL, NULL);\n      if(!g_window){\n        fprintf( stderr, \"Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\\n\" );\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n      glfwMakeContextCurrent(g_window);\n      glfwSwapInterval(1);\n    ```", "```cpp\n      glewExperimental = true;\n      if (glewInit() != GLEW_OK) {\n        fprintf(stderr, \"Final to Initialize GLEW\\n\");\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n    ```", "```cpp\n      glfwSetInputMode(g_window,GLFW_STICKY_KEYS,GL_TRUE);\n      glfwSetKeyCallback(g_window, key_callback);\n    ```", "```cpp\n      GLuint program_id = LoadShaders(\"pointcloud.vert\", \"pointcloud.frag\");\n    ```", "```cpp\n      GLfloat *g_vertex_buffer_data = (GLfloat*)malloc(IMAGE_WIDTH*IMAGE_HEIGHT * 3*sizeof(GLfloat));\n      GLfloat *g_uv_buffer_data = (GLfloat*)malloc(IMAGE_WIDTH*IMAGE_HEIGHT * 2*sizeof(GLfloat));\n    ```", "```cpp\n      unsigned short *depth_frame = readDepthFrame(\"depth_frame0.bin\");\n      unsigned char *color_frame = readColorFrame(\"color_frame0.bin\");\n    ```", "```cpp\n      GLuint texture_id = loadRGBImageToTexture(color_frame, IMAGE_WIDTH, IMAGE_HEIGHT);\n    ```", "```cpp\n      //divided by two due to 320x240 instead of 640x480 resolution\n      float cx = 320.0f/2.0f;\n      float cy = 240.0f/2.0f;\n      float fx = 574.0f/2.0f;\n      float fy = 574.0f/2.0f;\n      for(int y=0; y<IMAGE_HEIGHT; y++){\n        for(int x=0; x<IMAGE_WIDTH; x++){\n          int index = y*IMAGE_WIDTH+x;\n          float depth_value = (float)depth_frame[index]/1000.0f; //in meter\n          int ver_index = index*3;\n          int uv_index = index*2;\n          if(depth_value != 0){\n            g_vertex_buffer_data[ver_index+0] = ((float)x- cx)*depth_value/fx;\n            g_vertex_buffer_data[ver_index+1] = ((float)y- cy)*depth_value/fy;\n            g_vertex_buffer_data[ver_index+2] = -depth_value;\n            g_uv_buffer_data[uv_index+0] = (float)x/IMAGE_WIDTH;\n            g_uv_buffer_data[uv_index+1] = (float)y/IMAGE_HEIGHT;\n          }\n        }\n      }\n      //Enable depth test to ensure occlusion:\n      //uncommented glEnable(GL_DEPTH_TEST);\n    ```", "```cpp\n      GLuint matrix_id = glGetUniformLocation(program_id, \"MVP\");\n      GLuint texture_sampler_id = glGetUniformLocation(program_id, \"textureSampler\");\n      GLint attribute_vertex, attribute_uv;\n      attribute_vertex = glGetAttribLocation(program_id, \"vertexPosition_modelspace\");\n      attribute_uv = glGetAttribLocation(program_id, \"vertexUV\");\n    ```", "```cpp\n      GLuint vertex_array_id;\n      glGenVertexArrays(1, &vertex_array_id);\n      glBindVertexArray(vertex_array_id);\n    ```", "```cpp\n      GLuint vertex_buffer;\n      glGenBuffers(1, &vertex_buffer);\n      glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);\n      glBufferData(GL_ARRAY_BUFFER, \n    IMAGE_WIDTH*IMAGE_HEIGHT*2* sizeof(GLfloat), \n    g_uv_buffer_data, GL_STATIC_DRAW);\n    ```", "```cpp\n      GLuint uv_buffer;\n      glGenBuffers(1, &uv_buffer);\n      glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);\n      glBufferData(GL_ARRAY_BUFFER, \n    IMAGE_WIDTH*IMAGE_HEIGHT*3* sizeof(GLfloat), \n    g_vertex_buffer_data, GL_STATIC_DRAW);\n    ```", "```cpp\n      glUseProgram(program_id);\n    ```", "```cpp\n      glActiveTexture(GL_TEXTURE0);\n      glBindTexture(GL_TEXTURE_2D, texture_id);\n      glUniform1i(texture_sampler_id, 0);\n    ```", "```cpp\n      glEnableVertexAttribArray(attribute_vertex);\n      glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);\n      glVertexAttribPointer(attribute_vertex, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n      glEnableVertexAttribArray(attribute_uv);\n      glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);\n      glVertexAttribPointer(attribute_uv, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);\n    ```", "```cpp\n      do{\n        //clear the screen\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n        //compute the MVP matrix from keyboard and mouse input\n        computeViewProjectionMatrices(g_window);\n        //get the View and Model Matrix and apply to the rendering\n        glm::mat4 projection_matrix = getProjectionMatrix();\n        glm::mat4 view_matrix = getViewMatrix();\n        glm::mat4 model_matrix = glm::mat4(1.0);\n        model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateY, glm::vec3(0.0f, 1.0f, 0.0f));\n          model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateX, glm::vec3(1.0f, 0.0f, 0.0f));\n        glm::mat4 mvp = projection_matrix * view_matrix * model_matrix;\n        //send our transformation to the currently bound\n        //shader in the \"MVP\" uniform variable\n        glUniformMatrix4fv(matrix_id, 1, GL_FALSE, &mvp[0][0]);\n        glPointSize(2.0f);\n        //draw all points in space\n        glDrawArrays(GL_POINTS, 0, IMAGE_WIDTH*IMAGE_HEIGHT);\n        //swap buffers\n        glfwSwapBuffers(g_window);\n        glfwPollEvents();\n      }\n      // Check if the ESC key was pressed or the window was closed\n      while(!glfwWindowShouldClose(g_window) && glfwGetKey(g_window, GLFW_KEY_ESCAPE )!=GLFW_PRESS);\n    ```", "```cpp\n      glDisableVertexAttribArray(attribute_vertex);\n      glDisableVertexAttribArray(attribute_uv);\n      glDeleteBuffers(1, &vertex_buffer);\n      glDeleteBuffers(1, &uv_buffer);\n      glDeleteProgram(program_id);\n      glDeleteTextures(1, &texture_id);\n      glDeleteVertexArrays(1, &vertex_array_id);\n      glfwDestroyWindow(g_window);\n      glfwTerminate();\n      exit(EXIT_SUCCESS);\n    }\n    ```", "```cpp\n    /* Handle loading images to texture memory and setting up the parameters */\n    GLuint loadRGBImageToTexture(const unsigned char * image_buffer, int width, int height){\n      int channels;\n      GLuint textureID=0;\n      textureID=initializeTexture(image_buffer, width, height, GL_RGB);\n      return textureID;\n    }\n    GLuint initializeTexture(const unsigned char *image_data, int width, int height, GLenum input_format){\n      GLuint textureID=0;\n      //for the first time we create the image,\n      //create one texture element\n      glGenTextures(1, &textureID);\n      //bind the one element\n      glBindTexture(GL_TEXTURE_2D, textureID);\n      glPixelStorei(GL_UNPACK_ALIGNMENT,1);\n      /* Specify the target texture. Parameters describe the format and type of image data */\n      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, input_format, GL_UNSIGNED_BYTE, image_data);\n      /* Set the magnification method to linear, which returns an weighted average of 4 texture elements */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);\n      /* Set the magnification method to linear, which //returns an weighted average of 4 texture elements */\n      //closest to the center of the pixel \n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n      /* Choose the mipmap that most closely matches the size of the pixel being textured and use the GL_NEAREST criterion (texture element nearest to the center of the pixel) to produce texture value. */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n      glGenerateMipmap(GL_TEXTURE_2D);\n      return textureID;\n    }\n    ```", "```cpp\n    GLuint loadRGBImageToTexture(const unsigned char *image_data, int width, int height);\n    GLuint initializeTexture(const unsigned char *image_data, int width, int height, GLenum input_format = GL_RGBA);\n    ```", "```cpp\n    //initial position of the camera\n    glm::vec3 g_position = glm::vec3( 0, 0, 3.0 );\n    const float speed = 3.0f; // 3 units / second\n    float g_initial_fov = glm::pi<float>()*0.25f;\n    //compute the view matrix and projection matrix based on \n    //user input\n    void computeViewProjectionMatrices(GLFWwindow* window){\n      static double last_time = glfwGetTime();\n      // Compute time difference between current and last frame\n      double current_time = glfwGetTime();\n      float delta_time = float(current_time - last_time);\n      int width, height;\n      glfwGetWindowSize(window, &width, &height);\n      //direction vector for movement\n      glm::vec3 direction_z(0, 0, -0.5);\n      glm::vec3 direction_y(0, 0.5, 0);\n      glm::vec3 direction_x(0.5, 0, 0);\n      //up vector\n      glm::vec3 up = glm::vec3(0,-1,0);\n      if (glfwGetKey( window, GLFW_KEY_UP ) == GLFW_PRESS){\n        g_position += direction_y * delta_time * speed;\n      }\n      else if (glfwGetKey( window, GLFW_KEY_DOWN ) == GLFW_PRESS){\n        g_position -= direction_y * delta_time * speed;\n      }\n      else if (glfwGetKey( window, GLFW_KEY_RIGHT ) == GLFW_PRESS){\n        g_position += direction_z * delta_time * speed;\n      }\n      else if (glfwGetKey( window, GLFW_KEY_LEFT ) == GLFW_PRESS){\n        g_position -= direction_z * delta_time * speed;\n      }\n      else if (glfwGetKey( window, GLFW_KEY_PERIOD ) == GLFW_PRESS){\n        g_position -= direction_x * delta_time * speed;\n      }\n      else if (glfwGetKey( window, GLFW_KEY_COMMA ) == GLFW_PRESS){\n        g_position += direction_x * delta_time * speed;\n      }\n      /* update projection matrix: Field of View, aspect ratio, display range : 0.1 unit <-> 100 units */\n      g_projection_matrix = glm::perspective(g_initial_fov, (float)width/(float)height, 0.01f, 100.0f);\n\n      // update the view matrix\n      g_view_matrix = glm::lookAt(\n        g_position,           // camera position\n        g_position+direction_z, //viewing direction\n        up                  // up direction\n      );\n      last_time = current_time;\n    }\n    ```", "```cpp\nif(depth_value != 0){\n  g_vertex_buffer_data[ver_index+0] = ((float)x-cx)*depth_value/fx;\n  g_vertex_buffer_data[ver_index+1] = ((float)y-cy)*depth_value/fy;\n  g_vertex_buffer_data[ver_index+2] = -depth_value;\n  g_uv_buffer_data[uv_index+0] = (float)x/IMAGE_WIDTH;\n  g_uv_buffer_data[uv_index+1] = (float)y/IMAGE_HEIGHT;\n}\nelse{\n  g_vertex_buffer_data[ver_index+0] = ((float)x-cx)*0.2f/fx;\n  g_vertex_buffer_data[ver_index+1] = ((float)y-cy)*0.2f/fy;\n  g_vertex_buffer_data[ver_index+2] = 0;\n}\n```"]