- en: Chapter 8. Creating Alien Attack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The framework has come on in leaps and bounds and we are almost ready to make
    our first game. We are going to create a simple 2D sidescrolling shooter in the
    vein of the classic ''80''s and ''90''s shooter games such as R-Type or Pulstar.
    However, the game will not be set in space. Aliens have attacked earth and only
    you and your weaponized helicopter can stop them. One level of fast-paced action
    is available in the source code downloads and this chapter will cover the steps
    taken to create it. Here is a screenshot of the game we will be creating:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Alien Attack](img/6821OT_08_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'And another slightly more hectic shot:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Alien Attack](img/6821OT_08_02.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: 'There are still a few things that the framework must handle before we can create
    this game. These additions include:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Sound
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of the chapter you will have a good understanding of how this game
    was built using the framework and you will have the ability to continue and improve
    it. In this chapter, we will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sound
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating game-specific object classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooting and detecting bullets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating different enemy types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a game
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SDL_mixer extension for sound
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SDL_mixer extension has its own Mercurial repository that can be used to
    grab the latest source for the extension. It is located at [http://hg.libsdl.org/SDL_mixer](http://hg.libsdl.org/SDL_mixer).
    The TortoiseHg application can again be used to clone the extension''s Mercurial
    repository. Follow these steps to build the library:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Open up TortoiseHg and press *CTRL*+*SHIFT*+*N* to start cloning a new repository.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type [http://hg.libsdl.org/SDL_mixer](http://hg.libsdl.org/SDL_mixer) into the
    source box.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Destination** will be `C:\SDL2_mixer`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit **Clone** and wait for completion.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\SDL2_mixer\VisualC\` and open `SDL_mixer.vcproj` in Visual Studio
    2010.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As long as the x64 folder outlined in [Chapter 2](ch02.html "Chapter 2. Drawing
    in SDL"), *Drawing in SDL* was created, the project will convert with no issues.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to build the library without MP3 support as we are not going to
    need it, and also it does not work particularly well with SDL 2.0.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `MP3_MUSIC_DISABLED` to the **Preprocessor Definitions** in the project
    properties, which can be found by navigating to **C/C++** | **Preprocessor**,
    and build as per the `SDL_image` instructions in [Chapter 2](ch02.html "Chapter 2. Drawing
    in SDL"), *Drawing in SDL*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the SoundManager class
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game created in this chapter will not need any advanced sound manipulation,
    meaning the `SoundManager` class is quite basic. The class has only been tested
    using the `.ogg` files for music and the `.wav` files for sound effects. Here
    is the header file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `SoundManager` class is a singleton; this makes sense because there should
    only be one place that the sounds are stored and it should be accessible from
    anywhere in the game. Before sound can be used, `Mix_OpenAudio` must be called
    to set up the audio for the game. `Mix_OpenAudio` takes the following parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundManager` 类是一个单例；这样做是有道理的，因为声音应该只存储在一个地方，并且应该可以从游戏的任何地方访问。在使用声音之前，必须调用
    `Mix_OpenAudio` 来设置游戏音频。`Mix_OpenAudio` 函数接受以下参数：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is done in the `SoundManager`'s constructor with values that will work
    well for most games.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `SoundManager` 的构造函数中完成的，使用对大多数游戏都适用的值。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `SoundManager` class stores sounds in two different `std::map` containers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundManager` 类使用两个不同的 `std::map` 容器来存储声音：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These maps store pointers to one of two different types used by `SDL_mixer`
    (`Mix_Chunk*` and `Mix_Music*`), keyed using strings. The `Mix_Chunk*` types are
    used for sound effects and the `Mix_Music*` types are of course used for music.
    When loading a music file or a sound effect into `SoundManager`, we pass in the
    type of sound we are loading as an `enum` called `sound_type`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些映射存储了 `SDL_mixer` 使用的两种不同类型的指针（`Mix_Chunk*` 和 `Mix_Music*`），使用字符串作为键。`Mix_Chunk*`
    类型用于音效，而 `Mix_Music*` 类型当然用于音乐。当将音乐文件或音效加载到 `SoundManager` 中时，我们传递一个名为 `sound_type`
    的 `enum` 来表示要加载的声音类型。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This type is then used to decide which `std::map` to add the loaded sound to
    and also which `load` function to use from `SDL_mixer`. The `load` function is
    defined in `SoundManager.cpp`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型用于决定将加载的声音添加到哪个 `std::map` 中，以及从 `SDL_mixer` 中使用哪个 `load` 函数。`load` 函数在
    `SoundManager.cpp` 中定义。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once a sound has been loaded it can be played using the **playSound** or **playMusic**
    functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了声音，就可以使用 `**playSound**` 或 `**playMusic**` 函数来播放：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both of these functions take the ID of the sound to be played and the amount
    of times that it is to be looped. Both functions are very similar.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都接受要播放的声音的 ID 和要循环播放的次数。这两个函数非常相似。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One difference between `Mix_PlayMusic` and `Mix_PlayChannel` is that the latter
    takes an `int` as the first parameter; this is the channel that the sound is to
    be played on. A value of **-1** (as seen in the preceding code) tells `SDL_mixer`
    to play the sound on any available channel.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mix_PlayMusic` 和 `Mix_PlayChannel` 之间的一个区别是后者将一个 `int` 作为第一个参数；这是声音要播放的通道。值为
    **-1**（如前述代码所示）告诉 `SDL_mixer` 在任何可用的通道上播放声音。'
- en: 'Finally, when the `SoundManager` class is destroyed, it will call `Mix_CloseAudio`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当 `SoundManager` 类被销毁时，它将调用 `Mix_CloseAudio`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And that's it for the `SoundManager` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundManager` 类的内容到此结束。'
- en: Setting up the basic game objects
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本游戏对象
- en: 'The majority of the work that went into creating Alien Attack was done in the
    object classes, while almost everything else was already being handled by manager
    classes in the framework. Here are the most important changes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Alien Attack 所做的绝大多数工作都是在对象类中完成的，而框架中几乎所有的其他工作都是由管理类处理的。以下是最重要的更改：
- en: GameObject revamped
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GameObject` 进行了改进'
- en: The `GameObject` base class has a lot more to it than it previously did.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject` 基类比之前要复杂得多。'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This class now has a lot of the member variables that used to be in `SDLGameObject`.
    New variables for checking whether an object is updating, doing the death animation,
    or is dead, have been added. Updating is set to true when an object is within
    the game screen after scrolling with the game level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类现在有很多以前在 `SDLGameObject` 中使用的成员变量。新增了一些变量来检查对象是否正在更新、是否正在执行死亡动画或已经死亡。当对象在滚动游戏级别后位于游戏屏幕内时，更新设置为
    true。
- en: In place of a regular pointer to `LoaderParams` in the load function, an `std::unique_ptr`
    pointer is now used; this is part of the new **C++11 standard** and ensures that
    the pointer is deleted after going out of scope.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载函数中，用 `std::unique_ptr` 指针代替了常规的 `LoaderParams` 指针；这是 **C++11 标准** 的一部分，并确保指针在超出作用域后会被删除。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are two new functions that each derived object must now implement (whether
    it''s owned or inherited):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有两个新的函数，每个派生对象都必须实现（无论是所有者还是继承）：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: SDLGameObject is now ShooterObject
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SDLGameObject` 现在更名为 `ShooterObject`'
- en: 'The `SDLGameObject` class has now been renamed to `ShooterObject` and is a
    lot more specific to this type of game:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDLGameObject` 类现在已更名为 `ShooterObject`，并且更具体地针对这种类型的游戏：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class has default implementations for draw and update that can be used
    in derived classes; they are essentially the same as the previous `SDLGameObject`
    class, so we will not cover them here. A new function that has been added is `doDyingAnimation`.
    This function is responsible for updating the animation when enemies explode and
    then setting them to dead so that they can be removed from the game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此类为绘制和更新提供了默认实现，这些实现可以在派生类中使用；它们基本上与之前的 `SDLGameObject` 类相同，所以我们在这里不会介绍它们。新增的一个函数是
    `doDyingAnimation`。此函数负责在敌人爆炸时更新动画，并将它们设置为死亡状态，以便可以从游戏中移除。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Player inherits from ShooterObject
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家继承自 `ShooterObject`
- en: 'The **Player** object now inherits from the new `ShooterObject` class and implements
    its own update function. Some new game-specific functions and variables have been
    added:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家** 对象现在继承自新的 `ShooterObject` 类，并实现了自己的更新函数。一些新的游戏特定函数和变量已被添加：'
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ressurect` function resets the player back to the center of the screen
    and temporarily makes the `Player` object invulnerable; this is visualized using
    `alpha` of the texture. This function is also responsible for resetting the size
    value of the texture which is changed in `doDyingAnimation` to accommodate for
    the explosion texture:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ressurect` 函数将玩家重置到屏幕中心，并暂时使 `Player` 对象免疫伤害；这一效果通过纹理的 `alpha` 值来可视化。此函数还负责重置在
    `doDyingAnimation` 中更改的纹理大小值，以适应爆炸纹理：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Animation is a big part of the feel of the `Player` object; from flashing (when
    invulnerable), to rotating (when moving in a forward or backward direction). This
    has led to there being a separate function dedicated to handling animation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是 `Player` 对象感觉的重要组成部分；从闪烁（当无敌时），到旋转（当向前或向后移动时）。这导致有一个专门处理动画的独立函数：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The angle and `alpha` of an object are changed using new parameters to the
    `drawFrame` function of `TextureManager`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TextureManager` 的 `drawFrame` 函数的新参数来改变对象的角和 `alpha` 值：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally the `Player::update` function ties this all together while also having
    extra logic to handle when a level is complete:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Player::update` 函数将所有这些整合在一起，同时还有额外的逻辑来处理关卡完成的情况：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once a level is complete and the player has flown offscreen, the `Player::update`
    function also tells the game to increment the current level:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦关卡完成且玩家飞出屏幕，`Player::update` 函数还会告诉游戏增加当前关卡：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Game::setCurrentLevel` function changes the state to `BetweenLevelState`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game::setCurrentLevel` 函数将状态更改为 `BetweenLevelState`：'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Lots of enemy types
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多敌人类型
- en: 'A game such as Alien Attack needs a lot of enemy types to keep things interesting;
    each with its own behavior. Enemies should be easy to create and automatically
    added to the collision detection list. With this in mind, the `Enemy` class has
    now become a base class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 像外星攻击这样的游戏需要很多敌人类型来保持趣味性；每种敌人都有自己的行为。敌人应该易于创建并自动添加到碰撞检测列表中。考虑到这一点，`Enemy` 类现在已成为一个基类：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All enemy types will derive from this class, but it is important that they do
    not override the `type` method. The reason for this will become clear once we
    move onto our games collision detection classes. Go ahead and take a look at the
    enemy types in the Alien Attack source code to see how simple they are to create.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有敌人类型都将从这个类派生，但重要的是它们不要覆盖 `type` 方法。原因将在我们转向游戏碰撞检测类时变得清晰。现在请查看 Alien Attack
    源代码中的敌人类型，看看它们是如何简单易创建的。
- en: '![Lots of enemy types](img/6821OT_08_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![许多敌人类型](img/6821OT_08_10.jpg)'
- en: Adding a scrolling background
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加滚动背景
- en: 'Scrolling backgrounds are important to 2D games like this; they help give an
    illusion of depth and movement. This `ScrollingBackground` class uses two destination
    rectangles and two source rectangles; one expands while the other contracts. Once
    the expanding rectangle has reached its full width, both rectangles are reset
    and the loop continues:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动背景对于像这样的 2D 游戏非常重要；它们有助于营造深度和运动感。这个 `ScrollingBackground` 类使用两个目标矩形和两个源矩形；一个扩展，另一个收缩。一旦扩展的矩形达到其完整宽度，两个矩形都会重置，循环继续：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Handling bullets
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理子弹
- en: Most objects in the game fire bullets and they all pretty much need to be checked
    for collisions against bullets as well; the bottom line—bullets are important
    in Alien Attack. The game has a dedicated `BulletHandler` class that handles the
    creation, destruction, updating, and rendering of bullets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的大多数对象都会发射子弹，它们几乎都需要检查与子弹的碰撞；总之——子弹在《外星攻击》中非常重要。游戏有一个专门的`BulletHandler`类来处理子弹的创建、销毁、更新和渲染。
- en: Two types of bullets
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两种类型的子弹
- en: 'There are two types of bullets in the game, `PlayerBullet` and `EnemyBullet`,
    both of which are handled in the same `BulletManager` class. Both of the bullet
    classes are declared and defined in `Bullet.h`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中有两种子弹，`PlayerBullet`和`EnemyBullet`，它们都在同一个`BulletManager`类中处理。这两个子弹类都在`Bullet.h`中声明和定义：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Bullets are very simple, they just move in one direction and at a certain speed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹非常简单，它们只朝一个方向以一定速度移动。
- en: The BulletHandler class
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`BulletHandler`类'
- en: 'The `BulletHandler` class uses two public functions to add bullets:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulletHandler`类使用两个公共函数来添加子弹：'
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `BulletHandler` class is also a singleton. So, if an object wants to add
    a bullet to the game, it can do so using one of the above functions. Here is an
    example from the `ShotGlider` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulletHandler`类也是一个单例。因此，如果对象想要向游戏中添加子弹，它可以使用上述函数之一。以下是从`ShotGlider`类中的一个示例：'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will add a bullet at the current location of `ShotGlider`, with a heading
    vector of *V*(-10,0).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`ShotGlider`的当前位置添加一个子弹，其航向向量为*V*(-10,0)。
- en: 'Both `add` functions are very similar; they create a new instance of `PlayerBullet`
    or `EnemyBullet` and then push it into the correct vector. Here are their definitions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`add`函数非常相似；它们创建`PlayerBullet`或`EnemyBullet`的新实例，然后将它推入正确的向量中。以下是它们的定义：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A big advantage of having a separate place to store bullets like this, rather
    than have objects themselves manage their own bullets, is that there is no need
    to pass objects around just to get their bullets to check collisions against.
    This `BulletHandler` class gives us a centralized location that we can then easily
    pass to the collision handler.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象自己管理自己的子弹相比，在这样一个单独的地方存储子弹的一个大优点是，不需要传递对象来仅仅获取它们的子弹以检查碰撞。这个`BulletHandler`类为我们提供了一个集中的位置，我们可以轻松地将它传递给碰撞处理器。
- en: 'The `update` and `draw` functions are essentially just loops that call each
    bullet''s respective functions, however the `update` function will also destroy
    any bullets that have gone off the screen:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`和`draw`函数本质上只是循环调用每个子弹的相应函数，然而`update`函数还会销毁任何已经离开屏幕的子弹：'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Dealing with collisions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: 'With so many bullets flying around and having the `Enemy` objects to check
    collisions against, it is important that there be a separate class that does this
    collision checking for us. This way we know where to look if we decide we want
    to implement a new way of checking for collisions or optimize the current code.
    The `Collision.h` file contains a static method that checks for collisions between
    two `SDL_Rect` objects:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在周围飞舞着这么多子弹，并且需要检查与`Enemy`对象碰撞的情况下，有一个单独的类来为我们进行碰撞检测是非常重要的。这样，如果我们决定要实现一种新的碰撞检测方式或优化现有代码，我们就知道该往哪里查找。`Collision.h`文件包含一个静态方法，用于检查两个`SDL_Rect`对象之间的碰撞：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function makes use of a buffer, which is a value that is used to make the
    rectangles slightly smaller. In a game such as Alien Attack, exact collision on
    bounding rectangles would be slightly unfair and also not much fun. With the buffer
    value, more direct hits are needed before they will be registered as a collision.
    Here the buffer is set to `4`; this will take a fourth off of each side of the
    rectangle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了一个缓冲区，这是一个用于使矩形稍微小一点的价值。在像《外星攻击》这样的游戏中，精确的碰撞检测在边界矩形上可能会稍微不公平，而且也不太有趣。使用缓冲区值，需要更直接的命中才能被注册为碰撞。这里缓冲区设置为`4`；这将从矩形的每一边减去四分之一。
- en: 'The `Player` class will not handle its own collisions. This requires a way
    to separate out the player from the rest of the `GameObject` instants when the
    level is loaded. The `Level` class now stores a pointer to `Player`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`类不会处理自己的碰撞。当关卡加载时，需要一种方法将玩家从其他`GameObject`实例中分离出来。现在`Level`类存储了一个指向`Player`的指针：'
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With a public getter and setter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公共获取器和设置器：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `LevelParser` instance sets this pointer when it loads in `Player` from
    the level file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当`LevelParser`实例从关卡文件中加载`Player`时，它会设置这个指针：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Another addition to `Level` is that it holds a separate `std::vector` of `TileLayer*`
    which are tile layers that the game will check against for collisions. This value
    is passed in from the `.tmx` file and any `TileLayer` that needs to be checked
    for collisions must set `collidable` as a property in the tiled application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Level`的另一个新增功能是它包含一个单独的`std::vector`，其中包含`TileLayer*`，这些是游戏将用于碰撞检查的瓦片层。这个值来自`.tmx`文件，任何需要检查碰撞的`TileLayer`都必须在tiled应用程序中将`collidable`属性设置为属性。'
- en: '![Dealing with collisions](img/6821OT_08_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![处理碰撞](img/6821OT_08_07.jpg)'
- en: 'This also requires a slight alteration in `LevelParser::parseLevel` when checking
    for object layers, just in case the layer does contain properties (in which case
    data would no longer be the first child element):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求在检查对象层时对`LevelParser::parseLevel`进行轻微的修改，以防该层包含属性（在这种情况下，数据将不再是第一个子元素）：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `LevelParser` instance can now add collision layers to the collision layers
    array in `parseTileLayer`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelParser`实例现在可以在`parseTileLayer`中将碰撞层添加到碰撞层数组中：'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a CollisionManager class
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个`CollisionManager`类
- en: 'The class responsible for checking and handling all of these collisions is
    the `CollisionManager` class. Here is its declaration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 负责检查和处理所有这些碰撞的类是`CollisionManager`类。以下是它的声明：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Looking at the source code you will see that these functions are pretty big,
    yet they are relatively simple. They loop through each object that requires a
    collision test, create a rectangle for each, and then pass it to the static `RectRect`
    function defined in `Collision.h`. If a collision occurred then it calls the `collision`
    function for that object. The `checkEnemyPlayerBulletCollision` and `checkPlayerEnemyCollision`
    functions perform an extra check to see if the object is actually of `Enemy` type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码你会发现这些函数相当大，但它们相对简单。它们遍历每个需要碰撞测试的对象，为每个对象创建一个矩形，然后将它传递到在`Collision.h`中定义的静态`RectRect`函数。如果发生碰撞，它将调用该对象的`collision`函数。`checkEnemyPlayerBulletCollision`和`checkPlayerEnemyCollision`函数执行额外的检查，以查看对象是否实际上是`Enemy`类型：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If it is not, then it does not check the collision. This is why it is important
    that the `Enemy` subtypes do not override the `type` function or if they do, their
    type must also be added to this check. This condition also checks whether the
    object is updating or not; if it is not, then it is offscreen and does not need
    to be checked against for collision.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，则不会检查碰撞。这就是为什么确保`Enemy`子类型不覆盖`type`函数，或者如果它们覆盖了，它们的类型也必须添加到这个检查中，这一点很重要。这个条件还会检查对象是否正在更新；如果不是，那么它已经不在屏幕上，不需要检查碰撞。
- en: 'Checking for collision against tiles requires a similar method to working out
    where to start drawing the tiles from, which was implemented in the `TileLayer::render`
    function. Here is the `checkPlayerTileCollision` definition:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与瓦片的碰撞需要与确定从哪里开始绘制瓦片的方法类似，这已在`TileLayer::render`函数中实现。以下是`checkPlayerTileCollision`的定义：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Possible improvements
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的改进
- en: 'Alien Attack is a pretty robust game at the moment; we highly recommend looking
    through the source code and becoming familiar with every aspect of it. Once you
    have a good understanding of most of the areas of the game, it is a lot easier
    to see where certain areas could be enhanced. Here are some ideas that could be
    added to improve the game:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目前《外星攻击》是一款相当稳健的游戏；我们强烈建议查看源代码并熟悉它的每个方面。一旦你对游戏的大部分区域有了很好的理解，就更容易看到某些区域可以如何增强。以下是一些可以添加到游戏中以改进游戏的想法：
- en: Bullets could be created at the start of a level and stored in an object pool;
    so rather than creating and deleting bullets all the time they can be pulled from
    and put back into the object pool. The main advantage of this approach is that
    the creation and destruction of objects can be quite expensive when it comes to
    performance. Eliminating this while the game is running could give a real performance
    boost.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹可以在关卡开始时创建并存储在对象池中；因此，而不是不断创建和删除子弹，它们可以从对象池中取出并放回。这种方法的主要优点是，当涉及到性能时，对象的创建和销毁可能相当昂贵。在游戏运行时消除这一点可以真正提高性能。
- en: Collision detection could be optimized further, possibly through the addition
    of a **Quadtree** to stop unnecessary collision checks.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测可以进一步优化，可能通过添加一个**四叉树**来停止不必要的碰撞检查。
- en: The source code has a few areas that use string comparisons to check types.
    This can be a bit of a performance hog, so other options such as using `enums`
    as types may be a better option.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码中有几个区域使用字符串比较来检查类型。这可能会对性能产生一定影响，因此使用`枚举`作为类型等其它选项可能是一个更好的选择。
- en: You may have noticed areas yourself that you feel you could improve upon. Working
    on these within the context of a game, where you can test the results, is a great
    learning experience.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能自己已经注意到了一些你认为可以改进的地方。在游戏的背景下对这些进行工作，在那里你可以测试结果，是一种很好的学习体验。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The framework has been successfully used to create a game—Alien Attack. Throughout
    this chapter, the most important parts of the game were covered, along with a
    short explanation of why they were designed in such a way. With the source code
    for this game available, there is now a great project to start practicing with.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架已被成功用于创建一款游戏——外星人攻击。在本章中，我们涵盖了游戏最重要的部分，并简要解释了为什么它们被设计成这样。由于这款游戏的源代码现在可用，因此现在有一个很好的项目可以开始练习。
