- en: Chapter 10. Introducing Lua!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In our last game, we''ll move to the new Cocos IDE and develop an entire game
    using the Lua scripting language. You''ll get to know and use the Lua bindings
    for the Cocos2d-x API, which is not much different from what we''ve been using
    in C++; if anything, it''s just a lot easier!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, you''ll learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and publish a project in Cocos IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code an entire game in Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use sprites, particles, labels, menus, and actions, but this time with the Lua
    bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a match-three game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what is Lua like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of Lua (which means moon in Portuguese), you have the table. You
    may think of it as being similar to a JavaScript object, only it's much more than
    that. It plays the part of arrays, dictionaries, enumerations, structures, and
    classes, among other things. It makes Lua the perfect language to manage large
    sets of data. You write a script that handles the data, and then keep feeding
    it different "stuff." An inventory or shop system, an interactive children's book—these
    types of projects could all benefit from Lua's table-centric power, as they can
    be built around a fixed template with a data table at its core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its syntax, for those not used to a scripting language, can be a little odd,
    with its dos, thens, and ends. But once you get past this initial hurdle, you''ll
    find Lua quite user-friendly. Here are some of the "oddities" in its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semicolons are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'A table can be turned into a template to generate instances of it, in other
    words, a class. Methods of the instance of the table must be accessed with a `:`
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From inside the method, you refer to the instance of the class as `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can call the template''s method with a dot notation, passing
    the instance of that template to it as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I admit, it's weird, but it can be useful at times as pretty much every method
    you write in Lua can be made available for other parts of your code—sort of the
    way static methods are used in traditional OOP languages.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Lua – the knights who say nil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Debugging your Lua code can be frustrating at times. But you soon learn to
    distinguish between the minute subtleties in Lua''s runtime errors. The compiler
    will say something is `nil` (Lua''s `null`) in about 99.9 percent of cases. It''s
    up to you to figure out why. Here are the main culprits:'
  prefs: []
  type: TYPE_NORMAL
- en: You are referencing an object's own property without prepending `self.` or `self:`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are calling an instance method with a dot notation, and not passing the
    instance as the first parameter; something like `myObject.myMethod()` instead
    of `myObject.myMethod(myObject)`. Use `myObject:myMethod()` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are referencing a variable from a place outside its scope. For example,
    a local variable declared inside an `if` statement is being referenced outside
    the conditional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You forgot to return the class object at the end of your class or module/table
    declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You tried to access the zero index of an array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You forgot to add a few dos and thens or ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, maybe you're just having one of those days. A `nil` sort of day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cocos IDE will show errors in bold; the same bold it uses for global variables,
    which is confusing at times. But it helps nonetheless. Just make a habit of scanning
    your code for bold text!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might need to increase the heap memory inside the IDE. The quickest way
    to accomplish this is to find the file called `eclipse.ini` inside the Cocos IDE
    application folder. On a Mac, this means inside the Cocos IDE app package: right-click
    on the app icon, select **Show Package Contents**, and then navigate to **Contents/MacOS/eclipse.ini**.'
  prefs: []
  type: TYPE_NORMAL
- en: Then find the line where you read `-Xmx256m` or `-Xmx512m` and change it to
    `-Xmx1024m`.
  prefs: []
  type: TYPE_NORMAL
- en: This might help in slower computers. My laptop crashed a lot while running the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The game – Stone Age
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a match-three game. You know, the kind of game that is making a couple
    of companies a gazillion dollars and making a gazillion other companies clone
    those games in order to earn a couple of dollars. Yes, that game!
  prefs: []
  type: TYPE_NORMAL
- en: You must match three or more gems. If you match more than three, a random gem
    bursts and turns into a diamond, which you collect for more points.
  prefs: []
  type: TYPE_NORMAL
- en: The game has a timer, and when time runs out, it's game over.
  prefs: []
  type: TYPE_NORMAL
- en: I used pretty much the same structure as in the previous games in this book.
    But I broke it into separate modules so it's easier for you to use the code as
    a reference.
  prefs: []
  type: TYPE_NORMAL
- en: We have a `MenuScene` and a `GameScene` item. I have pretty much all Cocos2d-x
    actions in one module called `GridAnimations` and most of the interactivity inside
    another module called `GridController`. And all object pools are kept inside a
    class called `ObjectPools`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a grid game, so it''s perfect to illustrate working with table arrays
    in Lua, and its main advantages over C++: it''s much easier to create and memory
    manage dynamic lists (arrays) in Lua. This flexibility, aligned with Cocos2d-x''s
    awesomeness, make for very rapid prototyping and development. The actual game
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game – Stone Age](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: But before you import the starter project, let me show you how to create a new
    project inside the Cocos IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating or importing a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing could be simpler; since the IDE is based on Eclipse, you know most
    of its main functionalities already:'
  prefs: []
  type: TYPE_NORMAL
- en: First let's set up the IDE to use the Lua bindings. Go to **Preferences** |
    **Cocos** | **Lua**, and in the drop-down menu for **Lua Frameworks**, find the
    Cocos2d-x framework folder you downloaded:![Time for action – creating or importing
    a project](img/00040.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File** | **New** | **Cocos Lua Project**, if that option is already
    available, or select **File** | **New** | **Other** | **Cocos Lua** | **Cocos
    Lua Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New Cocos Project** wizard, give your project a name and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next dialogue, you can choose your project's orientation and design size.
    And that's it. Click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to import a project, click **File** | **Import** then **Cocos** | **Import
    Cocos Project**, and navigate to the project start folder for this chapter. The
    game is called `StoneAge`. (Download this chapter's source files from this book's
    website if you haven't done so already. There is a starter project and a final
    project that you can run and test.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learned to create and import a project into the Cocos IDE. Since the IDE
    is an Eclipse-based program, the steps should be familiar to you by now.
  prefs: []
  type: TYPE_NORMAL
- en: You may also wish to change the settings for the simulator. For that, all you
    need to do is right-click on your project and select either **Run As...** or **Debug
    As...**, and then **Run** or **Debug Configurations**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s best to leave the default for the **Mac OSX** runtime (if you''re on
    a Mac of course), as this is the fastest option. But if you wish to change the
    simulator, here is where you do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On my machine, version 3.4 of the framework threw compile errors. I had to
    add two fixes in order to run Stone Age. In `cocos-cocos2d-Cocos2dConstants.lua`,
    just before the last table is declared, I added this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, in `cocos-ui-GuiConstants.lua`, I added `ccui.LayoutComponent = {}`
    before new tables are added to `LayoutComponent`, also near the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: If you run into problems, switch to version 3.3, which was much more stable
    for Lua development.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up our screen resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The old `AppDelegate` class logic now exists inside a file called `main.lua`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the IDE, open the `main.lua` file inside the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the line where we set the animation interval, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I designed the game for iPhone retina, and here we set the appropriate scale
    and asset folder for both retina and non-retina phones. Next, let''s preload the
    sound files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, let''s set the ball rolling by creating and running our first
    scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like we've done in pretty much every game so far, we set the resolution policy
    and scale factor for our application and preloaded the sounds we'll be using.
  prefs: []
  type: TYPE_NORMAL
- en: The game was designed only for phones this time, and it was designed with the
    iPhone 4 screen in mind, and it resizes to older phones.
  prefs: []
  type: TYPE_NORMAL
- en: But don't run the game just yet. Let's create our menu scene. It has a little
    of everything in it and it will be a perfect introduction to the Cocos2d-x API
    in Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a menu scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new file and add a menu scene to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `src` folder and select **New** | **Lua File**; call the
    new file `MenuScene.lua`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a class that extends a scene. We first load our own module of
    all the game''s constants (this file already exists in the starter project):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we build our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll add the methods next, including the `init` method we called in the class
    constructor (always called `ctor`), but I wanted to stress the importance of returning
    the class at the end of its declaration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So moving just below the constructor, let''s continue building up our scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we added a background and two other sprites, plus an animation of
    a pterodactyl flying in the background. Once again, the calls are remarkably similar
    to the ones in C++.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s add a menu with a play button (all this still inside the `init`
    method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Typing the button's callback inside the same method where the callback is referenced
    is similar to writing a block or even a lambda function in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You created a scene in Lua with Cocos2d-x using a menu, a few sprites, and an
    animation. It's easy to see how similar the calls are in the Lua bindings to the
    original C++ ones. And with code completion inside the IDE, finding the correct
    methods is a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's tackle the `GameScene` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the nicest features of Lua is something called **live coding**, and
    it''s switched on by default in the Cocos IDE. To see what I mean by live coding,
    do this: while the game is running in the simulator, change the position of the
    character sprite in your code and save it. You should see the change taking effect
    in the simulator. This is a great way to build UI and game scenes.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating our game scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GameScene` class is already added to the start project and some of the
    code is already in place. We''ll focus first on building the game''s interface
    and listening to touches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on the `addTouchEvents` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, we register the events with the node''s instance of the event dispatcher.
    The actual touches are handled by our `GridController` object. We''ll go over
    those later; first, let''s build the UI. Time to work on the `init` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create our special objects, one to handle user interactivity, another for animations,
    and our good old object pool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we add a couple of nodes and our score labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main difference when compared to the C++ implementation of `Label:createWithTTF`
    is that, in Lua, we have a configuration table for the font.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This time, we saw how to register for touch events and how to create true type
    font labels. Next, we'll go over creating a typical grid for a match-three game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – building the gems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are basically two types of match-three games, those in which the selection
    of matches takes place automatically and those in which the matches are selected
    by the player. *Candy Crush* is a good example of the former, and *Diamond Dash*
    of the latter. When building the first type of game, you must add extra logic
    to ensure you start the game with a grid that contains no matches. This is what
    we''ll do now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `buildGrid` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that we generate a different random series of gems each time we run the
    game by changing the `randomseed` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `enabled` property will stop user interactions while the grid is being altered
    or animated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The grid is a two-dimensional array of columns of gems. The magic happens in
    the `getVerticalUnique` and `getVerticalHorizontalUnique` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To ensure that none of the gems will form a three-gem-match on the first two
    columns, we check them vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All this code is doing is checking a column to see if any gem is forming a string
    of three connected gems of the same type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we check both vertically and horizontally, starting with column 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This algorithm is doing the same thing we did previously with the columns, but
    it's also checking on individual rows.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a grid of gems, free of any three-gem matches. Again, if we had built
    the sort of match-three game where the user must select clusters of matched gems
    to have these removed from the grid (like *Diamond Dash*), we would not have to
    bother with this logic at all.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's manipulate the grid with gem swaps, identification of matches, and
    grid collapse.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – changing the grid with GridController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GridController` object initiates all grid changes since it''s where we
    handle touches. In the game, the user can drag a gem to swap places with another,
    or first select the gem they want to move and then select the gem they want to
    swap places with in a two-touch process. Let''s add the touch handling for that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GridController`, let''s add the logic to `onTouchDown`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we are displaying the game over screen, restart the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we find the gem the user is trying to select:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We find the gem closest to the touch position. If the user has not selected
    a gem yet (`selectedGem = nil`), we set the one just touched as the first gem
    selected. Otherwise, we determine whether the second gem selected can be used
    for a swap. Only gems above and below the first selected gem, or the ones to the
    left and right of it, can be swapped with. If that is valid, we use the second
    gem as the target gem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before moving on to `onTouchMove` and `onTouchUp`, let''s see how we determine
    which gem is being selected and which gem is a valid target gem. So let''s work
    on the `findGemAtPosition` value. Begin by determining where in the grid container
    the touch landed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is where the magic happens. We use the `x` and `y` position of the touch
    inside the grid to determine the index of the gem inside the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We finish by checking whether the touch is out of array bounds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And now let''s see the logic to determine whether the target gem is a valid
    target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We first check to see whether the target gem is at the top, bottom, left, or
    right of the selected gem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We next use a bit of trig magic to determine whether the selected target gem
    is diagonal to the selected gem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We finish by checking whether the target gem is not the same as the previously
    selected gem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the `onTouchUp` event handling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pretty simple! We just change the `z` layering of the selected gem, as we want
    to make sure that the gem is shown above the others when the swap takes place.
    So when we release the gem, we push it back to its original `z` level (which is
    what the `dropSelectedGem` method does, and we'll see how it does this soon).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `onTouchMove` event handles the option of dragging the selected gem until
    it swaps places with another gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We run most of the same logic as we did with `onTouchDown`. We move the `selectedGem`
    object until a suitable target gem is identified, and then we pick the second
    one as the target. This is when the swap happens. Let's do that now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, the logic that sets our selected gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start the swapping process; we have a selected gem but no target gem. We
    change the layering of the selected gem through `setLocalZOrder`. We also make
    the selected gem rotate 360 degrees.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we''re ready to select the target gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is now that we finally call our `GameScene` class and ask it to swap the
    gems.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just added the logic to handle all the user interactivity. Now, all that's
    left for us to do is handle the swaps, checking for matches and collapsing the
    grid. Let's do it!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – swapping the gems and looking for matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The swapping logic is found in `GameScene` in the `swapGemsToNewPosition` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `swapGemsToNewPosition` method makes one call to `GridAnimations` to animate
    the swap between the selected and target gem. Once this animation is complete,
    we fire a `onNewSwapComplete` method. The majority of the logic takes place in
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we have a match, we run animations on the matched gems, otherwise we play
    a swap back animation and play a sound effect to represent a wrong move by the
    player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of each new animation, be it the match one or the swap back one,
    we once again run callbacks listed at the top of the method. The most important
    thing these do is the call to `collapseGrid` done when the matched gems finish
    animating inside the `onMatchedAnimatedOut` callback:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We end the callback by clearing the selected gems and start with a clean slate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And here, at the end of the function, we call the swap gems animation with
    `onNewSwapComplete` as its callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s move back to `GridController` and add the `checkGridMatches` method.
    This is broken into three parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method starts the check by running `checkTypeMatch` on each cell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `checkTypeMatch` method searches around the current index and looks for
    matches at the top, bottom, left, and right of the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If any matches are found, they are added to the `matches` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But first we need to make sure there are no duplicates listed there, so when
    we add a gem to the `matches` array, we check whether it has not been added already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the simple method to look for duplicates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding matches is more than half the necessary logic for any match-three game.
    All you need to do is traverse the grid as effectively as you can and look for
    repeated patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the logic concerns the grid collapse. We'll do that next and then
    we're ready to publish the game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – collapsing the grid and repeating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So the flow of the game is move pieces around, look for matches, remove those,
    collapse the grid and add new gems, look for matches again, and if necessary,
    do the whole process in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the longest method in the game, and again, most of the logic happens
    inside callbacks. First we tag the gems being removed by setting their type data
    to `-1`. All the gems inside `matchArray` will be removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we traverse the grid''s columns and rearrange the gems whose type is
    not equal to `-1` inside the column arrays. Essentially, we update the data here
    so that gems above the ones removed "fall down". The actual change will take place
    in the `animateCollapse` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But now, let''s code the callback of that animation called `onGridCollapseComplete`.
    So above the code we''ve entered already inside `collapseGrid`, we add the `local`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we update the array of sprites, sorting them by the new `x` and `y` indexes
    of the grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we check for matches again. Remember that this callback runs after the
    grid collapse animation has finished, which means new gems have been added already
    and these may create new matches (we''ll look at the logic soon):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, if we find no more matches, we replace some random gems with diamonds
    if the value for combos is above 0 (meaning we had more than a 3 gem match in
    the last player''s move):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And we pick random gems for the diamonds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Animate the diamonds being collected, and at the end of that animation, call
    back `onMatchedAnimatedOut`, which will collapse the grid once more now that we
    had gems "burst" into diamonds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the whole `collapseGrid` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collapseGrid` method collects all the gems affected by matches or gems
    which exploded into diamonds. The resulting array is sent to `GridAnimations`
    for the proper animations to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: We'll work on those next and finish our game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating matches and collapses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now for the last bit of logic: the final animations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the easy ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This rotates a gem; we use this animation when a gem is first selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next is the swap animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All this does is swap the places of the first selected gem and the target gem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we add the animations we run for matched gems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will scale down a gem to nothing, and only fire the final callback when
    all gems have finish scaling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next is the collect diamonds animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This moves the diamonds to where the diamond score label is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And now, finally, add the grid collapse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We loop through all the gems and identify the ones that have been scaled down,
    meaning the ones which were *removed*. We move these above the column, so they
    will fall down as new gems, and we pick a new type for them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ones which were not removed will drop to their new positions. The way we
    do this is simple. We count how many gems were removed until we reached a gem
    which has not been removed. That count is stored in the local variable drop, which
    is reset to `0` with every column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That way, we know how many gems were removed below other gems. We use that to
    find the new `y` position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `dropGemTo` new position looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, we only fire the final callback once all gems have collapsed. This final
    callback will run another check for matches, as we've seen earlier, starting the
    whole process again.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That''s it; we have the three main parts of a match-three game: the swap, the
    matches, and the collapse.'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one animation we haven't covered, which is already included in
    the code for this chapter, and that is the column drop for the intro animation
    when the grid is first created. But there's nothing new with that one. Feel free
    to review it, though.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to publish the game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – publishing the game with the Cocos IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build and publish the game, we''ll need to tell the IDE a few things.
    I''ll show you how to publish the game for Android, but the steps are very similar
    for any of the other targets:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's tell the IDE where to find the Android SDK, NDK, and ANT, just
    as we did when we installed the Cocos2d-x console. In the IDE, open the **Preferences**
    panel. Then, under **Cocos**, enter the three paths just like we did before (remember
    that for ANT, you need to navigate to its `bin` folder).![Time for action – publishing
    the game with the Cocos IDE](img/00042.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in order to build the project, you need to select the fourth button at
    the top of the IDE (from the left-hand side), or right-click on your project and
    select **Cocos Tools**. You'll have different options available depending on which
    stage you are at in the deployment process.![Time for action – publishing the
    game with the Cocos IDE](img/00043.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, the IDE needs to add the native code support, and then it builds the
    project inside a folder called frameworks (it will contain an iOS, Mac OS, Windows,
    Android, and Linux version of your project just as if you had created it through
    the Cocos console).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can then choose to package the application into an APK or IPA, which you
    can transfer to your phone. Or, you can use the generated project inside Eclipse
    or Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just built your Lua game to Android, or iOS, or Windows, or Linux, or Mac
    OS, or all of them! Well done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it. You can now choose between C++ or Lua to build your games. The whole
    API can be accessed either way. So, every game created in this book can be done
    in either language (and yes, that includes the Box2D API.)
  prefs: []
  type: TYPE_NORMAL
- en: And this is it for the book. I hope you're not too tired to start working on
    your own ideas. And I hope to see your game sometime soon in an App Store near
    me!
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Vector Calculations with Cocos2d-x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix will cover some of the math concepts used in [Chapter 5](part0072_split_000.html#page
    "Chapter 5. On the Line – Rocket Through"), *On the Line – Rocket Through*, in
    a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: What are vectors?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's do a quick refresh on vectors and the way you can use Cocos2d-x
    to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is the difference between a vector and a point? At first, they seem
    to be the same. Consider the following point and vector:'
  prefs: []
  type: TYPE_NORMAL
- en: Point (2, 3.5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vec2 (2, 3.5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure illustrates a point and a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are vectors?](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this figure, they each have the same value for *x* and *y*. So what's the
    difference?
  prefs: []
  type: TYPE_NORMAL
- en: With a vector, you always have extra information. It is as if, besides those
    two values for *x* and *y*, we also have the *x* and *y* of the vector's origin,
    which in the previous figure we can assume to be point (0, 0). So the vector is
    *moving* in the direction described from point (0, 0) to point (2, 3.5). The extra
    information we can derive then from vectors is direction and length (usually referred
    to as magnitude).
  prefs: []
  type: TYPE_NORMAL
- en: It's as if a vector is a person's stride. We know how long each step is, and
    we know the direction in which the person is walking.
  prefs: []
  type: TYPE_NORMAL
- en: In game development, vectors can be used, among other things, to describe movement
    (speed, direction, acceleration, friction, and so on) or the combining forces
    acting upon a body.
  prefs: []
  type: TYPE_NORMAL
- en: The vector methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a lot you can do with vectors, and there are many ways to create them
    and manipulate them. And Cocos2d-x comes bundled with helper methods that will
    take care of most of the calculations for you. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a vector, and you want to get its angle—use `getAngle()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want the length of a vector—use `getLength()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to subtract two vectors; for example, to reduce the amount of movement
    of a sprite by another vector—use `vector1 - vector2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to add two vectors; for example, to increase the amount of movement
    of a sprite by another vector—use `vector1 + vector2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to multiply a vector; for example, applying a friction value to the
    amount of movement of a sprite—use `vector1 * vector2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want the vector that is perpendicular to another (also known as a vector's
    normal)—use `getPerp()` or `getRPerp()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, most importantly for our game example, you want the dot product of two
    vectors—use `dot(vector1, vector2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let me show you how to use these methods in our game example.
  prefs: []
  type: TYPE_NORMAL
- en: Using ccp helper methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the example of *Rocket Through*, the game we developed in [Chapter 5](part0072_split_000.html#page
    "Chapter 5. On the Line – Rocket Through"), *On the Line – Rocket Through*, we
    used vectors to describe movement, and now I want to show you the logic behind
    some of the methods we used to handle vector operations and what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the rocket around a point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start, as an example, with the rocket sprite moving with a vector of
    (5, 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotating the rocket around a point](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then draw a line from the rocket, say from point **A** to point **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotating the rocket around a point](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we want the rocket to rotate around point **B**. So how can we change the
    rocket's vector to accomplish that? With Cocos2d-x, we can use the helper point
    method `rotateByAngle` to rotate a point around any other point. In this case,
    we rotate the rocket's position point around point **B** by a certain angle.
  prefs: []
  type: TYPE_NORMAL
- en: But here's a question – in which direction should the rocket rotate?
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotating the rocket around a point](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By looking at this figure, you know that the rocket should rotate clockwise,
    since it''s moving towards the right. But programmatically, how could we determine
    that, and in the easiest way possible? We can determine this by using vectors
    and another property derived from them: the dot product.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the dot product of vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dot product of two vectors describes their angular relationship. If their
    dot product is greater than zero, the two vectors form an angle smaller than 90
    degrees. If it is less than zero, the angle is greater than 90 degrees. And if
    it is equal to zero, the vectors are perpendicular. Have a look at this descriptive
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the dot product of vectors](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: But one other way to think about this is that if the dot product is a positive
    value, then the vectors will "point" in the same direction. If it is a negative
    value, they point in opposite directions. How can we use that to help us?
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector will always have two perpendiculars, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the dot product of vectors](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These perpendiculars are often called right and left, or clockwise and counterclockwise
    perpendiculars, and they are themselves vectors, known as normals.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we calculate the dot product between the rocket's vector and each of
    the perpendiculars on line **AB**, you can see that we can determine the direction
    the rocket should rotate in. If the dot product of the rocket and the vector's
    right perpendicular is a positive value, it means the rocket is moving towards
    the right (clockwise). If not, it means the rocket is moving towards the left
    (counterclockwise).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the dot product of vectors](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The dot product is very easy to calculate. We don't even need to bother with
    the formula (though it's a simple one), because we can use the `d` `ot(vector1,
    vector2)` method.
  prefs: []
  type: TYPE_NORMAL
- en: So we have the vector for the rocket already. How do we get the vector for the
    normals? First, we get the vector for the **AB** line. We use another method for
    this – `point1 - point2`. This will subtract points **A** and **B** and return
    a vector representing that line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can get the left and right perpendiculars of that line vector with
    the `getPerp()` and `getRPerp()` methods respectively. However, we only need to
    check one of these. Then we get the dot product with `dot(rocketVector, lineNormal)`.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the correct normal, meaning the value for the dot product is a positive
    one, we can rotate the rocket to point to this normal's direction; so the rocket
    will be at a 90-degree angle with the line at all times as it rotates. This is
    easy, because we can convert the normal vector to an angle with the `getAngle()`
    method. All we need to do is apply that angle to the rocket.
  prefs: []
  type: TYPE_NORMAL
- en: But how fast should the rocket rotate? We'll see how to calculate that next.
  prefs: []
  type: TYPE_NORMAL
- en: Moving from pixel-based speed to angular-based speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When rotating the rocket, we still want to show it moving at the same speed
    as it was when moving in a straight line, or as close to it as possible. How do
    we do that?
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving from pixel-based speed to angular-based speed](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that the vector is being used to update the rocket's position in every
    iteration. In the example I gave you, the (5, 0) vector is currently adding 5
    pixels to the x position of the rocket in every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's consider an angular speed. If the angular speed were 15 degrees, and
    we kept rotating the rocket's position by that angle, it would mean the rocket
    would complete a full circle in 24 iterations. Because 360 degrees of a full circle
    divided by 15 degrees equals 24.
  prefs: []
  type: TYPE_NORMAL
- en: But we don't have the correct angle yet; we only have the amount in pixels the
    rocket moves in every iteration. But math can tell us a lot here.
  prefs: []
  type: TYPE_NORMAL
- en: Math says that the length of a circle is *twice the value of Pi, multiplied
    by the radius of the circle*, usually written as *2πr*.
  prefs: []
  type: TYPE_NORMAL
- en: We know the radius of the circle we want the rocket to describe. It is the length
    of the line we drew.
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving from pixel-based speed to angular-based speed](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With that formula, we can get the length in pixels of that circle, also known
    as its circumference. Let's say the line has a length of 100 pixels; this would
    mean the circle about to be described by the rocket has a length (or circumference)
    of 628.3 pixels (2 * π * 100).
  prefs: []
  type: TYPE_NORMAL
- en: With the speed described in the vector (5, 0), we can determine how long it
    would take the rocket to complete that pixel length. We don't need this to be
    absolutely precise; the last iteration will most likely move beyond that total
    length, but it's good enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving from pixel-based speed to angular-based speed](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When we have the total number of iterations to complete the length, we can convert
    that to an angle. So, if the iteration value is 125, the angle would be 360 degrees
    divided by 125; that is, 2.88\. That would be the angle required to describe a
    circle in 125 iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving from pixel-based speed to angular-based speed](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the rocket can change from pixel-based movement to angular-based movement
    without much visual change.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B. Pop Quiz Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 4, Fun with Sprites – Sky Defense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pop quiz – sprites and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Q1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 8, Getting Physical – Box2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Q1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 3 |'
  prefs: []
  type: TYPE_TB
