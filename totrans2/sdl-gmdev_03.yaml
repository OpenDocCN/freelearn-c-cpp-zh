- en: Chapter 3. Working with Game Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All games have objects, for example, players, enemies, **non-player character**
    (**NPC**), traps, bullets, and doors. Keeping track of all these objects and how
    they interact with each other is a big task and one that we would like to make
    as simple as possible. Our game could become unwieldy and difficult to update
    if we do not have a solid implementation. So what can we do to make our task easier?
    We can start by really trying to leverage the power of **object-oriented programming**
    (**OOP**). We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using abstract base classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective inheritance design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first powerful feature of OOP we will look at is inheritance. This feature
    can help us enormously when developing our reusable framework. Through the use
    of inheritance, we can share common functionality between similar classes and
    also create subtypes from existing types. We will not go into too much detail
    about inheritance itself but instead we will start to think about how we will
    apply it to our framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, all games have objects of various types. In most cases,
    these objects will have a lot of the same data and require a lot of the same basic
    functions. Let''s look at some examples of this common functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all of our objects will be drawn to the screen, thus requiring a `draw`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our objects are to be drawn, they will need a location to draw to, that is,
    x and y position variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't want static objects all the time, so we will need an `update` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects will be responsible for cleaning up after themselves; a function that
    deals with this will be important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a good starting point for our first game object class, so let''s go
    ahead and create it. Add a new class to the project called `GameObject` and we
    can begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The public, protected, and private keywords are very important. Public functions
    and data are accessible from anywhere. Protected status restricts access to only
    those classes derived from it. Private members are only available to that class,
    not even its derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there we have our first game object class. Now let''s inherit from it and
    create a class called `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have achieved is the ability to reuse the code and data that we originally
    had in `GameObject` and apply it to our new `Player` class. As you can see, a
    derived class can override the functionality of a parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can even use the functionality of the parent class, while also having
    its own additional functionality on top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we call the `draw` function from `GameObject` and then define some player-specific
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `::` operator is called the scope resolution operator and it is used to
    identify the specific place that some data or function resides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so far our classes do not do much, so let''s add some of our SDL functionality.
    We will add some drawing code to the `GameObject` class and then reuse it within
    our `Player` class. First we will update our `GameObject` header file with some
    new values and functions to allow us to use our existing SDL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have some new member variables that will be set in the new `load` function.
    We are also passing in the `SDL_Renderer` object we want to use in our `draw`
    function. Let''s define these functions in an implementation file and create `GameObject.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First define our new `load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are setting all of the values we declared in the header file. We will
    just use a start value of `1` for our `m_currentRow` and `m_currentFrame` values.
    Now we can create our `draw` function that will make use of these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We grab the texture we want from `TextureManager` using `m_textureID` and draw
    it according to our set values. Finally we can just put something in our `update`
    function that we can override in the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `GameObject` class is complete for now. We can now alter the `Player` header
    file to reflect our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move on to defining these functions in an implementation file. Create
    `Player.cpp` and we''ll walk through the functions. First we will start with the
    `load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can use our `GameObject::load` function. And the same applies to our
    `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s override the `update` function with something different; let''s
    animate this one and move it in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are all set; we can create these objects in the `Game` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then load them in the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'They will then need to be added to the `render` and `update` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one more thing to add to make this run correctly. We need to cap our
    frame rate slightly; if we do not, then our objects will move far too fast. We
    will go into more detail about this in a later chapter, but for now we can just
    put a delay in our main loop. So, back in `main.cpp`, we can add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run to see our two separate objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using inheritance](img/6821OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our `Player` class was extremely easy to write, as we had already written some
    of the code in our `GameObject` class, along with the needed variables. You may
    have noticed, however, that we were copying code into a lot of places in the `Game`
    class. It requires a lot of steps to create and add a new object to the game.
    This is not ideal, as it would be easy to miss a step and also it will get extremely
    hard to manage and maintain when a game goes beyond having two or three different
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: What we really want is for our `Game` class not to need to care about different
    types; then we could loop through all of our game objects in one go, with separate
    loops for each of their functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This leads us to our next OOP feature, polymorphism. What polymorphism allows
    us to do is to refer to an object through a pointer to its parent or base class.
    This may not seem powerful at first, but what this will allow us to do is essentially
    have our `Game` class need only to store a list of pointers to one type and any
    derived types can also be added to this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take our `GameObject` and `Player` classes as examples, with an added
    derived class, `Enemy`. In our `Game` class we have an array of `GameObject*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare four new objects, all of which are `GameObject*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Game::init` function we can then create instances of the objects using
    their individual types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now they can be pushed into the array of `GameObject*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Game::draw` function can now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are looping through all of our objects and calling the `draw`
    function. The loop does not care that some of our objects are actually `Player`
    or `Enemy`; it handles them in the same manner. We are accessing them through
    a pointer to their base class. So, to add a new type, it simply needs to be derived
    from `GameObject`, and the `Game` class can handle it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s implement this for real in our framework. First we need a base class;
    we will stick with `GameObject`. We will have to make some changes to the class
    so that we can use it as a base class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we have now prefixed our functions with the virtual keyword. The
    virtual keyword means that when calling this function through a pointer, it uses
    the definition from the type of the object itself, not the type of its pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In other words, this function would always call the `draw` function contained
    in `GameObject`, neither `Player` nor `Enemy`. We would never have the overridden
    behavior that we want. The virtual keyword would ensure that the `Player` and
    `Enemy` draw functions are called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a base class, so let''s go ahead and try it out in our `Game` class.
    We will start by declaring the objects in the `Game` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now declare along with our `GameObject*` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create and load the objects in the `init` function, then push them into
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good; we can now create a loop that will draw our objects and another
    that will update them. Now let''s look at the `render` and `update` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is a lot tidier and also much easier to manage. Let us
    derive one more class from `GameObject` just so that we nail this concept down.
    Create a new class called `Enemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the functions of this class the same as `Player` with only the
    `update` function as an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add it to the game. First, we declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create, load, and add to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have just added a new type and it was extremely quick and simple. Run the
    game to see our three objects, each with their own different behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing polymorphism](img/6821OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have covered a lot here and have a really nice system for handling our game
    objects, yet we still have an issue. There is nothing stopping us from deriving
    a class without the `update` or `draw` functions that we are using here, or even
    declaring a different function and putting the `update` code in there. It is unlikely
    that we, as the developers, would make this mistake, but others using the framework
    may. What we would like is the ability to force our derived classes to have their
    own implementation of a function we decide upon, creating something of a blueprint
    that we want all of our game objects to follow. We can achieve this through the
    use of an abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: Using abstract base classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are to implement our design correctly, then we have to be certain that
    all of our derived classes have a declaration and definition for each of the functions
    we want to access through the base class pointer. We can ensure this by making
    `GameObject` an abstract base class. An abstract base class cannot be initialized
    itself; its purpose is to dictate the design of derived classes. This gives us
    reusability as we know that any object we derive from `GameObject` will immediately
    work in the overall scheme of the game.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract base class is a class that contains at least one pure virtual function.
    A pure virtual function is a function that has no definition and must be implemented
    in any derived classes. We can make a function pure virtual by suffixing it with
    `=0`.
  prefs: []
  type: TYPE_NORMAL
- en: Should we always use inheritance?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance and polymorphism are both very useful and really show off the power
    of object-oriented programming. However, in some circumstances, inheritance can
    cause more problems than it solves, and therefore, we should bear in mind a few
    rules of thumb when deciding whether or not to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Could the same thing be achieved with a simpler solution?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we want to make a more powerful `Enemy` object; it will have the same
    behavior a regular `Enemy` object will have but with more health. One possible
    solution would be to derive a new class `PowerEnemy` from `Enemy` and give it
    double health. In this solution the new class will seem extremely sparse; it will
    use the functionality from `Enemy` but with one different value. An easier solution
    would be to have a way to set the health of an `Enemy` class, whether through
    an accessor or in the constructor. Inheritance isn't needed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Derived classes should model the "is a" relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deriving a class, it is a good idea for it to model the "is a" relationship.
    This means that the derived class should also be of the same type as the parent
    class. For example, deriving a `Player2` class from `Player` would fit the model,
    as `Player2` "is a" `Player`. But let's say, for example, we have a `Jetpack`
    class and we derive `Player` from this class to give it access to all the functionality
    that a `Jetpack` class has. This would not model the "is a" relationship, as a
    `Player` class is not a `Jetpack` class. It makes a lot more sense to say a `Player`
    class has a `Jetpack` class, and therefore, a `Player` class should have a member
    variable of type `Jetpack` with no inheritance; this is known as containment.
  prefs: []
  type: TYPE_NORMAL
- en: Possible performance penalties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On platforms such as PC and Mac, the performance penalties of using inheritance
    and virtual functions are negligible. However, if you are developing for less
    powerful devices such as handheld consoles, phones, or embedded systems, this
    is something that you should take into account. If your core loop involves calling
    a virtual function many times per second, the performance penalties can add up.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now put all of this knowledge together and implement as much as we can
    into our framework, with reusability in mind. We have quite a bit of work to do,
    so let''s start with our abstract base class, `GameObject`. We are going to strip
    out anything SDL-specific so that we can reuse this class in other SDL projects
    if needed. Here is our stripped down `GameObject` abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The pure virtual functions have been created, forcing any derived classes to
    also declare and implement them. There is also now no `load` function; the reason
    for this is that we don't want to have to create a new `load` function for each
    new project. We can be pretty sure that we will need different values when loading
    our objects for different games. The approach we will take here is to create a
    new class called `LoaderParams` and pass that into the constructor of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoaderParams` is simply a class that takes values into its constructor and
    sets them as member variables that can then be accessed to set the initial values
    of an object. While it may just seem that we are moving the parameters from the
    `load` function to somewhere else, it is a lot easier to just create a new `LoaderParams`
    class than to track down and alter the `load` function of all of our objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is our `LoaderParams` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This class holds any values we need when creating our object exactly the same
    way as our `load` function used to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also removed the `SDL_Renderer` parameter from the `draw` function.
    We will instead make our `Game` class a singleton, such as `TextureManager`. So,
    we can add the following to our `Game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Game.cpp`, we have to define our static instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a function in the header file that will return our `SDL_Renderer`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that `Game` is a singleton, we are going to use it differently in our `main.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we want to access the `m_pRenderer` value from `Game`, we can use
    the `getRenderer` function. Now that `GameObject` is essentially empty, how do
    we achieve the code-sharing we originally had? We are going to derive a new generic
    class from `GameObject` and call it `SDLGameObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With this class we can create our reusable SDL code. First, we can use our
    new `LoaderParams` class to set our member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the same `draw` function as before, making use of our singleton
    `Game` class to get the renderer we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`Player` and `Enemy` can now inherit from `SDLGameObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Player` class can be defined like so (the `Enemy` class is very similar):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is in place, we can go ahead and create the objects in
    our `Game` class and see everything in action. We won''t add the objects to the
    header file this time; we will use a shortcut and build our objects in one line
    in the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Build the project. We now have everything in place to allow us to easily reuse
    our `Game` and `GameObject` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of complex subjects in this chapter, and the concepts
    and ideas will take some time to sink in. We have covered the ability to easily
    create classes without having to rewrite a lot of similar functionality and the
    use of inheritance and how it allows us to share code between similar classes.
    We looked at polymorphism and how it can make object management a lot cleaner
    and reusable while abstract base classes took our inheritance knowledge up a notch
    by creating the blueprint we want all of our objects to follow. Finally, we put
    all our new knowledge into the context of our framework.
  prefs: []
  type: TYPE_NORMAL
