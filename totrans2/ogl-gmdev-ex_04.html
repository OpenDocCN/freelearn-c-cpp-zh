<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Control Freak</h1></div></div></div><p>Most games are designed to be interactive. This means that the player must have some way to control what happens during the game. In the last chapter, you wrote code that displayed the robot and moved him across the screen. Now, you will control the robot!</p><p>This chapter will explain how to implement an input system to control the game's character, and interact with the game. Topics will include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Types of input</strong>: There are many ways to interact with your game. Typically, games written for the PC depended on the mouse and keyboard. Direct touch input has now become the standard for mobile and tablet devices, and soon every PC will also have a touch-enabled display. We will cover the most common methods to receive input in your game.</li><li class="listitem" style="list-style-type: disc"><strong>Using the mouse and keyboard</strong>: In this section, you will write code to receive input from the mouse and keyboard to control both the game and our friendly robot.</li><li class="listitem" style="list-style-type: disc"><strong>Creating the user interface</strong>: In addition to controlling our robot, we also need a way to interact with the game. You will learn how to create an onscreen interface that allows you to control the game and choose the game options.</li><li class="listitem" style="list-style-type: disc"><strong>Controlling the character</strong>: We want our robot to be able to walk, run, jump, and play! You will learn how to use the mouse and keyboard to control how your robot moves about on the screen.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>A penny for your input</h1></div></div></div><p>It's likely that at some point in <a id="id216" class="indexterm"/>your life, you have been part of a conversation that seemed one-sided. The other party was talking and talking, and it didn't seem you could get a word in. After a while, such a conversation becomes quite boring!</p><p>The same would happen with a computer game that didn't allow any <strong>input</strong>. Input is a set of techniques that <a id="id217" class="indexterm"/>allows you to control the game. There are many ways to implement an input system, and we will cover them here.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>The keyboard input</h2></div></div></div><p>The most common form of input for most computers is the keyboard. Obviously, the keyboard <a id="id218" class="indexterm"/>can be used to enter text, but the keyboard can also be used to <a id="id219" class="indexterm"/>directly control the game.</p><p>Some examples of this include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the right arrow, left arrow, up arrow, and down arrow keys to control the character (we'll be using this)</li><li class="listitem" style="list-style-type: disc">Using the <em>W</em>, <em>A</em>, <em>S</em>, and <em>D</em> keys as to move the character (these keys almost form a cross on the keyboard, making them a good substitute to move up, left, down, and right, respectively)</li><li class="listitem" style="list-style-type: disc">Using certain keys to perform predefined actions, such as:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <em>Esc</em> key or <em>Q</em> to quit</li><li class="listitem" style="list-style-type: disc">Using the Spacebar or <em>Enter key</em> to fire a projectile</li></ul></div></li></ul></div><p>These are just a few examples. In fact, there are some games that seem to use every key on the keyboard!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Using the mouse</h2></div></div></div><p>The mouse<a id="id220" class="indexterm"/> has been around for a long time, so it makes sense that the <a id="id221" class="indexterm"/>mouse is used in many games. The mouse can be used in several ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The left and right mouse buttons can perform specific actions.</li><li class="listitem" style="list-style-type: disc">The wheel can be pushed and used as a third button.</li><li class="listitem" style="list-style-type: disc">The mouse wheel can be used to scroll.</li><li class="listitem" style="list-style-type: disc">The position of the mouse pointer can be tracked and used in conjunction with any of the previous actions. We will use a combination of the left mouse button and the mouse pointer position to click onscreen buttons when we design our user interface.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Touch</h2></div></div></div><p>More and more<a id="id222" class="indexterm"/> devices now respond to touch. Many input systems treat touch very <a id="id223" class="indexterm"/>similarly to the mouse:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A single touch is equivalent to using the left mouse button</li><li class="listitem" style="list-style-type: disc">A single touch that is held is equivalent to using the right mouse button</li><li class="listitem" style="list-style-type: disc">The position of the finger can be used in the same way as the mouse pointer</li></ul></div><p>However, there are many features of touch that cannot be easily equated to the mouse. For example, most touch interfaces allow several touches to be handled simultaneously. This feature is known as multitouch. This has led to many standard gestures, including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The swipe or flick (moving one or more fingers quickly across the screen)</li><li class="listitem" style="list-style-type: disc">The pinch (moving two fingers together)</li><li class="listitem" style="list-style-type: disc">The zoom (moving two fingers apart)</li></ul></div><p>Unfortunately, we won't be implementing touch in this game because the target device for this book is the PC.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Other inputs</h2></div></div></div><p>The advent<a id="id224" class="indexterm"/> of mobile devices was followed by an explosion of input techniques. Some of the more common ones include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The accelerometer, which can be used to track the physical motion of the device</li><li class="listitem" style="list-style-type: disc">Geolocation, which can be used to detect the physical location of the device</li><li class="listitem" style="list-style-type: disc">The compass, which can be used to detect the orientation of the device</li><li class="listitem" style="list-style-type: disc">The microphone, which can be used to accept voice input</li></ul></div><p>There are many other input techniques, and there is a lot of overlap. For example, most PCs have a microphone. Again, while many games in the mobile market are taking advantage of these alternative input methods, our game will be limited to the keyboard and mouse.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Someone is listening</h1></div></div></div><p>Now, it's time to <a id="id225" class="indexterm"/>actually write some code to implement input for our game. It turns out that some rudimentary input has already been implemented. This is<a id="id226" class="indexterm"/> because Windows is an <strong>event driven</strong> operating system and is already looking for input to occur. From a simplistic point of view, the main task of Windows (or any modern operating system) is to listen for <strong>events</strong>, and then do something based on those events.</p><p>So, whenever <a id="id227" class="indexterm"/>you hit a key on your keyboard, an event is triggered that wakes up Windows and says, "Hey, someone hit the keyboard!" Windows then passes that information to any programs that happen to be listening to keyboard events. The same occurs when you use the mouse.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>The WndProc event listener</h2></div></div></div><p>We have <a id="id228" class="indexterm"/>already told our program that we want it to listen to events. Open <code class="literal">RoboRacer.cpp</code> and locate the <code class="literal">WndProc</code> function. <code class="literal">WndProc</code> is part of the code that was created for us when use used the <strong>Win32 Project template</strong> to start our game. <code class="literal">WndProc</code> is <a id="id229" class="indexterm"/>known as a <strong>callback function</strong>.</p><p>Here is how a callback function works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, the function name is registered with the operating system. In our case, this occurs in <code class="literal">CreateGLWindow</code>:<div><pre class="programlisting">wc.lpfnWndProc = (WNDPROC)WndProc;</pre></div><p>This line tells our window class to register a function called <code class="literal">WndProc</code> as the event handler for our program.</p></li><li class="listitem" style="list-style-type: disc">Now, any events that are caught by Windows are passed to the <code class="literal">WndProc</code> function. The code in <code class="literal">WndProc</code> then decides which events to handle. Any events that aren't handled by <code class="literal">WndProc</code> are simply ignored by the program.</li></ul></div><p>As <code class="literal">WndProc</code> was created for a typical Windows application, it contains some things that we don't need, while there are some things that we can use:</p><div><pre class="programlisting">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  int wmId, wmEvent;
  PAINTSTRUCT ps;
  HDC hdc;
  
  switch (message)
  {
    case WM_COMMAND:
    wmId    = LOWORD(wParam);
    wmEvent = HIWORD(wParam);
    // Parse the menu selections:
    switch (wmId)
    {
      case IDM_ABOUT:
      DialogBox(hInstance, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
      break;
      case IDM_EXIT:
      DestroyWindow(hWnd);
      break;
      default:
      return DefWindowProc(hWnd, message, wParam, lParam);
    }
    break;
    case WM_PAINT:
    hdc = BeginPaint(hWnd, &amp;ps);
    // TODO: Add any drawing code here...
    EndPaint(hWnd, &amp;ps);
    break;
    case WM_DESTROY:
    PostQuitMessage(0);
    break;
    default:
    return DefWindowProc(hWnd, message, wParam, lParam);
  }
  return 0;
}</pre></div><p>The main <a id="id230" class="indexterm"/>work is done by <code class="literal">switch</code>, which handles various <a id="id231" class="indexterm"/>windows events (all prefixed by <strong>WM</strong>, which is an abbreviation for <strong>Windows Message</strong>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">WM_COMMAND</code> events can all be ignored. In a typical Windows application, you would create a menu and then assign various command events to be triggered when the user clicks on a command on the menu (for example, <code class="literal">IDM_ABOUT</code> to click on the <strong>About</strong> command). Games almost never use the standard Windows menu structure (and so, neither do we).</li><li class="listitem" style="list-style-type: disc">We also ignore the <code class="literal">WM_PAINT</code> event. This event is triggered whenever the window containing the program needs to be redrawn. However, we are constantly redrawing our window using OpenGL via the <code class="literal">Render</code> function, so we don't need to add code to do that here.</li><li class="listitem" style="list-style-type: disc">We are<a id="id232" class="indexterm"/> already handling the <code class="literal">WM_DESTROY</code> event. This event is triggered when you click the close icon (<strong>X</strong>) in the upper-right corner of the Windows. Our handler responds to this by posting its own message using <code class="literal">PostQuitMessage(0)</code>. This tells our program that it is time to quit.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Handling the message queue</h2></div></div></div><p>We discussed the Windows messaging system in <a class="link" href="ch01.html" title="Chapter 1. Building the Foundation">Chapter 1</a>, <em>Building the Foundation</em> but this discussion warrants a recap. If <a id="id233" class="indexterm"/>you take a look at the <code class="literal">_wWinMain</code> function, you will see this block of code that sets up the main messaging loop:</p><div><pre class="programlisting">bool done = false;
while (!done)
{
  if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
  {
    if (msg.message == WM_QUIT)
    {
      done = true;
    }
    else
    {
      TranslateMessage(&amp;msg);
      DispatchMessage(&amp;msg);
    }
  }
  else
  {
    int currentTime = glutGet(GLUT_ELAPSED_TIME);
    float deltaTime = (float)(currentTime - previousTime) / 1000;
    previousTime= currentTime;
    GameLoop(deltaTime);
  }
}</pre></div><p>The relevant part of this discussion is the call to <code class="literal">PeekMessage</code>. <code class="literal">PeekMessage</code> queries the message queue. In our case, if the <code class="literal">WM_QUIT</code> message has been posted (by <code class="literal">PostQuitMessage</code>), then done is set to <code class="literal">true</code> and the <code class="literal">while</code> loop exits, ending the game. As long as <code class="literal">WM_QUIT</code> has not been posted, the <code class="literal">while</code> loop will continue and <code class="literal">GameLoop</code> will be called.</p><p>The event driven system is a great way to handle input and other actions for most programs, but it doesn't work well with games. Unlike games, most programs just sit around <a id="id234" class="indexterm"/>waiting for some kind of input to occur. For example, a word processing program waits for either a keystroke, a mouse button click, or a command to be issued. With this type of system, it makes sense to wake up the program every time an event happens so that the event can be processed.</p><p>Games, on the other hand, do not sleep! Whether or not you are pressing a button, the game is still running. Furthermore, we need to be able to control the process so that an input is only processed when we are ready for it to be handled. For example, we don't want input to interrupt our render loop.</p><p>The following diagram shows how Windows is currently rigged to handle input:</p><div><img src="img/8199OS_04_01.jpg" alt="Handling the message queue"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Handling mouse and keyboard inputs</h2></div></div></div><p>We could<a id="id235" class="indexterm"/> expand <code class="literal">WndProc</code> to handle all of the input events. However, this is a terribly inefficient way to handle input, especially in a real-time program, such <a id="id236" class="indexterm"/>as a game. We will let Windows handle the case when the user closes the Window. For everything else, we are going to create our own input class that directly polls for input.</p><p>There are many different ways to design an input system, and I am not going to presume that this is the best system. However, our input system accomplishes two important tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We define a consistent input interface that handles both mouse and keyboard input</li><li class="listitem" style="list-style-type: disc">We handle input by directly polling for mouse and keyboard events during each frame (instead of waiting for Windows to send them to us)</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Creating the Input class</h2></div></div></div><p>Create a<a id="id237" class="indexterm"/> new class called <code class="literal">Input</code>. Then add the following code into <code class="literal">Input.h</code>:</p><div><pre class="programlisting">#pragma once
#include &lt;Windows.h&gt;

class Input
{
  public:
  enum Key
  {
    K_ESC = VK_ESCAPE,
    K_SPACE = VK_SPACE,
    K_LEFT = VK_LEFT,
    K_RIGHT = VK_RIGHT,
    K_UP = VK_UP,
    K_DOWN = VK_DOWN,
    K_W = 87,
    K_A = 65,
    K_S = 83,
    K_D = 68,
    K_Q = 81,
    K_ENTER = VK_RETURN,
    K_LB = VK_LBUTTON,
    K_RB = VK_RBUTTON
    
  };
  
  enum Command
  {
    CM_LEFT,
    CM_RIGHT,
    CM_STOP,
    CM_UP,
    CM_DOWN,
    CM_QUIT
  };
  
  #define KEYDOWN(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 1 : 0)
  
  protected:
  Command m_command;
HWND m_hWnd;
  
  public:
  Input(const HWND m_hWnd);
  ~Input();
  
  void Update(const float p_detlaTime);
  
  const Command GetCommand() const { return m_command; }
};</pre></div><p>As with all<a id="id238" class="indexterm"/> of our code, let's take a close look to see how this is designed:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We include <code class="literal">Windows.h</code> because we want access to the Windows API virtual key constants. These are constants that have been defined to represent special keys on the keyboard and mouse.</li><li class="listitem" style="list-style-type: disc">We create the <code class="literal">Key</code> enum so that we can easily define values to poll the keys that we want to handle.</li><li class="listitem" style="list-style-type: disc">We create the <code class="literal">Command</code> enum so that we can easily map input to command actions that we want to support.</li><li class="listitem" style="list-style-type: disc">We define a C++ macro named <code class="literal">KEYDOWN</code>. This greatly simplifies our future code (see the next step for details).</li><li class="listitem" style="list-style-type: disc">The class only has one member variable, <code class="literal">m_command</code>, which will be used to hold the <a id="id239" class="indexterm"/>last action that was requested.</li><li class="listitem" style="list-style-type: disc">We define three member functions: the constructor, the destructor, <code class="literal">Update</code>, and <code class="literal">GetCommand</code>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Virtual key codes</h2></div></div></div><p>In order to <a id="id240" class="indexterm"/>understand how our input system works, you must first understand virtual key codes. There are a lot of keys on a keyboard. In addition to letters and <a id="id241" class="indexterm"/>numbers, there are special keys, including shift, control, escape, enter, arrow keys, and function keys. Coming up with a simple way to identify each key is quite a task!</p><p>Windows uses two techniques to identify keys; for the normal keys (letters and numbers), each key is identified by the ASCII code of the value that is being tested. The following table shows the ASCII value for the keys that we use in our game:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>ASCII Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Key</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>87</p>
</td><td style="text-align: left" valign="top">
<p>
<em>W</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>65</p>
</td><td style="text-align: left" valign="top">
<p>
<em>A</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>83</p>
</td><td style="text-align: left" valign="top">
<p>
<em>S</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>68</p>
</td><td style="text-align: left" valign="top">
<p>
<em>D</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>81</p>
</td><td style="text-align: left" valign="top">
<p>
<em>Q</em>
</p>
</td></tr></tbody></table></div><p>For special keys, Windows defines integer constants to make them easier to work with. These are known as virtual key codes. The following table shows the virtual key codes that we will work with in our game:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Virtual key code</p>
</th><th style="text-align: left" valign="bottom">
<p>Key</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_ESC</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>Esc</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_SPACE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Spacebar</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_LEFT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Left arrow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_RIGHT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Right arrow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_UP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Up arrow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_DOWN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Down arrow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_RETURN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>Enter</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_LBUTTON</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Left mouse button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VK_RBUTTON</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Right mouse button</p>
</td></tr></tbody></table></div><p>Notice<a id="id242" class="indexterm"/> that there <a id="id243" class="indexterm"/>are even virtual key codes for the mouse buttons!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Querying for input</h2></div></div></div><p>The <code class="literal">GetAsyncKeyState</code> function is used to query the system for both keyboard and mouse input. Here<a id="id244" class="indexterm"/> is an example of that command:</p><div><pre class="programlisting">if ( (getAsyncKeyState(VK_ESC) &amp; 0x8000) == true ) 
{
  PostQuitMessage(0);
}</pre></div><p>First, we pass in a virtual key code (or ASCII value), then we do a logical and with the hex value <code class="literal">8000</code> to strip out information that we don't need. If the result of this call is <code class="literal">true</code>, then the queried key is being pressed.</p><p>It's a pretty awkward command to have to use over and over again! So, we create a C++ macro to make things simpler:</p><div><pre class="programlisting">#define KEYDOWN(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 1 : 0)</pre></div><p>
<code class="literal">KEYDOWN</code> executes the <code class="literal">GetAsyncKeyState</code> command. The macro accepts a key code as a parameter, and returns <code class="literal">true</code> if that key is being pressed or <code class="literal">false</code> if that key is not being pressed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Implementing the Input class</h2></div></div></div><p>All of the <a id="id245" class="indexterm"/>actual work is for our input system is done in the <code class="literal">Update</code> function, so let's implement the <code class="literal">Input</code> class. Open <code class="literal">Input.cpp</code> and enter the following code:</p><div><pre class="programlisting">#include "stdafx.h"
#include "Input.h"

Input::Input(const HWND p_hWnd)
{
  m_command = Command::CM_STOP;
m_hWnd = p_hWnd;
}

Input::~Input()
{
}

void Input::Update(const float p_deltaTime)
{
  m_command = Command::CM_STOP;
  if (KEYDOWN(Key::K_LEFT) || KEYDOWN(Key::K_A))
  {
    m_command = Command::CM_LEFT;
  }
  if (KEYDOWN(Key::K_RIGHT) || KEYDOWN(Key::K_D))
  {
    m_command = Command::CM_RIGHT;
  }
  if (KEYDOWN(Key::K_UP) || KEYDOWN(Key::K_LB))
  {
    m_command = Command::CM_UP;
  }
  if (KEYDOWN(Key::K_DOWN) || KEYDOWN(Key::K_RB))
  {
    m_command = Command::CM_DOWN;
  }
  if (KEYDOWN(Key::K_ESC) || KEYDOWN(Key::K_Q))
  {
    m_command = Command::CM_QUIT;
  }
}</pre></div><p>In a nutshell, the <code class="literal">Update</code> function queries all of the keys that we want to check simultaneously, and then maps those keys to one of the command enums that we have defined in<a id="id246" class="indexterm"/> the class header. The program then calls the class <code class="literal">GetCommand</code> method to determine the current action that has to be taken.</p><p>If you are really paying attention, then you may have realized that we only store a single command result into <code class="literal">m_command</code>, yet we are querying many keys. We can get away with this for two reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This is an infinitely simple input system with few demands</li><li class="listitem" style="list-style-type: disc">The computer cycles through the input at 60 frames per second, so the process of the player pressing and releasing keys is infinitely slow in comparison</li></ul></div><p>Basically, the<a id="id247" class="indexterm"/> last key detected will have its command stored in <code class="literal">m_command</code>, and that's good enough for us.</p><p>Also, notice that we set the initial command to <code class="literal">Input::Command::STOP</code>. As a result, if no key is currently being held down, then the <code class="literal">STOP</code> command will be the final value of <code class="literal">m_command</code>. The result of this is that if we are not pressing keys to make our robot move, then he will stop.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Adding input to the game loop</h2></div></div></div><p>Now that we have an input class, we will implement it in our game. We will handle input by adding <a id="id248" class="indexterm"/>it to <code class="literal">Update</code>. This gives us total control over when and how we handle input. We will only rely on the Windows event listener to tell us if the Window has been closed (so that we can still shut the game down properly).</p><p>Open <code class="literal">RoboRacer.cpp</code> and modify the <code class="literal">Update</code> function so that it looks like the following code:</p><div><pre class="programlisting">void Update(const float p_deltaTime)
{
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput (p_deltaTime);
  
  background-&gt;Update(p_deltaTime);
  robot_left-&gt;Update(p_deltaTime);
  robot_right-&gt;Update(p_deltaTime);
  robot_left_strip-&gt;Update(p_deltaTime);
  robot_right_strip-&gt;Update(p_deltaTime);
}</pre></div><p>Before now, our <code class="literal">Update</code> function only updated the game's sprites. If you recall, the sprite <code class="literal">Update</code> method modifies the position of the sprites. So, it makes sense to perform the input before we update the sprites. The <code class="literal">Update</code> method of the <code class="literal">Input</code> class queries the system for input, and then we run a <code class="literal">ProcessInput</code> to decide what to do.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Processing our input</h2></div></div></div><p>Just before we update all of our sprites, we need to process the input. Remember, the <code class="literal">Input</code> class <code class="literal">Update</code> method only queries the input and stores a command. It doesn't actually<a id="id249" class="indexterm"/> change anything. This is because the <code class="literal">Input</code> class does not have access to our sprites.</p><p>First, open <code class="literal">RoboRacer.cpp</code> and include the Input header file:</p><div><pre class="programlisting">include "Input.h"</pre></div><p>We need to add a variable to point to our <code class="literal">Input</code> class. Add the following line in the variable declarations section:</p><div><pre class="programlisting">Input* inputManager;</pre></div><p>Then, modify <code class="literal">StartGame</code> to instantiate the <code class="literal">Input</code> class:</p><div><pre class="programlisting">void StartGame()
{
  inputManager = new Input(hWnd);
  LoadTextures();
}</pre></div><p>Now, we will create a function to process the input. Add the following function to <code class="literal">RoboRacer.cpp</code>:</p><div><pre class="programlisting">void ProcessInput (const float p_deltaTime);
{
  switch (inputManager-&gt;GetCommand())
  {
    case Input::Command::CM_STOP:
    player-&gt;SetVelocity(0.0f);
    background-&gt;SetVelocity(0.0f);
    break;
    
    case Input::Command::CM_LEFT:
    if (player == robot_right)
    {
      robot_right-&gt;IsActive(false);
      robot_right-&gt;IsVisible(false);
      robot_left-&gt;SetPosition(robot_right-&gt;GetPosition());
    }
    
    player = robot_left;
    player-&gt;IsActive(true);
    player-&gt;IsVisible(true);
    player-&gt;SetVelocity(-50.0f);
    background-&gt;SetVelocity(50.0f);
    break;
    
    case Input::Command::CM_RIGHT:
    if (player == robot_left)
    {
      robot_left-&gt;IsActive(false);
      robot_left-&gt;IsVisible(false);
      robot_right-&gt;SetPosition(robot_left-&gt;GetPosition());
    }
    
    player = robot_right;
    player-&gt;IsActive(true);
    player-&gt;IsVisible(true);
    player-&gt;SetVelocity(50.0f);
    background-&gt;SetVelocity(-50.0f);
    break;
    
    case Input::Command::CM_UP:
    player-&gt;Jump(Sprite::SpriteState::UP);
    break;
    
    case Input::Command::CM_DOWN:
    player-&gt;Jump(Sprite::SpriteState::DOWN);
    break;
    
    case Input::Command::CM_QUIT:
    PostQuitMessage(0);
    break;
  }
}</pre></div><p>
<code class="literal">ProcessInput</code> is where the changes to our game actually take place. Although it seems like a lot of code, there are really only two things that are happening:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We query the input system for the latest command using <code class="literal">inputManager-&gt;GetCommand()</code></li><li class="listitem" style="list-style-type: disc">Based on that command we perform the required actions</li></ul></div><p>The<a id="id250" class="indexterm"/> following table shows the commands that we have defined, followed by a description of how this affects the game:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Command</p>
</th><th style="text-align: left" valign="bottom">
<p>Actions</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CM_STOP</code>
</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set the velocity of <code class="literal">player</code> to <code class="literal">0</code></li><li class="listitem" style="list-style-type: disc">Set the background velocity to <code class="literal">0</code></li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CM_LEFT</code>
</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If <code class="literal">player</code> is currently moving right, deactivate the right sprite and make it invisible, and set the left sprite to the right sprite's position</li><li class="listitem" style="list-style-type: disc">Set <code class="literal">player</code> to the left sprite</li><li class="listitem" style="list-style-type: disc">Activate the left sprite and make it visible</li><li class="listitem" style="list-style-type: disc">Set the velocity of the left sprite to <code class="literal">-50</code></li><li class="listitem" style="list-style-type: disc">Set the velocity of the background to <code class="literal">50</code></li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CM_RIGHT</code>
</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If <code class="literal">player</code> is currently moving left, deactivate the left sprite and make it invisible, and set the right sprite to the left sprite's position</li><li class="listitem" style="list-style-type: disc">Set <code class="literal">player</code> to the right sprite</li><li class="listitem" style="list-style-type: disc">Activate the right sprite and make it visible</li><li class="listitem" style="list-style-type: disc">Set the velocity of the right sprite to <code class="literal">50</code></li><li class="listitem" style="list-style-type: disc">Set the velocity of the background to <code class="literal">-50</code></li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CM_UP</code>
</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call the sprite's <code class="literal">Jump</code> method with the parameter set to <code class="literal">UP</code></li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CM_DOWN</code>
</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call the sprite's <code class="literal">Jump</code> method with the parameter set to <code class="literal">DOWN</code></li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CM_QUIT</code>
</p>
</td><td style="text-align: left" valign="top">
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Quit the game</li></ul></div>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Changes to the Sprite class</h2></div></div></div><p>Now that the robot can jump, we need to add a new method to the <code class="literal">Sprite</code> class to give the robot the <a id="id251" class="indexterm"/>ability to jump:</p><p>First, we will add an enum to Sprite.h to track the sprite state:</p><div><pre class="programlisting"> enum SpriteState
 {
  UP,
  DOWN
 };</pre></div><p>Next, we need a new member variable to track if an element has been clicked. Add:</p><div><pre class="programlisting"> bool m_isClicked;</pre></div><p>Now go to the constructor in Sprite.cpp and add a line to initialize the new variable:</p><div><pre class="programlisting"> m_isClicked = false;</pre></div><p>Add the following code to <code class="literal">Sprite.h</code>:</p><div><pre class="programlisting">void Jump(SpriteState p_state);
void IsClicked(const bool p_value) { m_isClicked = p_value; }
 const bool IsClicked() const { return m_isClicked; }</pre></div><p>Then add the following code to <code class="literal">Sprite.cpp</code>:</p><div><pre class="programlisting">void Sprite::Jump(SpriteState p_state)
{
  if (p_state == SpriteState::DOWN )
  {
    if (m_position.y &lt; 470.0f) m_position.y += 75.0f;
  }
  else if (p_state == SpriteState::UP)
  {
    if (m_position.y &gt;= 470.0f) m_position.y -= 75.0f;
  }
}</pre></div><p>Our robot is a little unique. When he jumps, he hovers at an elevated level until we tell him to come back down. The <code class="literal">Jump</code> method moves the robot <code class="literal">75</code> pixels higher when the player presses the up arrow, and moves him <code class="literal">75</code> pixels back down when the player presses the down arrow. However, we want to make sure that we don't allow a double-jump up or a double-jump down, so we check the current <code class="literal">y</code> position before we apply the change.</p><p>Now that we are going to use input to control our robot, we no longer need to set the initial velocity as we did in the previous chapter.  Locate the following two lines of code in LoadTextures and delete them:</p><div><pre class="programlisting">background-&gt;SetVelocity(-50.0f);
player-&gt;SetVelocity(50.0f);</pre></div><p>Run the game. You should now be able to control the robot with the arrow keys, moving him left and right, up and down. Congratulations, you're a control freak!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Graphical User Interface</h1></div></div></div><p>It is now time to<a id="id252" class="indexterm"/> turn our attention to the graphical user interface, or GUI. The GUI allows us to control other elements of the game, such as starting or stopping the game, or setting various options.</p><p>In this section, you will learn how to create buttons on the screen that can be clicked by the mouse. We'll keep<a id="id253" class="indexterm"/> it simple by adding a single button to pause the game. While we are at it, we will learn important lessons about game state.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Creating a button</h2></div></div></div><p>A button is<a id="id254" class="indexterm"/> nothing more than a texture that is being displayed on the screen. However, we have to perform some special coding to detect whether or not the button is being clicked. We will add this functionality to the sprite class so that our buttons are being handled by the same class that handles other image in our game.</p><p>We will actually create two buttons: one to Pause and one to Resume. I have used a simple graphics program to create the following two buttons:</p><div><img src="img/8199OS_04_02.jpg" alt="Creating a button"/></div><p>I have saved these buttons as, you guessed it, <code class="literal">pause.png</code> and <code class="literal">resume.png</code> in the <code class="literal">resources</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Enhancing the Input class</h2></div></div></div><p>In order to<a id="id255" class="indexterm"/> integrate UI into our existing <code class="literal">Input</code> class, we are going to have to add some additional features. We will add a dynamic array to the <code class="literal">Input</code> class to hold a list of UI elements that we need to check for input.</p><p>Start by adding the following line to the includes for <code class="literal">Input.h</code>:</p><div><pre class="programlisting">#include "Sprite.h"</pre></div><p>We need to include the <code class="literal">Sprite</code> class so that we can work with sprites in the <code class="literal">Input</code> class.</p><p>Next, we add a new command. Modify the <code class="literal">Command</code> enum so that it looks like the following list:</p><div><pre class="programlisting">enum Command
{
CM_INVALID,
CM_LEFT,
  CM_RIGHT,
  CM_STOP,
  CM_UP,
  CM_DOWN,
  CM_QUIT,
  CM_UI
};</pre></div><p>We have added <code class="literal">CM_UI</code>, which will be set as the current command if any UI element is clicked.</p><p>Now, we<a id="id256" class="indexterm"/> define a member variable to hold the list of UI elements. Add this line of code to the member variables in <code class="literal">Input.h</code>:</p><div><pre class="programlisting">Sprite** m_uiElements;
unsigned int m_uiCount;</pre></div><p>
<code class="literal">m_uiElements</code> will be a dynamic list of pointers to our elements, while <code class="literal">m_uiCount</code> will keep track of the number of elements in the list.</p><p>The final change to <code class="literal">Input.h </code>is to add the following line in the public methods:</p><div><pre class="programlisting">void AddUiElement(Sprite* m_pElement);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Adding UI elements to the list</h2></div></div></div><p>We need to be <a id="id257" class="indexterm"/>able to add a list of elements to our <code class="literal">Input</code> class so that they can be checked during the input handling.</p><p>First, we have to allocate memory for our list of elements. Add the following lines to the <code class="literal">Input</code> constructor in <code class="literal">Input.cpp</code>:</p><div><pre class="programlisting">m_uiElements = new Sprite*[10];
m_uiCount = 0;</pre></div><p>I could probably get cleverer than this, but for now, we will allocate enough memory to hold 10 UI elements. We then initialize <code class="literal">m_uiCount</code> to <code class="literal">0</code>. Now, we need to add the following method to <code class="literal">Input.cpp</code>:</p><div><pre class="programlisting">void Input::AddUiElement(Sprite* p_element)
{
  m_uiElements[m_uiCount] = p_element;
  m_uiCount++;
}</pre></div><p>This method allows us to add a UI element to our list (internally, each UI element is a pointer to a sprite). We add the element to the <code class="literal">m_uiElements</code> array at the current index and then <a id="id258" class="indexterm"/>increment <code class="literal">m_uiCount</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Checking each UI element</h2></div></div></div><p>Eventually, the Input class will contain a list of all UI elements that it is supposed to check. We will<a id="id259" class="indexterm"/> need to iterate through that list to see if any of the active elements have been clicked (if we want to ignore a particular element, we simply set its active flat to <code class="literal">false</code>).</p><p>Open <code class="literal">Input.cpp</code> and add the following code to <code class="literal">Update</code> above the existing code:</p><div><pre class="programlisting">for (unsigned int i = 0; i &lt; m_uiCount; i++)
{
  Sprite* element = m_uiElements[i];
  if (element-&gt;IsActive() == true)
  {
    if (CheckForClick(element))
    {
      element-&gt;IsClicked(true);
      m_command = Input::Command::CM_UI;
      return;
    }
  }
}</pre></div><p>This code iterates through each item in the <code class="literal">m_uiElements</code> array. If the element is active, then <code class="literal">CheckForClick</code> is called to see if this element has been clicked. If the element has been clicked, the <code class="literal">IsClicked</code> property of the element is set to <code class="literal">true</code> and <code class="literal">m_command</code> is set to <code class="literal">CM_UI</code>.</p><p>We put this code above the existing code because we want checking the UI to take priority over checking for game input. Notice in the preceding code that we exit the function if we find a UI element that has been clicked.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Pushing your buttons</h2></div></div></div><p>In order to <a id="id260" class="indexterm"/>see if an element has been clicked, we need to see if the left mouse button is down while the mouse pointer is inside the area bounded by the UI element.</p><p>First, open <code class="literal">Input.cpp</code> and add the following code:</p><div><pre class="programlisting">const bool Input::CheckForClick(Sprite* p_element) const
{
  if (KEYDOWN(Key::K_LB))
  {
    POINT cursorPosition;
    GetCursorPos(&amp;cursorPosition);
    ScreenToClient(m_hWnd, &amp;cursorPosition);
    float left = p_element-&gt;GetPosition().x;
    float right = p_element-&gt;GetPosition().x + p_element-&gt;GetSize().width;
    float top = p_element-&gt;GetPosition().y;
    float bottom = p_element-&gt;GetPosition().y + p_element-&gt;GetSize().height;
    
    if (cursorPosition.x &gt;= left  &amp;&amp;
      cursorPosition.x &lt;= right &amp;&amp;
    cursorPosition.y &gt;= top &amp;&amp;
    cursorPosition.y &lt;= bottom)
    {
      return true;
    }
    else
    {
      return false;
    }
  }
  return false;
}</pre></div><p>Here is <a id="id261" class="indexterm"/>what we are doing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We first make sure that the left mouse button is down.</li><li class="listitem" style="list-style-type: disc">We need to store the current position of the mouse. To do this, we create a <code class="literal">POINT</code> called <code class="literal">cursorPosition</code>, then pass that by reference into <code class="literal">GetCursorPos</code>. This will set <code class="literal">cursorPosition</code> to the current mouse position in screen coordinates.</li><li class="listitem" style="list-style-type: disc">We actually need the mouse position in client coordinates (the actual area that we have to work with, ignoring windows borders and fluff). To get this, we pass <code class="literal">cursorPosition</code> along with a handle to the current window into <code class="literal">ScreenToClient</code>.</li><li class="listitem" style="list-style-type: disc">Now that we have the <code class="literal">cursorPosition</code>, want to test to see if it is inside the rectangle that bounds our UI element. We calculate the left, right, top, and bottom<a id="id262" class="indexterm"/> coordinates of the sprite.</li><li class="listitem" style="list-style-type: disc">Finally, we check to see if <code class="literal">cursorPosition</code> is within the boundaries of the UI element. If so, we return <code class="literal">true</code>; otherwise, we return <code class="literal">false</code>.</li></ul></div><p>Ensure to add the following declaration to <code class="literal">Sprite.h</code>:</p><div><pre class="programlisting">const bool CheckForClick(Sprite* p_element) const;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Adding our pauseButton</h2></div></div></div><p>We now need to <a id="id263" class="indexterm"/>add the code to our game to create and monitor our pause and resume buttons.</p><p>First, we will add two variables for our two new sprites. Add the following two lines to the variable declaration block of <code class="literal">RoboRacer.cpp</code>:</p><div><pre class="programlisting">Sprite* pauseButton;
Sprite* resumeButton;</pre></div><p>Then, add the following lines to <code class="literal">LoadTextures</code> (just before the <code class="literal">return</code> statement):</p><div><pre class="programlisting">pauseButton = new Sprite(1);
pauseButton-&gt;SetFrameSize(75.0f, 38.0f);
pauseButton-&gt;SetNumberOfFrames(1);
pauseButton-&gt;SetPosition(5.0f, 5.0f);
pauseButton-&gt;AddTexture("resources/pauseButton.png");
pauseButton-&gt;IsVisible(true);
pauseButton-&gt;IsActive(true);
inputManager-&gt;AddUiElement(pauseButton);

resumeButton = new Sprite(1);
resumeButton-&gt;SetFrameSize(75.0f, 38.0f);
resumeButton-&gt;SetNumberOfFrames(1);
 resumeButton-&gt;SetPosition(80.0f, 5.0f);
resumeButton-&gt;AddTexture("resources/resumeButton.png");
inputManager-&gt;AddUiElement(resumeButton);</pre></div><p>This code sets up the pause and resume sprites exactly like we set up the other sprites in our game. Only the pause sprite is set to be active and visible.</p><p>You will notice one important addition: we add each sprite to the <code class="literal">Input</code> class with a call to <code class="literal">AddUiElement</code>. This adds the sprite to the list of UI elements that need to be checked for input.</p><p>We must also add code to the <code class="literal">Update</code> function in <code class="literal">RoboRacer.cpp</code>:</p><div><pre class="programlisting">pauseButton-&gt;Update(p_deltaTime);
resumeButton-&gt;Update(p_deltaTime);</pre></div><p>Similarly, we must add code to the <code class="literal">Render</code> function in <code class="literal">RoboRacer.cpp</code> (just before the call to <code class="literal">SwapBuffers</code>):</p><div><pre class="programlisting">pauseButton-&gt;Render();
resumeButton-&gt;Render();</pre></div><p>That's it! If <a id="id264" class="indexterm"/>you run the game now, you should see the new pause button in the upper-left corner. Unfortunately, it doesn't do anything yet (other than change the button from Pause to Resume. Before we can actually pause the game, we need to learn about state management.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>State management</h1></div></div></div><p>Think about it. If we want our game to pause, then we have to set some kind of flag that tells the game that <a id="id265" class="indexterm"/>we want it to take a break. We could set up a Boolean:</p><div><pre class="programlisting">bool m_isPaused;</pre></div><p>We would set <code class="literal">m_isPaused</code> to <code class="literal">true</code> if the game is paused, and set it to <code class="literal">false</code> if the game is running.</p><p>The problem with this approach is that there are a lot of special cases that we may run into in a real game. At any time the game might be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Starting</li><li class="listitem" style="list-style-type: disc">Ending</li><li class="listitem" style="list-style-type: disc">Running</li><li class="listitem" style="list-style-type: disc">Paused</li></ul></div><p>These are just some example of <strong>game states</strong>. A game state is a particular mode that requires special handling. As there can be so many states, we usually create a state manager to keep track of the state we are currently in.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Creating a state manager</h2></div></div></div><p>The simplest <a id="id266" class="indexterm"/>version of a state manager begins with an enum that defines all of the game states. Open <code class="literal">RoboRacer.cpp</code> and add the following code just under the include statements:</p><div><pre class="programlisting">enum GameState
{
  GS_Running,
  GS_Paused
};</pre></div><p>Then go to the variable declarations block and add the following line:</p><div><pre class="programlisting">GameState m_gameState;</pre></div><p>To keep<a id="id267" class="indexterm"/> things simple, we are going to define two states: running and paused. A larger game will have many more states.</p><p>Enums have a big advantage over Boolean variables. First, their purpose is generally clearer. Saying that the game state is <code class="literal">GS_Paused</code> or <code class="literal">GS_Running</code> is clearer than if we just had set a Boolean to <code class="literal">true</code> or <code class="literal">false</code>.</p><p>The other advantage is that enums can have more than two values. If we need to add another state to our game, it is as simple as adding another value to our <code class="literal">GameState</code> enum list.</p><p>Our game will start in the running state, so add the following line of code to the <code class="literal">StartGame</code> function:</p><div><pre class="programlisting">m_gameState = GS_Running;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Pausing the game</h2></div></div></div><p>Think about it for a minute. What do we want to do when the game is paused? We still want to<a id="id268" class="indexterm"/> see things on the screen, so that means that we still want to make all of our Render calls. However, we don't want things to change position or animate. We also don't want to process game input, though we do need to handle UI input.</p><p>All of this should have you thinking about the update calls. We want to block updates to everything except the UI. Modify the <code class="literal">Update</code> function in <code class="literal">RoboRacer.cpp</code> so that it contains the following code:</p><div><pre class="programlisting">void Update(const float p_deltaTime)
{
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
  
  if (m_gameState == GS_Running)
  {
    background-&gt;Update(p_deltaTime);
    robot_left-&gt;Update(p_deltaTime);
    robot_right-&gt;Update(p_deltaTime);
    robot_left_strip-&gt;Update(p_deltaTime);
    robot_right_strip-&gt;Update(p_deltaTime);
    
    pauseButton-&gt;Update(p_deltaTime);
    resumeButton-&gt;Update(p_deltaTime);
  }
}</pre></div><p>Notice that we<a id="id269" class="indexterm"/> will only process the sprite updates if the game state is <code class="literal">GS_Running</code>.</p><p>We are going to get ready to accept mouse input. First, we are going to setup a timer. Add the following code in the variable declarations of RoboRacer2d.cpp:</p><div><pre class="programlisting">float uiTimer;
const float UI_THRESHOLD = 0.2f;</pre></div><p>Then add the line of code below to StartGame:</p><div><pre class="programlisting"> uiTimer = 0.0f;</pre></div><p>The time will be used to add a small delay to mouse input. Without the delay, each click on the mouse would be registered several times instead of a single time.</p><p>We still need to handle input, but not all input. Go to the <code class="literal">ProcessInput</code> function in <code class="literal">RoboRacer.cpp</code> and make the following changes:</p><div><pre class="programlisting">void ProcessInput(const float p_deltaTime)
{
 Input::Command command = inputManager-&gt;GetCommand();
 if (m_gameState == GS_Paused) command = Input::Command::CM_UI;

 uiTimer += p_deltaTime;
 if (uiTimer &gt; UI_THRESHOLD)
 {
  uiTimer = 0.0f;
  switch (command)
  {
  case Input::Command::CM_STOP:
   player-&gt;SetVelocity(0.0f);
   background-&gt;SetVelocity(0.0f);
   break;

  case Input::Command::CM_LEFT:
   if (player == robot_right)
   {
    robot_right-&gt;IsActive(false);
    robot_right-&gt;IsVisible(false);
    robot_left-&gt;SetPosition(robot_right-&gt;GetPosition());
   }

   player = robot_left;
   player-&gt;IsActive(true);
   player-&gt;IsVisible(true);
   player-&gt;SetVelocity(-50.0f);
   background-&gt;SetVelocity(50.0f);
   break;

  case Input::Command::CM_RIGHT:
   if (player == robot_left)
   {
    robot_left-&gt;IsActive(false);
    robot_left-&gt;IsVisible(false);
    robot_right-&gt;SetPosition(robot_left-&gt;GetPosition());
   }

   player = robot_right;
   player-&gt;IsActive(true);
   player-&gt;IsVisible(true);
   player-&gt;SetVelocity(50.0f);
   background-&gt;SetVelocity(-50.0f);
   break;

  case Input::Command::CM_UP:
   player-&gt;Jump(Sprite::SpriteState::UP);
   break;

  case Input::Command::CM_DOWN:
   player-&gt;Jump(Sprite::SpriteState::DOWN);
   break;

  case Input::Command::CM_QUIT:
   PostQuitMessage(0);
   break;

  case Input::Command::CM_UI:
   if (pauseButton-&gt;IsClicked())
   {
    pauseButton-&gt;IsClicked(false);
    pauseButton-&gt;IsVisible(false);
    pauseButton-&gt;IsActive(false);

    resumeButton-&gt;IsVisible(true);
    resumeButton-&gt;IsActive(true);
    m_gameState = GS_Paused;
   }

   if (resumeButton-&gt;IsClicked())
   {
    resumeButton-&gt;IsClicked(false);
    resumeButton-&gt;IsVisible(false);
    resumeButton-&gt;IsActive(false);

    pauseButton-&gt;IsVisible(true);
    pauseButton-&gt;IsActive(true);
    m_gameState = GS_Running;
   }
  }
 }
  command = Input::Command::CM_INVALID;
}</pre></div><p>Take a look<a id="id270" class="indexterm"/> at the second line. It sets the command to <code class="literal">CM_UI</code> if the game is paused. This means that only UI commands will be processed while the game is paused. A hack? Perhaps, but it gets the job done!</p><p>We only have two more changes to make. When the pause button is clicked, we need to change the game state to <code class="literal">GS_Paused</code>, and when the resume button is clicked, we need to change the game state to <code class="literal">GS_Running</code>. Those changes have already been made in the <code class="literal">CS_UI</code> case in the preceding code!</p><p>When you run the program now, you will see that the game pauses when you click the pause button. When you click the resume button, everything picks up again.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>Again, you have traveled far! We implemented a basic input class, then modified our sprite class to handle UI. This unified approach allows one class to handle sprites as game objects as well as sprites as part of the user interface. The same approach to see if a button has been pushed, can also be used for collision detection for a game object too. Then you learned how to create a state machine to handle the various states that the game may be in.</p><p>In the next chapter, we will learn to detect when game objects collide.</p></div></body></html>