- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning to program is difficult for many reasons, but learning to program games
    is even more difficult, specifically because there are so many different systems
    and object types that need to interact with each other. Throughout this book,
    we have covered some of the most important design patterns to make those interactions
    as simple as possible. Each chapter focused explicitly on a design pattern to
    help make coding easier. However, buried within each paragraph and code sample
    are core ideas and techniques to help make our design easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: These *Best Practices* can sometimes be found in other books; however, programming
    books often strive to teach you the grammar of a language, as opposed to style,
    design, and organization. Even books about design patterns may gloss over these
    fundamental techniques. Since they are so fundamental, it is easy to forget they
    are not necessarily explicitly discussed everywhere. That leaves you, the reader,
    forced to read dozens of books and scour the Internet for blog posts that talk
    about these fundamentals. Worse, you are required to spend hours and hours writing
    code with the feeling that it could be better, but you just don't understand why
    it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all those things will happen anyway. Part of being a programmer is
    constantly reading books like this. You should be looking for ways to improve
    by reading blogs and you will write code that you consider garbage after six months.
    This is all part of becoming better. It is our hope in writing this book that
    you can understand and incorporate these fundamentals into your programs sooner
    rather than later.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be focusing on fundamental ideas and techniques that
    will improve your code and improve your game. These ideas come from years of programming
    as well as years of teaching. If these seem simple and obvious, that is great.
    However, we chose these topics because they are things that we, the authors, struggled
    with early on, or that our students struggled with.
  prefs: []
  type: TYPE_NORMAL
- en: Your objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this chapter we will be discussing a number of topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn fundamental code quality techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn and understand the uses of the const keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how iteration can improve your game and code design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn when to use scripting in a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning fundamental code quality techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of moving from beginner to expert programmer can be challenging.
    In the beginning, you must learn not only the rules of the language, but also
    how to use a compiler and understand the error messages. Moreover, you are trying
    to solve increasingly difficult programming problems while following what might
    seem like arbitrary rules for writing *good* code. Most novice programmers are
    focused on solving a given problem, as opposed to making the code look nice. To
    many, it seems worthless to spend time making the code look clean, because it
    will almost certainly be deleted after writing it. Even more experienced programmers
    may ignore code style in the rush to complete an assignment or finish a project.
  prefs: []
  type: TYPE_NORMAL
- en: This is bad for a few reasons. First, well-written code is easier to read and
    understand. It almost certainly has fewer errors, and is more efficient than code
    that is carelessly mixed together and never polished. Just as we discussed in
    earlier chapters, the time you spend upfront making sure the code is bug free,
    is time you won't need to use debugging it later. The time you spend making sure
    the code is readable and easy to maintain is time you won't need to spend later
    making changes or deciphering old code.
  prefs: []
  type: TYPE_NORMAL
- en: Second, good programming style is a matter of habit. Taking time to read and
    debug your code is slow at first. However, the more you improve your code, the
    easier and quicker it becomes. Eventually, you will develop habits and writing
    quality code will happen naturally. Without this habit, it can be easy to push
    style aside and worry about it later. However, the code that is being written
    is almost always sloppy, and it can be hard to find the time later to go back
    and improve it, since there is always another deadline approaching. With good
    habits, you will be able to write clean, readable code in even the most time-constrained
    situations, such as an interview or a fast-approaching deadline.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at some point in the future you will almost certainly be working with
    other programmers. This could be a small team of two or three, or perhaps in a
    company with dozens of programmers all over the world. Even if you understand
    what your code is doing, it is not guaranteed that your teammates will. Writing
    code that is hard to understand will lead to people using your code incorrectly.
    Instead, strive to make your code easy to use and hard to break. Take pride in
    how much other people love to use your code, your teammates and boss will thank
    you. You will appreciate it if your teammates do the same thing. At some point,
    you will be required to maintain other programmers code after they have left the
    job. You will find it much easier to do if they wrote high quality code, so write
    code that will be easy to work with after you have left.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few pages, we will cover some very basic but extremely important
    code quality tips. As we said, these come from years of reading programming, as
    well as teaching. Use these techniques for every single line of code that you
    write. Think about these techniques for every piece of code that you read. Doing
    so will help you form great habits.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid magic numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hard coding number literals into code is generally considered a bad idea. The
    problem with using a number literal instead of a named constant is that the purpose
    of that number is unknown to the reader. The number appears in code as if by magic.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is hard to know why those four numbers were chosen. It is also hard to know
    how the program will be changed if the values are modified. Code like this would
    be much more readable and maintainable if the named constants or variables were
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After the change, it is much easier to understand that the position of the new
    UFO is being randomly placed within the world. We can understand that if we change
    the values, the possible starting location of the UFO would either be outside
    of the world, or constrained to a tighter rectangle around the center of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides being hard to read and understand, using magic numbers makes the code
    hard to maintain and update. Let''s say we have an array of size 256\. Every loop
    that needs to manipulate the array must hardcode the value 256\. If the array
    size needs to be larger or smaller, we would need to change every occurrence of
    256\. We can''t simply do a *find and replace* because it is very possible that
    256 is used elsewhere in the code for a completely different reason. Instead we
    must look through every occurrence of the number and make sure that we are changing
    the code correctly. If we miss even one, we could create a bug. For example, if
    we are changing the size of the array to something smaller, such as 128\. Any
    loops that still treat the array as if it had size 256 will cause undefined behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, it is better to use a named constant instead of a magic number.
    The constant is more readable and easy to change because it only needs to be changed
    in one place. It is also less likely to cause bugs because we are only changing
    the values associated with the array. We won''t accidentally change a value we
    shouldn''t or miss a value that we should change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important reason we don''t want to use magic numbers is that they are
    inflexible. Throughout this book, we try to emphasize the benefits of reading
    data from a file. Obviously, if you hardcode a value, it can''t be read from a
    file. In the preceding example, if `BUFFER_SIZE` ever needs to be changed, the
    code needs to be recompiled. However, if the size of the buffer is read from a
    file at runtime, the code only needs to be compiled one time and the program will
    work for buffers of all sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we must remember to deallocate the buffer. Remember,
    that probably won't be the usual case because for arrays, we could always use
    an STL vector. The more general case is that we are reading ints or floats from
    a file. These could be used for anything from screen resolution, to player speed,
    or even the time interval between spawning enemies.
  prefs: []
  type: TYPE_NORMAL
- en: As with all rules, there are a few exceptions or special cases where it might
    be fine to hardcode numbers. The numbers `0` and `1` are generally consider OK.
    These might be used as the initialization values for ints or floats, or just the
    starting index for an array.
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to make your code as readable and flexible as possible, so a named
    constant is almost always going to be better than a hardcoded number. Do your
    best to make sure that your code can be understood by others. Your code isn't
    more readable if you simply have a variable named `ZERO` or `TWO`, so you should
    use your best judgment and perhaps ask another programmer if you think the meaning
    is unclear.
  prefs: []
  type: TYPE_NORMAL
- en: White space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When thinking about high quality code, white space is often forgotten. Maybe
    this is because white space isn''t code you write, but is instead the empty space
    between your code. However, if you don''t use white space correctly, your code
    will be unreadable. When we say white space, we are talking about the spaces,
    tabs, newlines, and blank lines within your program. How you use these can make
    the difference between code that is easy to read and maintain, and code that will
    give you nightmares. Here is a piece of code with very little thought about white
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is perfectly acceptable to the compiler. For humans, however,
    the code above is hard to read because there is no line spacing, no indentation,
    and no consistency. Of course, this is an extreme example, but throughout our
    years of teaching, we have seen examples of code with just as little thought to
    style and formatting. When code looks like the example above, the quality of comments
    and identifier names doesn''t matter because the entire block is difficult to
    read. Compare the preceding code with the following version, which has tried to
    code for human readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding example is by no means the perfect example of high quality
    code, it is certainly more readable and maintainable than the first example. When
    it comes to real-world programs and programmers, there is no such thing as perfect.
    Every programmer has their own style, which really means that every programmer
    believes their style is the easiest to read. However, as you read more code, you
    will notice that there are certain common elements to code that is readable. Let's
    look at some of those elements now.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Block statements such as loops and conditionals should have the sub statements
    indented. This easily shows the program intent to the reader. The number of spaces
    to indent is less important than the indentation itself. Most programmers agree
    that 2 to 4 spaces are sufficient for readability. The most important thing is
    to be consistent with your spacing. Likewise, the placement of the starting curly
    brace isn''t important, (although you can find some interesting arguments online),
    but it is important to consistently place it in the same location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to remember that in C++, indentation has no meaning to the
    compiler. Without the curly braces, loops and conditionals will execute only one
    statement. For this reason, some programmers will always use the curly braces,
    regardless of how many sub statements are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is misleading, because only the first statement will be
    part of the loop. It can be a common mistake when writing a loop or conditional
    to forget to add curly braces after adding a second statement. For this reason,
    some programmers will use curly braces even for single statement loops and conditionals.
    The idea is that the code is more readable and easier to maintain, and so it is
    less prone to error.
  prefs: []
  type: TYPE_NORMAL
- en: Blank lines and spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we said before, how you use white space will determine how readable your
    code is. Using indentation for code blocks is one way to show the logical structure
    of a program. Another good way to show this is by using blank lines. Just as a
    good piece of writing is separated into paragraphs, a good piece of code should
    be separated into some form of logical grouping. Group statements together that
    logically go together. Put blank lines between the groups to improve the readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has no blank lines so the code seems to run together. It
    is hard to look at it and understand what the code is doing because your brain
    tries to understand all of it at once. Even though there are comments, they don''t
    really help because they blend in to the rest of the code. The if statement is
    also hard to read because the conditions are separated by how they fit on the
    line instead of a logical alignment. In the following code, we have added some
    blank lines to separate the logic grouping of the statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By using line breaks to group related statements together, the code is separated
    into easy to understand chunks. These chunks help the reader understand which
    statements should logically go together. In addition, the comment at the beginning
    of each chunk sticks out much more and explains in English exactly what will happen
    will contained in the chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complicated conditional statements should be separated and aligned based on
    the conditions so they are easier to understand. In the preceding code, each of
    the four conditions are aligned in the same way. This gives a clue to the reader
    as to how the condition will be executed. Using parentheses along with aligning
    the code further adds to the readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using parentheses isn't just helpful in conditionals. All complicated expressions
    should be grouped together with parentheses. Of course, everyone's definition
    of complicated differs, so a good general rule is `*`, `/`, and `%` are executed
    before `+` and `-`; use parentheses for everything else. In addition to being
    clearer to the reader, this will ensure that the code is executing exactly as
    you expect. Even if you understand all the C++ rules of precedence and associativity,
    your teammates may not. Parentheses don't cost anything but can improve the readability,
    so feel free to use them as much as possible to show the intent of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and self-documenting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments and documentation seem to be more controversial than they should be.
    On the one hand, many people think comments and documentation are a waste of time.
    Writing documentation literally takes time away from writing code, and reading
    comments takes time away from reading the code. In addition, some people think
    that comments just don't help because they can become out of date, and don't explain
    anything that isn't already in the source code. The worst situation with comments
    is when they are flat out wrong. In that case, the code would be better off without
    the comments at all.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are few things more frustrating than debugging code written by
    someone that didn't add comments. Even debugging your own code just a few months
    after you have written it can be difficult. In the end, the time spent writing
    and updating comments is time that you and your teammates won't need to spend
    deciphering code.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the use of comments may be controversial, writing clean, high-quality
    code is important to everyone. As we have already seen earlier, using white space
    well can improve readability. However, white space alone doesn''t make code readable.
    We really want our code to be self-documenting. Here is an example of that, which
    is difficult to read, even though it has proper white space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you tell what the algorithm is doing? Unless you happen to know this algorithm
    already, chances are that you may not understand the intent of the function. Comments
    would help here, but the bigger problem is the low quality of the identifiers.
    Good variable names provide a hint as to what they will be used for. The idea
    is that, with good variable names, you should be able to understand the code without
    the need for comments. This is how you make your code self-documenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Even if you don't understand every single line of the preceding code example,
    you can at least use the function name as a guide. The name `CalculateSievePrimes`
    is a big clue as to what the function is doing. From there you should be able
    to piece together what each line is doing. Names such as candidate, `arraySize`,
    and multiple are much more meaningful than `a`, `b`, and `c`. The best part about
    self-documenting code is that it can never be wrong, and never become out of date.
    Of course, the code can still contain bugs. It just can't be out of sync with
    the documentation, because the code is the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things that you can do to attempt to make the code self-documenting,
    as we said before. Good variable names are a start. The variable name should explain
    the exact purpose of the variable and they should only be used for that purpose.
    For Boolean variables, give a name that makes it obvious what true means. A name
    such as `isActive` is much better than simply `active` or `activeFlag` because
    the names gives a hint as to what true means for that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Often there will be naming conventions that distinguish between types, local
    variables, constants, and static or global variables. Some of these naming conventions,
    such as using all capital letters for `const` variables, are very common and used
    by most programmers. Other naming conventions, such as beginning all static variable
    names with an `s_`, or adding a `p` at the beginning of pointers, are less common.
    Whether you think these styles look ugly or not, understand that they are there
    to help readability and make wrong code look wrong. The compiler will already
    catch some of the problems that these naming conventions aim to solve, but since
    they can still help readability they are worth considering.
  prefs: []
  type: TYPE_NORMAL
- en: When giving names to methods and functions, similar rules apply. Give a clear
    name that explains the purpose of the function. Make sure the function or method
    only has one purpose. Typically, the name should be an action. `CalculateSievePrimes`
    is a much clearer name than `SeivePrimes` or even just `Calculate`. As with Boolean
    variables, methods or functions that return Boolean values are often named with
    a hint. The name `IsEmpty` or `IsPowerOfTwo` are much more clear than `Empty`
    or `PowerOfTwo`.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the code is self-documenting, then why do we need to add comments at all?
    This is certainly the feeling of some programmers. When the comments aren't doing
    more than simply repeating the code, or when comments are out of date and difficult
    to update, then it is easy to understand why they feel that way. However, this
    is the opposite of what good comments should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good comments should explain things that the code cannot. For example, copyright
    information, or author and contact information are things that can''t be represented
    in code, but may be of use to the reader. Additionally, good comments do not simply
    repeat the code. The comment below is completely worthless. It adds nothing to
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, good comments should explain the intent and purpose of the code. Even
    if you understand what a block of code is supposed to do, you can''t know what
    the author was thinking when they wrote it. Knowing what the author was trying
    to accomplish can save you a lot of time when debugging someone else''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The comments above explain what the author was thinking while writing the code.
    They do not just repeat what the code is doing. Notice that some comments explain
    a single line, while other comments summarize entire code blocks. There aren't
    any hard rules about how many comments should be in your code. A rough suggestion
    is that every code block should have a comment explaining its purpose, with additional
    comments for more complex lines.
  prefs: []
  type: TYPE_NORMAL
- en: The comment blocks such as the one at the top of the method are the least likely
    to be used but they can serve an important purpose as well. Just as the section
    headers of this book help when you are scanning for something specific, function
    headers can help you when scanning a source code file looking for a specific function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions headers can be very helpful because they summarize everything about
    the function without the need to look at the code. Anyone can easily understand
    the purpose of the parameters, return values, and even any exceptions that may
    be thrown. The best part is, by using a tool such as Doxygen, the header blocks
    can be extracted to make external documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the Doxygen tool and documentation at [http://www.stack.nl/~dimitri/doxygen/](http://www.stack.nl/~dimitri/doxygen/).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these are the most difficult to write and maintain. It is comment
    blocks like these that often become out of date or are flat out wrong. It is up
    to you and your team if you want to use them. It takes discipline to keep up with
    them, but they can be worth it if you happen to be working on another programmer's
    code after they have left the team.
  prefs: []
  type: TYPE_NORMAL
- en: Learning and understand the uses of the const keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `const` is another area of programming that seems to be a little controversial.
    Some programmers argue that they have never had a bug where using `const` would
    have helped. Others feel that, since you can't guarantee that a `const` object
    won't be modified, it is completely worthless. The fact is that `const` objects
    can be modified. `const` is not magic. So, is `const` correctness still a good
    thing? Before we get into that, let's have a look at what `const` is.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a `const` variable, you must initialize it. All `const` variables
    will be checked at compile time to make sure that the variable is never assigned
    a new value. Since it happens at compile time, it doesn't have an influence on
    the performance. These are a few benefits that we should consider. First, it improves
    readability. By marking a variable as `const`, you are letting the reader know
    that this variable is not supposed to change. You are sharing your intent about
    the variable and making your code self-documenting. `const` variables are also
    usually named in all capital letters, which further helps with readability. Second,
    since the variable is checked at compile time, there is no way for the user to
    accidently change the value. If someone tries to modify the variable, it will
    cause a compiler error. This is great for you if you were expecting the value
    to stay the same. This is great for the user if the modification was truly an
    accident.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler errors should always be preferred over runtime. Anytime we can use
    the compiler to help us find problems, we should. This is the same reason that
    many programmers choose to set their compiler warnings to maximum and treat those
    warnings as errors. Time spent fixing a known compiler issue is time you won't
    have to spend finding the runtime error that it might cause.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `const` variables should be preferred over C style `#define` macros.
    Macros are a blunt tool. Sometimes they may be the only tool for the job, but
    they are overkill for simple symbolic constants. Macros do a blind *find and replace*.
    Anywhere the symbolic constant is in the source code, the value will replace it.
    While these situations may be rare, they can also be frustrating. Since the values
    are replaced in the pre-processing phase, the source code is unchanged when you
    go to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `const` variables, on the other hand, are part of the language. They follow
    all the normal language rules for types and operators. There is nothing mysterious
    happening. They are just variables that can''t be reassigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Const function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating `const` variables as symbolic constants makes code more readable because
    we are avoiding magic numbers. However, `const` correctness is more than just
    creating symbolic constants. It is important to understand `const` in relation
    to function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand the difference between these different function
    signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The default behavior of C and C++ is to pass by value. This means that, when
    you pass a variable to a function, a copy is made. Changes made to function parameters
    do not modify the original variable. The function author has freedom to use the
    variable however they want, while the original variable owner can be sure that
    the values will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means, as far as the original variable owner is concerned, these two function
    signatures behave the same. In fact, the compiler doesn''t make a distinction
    between these two when considering function overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since it is impossible for a pass by value variable to be modified when it gets
    passed to a function, many programmers do not mark these parameters as `const`.
    It can still be a good idea to mark them as `const`, because it signifies to the
    reader that the variable value shouldn't be changed. However, this type of parameter
    is less important to mark as `const` since it can't be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about when you want to pass an array to a function? Remember that one
    of the little quirks of C and C++ is the fact that arrays and pointers are sometimes
    treated similarly. When you pass an array to a function, a copy of the array is
    not made. Instead, a pointer to the first element is passed. One side effect of
    this default behavior is that the function can now modify the original data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is nothing preventing the function from modifying the
    original data. The `size` variable in the function is a copy of `SIZE` in main.
    However, the `buffer` variable is a pointer to array. The `PrintArray` function
    is short, so finding this bug might be easy, but in a longer function that may
    pass the pointer to additional functions, this problem can be difficult to track
    down.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user wanted to prevent the function from modifying the data, they could
    mark array as const. However, they won''t be able to use the `PrintArray` function,
    and they won''t be able to modify the data either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, sometimes the purpose of the function is to modify data. In that
    case, the user would just have to accept that if they wanted to use the function.
    With a name like `PrintArray`, the user probably expects that the data will be
    unchanged after the function call. Is the data modification on purpose or an accident?
    The user has no way of knowing.
  prefs: []
  type: TYPE_NORMAL
- en: Since the problem is with the poor function name, it is up to the function author
    to make the change. They can choose to make the name clearer, perhaps something
    such as `ClearAndPrintArray`, or fix the error. Of course, fixing the error doesn't
    prevent something like this from happening again, and it doesn't clarify the intent
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better idea would be for the author to mark buffer as a const parameter.
    This will allow the compiler to catch any accidents like the one above, and it
    will signal to the user that the function promises not to modify the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we said before, the `size` variable could also be marked as const. This would
    more clearly demonstrate that the variable shouldn't change, but it isn't necessary
    because it is a copy. Any modification of size will not change the value of `SIZE`
    in main. For this reason, many programmers, even the ones that strive for const
    correctness, do not mark *pass by value* parameters as const.
  prefs: []
  type: TYPE_NORMAL
- en: Const classes as parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now discussed the default behavior when passing arrays to functions.
    The compiler will automatically pass in a pointer to the first element of the
    array. This is good for both speed and flexibility. Since only a pointer is passed
    in, the compiler doesn't need to spend time copying a (possibly) large array.
    This is also more flexible, because the function can work with arrays of all sizes
    instead of just a specific size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, when passing structs or classes to a function, the default behavior
    is *pass by value*. We say unfortunately, because this will automatically evoke
    the copy constructor, which may be expensive and unnecessary if the function is
    only reading data from the data type. A good general rule to follow is when passing
    structs or classes to functions, do not pass by value, pass by pointer, or reference.
    This avoids the possibly expensive copy of the data. There are certainly exceptions
    to this rule, but 99% of the time, passing by value is the wrong thing to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to avoid the expensive copy constructor call when passing `GameObjects`
    to functions. Unfortunately, when we pass by pointer or reference, the function
    has access to our public data and can modify it. As before, the solution is to
    pass by pointer to `const` or reference to `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When writing functions, if the purpose is to modify the data, then you should
    pass by reference. However, if the purpose is not to modify the data, then pass
    by reference to const. You will avoid the expensive copy constructor call, and
    the data will be protected from accidental modification. Additionally, by making
    a habit of passing by reference or reference to `const`, you code will be self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: Const member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we kept the struct very simple. Since the struct didn''t
    have any member functions, we only needed to worry about when non-member functions
    want to modify the data. However, object-oriented programming suggests that we
    shouldn''t have data be public. Instead, all data should be private and accessed
    through public member functions. Let''s look at a very simple example to understand
    this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As expected, when our class is not marked as `const`, we can use both the `SetData`
    and `GetData` member functions. However, when we mark our class as `const`, we
    expect that we won't be able to use the `SetData` member function, because it
    modifies the data. However, unexpectedly, we can't use the `GetData` member function,
    even though it doesn't modify the data at all. To understand what is going on,
    we need to understand how member functions are called and how a member function
    modifies the correct data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a non-static member function is called. The first parameter is always
    the hidden `this` pointer. It is a pointer to the instance that is calling the
    function. This parameter is how the `SetData` and `GetData` can act upon the correct
    data. The `this` pointer is optional within the member function, as programmers,
    we can choose to use it or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is completely true. The `this` pointer is actually a `const` pointer to
    a `Simple` class. We didn''t talk about const pointers, but it just means the
    pointer can''t be modified, but the data it points to (the `Simple` class) can
    be. This distinction is important. The pointer is `const`, but the `Simple` class
    is not. The actual hidden parameter would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have code like this that calls a member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is really turning it into code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the reason we get errors when we try to pass a `const Simple` object
    to the member function. The function signature is not correct. The function does
    not accept a `const Simple` object. Unfortunately, since the `this` pointer is
    hidden, we cannot simply make the `GetData` function accept a `const Simple` pointer.
    Instead we must mark the function as `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We must mark the function as const within the class as well. Notice that `SetData`
    is not marked const, because the purpose of that function is to modify the class,
    but `GetData` is marked `const` because it only reads data from the class. So,
    our code would look something like the following. To save space, we didn''t include
    the function definitions again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, by marking the `GetData` member function as const, it can be
    used when the variable instance is marked const. Marking member functions as const
    allows the class to work correctly with non-member functions that may be attempting
    const correctness. For example, a non-member function (possibly written by another
    programmer) trying to display a `Simple` object by using the `GetData` member
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since `DisplaySimple` isn't intending to change the data in the class, the parameter
    should be marked as `const`. However, this code will only work if `GetData` is
    a `const` member function.
  prefs: []
  type: TYPE_NORMAL
- en: Being const-correct takes a little work and may seem difficult at first. However,
    if you make it a habit, it will eventually become the natural way that you program.
    When you are const-correct, your code is cleaner, more protected, self-documenting,
    and more flexible, because you are prepared for const and non-const instances.
    As a rule, if your function isn't going to modify the data, mark the parameter
    as const. If the member function isn't going to modify the class data, mark the
    member function as const.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said before, const isn't magic. It doesn't make your code 100% secure
    and protected. Knowing and understanding the rules related with const parameters
    and const member function will help prevent mistakes. However, failing to understand
    the rules and behaviors of const can lead to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest problem with const in C++ is a misunderstanding of bitwise const
    versus logical const. This means that the compiler will try to ensure that the
    bits and bytes will not change through that specific variable. This doesn''t mean
    that those bits won''t change through another variable, and it doesn''t mean that
    the data you may care about won''t change. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `i` is not const, but `ci` is a reference to a const
    `int`. Both `i` and `ci` are addressing the same bits. Since `ci` is marked const,
    we cannot change the value through that variable. However, `i` is not const, so
    we are free to modify the value. The fact that we can have a multiple const and
    non-const variables pointing to the same address has consequences for const member
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have given the `Simple` class a pointer to itself.
    This pointer can be used to modify its own data in a const member function. Remember,
    in a `const` member function, the `this` pointer is marked `const`, so data can''t
    be changed through that variable. However, as in this case, the data can still
    be changed through another variable. Even if we didn''t use another variable,
    the use of `const_cast` could also allow us to change the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to understand that you should never write code like this.
    It is undefined behavior to try to modify a const variable with `const_cast` or
    using a non-const pointer to a `const` object. The original data could be placed
    in read-only memory, and code like this could cause the program to crash. It is
    also possible that the compiler could optimize away multiple reads to memory that
    shouldn't change. Therefore, the old value may be used for any future calculations.
    Casting away `const` with `const_cast` is meant for backwards compatibility with
    old C++ libraries. It should *NEVER* be used to modify const values. If there
    is a piece of data that needs to be modified even when the class is `const`, use
    the `mutable` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when avoiding undefined behavior, bitwise constness can get us into trouble
    with const member variables. Consider a simple class that will contain some dynamic
    memory. Since it contains dynamic memory and pointers, we should add a copy constructor,
    destructor, and other things to prevent memory leaks and memory corruption, but
    we will omit those for now since they aren''t important for our discussion on
    const:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, bitwise const only prevents us from modifying the actual bits
    inside the class. This means we can't point `m_array` to a new location. However,
    it doesn't prevent us from modifying data in the array. There is nothing preventing
    `GetValue` from modifying the array in the const function, because the array data
    isn't part of the class, only the pointer is. Most users aren't concerned about
    where the data is located, but they would expect a const array to remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, being const, correct is certainly not a guarantee that the data
    will never be modified. If you are diligent about using const, as well as understand
    and avoid the problems that can arise, the benefits are worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how iteration can improve your game and code design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's nice to imagine it to be this way, games never come fully-formed
    from the mind of a designer/developer. A game is made up of many different ideas
    from many different people. While in the past people could develop games with
    only a single person, now it's much more common for teams to be made up of many
    different disciplines and every game developer on your team has ideas, many of
    them good that can contribute to the final product that gets made. But with that
    in mind you may be wondering how does a game get to the final point with all those
    different changes made? The answer to that is iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The game development cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Game development is a process, and different people have different names and/or
    phrases for each of these steps, but most people can agree that, for commercial
    game development, there are three main phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these states has their own steps within them as well. Due to page constraints,
    I'm unable to write about the entire process, but we will be focusing on the Production
    aspect of development, since that's where the most relevant content will be for
    our readers.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning more about the different aspects of the game
    development process, check out [https://en.wikipedia.org/wiki/Video_game_development#Development_process](https://en.wikipedia.org/wiki/Video_game_development#Development_process).
  prefs: []
  type: TYPE_NORMAL
- en: During game development, you'll see a lot of companies use an agile development
    process, which is based on iterative prototyping, using feedback and refinement
    of the game's iterations while gradually increasing the game's feature set. A
    lot of companies enjoy this method as there is always a version of the game playable
    every couple of weeks, and you can make adjustments as the project is being worked
    on. If you have heard of Scrum, it is a popular method of agile software development,
    and one that I use with my students as well as what I used in the game industry.
  prefs: []
  type: TYPE_NORMAL
- en: Production phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon entering the production phase, we have come up with our base idea for
    our project and have created our proposal and game design document. Now that we
    have this information, we can start doing the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playtesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these steps serves a valuable process and will be completed in this
    order. We will be repeating these steps repeatedly until release, so it's a good
    idea to have an understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prototyping is when you make the simplest version of your ideas in a quick manner
    to prove if your concept works well or not. For some people, they will do this
    via index cards, paper, chits, and boards, which is called a paper prototype.
    This can be quite useful, as you don't have to think about the code side of things
    to begin with, and instead it allows you to experience the core of the game without
    having all the nice art and polish. A game that is fun to play with bad graphics
    will only be improved when you add to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, assuming you have purchased this book, you are probably already
    a developer, but it''s still a good idea to think of it as an option. *Jesse Schell*
    wrote about paper prototypes in his book *The Art of Game Design: A Book of Lenses*,
    where he explained how you could create a paper prototype of the game Tetris.
    To do so, you could cut out cardboard pieces and then put them into a pile and
    pick them out randomly, and then slide them down the board, which would be a piece
    of paper. Once you completed a line, you would grab an X-acto knife and then cut
    the pieces. While it doesn''t give you the same experience entirely, it captures
    enough of the experience to see if you are using the right kinds of shapes and
    how fast the pieces should drop. The big advantage would be that you could create
    this prototype in 10 to 15 minutes, while programming it may take a lot longer.'
  prefs: []
  type: TYPE_NORMAL
- en: It's a lot easier to justify 30 minutes of work rather than a day for something
    that doesn't work out. This can be done with 3D games as well, such as First Person
    Shooters, by creating maps in a similar way to how you create combat encounters
    in a pen and paper role playing game such as Wizards of the Coast's *Dungeons
    and Dragons* (which is a great thing to learn how to play as a designer, as you
    learn about telling a story and developing interesting encounters).
  prefs: []
  type: TYPE_NORMAL
- en: A prototype's job is to prove if your game works and, specifically, how it works.
    Don't invest in only one idea specifically, but rather create a number of small
    prototypes thatÂ are quick to make, without worrying if it is polished or you've
    made it the best possible.
  prefs: []
  type: TYPE_NORMAL
- en: For some more information on building a prototype and an example of a prototype
    that was created in seven days about *Tower of Goo*, which was the prototype for
    their indie hit *World of Goo*, check out [http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1](http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1).
  prefs: []
  type: TYPE_NORMAL
- en: One of the most vital skills as a game developer is being able to create rapid
    prototypes, to see how it works, and then test it. We call this process of testing
    out a game idea playtesting.
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a prototype, we can then begin the playtesting process. Playtest
    as soon as possible in your development, and do it often. As soon as you have
    something playable, get people in front of it. First play the game yourself and
    see how you feel about it. Then invite some friends over to your house and have
    them play it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes, I find my students have difficulty at first actually doing playtests
    and may be hesitant to show people their projects as it's not *ready* yet or because
    they won't get it. Or they know that their project isn't finished so they think
    they know what they should be working on already, so there's no need to do playtesting.
    I find this usually comes from them being shy, and one of the first major obstacles
    you'll need to overcome as a developer is being able to show your ideas to the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: If the play testers of your game aren't your close friends and/or family, it
    is likely that people will say negative things about the game. This is a good
    thing. They will also mention many things that you already know your game doesn't
    have yet or that you don't have the budget for. This isn't a time for you to defend
    any points, or explain why things are the way they are, but instead a time for
    you to accept the points and note them, as you can take them into consideration
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: As a game developer, one thing that's important to note is that you are one
    of the worst judges of your games, especially when just starting out. A lot of
    times I see starting developers trying to justify the problems in their games,
    stating that it is their vision and people don't get it because it's not in a
    final game. It's a very important skill of a game developer to beÂ able to get
    feedback, take criticism, and evaluate if things are worth changing or not.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting a playtest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how valuable it is to do a playtest, you may wonder how to
    go about doing one. First, I do want to note that it is vitally important that
    you are in the room while your project is being playtested. While they are playing
    the game, you can see not only what someone thinks, but also how they react to
    things as well as what they do with your game. This is the time where you find
    out what works well and what doesn't. If for some reason, you are unable to be
    there in person, have them record themselves playing, both on the PC and from
    the webcam if possible.
  prefs: []
  type: TYPE_NORMAL
- en: When someone comes to a computer to playtest your game, you may be tempted to
    tell them things about your project, such as the controls and the story, and the
    mechanics, and anything else, but you should resist these urges. See what the
    player does without any prompting to begin with. This will give you an idea of
    what players will want to do naturally given the environment that you created
    and what needs to be explained more. Once they play for a while and you've gotten
    the information you need on that end, then you can tell them some things.
  prefs: []
  type: TYPE_NORMAL
- en: When playtesting, it's a good idea to get as much information from the player
    as you can. When they finish, ask them what they liked, what they disliked, if
    they found anything confusing, where they got stuck, and what was the most interesting
    thing to them. Do note that what a player says and what they actually do are two
    different things, so it's important that you are there and watching them. Getting
    your game played and seeing what those players do is where you will start to see
    the cracks in your design's form, and seeing what people do will show how they
    experience the things you have created. While doing this testing, I've seen a
    lot of people do the exact opposite of what I expected and not understand something
    that I thought was quite simple. The player isn't wrong in this regard though,
    I was. The player can only do what they know from prior playing or from what is
    taught in the game.
  prefs: []
  type: TYPE_NORMAL
- en: All of the information that you get during a playtest is important. Not just
    what they say, but also what they don't say. Once they finish playing, give them
    a survey to fill out. I find using Google Sheets does a good job at storing this
    information and isn't too difficult to set up, and you have hard data from which
    you can make decisions without having to remember what people say. Plus, it's
    a lot easier for people to select a number from 1-10 for how they enjoyed different
    aspects of the game than to ask their thoughts for everything and doesn't require
    them to write paragraphs of info (unless they want to in a comments section at
    the end).
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you''d like to see an example playtesting form, while this form is
    for board games, I feel it does a good job of making it easy for play testers
    to give information that can be useful: [https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/](https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re looking for some ideas of questions to ask, *Wesley Rockholz* wrote
    some examples of questions that may be useful for you to use: [http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php](http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the order in which players give their feedback is also important
    as it communicates how important different things are to them. You may find that
    what was intended to be the main mechanic isn't as engaging and/or fun as something
    else. That is valuable feedback, and you may decide to focus on that secondary
    mechanic instead for the title, as I've seen happen repeatedly on projects. It's
    better to do this as early as possible so you will waste as little of your time
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we've playtested our project and have gotten our player's feedback,
    and, if we have set it up, gotten data and analytics from which we can build upon.
    Now we need to take this information into consideration, make some changes to
    our current prototype, and then bring it back to be play tested again. This is
    what's known as the iteration stage of development.
  prefs: []
  type: TYPE_NORMAL
- en: In this stage, you'll need to take this feedback and then decide how to incorporate
    it into your design. You'll need to decide what should be changed as well as what
    shouldn't. While doing so, keep in mind the scope of the project, realistically
    evaluating how long it will take to make the changes, and be willing to cut features,
    even those that you love, to have the best project.
  prefs: []
  type: TYPE_NORMAL
- en: After making these decisions again, we will once again create a new prototype,
    which you will then playtest again. Then iterate again. Then build another prototype,
    where you will continue to test, removing prototypes that don't work and features
    that don't work well for the project. You'll also try adding new features using
    feedback and remove previous features that would no longer fit the game in its
    current state. You will keep doing this cycle repeatedly until you reach your
    final release!
  prefs: []
  type: TYPE_NORMAL
- en: If you're waiting for your game to be *perfect* before releasing it, you'll
    never release it. Games are never finished, they're only abandoned. If the project
    is at a point where it is good enough, you should ship, because it's only when
    you ship a project that you can finally say you've developed a title.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to see an example of this process and how it can benefit a title,
    check out: [http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php](http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php).'
  prefs: []
  type: TYPE_NORMAL
- en: Meeting milestones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working on a commercial game project, especially when you have a publisher,
    you often times will have a schedule to keep and milestones to meet. Milestones
    are ways for everyone to know if the game is on track or not, because certain
    things need to be accomplished by them. Not making a milestone can often be a
    horrible thing, because your publisher usually will only pay your team if the
    milestone has everything in it that was agreed upon. There''s no standard milestone
    schedule, as every company is different, but some of the most common ones are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-playable**: This is the first version of the game that can be played.
    Has the main mechanic of the game in and can demonstrate how it works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha**: When all the features of your game are in, known as being feature
    complete. Features can change slightly, and make revisions based on feedback and
    testing, but at this point, unimplemented things may be dropped to finish the
    title on time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beta**: The game is complete, with all assets and features completed and
    finished. At this point you are only doing bug testing and fixes for potential
    problems that would prevent your game from being shipped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gold**: This is the final version of the game, which you''ll either be releasing,
    or sending to your publisher to create copies on disks, cartridges, or whatever
    your device uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do note that every company is different and these milestones may mean different
    things to different people, so be sure to clarify before diving into development.
  prefs: []
  type: TYPE_NORMAL
- en: Learning when to use scripting in a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting languages are something that can be quite beneficial to developers
    when working on a team with multiple disciplines in it. But before we dive into
    what they are and how they work, and the pros and cons of using a scripting language,
    it's best to get a bit of a history lesson in terms of how code executes.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Underneath the hood, all the code that we have written over the course of this
    book is ones and zeroes indicating what switches should be marked as on and off
    by our computer's processor. Low-level programming languages such as machine language
    use these switches to execute commands. This was the only way to program to begin
    with, but we have developed more readable languages for us to work with instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with assembly languages, low-level languages have a very strong connection
    between the language''s instructions and the machine code''s instructions. While
    more readable than a sequence of `0`s and `1`s, it was still quite difficult to
    write code. For example, here is some assembly code used to add two numbers in
    Assembly Language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Each computer architecture has its own assembly language, so writing code in
    low-level languages has the disadvantage of not being portable as they are machine
    dependent. Back in the day, people would have to learn many different languages
    in order to port your program to another processor. Program structures became
    more complicated, as the demands of functionality increased over time, making
    it quite difficult for programmers to implement efficient programs that were robust
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to higher-level programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers, we are inherently lazy, so we seek ways to make our job easier
    or rather to find the best use of our time. With that in mind, we have developed
    other higher level languages, which are even easier to read. By higher level,
    we mean closer to the way that humans think or closer to the problem we are trying
    to solve. By abstracting the machine details from our code, we simplify programming
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have finished our code, we use a compiler to translate that high-level
    code into assembly, which in turn will get turned into machine language that our
    computer can execute. Afterwards, it will translate that program into an executable
    file that the user can run. Functionally, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This has several advantages, as it provides abstraction from the hardware details.
    For example, we don't need to work directly with registers, memory, addresses,
    and so on anymore. It also makes our code portable in that we can use the same
    program and have it translated by different assemblers for the different machines
    that use it. This was one of the reasons C took off and became so popular, because
    it allowed people to write code once and then have it work everywhere. You may
    notice that Unity has taken the same thought process to game development, and
    that's one of the reasons that I feel they've been so successful as of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: This is a much more efficient use of time than writing assembly language code
    as it allows us to create more complex programs and machines, and modern compilers
    such as Microsoft's produce some highly efficient assembly code in most circumstances.
    This is what we have been using over the course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code in assembly can still have its benefits though. For instance, after
    you've written your game in a higher-level language, you can start profiling it
    and seeing what aspects of the game are the bottlenecks, and then determine if
    rewriting it in assembly will give you a speed boost. The point of using a lower-level
    language is the fact that you can gain some substantial speed advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a real-life example as to how assembly was used to optimize a game engine,
    check out the following article from Intel: [https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/](https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: One of the issues with writing code that needs to be compiled before running
    is the fact that as projects increase in size, so do compile times. Recompiling
    a full game can take minutes to hours depending on the size of the project, and
    while that's going on, you are unable to work on your project, or else you'd need
    to recompile again. This is one of the reasons why scripting languages can be
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to scripting languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scripting language is a programming language that allows scripts to be written
    for it. A script is a program that can be executed without being compiled in one
    of a few different ways. Scripting languages are also sometimes referred to as
    very high-level programming languages, as they operate at a high level of abstraction,
    being very fast to learn how to write in.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting languages also have the advantage of taking care of a lot of things
    that programmers would need to take care of, such as garbage collection, memory
    management, and pointers, which often confuse non-developers. Even a visual editor
    such as Unreal 4's blueprints is still a scripting language, as it accomplishes
    the same thing as a written one does.
  prefs: []
  type: TYPE_NORMAL
- en: Most games use scripting languages in some form, but other games may use it
    a lot more, such as how GameMaker uses **Game Maker Language** (**GML**) for their
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Using interpreters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a scripting language, we need to be able to execute new code on the
    fly. However, unlike a compiler, there''s also another way to convert code into
    something that can be understood by a machine that is called an interpreter. Interpreters
    do not produce a program themselves, and rather stay around for the execution
    of a program. This program will either:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the source code directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate the source code into some other efficient intermediate representation
    (code) and then immediately execute it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly execute stored precompiled code made by a compiler that is part of
    the interpreter system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter translates one line at a time, as opposed to the compiler doing
    it all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visually, it looks a bit like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see here, the **Interpreter** takes in the **Source Code** and any
    **Input** that has been received, and will then **Output** what is expected of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Just in time compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is yet another way to run code,Â using what's called a **just in time compiler**,
    or **JIT** for short. A JIT caches the instructions, that have been previously
    interpreted to machine code, and reuses those native machine code instructions
    thus saving time and resources by not having to re-interpret statements that have
    already been interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visually, it looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, Unity uses a JIT and AOT compiler to convert code into machine code, which
    can then be read by the machine. The first time that a function is called, the
    game will convert that code into machine language and then the next time it is
    called, it will go directly to the translated code, so you only need to do conversions
    to things that are happening. Due to this happening at runtime, this may cause
    your project to lag when using a lot of new things.
  prefs: []
  type: TYPE_NORMAL
- en: A great talk about how scripting works inside of the Unity game engine can be
    found here:Â [https://www.youtube.com/watch?v=WE3PWHLGsX4](https://www.youtube.com/watch?v=WE3PWHLGsX4).
  prefs: []
  type: TYPE_NORMAL
- en: Why use a scripting language?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is often overkill when it comes to building things for your game, such as
    tools, or for high-level game tasks that could be handled by your technical designers.
    It has some definite advantages for ease of development. Specifically, that you
    don't have to worry about a lot of the low-level things, as the language takes
    care of it for you; there's also fewer errors by the programmer due to the limited
    options available. There's less of a technical programming knowledge required,
    and it can be customized to fit your game's needs. This also makes the game more
    data driven instead of hardcoding things into the game engine, and allows you
    to patch the game without having to send over the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: Often in game development, game logic and configurations can be found in script
    files. This way, it's very easy for scripts to be modified and adjusted by people
    on the team that aren't programmers (such as designers), allowing them to playtest
    the game and tweak the gameplay without having to recompile the game.
  prefs: []
  type: TYPE_NORMAL
- en: Many games also have a console window, which uses a scripting language to do
    things like this even at runtime. For instance, Unreal Engine has a console window
    open by default when you press Tab and in Source engine, pressing the ~ button
    at the pause menu will open one up.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting languages are also often used in areas that have level design as well,
    such as having triggers for when you enter certain areas, or for controlling cinematics.
    It also allows you to let players of your game mod the game as well, which could
    potentially increase the lifespan of your game and help foster your game's community.
  prefs: []
  type: TYPE_NORMAL
- en: When to use C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is a great language to be using, as performance isÂ a crucial first step.
    This used to be all aspects of game engines, but now is used primarily with graphics
    and AI code. Scripting languages also have the problem of being slower than C++,
    sometimes even 10x slower than what it would be otherwise. Due to scripting languages
    having memory management taken care of for them automatically, there could be
    times when commands are interrupted or take a while to complete garbage collection,
    causing lag and other problems.
  prefs: []
  type: TYPE_NORMAL
- en: C++ also has the advantage of much better IDEs and Debuggers, making it a lot
    easier for you to find mistakes and fix them when they do occur.
  prefs: []
  type: TYPE_NORMAL
- en: There's also the possibility that you are working with a legacy code base. Most
    game companies aren't starting with a fresh slate. It can also be useful to make
    use of the middleware libraries that C++ has, such as FMOD and AntTweakBar.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled versus scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some game engines, the game engine itself is programmed in C++, but the
    game logic is entirely done in a scripting language, like most development for
    Unity, for example. This allows you to iterate on gameplay much faster, and allows
    technical designers and artists to modify behaviors without having to bother a
    programmer. Also, depending on the language, it can allow people to use a more
    appropriate language for the problem's domain (for example, AI may not be the
    easiest thing to implement in C++).
  prefs: []
  type: TYPE_NORMAL
- en: Different companies handle working with languages differently. When I was working
    at aÂ AAA (pronounced triple-A)Â studio, we would have designers prototype ideas
    for mechanics and get it working in the best possible way making use of scripting
    languages. Upon approval from the leads as something to add to the project, if
    the script had performance issues, programmers would use the scripting language
    code as a base and then create a super-efficient version using C++ that would
    work in all levels. However, when I was working on an indie title, all of the
    code for the project was written in a scripting language (C#), since we didn't
    have access to the engine's source code (Unity). Also, if you are wanting to target
    devices that are limited in memory and processing power (such as the Nintendo
    3DS), you are likely wanting to care about performance a lot more so it's more
    important to use more optimized code. It's a good idea to be familiar with both
    options and be comfortable working either way.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in using a scripting language for your project, Lua is
    very widely used in the game industry because it's very easy to learn and fairly
    easy to incorporate into your engine. Lua started off as a configuration language.
    This has some nice quirks, in that it's great for creating and configuring things
    - which is what you want to do in a game. It's important to note, though,Â that
    it's not object-oriented but uses a small amount of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of games that use Lua as a scripting language can be found here: [https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games](https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in integrating Lua into your project or would like to
    see how it works, I highly suggest checking out [http://www.lua.org/start.html](http://www.lua.org/start.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of best-practice information, which we hope
    will give you a good foundation when building your own projects in the future.
    We touched on why hardcoding values is a bad idea, in addition to making a number
    of other code-quality suggestions, to ensure that your code is easy to understand
    and easy to extend from in the future, when it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how iteration is useful in game development, talking about the
    traditional game development cycle, with tips and tricks about playtesting and
    how it can be immensely useful when developing your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked into low-level and high-level programming languages, learning
    about how scripting languages run inside another program that we have to build
    into our project. They are not compiled but rather interpreted, and are generally
    easier to use and write code for than a compiled language, but come at the cost
    of performance. Depending on how complex your game is, it may be a good idea to
    stick to just C++, but if you are working with designers, it can be quite useful
    to give them the tools to do things on their own.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've reached the end of the book. We hope that you found the information
    both interesting and useful. As you go out there and build your own projects,
    make use of the design patterns and best practices that we've talked about over
    the past 12 chapters, and make the best games that you can!
  prefs: []
  type: TYPE_NORMAL
