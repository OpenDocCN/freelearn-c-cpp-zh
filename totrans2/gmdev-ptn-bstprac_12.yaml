- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Learning to program is difficult for many reasons, but learning to program games
    is even more difficult, specifically because there are so many different systems
    and object types that need to interact with each other. Throughout this book,
    we have covered some of the most important design patterns to make those interactions
    as simple as possible. Each chapter focused explicitly on a design pattern to
    help make coding easier. However, buried within each paragraph and code sample
    are core ideas and techniques to help make our design easier to read and maintain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编程由于多种原因而困难，但学习游戏编程则更加困难，特别是由于存在许多不同的系统和对象类型需要相互交互。在这本书中，我们已经介绍了一些最重要的设计模式，以使这些交互尽可能简单。每一章都明确地关注一个设计模式，以帮助简化编码。然而，在每个段落和代码示例中，都隐藏着核心思想和技巧，有助于使我们的设计更容易阅读和维护。
- en: These *Best Practices* can sometimes be found in other books; however, programming
    books often strive to teach you the grammar of a language, as opposed to style,
    design, and organization. Even books about design patterns may gloss over these
    fundamental techniques. Since they are so fundamental, it is easy to forget they
    are not necessarily explicitly discussed everywhere. That leaves you, the reader,
    forced to read dozens of books and scour the Internet for blog posts that talk
    about these fundamentals. Worse, you are required to spend hours and hours writing
    code with the feeling that it could be better, but you just don't understand why
    it isn't.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*最佳实践*有时可以在其他书中找到；然而，编程书籍往往努力教你一门语言的语法，而不是风格、设计和组织。即使是关于设计模式的书籍也可能忽略这些基本技巧。由于它们非常基础，很容易忘记它们并不一定在所有地方都明确讨论。这让你，作为读者，不得不阅读数十本书，并在互联网上搜寻讨论这些基础知识的博客文章。更糟糕的是，你需要花费数小时甚至数十小时编写代码，感觉这些代码可以更好，但你就是不明白为什么它不好。
- en: Of course, all those things will happen anyway. Part of being a programmer is
    constantly reading books like this. You should be looking for ways to improve
    by reading blogs and you will write code that you consider garbage after six months.
    This is all part of becoming better. It is our hope in writing this book that
    you can understand and incorporate these fundamentals into your programs sooner
    rather than later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些事情都会发生。作为程序员的一部分是不断阅读这样的书籍。你应该通过阅读博客来寻找改进的方法，你会在六个月后认为你写的代码是垃圾。我们写这本书的愿望是希望你能尽早而不是更晚地理解和将这些基础知识融入你的程序中。
- en: Chapter overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: In this chapter, we will be focusing on fundamental ideas and techniques that
    will improve your code and improve your game. These ideas come from years of programming
    as well as years of teaching. If these seem simple and obvious, that is great.
    However, we chose these topics because they are things that we, the authors, struggled
    with early on, or that our students struggled with.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注那些能够提升你的代码质量和游戏水平的根本思想和技巧。这些思想来源于多年的编程经验以及多年的教学经验。如果这些看起来简单明了，那真是太好了。然而，我们选择这些主题是因为它们是我们，作为作者，早期遇到的难题，或者是我们学生遇到的难题。
- en: Your objectives
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'Over the course of this chapter we will be discussing a number of topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论多个主题：
- en: Learn fundamental code quality techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习基本的代码质量技巧
- en: Learn and understand the uses of the const keyword
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习和理解const关键字的使用
- en: Learn how iteration can improve your game and code design
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习迭代如何改进你的游戏和代码设计
- en: Learn when to use scripting in a game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在游戏中何时使用脚本
- en: Learning fundamental code quality techniques
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基本的代码质量技巧
- en: The process of moving from beginner to expert programmer can be challenging.
    In the beginning, you must learn not only the rules of the language, but also
    how to use a compiler and understand the error messages. Moreover, you are trying
    to solve increasingly difficult programming problems while following what might
    seem like arbitrary rules for writing *good* code. Most novice programmers are
    focused on solving a given problem, as opposed to making the code look nice. To
    many, it seems worthless to spend time making the code look clean, because it
    will almost certainly be deleted after writing it. Even more experienced programmers
    may ignore code style in the rush to complete an assignment or finish a project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从初学者成长为专家程序员的进程可能具有挑战性。一开始，你必须学习不仅语言的规则，还要学习如何使用编译器和理解错误信息。此外，你试图解决越来越困难的编程问题，同时遵循可能看似任意的编写*良好*代码的规则。大多数新手程序员专注于解决给定的问题，而不是使代码看起来很漂亮。对许多人来说，花时间使代码看起来整洁似乎毫无价值，因为编写后它几乎肯定会删除。即使是经验丰富的程序员，在匆忙完成作业或项目时也可能忽略代码风格。
- en: This is bad for a few reasons. First, well-written code is easier to read and
    understand. It almost certainly has fewer errors, and is more efficient than code
    that is carelessly mixed together and never polished. Just as we discussed in
    earlier chapters, the time you spend upfront making sure the code is bug free,
    is time you won't need to use debugging it later. The time you spend making sure
    the code is readable and easy to maintain is time you won't need to spend later
    making changes or deciphering old code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个原因不好。首先，写得好的代码更容易阅读和理解。它几乎肯定有更少的错误，并且比随意混合在一起且从未打磨过的代码更有效率。正如我们在前面的章节中讨论的那样，你前期花在确保代码无错误上的时间，是以后你不需要用来调试的时间。你花在确保代码可读和易于维护上的时间，是以后你不需要用来修改或解读旧代码的时间。
- en: Second, good programming style is a matter of habit. Taking time to read and
    debug your code is slow at first. However, the more you improve your code, the
    easier and quicker it becomes. Eventually, you will develop habits and writing
    quality code will happen naturally. Without this habit, it can be easy to push
    style aside and worry about it later. However, the code that is being written
    is almost always sloppy, and it can be hard to find the time later to go back
    and improve it, since there is always another deadline approaching. With good
    habits, you will be able to write clean, readable code in even the most time-constrained
    situations, such as an interview or a fast-approaching deadline.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，良好的编程风格是一种习惯。花时间阅读和调试你的代码一开始会很慢。然而，随着你不断提高代码质量，它变得越来越容易和快速。最终，你会养成习惯，编写高质量的代码将变得自然而然。没有这种习惯，很容易将风格放在一边，以后再担心。然而，正在编写的代码几乎总是草率的，以后很难找到时间回去改进它，因为总是有另一个截止日期在逼近。有了良好的习惯，你甚至在最紧张的时间限制情况下，如面试或即将到来的截止日期，也能写出干净、可读的代码。
- en: Finally, at some point in the future you will almost certainly be working with
    other programmers. This could be a small team of two or three, or perhaps in a
    company with dozens of programmers all over the world. Even if you understand
    what your code is doing, it is not guaranteed that your teammates will. Writing
    code that is hard to understand will lead to people using your code incorrectly.
    Instead, strive to make your code easy to use and hard to break. Take pride in
    how much other people love to use your code, your teammates and boss will thank
    you. You will appreciate it if your teammates do the same thing. At some point,
    you will be required to maintain other programmers code after they have left the
    job. You will find it much easier to do if they wrote high quality code, so write
    code that will be easy to work with after you have left.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在未来的某个时刻，你几乎肯定会与其他程序员一起工作。这可能是一个由两三个程序员组成的小团队，或者可能是在一个拥有遍布全球数十个程序员的跨国公司中。即使你理解你的代码在做什么，也不能保证你的队友会理解。编写难以理解的代码会导致人们错误地使用你的代码。相反，努力使你的代码易于使用且难以破坏。以其他人对你的代码的喜爱为荣，你的队友和上司会感谢你。如果你的队友也这样做，你会感到很感激。在某个时刻，你将需要维护其他程序员离开工作后的代码。如果你离开后他们写的代码质量高，你会发现这要容易得多，所以写上你离开后也容易工作的代码。
- en: Over the next few pages, we will cover some very basic but extremely important
    code quality tips. As we said, these come from years of reading programming, as
    well as teaching. Use these techniques for every single line of code that you
    write. Think about these techniques for every piece of code that you read. Doing
    so will help you form great habits.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将介绍一些非常基础但极其重要的代码质量提示。正如我们所说，这些来自多年的阅读编程经验，以及教学。将使用这些技术为每行代码。思考这些技术为每段代码。这样做将帮助你形成良好的习惯。
- en: Avoid magic numbers
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用魔法数字
- en: 'Hard coding number literals into code is generally considered a bad idea. The
    problem with using a number literal instead of a named constant is that the purpose
    of that number is unknown to the reader. The number appears in code as if by magic.
    Consider the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字字面量硬编码到代码中通常被认为是一个坏主意。使用数字字面量而不是命名常量的问题是，读者不知道那个数字的目的。数字在代码中似乎凭空出现。考虑以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is hard to know why those four numbers were chosen. It is also hard to know
    how the program will be changed if the values are modified. Code like this would
    be much more readable and maintainable if the named constants or variables were
    used:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很难知道为什么选择了这四个数字。也很难知道如果修改了这些值，程序将如何改变。如果使用命名常量或变量，这样的代码将更容易阅读和维护：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After the change, it is much easier to understand that the position of the new
    UFO is being randomly placed within the world. We can understand that if we change
    the values, the possible starting location of the UFO would either be outside
    of the world, or constrained to a tighter rectangle around the center of the world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更改后，更容易理解新的不明飞行物（UFO）的位置是在世界内随机放置的。我们可以理解，如果我们更改这些值，UFO可能的起始位置将是世界之外，或者被限制在围绕世界中心的更紧密的矩形内。
- en: 'Besides being hard to read and understand, using magic numbers makes the code
    hard to maintain and update. Let''s say we have an array of size 256\. Every loop
    that needs to manipulate the array must hardcode the value 256\. If the array
    size needs to be larger or smaller, we would need to change every occurrence of
    256\. We can''t simply do a *find and replace* because it is very possible that
    256 is used elsewhere in the code for a completely different reason. Instead we
    must look through every occurrence of the number and make sure that we are changing
    the code correctly. If we miss even one, we could create a bug. For example, if
    we are changing the size of the array to something smaller, such as 128\. Any
    loops that still treat the array as if it had size 256 will cause undefined behavior:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了难以阅读和理解之外，使用魔法数字会使代码难以维护和更新。假设我们有一个大小为256的数组。每个需要操作数组的循环都必须硬编码值256。如果数组的大小需要增大或减小，我们就需要更改所有256的出现。我们无法简单地进行“查找和替换”，因为256在代码中可能用于完全不同的原因。相反，我们必须查看数字的所有出现，并确保我们正确地更改了代码。如果我们错过任何一个，我们可能会创建一个错误。例如，如果我们将数组的大小更改为更小的值，例如128。任何仍然将数组视为大小为256的循环都会导致未定义的行为：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As before, it is better to use a named constant instead of a magic number.
    The constant is more readable and easy to change because it only needs to be changed
    in one place. It is also less likely to cause bugs because we are only changing
    the values associated with the array. We won''t accidentally change a value we
    shouldn''t or miss a value that we should change:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最好使用命名常量而不是魔法数字。常量更易于阅读和更改，因为它只需要在一个地方更改。它也较少引起错误，因为我们只更改与数组相关的值。我们不会意外地更改不应该更改的值或错过应该更改的值：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another important reason we don''t want to use magic numbers is that they are
    inflexible. Throughout this book, we try to emphasize the benefits of reading
    data from a file. Obviously, if you hardcode a value, it can''t be read from a
    file. In the preceding example, if `BUFFER_SIZE` ever needs to be changed, the
    code needs to be recompiled. However, if the size of the buffer is read from a
    file at runtime, the code only needs to be compiled one time and the program will
    work for buffers of all sizes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想使用魔法数字的另一个重要原因是它们缺乏灵活性。在这本书中，我们试图强调从文件中读取数据的优点。显然，如果你硬编码一个值，它就不能从文件中读取。在先前的例子中，如果`BUFFER_SIZE`需要更改，代码需要重新编译。然而，如果缓冲区的大小在运行时从文件中读取，代码只需要编译一次，程序将适用于所有大小的缓冲区：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we must remember to deallocate the buffer. Remember,
    that probably won't be the usual case because for arrays, we could always use
    an STL vector. The more general case is that we are reading ints or floats from
    a file. These could be used for anything from screen resolution, to player speed,
    or even the time interval between spawning enemies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们必须记住释放缓冲区。记住，这很可能不是通常的情况，因为对于数组，我们总是可以使用STL向量。更一般的情况是我们从文件中读取整数或浮点数。这些可以用于从屏幕分辨率到玩家速度，甚至到生成敌人的时间间隔等任何东西。
- en: As with all rules, there are a few exceptions or special cases where it might
    be fine to hardcode numbers. The numbers `0` and `1` are generally consider OK.
    These might be used as the initialization values for ints or floats, or just the
    starting index for an array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有规则一样，有一些例外或特殊情况，可能允许硬编码数字。数字`0`和`1`通常被认为是可接受的。这些可能用作整数或浮点数的初始化值，或者只是数组的起始索引。
- en: Your goal is to make your code as readable and flexible as possible, so a named
    constant is almost always going to be better than a hardcoded number. Do your
    best to make sure that your code can be understood by others. Your code isn't
    more readable if you simply have a variable named `ZERO` or `TWO`, so you should
    use your best judgment and perhaps ask another programmer if you think the meaning
    is unclear.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是使你的代码尽可能易于阅读和灵活，因此命名常量几乎总是比硬编码的数字更好。尽你所能确保你的代码可以被他人理解。如果你的变量名为`ZERO`或`TWO`，你的代码并不一定更易于阅读，所以你应该使用你的最佳判断，并在你认为含义不明确时，也许可以询问另一位程序员。
- en: White space
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空白
- en: 'When thinking about high quality code, white space is often forgotten. Maybe
    this is because white space isn''t code you write, but is instead the empty space
    between your code. However, if you don''t use white space correctly, your code
    will be unreadable. When we say white space, we are talking about the spaces,
    tabs, newlines, and blank lines within your program. How you use these can make
    the difference between code that is easy to read and maintain, and code that will
    give you nightmares. Here is a piece of code with very little thought about white
    space:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当思考高质量代码时，空白往往被忽视。也许这是因为空白不是你编写的代码，而是你代码之间的空白空间。然而，如果你没有正确使用空白，你的代码将难以阅读。当我们提到空白时，我们指的是程序内部的空格、制表符、换行符和空白行。你如何使用这些元素可以决定代码是易于阅读和维护，还是让你做噩梦。以下是一段对空白考虑很少的代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code is perfectly acceptable to the compiler. For humans, however,
    the code above is hard to read because there is no line spacing, no indentation,
    and no consistency. Of course, this is an extreme example, but throughout our
    years of teaching, we have seen examples of code with just as little thought to
    style and formatting. When code looks like the example above, the quality of comments
    and identifier names doesn''t matter because the entire block is difficult to
    read. Compare the preceding code with the following version, which has tried to
    code for human readability:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对编译器来说是完全可接受的。然而，对于人类来说，上面的代码难以阅读，因为没有行间距、缩进和不一致。当然，这是一个极端的例子，但我们在多年的教学过程中，也看到了对样式和格式考虑很少的代码示例。当代码看起来像上面的例子时，注释和标识符名称的质量并不重要，因为整个块难以阅读。将上述代码与以下版本进行比较，该版本试图使代码对人类可读：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the preceding example is by no means the perfect example of high quality
    code, it is certainly more readable and maintainable than the first example. When
    it comes to real-world programs and programmers, there is no such thing as perfect.
    Every programmer has their own style, which really means that every programmer
    believes their style is the easiest to read. However, as you read more code, you
    will notice that there are certain common elements to code that is readable. Let's
    look at some of those elements now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子绝对不是高质量代码的完美示例，但它确实比第一个例子更易于阅读和维护。当涉及到现实世界的程序和程序员时，没有什么是完美的。每个程序员都有自己的风格，这实际上意味着每个程序员都认为自己的风格是最容易阅读的。然而，随着你阅读更多的代码，你会注意到可读代码有一些共同元素。现在让我们看看这些元素中的一些。
- en: Indentation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩进
- en: 'Block statements such as loops and conditionals should have the sub statements
    indented. This easily shows the program intent to the reader. The number of spaces
    to indent is less important than the indentation itself. Most programmers agree
    that 2 to 4 spaces are sufficient for readability. The most important thing is
    to be consistent with your spacing. Likewise, the placement of the starting curly
    brace isn''t important, (although you can find some interesting arguments online),
    but it is important to consistently place it in the same location:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 块语句，如循环和条件语句，应该将子语句缩进。这很容易向读者展示程序意图。缩进的空格数量不如缩进本身重要。大多数程序员认为2到4个空格对于可读性是足够的。最重要的是要保持缩进的一致性。同样，起始大括号的位置并不重要（尽管你可以在网上找到一些有趣的论点），但重要的是要始终将其放置在同一位置：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is important to remember that in C++, indentation has no meaning to the
    compiler. Without the curly braces, loops and conditionals will execute only one
    statement. For this reason, some programmers will always use the curly braces,
    regardless of how many sub statements are needed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，在C++中，缩进对编译器没有意义。如果没有大括号，循环和条件语句将只执行一个语句。因此，一些程序员无论需要多少个子语句，都会始终使用大括号：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example is misleading, because only the first statement will be
    part of the loop. It can be a common mistake when writing a loop or conditional
    to forget to add curly braces after adding a second statement. For this reason,
    some programmers will use curly braces even for single statement loops and conditionals.
    The idea is that the code is more readable and easier to maintain, and so it is
    less prone to error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子具有误导性，因为只有第一个语句将作为循环的一部分。在编写循环或条件语句时，忘记在添加第二个语句后添加大括号是一种常见的错误。因此，一些程序员即使在单语句循环和条件语句中也会使用大括号。这种想法是代码更易于阅读和维护，因此更不容易出错。
- en: Blank lines and spaces
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空行和空格
- en: 'As we said before, how you use white space will determine how readable your
    code is. Using indentation for code blocks is one way to show the logical structure
    of a program. Another good way to show this is by using blank lines. Just as a
    good piece of writing is separated into paragraphs, a good piece of code should
    be separated into some form of logical grouping. Group statements together that
    logically go together. Put blank lines between the groups to improve the readability:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，你如何使用空白空间将决定你的代码的可读性。使用缩进来表示代码块是显示程序逻辑结构的一种方法。另一种展示这种结构的好方法是使用空行。就像一篇好的写作被分成段落一样，好的代码也应该以某种逻辑分组的形式被分隔。将逻辑上相关的语句组合在一起。在组之间放置空行以提高可读性：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code has no blank lines so the code seems to run together. It
    is hard to look at it and understand what the code is doing because your brain
    tries to understand all of it at once. Even though there are comments, they don''t
    really help because they blend in to the rest of the code. The if statement is
    also hard to read because the conditions are separated by how they fit on the
    line instead of a logical alignment. In the following code, we have added some
    blank lines to separate the logic grouping of the statements:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有空行，所以代码看起来是连续的。看它很难理解代码在做什么，因为你的大脑试图一次性理解所有内容。尽管有注释，但它们并没有真正帮助，因为它们与代码的其他部分混合在一起。if语句也难以阅读，因为条件是通过它们在行上的适应而不是逻辑对齐来分隔的。在下面的代码中，我们添加了一些空行来分隔语句的逻辑分组：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By using line breaks to group related statements together, the code is separated
    into easy to understand chunks. These chunks help the reader understand which
    statements should logically go together. In addition, the comment at the beginning
    of each chunk sticks out much more and explains in English exactly what will happen
    will contained in the chunk.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用行断开来将相关的语句组合在一起，代码被分隔成易于理解的块。这些块帮助读者理解哪些语句在逻辑上应该放在一起。此外，每个块开头的注释更加突出，并用英语准确说明了块中将要发生的事情。
- en: 'Complicated conditional statements should be separated and aligned based on
    the conditions so they are easier to understand. In the preceding code, each of
    the four conditions are aligned in the same way. This gives a clue to the reader
    as to how the condition will be executed. Using parentheses along with aligning
    the code further adds to the readability:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的条件语句应该根据条件进行分隔和对齐，以便更容易理解。在前面给出的代码中，四个条件都是按照相同的方式进行对齐的。这为读者提供了关于条件将如何执行的解释。使用括号并结合代码对齐进一步增加了可读性：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using parentheses isn't just helpful in conditionals. All complicated expressions
    should be grouped together with parentheses. Of course, everyone's definition
    of complicated differs, so a good general rule is `*`, `/`, and `%` are executed
    before `+` and `-`; use parentheses for everything else. In addition to being
    clearer to the reader, this will ensure that the code is executing exactly as
    you expect. Even if you understand all the C++ rules of precedence and associativity,
    your teammates may not. Parentheses don't cost anything but can improve the readability,
    so feel free to use them as much as possible to show the intent of the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号不仅仅在条件语句中有帮助。所有复杂的表达式都应该用括号括起来。当然，每个人对复杂的定义都不同，所以一个好的通用规则是 `*`、`/` 和 `%`
    的执行顺序在 `+` 和 `-` 之前；其他所有情况都使用括号。这不仅会让读者更清晰，还能确保代码的执行方式与你预期的一致。即使你理解了所有 C++ 的优先级和结合性规则，你的队友可能不一定理解。括号并不需要任何成本，但可以提高可读性，所以请尽可能多地使用它们来展示代码的意图。
- en: Comments and self-documenting code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释和自文档化的代码
- en: Comments and documentation seem to be more controversial than they should be.
    On the one hand, many people think comments and documentation are a waste of time.
    Writing documentation literally takes time away from writing code, and reading
    comments takes time away from reading the code. In addition, some people think
    that comments just don't help because they can become out of date, and don't explain
    anything that isn't already in the source code. The worst situation with comments
    is when they are flat out wrong. In that case, the code would be better off without
    the comments at all.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注释和文档似乎比它们应有的争议性更大。一方面，许多人认为注释和文档是浪费时间。编写文档实际上会从编写代码中夺走时间，阅读注释则会从阅读代码中夺走时间。此外，有些人认为注释根本不起作用，因为它们可能会过时，而且不能解释源代码中已经存在的内容。注释最糟糕的情况是它们完全错误。在这种情况下，没有注释的代码可能反而更好。
- en: However, there are few things more frustrating than debugging code written by
    someone that didn't add comments. Even debugging your own code just a few months
    after you have written it can be difficult. In the end, the time spent writing
    and updating comments is time that you and your teammates won't need to spend
    deciphering code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有什么比调试没有添加注释的代码更令人沮丧的了。即使是你自己几个月前编写的代码，调试起来也可能很困难。最终，编写和更新注释所花费的时间是你和你的队友不需要花费在解读代码上的时间。
- en: 'While the use of comments may be controversial, writing clean, high-quality
    code is important to everyone. As we have already seen earlier, using white space
    well can improve readability. However, white space alone doesn''t make code readable.
    We really want our code to be self-documenting. Here is an example of that, which
    is difficult to read, even though it has proper white space:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然注释的使用可能存在争议，但编写干净、高质量的代码对每个人都很重要。正如我们之前已经看到的，合理使用空白空间可以提高可读性。然而，仅仅空白空间本身并不能使代码可读。我们真正希望我们的代码是自文档化的。以下是一个例子，尽管它有适当的空白空间，但仍然难以阅读：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Can you tell what the algorithm is doing? Unless you happen to know this algorithm
    already, chances are that you may not understand the intent of the function. Comments
    would help here, but the bigger problem is the low quality of the identifiers.
    Good variable names provide a hint as to what they will be used for. The idea
    is that, with good variable names, you should be able to understand the code without
    the need for comments. This is how you make your code self-documenting:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出这个算法在做什么吗？除非你恰好已经知道这个算法，否则你很可能不会理解函数的意图。注释在这里会有帮助，但更大的问题是标识符的低质量。好的变量名可以提供关于它们将用于什么的线索。想法是，有了好的变量名，你应该能够在不需要注释的情况下理解代码。这就是你使代码自文档化的方式：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Even if you don't understand every single line of the preceding code example,
    you can at least use the function name as a guide. The name `CalculateSievePrimes`
    is a big clue as to what the function is doing. From there you should be able
    to piece together what each line is doing. Names such as candidate, `arraySize`,
    and multiple are much more meaningful than `a`, `b`, and `c`. The best part about
    self-documenting code is that it can never be wrong, and never become out of date.
    Of course, the code can still contain bugs. It just can't be out of sync with
    the documentation, because the code is the documentation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不理解前一个代码示例中的每一行，你至少可以使用函数名作为指南。名称`CalculateSievePrimes`是关于函数正在做什么的一个重要线索。从那里，你应该能够拼凑出每一行正在做什么。名称如candidate、`arraySize`和multiple比`a`、`b`和`c`更有意义。自文档代码的最好部分是它永远不会出错，也永远不会过时。当然，代码仍然可能包含错误。只是它不能与文档不同步，因为代码本身就是文档。
- en: There are a few things that you can do to attempt to make the code self-documenting,
    as we said before. Good variable names are a start. The variable name should explain
    the exact purpose of the variable and they should only be used for that purpose.
    For Boolean variables, give a name that makes it obvious what true means. A name
    such as `isActive` is much better than simply `active` or `activeFlag` because
    the names gives a hint as to what true means for that variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，你可以做一些事情来尝试使代码具有自文档特性。好的变量名是一个开始。变量名应该解释变量的确切目的，并且它们应该只用于那个目的。对于布尔变量，给出一个使真值含义显而易见的名称。例如，`isActive`比仅仅`active`或`activeFlag`要好得多，因为这样的名称给出了关于该变量真值含义的提示。
- en: Often there will be naming conventions that distinguish between types, local
    variables, constants, and static or global variables. Some of these naming conventions,
    such as using all capital letters for `const` variables, are very common and used
    by most programmers. Other naming conventions, such as beginning all static variable
    names with an `s_`, or adding a `p` at the beginning of pointers, are less common.
    Whether you think these styles look ugly or not, understand that they are there
    to help readability and make wrong code look wrong. The compiler will already
    catch some of the problems that these naming conventions aim to solve, but since
    they can still help readability they are worth considering.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会有一些命名约定来区分类型、局部变量、常量和静态或全局变量。其中一些命名约定，例如使用全部大写字母来表示`const`变量，是非常常见的，并且被大多数程序员所使用。其他命名约定，例如所有静态变量名以`s_`开头，或者在指针名前添加`p`，则不太常见。无论你认为这些风格是否丑陋，都要明白它们的存在是为了帮助提高可读性，并使错误代码看起来更明显。编译器已经可以捕获这些命名约定旨在解决的问题中的一些，但鉴于它们仍然有助于提高可读性，因此值得考虑。
- en: When giving names to methods and functions, similar rules apply. Give a clear
    name that explains the purpose of the function. Make sure the function or method
    only has one purpose. Typically, the name should be an action. `CalculateSievePrimes`
    is a much clearer name than `SeivePrimes` or even just `Calculate`. As with Boolean
    variables, methods or functions that return Boolean values are often named with
    a hint. The name `IsEmpty` or `IsPowerOfTwo` are much more clear than `Empty`
    or `PowerOfTwo`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当给方法和函数命名时，也适用类似的规则。给出一个清晰的名称，说明函数的目的。确保函数或方法只有一个目的。通常，名称应该是一个动作。`CalculateSievePrimes`比`SeivePrimes`或仅仅是`Calculate`的名称更清晰。与布尔变量一样，返回布尔值的函数或方法通常带有提示性的名称。名称`IsEmpty`或`IsPowerOfTwo`比`Empty`或`PowerOfTwo`更清晰。
- en: Commenting
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: If the code is self-documenting, then why do we need to add comments at all?
    This is certainly the feeling of some programmers. When the comments aren't doing
    more than simply repeating the code, or when comments are out of date and difficult
    to update, then it is easy to understand why they feel that way. However, this
    is the opposite of what good comments should be.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码是自文档的，那么我们为什么还需要添加注释呢？这确实是某些程序员的感受。当注释只是简单地重复代码，或者当注释过时且难以更新时，很容易理解他们为什么会这样想。然而，这与好的注释应有的作用正好相反。
- en: 'Good comments should explain things that the code cannot. For example, copyright
    information, or author and contact information are things that can''t be represented
    in code, but may be of use to the reader. Additionally, good comments do not simply
    repeat the code. The comment below is completely worthless. It adds nothing to
    the code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的注释应该解释代码无法表达的内容。例如，版权信息、作者和联系方式等，这些都是代码无法表示但可能对读者有用的信息。此外，好的注释不会简单地重复代码。下面的注释完全无用。它对代码没有任何帮助：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead, good comments should explain the intent and purpose of the code. Even
    if you understand what a block of code is supposed to do, you can''t know what
    the author was thinking when they wrote it. Knowing what the author was trying
    to accomplish can save you a lot of time when debugging someone else''s code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，好的注释应该解释代码的意图和目的。即使你理解了一块代码应该做什么，你也不知道作者在编写它时在想什么。了解作者试图实现的目标可以在调试他人代码时节省你很多时间：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The comments above explain what the author was thinking while writing the code.
    They do not just repeat what the code is doing. Notice that some comments explain
    a single line, while other comments summarize entire code blocks. There aren't
    any hard rules about how many comments should be in your code. A rough suggestion
    is that every code block should have a comment explaining its purpose, with additional
    comments for more complex lines.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述注释解释了作者在编写代码时的想法。它们不仅仅是重复代码正在做什么。注意，一些注释解释了一行代码，而其他注释总结了整个代码块。关于代码中应该有多少注释并没有硬性规定。一个粗略的建议是，每个代码块都应该有一个注释来解释其目的，对于更复杂的行则可以有额外的注释。
- en: The comment blocks such as the one at the top of the method are the least likely
    to be used but they can serve an important purpose as well. Just as the section
    headers of this book help when you are scanning for something specific, function
    headers can help you when scanning a source code file looking for a specific function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于方法顶部的那段注释块最不可能被使用，但它们也能起到重要的作用。就像这本书的章节标题在查找特定内容时很有帮助一样，函数标题在扫描源代码文件查找特定函数时也能提供帮助。
- en: Functions headers can be very helpful because they summarize everything about
    the function without the need to look at the code. Anyone can easily understand
    the purpose of the parameters, return values, and even any exceptions that may
    be thrown. The best part is, by using a tool such as Doxygen, the header blocks
    can be extracted to make external documentation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数标题非常有用，因为它们总结了关于函数的所有信息，而无需查看代码。任何人都可以轻松理解参数的目的、返回值，甚至可能抛出的任何异常。最好的部分是，通过使用像Doxygen这样的工具，可以将头文件块提取出来制作外部文档。
- en: Check out the Doxygen tool and documentation at [http://www.stack.nl/~dimitri/doxygen/](http://www.stack.nl/~dimitri/doxygen/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Doxygen工具和文档，请访问[http://www.stack.nl/~dimitri/doxygen/](http://www.stack.nl/~dimitri/doxygen/)。
- en: Of course, these are the most difficult to write and maintain. It is comment
    blocks like these that often become out of date or are flat out wrong. It is up
    to you and your team if you want to use them. It takes discipline to keep up with
    them, but they can be worth it if you happen to be working on another programmer's
    code after they have left the team.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些是最难编写和维护的。正是这样的注释块常常变得过时或完全错误。是否使用它们取决于你和你所在的团队。保持它们需要自律，但如果你在团队成员离开团队后处理他们的代码，它们可能就值得了。
- en: Learning and understand the uses of the const keyword
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习和理解`const`关键字的使用
- en: Using `const` is another area of programming that seems to be a little controversial.
    Some programmers argue that they have never had a bug where using `const` would
    have helped. Others feel that, since you can't guarantee that a `const` object
    won't be modified, it is completely worthless. The fact is that `const` objects
    can be modified. `const` is not magic. So, is `const` correctness still a good
    thing? Before we get into that, let's have a look at what `const` is.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`是编程中似乎有些争议的另一个领域。一些程序员认为他们从未遇到过使用`const`就能解决问题的bug。另一些人则认为，由于你不能保证`const`对象不会被修改，所以它完全无用。事实上，`const`对象是可以被修改的。`const`并非魔法。那么，`const`的正确性是否仍然是一个好东西呢？在我们深入探讨这个问题之前，让我们先看看`const`是什么。
- en: When you create a `const` variable, you must initialize it. All `const` variables
    will be checked at compile time to make sure that the variable is never assigned
    a new value. Since it happens at compile time, it doesn't have an influence on
    the performance. These are a few benefits that we should consider. First, it improves
    readability. By marking a variable as `const`, you are letting the reader know
    that this variable is not supposed to change. You are sharing your intent about
    the variable and making your code self-documenting. `const` variables are also
    usually named in all capital letters, which further helps with readability. Second,
    since the variable is checked at compile time, there is no way for the user to
    accidently change the value. If someone tries to modify the variable, it will
    cause a compiler error. This is great for you if you were expecting the value
    to stay the same. This is great for the user if the modification was truly an
    accident.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`const`变量时，你必须对其进行初始化。所有`const`变量都会在编译时进行检查，以确保变量不会被赋予新的值。由于这发生在编译时，因此它不会对性能产生影响。以下是一些我们应该考虑的益处。首先，它提高了可读性。通过将变量标记为`const`，你是在告诉读者这个变量不应该改变。你正在分享你对变量的意图，并使你的代码具有自文档化的特性。`const`变量通常也使用全部大写字母命名，这进一步有助于提高可读性。其次，由于变量是在编译时进行检查的，因此用户无法意外地更改其值。如果有人试图修改变量，将会导致编译器错误。如果你预期值保持不变，这对你来说是个好消息。如果修改确实是一个意外，这对用户来说也是个好消息。
- en: Compiler errors should always be preferred over runtime. Anytime we can use
    the compiler to help us find problems, we should. This is the same reason that
    many programmers choose to set their compiler warnings to maximum and treat those
    warnings as errors. Time spent fixing a known compiler issue is time you won't
    have to spend finding the runtime error that it might cause.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 应该始终优先考虑编译器错误而不是运行时错误。任何时候我们都可以使用编译器来帮助我们找到问题。这就是为什么许多程序员选择将他们的编译器警告设置为最大，并将这些警告视为错误。花时间修复已知的编译器问题，你就不必花费时间去寻找它可能引起的运行时错误。
- en: Additionally, `const` variables should be preferred over C style `#define` macros.
    Macros are a blunt tool. Sometimes they may be the only tool for the job, but
    they are overkill for simple symbolic constants. Macros do a blind *find and replace*.
    Anywhere the symbolic constant is in the source code, the value will replace it.
    While these situations may be rare, they can also be frustrating. Since the values
    are replaced in the pre-processing phase, the source code is unchanged when you
    go to fix the problem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应优先使用`const`变量而不是C风格的`#define`宏。宏是一个简单的工具。有时它们可能是完成工作的唯一工具，但对于简单的符号常量来说，它们是过度杀伤。宏进行盲目的*查找和替换*。符号常量在源代码中的任何位置都会被其值替换。虽然这些情况可能很少见，但它们也可能令人沮丧。由于值是在预处理阶段被替换的，所以在你试图解决问题时，源代码不会发生变化。
- en: 'The `const` variables, on the other hand, are part of the language. They follow
    all the normal language rules for types and operators. There is nothing mysterious
    happening. They are just variables that can''t be reassigned:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`const`变量是语言的一部分。它们遵循所有正常的语言规则，包括类型和运算符。没有神秘的事情发生。它们只是不能重新分配的变量：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Const function parameters
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`const`函数参数'
- en: Creating `const` variables as symbolic constants makes code more readable because
    we are avoiding magic numbers. However, `const` correctness is more than just
    creating symbolic constants. It is important to understand `const` in relation
    to function parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将`const`变量作为符号常量创建可以使代码更易读，因为我们避免了使用魔法数字。然而，`const`的正确性不仅仅局限于创建符号常量。理解`const`与函数参数的关系同样重要。
- en: 'It is important to understand the difference between these different function
    signatures:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些不同函数签名之间的区别很重要：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default behavior of C and C++ is to pass by value. This means that, when
    you pass a variable to a function, a copy is made. Changes made to function parameters
    do not modify the original variable. The function author has freedom to use the
    variable however they want, while the original variable owner can be sure that
    the values will remain unchanged.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++的默认行为是按值传递。这意味着当你将变量传递给函数时，会创建一个副本。对函数参数所做的更改不会修改原始变量。函数作者有自由使用变量的方式，而原始变量所有者可以确信值将保持不变。
- en: 'That means, as far as the original variable owner is concerned, these two function
    signatures behave the same. In fact, the compiler doesn''t make a distinction
    between these two when considering function overloading:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，从原始变量所有者的角度来看，这两个函数签名表现相同。实际上，在考虑函数重载时，编译器不会在这两个之间做出区分：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since it is impossible for a pass by value variable to be modified when it gets
    passed to a function, many programmers do not mark these parameters as `const`.
    It can still be a good idea to mark them as `const`, because it signifies to the
    reader that the variable value shouldn't be changed. However, this type of parameter
    is less important to mark as `const` since it can't be changed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按值传递的变量在传递给函数时无法被修改，许多程序员不会将这些参数标记为`const`。尽管如此，将它们标记为`const`仍然是一个好主意，因为这向读者表明变量的值不应该被改变。然而，这种类型的参数标记为`const`的重要性较低，因为它不能被改变。
- en: 'What about when you want to pass an array to a function? Remember that one
    of the little quirks of C and C++ is the fact that arrays and pointers are sometimes
    treated similarly. When you pass an array to a function, a copy of the array is
    not made. Instead, a pointer to the first element is passed. One side effect of
    this default behavior is that the function can now modify the original data:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将数组传递给函数时怎么办？记住，C和C++的一个小特点是数组有时和指针被类似对待。当你将数组传递给函数时，并不会创建数组的副本。相反，传递的是指向第一个元素的指针。这种默认行为的一个副作用是函数现在可以修改原始数据：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, there is nothing preventing the function from modifying the
    original data. The `size` variable in the function is a copy of `SIZE` in main.
    However, the `buffer` variable is a pointer to array. The `PrintArray` function
    is short, so finding this bug might be easy, but in a longer function that may
    pass the pointer to additional functions, this problem can be difficult to track
    down.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，没有任何东西阻止函数修改原始数据。函数中的`size`变量是主函数中`SIZE`的一个副本。然而，`buffer`变量是一个指向数组的指针。由于`PrintArray`函数很短，所以找到这个错误可能很容易，但在一个可能将指针传递给其他函数的较长的函数中，这个问题可能很难追踪。
- en: 'If the user wanted to prevent the function from modifying the data, they could
    mark array as const. However, they won''t be able to use the `PrintArray` function,
    and they won''t be able to modify the data either:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想防止函数修改数据，他们可以将数组标记为const。然而，他们将无法使用`PrintArray`函数，也无法修改数据：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, sometimes the purpose of the function is to modify data. In that
    case, the user would just have to accept that if they wanted to use the function.
    With a name like `PrintArray`, the user probably expects that the data will be
    unchanged after the function call. Is the data modification on purpose or an accident?
    The user has no way of knowing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时函数的目的是修改数据。在这种情况下，用户必须接受如果他们想使用该函数的话。对于像`PrintArray`这样的名字，用户可能期望在函数调用后数据不会改变。数据修改是有意为之还是意外？用户无法得知。
- en: Since the problem is with the poor function name, it is up to the function author
    to make the change. They can choose to make the name clearer, perhaps something
    such as `ClearAndPrintArray`, or fix the error. Of course, fixing the error doesn't
    prevent something like this from happening again, and it doesn't clarify the intent
    of the function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于问题出在函数名不清晰，所以修改的责任在于函数的作者。他们可以选择使名称更清晰，比如使用`ClearAndPrintArray`这样的名字，或者修复错误。当然，修复错误并不能防止类似的事情再次发生，也不能明确函数的意图。
- en: 'A better idea would be for the author to mark buffer as a const parameter.
    This will allow the compiler to catch any accidents like the one above, and it
    will signal to the user that the function promises not to modify the data:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的主意是作者将缓冲区标记为const参数。这将允许编译器捕捉到上述类似的事故，并且会向用户表明函数承诺不会修改数据：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we said before, the `size` variable could also be marked as const. This would
    more clearly demonstrate that the variable shouldn't change, but it isn't necessary
    because it is a copy. Any modification of size will not change the value of `SIZE`
    in main. For this reason, many programmers, even the ones that strive for const
    correctness, do not mark *pass by value* parameters as const.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，`size`变量也可以标记为const。这将更清楚地表明变量不应该改变，但这不是必要的，因为它是一个副本。对大小的任何修改都不会改变主函数中`SIZE`的值。因此，许多程序员，即使是那些追求const正确性的程序员，也不会将*按值传递*的参数标记为const。
- en: Const classes as parameters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量类作为参数
- en: We have now discussed the default behavior when passing arrays to functions.
    The compiler will automatically pass in a pointer to the first element of the
    array. This is good for both speed and flexibility. Since only a pointer is passed
    in, the compiler doesn't need to spend time copying a (possibly) large array.
    This is also more flexible, because the function can work with arrays of all sizes
    instead of just a specific size.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了将数组传递给函数时的默认行为。编译器会自动传递数组的第一个元素的指针。这对速度和灵活性都有好处。由于只传递了一个指针，编译器不需要花费时间复制一个（可能）大的数组。这也更加灵活，因为函数可以处理所有大小的数组，而不仅仅是特定大小的数组。
- en: 'Unfortunately, when passing structs or classes to a function, the default behavior
    is *pass by value*. We say unfortunately, because this will automatically evoke
    the copy constructor, which may be expensive and unnecessary if the function is
    only reading data from the data type. A good general rule to follow is when passing
    structs or classes to functions, do not pass by value, pass by pointer, or reference.
    This avoids the possibly expensive copy of the data. There are certainly exceptions
    to this rule, but 99% of the time, passing by value is the wrong thing to do:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当将结构体或类传递给函数时，默认行为是*按值传递*。我们说不幸的是，因为这会自动调用复制构造函数，这可能既昂贵又没有必要，如果函数只是从数据类型中读取数据。遵循的一个好的一般规则是，当将结构体或类传递给函数时，不要按值传递，而是通过指针或引用传递。这避免了可能昂贵的复制数据。当然，这个规则肯定有例外，但99%的情况下，按值传递是错误的做法：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We would like to avoid the expensive copy constructor call when passing `GameObjects`
    to functions. Unfortunately, when we pass by pointer or reference, the function
    has access to our public data and can modify it. As before, the solution is to
    pass by pointer to `const` or reference to `const`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免在将`GameObjects`传递给函数时调用昂贵的复制构造函数。不幸的是，当我们通过指针或引用传递时，函数可以访问我们的公共数据并修改它。正如之前所做的那样，解决方案是通过指针传递到`const`或通过`const`引用传递：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When writing functions, if the purpose is to modify the data, then you should
    pass by reference. However, if the purpose is not to modify the data, then pass
    by reference to const. You will avoid the expensive copy constructor call, and
    the data will be protected from accidental modification. Additionally, by making
    a habit of passing by reference or reference to `const`, you code will be self-documenting.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，如果目的是修改数据，那么你应该通过引用传递。然而，如果目的不是修改数据，那么通过`const`引用传递。这样你将避免昂贵的复制构造函数调用，并且数据将受到意外修改的保护。此外，通过养成通过引用或`const`引用传递的习惯，你的代码将是自文档化的。
- en: Const member functions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量成员函数
- en: 'In the previous example, we kept the struct very simple. Since the struct didn''t
    have any member functions, we only needed to worry about when non-member functions
    want to modify the data. However, object-oriented programming suggests that we
    shouldn''t have data be public. Instead, all data should be private and accessed
    through public member functions. Let''s look at a very simple example to understand
    this concept:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们保持了结构体非常简单。由于结构体没有成员函数，我们只需要担心非成员函数何时想要修改数据。然而，面向对象编程建议我们不应该有公共数据。相反，所有数据都应该是私有的，并通过公共成员函数访问。让我们通过一个非常简单的例子来理解这个概念：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As expected, when our class is not marked as `const`, we can use both the `SetData`
    and `GetData` member functions. However, when we mark our class as `const`, we
    expect that we won't be able to use the `SetData` member function, because it
    modifies the data. However, unexpectedly, we can't use the `GetData` member function,
    even though it doesn't modify the data at all. To understand what is going on,
    we need to understand how member functions are called and how a member function
    modifies the correct data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当我们的类没有被标记为`const`时，我们可以使用`SetData`和`GetData`成员函数。然而，当我们把我们的类标记为`const`时，我们预期将无法使用`SetData`成员函数，因为它会修改数据。然而，出乎意料的是，即使它根本不会修改数据，我们也无法使用`GetData`成员函数。为了理解发生了什么，我们需要了解成员函数是如何被调用的以及成员函数是如何修改正确数据的。
- en: 'Whenever a non-static member function is called. The first parameter is always
    the hidden `this` pointer. It is a pointer to the instance that is calling the
    function. This parameter is how the `SetData` and `GetData` can act upon the correct
    data. The `this` pointer is optional within the member function, as programmers,
    we can choose to use it or not:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用非静态成员函数时，第一个参数总是隐藏的 `this` 指针。它是指向调用该函数的实例的指针。这个参数是 `SetData` 和 `GetData`
    能够作用于正确数据的方式。`this` 指针在成员函数中是可选的，作为程序员，我们可以选择使用或不使用它：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is completely true. The `this` pointer is actually a `const` pointer to
    a `Simple` class. We didn''t talk about const pointers, but it just means the
    pointer can''t be modified, but the data it points to (the `Simple` class) can
    be. This distinction is important. The pointer is `const`, but the `Simple` class
    is not. The actual hidden parameter would look something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全正确。`this` 指针实际上是一个指向 `Simple` 类的 `const` 指针。我们之前没有讨论过 `const` 指针，但这仅仅意味着指针本身不能被修改，但它所指向的数据（即
    `Simple` 类）是可以被修改的。这种区别很重要。指针是 `const` 的，但 `Simple` 类不是。实际的隐藏参数看起来可能像这样：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we have code like this that calls a member function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到如下调用成员函数的代码：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The compiler is really turning it into code that looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器实际上将其转换成如下代码：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the reason we get errors when we try to pass a `const Simple` object
    to the member function. The function signature is not correct. The function does
    not accept a `const Simple` object. Unfortunately, since the `this` pointer is
    hidden, we cannot simply make the `GetData` function accept a `const Simple` pointer.
    Instead we must mark the function as `const`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当我们尝试将 `const Simple` 对象传递给成员函数时会出现错误的原因。函数签名是不正确的。该函数不接受 `const Simple`
    对象。不幸的是，由于 `this` 指针是隐藏的，我们无法简单地让 `GetData` 函数接受 `const Simple` 指针。相反，我们必须将函数标记为
    `const`：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We must mark the function as const within the class as well. Notice that `SetData`
    is not marked const, because the purpose of that function is to modify the class,
    but `GetData` is marked `const` because it only reads data from the class. So,
    our code would look something like the following. To save space, we didn''t include
    the function definitions again:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在类内部也将函数标记为 `const`。注意，`SetData` 没有标记为 `const`，因为该函数的目的是修改类，但 `GetData`
    被标记为 `const`，因为它只从类中读取数据。所以，我们的代码可能看起来像以下这样。为了节省空间，我们没有再次包含函数定义：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, by marking the `GetData` member function as const, it can be
    used when the variable instance is marked const. Marking member functions as const
    allows the class to work correctly with non-member functions that may be attempting
    const correctness. For example, a non-member function (possibly written by another
    programmer) trying to display a `Simple` object by using the `GetData` member
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过将 `GetData` 成员函数标记为 `const`，它可以在变量实例被标记为 `const` 时使用。将成员函数标记为 `const`
    允许类与非成员函数正确地工作，这些非成员函数可能正在尝试保持 `const` 正确性。例如，一个非成员函数（可能由另一个程序员编写）试图通过使用 `GetData`
    成员函数来显示 `Simple` 对象：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since `DisplaySimple` isn't intending to change the data in the class, the parameter
    should be marked as `const`. However, this code will only work if `GetData` is
    a `const` member function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DisplaySimple` 并不打算更改类中的数据，参数应该被标记为 `const`。然而，这段代码只有在 `GetData` 是 `const`
    成员函数的情况下才能正常工作。
- en: Being const-correct takes a little work and may seem difficult at first. However,
    if you make it a habit, it will eventually become the natural way that you program.
    When you are const-correct, your code is cleaner, more protected, self-documenting,
    and more flexible, because you are prepared for const and non-const instances.
    As a rule, if your function isn't going to modify the data, mark the parameter
    as const. If the member function isn't going to modify the class data, mark the
    member function as const.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 `const` 正确性需要一点工作，一开始可能看起来有些困难。然而，如果你养成习惯，它最终会成为你编程的自然方式。当你保持 `const` 正确性时，你的代码会更干净、更安全、更具有自解释性，并且更灵活，因为你为
    `const` 和非 `const` 实例做好了准备。一般来说，如果你的函数不会修改数据，就将参数标记为 `const`。如果成员函数不会修改类数据，就将成员函数标记为
    `const`。
- en: Problems with const
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`const` 相关问题'
- en: As we said before, const isn't magic. It doesn't make your code 100% secure
    and protected. Knowing and understanding the rules related with const parameters
    and const member function will help prevent mistakes. However, failing to understand
    the rules and behaviors of const can lead to bugs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，const 并非魔法。它并不能使你的代码 100% 安全和受保护。了解和理解与 const 参数和 const 成员函数相关的规则将有助于防止错误。然而，未能理解
    const 的规则和行为可能会导致错误。
- en: 'The biggest problem with const in C++ is a misunderstanding of bitwise const
    versus logical const. This means that the compiler will try to ensure that the
    bits and bytes will not change through that specific variable. This doesn''t mean
    that those bits won''t change through another variable, and it doesn''t mean that
    the data you may care about won''t change. Consider the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中 const 最大的问题是对于位运算 const 和逻辑 const 的误解。这意味着编译器将尝试确保通过该特定变量位和字节不会改变。这并不意味着那些位不会通过另一个变量来改变，这也不意味着你关心的数据不会改变。考虑以下代码：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding example, `i` is not const, but `ci` is a reference to a const
    `int`. Both `i` and `ci` are addressing the same bits. Since `ci` is marked const,
    we cannot change the value through that variable. However, `i` is not const, so
    we are free to modify the value. The fact that we can have a multiple const and
    non-const variables pointing to the same address has consequences for const member
    functions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`i` 不是 const，但 `ci` 是一个指向 const `int` 的引用。`i` 和 `ci` 都在访问相同的位。由于 `ci`
    被标记为 const，我们不能通过该变量更改其值。然而，`i` 不是 const，所以我们有权修改其值。我们可以有多个 const 和非 const 变量指向同一地址，这对
    const 成员函数有影响：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we have given the `Simple` class a pointer to itself.
    This pointer can be used to modify its own data in a const member function. Remember,
    in a `const` member function, the `this` pointer is marked `const`, so data can''t
    be changed through that variable. However, as in this case, the data can still
    be changed through another variable. Even if we didn''t use another variable,
    the use of `const_cast` could also allow us to change the data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们给 `Simple` 类提供了一个指向自身的指针。这个指针可以在 const 成员函数中用来修改其数据。记住，在 const 成员函数中，`this`
    指针被标记为 const，所以不能通过该变量更改数据。然而，正如在这个例子中，数据仍然可以通过另一个变量来更改。即使我们没有使用另一个变量，`const_cast`
    的使用也可能允许我们更改数据：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is very important to understand that you should never write code like this.
    It is undefined behavior to try to modify a const variable with `const_cast` or
    using a non-const pointer to a `const` object. The original data could be placed
    in read-only memory, and code like this could cause the program to crash. It is
    also possible that the compiler could optimize away multiple reads to memory that
    shouldn't change. Therefore, the old value may be used for any future calculations.
    Casting away `const` with `const_cast` is meant for backwards compatibility with
    old C++ libraries. It should *NEVER* be used to modify const values. If there
    is a piece of data that needs to be modified even when the class is `const`, use
    the `mutable` keyword.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解，你永远不应该编写这样的代码。尝试使用 `const_cast` 或非 const 指针来修改 const 变量是未定义的行为。原始数据可能被放置在只读内存中，这样的代码可能会导致程序崩溃。也有可能编译器会优化掉不应更改的内存的多次读取。因此，旧值可能会被用于任何未来的计算。使用
    `const_cast` 移除 `const` 是为了与旧的 C++ 库保持向后兼容。它*永远*不应该用来修改 const 值。如果有一份数据即使在类是 `const`
    的情况下也需要修改，请使用 `mutable` 关键字。
- en: 'Even when avoiding undefined behavior, bitwise constness can get us into trouble
    with const member variables. Consider a simple class that will contain some dynamic
    memory. Since it contains dynamic memory and pointers, we should add a copy constructor,
    destructor, and other things to prevent memory leaks and memory corruption, but
    we will omit those for now since they aren''t important for our discussion on
    const:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使避免未定义的行为，位运算的 const 也会让我们在与 const 成员变量打交道时遇到麻烦。考虑一个将包含一些动态内存的简单类。由于它包含动态内存和指针，我们应该添加拷贝构造函数、析构函数以及其他一些东西来防止内存泄漏和内存损坏，但现在我们将省略这些，因为它们对我们讨论
    const 的内容不重要：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, bitwise const only prevents us from modifying the actual bits
    inside the class. This means we can't point `m_array` to a new location. However,
    it doesn't prevent us from modifying data in the array. There is nothing preventing
    `GetValue` from modifying the array in the const function, because the array data
    isn't part of the class, only the pointer is. Most users aren't concerned about
    where the data is located, but they would expect a const array to remain unchanged.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，位运算const只能阻止我们修改类内部的实际位。这意味着我们不能将`m_array`指向新的位置。然而，它并不能阻止我们修改数组中的数据。在const函数中，`GetValue`修改数组没有任何阻碍，因为数组数据不是类的一部分，只有指针是。大多数用户并不关心数据的位置，但他们期望const数组保持不变。
- en: As you can see, being const, correct is certainly not a guarantee that the data
    will never be modified. If you are diligent about using const, as well as understand
    and avoid the problems that can arise, the benefits are worth it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，保持一致性、正确性并不能保证数据永远不会被修改。如果你勤奋地使用const，并且理解和避免可能出现的错误，那么这些好处是值得的。
- en: Learning how iteration can improve your game and code design
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何通过迭代改进你的游戏和代码设计
- en: While it's nice to imagine it to be this way, games never come fully-formed
    from the mind of a designer/developer. A game is made up of many different ideas
    from many different people. While in the past people could develop games with
    only a single person, now it's much more common for teams to be made up of many
    different disciplines and every game developer on your team has ideas, many of
    them good that can contribute to the final product that gets made. But with that
    in mind you may be wondering how does a game get to the final point with all those
    different changes made? The answer to that is iteration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然想象它是这样很美好，但游戏并不是完全由设计师/开发者的头脑中产生的。一个游戏是由许多不同的人的不同想法组成的。在过去，人们可以用单一个人的力量开发游戏，但现在，由许多不同学科组成的团队更为常见，团队中的每个游戏开发者都有自己的想法，其中许多很好的想法可以为最终制作的产品做出贡献。但考虑到这一点，你可能想知道，在所有这些不同的变化之后，游戏是如何达到最终阶段的？答案是迭代。
- en: The game development cycle
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏开发周期
- en: 'Game development is a process, and different people have different names and/or
    phrases for each of these steps, but most people can agree that, for commercial
    game development, there are three main phases:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发是一个过程，不同的人对这些步骤有不同的名称和/或短语，但大多数人可以同意，对于商业游戏开发，有三个主要阶段：
- en: Pre-Production
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前期制作
- en: Production
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作阶段
- en: Post-Production
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后期制作
- en: Each of these states has their own steps within them as well. Due to page constraints,
    I'm unable to write about the entire process, but we will be focusing on the Production
    aspect of development, since that's where the most relevant content will be for
    our readers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态中的每一个都有它们自己的步骤。由于页面限制，我无法详细描述整个过程，但我们将重点关注开发的制作方面，因为这对我们的读者来说是最相关的内容。
- en: If you are interested in learning more about the different aspects of the game
    development process, check out [https://en.wikipedia.org/wiki/Video_game_development#Development_process](https://en.wikipedia.org/wiki/Video_game_development#Development_process).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于游戏开发过程的不同方面，请查看[https://en.wikipedia.org/wiki/Video_game_development#Development_process](https://en.wikipedia.org/wiki/Video_game_development#Development_process)。
- en: During game development, you'll see a lot of companies use an agile development
    process, which is based on iterative prototyping, using feedback and refinement
    of the game's iterations while gradually increasing the game's feature set. A
    lot of companies enjoy this method as there is always a version of the game playable
    every couple of weeks, and you can make adjustments as the project is being worked
    on. If you have heard of Scrum, it is a popular method of agile software development,
    and one that I use with my students as well as what I used in the game industry.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发过程中，你会看到很多公司使用敏捷开发流程，这种流程基于迭代原型设计，通过使用反馈和游戏迭代的精炼，逐渐增加游戏的功能集。许多公司都喜欢这种方法，因为每隔几周就可以玩到游戏的一个版本，并且可以在项目进行中做出调整。如果你听说过Scrum，它是一种流行的敏捷软件开发方法，也是我在我的学生和游戏行业中使用的方法。
- en: Production phase
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作阶段
- en: 'Upon entering the production phase, we have come up with our base idea for
    our project and have created our proposal and game design document. Now that we
    have this information, we can start doing the following three steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 进入生产阶段后，我们已经为我们的项目提出了基本想法，并创建了我们的提案和游戏设计文档。现在我们有了这些信息，我们可以开始以下三个步骤：
- en: Prototyping
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型制作
- en: Playtesting
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Iterating
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代
- en: Each of these steps serves a valuable process and will be completed in this
    order. We will be repeating these steps repeatedly until release, so it's a good
    idea to have an understanding of them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都服务于一个有价值的过程，并且将按照这个顺序完成。我们将反复重复这些步骤，直到发布，因此了解它们是个好主意。
- en: Prototyping
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型制作
- en: Prototyping is when you make the simplest version of your ideas in a quick manner
    to prove if your concept works well or not. For some people, they will do this
    via index cards, paper, chits, and boards, which is called a paper prototype.
    This can be quite useful, as you don't have to think about the code side of things
    to begin with, and instead it allows you to experience the core of the game without
    having all the nice art and polish. A game that is fun to play with bad graphics
    will only be improved when you add to it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 原型制作就是以快速的方式制作你想法的最简单版本，以证明你的概念是否运作良好。对于一些人来说，他们会通过索引卡、纸张、筹码和板子来完成这个任务，这被称为纸质原型。这可以非常实用，因为你一开始不必考虑代码方面的事情，而是让你能够体验游戏的核心，而不需要所有那些精美的艺术和打磨。一个图形不好的游戏，只有当你添加内容时才会变得有趣。
- en: 'Of course, assuming you have purchased this book, you are probably already
    a developer, but it''s still a good idea to think of it as an option. *Jesse Schell*
    wrote about paper prototypes in his book *The Art of Game Design: A Book of Lenses*,
    where he explained how you could create a paper prototype of the game Tetris.
    To do so, you could cut out cardboard pieces and then put them into a pile and
    pick them out randomly, and then slide them down the board, which would be a piece
    of paper. Once you completed a line, you would grab an X-acto knife and then cut
    the pieces. While it doesn''t give you the same experience entirely, it captures
    enough of the experience to see if you are using the right kinds of shapes and
    how fast the pieces should drop. The big advantage would be that you could create
    this prototype in 10 to 15 minutes, while programming it may take a lot longer.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，假设你已经购买了这本书，你很可能已经是一名开发者了，但将其视为一个选项仍然是个好主意。*杰西·谢尔*在他的书《游戏设计艺术：视角之书》中写到了纸质原型，他解释了如何制作《俄罗斯方块》的纸质原型。为此，你可以剪出纸板碎片，然后将它们堆在一起，随机抽取，然后沿着纸板滑动，这将是纸板的一部分。一旦完成了一行，你就可以拿起一把X-Acto刀，然后剪下碎片。虽然这不能给你完全相同的感觉，但它足以让你看到你是否使用了正确的形状，以及碎片应该以多快的速度落下。最大的优势是，你可以在10到15分钟内创建这个原型，而编程可能需要更长的时间。
- en: It's a lot easier to justify 30 minutes of work rather than a day for something
    that doesn't work out. This can be done with 3D games as well, such as First Person
    Shooters, by creating maps in a similar way to how you create combat encounters
    in a pen and paper role playing game such as Wizards of the Coast's *Dungeons
    and Dragons* (which is a great thing to learn how to play as a designer, as you
    learn about telling a story and developing interesting encounters).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些没有成功的事情，用30分钟来证明比用一整天更有说服力。这同样适用于3D游戏，比如第一人称射击游戏，通过创建地图的方式与你在纸上和笔的角色扮演游戏（如海岸巫师的《龙与地下城》）中创建战斗遭遇战的方式相似（作为一个设计师学习如何玩是一个很好的事情，因为你可以了解如何讲述故事和开发有趣的遭遇战）。
- en: A prototype's job is to prove if your game works and, specifically, how it works.
    Don't invest in only one idea specifically, but rather create a number of small
    prototypes that are quick to make, without worrying if it is polished or you've
    made it the best possible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的任务是证明你的游戏是否运作，以及它具体是如何运作的。不要只投资于一个特定的想法，而是创建多个小型原型，快速制作，不必担心它是否完美或是否是你能做得最好的。
- en: For some more information on building a prototype and an example of a prototype
    that was created in seven days about *Tower of Goo*, which was the prototype for
    their indie hit *World of Goo*, check out [http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1](http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构建原型和七天内创建的原型示例，例如关于*Goo塔*的原型，它是独立游戏《Goo世界》的原型，你可以查看[http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1](http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1)了解更多信息。
- en: One of the most vital skills as a game developer is being able to create rapid
    prototypes, to see how it works, and then test it. We call this process of testing
    out a game idea playtesting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，最重要的技能之一是能够快速创建原型，看看它如何运作，然后对其进行测试。我们称这个过程为游戏想法的测试。
- en: Playtesting
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Once we have a prototype, we can then begin the playtesting process. Playtest
    as soon as possible in your development, and do it often. As soon as you have
    something playable, get people in front of it. First play the game yourself and
    see how you feel about it. Then invite some friends over to your house and have
    them play it as well.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个原型，我们就可以开始游戏测试过程。在开发过程中尽快进行游戏测试，并且经常进行。一旦你有了一个可玩的东西，就让人来试玩。首先自己玩玩游戏，看看自己的感受如何。然后邀请一些朋友到你家里来，也让他们试玩。
- en: Oftentimes, I find my students have difficulty at first actually doing playtests
    and may be hesitant to show people their projects as it's not *ready* yet or because
    they won't get it. Or they know that their project isn't finished so they think
    they know what they should be working on already, so there's no need to do playtesting.
    I find this usually comes from them being shy, and one of the first major obstacles
    you'll need to overcome as a developer is being able to show your ideas to the
    world.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 经常发现我的学生在最初进行游戏测试时会有困难，他们可能因为项目尚未*准备好*或担心别人无法理解而犹豫是否展示他们的项目。或者他们知道项目尚未完成，所以认为自己已经知道应该做什么，因此没有必要进行游戏测试。我发现这通常是因为他们害羞，而作为开发者，你需要克服的第一个主要障碍就是能够向世界展示你的想法。
- en: If the play testers of your game aren't your close friends and/or family, it
    is likely that people will say negative things about the game. This is a good
    thing. They will also mention many things that you already know your game doesn't
    have yet or that you don't have the budget for. This isn't a time for you to defend
    any points, or explain why things are the way they are, but instead a time for
    you to accept the points and note them, as you can take them into consideration
    in the future.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏测试者不是你的亲密朋友和家人，那么很可能会有人对游戏提出负面评价。这是好事。他们还会提到许多你已经知道你的游戏还没有或没有预算去做的事情。这不是你为自己辩护或解释事情为什么是这样的时间，而是一个接受这些观点并记录下来，以便你可以在未来考虑它们的时间。
- en: As a game developer, one thing that's important to note is that you are one
    of the worst judges of your games, especially when just starting out. A lot of
    times I see starting developers trying to justify the problems in their games,
    stating that it is their vision and people don't get it because it's not in a
    final game. It's a very important skill of a game developer to be able to get
    feedback, take criticism, and evaluate if things are worth changing or not.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，有一点需要注意，你可能是自己游戏最差的评判者，尤其是在刚开始的时候。很多时候我看到初出茅庐的开发者试图为自己的游戏中的问题辩解，声称那是他们的愿景，人们不理解因为它还没有进入最终游戏。作为游戏开发者，能够获取反馈、接受批评并评估是否值得改变是非常重要的一项技能。
- en: Conducting a playtest
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行游戏测试
- en: Now that we know how valuable it is to do a playtest, you may wonder how to
    go about doing one. First, I do want to note that it is vitally important that
    you are in the room while your project is being playtested. While they are playing
    the game, you can see not only what someone thinks, but also how they react to
    things as well as what they do with your game. This is the time where you find
    out what works well and what doesn't. If for some reason, you are unable to be
    there in person, have them record themselves playing, both on the PC and from
    the webcam if possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道进行游戏测试是多么有价值，你可能想知道如何进行一次游戏测试。首先，我确实想强调，你在你的项目进行游戏测试时在场至关重要。当他们玩游戏时，你可以看到不仅有人认为什么，还可以看到他们对事物的反应以及他们如何使用你的游戏。这是你发现什么做得好，什么做得不好的时候。如果由于某种原因，你无法亲自到场，让他们记录下自己玩游戏的过程，如果可能的话，包括在PC上和通过摄像头。
- en: When someone comes to a computer to playtest your game, you may be tempted to
    tell them things about your project, such as the controls and the story, and the
    mechanics, and anything else, but you should resist these urges. See what the
    player does without any prompting to begin with. This will give you an idea of
    what players will want to do naturally given the environment that you created
    and what needs to be explained more. Once they play for a while and you've gotten
    the information you need on that end, then you can tell them some things.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人来电脑上测试你的游戏时，你可能会想告诉他们一些关于你的项目的事情，比如控制、故事、机制，以及其他任何东西，但你应该抵制这些冲动。首先看看玩家在没有提示的情况下会做什么。这将给你一个想法，即玩家在所创造的环境中会自然想要做什么，以及需要解释得更清楚的地方。一旦他们玩了一段时间，并且你已经从那方面获得了所需的信息，然后你可以告诉他们一些事情。
- en: When playtesting, it's a good idea to get as much information from the player
    as you can. When they finish, ask them what they liked, what they disliked, if
    they found anything confusing, where they got stuck, and what was the most interesting
    thing to them. Do note that what a player says and what they actually do are two
    different things, so it's important that you are there and watching them. Getting
    your game played and seeing what those players do is where you will start to see
    the cracks in your design's form, and seeing what people do will show how they
    experience the things you have created. While doing this testing, I've seen a
    lot of people do the exact opposite of what I expected and not understand something
    that I thought was quite simple. The player isn't wrong in this regard though,
    I was. The player can only do what they know from prior playing or from what is
    taught in the game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行游戏测试时，尽可能从玩家那里获取尽可能多的信息是个好主意。当他们完成游戏后，询问他们喜欢什么，不喜欢什么，是否发现什么令人困惑的地方，他们在哪里卡住了，以及对他们来说最有趣的是什么。请注意，玩家说的话和他们实际做的事情是两回事，所以你必须在场并观察他们。让你的游戏被玩，并观察那些玩家的行为，这是你开始看到设计缺陷的地方，而观察人们的行为将展示他们如何体验你所创造的事物。在进行这项测试时，我看到很多人做了我预期相反的事情，并且没有理解我认为相当简单的东西。然而，在这个问题上，玩家并没有错，是我错了。玩家只能做他们从之前的游戏或游戏中的教学所知道的事情。
- en: All of the information that you get during a playtest is important. Not just
    what they say, but also what they don't say. Once they finish playing, give them
    a survey to fill out. I find using Google Sheets does a good job at storing this
    information and isn't too difficult to set up, and you have hard data from which
    you can make decisions without having to remember what people say. Plus, it's
    a lot easier for people to select a number from 1-10 for how they enjoyed different
    aspects of the game than to ask their thoughts for everything and doesn't require
    them to write paragraphs of info (unless they want to in a comments section at
    the end).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏测试期间，你获得的所有信息都很重要。不仅包括他们所说的内容，还包括他们没有说的内容。一旦他们完成游戏，就给他们一份调查问卷填写。我发现使用Google
    Sheets来存储这些信息效果很好，而且设置起来并不困难，你还可以从这些硬数据中做出决策，而不必记住人们说了什么。此外，人们从1到10选择他们对游戏不同方面的喜爱程度，比要求他们写出对一切的看法要容易得多，而且不需要他们写段落信息（除非他们想在最后的评论部分这样做）。
- en: 'In case you''d like to see an example playtesting form, while this form is
    for board games, I feel it does a good job of making it easy for play testers
    to give information that can be useful: [https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/](https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看一个示例测试表单，虽然这个表单是为桌面游戏设计的，但我认为它很好地简化了测试者提供有用信息的流程：[https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/](https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/).
- en: 'If you''re looking for some ideas of questions to ask, *Wesley Rockholz* wrote
    some examples of questions that may be useful for you to use: [http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php](http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找一些可以提出的问题的想法，*韦斯利·罗克霍兹*提供了一些可能对你有用的提问示例：[http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php](http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php).
- en: In addition, the order in which players give their feedback is also important
    as it communicates how important different things are to them. You may find that
    what was intended to be the main mechanic isn't as engaging and/or fun as something
    else. That is valuable feedback, and you may decide to focus on that secondary
    mechanic instead for the title, as I've seen happen repeatedly on projects. It's
    better to do this as early as possible so you will waste as little of your time
    as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，玩家提供反馈的顺序也很重要，因为它传达了不同事物对他们的重要性。你可能会发现原本打算作为主要机制的东西并不像其他东西那样吸引人/有趣。这是宝贵的反馈，你可能会决定专注于那个次要机制，就像我在多个项目中看到的那样。尽早这样做会更好，这样你就可以尽可能少地浪费时间。
- en: Iteration
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: At this point, we've playtested our project and have gotten our player's feedback,
    and, if we have set it up, gotten data and analytics from which we can build upon.
    Now we need to take this information into consideration, make some changes to
    our current prototype, and then bring it back to be play tested again. This is
    what's known as the iteration stage of development.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经进行了项目测试并收集了玩家的反馈，如果已经设置好了，我们还从数据和分析中获得了可以继续发展的信息。现在我们需要考虑这些信息，对我们的当前原型进行一些修改，然后再次进行测试。这就是开发中的迭代阶段。
- en: In this stage, you'll need to take this feedback and then decide how to incorporate
    it into your design. You'll need to decide what should be changed as well as what
    shouldn't. While doing so, keep in mind the scope of the project, realistically
    evaluating how long it will take to make the changes, and be willing to cut features,
    even those that you love, to have the best project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你需要考虑这个反馈并决定如何将其融入你的设计中。你需要决定应该改变什么，以及不应该改变什么。在这样做的时候，要记住项目的范围，现实地评估做出这些改变需要多长时间，并且愿意砍掉一些功能，即使是你喜欢的，以获得最好的项目。
- en: After making these decisions again, we will once again create a new prototype,
    which you will then playtest again. Then iterate again. Then build another prototype,
    where you will continue to test, removing prototypes that don't work and features
    that don't work well for the project. You'll also try adding new features using
    feedback and remove previous features that would no longer fit the game in its
    current state. You will keep doing this cycle repeatedly until you reach your
    final release!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次做出这些决定后，我们将再次创建一个新的原型，然后你将再次进行测试。然后再次迭代。然后构建另一个原型，在那里你将继续测试，移除那些不起作用的原型和项目效果不佳的功能。你还将尝试使用反馈添加新功能，并移除那些不再适合当前游戏状态的功能。你将不断重复这个周期，直到达到最终的发布版本！
- en: If you're waiting for your game to be *perfect* before releasing it, you'll
    never release it. Games are never finished, they're only abandoned. If the project
    is at a point where it is good enough, you should ship, because it's only when
    you ship a project that you can finally say you've developed a title.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待你的游戏变得*完美*后再发布，你永远不会发布它。游戏永远不会完成，它们只是被放弃了。如果项目已经足够好，你应该发布，因为只有当你发布一个项目时，你才能最终说你已经开发了一个游戏。
- en: 'If you''d like to see an example of this process and how it can benefit a title,
    check out: [http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php](http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看这个过程的例子以及它如何有助于一个标题，请查看：[http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php](http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php)。
- en: Meeting milestones
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 达成里程碑
- en: 'When working on a commercial game project, especially when you have a publisher,
    you often times will have a schedule to keep and milestones to meet. Milestones
    are ways for everyone to know if the game is on track or not, because certain
    things need to be accomplished by them. Not making a milestone can often be a
    horrible thing, because your publisher usually will only pay your team if the
    milestone has everything in it that was agreed upon. There''s no standard milestone
    schedule, as every company is different, but some of the most common ones are
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在进行商业游戏项目时，尤其是当你有发行商时，你通常会有一个需要遵守的日程表和需要达到的里程碑。里程碑是让每个人都知道游戏是否按计划进行的一种方式，因为某些事情需要在它们完成之前完成。未能达到里程碑通常是一件糟糕的事情，因为你的发行商通常只有在里程碑中包含所有商定的内容时才会支付你的团队。没有标准的里程碑时间表，因为每家公司都不同，但其中一些最常见的如下：
- en: '**First-playable**: This is the first version of the game that can be played.
    Has the main mechanic of the game in and can demonstrate how it works.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**First-playable**：这是可以玩的游戏的第一个版本。包含了游戏的主要机制，可以展示它是如何工作的。'
- en: '**Alpha**: When all the features of your game are in, known as being feature
    complete. Features can change slightly, and make revisions based on feedback and
    testing, but at this point, unimplemented things may be dropped to finish the
    title on time.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha**：当你的游戏的所有功能都齐备时，称为功能完整。功能可以略有变化，并根据反馈和测试进行修订，但在这个阶段，未实现的功能可能会被删除，以确保按时完成标题。'
- en: '**Beta**: The game is complete, with all assets and features completed and
    finished. At this point you are only doing bug testing and fixes for potential
    problems that would prevent your game from being shipped.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta**：游戏已经完成，所有资源和功能都已完善和完成。此时你只是在进行错误测试和修复可能阻止游戏发布的潜在问题。'
- en: '**Gold**: This is the final version of the game, which you''ll either be releasing,
    or sending to your publisher to create copies on disks, cartridges, or whatever
    your device uses.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gold**：这是游戏的最终版本，你将要么发布它，要么将其发送给发行商，以便在磁盘、卡带或你的设备使用的任何介质上创建副本。'
- en: Do note that every company is different and these milestones may mean different
    things to different people, so be sure to clarify before diving into development.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每家公司都不同，这些里程碑对不同的人可能意味着不同的事情，所以在深入开发之前一定要明确。
- en: Learning when to use scripting in a game
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习何时在游戏中使用脚本
- en: Scripting languages are something that can be quite beneficial to developers
    when working on a team with multiple disciplines in it. But before we dive into
    what they are and how they work, and the pros and cons of using a scripting language,
    it's best to get a bit of a history lesson in terms of how code executes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言是当你在具有多个学科的团队中工作时，对开发者非常有帮助的东西。但在我们深入探讨它们是什么以及它们是如何工作之前，以及使用脚本语言的优缺点之前，最好先了解一下代码执行的历史。
- en: Introduction to assembly
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编语言简介
- en: Underneath the hood, all the code that we have written over the course of this
    book is ones and zeroes indicating what switches should be marked as on and off
    by our computer's processor. Low-level programming languages such as machine language
    use these switches to execute commands. This was the only way to program to begin
    with, but we have developed more readable languages for us to work with instead.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们在本书的整个过程中编写的所有代码都是一串零和一，表示我们的计算机处理器应该将哪些开关标记为开启和关闭。低级编程语言，如机器语言，使用这些开关来执行命令。这最初是编程的唯一方式，但我们已经开发出更易于阅读的语言来供我们使用。
- en: 'Starting with assembly languages, low-level languages have a very strong connection
    between the language''s instructions and the machine code''s instructions. While
    more readable than a sequence of `0`s and `1`s, it was still quite difficult to
    write code. For example, here is some assembly code used to add two numbers in
    Assembly Language:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从汇编语言开始，低级语言与语言的指令和机器代码的指令之间有着非常紧密的联系。虽然比一串`0`s和`1`s更易读，但编写代码仍然相当困难。例如，以下是一些用于在汇编语言中添加两个数字的汇编代码：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each computer architecture has its own assembly language, so writing code in
    low-level languages has the disadvantage of not being portable as they are machine
    dependent. Back in the day, people would have to learn many different languages
    in order to port your program to another processor. Program structures became
    more complicated, as the demands of functionality increased over time, making
    it quite difficult for programmers to implement efficient programs that were robust
    enough.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每种计算机架构都有自己的汇编语言，因此使用低级语言编写代码的缺点是不具有可移植性，因为它们依赖于机器。在过去的岁月里，人们必须学习许多不同的语言，以便将你的程序移植到另一个处理器。随着功能需求随着时间的推移而增加，程序结构变得更加复杂，这使得程序员很难实现既高效又足够健壮的程序。
- en: Moving to higher-level programming languages
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向高级编程语言
- en: As programmers, we are inherently lazy, so we seek ways to make our job easier
    or rather to find the best use of our time. With that in mind, we have developed
    other higher level languages, which are even easier to read. By higher level,
    we mean closer to the way that humans think or closer to the problem we are trying
    to solve. By abstracting the machine details from our code, we simplify programming
    tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们天生懒惰，因此我们寻求使我们的工作变得更简单，或者更确切地说，找到我们时间的最佳利用方式。考虑到这一点，我们已经开发了其他高级语言，这些语言甚至更容易阅读。当我们说高级时，我们的意思是更接近人类思考的方式，或者更接近我们试图解决的问题。通过从我们的代码中抽象出机器细节，我们简化了编程任务。
- en: Introducing the compiler
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍编译器
- en: 'Once we have finished our code, we use a compiler to translate that high-level
    code into assembly, which in turn will get turned into machine language that our
    computer can execute. Afterwards, it will translate that program into an executable
    file that the user can run. Functionally, it looks something like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了代码，我们就使用编译器将高级代码翻译成汇编语言，然后汇编语言将被转换成计算机可以执行的机器语言。之后，它将程序转换成用户可以运行的可执行文件。从功能上看，它看起来像这样：
- en: '![](img/00095.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00095.jpeg)'
- en: This has several advantages, as it provides abstraction from the hardware details.
    For example, we don't need to work directly with registers, memory, addresses,
    and so on anymore. It also makes our code portable in that we can use the same
    program and have it translated by different assemblers for the different machines
    that use it. This was one of the reasons C took off and became so popular, because
    it allowed people to write code once and then have it work everywhere. You may
    notice that Unity has taken the same thought process to game development, and
    that's one of the reasons that I feel they've been so successful as of this writing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个优点，因为它提供了对硬件细节的抽象。例如，我们不再需要直接与寄存器、内存、地址等打交道。这也使得我们的代码具有可移植性，我们可以使用相同的程序，并由不同的汇编器为使用它的不同机器进行翻译。这正是C语言之所以兴起并变得如此受欢迎的原因之一，因为它允许人们编写一次代码，然后它可以在任何地方运行。你可能已经注意到Unity在游戏开发中也采用了同样的思考方式，这也是我认为他们之所以成功的原因之一。
- en: This is a much more efficient use of time than writing assembly language code
    as it allows us to create more complex programs and machines, and modern compilers
    such as Microsoft's produce some highly efficient assembly code in most circumstances.
    This is what we have been using over the course of this book.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与编写汇编语言代码相比，这是一种更有效率的利用时间的方式，因为它允许我们创建更复杂的项目和机器，并且在大多数情况下，现代编译器如微软的编译器都能生成一些非常高效的汇编代码。这正是我们在本书中一直在使用的方法。
- en: Writing code in assembly can still have its benefits though. For instance, after
    you've written your game in a higher-level language, you can start profiling it
    and seeing what aspects of the game are the bottlenecks, and then determine if
    rewriting it in assembly will give you a speed boost. The point of using a lower-level
    language is the fact that you can gain some substantial speed advantages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在汇编语言中编写代码仍然有其好处。例如，在你用高级语言编写完你的游戏后，你可以开始分析它，看看游戏的哪些方面是瓶颈，然后确定是否将其重写为汇编语言会给你带来速度提升。使用低级语言的目的在于你可以获得一些实质性的速度优势。
- en: 'For a real-life example as to how assembly was used to optimize a game engine,
    check out the following article from Intel: [https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/](https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个真实生活中的例子，说明如何使用汇编语言来优化游戏引擎，请查看以下来自英特尔的文章：[https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/](https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/).
- en: One of the issues with writing code that needs to be compiled before running
    is the fact that as projects increase in size, so do compile times. Recompiling
    a full game can take minutes to hours depending on the size of the project, and
    while that's going on, you are unable to work on your project, or else you'd need
    to recompile again. This is one of the reasons why scripting languages can be
    useful.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前需要编译的代码编写中存在的问题之一是，随着项目规模的增加，编译时间也会增加。重新编译整个游戏可能需要几分钟到几小时，这期间你无法工作在项目上，否则你可能需要再次重新编译。这就是脚本语言可能有用的一部分原因。
- en: Introduction to scripting languages
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本语言的介绍
- en: A scripting language is a programming language that allows scripts to be written
    for it. A script is a program that can be executed without being compiled in one
    of a few different ways. Scripting languages are also sometimes referred to as
    very high-level programming languages, as they operate at a high level of abstraction,
    being very fast to learn how to write in.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言是一种允许为其编写脚本的编程语言。脚本是一种可以在不进行编译的情况下以几种不同方式执行的程序。脚本语言有时也被称为非常高级的编程语言，因为它们在高级别抽象，学习如何编写它们非常快。
- en: Scripting languages also have the advantage of taking care of a lot of things
    that programmers would need to take care of, such as garbage collection, memory
    management, and pointers, which often confuse non-developers. Even a visual editor
    such as Unreal 4's blueprints is still a scripting language, as it accomplishes
    the same thing as a written one does.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言还有优点，可以处理程序员需要处理的大量事情，例如垃圾回收、内存管理和指针，这些通常会让非开发者感到困惑。即使是像Unreal 4的蓝图这样的视觉编辑器，也仍然是脚本语言，因为它完成了与书面语言相同的事情。
- en: Most games use scripting languages in some form, but other games may use it
    a lot more, such as how GameMaker uses **Game Maker Language** (**GML**) for their
    logic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏以某种形式使用脚本语言，但有些游戏可能使用得更多，例如GameMaker使用**Game Maker Language**（**GML**）进行逻辑处理。
- en: Using interpreters
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用解释器
- en: 'To use a scripting language, we need to be able to execute new code on the
    fly. However, unlike a compiler, there''s also another way to convert code into
    something that can be understood by a machine that is called an interpreter. Interpreters
    do not produce a program themselves, and rather stay around for the execution
    of a program. This program will either:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用脚本语言，我们需要能够即时执行新代码。然而，与编译器不同，还有一种将代码转换为机器可以理解的方式，这被称为解释器。解释器不会生成程序，而是存在于程序的执行过程中。这个程序将执行以下操作之一：
- en: Execute the source code directly
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接执行源代码
- en: Translate the source code into some other efficient intermediate representation
    (code) and then immediately execute it
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码翻译成某种高效的中间表示（代码），然后立即执行它
- en: Explicitly execute stored precompiled code made by a compiler that is part of
    the interpreter system
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确执行由解释器系统中的编译器生成的预编译代码
- en: The interpreter translates one line at a time, as opposed to the compiler doing
    it all at once.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器逐行翻译，而编译器则一次性完成所有工作。
- en: 'Visually, it looks a bit like the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，它看起来有点像以下这样：
- en: '![](img/00096.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00096.jpeg)'
- en: As you can see here, the **Interpreter** takes in the **Source Code** and any
    **Input** that has been received, and will then **Output** what is expected of
    it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，**解释器**接收**源代码**和任何已接收的**输入**，然后输出其期望的结果。
- en: Just in time compilation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时编译
- en: There is yet another way to run code, using what's called a **just in time compiler**,
    or **JIT** for short. A JIT caches the instructions, that have been previously
    interpreted to machine code, and reuses those native machine code instructions
    thus saving time and resources by not having to re-interpret statements that have
    already been interpreted.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码还有另一种方式，使用所谓的**即时编译器**，或简称**JIT**。JIT缓存了之前已解释为机器代码的指令，并重用这些原生机器代码指令，从而通过不必重新解释已解释的语句来节省时间和资源。
- en: 'Visually, it looks similar to this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，它看起来类似这样：
- en: '![](img/00097.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00097.jpeg)'
- en: Now, Unity uses a JIT and AOT compiler to convert code into machine code, which
    can then be read by the machine. The first time that a function is called, the
    game will convert that code into machine language and then the next time it is
    called, it will go directly to the translated code, so you only need to do conversions
    to things that are happening. Due to this happening at runtime, this may cause
    your project to lag when using a lot of new things.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Unity使用即时编译（JIT）和预编译（AOT）编译器将代码转换为机器码，这样机器就可以读取。当函数第一次被调用时，游戏会将该代码转换为机器语言，然后下次调用时，它会直接跳转到翻译后的代码，因此你只需要对正在发生的事情进行转换。由于这是在运行时发生的，这可能会导致你在使用大量新功能时项目出现卡顿。
- en: A great talk about how scripting works inside of the Unity game engine can be
    found here: [https://www.youtube.com/watch?v=WE3PWHLGsX4](https://www.youtube.com/watch?v=WE3PWHLGsX4).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Unity游戏引擎内部脚本工作原理的精彩演讲可以在这里找到：[https://www.youtube.com/watch?v=WE3PWHLGsX4](https://www.youtube.com/watch?v=WE3PWHLGsX4)。
- en: Why use a scripting language?
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用脚本语言？
- en: C++ is often overkill when it comes to building things for your game, such as
    tools, or for high-level game tasks that could be handled by your technical designers.
    It has some definite advantages for ease of development. Specifically, that you
    don't have to worry about a lot of the low-level things, as the language takes
    care of it for you; there's also fewer errors by the programmer due to the limited
    options available. There's less of a technical programming knowledge required,
    and it can be customized to fit your game's needs. This also makes the game more
    data driven instead of hardcoding things into the game engine, and allows you
    to patch the game without having to send over the entire project.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为你的游戏构建工具或处理由技术设计师处理的高级游戏任务时，C++通常过于强大。它确实有一些开发上的优势。具体来说，你不必担心很多底层的事情，因为语言会为你处理这些；程序员由于选项有限，错误也更少。需要的编程知识更少，并且可以根据游戏需求进行定制。这也使得游戏更注重数据驱动，而不是将东西硬编码到游戏引擎中，并允许你在不发送整个项目的情况下修补游戏。
- en: Often in game development, game logic and configurations can be found in script
    files. This way, it's very easy for scripts to be modified and adjusted by people
    on the team that aren't programmers (such as designers), allowing them to playtest
    the game and tweak the gameplay without having to recompile the game.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，游戏逻辑和配置通常可以在脚本文件中找到。这样，非程序员（如设计师）很容易修改和调整脚本，允许他们进行游戏测试和调整游戏玩法，而无需重新编译游戏。
- en: Many games also have a console window, which uses a scripting language to do
    things like this even at runtime. For instance, Unreal Engine has a console window
    open by default when you press Tab and in Source engine, pressing the ~ button
    at the pause menu will open one up.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏也都有一个控制台窗口，它使用脚本语言在运行时执行此类操作。例如，当你按下Tab键时，Unreal Engine会默认打开控制台窗口，而在Source引擎中，在暂停菜单中按下~按钮也会打开一个控制台窗口。
- en: Scripting languages are also often used in areas that have level design as well,
    such as having triggers for when you enter certain areas, or for controlling cinematics.
    It also allows you to let players of your game mod the game as well, which could
    potentially increase the lifespan of your game and help foster your game's community.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言也常用于具有关卡设计的领域，例如，当进入某些区域时触发器，或控制电影场景。它还允许你的游戏玩家对游戏进行修改，这可能会增加游戏的生命周期并有助于培养你的游戏社区。
- en: When to use C++
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用C++
- en: C++ is a great language to be using, as performance is a crucial first step.
    This used to be all aspects of game engines, but now is used primarily with graphics
    and AI code. Scripting languages also have the problem of being slower than C++,
    sometimes even 10x slower than what it would be otherwise. Due to scripting languages
    having memory management taken care of for them automatically, there could be
    times when commands are interrupted or take a while to complete garbage collection,
    causing lag and other problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一个很好的语言选择，因为性能是一个关键的第一步。这曾经是游戏引擎的所有方面，但现在主要用于图形和AI代码。脚本语言也存在比C++慢的问题，有时甚至比其他情况慢10倍。由于脚本语言自动处理内存管理，有时命令可能会中断或需要一段时间才能完成垃圾回收，导致卡顿和其他问题。
- en: C++ also has the advantage of much better IDEs and Debuggers, making it a lot
    easier for you to find mistakes and fix them when they do occur.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: C++也有更好的IDE和调试器的优势，这使得你在出错时更容易找到并修复错误。
- en: There's also the possibility that you are working with a legacy code base. Most
    game companies aren't starting with a fresh slate. It can also be useful to make
    use of the middleware libraries that C++ has, such as FMOD and AntTweakBar.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种可能性，就是你正在处理一个遗留代码库。大多数游戏公司并不是从一张白纸开始。利用C++的中间件库，如FMOD和AntTweakBar，也可能很有用。
- en: Compiled versus scripting
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译与脚本
- en: For some game engines, the game engine itself is programmed in C++, but the
    game logic is entirely done in a scripting language, like most development for
    Unity, for example. This allows you to iterate on gameplay much faster, and allows
    technical designers and artists to modify behaviors without having to bother a
    programmer. Also, depending on the language, it can allow people to use a more
    appropriate language for the problem's domain (for example, AI may not be the
    easiest thing to implement in C++).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些游戏引擎，游戏引擎本身是用C++编写的，但游戏逻辑完全是使用脚本语言完成的，例如Unity的大多数开发。这允许你更快地迭代游戏玩法，并允许技术设计师和艺术家在不打扰程序员的情况下修改行为。此外，根据语言的不同，它还可以允许人们使用更适合问题域的语言（例如，AI可能不是在C++中实现的最容易的事情）。
- en: Different companies handle working with languages differently. When I was working
    at a AAA (pronounced triple-A) studio, we would have designers prototype ideas
    for mechanics and get it working in the best possible way making use of scripting
    languages. Upon approval from the leads as something to add to the project, if
    the script had performance issues, programmers would use the scripting language
    code as a base and then create a super-efficient version using C++ that would
    work in all levels. However, when I was working on an indie title, all of the
    code for the project was written in a scripting language (C#), since we didn't
    have access to the engine's source code (Unity). Also, if you are wanting to target
    devices that are limited in memory and processing power (such as the Nintendo
    3DS), you are likely wanting to care about performance a lot more so it's more
    important to use more optimized code. It's a good idea to be familiar with both
    options and be comfortable working either way.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的公司处理与语言合作的方式不同。当我在一间AAA（发音为三A）工作室工作时，我们会让设计师为机制原型设计想法，并尽可能好地使用脚本语言实现它们。一旦得到负责人的批准，如果脚本存在性能问题，程序员会以脚本语言代码为基础，然后创建一个超级高效的版本，使用C++实现，使其在所有级别上都能工作。然而，当我为一个独立游戏项目工作时，所有的代码都是用脚本语言（C#）编写的，因为我们没有访问引擎源代码（Unity）。此外，如果你想要针对内存和处理能力有限的设备（如任天堂3DS），你可能会更加关注性能，因此使用更优化的代码就更加重要。熟悉这两种选项并且能够舒适地以任何一种方式工作是个好主意。
- en: If you are interested in using a scripting language for your project, Lua is
    very widely used in the game industry because it's very easy to learn and fairly
    easy to incorporate into your engine. Lua started off as a configuration language.
    This has some nice quirks, in that it's great for creating and configuring things
    - which is what you want to do in a game. It's important to note, though, that
    it's not object-oriented but uses a small amount of memory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对你的项目有兴趣使用脚本语言，Lua在游戏行业中非常广泛使用，因为它非常容易学习，并且相对容易集成到你的引擎中。Lua最初是一个配置语言。这有一些很好的特性，比如它非常适合创建和配置事物——这正是你在游戏中想要做的。不过，需要注意的是，它不是面向对象的，但使用少量的内存。
- en: 'A list of games that use Lua as a scripting language can be found here: [https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games](https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lua作为脚本语言的游戏列表可以在这里找到：[https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games](https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games)。
- en: If you are interested in integrating Lua into your project or would like to
    see how it works, I highly suggest checking out [http://www.lua.org/start.html](http://www.lua.org/start.html).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣将Lua集成到你的项目中或者想看看它是如何工作的，我强烈建议查看[http://www.lua.org/start.html](http://www.lua.org/start.html)。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of best-practice information, which we hope
    will give you a good foundation when building your own projects in the future.
    We touched on why hardcoding values is a bad idea, in addition to making a number
    of other code-quality suggestions, to ensure that your code is easy to understand
    and easy to extend from in the future, when it needs to be.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多最佳实践信息，希望这将为您在将来构建自己的项目时提供一个良好的基础。我们讨论了为什么硬编码值是个坏主意，并提出了许多其他关于代码质量的建议，以确保您的代码易于理解，也易于在将来需要时进行扩展。
- en: We also learned how iteration is useful in game development, talking about the
    traditional game development cycle, with tips and tricks about playtesting and
    how it can be immensely useful when developing your projects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了迭代在游戏开发中的有用性，讨论了传统的游戏开发周期，以及关于游戏测试的技巧和窍门，以及它在开发项目时如何非常有用。
- en: We also looked into low-level and high-level programming languages, learning
    about how scripting languages run inside another program that we have to build
    into our project. They are not compiled but rather interpreted, and are generally
    easier to use and write code for than a compiled language, but come at the cost
    of performance. Depending on how complex your game is, it may be a good idea to
    stick to just C++, but if you are working with designers, it can be quite useful
    to give them the tools to do things on their own.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了低级和高级编程语言，了解了脚本语言是如何在我们必须将其构建到项目中的另一个程序内部运行的。它们不是编译的，而是解释的，通常比编译语言更容易使用和编写代码，但代价是性能。根据您的游戏复杂程度，坚持使用C++可能是个好主意，但如果您与设计师合作，给他们提供自己动手的工具可能非常有用。
- en: With that, we've reached the end of the book. We hope that you found the information
    both interesting and useful. As you go out there and build your own projects,
    make use of the design patterns and best practices that we've talked about over
    the past 12 chapters, and make the best games that you can!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就到达了这本书的结尾。我们希望您觉得这些信息既有趣又实用。当您出去构建自己的项目时，请利用我们在过去12章中讨论的设计模式和最佳实践，制作出最好的游戏！
