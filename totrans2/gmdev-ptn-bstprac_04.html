<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">Artificial Intelligence Using the State Pattern</h1>
            

            
                
<p class="calibre2">In the last chapter, we discussed the Component Object Model. Giving an entity a behavior is now as simple as just creating a new component and having that control the game object.</p>
<p class="calibre2">Whenever someone starts to make a game, they begin by writing gameplay code. That is the fun stuff. Everyone wants to see graphics and physics take effect on screen. Things such as a pause screen, options menu, or even a second level are an afterthought. The same happens for organizing the behaviors of a player. Programmers are excited to make a player jump and make a player dash, but with each new ability a player has, there are combinations that you may want to disallow. For example, the player might not be allowed to dash while jumping, or may only be able to dash every 3 seconds. The State pattern solves these problems.</p>
<p class="calibre2">By coding the Game State Manager first, the problem of switching to a menu or pausing is solved. By coding finite State Machines as a component for the game object, the problem of complex behavior or a player or enemy is solved. By adding multiple State Machines to the same game object, complex behavior can be created with very simple code, as is seen in many games, and is a widely used feature built into the Unreal Engine and given visual editors in Unity using Hutong Games LLC's popular Playmaker extension.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            
                
<p class="calibre2">In this chapter, we will create a simple State Machine to control the player via input, as well as create an enemy State Machine which will detect when the player gets close to it and will follow them when in range. We will also look at the base <kbd class="calibre14">StateMachineComponent</kbd> class in the Mach5 Engine and show that, by writing code for a few states, we can create a more complex behavior quite easily. We will also show that adding more than one State Machine to an object can create multiple behaviors to run at the same time, avoiding duplicated state code.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            
                
<p class="calibre2">This chapter will be split into a number of topics. It will contain a simple step-by-step process from beginning to end. Here is the outline of our tasks:</p>
<ul class="calibre17">
<li class="calibre18">The State pattern explained</li>
<li class="calibre18">Introduction to State Machines</li>
<li class="calibre18">An overview of enumerations</li>
<li class="calibre18">Doing things based on our states</li>
<li class="calibre18">Why if statements could get you fired</li>
<li class="calibre18">Expanding on the State Machine</li>
<li class="calibre18">The State pattern in action--M5StateMachine</li>
<li class="calibre18">The State pattern in action--StageManager</li>
<li class="calibre18">Issues with FSMs</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The State pattern explained</h1>
            

            
                
<p class="calibre2">The State pattern is a way to allow a game object to change its behavior and functionality in response to different stimuli within the game, especially when a variable or a condition within that object changes, as those changes may trigger a change in state. The state of an object is managed by some context (commonly referred to in the game industry as a machine), but the states tell the machine when to change states and thereby functionality. The State pattern contains two parts: the state and the context. The context object holds the current state and can be used by the state class to change what state should be run, whereas the state object holds the actual functionality:</p>
<div><img class="alignnone10" src="img/00033.jpeg"/></div>
<p class="calibre2">In the Mach5 Engine, there is a class that already uses the State pattern (<kbd class="calibre14">M5StateMachine</kbd>) but, before we dive into a completed version, let's actually build one from scratch.</p>
<p class="calibre2">There are multiple ways to implement the State pattern or to get a State-like behavior. We'll go over some of the commonly seen versions and the pros and cons of using them before moving to our final version.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Introduction to State Machines</h1>
            

            
                
<p class="calibre2">We often write code to react to things happening within the game environment based on the expectations of us, as well as our players. For instance, if we are creating a 2D side-scrolling platformer game, when the player presses one of the arrow keys, we're expecting the player's character to move and, whenever we press the spacebar, we expect the sprite to jump into the air. Or perhaps in a 3D game, when our player sees a panel with a large button, they expect to be able to press it.</p>
<p class="calibre2">Tons of things in our ordinary lives act this way as well, reactive to certain stimuli. For instance, when you use your television remote, you expect certain things to happen, or even when swiping or tapping on your mobile phone. Based on the stimuli provided, the <em class="calibre12">state</em> of our object may change. We call something that can be in one of multiple states at a time a State Machine.</p>
<p class="calibre2">Almost every program you write can be considered a State Machine of some sort. The second that you add in an <kbd class="calibre14">if</kbd> statement to your project, you have developed code that can be in at least one of those states. That being said, you don't want to have a bunch of <kbd class="calibre14">switch</kbd> and/or <kbd class="calibre14">if</kbd> statements inside of your code as it can quickly get out of hand and make it difficult to understand exactly what it is that your code is doing.</p>
<p class="calibre2">As programmers, we often want to take our problems and break them down over and over again until they're in their simplest form, so let's see a possible way to do that. In game development, you'll hear references to an <strong class="calibre1">FSM</strong> which stands for <strong class="calibre1">Finite State Machine</strong>. Finite means that there are only a certain number of states and that they are all clearly defined for what they can do and how they will change between states.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">An overview of enumerations</h1>
            

            
                
<p class="calibre2">Let's say we're going to create a simple enemy. This enemy will not do anything by default, but if the player is nearby, it will move toward them. However, if the player gets too far away from them, then they will stop their pursuit. Finally, if the player shoots the enemy, it will die. So, keeping that in mind, we can extract the states that we'll need. They are as follows:</p>
<ul class="calibre17">
<li class="calibre18">Idle</li>
<li class="calibre18">Follow</li>
<li class="calibre18">Death</li>
</ul>
<p class="calibre2">While we are creating our State Machine, we need some way to keep track of what state our objects are going to be in. One may think a way to do this would be to have a <kbd class="calibre14">bool</kbd> (Boolean value of true or false) for each possible state there is and then set them all to <kbd class="calibre14">false</kbd>, except for the state that we're in. This is a very bad idea.</p>
<p class="calibre2">Another thought could be to just have an integer and then set a value for each one that there is. This is also a bad idea, as using numbers in this way is basically the same thing as using magic numbers in our code, since the numbers have no logic to them for people to read. Alternatively, you could have <kbd class="calibre14">#defines</kbd> for each possible value, but that will allow people to put in whatever number they want without any protections at all. Instead, whenever we see a series of things where only one of them is true at a time, we can make use of the programming feature of enumerations, called enums for short.</p>
<p class="calibre2">The basic concept of using enumerations is that you get to create your own custom data types which are restricted to only have a certain list of values. Unlike integers or <kbd class="calibre14">#defines</kbd>, these numbers are expressed using constants and allow us to have all of the advantages of having a value, such as being able to compare values. In our case, an <kbd class="calibre14">enum</kbd> for our states would look something like the following:</p>
<pre class="calibre23">
enum State <br class="title-page-name"/>{ <br class="title-page-name"/>  Idle, <br class="title-page-name"/>  Follow, <br class="title-page-name"/>  Death <br class="title-page-name"/>}; 
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Acting on states</h1>
            

            
                
<p class="calibre2">Now that we have our states defined, let's now make it so that we can actually do something in our code based on what state our object is in. For this first example, I'm going to update the <kbd class="calibre14">ChasePlayerComponent</kbd> class that already exists in the <kbd class="calibre14">EngineTest</kbd> project.</p>
<p class="calibre2">From the Solution Explorer tab on the right-hand side, open up the <kbd class="calibre14">SpaceShooter/Components/ChasePlayerComp</kbd> folder and access the <kbd class="calibre14">ChasePlayerComponent.h</kbd> file. From there, replace the class with the following changes in bold:</p>
<pre class="calibre23">
<strong class="calibre1">enum State</strong><strong class="calibre1">{<br class="title-page-name"/></strong><strong class="calibre1">  Idle,<br class="title-page-name"/></strong><strong class="calibre1">  Follow,<br class="title-page-name"/></strong><strong class="calibre1">  Death<br class="title-page-name"/></strong><strong class="calibre1">};</strong> <br class="title-page-name"/> <br class="title-page-name"/>//!&lt; Simple AI to Chase the Player <br class="title-page-name"/>class ChasePlayerComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ChasePlayerComponent(void); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp; iniFile); <br class="title-page-name"/>  virtual ChasePlayerComponent* Clone(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  float m_speed; <br class="title-page-name"/>  <strong class="calibre1">float m_followDistance; </strong><br class="title-page-name"/><strong class="calibre1">  float m_loseDistance; </strong><br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">  void FollowPlayer(); </strong><br class="title-page-name"/><strong class="calibre1">  float GetDistanceFromPlayer(); </strong><br class="title-page-name"/><strong class="calibre1">  State m_currentState;</strong> <br class="title-page-name"/> <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">The <kbd class="calibre14">FollowPlayer</kbd> and <kbd class="calibre14">GetDistanceFromPlayer</kbd> functions are going to be helper functions for our functionality. We've added our state <kbd class="calibre14">enum</kbd> to store each of the possible states we can be in, and we added the <kbd class="calibre14">m_currentState</kbd> variable to hold the current state we are in. To determine when we should switch states, we have two other values, <kbd class="calibre14">m_followDistance</kbd> and <kbd class="calibre14">m_loseDistance</kbd>, which are the distance in pixels that our player needs to be from the enemy to follow them, and then how far the player needs to get away to escape, respectively.</p>
<p class="calibre2">Now that we have that finished, let's first go ahead and add in the helper functions at the bottom of the <kbd class="calibre14">ChasePlayerComponent.cpp</kbd> file so that we can have the proper functionality, once we update our other functions:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*!   <br class="title-page-name"/>Makes it so the enemy will move in the direction of the player <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>void ChasePlayerComponent::FollowPlayer() <br class="title-page-name"/>{ <br class="title-page-name"/>  std::vector&lt;M5Object*&gt; players; <br class="title-page-name"/>  M5ObjectManager::GetAllObjectsByType(AT_Player, players); <br class="title-page-name"/>  M5Vec2 dir; <br class="title-page-name"/>  M5Vec2::Sub(dir, players[0]-&gt;pos, m_pObj-&gt;pos); <br class="title-page-name"/>  m_pObj-&gt;rotation = std::atan2f(dir.y, dir.x); <br class="title-page-name"/>  dir.Normalize(); <br class="title-page-name"/>  dir *= m_speed; <br class="title-page-name"/>  m_pObj-&gt;vel = dir; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Returns the distance of the object this is attached to the player <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>float ChasePlayerComponent::GetDistanceFromPlayer() <br class="title-page-name"/>{ <br class="title-page-name"/>  std::vector&lt;M5Object*&gt; players; <br class="title-page-name"/>  M5ObjectManager::GetAllObjectsByType(AT_Player, players); <br class="title-page-name"/> <br class="title-page-name"/>  return M5Vec2::Distance(m_pObj-&gt;pos, players[0]-&gt;pos); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">These functions use some basic linear algebra in order to move our object toward the player and to get the distance between two positions.</p>
<p>Diving into the mathematics behind it is out of the scope of this book, but if you're interested in learning more, I highly suggest you check out the following link. The code is written for Cocos2D so it will not be exactly the same as what Mach5 would use, but the concepts are explained very well: <a href="https://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1" target="_blank" class="calibre24">https://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1</a>.</p>
<p class="calibre2">Now that we have that functionality in, we need to update a couple of things. First of all, we will use the constructor to set the initial value of our <kbd class="calibre14">currentState</kbd> variable:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Sets component type and starting values for player <br class="title-page-name"/>*/   <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>ChasePlayerComponent::ChasePlayerComponent(void): <br class="title-page-name"/>  M5Component(CT_ChasePlayerComponent), <br class="title-page-name"/>  m_speed(1) <br class="title-page-name"/>  { <br class="title-page-name"/>    <strong class="calibre1">m_currentState = Idle;</strong> <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Next, we need to tell our object to read in the values of our object through its INI file:</p>
<pre class="calibre23">
void ChasePlayerComponent::FromFile(M5IniFile&amp; iniFile) <br class="title-page-name"/>{ <br class="title-page-name"/>  iniFile.SetToSection("ChasePlayerComponent"); <br class="title-page-name"/>  iniFile.GetValue("speed", m_speed); <br class="title-page-name"/> <strong class="calibre1"> iniFile.GetValue("followDistance", m_followDistance); </strong><br class="title-page-name"/><strong class="calibre1">  iniFile.GetValue("loseDistance", m_loseDistance);</strong> <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2"><kbd class="calibre14">FromFile</kbd> is only called once on the first object that gets created in initialization. In order to make it easy to tweak values without having to recompile the project, Mach 5 reads in information from a file to set variables. We haven't modified the <kbd class="calibre14">.ini</kbd> file yet, but we will once we finish all of these modifications:</p>
<pre class="calibre23">
M5Component* ChasePlayerComponent::Clone(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  ChasePlayerComponent* pNew = new ChasePlayerComponent; <br class="title-page-name"/>  pNew-&gt;m_speed = m_speed; <br class="title-page-name"/>  <strong class="calibre1">pNew-&gt;m_followDistance = m_followDistance;</strong><br class="title-page-name"/><strong class="calibre1">  pNew-&gt;m_loseDistance = m_loseDistance;</strong> <br class="title-page-name"/>  return pNew; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">We then need to go to Windows Explorer and move to the project's <kbd class="calibre14">EngineTest/EngineTest/ArcheTypes</kbd> folder, and then access the <kbd class="calibre14">Raider.ini</kbd> file and add the new properties to the object:</p>
<pre class="calibre23">
posX   = 0 <br class="title-page-name"/>posY   = 0 <br class="title-page-name"/>velX   = 0 <br class="title-page-name"/>velY   = 0 <br class="title-page-name"/>scaleX = 10 <br class="title-page-name"/>scaleY = 10 <br class="title-page-name"/>rot    = 0 <br class="title-page-name"/>rotVel = 0 <br class="title-page-name"/>components = GfxComponent ColliderComponent ChasePlayerComponent <br class="title-page-name"/> <br class="title-page-name"/>[GfxComponent] <br class="title-page-name"/>texture = enemyBlack3.tga <br class="title-page-name"/>drawSpace = world <br class="title-page-name"/> <br class="title-page-name"/>[ColliderComponent] <br class="title-page-name"/>radius = 5 <br class="title-page-name"/>isResizeable = 0 <br class="title-page-name"/> <br class="title-page-name"/>[ChasePlayerComponent] <br class="title-page-name"/>speed = 40 <br class="title-page-name"/><strong class="calibre1">followDistance = 50</strong> <br class="title-page-name"/><strong class="calibre1">loseDistance = 75</strong> 
</pre>
<p class="calibre2">If a text editor doesn't open for you, feel free to use Notepad. In this case, we are adding in two new properties which represent the values we created earlier.</p>
<p class="calibre2">Then, we need to update our stage so it's a little easier for us to do some testing. Back in Windows Explorer, open up the <kbd class="calibre14">EngineTest/EngineTest/Stages</kbd> folder and then open up the <kbd class="calibre14">Level01.ini</kbd> file and set it to the following:</p>
<pre class="calibre23">
ArcheTypes = Player Raider <br class="title-page-name"/> <br class="title-page-name"/>[Player] <br class="title-page-name"/>count = 1 <br class="title-page-name"/>pos = 0 0 <br class="title-page-name"/> <br class="title-page-name"/>[Raider] <br class="title-page-name"/>count = 1 <br class="title-page-name"/>pos = 100 10 
</pre>
<p class="calibre2">With this, our level will just have our player in the center of the world and an enemy Raider positioned at (<kbd class="calibre14">100</kbd>, <kbd class="calibre14">10</kbd>). With all of that accomplished, save the files and dive back into our <kbd class="calibre14">ChasePlayerComponent.cpp</kbd> file and replace the <kbd class="calibre14">Update</kbd> function with the following:</p>
<pre class="calibre23">
void ChasePlayerComponent::Update(float) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Depending on  what state we are in, do different things <br class="title-page-name"/>  switch (m_currentState) <br class="title-page-name"/>  { <br class="title-page-name"/>  case Idle: <br class="title-page-name"/>    // No longer move if we were <br class="title-page-name"/>    m_pObj-&gt;vel = M5Vec2(0, 0); <br class="title-page-name"/> <br class="title-page-name"/>    // If the player gets too close, the enemy notices them <br class="title-page-name"/>    if (GetDistanceFromPlayer() &lt; m_followDistance) <br class="title-page-name"/>    { <br class="title-page-name"/>      // And will begin to give chase <br class="title-page-name"/>      m_currentState = Follow; <br class="title-page-name"/>    } <br class="title-page-name"/>     <br class="title-page-name"/>    return; <br class="title-page-name"/>  case Follow: <br class="title-page-name"/>    // Follow the player <br class="title-page-name"/>    FollowPlayer(); <br class="title-page-name"/> <br class="title-page-name"/>    // If the player manages to get away from the enemy <br class="title-page-name"/>    if (GetDistanceFromPlayer() &gt; m_loseDistance) <br class="title-page-name"/>    { <br class="title-page-name"/>      // Stop in your tracks <br class="title-page-name"/>      m_currentState = Idle; <br class="title-page-name"/>    } <br class="title-page-name"/>    break; <br class="title-page-name"/>  case Death: <br class="title-page-name"/>    // Set object for deletion <br class="title-page-name"/>    m_pObj-&gt;isDead = true; <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Save everything and go ahead and run the project. If all goes well, you should see a scene like this:</p>
<div><img class="image-border16" src="img/00034.jpeg"/></div>
<p class="calibre2">Notice that our enemy is not moving at the beginning due to it being in the Idle state. However, if we move closer to it, it would look something like this:</p>
<div><img class="image-border17" src="img/00035.jpeg"/></div>
<p class="calibre2">You'll see that it now follows us without stopping. If we manage to move far enough away from the enemy though, they'll stop:</p>
<div><img class="image-border18" src="img/00036.jpeg"/></div>
<p class="calibre2">This clearly shows the basic principles of the State pattern in use, though there are a number of things we can do to improve this, which we will talk about soon.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Issues with conditionals</h1>
            

            
                
<p class="calibre2">The next thing we need to consider is how we should do something based on what state we are in. When writing programs, conditional clauses such as the <kbd class="calibre14">if</kbd> and <kbd class="calibre14">switch</kbd> statements that we learned about earlier may make your code more difficult to manage. Sometimes, when writing code for specific functionality, writing if statements is completely understandable, especially if it makes sense when you are writing it. For example, the following code makes perfect sense:</p>
<pre class="calibre23">
void MinValue(int a, int b) <br class="title-page-name"/>{ <br class="title-page-name"/>  if (a &lt; b) <br class="title-page-name"/>    return a; <br class="title-page-name"/>  else <br class="title-page-name"/>    return b; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>// Could also be written in the following way: <br class="title-page-name"/>void MinValue(int a, int b) <br class="title-page-name"/>{ <br class="title-page-name"/>  return (a &lt; b) ? a : b; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">However, if you are writing something where you are checking what the type of an object is, or whether a variable is of a certain type, that is a bit of an issue. For instance, look at the following function:</p>
<pre class="calibre23">
<a class="calibre29">void AttackPlayer(Weapon * weapon)</a> <br class="title-page-name"/>  { <br class="title-page-name"/>    if (weapon.name == "Bow")     <br class="title-page-name"/>    { <br class="title-page-name"/>      ShootArrow(weapon); <br class="title-page-name"/>    } <br class="title-page-name"/>    else if (weapon.name == "Sword") <br class="title-page-name"/>    { <br class="title-page-name"/>      MeleeAttack(weapon); <br class="title-page-name"/>    } <br class="title-page-name"/>    else <br class="title-page-name"/>    { <br class="title-page-name"/>      IdleAnimation(weapon); <br class="title-page-name"/>    } <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As you can see, if we start going down this path, we will need to add many different checks throughout our project, which will make our code hard to change if we ever decide to add more things to support here. First of all, instead of a bunch of <kbd class="calibre14">if</kbd>/<kbd class="calibre14">else</kbd> statements, when we see something that's comparing the same value and doing something based off of that value, we should be using a <kbd class="calibre14">switch</kbd> statement, like we did earlier, with a few modifications:</p>
<pre class="calibre23">
void AttackPlayer(Weapon * weapon) <br class="title-page-name"/>{ <br class="title-page-name"/>// C++ doesn't support using string literals in switch  <br class="title-page-name"/>// statements so we have to use a different variable <br class="title-page-name"/>// type, such as an integer <br class="title-page-name"/>  switch (weapon.type) <br class="title-page-name"/>  { <br class="title-page-name"/>  case 0: <br class="title-page-name"/>    ShootArrow(weapon); <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  case 1: <br class="title-page-name"/>    MeleeAttack(weapon); <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  default: <br class="title-page-name"/>    IdleAnimation(weapon); <br class="title-page-name"/> <br class="title-page-name"/>  } <br class="title-page-name"/>   <br class="title-page-name"/>} 
</pre>
<p class="calibre2">But in this particular case, we are just calling a different function based on the value, with each of the functions being some kind of attack. Instead, we should make use of polymorphism and have the code automatically do the correct thing:</p>
<pre class="calibre23">
  class Weapon <br class="title-page-name"/>  { <br class="title-page-name"/>  public: <br class="title-page-name"/>    virtual void Attack()  <br class="title-page-name"/>    { <br class="title-page-name"/>      // Do nothing <br class="title-page-name"/>    }; <br class="title-page-name"/>  }; <br class="title-page-name"/> <br class="title-page-name"/>  class Bow : Weapon <br class="title-page-name"/>  { <br class="title-page-name"/>  public: <br class="title-page-name"/>    virtual void Attack() <br class="title-page-name"/>    { <br class="title-page-name"/>      // Attack with Bow <br class="title-page-name"/>    }; <br class="title-page-name"/>  }; <br class="title-page-name"/> <br class="title-page-name"/>  void AttackPlayer(Weapon * weapon) <br class="title-page-name"/>  { <br class="title-page-name"/>    weapon-&gt;Attack(); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Now whenever we call <kbd class="calibre14">AttackPlayer</kbd>, it will do the correct thing automatically.</p>
<p class="calibre2">Just remember that creating complex behavior leads to ugly code being written and increases the likelihood of bugs. If you forget about a condition that needs to be there, your game hopefully would break, letting you know there is a problem, but it could not do anything. Then, when you find your game crashes down the road, your life becomes a lot more complex and your game could become unplayable or just plainly not fun.</p>
<p>Robert Elder has a link of the subject which I think explains the kind of crazy things that you can do with conditional statements, which would almost certainly get you fired: <a href="http://blog.robertelder.org/switch-statements-statement-expressions/" target="_blank" class="calibre24">http://blog.robertelder.org/switch-statements-statement-expressions/</a>.</p>
<p class="calibre2">Don't lose sleep over having conditionals in your code, but make sure that you only include them when you actually need them there. As you continue coding, you'll have a better idea as to when it's a good idea or not, but it is something to keep in mind.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Expanding on the State Machine</h1>
            

            
                
<p class="calibre2">So currently, you'll notice that in the Idle state we are setting our velocity to <kbd class="calibre14">0,0</kbd> every single frame. In this simple example, it's not a terribly big deal, but this overdoing of calculations is something that we'd like to avoid in the future. We only really need to do it once, right when we enter the state. We may also want to do certain actions when we leave the state, but we won't be able to do that in the current form of our State Machine, so we are going to need to redo some stuff.</p>
<p class="calibre2">First, let's go back to the <kbd class="calibre14">ChasePlayerComponent.h</kbd> file and add the following bold function definitions:</p>
<pre class="calibre23">
class ChasePlayerComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ChasePlayerComponent(void); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp; iniFile); <br class="title-page-name"/>  virtual M5Component* Clone(void); <br class="title-page-name"/> <strong class="calibre1"> virtual void EnterState(State state);</strong><br class="title-page-name"/><strong class="calibre1">  virtual void UpdateState(State state, float dt);</strong><br class="title-page-name"/><strong class="calibre1">  virtual void ExitState(State state);</strong> <br class="title-page-name"/>  virtual void SetNewState(State state, bool initialState = false); <br class="title-page-name"/>private: <br class="title-page-name"/>  float m_speed; <br class="title-page-name"/>  float m_followDistance; <br class="title-page-name"/>  float m_loseDistance; <br class="title-page-name"/> <br class="title-page-name"/>  void FollowPlayer(); <br class="title-page-name"/>  float GetDistanceFromPlayer(); <br class="title-page-name"/>  State m_currentState; <br class="title-page-name"/> <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">So instead of having our <kbd class="calibre14">Update</kbd> function handle everything, we've now created three functions for each of the different times that our state can be in: entering a new state, updating based on that state, and then what to do when we leave the state. Aside from that, we also have a <kbd class="calibre14">SetNewState</kbd> function which will take care of changing the state to something else. All of the functions take in a <kbd class="calibre14">State</kbd> enum to choose how to execute, with the <kbd class="calibre14">Update</kbd> state also having the time that passed this frame, and the <kbd class="calibre14">SetNewState</kbd> having an option for saying it's the first time you've set a state so you don't need to leave the previous one. After that, we need to actually add in the functionality for these new functions:</p>
<pre class="calibre23">
void ChasePlayerComponent::EnterState(State state) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Depending on what state we are in, do different things <br class="title-page-name"/>  switch (state) <br class="title-page-name"/>  { <br class="title-page-name"/>  case Idle: <br class="title-page-name"/>    // No longer move if we were <br class="title-page-name"/>    if (m_pObj) <br class="title-page-name"/>    {   <br class="title-page-name"/>      m_pObj-&gt;vel = M5Vec2(0, 0); <br class="title-page-name"/>    } <br class="title-page-name"/>     <br class="title-page-name"/>    M5DEBUG_PRINT("\nIdle: Enter"); <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  case Follow: <br class="title-page-name"/>    M5DEBUG_PRINT("\nFollow: Enter"); <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  case Death: <br class="title-page-name"/>    m_pObj-&gt;isDead = true; <br class="title-page-name"/>    M5DEBUG_PRINT("\nDeath: Enter"); <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>void ChasePlayerComponent::UpdateState(State state, float) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Depending on what state we are in, do different things <br class="title-page-name"/>  switch (state) <br class="title-page-name"/>  { <br class="title-page-name"/>  case Idle: <br class="title-page-name"/>    //M5DEBUG_PRINT("\nIdle: Update"); <br class="title-page-name"/>    // If the player gets too close, the enemy notices them <br class="title-page-name"/>    if (GetDistanceFromPlayer() &lt; m_followDistance) <br class="title-page-name"/>    { <br class="title-page-name"/>      // And will begin to give chase <br class="title-page-name"/>      SetNewState(Follow); <br class="title-page-name"/>    } <br class="title-page-name"/>     <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  case Follow: <br class="title-page-name"/>    //M5DEBUG_PRINT("\nFollow: Update"); <br class="title-page-name"/> <br class="title-page-name"/>    // Follow the player <br class="title-page-name"/>    FollowPlayer(); <br class="title-page-name"/> <br class="title-page-name"/>    // If the player manages to get away from the enemy <br class="title-page-name"/>    if (GetDistanceFromPlayer() &gt; m_loseDistance) <br class="title-page-name"/>    { <br class="title-page-name"/>      // Stop in your tracks <br class="title-page-name"/>      SetNewState(Idle); <br class="title-page-name"/>    } <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>void ChasePlayerComponent::ExitState(State state) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Depending on what state we are in, do different things <br class="title-page-name"/>  switch (state) <br class="title-page-name"/>  { <br class="title-page-name"/>  case Idle: <br class="title-page-name"/>    M5DEBUG_PRINT("\nIdle: Exit"); <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  case Follow: <br class="title-page-name"/>    M5DEBUG_PRINT("\nFollow: Exit"); <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>// initialState by default is false, so will only need to give <br class="title-page-name"/>// second parameter the first time it is called <br class="title-page-name"/>void ChasePlayerComponent::SetNewState(State state, bool initialState) <br class="title-page-name"/>{ <br class="title-page-name"/>  if (!initialState) <br class="title-page-name"/>  { <br class="title-page-name"/>    // Exit of our old state <br class="title-page-name"/>    ExitState(currentState); <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  // Then start up our new one <br class="title-page-name"/>  m_currentState = state; <br class="title-page-name"/>  EnterState(m_currentState); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">And then, we need to update our <kbd class="calibre14">Update</kbd> function to just call our correct function:</p>
<pre class="calibre23">
void ChasePlayerComponent::Update(float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  UpdateState(m_currentState, dt); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">We also need to change our constructor so that instead of setting the current state, we set it ourselves:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Sets component type and starting values for player <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>ChasePlayerComponent::ChasePlayerComponent(void): <br class="title-page-name"/>  M5Component(CT_ChasePlayerComponent), <br class="title-page-name"/>  m_speed(1) <br class="title-page-name"/>{ <br class="title-page-name"/>  SetNewState(Idle, true); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">First of all, note that I am calling the <kbd class="calibre14">M5DEBUG_PRINT</kbd> function. This is to make it easy to tell that we are changing between different states. For the purposes of this demonstration, I commented out the <kbd class="calibre14">Update</kbd> function's version, but it could be useful for you to check it out. Note in this version, we have a <kbd class="calibre14">switch</kbd> statement for each of the functions and do something differently based on the state that is set in there.</p>
<p class="calibre2">In my version of the editor, by default the text will not be displayed on the screen. To fix this issue, go to the <kbd class="calibre14">SplashStage.cpp</kbd> file and comment out the following bold code:</p>
<pre class="calibre23">
SplashStage::~SplashStage(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  //We are done this with ArcheType so lets get rid of it. <br class="title-page-name"/>  M5ObjectManager::RemoveArcheType(AT_Splash); <br class="title-page-name"/>  //M5DEBUG_DESTROY_CONSOLE(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Now let's run our project!</p>
<div><img class="image-border19" src="img/00037.jpeg"/></div>
<p class="calibre2">You can tell from the editor when we are switching our states and that the code is being called correctly!</p>
<p class="calibre2">This version works pretty well, but there are some issues with it; namely that it involves a lot of rewriting, and we will need to copy/paste this functionality and make changes anytime we want to make a new version. Next, we will take a look at the State Machine included in the Mach5 Engine and the advantages that it has over what we've been talking about so far.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The State pattern in action - the M5StateMachine class</h1>
            

            
                
<p class="calibre2">The Mach5 Engine itself also has its own implementation of a State Machine, using inheritance to allow users to not have to rewrite the base functionality over and over again and using function pointers instead of having one function for each state. A function pointer is what it sounds like--a pointer to the address in memory where the function is--and we can call it from that information.</p>
<p>To learn more about function pointers and how they are used, check out <a href="http://www.cprogramming.com/tutorial/function-pointers.html" target="_blank" class="calibre24">http://www.cprogramming.com/tutorial/function-pointers.html</a>.</p>
<p class="calibre2">You can take a look at the base version of one here, starting with the <kbd class="calibre14">Header</kbd> file:</p>
<pre class="calibre23">
#ifndef M5STATEMACNINE_H <br class="title-page-name"/>#define M5STATEMACNINE_H <br class="title-page-name"/> <br class="title-page-name"/>#include "M5Component.h" <br class="title-page-name"/>#include "M5Vec2.h" <br class="title-page-name"/> <br class="title-page-name"/>//! Base State for M5StateMachines <br class="title-page-name"/>class M5State <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  //! Empty virtual destructor <br class="title-page-name"/>  virtual ~M5State(void) {} <br class="title-page-name"/>  //! Called when we first enter a state <br class="title-page-name"/>  virtual void Enter(float dt)  = 0; <br class="title-page-name"/>  //! called once per frame <br class="title-page-name"/>  virtual void Update(float dt) = 0; <br class="title-page-name"/>  //! called before we exit a state <br class="title-page-name"/>  virtual void Exit(float dt)   = 0; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//! Base class for Finite statemanchine component for AstroShot <br class="title-page-name"/>class M5StateMachine : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  M5StateMachine(M5ComponentTypes type); <br class="title-page-name"/>  virtual ~M5StateMachine(void); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  void SetNextState(M5State* pNext); <br class="title-page-name"/>private: <br class="title-page-name"/>  M5State* m_pCurr; //!&lt; a pointer to our current state to be updated <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>#endif //M5STATEMACNINE_H 
</pre>
<p class="calibre2">In the preceding code, note that we finally broke apart the <kbd class="calibre14">StateMachine</kbd> and the <kbd class="calibre14">State</kbd> object into their own classes, with the state function having its own <kbd class="calibre14">Enter</kbd>, <kbd class="calibre14">Update</kbd>, and <kbd class="calibre14">Exit</kbd> functions. The State Machine keeps track of the current state that we are in and updates appropriately using the <kbd class="calibre14">Update</kbd> and <kbd class="calibre14">SetNextState</kbd> functions, and a <kbd class="calibre14">SetStateState</kbd> function is used to dictate what state we should start from. The implementation for the class looks a little something like this:</p>
<pre class="calibre23">
#include "M5StateMachine.h"<br class="title-page-name"/><br class="title-page-name"/>M5StateMachine::M5StateMachine(M5ComponentTypes type):<br class="title-page-name"/> M5Component(type),<br class="title-page-name"/> m_pCurr(nullptr)<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>M5StateMachine::~M5StateMachine(void)<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>void M5StateMachine::Update(float dt)<br class="title-page-name"/>{<br class="title-page-name"/> m_pCurr-&gt;Update(dt);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>void M5StateMachine::SetNextState(M5State* pNext)<br class="title-page-name"/>{<br class="title-page-name"/> if(m_pCurr)<br class="title-page-name"/> m_pCurr-&gt;Exit();<br class="title-page-name"/> <br class="title-page-name"/> m_pCurr = pNext;<br class="title-page-name"/> m_pCurr-&gt;Enter();<br class="title-page-name"/>}
</pre>
<p class="calibre2">This system provides a template that we can expand upon, in order to create more interesting behavior that does something a bit more complex. Take, for example, the <kbd class="calibre14">RandomGoComponent</kbd> class, whose header looks like this:</p>
<pre class="calibre23">
#ifndef RANDOM_LOCATION_COMPONENT_H <br class="title-page-name"/>#define RANDOM_LOCATION_COMPONENT_H <br class="title-page-name"/> <br class="title-page-name"/>#include "Core\M5Component.h" <br class="title-page-name"/>#include "Core\M5StateMachine.h" <br class="title-page-name"/>#include "Core\M5Vec2.h" <br class="title-page-name"/> <br class="title-page-name"/>//Forward declation <br class="title-page-name"/>class RandomGoComponent; <br class="title-page-name"/> <br class="title-page-name"/>class RLCFindState : public M5State <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  RLCFindState(RandomGoComponent* parent); <br class="title-page-name"/>  void Enter(float dt); <br class="title-page-name"/>  void Update(float dt); <br class="title-page-name"/>  void Exit(float dt); <br class="title-page-name"/>private: <br class="title-page-name"/>  RandomGoComponent* m_parent; <br class="title-page-name"/>}; <br class="title-page-name"/>class RLCRotateState : public M5State <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  RLCRotateState(RandomGoComponent* parent); <br class="title-page-name"/>  void Enter(float dt); <br class="title-page-name"/>  void Update(float dt); <br class="title-page-name"/>  void Exit(float dt); <br class="title-page-name"/>private: <br class="title-page-name"/>  float m_targetRot; <br class="title-page-name"/>  M5Vec2 m_dir; <br class="title-page-name"/>  RandomGoComponent* m_parent; <br class="title-page-name"/>}; <br class="title-page-name"/>class RLCGoState : public M5State <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  RLCGoState(RandomGoComponent* parent); <br class="title-page-name"/>  void Enter(float dt); <br class="title-page-name"/>  void Update(float dt); <br class="title-page-name"/>  void Exit(float dt); <br class="title-page-name"/>private: <br class="title-page-name"/>  RandomGoComponent* m_parent; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/> <br class="title-page-name"/>class RandomGoComponent : public M5StateMachine <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  RandomGoComponent(void); <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp;); <br class="title-page-name"/>  virtual M5Component* Clone(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  friend RLCFindState; <br class="title-page-name"/>  friend RLCGoState; <br class="title-page-name"/>  friend RLCRotateState; <br class="title-page-name"/> <br class="title-page-name"/>  float          m_speed; <br class="title-page-name"/>  float          m_rotateSpeed; <br class="title-page-name"/>  M5Vec2         m_target; <br class="title-page-name"/>  RLCFindState   m_findState; <br class="title-page-name"/>  RLCRotateState m_rotateState; <br class="title-page-name"/>  RLCGoState     m_goState; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>#endif // !RANDOM_LOCATION_COMPONENT_H 
</pre>
<p class="calibre2">This class contains three states, <kbd class="calibre14">Find</kbd>, <kbd class="calibre14">Rotate</kbd>, and <kbd class="calibre14">Go</kbd>, which have been added as objects in the <kbd class="calibre14">RandomGoComponent</kbd>. Each of the states has their own <kbd class="calibre14">Enter</kbd>, <kbd class="calibre14">Update</kbd>, and <kbd class="calibre14">Exit</kbd> functionality, in addition to the constructor and a reference to their parent. The implementation for the classes looks something like this:</p>
<pre class="calibre23">
#include "RandomGoStates.h"<br class="title-page-name"/>#include "RandomGoComponent.h"<br class="title-page-name"/><br class="title-page-name"/>#include "Core\M5Random.h"<br class="title-page-name"/>#include "Core\M5Object.h"<br class="title-page-name"/>#include "Core\M5Intersect.h"<br class="title-page-name"/>#include "Core\M5Gfx.h"<br class="title-page-name"/>#include "Core\M5Math.h"<br class="title-page-name"/>#include &lt;cmath&gt;<br class="title-page-name"/><br class="title-page-name"/>FindState::FindState(RandomGoComponent* parent): m_parent(parent)<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/>void FindState::Enter()<br class="title-page-name"/>{<br class="title-page-name"/> M5Vec2 botLeft;<br class="title-page-name"/> M5Vec2 topRight;<br class="title-page-name"/> M5Gfx::GetWorldBotLeft(botLeft);<br class="title-page-name"/> M5Gfx::GetWorldTopRight(topRight);<br class="title-page-name"/><br class="title-page-name"/> M5Vec2 target;<br class="title-page-name"/> target.x = M5Random::GetFloat(botLeft.x, topRight.x);<br class="title-page-name"/> target.y = M5Random::GetFloat(botLeft.y, topRight.y);<br class="title-page-name"/><br class="title-page-name"/> m_parent-&gt;SetTarget(target);<br class="title-page-name"/><br class="title-page-name"/>}<br class="title-page-name"/>void FindState::Update(float)<br class="title-page-name"/>{<br class="title-page-name"/> m_parent-&gt;SetNextState(m_parent-&gt;GetState(RGS_ROTATE_STATE));<br class="title-page-name"/>}<br class="title-page-name"/>void FindState::Exit()<br class="title-page-name"/>{<br class="title-page-name"/>}
</pre>
<p class="calibre2">This class will just tell our main State Machine where its intended location is. This only needs to be done once, so it is done in the <kbd class="calibre14">Enter</kbd> state. The <kbd class="calibre14">Update</kbd> state just states that after this is done, we want to move to the <kbd class="calibre14">Rotate</kbd> state, and <kbd class="calibre14">Exit</kbd> does nothing. Technically, we could not create it, and that would be fine as well since the base class doesn't do anything as well, but it is here if you wish to expand upon it:</p>
<pre class="calibre23">
RotateState::RotateState(RandomGoComponent* parent): m_parent(parent)<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/>void RotateState::Enter()<br class="title-page-name"/>{<br class="title-page-name"/> M5Vec2 target = m_parent-&gt;GetTarget();<br class="title-page-name"/><br class="title-page-name"/> M5Vec2::Sub(m_dir, target, m_parent-&gt;GetM5Object()-&gt;pos);<br class="title-page-name"/> <br class="title-page-name"/> m_targetRot = std::atan2f(m_dir.y, m_dir.x);<br class="title-page-name"/> m_targetRot = M5Math::Wrap(m_targetRot, 0.f, M5Math::TWO_PI);<br class="title-page-name"/> <br class="title-page-name"/> m_parent-&gt;GetM5Object()-&gt;rotationVel = m_parent-&gt;GetRotationSpeed();<br class="title-page-name"/>}<br class="title-page-name"/>void RotateState::Update(float)<br class="title-page-name"/>{<br class="title-page-name"/> m_parent-&gt;GetM5Object()-&gt;rotation = M5Math::Wrap(m_parent-&gt;GetM5Object()-&gt;rotation, 0.f, M5Math::TWO_PI);<br class="title-page-name"/> <br class="title-page-name"/> if (M5Math::IsInRange(m_parent-&gt;GetM5Object()-&gt;rotation, m_targetRot - .1f, m_targetRot + .1f))<br class="title-page-name"/> m_parent-&gt;SetNextState(m_parent-&gt;GetState(RGS_GO_STATE));<br class="title-page-name"/>}<br class="title-page-name"/>void RotateState::Exit()<br class="title-page-name"/>{<br class="title-page-name"/> m_parent-&gt;GetM5Object()-&gt;rotationVel = 0;<br class="title-page-name"/> <br class="title-page-name"/> m_dir.Normalize();<br class="title-page-name"/> M5Vec2::Scale(m_dir, m_dir, m_parent-&gt;GetSpeed());<br class="title-page-name"/> <br class="title-page-name"/> m_parent-&gt;GetM5Object()-&gt;vel = m_dir;<br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">Rotate</kbd> state will just rotate the character till it is facing the location that it wants to go to. If it is within the range of the rotation, it will then switch to the <kbd class="calibre14">Go</kbd> state. Before leaving though, it will set the velocity of our parent to the appropriate direction in the <kbd class="calibre14">Exit</kbd> function:</p>
<pre class="calibre23">
GoState::GoState(RandomGoComponent* parent): m_parent(parent)<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/>void GoState::Enter()<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/>void GoState::Update(float)<br class="title-page-name"/>{<br class="title-page-name"/> M5Vec2 target = m_parent-&gt;GetTarget();<br class="title-page-name"/> if (M5Intersect::PointCircle(target, m_parent-&gt;GetM5Object()-&gt;pos, m_parent-&gt;GetM5Object()-&gt;scale.x))<br class="title-page-name"/> m_parent-&gt;SetNextState(m_parent-&gt;GetState(RGS_FIND_STATE));<br class="title-page-name"/>}<br class="title-page-name"/>void GoState::Exit()<br class="title-page-name"/>{<br class="title-page-name"/> m_parent-&gt;GetM5Object()-&gt;vel.Set(0, 0);<br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">Go</kbd> state merely checks whether the enemy intersects with the target that we are set to go to. If it does, we then set our state to move back to the <kbd class="calibre14">Find</kbd> state and start everything over again, and also stop the player from moving in the <kbd class="calibre14">Exit</kbd> function:</p>
<pre class="calibre23">
RandomGoComponent::RandomGoComponent():<br class="title-page-name"/> M5StateMachine(CT_RandomGoComponent),<br class="title-page-name"/> m_speed(1),<br class="title-page-name"/> m_rotateSpeed(1),<br class="title-page-name"/> m_findState(this),<br class="title-page-name"/> m_rotateState(this),<br class="title-page-name"/> m_goState(this)<br class="title-page-name"/>{<br class="title-page-name"/> SetNextState(&amp;m_findState);<br class="title-page-name"/>}<br class="title-page-name"/>void RandomGoComponent::FromFile(M5IniFile&amp; iniFile)<br class="title-page-name"/>{<br class="title-page-name"/> iniFile.SetToSection("RandomGoComponent");<br class="title-page-name"/> iniFile.GetValue("speed", m_speed);<br class="title-page-name"/> iniFile.GetValue("rotationSpeed", m_speed);<br class="title-page-name"/>}<br class="title-page-name"/>RandomGoComponent* RandomGoComponent::Clone(void) const<br class="title-page-name"/>{<br class="title-page-name"/> RandomGoComponent* pNew = new RandomGoComponent;<br class="title-page-name"/> pNew-&gt;m_speed = m_speed;<br class="title-page-name"/> pNew-&gt;m_rotateSpeed = m_rotateSpeed;<br class="title-page-name"/> return pNew;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>M5State* RandomGoComponent::GetState(RandomGoStates state)<br class="title-page-name"/>{<br class="title-page-name"/> switch (state)<br class="title-page-name"/> {<br class="title-page-name"/> case RGS_FIND_STATE:<br class="title-page-name"/> return &amp;m_findState;<br class="title-page-name"/> break;<br class="title-page-name"/> case RGS_ROTATE_STATE:<br class="title-page-name"/> return &amp;m_rotateState;<br class="title-page-name"/> break;<br class="title-page-name"/> case RGS_GO_STATE:<br class="title-page-name"/> return &amp;m_goState;<br class="title-page-name"/> break;<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> //In case somethings goes wrong <br class="title-page-name"/> return &amp;m_findState;<br class="title-page-name"/>}
</pre>
<p class="calibre2">As you can see, this works in a very similar way to what we have done before--setting our first state, getting the initial values from the INI file, and then setting things properly when cloned. Finally, we also have a <kbd class="calibre14">GetState</kbd> function which will return the current state that the player has using a switch like we talked about previously.</p>
<p class="calibre2">To see this in action, go ahead and go to the <kbd class="calibre14">Raider.ini</kbd> file and modify the code to fit the following:</p>
<pre class="calibre23">
posX   = 0 <br class="title-page-name"/>posY   = 0 <br class="title-page-name"/>velX   = 0 <br class="title-page-name"/>velY   = 0 <br class="title-page-name"/>scaleX = 10 <br class="title-page-name"/>scaleY = 10 <br class="title-page-name"/>rot    = 0 <br class="title-page-name"/>rotVel = 0 <br class="title-page-name"/>components = GfxComponent ColliderComponent RandomGoComponent <br class="title-page-name"/> <br class="title-page-name"/>[GfxComponent] <br class="title-page-name"/>texture = enemyBlack3.tga <br class="title-page-name"/>drawSpace = world <br class="title-page-name"/> <br class="title-page-name"/>[ColliderComponent] <br class="title-page-name"/>radius = 5 <br class="title-page-name"/>isResizeable = 0 <br class="title-page-name"/> <br class="title-page-name"/>[RandomGoComponent] <br class="title-page-name"/>speed = 40 <br class="title-page-name"/>rotationSpeed = 40 
</pre>
<p class="calibre2">If all went well, save the file and then run the project!</p>
<div><img class="image-border20" src="img/00038.jpeg"/></div>
<p class="calibre2">Now we will see the enemy continually move into new areas, rotating before going there!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The State pattern in action - StageManager</h1>
            

            
                
<p class="calibre2">Another aspect of the Mach5 Engine that uses the State pattern is the <kbd class="calibre14">M5StageManager</kbd> class:</p>
<pre class="calibre23">
class M5StageManager <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  friend class M5App; <br class="title-page-name"/> <br class="title-page-name"/>  //Registers a GameStage and a builder with the the StageManger <br class="title-page-name"/>  static void AddStage(M5StageTypes type, M5StageBuilder* builder); <br class="title-page-name"/>  //Removes a Stage Builder from the Manager <br class="title-page-name"/>  static void RemoveStage(M5StageTypes type); <br class="title-page-name"/>  //Clears all stages from the StageManager <br class="title-page-name"/>  static void ClearStages(void); <br class="title-page-name"/>  //Sets the given stage ID to the starting stage of the game <br class="title-page-name"/>  static void SetStartStage(M5StageTypes startStage); <br class="title-page-name"/>  //Test if the game is quitting <br class="title-page-name"/>  static bool IsQuitting(void); <br class="title-page-name"/>  //Test stage is restarting <br class="title-page-name"/>  static bool IsRestarting(void); <br class="title-page-name"/>  //Gets the pointer to the users game specific data <br class="title-page-name"/>  static M5GameData&amp; GetGameData(void); <br class="title-page-name"/>  //Sets the next stage for the game <br class="title-page-name"/>  static void SetNextStage(M5StageTypes nextStage); <br class="title-page-name"/>  // Pauses the current stage, so it can be resumed but changes stages <br class="title-page-name"/>  static void PauseAndSetNextStage(M5StageTypes nextStage); <br class="title-page-name"/>  // Resumes the previous stage <br class="title-page-name"/>  static void Resume(void); <br class="title-page-name"/>  //Tells the game to quit <br class="title-page-name"/>  static void Quit(void); <br class="title-page-name"/>  //Tells the stage to restart <br class="title-page-name"/>  static void Restart(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  static void Init(const M5GameData&amp; gameData, int framesPerSecond);<br class="title-page-name"/>  static void Update(void); <br class="title-page-name"/>  static void Shutdown(void); <br class="title-page-name"/>  static void InitStage(void); <br class="title-page-name"/>  static void ChangeStage(void); <br class="title-page-name"/> <br class="title-page-name"/>};//end M5StageManager 
</pre>
<p class="calibre2">Since there will only be one of these in the game, all of the functionality has been made static similarly to a Singleton but, depending on the state that the project is in, it will do different things. Take, for example, changing what stage we are in. I'm sure you'll find that it looks very similar to how we changed states earlier:</p>
<pre class="calibre23">
void M5StageManager::ChangeStage(void)<br class="title-page-name"/>{<br class="title-page-name"/> /*Only unload if we are not restarting*/<br class="title-page-name"/> if (s_isPausing)<br class="title-page-name"/> {<br class="title-page-name"/>   M5ObjectManager::Pause();<br class="title-page-name"/>   M5Phy::Pause();<br class="title-page-name"/>   M5Gfx::Pause(s_drawPaused);<br class="title-page-name"/>   PauseInfo pi(s_pStage, s_currStage);<br class="title-page-name"/>   s_pauseStack.push(pi);<br class="title-page-name"/>   s_isPausing = false;<br class="title-page-name"/> }<br class="title-page-name"/> else if (s_isResuming)<br class="title-page-name"/> {<br class="title-page-name"/>   /*Make sure to shutdown the stage*/<br class="title-page-name"/>   s_pStage-&gt;Shutdown();<br class="title-page-name"/>   delete s_pStage;<br class="title-page-name"/>   s_pStage = nullptr;<br class="title-page-name"/> }<br class="title-page-name"/> else if (!s_isRestarting) //Just changine the stage<br class="title-page-name"/> {<br class="title-page-name"/>   /*Make sure to shutdown the stage*/<br class="title-page-name"/>   s_pStage-&gt;Shutdown();<br class="title-page-name"/>   delete s_pStage;<br class="title-page-name"/>   s_pStage = nullptr;<br class="title-page-name"/><br class="title-page-name"/>   //If we are setting the next state, that means we are ignore all<br class="title-page-name"/>   //paused states, so lets clear the pause stack<br class="title-page-name"/>   while (!s_pauseStack.empty())<br class="title-page-name"/>   {<br class="title-page-name"/>     M5Gfx::Resume();<br class="title-page-name"/>     M5Phy::Resume();<br class="title-page-name"/>     M5ObjectManager::Resume();<br class="title-page-name"/>     PauseInfo pi = s_pauseStack.top();<br class="title-page-name"/>     pi.pStage-&gt;Shutdown();<br class="title-page-name"/>     delete pi.pStage;<br class="title-page-name"/>     s_pauseStack.pop();<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/> }<br class="title-page-name"/> else if (s_isRestarting)<br class="title-page-name"/> {<br class="title-page-name"/>   /*Make sure to shutdown the stage*/<br class="title-page-name"/>   s_pStage-&gt;Shutdown();<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> s_currStage = s_nextStage;<br class="title-page-name"/>}
</pre>
<p class="calibre2">I highly advise taking a closer look at the file and going through each function to see how they interact with each other.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Issues with FSMs</h1>
            

            
                
<p class="calibre2">We've seen some of the ways in which FSMs can be valuable things to add to your projects and how they can make simple AI behaviors much easier, but there are some issues with them.</p>
<p class="calibre2">Traditional FSMs such as the ones we've displayed here can, over time, become unmanageable as you continue to add many different states to them. The difficult part is keeping the number of states to a minimum while also adding complexity by adding new contexts in which your characters can respond.</p>
<p class="calibre2">You'll also have a lot of similar code being written as you'll be rebuilding different behaviors that have pieces of others, which can also be time-consuming. Another thing that's been going on recently in the game industry is AI programmers moving on to more complex ways of handing AI, such as behavior trees.</p>
<p>If you're interested in why some people believe that the age of Finite State Machines is over, check out <a href="http://aigamedev.com/open/article/fsm-age-is-over/" target="_blank" class="calibre24">http://aigamedev.com/open/article/fsm-age-is-over/</a>. A look at the issues with FSMs, as well as some potential solutions to fix those issues, can be found here: <a href="http://aigamedev.com/open/article/fsm-age-is-over/" target="_blank" class="calibre24">http://aigamedev.com/open/article/hfsm-gist/</a>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">In this chapter, we learned about the State pattern, which is a way to allow a game object to change its behavior and functionality in response to different stimuli within the game. We learned about the State and the Context (Machine) and how they are used together. We then learned how we can use the State pattern to gain some exposure toward AI programming, as well as how our project's Game State Manager works and why it's important. Of course, FSMs are most popular in being used for AI, but can also be used in UI as well as dealing with user input, making them another useful tool to have in your arsenal.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>