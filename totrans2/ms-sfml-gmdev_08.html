<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/><span class="koboSpan" id="kobo.1.1">Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting </span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There is a certain standard expected of a game in this day and age. </span><span class="koboSpan" id="kobo.2.2">As technology progresses and the number of transistors in any given computational unit increases, there is more and more power at our disposal to do what was previously unheard of. </span><span class="koboSpan" id="kobo.2.3">One thing that definitely makes use of all of this extra horse power is dynamic lighting. </span><span class="koboSpan" id="kobo.2.4">Because of its stunning visual results, it has become an integral part of most video games, and is now one of the core technologies that are expected to come with them.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we're going to cover the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Using the technique of deferred rendering/shading</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Implementing a multi-pass lighting shader</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Faking geometry complexity using normal maps</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Using specular maps to create shiny surfaces</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Using height maps to make lighting feel more three-dimensional</span></li></ul></div><p><span class="koboSpan" id="kobo.9.1">Let's start shedding some light on this subject!</span></p><div class="section" title="Using third-party software"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/><span class="koboSpan" id="kobo.10.1">Using third-party software</span></h1></div></div></div><p><span class="koboSpan" id="kobo.11.1">None of the material maps used in this chapter are hand-drawn. </span><span class="koboSpan" id="kobo.11.2">For the generation of certain material maps, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">Crazybump</span></em></span><span class="koboSpan" id="kobo.13.1"> was used, which can be found at </span><a class="ulink" href="http://crazybump.com/"><span class="koboSpan" id="kobo.14.1">http://crazybump.com/</span></a><span class="koboSpan" id="kobo.15.1">.</span></p><p><span class="koboSpan" id="kobo.16.1">There are other free alternatives that can be found online.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Deferred rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/><span class="koboSpan" id="kobo.1.1">Deferred rendering</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Deferred rendering/shading is a technique that gives us greater control over how certain effects are applied to a scene by not enabling them during the first pass. </span><span class="koboSpan" id="kobo.2.2">Instead, the scene can be rendered to an off screen buffer, along with other buffers that hold other material types of the same image, and then drawn on the screen in a later pass, after the effects have been applied, potentially in multiple passes as well. </span><span class="koboSpan" id="kobo.2.3">Using this approach allows us to separate and compartmentalize certain logic that would otherwise be entangled with our main rendering code. </span><span class="koboSpan" id="kobo.2.4">It also gives us an opportunity to apply as many effects to the final image as we want. </span><span class="koboSpan" id="kobo.2.5">Let's see what it takes to implement this technique.</span></p><div class="section" title="Modifying the renderer"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/><span class="koboSpan" id="kobo.3.1">Modifying the renderer</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">In order to support all the fancy new techniques we're about to utilize, we need to make some changes to our renderer. </span><span class="koboSpan" id="kobo.4.2">It should be able to keep a buffer texture and render to it in multiple passes in order to create the lighting we're looking for:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class Renderer { 
  friend Window; 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.5.2">void EnableDeferredRendering(); 
  void BeginSceneRendering(); 
  void BeginTextureRendering(); 
  sf::RenderTexture* GetCurrentTexture(); 
  sf::RenderTexture* GetFinishedTexture(); 
  void SwapTextures(); 
  void ClearCurrentTexture(); 
  void ClearFinishedTexture(); 
  void ClearTextures(); 
  void DrawBufferTexture(); 
  void DisableDeferredRendering(); 
  ... 
</span><span class="koboSpan" id="kobo.5.3">private: 
  void CreateTextures(); 
  ... 
  </span><span class="koboSpan" id="kobo.5.4">sf::Shader* m_currentShader; 
  sf::RenderTexture* m_currentTexture; 
  sf::RenderTexture m_texture1; 
  sf::RenderTexture m_texture2; 
  ... 
  </span><span class="koboSpan" id="kobo.5.5">bool m_deferred; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">For convenience, we have a couple of methods for toggling the deferred rendering process. </span><span class="koboSpan" id="kobo.6.2">Also, since rendering a scene to a texture is slightly different than rendering a texture to another texture, because of where the camera (view) is positioned, we will use the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">BeginSceneRendering()</span></code><span class="koboSpan" id="kobo.8.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.9.1">BeginTextureRendering()</span></code><span class="koboSpan" id="kobo.10.1"> methods to properly handle the task.</span></p><p><span class="koboSpan" id="kobo.11.1">Note the use of two textures in this class as well as a pointer to point to the texture that is currently in use. </span><span class="koboSpan" id="kobo.11.2">The essence of a multi-pass approach is being able to sample the texture holding the information of the previous render pass while drawing to the current render target.</span></p><p><span class="koboSpan" id="kobo.12.1">Lastly, we'll discuss three methods for clearing the current texture, the texture of a previous render pass, and both of these. </span><span class="koboSpan" id="kobo.12.2">The most recent render pass texture can then be rendered by calling the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">DrawBufferTexture()</span></code><span class="koboSpan" id="kobo.14.1"> method.</span></p><div class="section" title="Implementing changes in the Renderer class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec14"/><span class="koboSpan" id="kobo.15.1">Implementing changes in the Renderer class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.16.1">Let's start with something simple. </span><span class="koboSpan" id="kobo.16.2">Implement the deferred rendering toggle methods; they will help you keep track of the current rendering state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">void Renderer::EnableDeferredRendering() { 
  if (!m_useShaders) { return; } 
  m_deferred = true; 
} 
 
void Renderer::DisableDeferredRendering() { m_deferred = false; } 
</span></pre><p><span class="koboSpan" id="kobo.18.1">As you can see, it's as simple as flipping a flag. </span><span class="koboSpan" id="kobo.18.2">In the case of enabling deferred rendering, we also need to check whether the use of shaders is allowed.</span></p><p><span class="koboSpan" id="kobo.19.1">Also, the textures we're using as buffers clearly need to be created:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.20.1">void Renderer::CreateTextures() { 
  if (!m_useShaders) { return; } 
  m_texture1.create(m_screenSize.x, m_screenSize.y); 
  m_texture2.create(m_screenSize.x, m_screenSize.y); 
  ClearTextures(); 
  m_texture1.display(); 
  m_texture2.display(); 
  m_currentTexture = &amp;m_texture1; 
} 
</span></pre><p><span class="koboSpan" id="kobo.21.1">This particular method is invoked inside the constructor of </span><code class="literal"><span class="koboSpan" id="kobo.22.1">Renderer</span></code><span class="koboSpan" id="kobo.23.1">.</span></p><p><span class="koboSpan" id="kobo.24.1">Next, we have something equally as simple, yet quite a bit more important:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">void Renderer::BeginSceneRendering() { 
  auto&amp; view = m_window-&gt;GetRenderWindow()-&gt;getView(); 
  m_currentTexture-&gt;setView(view); 
} 
 
void Renderer::BeginTextureRendering() { 
  auto&amp; view = m_window-&gt;GetRenderWindow()-&gt;getDefaultView(); 
  m_currentTexture-&gt;setView(view); 
} 
</span></pre><p><span class="koboSpan" id="kobo.26.1">By using these methods at the appropriate time, we can successfully draw shapes that would have world coordinates for a standalone texture buffer the size of a window. </span><span class="koboSpan" id="kobo.26.2">We can also simply draw information from another window-sized texture to the buffer.</span></p><p><span class="koboSpan" id="kobo.27.1">Some helpful getter methods are always useful:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">sf::RenderTexture* Renderer::GetCurrentTexture() { 
  if (!m_useShaders) { return nullptr; } 
  return m_currentTexture; 
} 
 
sf::RenderTexture* Renderer::GetFinishedTexture() { 
  if (!m_useShaders) { return nullptr; } 
  if (!m_currentTexture) { return nullptr; } 
  return (m_currentTexture == &amp;m_texture1 ? 
    </span><span class="koboSpan" id="kobo.28.2">&amp;m_texture2 : &amp;m_texture1); 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">While the first one simply returns a pointer to the current buffer texture being used, the second method does the exact opposite. </span><span class="koboSpan" id="kobo.29.2">It determines which texture is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.30.1">not</span></em></span><span class="koboSpan" id="kobo.31.1"> the current buffer; once it identifies this, it returns a pointer to that object instead. </span><span class="koboSpan" id="kobo.31.2">Why exactly this is useful will become apparent shortly.</span></p><p><span class="koboSpan" id="kobo.32.1">Clearing these textures is just as simple as one might think:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">void Renderer::ClearCurrentTexture() { 
  if (!m_useShaders) { return; } 
  if (!m_currentTexture) { return; } 
  m_currentTexture-&gt;clear(); 
} 
 
void Renderer::ClearFinishedTexture() { 
  if (!m_useShaders) { return; } 
  auto texture = GetFinishedTexture(); 
  if (!texture) { return; } 
  texture-&gt;clear(); 
} 
 
void Renderer::ClearTextures() { 
  if (!m_useShaders) { return; } 
  m_texture1.clear(); 
  m_texture2.clear(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">In order to prepare for another render pass and display all the changes made to the first buffer, the textures must be swapped like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">void Renderer::SwapTextures() { 
  if (!m_useShaders) { return; } 
  if (m_currentTexture) { m_currentTexture-&gt;display(); } 
  if (m_currentTexture != &amp;m_texture1) { 
    m_currentTexture = &amp;m_texture1; 
  } else { 
    m_currentTexture = &amp;m_texture2; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">Note the call to the texture's </span><code class="literal"><span class="koboSpan" id="kobo.37.1">display</span></code><span class="koboSpan" id="kobo.38.1"> method. </span><span class="koboSpan" id="kobo.38.2">Calling </span><code class="literal"><span class="koboSpan" id="kobo.39.1">display</span></code><span class="koboSpan" id="kobo.40.1"> is required because we want all of the changes made to the texture to be reflected. </span><span class="koboSpan" id="kobo.40.2">Without calling this method, our progress would not manifest.</span></p><p><span class="koboSpan" id="kobo.41.1">Another key alteration to this class is making sure the buffer texture is being used while deferred rendering is enabled:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">void Renderer::Draw(const sf::Drawable&amp; l_drawable, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { 
    if (!m_deferred || !m_useShaders) { 
      l_target = m_window-&gt;GetRenderWindow(); 
    } else { l_target = m_currentTexture; } 
  } 
  sf::RenderStates states = sf::RenderStates::Default; 
  if (m_addBlend) { states.blendMode = sf::BlendAdd; } 
  if (m_useShaders &amp;&amp; m_currentShader) { 
    states.shader = m_currentShader; 
  } 
  l_target-&gt;draw(l_drawable, states); 
  ++m_drawCalls; 
} 
</span></pre><p><span class="koboSpan" id="kobo.43.1">After a couple of checks to make sure we're not overwriting an already provided render target and that the use of shaders is enabled, we select the buffer texture by overwriting the </span><code class="literal"><span class="koboSpan" id="kobo.44.1">l_target</span></code><span class="koboSpan" id="kobo.45.1"> pointer with its address.</span></p><p><span class="koboSpan" id="kobo.46.1">Finally, the buffer texture that has all of the render pass information can be drawn on the screen like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">void Renderer::DrawBufferTexture() { 
  if (!m_useShaders) { return; } 
  auto texture = GetFinishedTexture(); 
  if (!texture) { return; } 
  m_sprite.setTexture(texture-&gt;getTexture()); 
  Draw(m_sprite); 
} 
</span></pre><p><span class="koboSpan" id="kobo.48.1">This simple, yet powerful, design provides us with the possibilities of implementing almost any postprocessing effect imaginable.</span></p></div></div><div class="section" title="A minimal example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/><span class="koboSpan" id="kobo.49.1">A minimal example</span></h2></div></div></div><p><span class="koboSpan" id="kobo.50.1">One of the effects incidentally, the focus of this chapter is dynamic lighting. </span><span class="koboSpan" id="kobo.50.2">Before we go further and implement the more advanced features or delve into more complex concepts, let's walk through the process of using the newly implemented renderer features. </span><span class="koboSpan" id="kobo.50.3">Let's take one step at a time.</span></p><p><span class="koboSpan" id="kobo.51.1">First, the scene should be drawn to the texture buffer as usual:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">renderer-&gt;EnableDeferredRendering(); 
renderer-&gt;UseShader("default"); 
renderer-&gt;BeginSceneRendering(); 
 
for (unsigned int i = 0; i &lt; Sheet::Num_Layers; ++i) { 
  context-&gt;m_gameMap-&gt;Draw(i); 
  context-&gt;m_systemManager-&gt;Draw(window, i); 
  particles-&gt;Draw(window, i); 
} 
particles-&gt;Draw(window, -1); 
 
renderer-&gt;SwapTextures(); 
</span></pre><p><span class="koboSpan" id="kobo.53.1">As you can see, once deferred rendering is enabled, the default shader is used and the scene rendering process begins. </span><span class="koboSpan" id="kobo.53.2">For each layer, the map, entities, and particles are all drawn as usual. </span><span class="koboSpan" id="kobo.53.3">The only difference now is that the buffer texture is being used behind the scenes. </span><span class="koboSpan" id="kobo.53.4">Once everything is rendered, the textures are swapped; this allows the current back buffer texture to display all the changes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">renderer-&gt;BeginTextureRendering(); 
 
if(renderer-&gt;UseShader("LightPass")) { 
  auto shader = renderer-&gt;GetCurrentShader(); 
  auto time = context-&gt;m_gameMap-&gt;GetTimeNormal(); 
  shader-&gt;setUniform("AmbientLight", 
    sf::Glsl::Vec3(time, time, time)); 
  sf::Vector3f lightPos(700.f, 300.f, 10.f); 
  sf::Vector2i screenPos = window-&gt;GetRenderWindow()-&gt; 
    mapCoordsToPixel({ lightPos.x, lightPos.y }); 
  shader-&gt;setUniform("LightPosition", 
    sf::Glsl::Vec3(screenPos.x, window-&gt;GetWindowSize().y - 
    screenPos.y, lightPos.z)); 
  shader-&gt;setUniform("LightColor", 
    sf::Glsl::Vec3(0.1f, 0.1f, 0.1f)); 
  shader-&gt;setUniform("LightRadius", 128.f); 
 
  shader-&gt;setUniform("texture", 
    renderer-&gt;GetFinishedTexture()-&gt;getTexture()); 
 
  auto size = context-&gt;m_wind-&gt;GetWindowSize(); 
 
  sf::VertexArray vertices(sf::TrianglesStrip, 4); 
  vertices[0] = sf::Vertex(sf::Vector2f(0, 0), 
    sf::Vector2f(0,   1)); 
  vertices[1] = sf::Vertex(sf::Vector2f(size.x, 0), 
    sf::Vector2f(1, 1)); 
  vertices[2] = sf::Vertex(sf::Vector2f(0, size.y), 
    sf::Vector2f(0, 0)); 
  vertices[3] = sf::Vertex(sf::Vector2f(size), 
    sf::Vector2f(1, 0)); 
 
  renderer-&gt;Draw(vertices); 
  renderer-&gt;SwapTextures(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.55.1">Once the scene is rendered, we enter what from now on is going to be referred to as the light pass. </span><span class="koboSpan" id="kobo.55.2">This special pass uses its own shader and is responsible for the illumination of the scene. </span><span class="koboSpan" id="kobo.55.3">It sets up what is known as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.56.1">ambient light</span></em></span><span class="koboSpan" id="kobo.57.1"> as well as regular omnidirectional light.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/><span class="koboSpan" id="kobo.58.1">Note</span></h3><p><span class="strong"><strong><span class="koboSpan" id="kobo.59.1">Ambient light</span></strong></span><span class="koboSpan" id="kobo.60.1"> is a type of light that has no position. </span><span class="koboSpan" id="kobo.60.2">It illuminates any part of the scene evenly, regardless of the distance.</span></p></div></div><p><span class="koboSpan" id="kobo.61.1">As illustrated in the preceding code, the point light first has its world coordinates converted into screen-space coordinates, which are then passed as a uniform to the shader. </span><span class="koboSpan" id="kobo.61.2">Then, the light color and radius are passed to the shader along with the texture of the previous pass, which, in this case, is simply the color (diffuse) map of the scene.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/><span class="koboSpan" id="kobo.62.1">Note</span></h3><p><span class="strong"><strong><span class="koboSpan" id="kobo.63.1">Point light</span></strong></span><span class="koboSpan" id="kobo.64.1"> is a type of light that emits light in all directions (omnidirectional) from a single point, creating a sphere of illumination.</span></p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/><span class="koboSpan" id="kobo.65.1">Tip</span></h3><p><span class="koboSpan" id="kobo.66.1">The screen-space coordinate system has its </span><span class="emphasis"><em><span class="koboSpan" id="kobo.67.1">Y</span></em></span><span class="koboSpan" id="kobo.68.1"> axis inversed from the world coordinate format, meaning the positive </span><span class="emphasis"><em><span class="koboSpan" id="kobo.69.1">Y</span></em></span><span class="koboSpan" id="kobo.70.1"> values go up, not down. </span><span class="koboSpan" id="kobo.70.2">This is the reason the light position's </span><span class="emphasis"><em><span class="koboSpan" id="kobo.71.1">Y</span></em></span><span class="koboSpan" id="kobo.72.1"> coordinate has to be adjusted before it is passed to the shader.</span></p></div></div><p><span class="koboSpan" id="kobo.73.1">The next portion of the code is essentially meant to just trigger a full redraw of the diffuse texture onto the buffer texture. </span><span class="koboSpan" id="kobo.73.2">We're making a quad comprised of two triangular strips represented as </span><code class="literal"><span class="koboSpan" id="kobo.74.1">sf::VertexArray</span></code><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">It's made to be the size of the entire window so that all the pixels could surely be redrawn. </span><span class="koboSpan" id="kobo.75.3">Once the quad is drawn, the textures are once again swapped to reflect all the changes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.76.1">renderer-&gt;DisableDeferredRendering(); 
window-&gt;GetRenderWindow()-&gt;setView( 
  window-&gt;GetRenderWindow()-&gt;getDefaultView()); 
renderer-&gt;DrawBufferTexture(); 
window-&gt;GetRenderWindow()-&gt;setView(currentView); 
renderer-&gt;DisableShader(); 
</span></pre><p><span class="koboSpan" id="kobo.77.1">The last bit of this example simply turns off deferred rendering so that all render operations from now on are done to the window. </span><span class="koboSpan" id="kobo.77.2">The window view is then set to its default state, so that the buffer texture can be drawn onscreen easily. </span><span class="koboSpan" id="kobo.77.3">Finally, we reset the view back, shortly before whatever shader is still active is disabled.</span></p><div class="section" title="Shader code"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec15"/><span class="koboSpan" id="kobo.78.1">Shader code</span></h3></div></div></div><p><span class="koboSpan" id="kobo.79.1">We're almost done! </span><span class="koboSpan" id="kobo.79.2">The last, but definitely not the least, important piece of this puzzle is writing the lighting pass shader correctly in order to get proper results. </span><span class="koboSpan" id="kobo.79.3">Given what we already know about the light pass procedure in our C++ code, let's see what GLSL has to offer:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.80.1">uniform sampler2D texture; 
uniform vec3 AmbientLight; 
uniform vec3 LightPosition; 
uniform vec3 LightColor; 
uniform float LightRadius; 
 
void main() 
{ 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
 
  float dist = sqrt( 
    pow(LightPosition.x - gl_FragCoord.x, 2) + 
    pow(LightPosition.y - gl_FragCoord.y, 2) + 
    pow(LightPosition.z - gl_FragCoord.z, 2)); 
   
  vec4 finalPixel; 
   
  if(dist &lt;= LightRadius) 
    finalPixel = (gl_Color * pixel) + 
    (pixel * vec4(LightColor, 1.0)); 
  else 
    finalPixel = (gl_Color * pixel) * vec4(AmbientLight, 1.0); 
  gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.81.1">As expected, we need to process the diffuse texture in this pass in order to preserve color information. </span><span class="koboSpan" id="kobo.81.2">The other uniform values consist of a 3D vector that represents the ambient color, two 3D vectors for the position and color of a regular source of light, and a floating point value for the radius of the same light.</span></p><p><span class="koboSpan" id="kobo.82.1">The texture that was passed to the shader is sampled at the appropriate, interpolated texture coordinates and stored in the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">pixel</span></code><span class="koboSpan" id="kobo.84.1"> variable. </span><span class="koboSpan" id="kobo.84.2">The distance between the pixel being processed and the light's center is then calculated using the Pythagorean variant distance formula:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.85.1"><img src="graphics/B05590_08_01-1.jpg" alt="Shader code"/></span></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/><span class="koboSpan" id="kobo.86.1">Note</span></h3><p><span class="koboSpan" id="kobo.87.1">The </span><code class="literal"><span class="koboSpan" id="kobo.88.1">gl_FragCoord</span></code><span class="koboSpan" id="kobo.89.1"> parameter holds the pixel coordinates in the screen space. </span><span class="koboSpan" id="kobo.89.2">Its </span><span class="emphasis"><em><span class="koboSpan" id="kobo.90.1">Z</span></em></span><span class="koboSpan" id="kobo.91.1"> component is a depth value, which we're not going to use for the time being.</span></p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/><span class="koboSpan" id="kobo.92.1">Tip</span></h3><p><span class="koboSpan" id="kobo.93.1">The </span><code class="literal"><span class="koboSpan" id="kobo.94.1">pow</span></code><span class="koboSpan" id="kobo.95.1"> function simply returns a value that is raised to the power of its second argument.</span></p></div></div><p><span class="koboSpan" id="kobo.96.1">After the distance is calculated, a check is made to determine whether the distance between the light and the pixel we're working with is within the light's radius. </span><span class="koboSpan" id="kobo.96.2">If it is, the color information of our pixel is multiplied by the light color and added to the final pixel that's going to be written. </span><span class="koboSpan" id="kobo.96.3">Otherwise, the color information is simply multiplied by the ambient color.</span></p><p><span class="koboSpan" id="kobo.97.1">This fairly basic principle gives us, as one should expect, fairly basic and non-realistic lighting:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.98.1"><img src="graphics/image_08_002.jpg" alt="Shader code"/></span></div><p><span class="koboSpan" id="kobo.99.1">Although it works, in reality, light is emitted in all directions. </span><span class="koboSpan" id="kobo.99.2">It also slowly loses its brightness. </span><span class="koboSpan" id="kobo.99.3">Let's see what it takes to make this happen in our game.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Attenuating light"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/><span class="koboSpan" id="kobo.1.1">Attenuating light</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Light attenuation, also known as gradual loss in intensity, is what we're going to use when creating the effect of a light source that is slowly bleeding away. </span><span class="koboSpan" id="kobo.2.2">It essentially comes down to using yet another formula inside the light pass shader. </span><span class="koboSpan" id="kobo.2.3">There are many variations of attenuating light that work for different purposes. </span><span class="koboSpan" id="kobo.2.4">Let's take a look:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">uniform sampler2D texture; 
uniform vec3 AmbientLight; 
uniform vec3 LightPosition; 
uniform vec3 LightColor; 
uniform float LightRadius; 
uniform float LightFalloff; 
 
void main() 
{ 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
  // Nornalized light vector and distance to the light surface. 
  </span><span class="koboSpan" id="kobo.3.2">vec3 L = LightPosition - gl_FragCoord.xyz; 
  float distance = length(L); 
  float d = max(distance - LightRadius, 0); 
  L /= distance; 
  // calculate basic attenuation 
  float attenuation = 1 / pow(d/LightRadius + 1, 2); 
   
  attenuation = (attenuation - LightFalloff) / (1 - LightFalloff); 
  attenuation = max(attenuation, 0); 
   
  vec4 finalPixel = (gl_Color * pixel); 
  finalPixel *= vec4(AmbientLight, 1.0); // IF FIRST PASS ONLY! 
  </span><span class="koboSpan" id="kobo.3.3">finalPixel += (pixel * vec4(LightColor, 1.0) * attenuation); 
   
  gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.4.1">Once again, we're dealing with the same uniform values being passed in, but with one additional value of </span><code class="literal"><span class="koboSpan" id="kobo.5.1">LightFalloff</span></code><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">It's a factor between </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">0</span></em></span><span class="koboSpan" id="kobo.8.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">1</span></em></span><span class="koboSpan" id="kobo.10.1"> that determines how fast a source of light would lose its brightness.</span></p><p><span class="koboSpan" id="kobo.11.1">Inside the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">main()</span></code><span class="koboSpan" id="kobo.13.1"> function, the diffused pixel is sampled as usual. </span><span class="koboSpan" id="kobo.13.2">This is done before we calculate a vector </span><code class="literal"><span class="koboSpan" id="kobo.14.1">L</span></code><span class="koboSpan" id="kobo.15.1"> that represents the position difference between the pixel and the light's center. </span><span class="koboSpan" id="kobo.15.2">This vector is then converted into distance using the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">length</span></code><span class="koboSpan" id="kobo.17.1"> function. </span><span class="koboSpan" id="kobo.17.2">This is the same type of distance that we calculated manually in the first iteration of this shader. </span><span class="koboSpan" id="kobo.17.3">The floating number variable </span><code class="literal"><span class="koboSpan" id="kobo.18.1">d</span></code><span class="koboSpan" id="kobo.19.1"> is then used to calculate the distance between the fragment and the outside of the light by subtracting the light's radius from it. </span><span class="koboSpan" id="kobo.19.2">The </span><code class="literal"><span class="koboSpan" id="kobo.20.1">max()</span></code><span class="koboSpan" id="kobo.21.1"> function simply makes sure we don't get a negative value back if the pixel is inside the light's bubble.</span></p><p><span class="koboSpan" id="kobo.22.1">The attenuation itself, as mentioned before, can have many variations. </span><span class="koboSpan" id="kobo.22.2">This particular variation visually works best for the type of game we're dealing with.</span></p><p><span class="koboSpan" id="kobo.23.1">After the calculations are performed, the final output pixel is multiplied by the ambient light (which should only be done during the first pass if there are multiple light passes). </span><span class="koboSpan" id="kobo.23.2">Additionally, the light information is multiplied by the diffuse pixel and the attenuation factor is added to it. </span><span class="koboSpan" id="kobo.23.3">This last bit of multiplication ensures that, given the pixel is outside the effective light range, no additional light is added to it. </span><span class="koboSpan" id="kobo.23.4">The result of this is slightly more appealing to look at:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.24.1"><img src="graphics/image_08_003.jpg" alt="Attenuating light"/></span></div><p><span class="koboSpan" id="kobo.25.1">At this point, a very good question you could ask is 'How on earth is this going to work with multiple light input?' </span><span class="koboSpan" id="kobo.25.2">Luckily, this is a bit simpler than one might think.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Multi-pass shading"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/><span class="koboSpan" id="kobo.1.1">Multi-pass shading</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Much like </span><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">C/C++</span></em></span><span class="koboSpan" id="kobo.4.1"> code, GLSL does support the use of data arrays. </span><span class="koboSpan" id="kobo.4.2">Using them can seem like an obvious choice to just push information about multiple light streams into the shader and have it all done in one pass. </span><span class="koboSpan" id="kobo.4.3">Unlike </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">C++</span></em></span><span class="koboSpan" id="kobo.6.1">, however, GLSL needs to know the sizes of these arrays at compile time, which is very much like </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">C</span></em></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">At the time of writing, dynamic size arrays aren't supported. </span><span class="koboSpan" id="kobo.8.3">While this information can put a damper on a naive plan of handling multiple light sources with ease, there are still options to choose from, obviously.</span></p><p><span class="koboSpan" id="kobo.9.1">One approach to combat this may be to have a very large, statically sized array of data. </span><span class="koboSpan" id="kobo.9.2">Only some of that data would be filled in and the shader would process it by looping over the array while using a uniform integer that tells it how many lights were actually passed to it. </span><span class="koboSpan" id="kobo.9.3">This idea comes with a few obvious bottlenecks. </span><span class="koboSpan" id="kobo.9.4">First, there would be a threshold for the maximum number of light streams allowed on the screen. </span><span class="koboSpan" id="kobo.9.5">The second issue is performance. </span><span class="koboSpan" id="kobo.9.6">Sending data over to the GPU is costly and can quickly become inefficient if we send over too much information all at once.</span></p><p><span class="koboSpan" id="kobo.10.1">As flawed as the first idea is, it has one component that comes in handy when considering a better strategy: the maximum number of light streams allowed. </span><span class="koboSpan" id="kobo.10.2">Instead of pushing tons and tons of data through to the GPU at once, why not just do it a little bit at a time in different passes. </span><span class="koboSpan" id="kobo.10.3">If the right number of light streams is sent each time, both the CPU and GPU performance bottlenecks can be minimized. </span><span class="koboSpan" id="kobo.10.4">The results of each pass can then be blended together into a single texture.</span></p><div class="section" title="Modifying the light pass shader"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec77"/><span class="koboSpan" id="kobo.11.1">Modifying the light pass shader</span></h2></div></div></div><p><span class="koboSpan" id="kobo.12.1">There are a couple of challenges we need to overcome in order to correctly blend the buffer textures of multiple passes. </span><span class="koboSpan" id="kobo.12.2">First, there's loss of information due to ambient lighting. </span><span class="koboSpan" id="kobo.12.3">If the light is too dark, every subsequent pass becomes less and less visible. </span><span class="koboSpan" id="kobo.12.4">To fix this problem, in addition to the color information of the last render pass, we're going to need access to the actual diffuse map.</span></p><p><span class="koboSpan" id="kobo.13.1">The second issue is choosing the right number of light streams per shader pass. </span><span class="koboSpan" id="kobo.13.2">This can be benchmarked or simply gotten right through trial and error. </span><span class="koboSpan" id="kobo.13.3">For our purposes, we'll go with 3-4 light streams per pass. </span><span class="koboSpan" id="kobo.13.4">Let's take a look at how the light shader can be modified to achieve this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">uniform sampler2D LastPass; 
uniform sampler2D DiffuseMap; 
uniform vec3 AmbientLight; 
uniform int LightCount; 
uniform int PassNumber; 
 
struct LightInfo { 
  vec3 position; 
  vec3 color; 
  float radius; 
  float falloff; 
}; 
 
const int MaxLights = 3; 
uniform LightInfo Lights[MaxLights]; 
</span></pre><p><span class="koboSpan" id="kobo.15.1">First, note the new </span><code class="literal"><span class="koboSpan" id="kobo.16.1">sampler2D</span></code><span class="koboSpan" id="kobo.17.1"> uniform type being passed in for the diffuse map. </span><span class="koboSpan" id="kobo.17.2">This is going to be invaluable in order to avoid light colors from being washed out with additional passes. </span><span class="koboSpan" id="kobo.17.3">The other two bits of additional information we're going to need are values that determine the number of light streams that have been sent to the shader for the current pass and the pass we're dealing with at the moment.</span></p><p><span class="koboSpan" id="kobo.18.1">The actual light information is now neatly stored away in a </span><code class="literal"><span class="koboSpan" id="kobo.19.1">struct</span></code><span class="koboSpan" id="kobo.20.1"> that holds the usual data we expect. </span><span class="koboSpan" id="kobo.20.2">Underneath it, we need to declare a constant integer for the number of maximum light streams per shader pass and the uniform array that's going to be filled in by our C++ code for the light information.</span></p><p><span class="koboSpan" id="kobo.21.1">Let's see the changes that the body of the shader needs to undergo in order to support this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void main() 
{ 
  vec4 pixel = texture2D(LastPass, gl_TexCoord[0].xy); 
  vec4 diffusepixel = texture2D(DiffuseMap, gl_TexCoord[0].xy); 
  vec4 finalPixel = gl_Color * pixel; 
  if(PassNumber == 1) { finalPixel *= vec4(AmbientLight, 1.0); } 
  // IF FIRST PASS ONLY! 
  </span><span class="koboSpan" id="kobo.22.2">for(int i = 0; i &lt; LightCount; ++i) { 
     vec3 L = Lights[i].position - gl_FragCoord.xyz; 
     float distance = length(L); 
     float d = max(distance - Lights[i].radius, 0); 
     L /= distance; 
     float attenuation = 1 / pow(d/Lights[i].radius + 1, 2); 
     attenuation = (attenuation - Lights[i].falloff) / 
       (1 - Lights[i].falloff); 
     attenuation = max(attenuation, 0); 
     finalPixel += diffusepixel * 
       ((vec4(Lights[i].color, 1.0) * attenuation)); 
  } 
  gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">First, we need to sample the diffuse pixel as well as the pixel from the previous shader pass. </span><span class="koboSpan" id="kobo.23.2">The </span><code class="literal"><span class="koboSpan" id="kobo.24.1">finalPixel</span></code><span class="koboSpan" id="kobo.25.1"> variable is established early on and uses the information from the previous shader pass. </span><span class="koboSpan" id="kobo.25.2">It is important you note this, because the previous pass would be lost otherwise. </span><span class="koboSpan" id="kobo.25.3">Since we have access to the pass number in the shader now, we can selectively apply the ambient light to the pixel only during the first pass.</span></p><p><span class="koboSpan" id="kobo.26.1">We can then jump into a </span><code class="literal"><span class="koboSpan" id="kobo.27.1">for</span></code><span class="koboSpan" id="kobo.28.1"> loop that uses the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">LightCount</span></code><span class="koboSpan" id="kobo.30.1"> uniform passed in from the C++ side. </span><span class="koboSpan" id="kobo.30.2">This design gives us control to only use as much data as was sent to the shader and not go overboard if the last shader pass has fewer light streams than the maximum number allowed.</span></p><p><span class="koboSpan" id="kobo.31.1">Finally, let's see what needs to change when it comes to the actual shading of the fragment. </span><span class="koboSpan" id="kobo.31.2">All our calculations remain the same, except for using light data. </span><span class="koboSpan" id="kobo.31.3">The lights uniform is now accessed with the square brackets to fetch the correct information during each iteration of the loop. </span><span class="koboSpan" id="kobo.31.4">Note the final pixel calculation at the very bottom of the loop. </span><span class="koboSpan" id="kobo.31.5">It now uses the diffuse pixel instead of the pixel of a previous shader pass.</span></p></div><div class="section" title="Changes in the C++ code"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec78"/><span class="koboSpan" id="kobo.32.1">Changes in the C++ code</span></h2></div></div></div><p><span class="koboSpan" id="kobo.33.1">None of the fanciness in the GLSL we've just finished is complete without appropriate support from our actual code base. </span><span class="koboSpan" id="kobo.33.2">First, let's start with something simple and conveniently represent a light stream in a proper </span><code class="literal"><span class="koboSpan" id="kobo.34.1">struct</span></code><span class="koboSpan" id="kobo.35.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.36.1">struct LightBase { 
  LightBase(const sf::Vector3f&amp; l_pos, 
    const sf::Vector3f&amp; l_color, float l_rad, float l_fall) 
    : m_lightPos(l_pos), m_lightColor(l_color), m_radius(l_rad), 
    m_falloff(l_fall) {} 
  LightBase(const sf::Vector3f&amp; l_color): m_lightColor(l_color) {} 
  sf::Vector3f m_lightPos; 
  sf::Vector3f m_lightColor; 
  float m_radius; 
  float m_falloff; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.37.1">That's better! </span><span class="koboSpan" id="kobo.37.2">Now let's begin passing in all of the additional information to the shader itself:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">... </span><span class="koboSpan" id="kobo.38.2">// Diffuse pass. 
</span><span class="koboSpan" id="kobo.38.3">renderer-&gt;SwapTextures(); 
auto DiffuseImage = renderer-&gt;GetFinishedTexture()-&gt; 
  getTexture().copyToImage(); 
DiffuseImage.flipVertically(); 
auto DiffuseTexture = sf::Texture(); 
DiffuseTexture.loadFromImage(DiffuseImage); 
renderer-&gt;BeginTextureRendering(); 
... 
</span><span class="koboSpan" id="kobo.38.4">std::vector&lt;LightBase&gt; lights; 
// {Position}, {Color}, Radius, Falloff 
lights.push_back({ { 700.f, 350.f, 10.f }, { 1.f, 0.f, 0.f }, 
  128.f, 0.005f }); 
lights.push_back({ { 600.f, 350.f, 10.f }, { 0.f, 1.f, 0.f }, 
  128.f, 0.005f }); 
lights.push_back({ { 500.f, 350.f, 10.f }, { 0.f, 0.f, 1.f }, 
  128.f, 0.005f }); 
lights.push_back({ { 400.f, 600.f, 10.f },{ 1.f, 0.f, 0.f }, 
  128.f, 0.005f }); 
lights.push_back({ { 300.f, 600.f, 10.f },{ 0.f, 1.f, 0.f }, 
  128.f, 0.005f }); 
lights.push_back({ { 200.f, 600.f, 10.f },{ 0.f, 0.f, 1.f }, 
  128.f, 0.005f }); 
lights.push_back({ { 600.f, 550.f, 0.f }, { 1.f, 1.f, 1.f }, 
  128.f, 0.005f }); 
 
const int LightsPerPass = 3; 
</span></pre><p><span class="koboSpan" id="kobo.39.1">Right after we're done with drawing onto the diffuse texture, it's copied over and stored in a separate buffer. </span><span class="koboSpan" id="kobo.39.2">It's then flipped along the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.40.1">Y</span></em></span><span class="koboSpan" id="kobo.41.1"> axis, as the copying process inverts it.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/><span class="koboSpan" id="kobo.42.1">Tip</span></h3><p><span class="koboSpan" id="kobo.43.1">The copying and flipping of the texture here is a proof of concept. </span><span class="koboSpan" id="kobo.43.2">It shouldn't be performed in production code, as it's highly inefficient.</span></p></div></div><p><span class="koboSpan" id="kobo.44.1">At this point, we're ready to begin the light pass. </span><span class="koboSpan" id="kobo.44.2">Just before we start this, ensure that a couple of light streams are added to </span><code class="literal"><span class="koboSpan" id="kobo.45.1">std::vector</span></code><span class="koboSpan" id="kobo.46.1"> and are waiting to be passed in. </span><span class="koboSpan" id="kobo.46.2">Also, declare a constant at the very bottom that denotes how many light streams are supposed to be passed to a shader every time. </span><span class="koboSpan" id="kobo.46.3">This number has to match the constant inside the shader.</span></p><p><span class="koboSpan" id="kobo.47.1">Let's begin with the actual light pass and see what it involves:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">if (renderer-&gt;UseShader("LightPass")) { 
  renderer-&gt;BeginTextureRendering(); 
  auto shader = renderer-&gt;GetCurrentShader(); 
  shader-&gt;setUniform("AmbientLight", 
    sf::Glsl::Vec3(0.f, 0.f, 0.2f)); 
  int i = 0; 
  int pass = 0; 
  auto lightCount = lights.size(); 
  for (auto&amp; light : lights) { 
    std::string id = "Lights[" + std::to_string(i) + "]"; 
    sf::Vector2i screenPos = window-&gt;GetRenderWindow()-&gt; 
      mapCoordsToPixel({light.m_lightPos.x, light.m_lightPos.y}); 
    shader-&gt;setUniform(id + ".position", sf::Glsl::Vec3( 
      screenPos.x, window-&gt;GetWindowSize().y - screenPos.y, 
      light.m_lightPos.z)); 
    shader-&gt;setUniform(id + ".color", 
      sf::Glsl::Vec3(light.m_lightColor)); 
    shader-&gt;setUniform(id + ".radius", light.m_radius); 
    shader-&gt;setUniform(id + ".falloff", light.m_falloff); 
    ++i; 
    if (i &lt; LightsPerPass &amp;&amp; (pass * LightsPerPass) + i 
      &lt; lightCount) 
    { continue; } 
    shader-&gt;setUniform("LightCount", i); 
    i = 0; 
    shader-&gt;setUniform("PassNumber", pass + 1); 
    shader-&gt;setUniform("LastPass", 
      renderer-&gt;GetFinishedTexture()-&gt;getTexture()); 
    shader-&gt;setUniform("DiffuseMap", DiffuseTexture); 
    renderer-&gt;Draw(vertices); 
    renderer-&gt;SwapTextures(); 
    renderer-&gt;BeginTextureRendering(); 
    ++pass; 
  } 
} 
... 
</span></pre><p><span class="koboSpan" id="kobo.49.1">Ambient lighting is first set up, as it's not going to change between the iterations. </span><span class="koboSpan" id="kobo.49.2">In this case, we're giving it a slight blue tint. </span><span class="koboSpan" id="kobo.49.3">Additionally, a couple of local variables for the iteration and pass are created in order to have this information handy.</span></p><p><span class="koboSpan" id="kobo.50.1">As we're iterating over each light stream, a string called </span><code class="literal"><span class="koboSpan" id="kobo.51.1">id</span></code><span class="koboSpan" id="kobo.52.1"> is created with the integer of each iteration passed inside. </span><span class="koboSpan" id="kobo.52.2">This is meant to represent the array access analysis of the light streams' uniform inside the shader, and it will serve as a helpful way of allowing us to access and overwrite that data. </span><span class="koboSpan" id="kobo.52.3">The light information is then passed in using the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">id</span></code><span class="koboSpan" id="kobo.54.1"> string with an attached dot operator and the name of the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">struct</span></code><span class="koboSpan" id="kobo.56.1"> data member. </span><span class="koboSpan" id="kobo.56.2">The light's identifier </span><code class="literal"><span class="koboSpan" id="kobo.57.1">i</span></code><span class="koboSpan" id="kobo.58.1"> is incremented shortly after. </span><span class="koboSpan" id="kobo.58.2">At this point, we need to decide whether the required number of light streams have been processed in order to invoke the shader. </span><span class="koboSpan" id="kobo.58.3">If the last light stream for the pass has been added, or if we're dealing with the last light stream of the scene, the rest of the uniforms are initialized and the fullscreen </span><code class="literal"><span class="koboSpan" id="kobo.59.1">sf::VertexArray</span></code><span class="koboSpan" id="kobo.60.1"> quad we talked about earlier is drawn, invoking a shader for each visible pixel. </span><span class="koboSpan" id="kobo.60.2">This effectively gives us a result like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.61.1"><img src="graphics/image_08_004.jpg" alt="Changes in the C++ code"/></span></div><p><span class="koboSpan" id="kobo.62.1">Now we're getting somewhere! </span><span class="koboSpan" id="kobo.62.2">The only downside to this is all of the mess we have to deal with in our C++ code, as none of this data is managed properly. </span><span class="koboSpan" id="kobo.62.3">Let's fix this now!</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Managing light input"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/><span class="koboSpan" id="kobo.1.1">Managing light input</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Good data organization is important in every aspect of software design. </span><span class="koboSpan" id="kobo.2.2">It's hard to imagine an application that would run quickly and efficiently, yet wants have a strong, powerful, and flexible framework running in the backend. </span><span class="koboSpan" id="kobo.2.3">Our situation up until this point has been fairly manageable, but imagine you want to draw additional textures for the map, entities, and all your particles. </span><span class="koboSpan" id="kobo.2.4">This would quickly become tiresome to deal with and maintain. </span><span class="koboSpan" id="kobo.2.5">It's time to utilize our engineering ingenuity and come up with a better system.</span></p><div class="section" title="Interface for light users"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec79"/><span class="koboSpan" id="kobo.3.1">Interface for light users</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">First and foremost, each class that desires to use our lighting engine would need to implement their own version of drawing certain types of textures to the buffer(s). </span><span class="koboSpan" id="kobo.4.2">For diffuse maps, we already have the plain old regular </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Draw</span></code><span class="koboSpan" id="kobo.6.1"> calls, but even if they are all lucky enough to have the same signature, that's not good enough. </span><span class="koboSpan" id="kobo.6.2">A common interface for these classes is needed in order to make them a successful part of the lighting family:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class LightManager; 
class Window; 
 
class LightUser { 
  friend class LightManager; 
  virtual void Draw(MaterialMapContainer&amp; l_materials, 
    Window&amp; l_window, int l_layer) = 0; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">The </span><code class="literal"><span class="koboSpan" id="kobo.9.1">LightUser</span></code><span class="koboSpan" id="kobo.10.1"> class forces any derivatives to implement a special </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Draw</span></code><span class="koboSpan" id="kobo.12.1"> method that uses a material container. </span><span class="koboSpan" id="kobo.12.2">It also has access to the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Window</span></code><span class="koboSpan" id="kobo.14.1"> class and knows which layer it's trying to draw to. </span><span class="koboSpan" id="kobo.14.2">'What's a material container?' </span><span class="koboSpan" id="kobo.14.3">you may ask? </span><span class="koboSpan" id="kobo.14.4">Let's find out by taking this design further.</span></p></div><div class="section" title="The light manager class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec80"/><span class="koboSpan" id="kobo.15.1">The light manager class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">Before we design a grand class that would take care of all our lighting needs, let's talk about materials. </span><span class="koboSpan" id="kobo.16.2">As it so happens, we've already dealt with one type of material: the diffuse map. </span><span class="koboSpan" id="kobo.16.3">There are many other possible materials we're going to work with, so let's not beat around the bush any longer and see what they are:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">enum class MaterialMapType { Diffuse, Height, Normal, 
  Specular, COUNT }; 
using MaterialMapContainer = std::unordered_map&lt; 
  MaterialMapType, std::unique_ptr&lt;sf::RenderTexture&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.18.1">In addition to diffuse maps, we're going to build </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">height</span></em></span><span class="koboSpan" id="kobo.20.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.21.1">normal</span></em></span><span class="koboSpan" id="kobo.22.1">, and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.23.1">specular</span></em></span><span class="koboSpan" id="kobo.24.1"> maps as well. </span><span class="koboSpan" id="kobo.24.2">None of these terms will probably make sense right now, but that's alright. </span><span class="koboSpan" id="kobo.24.3">Each one will be explained in detail as we cross that bridge.</span></p><p><span class="koboSpan" id="kobo.25.1">The material map container type is simply a map that links a type to a </span><code class="literal"><span class="koboSpan" id="kobo.26.1">sf::RenderTexture</span></code><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">This way, we can have a separate texture for each material type.</span></p><p><span class="koboSpan" id="kobo.28.1">For the light manager, we're only going to need two type definitions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">using LightContainer = std::vector&lt;LightBase&gt;; 
using LightUserContainer = std::vector&lt;LightUser*&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.30.1">As you can see, they're extremely simple. </span><span class="koboSpan" id="kobo.30.2">We're going to store the light streams themselves along with pointers to the light user classes in vectors, as nothing fancier is necessary here. </span><span class="koboSpan" id="kobo.30.3">With that, let's take a look at the actual definition of the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">LightManager</span></code><span class="koboSpan" id="kobo.32.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">class Window; 
 
class LightManager { 
public: 
  LightManager(Window* l_window); 
 
  void AddLight(const LightBase&amp; l_light); 
  void AddLightUser(LightUser* l_user); 
  LightBase* GetAmbientLight(); 
 
  void RenderMaterials(); 
  void RenderScene(); 
 
  const unsigned int LightsPerPass = 4; 
protected: 
  MaterialMapContainer m_materialMaps; 
private: 
  void ClearAll(); 
  void SetViews(); 
  void DisplayAll(); 
  LightBase m_ambientLight; 
  LightContainer m_lights; 
  LightUserContainer m_users; 
 
  sf::VertexArray m_fullScreenQuad; 
 
  Window* m_window; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.34.1">As you can see, this is as basic as it can be. </span><span class="koboSpan" id="kobo.34.2">The constructor takes in a pointer to the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">Window</span></code><span class="koboSpan" id="kobo.36.1"> class. </span><span class="koboSpan" id="kobo.36.2">We have a couple of </span><code class="literal"><span class="koboSpan" id="kobo.37.1">add</span></code><span class="koboSpan" id="kobo.38.1">methods for the light users, as well as the light streams themselves. </span><span class="koboSpan" id="kobo.38.2">We also have a few render methods for specific tasks. </span><span class="koboSpan" id="kobo.38.3">Note the constant integer that this class defines for the maximum number of light streams allowed per shader pass. </span><span class="koboSpan" id="kobo.38.4">Rendering only three light streams like we did before is a bit wasteful, so this can be upped even more, provided it doesn't become detrimental to the performance of the process.</span></p><p><span class="koboSpan" id="kobo.39.1">The helper methods of which there are three--deal with clearing the buffer textures, setting their views, and displaying the changes made to them. </span><span class="koboSpan" id="kobo.39.2">We also store the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">sf::VertexArray</span></code><span class="koboSpan" id="kobo.41.1"> of the quad that we're going to use to perform a light pass operation.</span></p><div class="section" title="Implementing the light manager"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec16"/><span class="koboSpan" id="kobo.42.1">Implementing the light manager</span></h3></div></div></div><p><span class="koboSpan" id="kobo.43.1">As always, let's begin by seeing what needs to be constructed when the light manager is created:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.44.1">LightManager::LightManager(Window* l_window) : m_window(l_window), 
  m_ambientLight({ 0.f, 0.f, 0.f }) 
{ 
  auto windowSize = l_window-&gt;GetWindowSize(); 
  for (auto i = 0; 
    i &lt; static_cast&lt;int&gt;(MaterialMapType::COUNT); ++i) 
  { 
    auto pair = m_materialMaps.emplace( 
      static_cast&lt;MaterialMapType&gt;(i), 
      std::move(std::make_unique&lt;sf::RenderTexture&gt;())); 
    auto&amp; texture = pair.first-&gt;second; 
    texture-&gt;create(windowSize.x, windowSize.y); 
  } 
 
  m_fullScreenQuad = sf::VertexArray(sf::TriangleStrip, 4); 
 
  m_fullScreenQuad[0] = sf::Vertex( 
    sf::Vector2f(0, 0), sf::Vector2f(0, 1)); 
  m_fullScreenQuad[1] = sf::Vertex( 
    sf::Vector2f(windowSize.x, 0), sf::Vector2f(1, 1)); 
  m_fullScreenQuad[2] = sf::Vertex( 
    sf::Vector2f(0, windowSize.y), sf::Vector2f(0, 0)); 
  m_fullScreenQuad[3] = sf::Vertex( 
    sf::Vector2f(windowSize), sf::Vector2f(1, 0)); 
} 
</span></pre><p><span class="koboSpan" id="kobo.45.1">The initializer list is useful for storing the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">Window</span></code><span class="koboSpan" id="kobo.47.1"> pointer, as well as initializing the ambient lighting to absolute black. </span><span class="koboSpan" id="kobo.47.2">Once this is done, the window size is obtained and all the material textures are created. </span><span class="koboSpan" id="kobo.47.3">Lastly, the window-sized quad is set up for later use.</span></p><p><span class="koboSpan" id="kobo.48.1">The adder and getter methods are quite simple, yet they are necessary:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">void LightManager::AddLight(const LightBase&amp; l_light) { 
  m_lights.push_back(l_light); 
} 
void LightManager::AddLightUser(LightUser* l_user) { 
  m_users.emplace_back(l_user); 
} 
LightBase* LightManager::GetAmbientLight() { 
  return &amp;m_ambientLight; 
} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">Dealing with material maps all at once can be quite wasteful typing-wise, so we need a few methods to help us do this quickly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">void LightManager::ClearAll() { 
  for (auto&amp; map : m_materialMaps) { map.second-&gt;clear(); } 
} 
 
void LightManager::SetViews() { 
  auto view = m_window-&gt;GetRenderWindow()-&gt;getView(); 
  for (auto&amp; map : m_materialMaps) { map.second-&gt;setView(view); } 
} 
 
void LightManager::DisplayAll() { 
  for (auto&amp; map : m_materialMaps) { map.second-&gt;display(); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">Note the view we're using in </span><code class="literal"><span class="koboSpan" id="kobo.53.1">SetViews()</span></code><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">Since these material maps are going to be used instead of the window, they must use the window's view in order to handle the world coordinates of all the visuals being drawn.</span></p><p><span class="koboSpan" id="kobo.55.1">Speaking of material maps, every class that wishes to use our light manager should be able to draw to every single one of them. </span><span class="koboSpan" id="kobo.55.2">Luckily, we've made it easier on ourselves by making it a requirement that these classes implement a purely virtual </span><code class="literal"><span class="koboSpan" id="kobo.56.1">Draw</span></code><span class="koboSpan" id="kobo.57.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.58.1">void LightManager::RenderMaterials() { 
  ClearAll(); 
  SetViews(); 
  // Render each elevation in proper order. 
  </span><span class="koboSpan" id="kobo.58.2">for (auto i = 0; i &lt; Sheet::Num_Layers; ++i) { 
    for (auto&amp; user : m_users) { 
      user-&gt;Draw(m_materialMaps, *m_window, i); 
    } 
  } 
  // Render everything above allowed height. 
  </span><span class="koboSpan" id="kobo.58.3">for (auto&amp; user : m_users) { 
    user-&gt;Draw(m_materialMaps, *m_window, -1); 
  } 
  DisplayAll(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.59.1">After all the textures are cleared and their views are set, each light user needs to draw something for each of the allowed layers our game engine supports. </span><span class="koboSpan" id="kobo.59.2">Quite literally, on top of this, any visuals that are above these elevations also need to have a chance to be rendered, which we can achieve by using the second loop. </span><span class="koboSpan" id="kobo.59.3">All the material textures are then updated by invoking the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">DisplayAll()</span></code><span class="koboSpan" id="kobo.61.1"> method.</span></p><p><span class="koboSpan" id="kobo.62.1">Once the materials are drawn, we need to go through the same process of multi-pass shading as we did in our minimal code example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.63.1">void LightManager::RenderScene() { 
  auto renderer = m_window-&gt;GetRenderer(); 
  auto window = m_window-&gt;GetRenderWindow(); 
  auto size = window-&gt;getSize(); 
  auto currentView = window-&gt;getView(); 
 
  renderer-&gt;EnableDeferredRendering(); 
 
  if (renderer-&gt;UseShader("LightPass")) { 
    // Light pass. 
    </span><span class="koboSpan" id="kobo.63.2">auto shader = renderer-&gt;GetCurrentShader(); 
    shader-&gt;setUniform("AmbientLight", 
      sf::Glsl::Vec3(m_ambientLight.m_lightColor)); 
    shader-&gt;setUniform("DiffuseMap", 
      m_materialMaps[MaterialMapType::Diffuse]-&gt;getTexture()); 
    ... 
    </span><span class="koboSpan" id="kobo.63.3">int LightID = 0; 
    int pass = 0; 
    for (auto&amp; light : m_lights) { 
      std::string id = "Lights[" + std::to_string(LightID) + "]"; 
      sf::Vector2i screenPos = window-&gt;mapCoordsToPixel( 
        { light.m_lightPos.x, light.m_lightPos.y }, currentView); 
      float y = static_cast&lt;float&gt;( 
        static_cast&lt;int&gt;(size.y) - screenPos.y); 
      shader-&gt;setUniform(id + ".position", 
        sf::Glsl::Vec3(screenPos.x, y, light.m_lightPos.z)); 
      shader-&gt;setUniform(id + ".color", 
        sf::Glsl::Vec3(light.m_lightColor)); 
      shader-&gt;setUniform(id + ".radius", light.m_radius); 
      shader-&gt;setUniform(id + ".falloff", light.m_falloff); 
      ++LightID; 
      if (LightID &lt; LightsPerPass &amp;&amp; (pass * LightsPerPass) 
        + LightID &lt; m_lights.size()) 
      { continue; } 
      renderer-&gt;BeginTextureRendering(); 
      shader-&gt;setUniform("LightCount", LightID); 
      LightID = 0; 
      shader-&gt;setUniform("PassNumber", pass + 1); 
      if (pass == 0) { 
        shader-&gt;setUniform("LastPass", 
          m_materialMaps[MaterialMapType::Diffuse]-&gt;getTexture()); 
      } else { 
        shader-&gt;setUniform("LastPass", 
          renderer-&gt;GetFinishedTexture()-&gt;getTexture()); 
      } 
      renderer-&gt;Draw(m_fullScreenQuad); 
      renderer-&gt;SwapTextures(); 
      ++pass; 
    } 
  } 
   
  renderer-&gt;DisableDeferredRendering(); 
  renderer-&gt;DisableShader(); 
  window-&gt;setView(window-&gt;getDefaultView()); 
  renderer-&gt;DrawBufferTexture(); 
  window-&gt;setView(currentView); 
} 
</span></pre><p><span class="koboSpan" id="kobo.64.1">This is very close to the already established model we discussed before. </span><span class="koboSpan" id="kobo.64.2">A couple of changes to note here are: the use of an internal data member called </span><code class="literal"><span class="koboSpan" id="kobo.65.1">m_materialMaps</span></code><span class="koboSpan" id="kobo.66.1"> for passing material information to the light pass shader and the check near the bottom where the diffuse texture is passed in as the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">"LastPass"</span></code><span class="koboSpan" id="kobo.68.1"> uniform if it is the very first shader pass. </span><span class="koboSpan" id="kobo.68.2">This has to be done otherwise we'd be sampling a completely black texture.</span></p></div><div class="section" title="Integrating the light manager class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec17"/><span class="koboSpan" id="kobo.69.1">Integrating the light manager class</span></h3></div></div></div><p><span class="koboSpan" id="kobo.70.1">Once the light manager is implemented, we can add all the classes that use it to its list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.71.1">State_Game::State_Game(StateManager* l_stateManager) 
  : BaseState(l_stateManager), 
    m_lightManager(l_stateManager-&gt;GetContext()-&gt;m_wind) 
{ 
  auto context = m_stateMgr-&gt;GetContext(); 
  m_lightManager.AddLightUser(context-&gt;m_gameMap); 
  m_lightManager.AddLightUser(context-&gt;m_systemManager); 
  m_lightManager.AddLightUser(context-&gt;m_particles); 
} 
</span></pre><p><span class="koboSpan" id="kobo.72.1">In this case, we're only working with the game map, the system manager, and the particle manager classes as light users.</span></p><p><span class="koboSpan" id="kobo.73.1">Setting up our previous light information is equally as easy now as it was before:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.74.1">void State_Game::OnCreate() { 
  ... 
  </span><span class="koboSpan" id="kobo.74.2">m_lightManager.GetAmbientLight()-&gt;m_lightColor = 
    sf::Vector3f(0.2f, 0.2f, 0.2f); 
  m_lightManager.AddLight({ { 700.f, 350.f, 32.f }, 
    { 1.f, 0.f, 0.f }, 128.f, 0.005f }); 
  m_lightManager.AddLight({ { 600.f, 350.f, 32.f }, 
    { 0.f, 1.f, 0.f }, 128.f, 0.005f }); 
  m_lightManager.AddLight({ { 500.f, 350.f, 32.f }, 
    { 0.f, 0.f, 1.f }, 128.f, 0.005f }); 
  m_lightManager.AddLight({ { 400.f, 600.f, 32.f }, 
    { 1.f, 0.f, 0.f }, 128.f, 0.005f }); 
  m_lightManager.AddLight({ { 300.f, 600.f, 32.f }, 
    { 0.f, 1.f, 0.f }, 128.f, 0.005f }); 
  m_lightManager.AddLight({ { 200.f, 600.f, 32.f }, 
    { 0.f, 0.f, 1.f }, 128.f, 0.005f }); 
  m_lightManager.AddLight({ { 600.f, 550.f, 33.f }, 
    { 1.f, 1.f, 1.f }, 128.f, 0.01f }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.75.1">Finally, we just need to make sure the material maps are drawn, just like the scene itself:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.76.1">void State_Game::Draw() { 
  m_lightManager.RenderMaterials(); 
  m_lightManager.RenderScene(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.77.1">Now, the only thing left to do is to adapt those pesky classes to the new lighting model we have set up here.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Adapting classes to use lights"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/><span class="koboSpan" id="kobo.1.1">Adapting classes to use lights</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Obviously, each and every single class that does any rendering in our game does it differently. </span><span class="koboSpan" id="kobo.2.2">Rendering the same graphics to different types of material maps is no exception to this rule. </span><span class="koboSpan" id="kobo.2.3">Let's see how every light-supporting class should implement their respective </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Draw</span></code><span class="koboSpan" id="kobo.4.1"> methods in order to stay in sync with our lighting system.</span></p><div class="section" title="The Map class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec81"/><span class="koboSpan" id="kobo.5.1">The Map class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">The first class we need to deal with is the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Map</span></code><span class="koboSpan" id="kobo.8.1"> class. </span><span class="koboSpan" id="kobo.8.2">It will be a bit different due to the way it handles the drawing of tiles. </span><span class="koboSpan" id="kobo.8.3">So let's take a look at what needs to be added in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">class Map : ..., public LightUser { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.9.2">void Draw(MaterialMapContainer&amp; l_materials, 
    Window&amp; l_window, int l_layer); 
protected: 
  ... 
  </span><span class="koboSpan" id="kobo.9.3">Void CheckTextureSizes(int l_fromZ, int l_toZ); 
  std::array&lt;sf::RenderTexture, Sheet::Num_Layers&gt; m_textures; 
  ... 
</span><span class="koboSpan" id="kobo.9.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">So far, so good! </span><span class="koboSpan" id="kobo.10.2">The </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Map</span></code><span class="koboSpan" id="kobo.12.1"> class is now using the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">LightUser</span></code><span class="koboSpan" id="kobo.14.1"> interface. </span><span class="koboSpan" id="kobo.14.2">The </span><code class="literal"><span class="koboSpan" id="kobo.15.1">m_textures</span></code><span class="koboSpan" id="kobo.16.1"> data member is an established array that existed before all of this and it simply stores different textures for each supported elevation. </span><span class="koboSpan" id="kobo.16.2">One new protected member function is added though, called </span><code class="literal"><span class="koboSpan" id="kobo.17.1">CheckTextureSizes</span></code><span class="koboSpan" id="kobo.18.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">void Map::CheckTextureSizes(int l_fromZ, int l_toZ) { 
  auto realMapSize = m_tileMap.GetMapSize() * 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  for (auto layer = l_fromZ; layer &lt;= l_toZ; ++layer) { 
    if (m_textures[layer].getSize() != realMapSize) { 
      ... </span><span class="koboSpan" id="kobo.19.2">// Information printed to the console. 
      </span><span class="koboSpan" id="kobo.19.3">if (!m_textures[layer].create(realMapSize.x, realMapSize.y)) 
      { ... </span><span class="koboSpan" id="kobo.19.4">} // Error message. 
    </span><span class="koboSpan" id="kobo.19.5">} 
    ... </span><span class="koboSpan" id="kobo.19.6">// Other textures. 
  </span><span class="koboSpan" id="kobo.19.7">} 
} 
</span></pre><p><span class="koboSpan" id="kobo.20.1">This is just a handy way of making sure all the future textures, as well as the current diffuse maps, have the appropriate size.</span></p><p><span class="koboSpan" id="kobo.21.1">Let's see what the </span><code class="literal"><span class="koboSpan" id="kobo.22.1">Redraw</span></code><span class="koboSpan" id="kobo.23.1"> method now needs to do in order to fully support the light manager:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">void Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { 
  ... 
  </span><span class="koboSpan" id="kobo.24.2">CheckTextureSizes(l_from.z, l_to.z); 
  ClearMapTexture(l_from, originalTo); 
  auto renderer = m_window-&gt;GetRenderer(); 
 
  if (renderer-&gt;UseShader("default")) { 
    // Diffuse pass. 
    </span><span class="koboSpan" id="kobo.24.3">for (auto x = l_from.x; x &lt;= l_to.x; ++x) { 
      for (auto y = l_from.y; y &lt;= l_to.y; ++y) { 
        for (auto layer = l_from.z; layer &lt;= l_to.z; ++layer) { 
          auto tile = m_tileMap.GetTile(x, y, layer); 
          if (!tile) { continue; } 
          auto&amp; sprite = tile-&gt;m_properties-&gt;m_sprite; 
          sprite.setPosition( 
            static_cast&lt;float&gt;(x * Sheet::Tile_Size), 
            static_cast&lt;float&gt;(y * Sheet::Tile_Size)); 
          renderer-&gt;Draw(sprite, &amp;m_textures[layer]); 
        } 
      } 
    } 
  } 
  ... </span><span class="koboSpan" id="kobo.24.4">// Other passes. 
  </span><span class="koboSpan" id="kobo.24.5">renderer-&gt;DisableShader(); 
  DisplayAllTextures(l_from.z, l_to.z); 
} 
</span></pre><p><span class="koboSpan" id="kobo.25.1">Only a few extra lines add the support here. </span><span class="koboSpan" id="kobo.25.2">We just need to make sure the renderer is involved when the drawing is happening because it allows the right shader to be used in the process.</span></p><p><span class="koboSpan" id="kobo.26.1">Since we're going to add more material maps quite soon, clearing of these textures also needs to be integrated into the existing code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">void Map::ClearMapTexture(sf::Vector3i l_from, sf::Vector3i l_to){ 
  ... 
  </span><span class="koboSpan" id="kobo.27.2">if (l_to.x == -1 &amp;&amp; l_to.y == -1) { 
    // Clearing the entire texture. 
    </span><span class="koboSpan" id="kobo.27.3">for (auto layer = l_from.z; layer &lt;= toLayer; ++layer) { 
      m_textures[layer].clear({ 0,0,0,0 }); 
      ... </span><span class="koboSpan" id="kobo.27.4">// Other textures. 
    </span><span class="koboSpan" id="kobo.27.5">} 
    return; 
  } 
  // Portion of the map needs clearing. 
  </span><span class="koboSpan" id="kobo.27.6">... 
  </span><span class="koboSpan" id="kobo.27.7">for (auto layer = l_from.z; layer &lt;= toLayer; ++layer) { 
    m_textures[layer].draw(shape, sf::BlendMultiply); 
    ... </span><span class="koboSpan" id="kobo.27.8">// Other textures. 
  </span><span class="koboSpan" id="kobo.27.9">} 
  DisplayAllTextures(l_from.z, toLayer); 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">The spaces for doing so are marked with comments, which is exactly the same for the helper methods that aid in displaying all the changes made to these buffer textures:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">void Map::DisplayAllTextures(int l_fromZ, int l_toZ) { 
  for (auto layer = l_fromZ; layer &lt;= l_toZ; ++layer) { 
    m_textures[layer].display(); 
    ... </span><span class="koboSpan" id="kobo.29.2">// Other textures. 
  </span><span class="koboSpan" id="kobo.29.3">} 
} 
</span></pre><p><span class="koboSpan" id="kobo.30.1">The actual </span><code class="literal"><span class="koboSpan" id="kobo.31.1">Draw</span></code><span class="koboSpan" id="kobo.32.1"> method from the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">LightUser</span></code><span class="koboSpan" id="kobo.34.1"> class can be implemented like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">void Map::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  if (l_layer &lt; 0) { return; } 
  if (l_layer &gt;= Sheet::Num_Layers) { return; } 
  auto rect = sf::IntRect(sf::Vector2i(0, 0), 
    sf::Vector2i(m_textures[l_layer].getSize())); 
  m_layerSprite.setTextureRect(rect); 
  // Diffuse. 
  </span><span class="koboSpan" id="kobo.35.2">m_layerSprite.setTexture(m_textures[l_layer].getTexture()); 
  m_window-&gt;GetRenderer()-&gt;Draw(m_layerSprite, 
    l_materials[MaterialMapType::Diffuse].get()); 
  ... </span><span class="koboSpan" id="kobo.35.3">// Other textures. 
</span><span class="koboSpan" id="kobo.35.4">} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">Because of the way the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">Map</span></code><span class="koboSpan" id="kobo.38.1"> class works, all we have to do is set up the sprite we're working with to use the right texture for the appropriate material type. </span><span class="koboSpan" id="kobo.38.2">In this case, all we need is the diffuse texture.</span></p></div><div class="section" title="The entity renderer system"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec82"/><span class="koboSpan" id="kobo.39.1">The entity renderer system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.40.1">If you recall, the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">SystemManager</span></code><span class="koboSpan" id="kobo.42.1"> class is the one we added to </span><code class="literal"><span class="koboSpan" id="kobo.43.1">LightManager</span></code><span class="koboSpan" id="kobo.44.1"> as </span><code class="literal"><span class="koboSpan" id="kobo.45.1">LightUser</span></code><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Although there's only one system that does the rendering for now, we still want to keep it this way and simply forward all the arguments passed to </span><code class="literal"><span class="koboSpan" id="kobo.47.1">SystemManager</span></code><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">This keeps our options for additional systems doing the same thing open in the future:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">void SystemManager::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.49.2">auto system = dynamic_cast&lt;S_Renderer*&gt;(itr-&gt;second.get()); 
  system-&gt;Draw(l_materials, l_window, l_layer); 
} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">The forwarded arguments are sent to </span><code class="literal"><span class="koboSpan" id="kobo.51.1">S_Renderer</span></code><span class="koboSpan" id="kobo.52.1"> and can be used like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.53.1">void S_Renderer::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.53.2">if (renderer-&gt;UseShader("default")) { 
    // Diffuse pass. 
    </span><span class="koboSpan" id="kobo.53.3">for (auto &amp;entity : m_entities) { 
      auto position = entities-&gt;GetComponent&lt;C_Position&gt;( 
        entity, Component::Position); 
      if (position-&gt;GetElevation() &lt; l_layer) { continue; } 
      if (position-&gt;GetElevation() &gt; l_layer) { break; } 
      C_Drawable* drawable = GetDrawableFromType(entity); 
      if (!drawable) { continue; } 
      drawable-&gt;Draw(&amp;l_window, 
        l_materials[MaterialMapType::Diffuse].get()); 
    } 
  } 
  ... </span><span class="koboSpan" id="kobo.53.4">// Other passes. 
  </span><span class="koboSpan" id="kobo.53.5">renderer-&gt;DisableShader(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.54.1">It's fairly similar to how the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Map</span></code><span class="koboSpan" id="kobo.56.1"> class handles its redrawing process. </span><span class="koboSpan" id="kobo.56.2">All we need to do is make sure the Renderer class is used to do the drawing to the diffuse texture, which is what happens under the hood, as </span><code class="literal"><span class="koboSpan" id="kobo.57.1">C_Drawable</span></code><span class="koboSpan" id="kobo.58.1"> simply passes these arguments down the line:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.59.1">class C_Drawable : public C_Base{ 
  ... 
  </span><span class="koboSpan" id="kobo.59.2">virtual void Draw(Window* l_wind, 
    sf::RenderTarget* l_target = nullptr) = 0; 
}; 
 
class C_SpriteSheet : public C_Drawable{ 
  ... 
  </span><span class="koboSpan" id="kobo.59.3">void Draw(Window* l_wind, sf::RenderTarget* l_target = nullptr){ 
    if (!m_spriteSheet) { return; } 
    m_spriteSheet-&gt;Draw(l_wind, l_target); 
  } 
  ... 
</span><span class="koboSpan" id="kobo.59.4">}; 
 
void SpriteSheet::Draw(Window* l_wnd, sf::RenderTarget* l_target) { 
  l_wnd-&gt;GetRenderer()-&gt;Draw(m_sprite, l_target); 
} 
</span></pre></div><div class="section" title="The particle system"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec83"/><span class="koboSpan" id="kobo.60.1">The particle system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.61.1">Drawing particles in this way is not much different from how other </span><code class="literal"><span class="koboSpan" id="kobo.62.1">LightUser</span></code><span class="koboSpan" id="kobo.63.1"> do it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.64.1">void ParticleSystem::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.64.2">if (renderer-&gt;UseShader("default")) { 
  // Diffuse pass. 
    </span><span class="koboSpan" id="kobo.64.3">for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
      if (l_layer &gt;= 0) { 
        if (positions[i].z &lt; l_layer * Sheet::Tile_Size) 
        { continue; } 
        if (positions[i].z &gt;= (l_layer + 1) * Sheet::Tile_Size) 
        { continue; } 
      } else if(positions[i].z&lt;Sheet::Num_Layers*Sheet::Tile_Size) 
      { continue; } 
      renderer-&gt;AdditiveBlend(blendModes[i]); 
      renderer-&gt;Draw(drawables[i], 
        l_materials[MaterialMapType::Diffuse].get()); 
    } 
  } 
  renderer-&gt;AdditiveBlend(false); 
  ... </span><span class="koboSpan" id="kobo.64.4">// Other passes. 
  </span><span class="koboSpan" id="kobo.64.5">renderer-&gt;DisableShader(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.65.1">Once again, it's all about making sure the materials are passed through </span><code class="literal"><span class="koboSpan" id="kobo.66.1">Renderer</span></code><span class="koboSpan" id="kobo.67.1">.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Preparing for additional materials"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/><span class="koboSpan" id="kobo.1.1">Preparing for additional materials</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Drawing basic light streams is fairly nifty. </span><span class="koboSpan" id="kobo.2.2">But let's face it, we want to do more than that! </span><span class="koboSpan" id="kobo.2.3">Any additional processing is going to require further material information about the surfaces we're working with. </span><span class="koboSpan" id="kobo.2.4">As far as storing those materials goes, the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Map</span></code><span class="koboSpan" id="kobo.4.1"> class needs to allocate additional space for textures that will be used for this purpose:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class Map : ..., public LightUser { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.5.2">void Draw(MaterialMapContainer&amp; l_materials, 
    Window&amp; l_window, int l_layer); 
protected: 
  ... 
  </span><span class="koboSpan" id="kobo.5.3">std::array&lt;sf::RenderTexture, Sheet::Num_Layers&gt; m_textures; 
  std::array&lt;sf::RenderTexture, Sheet::Num_Layers&gt; m_normals; 
  std::array&lt;sf::RenderTexture, Sheet::Num_Layers&gt; m_speculars; 
  std::array&lt;sf::RenderTexture, Sheet::Num_Layers&gt; m_heightMap; 
  ... 
</span><span class="koboSpan" id="kobo.5.4">}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">These textures will also need to be checked for incorrect sizes and adjusted if it ever comes to that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">void Map::CheckTextureSizes(int l_fromZ, int l_toZ) { 
  auto realMapSize = m_tileMap.GetMapSize() * 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  for (auto layer = l_fromZ; layer &lt;= l_toZ; ++layer) { 
    ... 
    </span><span class="koboSpan" id="kobo.7.2">if (m_normals[layer].getSize() != realMapSize) { 
      if (!m_normals[layer].create(realMapSize.x, realMapSize.y)) 
      { ... </span><span class="koboSpan" id="kobo.7.3">} 
    } 
    if (m_speculars[layer].getSize() != realMapSize) { 
      if (!m_speculars[layer].create(realMapSize.x,realMapSize.y)) 
      { ... </span><span class="koboSpan" id="kobo.7.4">} 
    } 
    if (m_heightMap[layer].getSize() != realMapSize) { 
      if (!m_heightMap[layer].create(realMapSize.x,realMapSize.y)) 
      { ... </span><span class="koboSpan" id="kobo.7.5">} 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.8.1">Clearing the material maps is equally as simple; we just need to add a couple of extra lines:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">void Map::ClearMapTexture(sf::Vector3i l_from, sf::Vector3i l_to) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.9.2">if (l_to.x == -1 &amp;&amp; l_to.y == -1) { 
    for (auto layer = l_from.z; layer &lt;= toLayer; ++layer) { 
      ... 
      </span><span class="koboSpan" id="kobo.9.3">m_normals[layer].clear({ 0,0,0,0 }); 
      m_speculars[layer].clear({ 0,0,0,0 }); 
      m_heightMap[layer].clear({ 0,0,0,0 }); 
    } 
    return; 
  } 
  ... 
  </span><span class="koboSpan" id="kobo.9.4">for (auto layer = l_from.z; layer &lt;= toLayer; ++layer) { 
    ... 
    </span><span class="koboSpan" id="kobo.9.5">m_normals[layer].draw(shape, sf::BlendMultiply); 
    m_speculars[layer].draw(shape, sf::BlendMultiply); 
    m_heightMap[layer].draw(shape, sf::BlendMultiply); 
  } 
  DisplayAllTextures(l_from.z, toLayer); 
} 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Displaying the changes that were made to the buffer textures follows the same easy and manageable approach:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">void Map::DisplayAllTextures(int l_fromZ, int l_toZ) { 
  for (auto layer = l_fromZ; layer &lt;= l_toZ; ++layer) { 
    m_textures[layer].display(); 
    m_normals[layer].display(); 
    m_speculars[layer].display(); 
    m_heightMap[layer].display(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.12.1">Finally, drawing this information to the internal buffers of </span><code class="literal"><span class="koboSpan" id="kobo.13.1">LightManager</span></code><span class="koboSpan" id="kobo.14.1">, in the case of the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">Map</span></code><span class="koboSpan" id="kobo.16.1"> class, can be done like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">void Map::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... </span><span class="koboSpan" id="kobo.17.2">// Diffuse. 
  </span><span class="koboSpan" id="kobo.17.3">// Normal. 
  </span><span class="koboSpan" id="kobo.17.4">m_layerSprite.setTexture(m_normals[l_layer].getTexture()); 
  m_window-&gt;GetRenderer()-&gt;Draw(m_layerSprite, 
    l_materials[MaterialMapType::Normal].get()); 
  // Specular. 
  </span><span class="koboSpan" id="kobo.17.5">m_layerSprite.setTexture(m_speculars[l_layer].getTexture()); 
  m_window-&gt;GetRenderer()-&gt;Draw(m_layerSprite, 
    l_materials[MaterialMapType::Specular].get()); 
  // Height. 
  </span><span class="koboSpan" id="kobo.17.6">m_layerSprite.setTexture(m_heightMap[l_layer].getTexture()); 
  m_window-&gt;GetRenderer()-&gt;Draw(m_layerSprite, 
    l_materials[MaterialMapType::Height].get()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.18.1">Easy enough? </span><span class="koboSpan" id="kobo.18.2">Good! </span><span class="koboSpan" id="kobo.18.3">Let's keep progressing and build shaders that can handle the process of drawing these material maps.</span></p><div class="section" title="Preparing the texture manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec84"/><span class="koboSpan" id="kobo.19.1">Preparing the texture manager</span></h2></div></div></div><p><span class="koboSpan" id="kobo.20.1">In order to automatically load the additional material maps when loading diffuse images, we need to make some very quick and painless changes to the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">ResourceManager</span></code><span class="koboSpan" id="kobo.22.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.23.1">TextureManager</span></code><span class="koboSpan" id="kobo.24.1"> classes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">class ResourceManager{ 
public: 
  bool RequireResource(const std::string&amp; l_id, 
    bool l_notifyDerived = true) 
  { 
    ... 
    </span><span class="koboSpan" id="kobo.25.2">if (l_notifyDerived) { OnRequire(l_id); } 
    return true; 
  } 
 
  bool ReleaseResource(const std::string&amp; l_id, 
    bool l_notifyDerived = true) 
  { 
    ... 
    </span><span class="koboSpan" id="kobo.25.3">if (l_notifyDerived) { OnRelease(l_id); } 
    return true; 
  } 
protected: 
  ... 
  </span><span class="koboSpan" id="kobo.25.4">virtual void OnRequire(const std::string&amp; l_id) {} 
  virtual void OnRelease(const std::string&amp; l_id) {} 
}; 
 
class TextureManager : ...{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.25.5">void OnRequire(const std::string&amp; l_id) { 
    if (RequireResource(l_id + "_normal", false)) { ... </span><span class="koboSpan" id="kobo.25.6">} 
    if (RequireResource(l_id + "_specular", false)) { ... </span><span class="koboSpan" id="kobo.25.7">} 
  } 
 
  void OnRelease(const std::string&amp; l_id) { 
    if (ReleaseResource(l_id + "_normal", false)) { ... </span><span class="koboSpan" id="kobo.25.8">} 
    if (ReleaseResource(l_id + "_specular", false)) { ... </span><span class="koboSpan" id="kobo.25.9">} 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.26.1">By adding the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">OnRequire()</span></code><span class="koboSpan" id="kobo.28.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.29.1">OnRelease()</span></code><span class="koboSpan" id="kobo.30.1"> methods and integrating them properly with the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">l_notifyDerived</span></code><span class="koboSpan" id="kobo.32.1"> flag to avoid infinite recursion, </span><code class="literal"><span class="koboSpan" id="kobo.33.1">TextureManager</span></code><span class="koboSpan" id="kobo.34.1"> can safely load in both the normal and specular material maps when a diffuse texture is loaded, provided they are found. </span><span class="koboSpan" id="kobo.34.2">Note that the texture manager actually passes in </span><code class="literal"><span class="koboSpan" id="kobo.35.1">false</span></code><span class="koboSpan" id="kobo.36.1"> as the second argument when it needs these maps to avoid infinite recursion.</span></p></div><div class="section" title="Material pass shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec85"/><span class="koboSpan" id="kobo.37.1">Material pass shaders</span></h2></div></div></div><p><span class="koboSpan" id="kobo.38.1">There will be two types of material pass shaders we'll use. </span><span class="koboSpan" id="kobo.38.2">One type, simply referred to as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.39.1">MaterialPass</span></em></span><span class="koboSpan" id="kobo.40.1">, will sample the material color from a texture:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">uniform sampler2D texture; 
uniform sampler2D material; 
void main() 
{ 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
  vec4 materialPixel = texture2D(material, gl_TexCoord[0].xy); 
  materialPixel.a *= pixel.a; 
  gl_FragColor = gl_Color * materialPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.42.1">It retrieves the diffuse pixel and the material texture pixel, as well as uses the diffuse alpha value to display the right color. </span><span class="koboSpan" id="kobo.42.2">This effectively means that if we're dealing with a transparent pixel on a diffuse map, no material color is going to be rendered for it. </span><span class="koboSpan" id="kobo.42.3">Otherwise, the material color is completely independent of the diffuse pixel. </span><span class="koboSpan" id="kobo.42.4">This is useful for drawing images that also have material maps located in a different texture.</span></p><p><span class="koboSpan" id="kobo.43.1">The second type of material shader, known from here on out as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.44.1">MaterialValuePass</span></em></span><span class="koboSpan" id="kobo.45.1">, will also sample the diffuse pixel. </span><span class="koboSpan" id="kobo.45.2">Instead of using a material texture, however, it'll simply use a static color value for all the pixels that aren't transparent:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.46.1">uniform sampler2D texture; 
uniform vec3 material; 
void main() 
{ 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
  float alpha = 0.0; 
  if(pixel == vec4(0.0, 0.0, 0.0, 1.0)) 
    alpha = gl_Color.a; 
  else 
    alpha = pixel.a; 
  gl_FragColor = gl_Color * vec4(material.rgb, alpha); 
} 
</span></pre><p><span class="koboSpan" id="kobo.47.1">Here, we first verify that the sampled pixel isn't completely black. </span><span class="koboSpan" id="kobo.47.2">If it is, the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">alpha</span></code><span class="koboSpan" id="kobo.49.1"> value of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">gl_Color</span></code><span class="koboSpan" id="kobo.51.1"> is used instead of that of the pixel. </span><span class="koboSpan" id="kobo.51.2">Then, we simply write the static material color value to the fragment. </span><span class="koboSpan" id="kobo.51.3">This type of shader is useful for drawable objects that don't have material maps and instead use a static color for every single pixel.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Normal maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/><span class="koboSpan" id="kobo.1.1">Normal maps</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Lighting can be used to create visually complex and breath taking scenes. </span><span class="koboSpan" id="kobo.2.2">One of the massive benefits of having a lighting system is the ability it provides to add extra details to your scene, which wouldn't have been possible otherwise. </span><span class="koboSpan" id="kobo.2.3">One way of doing so is using </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">normal maps</span></strong></span><span class="koboSpan" id="kobo.4.1">.</span></p><p><span class="koboSpan" id="kobo.5.1">Mathematically speaking, the word </span><span class="emphasis"><em><span class="koboSpan" id="kobo.6.1">normal</span></em></span><span class="koboSpan" id="kobo.7.1"> in the context of a surface is simply a directional vector that is perpendicular to said surface. </span><span class="koboSpan" id="kobo.7.2">Consider the following illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.8.1"><img src="graphics/image_08_005.jpg" alt="Normal maps"/></span></div><p><span class="koboSpan" id="kobo.9.1">In this case, what's normal is facing up because that's the direction perpendicular to the plane. </span><span class="koboSpan" id="kobo.9.2">How is this helpful? </span><span class="koboSpan" id="kobo.9.3">Well, imagine you have a really complex model with many vertices; it'd be extremely taxing to render said model because of all the geometry that would need to be processed with each frame. </span><span class="koboSpan" id="kobo.9.4">A clever trick to work around this, known as </span><span class="strong"><strong><span class="koboSpan" id="kobo.10.1">normal mapping</span></strong></span><span class="koboSpan" id="kobo.11.1">, is to take the information of all of those vertices and save them on a texture that looks similar to this one:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.12.1"><img src="graphics/image_08_006.jpg" alt="Normal maps"/></span></div><p><span class="koboSpan" id="kobo.13.1">It probably looks extremely funky, especially if being looked at in a physical release of this book that's in grayscale, but try not to think of this in terms of colors, but directions. </span><span class="koboSpan" id="kobo.13.2">The red channel of a normal map encodes the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">-x</span></em></span><span class="koboSpan" id="kobo.15.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">+x</span></em></span><span class="koboSpan" id="kobo.17.1"> values. </span><span class="koboSpan" id="kobo.17.2">The green channel does the same for </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">-y</span></em></span><span class="koboSpan" id="kobo.19.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">+y</span></em></span><span class="koboSpan" id="kobo.21.1"> values, and the blue channel is used for </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">-z</span></em></span><span class="koboSpan" id="kobo.23.1"> to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.24.1">+z</span></em></span><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">Looking back at the previous image now, it's easier to confirm which direction each individual pixel is facing. </span><span class="koboSpan" id="kobo.25.3">Using this information on geometry that's completely flat would still allow us to light it in such a way that it would make it look like it has all of the detail in there; yet, it would still remain flat and light on performance:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.26.1"><img src="graphics/image_08_007.jpg" alt="Normal maps"/></span></div><p><span class="koboSpan" id="kobo.27.1">These normal maps can be hand-drawn or simply generated using software such as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">Crazybump</span></em></span><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">Let's see how all of this can be done in our game engine.</span></p><div class="section" title="Implementing normal map rendering"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec86"/><span class="koboSpan" id="kobo.30.1">Implementing normal map rendering</span></h2></div></div></div><p><span class="koboSpan" id="kobo.31.1">In the case of maps, implementing normal map rendering is extremely simple. </span><span class="koboSpan" id="kobo.31.2">We already have all the material maps integrated and ready to go, so at this time, it's simply a matter of sampling the texture of the tile sheet normals:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">void Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { 
  ... 
  </span><span class="koboSpan" id="kobo.32.2">if (renderer-&gt;UseShader("MaterialPass")) { 
    // Material pass. 
    </span><span class="koboSpan" id="kobo.32.3">auto shader = renderer-&gt;GetCurrentShader(); 
    auto textureName = m_tileMap.GetTileSet().GetTextureName(); 
    auto normalMaterial = m_textureManager-&gt; 
      GetResource(textureName + "_normal"); 
    for (auto x = l_from.x; x &lt;= l_to.x; ++x) { 
      for (auto y = l_from.y; y &lt;= l_to.y; ++y) { 
        for (auto layer = l_from.z; layer &lt;= l_to.z; ++layer) { 
          auto tile = m_tileMap.GetTile(x, y, layer); 
          if (!tile) { continue; } 
          auto&amp; sprite = tile-&gt;m_properties-&gt;m_sprite; 
          sprite.setPosition( 
            static_cast&lt;float&gt;(x * Sheet::Tile_Size), 
            static_cast&lt;float&gt;(y * Sheet::Tile_Size)); 
          // Normal pass. 
          </span><span class="koboSpan" id="kobo.32.4">if (normalMaterial) { 
            shader-&gt;setUniform("material", *normalMaterial); 
            renderer-&gt;Draw(sprite, &amp;m_normals[layer]); 
          } 
        } 
      } 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.32.5">} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">The process is exactly the same as drawing a normal tile to a diffuse map, except that here we have to provide the material shader with the texture of the tile-sheet normal map. </span><span class="koboSpan" id="kobo.33.2">Also note that we're now drawing to a normal buffer texture.</span></p><p><span class="koboSpan" id="kobo.34.1">The same is true for drawing entities as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">void S_Renderer::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.35.2">if (renderer-&gt;UseShader("MaterialPass")) { 
    // Material pass. 
    </span><span class="koboSpan" id="kobo.35.3">auto shader = renderer-&gt;GetCurrentShader(); 
    auto textures = m_systemManager-&gt; 
      GetEntityManager()-&gt;GetTextureManager(); 
    for (auto &amp;entity : m_entities) { 
      auto position = entities-&gt;GetComponent&lt;C_Position&gt;( 
        entity, Component::Position); 
      if (position-&gt;GetElevation() &lt; l_layer) { continue; } 
      if (position-&gt;GetElevation() &gt; l_layer) { break; } 
      C_Drawable* drawable = GetDrawableFromType(entity); 
      if (!drawable) { continue; } 
      if (drawable-&gt;GetType() != Component::SpriteSheet) 
      { continue; } 
      auto sheet = static_cast&lt;C_SpriteSheet*&gt;(drawable); 
      auto name = sheet-&gt;GetSpriteSheet()-&gt;GetTextureName(); 
      auto normals = textures-&gt;GetResource(name + "_normal"); 
      // Normal pass. 
      </span><span class="koboSpan" id="kobo.35.4">if (normals) { 
        shader-&gt;setUniform("material", *normals); 
        drawable-&gt;Draw(&amp;l_window, 
          l_materials[MaterialMapType::Normal].get()); 
      } 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.35.5">} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">You can try obtaining a normal texture through the texture manager. </span><span class="koboSpan" id="kobo.36.2">If you find one, you can draw it to the normal map material buffer.</span></p><p><span class="koboSpan" id="kobo.37.1">Dealing with particles isn't much different from what we've seen already, except for one small detail:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">void ParticleSystem::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.38.2">if (renderer-&gt;UseShader("MaterialValuePass")) { 
    // Material pass. 
    </span><span class="koboSpan" id="kobo.38.3">auto shader = renderer-&gt;GetCurrentShader(); 
    for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
      if (l_layer &gt;= 0) { 
        if (positions[i].z &lt; l_layer * Sheet::Tile_Size) 
        { continue; } 
        if (positions[i].z &gt;= (l_layer + 1) * Sheet::Tile_Size) 
        { continue; } 
      } else if (positions[i].z &lt; 
        Sheet::Num_Layers * Sheet::Tile_Size) 
      { continue; } 
      // Normal pass. 
      </span><span class="koboSpan" id="kobo.38.4">shader-&gt;setUniform("material", 
        sf::Glsl::Vec3(0.5f, 0.5f, 1.f)); 
      renderer-&gt;Draw(drawables[i], 
        l_materials[MaterialMapType::Normal].get()); 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.38.5">} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">As you can see, we're actually using the material value shader in order to give particles static normals, which are always sort of pointing to the camera. </span><span class="koboSpan" id="kobo.39.2">A normal map buffer should look something like this after you render all the normal maps to it:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.40.1"><img src="graphics/image_08_008.jpg" alt="Implementing normal map rendering"/></span></div></div><div class="section" title="Changing the lighting shader"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec87"/><span class="koboSpan" id="kobo.41.1">Changing the lighting shader</span></h2></div></div></div><p><span class="koboSpan" id="kobo.42.1">Now that we have all of this information, let's actually use it when calculating the illumination of the pixels inside the light pass shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">uniform sampler2D LastPass; 
uniform sampler2D DiffuseMap; 
uniform sampler2D NormalMap; 
uniform vec3 AmbientLight; 
uniform int LightCount; 
uniform int PassNumber; 
 
struct LightInfo { 
  vec3 position; 
  vec3 color; 
  float radius; 
  float falloff; 
}; 
 
const int MaxLights = 4; 
uniform LightInfo Lights[MaxLights]; 
 
void main() 
{ 
  vec4 pixel = texture2D(LastPass, gl_TexCoord[0].xy); 
  vec4 diffusepixel = texture2D(DiffuseMap, gl_TexCoord[0].xy); 
  vec4 normalpixel = texture2D(NormalMap, gl_TexCoord[0].xy); 
  vec3 PixelCoordinates = 
    vec3(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z); 
  vec4 finalPixel = gl_Color * pixel; 
  vec3 viewDirection = vec3(0, 0, 1); 
  if(PassNumber == 1) { finalPixel *= vec4(AmbientLight, 1.0); } 
  // IF FIRST PASS ONLY! 
  </span><span class="koboSpan" id="kobo.43.2">vec3 N = normalize(normalpixel.rgb * 2.0 - 1.0); 
  for(int i = 0; i &lt; LightCount; ++i) { 

    vec3 L = Lights[i].position - PixelCoordinates;
    float distance = length(L);
    float d = max(distance - Lights[i].radius, 0);
    L /= distance;
    float attenuation = 1 / pow(d/Lights[i].radius + 1, 2); 
    attenuation = (attenuation - Lights[i].falloff) / 
      (1 - Lights[i].falloff); 
    attenuation = max(attenuation, 0); 
    float normalDot = max(dot(N, L), 0.0); 
    finalPixel += (diffusepixel * 
      ((vec4(Lights[i].color, 1.0) * attenuation))) * normalDot; 
  } 
  gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">First, the normal map texture needs to be passed to it, as well as sampled, which is where the first two highlighted lines of code come in. </span><span class="koboSpan" id="kobo.44.2">Once this is done, for each light we're drawing on the screen, the normal directional vector is calculated. </span><span class="koboSpan" id="kobo.44.3">This is done by first making sure that it can go into the negative range and then normalizing it. </span><span class="koboSpan" id="kobo.44.4">A normalized vector only represents a direction.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/><span class="koboSpan" id="kobo.45.1">Note</span></h3><p><span class="koboSpan" id="kobo.46.1">Since the color values range from </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">0</span></em></span><span class="koboSpan" id="kobo.48.1"> to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.49.1">255</span></em></span><span class="koboSpan" id="kobo.50.1">, negative values cannot be directly represented. </span><span class="koboSpan" id="kobo.50.2">This is why we first bring them into the right range by multiplying them by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">2.0</span></em></span><span class="koboSpan" id="kobo.52.1"> and subtracting by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.53.1">1.0</span></em></span><span class="koboSpan" id="kobo.54.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.55.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.56.1">dot product</span></strong></span><span class="koboSpan" id="kobo.57.1"> is then calculated between the normal vector and the normalized </span><code class="literal"><span class="koboSpan" id="kobo.58.1">L</span></code><span class="koboSpan" id="kobo.59.1"> vector, which now represents the direction from the light to the pixel. </span><span class="koboSpan" id="kobo.59.2">How much a pixel is lit up from a specific light is directly contingent upon the dot product, which is a value from </span><span class="emphasis"><em><span class="koboSpan" id="kobo.60.1">1.0</span></em></span><span class="koboSpan" id="kobo.61.1"> to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.62.1">0.0</span></em></span><span class="koboSpan" id="kobo.63.1"> and represents magnitude.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/><span class="koboSpan" id="kobo.64.1">Note</span></h3><p><span class="koboSpan" id="kobo.65.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.66.1">dot product</span></strong></span><span class="koboSpan" id="kobo.67.1"> is an algebraic operation that takes in </span><span class="emphasis"><em><span class="koboSpan" id="kobo.68.1">two vectors</span></em></span><span class="koboSpan" id="kobo.69.1">, as well as the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">cosine</span></em></span><span class="koboSpan" id="kobo.71.1"> of the angle between them, and produces a scalar value between </span><span class="emphasis"><em><span class="koboSpan" id="kobo.72.1">0.0</span></em></span><span class="koboSpan" id="kobo.73.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.74.1">1.0</span></em></span><span class="koboSpan" id="kobo.75.1"> that essentially represents how "orthogonal" they are. </span><span class="koboSpan" id="kobo.75.2">We use this property to light pixels less and less, given greater and greater angles between their normals and the light.</span></p></div></div><p><span class="koboSpan" id="kobo.76.1">Finally, the dot product is used again when calculating the final pixel value. </span><span class="koboSpan" id="kobo.76.2">The entire influence of the light is multiplied by it, which allows every pixel to be drawn differently as if it had some underlying geometry that was pointing in a different direction.</span></p><p><span class="koboSpan" id="kobo.77.1">The last thing left to do now is to pass the normal map buffer to the shader in our C++ code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.78.1">void LightManager::RenderScene() { 
  ... 
  </span><span class="koboSpan" id="kobo.78.2">if (renderer-&gt;UseShader("LightPass")) { 
    // Light pass. 
    </span><span class="koboSpan" id="kobo.78.3">... 
    </span><span class="koboSpan" id="kobo.78.4">shader-&gt;setUniform("NormalMap", 
      m_materialMaps[MaterialMapType::Normal]-&gt;getTexture()); 
    ... 
  </span><span class="koboSpan" id="kobo.78.5">} 
  ... 
</span><span class="koboSpan" id="kobo.78.6">} 
</span></pre><p><span class="koboSpan" id="kobo.79.1">This effectively enables normal mapping and gives us beautiful results such as this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.80.1"><img src="graphics/image_08_009.jpg" alt="Changing the lighting shader"/></span></div><p><span class="koboSpan" id="kobo.81.1">The leaves, the character, and pretty much everything in this image, now look like they have a definition, ridges, and crevices; it is lit as if it had geometry, although it's paper-thin. </span><span class="koboSpan" id="kobo.81.2">Note the lines around each tile in this particular instance. </span><span class="koboSpan" id="kobo.81.3">This is one of the main reasons why normal maps for pixel art, such as tile sheets, shouldn't be automatically generated; it can sample the tiles adjacent to it and incorrectly add bevelled edges.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Specular maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/><span class="koboSpan" id="kobo.1.1">Specular maps</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">While normal maps provide us with the possibility of faking how bumpy a surface is, specular maps allow us to do the same with the shininess of a surface. </span><span class="koboSpan" id="kobo.2.2">This is what the same segment of the tile sheet we used as an example for a normal map looks like in a specular map:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.3.1"><img src="graphics/image_08_010.jpg" alt="Specular maps"/></span></div><p><span class="koboSpan" id="kobo.4.1">It's not as complex as a normal map, since it only needs to store one value: the shininess factor. </span><span class="koboSpan" id="kobo.4.2">We can leave it up to each light to decide how much </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">shine</span></em></span><span class="koboSpan" id="kobo.6.1"> it will cast upon the scenery by letting it have its own values:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">struct LightBase { 
  ... 
  </span><span class="koboSpan" id="kobo.7.2">float m_specularExponent = 10.f; 
  float m_specularStrength = 1.f; 
}; 
</span></pre><div class="section" title="Adding support for specularity"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec88"/><span class="koboSpan" id="kobo.8.1">Adding support for specularity</span></h2></div></div></div><p><span class="koboSpan" id="kobo.9.1">Similar to normal maps, we need to use the material pass shader to render to a specularity buffer texture:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">void Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { 
  ... 
  </span><span class="koboSpan" id="kobo.10.2">if (renderer-&gt;UseShader("MaterialPass")) { 
    // Material pass. 
    </span><span class="koboSpan" id="kobo.10.3">... 
    </span><span class="koboSpan" id="kobo.10.4">auto specMaterial = m_textureManager-&gt;GetResource( 
      textureName + "_specular"); 
    for (auto x = l_from.x; x &lt;= l_to.x; ++x) { 
      for (auto y = l_from.y; y &lt;= l_to.y; ++y) { 
        for (auto layer = l_from.z; layer &lt;= l_to.z; ++layer) { 
          ... </span><span class="koboSpan" id="kobo.10.5">// Normal pass. 
          </span><span class="koboSpan" id="kobo.10.6">// Specular pass. 
          </span><span class="koboSpan" id="kobo.10.7">if (specMaterial) { 
            shader-&gt;setUniform("material", *specMaterial); 
            renderer-&gt;Draw(sprite, &amp;m_speculars[layer]); 
          } 
        } 
      } 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.10.8">} 
</span></pre><p><span class="koboSpan" id="kobo.11.1">The texture for specularity is once again attempted to be obtained; it is passed down to the material pass shader if found. </span><span class="koboSpan" id="kobo.11.2">The same is true when you render entities:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">void S_Renderer::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.12.2">if (renderer-&gt;UseShader("MaterialPass")) { 
    // Material pass. 
    </span><span class="koboSpan" id="kobo.12.3">... 
    </span><span class="koboSpan" id="kobo.12.4">for (auto &amp;entity : m_entities) { 
      ... </span><span class="koboSpan" id="kobo.12.5">// Normal pass. 
      </span><span class="koboSpan" id="kobo.12.6">// Specular pass. 
      </span><span class="koboSpan" id="kobo.12.7">if (specular) { 
        shader-&gt;setUniform("material", *specular); 
        drawable-&gt;Draw(&amp;l_window, 
          l_materials[MaterialMapType::Specular].get()); 
      } 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.12.8">} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">Particles, on the other hand, also use the material value pass shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">void ParticleSystem::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.14.2">if (renderer-&gt;UseShader("MaterialValuePass")) { 
    // Material pass. 
    </span><span class="koboSpan" id="kobo.14.3">auto shader = renderer-&gt;GetCurrentShader(); 
    for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
      ... </span><span class="koboSpan" id="kobo.14.4">// Normal pass. 
      </span><span class="koboSpan" id="kobo.14.5">// Specular pass. 
      </span><span class="koboSpan" id="kobo.14.6">shader-&gt;setUniform("material", 
        sf::Glsl::Vec3(0.f, 0.f, 0.f)); 
      renderer-&gt;Draw(drawables[i], 
        l_materials[MaterialMapType::Specular].get()); 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.15.1">For now, we don't want any of them to be specular at all. </span><span class="koboSpan" id="kobo.15.2">This can obviously be tweaked later on, but the important thing is that we have that functionality available and yielding results, such as the following:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.16.1"><img src="graphics/image_08_011.jpg" alt="Adding support for specularity"/></span></div><p><span class="koboSpan" id="kobo.17.1">This specularity texture needs to be sampled inside a light pass, just like a normal texture. </span><span class="koboSpan" id="kobo.17.2">Let's see what this involves.</span></p></div><div class="section" title="Changing the lighting shader"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec89"/><span class="koboSpan" id="kobo.18.1">Changing the lighting shader</span></h2></div></div></div><p><span class="koboSpan" id="kobo.19.1">Just as before, a uniform </span><code class="literal"><span class="koboSpan" id="kobo.20.1">sampler2D</span></code><span class="koboSpan" id="kobo.21.1"> needs to be added to sample the specularity of a particular fragment:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">uniform sampler2D LastPass; 
uniform sampler2D DiffuseMap; 
uniform sampler2D NormalMap; 
uniform sampler2D SpecularMap; 
uniform vec3 AmbientLight; 
uniform int LightCount; 
uniform int PassNumber; 
 
struct LightInfo { 
  vec3 position; 
  vec3 color; 
  float radius; 
  float falloff; 
  float specularExponent; 
  float specularStrength; 
}; 
 
const int MaxLights = 4; 
uniform LightInfo Lights[MaxLights]; 
 
const float SpecularConstant = 0.4; 
 
void main() 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.22.2">vec4 specularpixel = texture2D(SpecularMap, gl_TexCoord[0].xy); 
  vec3 viewDirection = vec3(0, 0, 1); // Looking at positive Z. 
  </span><span class="koboSpan" id="kobo.22.3">... 
  </span><span class="koboSpan" id="kobo.22.4">for(int i = 0; i &lt; LightCount; ++i){ 
    ... 
    </span><span class="koboSpan" id="kobo.22.5">float specularLevel = 0.0; 
    specularLevel = 
      pow(max(0.0, dot(reflect(-L, N), viewDirection)), 
      Lights[i].specularExponent * specularpixel.a) 
      * SpecularConstant; 
    vec3 specularReflection = Lights[i].color * specularLevel * 
      specularpixel.rgb * Lights[i].specularStrength; 
    finalPixel += 
      (diffusepixel * ((vec4(Lights[i].color, 1.0) * attenuation)) 
      + vec4(specularReflection, 1.0)) * normalDot; 
  } 
  gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">We also need to add in the specular exponent and strength to each light's </span><code class="literal"><span class="koboSpan" id="kobo.24.1">struct</span></code><span class="koboSpan" id="kobo.25.1">, as it's now part of it. </span><span class="koboSpan" id="kobo.25.2">Once the specular pixel is sampled, we need to set up the direction of the camera as well. </span><span class="koboSpan" id="kobo.25.3">Since that's static, we can leave it as is in the shader.</span></p><p><span class="koboSpan" id="kobo.26.1">The specularity of the pixel is then calculated by taking into account the dot product between the pixel's normal and the light, the color of the specular pixel itself, and the specular strength of the light. </span><span class="koboSpan" id="kobo.26.2">Note the use of a specular constant in the calculation. </span><span class="koboSpan" id="kobo.26.3">This is a value that can, and should, be tweaked in order to obtain the best results, as 100% specularity rarely looks good.</span></p><p><span class="koboSpan" id="kobo.27.1">Then, all that's left is to make sure the specularity texture is also sent to the light pass shader, in addition to the light's specular exponent and strength values:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">void LightManager::RenderScene() { 
  ... 
  </span><span class="koboSpan" id="kobo.28.2">if (renderer-&gt;UseShader("LightPass")) { 
    // Light pass. 
    </span><span class="koboSpan" id="kobo.28.3">... 
    </span><span class="koboSpan" id="kobo.28.4">shader-&gt;setUniform("SpecularMap", 
      m_materialMaps[MaterialMapType::Specular]-&gt;getTexture()); 
    ... 
    </span><span class="koboSpan" id="kobo.28.5">for (auto&amp; light : m_lights) { 
      ... 
      </span><span class="koboSpan" id="kobo.28.6">shader-&gt;setUniform(id + ".specularExponent", 
        light.m_specularExponent); 
      shader-&gt;setUniform(id + ".specularStrength", 
        light.m_specularStrength); 
      ... 
    </span><span class="koboSpan" id="kobo.28.7">} 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">The result may not be visible right away, but upon closer inspection of moving a light stream, we can see that correctly mapped surfaces will have a glint that will move around with the light:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.30.1"><img src="graphics/image_08_012.jpg" alt="Changing the lighting shader"/></span></div><p><span class="koboSpan" id="kobo.31.1">While this is nearly perfect, there's still some room for improvement.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Height maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/><span class="koboSpan" id="kobo.1.1">Height maps</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The main point of illuminating the world is to make all the visual details pop up in a realistic manner. </span><span class="koboSpan" id="kobo.2.2">We have already added artificial dynamic lighting, fake 3D geometry, and shininess, so what's left? </span><span class="koboSpan" id="kobo.2.3">Well, there's nothing that shows the proper height of the scene yet. </span><span class="koboSpan" id="kobo.2.4">Until this very moment, we've been dealing with the scene as if it's completely flat when calculating the lighting distances. </span><span class="koboSpan" id="kobo.2.5">Instead of this, we need to work on something referred to as the height map that will store the heights of the pixels.</span></p><div class="section" title="Adapting the existing code"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec90"/><span class="koboSpan" id="kobo.3.1">Adapting the existing code</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Drawing heights properly can be quite tricky, especially in the case of tile maps. </span><span class="koboSpan" id="kobo.4.2">We need to know which way a tile is facing when drawing realistic heights. </span><span class="koboSpan" id="kobo.4.3">Consider the following illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.5.1"><img src="graphics/image_08_013.jpg" alt="Adapting the existing code"/></span></div><p><span class="koboSpan" id="kobo.6.1">The tiles right next to point </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">A</span></strong></span><span class="koboSpan" id="kobo.8.1"> have no normals associated with them, while the tiles next to point </span><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">B</span></strong></span><span class="koboSpan" id="kobo.10.1"> are all facing the camera. </span><span class="koboSpan" id="kobo.10.2">We can store normal data inside our map files by making these few simple alterations:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">struct Tile { 
  ... 
  </span><span class="koboSpan" id="kobo.11.2">sf::Vector3f m_normal; 
}; 
 
void TileMap::ReadInTile(std::stringstream&amp; l_stream) { 
  ... 
  </span><span class="koboSpan" id="kobo.11.3">sf::Vector3f normals(0.f, 1.f, 0.f); 
  l_stream &gt;&gt; normals.x &gt;&gt; normals.y &gt;&gt; normals.z; 
  tile-&gt;m_normal = normals; 
  ... 
</span><span class="koboSpan" id="kobo.11.4">} 
 
TILE 57 15 3 1 1 // Tile entry without a normal. 
</span><span class="koboSpan" id="kobo.11.5">TILE 144 15 8 1 1 0 0 1 // Tile entry with a normal 0,0,1 
</span></pre><p><span class="koboSpan" id="kobo.12.1">The </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Tile</span></code><span class="koboSpan" id="kobo.14.1"> structure itself holds on to a normal value now, which will be used later on. </span><span class="koboSpan" id="kobo.14.2">When tiles are being read in from a file, additional information is loaded at the very end. </span><span class="koboSpan" id="kobo.14.3">The last two lines here show the actual entries from a map file.</span></p><p><span class="koboSpan" id="kobo.15.1">Drawing the heights of these tiles based on their normals is all done in the appropriate shader, so let's pass all of the information it needs:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">void Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { 
  ... 
  </span><span class="koboSpan" id="kobo.16.2">if (renderer-&gt;UseShader("HeightPass")) { 
    // Height pass. 
    </span><span class="koboSpan" id="kobo.16.3">auto shader = renderer-&gt;GetCurrentShader(); 
    for (auto x = l_from.x; x &lt;= l_to.x; ++x) { 
      for (auto y = l_from.y; y &lt;= l_to.y; ++y) { 
        for (auto layer = l_from.z; layer &lt;= l_to.z; ++layer) { 
          auto tile = m_tileMap.GetTile(x, y, layer); 
          if (!tile) { continue; } 
          auto&amp; sprite = tile-&gt;m_properties-&gt;m_sprite; 
          sprite.setPosition( 
            static_cast&lt;float&gt;(x * Sheet::Tile_Size), 
            static_cast&lt;float&gt;(y * Sheet::Tile_Size)); 
          shader-&gt;setUniform("BaseHeight", 
            static_cast&lt;float&gt;(layer * Sheet::Tile_Size)); 
          shader-&gt;setUniform("YPosition", sprite.getPosition().y); 
          shader-&gt;setUniform("SurfaceNormal", 
            sf::Glsl::Vec3(tile-&gt;m_normal)); 
          renderer-&gt;Draw(sprite, &amp;m_heightMap[layer]); 
        } 
      } 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.16.4">} 
</span></pre><p><span class="koboSpan" id="kobo.17.1">The height pass shader uses a value for the base height of the drawable, which, in this case, is just elevation in world coordinates. </span><span class="koboSpan" id="kobo.17.2">It also uses the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">Y</span></em></span><span class="koboSpan" id="kobo.19.1"> world coordinate of the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Drawable</span></code><span class="koboSpan" id="kobo.21.1"> class and takes in the surface normal. </span><span class="koboSpan" id="kobo.21.2">The same values need to be set up for the entities as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void S_Renderer::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.22.2">if (renderer-&gt;UseShader("HeightPass")) { 
    // Height pass. 
    </span><span class="koboSpan" id="kobo.22.3">auto shader = renderer-&gt;GetCurrentShader(); 
    shader-&gt;setUniform("BaseHeight", 
      static_cast&lt;float&gt;(l_layer * Sheet::Tile_Size)); 
    shader-&gt;setUniform("SurfaceNormal", 
      sf::Glsl::Vec3(0.f, 0.f, 1.f)); 
    for (auto &amp;entity : m_entities) { 
      auto position = entities-&gt;GetComponent&lt;C_Position&gt;( 
        entity, Component::Position); 
      if (position-&gt;GetElevation() &lt; l_layer) { continue; } 
      if (position-&gt;GetElevation() &gt; l_layer) { break; } 
      C_Drawable* drawable = GetDrawableFromType(entity); 
      if (!drawable) { continue; } 
      if (drawable-&gt;GetType() != Component::SpriteSheet) 
      { continue; } 
      auto sheet = static_cast&lt;C_SpriteSheet*&gt;(drawable); 
      shader-&gt;setUniform("YPosition", position-&gt;GetPosition().y); 
      drawable-&gt;Draw(&amp;l_window, 
        l_materials[MaterialMapType::Height].get()); 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.22.4">} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">In this case, however, we're using the same normal for all the entities. </span><span class="koboSpan" id="kobo.23.2">This is because we want them to face the camera and be illuminated as if they're standing perpendicular to the ground. </span><span class="koboSpan" id="kobo.23.3">Particles, on the other hand, are not facing the camera, but instead have normals pointing up toward the positive </span><span class="emphasis"><em><span class="koboSpan" id="kobo.24.1">Y</span></em></span><span class="koboSpan" id="kobo.25.1"> axis:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">void ParticleSystem::Draw(MaterialMapContainer&amp; l_materials, 
  Window&amp; l_window, int l_layer) 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.26.2">if (renderer-&gt;UseShader("HeightPass")) { 
    // Height pass. 
    </span><span class="koboSpan" id="kobo.26.3">auto shader = renderer-&gt;GetCurrentShader(); 
    shader-&gt;setUniform("SurfaceNormal", 
      sf::Glsl::Vec3(0.f, 1.f, 0.f)); 
    for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
      if (l_layer &gt;= 0) { 
        if (positions[i].z &lt; l_layer * Sheet::Tile_Size) 
        { continue; } 
        if (positions[i].z &gt;= (l_layer + 1) * Sheet::Tile_Size) 
        { continue; } 
      } else if (positions[i].z &lt; 
        Sheet::Num_Layers * Sheet::Tile_Size) 
      { continue; } 
      shader-&gt;setUniform("BaseHeight", positions[i].z); 
      shader-&gt;setUniform("YPosition", positions[i].y); 
      renderer-&gt;Draw(drawables[i], 
        l_materials[MaterialMapType::Height].get()); 
    } 
  } 
  ... 
</span><span class="koboSpan" id="kobo.26.4">} 
</span></pre></div><div class="section" title="Writing the height pass shader"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec91"/><span class="koboSpan" id="kobo.27.1">Writing the height pass shader</span></h2></div></div></div><p><span class="koboSpan" id="kobo.28.1">The height pass is the only program we've written so far that uses both the vertex and the fragment shaders.</span></p><p><span class="koboSpan" id="kobo.29.1">Let's take a look at what needs to happen in the vertex shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">uniform float YPosition; 
out float Height; 
void main() 
{ 
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; 
  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0; 
  gl_FrontColor = gl_Color; 
  Height = gl_Vertex.y - YPosition; 
} 
</span></pre><p><span class="koboSpan" id="kobo.31.1">There's only one line here that isn't standard from what is traditionally known as a vertex shader, outside of the uniform variable and the out variable, of course. </span><span class="koboSpan" id="kobo.31.2">The vertex shader outputs a floating point value called </span><code class="literal"><span class="koboSpan" id="kobo.32.1">Height</span></code><span class="koboSpan" id="kobo.33.1"> to the fragment shader. </span><span class="koboSpan" id="kobo.33.2">It's simply the height between the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.34.1">Y</span></em></span><span class="koboSpan" id="kobo.35.1"> component of the vertex of a shape in world coordinates and the base </span><span class="emphasis"><em><span class="koboSpan" id="kobo.36.1">Y</span></em></span><span class="koboSpan" id="kobo.37.1"> position of that same shape. </span><span class="koboSpan" id="kobo.37.2">The height is then interpolated between all the fragments, giving a nice, gradient distribution.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/><span class="koboSpan" id="kobo.38.1">Note</span></h3><p><span class="koboSpan" id="kobo.39.1">The </span><code class="literal"><span class="koboSpan" id="kobo.40.1">gl_Vertex</span></code><span class="koboSpan" id="kobo.41.1"> information is stored in world coordinates. </span><span class="koboSpan" id="kobo.41.2">The bottom </span><span class="emphasis"><em><span class="koboSpan" id="kobo.42.1">Y</span></em></span><span class="koboSpan" id="kobo.43.1"> coordinates always start at the same height as the drawable, which makes the top </span><span class="emphasis"><em><span class="koboSpan" id="kobo.44.1">Y</span></em></span><span class="koboSpan" id="kobo.45.1"> coordinates equal to the sum of its position and height.</span></p></div></div><p><span class="koboSpan" id="kobo.46.1">Finally, we can take a look at the fragment shader and actually do some filling up of fragments:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">uniform sampler2D texture; 
uniform vec3 SurfaceNormal; 
uniform float BaseHeight; 
in float Height; 
void main() 
{ 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
  float value = (BaseHeight - (Height * SurfaceNormal.z)) / 255.0; 
  gl_FragColor = vec4(value, value, value, pixel.a); 
} 
</span></pre><p><span class="koboSpan" id="kobo.48.1">As shown previously, it takes in the diffuse texture, the surface normal, the base height of the drawable, and the interpolated </span><code class="literal"><span class="koboSpan" id="kobo.49.1">Height</span></code><span class="koboSpan" id="kobo.50.1"> value from the vertex shader. </span><span class="koboSpan" id="kobo.50.2">The diffuse pixel is then sampled in order to use its alpha value for transparency. </span><span class="koboSpan" id="kobo.50.3">The height value itself is calculated by subtracting the result of the pixel height being multipled by the surface normal's </span><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">Z </span></em></span><span class="koboSpan" id="kobo.52.1">component from the base height of the drawable. </span><span class="koboSpan" id="kobo.52.2">The whole thing is finally divided by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.53.1">255</span></em></span><span class="koboSpan" id="kobo.54.1"> because we want to store color information in a normalized format.</span></p></div><div class="section" title="Changing the lighting shader"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec92"/><span class="koboSpan" id="kobo.55.1">Changing the lighting shader</span></h2></div></div></div><p><span class="koboSpan" id="kobo.56.1">Finally, the light pass shader can be changed as well by sampling the height map:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">... 
</span><span class="koboSpan" id="kobo.57.2">uniform sampler2D HeightMap; 
... 
</span><span class="koboSpan" id="kobo.57.3">void main() 
{ 
  ... 
  </span><span class="koboSpan" id="kobo.57.4">float pixelheight = texture2D(HeightMap, gl_TexCoord[0].xy).r 
    * 255; 
  vec3 PixelCoordinates = 
    vec3(gl_FragCoord.x, gl_FragCoord.y, pixelheight); 
  ... 
  </span><span class="koboSpan" id="kobo.57.5">gl_FragColor = finalPixel; 
} 
</span></pre><p><span class="koboSpan" id="kobo.58.1">Once the pixel height is sampled and multiplied by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.59.1">255</span></em></span><span class="koboSpan" id="kobo.60.1"> to bring it back to world coordinates, all we need to do is replace the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">gl_FragCoord.z</span></code><span class="koboSpan" id="kobo.62.1"> value with </span><code class="literal"><span class="koboSpan" id="kobo.63.1">pixelHeight</span></code><span class="koboSpan" id="kobo.64.1"> when calculating the distance between a pixel and a fragment. </span><span class="koboSpan" id="kobo.64.2">Yes, that's really all it takes!</span></p><p><span class="koboSpan" id="kobo.65.1">The </span><code class="literal"><span class="koboSpan" id="kobo.66.1">HeightMap</span></code><span class="koboSpan" id="kobo.67.1"> can then be actually passed to the shader for sampling, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.68.1">void LightManager::RenderScene() { 
  ... 
  </span><span class="koboSpan" id="kobo.68.2">if (renderer-&gt;UseShader("LightPass")) { 
    // Light pass. 
    </span><span class="koboSpan" id="kobo.68.3">... 
    </span><span class="koboSpan" id="kobo.68.4">shader-&gt;setUniform("HeightMap", 
      m_materialMaps[MaterialMapType::Height]-&gt;getTexture()); 
    ... 
  </span><span class="koboSpan" id="kobo.68.5">} 
  ... 
</span><span class="koboSpan" id="kobo.68.6">} 
</span></pre><p><span class="koboSpan" id="kobo.69.1">This gives us a very nice effect that can actually show off the height of a particular structure, given it has elevated properly and has the right normals:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.70.1"><img src="graphics/image_08_014.jpg" alt="Changing the lighting shader"/></span></div><p><span class="koboSpan" id="kobo.71.1">The light post on the left has no normals, while the post on the right has normals that face the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.72.1">+Z</span></em></span><span class="koboSpan" id="kobo.73.1"> direction. </span><span class="koboSpan" id="kobo.73.2">The light position is exactly the same in both these images.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">If you are still here, congratulations! </span><span class="koboSpan" id="kobo.2.2">That was quite a bit of information to take in, but just as our world is finally beginning to take shape visually, we're about to embark on an even more stunning feature that will be discussed in the next chapter. </span><span class="koboSpan" id="kobo.2.3">See you there!</span></p></div></div></div></body></html>