- en: Chapter 11. Working with the System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing files in a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing and creating files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data quickly from one process to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing interprocess communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pointers in shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fastest way to read files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines – saving the state and postponing the execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each operating system has many system calls doing almost the same things in
    slightly different ways. Those calls differ in performance and differ from one
    operating system to another. Boost provides portable and safe wrappers around
    those calls. Knowledge of those wrappers is essential for writing good programs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to working with the operating system. We have seen how
    to deal with network communications and signals in [Chapter 6](ch06.html "Chapter 6. Manipulating
    Tasks"), *Manipulating Tasks*. In this chapter, we'll take a closer look at the
    filesystem and creating and deleting files. We'll see how data can be passed between
    different system processes, how to read files at maximum speed, and how to perform
    other tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Listing files in a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are STL functions and classes to read and write data to files. But there
    are no functions to list files in a directory, to get the type of a file, or to
    get access rights for a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how such iniquities can be fixed using Boost. We'll be creating a
    program that lists names, write accesses, and types of files in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some basics of C++ would be more than enough to use this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe requires linking against the `boost_system` and `boost_filesystem`
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe and the next one are about portable wrappers for working with a
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the following two headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to specify a directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After specifying the directory, loop through its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is getting the file info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now output the file info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step would be to output the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it. Now, if we run the program, it will output something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions and classes of `Boost.Filesystem` just wrap around system-specific
    functions to work with files.
  prefs: []
  type: TYPE_NORMAL
- en: Note the usage of `/` in step 2\. POSIX systems use a slash to specify paths;
    Windows, by default, uses backslashes. However, Windows understands forward slashes
    too, so `./` will work on all of the popular operating systems, and it means "the
    current directory".
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at step 3, where we are default constructing the `boost::filesystem::directory_iterator`
    class. It works just as a `std::istream_iterator` class, which acts as an `end`
    iterator when default constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4 is a tricky one, not because this function is hard to understand, but
    because lots of conversions are happening. Dereferencing the `begin` iterator
    returns `boost::filesystem::directory_entry`, which is implicitly converted to
    `boost::filesystem::path`, which is used as a parameter for the `boost::filesystem::status`
    function. Actually, we can do much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read the reference documentation carefully to avoid unrequired implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5 is obvious, so we are moving to step 6 where implicit conversion to
    the path happens again. A better solution would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `begin->path()` returns a const reference to the `boost::filesystem::path`
    variable that is contained inside `boost::filesystem::directory_entry`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, `Boost.Filesystem` is not a part of C++11, but it is proposed
    for inclusion in the next C++ standard. `Boost.Filesystem` currently misses support
    for rvalue references, but still remains one of the simplest and most portable
    libraries to work with a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Erasing and creating files and directories* recipe will show another example
    of the usage of `Boost.Filesystem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read Boost''s official documentation for `Boost.Filesystem` to get more info
    about its abilities; it is available at the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Boost.Filesystem` library is proposed for inclusion in C++1y. The draft
    is available at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.h).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing and creating files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In these lines, we attempt to write something to `file.txt` in the `dir/subdir`
    directory. This attempt will fail if there is no such directory. The ability to
    work with filesystems is necessary for write a good working code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we'll construct a directory and a subdirectory, write some data
    to a file, and try to create `symlink`, and if the symbolic link's creation fails,
    erase the created file. We will also avoid using exceptions as a mechanism of
    error reporting, preferring some form of return codes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how that can be done in an elegant way using Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and the `std::ofstream` class is required for this recipe.
    `Boost.Filesystem` is not a header-only library, so code in this recipe requires
    linking against the `boost_system` and `boost_filesystem` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We continue to deal with portable wrappers for a filesystem, and in this recipe
    we''ll see how to modify the directory content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we''ll need to include some headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need a variable to store errors (if any):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also create directories, if required, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we will write data to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to attempt to create `symlink`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to check that the file is accessible through `symlink`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or remove the created file, if `symlink` creation failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw `boost::system::error_code` in action in almost all of the recipes in
    , *Manipulating Tasks*. It can store information about errors and is widely used
    throughout the Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not provide an instance of `boost::system::error_code` to the `Boost.Filesystem`
    functions, the code will compile well, but when an error occurs, an exception
    will be thrown. Usually a `boost::filesystem::filesystem_error` exception is thrown
    unless you are having trouble with allocating memory.
  prefs: []
  type: TYPE_NORMAL
- en: Take a careful look at step 3\. We used the `boost::filesystem::create_directories`
    function, not `boost::filesystem::create_directory`, because the latter cannot
    create subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining steps are trivial to understand and should not cause any trouble.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::system::error_code` class is a part of C++11 and can be found in
    the `<system_error>` header in the `std::` namespace. The classes of `Boost.Filesystem`
    are not a part of C++11, but they are proposed for inclusion in C++1y, which will
    probably be ready in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a small recommendation for those who are going to use `Boost.Filesystem`;
    when the errors occurring during filesystem operations are routine, use `boost::system::error_codes`.
    Otherwise, catching exceptions is preferable and more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Listing files in a directory* recipe also contains information about `Boost.Filesystem`.
    Read Boost's official documentation to get more information and examples at [http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data quickly from one process to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we write programs that will communicate with each other a lot. When
    programs are run on different machines, using sockets is the most common technique
    for communication. But if multiple processes run on a single machine, we can do
    much better!
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how to make a single memory fragment available from different
    processes using the `Boost.Interprocess` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. Knowledge of atomic variables
    is also required (take a look at the *See also* section for more information about
    atomics). Some platforms require linking against the runtime library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example we''ll be sharing a single atomic variable between processes,
    making it increment when a new process starts and decrement when the process terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to include the following header for interprocess communications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following the header, `typedef` and a check will help us make sure that atomics
    are usable for this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create or get a shared segment of memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get or construct an `atomic` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Work with the `atomic` variable in the usual way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Destroy the `atomic` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all! Now if we run multiple instances of this program simultaneously,
    we'll see that each new instance increments its index value.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea of this recipe is to get a segment of memory that is visible to
    all processes, and place some data in it. Let's take a look at step 3, where we
    retrieve such a segment of memory. Here, `shm-cache` is the name of the segment
    (different segments differ in name); you can give any names you like to the segments.
    The first parameter is `boost::interprocess::open_or_create`, which says that
    `boost::interprocess::managed_shared_memory` will open an existing segment with
    the name `shm-cache`, or it will construct it. The last parameter is the size
    of the segment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The size of the segment must be big enough to fit the `Boost.Interprocess` library-specific
    data in it. That's why we used `1024` and not `sizeof(atomic_t)`. But it does
    not really matter, because the operating system will round this value to the nearest
    larger supported value, which is usually equal to or larger than 4 kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 is a tricky one as we are doing multiple tasks at the same time here.
    In part `2` of this step, we will find or construct a variable with the name `shm-counter`
    in the segment. In part `3` of step 4, we will provide a parameter, which will
    be used for the initialization of a variable if it has not been found in step
    2\. This parameter will be used only if the variable is not found and must be
    constructed, otherwise it is ignored. Take a closer look at the second line (part
    `1`). See the call to the dereference operator `*`. We are doing it because `segment.find_or_construct<atomic_t>`
    returns a pointer to `atomic_t`, and working with bare pointers in C++ is a bad
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using atomic variables in shared memory! This is required,
    because two or more processes can simultaneously work with the same `shm-counter`
    atomic variable.
  prefs: []
  type: TYPE_NORMAL
- en: You must be very careful when working with objects in shared memory; do not
    forget to destroy them! In step 6, we are destroying the object and segment using
    their names.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a closer look at step 2 where we are checking for `BOOST_ATOMIC_INT_LOCK_FREE
    != 2`. We are checking that `atomic_t` won't use mutexes. This is very important,
    because usually, mutexes won't work in shared memory. So if `BOOST_ATOMIC_INT_LOCK_FREE`
    is not equal to `2`, we'll get an undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, C++11 has no interprocess classes, and as far as I know, `Boost.Interprocess`
    is not proposed for inclusion in C++1y.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a managed segment is created, it cannot increase in size! Make sure that
    you are creating segments big enough for your needs, or take a look at the *See
    also* section for information about increasing managed segments.
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory is the fastest way for processes to communicate, and works for
    processes that can share memory. That usually means that the processes must run
    on the same host or on a **symmetric multiprocessing** (**SMP**) cluster.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Syncing interprocess communications* recipe will tell you more about shared
    memory, interprocess communications, and syncing access to resources in shared
    memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Fast access to common resource using atomics* recipe in Chapter 5,
    Multithreading for more information about atomics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost's official documentation for `Boost.Interprocess` may also help; it is
    available at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to increase managed segments is described at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin)[g_managed_memory](http://g_managed_memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing interprocess communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to create shared memory and how to place
    some objects in it. Now it's time to do something useful. Let's take an example
    from the *Creating a work_queue class* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, and make it work for multiple processes. At the end of this
    example, we'll get a class that can store different tasks and pass them between
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses techniques from the previous one. You will also need to read
    the *Creating a work_queue class* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, and get its main idea. The example requires linking against
    the runtime library on some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is considered that spawning separate subprocesses instead of threads makes
    a program more reliable, because termination of a subprocess won't terminate the
    main process. We won't argue with that assumption here, and just see how data
    sharing between processes can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of headers are required for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to define our structure, `task_structure`, which will be used to
    store tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s start writing the `work_queue` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the members of `work_queue` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialization of members should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to make some minor changes to the member functions of `work_queue`,
    such as using `scoped_lock_t` instead of the original unique locks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are doing almost exactly the same things as in the *Creating
    a work_queue class* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, but when we allocate the data in shared memory, additional care
    must be taken when doing memory allocations or using synchronization primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Take additional care when storing shared memory objects that have pointers or
    references as member fields. We'll see how to cope with pointers in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at step 2\. We did not use `boost::function` as a task type because
    it has pointers in it, so it won't work in shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is interesting because of `allocator_t`. It is a type of allocator that
    all containers must use to allocate elements. It is a stateful allocator, which
    means that it will be copied along with the container. Also, it cannot be default
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: If memory is not allocated from the shared memory segment, it won't be available
    to other processes; that's why a specific allocator for containers is required.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 is pretty trivial, except that we have only references to `tasks_`, `mutex_`,
    and `cond_`. This is done because objects themselves are constructed in the shared
    memory. So, `work_queue` can only store references to them.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5 we are initializing members. This code will be familiar to you; we
    were doing exactly the same things in the previous recipe. Note that we are providing
    an instance of allocator to `tasks_` while constructing it. That's because `allocator_t`
    cannot be constructed by the container itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shared memory is not destructed at the exit event of a process, so we can run
    the program once, post the tasks to a work queue, stop the program, start some
    other program, and get tasks stored by the first instance of the program. Shared
    memory will be destroyed only at restart, or if you explicitly call `segment.deallocate("work-queue");`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As was mentioned in the previous recipe, C++11 has no classes from `Boost.Interprocess`.
    Moreover, you must not use C++11 or C++03 containers in shared memory segments.
    Some of those containers may work, but that behavior is not portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look inside some of the `<boost/interprocess/containers/*.hpp>` headers,
    you''ll find that they just use containers from the `Boost.Containers` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Containers of `Boost.Interprocess` have all of the benefits of the `Boost.Containers`
    library, including rvalue references and their emulation on older compilers.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Interprocess` is the fastest solution for communication between processes
    that are running on the same machine.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using pointers in shared memory* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read [Chapter 5](ch05.html "Chapter 5. Multithreading"), *Multithreading*, for
    more information about synchronization primitives and multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to Boost''s official documentation for the `Boost.Interprocess` library
    for more examples and information; it is available at the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using pointers in shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is hard to imagine writing some C++ core classes without pointers. Pointers
    and references are everywhere in C++, and they do not work in shared memory! So
    if we have a structure like this in shared memory and assign the address of some
    integer variable in shared memory to `pointer_`, we won''t get the correct address
    in the other process that will attempt to use `pointer_` from that instance of
    `with_pointer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How can we fix that?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe is required for understanding this one. The example requires
    linking against the runtime system library on some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fixing it is very simple; we need only to replace the pointer with `offset_ptr<>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are free to use it as a normal pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot use pointers in shared memory because when a piece of shared memory
    is mapped into the address space of a process, its address is valid only for that
    process. When we are getting the address of a variable, it is just a local address
    for that process; other processes will map shared memory to a different base address,
    and as a result the variable address will differ.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4880OS_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So how can we work with an address that is always changing? There is a trick!
    As the pointer and structure are in the same shared memory segment, the distance
    between them does not change. The idea behind `boost::interprocess::offset_ptr`
    is to remember that distance, and on dereference, add the distance value to the
    process-dependent address of the `offset_ptr` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The offset pointer imitates the behavior of pointers, so it is a drop-in replacement
    that can be applied fast.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not place classes that may have pointers or references into shared memory!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An offset pointer works slightly slower than the usual pointer because on each
    dereference, it is required to compute the address. But this difference is not
    usually sufficient to bother you.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has no offset pointers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boost's official documentation contains many examples and more advanced `Boost.Interprocess`
    features; it is available at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *fastest way to read files* recipe contains information about some nontraditional
    usage of the `Boost.Interprocess` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fastest way to read files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All around the Internet, people are asking "What is the fastest way to read
    files?". Let''s make our task for this recipe even harder: "What is the fastest
    and most portable way to read binary files?"'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and the `std::fstream` containers is required for this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique from this recipe is widely used by applications critical to input
    and output performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to include two headers from the `Boost.Interprocess` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to open a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main part of this recipe is mapping all of the files to memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Getting a pointer to the data in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! Now we can work with a file just as with normal memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All popular operating systems have the ability to map a file to processes' address
    space. After such mapping is done, the process can work with those addresses just
    as with normal memory. The operating system will take care of all of the file
    operations, such as caching and read-ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it faster than traditional read/writes? That's because in most cases
    read/write is implemented as memory mapping and copying data to a user-specified
    buffer. So read usually does more work.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the case of STL, we must provide an open mode when opening a file.
    See step 2 where we provided the `boost::interprocess::read_only` mode.
  prefs: []
  type: TYPE_NORMAL
- en: See step 3 where we mapped a whole file at once. This operation is actually
    really fast, because the OS does not read data from the disk, but waits for the
    requests to be a part of the mapped region. After a part of the mapped region
    was requested, the OS loads that part of the file from the disk. As we can see,
    memory mapping operations are lazy, and the size of the mapped region does not
    affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, a 32-bit OS cannot memory-map large files, so you'll need to map them
    in pieces. POSIX (Linux) operating systems require `_FILE_OFFSET_BITS=64` to be
    defined for the whole project to work with large files on a 32-bit platform. Otherwise,
    the OS won't be able to map parts of the file that are beyond 4 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to measure the performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Just as expected, memory-mapped files are slightly faster than traditional reads.
    We can also see that pure C methods have the same performance as that of the C++
    `std::ifstream` class, so please do not use functions related to `FILE*` in C++.
    They are just for C, not for C++!
  prefs: []
  type: TYPE_NORMAL
- en: 'For optimal performance of `std::ifstream`, do not forget to open files in
    binary mode and read data by blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, classes for memory mapping files are not part of C++11, and it
    looks like they won't be in C++14 either.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to memory-mapped regions is also a very fast operation. The OS will
    cache the writes and won't flush modifications to the disc immediately. There
    is a difference between the OS and the `std::ofstream` data caching. If the `std::ofstream`
    data is cached by an application and it terminates, the cached data can be lost.
    When data is cached by the OS, termination of the application won't lead to data
    loss. Power failures and system crashes lead to data loss in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple processes map a single file, and one of the processes modifies the
    mapped region, the changes are immediately visible to the other processes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Boost`.`Interprocess` library contains a lot of useful features to work
    with the system; not all of them are covered in this book. You can read more about
    this great library at the official site:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interproces)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coroutines – saving the state and postponing the execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, plenty of embedded devices still have only a single core. Developers
    write for those devices, trying to squeeze maximum performance out of them. Using
    `Boost.Threads` or some other thread library for such devices is not effective;
    the OS will be forced to schedule threads for execution, manage resources, and
    so on, as the hardware cannot run them in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: So how can we make a program switch to the execution of a subprogram while waiting
    for some resource in the main part?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and templates is required for this recipe. Reading some
    recipes about `Boost.Function` may also help.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is about coroutines, subroutines that allow multiple entry points.
    Multiple entry points give us an ability to suspend and resume the execution of
    a program at certain locations, switching to/from other subprograms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.Coroutine` library will take care of almost everything. We just
    need to include its header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a coroutine type with the required signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a coroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can execute the subprogram while waiting for an event in the main program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The coroutine method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At step 2, we are describing the signature of our subprogram using the function
    signature `std::string& (std::size_t)` as a template parameter. This means that
    the subprogram accepts `std::size_t` and returns a reference to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is interesting because of the `coroutine_task` signature. Note that this
    signature is common for all coroutine tasks. `caller` is the variable that will
    be used to get parameters from the caller and to return the result of the execution
    back.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 requires additional care because the constructor of `corout_t` will automatically
    start the coroutine execution. That's why we call `caller(result)` at the beginning
    of the coroutine task (it returns us to the `main` method).
  prefs: []
  type: TYPE_NORMAL
- en: When we call `coroutine(10)` in step 4, we are causing a coroutine program to
    execute. Execution will jump to step 5 right after the first `caller(result)`
    method, where we'll get a value `10` from `caller.get()` and will continue our
    execution until `caller(result)`. After that, execution will return to step 4,
    right after the `coroutine(10)` call. Next, a call to `coroutine(10)` or `coroutine(300)`
    will continue the execution of the subprogram from the place right after the second
    `caller(result)` method at step 5.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4880OS_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at `std::string& s = coroutine.get()` in step 4\. Here, we'll be
    getting a reference to the `std::string` result from the beginning of `coroutine_task`
    described in step 5\. We can even modify it, and `coroutine_task` will see the
    modified value. Let me describe the main difference between coroutines and threads.
    When a coroutine is executed, the main task does nothing. When the main task is
    executed, the coroutine task does nothing. You have no such guarantee with threads.
    With coroutines, you explicitly specify when to start a subtask and when to finish
    it. In a single core environment, threads can switch at any moment of time; you
    cannot control that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use thread's local storage and do not call `boost::coroutines::coroutine<>::operator()`
    from inside the same coroutine; do not call `boost::coroutines::coroutine<>::get()`
    when a coroutine task is finished. These operations lead to undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While switching threads, the OS does a lot of work, so it is not a very fast
    operation. However, with coroutines, you have full control over switching tasks;
    moreover, you do not need to do any OS-specific internal kernel work. Switching
    coroutines is much faster than switching threads, however, it's not as fast as
    calling `boost::function`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Coroutine` library will take care of calling a destructor for variables
    in a coroutine task, so there's no need to worry about leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coroutines use the `boost::coroutines::detail::forced_unwind` exception to free
    resources that are not derived from `std::exception`. You must take care not to
    catch that exception in coroutine tasks.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has no coroutines. But coroutines use features of C++11 when possible,
    and even emulate rvalue references on C++03 compilers. You cannot copy `boost::coroutines::coroutine<>`,
    but you can move them using `Boost.Move`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boost''s official documentation contains more examples, performance notes,
    restrictions, and use cases for the `Boost.Coroutines` library; it is available
    at the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a look at recipes from [Chapter 3](ch03.html "Chapter 3. Managing Resources"),
    *Managing Resources*, and [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, to get the difference between the `Boost.Coroutine`, `Boost.Thread`,
    and `Boost.Function` libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
