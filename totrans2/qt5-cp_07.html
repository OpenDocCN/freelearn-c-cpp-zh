<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch07" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Chapter 7. Parsing JSON and XML Documents to Use Online APIs</h1></div></div></div><p class="calibre9">In this chapter, you'll find the powerful application, Qt, running on the popular Android devices. Following the introduction of Qt application development for Android, it also utilizes online APIs, which usually return JSON or XML documents. The topics that are covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Setting up Qt for Android</li><li class="listitem">Parsing JSON results</li><li class="listitem">Parsing XML results</li><li class="listitem">Building Qt applications for Android</li><li class="listitem">Parsing JSON in QML</li></ul></div><div><div><div><div><h1 class="title2"><a id="ch07lvl1sec48" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Setting up Qt for Android</h1></div></div></div><p class="calibre9">Qt for Android<a id="id317" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> requires at least an API level 10 (for Android 2.3.3 platforms). Most Qt modules are supported, which means your Qt application can be deployed on Android with little <a id="id318" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>or no modification. For development, both Qt Widget-based applications and Qt Quick applications in Qt Creator are supported on Android. However, setting up Qt for Android on a Windows PC is not very straightforward. Therefore, before we venture deeper into anything, let's set up the development environment for Qt on Android.</p><p class="calibre9">First, you need to install Qt for Android. If you're using an online installer, remember to select the Android components, as shown in the following screenshot:</p><div><img src="img/4615OS_07_01.jpg" alt="Setting up Qt for Android" class="calibre65"/></div><p class="calibre9">Here, we only <a id="id319" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>chose <strong class="calibre10">Android armv7</strong>, which enables us to deploy applications for ARMv7 Android devices. If you're using an offline installer, download Qt for the Android installer.</p><p class="calibre9">Now, let's install a <strong class="calibre10">Java Development Kit</strong> (<strong class="calibre10">JDK</strong>). There is no way to get rid of Java, since Android heavily depends on it. Also, note that you need to install at least Version 6 of JDK, according to <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://doc.qt.io/qt-5/androidgs.html">http://doc.qt.io/qt-5/androidgs.html</a>. You can download<a id="id320" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> JDK from <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>. You also need to<a id="id321" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> set a <code class="literal">JAVA_HOME</code> environment variable in the JDK installation directory, <code class="literal">D:\Program Files\Java\jdk1.8.0_25</code>.</p><p class="calibre9">Now, let's install two kits from Google, the Android SDK and Android NDK. Always remember to download the latest version; here we use Android SDK r24.0.2 and Android NDK r10b.</p><p class="calibre9">After you install the Android SDK, run the SDK Manager. Install or update <strong class="calibre10">Android SDK Tools</strong>, <strong class="calibre10">Android SDK Platform-tools</strong>, <strong class="calibre10">Android SDK Build-tools</strong>, <strong class="calibre10">Google USB Driver</strong>, at least one API level's <strong class="calibre10">SDK Platform</strong>, and <strong class="calibre10">ARM EABI v7a System Image</strong> for the purpose of our task. For this chapter, we installed API 19's <strong class="calibre10">SDK Platform</strong> and <strong class="calibre10">ARM EABI v7a System Image</strong>. Then, edit the <code class="literal">PATH</code> environment variable. Add the path of the platform and SDK<a id="id322" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> tools to it with a semicolon as a separator. If <code class="literal">D:\Program Files (x86)\Android\android-sdk</code> is the path of <strong class="calibre10">Android SDK Tools</strong>, it would be as follows:</p><p class="calibre9">
<code class="literal">D:\Program Files (x86)\Android\android-sdk\platform-tools;D:\Program Files (x86)\Android\android-sdk\tools</code>
</p><div><div><h3 class="title4"><a id="note21" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Android SDK and NDK can be obtained <a id="id323" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>on the Android developer website, <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://developer.android.com">http://developer.android.com</a>.</p></div></div><p class="calibre9">Once you download the<a id="id324" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> NDK, extract the <code class="literal">zip</code> file to your hard drive, <code class="literal">D:\android-ndk</code>. Then, add an<a id="id325" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> environment variable named <code class="literal">ANDROID_NDK_ROOT</code> with the value, <code class="literal">D:\android-ndk</code>.</p><p class="calibre9">Similar procedures should be applied<a id="id326" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> for Apache Ant. You can download it from <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://ant.apache.org/bindownload.cgi">http://ant.apache.org/bindownload.cgi</a>. We use Apache Ant 1.9.4 in this book. There is no environment variable that needs to be set here. Now, reboot your computer if you're using Windows so that the environment variables can be refreshed and loaded correctly.</p><p class="calibre9">Open AVD Manager and create a new virtual device. You'd better choose a smaller virtual device such as Nexus S for this exercise, as shown in the following screenshot. Feel free to change it if you want, but remember to tick <strong class="calibre10">Use Host GPU</strong>, which will make the virtual device use GLES to accelerate the graphics. If you haven't turned that on, you'll get an extremely slow virtual device that might even be too sluggish to test applications on.</p><div><img src="img/4615OS_07_02.jpg" alt="Setting up Qt for Android" class="calibre66"/></div><p class="calibre9">Now, open Qt Creator; navigate to <strong class="calibre10">Tools</strong> | <strong class="calibre10">Options</strong>. See if Qt Version in <strong class="calibre10">Build &amp; Run</strong> has an Android entry. You <a id="id327" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>have to manually add Qt for Android if it's not<a id="id328" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> there. Then, switch to the <strong class="calibre10">Android</strong> options, set up JDK, Android SDK, Android NDK, and Ant, as shown in the following screenshot:</p><div><img src="img/4615OS_07_03.jpg" alt="Setting up Qt for Android" class="calibre67"/></div><p class="calibre9">The warning for missing architectures can be safely ignored because we won't develop applications for MIPS and x86 Android in this chapter. However, pay attention to it if you need to deploy your applications on these hardware platforms.</p><p class="calibre9">Click on <strong class="calibre10">Apply</strong> and switch to the <strong class="calibre10">Devices</strong> options. There should be a <strong class="calibre10">Run on Android</strong> item in the <strong class="calibre10">Device</strong> combobox. An auto-detected <strong class="calibre10">Android for armeabi-v7a</strong> is expected if you navigate to <strong class="calibre10">Build &amp; Run</strong> | <strong class="calibre10">Kits</strong> now.</p><p class="calibre9">Now, let's test if we can run a Qt application on our virtual Android device. Open AVD Manager and start the virtual device. We start it first because it could take a lot of time. Then, open Qt Creator and make a simple application.</p><div><ol class="orderedlist"><li class="listitem1">Create a new Qt Widget-based application project.</li><li class="listitem1">Select <strong class="calibre10">Android for armeabi-v7a Kit</strong>.</li><li class="listitem1">Edit <code class="literal">mainwindow.ui</code> and drag a label to <code class="literal">centralWidget</code>.</li><li class="listitem1">Change the <strong class="calibre10">MainWindow</strong> page's layout to <strong class="calibre10">Lay Out Vertically</strong> (or others) so that the widgets will be stretched automatically.</li><li class="listitem1">Change the label's text to <code class="literal">Hello Android!</code> or something else.</li></ol></div><p class="calibre9">Wait for the time-consuming virtual Android device until it's fully started. If it's not, click on <strong class="calibre10">Run</strong> and wait for <a id="id329" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>a few minutes. You'll see this application<a id="id330" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> running on our virtual Android device. As seen in the following screenshot, the Qt for Android development environment is set up successfully. So, we can move on and write an application that can use a camera to take photos:</p><div><img src="img/4615OS_07_04.jpg" alt="Setting up Qt for Android" class="calibre68"/></div><div><div><h3 class="title4"><a id="tip12" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">Testing an application on a desktop while it's incomplete, and then testing it on a mobile platform would save plenty of time compared to testing on the virtual Android device<a id="id331" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> all the time. In addition to this, it's much faster to test on a real device than a virtual one.</p></div></div><p class="calibre9">Instead of tolerating a<a id="id332" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> slow emulator, we're going to first develop the application on a desktop, then deploy it on an actual Android device and see if there is anything mismatched or inappropriate for mobile devices. Make any relevant changes accordingly. This could save you plenty of time. However, it still takes a longer time, even though the actual Android device is much more responsive than the virtual one.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch07lvl1sec49" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Parsing JSON results</h1></div></div></div><p class="calibre9">There are tons of<a id="id333" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> companies that provide developers APIs to access to their services, including the dictionary, weather, and so on. In this chapter, we'll use Yahoo! Weather as an example to show you how to use its online API to get weather data. For more details about <a id="id334" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Yahoo! Weather API, refer to <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://developer.yahoo.com/weather/">https://developer.yahoo.com/weather/</a>.</p><p class="calibre9">Now, let's create a new project named <code class="literal">Weather_Demo</code>, which is a Qt Widget-based application project. As usual, let's first design the UI.</p><div><img src="img/4615OS_07_05.jpg" alt="Parsing JSON results" class="calibre69"/></div><p class="calibre9">We've removed the menu bar, tool bar, and status bar as we did before. Then, we added a <strong class="calibre10">Label</strong>, <strong class="calibre10">Line Edit</strong>, and <strong class="calibre10">Push Button</strong> on top of <code class="literal">centralWidget</code>. Their object names are <code class="literal">woeidLabel</code>, <code class="literal">woeidEdit</code>, and <code class="literal">okButton</code>, respectively. After this, another label named <code class="literal">locationLabel</code> is used to display the location returned from the API. The red rectangle is <strong class="calibre10">Horizontal Layout</strong>, which consists of <code class="literal">tempLabel</code> and <code class="literal">windLabel</code>, which are both <strong class="calibre10">Label</strong> and are<a id="id335" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> separated by <strong class="calibre10">Horizontal Spacer</strong>. Append <strong class="calibre10">Label</strong>, whose object name is <code class="literal">attrLabel</code>, and then change its alignment to <code class="literal">AlignRight</code> and <code class="literal">AlignBottom</code>.</p><p class="calibre9">
<strong class="calibre10">Where On Earth ID</strong> (<strong class="calibre10">WOEID</strong>) is a<a id="id336" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> 32-bit identifier that is unique and nonrepetitive. By using WOEID, we can avoid duplicity. However, this also means that we need to find out what WOEID is used for our location. Luckily, there are several websites that provide you with easy-to-use online tools to get the WOEID. One of them is<a id="id337" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the Zourbuth project, <strong class="calibre10">Yahoo! WOEID Lookup</strong>, which can be accessed at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://zourbuth.com/tools/woeid/">http://zourbuth.com/tools/woeid/</a>.</p><p class="calibre9">Now, let's move on and focus on the parsing of API results. We created a new C++ class, <code class="literal">Weather</code>, to deal with the Yahoo! Weather API. I'd like to introduce you to parsing the <strong class="calibre10">JSON</strong> (<strong class="calibre10">JavaScript Object Notation</strong>) results before XML. However, before we cook the <code class="literal">Weather</code> class, remember to add network to <code class="literal">QT</code> in the project file. In this case, the <code class="literal">Weather_Demo.pro</code> project file looks like this:</p><div><pre class="programlisting">QT       += core gui network

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = Weather_Demo
TEMPLATE = app

SOURCES += main.cpp\
        mainwindow.cpp \
        weather.cpp

HEADERS  += mainwindow.h \
            weather.h

FORMS    += mainwindow.ui</pre></div><p class="calibre9">Now, we can<a id="id338" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> write the <code class="literal">Weather</code> class. Its <code class="literal">weather.h</code> header file is pasted as follows:</p><div><pre class="programlisting">#ifndef WEATHER_H
#define WEATHER_H

#include &lt;QObject&gt;
#include &lt;QJsonDocument&gt;
#include &lt;QJsonObject&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QImage&gt;

class Weather : public QObject
{
    Q_OBJECT
    public:
    explicit Weather(QObject *parent = 0);

    signals:
    void updateFinished(const QString &amp;location, const QString &amp;temp, const QString &amp;wind);
    void imageDownloaded(const QImage &amp;);

    public slots:
    void updateData(const QString &amp;woeid);
    void getAttrImg();

    private:
    QNetworkAccessManager *naManager;
    QNetworkReply *imgReply;
    QImage attrImg;

    private slots:
    void onSSLErrors(QNetworkReply *);
    void onQueryFinished(QNetworkReply *);
};

#endif // WEATHER_H</pre></div><p class="calibre9">In addition to the weather information query, we also use this class to get an attribution image, which is stated in the Yahoo! documentation. It is kind of trivial in traditional Qt/C++ that we have<a id="id339" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to use <code class="literal">QNetworkAccessManager</code> to access <code class="literal">QUrl</code>, because <code class="literal">QJsonDocument</code> cannot load from <code class="literal">QUrl</code> directly. Anyway, let's see how we get the result from the Yahoo! Weather API in the <code class="literal">weather.cpp</code> file. The header part includes the following lines:</p><div><pre class="programlisting">#include &lt;QDebug&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QJsonArray&gt;
#include "weather.h"</pre></div><p class="calibre9">Then, let's see the constructor of <code class="literal">Weather</code>. Here, we simply construct the <code class="literal">QNetworkAccessManager</code> object, <code class="literal">naManager</code>, and connect its signals:</p><div><pre class="programlisting">Weather::Weather(QObject *parent) :
    QObject(parent)
{
    naManager = new QNetworkAccessManager(this);

    connect(naManager, &amp;QNetworkAccessManager::finished, this, &amp;Weather::onQueryFinished);
    connect(naManager, &amp;QNetworkAccessManager::sslErrors, this, &amp;Weather::onSSLErrors);
}</pre></div><p class="calibre9">The <code class="literal">onSSLErrors</code> slot is simply to let the <code class="literal">QNetworkReply</code> object ignore all the SSL errors. This won't cause any serious problems in this case. However, if you're dealing with a secure communication or anything else that needs to validate the connection, you may wish to look into the error.</p><div><pre class="programlisting">void Weather::onSSLErrors(QNetworkReply *re)
{
    re-&gt;ignoreSslErrors();
}</pre></div><p class="calibre9">Then, let's check<a id="id340" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the <code class="literal">updateData</code> function before <code class="literal">onQueryFinished</code>. Here, we construct <code class="literal">QUrl</code>, which is the Yahoo! Weather API's exact address. Note that you don't need to use an HTML code for <code class="literal">QUrl</code>. In fact, it'd be better to use a space along with the other symbols directly. After this, similar to the previous chapter, we use <code class="literal">QNetworkRequest</code> to wrap this <code class="literal">QUrl</code> and dispatch the request through <code class="literal">QNetworkAccessManager</code>.</p><div><pre class="programlisting">void Weather::updateData(const QString &amp;woeid)
{
    QUrl url("https://query.yahooapis.com/v1/public/yql?q=select * from weather.forecast where woeid = " + woeid + "&amp;format=json");
    QNetworkRequest req(url);
    naManager-&gt;get(req);
}</pre></div><p class="calibre9">As for the<a id="id341" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">getAttrImg</code> function, it's almost the same. The only difference is that this function is used to get an <a id="id342" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>attribution image instead of weather information. We store the reply as <code class="literal">imgReply</code> so that we can distinguish the image from the weather.</p><div><pre class="programlisting">void Weather::getAttrImg()
{
    QUrl url("https://poweredby.yahoo.com/purple.png");
    QNetworkRequest req(url);
    imgReply = naManager-&gt;get(req);
}</pre></div><p class="calibre9">If the corresponding <code class="literal">QNetworkReply</code> object is finished, the <code class="literal">onQueryFinished</code> slot function will be executed, which is shown in the following code. After all the pavement, let's see what's inside this function. We can check whether there is any error in the reply at the very beginning. Then, if it's <code class="literal">imgReply</code>, we cook <code class="literal">QImage</code> from the data and emit a signal to send this image out. If none of these happen, we'll parse the weather from the JSON reply.</p><div><pre class="programlisting">void Weather::onQueryFinished(QNetworkReply *re)
{
    if (re-&gt;error() != QNetworkReply::NoError) {
        qDebug() &lt;&lt; re-&gt;errorString();
        re-&gt;deleteLater();
        return;
    }

    if (re == imgReply) {
        attrImg = QImage::fromData(imgReply-&gt;readAll());
        emit imageDownloaded(attrImg);
        imgReply-&gt;deleteLater();
        return;
    }

    QByteArray result = re-&gt;readAll();
    re-&gt;deleteLater();

    QJsonParseError err;
    QJsonDocument doc = QJsonDocument::fromJson(result, &amp;err);
    if (err.error != QJsonParseError::NoError) {
        qDebug() &lt;&lt; err.errorString();
        return;
    }
    QJsonObject obj = doc.object();
    QJsonObject res = obj.value("query").toObject().value("results").toObject().value("channel").toObject();

    QJsonObject locObj = res["location"].toObject();
    QString location;
    for(QJsonObject::ConstIterator it = locObj.constBegin(); it != locObj.constEnd(); ++it) {
        location.append((*it).toString());
        if ((it + 1) != locObj.constEnd()) {
            location.append(", ");
        }
    }

    QString temperature = res["item"].toObject()["condition"].toObject()["temp"].toString() + res["units"].toObject()["temperature"].toString();

    QJsonObject windObj = res["wind"].toObject();
    QString wind;
    for(QJsonObject::ConstIterator it = windObj.constBegin(); it != windObj.constEnd(); ++it) {
        wind.append(it.key());
        wind.append(": ");
        wind.append((*it).toString());
        wind.append("\n");
    }

    emit updateFinished(location, temperature, wind);
}</pre></div><p class="calibre9">As I mentioned<a id="id343" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> before, it is trivial. First, we read the result from <code class="literal">QNetworkReply</code>, and then use <code class="literal">QJsonDocument::fromJson</code> to parse the <code class="literal">byte</code> array as a JSON document. If there is an error during the process, we simply print the error string and return. Then, we need to get <code class="literal">QJsonObject</code> contained in <code class="literal">QJsonDocument</code>. Only then <a id="id344" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>can we parse all the information inside it. The formatted result using <code class="literal">560743</code> as the WOEID is shown as follows:</p><div><pre class="programlisting">{
  "query":{
    "count":1,
    "created":"2014-12-05T23:19:54Z",
    "lang":"en-GB",
    "results":{
      "channel":{
        "title":"Yahoo! Weather - Dublin, IE",
        "link":"http://us.rd.yahoo.com/dailynews/rss/weather/Dublin__IE/*http://weather.yahoo.com/forecast/EIXX0014_f.html",
        "description":"Yahoo! Weather for Dublin, IE",
        "language":"en-us",
        "lastBuildDate":"Fri, 05 Dec 2014 9:59 pm GMT",
        "ttl":"60",
        "location":{
          "city":"Dublin",
          "country":"Ireland",
          "region":"DUB"
        },
        "units":{
          "distance":"mi",
          "pressure":"in",
          "speed":"mph",
          "temperature":"F"
        },
        "wind":{
          "chill":"29",
          "direction":"230",
          "speed":"8"
        },
        "atmosphere":{
          "humidity":"93",
          "pressure":"30.36",
          "rising":"1",
          "visibility":"6.21"
        },
        "astronomy":{
          "sunrise":"8:22 am",
          "sunset":"4:09 pm"
        },
        "image":{
          "title":"Yahoo! Weather",
          "width":"142",
          "height":"18",
          "link":"http://weather.yahoo.com",
          "url":"http://l.yimg.com/a/i/brand/purplelogo//uh/us/news-wea.gif"
        },
        "item":{
          "title":"Conditions for Dublin, IE at 9:59 pm GMT",
          "lat":"53.33",
          "long":"-6.29",
          "link":"http://us.rd.yahoo.com/dailynews/rss/weather/Dublin__IE/*http://weather.yahoo.com/forecast/EIXX0014_f.html",
          "pubDate":"Fri, 05 Dec 2014 9:59 pm GMT",
          "condition":{
            "code":"29",
            "date":"Fri, 05 Dec 2014 9:59 pm GMT",
            "temp":"36",
            "text":"Partly Cloudy"
          },
          "description":"\n&lt;img src=\"http://l.yimg.com/a/i/us/we/52/29.gif\"/&gt;&lt;br /&gt;\n&lt;b&gt;Current Conditions:&lt;/b&gt;&lt;br /&gt;\nPartly Cloudy, 36 F&lt;BR /&gt;\n&lt;BR /&gt;&lt;b&gt;Forecast:&lt;/b&gt;&lt;BR /&gt;\nFri - Partly Cloudy. High: 44 Low: 39&lt;br /&gt;\nSat - Mostly Cloudy. High: 48 Low: 41&lt;br /&gt;\nSun - Mostly Sunny/Wind. High: 43 Low: 37&lt;br /&gt;\nMon - Mostly Sunny/Wind. High: 43 Low: 37&lt;br /&gt;\nTue - PM Light Rain/Wind. High: 52 Low: 38&lt;br /&gt;\n&lt;br /&gt;\n&lt;a href=\"http://us.rd.yahoo.com/dailynews/rss/weather/Dublin__IE/*http://weather.yahoo.com/forecast/EIXX0014_f.html\"&gt;Full Forecast at Yahoo! Weather&lt;/a&gt;&lt;BR/&gt;&lt;BR/&gt;\n(provided by &lt;a href=\"http://www.weather.com\" &gt;The Weather Channel&lt;/a&gt;)&lt;br/&gt;\n",
          "forecast":[
          {
            "code":"29",
            "date":"5 Dec 2014",
            "day":"Fri",
            "high":"44",
            "low":"39",
            "text":"Partly Cloudy"
          },
          {
            "code":"28",
            "date":"6 Dec 2014",
            "day":"Sat",
            "high":"48",
            "low":"41",
            "text":"Mostly Cloudy"
          },
          {
            "code":"24",
            "date":"7 Dec 2014",
            "day":"Sun",
            "high":"43",
            "low":"37",
            "text":"Mostly Sunny/Wind"
          },
          {
            "code":"24",
            "date":"8 Dec 2014",
            "day":"Mon",
            "high":"43",
            "low":"37",
            "text":"Mostly Sunny/Wind"
          },
          {
            "code":"11",
            "date":"9 Dec 2014",
            "day":"Tue",
            "high":"52",
            "low":"38",
            "text":"PM Light Rain/Wind"
          }
          ],
          "guid":{
            "isPermaLink":"false",
            "content":"EIXX0014_2014_12_09_7_00_GMT"
          }
        }
      }
    }
  }
}</pre></div><div><div><h3 class="title4"><a id="note22" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">For details <a id="id345" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>about JSON, visit <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.json.org">http://www.json.org</a>.</p></div></div><p class="calibre9">As you can see, all the information is stored inside <code class="literal">query/results/channel</code>. Therefore, we need to convert it to <code class="literal">QJsonObject</code>, level by level. As you can see in the code, <code class="literal">QJsonObject res</code> is <code class="literal">channel</code>. Note that the <code class="literal">value</code> function will return a <code class="literal">QJsonValue</code> object <a id="id346" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>and you will need to call <code class="literal">toObject()</code> to make it <code class="literal">QJsonObject</code> before you can use the <code class="literal">value</code> function to parse the value again. After this, it's pretty straightforward. The <code class="literal">locObj</code> object is the location where we use a <code class="literal">for</code> loop to put the values together, where as <code class="literal">QJsonObject::ConstIterator</code> is just Qt's wrapper of STL <code class="literal">const_iterator</code>.</p><p class="calibre9">To obtain the current temperature, we need to go through a similar journey to channel because the temperature is in item/condition/temp, while its unit is <code class="literal">units/temperature</code>.</p><p class="calibre9">As for the <code class="literal">wind</code> section, we use a lazy way to retrieve the data. The <code class="literal">windObj</code> line is not a single value statement; instead, it has several keys and values. Therefore, we use a <code class="literal">for</code> loop to walk through this array and retrieve both of its keys along with its value, and simply put them together.</p><p class="calibre9">Now, let's go back to the <code class="literal">MainWindow</code> class to see how to interact with the <code class="literal">Weather</code> class. The header file of <code class="literal">MainWindow</code>, which is <code class="literal">mainwindow.h</code>, is pasted here:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;
#include "weather.h"

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;
  Weather *w;

private slots:
  void onOkButtonClicked();
  void onAttrImageDownloaded(const QImage &amp;);
  void onWeatherUpdateFinished(const QString &amp;location, const QString &amp;temp, const QString &amp;wind);
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">We declare a <code class="literal">Weather</code> object pointer, <code class="literal">w</code>, as the <code class="literal">MainWindow</code> class's private member. Meanwhile, <code class="literal">onOkButtonClicked</code> is<a id="id347" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the handler when <code class="literal">okButton</code> gets clicked. The <code class="literal">onAttrImageDownloaded</code> and <code class="literal">onWeatherUpdateFinished</code> functions will be coupled with the <code class="literal">Weather</code> class's signals. Now, let's see what's inside the source file:</p><div><pre class="programlisting">#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);
  w = new Weather(this);

  connect(ui-&gt;okButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onOkButtonClicked);
  connect(w, &amp;Weather::updateFinished, this, &amp;MainWindow::onWeatherUpdateFinished);
  connect(w, &amp;Weather::imageDownloaded, this, &amp;MainWindow::onAttrImageDownloaded);
  w-&gt;getAttrImg();
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::onOkButtonClicked()
{
  w-&gt;updateData(ui-&gt;woeidEdit-&gt;text());
}

void MainWindow::onAttrImageDownloaded(const QImage &amp;img)
{
  ui-&gt;attrLabel-&gt;setPixmap(QPixmap::fromImage(img));
}

void MainWindow::onWeatherUpdateFinished(const QString &amp;location, const QString &amp;temp, const QString &amp;wind)
{
  ui-&gt;locationLabel-&gt;setText(location);
  ui-&gt;tempLabel-&gt;setText(temp);
  ui-&gt;windLabel-&gt;setText(wind);
}</pre></div><p class="calibre9">In the<a id="id348" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> constructor, apart from the signals connection and the <code class="literal">w</code> object's construction, we call <code class="literal">getAttrImg</code> of <code class="literal">w</code> to retrieve the attribution image. When the image is downloaded, the <code class="literal">onAttrImageDownloaded</code> slot function will be executed where the image will be displayed on <code class="literal">attrLabel</code>.</p><p class="calibre9">Once the user clicks on <code class="literal">okButton</code>, the <code class="literal">onOkButtonClicked</code> slot function gets executed, where we call the <code class="literal">updateData</code> function of the <code class="literal">Weather</code> class to pass the WOEID. Then, when the update is finished, the <code class="literal">updateFinished</code> signal is emitted and <code class="literal">onWeatherUpdateFinished</code> is executed. We just use these three <code class="literal">QString</code> objects to set the corresponding label's text.</p><p class="calibre9">Now, test your application to see if it's running as shown in this screenshot:</p><div><img src="img/4615OS_07_06.jpg" alt="Parsing JSON results" class="calibre18"/></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch07lvl1sec50" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Parsing XML results</h1></div></div></div><p class="calibre9">Although a lot of APIs provide both XML and JSON results, you may still find that some of them only<a id="id349" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> offer one format. Besides, you might feel that parsing JSON in C++/Qt is not a pleasant process. You may remember how easy it is to parse the XML model in QML/Qt Quick. Well, let's see how to do this in C++/Qt.</p><p class="calibre9">To make use of an <code class="literal">xml</code> module, we have to add <code class="literal">xml</code> to QT in the <code class="literal">project</code> file, the same way we did to network. This time, Qt has provided an XML reader class called <code class="literal">QXmlStreamReader</code> to help us parse the XML documents. The first thing we need to do is to change the <code class="literal">updateData</code> function in the <code class="literal">Weather</code> class to let the Yahoo! Weather API return an XML result.</p><div><pre class="programlisting">void Weather::updateData(const QString &amp;woeid)
{
  QUrl url("https://query.yahooapis.com/v1/public/yql?q=select * from weather.forecast where woeid = " + woeid + "&amp;format=xml");
    QNetworkRequest req(url);
    naManager-&gt;get(req);
}</pre></div><p class="calibre9">The changing of <code class="literal">&amp;format=json</code> to <code class="literal">&amp;format=xml</code> needs to be done here. In contrast to this, there is a lot of work to do in the <code class="literal">onQueryFinished</code> slot function. The old JSON part is<a id="id350" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> commented out so that we can write the XML parsing code. The modified function without the comment is shown as follows:</p><div><pre class="programlisting">void Weather::onQueryFinished(QNetworkReply *re)
{
  if (re-&gt;error() != QNetworkReply::NoError) {
    qDebug() &lt;&lt; re-&gt;errorString();
    re-&gt;deleteLater();
    return;
  }

  if (re == imgReply) {
    attrImg = QImage::fromData(imgReply-&gt;readAll());
    emit imageDownloaded(attrImg);
    imgReply-&gt;deleteLater();
    return;
  }

  QByteArray result = re-&gt;readAll();
  re-&gt;deleteLater();

  QXmlStreamReader xmlReader(result);
  while (!xmlReader.atEnd() &amp;&amp; !xmlReader.hasError()) {
    QXmlStreamReader::TokenType token = xmlReader.readNext();
    if (token == QXmlStreamReader::StartElement) {
      QStringRef name = xmlReader.name();
      if (name == "channel") {
        parseXMLChannel(xmlReader);
      }
    }
  }
}</pre></div><p class="calibre9">Here, <code class="literal">parseXMLChannel</code> is a newly created member function. We can use a separate function to make our code neat and tidy.</p><div><div><h3 class="title4"><a id="note23" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Remember to declare the <code class="literal">parseXMLChannel</code> function in the header file.</p></div></div><p class="calibre9">Its definition is pasted as follows:</p><div><pre class="programlisting">void Weather::parseXMLChannel(QXmlStreamReader &amp;xml)
{
  QString location, temperature, wind;
  QXmlStreamReader::TokenType token = xml.readNext();
  while (token != QXmlStreamReader::EndDocument) {
    if (token == QXmlStreamReader::EndElement || xml.name().isEmpty()) {
      token = xml.readNext();
      continue;
    }

    QStringRef name = xml.name();
    if (name == "location") {
      QXmlStreamAttributes locAttr = xml.attributes();
      location = locAttr.value("city").toString() + ", " + locAttr.value("country").toString() + ", " + locAttr.value("region").toString();
    }
    else if (name == "units") {
      temperature = xml.attributes().value("temperature").toString();
    }
    else if (name == "wind") {
      QXmlStreamAttributes windAttr = xml.attributes();
      for (QXmlStreamAttributes::ConstIterator it = windAttr.begin(); it != windAttr.end(); ++it) {
        wind.append(it-&gt;name().toString());
        wind.append(": ");
        wind.append(it-&gt;value());
        wind.append("\n");
      }
    }
    else if (name == "condition") {
      temperature.prepend(xml.attributes().value("temp").toString());
      break;//we got all information, exit the loop
    }
    token = xml.readNext();
  }

  emit updateFinished(location, temperature, wind);
}</pre></div><p class="calibre9">Before we <a id="id351" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>walk through <code class="literal">parseXMLChannel</code> function, I'd like to show you what the XML document looks like, shown as follows:</p><div><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;query  yahoo:count="1" yahoo:created="2014-12-06T22:50:22Z" yahoo:lang="en-GB"&gt;
  &lt;results&gt;
    &lt;channel&gt;
      &lt;title&gt;Yahoo! Weather - Dublin, IE&lt;/title&gt;
      &lt;link&gt;http://us.rd.yahoo.com/dailynews/rss/weather/Dublin__IE/*http://weather.yahoo.com/forecast/EIXX0014_f.html&lt;/link&gt;
      &lt;description&gt;Yahoo! Weather for Dublin, IE&lt;/description&gt;
      &lt;language&gt;en-us&lt;/language&gt;
      &lt;lastBuildDate&gt;Sat, 06 Dec 2014 9:59 pm GMT&lt;/lastBuildDate&gt;
      &lt;ttl&gt;60&lt;/ttl&gt;
      &lt;yweather:location  city="Dublin" country="Ireland" region="DUB"/&gt;
      &lt;yweather:units  distance="mi" pressure="in" speed="mph" temperature="F"/&gt;
      &lt;yweather:wind  chill="41" direction="230" speed="22"/&gt;
      &lt;yweather:atmosphere  humidity="93" pressure="30.03" rising="2" visibility="6.21"/&gt;
      &lt;yweather:astronomy  sunrise="8:24 am" sunset="4:07 pm"/&gt;
      &lt;image&gt;
        &lt;title&gt;Yahoo! Weather&lt;/title&gt;
        &lt;width&gt;142&lt;/width&gt;
        &lt;height&gt;18&lt;/height&gt;
        &lt;link&gt;http://weather.yahoo.com&lt;/link&gt;
        &lt;url&gt;http://l.yimg.com/a/i/brand/purplelogo//uh/us/news-wea.gif&lt;/url&gt;
      &lt;/image&gt;
      &lt;item&gt;
        &lt;title&gt;Conditions for Dublin, IE at 9:59 pm GMT&lt;/title&gt;
        &lt;geo:lat &gt;53.33&lt;/geo:lat&gt;
        &lt;geo:long &gt;-6.29&lt;/geo:long&gt;
        &lt;link&gt;http://us.rd.yahoo.com/dailynews/rss/weather/Dublin__IE/*http://weather.yahoo.com/forecast/EIXX0014_f.html&lt;/link&gt;
        &lt;pubDate&gt;Sat, 06 Dec 2014 9:59 pm GMT&lt;/pubDate&gt;
        &lt;yweather:condition  code="27" date="Sat, 06 Dec 2014 9:59 pm GMT" temp="48" text="Mostly Cloudy"/&gt;
        &lt;description&gt;&lt;![CDATA[&lt;img src="img/27.gif"/&gt;&lt;br /&gt; &lt;b&gt;Current Conditions:&lt;/b&gt;&lt;br /&gt; Mostly Cloudy, 48 F&lt;BR /&gt; &lt;BR /&gt;&lt;b&gt;Forecast:&lt;/b&gt;&lt;BR /&gt; Sat - Light Rain/Wind Late. High: 48 Low: 42&lt;br /&gt; Sun - Mostly Sunny/Wind. High: 44 Low: 37&lt;br /&gt; Mon - Sunny. High: 43 Low: 37&lt;br /&gt; Tue - Showers/Wind. High: 53 Low: 39&lt;br /&gt; Wed - Partly Cloudy/Wind. High: 45 Low: 39&lt;br /&gt; &lt;br /&gt; &lt;a href="http://us.rd.yahoo.com/dailynews/rss/weather/Dublin__IE/*http://weather.yahoo.com/forecast/EIXX0014_f.html"&gt;Full Forecast at Yahoo! Weather&lt;/a&gt;&lt;BR/&gt;&lt;BR/&gt; (provided by &lt;a href="http://www.weather.com" &gt;The Weather Channel&lt;/a&gt;)&lt;br/&gt;]]&gt;&lt;/description&gt;
        &lt;yweather:forecast  code="11" date="6 Dec 2014" day="Sat" high="48" low="42" text="Light Rain/Wind Late"/&gt;
        &lt;yweather:forecast  code="24" date="7 Dec 2014" day="Sun" high="44" low="37" text="Mostly Sunny/Wind"/&gt;
        &lt;yweather:forecast  code="32" date="8 Dec 2014" day="Mon" high="43" low="37" text="Sunny"/&gt;
        &lt;yweather:forecast  code="11" date="9 Dec 2014" day="Tue" high="53" low="39" text="Showers/Wind"/&gt;
        &lt;yweather:forecast  code="24" date="10 Dec 2014" day="Wed" high="45" low="39" text="Partly Cloudy/Wind"/&gt;
        &lt;guid isPermaLink="false"&gt;EIXX0014_2014_12_10_7_00_GMT&lt;/guid&gt;
      &lt;/item&gt;
    &lt;/channel&gt;
  &lt;/results&gt;
&lt;/query&gt;
&lt;!--  total: 27  --&gt;
&lt;!--  engine4.yql.bf1.yahoo.com  --&gt;</pre></div><p class="calibre9">As you can deduce, the XML structure shares a lot of similarities with the JSON document. For<a id="id352" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> instance, all the data we need is still stored in query/results/channel. The difference is, however, more significant than you may have expected.</p><div><div><h3 class="title4"><a id="note24" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">If you want to learn<a id="id353" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> XML thoroughly, check the XML tutorial at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.w3schools.com/xml/">http://www.w3schools.com/xml/</a>.</p></div></div><p class="calibre9">In the <code class="literal">onQueryFinished</code> slot, we use a <code class="literal">while</code> loop to let <code class="literal">xmlReader</code> keep reading until the end or until an error. The<a id="id354" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">readNext</code> function of the <code class="literal">QXmlStreamReader</code> class will read the next token and return its type. <code class="literal">TokenType</code> is an enum, which describes the type of token currently being read. Each time you call <code class="literal">readNext</code>, <code class="literal">QXmlStreamReader</code> will move forward by one token. If we want to read all the data of one element, we may have to read it from the beginning. Therefore, we use an <code class="literal">if</code> statement to ensure that the token is at the starting. In addition to this, we test if we're reading the channel now. Then, we call <code class="literal">parseXMLChannel</code> to retrieve all data that we need.</p><p class="calibre9">In the <code class="literal">parseXMLChannel</code> function, pretty much the<a id="id355" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> same strategy is used. We test the <code class="literal">name</code> element so that we know which stage we are in. One thing worth your attention is that all prefixes such as <code class="literal">yweather:</code> are omitted. Hence, you should use <code class="literal">location</code> instead of <code class="literal">yweather:location</code>. Other parts are similar to their counterparts in JSON, where <code class="literal">QStringRef</code> is similar to <code class="literal">QJsonValue</code>. Last but not least, <code class="literal">QXmlStreamReader</code> is a stream reader, which means that it reads in order. In other words, we can break the <code class="literal">while</code> loop after we get <code class="literal">temp</code> in <code class="literal">condition</code> since <code class="literal">condition</code> is the last element that we're interested in.</p><p class="calibre9">After these changes, you can build and run this application again and you should expect it to run in the same manner.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch07lvl1sec51" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Building Qt applications for Android</h1></div></div></div><p class="calibre9">You may<a id="id356" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> wonder how to build Qt applications for <a id="id357" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Android devices since this application is built for desktop PCs. Well, it's much easier than you thought.</p><div><ol class="orderedlist"><li class="listitem1">Switch to <strong class="calibre10">Projects</strong> mode.</li><li class="listitem1">Click on <strong class="calibre10">Add Kit</strong> and select <strong class="calibre10">Android for armeabit-v7a (GCC 4.9 and Qt 5.3.2)</strong>. Note that the text may differ a little bit.</li><li class="listitem1">Plug in your phone if you're using it as the target Android device.</li><li class="listitem1">Open <strong class="calibre10">Command Prompt</strong> and run <code class="literal">adb devices</code>. Make sure your device is on the list.</li></ol></div><p class="calibre9">Now, click on <strong class="calibre10">Run</strong> and Qt will prompt a dialog asking you to select the Android device, as shown in the <a id="id358" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>following screenshot:</p><div><img src="img/4615OS_07_07.jpg" alt="Building Qt applications for Android" class="calibre70"/></div><p class="calibre9">We choose to run our <a id="id359" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>application on an actual Android device, which is an HTC One phone in this case. If you don't have any available Android devices, you may have to create a virtual device, as mentioned at the beginning of this chapter. For both the options, choose the device and click on the <strong class="calibre10">OK</strong> button.</p><div><div><h3 class="title4"><a id="note25" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">On an actual Android device, you need to go to <strong class="calibre10">Settings</strong> and turn on <strong class="calibre10">USB debugging</strong> in <strong class="calibre10">Developer options</strong>.</p></div></div><p class="calibre9">As you can see from the following screenshot, the demonstration runs well. It definitely needs ongoing improvements and UI optimization before submitting, though. However, remember that<a id="id360" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> we designed and built this application for a<a id="id361" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> desktop PC! We have just built it for a mobile phone without any modification and it runs as expected.</p><div><img src="img/4615OS_07_08.jpg" alt="Building Qt applications for Android" class="calibre71"/></div><p class="calibre9">When you test the application, all the information is printed to the <strong class="calibre10">Application Output</strong> panel in Qt Creator. This could be useful when your application runs unexpectedly.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch07lvl1sec52" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Parsing JSON in QML</h1></div></div></div><p class="calibre9">Let's rewrite<a id="id362" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the weather demo in QML. You will find out how easy and <a id="id363" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>elegant it is to write such an application in QML. Since the XML part is already covered in the previous chapter, we'll focus on parsing JSON this time.</p><p class="calibre9">First, create a new Qt Quick application project named <code class="literal">Weather_QML</code>. Keep the other settings as default, which means we use <strong class="calibre10">Qt Quick Controls</strong>. Remember to tick the checkbox<a id="id364" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> of the Android kit.</p><p class="calibre9">Create a new<a id="id365" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> QML file named <code class="literal">Weather.qml</code> to mimic the <code class="literal">Weather</code> class in the previous C++ code. This file is pasted here:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Controls 1.2

Rectangle {
  Column {
    anchors.fill: parent
    spacing: 6

    Label {
      id: location
      width: parent.width
      fontSizeMode: Text.Fit
      minimumPointSize: 9
      font.pointSize: 12
    }

    Row {
      spacing: 20
      width: parent.width
      height: parent.height

      Label {
        id: temp
        width: parent.width / 2
        height: parent.height
        fontSizeMode: Text.Fit
        minimumPointSize: 12
        font.pointSize: 72
        font.bold: true
      }

      Label {
        id: wind
        width: temp.width - 20
        height: parent.height
        fontSizeMode: Text.Fit
        minimumPointSize: 9
        font.pointSize: 24
      }
    }
  }

  Image {
    id: attrImg
    anchors { right: parent.right; bottom: parent.bottom }
    fillMode: Image.PreserveAspectFit
    source: 'https://poweredby.yahoo.com/purple.png'
  }

  function query (woeid) {
    var url = 'https://query.yahooapis.com/v1/public/yql?q=select * from weather.forecast where woeid = ' + woeid + '&amp;format=json'
    var res
    var doc = new XMLHttpRequest()
    doc.onreadystatechange = function() {
      if (doc.readyState == XMLHttpRequest.DONE) {
        res = doc.responseText
        parseJSON(res)
      }
    }
    doc.open('GET', url, true)
    doc.send()
  }

  function parseJSON(data) {
    var obj = JSON.parse(data)

    if (typeof(obj) == 'object') {
      if (obj.hasOwnProperty('query')) {
        var ch = obj.query.results.channel
        var loc = '', win = ''
        for (var lk in ch.location) {
          loc += ch.location[lk] + ', '
        }
        for (var wk in ch.wind) {
          win += wk + ': ' + ch.wind[wk] + '\n'
        }
        location.text = loc
        temp.text = ch.item.condition.temp + ch.units.temperature
        wind.text = win
      }
    }
  }
}</pre></div><p class="calibre9">The first part is just a QML version UI of the previous application. You may want to pay attention to the <code class="literal">fontSizeMode</code> and <code class="literal">minimumPointSize</code> property in <code class="literal">Label</code>. These properties are newly introduced in Qt 5, and enable the text scale to be dynamically adjusted. By setting <code class="literal">Text.Fit</code> as <code class="literal">fontSizeMode</code>, it'll shrink the text if <code class="literal">height</code> or <code class="literal">width</code> is not sufficient for the text, where <code class="literal">minimumPointSize</code> is the minimum point size. The text will get elided if it can't display at a minimum size. Similar to the <code class="literal">elide</code> property, you have to <a id="id366" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>explicitly set the <code class="literal">width</code> and <code class="literal">height</code> property of <code class="literal">Text</code> or <code class="literal">Label</code> to make this dynamic mechanism work.</p><p class="calibre9">The attribution image is displayed in a slightly different way from C++. We utilize the flexibility of Qt Quick to float <code class="literal">Image</code> on top of the whole item by setting only <code class="literal">anchors</code>. In addition to this, we don't need to use <code class="literal">QNetworkAccessManager</code> to download the image. It's all in one.</p><p class="calibre9">After the UI part, we<a id="id367" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> create the two JavaScript functions to do the dirty work. The<a id="id368" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">query</code> function is used to send an <code class="literal">http</code> request and pass the received data to the <code class="literal">parseJSON</code> function once it's done. Don't get confused by XML in <code class="literal">XMLHttpRequest</code>; it's just a traditional naming convention. Then, we create a<a id="id369" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">handler</code> function for <code class="literal">onreadystatechanged</code>, which is to call <code class="literal">parseJSON</code> when the request is done. Note that the <code class="literal">open</code> function won't send the request, only the <code class="literal">send</code> function does.</p><p class="calibre9">It's still short and clean in the <code class="literal">parseJSON</code> function. <code class="literal">JSON.parse</code> will return a <code class="literal">JSON</code> object if it is parsed successfully. Therefore, we need to test whether its type is <code class="literal">object</code> before we get into parsing. Then, we just do one more test to see whether it has <code class="literal">query</code> as its property. If so, we can start extracting data from <code class="literal">obj</code>. Unlike its C++ counterpart, we can treat all its keys as its properties and use the <code class="literal">dot</code> operation to access them directly. To shorten the operations, we first create a <code class="literal">ch</code> variable, which is <code class="literal">query/results/channel</code>. Next, we extract the data from the <code class="literal">ch</code> object. Finally, we change the text directly.</p><div><div><h3 class="title4"><a id="note26" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">The <code class="literal">ch.location</code> and <code class="literal">ch.wind</code> objects can be treated as <code class="literal">QVariantMap</code> objects. Thus, we can use the <code class="literal">for</code> loop to easily extract the values.</p></div></div><p class="calibre9">Let's edit the <code class="literal">main.qml</code> file as shown here:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Controls 1.2
import "qrc:/"

ApplicationWindow {
  visible: true
  width: 240
  height: 320
  title: qsTr("Weather QML")

  Row {
    id: inputField
    anchors { top: parent.top; topMargin: 10; left: parent.left; leftMargin: 10; right: parent.right; rightMargin: 10 }
    spacing: 6

    Label {
      id: woeidLabel
      text: "WOEID"
    }
    TextField {
      width: inputField.width - woeidLabel.width
      inputMethodHints: Qt.ImhDigitsOnly
      onAccepted: weather.query(text)
    }
  }

  Weather {
    anchors { top: inputField.bottom; topMargin: 10; left: parent.left; leftMargin: 10; right: parent.right; rightMargin: 10; bottom: parent.bottom; bottomMargin: 10 }
    id: weather
  }
}</pre></div><p class="calibre9">
<code class="literal">Row</code> is the same WOEID input panel, for which we don't create an <strong class="calibre10">OK</strong> button this time. Instead, we<a id="id370" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> handle the accepted signal in <code class="literal">onAccepted</code> by calling the <code class="literal">query</code> function in<a id="id371" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">weather</code>, which is a <code class="literal">Weather</code> element. We set the <code class="literal">inputMethodHints</code> property to <code class="literal">Qt.ImhDigitsOnly</code>, which is useful on mobile platforms. This application should run almost the same as the C++ one or should we say better.</p><div><img src="img/4615OS_07_09.jpg" alt="Parsing JSON in QML" class="calibre72"/></div><p class="calibre9">The <code class="literal">inputMethodHints</code> property <a id="id372" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>may seem useless on a desktop; indeed, you need to use <code class="literal">inputMask</code> <a id="id373" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>and <code class="literal">validator</code> to restrict the acceptable input. However, it shows its power on mobiles, as follows:</p><div><img src="img/4615OS_07_10.jpg" alt="Parsing JSON in QML" class="calibre71"/></div><p class="calibre9">As you can see, <code class="literal">inputMethodHints</code> not only restricts the input, but it also provides a better experience for <a id="id374" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>users. This is also viable in a C++/Qt development; you can find the relevant functions<a id="id375" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to achieve this. The whole point in QML is that parsing the JSON and XML documents is easier and tidier than C++.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch07lvl1sec53" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Summary</h1></div></div></div><p class="calibre9">After this chapter, you're expected to handle common tasks and write types of real-world applications. You'll get your own understanding of Qt Quick and traditional Qt. It's also a current trend to write hybrid applications, which make full use of both of them by writing the C++ plugins to enhance QML. QML has an unbeatable advantage of flexible UI design, which is even more obvious on mobile platforms. While the development part is nearing the end, in the next chapter we'll talk about how to support multiple languages.</p></div></div>



  </body></html>