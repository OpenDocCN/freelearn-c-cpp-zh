["```cpp\nvoid CheckBoundaries(Sprite* p_sprite)\n{\n  if (p_sprite->GetPosition().x < 0)\n  {\n    p_sprite->SetVelocity(0.0f);\n  }\n  else if (p_sprite->GetPosition().x > screen_width)\n  {\n    p_sprite->SetVelocity(0.0f);\n  }\n}\n```", "```cpp\ninputManager->Update(p_deltaTime);\nProcessInput();\nCheckBoundaries(player);\n\n```", "```cpp\nRect m_collision;\n```", "```cpp\nconst Rect GetCollisionRect() const;\nvoid SetCollisionRectOffset(const Rect p_rect) { m_collision = p_rect; }\n```", "```cpp\nconst Sprite::Rect Sprite::GetCollisionRect() const\n{\n  Rect rect;\n  rect.left = m_position.x + m_collision.left;\n  rect.right = m_position.x + m_size.width + m_collision.right;\n  rect.top = m_position.y + m_collision.top;\n  rect.bottom = m_position.y + m_size.height + m_collision.bottom;\n\n  return rect;\n}\n```", "```cpp\nm_collision.left = 0.0f;\nm_collision.right = 0.0f;\nm_collision.top = 0.0f;\nm_collision.bottom = 0.0f;\n```", "```cpp\nSprite::Rect collision;\ncollision.left = 34.0f;\ncollision.right = -10.0f;\ncollision.top = 0.0f;\ncollision.bottom = 0.0f;\nrobot_left->SetCollisionRectOffset(collision);\nrobot_right->SetCollisionRectOffset(collision);\n\nreturn true;\n```", "```cpp\nvoid CheckBoundaries(Sprite* p_sprite)\n{\n  Sprite::Rect check = p_sprite->GetCollisionRect();\n\n  if (check.left < 0.0f)\n  {\n    p_sprite->SetVelocity(0.0f);\n  }\n  else if (check.right > screen_width)\n  {\n    p_sprite->SetVelocity(0.0f);\n  }\n}\n```", "```cpp\nvoid CheckBoundaries(Sprite* p_sprite)\n{\n  Sprite::Rect check = p_sprite->GetCollisionRect();\n float offset;\n  float x;\n  float y;\n\n  if (check.left < 0.0f)\n  {\n    p_sprite->SetVelocity(0.0f);\n    offset = check.left;\n x = p_sprite->GetPosition().x - offset;\n y = p_sprite->GetPosition().y;\n p_sprite->SetPosition(x, y);\n  }\n  else if (check.right > screen_width)\n  {\n    p_sprite->SetVelocity(0.0f);\n    offset = screen_width - check.right;\n x = p_sprite->GetPosition().x + offset;\n y = p_sprite->GetPosition().y;\n p_sprite->SetPosition(x, y);\n  }\n  if (check.top < 0.0f)\n  {\n    p_sprite->SetVelocity(0.0f);\n    offset = check.top;\n y = p_sprite->GetPosition().y - offset;\n x = p_sprite->GetPosition().x;\n p_sprite->SetPosition(x, y);\n  }\n  else if (check.bottom > screen_height)\n  {\n    p_sprite->SetVelocity(0.0f);\n    offset = screen_height - check.bottom;\n y = p_sprite->GetPosition().y + offset;\n x = p_sprite->GetPosition().x;\n p_sprite->SetPosition(x, y);\n  }\n}\n```", "```cpp\nvoid CheckBackground()\n{\n  float leftThreshold = 0.0f;\n  float rightThreshold = -(background->GetSize().width - screen_width);\n  if (background->GetPosition().x > 0)\n  {\n    background->SetPosition(0.0f, background->GetPosition().y);\n  }\n  else if (background->GetPosition().x < rightThreshold)\n  {\n    background->SetPosition(rightThreshold, background->GetPosition().y);\n  }\n}\n```", "```cpp\ninputManager->Update(p_deltaTime);\nProcessInput();\nCheckBoundaries(player);\nCheckBackground();\n\n```", "```cpp\nint m_value;\n```", "```cpp\nvoid SetValue(const int p_value) { m_value = p_value; }\nconst int GetValue() const { return m_value; }\n```", "```cpp\nSprite* pickup;\n```", "```cpp\npickup = new Sprite(1);\npickup->SetFrameSize(26.0f, 50.0f);\npickup->SetNumberOfFrames(1);\npickup->AddTexture(\"resources/oil.png\");\npickup->IsVisible(false);\npickup->IsActive(false);\npickup->SetValue(50);\n```", "```cpp\n#include <stdlib.h>\n#include <time.h>\n```", "```cpp\nfloat pickupSpawnThreshold;\nfloat pickupSpawnTimer;\n```", "```cpp\nsrand(time(NULL));\npickupSpawnThreshold = 15.0f;\npickupSpawnTimer = 0.0f;\n```", "```cpp\nvoid SpawnPickup(float p_DeltaTime)\n{\n  if (pickup->IsVisible() == false)\n  {\n    pickupSpawnTimer += p_DeltaTime;\n    if (pickupSpawnTimer > pickupSpawnThreshold)\n    {\n      float marginX = pickup->GetSize().width;\n      float marginY = pickup->GetSize().height;\n      float spawnX = (rand() % (int)(screen_width - (marginX * 2))) + marginX;\n      float spawnY = screen_height - ((rand() % (int)(player->GetSize().height - (marginY * 1.5))) + marginY);\n      pickup->SetPosition(spawnX, spawnY);\n      pickup->IsVisible(true);\n      pickup->IsActive(true);\n      pickupSpawnTimer = 0.0f;\n    }\n  }\n}\n```", "```cpp\nif (m_gameState == GS_Running)\n{\n  background->Update(p_deltaTime);\n  robot_left->Update(p_deltaTime);\n  robot_right->Update(p_deltaTime);\n  robot_left_strip->Update(p_deltaTime);\n  robot_right_strip->Update(p_deltaTime);\n\n  pause->Update(p_deltaTime);\n  resume->Update(p_deltaTime);\n\n  pickup->Update(p_deltaTime);\n SpawnPickup(p_deltaTime);\n}\n```", "```cpp\nvoid Render()\n{\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n\n  background->Render();\n  robot_left->Render();\n  robot_right->Render();\n  robot_left_strip->Render();\n  robot_right_strip->Render();\n\n  pause->Render();\n  resume->Render();\n\n  pickup->Render();\n  SwapBuffers(hDC);\n}\n```", "```cpp\nc = sqrt(a * a + b * b);\nif (c <= r1 + r2) return true;\n```", "```cpp\nc = a * a + b * b;\nif (c<= r1 * r1 + r2 * r2) return true;\n```", "```cpp\nfloat m_radius;\nPoint m_center;\n```", "```cpp\nvoid SetRadius(const GLfloat p_radius) { m_radius = p_radius; }\nconst float GetRadius() const { return m_radius; }\nvoid SetCenter(const Point p_center) { m_center = p_center; }\nconst Point GetCenter() const;\nconst bool IntersectsCircle(const Sprite* p_sprite) const;\n```", "```cpp\nconst Sprite::Point Sprite::GetCenter() const\n{\n  Point center;\n  center.x = this->GetPosition().x + m_center.x;\n  center.y = this->GetPosition().y + m_center.y;\n\n  return center;\n}\n```", "```cpp\nconst bool Sprite::IntersectsCircle(const Sprite* p_sprite) const\n{\n if (this->IsCollideable() && p_sprite->IsCollideable() && this->IsActive() && p_sprite->IsActive())\n {\n  const Point p1 = this->GetCenter();\n  const Point p2 = p_sprite->GetCenter();\n  float y = p2.y - p1.y;\n  float x = p2.x - p1.x;\n  float d = x*x + y*y;\n  float r1 = this->GetRadius() * this->GetRadius();\n  float r2 = p_sprite->GetRadius() * p_sprite->GetRadius();\n  if (d <= r1 + r2)\n  {\n   return true;\n  }\n }\n return false;\n}\n```", "```cpp\nSprite::Point center;\nfloat radius;\n\ncenter.x = robot_right->GetSize().width / 2.0f;\ncenter.y = robot_right->GetSize().height / 2.0f;\nradius = (center.x + center.y) / 2.0f;\n\nrobot_right->SetCenter(center);\nrobot_right->SetRadius(radius);\nrobot_left->SetCenter(center);\nrobot_left->SetRadius(radius);\n\ncenter.x = pickup->GetSize().width / 2.0f;\nfloat yOffset = (pickup->GetSize().height / 4.0f) * 3.0f;\ncenter.y = yOffset;\npickup->SetCenter(center);\nradius = pickup->GetSize().width / 2.0f;\npickup->SetRadius(radius);\n```", "```cpp\nvoid CheckCollisions()\n{\n if (player->IntersectsCircle(pickup))\n {\n  pickup->IsVisible(false);\n  pickup->IsActive(false);\n  player->SetValue(player->GetValue() + pickup->GetValue());\n  pickupSpawnTimer = 0.0f;\n }\n}\n```", "```cpp\nif (m_gameState == GS_Running)\n{\n  background->Update(p_deltaTime);\n  robot_left->Update(p_deltaTime);\n  robot_right->Update(p_deltaTime);\n  robot_left_strip->Update(p_deltaTime);\n  robot_right_strip->Update(p_deltaTime);\n\n  pause->Update(p_deltaTime);\n  resume->Update(p_deltaTime);\n\n  pickup->Update(p_deltaTime);\n  SpawnPickup(p_deltaTime);\n\n  CheckCollisions();\n}\n```", "```cpp\nrobot_left->IsCollideable(true);\nrobot_right->IsCollideable(true);\npickup->IsCollideable(true);\n```", "```cpp\nSprite* enemy;\n```", "```cpp\nenemy = new Sprite(1);\nenemy->SetFrameSize(32.0f, 50.0f);\nenemy->SetNumberOfFrames(1);\nenemy->AddTexture(\"resources/water.png\");\nenemy->IsVisible(false);\nenemy->IsActive(false);\nenemy->SetValue(-50);\nenemy->IsCollideable(true);\n```", "```cpp\nfloat enemySpawnThreshold;\nfloat enemySpawnTimer;\n```", "```cpp\nenemySpawnThreshold = 7.0f;\nenemySpawnTimer = 0.0f;\n```", "```cpp\nvoid SpawnEnemy(float p_DeltaTime)\n{\n  if (enemy->IsVisible() == false)\n  {\n    enemySpawnTimer += p_DeltaTime;\n    if (enemySpawnTimer >enemySpawnThreshold)\n    {\n      float marginX = enemy->GetSize().width;\n      float marginY = enemy->GetSize().height;\n      float spawnX = (rand() % (int)(screen_width - (marginX * 2))) + marginX;\n      float spawnY = screen_height - ((rand() % (int)(player->GetSize().height - (marginY * 2))) + marginY);\n      enemy->SetPosition(spawnX, spawnY);\n      enemy->IsVisible(true);\n      enemy->IsActive(true);\n    }\n  }\n}\n```", "```cpp\nif (m_gameState == GS_Running)\n{\n  background->Update(p_deltaTime);\n  robot_left->Update(p_deltaTime);\n  robot_right->Update(p_deltaTime);\n  robot_left_strip->Update(p_deltaTime);\n  robot_right_strip->Update(p_deltaTime);\n\n  pause->Update(p_deltaTime);\n  resume->Update(p_deltaTime);\n\n  pickup->Update(p_deltaTime);\n  SpawnPickup(p_deltaTime);\n\n  enemy->Update(p_deltaTime);\n SpawnEnemy(p_deltaTime);\n\n  CheckCollisions();\n\n}\n```", "```cpp\nvoid Render()\n{\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n\n  background->Render();\n  robot_left->Render();\n  robot_right->Render();\n  robot_left_strip->Render();\n  robot_right_strip->Render();\n\n  pause->Render();\n  resume->Render();\n\n  pickup->Render();\n  enemy->Render();\n  SwapBuffers(hDC);\n}\n```", "```cpp\nconst bool IntersectsRect(const Sprite*p_sprite) const;\n```", "```cpp\nconst bool Sprite::IntersectsRect(const Sprite* p_sprite) const\n{\n if (this->IsCollideable() && p_sprite->IsCollideable() && this->IsActive() && p_sprite->IsActive()) \n {\n  const Rect recta = this->GetCollisionRect();\n  const Rect rectb = p_sprite->GetCollisionRect();\n  if (recta.left >= rectb.left && recta.left <= rectb.right && recta.top >= rectb.top && recta.top <= rectb.bottom)\n  {\n   return true;\n  }\n  else if (recta.right >= rectb.left && recta.right <= rectb.right && recta.top >= rectb.top && recta.top <= rectb.bottom)\n  {\n   return true;\n  }\n  else if (recta.left >= rectb.left && recta.right <= rectb.right && recta.top < rectb.top && recta.bottom > rectb.bottom)\n  {\n   return true;\n  }\n  else if (recta.top >= rectb.top && recta.bottom <= rectb.bottom && recta.left < rectb.left && recta.right > rectb.right)\n  {\n   return true;\n  }\n  else if (rectb.left >= recta.left && rectb.left <= recta.right &&\n   rectb.top >= recta.top && rectb.top <= recta.bottom)\n  {\n   return true;\n  }\n  else if (rectb.right >= recta.left && rectb.right <= recta.right && rectb.top >= recta.top && rectb.top <= recta.bottom)\n  {\n   return true;\n  }\n  else if (rectb.left >= recta.left && rectb.right <= recta.right && rectb.top < recta.top && rectb.bottom > recta.bottom)\n  {\n   return true;\n  }\n  else if (recta.top >= rectb.top && recta.bottom <= rectb.bottom && recta.left < rectb.left && recta.right > rectb.right)\n  {\n   return true;\n  }\n  else if (rectb.top >= recta.top && rectb.bottom <= recta.bottom && rectb.left < recta.left && rectb.right > recta.right)\n  {\n   return true;\n  }\n }\n return false;\n}\n```", "```cpp\nif (player->IntersectsRect(enemy))\n{\n  enemy->IsVisible(false);\n  enemy->IsActive(false);\n  enemy->SetValue(player->GetValue() + enemy->GetValue());\n  enemySpawnTimer = 0.0f;\n}\n```"]