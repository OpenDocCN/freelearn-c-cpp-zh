- en: Chapter 3. Advanced LLVM IR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。高级 LLVM IR
- en: LLVM provides a powerful intermediate representation for efficient compiler
    transformations and analysis, while providing a natural means to debug and visualize
    the transformations. The IR is so designed that it can be easily mapped to high
    level languages. LLVM IR provides typed information, which can be used for various
    optimizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 为高效的编译器转换和分析提供了一种强大的中间表示，同时提供了调试和可视化转换的自然方式。IR 的设计使其可以轻松映射到高级语言。LLVM IR
    提供了类型信息，可用于各种优化。
- en: In the last chapter, you learned how to create some simple LLVM instructions
    within a function and module. Starting from simple examples such as emitting binary
    operations, we constructed functions in a module and also created some complex
    programming paradigms such as if-else and loops. LLVM provides a rich set of instructions
    and intrinsics to emit a complex IR.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何在函数和模块中创建一些简单的 LLVM 指令。从发出二进制操作等简单示例开始，我们在模块中构建了函数，并创建了诸如 if-else
    和循环等一些复杂的编程范式。LLVM 提供了一套丰富的指令和内嵌函数，用于发出复杂的 IR。
- en: 'In this chapter, we will go through some more examples of LLVM IR which involve
    memory operations. Some advanced topics such as aggregate data types and operations
    on them will also be covered. The topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过一些涉及内存操作的更多 LLVM IR 示例。本章还将涵盖一些高级主题，例如聚合数据类型及其操作。本章涵盖的主题如下：
- en: Getting the address of an element
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取元素的地址
- en: Reading from the memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内存中读取
- en: Writing into a memory location
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向内存位置写入
- en: Inserting a scalar into a vector
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标量插入到向量中
- en: Extracting a scalar from a vector
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从向量中提取标量
- en: Memory access operations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存访问操作
- en: Memory is an important component of almost all computing systems. Memory stores
    data, which needs to be read to perform operations on the computing system. Results
    of the operations are stored back in the memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是几乎所有计算系统的重要组件。内存存储数据，这些数据需要被读取以在计算系统中执行操作。操作的结果将存储回内存中。
- en: The first step is to get the location of the desired element from the memory
    and store the address in which that particular element can be found. You will
    now learn how to calculate the address and perform load-store operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从内存中获取所需元素的地址，并将该特定元素可以找到的地址存储起来。你现在将学习如何计算地址并执行加载/存储操作。
- en: Getting the address of an element
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取元素的地址
- en: In LLVM, the `getelementptr` instruction is used to get the address of an element
    in an aggregate data structure. It only calculates the address and does not access
    the memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，`getelementptr` 指令用于获取聚合数据结构中元素的地址。它只计算地址，并不访问内存。
- en: The first argument of the `getelementptr` instruction is a type used as the
    basis for calculating the address. The second argument is pointer or vector of
    pointers which act as base of the address - which in our array case will be `a`.
    The next arguments are the indices of the element to be accessed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`getelementptr` 指令的第一个参数是一个用作计算地址基础的类型。第二个参数是指针或指针的向量，它作为地址的基础 - 在我们的数组情况下将是
    `a`。接下来的参数是要访问的元素的索引。'
- en: 'The Language reference ([http://llvm.org/docs/LangRef.html#getelementptr-instruction](http://llvm.org/docs/LangRef.html#getelementptr-instruction))
    mentions important notes on `getelementptr` instruction as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 语言参考（[http://llvm.org/docs/LangRef.html#getelementptr-instruction](http://llvm.org/docs/LangRef.html#getelementptr-instruction)）中提到了关于
    `getelementptr` 指令的重要注意事项如下：
- en: The first index always indexes the pointer value given as the first argument,
    the second index indexes a value of the type pointed to (not necessarily the value
    directly pointed to, since the first index can be non-zero), etc. The first type
    indexed into must be a pointer value, subsequent types can be arrays, vectors,
    and structs. Note that subsequent types being indexed into can never be pointers,
    since that would require loading the pointer before continuing calculation.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个索引始终索引第一个参数给出的指针值，第二个索引索引指向的类型（不一定是直接指向的值，因为第一个索引可能不为零），等等。第一个索引的类型必须是指针值，后续的类型可以是数组、向量和结构体。注意，后续索引的类型不能是指针，因为这需要在继续计算之前加载指针。
- en: 'This essentially implies two important things:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上意味着两件重要的事情：
- en: Every pointer has an index, and the first index is always an array index. If
    it's a pointer to a structure, you have to use index 0 to mean (the first such
    structure), then the index of the element.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个指针都有一个索引，第一个索引始终是数组索引。如果它是一个结构体的指针，你必须使用索引 0 来表示（第一个这样的结构体），然后是元素的索引。
- en: The first type parameter helps GEP identify the sizes of the base structure
    and its elements, thus easily calculating the address. The resulting type (`%a1`)
    is not necessarily the same.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个类型参数帮助 GEP 识别基结构及其元素的大小，从而轻松计算地址。结果类型（`%a1`）不一定相同。
- en: More elaborated explanation is provided at [http://llvm.org/docs/GetElementPtr.html](http://llvm.org/docs/GetElementPtr.html)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的解释请参阅 [http://llvm.org/docs/GetElementPtr.html](http://llvm.org/docs/GetElementPtr.html)
- en: Let's assume that we have a pointer to a vector of two 32 bit integers `<2 x
    i32>* %a` and we want to access second integer from the vector. The address will
    be calculated as
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个指向两个 32 位整数向量 `<2 x i32>* %a` 的指针，并且我们想要访问向量中的第二个整数。地址将被计算如下
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To emit this instruction, LLVM API can be used as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要发出此指令，可以使用如下所示的 LLVM API：
- en: First create an array type which will be passed as argument to the function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个数组类型，该类型将被作为参数传递给函数。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The whole code looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码看起来如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compile the code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Reading from the memory
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内存读取
- en: Now, since we have the address, we are ready to read the data from that address
    and assign the read value to a variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们有了地址，我们准备从该地址读取数据并将读取的值赋给一个变量。
- en: In LLVM the `load` instruction is used to read from a memory location. This
    simple instruction or combination of similar instructions may then be mapped to
    some of the sophisticated memory read instructions in low-level assembly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，`load` 指令用于从内存位置读取。这个简单的指令或类似指令的组合可以映射到底层汇编中的某些复杂的内存读取指令。
- en: A `load` instruction takes an argument, which is the memory address from which
    the data should be read. We obtained the address in the previous section by the
    `getelementptr` instruction in `a1`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `load` 指令接受一个参数，即从该内存地址读取数据的内存地址。我们在上一节中通过 `getelementptr` 指令在 `a1` 中获得了地址。
- en: 'The `load` instruction looks like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 指令看起来如下：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that the `load` will take the data pointed by `a1` and save in `%val`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `load` 将取由 `a1` 指向的数据并将其保存到 `%val` 中。
- en: 'To emit this we can use the API provided by LLVM in a function, as shown in
    the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要发出此，我们可以在函数中使用 LLVM 提供的 API，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s also return the loaded value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也返回加载的值：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The whole code is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码如下：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compile the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编译以下代码：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Writing into a memory location
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据写入内存位置
- en: 'LLVM uses the `store` instruction to write into a memory location. There are
    two arguments to the `store` instruction: a value to store and an address at which
    to store it. The `store` instruction has no return value. Let''s say that we want
    to write a data to the second element of the vector of two integers. The `store`
    instruction looks like `store i32 3, i32* %a1`. To emit the `store` instruction,
    we can use the following API provided by LLVM:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 使用 `store` 指令将数据写入内存位置。`store` 指令有两个参数：要存储的值和存储它的地址。`store` 指令没有返回值。假设我们想要将数据写入两个整数的向量中的第二个元素。`store`
    指令看起来像 `store i32 3, i32* %a1`。要发出 `store` 指令，我们可以使用 LLVM 提供的以下 API：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For example, we will multiply the second element of the `<2 x i32>` vector by
    `16` and store it back at the same location.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将 `<2 x i32>` 向量的第二个元素乘以 `16` 并将其存储在相同的位置。
- en: 'Consider the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Compile the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译以下代码：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting output will be as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出将如下：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inserting a scalar into a vector
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标量插入到向量中
- en: LLVM also provides the API to emit an instruction, which inserts a scalar into
    a vector type. Note that this vector is different from an array. A vector type
    is a simple derived type that represents a vector of elements. Vector types are
    used when multiple primitive data are operated in parallel using **single instruction
    multiple data** (**SIMD**). A vector type requires a size (number of elements)
    and an underlying primitive data type. For example, we have a vector `Vec` that
    has four integers of `i32` type `<4 x i32>`. Now, we want to insert the values
    10, 20, 30, and 40 at 0, 1, 2, and 3 indexes of the vector.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 还提供了发出指令的 API，该指令可以将标量插入到向量类型中。请注意，这种向量与数组不同。向量类型是一个简单的派生类型，表示元素向量。当使用
    **单指令多数据**（**SIMD**）并行操作多个原始数据时，使用向量类型。向量类型需要一个大小（元素数量）和一个基础原始数据类型。例如，我们有一个 `Vec`
    向量，它包含四个 `i32` 类型的整数 `<4 x i32>`。现在，我们想在向量的 0、1、2 和 3 索引处插入值 10、20、30 和 40。
- en: The `insertelement` instruction takes three arguments. The first argument is
    a value of vector type. The second operand is a scalar value whose type must equal
    the element type of the first operand. The third operand is an index indicating
    the position at which to insert the value. The resultant value is a vector of
    the same type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertelement` 指令接受三个参数。第一个参数是向量类型的值。第二个操作数是一个标量值，其类型必须等于第一个操作数的元素类型。第三个操作数是一个索引，指示要插入值的位位置。结果值是相同类型的向量。'
- en: 'The `insertelement` instruction looks like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertelement` 指令看起来如下：'
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This can be further understood by keeping the following in mind:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下要点进一步理解：
- en: '`Vec` is of vector type `< 4 x i32 >`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vec` 是向量类型 `< 4 x i32 >`'
- en: '`val0` is the value to be inserted'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val0` 是要插入的值'
- en: '`idx` is the index at which the value is to be inserted in the vector'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idx` 是要在向量中插入值的索引'
- en: 'Consider the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compile the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编译以下代码：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting output is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The vector `Vec` will have `<10, 20, 30, 40>` values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 `Vec` 将具有 `<10, 20, 30, 40>` 的值。
- en: Extracting a scalar from a vector
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从向量中提取标量
- en: An individual scalar element can be extracted from a vector. LLVM provides the
    `extractelement` instruction for the same. The first operand of an `extractelement`
    instruction is a value of vector type. The second operand is an index indicating
    the position from which to extract the element.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从向量中提取单个标量元素。LLVM 提供了 `extractelement` 指令来完成同样的操作。`extractelement` 指令的第一个操作数是向量类型的值。第二个操作数是一个索引，指示从哪个位置提取元素。
- en: 'The `extractelement` instruction looks like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertelement` 指令看起来如下：'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This can be further understood by keeping the following in mind:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下要点进一步理解：
- en: '`vec` is a vector'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec` 是一个向量'
- en: '`idx` is the index at which the data to be extracted lies'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idx` 是要提取的数据所在的索引'
- en: '`result` is of scalar type, which is `i32` here'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result` 是标量类型，这里为 `i32`'
- en: Let's take an example where we want to add all the elements of a given vector
    and return an integer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们想要将给定向量的所有元素相加并返回一个整数。
- en: 'Consider the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Compile the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译以下代码：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Memory operations form an important instruction for most of the target architecture.
    Some of the architectures have sophisticated instructions to move data in and
    out of the memory. Some even perform binary operations directly on the memory
    operands, while some of them load data from memory into registers and then perform
    operations on them (CISC vs RISC). Many load-store operations are also done by
    LLVM instrinsics. For examples, please refer to [http://llvm.org/docs/LangRef.html#masked-vector-load-and-store-intrinsics](http://llvm.org/docs/LangRef.html#masked-vector-load-and-store-intrinsics).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 内存操作对于大多数目标架构来说是一个重要的指令。一些架构具有复杂的指令来在内存中移动数据。一些甚至可以直接在内存操作数上执行二进制操作，而另一些则从内存中加载数据到寄存器，然后对其进行操作（CISC
    对比 RISC）。许多加载/存储操作也由 LLVM 内置函数完成。例如，请参阅 [http://llvm.org/docs/LangRef.html#masked-vector-load-and-store-intrinsics](http://llvm.org/docs/LangRef.html#masked-vector-load-and-store-intrinsics)。
- en: LLVM IR provides a common playfield for all the architectures. It provides elementary
    instructions for data operations on memory or on aggregate data types. The architectures,
    while lowering LLVM IR, may combine IR instructions to emit their specific instructions.
    In this chapter, we went through some advanced IR instructions and also looked
    into examples of them. For a detailed study, refer to [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html),
    which provides the authoritative resource for LLVM IR instructions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR为所有架构提供了一个共同的竞技场。它提供了在内存或聚合数据类型上执行数据操作的基本指令。在将LLVM IR降低到特定架构的过程中，架构可能会组合IR指令以生成它们特有的指令。在本章中，我们探讨了某些高级IR指令，并查看了一些示例。对于详细研究，请参考[http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html)，它提供了LLVM
    IR指令的权威资源。
- en: In the next chapter, you will study how LLVM IR can be optimized to reduce instructions
    and emit a clean code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何优化LLVM IR以减少指令并生成干净的代码。
