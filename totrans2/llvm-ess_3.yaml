- en: Chapter 3. Advanced LLVM IR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM provides a powerful intermediate representation for efficient compiler
    transformations and analysis, while providing a natural means to debug and visualize
    the transformations. The IR is so designed that it can be easily mapped to high
    level languages. LLVM IR provides typed information, which can be used for various
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, you learned how to create some simple LLVM instructions
    within a function and module. Starting from simple examples such as emitting binary
    operations, we constructed functions in a module and also created some complex
    programming paradigms such as if-else and loops. LLVM provides a rich set of instructions
    and intrinsics to emit a complex IR.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through some more examples of LLVM IR which involve
    memory operations. Some advanced topics such as aggregate data types and operations
    on them will also be covered. The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the address of an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing into a memory location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a scalar into a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting a scalar from a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory access operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory is an important component of almost all computing systems. Memory stores
    data, which needs to be read to perform operations on the computing system. Results
    of the operations are stored back in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to get the location of the desired element from the memory
    and store the address in which that particular element can be found. You will
    now learn how to calculate the address and perform load-store operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the address of an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In LLVM, the `getelementptr` instruction is used to get the address of an element
    in an aggregate data structure. It only calculates the address and does not access
    the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of the `getelementptr` instruction is a type used as the
    basis for calculating the address. The second argument is pointer or vector of
    pointers which act as base of the address - which in our array case will be `a`.
    The next arguments are the indices of the element to be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Language reference ([http://llvm.org/docs/LangRef.html#getelementptr-instruction](http://llvm.org/docs/LangRef.html#getelementptr-instruction))
    mentions important notes on `getelementptr` instruction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first index always indexes the pointer value given as the first argument,
    the second index indexes a value of the type pointed to (not necessarily the value
    directly pointed to, since the first index can be non-zero), etc. The first type
    indexed into must be a pointer value, subsequent types can be arrays, vectors,
    and structs. Note that subsequent types being indexed into can never be pointers,
    since that would require loading the pointer before continuing calculation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This essentially implies two important things:'
  prefs: []
  type: TYPE_NORMAL
- en: Every pointer has an index, and the first index is always an array index. If
    it's a pointer to a structure, you have to use index 0 to mean (the first such
    structure), then the index of the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first type parameter helps GEP identify the sizes of the base structure
    and its elements, thus easily calculating the address. The resulting type (`%a1`)
    is not necessarily the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More elaborated explanation is provided at [http://llvm.org/docs/GetElementPtr.html](http://llvm.org/docs/GetElementPtr.html)
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we have a pointer to a vector of two 32 bit integers `<2 x
    i32>* %a` and we want to access second integer from the vector. The address will
    be calculated as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To emit this instruction, LLVM API can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First create an array type which will be passed as argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reading from the memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, since we have the address, we are ready to read the data from that address
    and assign the read value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: In LLVM the `load` instruction is used to read from a memory location. This
    simple instruction or combination of similar instructions may then be mapped to
    some of the sophisticated memory read instructions in low-level assembly.
  prefs: []
  type: TYPE_NORMAL
- en: A `load` instruction takes an argument, which is the memory address from which
    the data should be read. We obtained the address in the previous section by the
    `getelementptr` instruction in `a1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load` instruction looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `load` will take the data pointed by `a1` and save in `%val`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To emit this we can use the API provided by LLVM in a function, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also return the loaded value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Writing into a memory location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LLVM uses the `store` instruction to write into a memory location. There are
    two arguments to the `store` instruction: a value to store and an address at which
    to store it. The `store` instruction has no return value. Let''s say that we want
    to write a data to the second element of the vector of two integers. The `store`
    instruction looks like `store i32 3, i32* %a1`. To emit the `store` instruction,
    we can use the following API provided by LLVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For example, we will multiply the second element of the `<2 x i32>` vector by
    `16` and store it back at the same location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Inserting a scalar into a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM also provides the API to emit an instruction, which inserts a scalar into
    a vector type. Note that this vector is different from an array. A vector type
    is a simple derived type that represents a vector of elements. Vector types are
    used when multiple primitive data are operated in parallel using **single instruction
    multiple data** (**SIMD**). A vector type requires a size (number of elements)
    and an underlying primitive data type. For example, we have a vector `Vec` that
    has four integers of `i32` type `<4 x i32>`. Now, we want to insert the values
    10, 20, 30, and 40 at 0, 1, 2, and 3 indexes of the vector.
  prefs: []
  type: TYPE_NORMAL
- en: The `insertelement` instruction takes three arguments. The first argument is
    a value of vector type. The second operand is a scalar value whose type must equal
    the element type of the first operand. The third operand is an index indicating
    the position at which to insert the value. The resultant value is a vector of
    the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `insertelement` instruction looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be further understood by keeping the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vec` is of vector type `< 4 x i32 >`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val0` is the value to be inserted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idx` is the index at which the value is to be inserted in the vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The vector `Vec` will have `<10, 20, 30, 40>` values.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a scalar from a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An individual scalar element can be extracted from a vector. LLVM provides the
    `extractelement` instruction for the same. The first operand of an `extractelement`
    instruction is a value of vector type. The second operand is an index indicating
    the position from which to extract the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `extractelement` instruction looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be further understood by keeping the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vec` is a vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idx` is the index at which the data to be extracted lies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result` is of scalar type, which is `i32` here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take an example where we want to add all the elements of a given vector
    and return an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory operations form an important instruction for most of the target architecture.
    Some of the architectures have sophisticated instructions to move data in and
    out of the memory. Some even perform binary operations directly on the memory
    operands, while some of them load data from memory into registers and then perform
    operations on them (CISC vs RISC). Many load-store operations are also done by
    LLVM instrinsics. For examples, please refer to [http://llvm.org/docs/LangRef.html#masked-vector-load-and-store-intrinsics](http://llvm.org/docs/LangRef.html#masked-vector-load-and-store-intrinsics).
  prefs: []
  type: TYPE_NORMAL
- en: LLVM IR provides a common playfield for all the architectures. It provides elementary
    instructions for data operations on memory or on aggregate data types. The architectures,
    while lowering LLVM IR, may combine IR instructions to emit their specific instructions.
    In this chapter, we went through some advanced IR instructions and also looked
    into examples of them. For a detailed study, refer to [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html),
    which provides the authoritative resource for LLVM IR instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will study how LLVM IR can be optimized to reduce instructions
    and emit a clean code.
  prefs: []
  type: TYPE_NORMAL
