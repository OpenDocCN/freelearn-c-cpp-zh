<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Basic IR Transformations</h1></div></div></div><p class="calibre7">Until now, we have seen how the IR is independent of its target and how it can be used to generate code for a specific backend. To generate efficient code for the backend, we optimize the IR generated by the frontend by running a series of analysis and transformation passes using the LLVM pass manager. We must note that most of the optimizations that happen in a compiler take place on the IR, one of the reasons being that the IR is retargetable and the same set of optimizations would be valid for a number of targets. It reduces the effort of writing the same optimization for every target. There are some target-specific optimizations too; they happen at the selection DAG level, which we will see later. Another reason for IR being the target of optimization is that LLVM IR is in SSA form, which means every variable is assigned only once and every new assignment to a variable is a new variable itself. One very visible benefit of this representation is that we don't have to do reaching definition analysis where some variable is assigned a value of another variable. SSA representation also helps in a number of optimizations such as constant propagation, dead code elimination, and so on. Going ahead, we will see some of the important optimizations in LLVM, what is the role of LLVM Pass Infrastructure, and how we can use the opt tool to perform different optimizations.</p><p class="calibre7">In this chapter, we will cover following topics:</p><div><ul class="itemizedlist"><li class="listitem">The opt tool</li><li class="listitem">Pass and Pass Manager</li><li class="listitem">Using other Pass info in own pass</li><li class="listitem">IR simplification examples</li><li class="listitem">IR combination examples</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec29" class="calibre1"/>Opt Tool</h1></div></div></div><p class="calibre7">
<strong class="calibre2">Opt</strong> <a id="id118" class="calibre1"/>is the LLVM Optimizer and analyzer tool that is run on LLVM IR to optimize the IR or produce an analysis about it. We saw in the first chapter a very basic introduction to the opt tool, and how to use it to run analysis and transformation passes. In this section, we will see what else the opt tool does. We must note that opt is a developer tool and all the optimizations that it provides can be invoked from the frontend as well.</p><p class="calibre7">With the opt tool, we can specify the level of optimization that we need, which means we can specify the optimization levels from <code class="email">O0</code>, <code class="email">O1</code>, <code class="email">O2</code>, to <code class="email">O3</code>(<code class="email">O0</code> being the least optimized code and <code class="email">O3</code> being the most optimized code). Apart from these, there is also an optimization level <code class="email">Os</code> or <code class="email">Oz</code>, which deals with space optimization. The syntax to invoke one of these optimizations is:</p><div><pre class="programlisting">
<strong class="calibre2">$ opt -Ox -S input.ll</strong>
</pre></div><p class="calibre7">Here, x <a id="id119" class="calibre1"/>represents the optimization level, which can have a value from 0 to 3 or s or z. These optimization levels are similar to what Clang frontend specifies. <code class="email">-O0</code> represents no optimization whereas <code class="email">–O1</code> means only few optimizations are enabled. <code class="email">–O2</code> is a moderate level of optimization and <code class="email">–O3</code> is the highest level of optimization, which is similar to <code class="email">–O2</code> but it allows optimization that takes longer to perform or may generate larger code (the O3 level does not guarantee that the code will be the most optimized and efficient, it just says that the compiler will try more to optimize the code and in the process may break things also). <code class="email">–Os</code> means optimization for size, basically not running optimizations which increase code size (for example, it removes <code class="email">slp-vectorizer</code> optimization) and perform optimizations that reduce code size (for example, instruction combining optimization).</p><p class="calibre7">We can direct the opt tool to run a specific pass that we require. These passes can be one of the already defined passes<a id="id120" class="calibre1"/> listed at <a class="calibre1" href="http://llvm.org/docs/Passes.html">http://llvm.org/docs/Passes.html</a> or one of the passes we have written ourselves. The passes listed in the above link are also run in the optimization levels of <code class="email">-O1</code>, <code class="email">-O2</code>, and <code class="email">-O3</code>. To view which pass is being run at a certain optimization level, use the <code class="email">-debug-pass=Structure</code> command-line option along with the opt tool.</p><p class="calibre7">Let's take an example to demonstrate the difference between the <code class="email">O1</code> and <code class="email">O2</code> level of optimization. The <code class="email">O3</code> level generally has one or two more passes from <code class="email">O2</code>. So, let's take an example and see how much the <code class="email">O2</code> level of optimization optimizes the code. Write the test code in the <code class="email">test.ll</code> file:</p><div><pre class="programlisting">define internal i32 @test(i32* %X, i32* %Y)
{  
    %A = load i32, i32* %X
    %B = load i32, i32* %Y
    %C = add i32 %A, %B
    ret i32 %C
}
define internal i32 @caller(i32* %B)
{
    %A = alloca i32
    store i32 1, i32* %A
    %C = call i32 @test(i32* %A, i32* %B)
    ret i32 %C
}
define i32 @callercaller()
{
    %B = alloca i32
    store i32 2, i32* %B
    %X = call i32 @caller(i32* %B)
    ret i32 %X
}</pre></div><p class="calibre7">In this test<a id="id121" class="calibre1"/> code, the <code class="email">callercaller</code> function calls the <code class="email">caller</code> function, which in turn calls the <code class="email">test</code> function, which performs an addition of two numbers and returns the value to its caller, which in turn returns the value to the <code class="email">callercaller</code> function.</p><p class="calibre7">Now, run the <code class="email">O1</code> and <code class="email">O2</code> levels of optimization, as shown:</p><div><pre class="programlisting">
<strong class="calibre2">$ opt -O1 -S test.ll &gt; 1.ll</strong>
<strong class="calibre2">$ opt -O2 -S test.ll &gt; 2.ll</strong>
</pre></div><p class="calibre7">The following screenshot shows the difference in the optimized code for the <code class="email">O1</code> and <code class="email">O2</code> levels:</p><div><img src="img/00003.jpeg" alt="Opt Tool" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">As we can<a id="id122" class="calibre1"/> see, the code in <code class="email">O2</code> has optimized the calls to the function and the <code class="email">Add</code> operations as well and returns the result directly from the <code class="email">callercaller</code> function. This is obtained due to the fact that <code class="email">O2</code> optimization runs the passes <strong class="calibre2">always-inline</strong> which inlines all the function calls and treats the code as one big function. Then, in also runs the <code class="email">globaldce</code> pass, which eliminates unreachable internals from the code. After this, it runs <code class="email">constmerge</code> which merges duplicate global constants into a single constant. It also performs a global value numbering pass that eliminates partially or fully redundant instructions and eliminates redundant load instructions.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Pass and Pass Manager</h1></div></div></div><p class="calibre7">LLVM's <code class="email">Pass</code> infrastructure <a id="id123" class="calibre1"/>is one of the <a id="id124" class="calibre1"/>many important features of the LLVM system. There are a number of analysis and optimization passes that can be run using this infrastructure. The starting point for LLVM passes is the <code class="email">Pass</code> class, which is a superclass of all the passes. We need to inherit from some predefined subclasses taking into account what our pass is going to implement.</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">ModulePass</strong>: This<a id="id125" class="calibre1"/> is the most general superclass. By inheriting this class we allow the entire module to be analyzed at once. The functions within the module may not be referred to in a particular order. To use it, write a subclass that inherits from the <code class="email">ModulePass</code> subclass and overloads the <code class="email">runOnModule</code> function.<div><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre7">Before going ahead with the discussion of other <code class="email">Pass</code> classes, let's look into the three virtual methods<a id="id126" class="calibre1"/> that the <code class="email">Pass</code> classes override:</p><div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">doInitialization</strong>: This is<a id="id127" class="calibre1"/> meant to do initialization stuff that does not depend on the current function being processed.</li><li class="listitem"><strong class="calibre2">runOn{Passtype}</strong>: This is <a id="id128" class="calibre1"/>the method where we should implement our subclass for the functionality of the pass. This will be <code class="email">runOnFunction</code> for <code class="email">FunctionPass</code>, <code class="email">runOnLoop</code> for <code class="email">LoopPass</code>, and so on.</li><li class="listitem"><strong class="calibre2">doFinalization</strong>: This is <a id="id129" class="calibre1"/>called when <code class="email">runOn{Passtype}</code> has finished doing the job for every function in the program.</li></ul></div></div></li><li class="listitem"><strong class="calibre2">FunctionPass</strong>: These<a id="id130" class="calibre1"/> passes execute on each function present <a id="id131" class="calibre1"/>in the module, independent from other functions in the module. There is no defined order in which the functions will be processed. They are not allowed to modify functions other than the one being processed, and any addition or deletion of functions from the current module is also not allowed. To implement <code class="email">FunctionPass</code> we might need to overload the three virtual functions mentioned earlier by implementing in the <code class="email">runOnFunction</code> method.</li><li class="listitem"><strong class="calibre2">BasicBlockPass</strong>: These <a id="id132" class="calibre1"/>passes work on basic blocks one at a time, independently of other basic blocks present in the program. They<a id="id133" class="calibre1"/> are not allowed to add or delete any new basic block or change the CFG. They are also not allowed to do things that <code class="email">FunctionPass</code> is not allowed to. To implement, they can override the <code class="email">doInitialization</code> and <code class="email">doFinalization</code> methods of <code class="email">FunctionPass</code>, or overload their own virtual methods for the two methods mentioned earlier and the <code class="email">runOnBasicBlock</code> method.</li><li class="listitem"><strong class="calibre2">LoopPass</strong>: These <a id="id134" class="calibre1"/>passes work on each loop in the function, independent of all other loops within the function. Loops are processed in such a way that the outermost loop is executed the last. To implement <code class="email">LoopPass</code> we need to overload the <code class="email">doInitialization</code>, <code class="email">doFinalization</code>, and <code class="email">runOnLoop</code> methods.</li></ul></div><p class="calibre7">Now, let's see how to get started with writing a custom pass. Let's write a pass that will print the names of all the functions.</p><p class="calibre7">Before getting started with writing the implementation of the pass, we need to make changes in a few places in the code so that the pass is recognized and can be run.</p><p class="calibre7">We need to create<a id="id135" class="calibre1"/> a directory under the LLVM tree. Let's make a directory, <code class="email">lib/Transforms/FnNamePrint</code>. In this directory, we need to create a <code class="email">Makefile</code> with the <a id="id136" class="calibre1"/>following contents, which will allow our pass to be compiled:</p><div><pre class="programlisting">LEVEL = ../../..

LIBRARYNAME = FnNamePrint

LOADABLE_MODULE = 1

include $(LEVEL)/Makefile.common</pre></div><p class="calibre7">This specifies that all <code class="email">.cpp</code> files should be compiled and linked into a shared object that will be available in the <code class="email">lib</code> folder of the <code class="email">build-folder</code> (<code class="email">build-folder/lib/FnNamePrint.so</code>).</p><p class="calibre7">Now, let's get started with writing the actual pass implementation. We need to create the source file for the pass in <code class="email">lib/Transforms/FnNamePrint</code>: let's name it <code class="email">FnNamePrint.cpp</code>. The first step now is to choose the correct subclass. In this case, as we are trying to print names of each function, the <code class="email">FunctionPass</code> class will serve our purpose by processing one function at a time. Also, we are only printing the name of function and not modifying anything within it, so we are choosing <code class="email">FunctionPass</code> for simplicity. We could use <code class="email">ModulePass</code> as well because it is an <code class="email">Immutable Pass</code>.</p><p class="calibre7">Now, let's write the source code for the pass implementation, which looks like this:</p><div><pre class="programlisting">#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {
  struct FnNamePrint: public FunctionPass {
    static char ID;
    FnNamePrint () : FunctionPass(ID) {}
    bool runOnFunction(Function &amp;F) override {
      errs() &lt;&lt; "Function " &lt;&lt; F.getName() &lt;&lt; '\n';
      return false;
    }
  };
}

char FnNamePrint::ID = 0;static RegisterPass&lt; FnNamePrint &gt; X("funcnameprint","Function Name Print", false, false);</pre></div><p class="calibre7">In the preceding code we <code class="email">include</code> the necessary headers first and use an <code class="email">llvm</code> namespace:</p><div><pre class="programlisting">#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;</pre></div><p class="calibre7">We declare our<a id="id137" class="calibre1"/> pass as a structure, <code class="email">FnNamePrint</code>, which is a subclass of <code class="email">FunctionPass</code>. In <code class="email">runOnFunction</code> we implement the logic to print the function<a id="id138" class="calibre1"/> name. The <code class="email">bool</code> value returned in the end signifies whether we have made any modification within the function. A <code class="email">True</code> value is returned if some modifications was made, otherwise, <code class="email">false</code> is returned. In our case, we are not making any modifications, so we return <code class="email">false</code>.</p><div><pre class="programlisting">struct FnNamePrint: public FunctionPass {
  static char ID;
  FnNamePrint () : FunctionPass(ID) {}
  bool runOnFunction(Function &amp;F) override {
    errs() &lt;&lt; "Function " &lt;&lt; F.getName() &lt;&lt; '\n';
    return false;
    }
  };
}</pre></div><p class="calibre7">Then, we declare the <code class="email">ID</code> for the pass, which is used to identify the pass:</p><div><pre class="programlisting">char FnNamePrint::ID = 0;</pre></div><p class="calibre7">Finally, we need to register the passes with the Pass Manager. The first argument is the Pass name used by the <code class="email">opt</code> tool to identify this pass. The second argument is the actual Pass name. The third and fourth arguments specify whether the pass modified the <code class="email">cfg</code> and whether it is an analysis pass.</p><div><pre class="programlisting">static RegisterPass&lt; FnNamePrint &gt; X("funcnameprint","Function Name Print", false, false);</pre></div><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre7">The implementation of the pass is done. Now, before we use it, we need to build LLVM using the <code class="email">make</code> command, which will build the shared object in the <code class="email">lib</code> folder within the build (<code class="email">build-folder/lib/FnNamePrint.so</code>).</p></div><p class="calibre7">Now, we can run the pass over a test case using the <code class="email">opt</code> tool in the following way:</p><div><pre class="programlisting">
<strong class="calibre2">$ opt -load path-to-llvm/build/lib/FnNamePrint.so -funcnameprint test.ll</strong>
</pre></div><p class="calibre7">The <code class="email">load</code> command line option specifies the path from where to pick the shared object of the pass and <code class="email">–funcnameprint</code> is the option to opt tool to tell it to run the pass we have written. The Pass will print the names of all the function present in the testcase. For the example in the first section it will print out:</p><div><pre class="programlisting">
<strong class="calibre2">Function test</strong>
<strong class="calibre2">Function caller</strong>
<strong class="calibre2">Function callercaller</strong>
</pre></div><p class="calibre7">So, we got <a id="id139" class="calibre1"/>started with writing a Pass. Now, we will see the significance of the <code class="email">PassManager</code> class in LLVM.</p><p class="calibre7">The <code class="email">PassManager</code> class schedules the passes to be run efficiently. The <code class="email">PassManager</code> is used by all LLVM tools that run passes for the execution of these passes. It is the responsibility of the <code class="email">PassManager</code> to make sure the interaction between the passes is correctly done. As it tries to execute the passes in an optimized way, it must have information regarding how the passes interact with each other and what the different dependencies between the passes are.</p><p class="calibre7">A pass itself <a id="id140" class="calibre1"/>can specify the dependency on other passes, that is, which passes need to be run before the execution of the current pass. Also, it can specify the passes that will be invalidated by the execution of the current pass. The <code class="email">PassManager</code> gets the analysis results before a pass is executed. We will later see how a pass can specify such dependencies.</p><p class="calibre7">The main work of the <code class="email">PassManager</code> is to avoid the calculation of analysis results time and again. This is done by keeping track of which analyses are available, which are invalidated, and which analyses are required. The <code class="email">PassManager</code> tracks the lifetimes of the analysis results and frees the memory holding the analysis results when not required, allowing for optimal memory use.</p><p class="calibre7">The <code class="email">PassManager</code> pipelines the passes together to get better memory and cache results, improving the cache behavior of the compiler. When a series of consecutive <code class="email">FunctionPass</code> are given, it will execute all the <code class="email">FunctionPass</code> on the first function, then all the <code class="email">FunctionPass</code> on the second function, and so on. This improves cache behavior as it is only dealing with the single function part of the LLVM representation and not the entire program.</p><p class="calibre7">The <code class="email">PassManager</code> also<a id="id141" class="calibre1"/> specifies the <code class="email">–debug-pass</code> option with which we can see how one pass interacts with other passes. We can see what all passes are run using the <code class="email">–debug-pass=Argument</code> option. We can use the <code class="email">–debug-pass=Structure</code> option to see how the passes had run. It will also give us the names of the passes that ran. Let's take the example of the test code in the first section of this chapter:</p><div><pre class="programlisting">
<strong class="calibre2">$ opt -O2 -S test.ll -debug-pass=Structure</strong>
<strong class="calibre2">$ opt -load /build-folder/lib/LLVMFnNamePrint.so test.ll -funcnameprint -debug-pass=Structure</strong>

<strong class="calibre2">Pass Arguments:  -targetlibinfo -tti -funcnameprint -verify</strong>
<strong class="calibre2">Target Library Information</strong>
<strong class="calibre2">Target Transform Information</strong>
<strong class="calibre2">  ModulePass Manager</strong>
<strong class="calibre2">    FunctionPass Manager</strong>
<strong class="calibre2">      Function Name Print</strong>
<strong class="calibre2">      Module Verifier</strong>
<strong class="calibre2">Function test</strong>
<strong class="calibre2">Function caller</strong>
<strong class="calibre2">Function callercaller</strong>
</pre></div><p class="calibre7">In the <a id="id142" class="calibre1"/>output, the <code class="email">Pass Arguments</code> gives us the passes that are run and the following list is the structure used to run each pass. The Passes just after <code class="email">ModulePass</code> <code class="email">Manager</code> will show the passes run per module (here, it is empty). The passes in hierarchy of <code class="email">FunctionPass</code> <code class="email">Manager</code> show that these passes were run per function (<code class="email">Function Name Print</code> and <code class="email">Module Verifier</code>), which is the expected result.</p><p class="calibre7">The <code class="email">PassManger</code> also<a id="id143" class="calibre1"/> provides some other useful flags, some of which are the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">time-passes</strong>: This <a id="id144" class="calibre1"/>gives time information about the pass along with the other passes that are lined up.</li><li class="listitem"><strong class="calibre2">stats</strong>: This prints <a id="id145" class="calibre1"/>statistics about each pass.</li><li class="listitem"><strong class="calibre2">instcount</strong>: This <a id="id146" class="calibre1"/>collects the count of all instructions and reports them. <code class="email">–stats</code> must also be Passes to the opt tool so that the results of <code class="email">instcount</code> are visible.</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Using other Pass info in current Pass</h1></div></div></div><p class="calibre7">For the Pass Manager <a id="id147" class="calibre1"/>to work optimally it needs to know the dependencies between the Passes. Each of the passes can itself declare its dependencies: the analysis passes that need to be executed before this pass is executed and the passes that will get invalidated after the current pass is run. To specify these dependencies, a pass needs to implement the <code class="email">getAnalysisUsage</code> method.</p><div><pre class="programlisting">virtual void getAnalysisUsage(AnalysisUsage &amp;Info) const;</pre></div><p class="calibre7">Using this method <a id="id148" class="calibre1"/>the current pass can specify the required and invalidated sets by filling in the details in the <code class="email">AnalysisUsage</code> object. To fill in the information the Pass needs to call any of the following methods:</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec08" class="calibre1"/>AnalysisUsage::addRequired&lt;&gt; method</h2></div></div></div><p class="calibre7">This method arranges <a id="id149" class="calibre1"/>for the execution of a Pass prior to the current Pass. One example of this is: for memory copy optimization it needs the results of an alias analysis:</p><div><pre class="programlisting">void getAnalysisUsage(AnalysisUsage &amp;AU) const override {
AU.addRequired&lt;AliasAnalysis&gt;();
…
…
}</pre></div><p class="calibre7">By adding the pass required to run, it is made sure that <code class="email">Alias Analysis Pass</code> is run before the <code class="email">MemCpyOpt</code> Pass. Also, this makes sure that if the <code class="email">Alias Analysis</code> has been invalidated by some other Pass, it will be run before the <code class="email">MemCpyOpt</code> Pass is run.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec09" class="calibre1"/>AnalysisUsage:addRequiredTransitive&lt;&gt; method</h2></div></div></div><p class="calibre7">When an analysis<a id="id150" class="calibre1"/> chains to other analyses for results, this method should be used instead of the <code class="email">addRequired</code> method. That is, when we need to preserve the order in which the analysis passes are run we use this method. For example:</p><div><pre class="programlisting">void DependenceAnalysis::getAnalysisUsage(AnalysisUsage &amp;AU) const {
  …
  AU.addRequiredTransitive&lt;AliasAnalysis&gt;();
  AU.addRequiredTransitive&lt;ScalarEvolution&gt;();
  AU.addRequiredTransitive&lt;LoopInfo&gt;();
}</pre></div><p class="calibre7">Here, <code class="email">DependenceAnalysis</code> chains to <code class="email">AliasAnalysis</code>, <code class="email">ScalarEvolution</code> and <code class="email">LoopInfo</code> Passes for the results.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec10" class="calibre1"/>AnalysisUsage::addPreserved&lt;&gt; method</h2></div></div></div><p class="calibre7">By using this method <a id="id151" class="calibre1"/>a Pass can specify which analyses of other Passes it will not invalidate on running: that is, it will preserve the information already present, if any. This means that the subsequent passes that require the analysis would not need to run this again.</p><p class="calibre7">For example, in the case of the <code class="email">MemCpyOpt</code> Pass seen earlier, it required the <code class="email">AliasAnalysis</code> results and it also preserved them. Also:</p><div><pre class="programlisting">void getAnalysisUsage(AnalysisUsage &amp;AU) const override {
      ……
      AU.addPreserved&lt;AliasAnalysis&gt;();
      …..
    }</pre></div><p class="calibre7">To get a detailed understanding of how everything is linked and works together, you can pick up any of the transformation passes and go through the source code and you will know how they are getting information from other passes and how they are using it.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Instruction simplification example</h1></div></div></div><p class="calibre7">In this section, we will<a id="id152" class="calibre1"/> see how we fold instructions into simpler forms in LLVM. Here, the creation of new instructions will not take place. Instruction simplification does constant folding:</p><div><pre class="programlisting">sub i32 2, 1 -&gt; 1</pre></div><p class="calibre7">That is, it simplifies the <code class="email">sub</code> instruction to a constant value <code class="email">1</code>.</p><p class="calibre7">It can handle non-constant operands as well:</p><div><pre class="programlisting">or i32 %x, 0 -&gt; %x</pre></div><p class="calibre7">It returns a value of variable <code class="email">%x</code>
</p><div><pre class="programlisting">
<strong class="calibre2">and i32 %x %x -&gt; %x</strong>
</pre></div><p class="calibre7">In this case, it returns an already existing value.</p><p class="calibre7">The implementations for the methods that simplify instructions are located in <code class="email">lib/Analysis/InstructionSimplify.cpp</code>.</p><p class="calibre7">Some of the important methods of dealing with the simplification of instructions are:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">SimplifyBinOp method</strong>: This is<a id="id153" class="calibre1"/> used to simplify binary operations such as addition, subtraction, and multiplication, and so on. It has the function signature as follows:<div><pre class="programlisting">static Value *SimplifyBinOp(unsigned Opcode, Value *LHS, 
Value *RHS, const Query &amp;Q, unsigned MaxRecurse)</pre></div></li></ul></div><p class="calibre7">Here, by <code class="email">Opcode</code>, we mean the operator instruction that we are trying to simplify. LHS and RHS are the operands on either side of the operator. <code class="email">MaxRecurse</code> is the recursion level we specify after which the routine must stop trying simplification of the instruction.</p><p class="calibre7">In this method, we have a switch case on the <code class="email">Opcode</code>:</p><div><pre class="programlisting">switch (Opcode) {</pre></div><p class="calibre7">Using this <code class="email">Opcode,</code> the method decides which function it needs to call for simplification. Some of the methods are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">SimplifyAddInst</strong>: This <a id="id154" class="calibre1"/>method <a id="id155" class="calibre1"/>tries to fold the result of the <code class="email">Add</code> operator when the operands are known. Some of the folding is as follows:<div><pre class="programlisting">X + undef -&gt; undef
X + 0 -&gt; X
X + (Y - X) -&gt; Y or (Y - X) + X -&gt; Y</pre></div></li></ul></div><p class="calibre7">The code for the last simplification in the function <code class="email">static</code> <code class="email">Value *SimplifyAddInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW, const Query &amp;Q, unsigned MaxRecurse )</code> looks something like this:</p><div><pre class="programlisting">if (match(Op1, m_Sub(m_Value(Y), m_Specific(Op0))) ||
      match(Op0, m_Sub(m_Value(Y), m_Specific(Op1))))
    return Y;</pre></div><p class="calibre7">Here, the first condition matches the <code class="email">(Y-X)</code> value in the expression as <code class="email">Operand1: m_Value(Y)</code> denotes value of <code class="email">Y</code> and <code class="email">m_Specific(Op0)</code> denotes <code class="email">X</code>. As soon as it is matched it folds the expression to a constant value <code class="email">Y</code> and returns it. The case is similar for the second part of our condition:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">SimplifySubInst</strong>: This <a id="id156" class="calibre1"/>method tries to fold the result of <code class="email">subtract</code> operator when the operators are known. Some examples for the same are as follows:<div><pre class="programlisting">X - undef -&gt; undef
X - X -&gt; 0
X - 0 -&gt; X
X - (X - Y) -&gt; Y</pre></div></li></ul></div><p class="calibre7">The matching of instructions and folding is done similar to as shown in <code class="email">SimplifyAddInst</code>:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">SimplifyAndInst</strong>: Similar <a id="id157" class="calibre1"/>to the two preceding methods, it tries to fold the result for the logical operator And. Some examples of this are:<div><pre class="programlisting">A &amp; ~A  =  ~A &amp; A  =  0</pre></div></li></ul></div><p class="calibre7">The code for this, in the method looks like:</p><div><pre class="programlisting">if (match(Op0, m_Not(m_Specific(Op1))) ||
      match(Op1, m_Not(m_Specific(Op0))))
    return Constant::getNullValue(Op0-&gt;getType());</pre></div><p class="calibre7">Here, it tries to match <code class="email">A</code> and <code class="email">~A</code> and<a id="id158" class="calibre1"/> returns a <code class="email">Null</code> value, 0, when it matches the condition.</p><p class="calibre7">So, we have seen a bit of instruction simplification. Now, what do we do if we can replace a set of instructions with a more effective set of instructions?</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Instruction Combining</h1></div></div></div><p class="calibre7">Instruction combining<a id="id159" class="calibre1"/> is a LLVM Pass and compiler technique in which we replace a sequence of instructions with instructions that are more effective and give the same result on execution in a smaller number of machine cycles. Instruction combining does not alter the CFG of the program and is mainly used for algebraic simplification. The major difference between instruction combining and instruction simplification is that in instruction simplification we cannot generate new instructions, which is possible in instruction combining. This pass is run by specifying the <code class="email">–instcombine</code> argument to the opt tool and is implemented in the <code class="email">lib/transforms/instcombine</code> folder. The <code class="email">instcombine</code> Pass combines</p><div><pre class="programlisting">%Y = add i32 %X, 1
%Z = add i32 %Y, 1
into:
%Z = add i32 %X, 2</pre></div><p class="calibre7">It has removed one redundant <code class="email">add</code> instruction and hence combined the two <code class="email">add</code> instructions to one.</p><p class="calibre7">The LLVM page states that this pass guarantees that the following canonicalizations are performed on the program:</p><div><ul class="itemizedlist"><li class="listitem">Constant operand of a binary operator is moved to RHS.</li><li class="listitem">Bitwise operators with constant operands are grouped together with shifts being performed first then 'or' operations, 'and' operations and then 'xor operations'</li><li class="listitem">If possible, comparison operators are converted from &lt;,&gt;,&lt;=,&gt;= to == or != .</li><li class="listitem">All <code class="email">cmp</code> instructions operating on Boolean values are replaced with logical operations.</li><li class="listitem">Add X, X is represented by X*2 , that is X&lt;&lt;1</li><li class="listitem">Multipliers with a power-of-two constant argument are transformed into shifts.</li></ul></div><p class="calibre7">This pass starts <a id="id160" class="calibre1"/>from <code class="email">bool InstCombiner::runOnFunction(Function &amp;F)</code> located in the <code class="email">InstructionCombining.cpp</code> file. There are different files under the <code class="email">lib/Transform/InstCombine</code> folder to combine instructions related to different instructions. The methods, before trying to combine instructions, try to simplify them. Some of these <a id="id161" class="calibre1"/>methods for simplification of the <code class="email">instcombine</code> module are:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">SimplifyAssociativeOrCommutative function</strong>: It performs simplification for operators that <a id="id162" class="calibre1"/>are associative or commutative. For commutative operators, it orders the operands from right to left in the order of increasing complexity. For associative operations of the form "<code class="email">(X op Y) op Z</code>", it converts it to "<code class="email">X op (Y op Z)</code>" if (Y op Z) can be simplified.</li><li class="listitem"><strong class="calibre2">tryFactorization function</strong>: This <a id="id163" class="calibre1"/>method tries to simplify binary operations by factoring out common terms using commutative and distributive property of the operator. For example, <code class="email">(A*B)+(A*C)</code> is simplified to <code class="email">A*(B+C)</code>.</li></ul></div><p class="calibre7">Now, let's look at instruction combining. As described earlier, various functionalities are implemented in different files. Let's take an example testcode and see where to add code so that instruction combining happens for our testcode.</p><p class="calibre7">Let's write the testcode in <code class="email">test.ll</code> for the pattern <code class="email">(A | (B ^ C)) ^ ((A ^ C) ^ B)</code>, which can be reduced to <code class="email">(A &amp; (B ^ C))</code>:</p><div><pre class="programlisting">define i32 @testfunc(i32 %x, i32 %y, i32 %z) {
%xor1 = xor i32 %y, %z
%or = or i32 %x, %xor1
%xor2 = xor i32 %x, %z
%xor3 = xor i32 %xor2, %y
%res = xor i32 %or, %xor3
ret i32 %res
}</pre></div><p class="calibre7">The code in LLVM for the handling of operators such as "And", "Or", and "Xor" lies in the <code class="email">lib/Transforms/InstCombine/InstCombineAndOrXor.cpp</code> file.</p><p class="calibre7">In the <code class="email">InstCombineAndOrXor.cpp</code> file, in the <code class="email">InstCombiner::visitXor(BinaryOperator &amp;I)</code> function, go to the <code class="email">if</code> condition <code class="email">If</code> <code class="email">(Op0I &amp;&amp; Op1I)</code> and add the following snippet of code:</p><div><pre class="programlisting">If (match(Op01, m_Or(m_Xor(m_Value(B), m_Value(C)), m_Value(A)))
&amp;&amp; match(Op1I, m_Xor( m_Xor(m_Specific(A), m_Specific(C)), m_Specific(B)))) {
  return BinaryOperator::CreateAnd(A, Builder-&gt;CreateXor(B,C));
}</pre></div><p class="calibre7">As it is quite clear, the code added is to match the pattern <code class="email">(A | (B ^ C)) ^ ((A ^ C) ^ B)</code> and return <code class="email">(A &amp; (B ^ C))</code> when matched.</p><p class="calibre7">To test the code, build<a id="id164" class="calibre1"/> LLVM and run the <code class="email">instcombine</code> Pass with this test code and see the output.</p><div><pre class="programlisting">
<strong class="calibre2">$ opt –instcombine –S test.ll</strong>
<strong class="calibre2">define i32 @testfunc(i32 %x, i32 %y, i32 %z) {</strong>
<strong class="calibre2">%1 = xor i32 %y, %z</strong>
<strong class="calibre2">%res = and i32 %1, %x</strong>
<strong class="calibre2">ret i32 %res</strong>
<strong class="calibre2">}</strong>
</pre></div><p class="calibre7">So the output shows that now only one <code class="email">xor</code> <code class="email">and</code> one and operation is required instead of four <code class="email">xor</code> and one <code class="email">or</code> earlier<code class="email">.</code>
</p><p class="calibre7">To understand and add more transformations you can look into the source code in the <code class="email">InstCombine</code> folder.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">So, in this chapter, we looked into how simple transformations can be applied to IR. We looked into the opt tool, LLVM Pass infrastructure, the <code class="email">Passmanager</code> and how to use information of one Pass in another Pass. We ended the chapter with examples of instruction simplification and instruction combining. In the next chapter, we will see some more advanced optimizations like Loop Optimization, Scalar Evolution, and others, where we will operate at a block of code rather than individual instructions.</p></div></body></html>