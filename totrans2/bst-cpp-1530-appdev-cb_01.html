<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Starting to Write Your Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Starting to Write Your Application</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting configuration options</li><li class="listitem" style="list-style-type: disc">Storing any value in a container/variable</li><li class="listitem" style="list-style-type: disc">Storing multiple chosen types in a container/variable</li><li class="listitem" style="list-style-type: disc">Using a safer way to work with a container that stores multiple chosen types</li><li class="listitem" style="list-style-type: disc">Returning a value or flag where there is no value</li><li class="listitem" style="list-style-type: disc">Returning an array from a function</li><li class="listitem" style="list-style-type: disc">Combining multiple values into one</li><li class="listitem" style="list-style-type: disc">Reordering the parameters of a function</li><li class="listitem" style="list-style-type: disc">Binding a value as a function parameter</li><li class="listitem" style="list-style-type: disc">Using the C++11 move emulation</li><li class="listitem" style="list-style-type: disc">Making a noncopyable class</li><li class="listitem" style="list-style-type: disc">Making a noncopyable but movable class</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>Boost is a collection of <a id="id0" class="indexterm"/>C++ libraries. Each library has been reviewed by many professional programmers before being accepted to Boost. Libraries are tested on multiple platforms using many compilers and the C++ standard library implementations. While using Boost, you can be sure that you are using one of the most portable, fast, and reliable solutions that is distributed under a license suitable for commercial and open source projects.</p><p>Many parts of Boost have been included in C++11, and even more parts are going to be included in the next standard of C++. You will find C++11-specific notes in each recipe of this book.</p><p>Without a long introduction, let's get started!</p><p>In this chapter we will see some <a id="id1" class="indexterm"/>recipes for everyday use. We'll see how to get configuration options from different sources and what can be cooked up using some of the datatypes introduced by Boost library authors.</p></div></div>
<div class="section" title="Getting configuration options"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Getting configuration options</h1></div></div></div><p>Take a look at some of the console <a id="id2" class="indexterm"/>programs, such as <code class="literal">cp</code> in Linux. They all have a fancy help, their input parameters do not depend on any position, and have a human readable syntax, for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp --help </strong></span>

<span class="strong"><strong>Usage: cp [OPTION]... [-T] SOURCE DEST </strong></span>
<span class="strong"><strong>  -a, --archive           same as -dR --preserve=all </strong></span>
<span class="strong"><strong>  -b                      like --backup but does not accept an argument</strong></span>
</pre></div><p>You can implement the same functionality for your program in 10 minutes. And all you need is the <a id="id3" class="indexterm"/>
<code class="literal">Boost.ProgramOptions</code> library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is all you need for this recipe. Remember that this library is not a header-only, so your program will <a id="id4" class="indexterm"/>need to link against the <code class="literal">libboost_program_options</code> library.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How to do it...</h2></div></div></div><p>Let's start with a simple program that accepts the number of apples and oranges as input and counts the total number of fruits. We want to achieve the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ our_program –apples=10 –oranges=20</strong></span>
<span class="strong"><strong>Fruits count: 30</strong></span>
</pre></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need to include the <code class="literal">program_options</code> header and make an alias for the <code class="literal">boost::program_options</code> namespace (it is too long to type it!). We would also need an <code class="literal">&lt;iostream&gt;</code> header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/program_options.hpp&gt;
#include &lt;iostream&gt;
namespace opt = boost::program_options;</pre></div></li><li class="listitem">Now we are ready to describe our options:<div class="informalexample"><pre class="programlisting">// Constructing an options describing variable and giving
// it a textual description "All options" to it.
opt::options_description desc("All options");
    
// When we are adding options, first parameter is a name
// to be used in command line. Second parameter is a type
// of that option, wrapped in value&lt;&gt; class. 
// Third parameter must be a short description of that 
// option
desc.add_options()
    ("apples", opt::value&lt;int&gt;(), "how many apples do you have")
    ("oranges", opt::value&lt;int&gt;(), "how many oranges do you have")
;</pre></div></li><li class="listitem">We'll see how to use a third <a id="id5" class="indexterm"/>parameter a little bit later, after which we'll deal with parsing the command line and outputting the result:<div class="informalexample"><pre class="programlisting">// Variable to store our command line arguments
opt::variables_map vm;
    
// Parsing and storing arguments
opt::store(opt::parse_command_line(argc, argv, desc), vm);
opt::notify(vm);
std::cout &lt;&lt; "Fruits count: "
    &lt;&lt; vm["apples"].as&lt;int&gt;() + vm["oranges"].as&lt;int&gt;()
    &lt;&lt; std::endl;</pre></div><p>That was simple, wasn't it? </p></li><li class="listitem">Let's add the <code class="literal">--help</code> parameter to our option's description:<div class="informalexample"><pre class="programlisting">    ("help", "produce help message")</pre></div></li><li class="listitem">Now add the following lines after <code class="literal">opt::notify(vm);</code>, and you'll get a fully functional help for your program:<div class="informalexample"><pre class="programlisting">if (vm.count("help")) {
    std::cout &lt;&lt; desc &lt;&lt; "\n";
    return 1;
}</pre></div><p>Now, if we call our program with the <code class="literal">--help</code> parameter, we'll get the following output:</p><div class="informalexample"><pre class="programlisting">All options: 
  --apples arg          how many apples do you have 
  --oranges arg         how many oranges do you have 
  --help                produce help message</pre></div><p>As you can see, we do not provide a type for the option's value, because we do not expect any values to be passed to it.</p></li><li class="listitem">Once we have got through all the basics, let's add short names for some of the options, set the default value <a id="id6" class="indexterm"/>for apples, add some string input, and get the missing options from the configuration file:<div class="informalexample"><pre class="programlisting">#include &lt;boost/program_options.hpp&gt;
// 'reading_file' exception class is declared in errors.hpp
#include &lt;boost/program_options/errors.hpp&gt;
#include &lt;iostream&gt;
namespace opt = boost::program_options;

int main(int argc, char *argv[])
{
    opt::options_description desc("All options");
    // 'a' and 'o' are short option names for apples and 
    // oranges 'name' option is not marked with 
    // 'required()', so user may not support it
    desc.add_options()
        ("apples,a", opt::value&lt;int&gt;()-&gt;default_value(10), "apples that you have")
        ("oranges,o", opt::value&lt;int&gt;(), "oranges that you have")
        ("name", opt::value&lt;std::string&gt;(), "your name")
        ("help", "produce help message")
    ;
    opt::variables_map vm;
 // Parsing command line options and storing values to 'vm'
 
   opt::store(opt::parse_command_line(argc, argv, desc), vm);
    // We can also parse environment variables using 
    // 'parse_environment' method
    opt::notify(vm);
    if (vm.count("help")) {
        std::cout &lt;&lt; desc &lt;&lt; "\n";
        return 1;
    }
    // Adding missing options from "aples_oranges.cfg" 
    // config file.
    // You can also provide an istreamable object as a 
    // first parameter for 'parse_config_file'
    // 'char' template parameter will be passed to
    // underlying std::basic_istream object
    try {
      opt::store(
        opt::parse_config_file&lt;char&gt;("apples_oranges.cfg", desc), 
        vm
      );
    } catch (const opt::reading_file&amp; e) {
        std::cout 
           &lt;&lt; "Failed to open file 'apples_oranges.cfg': "
           &lt;&lt; e.what();
    }
    opt::notify(vm);
    if (vm.count("name")) {
      std::cout &lt;&lt; "Hi," &lt;&lt; vm["name"].as&lt;std::string&gt;() &lt;&lt; "!\n";
    }

    std::cout &lt;&lt; "Fruits count: "
        &lt;&lt; vm["apples"].as&lt;int&gt;() + vm["oranges"].as&lt;int&gt;()
        &lt;&lt; std::endl;
    return 0;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>When using a configuration file, we need to remember that its syntax differs from the command-line syntax. We do not need to place minuses before the options. So our <code class="literal">apples_oranges.cfg</code> option must look like this:</p><p><code class="literal">oranges=20</code></p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How it works...</h2></div></div></div><p>This example is pretty trivial to understand <a id="id7" class="indexterm"/>from code and comments. Much more interesting is what output we get on execution:</p><div class="informalexample"><pre class="programlisting">$ ./our_program --help 
All options: 
  -a [ --apples ] arg (=10) how many apples do you have 
  -o [ --oranges ] arg      how many oranges do you have 
  --name arg                your name 
  --help                    produce help message 

$ ./our_program 
Fruits count: 30

$ ./our_program -a 10 -o 10 --name="Reader" 
Hi,Reader! 
Fruits count: 20</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>There's more...</h2></div></div></div><p>The C++11 standard adopted many Boost libraries; however, you won't find <code class="literal">Boost.ProgramOptions</code> in it.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation contains many more examples and shows more advanced features of <code class="literal">Boost.ProgramOptions</code>, such as position-dependent options, nonconventional syntax, and more. This is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html">http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html</a></p></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books that you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div>
<div class="section" title="Storing any value in a container/variable"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Storing any value in a container/variable</h1></div></div></div><p>If you have been <a id="id8" class="indexterm"/>programming in Java, C#, or Delphi, you will definitely miss the ability to create containers with the <code class="literal">Object</code> value type in C++. The <code class="literal">Object</code> <a id="id9" class="indexterm"/>class in those <a id="id10" class="indexterm"/>languages is a basic class for almost all types, so you are <a id="id11" class="indexterm"/>able to assign (almost) any value to it at any time. Just <a id="id12" class="indexterm"/>imagine how great it would be to have such a feature in C++:</p><div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;auto_ptr.h&gt;

int main()
{
    typedef std::auto_ptr&lt;Object&gt; object_ptr;
    std::vector&lt;object_ptr&gt; some_values;
    some_values.push_back(new Object(10));
    some_values.push_back(new Object("Hello there"));
    some_values.push_back(new Object(std::string("Wow!")));
    std::string* p = 
         dynamic_cast&lt;std::string*&gt;(some_values.back().get());
    assert(p);

    (*p) += " That is great!\n";
    std::cout &lt;&lt; *p;
    return 0;
}</pre></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Getting ready</h2></div></div></div><p>We'll be working with the <a id="id13" class="indexterm"/>header-only library. Basic knowledge of C++ is all you need for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How to do it...</h2></div></div></div><p>In such cases, Boost <a id="id14" class="indexterm"/>offers a <a id="id15" class="indexterm"/>solution, the <code class="literal">Boost.Any</code> <a id="id16" class="indexterm"/>library, which has an even better syntax:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/any.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main()
{
    std::vector&lt;boost::any&gt; some_values;
    some_values.push_back(10);
    const char* c_str = "Hello there!";
    some_values.push_back(c_str);
    some_values.push_back(std::string("Wow!"));
    std::string&amp; s = 
       boost::any_cast&lt;std::string&amp;&gt;(some_values.back());
    s += " That is great!\n";
    std::cout &lt;&lt; s;
    return 0;
}</pre></div><p>Great, isn't it? By the way, it has an empty state, which could be checked using the <code class="literal">empty()</code> member function (just as in STL containers).</p><p>You can get the value from <code class="literal">boost::any</code> using two approaches:</p><div class="informalexample"><pre class="programlisting">    boost::any variable(std::string("Hello world!"));

    //#1: Following method may throw a boost::bad_any_cast exception
    // if actual value in variable is not a std::string
    std::string s1 = boost::any_cast&lt;std::string&gt;(variable);

    //#2: If actual value in variable is not a std::string
    // will return an NULL pointer
    std::string* s2 = boost::any_cast&lt;std::string&gt;(&amp;variable);</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::any</code> class just stores any value in it. To achieve this it uses the <span class="strong"><strong>type erasure</strong></span> technique (close to what Java or C# does with all of its types). To use this library, you do not really need to know its internal <a id="id17" class="indexterm"/>implementation, so let's just have a quick glance at the type <a id="id18" class="indexterm"/>erasure technique. <code class="literal">Boost.Any</code>, on assignment of some <a id="id19" class="indexterm"/>variable of type <code class="literal">T</code>, constructs a type (let's call it <code class="literal">holder&lt;T&gt;</code>) that may store a value <a id="id20" class="indexterm"/>of the specified type <code class="literal">T</code>, and is derived from some internal base-type placeholder. A placeholder has virtual functions for getting <code class="literal">std::type_info</code> of a stored type and for cloning a stored type. When <code class="literal">any_cast&lt;T&gt;()</code> is used, <code class="literal">boost::any</code> checks that <code class="literal">std::type_info</code> of a stored value is equal to <code class="literal">typeid(T)</code> (the overloaded placeholder's function is used for getting <code class="literal">std::type_info</code>).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>There's more...</h2></div></div></div><p>Such flexibility never comes <a id="id21" class="indexterm"/>without a <a id="id22" class="indexterm"/>cost. Copy constructing, value constructing, copy assigning, and assigning values to instances of <code class="literal">boost::any</code> will call a dynamic memory allocation function; all of the type <a id="id23" class="indexterm"/>casts need to get <span class="strong"><strong>runtime type information</strong></span> (<span class="strong"><strong>RTTI</strong></span>); <code class="literal">boost::any</code> uses virtual functions a lot. <a id="id24" class="indexterm"/>If you are keen on performance, see the next <a id="id25" class="indexterm"/>recipe, which will give you an idea of how to achieve almost the same results without dynamic allocations and RTTI usage.</p><p>Another disadvantage of <code class="literal">Boost.Any</code> is that it cannot be used with RTTI disabled. There is a possibility to make this library usable even with RTTI disabled, but it is not currently implemented.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Almost all exceptions in Boost derive from the <code class="literal">std::exception</code> class or from its derivatives, for example, <code class="literal">boost::bad_any_cast</code> is derived from <code class="literal">std::bad_cast</code>. It means that you can catch almost all Boost exceptions using <code class="literal">catch (const std::exception&amp; e)</code>.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation <a id="id26" class="indexterm"/>may <a id="id27" class="indexterm"/>give <a id="id28" class="indexterm"/>you some more examples, and it can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/any.html">http://www.boost.org/doc/libs/1_53_0/doc/html/any.html</a></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using a safer way to work with a container that stores multiple chosen types</em></span> recipe for more info on the topic</li></ul></div></div></div>
<div class="section" title="Storing multiple chosen types in a variable/container"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Storing multiple chosen types in a variable/container</h1></div></div></div><p>Are you aware of the concept <a id="id29" class="indexterm"/>of unrestricted unions in C++11? Let me tell you about it in short. <span class="strong"><strong>C++03 unions</strong></span> <a id="id30" class="indexterm"/>can only hold <a id="id31" class="indexterm"/>extremely simple types of data called POD (plain old data). So in C++03, you cannot, for example, store <code class="literal">std::string</code> or <code class="literal">std::vector</code> in a union. C++11 relaxes this requirement, but you'll have to manage the construction and destruction of such types by yourself, call in-place construction/destruction, and remember what type is stored in a union. A huge amount of work, isn't it?</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Getting ready</h2></div></div></div><p>We'll be working with the header-only library, which is simple to use. Basic knowledge of C++ is all you need for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it...</h2></div></div></div><p>Let me introduce the <code class="literal">Boost.Variant</code> library to you.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The<code class="literal"> Boost.Variant</code> library can store any of the types specified at compile time; it also manages in-place construction/destruction and doesn't even require the C++11 standard:<div class="informalexample"><pre class="programlisting">#include &lt;boost/variant.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main()
{
    typedef boost::variant&lt;int, const char*, std::string&gt; 
      my_var_t;
    std::vector&lt;my_var_t&gt; some_values;
    some_values.push_back(10);
    some_values.push_back("Hello there!");
    some_values.push_back(std::string("Wow!"));
    std::string&amp; s = boost::get&lt;std::string&gt;(some_values.back());
    s += " That is great!\n";
    std::cout &lt;&lt; s;
    return 0;
}</pre></div><p>Great, isn't it?</p></li><li class="listitem"><code class="literal">Boost.Variant</code> has no empty state, but has an <code class="literal">empty()</code> function, which always returns <code class="literal">false</code>. If <a id="id32" class="indexterm"/>you do need to represent an empty state, just add some trivial type at the first position of the types supported <a id="id33" class="indexterm"/>by the <code class="literal">Boost.Variant</code> library. When <code class="literal">Boost.Variant</code> contains that type, interpret it as an empty state. Here is an example in which we will use a <code class="literal">boost::blank</code> type to represent an empty state:<div class="informalexample"><pre class="programlisting">    typedef boost::variant&lt;boost::blank, int, const char*, std::string&gt; my_var_t;
    // Default constructor will construct an 
    // instance of boost::blank
    my_var_t var;
    // 'which()' method returns an index of a type,
    // currently held by variant.
    assert(var.which() == 0); // Empty state
    var = "Hello, dear reader";
    assert(var.which() != 0);</pre></div></li><li class="listitem">You can get a value from a variant using two approaches:<div class="informalexample"><pre class="programlisting">    boost::variant&lt;int, std::string&gt; variable(0);
    // Following method may throw a boost::bad_get
    // exception if actual value in variable is not an int
    int s1 = boost::get&lt;int&gt;(variable);
    // If actual value in variable is not an int
    // will return an NULL pointer
    int* s2 = boost::get&lt;int&gt;(&amp;variable);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::variant</code> class <a id="id34" class="indexterm"/>holds an array of characters and stores values in that array. Size of the array is determined at compile time using <code class="literal">sizeof()</code> and functions to get alignment. On assignment or <a id="id35" class="indexterm"/>construction of <code class="literal">boost::variant</code>, the previous <a id="id36" class="indexterm"/>values are in-place destroyed, and new values are constructed on top of the character array using the new placement.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.Variant</code> variables usually do not allocate memory in a heap, and they do not require RTTI to be enabled. <code class="literal">Boost.Variant</code> is extremely fast and used widely by other Boost libraries. To achieve maximum performance, make sure that there is a trivial type in the list of supported types, and that this type is at the first position.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p><code class="literal">Boost.Variant</code> is not a part of the C++11 standard.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using a safer way to work with a container that stores multiple chosen types</em></span> recipe</li><li class="listitem" style="list-style-type: disc">Boost's official <a id="id37" class="indexterm"/>documentation <a id="id38" class="indexterm"/>contains more examples and descriptions of some other features of <code class="literal">Boost.Variant</code>, and can be found at:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html">http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html</a></p></li></ul></div></div></div>
<div class="section" title="Using a safer way to work with a container that stores multiple chosen types"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Using a safer way to work with a container that stores multiple chosen types</h1></div></div></div><p>Imagine that you are creating a <a id="id39" class="indexterm"/>wrapper around some SQL database interface. You decided that <code class="literal">boost::any</code> will perfectly match the requirements for a single cell of the database table. Some other programmer will be using your classes, and his task would be to get a row from the database and count the sum of the arithmetic types in a row.</p><p>Here's how the code would look:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/any.hpp&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// This typedefs and methods will be in our header,
// that wraps around native SQL interface
typedef boost::any cell_t;
typedef std::vector&lt;cell_t&gt; db_row_t;

// This is just an example, no actual work with database.
db_row_t get_row(const char* /*query*/) {
    // In real application 'query' parameter shall have a 'const
    // char*' or 'const std::string&amp;' type? See recipe Using a 
    // reference to string type in Chapter 7, Manipulating Strings
    // for an answer.
    db_row_t row;
    row.push_back(10);
    row.push_back(10.1f);
    row.push_back(std::string("hello again"));
    return row;
}

// This is how a user will use your classes
struct db_sum: public std::unary_function&lt;boost::any, void&gt; {
private:
    double&amp; sum_;
public:
    explicit db_sum(double&amp; sum)
        : sum_(sum)
    {}

    void operator()(const cell_t&amp; value) {
        const std::type_info&amp; ti = value.type();
        if (ti == typeid(int)) {
            sum_ += boost::any_cast&lt;int&gt;(value);
        } else if (ti == typeid(float)) {
            sum_ += boost::any_cast&lt;float&gt;(value);
        }
    }
};

int main()
{
    db_row_t row = get_row("Query: Give me some row, please.");
    double res = 0.0;
    std::for_each(row.begin(), row.end(), db_sum(res));
    std::cout &lt;&lt; "Sum of arithmetic types in database row is: " &lt;&lt; res &lt;&lt; std::endl;
    return 0;
}</pre></div><p>If you compile and run this example, it will output a correct answer:</p><div class="informalexample"><pre class="programlisting">Sum of arithmetic types in database row is: 20.1</pre></div><p>Do you remember what your <a id="id40" class="indexterm"/>thoughts were when reading the implementation of <code class="literal">operator()</code>? I guess they were, "And what about double, long, short, unsigned, and other types?". The same thoughts will come to the mind of a programmer who will use your interface. So you'll need to carefully document values stored by your <code class="literal">cell_t</code>, or read the more elegant solution described in the following sections.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Getting ready</h2></div></div></div><p>Reading the previous two recipes is highly recommended if you are not already familiar with the <code class="literal">Boost.Variant</code> and <code class="literal">Boost.Any</code> libraries.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it...</h2></div></div></div><p>The <code class="literal">Boost.Variant</code> library implements a visitor programming pattern for accessing the stored data, which is much safer than getting values via <code class="literal">boost::get&lt;&gt;</code>. This pattern forces the programmer to take care of each variant type, otherwise the code will fail to compile. You can use this pattern via the <code class="literal">boost::apply_visitor</code> function, which takes a visitor functional object as the first parameter and a variant as the second parameter. Visitor functional objects must derive <a id="id41" class="indexterm"/>from the <code class="literal">boost::static_visitor&lt;T&gt;</code> class, where <code class="literal">T</code> is a type being returned by a visitor. A visitor object must have overloads of <code class="literal">operator()</code> for each type stored by a variant.</p><p>Let's change the <code class="literal">cell_t</code> type to <code class="literal">boost::variant&lt;int, float, string&gt;</code> and modify our example:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/variant.hpp&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

// This typedefs and methods will be in header,
// that wraps around native SQL interface.
typedef boost::variant&lt;int, float, std::string&gt; cell_t;
typedef std::vector&lt;cell_t&gt; db_row_t;

// This is just an example, no actual work with database.
db_row_t get_row(const char* /*query*/) {
    // See the recipe "Using a reference to string type" 
    // in Chapter 7, Manipulating Strings
    // for a better type for 'query' parameter.
    db_row_t row;
    row.push_back(10);
    row.push_back(10.1f);
    row.push_back("hello again");
    return row;
}

// This is how code required to sum values
// We can provide no template parameter
// to boost::static_visitor&lt;&gt; if our visitor returns nothing.
struct db_sum_visitor: public boost::static_visitor&lt;double&gt; {
    double operator()(int value) const {
        return value;
    }
    double operator()(float value) const {
        return value;
    }
    double operator()(const std::string&amp; /*value*/) const {
        return 0.0;
    }
};

int main()
{
    db_row_t row = get_row("Query: Give me some row, please.");
    double res = 0.0;
    db_row_t::const_iterator it = row.begin(), end = row.end();
    for (; it != end; ++it) {
         res += boost::apply_visitor(db_sum_visitor(), *it);
    }
    std::cout &lt;&lt; "Sum of arithmetic types in database row is: " &lt;&lt; res &lt;&lt; std::endl;
    return 0;
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>The <code class="literal">Boost.Variant</code> library will generate a big <code class="literal">switch</code> statement at compile time, each case of <code class="literal">which</code> will call a visitor for a single type from the variant's list of types. At runtime, the index of the stored type can <a id="id42" class="indexterm"/>be retrieved using <code class="literal">which()</code>, and a jump to the correct case in the switch will be made. Something like this will be generated for <code class="literal">boost::variant&lt;int, float, std::string&gt;</code>:</p><div class="informalexample"><pre class="programlisting">switch (which())
{
case 0: return visitor(*reinterpret_cast&lt;int*&gt;(address()));
case 1: return visitor(*reinterpret_cast&lt;float*&gt;(address()));
case 2: return visitor(*reinterpret_cast&lt;std::string*&gt;(address()));
default: assert(false);
}</pre></div><p>Here, the <code class="literal">address()</code> function returns a pointer to the internal storage of <code class="literal">boost::variant&lt;int, float, std::string&gt;</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>There's more...</h2></div></div></div><p>If we compare this example with the first example in this recipe, we'll see the following advantages of <code class="literal">boost::variant</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We know what types a variable can store</li><li class="listitem" style="list-style-type: disc">If a library writer of the SQL interface adds or modifies a type held by a variant, we'll get a compile-time error instead of incorrect behavior</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">After reading some recipes from <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <span class="emphasis"><em>Compile-time Tricks</em></span>, you'll be able to make the visitor <a id="id43" class="indexterm"/>object so generic that it will be able to work correctly even if the underlying types change</li><li class="listitem" style="list-style-type: disc">Boost's official documentation contains more examples and a description of some other features of <code class="literal">Boost.Variant</code>, and is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html">http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html</a></p></li></ul></div></div></div>
<div class="section" title="Returning a value or flag where there is no value"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Returning a value or flag where there is no value</h1></div></div></div><p>Imagine that we have a function <a id="id44" class="indexterm"/>that does not throw an exception and returns a value or indicates that an error has occurred. In Java or C# programming languages, such cases are <a id="id45" class="indexterm"/>handled by comparing a return value from a function value with a null pointer; if it is null then an error has occurred. In C++, returning a pointer from a function confuses library users and usually requires dynamic memory allocation (which is slow).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Getting ready</h2></div></div></div><p>Only basic knowledge of C++ is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How to do it...</h2></div></div></div><p>Ladies and gentlemen, let me introduce you to the <code class="literal">Boost.Optional</code> library using the following example:</p><p>The <code class="literal">try_lock_device()</code> <a id="id46" class="indexterm"/>function tries to acquire a lock for a device, and may succeed or not depending on different conditions (in our example it depends on the <code class="literal">rand()</code> function call). The function returns an optional variable that can be converted to a Boolean variable. If the returned value is equal to Boolean <code class="literal">true</code>, then the lock is acquired, and an instance of a class to work with the device can be obtained by dereferencing the returned optional variable:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/optional.hpp&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

class locked_device {
    explicit locked_device(const char* /*param*/) {
        // We have unique access to device
        std::cout &lt;&lt; "Device is locked\n";
    }
public:
    ~locked_device () {
        // Releasing device lock
    }

    void use() {
        std::cout &lt;&lt; "Success!\n";
    }
    static boost::optional&lt;locked_device&gt; try_lock_device() {
        if (rand()%2) {
            // Failed to lock device
            return boost::none;
        }
        // Success!
        return locked_device("device name");
    }
};

int main()
{
    // Boost has a library called Random. If you wonder why it was 
    // written when stdlib.h has rand() function, see the recipe
    // "Using a true random number generator in Chapter 12, 
    // Scratching the Tip of the Iceberg
    srandom(5);
    for (unsigned i = 0; i &lt; 10; ++i) {
        boost::optional&lt;locked_device&gt; t = locked_device::try_lock_device();
        // optional is convertible to bool
        if (t) {
            t-&gt;use();
            return 0;
        } else {
            std::cout &lt;&lt; "...trying again\n";
        }
    }
    std::cout &lt;&lt; "Failure!\n";
    return -1;
}</pre></div><p>This program will output the following:</p><div class="informalexample"><pre class="programlisting">...trying again 
...trying again 
Device is locked 
Success! </pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The default constructed <code class="literal">optional</code> variable is convertible to a Boolean variable holding <code class="literal">false</code> and must not be dereferenced, because it does not have an underlying type constructed.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How it works...</h2></div></div></div><p>The <code class="literal">Boost.Optional</code> class is very <a id="id47" class="indexterm"/>close to the <code class="literal">boost::variant</code> class but for only one type, <code class="literal">boost::optional&lt;T&gt;</code> has an array of <code class="literal">chars</code>, where the object of type <code class="literal">T</code> can be <a id="id48" class="indexterm"/>an in-place constructor. It also has a Boolean variable to remember the state of the object (is it constructed or not).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.Optional</code> class does not use dynamic allocation, and it does not require a default constructor for the underlying type. It is fast and considered for inclusion in the next standard of C++. The current <code class="literal">boost::optional</code> implementation cannot work with C++11 <span class="strong"><strong>rvalue</strong></span> references; however, there are some patches proposed to fix that.</p><p>The C++11 standard does not include the <code class="literal">Boost.Optional</code> class; however, it is currently being reviewed for inclusion in the next C++ standard or in C++14.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation contains more examples and describes advanced features of <code class="literal">Boost.Optional</code> (like in-place construction using the factory functions). The documentation is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html</a></p></li></ul></div></div></div>
<div class="section" title="Returning an array from a function"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Returning an array from a function</h1></div></div></div><p>Let's play a <a id="id49" class="indexterm"/>guessing game! <a id="id50" class="indexterm"/>What can you tell about the following function?</p><div class="informalexample"><pre class="programlisting">char* vector_advance(char* val);</pre></div><p>Should return values be deallocated by the programmer or not? Does the function attempt to deallocate the input parameter? Should the input parameter be zero-terminated, or should the function assume that the input parameter has a specified width?</p><p>And now, let's make the task harder! Take a look at the following line:</p><div class="informalexample"><pre class="programlisting">char ( &amp;vector_advance( char (&amp;val)[4] ) )[4];</pre></div><p>Please do not worry; I've also been scratching my head for half an hour before getting an idea of what is happening here. <code class="literal">vector_advance</code> is a function that accepts and returns an array of four elements. Is there <a id="id51" class="indexterm"/>a way to write such a function clearly?</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>Only basic knowledge of C++ is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><p>We can rewrite the function like this:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/array.hpp&gt;
typedef boost::array&lt;char, 4&gt; array4_t;array4_t&amp; vector_advance(array4_t&amp; val);</pre></div><p>Here, <code class="literal">boost::array&lt;char, 4&gt;</code> is just a simple wrapper around an array of four char elements.</p><p>This code answers all of the questions <a id="id52" class="indexterm"/>from our first example and is much more readable than the second example.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works...</h2></div></div></div><p>The first template parameter of <code class="literal">boost::array</code> is the element type, and the second one is the size of an array. <code class="literal">boost::array</code> is a fixed-size array; if you need to change the array size at runtime, use <code class="literal">std::vector</code> or <code class="literal">boost::container::vector</code> instead.</p><p>The <code class="literal">Boost.Array</code> library just contains an array in it. That is all. Simple and efficient. The <code class="literal">boost::array&lt;&gt;</code> class has no handwritten constructors and all of its members are public, so the compiler will think of it as a POD type.</p><div class="mediaobject"><img src="graphics/4880OS_01_new.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>There's more...</h2></div></div></div><p>Let's see some more examples of the usage of <code class="literal">boost::array</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/array.hpp&gt;
#include &lt;algorithm&gt;

// Functional object to increment value by one
struct add_1 : public std::unary_function&lt;char, void&gt; {
    void operator()(char&amp; c) const {
        ++ c;
    }
    // If you're not in a mood to write functional objects,
    // but don't know what does 'boost::bind(std::plus&lt;char&gt;(),
    // _1, 1)' do, then read recipe 'Binding a value as a function 
    // parameter'.
};

typedef boost::array&lt;char, 4&gt; array4_t;
array4_t&amp; vector_advance(array4_t&amp; val) {
    // boost::array has begin(), cbegin(), end(), cend(), 
    // rbegin(), size(), empty() and other functions that are 
    // common for STL containers.
    std::for_each(val.begin(), val.end(), add_1());
    return val;
}

int main() {
    // We can initialize boost::array just like an array in C++11:
    // array4_t val = {0, 1, 2, 3};
    // but in C++03 additional pair of curly brackets is required.
    array4_t val = {{0, 1, 2, 3}};

    // boost::array works like a usual array:
    array4_t val_res;       // it can be default constructible and
    val_res = vector_advance(val);  // assignable
    // if value type supports default construction and assignment

    assert(val.size() == 4);
    assert(val[0] == 1);
    /*val[4];*/ // Will trigger an assert because max index is 3
    // We can make this assert work at compile-time.
    // Interested? See recipe 'Checking sizes at compile time' 
    // in Chapter 4, Compile-time Tricks.'
    assert(sizeof(val) == sizeof(char) * array4_t::static_size);
    return 0;
}</pre></div><p>One of the biggest <a id="id53" class="indexterm"/>advantages of <code class="literal">boost::array</code> is that it provides exactly the same performance as a normal C array. People from the C++ standard committee also liked it, so it was accepted to the C++11 standard. There is a chance that your STL library already <a id="id54" class="indexterm"/>has it (you may try to include the <code class="literal">&lt;array&gt;</code> header and check for the availability of <code class="literal">std::array&lt;&gt;</code>).</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation gives a complete list of the <code class="literal">Boost.Array</code> methods with a description of the method's complexity and throw behavior, and is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/boost/array.html">http://www.boost.org/doc/libs/1_53_0/doc/html/boost/array.html</a></p></li><li class="listitem" style="list-style-type: disc">The <code class="literal">boost::array</code> function is widely used across recipes; for example, refer to the <span class="emphasis"><em>Binding a value as a function parameter</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Combining multiple values into one"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Combining multiple values into one</h1></div></div></div><p>There is a very nice present for <a id="id55" class="indexterm"/>those who like <code class="literal">std::pair</code>. Boost has a library called <a id="id56" class="indexterm"/>
<code class="literal">Boost.Tuple</code>, and it is just like <code class="literal">std::pair</code>, but it can also work with triples, quads, and even bigger collections of types.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>Only basic knowledge of C++ and STL is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it...</h2></div></div></div><p>Perform the following steps to combine multiple values in to one:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start working with tuples, you need to include a proper header and declare a variable:<div class="informalexample"><pre class="programlisting">#include &lt;boost/tuple/tuple.hpp&gt;
#include &lt;string&gt;

boost::tuple&lt;int, std::string&gt; almost_a_pair(10, "Hello");
boost::tuple&lt;int, float, double, int&gt; quad(10, 1.0f, 10.0, 1);</pre></div></li><li class="listitem">Getting a specific value is implemented via the <code class="literal">boost::get&lt;N&gt;()</code> function, where <code class="literal">N</code> is a zero-based index of a required value:<div class="informalexample"><pre class="programlisting">    int i = boost::get&lt;0&gt;(almost_a_pair);
    const std::string&amp; str = boost::get&lt;1&gt;(almost_a_pair);
    double d = boost::get&lt;2&gt;(quad);</pre></div><p>The <code class="literal">boost::get&lt;&gt;</code> function <a id="id57" class="indexterm"/>has many overloads and is used widely across Boost. We have already seen how it can be used with other libraries in the <span class="emphasis"><em>Storing multiple chosen types in a container/variable</em></span> recipe.</p></li><li class="listitem">You can construct tuples using <a id="id58" class="indexterm"/>the <code class="literal">boost::make_tuple()</code> <a id="id59" class="indexterm"/>function, which is shorter to write, because you do not need to fully qualify the tuple type:<div class="informalexample"><pre class="programlisting">    using namespace boost;
    
    // Tuple comparison operators are
    // defined in header "boost/tuple/tuple_comparison.hpp"
    // Don't forget to include it!
    std::set&lt;tuple&lt;int, double, int&gt; &gt; s;
    s.insert(make_tuple(1, 1.0, 2));
    s.insert(make_tuple(2, 10.0, 2));
    s.insert(make_tuple(3, 100.0, 2));

    // Requires C++11
    auto t = make_tuple(0, -1.0, 2);
    assert(2 == get&lt;2&gt;(t));
    // We can make a compile-time assert for type
    // of t. Interested? See chapter 'compile-time tricks'</pre></div></li><li class="listitem">Another function that makes life easy is <code class="literal">boost::tie()</code>. It works almost as <code class="literal">make_tuple</code>, but adds a nonconst reference for each of the passed types. Such a tuple can be used to get values to a variable from another tuple. It can be better understood from the following example:<div class="informalexample"><pre class="programlisting">    boost::tuple&lt;int, float, double, int&gt; quad(10, 1.0f, 10.0, 1);
    int i;
    float f;
    double d;
    int i2;

    // Passing values from 'quad' variables
    // to variables 'i', 'f', 'd', 'i2'
    boost::tie(i, f, d, i2) = quad;
    assert(i == 10);
    assert(i2 == 1);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How it works...</h2></div></div></div><p>Some readers may wonder why we need a tuple when we can always write our own structures with better names, for <a id="id60" class="indexterm"/>example, instead of writing <code class="literal">boost::tuple&lt;int, std::string&gt;</code>, we can create a structure:</p><div class="informalexample"><pre class="programlisting">struct id_name_pair {
    int id;
    std::string name;
};</pre></div><p>Well, this structure is definitely more clear than <code class="literal">boost::tuple&lt;int, std::string&gt;</code>. But what if this structure is used only twice in the code?</p><p>The main idea behind the tuple's library is to simplify template programming.</p><div class="mediaobject"><img src="graphics/4880OS_01_new.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>There's more...</h2></div></div></div><p>A tuple works as fast as <code class="literal">std::pair</code> (it does not allocate memory on a heap and has no virtual functions). The C++ committee found this class to be very useful and it was included in STL; you can find it in a C++11-compatible STL implementation in the header file <code class="literal">&lt;tuple&gt;</code> (don't forget to replace all the <code class="literal">boost::</code> namespaces with <code class="literal">std::</code>).</p><p>The current Boost implementation of a tuple does not use variadic templates; it is just a set of classes generated by a script. There is an experimental version that uses C++11 rvalues and an emulation of them on C++03 compilers, so there is a chance that Boost 1.54 will be shipped with faster <a id="id61" class="indexterm"/>implementation of tuples.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec41"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The experimental version of <a id="id62" class="indexterm"/>tuples can be found at the following link:<p><a class="ulink" href="http://svn.boost.org/svn/boost/sandbox/tuple-move/">http://svn.boost.org/svn/boost/sandbox/tuple-move/</a></p></li><li class="listitem" style="list-style-type: disc">Boost's official documentation contains more examples, information about performance, and abilities of <code class="literal">Boost.Tuple</code>. It is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/tuple/doc/tuple_users_guide.html">http://www.boost.org/doc/libs/1_53_0/libs/tuple/doc/tuple_users_guide.html</a></p></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Converting all tuple elements to strings</em></span> recipe in <a class="link" href="ch08.html" title="Chapter 8. Metaprogramming">Chapter 8</a>, <span class="emphasis"><em>Metaprogramming,</em></span> shows some advanced usages of tuples</li></ul></div></div></div>
<div class="section" title="Reordering the parameters of function"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Reordering the parameters of function</h1></div></div></div><p>This recipe and the next one are <a id="id63" class="indexterm"/>devoted to a very interesting library, whose functionality at first glance looks like some kind of magic. This library is called <code class="literal">Boost.Bind</code> and it allows you to easily create new functional objects from functions, member <a id="id64" class="indexterm"/>functions, and functional objects, also allowing the reordering of the initial function's input parameters and binding some values or references as function parameters.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec42"/>Getting ready</h2></div></div></div><p>Knowledge of C++, STL algorithms, and functional objects is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start with an example. You are working with a vector of integral types provided by some other programmer. That integral type has only one operator, <code class="literal">+</code>, but your task is to multiply a value by two. Without <code class="literal">bind</code> this can be achieved with the use of a functional object:<div class="informalexample"><pre class="programlisting">class Number{};
inline Number operator + (Number, Number);

// Your code starts here
struct mul_2_func_obj: public std::unary_function&lt;Number, Number&gt; {
    Number operator()(Number n1) const {
        return n1 + n1;
    }
};

void mul_2_impl1(std::vector&lt;Number&gt;&amp; values) {
    std::for_each(values.begin(), values.end(), mul_2_func_obj());
}</pre></div><p>With <code class="literal">Boost.Bind</code>, it would be as follows:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/bind.hpp&gt;
#include &lt;functional&gt;

void mul_2_impl2(std::vector&lt;Number&gt;&amp; values) {
   std::for_each(values.begin(), values.end(),
       boost::bind(std::plus&lt;Number&gt;(), _1, _1));
}</pre></div></li><li class="listitem">By the way, we can easily make this function more generic:<div class="informalexample"><pre class="programlisting">template &lt;class T&gt;
void mul_2_impl3(std::vector&lt;T&gt;&amp; values) {
   std::for_each(values.begin(), values.end(),
       boost::bind(std::plus&lt;T&gt;(), _1, _1));
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How it works...</h2></div></div></div><p>Let's take a closer look at the <code class="literal">mul_2</code> <a id="id65" class="indexterm"/>function. We provide a vector of values to it, and for each value it applies a functional object returned by the <code class="literal">bind()</code> function. The <code class="literal">bind()</code> <a id="id66" class="indexterm"/>function takes in three parameters; the first parameter is an instance of the <code class="literal">std::plus&lt;Number&gt;</code> class (which is a functional object). The second and third parameters are placeholders. The <a id="id67" class="indexterm"/>placeholder <code class="literal">_1</code> substitutes the argument with the first input argument of the resulting functional object. As you might guess, there are many placeholders; placeholder <code class="literal">_2</code> means <a id="id68" class="indexterm"/>substituting the argument with the second input argument of the resulting functional object, and the same also applies to placeholder <code class="literal">_3</code>. Well, seems you've got the idea.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec45"/>There's more...</h2></div></div></div><p>Just to make sure that you've got the whole idea and know where bind can be used, let's take a look at another example.</p><p>We have two classes, which work with some sensor devices. The devices and classes are from different vendors, so they provide different APIs. Both classes have only one public method <code class="literal">watch</code>, which accepts a functional object:</p><div class="informalexample"><pre class="programlisting">class Device1 {
private:
    short temperature();
    short wetness();
    int illumination();
    int atmospheric_pressure();
    void wait_for_data();
public:
    template &lt;class FuncT&gt;
    void watch(const FuncT&amp; f) {
        for(;;) {
            wait_for_data();
            f(
                temperature(),
                wetness(),
                illumination(),
                atmospheric_pressure()
            );
        }
    }
};

class Device2 {
private:
    short temperature();
    short wetness();
    int illumination();
    int atmospheric_pressure();
    void wait_for_data();
public:
    template &lt;class FuncT&gt;
    void watch(const FuncT&amp; f) {
        for(;;) {
            wait_for_data();
            f(
                wetness(),
                temperature(),
                atmospheric_pressure(),
                illumination()
            );
        }
    }
};</pre></div><p>The <code class="literal">Device1::watch</code> and <code class="literal">Device2::watch</code> functions pass values to a functional object in a different order.</p><p>Some other libraries provide a <a id="id69" class="indexterm"/>function, which is used to detect storms, and throws an exception when the risk of a storm is high enough:</p><div class="informalexample"><pre class="programlisting">void detect_storm(int wetness, int temperature, int atmospheric_pressure);</pre></div><p>Your task is to provide a storm-detecting <a id="id70" class="indexterm"/>function to both of the devices. Here is how it can be achieved using the <code class="literal">bind</code> function:</p><div class="informalexample"><pre class="programlisting">    Device1 d1;
    // resulting functional object will silently ignore 
    // additional parameters passed to function call
    d1.watch(boost::bind(&amp;detect_storm, _2, _1, _4));
    ...
    Device2 d2;
    d2.watch(boost::bind(&amp;detect_storm, _1, _2, _3));</pre></div><p>The <code class="literal">Boost.Bind</code> library provides good performance because it does not use dynamic allocations and virtual functions. It is useful even when the C++11 lambda functions are not usable:</p><div class="informalexample"><pre class="programlisting">template &lt;class FuncT&gt;
void watch(const FuncT&amp; f) {
    f(10, std::string("String"));
    f(10, "Char array");
    f(10, 10);
}

struct templated_foo {
    template &lt;class T&gt;
    void operator()(T, int) const {
        // No implementation, just showing that bound
        // functions still can be used as templated
    }
};

void check_templated_bind() {
    // We can directly specify return type of a functional object
    // when bind fails to do so
    watch(boost::bind&lt;void&gt;(templated_foo(), _2, _1));
}</pre></div><p>Bind is a part of the C++11 standard. It is defined in the <code class="literal">&lt;functional&gt;</code> header and may slightly differ from the <code class="literal">Boost.Bind</code> implementation (however, it will be at least as effective as Boost's implementation).</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec46"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Binding a value as a function parameter</em></span> recipe says more about the features of <code class="literal">Boost.Bind</code></li><li class="listitem" style="list-style-type: disc">Boost's official documentation <a id="id71" class="indexterm"/>contains many more examples and descriptions of advanced features. It is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html">http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html</a></p></li></ul></div></div></div>
<div class="section" title="Binding a value as a function parameter"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Binding a value as a function parameter</h1></div></div></div><p>If you work with the STL library a <a id="id72" class="indexterm"/>lot and use the <code class="literal">&lt;algorithm&gt;</code> header, you will definitely write a lot of functional objects. You can construct them using a set of <a id="id73" class="indexterm"/>STL adapter functions such as <code class="literal">bind1st</code>, <code class="literal">bind2nd</code>, <code class="literal">ptr_fun</code>, <code class="literal">mem_fun</code>, and <code class="literal">mem_fun_ref</code>, or you can write them by hand (because adapter functions look scary). Here is some good news: <code class="literal">Boost.Bind</code> can be used instead of all of those functions and it provides a more human-readable syntax.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec47"/>Getting ready</h2></div></div></div><p>Read the previous recipe to get an idea of placeholders, or just make sure that you are familiar with C++11 placeholders. Knowledge of STL functions and algorithms is welcomed.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec48"/>How to do it...</h2></div></div></div><p>Let's see some examples of the <a id="id74" class="indexterm"/>usage of <code class="literal">Boost.Bind</code> along with traditional STL classes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Count values greater than or equal to 5 as shown in the following code:<div class="informalexample"><pre class="programlisting">boost::array&lt;int, 12&gt; values = {{1, 2, 3, 4, 5, 6, 7, 100, 99, 98, 97, 96}};

std::size_t count0 = std::count_if(values.begin(), values.end(),
      std::bind1st(std::less&lt;int&gt;(), 5));
std::size_t count1 = std::count_if(values.begin(), values.end(),
      boost::bind(std::less&lt;int&gt;(), 5, _1));
assert(count0 == count1);</pre></div></li><li class="listitem">This is how we could count empty strings:<div class="informalexample"><pre class="programlisting">boost::array&lt;std::string, 3&gt;  str_values = {{"We ", "are", " the champions!"}};
count0 = std::count_if(str_values.begin(), str_values.end(),
      std::mem_fun_ref(&amp;std::string::empty));
count1 = std::count_if(str_values.begin(), str_values.end(),
      boost::bind(&amp;std::string::empty, _1));
assert(count0 == count1);</pre></div></li><li class="listitem">Now let's count strings <a id="id75" class="indexterm"/>with a length less than <code class="literal">5</code>:<div class="informalexample"><pre class="programlisting">// That code won't compile! And it is hard to understand
//count0 = std::count_if(str_values.begin(), 
//str_values.end(),
//std::bind2nd(
//    std::bind1st(
//        std::less&lt;std::size_t&gt;(),
//        std::mem_fun_ref(&amp;std::string::size)
//    )
//, 5
//));
// This will become much more readable,
// when you get used to bind
count1 = std::count_if(str_values.begin(), str_values.end(),
    boost::bind(std::less&lt;std::size_t&gt;(), 
    boost::bind(&amp;std::string::size, _1), 5));
assert(2 == count1);</pre></div></li><li class="listitem">Compare the strings:<div class="informalexample"><pre class="programlisting">std::string s("Expensive copy constructor of std::string will be called when binding");
count0 = std::count_if(str_values.begin(), str_values.end(), std::bind2nd(std::less&lt;std::string&gt;(), s));
count1 = std::count_if(str_values.begin(), str_values.end(), boost::bind(std::less&lt;std::string&gt;(), _1, s));
assert(count0 == count1);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec49"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::bind</code> function <a id="id76" class="indexterm"/>returns a functional object that stores a copy of the bound values and a copy of the original functional object. When the actual call to <code class="literal">operator()</code> is performed, the stored parameters are passed to the original functional object along with the parameters passed at the time of call.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec50"/>There's more...</h2></div></div></div><p>Take a look at the previous examples. When we are binding values, we copy a value into a functional object. For some classes this operation is expensive. Is there a way to bypass copying?</p><p>Yes, there is! And the <code class="literal">Boost.Ref</code> library will help us here! It contains two functions, <code class="literal">boost::ref()</code> and <code class="literal">boost::cref()</code>, the first of which allows us to pass a parameter as a reference, and the second one passes the parameter as a constant reference. The <code class="literal">ref()</code> and <code class="literal">cref()</code> <a id="id77" class="indexterm"/>functions just construct an object of <a id="id78" class="indexterm"/>type <code class="literal">reference_wrapper&lt;T&gt;</code> or <code class="literal">reference_wrapper&lt;const T&gt;</code>, <a id="id79" class="indexterm"/>which is implicitly convertible to a reference type. Let's change our previous examples:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/ref.hpp&gt;
...
std::string s("Expensive copy constructor of std::string now "
             "won't be called when binding");
count0 = std::count_if(str_values.begin(), str_values.end(), std::bind2nd(std::less&lt;std::string&gt;(), boost::cref(s)));
count1 = std::count_if(str_values.begin(), str_values.end(), boost::bind(std::less&lt;std::string&gt;(), _1, boost::cref(s)));
assert(count0 == count1);</pre></div><p>Just one more example to show you how <code class="literal">boost::ref</code> can be used to concatenate strings:</p><div class="informalexample"><pre class="programlisting">void wierd_appender(std::string&amp; to, const std::string&amp; from) {
    to += from;
};

std::string result;
std::for_each(str_values.cbegin(), str_values.cend(), boost::bind(&amp;wierd_appender, boost::ref(result), _1));
assert(result == "We are the champions!");</pre></div><p>The functions <code class="literal">ref</code> and <code class="literal">cref</code> (and <code class="literal">bind</code>) are accepted to the C++11 standard and defined in the <code class="literal">&lt;functional&gt;</code> header in the <code class="literal">std::</code> namespace. None of these functions dynamically allocate memory in the <a id="id80" class="indexterm"/>heap and they do not use virtual functions. The objects returned by them are easy to optimize and they do not apply any optimization barriers for good compilers.</p><p>STL implementations of those functions may have additional optimizations to reduce compilation time or just compiler-specific optimizations, but unfortunately, some STL implementations miss the functionality of <a id="id81" class="indexterm"/>Boost versions. You may use the STL version of those functions with any Boost library, or even mix Boost and STL versions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec51"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost.Bind</code> library is used widely across this book; see <a class="link" href="ch06.html" title="Chapter 6. Manipulating Tasks">Chapter 6</a>, <span class="emphasis"><em>Manipulating Tasks</em></span>, and <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <span class="emphasis"><em>Multithreading</em></span>, for more examples</li><li class="listitem" style="list-style-type: disc">The official documentation contains many more examples and a description of advanced features at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html">http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html</a></li></ul></div></div></div>
<div class="section" title="Using the C++11 move emulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Using the C++11 move emulation</h1></div></div></div><p>One of the greatest features of the C++11 standard is rvalue references. This feature allows us to modify temporary objects, "stealing" resources from them. As you can guess, the C++03 standard has no rvalue <a id="id82" class="indexterm"/>references, but using the <code class="literal">Boost.Move</code> library you can write some portable code that uses them, and even more, you actually get started with the emulation of move semantics.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec52"/>Getting ready</h2></div></div></div><p>It is highly recommended to at least know the basics of C++11 rvalue references.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec53"/>How to do it...</h2></div></div></div><p>Now, let's take a look at the following examples:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Imagine that you have a class with multiple fields, some of which are STL containers.<div class="informalexample"><pre class="programlisting">namespace other {
    // Its default construction is cheap/fast
    class characteristics{};
} // namespace other

struct person_info {
    // Fields declared here
    // ...
    bool is_male_;
    std::string name_;
    std::string second_name_;
    other::characteristics characteristic_;
};</pre></div></li><li class="listitem">It is time to add the move assignment and move constructors to it! Just remember that in C++03, STL containers have neither move operators nor move constructors.</li><li class="listitem">The correct implementation of the move assignment is the same as <code class="literal">swap</code> and <code class="literal">clear</code> (if an empty state is allowed). The correct implementation of the move constructor is close to the <a id="id83" class="indexterm"/>default construct and <code class="literal">swap</code>. So, let's start with the <code class="literal">swap</code> member function:<div class="informalexample"><pre class="programlisting">#include &lt;boost/swap.hpp&gt;

    void swap(person_info&amp; rhs) {
        std::swap(is_male_, rhs.is_male_);
        name_.swap(rhs.name_);
        second_name_.swap(rhs.second_name_);
        boost::swap(characteristic_, rhs.characteristic_);
    }</pre></div></li><li class="listitem">Now put the following macro in the <code class="literal">private</code> section:<div class="informalexample"><pre class="programlisting">BOOST_COPYABLE_AND_MOVABLE(classname)</pre></div></li><li class="listitem">Write a copy constructor.</li><li class="listitem">Write a copy assignment, taking the parameter as <code class="literal">BOOST_COPY_ASSIGN_REF(classname)</code>.</li><li class="listitem">Write a move constructor and a move assignment, taking the parameter as <code class="literal">BOOST_RV_REF(classname)</code>:<div class="informalexample"><pre class="programlisting">
<code class="literal">struct person_info {</code>
    // Fields declared here
    // ...
private:
    BOOST_COPYABLE_AND_MOVABLE(person_info)
public:
    // For the simplicity of example we will assume that 
    // person_info default constructor and swap are very 
    // fast/cheap to call
    person_info() {}

    person_info(const person_info&amp; p)
        : is_male_(p.is_male_)
        , name_(p.name_)
        , second_name_(p.second_name_)
        , characteristic_(p.characteristic_)
    {}

    person_info(BOOST_RV_REF(person_info) person) {
        swap(person);
    }

    person_info&amp; operator=(BOOST_COPY_ASSIGN_REF(person_info) person) {
        if (this != &amp;person) {
             person_info tmp(person);
             swap(tmp);
         }
        return *this;
    }

    person_info&amp; operator=(BOOST_RV_REF(person_info) person) {
        if (this != &amp;person) {
             swap(person);
             person_info tmp;
             tmp.swap(person);
         }
        return *this;
    }

    void swap(person_info&amp; rhs) {
    // …
    }

};</pre></div></li><li class="listitem">Now we have a portable, fast implementation of the move assignment and move construction operators of the <code class="literal">person_info</code> class.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec54"/>How it works...</h2></div></div></div><p>Here is an example of how the <a id="id84" class="indexterm"/>move assignment can be used:</p><div class="informalexample"><pre class="programlisting">    person_info vasya;
    vasya.name_ = "Vasya";
    vasya.second_name_ = "Snow";
    vasya.is_male_ = true;

    person_info new_vasya(boost::move(vasya));
    assert(new_vasya.name_ == "Vasya");
    assert(new_vasya.second_name_ == "Snow");
    assert(vasya.name_.empty());
    assert(vasya.second_name_.empty());

    vasya = boost::move(new_vasya);
    assert(vasya.name_ == "Vasya");
    assert(vasya.second_name_ == "Snow");
    assert(new_vasya.name_.empty());
    assert(new_vasya.second_name_.empty());</pre></div><p>The <code class="literal">Boost.Move</code> library is implemented in a very efficient way. When the C++11 compiler is used, all the macros for <a id="id85" class="indexterm"/>rvalues emulation will be expanded to C++11-specific features, otherwise (on C++03 compilers) rvalues will be emulated using specific datatypes and functions that never copy passed values nor called any dynamic memory allocations or virtual functions.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec55"/>There's more...</h2></div></div></div><p>Have you noticed the <code class="literal">boost::swap</code> call? It is a really helpful utility function, which will first search for a <code class="literal">swap</code> function in the namespace of a variable (the namespace <code class="literal">other::</code>), and if there is no swap function for the <code class="literal">characteristics</code> class, it will use the STL implementation of swap.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec56"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information about emulation implementation can be found on the Boost website and in the sources of the <code class="literal">Boost.Move</code> library at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/move.html">http://www.boost.org/doc/libs/1_53_0/doc/html/move.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost.Utility</code> library <a id="id86" class="indexterm"/>is the one that contains <code class="literal">boost::utility</code>, and it has many useful functions and classes. Refer to its documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm">http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm</a>.</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Initializing the base class by the member of the derived</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Managing Resources">Chapter 3</a>, <span class="emphasis"><em>Managing Resources</em></span>.</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Making a noncopyable class</em></span> recipe.</li><li class="listitem" style="list-style-type: disc">In the <span class="emphasis"><em>Making a noncopyable but movable class</em></span> recipe, there is more info about <code class="literal">Boost.Move</code> and some examples on how we can use the movable objects in containers in a portable and efficient way.</li></ul></div></div></div>
<div class="section" title="Making a noncopyable class"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Making a noncopyable class</h1></div></div></div><p>You must have almost certainly <a id="id87" class="indexterm"/>encountered situations where providing a copy constructor and <a id="id88" class="indexterm"/>move assignment operator for a class will require too much work, or where a class owns some resources that must not be copied for technical reasons:</p><div class="informalexample"><pre class="programlisting">class descriptor_owner {
    void* descriptor_;

public:
    explicit descriptor_owner(const char* params);

    ~descriptor_owner() {
        system_api_free_descriptor(descriptor_);
    }
};</pre></div><p>The C++ compiler, in the case of the previous example, will generate a copy constructor and an assignment operator, so the potential user of the <code class="literal">descriptor_owner</code> class will be able to create the following awful things:</p><div class="informalexample"><pre class="programlisting">    descriptor_owner d1("O_o");  
    descriptor_owner d2("^_^");
    
    // Descriptor of d2 was not correctly freed
    d2 = d1;
    
    // destructor of d2 will free the descriptor
    // destructor of d1 will try to free already freed descriptor</pre></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec57"/>Getting ready</h2></div></div></div><p>Only very basic knowledge of C++ is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec58"/>How to do it...</h2></div></div></div><p>To avoid such situations, the <code class="literal">boost::noncopyable</code> class was invented. If you derive your own class from it, the copy constructor and assignment operator won't be generated by the C++ compiler:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/noncopyable.hpp&gt;

class descriptor_owner_fixed : private boost::noncopyable {
    …</pre></div><p>Now the user won't be able to <a id="id89" class="indexterm"/>do bad things:</p><div class="informalexample"><pre class="programlisting">    descriptor_owner_fixed d1("O_o");
    descriptor_owner_fixed d2("^_^");
    // Won't compile
    d2 = d1;
    // Won't compile either
    descriptor_owner_fixed d3(d1);</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec59"/>How it works...</h2></div></div></div><p>A sophisticated reader will tell me that we can achieve exactly the same result by making a copy constructor and an assignment operator of <code class="literal">descriptor_owning_fixed</code> private, or just by defining them without <a id="id90" class="indexterm"/>actual implementation. Yes, you are correct. Moreover, this is the current implementation of the <code class="literal">boost::noncopyable</code> class. But <code class="literal">boost::noncopyable</code> also serves as good documentation for your class. It never raises questions such as "Is the copy constructor body defined elsewhere?" or "Does it have a nonstandard copy constructor (with a nonconst referenced parameter)?".</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec60"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Making a noncopyable but movable class</em></span> recipe will give you ideas on how to allow unique ownership of a resource in C++03 by moving it</li><li class="listitem" style="list-style-type: disc">You may find a lot of helpful functions and classes in the <code class="literal">Boost.Utility</code> library's official documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm">http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm</a></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Initializing the base class by the member of the derived</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Managing Resources">Chapter 3</a>, <span class="emphasis"><em>Managing Resources</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the C++11 move emulation</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Making a noncopyable but movable class"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Making a noncopyable but movable class</h1></div></div></div><p>Now imagine the following <a id="id91" class="indexterm"/>situation: we have a resource that <a id="id92" class="indexterm"/>cannot be copied, which should be correctly freed in a destructor, and we want to return it from a function:</p><div class="informalexample"><pre class="programlisting">descriptor_owner construct_descriptor() {
    return descriptor_owner("Construct using this string");
}</pre></div><p>Actually, you can work around such situations using the <code class="literal">swap</code> method:</p><div class="informalexample"><pre class="programlisting">void construct_descriptor1(descriptor_owner&amp; ret) {
    descriptor_owner("Construct using this string").swap(ret);
}</pre></div><p>But such a workaround won't allow us to use <code class="literal">descriptor_owner</code> in STL or Boost containers. And by the way, it looks awful!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec61"/>Getting ready</h2></div></div></div><p>It is highly recommended to know at least the basics of C++11 rvalue references. Reading the <span class="emphasis"><em>Using the C++11 move emulation</em></span> recipe is also recommended.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec62"/>How to do it...</h2></div></div></div><p>Those readers who use C++11 already <a id="id93" class="indexterm"/>know about the move-only classes (like <code class="literal">std::unique_ptr</code> or <code class="literal">std::thread</code>). Using such an approach, we can make a move-only <code class="literal">descriptor_owner</code> class:</p><div class="informalexample"><pre class="programlisting">class descriptor_owner1 {
    void* descriptor_;

public:
    descriptor_owner1()
        : descriptor_(NULL)
    {}

    explicit descriptor_owner1(const char* param)
        : descriptor_(strdup(param))
    {}

    descriptor_owner1(descriptor_owner1&amp;&amp; param)
        : descriptor_(param.descriptor_)
    {
        param.descriptor_ = NULL;
    }

    descriptor_owner1&amp; operator=(descriptor_owner1&amp;&amp; param) {
        clear();
        std::swap(descriptor_, param.descriptor_);
        return *this;
    }

    void clear() {
        free(descriptor_);
        descriptor_ = NULL;
    }

    bool empty() const {
        return !descriptor_;
    }

    ~descriptor_owner1() {
        clear();
    }
};

// GCC compiles the following in with -std=c++0x
descriptor_owner1 construct_descriptor2() {
    return descriptor_owner1("Construct using this string");
}

void foo_rv() {
    std::cout &lt;&lt; "C++11\n";
    descriptor_owner1 desc;
    desc = construct_descriptor2();
    assert(!desc.empty());
}</pre></div><p>This will work only on C++11 compatible compilers. That is the right moment for <code class="literal">Boost.Move</code>! Let's modify our <a id="id94" class="indexterm"/>example so it can be used on C++03 compilers.</p><p>According to the documentation, to <a id="id95" class="indexterm"/>write a movable but noncopyable type in portable syntax, we need to follow these simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Put the <code class="literal">BOOST_MOVABLE_BUT_NOT_COPYABLE(classname)</code> macro in the <code class="literal">private</code> section:<div class="informalexample"><pre class="programlisting">class descriptor_owner_movable {
    void* descriptor_;
    BOOST_MOVABLE_BUT_NOT_COPYABLE(descriptor_owner_movable)</pre></div></li><li class="listitem">Write a move constructor and a move assignment, taking the parameter as <code class="literal">BOOST_RV_REF(classname)</code>:<div class="informalexample"><pre class="programlisting">#include &lt;boost/move/move.hpp&gt;

public:
    descriptor_owner_movable()
        : descriptor_(NULL)
    {}

    explicit descriptor_owner_movable(const char* param)
        : descriptor_(strdup(param))
    {}

    descriptor_owner_movable(
      BOOST_RV_REF(descriptor_owner_movable) param)
       : descriptor_(param.descriptor_)
    { 
    param.descriptor_ = NULL;
    }

    descriptor_owner_movable&amp; operator=(
      BOOST_RV_REF(descriptor_owner_movable) param)
    {
      clear();
      std::swap(descriptor_, param.descriptor_);
      return *this;
    }
    // ...
};

descriptor_owner_movable construct_descriptor3() {
    return descriptor_owner_movable("Construct using this string");
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec63"/>How it works...</h2></div></div></div><p>Now we have a movable but non<a id="id96" class="indexterm"/>copyable class that can be used even <a id="id97" class="indexterm"/>on C++03 compilers and in <code class="literal">Boost.Containers</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/container/vector.hpp&gt;
...
    // Following code will work on C++11 and C++03 compilers
    descriptor_owner_movable movable;
    movable = construct_descriptor3();
    boost::container::vector&lt;descriptor_owner_movable&gt; vec;
    vec.resize(10);
    vec.push_back(construct_descriptor3());

    vec.back() = boost::move(vec.front());</pre></div><p>But unfortunately, C++03 STL containers still won't be able to use it (that is why we used a vector from <code class="literal">Boost.Containers</code> in the previous example).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec64"/>There's more...</h2></div></div></div><p>If you want to use <code class="literal">Boost.Containers</code> on C++03 compilers and STL containers, on C++11 compilers you can use the following simple trick. Add the header file to your project with the following content:</p><div class="informalexample"><pre class="programlisting">// your_project/vector.hpp
// Copyright and other stuff goes here

// include guards
#ifndef YOUR_PROJECT_VECTOR_HPP
#define YOUR_PROJECT_VECTOR_HPP

#include &lt;boost/config.hpp&gt;

// Those macro declared in boost/config.hpp header
// This is portable and can be used with any version of boost 
// libraries
#if !defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
// We do have rvalues
#include &lt;vector&gt;

namespace your_project_namespace {
  using std::vector;
} // your_project_namespace

#else
// We do NOT have rvalues
#include &lt;boost/container/vector.hpp&gt;

namespace your_project_namespace {
  using boost::container::vector;
} // your_project_namespace

#endif // !defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
#endif // YOUR_PROJECT_VECTOR_HPP</pre></div><p>Now you can <a id="id98" class="indexterm"/>include <code class="literal">&lt;your_project/vector.hpp&gt;</code> and use a vector from the namespace <code class="literal">your_project_namespace</code>:</p><div class="informalexample"><pre class="programlisting">    your_project_namespace::vector&lt;descriptor_owner_movable&gt; v;
    v.resize(10);
    v.push_back(construct_descriptor3());
    v.back() = boost::move(v.front());</pre></div><p>But beware of compiler- and STL-implementation-specific issues! For example, this code will compile on GCC 4.7 in C++11 <a id="id99" class="indexterm"/>mode only if you mark the <a id="id100" class="indexterm"/>move constructor, destructor, and move assignment operators with <code class="literal">noexcept</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec65"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Reducing code size and increasing performance of user-defined types (UDTs) in C++11</em></span> recipe in <a class="link" href="ch10.html" title="Chapter 10. Gathering Platform and Compiler Information">Chapter 10</a>, <span class="emphasis"><em>Gathering Platform and Compiler Information</em></span>, for more info on <code class="literal">noexcept</code></li><li class="listitem" style="list-style-type: disc">More information about <code class="literal">Boost.Move</code> can be found on Boost's website <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/move.html">http://www.boost.org/doc/libs/1_53_0/doc/html/move.html</a></li></ul></div></div></div></body></html>