["```cpp\nclass GL_Window { \n  ... \nprivate: \n  ... \n  sf::Window m_window; \n  ... \n}; \n\n```", "```cpp\nvoid GL_Window::BeginDraw() { \n  glClearColor(0.f, 0.f, 0.f, 1.f); // BLACK \n  glClear(GL_COLOR_BUFFER_BIT); \n} \n\n```", "```cpp\nGame::Game() : m_window(\"Chapter 7\", sf::Vector2u(800, 600)) \n{ \n  ... \n  std::cout << glGetString(GL_VERSION) << std::endl; \n  GLenum status = glewInit(); \n  if (status != GLEW_OK) { \n    std::cout << \"GLEW failed!\" << std::endl; \n  } \n  ... \n} \n\n```", "```cpp\nglBegin(GL_TRIANGLES); \n\nglColor3f(1.0f, 0.0f, 0.0f); // Red \nglVertex3f(-0.5f, -0.5f, 0.5f); \n\nglColor3f(0.0f, 1.0f, 0.0f); // Green \nglVertex3f(-0.5f, 0.5f, 0.5f); \n\nglColor3f(0.0f, 0.0f, 1.0f); // Blue \nglVertex3f(0.5f,  0.5f, 0.5f); \n\nglEnd(); \n\n```", "```cpp\nenum class VertexAttribute{ Position, COUNT }; \n\nstruct GL_Vertex { \n  GL_Vertex(const glm::vec3& l_pos): m_pos(l_pos) {} \n\n  glm::vec3 m_pos; // Attribute 1\\. \n  // ... \n}; \n\n```", "```cpp\nclass GL_Model { \npublic: \n  GL_Model(GL_Vertex* l_vertices, unsigned int l_vertCount); \n  ~GL_Model(); \n\n  void Draw(); \nprivate: \n  GLuint m_VAO; \n  GLuint m_vertexVBO; \n  unsigned int m_drawCount; \n}; \n\n```", "```cpp\nGL_Model::GL_Model(GL_Vertex* l_vertices, \n  unsigned int l_vertCount) \n{ \n  m_drawCount = l_vertCount; \n\n  glGenVertexArrays(1, &m_VAO); \n  glBindVertexArray(m_VAO); \n  glGenBuffers(1, &m_vertexVBO); \n\n  glBindBuffer(GL_ARRAY_BUFFER, m_vertexVBO); \n  glBufferData(GL_ARRAY_BUFFER, \n    l_vertCount * sizeof(l_vertices[0]), \n    l_vertices, GL_STATIC_DRAW); \n  glEnableVertexAttribArray( \n    static_cast<GLuint>(VertexAttribute::Position)); \n  glVertexAttribPointer( \n    static_cast<GLuint>(VertexAttribute::Position), 3, GL_FLOAT, \n    GL_FALSE, 0, 0); \n\n  glBindVertexArray(0); \n} \n\n```", "```cpp\nGL_Model::~GL_Model() { \n  glDeleteBuffers(1, &m_vertexVBO); \n  glDeleteVertexArrays(1, &m_VAO); \n} \n\n```", "```cpp\nvoid GL_Model::Draw() { \n  glBindVertexArray(m_VAO); \n  glDrawArrays(GL_TRIANGLES, 0, m_drawCount); \n  glBindVertexArray(0); \n} \n\n```", "```cpp\ninline std::string ReadFile(const std::string& l_filename) { \n  std::ifstream file(l_filename); \n  if (!file.is_open()) { return \"\"; } \n  std::string output; \n  std::string line; \n  while (std::getline(file, line)) { \n    output.append(line + \"\\n\"); \n  } \n  file.close(); \n  return output; \n} \n\n```", "```cpp\nenum class ShaderType{ Vertex, Fragment, COUNT }; \n\nclass GL_Shader { \npublic: \n  GL_Shader(const std::string& l_fileName); \n  ~GL_Shader(); \n\n  void Bind() const; \nprivate: \n  static void CheckError(GLuint l_shader, GLuint l_flag, \n    bool l_program, const std::string& l_errorMsg); \n  static GLuint BuildShader(const std::string& l_src, \n    unsigned int l_type); \n\n  GLuint m_program; \n  GLuint m_shader[static_cast<unsigned int>(ShaderType::COUNT)]; \n}; \n\n```", "```cpp\nGL_Shader::GL_Shader(const std::string& l_fileName) { \n  auto src_vert = Utils::ReadFile(l_fileName + \".vert\"); \n  auto src_frag = Utils::ReadFile(l_fileName + \".frag\"); \n  if (src_vert.empty() && src_frag.empty()) { return; } \n\n  m_program = glCreateProgram(); // Create a new program. \n  m_shader[static_cast<GLuint>(ShaderType::Vertex)] = \n    BuildShader(src_vert, GL_VERTEX_SHADER); \n  m_shader[static_cast<GLuint>(ShaderType::Fragment)] = \n    BuildShader(src_frag, GL_FRAGMENT_SHADER); \n\n  for (GLuint i = 0; \n    i < static_cast<GLuint>(ShaderType::COUNT); ++i) \n  { \n    glAttachShader(m_program, m_shader[i]); \n  } \n\n  glBindAttribLocation(m_program, \n    static_cast<GLuint>(VertexAttribute::Position), \"position\"); \n\n  glLinkProgram(m_program); \n  CheckError(m_program,GL_LINK_STATUS,true,\"Shader link error:\"); \n  glValidateProgram(m_program); \n  CheckError(m_program,GL_VALIDATE_STATUS,true,\"Invalid shader:\"); \n} \n\n```", "```cpp\nGL_Shader::~GL_Shader() { \n  for (GLuint i = 0; \n    i < static_cast<GLuint>(ShaderType::COUNT); ++i) \n  { \n    glDetachShader(m_program, m_shader[i]); \n    glDeleteShader(m_shader[i]); \n  } \n  glDeleteProgram(m_program); \n} \n\n```", "```cpp\nvoid GL_Shader::Bind() const { glUseProgram(m_program); } \n\n```", "```cpp\nvoid GL_Shader::CheckError(GLuint l_shader, GLuint l_flag, \n  bool l_program, const std::string& l_errorMsg) \n{ \n  GLint success = 0; \n  GLchar error[1024] = { 0 }; \n  if (l_program) { glGetProgramiv(l_shader, l_flag, &success); } \n  else { glGetShaderiv(l_shader, l_flag, &success); } \n\n  if (success) { return; } \n  if (l_program) { \n    glGetProgramInfoLog(l_shader, sizeof(error), nullptr, error); \n  } else { \n    glGetShaderInfoLog(l_shader, sizeof(error), nullptr, error); \n  } \n  std::cout << l_errorMsg << error << std::endl; \n} \n\n```", "```cpp\nGLuint GL_Shader::BuildShader(const std::string& l_src, \n  unsigned int l_type) \n{ \n  GLuint shaderID = glCreateShader(l_type); \n  if (!shaderID) { \n    std::cout << \"Bad shader type!\" << std::endl; return 0; \n  } \n  const GLchar* sources[1]; \n  GLint lengths[1]; \n  sources[0] = l_src.c_str(); \n  lengths[0] = l_src.length(); \n  glShaderSource(shaderID, 1, sources, lengths); \n  glCompileShader(shaderID); \n  CheckError(shaderID, GL_COMPILE_STATUS, false, \n    \"Shader compile error: \"); \n  return shaderID; \n} \n\n```", "```cpp\n#version 450\nattribute vec3 position; \n\nvoid main(){ \n   gl_Position = vec4(position, 1.0); \n} \n\n```", "```cpp\n#version 450 \n\nvoid main(){ \n   gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // White. \n} \n\n```", "```cpp\nclass Game{ \n  ... \nprivate: \n  ... \n  std::unique_ptr<GL_Shader> m_shader; \n  std::unique_ptr<GL_Model> m_model; \n  ... \n}; \n\n```", "```cpp\nGame::Game() ... { \n  ... \n  m_shader = std::make_unique<GL_Shader>( \n    Utils::GetWorkingDirectory() + \"GL/basic\"); \n\n  GL_Vertex vertices[] = { \n    //        |-----POSITION----| \n    //            X     Y    Z \n    GL_Vertex({ -0.5, -0.5, 0.5 }, // 0 \n    GL_Vertex({ -0.5, 0.5, 0.5 }, // 1 \n    GL_Vertex({ 0.5, 0.5, 0.5 }, // 2 \n  }; \n\n  m_model = std::make_unique<GL_Model>(vertices, 3); \n} \n\n```", "```cpp\nvoid Game::Render() { \n  m_window.BeginDraw(); \n  // Render here. \n  m_shader->Bind(); \n  m_model->Draw(); \n  // Finished rendering. \n  m_window.EndDraw(); \n} \n\n```", "```cpp\nclass GL_Texture { \npublic: \n  GL_Texture(const std::string& l_fileName); \n  ~GL_Texture(); \n\n  void Bind(unsigned int l_unit); \nprivate: \n  GLuint m_texture; \n}; \n\n```", "```cpp\nGL_Texture::GL_Texture(const std::string& l_fileName) { \n  int width, height, nComponents; \n  unsigned char* imageData = stbi_load(l_fileName.c_str(), \n    &width, &height, &nComponents, 4); \n  if (!imageData) { return; } \n\n  glGenTextures(1, &m_texture); \n  glBindTexture(GL_TEXTURE_2D, m_texture); \n\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); \n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); \n  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,GL_LINEAR); \n  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,GL_LINEAR); \n\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, \n    GL_RGBA, GL_UNSIGNED_BYTE, imageData); \n\n  stbi_image_free(imageData); \n} \n\n```", "```cpp\nGL_Texture::~GL_Texture() { glDeleteTextures(1, &m_texture); } \n\n```", "```cpp\nvoid GL_Texture::Bind(unsigned int l_unit) { \n  assert(l_unit >= 0 && l_unit < 32); \n  glActiveTexture(GL_TEXTURE0 + l_unit); \n  glBindTexture(GL_TEXTURE_2D, m_texture); \n} \n\n```", "```cpp\nenum class VertexAttribute{ Position, TexCoord, COUNT }; \n\nstruct GL_Vertex { \n  GL_Vertex(const glm::vec3& l_pos, \n    const glm::vec2& l_texCoord) \n    : m_pos(l_pos), m_texCoord(l_texCoord) {} \n\n  glm::vec3 m_pos; // Attribute 1\\. \n  glm::vec2 m_texCoord; // Attribute 2\\. \n  // ... \n}; \n\n```", "```cpp\nGL_Model::GL_Model(GL_Vertex* l_vertices,unsigned int l_vertCount) \n{ \n  ... \n  auto stride = sizeof(l_vertices[0]);\n auto texCoordOffset = sizeof(l_vertices[0].m_pos); \n\n  glBindBuffer(GL_ARRAY_BUFFER, m_vertexVBO); \n  glBufferData(GL_ARRAY_BUFFER, \n    l_vertCount * sizeof(l_vertices[0]), \n    l_vertices, GL_STATIC_DRAW); \n  glEnableVertexAttribArray( \n    static_cast<GLuint>(VertexAttribute::Position)); \n  glVertexAttribPointer( \n    static_cast<GLuint>(VertexAttribute::Position), 3, GL_FLOAT, \n    GL_FALSE, stride, 0); \n  glEnableVertexAttribArray( \n    static_cast<GLuint>(VertexAttribute::TexCoord)); \n  glVertexAttribPointer( \n    static_cast<GLuint>(VertexAttribute::TexCoord), 2, GL_FLOAT, \n    GL_FALSE, stride, (void*)texCoordOffset); \n  ... \n} \n\n```", "```cpp\nGL_Shader::GL_Shader(const std::string& l_fileName) { \n  ... \n  glBindAttribLocation(m_program, \n    static_cast<GLuint>(VertexAttribute::Position), \"position\"); \n  glBindAttribLocation(m_program, \n    static_cast<GLuint>(VertexAttribute::TexCoord), \n    \"texCoordVert\"); \n  ... \n} \n\n```", "```cpp\n#version 450 \n\nattribute vec3 position; \nattribute vec2 texCoordVert;\nvarying vec2 texCoord; // Pass to fragment shader. \nvoid main(){ \n  gl_Position = vec4(position, 1.0); \n  texCoord = texCoordVert; // Pass to fragment shader. \n} \n\n```", "```cpp\n#version 450 \nuniform sampler2D texture; \nvarying vec2 texCoord; // Receiving it from vertex shader. \n\nvoid main(){ \n  gl_FragColor = texture2D(texture, texCoord); \n} \n\n```", "```cpp\nGame::Game() ... { \n  ... \n  GL_Vertex vertices[] = { \n    //           |---POSITION----| |TEXTURE| \n    //            X     Y    Z      X  Y \n    GL_Vertex({ -0.5, -0.5, 0.5 }, { 0, 0 }), // 0 \n    GL_Vertex({ -0.5, 0.5, 0.5 }, { 0, 1 }), // 1 \n    GL_Vertex({ 0.5, 0.5, 0.5 }, { 1, 1 }), // 2 \n  }; \n  m_texture = std::make_unique<GL_Texture>( \n    Utils::GetWorkingDirectory() + \"GL/brick.jpg\"); \n  ... \n} \n\nvoid Game::Render() { \n  m_window.BeginDraw(); \n  // Render here. \n  m_texture->Bind(0); \n  m_shader->Bind(); \n  m_model->Draw(); \n  m_window.EndDraw(); \n} \n\n```", "```cpp\n#include <glm.hpp> \n#include <gtx/transform.hpp> \nclass GL_Transform { \npublic: \n  GL_Transform(const glm::vec3& l_pos = { 0.f, 0.f, 0.f }, \n    const glm::vec3& l_rot = { 0.f, 0.f, 0.f }, \n    const glm::vec3& l_scale = { 1.f, 1.f, 1.f }); \n\n  glm::vec3 GetPosition()const; \n  glm::vec3 GetRotation()const; \n  glm::vec3 GetScale()const; \n\n  void SetPosition(const glm::vec3& l_pos); \n  void SetRotation(const glm::vec3& l_rot); \n  void SetScale(const glm::vec3& l_scale); \n\n  glm::mat4 GetModelMatrix(); \nprivate: \n  void RecalculateMatrix(); \n  glm::vec3 m_position; \n  glm::vec3 m_rotation; \n  glm::vec3 m_scale; \n}; \n\n```", "```cpp\nGL_Transform::GL_Transform(const glm::vec3& l_pos, \n  const glm::vec3& l_rot, const glm::vec3& l_scale) \n  : m_position(l_pos), m_rotation(l_rot), m_scale(l_scale) \n{} \n\n```", "```cpp\nglm::mat4 GL_Transform::GetModelMatrix() { \n  glm::mat4 matrix_pos = glm::translate(m_position); \n  glm::mat4 matrix_scale = glm::scale(m_scale); \n  // Represent each stored rotation as a different matrix, because \n  // we store angles. \n  //          x  y  z \n  glm::mat4 matrix_rotX = glm::rotate(m_rotation.x, \n    glm::vec3(1, 0, 0)); \n  glm::mat4 matrix_rotY = glm::rotate(m_rotation.y, \n    glm::vec3(0, 1, 0)); \n  glm::mat4 matrix_rotZ = glm::rotate(m_rotation.z, \n    glm::vec3(0, 0, 1)); \n  // Create a rotation matrix. \n  // Multiply in reverse order it needs to be applied. \n  glm::mat4 matrix_rotation = matrix_rotZ*matrix_rotY*matrix_rotX; \n  // Apply transforms in reverse order they need to be applied in. \n  return matrix_pos * matrix_rotation * matrix_scale; \n} \n\n```", "```cpp\nglm::vec3 GL_Transform::GetPosition() const { return m_position; } \nglm::vec3 GL_Transform::GetRotation() const { return m_rotation; } \nglm::vec3 GL_Transform::GetScale() const { return m_scale; } \n\nvoid GL_Transform::SetPosition(const glm::vec3& l_pos) \n{ m_position = l_pos; } \nvoid GL_Transform::SetRotation(const glm::vec3& l_rot) \n{ m_rotation = l_rot; } \nvoid GL_Transform::SetScale(const glm::vec3& l_scale) \n{ m_scale = l_scale; } \n\n```", "```cpp\nenum class UniformType{ Transform, COUNT }; \n\nclass GL_Shader { \npublic: \n  ... \n  void Update(GL_Transform& l_transform); \n  ... \nprivate: \n  ... \n  GLuint m_uniform[static_cast<unsigned int>(UniformType::COUNT)]; \n}; \n\n```", "```cpp\nGL_Shader::GL_Shader(const std::string& l_fileName) { \n  ... \n  m_uniform[static_cast<unsigned int>(UniformType::Transform)] = \n    glGetUniformLocation(m_program, \"transform\"); \n} \n\n```", "```cpp\nvoid GL_Shader::Update(GL_Transform& l_transform) { \n  glm::mat4 modelMatrix = l_transform.GetModelMatrix(); \n\n  glUniformMatrix4fv(static_cast<GLint>( \n    m_uniform[static_cast<unsigned int>(UniformType::Transform)]), \n    1, GL_FALSE, &modelMatrix[0][0]); \n} \n\n```", "```cpp\n#version 450 \n\nattribute vec3 position; \nattribute vec2 texCoordVert; \nvarying vec2 texCoord; // Pass to fragment shader. \n\nuniform mat4 transform; // Passed in by the shader class. \n\nvoid main(){ \n  gl_Position = transform * vec4(position, 1.0); \n  texCoord = texCoordVert; // Pass to fragment shader. \n} \n\n```", "```cpp\nclass Game{ \n  ... \nprivate: \n  ... \n  GL_Transform m_transform; \n  ... \n}; \n\n```", "```cpp\nvoid Game::Update() { \n  ... \n  auto rotation = m_transform.GetRotation(); \n  rotation.x += 0.001f; \n  rotation.y += 0.0002f; \n  rotation.z += 0.002f; \n  if (rotation.x >= 360.f) { rotation.x = 0.f; } \n  if (rotation.y >= 360.f) { rotation.y = 0.f; } \n  if (rotation.z >= 360.f) { rotation.z = 0.f; } \n  m_transform.SetRotation(rotation); \n  m_shader->Update(m_transform); \n} \n\n```", "```cpp\nclass GL_Camera { \npublic: \n  GL_Camera(const glm::vec3& l_pos, float l_fieldOfView, \n    float l_aspectRatio, float l_frustumNear, float l_frustumFar); \n\n  glm::mat4 GetViewProjectionMatrix(); \nprivate: \n  void RecalculatePerspective(); \n\n  float m_fov; \n  float m_aspect; \n  float m_frustumNear; \n  float m_frustumFar; \n\n  glm::vec3 m_position; \n  glm::vec3 m_forwardDir; \n  glm::vec3 m_upDir; \n\n  glm::mat4 m_perspectiveMatrix; \n}; \n\n```", "```cpp\nGL_Camera::GL_Camera(const glm::vec3& l_pos, float l_fieldOfView, \n  float l_aspectRatio, float l_frustumNear, float l_frustumFar) \n  : m_position(l_pos), m_fov(l_fieldOfView), \n  m_aspect(l_aspectRatio), m_frustumNear(l_frustumNear), \n  m_frustumFar(l_frustumFar) \n{ \n  RecalculatePerspective(); \n  m_forwardDir = glm::vec3(0.f, 0.f, 1.f); \n  m_upDir = glm::vec3(0.f, 1.f, 0.f); \n} \n\n```", "```cpp\nvoid GL_Camera::RecalculatePerspective() { \n  m_perspectiveMatrix = glm::perspective(m_fov, m_aspect, \n    m_frustumNear, m_frustumFar); \n} \n\n```", "```cpp\nglm::mat4 GL_Camera::GetViewProjectionMatrix() { \n  glm::mat4 viewMatrix = glm::lookAt(m_position, \n    m_position + m_forwardDir, m_upDir); \n  return m_perspectiveMatrix * viewMatrix; \n} \n\n```", "```cpp\nvoid GL_Shader::Update(GL_Transform& l_transform, \n  GL_Camera& l_camera) \n{ \n  glm::mat4 modelMatrix = l_transform.GetModelMatrix(); \n  glm::mat4 viewProjMatrix = l_camera.GetViewProjectionMatrix();\n\n  glm::mat4 modelViewMatrix = viewProjMatrix * modelMatrix; \n  glUniformMatrix4fv(static_cast<GLint>( \n    m_uniform[static_cast<unsigned int>(UniformType::Transform)]), \n    1, GL_FALSE, &modelViewMatrix[0][0]); \n} \n\n```", "```cpp\nclass Game{ \n  ... \nprivate: \n  ... \n  std::unique_ptr<GL_Camera> m_camera; \n}; \n\n```", "```cpp\nGame::Game() ... { \n  ... \n  float aspectRatio = \n    static_cast<float>(m_window.GetWindowSize().x) / \n    static_cast<float>(m_window.GetWindowSize().y); \n  float frustum_near = 1.f; \n  float frustum_far = 100.f; \n\n  m_camera = std::make_unique<GL_Camera>( \n    glm::vec3(0.f, 0.f, -5.f), 70.f, aspectRatio, \n    frustum_near, frustum_far); \n} \n\n```", "```cpp\nvoid Game::Update() { \n  ... \n  m_shader->Update(m_transform, *m_camera); \n} \n\n```", "```cpp\nenum class GL_Direction{ Up, Down, Left, Right, Forward, Back }; \n\nclass GL_Camera { \npublic: \n  ... \n  void MoveBy(GL_Direction l_dir, float l_amount); \n  void OffsetLookBy(float l_speed, float l_x, float l_y); \n  ... \n}; \n\n```", "```cpp\nvoid GL_Camera::MoveBy(GL_Direction l_dir, float l_amount) { \n  if (l_dir == GL_Direction::Forward) { \n    m_position += m_forwardDir * l_amount; \n  } else if (l_dir == GL_Direction::Back) { \n    m_position -= m_forwardDir * l_amount; \n  } else if (l_dir == GL_Direction::Up) { \n    m_position += m_upDir * l_amount; \n  } else if (l_dir == GL_Direction::Down) { \n    m_position -= m_upDir * l_amount; \n  } ... \n} \n\n```", "```cpp\n} else if (l_dir == GL_Direction::Left) { \n  glm::vec3 cross = glm::cross(m_forwardDir, m_upDir); \n  m_position -= cross * l_amount; \n} else if (l_dir == GL_Direction::Right) { \n  glm::vec3 cross = glm::cross(m_forwardDir, m_upDir); \n  m_position += cross * l_amount; \n} ... \n\n```", "```cpp\nvoid GL_Camera::OffsetLookBy(float l_speed, float l_x, float l_y) \n{ \n  glm::vec3 rotVector = glm::cross(m_forwardDir, m_upDir); \n  glm::mat4 rot_matrix = glm::rotate(-l_x * l_speed, m_upDir) * \n               glm::rotate(-l_y * l_speed, rotVector); \n  m_forwardDir = glm::mat3(rot_matrix) * m_forwardDir; \n} \n\n```", "```cpp\nvoid Game::Update() { \n  ... \n  m_mouseDifference = sf::Mouse::getPosition( \n    *m_window.GetRenderWindow()) - m_mousePosition; \n  m_mousePosition = sf::Mouse::getPosition( \n    *m_window.GetRenderWindow()); \n\n  float moveAmount = 0.005f; \n  float rotateSpeed = 0.004f; \n\n  if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) { \n    // Forward. \n    m_camera->MoveBy(GL_Direction::Forward, moveAmount); \n  } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) { \n    // Back. \n    m_camera->MoveBy(GL_Direction::Back, moveAmount); \n  } \n\n  if (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) { \n    // Left. \n    m_camera->MoveBy(GL_Direction::Left, moveAmount); \n  } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) { \n    // Right. \n    m_camera->MoveBy(GL_Direction::Right, moveAmount); \n  } \n\n  if (sf::Keyboard::isKeyPressed(sf::Keyboard::Q)) { \n    // Up. \n    m_camera->MoveBy(GL_Direction::Up, moveAmount); \n  } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Z)) { \n    // Down. \n    m_camera->MoveBy(GL_Direction::Down, moveAmount); \n  } \n\n  if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) { \n    m_camera->OffsetLookBy(rotateSpeed, \n      static_cast<float>(m_mouseDifference.x), \n      static_cast<float>(m_mouseDifference.y)); \n  } \n  ... \n} \n\n```", "```cpp\nclass GL_Model { \n  ... \nprivate: \n  ... \n  GLuint m_indexVBO; \n  ... \n}; \n\n```", "```cpp\nGL_Model::GL_Model(GL_Vertex* l_vertices, \n  unsigned int l_vertCount, unsigned int* l_indices,\nunsigned int l_indexCount) \n{ \n  m_drawCount = l_indexCount; \n\n  glGenVertexArrays(1, &m_VAO); \n  glBindVertexArray(m_VAO); \n  glGenBuffers(1, &m_vertexVBO); \n  glGenBuffers(1, &m_indexVBO); \n  ... \n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); \n  glBufferData(GL_ELEMENT_ARRAY_BUFFER, \n    l_indexCount * (sizeof(l_indices[0])), \n    l_indices, GL_STATIC_DRAW); \n  ... \n} \n\n```", "```cpp\nGL_Model::~GL_Model() { \n  glDeleteBuffers(1, &m_vertexVBO); \n  glDeleteBuffers(1, &m_indexVBO); \n  glDeleteVertexArrays(1, &m_VAO); \n} \n\n```", "```cpp\nvoid GL_Model::Draw() { \n  glBindVertexArray(m_VAO); \n  glDrawElements(GL_TRIANGLES, m_drawCount, GL_UNSIGNED_INT, 0); \n  glBindVertexArray(0); \n} \n\n```", "```cpp\nGame::Game() ... { \n  ... \n  GL_Vertex vertices[] = { \n    //      |---POSITION----| |TEXTURE| \n    //        X    Y  Z      X, Y \n    GL_Vertex({ -0.5, -0.5, 0.5 }, { 0, 0 }), // 0 \n    GL_Vertex({ -0.5, 0.5, 0.5 }, { 0, 1 }), // 1 \n    GL_Vertex({ 0.5, 0.5, 0.5 }, { 1, 1 }), // 2 \n    GL_Vertex({ 0.5, -0.5, 0.5 }, { 1, 0 }), // 3 \n    GL_Vertex({ -0.5, -0.5, -0.5f }, { 1, 0 }), // 4 \n    GL_Vertex({ -0.5, 0.5, -0.5f }, { 1, 1 }), // 5 \n    GL_Vertex({ 0.5, 0.5, -0.5f }, { 0, 0 }), // 6 \n    GL_Vertex({ 0.5, -0.5, -0.5f }, { 0, 1 }) // 7 \n  }; \n\n  unsigned int indices[] = { \n    2, 1, 0, 0, 3, 2, // Back \n    5, 4, 0, 0, 1, 5, // Right \n    3, 7, 6, 6, 2, 3, // Left \n    6, 7, 4, 4, 5, 6, // Front \n    1, 2, 6, 6, 5, 1, // Top \n    0, 4, 7, 7, 3, 0 // Bottom \n  }; \n\n  m_model = std::make_unique<GL_Model>(vertices, 8, indices, 36); \n  ... \n} \n\n```", "```cpp\nGame::Game() ... { \n  ... \n  glEnable(GL_DEPTH_TEST); \n  ... \n} \n\n```", "```cpp\nvoid GL_Window::Create() { \n  ... \n  sf::ContextSettings settings; \n  settings.depthBits = 32; // 32 bits. \n  settings.stencilBits = 8; \n  settings.antialiasingLevel = 0; \n  settings.majorVersion = 4; \n  settings.minorVersion = 5; \n\n  m_window.create(sf::VideoMode(m_windowSize.x, \n    m_windowSize.y, 32), m_windowTitle, style, settings); \n} \n\n```", "```cpp\nvoid GL_Window::BeginDraw() { \n  glClearColor(0.f, 0.f, 0.f, 1.f); // BLACK \n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n} \n\n```", "```cpp\nGame::Game() ... { \n  ... \n  glEnable(GL_DEPTH_TEST); \n  glEnable(GL_CULL_FACE); \n  glCullFace(GL_BACK); \n  ... \n} \n\n```"]