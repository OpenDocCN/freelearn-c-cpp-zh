<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Come Play with Us! &#x2013; Multiplayer Subtleties"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Come Play with Us! – Multiplayer Subtleties</h1></div></div></div><p>Lots of great things in this world have incredibly humble beginnings. The contents of this book, from cover to cover, tell a story of a journey that began with nothing more than an interest and the will to create. Now that we're at the climax of our tale, why not end with a bang? Let's bring things back full circle and combine the framework we've developed with capabilities of networking to bring the third project of this book into new light! Let's connect our players not just through means of simple information exchange, but also through gameplay.</p><p>In this chapter, we're going to cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a game server that supports previously implemented mechanics</li><li class="listitem" style="list-style-type: disc">Exchanging entity data over a network</li><li class="listitem" style="list-style-type: disc">Transforming existing game code into a client application</li><li class="listitem" style="list-style-type: disc">Implementing player versus player combat</li><li class="listitem" style="list-style-type: disc">Hiding network latency by smoothing out entity movement</li></ul></div><p>There's a lot of code to cover, so let's get started!</p><div class="section" title="Use of copyrighted resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec124"/>Use of copyrighted resources</h1></div></div></div><p>As <a id="id625" class="indexterm"/>always, it's fair to credit the artists who made the amazing <a id="id626" class="indexterm"/>graphics and sound effects that we're going to be using for our final project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Simple small pixel hearts</em></span> by <span class="emphasis"><em>C.Nilsson</em></span> under the CC-BY-SA 3.0 license: <a class="ulink" href="http://opengameart.org/content/simple-small-pixel-hearts">http://opengameart.org/content/simple-small-pixel-hearts</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Grunt</em></span> by <span class="emphasis"><em>n3b</em></span> under the CC-BY 3.0 license: <a class="ulink" href="http://opengameart.org/content/grunt">http://opengameart.org/content/grunt</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Swishes sound pack</em></span> by <span class="emphasis"><em>artisticdude</em></span> under the CC0 license (public domain): <a class="ulink" href="http://opengameart.org/content/swishes-sound-pack">http://opengameart.org/content/swishes-sound-pack</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>3 Item sounds</em></span> by <span class="emphasis"><em>Michel Baradari</em></span> under the CC-BY 3.0 license: <a class="ulink" href="http://opengameart.org/content/3-item-sounds">http://opengameart.org/content/3-item-sounds</a></li></ul></div></div></div>
<div class="section" title="Shared code"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec125"/>Shared code</h1></div></div></div><p>Since <a id="id627" class="indexterm"/>there are many instances where code we write is going to exist on both the client and the server side, let's discuss that first, starting with the way data exchange between both sides is made.</p><p>The most important part of our information exchange is updating entities on any and all connected clients. We do this by sending specialized structures back and forth, which contains relevant entity information. From now on, these structures are going to be referred to as snapshots. Let's see how they can be implemented, by taking a look at the <code class="literal">EntitySnapshot.h</code> file:</p><div class="informalexample"><pre class="programlisting">struct EntitySnapshot{
    std::string m_type;
    sf::Vector2f m_position;
    sf::Int32 m_elevation;
    sf::Vector2f m_velocity;
    sf::Vector2f m_acceleration;
    sf::Uint8 m_direction;
    sf::Uint8 m_state;
    sf::Uint8 m_health;
    std::string m_name;
};</pre></div><p>The information we're going to be updating constantly for any given entity consists of its position and elevation, velocity, acceleration, the direction it's facing as well as the state it's in, and the entity's health and name. The type of an entity is also sent in a snapshot and used when creating the entity on the client side.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/>Tip</h3><p>In this example, the order of the data members in the <code class="literal">EntitySnapshot</code> structure may not be the most efficient. Ordering data in your structures from biggest to smallest can help reduce their size, and therefore the bandwidth overhead. Structure alignment and packing are not going to be covered here, but it's a worthy subject to look into.</p></div></div><p>Something that helps a great deal in making our code more readable is overloading the <span class="emphasis"><em>bitwise shift</em></span> operators of <code class="literal">sf::Packet</code> to support custom data types, such as <code class="literal">EntitySnapshot</code>:</p><div class="informalexample"><pre class="programlisting">sf::Packet&amp; operator &lt;&lt;(sf::Packet&amp; l_packet, 
    const EntitySnapshot&amp; l_snapshot);
sf::Packet&amp; operator &gt;&gt;(sf::Packet&amp; l_packet, 
    EntitySnapshot&amp; l_snapshot);</pre></div><p>Actual<a id="id628" class="indexterm"/> implementation of these overloads exists inside the <code class="literal">EntitySnapshot.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">sf::Packet&amp; operator &lt;&lt;(sf::Packet&amp; l_packet, 
   const EntitySnapshot&amp; l_snapshot)
{
   return l_packet &lt;&lt; l_snapshot.m_type &lt;&lt; l_snapshot.m_name 
      &lt;&lt; l_snapshot.m_position.x &lt;&lt; l_snapshot.m_position.y 
      &lt;&lt; l_snapshot.m_elevation &lt;&lt; l_snapshot.m_velocity.x 
      &lt;&lt; l_snapshot.m_velocity.y &lt;&lt; l_snapshot.m_acceleration.x
      &lt;&lt; l_snapshot.m_acceleration.y &lt;&lt; l_snapshot.m_direction 
      &lt;&lt; l_snapshot.m_state &lt;&lt; l_snapshot.m_health;
}

sf::Packet&amp; operator &gt;&gt;(sf::Packet&amp; l_packet, 
   EntitySnapshot&amp; l_snapshot)
{
   return l_packet &gt;&gt; l_snapshot.m_type &gt;&gt; l_snapshot.m_name 
      &gt;&gt; l_snapshot.m_position.x &gt;&gt; l_snapshot.m_position.y 
      &gt;&gt; l_snapshot.m_elevation &gt;&gt; l_snapshot.m_velocity.x 
      &gt;&gt; l_snapshot.m_velocity.y &gt;&gt; l_snapshot.m_acceleration.x
      &gt;&gt; l_snapshot.m_acceleration.y &gt;&gt; l_snapshot.m_direction 
      &gt;&gt; l_snapshot.m_state &gt;&gt; l_snapshot.m_health;
}</pre></div><p>Other data exchanges are going to be more specific to the situation, so we're going to cover them later on. One thing we can do to prepare for that now, however, is updating the <code class="literal">Network</code> enumeration in the <code class="literal">NetworkDefinitions.h</code> file with a new value that is going to be used as a delimiter between different types of data in a specific packet:</p><div class="informalexample"><pre class="programlisting">enum class Network{
  HighestTimestamp = 2147483647, ClientTimeout = 10000,
  ServerPort = 5600, NullID = -1, <span class="strong"><strong>PlayerUpdateDelim = -1</strong></span>
};</pre></div><p>As we're going to work with the specific packet type that uses this delimiter on both the client and the server, its place is within the shared code space.</p><div class="section" title="Additional components"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec67"/>Additional components</h2></div></div></div><p>First<a id="id629" class="indexterm"/> and foremost, entities that need to be synchronized between the server and client need to be marked and assigned a unique identifier. This is where the <code class="literal">C_Client</code> component comes in:</p><div class="informalexample"><pre class="programlisting">class C_Client : public C_Base{
public:
  C_Client(): C_Base(Component::Client),
    m_clientID((ClientID)Network::NullID){}
  void ReadIn(std::stringstream&amp; l_stream){}

  ClientID GetClientID()const{ return m_clientID; }
  void SetClientID(const ClientID&amp; l_id){ m_clientID = l_id; }
private:
  ClientID m_clientID;
};</pre></div><p>It would <a id="id630" class="indexterm"/>also be nice to support entity names, in order to be able to store player nicknames. This can be accomplished by implementing a name component:</p><div class="informalexample"><pre class="programlisting">class C_Name : public C_Base{
public:
  C_Name() : C_Base(Component::Name){}
  void ReadIn(std::stringstream&amp; l_stream){ l_stream &gt;&gt; m_name; }
  const std::string&amp; GetName()const{ return m_name; }
  void SetName(const std::string&amp; l_name){ m_name = l_name; }
private:
  std::string m_name;
};</pre></div><p>It's a common thing in games to have a small cooldown period where an entity cannot be attacked, possibly also defining how long its hurting/death animation should last. Components that allow and define such functionality would ideally have to inherit from a base class, which simplifies the process of timing such events:</p><div class="informalexample"><pre class="programlisting">class C_TimedComponentBase : public C_Base{
public:
  C_TimedComponentBase(const Component&amp; l_type)
    : C_Base(l_type), m_duration(sf::milliseconds(0)){}
  virtual ~C_TimedComponentBase(){}

  const sf::Time&amp; GetTimer()const{ return m_duration; }
  void SetTimer(const sf::Time&amp; l_time){ m_duration = l_time; }
  void AddToTimer(const sf::Time&amp; l_time){ m_duration += l_time; }

  void Reset(){ m_duration = sf::milliseconds(0); }
protected:
  sf::Time m_duration;
};</pre></div><p>One component that will make use of the base timed class will be <code class="literal">C_Health</code>:</p><div class="informalexample"><pre class="programlisting">using Health = unsigned int;

class C_Health : public C_TimedComponentBase{
public:
  C_Health(): C_TimedComponentBase(Component::Health), 
    m_hurtDuration(0), m_deathDuration(0){}
  void ReadIn(std::stringstream&amp; l_stream){
    l_stream &gt;&gt; m_maxHealth &gt;&gt; m_hurtDuration &gt;&gt; m_deathDuration;
    m_health = m_maxHealth;
  }
  Health GetHealth()const{ return m_health; }
  Health GetMaxHealth()const{ return m_maxHealth; }
  void SetHealth(const Health&amp; l_health){ m_health = l_health; }
  void ResetHealth(){ m_health = m_maxHealth; }

  sf::Uint32 GetHurtDuration(){ return m_hurtDuration; }
  sf::Uint32 GetDeathDuration(){ return m_deathDuration; }
private:
  Health m_health;
  Health m_maxHealth;
  sf::Uint32 m_hurtDuration;
  sf::Uint32 m_deathDuration;
};</pre></div><p>As you <a id="id631" class="indexterm"/>can see, it holds values for the current entity health, its maximum health value, and a few data members that hold the expected duration of being hurt and dying.</p><p>Naturally, we're going to need more entity message and event types in order to express the process of combat. The newly added types are highlighted in the following code snippet:</p><div class="informalexample"><pre class="programlisting">enum class EntityMessage{
  Move, Is_Moving, Frame_Change, State_Changed,
  Direction_Changed, Switch_State, <span class="strong"><strong>Attack,</strong></span>
<span class="strong"><strong>  Being_Attacked, Hurt, Die, Respawn, Removed_Entity</strong></span>
};
enum class EntityEvent{
  Spawned, Despawned, Colliding_X, Colliding_Y,
  Moving_Left, Moving_Right, Moving_Up, Moving_Down,
  Elevation_Change, Became_Idle, Began_Moving, <span class="strong"><strong>Began_Attacking</strong></span>
};</pre></div><p>The <code class="literal">EntityManager</code> class is also going to be shared between both sides. Some adjustments have to be made to its <code class="literal">AddEntity</code> and <code class="literal">RemoveEntity</code> methods in order to let the rest of the entity component system know when an entity has been added or removed:</p><div class="informalexample"><pre class="programlisting">int EntityManager::AddEntity(const Bitmask&amp; l_mask, int l_id){
    ...
    m_systems-&gt;EntityModified(entity,l_mask);
    m_systems-&gt;AddEvent(entity, (EventID)EntityEvent::Spawned);
    return entity;
}

bool EntityManager::RemoveEntity(const EntityId&amp; l_id){
    ...
    Message msg((MessageType)EntityMessage::Removed_Entity);
    msg.m_receiver = l_id;
    msg.m_int = l_id;
    m_systems-&gt;GetMessageHandler()-&gt;Dispatch(msg);
    ... // Removing all components.
}</pre></div><p>A lot<a id="id632" class="indexterm"/> more of the code we've written in previous chapters is actually going to need to be shared as well. Some of these classes, like the entity manager for example, have been slightly modified to serve as parents for derivatives of client and server implementations. We're not going to discuss that at length here, as the code files of this chapter should be more than helpful for familiarizing yourself with the code structure.</p></div></div>
<div class="section" title="Building our game server"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec126"/>Building our game server</h1></div></div></div><p>In <a class="link" href="ch13.html" title="Chapter 13. We Have Contact! – Networking Basics">Chapter 13</a>, <span class="emphasis"><em>We Have Contact! – Networking Basics</em></span>, we took a look at a very basic chat <a id="id633" class="indexterm"/>service that was supported by a server application and multiple clients connecting to it. Building a game server is quite similar to that. We have a piece of software that acts as a central point of interest to all its clients by doing all of the calculations and sending the results back to them in order to ensure proper and identical simulation is taking place across the board. Naturally, since we're not simply exchanging text messages, there is going to be a lot more data being sent back and forth, as well as more calculation on the server side.</p><p>First, we need to decide on a time interval value of sending entity snapshots. It has to be often enough to maintain smooth updates, but send as little information as possible to remain efficient. After some testing and tweaking, a sweet spot can be found pretty easily. For this particular project, let's say that an entity snapshot will be sent once every 100 milliseconds, which will be defined in <code class="literal">NetSettings.h</code>:</p><div class="informalexample"><pre class="programlisting">#define SNAPSHOT_INTERVAL 100</pre></div><p>Sending 10 snapshots a second is enough to keep the clients happy and the server maintaining a <a id="id634" class="indexterm"/>relatively low bandwidth.</p><div class="section" title="Additions to the entity component system"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec68"/>Additions to the entity component system</h2></div></div></div><p>The <a id="id635" class="indexterm"/>majority of combat logic is going to take place on the server side. In order to support entities attacking one another, we need a new component to work with the <code class="literal">C_Attacker</code>:</p><div class="informalexample"><pre class="programlisting">class C_Attacker : public C_TimedComponentBase{
public:
  C_Attacker(): C_TimedComponentBase(Component::Attacker), 
    m_attacked(false), m_knockback(0.f), m_attackDuration(0){}
  void ReadIn(std::stringstream&amp; l_stream){
    l_stream &gt;&gt; m_offset.x &gt;&gt; m_offset.y 
      &gt;&gt; m_attackArea.width &gt;&gt; m_attackArea.height 
      &gt;&gt; m_knockback &gt;&gt; m_attackDuration;
  }

  void SetAreaPosition(const sf::Vector2f&amp; l_pos){
    m_attackArea.left = l_pos.x;
    m_attackArea.top = l_pos.y;
  }

  const sf::FloatRect&amp; GetAreaOfAttack(){ return m_attackArea; }
  const sf::Vector2f&amp; GetOffset(){ return m_offset; }
  bool HasAttacked(){ return m_attacked; }
  void SetAttacked(bool l_attacked){ m_attacked = l_attacked; }
  float GetKnockback(){ return m_knockback; }
  sf::Uint32 GetAttackDuration(){ return m_attackDuration; }
private:
  sf::FloatRect m_attackArea;
  sf::Vector2f m_offset;
  bool m_attacked;
  float m_knockback;
  sf::Uint32 m_attackDuration;
};</pre></div><p>The attacker component holds information about the size and location of the entity's attack area and possible offset, a flag to check if the entity has hit something while attacking, the force of knockback that is to be applied to another entity being attacked by this one, and the duration of the attack.</p><div class="section" title="Implementing combat"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec16"/>Implementing combat</h3></div></div></div><p>Entity-on-entity combat is going to be a fairly simple addition, since we already have a nice <a id="id636" class="indexterm"/>collision system in place. It only requires a few additional lines of code inside the <code class="literal">EntityCollisions</code> method:</p><div class="informalexample"><pre class="programlisting">void S_Collision::EntityCollisions(){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for (auto itr = m_entities.begin();
    itr != m_entities.end(); ++itr)
  {
    for (auto itr2 = std::next(itr);
      itr2 != m_entities.end(); ++itr2)
    {
      ...
      C_Attacker* attacker1 = entities-&gt;
        GetComponent&lt;C_Attacker&gt;(*itr, Component::Attacker);
      C_Attacker* attacker2 = entities-&gt;
        GetComponent&lt;C_Attacker&gt;(*itr2, Component::Attacker);
      if (!attacker1 &amp;&amp; !attacker2){ continue; }
      Message msg((MessageType)EntityMessage::Being_Attacked);
      if (attacker1){
        if (attacker1-&gt;GetAreaOfAttack().intersects(
          collidable2-&gt;GetCollidable()))
        {
          // Attacker-on-entity collision!
          msg.m_receiver = *itr2;
          msg.m_sender = *itr;
          m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
        }
      }
      if (attacker2){
        if (attacker2-&gt;GetAreaOfAttack().intersects(
          collidable1-&gt;GetCollidable()))
        {
          // Attacker-on-entity collision!
          msg.m_receiver = *itr;
          msg.m_sender = *itr2;
          m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
        }
      }
    }
  }
}</pre></div><p>First, both entities being checked get their attacker components fetched. If neither one of them has one, the iteration is skipped. Otherwise, a new message of type <code class="literal">Being_Attacked</code> is constructed. If the attacking entity's area of attach actually intersects the bounding box of another entity, this message is filled in with receiver and sender information<a id="id637" class="indexterm"/> and sent out.</p><p>In order to process and react properly to these collisions, as well as update all the entities that have potential to be in combat, we're going to need a new system: <code class="literal">S_Combat</code>! It doesn't have any additional methods other than the ones required to be implemented by the base system class, so there's really no need for us to examine its header. Let's take a look at its constructor and destructor instead:</p><div class="informalexample"><pre class="programlisting">S_Combat::S_Combat(SystemManager* l_systemMgr)
  : S_Base(System::Combat, l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::Movable);
  req.TurnOnBit((unsigned int)Component::State);
  req.TurnOnBit((unsigned int)Component::Health);
  m_requiredComponents.push_back(req);
  req.ClearBit((unsigned int)Component::Health);
  req.TurnOnBit((unsigned int)Component::Attacker);
  m_requiredComponents.push_back(req);

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Being_Attacked, this);
}</pre></div><p>This system will hold any entity that has position, is a movable entity with a state, and has a health component or attack component or both. It also subscribes to the <code class="literal">Being_Attacked</code> message in order to process attack area collisions.</p><p>Naturally, the same attack area cannot be positioned identically for all four directions that an entity is facing. Consider the following example:</p><div class="mediaobject"><img src="graphics/B04284_14_01.jpg" alt="Implementing combat"/></div><p>Repositioning the attack area for each entity based on its current direction is done inside the <code class="literal">Update</code> method of this system:</p><div class="informalexample"><pre class="programlisting">void S_Combat::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for (auto &amp;entity : m_entities){
    C_Attacker* attack = entities-&gt;
      GetComponent&lt;C_Attacker&gt;(entity, Component::Attacker);
    if (!attack){ continue; }
    sf::Vector2f offset = attack-&gt;GetOffset();
    sf::FloatRect AoA = attack-&gt;GetAreaOfAttack();
    Direction dir = entities-&gt;GetComponent&lt;C_Movable&gt;
      (entity, Component::Movable)-&gt;GetDirection();
    sf::Vector2f position = entities-&gt;GetComponent&lt;C_Position&gt;
      (entity, Component::Position)-&gt;GetPosition();
    if (dir == Direction::Left){ offset.x -= AoA.width / 2; }
    else if (dir == Direction::Right){offset.x += AoA.width / 2; }
    else if (dir == Direction::Up){offset.y -= AoA.height / 2; }
    else if (dir == Direction::Down){offset.y += AoA.height / 2; }
    position -= sf::Vector2f(AoA.width / 2, AoA.height / 2);
    attack-&gt;SetAreaPosition(position + offset);
  }
}</pre></div><p>If the <a id="id638" class="indexterm"/>current entity being checked has no <code class="literal">C_Attacker</code> component, the iteration is simply skipped. Otherwise, both the entity's area of attack and its offset are obtained, in addition to its current direction and position. In order to first center the attack area, half of its width and height is subtracted from the entity's position. The offset is then adjusted based on the direction the entity is facing, and the area of attack is moved to the latest position with it applied.</p><p>Let's take a look at a possible response to the message our collision system sends out:</p><div class="informalexample"><pre class="programlisting">void S_Combat::Notify(const Message&amp; l_message){
  if (!HasEntity(l_message.m_receiver) ||
    !HasEntity(l_message.m_sender))
  {
    return;
  }
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  EntityMessage m = (EntityMessage)l_message.m_type;
  switch (m){
  case EntityMessage::Being_Attacked:
    C_Health* victim = entities-&gt;GetComponent&lt;C_Health&gt;
      (l_message.m_receiver, Component::Health);
    C_Attacker* attacker = entities-&gt;GetComponent&lt;C_Attacker&gt;
      (l_message.m_sender, Component::Attacker);
    if (!victim || !attacker){ return; }
    S_State* StateSystem = m_systemManager-&gt;
      GetSystem&lt;S_State&gt;(System::State);
    if (StateSystem-&gt;GetState(l_message.m_sender) !=
      EntityState::Attacking)
    {
      return;
    }
    if (attacker-&gt;HasAttacked()){ return; }
    // Begin attacking.
    victim-&gt;SetHealth((victim-&gt;GetHealth() &gt; 1 ?
      victim-&gt;GetHealth() - 1 : 0));
    attacker-&gt;SetAttacked(true);
    if (!victim-&gt;GetHealth()){
      StateSystem-&gt;ChangeState(l_message.m_receiver,
        EntityState::Dying, true);
    } else {
      Message msg((MessageType)EntityMessage::Hurt);
      msg.m_receiver = l_message.m_receiver;
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
    }

    // Knockback.
    Direction attackerDirection =entities-&gt;GetComponent&lt;C_Movable&gt;
      (l_message.m_sender, Component::Movable)-&gt;GetDirection();
    float Knockback = attacker-&gt;GetKnockback();
    sf::Vector2f KnockbackVelocity;
    if (attackerDirection == Direction::Left ||
      attackerDirection == Direction::Up)
    {
      Knockback = -Knockback;
    }
    if (attackerDirection == Direction::Left ||
      attackerDirection == Direction::Right)
    {
      KnockbackVelocity.x = Knockback;
    }
    else{ KnockbackVelocity.y = Knockback; }
    entities-&gt;GetComponent&lt;C_Movable&gt;
      (l_message.m_receiver, Component::Movable)-&gt;
      SetVelocity(KnockbackVelocity);
    break;
  }
}</pre></div><p>First, we check if the combat system has both the sender and receiver of this message. If that's the case, the <code class="literal">Being_Attacked</code> message is processed by first obtaining the health component of the entity being attacked, as well as the attacker component of the aggressor. The<a id="id639" class="indexterm"/> state of the attacking entity is then checked. If it is not currently attacking or if the entity has already attacked something else, the method is terminated by returning. Otherwise, the attack is initiated by first reducing the victim's health by <span class="emphasis"><em>1</em></span>. The attacker is then flagged for having already attacked an entity. If the victim's health is at value 0, its state is changed to <code class="literal">Dying</code>. Otherwise, a <code class="literal">Hurt</code> message is dispatched.</p><p>The remaining few lines of code deal with the victim entity being knocked back slightly, as it's being attacked. Both the attacker's direction and knockback force are obtained and a <code class="literal">sf::Vector2f</code> variable, signifying the applied force is created. If the attacker is facing either left or up, the knockback value is inverted. Also, if the attacking entity is facing either left or right, the knockback is applied on the <span class="emphasis"><em>X</em></span> axis. Otherwise, the <span class="emphasis"><em>Y</em></span> axis is used. Then, the force is simply applied as velocity through the victim's <code class="literal">C_Movable</code> component.</p></div></div><div class="section" title="Server action timing"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec69"/>Server action timing</h2></div></div></div><p>One major<a id="id640" class="indexterm"/> difference between running the same code on a <a id="id641" class="indexterm"/>server and a client is how certain actions and events are timed. Since we have no animations happening, there is no way to simply check when the last frame was reached and terminate an attack or death, for example. This is where manually setting certain time values comes in. For this, we're going to need the <code class="literal">S_Timers</code> system. Since it also doesn't have any additional methods other than the required ones, the class definition is not necessary. </p><p>Let's start by taking a look at the constructor and destructor of this system:</p><div class="informalexample"><pre class="programlisting">S_Timers::S_Timers(SystemManager* l_systemMgr)
  : S_Base(System::Timers, l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::State);
  req.TurnOnBit((unsigned int)Component::Attacker);
  m_requiredComponents.push_back(req);
  req.ClearBit((unsigned int)Component::Attacker);
  req.TurnOnBit((unsigned int)Component::Health);
  m_requiredComponents.push_back(req);
}</pre></div><p>Once again, we simply subscribe to the state component as well as the attacker component, health component, or both. Nothing interesting happens here, so let's move on to the <code class="literal">Update</code> method that makes timing on the server side possible:</p><div class="informalexample"><pre class="programlisting">void S_Timers::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for (auto &amp;entity : m_entities){
    EntityState state = entities-&gt;GetComponent&lt;C_State&gt;
      (entity, Component::State)-&gt;GetState();
    if (state == EntityState::Attacking){
      C_Attacker* attack = entities-&gt;GetComponent&lt;C_Attacker&gt;
        (entity, Component::Attacker);
      attack-&gt;AddToTimer(sf::seconds(l_dT));
      if (attack-&gt;GetTimer().asMilliseconds() &lt;
        attack-&gt;GetAttackDuration())
      {
        continue;
      }
      attack-&gt;Reset();
      attack-&gt;SetAttacked(false);
    } else if (state == EntityState::Hurt ||
      state == EntityState::Dying)
    {
      C_Health* health = entities-&gt;
        GetComponent&lt;C_Health&gt;(entity, Component::Health);
      health-&gt;AddToTimer(sf::seconds(l_dT));
      if ((state == EntityState::Hurt &amp;&amp; 
        health-&gt;GetTimer().asMilliseconds() &lt;
        health-&gt;GetHurtDuration()) ||
        (state == EntityState::Dying &amp;&amp; 
        health-&gt;GetTimer().asMilliseconds() &lt;
        health-&gt;GetDeathDuration()))
      {
        continue;
      }

      health-&gt;Reset();
      if (state == EntityState::Dying){
        Message msg((MessageType)EntityMessage::Respawn);
        msg.m_receiver = entity;
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
        health-&gt;ResetHealth();
      }
    } else { continue; }
    m_systemManager-&gt;GetSystem&lt;S_State&gt;(System::State)-&gt;
      ChangeState(entity, EntityState::Idle, true);
  }
}</pre></div><p>In this<a id="id642" class="indexterm"/> system, both the attacker and health components<a id="id643" class="indexterm"/> are checked to see whether they have reached specific time values that are provided in the entity file. If the entity is in an attacking state, the attacker component is obtained and the elapsed time is added to it. If the attack duration is passed, the timer is reset and the "attacked" flag is set back to false, making another attack possible.</p><p>If the<a id="id644" class="indexterm"/> entity is in either the hurting or dying state, the respectful time <a id="id645" class="indexterm"/>values are checked against predetermined durations and the timer is reset once again. If the entity is actually in a dying state, a <code class="literal">Respawn</code> message is sent out as well, in order to reset its animation, health and move the entity to a specific location where it "respawns".</p></div><div class="section" title="Server network system"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec70"/>Server network system</h2></div></div></div><p>Handling <a id="id646" class="indexterm"/>entity networking on the server side can be made <a id="id647" class="indexterm"/>a lot easier by simply building a dedicated system that would already have access to entity data by design. This is where the server network system comes in.</p><p>Let's start with how entities are going to be controlled by players. In previous chapters, we simply used messaging to move entities around on the client side. Obviously, due to network delays and bandwidth restrictions, it would be problematic to simply send out a bunch of messages whenever a client moves. It's much more efficient to simply keep track of a player's input state, as this simple structure demonstrates:</p><div class="informalexample"><pre class="programlisting">struct PlayerInput{
    int m_movedX;
    int m_movedY;
    bool m_attacking;
    PlayerInput() : m_movedX(0), m_movedY(0), m_attacking(false){}
};

using PlayerInputContainer = std::unordered_map&lt;EntityId, 
  PlayerInput&gt;;</pre></div><p>The first two data members will contain the amount of times a player has been moved along either axis. On the client side, we're going to be sending input states to the server at a specific interval, which means we have the benefit of combining messages into neat packets, as well as process out redundant movement, such as moving left and right by the same amount. Additionally, clients are also going to be sending their attacking states. All of this information will be held in a container, which tethers it to a specific entity ID.</p><p>Now, let's take a look at the header file of the network system we're going to implement:</p><div class="informalexample"><pre class="programlisting">class S_Network : public S_Base{
public:
  S_Network(SystemManager* l_systemMgr);
  ~S_Network();

  void Update(float l_dT);
  void HandleEvent(const EntityId&amp; l_entity,
    const EntityEvent&amp; l_event);
  void Notify(const Message&amp; l_message);

  bool RegisterClientID(const EntityId&amp; l_entity,
    const ClientID&amp; l_client);
  void RegisterServer(Server* l_server);
  ClientID GetClientID(const EntityId&amp; l_entity);
  EntityId GetEntityID(const ClientID&amp; l_client);

  void CreateSnapshot(sf::Packet&amp; l_packet);
  void UpdatePlayer(sf::Packet&amp; l_packet, const ClientID&amp; l_cid);
private:
  PlayerInputContainer m_playerInput;
  Server* m_server;
};</pre></div><p>As usual, we<a id="id648" class="indexterm"/> have the required methods implemented, as well as a few additional ones. Since we're going to link behavior between <a id="id649" class="indexterm"/>clients and entities, we have a few methods that help us register and obtain this relationship information. On top of that, a few helper methods exist for creating snapshots of entity states and updating a specific client's information from an incoming packet.</p><div class="section" title="Implementing the network system"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec17"/>Implementing the network system</h3></div></div></div><p>Let's<a id="id650" class="indexterm"/> start with the constructor and destructor of the network system:</p><div class="informalexample"><pre class="programlisting">S_Network::S_Network(SystemManager* l_systemMgr)
  : S_Base(System::Network, l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Client);
  m_requiredComponents.push_back(req);

  MessageHandler* messageHandler = 
    m_systemManager-&gt;GetMessageHandler();
  messageHandler-&gt;Subscribe(EntityMessage::Removed_Entity, this);
  messageHandler-&gt;Subscribe(EntityMessage::Hurt, this);
  messageHandler-&gt;Subscribe(EntityMessage::Respawn, this);
}</pre></div><p>This particular system is only going to require a single component: <code class="literal">C_Client</code>. It also subscribes to entity removal, hurt, and respawn messages.</p><p>Next, the <code class="literal">Update</code> method:</p><div class="informalexample"><pre class="programlisting">void S_Network::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for (auto &amp;entity : m_entities){
    auto&amp; player = m_playerInput[entity];
    if (player.m_movedX || player.m_movedY){
      if (player.m_movedX){
        Message msg((MessageType)EntityMessage::Move);
        msg.m_receiver = entity;
        if (player.m_movedX &gt; 0){msg.m_int=(int)Direction::Right;}
        else { msg.m_int = (int)Direction::Left; }
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
      }

      if (player.m_movedY){
        Message msg((MessageType)EntityMessage::Move);
        msg.m_receiver = entity;
        if (player.m_movedY &gt; 0){msg.m_int=(int)Direction::Down;}
        else { msg.m_int = (int)Direction::Up; }
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
      }
    }
    if (player.m_attacking){
      Message msg((MessageType)EntityMessage::Attack);
      msg.m_receiver = entity;
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
    }
  }
}</pre></div><p>This is<a id="id651" class="indexterm"/> where we process the current control state of a client and apply it to the entity. Relevant messages are constructed and sent out, based on the state of a client's input.</p><p>Next, let's deal with those three message types that this system is subscribed to:</p><div class="informalexample"><pre class="programlisting">void S_Network::Notify(const Message&amp; l_message){
  if (!HasEntity(l_message.m_receiver)){ return; }
  EntityMessage m = EntityMessage(l_message.m_type);
  if (m == EntityMessage::Removed_Entity){
    m_playerInput.erase(l_message.m_receiver);
    return;
  }
  if (m == EntityMessage::Hurt){
    sf::Packet packet;
    StampPacket(PacketType::Hurt, packet);
    packet &lt;&lt; l_message.m_receiver;
    m_server-&gt;Broadcast(packet);
    return;
  }
  if (m == EntityMessage::Respawn){
    C_Position* position = m_systemManager-&gt;GetEntityManager()-&gt;
      GetComponent&lt;C_Position&gt;(l_message.m_receiver,
      Component::Position);
    if (!position){ return; }
    position-&gt;SetPosition(64.f, 64.f);
    position-&gt;SetElevation(1);
  }
}</pre></div><p>First, if the<a id="id652" class="indexterm"/> entity is being removed, the player input information of the corresponding client in control of that entity gets erased. If a message about an entity getting hurt is received, a hurt packet is constructed and sent to all clients to notify them of an entity taking damage. Lastly, an entity respawn message is handled by resetting its position and elevation to some pre-defined values. These coordinates can easily be randomized or read in from the map file, but for demonstration purposes this works just fine.</p><p>When a client connects to our server and an entity for it is created, we need to have a method that allows us to express that relationship by binding the two values together, as shown here:</p><div class="informalexample"><pre class="programlisting">bool S_Network::RegisterClientID(const EntityId&amp; l_entity,
  const ClientID&amp; l_client)
   {
  if (!HasEntity(l_entity)){ return false; }
  m_systemManager-&gt;GetEntityManager()-&gt;GetComponent&lt;C_Client&gt;
    (l_entity, Component::Client)-&gt;SetClientID(l_client);
  return true;
}</pre></div><p>Since we're going to be storing the client ID inside the client component, it's obtained through the entity manager and used in exactly that manner.</p><p>The network class is also going to need access to an instance of the <code class="literal">Server</code> class, hence the following method:</p><div class="informalexample"><pre class="programlisting">void S_Network::RegisterServer(Server* l_server){
    m_server = l_server;
}</pre></div><p>Next, a few methods of convenience for obtaining client and entity IDs:</p><div class="informalexample"><pre class="programlisting">ClientID S_Network::GetClientID(const EntityId&amp; l_entity){
  if (!HasEntity(l_entity)){ return (ClientID)Network::NullID; }
  return m_systemManager-&gt;GetEntityManager()-&gt;
    GetComponent&lt;C_Client&gt;(l_entity, Component::Client)-&gt;
    GetClientID();
}
EntityId S_Network::GetEntityID(const ClientID&amp; l_client){
  EntityManager* e = m_systemManager-&gt;GetEntityManager();
  auto entity = std::find_if(m_entities.begin(), m_entities.end(),
    [&amp;e, &amp;l_client](EntityId&amp; id){
      return e-&gt;GetComponent&lt;C_Client&gt;
        (id, Component::Client)-&gt;GetClientID() == l_client;
  });
  return(entity != m_entities.end() ?
    *entity : (EntityId)Network::NullID);
}</pre></div><p>Snapshot <a id="id653" class="indexterm"/>creation itself also deserves its own method:</p><div class="informalexample"><pre class="programlisting">void S_Network::CreateSnapshot(sf::Packet&amp; l_packet){
  <span class="strong"><strong>sf::Lock lock(m_server-&gt;GetMutex());</strong></span>
  ServerEntityManager* e =
    (ServerEntityManager*)m_systemManager-&gt;GetEntityManager();
  StampPacket(PacketType::Snapshot, l_packet);
  l_packet &lt;&lt; sf::Int32(e-&gt;GetEntityCount());
  if (e-&gt;GetEntityCount()){
    e-&gt;DumpEntityInfo(l_packet);
  }
}</pre></div><p>Because we're accessing entity information that could be changed, the server mutex has to be locked before we access it. After assigning a snapshot type to the packet provided as an argument, we write the number of entities into it as well. If the number is above zero, a <code class="literal">DumpEntityInfo</code> method is invoked. This method is defined within our <code class="literal">ServerEntityManager</code> class and will be covered shortly.</p><p>Lastly, let's handle the incoming player update packets:</p><div class="informalexample"><pre class="programlisting">void S_Network::UpdatePlayer(sf::Packet&amp; l_packet,
  const ClientID&amp; l_cid)
{
  <span class="strong"><strong>sf::Lock lock(m_server-&gt;GetMutex());</strong></span>
  EntityId eid = GetEntityID(l_cid);
  if (eid == -1){ return; }
  if (!HasEntity(eid)){ return; }
  sf::Int8 entity_message;
  m_playerInput[eid].m_attacking = false;
  while (l_packet &gt;&gt; entity_message){
    switch (entity_message){
    case sf::Int8(EntityMessage::Move):
    {
      sf::Int32 x = 0, y = 0;
      l_packet &gt;&gt; x &gt;&gt; y;
      m_playerInput[eid].m_movedX = x;
      m_playerInput[eid].m_movedY = y;
      break;
    }
    case sf::Int8(EntityMessage::Attack):
    {
      sf::Int8 attackState;
      l_packet &gt;&gt; attackState;
      if (attackState){ m_playerInput[eid].m_attacking = true; }
      break;
    }
    }
    sf::Int8 delim = 0;
    if (!(l_packet &gt;&gt; delim) || delim !=
      (sf::Int8)Network::PlayerUpdateDelim)
    {
      std::cout &lt;&lt; "Faulty update!" &lt;&lt; std::endl; 
      break;
    }
  }
}</pre></div><p>Before <a id="id654" class="indexterm"/>anything can be done, we must make sure that the server mutex is locked and the client sending this packet has a valid entity attached to it. This is done by obtaining the entity ID and checking its validity in the next two lines. A local variable named <code class="literal">entity_message</code> is then created in order to hold the message type that the client is going to be sending to us. The attack state of the entity is then set to <code class="literal">false</code> by default and iterating over the packet's information begins.</p><p>Encountering a <code class="literal">Move</code> message is dealt with by extracting the X and Y values from the packet and overwriting our player movement information for the given entity with them. The <code class="literal">Attack</code> message has one less value to worry about. The player's <code class="literal">m_attacking</code> flag is set to <code class="literal">true</code> if the incoming player state contains anything else but zero.</p></div></div><div class="section" title="Server entity and system management"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec71"/>Server entity and system management</h2></div></div></div><p>The <a id="id655" class="indexterm"/>components and systems supported on the server side are obviously <a id="id656" class="indexterm"/>going to differ from those on the client side. On top of that, custom methods for both ends help out a great deal by allowing the base class to remain unmodified, while the derivatives can deal with side-specific logic. Let's take a look at our simple extension to the <code class="literal">EntityManager</code> class that runs on the server side:</p><div class="informalexample"><pre class="programlisting">ServerEntityManager::ServerEntityManager(SystemManager* l_sysMgr)
  : EntityManager(l_sysMgr)
{
  AddComponentType&lt;C_Position&gt;(Component::Position);
  AddComponentType&lt;C_State&gt;(Component::State);
  AddComponentType&lt;C_Movable&gt;(Component::Movable);
  AddComponentType&lt;C_Controller&gt;(Component::Controller);
  AddComponentType&lt;C_Collidable&gt;(Component::Collidable);
  AddComponentType&lt;C_Client&gt;(Component::Client);
  AddComponentType&lt;C_Health&gt;(Component::Health);
  AddComponentType&lt;C_Name&gt;(Component::Name);
  AddComponentType&lt;C_Attacker&gt;(Component::Attacker);
}</pre></div><p>We're obviously not going to need any graphics or sound related component types here. It's the client's job to deal with those.</p><p>This class will also be useful when creating entity snapshots. All of the entity information is dumped into a provided instance of <code class="literal">sf::Packet</code> by using this method:</p><div class="informalexample"><pre class="programlisting">void ServerEntityManager::DumpEntityInfo(sf::Packet&amp; l_packet){
  for (auto &amp;entity : m_entities){
    l_packet &lt;&lt; sf::Int32(entity.first);
    EntitySnapshot snapshot;
    snapshot.m_type = entity.second.m_type;
    const auto&amp; mask = entity.second.m_bitmask;
    if (mask.GetBit((unsigned int)Component::Position)){
      C_Position* p = GetComponent&lt;C_Position&gt;(entity.first,
        Component::Position);
      snapshot.m_position = p-&gt;GetPosition();
      snapshot.m_elevation = p-&gt;GetElevation();
    }
    if (mask.GetBit((unsigned int)Component::Movable)){
      C_Movable* m = GetComponent&lt;C_Movable&gt;(entity.first,
        Component::Movable);
      snapshot.m_velocity = m-&gt;GetVelocity();
      snapshot.m_acceleration = m-&gt;GetAcceleration();
      snapshot.m_direction = sf::Uint8(m-&gt;GetDirection());
    }
    if (mask.GetBit((unsigned int)Component::State)){
      C_State* s = GetComponent&lt;C_State&gt;(entity.first,
        Component::State);
      snapshot.m_state = sf::Uint8(s-&gt;GetState());
    }
    if (mask.GetBit((unsigned int)Component::Health)){
      C_Health* h = GetComponent&lt;C_Health&gt;(entity.first,
        Component::Health);
      snapshot.m_health = h-&gt;GetHealth();
    }
    if (mask.GetBit((unsigned int)Component::Name)){
      C_Name* n = GetComponent&lt;C_Name&gt;(entity.first,
        Component::Name);
      snapshot.m_name = n-&gt;GetName();
    }
    l_packet &lt;&lt; snapshot;
  }
}</pre></div><p>The entity <a id="id657" class="indexterm"/>ID is written into the packet instance first. An <code class="literal">EntitySnapshot</code> variable is created afterwards, and it is filled with relevant component information, provided<a id="id658" class="indexterm"/> these components exist at all. Once that's done, the snapshot instance is written to the packet, which is made incredibly easy thanks to its overloaded <code class="literal">&lt;&lt;</code> and <code class="literal">&gt;&gt;</code> operators.</p><p>For system management on the server side, we only need to handle the systems that are added:</p><div class="informalexample"><pre class="programlisting">ServerSystemManager::ServerSystemManager(){
  AddSystem&lt;S_Network&gt;(System::Network);
  AddSystem&lt;S_State&gt;(System::State);
  AddSystem&lt;S_Control&gt;(System::Control);
  AddSystem&lt;S_Movement&gt;(System::Movement);
  AddSystem&lt;S_Timers&gt;(System::Timers);
  AddSystem&lt;S_Collision&gt;(System::Collision);
  AddSystem&lt;S_Combat&gt;(System::Combat);
}</pre></div><p>Similar to what we did for components, we simply exclude anything graphical or sound related.</p></div><div class="section" title="Main server class"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec72"/>Main server class</h2></div></div></div><p>Similar<a id="id659" class="indexterm"/> to the client side's <code class="literal">Game</code> class, a supervisor object is going to be needed on the server side as well. We're going to be keeping instances of the game map, entity, and server managers, and the <code class="literal">Server</code> class itself in a new class, simply called <code class="literal">World</code>. Let's start by taking a look at the header file:</p><div class="informalexample"><pre class="programlisting">class World{
public:
    World();
    ~World();

    void Update(const sf::Time&amp; l_time);
    void HandlePacket(sf::IpAddress&amp; l_ip, 
      const PortNumber&amp; l_port, const PacketID&amp; l_id, 
     sf::Packet&amp; l_packet, Server* l_server);
    void ClientLeave(const ClientID&amp; l_client);
    void CommandLine();

    bool IsRunning();
private:
    sf::Time m_tpsTime;
    sf::Time m_serverTime;
    sf::Time m_snapshotTimer;
    sf::Thread m_commandThread;
    Server m_server;
    ServerSystemManager m_systems;
    ServerEntityManager m_entities;
    bool m_running;

    Map m_map;
    unsigned int m_tick;
    unsigned int m_tps;
};</pre></div><p>Similar<a id="id660" class="indexterm"/> to <code class="literal">Game</code>, it has an <code class="literal">Update</code> method where all of the time-related magic is going to happen. It also has methods for handling custom packet types, handling a client leaving, and processing command-line input.</p><p>Data member wise, we're looking at a few <code class="literal">sf::Time</code> instances for keeping track of the current server time, as well as delivery time for snapshots. A <code class="literal">sf::Thread</code> instance for the command line is also quite handy to have around.</p><p>Last but not least, the <code class="literal">m_tpsTime</code>, <code class="literal">m_tick</code> and <code class="literal">m_tps</code> data members exist for the simple convenience of measuring the update rate on the server. The number of updates per second, also known as ticks, is quite useful for tracking down and resolving performance issues.</p></div><div class="section" title="Implementing the world class"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec73"/>Implementing the world class</h2></div></div></div><p>Let's kick <a id="id661" class="indexterm"/>this class into gear, starting with the constructor and destructor:</p><div class="informalexample"><pre class="programlisting">World::World(): m_server(&amp;World::HandlePacket, this),
  m_commandThread(&amp;World::CommandLine, this), m_entities(nullptr),
  m_map(&amp;m_entities), m_tick(0), m_tps(0), m_running(false)
{
  if (!m_server.Start()){ return; }
  m_running = true;
  m_systems.SetEntityManager(&amp;m_entities);
  m_entities.SetSystemManager(&amp;m_systems);
  m_map.LoadMap("media/Maps/map1.map");
  m_systems.GetSystem&lt;S_Collision&gt;(System::Collision)-&gt;
    SetMap(&amp;m_map);
  m_systems.GetSystem&lt;S_Movement&gt;(System::Movement)-&gt;
    SetMap(&amp;m_map);
  m_systems.GetSystem&lt;S_Network&gt;(System::Network)-&gt;
    RegisterServer(&amp;m_server);
  m_server.BindTimeoutHandler(&amp;World::ClientLeave, this);
  m_commandThread.launch();
}

World::~World(){ m_entities.SetSystemManager(nullptr); }</pre></div><p>Our <code class="literal">Server</code> instance is set up by providing a valid packet handler in the initializer list, where the command thread is also set up. In the actual body of the constructor, we first attempt to start the server and catch a possible failure in an <code class="literal">if</code> statement. Upon a successful start, the <code class="literal">m_running</code> flag is set to <code class="literal">true</code> and both the entity manager and system manager are provided with pointers to each other. The game map is then loaded and relevant systems are provided with its instance. After our network system is made available with an instance of <code class="literal">Server</code>, the <code class="literal">ClientLeave</code> method is fed in as the timeout handler and the command line thread is launched.</p><p>Upon destruction of the <code class="literal">World</code> class, all we really have to worry about is taking away the entity manager's access to the system manager.</p><p>Next, let's keep the action rolling by updating everything:</p><div class="informalexample"><pre class="programlisting">void World::Update(const sf::Time&amp; l_time){
  if (!m_server.IsRunning()){ m_running = false; return; }
  m_serverTime += l_time;
  m_snapshotTimer += l_time;
  m_tpsTime += l_time;
  m_server.Update(l_time);
  <span class="strong"><strong>m_server.GetMutex().lock();</strong></span>
  m_systems.Update(l_time.asSeconds());
  <span class="strong"><strong>m_server.GetMutex().unlock();</strong></span>
  if (m_snapshotTimer.asMilliseconds() &gt;= SNAPSHOT_INTERVAL){
    sf::Packet snapshot;
    m_systems.GetSystem&lt;S_Network&gt;(System::Network)-&gt;
      CreateSnapshot(snapshot);
    m_server.Broadcast(snapshot);
    m_snapshotTimer = sf::milliseconds(0);
  }
  if (m_tpsTime &gt;= sf::milliseconds(1000)){
    m_tps = m_tick;
    m_tick = 0;
    m_tpsTime = sf::milliseconds(0);
  } else {
    ++m_tick;
  }
}</pre></div><p>The server<a id="id662" class="indexterm"/> instance is first checked for having stopped. If that's the case, the world class itself is stopped and the <code class="literal">Update</code> method is returned from. Otherwise, all of our time values are updated alongside the server class. The system manager's <code class="literal">Update</code> method is then invoked in order to update all of the entity information. The server mutex has to be locked while that happens, as entity information could potentially be changed.</p><p>Once everything is up to date, the snapshot timer is checked to see if it has exceeded the snapshot interval. With that being the case, a snapshot packet is created and filled in by using the <code class="literal">CreateSnapshot</code> method of <code class="literal">S_Network</code>. The packet is then broadcasted to every single client and the snapshot timer is reset to zero.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>
<span class="strong"><strong>Ticks Per Second</strong></span> (<span class="strong"><strong>TPS</strong></span>) are measured by increasing the <code class="literal">m_tick</code> data member every <a id="id663" class="indexterm"/>update, provided the TPS timer hasn't exceeded one second. If that's the case, <code class="literal">m_tps</code> is assigned the value of <code class="literal">m_tick</code>, which in turn gets set back to zero, alongside the TPS timer.</p></div></div><p>Handling incoming packets is the next piece of the puzzle:</p><div class="informalexample"><pre class="programlisting">void World::HandlePacket(sf::IpAddress&amp; l_ip,
  const PortNumber&amp; l_port, const PacketID&amp; l_id,
  sf::Packet&amp; l_packet, Server* l_server)
{
  ClientID id = l_server-&gt;GetClientID(l_ip, l_port);
  PacketType type = (PacketType)l_id;
  if (id &gt;= 0){
    if (type == PacketType::Disconnect){
      ClientLeave(id);
      l_server-&gt;RemoveClient(l_ip, l_port);
    } else if (type == PacketType::Message){
      // ...
    } else if (type == PacketType::PlayerUpdate){
      m_systems.GetSystem&lt;S_Network&gt;(System::Network)-&gt;
        UpdatePlayer(l_packet, id);
    }
  } else {
    if (type != PacketType::Connect){ return; }
    std::string nickname;
    if (!(l_packet &gt;&gt; nickname)){ return; }
    ClientID cid = l_server-&gt;AddClient(l_ip, l_port);
    if (cid == -1){
      sf::Packet packet;
      StampPacket(PacketType::Disconnect, packet);
      l_server-&gt;Send(l_ip, l_port, packet);
      return;
    }
    <span class="strong"><strong>sf::Lock lock(m_server.GetMutex());</strong></span>
    sf::Int32 eid = m_entities.AddEntity("Player");
    if (eid == -1){ return; }
    m_systems.GetSystem&lt;S_Network&gt;(System::Network)-&gt;
      RegisterClientID(eid, cid);
    C_Position* pos = m_entities.GetComponent&lt;C_Position&gt;
      (eid, Component::Position);
    pos-&gt;SetPosition(64.f, 64.f);
    m_entities.GetComponent&lt;C_Name&gt;(eid, Component::Name)-&gt;
      SetName(nickname);
    sf::Packet packet;
    StampPacket(PacketType::Connect, packet);
    packet &lt;&lt; eid;
    packet &lt;&lt; pos-&gt;GetPosition().x &lt;&lt; pos-&gt;GetPosition().y;
    if (!l_server-&gt;Send(cid, packet)){
      std::cout &lt;&lt; "Unable to respond to connect packet!"
        &lt;&lt; std::endl;
      return;
    }
  }
}</pre></div><p>The <a id="id664" class="indexterm"/>client ID is first obtained from the originating IP address and port number. If a client with that information exists, we're interested in three packet types that can be received from it. First, the client disconnect packet is handled by invoking the <code class="literal">ClientLeave</code> method with the client ID passed in as the only argument. Next, the actual client is removed from the server class.</p><p>The next packet type, <code class="literal">Message</code>, is left unimplemented for now. We're not going to send chat messages between clients just yet, but this is where it would be implemented in the future. Following that is the player update packet type, in which case the packet is simply passed into the network system to be processed. We have already covered this.</p><p>If the origin information of the incoming data does not yield us a valid client ID, we're only interested in communications that attempt to connect. First, we attempt to extract a string<a id="id665" class="indexterm"/> from the packet, which would be the player nickname. If that fails, this method is returned from. Next, the client information is added and its success is checked by analyzing the returned client ID. In case of a failure, a <code class="literal">Disconnect</code> packet is sent back to the originating source and the method is returned from. Otherwise, the server mutex is locked and we attempt to add a new player entity. Failure to do that, once again, would result in returning from this method. The client ID is then registered in the network system and the position of our newly added player entity is set to some pre-defined values. The name component of the player entity is also adjusted to reflect the entered nickname. At this point, a connect packet is constructed as a response. It contains the entity ID of the player, as well as its spawn position. The packet is then sent out to our new client.</p><p>Leaving the server is a much simpler procedure in comparison to this. Let's take a look:</p><div class="informalexample"><pre class="programlisting">void World::ClientLeave(const ClientID&amp; l_client){
    <span class="strong"><strong>sf::Lock lock(m_server.GetMutex());</strong></span>
    S_Network* network = m_systems.
     GetSystem&lt;S_Network&gt;(System::Network);
    m_entities.RemoveEntity(network-&gt;GetEntityID(l_client));
}</pre></div><p>The server mutex gets locked before this operation is performed. The network system is then obtained and the <code class="literal">RemoveEntity</code> method of our entity manager is invoked with the return value of network system's <code class="literal">GetEntityID</code> method. This effectively removes the entity.</p><p>Implementing some basic commands on the server side proves to be more than useful. Let's take a look at a very basic setup of a command-line thread:</p><div class="informalexample"><pre class="programlisting">void World::CommandLine(){
   while (m_server.IsRunning()){
      std::string str;
      std::getline(std::cin, str);
      if (str == "terminate"){
         m_server.Stop();
         m_running = false;
         break;
      } else if (str == "disconnectall"){
         std::cout &lt;&lt; "Disconnecting all clients..." &lt;&lt; std::endl;
         m_server.DisconnectAll();
         <span class="strong"><strong>sf::Lock lock(m_server.GetMutex());</strong></span>
         m_entities.Purge();
      } else if (str.find("tps") != std::string::npos){
         std::cout &lt;&lt; "TPS: " &lt;&lt; m_tps &lt;&lt; std::endl;
      } else if (str == "clients"){
         std::cout &lt;&lt; m_server.GetClientCount() 
            &lt;&lt; " clients online:" &lt;&lt; std::endl;
         std::cout &lt;&lt; m_server.GetClientList() 
            &lt;&lt; std::endl;
      } else if (str == "entities"){
         std::cout &lt;&lt; "Current entity count: " 
            &lt;&lt; m_entities.GetEntityCount() &lt;&lt; std::endl;
      }
   }
}</pre></div><p>First, a<a id="id666" class="indexterm"/> loop is entered and kept alive as long as the server is running. Next, the command line is prompted to obtain a line of input. The first command we process is <code class="literal">"terminate"</code>. This stops the server and breaks out of the command line loop, which is helpful. The following command disconnects every single client and purges all entities that currently exist. Notice that the server mutex gets locked before the purge. The next command simply displays the current tick per second rate. Typing in <code class="literal">"clients"</code> would result in a list of clients currently connected that contains their IP addresses, port numbers, and latency values. Lastly, the <code class="literal">"entities"</code> command simply prints out the number of entities that are currently in the world.</p><p>The last and definitely the least interesting method is useful for obtaining the current status of the world:</p><div class="informalexample"><pre class="programlisting">bool World::IsRunning(){ return m_running; }</pre></div></div><div class="section" title="Server entry point"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec74"/>Server entry point</h2></div></div></div><p>Now let's <a id="id667" class="indexterm"/>put all of this effort to work. The following are the contents of our <code class="literal">Server_Main.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">#include "World.h"

int main(){
    World world;
    sf::Clock clock;
    clock.restart();

    while (world.IsRunning()){
        world.Update(clock.restart());
    }
     return 0;
}</pre></div><p>It couldn't get simpler than this. A new instance of the <code class="literal">World</code> class is created, alongside a clock that is promptly restarted. Our main <code class="literal">while</code> loop is entered with the condition that the world instance has to keep running. It gets updated every iteration with the return value of <code class="literal">clock.restart()</code>. After the loop is terminated, zero is returned to end the program successfully. </p><p>All <a id="id668" class="indexterm"/>of this brings us a very nice looking and capable console window that's ready to handle some incoming connections:</p><div class="mediaobject"><img src="graphics/B04284_14_02.jpg" alt="Server entry point"/></div><p>This by itself is, of course, completely useless without the client that draws all of the pretty images as a result of the server communicating with it. That is the next major task on our list.</p></div></div>
<div class="section" title="Developing the game client"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec127"/>Developing the game client</h1></div></div></div><p>With <a id="id669" class="indexterm"/>proper backend support from the server, we can now focus entirely on client-side details and spoil ourselves a little with pretty visuals that always yield that sense of accomplishment a lot quicker than anything that runs in the background. Let's start by creating the client's own version of <code class="literal">NetSettings.h</code>:</p><div class="informalexample"><pre class="programlisting">#define NET_RENDER_DELAY 100 // ms.
#define PLAYER_UPDATE_INTERVAL 50 // ms</pre></div><p>We have a couple of macros to work with here. First is the expected delay between what's being rendered on screen and real time. This means that technically we're going to be rendering all action about 100 milliseconds in the past. The second macro is the interval at which we're going to be sending updates to the server. 50 milliseconds gives us plenty of time to<a id="id670" class="indexterm"/> gather a few input states and let the server know what's going on.</p><div class="section" title="Entity component system expansions"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec75"/>Entity component system expansions</h2></div></div></div><p>As in <a id="id671" class="indexterm"/>the case of the server, additional components and systems are necessary if we want to realize any of our goals. Unlike the server, however, these additions to the client entity component system are going to serve an entirely different purpose. It's going to be important for us to see the names and health values of all players in the game. We're going to shoot for something like this:</p><div class="mediaobject"><img src="graphics/B04284_14_03.jpg" alt="Entity component system expansions"/></div><p>In order to easily maintain these glyphs floating above an entity, we're going to need a new type of component that describes exactly where they're supposed to be rendered:</p><div class="informalexample"><pre class="programlisting">class C_UI_Element : public C_Base{
public:
  C_UI_Element() : C_Base(Component::UI_Element),
    m_showHealth(false), m_showName(false){}
  void ReadIn(std::stringstream&amp; l_stream){
    l_stream &gt;&gt; m_offset.x &gt;&gt; m_offset.y;
  }

  const sf::Vector2f&amp; GetOffset(){ return m_offset; }
  void SetOffset(const sf::Vector2f&amp; l_offset){ m_offset = l_offset; }

  void SetShowHealth(bool l_show){ m_showHealth = l_show; }
  void SetShowName(bool l_show){ m_showName = l_show; }
  bool ShowHealth(){ return m_showHealth; }
  bool ShowName(){ return m_showName; }
private:
  sf::Vector2f m_offset;
  bool m_showHealth;
  bool m_showName;
};</pre></div><p>The <code class="literal">C_UI_Element</code> component will read in two offset values, one for X and one for Y, from the <a id="id672" class="indexterm"/>entity file. This way, characters of different sizes can define their own rules of where this information will appear. We also included a couple of Boolean flags in case the health or name information ever needs to be disabled for some reason.</p><p>The component alone isn't going to do anything fancy, so let's create a new system that actually makes something happen:</p><div class="informalexample"><pre class="programlisting">class S_CharacterUI : public S_Base{
public:
    S_CharacterUI(SystemManager* l_systemMgr);
    ~S_CharacterUI();

    void Update(float l_dT);
    void HandleEvent(const EntityId&amp; l_entity, 
      const EntityEvent&amp; l_event);
    void Notify(const Message&amp; l_message);

    void Render(Window* l_wind);
private:
    sf::Sprite m_heartBar;
    sf::Text m_nickname;
    sf::RectangleShape m_nickbg;
    sf::Vector2u m_heartBarSize;
};</pre></div><p>Note that this system has a <code class="literal">Render</code> method. We're not only going to update the position of the graphical elements, but also draw them on the screen. This includes a sprite that will be bound to whatever texture is chosen to represent health, an instance of <code class="literal">sf::Text</code> that will hold the entity's name, a rectangle background that will be rendered behind the name, and a data member that holds the size of the health bar texture.</p><p>With that out of the way, let's start implementing this system!</p><div class="informalexample"><pre class="programlisting">S_CharacterUI::S_CharacterUI(SystemManager* l_systemMgr)
  : S_Base(System::Character_UI, l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::UI_Element);
  req.TurnOnBit((unsigned int)Component::Health);
  m_requiredComponents.push_back(req);
  req.ClearBit((unsigned int)Component::Health);
  req.TurnOnBit((unsigned int)Component::Name);
  m_requiredComponents.push_back(req);

  ClientSystemManager* mgr =(ClientSystemManager*)m_systemManager;
  mgr-&gt;GetTextureManager()-&gt;RequireResource("HeartBar");
  mgr-&gt;GetFontManager()-&gt;RequireResource("Main");
  sf::Texture* txtr = mgr-&gt;GetTextureManager()-&gt;
    GetResource("HeartBar");
  txtr-&gt;setRepeated(true);
  m_heartBarSize = txtr-&gt;getSize();
  m_heartBar.setTexture(*txtr);
  m_heartBar.setScale(0.5f, 0.5f);
  m_heartBar.setOrigin(m_heartBarSize.x / 2, m_heartBarSize.y);
  m_nickname.setFont(*mgr-&gt;GetFontManager()-&gt;GetResource("Main"));
  m_nickname.setCharacterSize(9);
  m_nickname.setColor(sf::Color::White);
  m_nickbg.setFillColor(sf::Color(100, 100, 100, 100));
}</pre></div><p>The first<a id="id673" class="indexterm"/> order of business here is, of course, setting up the component requirements. An entity has to have a position component and a UI element component, in addition to some combination of the health and name components. The rest of the constructor is used to set up the texture and font resources for our graphics. Our health bar texture is set to be repeated so we can represent any health value. The actual texture is only the size of a single heart.</p><p>The resources for these elements obviously have to be released when they're no longer needed. That's where the destructor comes in:</p><div class="informalexample"><pre class="programlisting">S_CharacterUI::~S_CharacterUI(){
    ClientSystemManager* mgr =
     (ClientSystemManager*)m_systemManager;
    mgr-&gt;GetTextureManager()-&gt;ReleaseResource("HeartBar");
    mgr-&gt;GetFontManager()-&gt;ReleaseResource("Main");
}</pre></div><p>Lastly, the most important part of this system is contained within the <code class="literal">Render</code> method:</p><div class="informalexample"><pre class="programlisting">void S_CharacterUI::Render(Window* l_wind){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for (auto &amp;entity : m_entities){
    C_Health* health = entities-&gt;
      GetComponent&lt;C_Health&gt;(entity, Component::Health);
    C_Name* name = entities-&gt;
      GetComponent&lt;C_Name&gt;(entity, Component::Name);
    C_Position* pos = entities-&gt;
      GetComponent&lt;C_Position&gt;(entity, Component::Position);
    C_UI_Element* ui = entities-&gt;
      GetComponent&lt;C_UI_Element&gt;(entity, Component::UI_Element);
    if (health){
      m_heartBar.setTextureRect(sf::IntRect(0, 0,
        m_heartBarSize.x * health-&gt;GetHealth(),
        m_heartBarSize.y));
      m_heartBar.setOrigin((
        m_heartBarSize.x * health-&gt;GetHealth())/2,
        m_heartBarSize.y);
      m_heartBar.setPosition(pos-&gt;GetPosition() +ui-&gt;GetOffset());
      l_wind-&gt;GetRenderWindow()-&gt;draw(m_heartBar);
    }
    if (name){
      m_nickname.setString(name-&gt;GetName());
      m_nickname.setOrigin(m_nickname.getLocalBounds().width / 2,
        m_nickname.getLocalBounds().height / 2);
      if (health){
        m_nickname.setPosition(m_heartBar.getPosition().x,
          m_heartBar.getPosition().y - (m_heartBarSize.y));
      } else {
        m_nickname.setPosition(pos-&gt;GetPosition() +
          ui-&gt;GetOffset());
      }
      m_nickbg.setSize(sf::Vector2f(
        m_nickname.getGlobalBounds().width + 2,
        m_nickname.getCharacterSize() + 1));
      m_nickbg.setOrigin(m_nickbg.getSize().x / 2,
        m_nickbg.getSize().y / 2);
      m_nickbg.setPosition(m_nickname.getPosition().x + 1,
        m_nickname.getPosition().y + 1);
      l_wind-&gt;GetRenderWindow()-&gt;draw(m_nickbg);
      l_wind-&gt;GetRenderWindow()-&gt;draw(m_nickname);
    }
  }
}</pre></div><p>For each<a id="id674" class="indexterm"/> entity, we obtain all four components that we're going to be working with. Since there can be instances where either the name or health components exist without the other one present, both of them must be checked before we commit to rendering them.</p><p>The health bar portion is drawn by first resetting the texture rectangle of the sprite. Its width is changed to the result of multiplying the width of a single heart in the texture by the health value an entity has. The <span class="emphasis"><em>Y</em></span> value is left unchanged. The origin of the sprite is then <a id="id675" class="indexterm"/>changed to be in the middle of it on the <span class="emphasis"><em>X</em></span> axis and on the very bottom of the <span class="emphasis"><em>Y</em></span> axis. Its position is then set to that of the entity's, but with the UI element's offset factored in. Because the texture is set up to repeat itself, this allows us to represent ridiculous amounts of health:</p><div class="mediaobject"><img src="graphics/B04284_14_04.jpg" alt="Entity component system expansions"/></div><p>When an entity's name is rendered, the <code class="literal">sf::Text</code> instance is first set up by changing the string and its origin is manipulated to be exactly in the middle. Since we want our information to be nicely stacked and not drawn on top of each other, checking if the health was rendered is necessary.</p><p>If the health component is present, the name's position is obtained from the <code class="literal">m_heartBar</code> data member. The Y value of that position is modified by subtracting the height of the health bar in order to render the player name on top. Otherwise, the name's position is set to match the entity with the offset included. The name background is then set up to be slightly larger than the text that it will be drawn behind and its origin is set to the exact center. The position of the name background is slightly offset by a single pixel from the position of the actual name. The values used here can be perfected by simply trying out different things and getting the feel for the best result.</p><p>Lastly, the background and the entity's name are drawn in that order on screen.</p></div><div class="section" title="Network class and interpolation"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec76"/>Network class and interpolation</h2></div></div></div><p>Showing <a id="id676" class="indexterm"/>our entities simply appearing on the screen isn't satisfactory at all. Even if we get them to move, you will quickly notice that due to the delay between the server and client, players would look more like they're skipping across the screen, rather than walking. A little more work has to be done on the client side in order to smooth it out. For that, we're going to rely on something called interpolation. Consider the following illustration:</p><div class="mediaobject"><img src="graphics/B04284_14_05.jpg" alt="Network class and interpolation"/></div><p>What is <a id="id677" class="indexterm"/>interpolation? It's an estimation between two known data points. There are many different types of interpolation out there, all with a different philosophy of use. For our purposes, interpolating data simply comes down to finding a weighted average between two values at a given time. In the preceding diagram, we have two snapshots representing different places in time. Interpolating helps us find the state of an entity somewhere in the middle of those two snapshots, and, in turn, smooths out their movement by adjusting attributes such as position, velocity, and acceleration based on the estimation, rather than actual snapshot data.</p><p>Finding a value at a specific point in time between two snapshots can be expressed this way:</p><div class="mediaobject"><img src="graphics/B04284_14_06.jpg" alt="Network class and interpolation"/></div><p>A value we want to find at a given time, tx, is simply the difference of the value between both snapshots divided by the difference in time, multiplied by the time that has passed since the first snapshot and then added to the value of the first snapshot. In code, it can be expressed like this:</p><div class="informalexample"><pre class="programlisting">template&lt;class T&gt;
inline T Interpolate(const sf::Int32&amp; T1, const sf::Int32&amp; T2,
  const T&amp; T1_val, const T&amp; T2_val, const sf::Int32&amp; T_X)
{
  return (((T2_val - T1_val) / (T2 - T1)) * (T_X - T1)) + T1_val;
}</pre></div><p>Having a few extra methods for actually handling the snapshot and time types, as well as comparing two snapshots together, would be useful:</p><div class="informalexample"><pre class="programlisting">void InterpolateSnapshot(const EntitySnapshot&amp; l_s1, 
  const sf::Int32&amp; T1, const EntitySnapshot&amp; l_s2, 
  const sf::Int32&amp; T2, EntitySnapshot&amp; l_target, 
  const sf::Int32&amp; T_X);

bool CompareSnapshots(const EntitySnapshot&amp; l_s1, 
  const EntitySnapshot&amp; l_s2, bool l_position = true, 
  bool l_physics = true, bool l_state = true);</pre></div><p>We're <a id="id678" class="indexterm"/>going to need some way of containing these snapshots, so it's time to define our data types:</p><div class="informalexample"><pre class="programlisting">using SnapshotMap = std::unordered_map&lt;EntityId, EntitySnapshot&gt;;
struct SnapshotDetails{
  SnapshotMap m_snapshots;
};
using SnapshotContainer = std::map&lt;sf::Int32, SnapshotDetails&gt;;
using OutgoingMessages = std::unordered_map&lt;EntityMessage,
  std::vector&lt;Message&gt;&gt;;</pre></div><p>All of the snapshots are first stored with the entity ID being the key. The actual map itself is being held by a <code class="literal">SnapshotDetails</code> struct, which may prove to be useful later if we decide to add any additional snapshot information. All of the entity data is then stored in a map structure, where the timestamp of the snapshot is the key value. Notice that we're using a regular map here, as opposed to an unordered map. What's the benefit, you may ask. The regular map type may be a little bit slower, but it automatically sorts its entries by key. This means that newer snapshots will always go towards the end of the map. The reason why that's important will become apparent when we're performing entity interpolation.</p><p>The last data type we're going to need for the network class is some sort of container that holds outgoing messages we're going to send to the server. In this case, an unordered map works just fine.</p><p>So, what is our network system class going to look like? Let's take a look:</p><div class="informalexample"><pre class="programlisting">class S_Network : public S_Base{
public:
  S_Network(SystemManager* l_systemMgr);
  ~S_Network();

  void Update(float l_dT);
  void HandleEvent(const EntityId&amp; l_entity,
    const EntityEvent&amp; l_event);
  void Notify(const Message&amp; l_message);

  void SetClient(Client* m_client);
  void SetPlayerID(const EntityId&amp; l_entity);

  void AddSnapshot(const EntityId&amp; l_entity, 
    const sf::Int32&amp; l_timestamp, 
    EntitySnapshot&amp; l_snapshot);
  void SendPlayerOutgoing();
  void ClearSnapshots();
private:
  void ApplyEntitySnapshot(const EntityId&amp; l_entity,
    const EntitySnapshot&amp; l_snapshot,
    bool l_applyPhysics);

  void PerformInterpolation();
  SnapshotContainer m_entitySnapshots;
  EntityId m_player;
  OutgoingMessages m_outgoing;
  Client* m_client;
  sf::Time m_playerUpdateTimer;
};</pre></div><p>Apart <a id="id679" class="indexterm"/>from the normal methods a system has to implement, we have a few setters for registering a <code class="literal">Client</code> instance, as well as keeping track of the entity ID that our client is going to be controlling as a player. A few helper methods for adding a received entity snapshot, as well as sending out player messages to the server also exist to make life just a little bit easier. For our private method selection, we have a total of two: one for applying a specific snapshot to an entity and another for performing interpolation. This is met by a standard number of data members that are responsible for containing received snapshots, keeping track of the player ID, containing outgoing messages to the server before they're sent out, and having access to the <code class="literal">Client</code> instance. To top that off, we're going to use another <code class="literal">sf::Time</code> data type in order to keep track of time passage for sending player updates to the server.</p></div><div class="section" title="Implementing the client network class"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec77"/>Implementing the client network class</h2></div></div></div><p>Before <a id="id680" class="indexterm"/>we get to actually implementing the network system, let's complete the last two functions related to interpolation and comparison of entity snapshots:</p><div class="informalexample"><pre class="programlisting">void InterpolateSnapshot(const EntitySnapshot&amp; l_s1,
  const sf::Int32&amp; T1, const EntitySnapshot&amp; l_s2,
  const sf::Int32&amp; T2, EntitySnapshot&amp; l_target,
  const sf::Int32&amp; T_X)
{
  l_target.m_direction = <span class="strong"><strong>l_s2.m_direction</strong></span>;
  l_target.m_health = <span class="strong"><strong>l_s2.m_health</strong></span>;
  l_target.m_name = <span class="strong"><strong>l_s2.m_name</strong></span>;
  l_target.m_state = l_s1.m_state;
  l_target.m_elevation = l_s1.m_elevation;

  l_target.m_position.x = Interpolate&lt;float&gt;(
    T1, T2, l_s1.m_position.x, l_s2.m_position.x, T_X);
  l_target.m_position.y = Interpolate&lt;float&gt;(
    T1, T2, l_s1.m_position.y, l_s2.m_position.y, T_X);

  l_target.m_velocity.x = Interpolate&lt;float&gt;(
    T1, T2, l_s1.m_velocity.x, l_s2.m_velocity.x, T_X);
  l_target.m_velocity.y = Interpolate&lt;float&gt;(
    T1, T2, l_s1.m_velocity.y, l_s2.m_velocity.y, T_X);

  l_target.m_acceleration.x = Interpolate&lt;float&gt;(
    T1, T2, l_s1.m_acceleration.x, l_s2.m_acceleration.x, T_X);
  l_target.m_acceleration.y = Interpolate&lt;float&gt;(
    T1, T2, l_s1.m_acceleration.y, l_s2.m_acceleration.y, T_X);
}</pre></div><p>We<a id="id681" class="indexterm"/> begin by overwriting some values that don't need to be interpolated. Note that the direction, health, and name values are overwritten with the latest available information from the second entity snapshot, rather than the first. This provides an overall smoother feel to entity movement and interactions. For the rest of the snapshot data, we use our handy <code class="literal">Interpolate</code> function, which provides a smooth transition between the two updates. </p><p>It's also quite useful to have a function that can compare two snapshots together, so we can know if any data has changed. <code class="literal">CompareSnapshots</code> comes to the rescue here:</p><div class="informalexample"><pre class="programlisting">bool CompareSnapshots(const EntitySnapshot&amp; l_s1,
  const EntitySnapshot&amp; l_s2, bool l_position,
  bool l_physics, bool l_state)
{
  if (l_position &amp;&amp; (l_s1.m_position != l_s2.m_position || 
    l_s1.m_elevation != l_s2.m_elevation))
  { return false; }
  if (l_physics &amp;&amp; (l_s1.m_velocity != l_s2.m_velocity ||
    l_s1.m_acceleration != l_s2.m_acceleration ||
    l_s1.m_direction != l_s2.m_direction))
  { return false; }
  if (l_state &amp;&amp; (l_s1.m_state != l_s2.m_state))
  { return false; }
  return true;
}</pre></div><p>It's not really necessary to check every single aspect of a snapshot here. All we really care about is the positional, kinematic, and state information of the entity. Three additional Boolean arguments can also be provided, telling this function which data is relevant.</p><p>With<a id="id682" class="indexterm"/> this out of the way, we can finally begin implementing the network system class, starting, of course, with the constructor and destructor:</p><div class="informalexample"><pre class="programlisting">S_Network::S_Network(SystemManager* l_systemMgr)
  : S_Base(System::Network, l_systemMgr), m_client(nullptr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Client);
  m_requiredComponents.push_back(req);

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Move, this);
  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Attack, this);
  m_playerUpdateTimer = sf::milliseconds(0);
}</pre></div><p>Much like on the server class, we only care about the entities that have client components in this system. Messages for entity movement and attacks are also subscribed to in order to properly store them and update the server later on.</p><p>Next up, we have the <code class="literal">Update</code> method:</p><div class="informalexample"><pre class="programlisting">void S_Network::Update(float l_dT){
  if (!m_client){ return; }
  <span class="strong"><strong>sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
  m_playerUpdateTimer += sf::seconds(l_dT);
  if (m_playerUpdateTimer.asMilliseconds() &gt;=
    PLAYER_UPDATE_INTERVAL)
  {
    SendPlayerOutgoing();
    m_playerUpdateTimer = sf::milliseconds(0);
  }
  PerformInterpolation();
}</pre></div><p>First, a check is made to make sure we have a valid pointer to the client class. If so, we lock the client mutex and add time to the player update timer. The <code class="literal">SendPlayerOutgoing</code> method is then invoked and the timer is reset if enough time has passed to update the server. Lastly, we call the private helper method of this class, which is responsible for interpolating between snapshots. Keeping this functionality separate from the actual update loop leaves us with nicer looking code and allows early return while interpolating.</p><p>Handling<a id="id683" class="indexterm"/> the messages this system is subscribed to is quite simple, as you will see here:</p><div class="informalexample"><pre class="programlisting">void S_Network::Notify(const Message&amp; l_message){
  if (!HasEntity(l_message.m_receiver) ||
    l_message.m_receiver != m_player)
  {
    return;
  }
  if (l_message.m_type == (MessageType)EntityMessage::Attack &amp;&amp;
    m_outgoing.find(EntityMessage::Attack) != m_outgoing.end())
  {
    return;
  }
  m_outgoing[(EntityMessage)l_message.m_type].
    emplace_back(l_message);
}</pre></div><p>At this point, all we care about is adding the message into our outgoing container, since we're not dealing with more complex types just yet. An additional check is performed in case an attack message is received. There really is no point of having multiple attack messages in this container at the same time, so the <code class="literal">Notify</code> method simply returns if an attack message is attempted to be inserted while one already exists in the container.</p><p>Next, we have some helper methods:</p><div class="informalexample"><pre class="programlisting">void S_Network::SetClient(Client* l_client){m_client = l_client;}
void S_Network::SetPlayerID(const EntityId&amp; l_entity){
  m_player = l_entity;
}
void S_Network::AddSnapshot(const EntityId&amp; l_entity, 
  const sf::Int32&amp; l_timestamp, EntitySnapshot&amp; l_snapshot)
{
  <span class="strong"><strong>sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
  auto i = m_entitySnapshots.emplace(l_timestamp,
    SnapshotDetails());
  i.first-&gt;second.m_snapshots.emplace(l_entity, l_snapshot);
}</pre></div><p>There's nothing too special going on here. One thing to note is that when a new snapshot is being added, the client mutex probably should be locked. Speaking of snapshots, let's look at how one could be applied to an entity:</p><div class="informalexample"><pre class="programlisting">void S_Network::ApplyEntitySnapshot(const EntityId&amp; l_entity, 
  const EntitySnapshot&amp; l_snapshot, bool l_applyPhysics)
{
  ClientEntityManager* entities =
    (ClientEntityManager*)m_systemManager-&gt;GetEntityManager();
  C_Position* position = nullptr;
  C_Movable* movable = nullptr;
  S_Movement* movement_s = nullptr;
  S_State* state_s = nullptr;
  C_Health* health = nullptr;
  C_Name* name = nullptr;
  <span class="strong"><strong>sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
  if (position = entities-&gt;GetComponent&lt;C_Position&gt;(l_entity,
    Component::Position))
  {
    position-&gt;SetPosition(l_snapshot.m_position);
    position-&gt;SetElevation(l_snapshot.m_elevation);
  }
  if (l_applyPhysics){
    if (movable = entities-&gt;GetComponent&lt;C_Movable&gt;(l_entity,
      Component::Movable))
    {
      movable-&gt;SetVelocity(l_snapshot.m_velocity);
      movable-&gt;SetAcceleration(l_snapshot.m_acceleration);
    }
  }
  if (movement_s = m_systemManager-&gt;
    GetSystem&lt;S_Movement&gt;(System::Movement))
  {
    movement_s-&gt;SetDirection(l_entity,
      (Direction)l_snapshot.m_direction);
  }
  if (state_s = m_systemManager-&gt;
    GetSystem&lt;S_State&gt;(System::State))
  {
    state_s-&gt;ChangeState(l_entity,
      (EntityState)l_snapshot.m_state,true);
  }
  if (health = entities-&gt;GetComponent&lt;C_Health&gt;(l_entity,
    Component::Health))
  {
    health-&gt;SetHealth(l_snapshot.m_health);
  }
  if (name = entities-&gt;GetComponent&lt;C_Name&gt;(l_entity,
    Component::Name))
  {
    name-&gt;SetName(l_snapshot.m_name);
  }
}</pre></div><p>After we obtain a pointer to the entity manager and set up empty pointers to various components that the entity snapshot might contain information about, the client mutex is locked <a id="id684" class="indexterm"/>and we begin manipulating the component information carefully, by first attempting to retrieve a valid component address inside the <code class="literal">if</code> statements. This method also takes in a flag to let it know whether physics information, such as acceleration or velocity, should be applied, which can come in handy.</p><p>The following method is executed while updating the network system class, and it is responsible for sending player updates to the server:</p><div class="informalexample"><pre class="programlisting">void S_Network::SendPlayerOutgoing(){
  sf::Int32 p_x = 0, p_y = 0;
  sf::Int8 p_a = 0;

  for (auto &amp;itr : m_outgoing){
    if (itr.first == EntityMessage::Move){
      sf::Int32 x = 0, y = 0;
      for (auto &amp;message : itr.second){
        if (message.m_int == (int)Direction::Up){ --y; }
        else if (message.m_int == (int)Direction::Down){ ++y; }
        else if (message.m_int == (int)Direction::Left){ --x; }
        else if (message.m_int == (int)Direction::Right){ ++x; }
      }
      if (!x &amp;&amp; !y){ continue; }
      p_x = x; p_y = y;
    } else if (itr.first == EntityMessage::Attack){ p_a = 1; }
  }

  sf::Packet packet;
  StampPacket(PacketType::PlayerUpdate, packet);
  packet &lt;&lt; sf::Int8(EntityMessage::Move)
    &lt;&lt; p_x &lt;&lt; p_y &lt;&lt; sf::Int8(Network::PlayerUpdateDelim);
  packet &lt;&lt; sf::Int8(EntityMessage::Attack)
    &lt;&lt; p_a &lt;&lt; sf::Int8(Network::PlayerUpdateDelim);
  m_client-&gt;Send(packet);
  m_outgoing.clear();
}</pre></div><p>We begin by setting up some local variables that are going to be holding the number of times our player has moved in the X and Y directions. A smaller variable is also set up for the attack state. The next step is to iterate over all outgoing messages and process each type individually. In a case of a <code class="literal">Move</code> type, every single one of them is counted. If an <code class="literal">Attack</code> message is found, the attack state is simply set to 1.</p><p>The last step is, of course, sending this information out. A new packet is then constructed and marked as a player update. The movement and attack state information is then fed into the <a id="id685" class="indexterm"/>packet. Notice that we're adding in the <code class="literal">PlayerUpdateDelim</code> value at the end of each update type. Enforcing specific communication rules as such decreases the chances of our server processing invalid or damaged data. Once the update packet is sent in, the outgoing message container is cleared for the next time.</p><p>Lastly, we arrive at the key method for ensuring smooth entity movement:</p><div class="informalexample"><pre class="programlisting">void S_Network::PerformInterpolation(){
  if (m_entitySnapshots.empty()){ return; }
  ClientEntityManager* entities =
    (ClientEntityManager*)m_systemManager-&gt;GetEntityManager();
  sf::Time t = m_client-&gt;GetTime();
  auto itr = ++m_entitySnapshots.begin();
  while (itr != m_entitySnapshots.end()){
    if (m_entitySnapshots.begin()-&gt;first &lt;=
      t.asMilliseconds() - NET_RENDER_DELAY &amp;&amp;
      itr-&gt;first &gt;= t.asMilliseconds() - NET_RENDER_DELAY)
    {
      auto Snapshot1 = m_entitySnapshots.begin();
      auto Snapshot2 = itr;
      bool SortDrawables = false;
      for (auto snap = Snapshot1-&gt;second.m_snapshots.begin();
        snap != Snapshot1-&gt;second.m_snapshots.end();)
      {
        if (!entities-&gt;HasEntity(snap-&gt;first)){
          if (entities-&gt;AddEntity(snap-&gt;second.m_type,
            snap-&gt;first) == (int)Network::NullID)
          {
            std::cout &lt;&lt; "Failed adding entity type: "
              &lt;&lt; snap-&gt;second.m_type &lt;&lt; std::endl;
            continue;
          }
          ApplyEntitySnapshot(snap-&gt;first, snap-&gt;second, true);
          ++snap;
          continue;
        }
        auto snap2 =Snapshot2-&gt;second.m_snapshots.find(
          snap-&gt;first);
        if (snap2 == Snapshot2-&gt;second.m_snapshots.end()){
         <span class="strong"><strong> sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
          entities-&gt;RemoveEntity(snap-&gt;first);
          snap = Snapshot1-&gt;second.m_snapshots.erase(snap);
          continue;
        }

        EntitySnapshot i_snapshot;
        InterpolateSnapshot(snap-&gt;second, Snapshot1-&gt;first,
          snap2-&gt;second, Snapshot2-&gt;first,
          i_snapshot, t.asMilliseconds() - NET_RENDER_DELAY);
        ApplyEntitySnapshot(snap-&gt;first, i_snapshot, true);
        if (!CompareSnapshots(snap-&gt;second, snap2-&gt;second,
          true, false, false))
        {
          SortDrawables = true;
        }
        ++snap;
      }
      if (SortDrawables){
        m_systemManager-&gt;GetSystem&lt;S_Renderer&gt;
          (System::Renderer)-&gt;SortDrawables();
      }
      return;
    }
    m_entitySnapshots.erase(m_entitySnapshots.begin());
    itr = ++m_entitySnapshots.begin();
  }
}</pre></div><p>First<a id="id686" class="indexterm"/> and foremost, we must deal with the possibility of our client not having any snapshots at all. If that happens, this method is returned from immediately. If we have snapshots available, the next step is iterating over the snapshot container and finding two snapshots that we're currently between (time wise). Normally, this wouldn't be a likely outcome, but keep in mind that we're rendering things slightly in the past:</p><div class="mediaobject"><img src="graphics/B04284_14_07.jpg" alt="Implementing the client network class"/></div><p>The benefit of rendering slightly in the past is that we will actually have more data that has arrived from the server, which in turn will allow us to smooth it out and provide nicer entity movement. This wouldn't be possible if we simply rendered everything in real time. This delay is represented by the <code class="literal">NET_RENDER_DELAY</code> macro.</p><p>Once <a id="id687" class="indexterm"/>we find the pair of snapshots that we're looking for, a local variable called <code class="literal">SortDrawables</code> is set up to keep track of whether or not we need to worry about re-sorting drawable components to represent depth correctly. All of the entities from the first (earlier) snapshot are then iterated over. Our first concern is making sure that an entity that exists in the snapshot also exists on our client. If it doesn't, a new entity is created from the type that the snapshot provides. All of its information is then applied to the newly created entity and we skip the current iteration of the snapshot loop as there's no need to interpolate anything.</p><p>The next step is making sure that the entity that exists in the earlier snapshot also exists in the later one, so an attempt to find it in the second snapshot container is made. Provided the entity has not been found, the client mutex is locked and the entity is removed from our client, prior to actually being erased from the snapshot container as well. The current iteration is then skipped, as we have no reason to interpolate once again.</p><p>If all of these checks yield no reason for us to skip an iteration, a new instance of <code class="literal">EntitySnapshot</code> is created. This is going to be our target for holding interpolated data. <code class="literal">InterpolateSnapshot</code> is then called with both snapshots and their time values, as well as the target snapshot and the current time <span class="emphasis"><em>with the interpolation delay</em></span> factored in is passed in as arguments. After the target snapshot is filled in with the interpolated data, it is applied to the current entity. We also want to compare both snapshots we're interpolating between and set the <code class="literal">SortDrawables</code> variable to <code class="literal">true</code> if they have different positions. After all of the entity interpolation code, this variable is checked and the system renderer is instructed to re-sort the drawable components if it was indeed set to <code class="literal">true</code> at some point.</p><p>One last thing to take away from this is that if the time checking conditional in the very first loop ends up not being satisfied, the first element in the snapshot container is erased and the iterator is reset to point to the second value in it, ensuring a proper disposal of irrelevant snapshots.</p></div><div class="section" title="Client entity and system management"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec78"/>Client entity and system management</h2></div></div></div><p>Quite<a id="id688" class="indexterm"/> predictably, we're going to have different<a id="id689" class="indexterm"/> types of components and systems available on the client side than the server side, starting with component types:</p><div class="informalexample"><pre class="programlisting">ClientEntityManager::ClientEntityManager(SystemManager* l_sysMgr, 
  TextureManager* l_textureMgr): EntityManager(l_sysMgr),
  m_textureManager(l_textureMgr)
{
  AddComponentType&lt;C_Position&gt;(Component::Position);
  AddComponentType&lt;C_State&gt;(Component::State);
  AddComponentType&lt;C_Movable&gt;(Component::Movable);
  AddComponentType&lt;C_Controller&gt;(Component::Controller);
  AddComponentType&lt;C_Collidable&gt;(Component::Collidable);
  AddComponentType&lt;C_SpriteSheet&gt;(Component::SpriteSheet);
  AddComponentType&lt;C_SoundEmitter&gt;(Component::SoundEmitter);
  AddComponentType&lt;C_SoundListener&gt;(Component::SoundListener);
  AddComponentType&lt;C_Client&gt;(Component::Client);
  AddComponentType&lt;C_Health&gt;(Component::Health);
  AddComponentType&lt;C_Name&gt;(Component::Name);
  AddComponentType&lt;C_UI_Element&gt;(Component::UI_Element);
}</pre></div><p>After<a id="id690" class="indexterm"/> making sure all client-relevant component<a id="id691" class="indexterm"/> types are registered, let's implement our own version of loading an entity here, as it involves manipulating the renderable components it may have:</p><div class="informalexample"><pre class="programlisting">int ClientEntityManager::AddEntity(
  const std::string&amp; l_entityFile, int l_id)
{
  ...
  while (std::getline(file, line)){
    ...
    } else if (type == "Component"){
      ...
      keystream &gt;&gt; *component;
      <span class="strong"><strong>if (component-&gt;GetType() == Component::SpriteSheet){</strong></span>
        <span class="strong"><strong>C_SpriteSheet* sheet = (C_SpriteSheet*)component;</strong></span>
        <span class="strong"><strong>sheet-&gt;Create(m_textureManager);</strong></span>
      <span class="strong"><strong>}</strong></span>
    }
  }
  ...
}</pre></div><p>We have already seen this code in previous chapters, but it's still fair to emphasize that the highlighted snippet does not exist on the server side at all, yet is necessary here. </p><p>Next, the client's version of a system manager:</p><div class="informalexample"><pre class="programlisting">class ClientSystemManager : public SystemManager{
public:
    ClientSystemManager(TextureManager* l_textureMgr,
      FontManager* l_fontMgr);
    ~ClientSystemManager();

    TextureManager* GetTextureManager();
    FontManager* GetFontManager();
    void Draw(Window* l_wind, unsigned int l_elevation);
private:
    TextureManager* m_textureMgr;
    FontManager* m_fontMgr;
};</pre></div><p>Naturally, the<a id="id692" class="indexterm"/> only additions we have here are, once <a id="id693" class="indexterm"/>again, related to graphics. We wouldn't need to draw anything on the server side, but it's necessary here.</p><p>The constructor of our client system manager handles adding systems that are relevant to the client performing as intended:</p><div class="informalexample"><pre class="programlisting">ClientSystemManager::ClientSystemManager(
  TextureManager* l_textureMgr, FontManager* l_fontMgr)
  : m_textureMgr(l_textureMgr), m_fontMgr(l_fontMgr)
{
  AddSystem&lt;S_State&gt;(System::State);
  AddSystem&lt;S_Control&gt;(System::Control);
  AddSystem&lt;S_Movement&gt;(System::Movement);
  AddSystem&lt;S_Collision&gt;(System::Collision);
  AddSystem&lt;S_SheetAnimation&gt;(System::SheetAnimation);
  AddSystem&lt;S_Network&gt;(System::Network);
  AddSystem&lt;S_Sound&gt;(System::Sound);
  AddSystem&lt;S_Renderer&gt;(System::Renderer);
  AddSystem&lt;S_CharacterUI&gt;(System::Character_UI);
}</pre></div><p>Note the placement of the network system here. The order of adding these systems directly dictates the order in which they are updated. We don't want our network system sending or receiving any data before we get a chance to process our own.</p><p>Naturally, getters for texture and font managers would be useful on this side:</p><div class="informalexample"><pre class="programlisting">TextureManager* ClientSystemManager::GetTextureManager(){
    return m_textureMgr;
}
FontManager* ClientSystemManager::GetFontManager(){
    return m_fontMgr;
}</pre></div><p>Lastly, we have a few systems that need to render something on screen:</p><div class="informalexample"><pre class="programlisting">void ClientSystemManager::Draw(Window* l_wind,
  unsigned int l_elevation)
{
  auto itr = m_systems.find(System::Renderer);
  if(itr != m_systems.end()){
    S_Renderer* system = (S_Renderer*)itr-&gt;second;
    system-&gt;Render(l_wind, l_elevation);
  }
  itr = m_systems.find(System::Character_UI);
  if (itr != m_systems.end()){
    S_CharacterUI* ui = (S_CharacterUI*)itr-&gt;second;
    ui-&gt;Render(l_wind);
  }
}</pre></div><p>After the<a id="id694" class="indexterm"/> renderer system draws all of the entities on<a id="id695" class="indexterm"/> screen, we want to overlay their names and health graphics on top of that.</p></div><div class="section" title="Putting the pieces into place"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec79"/>Putting the pieces into place</h2></div></div></div><p>Because <a id="id696" class="indexterm"/>all of the networking and action is going to take place solely within the confines of the game state, that's the main class we're going to adjust, starting with the header file:</p><div class="informalexample"><pre class="programlisting">class State_Game : public BaseState{
    ...
private:
    Map* m_gameMap;
    int m_player;
   <span class="strong"><strong>Client* m_client;</strong></span>
};</pre></div><p>After making sure that the game state has a pointer to a <code class="literal">Client</code> instance, we must provide a way for the game to handle incoming packets:</p><div class="informalexample"><pre class="programlisting">void State_Game::HandlePacket(const PacketID&amp; l_id,
  sf::Packet&amp; l_packet, Client* l_client)
{
  ClientEntityManager* emgr = m_stateMgr-&gt;
    GetContext()-&gt;m_entityManager;
  PacketType type = (PacketType)l_id;
  if (type == PacketType::Connect){
    sf::Int32 eid;
    sf::Vector2f pos;
    if (!(l_packet &gt;&gt; eid) || !(l_packet &gt;&gt; pos.x) ||
      !(l_packet &gt;&gt; pos.y))
    {
      std::cout &lt;&lt; "Faulty CONNECT response!" &lt;&lt; std::endl;
      return;
    }
    std::cout &lt;&lt; "Adding entity: " &lt;&lt; eid &lt;&lt; std::endl;
    <span class="strong"><strong>m_client-&gt;GetMutex().lock();</strong></span>
    emgr-&gt;AddEntity("Player", eid);
    emgr-&gt;GetComponent&lt;C_Position&gt;
      (eid, Component::Position)-&gt;SetPosition(pos);
    <span class="strong"><strong>m_client-&gt;GetMutex().unlock();</strong></span>
    m_player = eid;
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
     GetSystem&lt;S_Network&gt;(System::Network)-&gt;SetPlayerID(m_player);
    <span class="strong"><strong>emgr-&gt;AddComponent(eid, Component::SoundListener);</strong></span>
    return;
  }

  if (!m_client-&gt;IsConnected()){ return; }
  switch (type){
  case PacketType::Snapshot:
  {
    sf::Int32 entityCount = 0;
    if (!(l_packet &gt;&gt; entityCount)){
      std::cout &lt;&lt; "Snapshot extraction failed."
        &lt;&lt; std::endl;
      return;
    }
    <span class="strong"><strong>sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
    sf::Int32 t = m_client-&gt;GetTime().asMilliseconds();
    for (unsigned int i = 0; i &lt; entityCount; ++i){
      sf::Int32 eid;
      EntitySnapshot snapshot;
      if (!(l_packet &gt;&gt; eid) || !(l_packet &gt;&gt; snapshot)){
        std::cout &lt;&lt; "Snapshot extraction failed."
          &lt;&lt; std::endl;
        return;
      }
      m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
        GetSystem&lt;S_Network&gt;(System::Network)-&gt;
          AddSnapshot(eid, t, snapshot);
    }
    break;
  }
  case PacketType::Disconnect:
  {
    m_stateMgr-&gt;Remove(StateType::Game);
    m_stateMgr-&gt;SwitchTo(StateType::MainMenu);
    std::cout &lt;&lt; "Disconnected by server!" &lt;&lt; std::endl;
    break;
  }
  case PacketType::Hurt:
  {
    EntityId id;
    if (!(l_packet &gt;&gt; id)){ return; }
    Message msg((MessageType)EntityMessage::Hurt);
    msg.m_receiver = id;
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
      GetMessageHandler()-&gt;Dispatch(msg);
    break;
  }
  }
}</pre></div><p>First, we<a id="id697" class="indexterm"/> handle the connect packet that the server sends back to us after the client tries to reach it. If the entity ID and position were successfully extracted from the packet, the client mutex is locked while the player entity is added and its position is updated. The entity ID of our player is then stored in the <code class="literal">m_player</code> data member and passed in to our network system, which needs it. Note the very last line of code in this segment before we return. After the entity is successfully constructed, we're adding in a sound listener component to it. Naturally, there can only be one single sound listener on the client side, which is our player. This means that the <code class="literal">player.entity</code> file <span class="emphasis"><em>does not</em></span> have its own sound listener component anymore. Instead, it must be added here in order to have correct audio positioning.</p><p>Next, if our client is already connected to the server, we're ready to process snapshot, hurt, and disconnect packets. If a snapshot is received, we first attempt to read the number of entities it contains and return if the reading fails. The client mutex is then locked and the current time is obtained in order to maintain continuity of entity snapshots. A new <code class="literal">for</code> loop is then constructed to run for each individual entity in the packet and extract its ID and snapshot data, which in turn is added to the network system for later processing.</p><p>If a disconnect packet is received from the server, we simply remove the game state and switch back to the main menu. Also, upon receiving a hurt packet, the entity ID in it is extracted and a <code class="literal">Hurt</code> message that is to be received by that entity is created and sent out.</p><p>Now, it's time to adjust the existing methods of our game state in order to have it try to establish a connection to the server upon creation:</p><div class="informalexample"><pre class="programlisting">void State_Game::OnCreate(){
  m_client-&gt;Setup(&amp;State_Game::HandlePacket, this);
  if (m_client-&gt;Connect()){
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
      GetSystem&lt;S_Network&gt;(System::Network)-&gt;SetClient(m_client);
    ...
    evMgr-&gt;AddCallback(StateType::Game, "Player_Attack",
      &amp;State_Game::PlayerAttack, this);
    ...
  } else {
    std::cout &lt;&lt; "Failed to connect to the game server!"
      &lt;&lt; std::endl;
    m_stateMgr-&gt;Remove(StateType::Game);
    m_stateMgr-&gt;SwitchTo(StateType::MainMenu);
  }
}</pre></div><p>First, the <a id="id698" class="indexterm"/>client's packet handler is assigned. We then attempt to connect to the server with whatever IP and port information exist inside the client class at this point. If the connection attempt was successful, we can start initializing our data members and add callbacks, one of which is a callback to a new method that handles the player attack button being pressed. If the connection wasn't successful, the game state is removed and we switch back to the main menu state instead.</p><p>If the game state is removed, some cleanup is in order:</p><div class="informalexample"><pre class="programlisting">void State_Game::OnDestroy(){
  m_client-&gt;Disconnect();
  m_client-&gt;UnregisterPacketHandler();
  S_Network* net = m_stateMgr-&gt;GetContext()-&gt;
    m_systemManager-&gt;GetSystem&lt;S_Network&gt;(System::Network);
  net-&gt;ClearSnapshots();
  net-&gt;SetClient(nullptr);
  net-&gt;SetPlayerID((int)Network::NullID);
  ...
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_Attack");
  ...
}</pre></div><p>In addition to the rest of the code that cleans up the game state, we must now also disconnect from the server and unregister the packet handler that is being used by the client class. The network system is also cleared of all snapshots it may currently hold, as well as any player information and pointers to the client class. The player attack callback is also removed here.</p><p>Naturally, we're going to want to alter the <code class="literal">Update</code> method of the game state a little as well:</p><div class="informalexample"><pre class="programlisting">void State_Game::Update(const sf::Time&amp; l_time){
  if (!m_client-&gt;IsConnected()){
    m_stateMgr-&gt;Remove(StateType::Game);
    m_stateMgr-&gt;SwitchTo(StateType::MainMenu);
    return;
  }
  SharedContext* context = m_stateMgr-&gt;GetContext();
  UpdateCamera();
  m_gameMap-&gt;Update(l_time.asSeconds());
  {
    <span class="strong"><strong>sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
    context-&gt;m_systemManager-&gt;Update(l_time.asSeconds());
  }
}</pre></div><p>The<a id="id699" class="indexterm"/> connection status of our client is first checked. Not being connected means we get to exit the game state and switch back to the main menu once again. Otherwise, we continue on with the updating. Note the curly brackets surrounding the system manager update call. They create a scope for any variables defined inside, which is useful for locking the client mutex with a <code class="literal">sf::Lock</code> instance, as it will fall out of scope once we're outside the brackets, in turn unlocking it.</p><p>Drawing things on screen also needs a slight adjustment:</p><div class="informalexample"><pre class="programlisting">void State_Game::Draw(){
  if (!m_gameMap){ return; }
  <span class="strong"><strong>sf::Lock lock(m_client-&gt;GetMutex());</strong></span>
  for (int i = 0; i &lt; Sheet::Num_Layers; ++i){
    m_gameMap-&gt;Draw(i);
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
      Draw(m_stateMgr-&gt;GetContext()-&gt;m_wind, i);
  }
}</pre></div><p>The only addition here is the client mutex lock right before we draw entities on different elevations in a <code class="literal">for</code> loop. We don't want another thread to manipulate any data that we may be currently accessing.</p><p>Lastly, the player attack button being pressed needs to be handled like this:</p><div class="informalexample"><pre class="programlisting">void State_Game::PlayerAttack(EventDetails* l_details){
  Message msg((MessageType)EntityMessage::Attack);
  msg.m_receiver = m_player;
  m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
    GetMessageHandler()-&gt;Dispatch(msg);
}</pre></div><p>It's quite simple. When an attack key is pressed, the entity component system has a new attack message sent to it. Our network system is subscribed to this message type and adds it to the player<a id="id700" class="indexterm"/> update container, which is going to be sent out to the server at a specific interval.</p></div><div class="section" title="Main menu adjustments"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec80"/>Main menu adjustments</h2></div></div></div><p>Our <a id="id701" class="indexterm"/>client-server setup is now functional, but we are missing one more small addition in order to really make it work. We have no way of putting in our server information! Let's fix that by modifying the main menu interface file:</p><div class="informalexample"><pre class="programlisting">Interface MainMenu MainMenu.style 0 0 Immovable NoTitle "Main menu"
Element Label Title 100 0 MainMenuTitle.style "Main menu:"
Element Label IpLabel 0 32 DefaultLabel.style "IP:"
Element TextField IP 18 32 MainMenuTextfield.style "127.0.0.1"
Element Label PortLabel 150 32 DefaultLabel.style "Port:"
Element TextField PORT 175 32 MainMenuTextfield.style "5600"
Element Label NameLabel 50 56 DefaultLabel.style "Nickname:"
Element TextField Nickname 105 56 MainMenuTextfield.style "Player"
Element Label Play 0 80 MainMenuLabel.style "CONNECT"
Element Label Disconnect 0 116 MainMenuLabel.style "DISCONNECT"
Element Label Credits 0 152 MainMenuLabel.style "CREDITS"
Element Label Quit 0 188 MainMenuLabel.style "EXIT"</pre></div><p>Quite a few new elements are added to the main menu here. We have three new text fields and some text labels that go next to them to let the user know what they're for. This is how server information, as well as the player nickname, is going to be entered. Let's make this happen by adding a few callbacks for the new buttons:</p><div class="informalexample"><pre class="programlisting">void State_MainMenu::OnCreate(){
  SetTransparent(true); // Transparent for rendering.
  SetTranscendent(true); // Transcendent for updating.
  ...
  eMgr-&gt;AddCallback(StateType::MainMenu, "MainMenu_Play",
    &amp;State_MainMenu::Play, this);
  eMgr-&gt;AddCallback(StateType::MainMenu, "MainMenu_Disconnect",
    &amp;State_MainMenu::Disconnect, this);
  eMgr-&gt;AddCallback(StateType::MainMenu, "MainMenu_Quit",
    &amp;State_MainMenu::Quit, this);
}

void State_MainMenu::OnDestroy(){
  ...
  gui-&gt;RemoveInterface(StateType::MainMenu, "MainMenu");
  eMgr-&gt;RemoveCallback(StateType::MainMenu, "MainMenu_Play");
  eMgr-&gt;RemoveCallback(StateType::MainMenu,"MainMenu_Disconnect");
  eMgr-&gt;RemoveCallback(StateType::MainMenu, "MainMenu_Quit");
}</pre></div><p>To make<a id="id702" class="indexterm"/> the main menu feel interactive, we're going to want to update this interface each time the menu state is activated:</p><div class="informalexample"><pre class="programlisting">void State_MainMenu::Activate(){
  GUI_Interface* menu = m_stateMgr-&gt;GetContext()-&gt;
    m_guiManager-&gt;GetInterface(StateType::MainMenu, "MainMenu");
  if(m_stateMgr-&gt;HasState(StateType::Game)){
    // Resume
    menu-&gt;GetElement("Play")-&gt;SetText("Resume");
    menu-&gt;GetElement("Disconnect")-&gt;SetActive(true);
    menu-&gt;GetElement("IP")-&gt;SetActive(false);
    menu-&gt;GetElement("PORT")-&gt;SetActive(false);
    menu-&gt;GetElement("IpLabel")-&gt;SetActive(false);
    menu-&gt;GetElement("PortLabel")-&gt;SetActive(false);
    menu-&gt;GetElement("NameLabel")-&gt;SetActive(false);
    menu-&gt;GetElement("Nickname")-&gt;SetActive(false);
  } else {
    // Play
    menu-&gt;GetElement("Play")-&gt;SetText("CONNECT");
    menu-&gt;GetElement("Disconnect")-&gt;SetActive(false);
    menu-&gt;GetElement("IP")-&gt;SetActive(true);
    menu-&gt;GetElement("PORT")-&gt;SetActive(true);
    menu-&gt;GetElement("IpLabel")-&gt;SetActive(true);
    menu-&gt;GetElement("PortLabel")-&gt;SetActive(true);
    menu-&gt;GetElement("NameLabel")-&gt;SetActive(true);
    menu-&gt;GetElement("Nickname")-&gt;SetActive(true);
  }
}</pre></div><p>Depending on whether a game state exists or not, we set up the elements in our interface to reflect the current state of our connection.</p><p>Lastly, let's look at the callback methods of both connect and disconnect buttons:</p><div class="informalexample"><pre class="programlisting">void State_MainMenu::Play(EventDetails* l_details){
  if (!m_stateMgr-&gt;HasState(StateType::Game)){
    GUI_Interface* menu = m_stateMgr-&gt;GetContext()-&gt;
      m_guiManager-&gt;GetInterface(StateType::MainMenu, "MainMenu");
    std::string ip = menu-&gt;GetElement("IP")-&gt;GetText();
    PortNumber port = std::atoi(
      menu-&gt;GetElement("PORT")-&gt;GetText().c_str());
    std::string name = menu-&gt;GetElement("Nickname")-&gt;GetText();
    m_stateMgr-&gt;GetContext()-&gt;m_client-&gt;
      SetServerInformation(ip, port);
    m_stateMgr-&gt;GetContext()-&gt;m_client-&gt;SetPlayerName(name);
  }
  m_stateMgr-&gt;SwitchTo(StateType::Game);
}

void State_MainMenu::Disconnect(EventDetails* l_details){
  m_stateMgr-&gt;GetContext()-&gt;m_client-&gt;Disconnect();
}</pre></div><p>The first <a id="id703" class="indexterm"/>check in the <code class="literal">Play</code> method is made to ensure the text field information is properly passed in to where it needs to go. Because we have the same button that's going to be pressed to both connect to the server and switch back to the game state once it exists, making sure the client instance's server and player name information is updated is important. We then switch to the game state, which could either mean that it has to be created, at which time the information we just passed in is used, or that it's simply brought back to being the dominant application state.</p><p>The disconnect button callback only invokes the client's <code class="literal">Disconnect</code> method, which in turn results to the game state terminating itself.</p><p>With that, we have a fully functional 2D multiplayer game where players can attack one another!</p><div class="mediaobject"><img src="graphics/B04284_14_08.jpg" alt="Main menu adjustments"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec128"/>Summary</h1></div></div></div><p>Congratulations! You have made it to the end! It has been quite a journey to take. With nothing more than some basic tools and concentrated effort, we have managed to create a small world. It may not have that much content in it, but that's where you come in. Just because you are done reading this book doesn't mean that either one of the three projects we covered is finished. In fact, this is only the beginning. Although we have covered a lot, there's still a plethora of features that you can implement on your own, such as different types of enemies, selectable player skins for the last project, magic and ranged attacks, animated map tiles, map transitions for the last project, a chat system, levels and experience for our RPG, and much more. Undoubtedly, you must have your own ideas and mechanics in mind that should instead be brought forth and realized in your games. Don't stop now; keep the flow going and get to coding!</p><p>Thank you so much for reading, and remember that ultimately whatever becomes of the world we created is in your hands, so make it a good one. Goodbye!</p></div></body></html>