- en: Chapter 10. Qt Quick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：Qt Quick
- en: '*In the previous chapter, we introduced you to the basics of Qt Quick and QML.
    By now, you should be fluent enough with the syntax and understand the basic concepts
    of how Qt Quick works. In this chapter, we will show you how to make your games
    stand out from the crowd by introducing different kinds of animations that make
    your applications feel more like the real world. You will also learn to treat
    Qt Quick objects as separate entities programmable using state machines. A large
    section of this chapter is devoted to making your games prettier by using OpenGL
    effects and particle systems. Another significant part of this chapter will introduce
    how to implement a number of important gaming concepts using Qt Quick. All this
    is going to be shown with the building of a simple 2D action game using the presented
    concepts.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在前一章中，我们向您介绍了 Qt Quick 和 QML 的基础知识。到现在，你应该已经足够熟练，能够掌握语法并理解 Qt Quick 的工作基本概念。在本章中，我们将向您展示如何通过引入不同类型的动画，使您的游戏脱颖而出，让您的应用程序感觉更像现实世界。您还将学习如何将
    Qt Quick 对象视为可使用状态机编程的独立实体。本章的大部分内容将致力于通过使用 OpenGL 效果和粒子系统使您的游戏更加美观。本章的另一重要部分将介绍如何使用
    Qt Quick 实现许多重要的游戏概念。所有这些将通过构建一个简单的 2D 动作游戏来展示，该游戏将使用所介绍的概念。*'
- en: Bringing life into static user interfaces
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为静态用户界面注入活力
- en: What we have described so far can be called anything but "fluid." Let's change
    that now by learning how to add some dynamics into the user interfaces we create.
    Thus far, books cannot contain moving pictures, so most things we describe here
    you will have to test yourself by running the provided Qt Quick code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所描述的，根本不能称之为“流畅”。现在，让我们通过学习如何将一些动态效果添加到我们创建的用户界面中来改变这一点。到目前为止，书籍无法包含动态图片，因此，这里描述的大多数内容，你都需要通过运行提供的
    Qt Quick 代码自行测试。
- en: Animating elements
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画元素
- en: Qt Quick provides a very extensive framework for creating animations. By that,
    we don't mean only moving items around. We define an animation as *changing an
    arbitrary value over time*. So, what can we animate? Of course, we can animate
    item geometry. But we can also animate rotation, scale, other numeric values,
    and even colors. But let's not stop here. Qt Quick also lets you animate the parent-child
    hierarchy of items or anchor assignments. Almost anything that can be represented
    by an item property can be animated.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 提供了一个非常广泛的框架来创建动画。我们这里所说的“动画”，并不仅仅是指移动项目。我们定义动画为“随时间改变任意值”。那么，我们可以动画化什么？当然，我们可以动画化项目几何形状。但我们也可以动画化旋转、缩放、其他数值，甚至是颜色。但不要止步于此。Qt
    Quick 还允许你动画化项目的父子层次结构或锚点分配。几乎任何可以用项目属性表示的东西都可以进行动画化。
- en: Moreover, the changes are rarely linear—if you kick a ball in the air, it first
    gains height quickly because its initial speed was large. However, the ball is
    a physical object being pulled down by the Earth's gravity, which slows the climb
    down until the ball stops and then starts falling down, accelerating until it
    hits the ground. Depending on the properties of both the ground and ball, the
    object can bounce off the surface into the air again with less momentum, repeating
    the spring-like motion until eventually it fades away, leaving the ball on the
    ground. Qt Quick lets you model all that using easing curves that can be assigned
    to animations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变化很少是线性的——如果你把球踢向空中，它首先会迅速上升，因为它的初始速度很大。然而，球是一个受到地球重力作用的物理对象，这会减缓上升速度，直到球停止并开始下落，加速直到它触地。根据地面和球体的属性，物体可以弹起再次进入空中，动量减小，重复类似弹簧的运动，直到最终消失，球体落在地面上。Qt
    Quick 允许你使用可以分配给动画的缓动曲线来模拟所有这些。
- en: Generic animations
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用动画
- en: Qt Quick provides a number of animation types derived from a generic `Animation`
    element that you will never use directly. The type exists only to provide an API
    common to different animation types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 提供了从通用的 `Animation` 元素派生出的多种动画类型，你永远不会直接使用它们。这种类型的存在只是为了提供不同动画类型共有的
    API。
- en: Let's take a closer look at the animation framework by looking at a family of
    animation types derived from the most common animation type—`PropertyAnimation`.
    As the name implies, they provide the means to animate values of object properties.
    Despite the fact that you can use the `PropertyAnimation` element directly, it
    is usually more convenient to use one of its subclasses that are specialized in
    dealing with peculiarities of different data types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看从最常见的动画类型`PropertyAnimation`派生的一系列动画类型来更仔细地查看动画框架。正如其名所示，它们提供了动画对象属性值的方法。尽管您可以直接使用`PropertyAnimation`元素，但通常更方便使用其专门处理不同数据类型特性的子类。
- en: 'The most basic property animation type is `NumberAnimation`, which lets you
    animate all kinds of numeric values of both integral and real numbers. The simplest
    way of using it is to declare an animation, tell it to animate a specific property
    in a specific object, and then set the length of the animation and the starting
    and ending value for the property:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的属性动画类型是`NumberAnimation`，它允许您动画化整数和实数的所有数值。使用它的最简单方法是声明一个动画，告诉它在一个特定对象中动画化一个特定的属性，然后设置动画的长度以及属性的起始和结束值：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Time for action – scene for an action game
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 动作游戏的场景
- en: 'Create a new Qt Quick UI project. In the project directory, make a subdirectory
    called `images` and from the game project that we have created using Graphics
    View copy `grass.png`, `sky.png`, and `trees.png`. Then, put the following code
    into the QML document:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Qt Quick UI 项目。在项目目录中，创建一个名为 `images` 的子目录，并从使用 Graphics View 创建的游戏项目中复制
    `grass.png`、`sky.png` 和 `trees.png`。然后，将以下代码放入 QML 文档中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run the project now, you will see a screen similar to this one:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行项目时，你会看到一个类似于这个屏幕的界面：
- en: '![Time for action – scene for an action game](img/8874OS_10_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 动作游戏的场景](img/8874OS_10_01.jpg)'
- en: '*What just happened?*'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We set up a very simple scene consisting of three images stacked up to form
    a landscape. Between the background layer (the sky) and the foreground (trees),
    we placed a yellow circle representing the sun. Since we are going to be moving
    the sun around in a moment, we anchored the center of the object to an empty item
    without physical dimensions so that we can set the sun's position relative to
    its center. We also equipped the scene with a `dayLength` property, which is going
    to hold information about the length of one day of game time. By default, we set
    it to 60 seconds so that things happen really fast and we can see the animation's
    progress without waiting. After all things are set correctly, the length of the
    day can be balanced to fit our needs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个非常简单的场景，由三个图像堆叠形成一幅风景画。在背景层（天空）和前景（树木）之间，我们放置了一个代表太阳的黄色圆圈。由于我们很快就要移动太阳，我们将对象的中心锚定到一个没有物理尺寸的空项目上，这样我们就可以设置太阳相对于其中心的位置。我们还为场景配备了一个`dayLength`属性，它将保存有关游戏时间一天长度的信息。默认情况下，我们将其设置为60秒，这样事情就会发生得非常快，我们可以看到动画的进度而无需等待。在所有事情都设置正确之后，我们可以调整一天的长度以适应我们的需求。
- en: The graphical design lets us easily manipulate the sun while keeping it behind
    the tree line. Notice how the stacking order is implicitly determined by the order
    of elements in the document.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图形设计使我们能够轻松地操作太阳，同时保持它在树线之后。注意堆叠顺序是如何隐式地由文档中元素的顺序决定的。
- en: Time for action – animating the sun's horizontal movement
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 动画太阳的水平运动
- en: The everyday cruise of the sun in the sky starts in the east and continues west
    to hide beneath the horizon in the evening. Let's try to replicate this horizontal
    movement by adding animation to our `sun` object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 太阳在天空中的日常巡航从东方开始，继续向西，直到傍晚时分隐藏在地平线下。让我们通过向我们的`sun`对象添加动画来尝试复制这种水平运动。
- en: 'Open the QML document of our last project. Inside the `root` item add the following
    declaration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们上一个项目的 QML 文档。在`root`项目内部添加以下声明：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the program with such modifications will produce a run with a horizontal
    movement of the sun. The following image is a composition of a number of frames
    of the run:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序进行这样的修改后，将产生一个太阳水平移动的运行效果。以下图像是运行过程中多个帧的组合：
- en: '![Time for action – animating the sun''s horizontal movement](img/8874OS_10_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 动画太阳的水平运动](img/8874OS_10_02.jpg)'
- en: '*What just happened?*'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We introduced a `NumberAnimation` element that is set to animate the `x` property
    of the `sun` object. The animation starts at `0` and lasts until `x` reaches the
    `root` item's width (which is the right edge of the scene). The movement lasts
    for `dayLength` miliseconds. The `running` property of the animation is set to
    `true` to enable the animation. Since we didn't specify otherwise, the motion
    is linear.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个 `NumberAnimation` 元素，该元素被设置为动画化 `sun` 对象的 `x` 属性。动画从 `0` 开始，直到 `x` 达到
    `root` 项的宽度（这是场景的右边缘）。运动持续 `dayLength` 毫秒。动画的 `running` 属性被设置为 `true` 以启用动画。由于我们没有指定其他方式，运动是线性的。
- en: You might be thinking that the animation runs in the wrong direction—"west"
    is on the left and "east" is on the right, yes? That's true, however, only if
    the observer faces north. If that were the case for our scene, we wouldn't be
    seeing the sun at all—at noon, it crosses the south direction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为动画运行的方向是错误的——“西”在左边，“东”在右边，对吧？是的，然而，这只在观察者面向北方时才成立。如果我们的场景是这样的，我们就根本看不到太阳——在中午时分，它会穿过南方方向。
- en: Composing animations
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合动画
- en: The animation we made in the last section looks okay but is not very realistic.
    The sun should rise in the morning, reach its peak sometime before noon, and then
    sometime later start setting toward the evening, when it should cross the horizon
    and hide beneath the landscape.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个部分中制作的动画看起来不错，但并不非常逼真。太阳应该在早上升起，在中午之前达到顶峰，然后稍后开始向傍晚方向落下，此时它应该穿过地平线并隐藏在地形之下。
- en: 'To achieve such an effect, we could add two more animations for the `y` property
    of the sun. The first animation would start right at the beginning and decrease
    the vertical position of the sun (remember that the vertical geometry axis points
    down, so decreasing the vertical position means the object goes up). The animation
    would be complete at one third of the day length. We would then need a way to
    wait for some time and then start a second animation that would pull the object
    down toward the ground. Starting and stopping the animation is easy—we can either
    call the `start()` and `stop()` functions on the animation item or directly alter
    the value of the `running` property. Each `Animation` object emits `started()`
    and `stopped()` signals. The delay can be implemented by using a timer. We could
    provide a signal handler for the stopped signal of the first animation to trigger
    a timer to start the other one like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样的效果，我们可以为太阳的 `y` 属性添加两个额外的动画。第一个动画将从一开始就降低太阳的垂直位置（记住，垂直几何轴指向下方，所以降低垂直位置意味着对象向上移动）。动画将在一天长度的三分之一时完成。然后我们需要一种方法来等待一段时间，然后启动第二个动画，该动画将把对象向下拉向地面。启动和停止动画很容易——我们可以在动画项上调用
    `start()` 和 `stop()` 函数，或者直接更改 `running` 属性的值。每个 `Animation` 对象都会发出 `started()`
    和 `stopped()` 信号。延迟可以通过使用计时器来实现。我们可以为第一个动画的停止信号提供一个信号处理器来触发计时器以启动另一个，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even ignoring any side problems this would bring (for example, how to stop the
    animation without starting the second one), such an approach couldn't be called
    "declarative," could it?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使忽略这可能会带来的任何副作用（例如，如何在启动第二个动画之前停止动画），这样的方法也不能被称为“声明式”，对吧？
- en: 'Fortunately, similar to what we had in C++, Qt Quick lets us form animation
    groups that run either parallel to each other or in sequence. There are the `SequentialAnimation`
    and `ParallelAnimation` types where you can declare any number of child animation
    elements forming the group. To run two animations in parallel, we could declare
    the following hierarchy of elements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，类似于我们在 C++ 中所拥有的，Qt Quick 允许我们形成动画组，这些动画组可以相互并行运行或按顺序运行。这里有 `SequentialAnimation`
    和 `ParallelAnimation` 类型，您可以在其中声明任意数量的子动画元素来形成组。要并行运行两个动画，我们可以声明以下元素层次结构：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The same technique can be used to synchronize a larger group of animations,
    even if each component has a different duration:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以用来同步更大的动画组，即使每个组件的持续时间不同：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The group presented in the snippet consists of three animations. The first
    two animations are executed together as they form a parallel subgroup. One member
    of the group runs twice as long as the other. Only after the whole subgroup completes
    is the third animation started. This can be visualized using a UML activity diagram
    where the size of each activity is proportional to the duration of that activity:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 段落中展示的组由三个动画组成。前两个动画一起执行，因为它们形成一个并行子组。组中的一个成员运行时间是另一个的两倍。只有当整个子组完成之后，第三个动画才开始。这可以通过一个UML活动图来可视化，其中每个活动的尺寸与该活动的持续时间成比例：
- en: '![Composing animations](img/8874OS_10_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![组合动画](img/8874OS_10_03.jpg)'
- en: Time for action – making the sun rise and set
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 – 制作日出日落
- en: Let's add vertical movement (animation of the `y` property) to our sun by adding
    a sequence of animations to the QML document. As our new animations are going
    to be running in parallel to the horizontal animation, we could enclose animations
    for both directions within a single `ParallelAnimation` group. It would work,
    but in our opinion this would unnecessarily clutter the document. Another way
    of specifying parallel animations is to declare them as separate hierarchies of
    elements, making each animation independent of the other, and that is what we
    are going to do here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在QML文档中添加垂直移动（`y`属性的动画）到我们的太阳，通过添加一系列动画来实现。由于我们的新动画将与水平动画并行运行，我们可以将两个方向的动画都包含在一个`ParallelAnimation`组中。这会起作用，但据我们看来，这会不必要地使文档变得杂乱。指定并行动画的另一种方式是将它们声明为独立的元素层次结构，使每个动画独立于其他动画，这正是我们要在这里做的。
- en: 'Open our document from the last exercise and right under the previous animation,
    place the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个练习的文档中打开，在之前的动画下方放置以下代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running the program will result in the light source rising in the morning and
    setting in the evening. However, the trajectory of the move seems somewhat awkward.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序将导致光源在早晨升起，在傍晚落下。然而，移动的轨迹似乎有些笨拙。
- en: '![Time for action – making the sun rise and set](img/8874OS_10_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![动作时间 – 制作日出日落](img/8874OS_10_04.jpg)'
- en: '*What just happened?*'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We declared a sequential animation group consisting of three animations, each
    taking 1/3 of the day length. The first member of the group makes the sun go up.
    The second member, which is an instance of a new element type—`PauseAnimation`—introduces
    a delay equal to its duration. This in turn lets the third component start its
    work in the afternoon to pull the sun down toward the horizon.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个由三个动画组成的顺序动画组，每个动画持续时间为一天长度的1/3。组中的第一个成员使太阳升起。第二个成员，它是一个新元素类型`PauseAnimation`的实例，引入了一个等于其持续时间的延迟。这反过来又让第三个组件在下午开始工作，将太阳拉向地平线。
- en: The problem with such a declaration is that the sun moves in a horribly angular
    way, as can be seen in the image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这样声明的问题在于太阳以极其角度化的方式移动，如图像所示。
- en: Non-linear animations
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非线性动画
- en: The reason for the described problem is that our animations are linear. As we
    noted in the beginning of this chapter, linear animations rarely occur in nature,
    which usually makes their use yield a very unrealistic result.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的问题的原因是我们的动画是线性的。正如我们在本章开头所指出的，线性动画在自然界中很少发生，这通常使得它们的使用产生非常不真实的结果。
- en: 'We also said earlier that Qt Quick allows us to use easing curves to perform
    animations along non-linear paths. There are a large number of curves offered.
    Here is a diagram listing available non-linear easing curves:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前也说过，Qt Quick允许我们使用缓动曲线来执行沿非线性路径的动画。提供了大量的曲线。以下是一个列出可用非线性缓动曲线的图表：
- en: '![Non-linear animations](img/8874OS_10_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![非线性动画](img/8874OS_10_05.jpg)'
- en: You can use any of the curves on an element of the type `PropertyAnimation`
    or one derived from it (for example, `NumberAnimation`). This is done by using
    the `easing` property group, where you can set the `type` of the curve. Different
    curve types may further be tweaked by setting a number of properties in the `easing`
    property group, such as `amplitude` (for bounce and elastic curves), `overshoot`
    (for back curves), or `period` (for elastic curves).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`PropertyAnimation`类型或其派生类型（例如`NumberAnimation`）的元素上使用任何曲线。这是通过使用`easing`属性组来完成的，您可以在其中设置曲线的`type`。不同的曲线类型可以通过在`easing`属性组中设置多个属性进一步调整，例如`amplitude`（用于弹跳和弹性曲线）、`overshoot`（用于回弹曲线）或`period`（用于弹性曲线）。
- en: 'Declaring an animation along an `InOutBounce` path is very easy:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 声明沿`InOutBounce`路径的动画非常简单：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Time for action – improving the path of the sun
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 改善太阳的路径
- en: The task at hand is going to be to improve the animation of the sun so that
    it behaves in a more realistic way. We will do this by adjusting the animations
    so that the object moves over a curved path.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当前任务是要改进太阳的动画，使其表现得更加逼真。我们将通过调整动画，使对象沿着曲线路径移动。
- en: 'In our QML document, replace the previous vertical animation with the following
    one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 QML 文档中，将之前的垂直动画替换为以下动画：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Time for action – improving the path of the sun](img/8874OS_10_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 改善太阳的路径](img/8874OS_10_06.jpg)'
- en: '*What just happened?*'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The sequence of three animations (two linear ones and a pause) was replaced
    by another sequence of two animations that follow a path determined by a cubic
    function. This makes our sun rise pretty fast and then slow down to an amount
    almost unnoticeable near the moment when the sun approaches noon. When the first
    animation is finished, the second one reverses the motion, making the sun descend
    very slowly and then increase its velocity as dusk approaches. As a result, the
    further the sun is away from the ground, the slower it seems to move. At the same
    time, the horizontal animation remains linear as the speed of Earth in its motion
    around the Sun is practically constant. When we combine the horizontal and vertical
    animations, we get a path that looks very similar to what we can observe in the
    real world.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 三个动画序列（两个线性动画和一个暂停）被另一个由三次函数确定的路径的动画序列所取代。这使得我们的太阳升起很快，然后减速到几乎在太阳接近中午时几乎察觉不到的程度。当第一个动画完成后，第二个动画会反转运动，使太阳缓慢下降，然后在黄昏临近时增加速度。因此，太阳离地面越远，它看起来移动得越慢。同时，水平动画保持线性，因为地球在围绕太阳运动的速度实际上是恒定的。当我们结合水平和垂直动画时，我们得到一条看起来非常类似于我们在现实世界中观察到的路径。
- en: Property value sources
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性值来源
- en: From a QML perspective, animation and element types derived from it are something
    called *property value source*. This means they can be attached to a property
    and generate values for it. What is important is that it allows us to use animations
    using a much simpler syntax. Instead of explicitly declaring the target and property
    of an animation, one can attach the animation to a named property of the parent
    object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从 QML 的角度来看，动画及其衍生元素类型被称为 *属性值来源*。这意味着它们可以附加到属性上并为它生成值。重要的是，它允许我们使用更简单的语法来使用动画。不需要显式声明动画的目标和属性，可以将动画附加到父对象的命名属性上。
- en: 'To do this, instead of specifying `target` and `property` for `Animation`,
    use the `on` keyword followed by the name of a property name for which the animation
    is to be a value source. For example, to animate the `rotation` property of an
    object with a `NumberAnimation` object, the following code can be used:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，对于 `Animation`，不要指定 `target` 和 `property`，而是使用 `on` 关键字后跟属性名，该属性名是动画的值来源。例如，要使用
    `NumberAnimation` 对象动画化对象的 `rotation` 属性，可以使用以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is valid to specify more than one property value source for the same property
    of an object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同一个对象的同一属性，指定多个属性值来源是有效的。
- en: Time for action – adjusting the sun's color
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 调整太阳的颜色
- en: If you look at the sun at dusk or dawn, you will see that it is not yellow,
    but rather becomes red the closer it is to the horizon. Let's teach our object
    representing the sun to do the same by providing a property value source for it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你黄昏或黎明时分看太阳，你会发现它不是黄色的，而是越接近地平线就越变成红色。让我们通过为表示太阳的对象提供一个属性值来源来教会它做同样的事情。
- en: 'Open the QML document, find the declaration for the `sunVisual` object, and
    extend it with the highlighted part:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 QML 文档，找到 `sunVisual` 对象的声明，并用下面的高亮部分扩展它：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: An animation was attached to the `color` property of our rectangle modeling
    the visual aspects of the sun. The animation consists of three parts. First, we
    perform a transition from red to yellow using the `ColorAnimation` object. This
    is an `Animation` subtype dedicated to modifying colors. Since the rectangle color
    is not a number, using the `NumberAnimation` object would not have worked as the
    type cannot interpolate color values. Therefore, we either have to use the `PropertyAnimation`
    or `ColorAnimation` object. The duration for the animation is set to 20 percent
    of half the day length so that the yellow color is obtained very quickly. The
    second component is a `PauseAnimation` object to provide a delay before the third
    component is executed, which gradually changes the color back to red. For the
    last component, we do not provide a value for the `from` property. This causes
    the animation to be initiated with the value of the property current to the time
    when the animation is executed (in this case, the sun should be yellow).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个动画附加到了矩形的`color`属性上，以模拟太阳的视觉方面。这个动画由三个部分组成。首先，我们使用`ColorAnimation`对象从红色过渡到黄色。这是一个专门用于修改颜色的`Animation`子类型。由于矩形的颜色不是数字，使用`NumberAnimation`对象将不起作用，因为该类型无法插值颜色值。因此，我们只能使用`PropertyAnimation`或`ColorAnimation`对象。动画的持续时间设置为半日长度的20%，以便黄色能够非常快地获得。第二个组件是一个`PauseAnimation`对象，在执行第三个组件之前提供延迟，该组件逐渐将颜色变回红色。对于最后一个组件，我们没有为`from`属性提供值。这导致动画以动画执行时的属性当前值启动（在这种情况下，太阳应该是黄色的）。
- en: Notice that we only had to specify the property name for the top-level animation.
    This particular element is what serves as the property value source, and all descendant
    animation objects "inherit" the target property from that property value source.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要指定顶级动画的属性名称。这个特定的元素充当属性值源，所有下级动画对象“继承”了目标属性。
- en: Time for action – furnishing sun animation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 装饰太阳动画
- en: The animation of the sun looks almost perfect right now. We can still improve
    it, though. If you look into the sky in the early morning and then again at noon,
    you will notice that the sun appears much bigger during sunrise or sunset compared
    to its size in zenith. We can simulate that effect by scaling the object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前太阳的动画看起来几乎完美。尽管如此，我们仍然可以改进它。如果你在清晨和中午时分观察天空，你会注意到，与太阳在顶点的大小相比，太阳在日出或日落时看起来要大得多。我们可以通过缩放对象来模拟这种效果。
- en: 'In our scene document, add another sequential animation that operates on the
    `scale` property of the sun:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景文档中，添加另一个操作太阳`scale`属性的顺序动画：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Time for action – furnishing sun animation](img/8874OS_10_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 装饰太阳动画](img/8874OS_10_07.jpg)'
- en: '*What just happened?*'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'In this section, we just followed the path set for an earlier declaration—the
    vertical movement of the stellar body influences its perceived size; therefore,
    it seems like a good decision to bind the two animations together. Notice that
    instead of specifying a new property value source for the scale, we might have
    modified the original animation and made the scale animation parallel to that
    operate on the `y` property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只是遵循了早期声明的路径——恒星体的垂直运动影响其感知的大小；因此，将两个动画绑定在一起似乎是一个好决定。注意，我们可能修改了原始动画，并使缩放动画与操作`y`属性的动画并行，而不是为缩放指定一个新的属性值源：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Have a go hero – animating the sun's rays
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 动画太阳光线
- en: 'By now, you should be an animation expert. If you want to try your skills,
    here is a task for you. The following code can be applied to the `sun` object
    and will display very simple red rays emitted from the sun:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经成为一个动画专家。如果你想尝试你的技能，这里有一个任务给你。以下代码可以应用于`sun`对象，并将显示从太阳发出的非常简单的红色光线：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Have a go hero – animating the sun''s rays](img/8874OS_10_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![尝试一下英雄 – 动画太阳光线](img/8874OS_10_08.jpg)'
- en: The goal is to animate the rays so that the overall effect looks good and fits
    the tune like style of the scene. Try different animations—rotations, size changes,
    and colors. Apply them to different elements—all rays at once (for example, using
    the `sunRays` identifier) or only particular rectangles generated by the repeater.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使光线动画看起来整体效果良好，并符合场景的调子风格。尝试不同的动画——旋转、大小变化和颜色。将它们应用于不同的元素——一次所有光线（例如，使用`sunRays`标识符）或仅由重复器生成的特定矩形。
- en: Behaviors
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: In the previous chapter, we implemented a dashboard for a racing game where
    we had a number of clocks with needles. We could set values for each clock (for
    example, car speed) and a respective needle would immediately set itself to the
    given value. But such an approach is unrealistic—in the real world, changes of
    a value happen over time. In our example, the car accelerates from 10 mph to 50
    mph by going through 11 mph, 12 mph and so on, until after some time it reaches
    the desired value. We call this the *behavior* of a value—it is essentially a
    model that tells how the parameter reaches its destined value. Defining such models
    is a perfect use case for declarative programming. Fortunately, QML exposes a
    `Behavior` element that lets us model behaviors of property changes in Qt Quick.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个赛车游戏的仪表盘，其中包含了一些带有指针的时钟。我们可以为每个时钟设置值（例如，汽车速度），相应的指针会立即调整到给定的值。但这种方法在现实中是不现实的——在现实世界中，值的改变是随着时间的推移发生的。在我们的例子中，汽车通过10英里/小时加速到50英里/小时，经过11英里/小时、12英里/小时等等，直到经过一段时间后达到期望的值。我们称这种值为*行为*——它本质上是一个模型，描述了参数如何达到其目标值。定义这样的模型是声明式编程的完美用例。幸运的是，QML公开了一个`行为`元素，它允许我们模拟Qt
    Quick中属性变化的动态行为。
- en: 'The `Behavior` elements let us associate an animation with a given property
    so that, every time the property value is to be changed, it is done by running
    the given animation instead of by making an immediate change to the property value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`行为`元素允许我们将一个动画与一个特定的属性关联起来，这样每次需要改变属性值时，就会通过运行指定的动画来代替直接改变属性值：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code implements a simple scene with a red rectangle anchored
    to an empty item. Whenever the user clicks somewhere within the scene, the empty
    item is moved there, dragging along the rectangle. Let''s see how to use the `Behavior`
    element to smoothly change the position of the empty item. The `Behavior` element
    is a property value source just like the `Animation` element itself; thus, it
    is easiest to use on the on-property syntax:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了一个简单的场景，其中有一个红色矩形被锚定到一个空的项目上。每当用户在场景内点击时，空项目就会移动到那里，并拖动矩形。让我们看看如何使用`行为`元素来平滑地改变空项目的位置。`行为`元素就像`动画`元素本身一样，是一个属性值源；因此，它最容易在属性语法中使用：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By adding the two marked declarations, we define behaviors for properties `x`
    and `y` that follow animations defined by `NumberAnimation`. We do not include
    start or end values for the animation as these will depend on the initial and
    final value for the property. We also don't set the property name in the animation
    because by default, the property for which the behavior is defined will be used.
    As a result, we get a linear animation of a numerical property from the original
    value to the destined value over the default duration.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加两个标记的声明，我们为属性`x`和`y`定义了遵循`NumberAnimation`定义的动画的行为。我们不包括动画的起始或结束值，因为这些将取决于属性的初始和最终值。我们也没有在动画中设置属性名称，因为默认情况下，定义行为所用的属性将被使用。因此，我们得到一个从原始值到目标值的线性数值属性动画，持续时间为默认值。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using linear animations for real world objects rarely looks good. Usually, you
    will get much better results if you set an easing curve for the animation so that
    it starts slowly and then gains speed and decelerates just before it is finished.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界中的对象，使用线性动画通常看起来并不好。通常，如果你为动画设置一个缓动曲线，那么动画会从慢速开始，然后加速，并在完成前减速，这样你会得到更好的结果。
- en: 'Animations that you set on behaviors can be as complex as you want:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在行为上的动画可以像你想要的那样复杂：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The behavioral model declared in the last piece of code performs a sequential
    animation. It first changes the color of the rectangle to yellow using the `PropertyAction`
    element, which performs an immediate update of a property value (we will talk
    about this more a bit later). The color will be set back to red after, as the
    last step of the model. In the meantime, a parallel animation is performed. One
    of its components is a `NumberAnimation` class that executes the actual animation
    of the `x` property of `empty` (since the target and property of the animation
    are not explicitly set). The second component is a sequential animation of the
    `scale` property of the rectangle, which first scales the item up by 50 percent
    during the first half of the animation and then scales it back down in the second
    half of the animation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码中声明的行为模型执行了一个顺序动画。它首先使用 `PropertyAction` 元素将矩形的颜色更改为黄色，该元素执行属性值的即时更新（我们稍后会详细讨论这一点）。然后，在模型的最后一步，颜色将恢复为红色。同时，执行一个并行动画。其中一个组件是
    `NumberAnimation` 类，它执行 `empty` 的 `x` 属性的实际动画（因为动画的目标和属性没有明确设置）。第二个组件是矩形的 `scale`
    属性的顺序动画，它在动画的前半部分将项目放大 50%，然后在动画的后半部分将其缩小回原始大小。
- en: Time for action – animating the car dashboard
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 动画汽车仪表盘
- en: Let's employ the knowledge we just learned to improve our car dashboard so that
    it shows some realism in the way the clocks update their values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用刚刚学到的知识来改进我们的汽车仪表盘，使其在时钟更新值的方式上显示一些逼真性。
- en: 'Open the dashboard project and navigate to the `dashboard.qml` file. Find the
    declaration of the `Needle` object, which is responsible for visualizing the speed
    of the vehicle. Add the following declaration to the object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 打开仪表盘项目并导航到 `dashboard.qml` 文件。找到负责可视化车辆速度的 `Needle` 对象的声明。向该对象添加以下声明：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeat the process for the left clock. Set the velocity of the animation to
    `100`. Build and run the project. See how the needles behave when you modify the
    parameter values in spinboxes. Adjust the `velocity` of each animation until you
    get a realistic result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对左侧的时钟重复此过程。将动画的速度设置为 `100`。构建并运行项目。观察当你在微调框中修改参数值时，指针的行为。调整每个动画的 `velocity`，直到得到逼真的结果。
- en: '*What just happened?*'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have set the property value sources on needle rotations that are triggered
    whenever a new value for the property is requested. Instead of immediately accepting
    the new value, the `Behavior` element intercepts the request and starts the `SmoothedAnimation`
    class to gradually reach the requested value. The `SmoothedAnimation` class is
    an animation type that animates numeric properties. The speed of the animation
    is not determined by its duration, but instead a `velocity` property is set. This
    property dictates how fast a value is to be changed. However, the animation is
    using a non-linear path—it first starts slowly, then accelerates to the given
    velocity and near the end of the animation, decelerates in a smooth fashion. This
    yields an animation that is attractive and realistic and at the same time, is
    of shorter or longer duration, depending on the distance between the starting
    and ending values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在需要请求属性新值的针旋转上设置了属性值源。而不是立即接受新值，`Behavior` 元素拦截请求并启动 `SmoothedAnimation`
    类，以逐渐达到请求的值。`SmoothedAnimation` 类是一种动画类型，它动画化数值属性。动画的速度不由其持续时间决定，而是通过设置一个 `velocity`
    属性。该属性决定了值改变的速度。然而，动画使用的是非线性路径——它首先缓慢开始，然后加速到给定的速度，并在动画接近结束时以平滑的方式减速。这产生了一个既吸引人又逼真的动画，同时，根据起始值和结束值之间的距离，动画的持续时间可以是较短或较长的。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can implement custom property value sources by subclassing `QQmlPropertyValueSource`
    and registering the class in the QML engine.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过继承 `QQmlPropertyValueSource` 并在 QML 引擎中注册该类来实现自定义属性值源。
- en: States and transitions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态和转换
- en: When you look at real world objects, it is often very easy to define their behavior
    by extracting a number of states the object may take and describing each of the
    states separately. A lamp can be turned either on or off. When it is "on" it is
    emitting light of a given color, but it is not doing that when in the "off" state.
    Dynamics of the object can be defined by describing what happens if the object
    leaves one of the states and enters another one. Considering our lamp example,
    if you turn the lamp on, it doesn't momentarily start emitting light with its
    full power, but rather the brightness of the light gradually increases to reach
    its final power after a very short period.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你观察现实世界中的对象时，通常很容易通过提取对象可能采取的几个状态并分别描述每个状态来定义其行为。灯可以开启或关闭。当它“开启”时，它会发出特定颜色的光，但在“关闭”状态下则不会这样做。对象的行为可以通过描述如果对象离开一个状态并进入另一个状态时会发生什么来定义。以我们的灯为例，如果你打开灯，它不会瞬间以全功率发出光，而是亮度逐渐增加，在很短的时间内达到最终功率。
- en: Qt Quick supports *state-driven* development by letting us declare states and
    transitions between them for items. The model fits the declarative nature of Qt
    Quick very well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick通过允许我们声明状态及其之间转换来支持*状态驱动*开发。这种模型非常适合Qt Quick的声明性特性。
- en: 'By default, each item has a single anonymous state and all properties you define
    take values of the expressions you bind or assign to them imperatively based on
    different conditions. Instead of this, a set of states can be defined for the
    object and for each of the state properties of the object itself; in addition,
    the objects defined within it can be programmed with different values or expressions.
    Our example lamp definition could be similar to:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个项目只有一个匿名状态，你定义的所有属性都取绑定或基于不同条件强制分配给它们的表达式的值。相反，可以为对象定义一组状态，以及对象本身的每个状态属性；此外，在其中定义的对象可以用不同的值或表达式进行编程。我们的示例灯定义可能类似于：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could, of course, bind the `color` property of `lightsource` to `lamp.lampOn
    ? "yellow" : "transparent"`, but instead we can define an "on" state for the lamp
    and use a `PropertyChanges` element to modify the rectangle color:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，我们可以将`lightsource`的`color`属性绑定到`lamp.lampOn ? "yellow" : "transparent"`，但相反，我们可以为灯定义一个“开启”状态，并使用`PropertyChanges`元素来修改矩形颜色：'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each item has a `state` property that you can read to get the current state,
    but you can also write to it to trigger transition to a given state. By default,
    the `state` property is set to an empty string that represents the anonymous state.
    Note that with the preceding definition, the item has two states—the "on" state
    and the anonymous state (which in this case is used when the lamp is off). Remember
    that state names have to be unique as the `name` parameter is what identifies
    a state in Qt Quick.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有一个`state`属性，你可以读取它来获取当前状态，但也可以写入它来触发转换到给定状态。默认情况下，`state`属性被设置为空字符串，表示匿名状态。请注意，根据前面的定义，项目有两个状态——“开启”状态和匿名状态（在这种情况下，当灯关闭时使用）。记住，状态名称必须是唯一的，因为`name`参数是用来在Qt
    Quick中标识状态的。
- en: 'To enter a state, we can, of course, use an event handler fired when the value
    of the `lampOn` parameter is modified:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入一个状态，我们当然可以使用一个事件处理器，当`lampOn`参数的值被修改时触发：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Such imperative code works, but it can be replaced with a declarative definition
    in the state itself:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的命令式代码可以工作，但可以在状态本身中用声明性定义替换：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Whenever the expression bound to the `when` property evaluates to `true`, the
    state becomes active. If the expression becomes `false`, the object will return
    to the default state or will enter a state for which its own `when` property evaluates
    to `true`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到`when`属性的表达式评估为`true`时，状态变为活动状态。如果表达式变为`false`，对象将返回默认状态或进入其`when`属性评估为`true`的状态。
- en: 'To define more than one custom state, it is enough to assign a list of state
    definitions to the `states` property:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义多个自定义状态，只需将状态定义列表分配给`states`属性即可：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `PropertyChanges` element is the most often used change in a state definition,
    but it is not the only one. In exactly the same way that the `ParentChange` element
    can assign a different parent to an item and the `AnchorChange` element can update
    anchor definitions, it is also possible to run a script when a state is entered
    using the `StateChangeScript` element. All these element types are used by declaring
    their instances as children in a `State` object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyChanges`元素是在状态定义中最常用的更改，但它不是唯一的。与`ParentChange`元素可以为项目分配不同的父元素以及`AnchorChange`元素可以更新锚定义的方式完全相同，使用`StateChangeScript`元素也可以在状态进入时运行脚本。所有这些元素类型都是通过在`State`对象中将它们的实例作为子元素声明来使用的。'
- en: The second part of the state machine framework is defining how an object transits
    from one state to another. Similar to the `states` property, all items have a
    `transitions` property, which takes a list of definitions represented by the `Transition`
    objects and provides information about animations that should be played when a
    particular transition takes place.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机框架的第二部分是定义一个对象如何从一个状态转换到另一个状态。类似于`states`属性，所有项目都有一个`transitions`属性，它接受一个由`Transition`对象表示的定义列表，并提供有关在特定转换发生时应播放的动画的信息。
- en: A transition is identified by three attributes—the source state, the destination
    state, and a set of animations. Both the source state name (set to the `from`
    property) and the target state name (set to the `to` property) can be empty, in
    which case they should be interpreted as "any". If a `Transition` exists that
    matches the current state change, its animations will be executed. A more concrete
    transition definition (which is one where `from` and/or `to` are explicitly set)
    has precedence over a more generic one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 转换通过三个属性来识别——源状态、目标状态和一组动画。源状态名称（设置为`from`属性）和目标状态名称（设置为`to`属性）都可以为空，在这种情况下，它们应被解释为“任何”。如果存在一个与当前状态更改匹配的`Transition`，则其动画将被执行。一个更具体的转换定义（其中`from`和/或`to`被显式设置）比一个更通用的定义具有优先级。
- en: 'Suppose that we want to animate the opacity of the lamp rectangle from `0`
    to `1` when the lamp is switched on. We can do it as an alternative to manipulating
    the color. Let''s update the lamp definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在灯开启时将灯矩形的透明度从`0`动画到`1`。我们可以作为操作颜色的替代方案来完成它。让我们更新灯的定义：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The transition is triggered for any source and any target state—it will be active
    when the lamp goes from the anonymous to the "on" state, as well as in the opposite
    direction. It defines a single `NumberAnimation` element that lasts for 100 miliseconds.
    The animation does not define the target object nor the property it works on;
    thus, it will be executed for any property and any object that needs updating
    as part of the transition—in the case of the lamp, it will only be the `opacity`
    property of the `lightsource` object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 转换对任何源状态和任何目标状态都会触发——当灯从匿名状态切换到“开启”状态时，它将处于活动状态，以及相反的方向。它定义了一个持续100毫秒的单一`NumberAnimation`元素。动画没有定义目标对象或它所操作的属性；因此，它将为任何属性和任何需要作为转换一部分进行更新的对象执行——在灯的情况下，它将仅是`lightsource`对象的`opacity`属性。
- en: 'If more than one animation is defined in a transition, all animations will
    run in parallel. If you need a sequential animation, you need to explicitly use
    a `SequentialAnimation` element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在转换中定义了多个动画，所有动画将并行运行。如果您需要一个顺序动画，您需要显式使用`SequentialAnimation`元素：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: States are a feature of all `Item` types as well as its descendent types. It
    is, however, possible to use states with elements not derived from the `Item`
    object by using a `StateGroup` element, which is a self-contained functionality
    of states and transitions with exactly the same interface as what is described
    here regarding `Item` objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是所有`Item`类型及其派生类型的一个特性。然而，通过使用`StateGroup`元素，可以与未从`Item`对象派生的元素一起使用状态，这是一个包含状态和转换的自包含功能，具有与这里描述的`Item`对象完全相同的接口。
- en: More animation types
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多动画类型
- en: The animation types we discussed earlier are used for modifying values of types
    that can be described using physical metrics (position, sizes, colors, angles).
    But there are more types available.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的动画类型用于修改可以使用物理度量（位置、大小、颜色、角度）描述的类型值。但还有更多类型可供选择。
- en: The first group of special animations consists of the `AnchorAnimation` and
    `ParentAnimation` elements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组特殊动画包括`AnchorAnimation`和`ParentAnimation`元素。
- en: The `AnchorAnimation` element is useful if a state change should cause a change
    to defined anchors for an item. Without it, the item would immediately snap into
    its place. By using the `AnchorAnimation` element, we trigger all anchor changes
    to be gradually animated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnchorAnimation` 元素在需要状态改变导致项目定义锚点发生变化时非常有用。没有它，项目会立即跳到其位置。通过使用 `AnchorAnimation`
    元素，我们可以触发所有锚点变化逐渐动画化。'
- en: The `ParentAnimation` element, on the other hand, makes it possible to define
    animations that should be present when an item receives a new parent. This usually
    causes an item to be moved to a different position in the scene. By using the
    `ParentAnimation` element in a state transition, we can define how the item gets
    into its target position. The element can contain any number of child animation
    elements that are going to be run in parallel during a `ParentChange` element.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ParentAnimation` 元素使得在项目获得新的父元素时定义动画成为可能。这通常会导致项目在场景中移动到不同的位置。通过在状态转换中使用
    `ParentAnimation` 元素，我们可以定义项目如何进入其目标位置。该元素可以包含任意数量的子动画元素，这些元素将在 `ParentChange`
    元素执行期间并行运行。
- en: The second special group of animations is action animations—`PropertyAction`
    and `ScriptAction`. These animation types are not stretched in time, but rather
    perform a given one-time action.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组特殊的动画是动作动画——`PropertyAction` 和 `ScriptAction`。这些动画类型不会在时间上拉伸，而是执行一次性的给定动作。
- en: The `PropertyAction` element is a special kind of animation that performs an
    immediate update of a property to a given value. It is usually used as part of
    a more complex animation to modify a property that is not animated. It makes sense
    to use it if a property needs to have a certain value during an animation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyAction` 元素是一种特殊的动画，它将属性立即更新到给定的值。它通常用作更复杂动画的一部分，以修改未动画化的属性。如果属性需要在动画期间具有某个特定值，则使用它是有意义的。'
- en: The `ScriptAction` is an element that allows the execution of an imperative
    piece of code during an animation (usually at its beginning or end).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptAction` 是一个元素，允许在动画期间（通常在开始或结束时）执行命令式代码片段。'
- en: Quick game programming
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速游戏编程
- en: Here, we will go through the process of creating a platform game using Qt Quick.
    It will be a game similar to Benjamin the Elephant from [Chapter 6](ch06.html
    "Chapter 6. Graphics View"), *Graphics View*. The player will control a character
    that will be walking through the landscape and collecting coins. The coins will
    randomly be appearing in the world. The character can access highly placed coins
    by jumping. The more the character jumps, the more tired he gets and the slower
    he begins to move and has to rest to regain speed. To make the game more difficult,
    at times moving obstacles will be generated. When the character bumps into any
    of them, he gets more and more tired. When the fatigue exceeds a certain level,
    the character dies and the game ends.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过使用 Qt Quick 创建一个平台游戏的过程。它将是一款类似于第 6 章[图形视图](ch06.html "第 6 章。图形视图")中的本杰明大象的游戏。玩家将控制一个角色，该角色将在景观中行走并收集金币。金币将随机出现在世界中。角色可以通过跳跃来获取放置在高处的金币。角色跳得越多，就越累，开始移动得越慢，并且需要休息以恢复速度。为了使游戏更具挑战性，有时会生成移动障碍。当角色撞到任何障碍时，他会变得越来越累。当疲劳超过一定水平时，角色就会死亡，游戏结束。
- en: Throughout this chapter as well as the previous one, we prepared a number of
    pieces we will be reusing for this game. The layered scene that was arranged when
    you learned about animations will serve as our game scene. The animated sun is
    going to represent the passing of time. When the sun sets, the time runs out and
    the game ends. The heartbeat diagram will be used to represent the character's
    level of fatigue—the more tired the character gets, the faster his heart beats.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及上一章中，我们为这个游戏准备了一些将重新使用的组件。当你学习动画时安排的分层场景将作为我们的游戏场景。动画太阳将代表时间的流逝。当太阳落山时，时间耗尽，游戏结束。心跳图将用来表示角色的疲劳程度——角色越累，心跳越快。
- en: There are many ways this game can be implemented and we want to give you a level
    of freedom, so this is not going to be a step-by-step guide on how to implement
    a complete game. At some points, we will be telling you to employ some skills
    you have already learned to perform some task without telling you how to do it.
    At others, we will provide broad descriptions and complete solutions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏可以以多种方式实现，我们希望给你一定的自由度，所以这不会是一个逐步指导如何实现完整游戏的指南。在某些时候，我们会告诉你使用你已经学到的技能来完成某些任务，而不会告诉你如何做。在其他时候，我们会提供广泛的描述和完整的解决方案。
- en: Game loops
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: Most games revolve around some kind of game loop. It is usually some kind of
    function that is repeatedly called at constant intervals and its task is to progress
    the game—process input events, move objects around, calculate and execute actions,
    check win conditions, and so on. Such an approach is very imperative and usually
    results in a very complex function that needs to know everything about everybody
    (This kind of anti-pattern is sometimes called a *god object* pattern). In QML
    (which powers the Qt Quick framework), we aim to separate responsibilities and
    declare well-defined behaviors for particular objects. Therefore, although it
    is possible to set up a timer which will periodically call a game loop function,
    this is not the best possible approach in a declarative world.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都围绕某种游戏循环展开。这通常是一种在固定间隔重复调用的函数，其任务是推进游戏——处理输入事件，移动对象，计算和执行动作，检查胜利条件等等。这种方法非常命令式，通常会导致一个非常复杂的函数，需要了解每个人的所有信息（这种反模式有时被称为*神对象*模式）。在QML（为Qt
    Quick框架提供动力）中，我们旨在分离责任并为特定对象声明定义良好的行为。因此，尽管可以设置一个计时器，定期调用游戏循环函数，但这在声明式世界中并不是最佳方法。
- en: Instead, we suggest using a natural time-flow mechanism already present in Qt
    Quick—one that controls the consistency of animations. Remember how we defined
    the sun's travel across the sky at the beginning of this chapter? Instead of setting
    up a timer and moving the object by a calculated number of pixels, we created
    an animation, defined a total running time for it, and let Qt take care of updating
    the object. This has the great benefit of neglecting delays in function execution.
    If you used a timer and some external event introduced a significant delay before
    the timeout function was run, the animation would start lagging behind. When Qt
    Quick animations are used, the framework compensates for such delays, skipping
    some of the frame updates to ensure that the requested animation duration is respected.
    Thanks to that, you will not have to take care of it all by yourself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们建议使用Qt Quick中已经存在的自然时间流动机制——该机制控制动画的一致性。还记得我们在本章开头定义太阳在天空中移动的方式吗？我们不是通过设置计时器和移动对象一定数量的像素来设置，而是创建了一个动画，为它定义了总运行时间，并让Qt负责更新对象。这有一个很大的好处，就是忽略了函数执行中的延迟。如果你使用计时器，而某些外部事件在超时函数运行之前引入了显著的延迟，动画就会开始落后。当使用Qt
    Quick动画时，框架会补偿这些延迟，跳过一些帧更新，以确保尊重请求的动画持续时间。因此，你不必自己处理这一切。
- en: To overcome the second difficult aspect of a game loop—the god anti-pattern—we
    suggest encapsulating the logic of each item directly in the item itself the using
    states and transitions framework we introduced earlier. If you define an object
    using a natural time flow describing all states it can enter during its lifetime
    and actions causing transitions between states, you will be able to just plop
    the object with its included behavior wherever it is needed and thus easily reuse
    such definitions in different games, reducing the amount of work necessary to
    make the object fit into the game.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服游戏循环的第二个难题——神反模式，我们建议将每个项目的逻辑直接封装在项目本身中，使用我们之前介绍的状态和转换框架。如果你定义一个对象，使用自然的时间流动描述它在生命周期中可以进入的所有状态以及导致状态转换的动作，你将能够将包含行为的对象随意放置在任何需要的地方，从而在不同的游戏中轻松重用这些定义，减少使对象适应游戏所需的工作量。
- en: 'As for input event processing, a usual approach in games is to read input events
    and call functions responsible for actions associated with particular events:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 至于输入事件处理，在游戏中常用的方法是从输入事件中读取事件并调用与特定事件相关的动作负责的函数：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This, however, has its drawbacks, one of which is the need to check events at
    even periods of time. This might be hard and certainly is not a declarative approach.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有其缺点，其中之一是需要检查事件在均匀的时间间隔。这可能很困难，肯定不是一种声明式方法。
- en: We already know that Qt Quick handles keyboard input via the `Keys` attached
    property. It is possible to craft QML code similar to the one just presented,
    but the problem with such an approach is that the faster the player taps keys
    on the keyboard, the more frequently the character will move, jump, or shoot.
    It isn't hard if it is done properly, though.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Qt Quick通过`Keys`附加属性来处理键盘输入。可以编写类似于刚才展示的QML代码，但这种方法的问题在于，玩家在键盘上按得越快，角色移动、跳跃或射击的频率就越高。如果做得恰当，这并不困难。
- en: Time for action – character navigation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 角色导航
- en: 'Create a new QML document and call it `Player.qml`. In the document, place
    the following declarations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的QML文档，并将其命名为`Player.qml`。在文档中，放置以下声明：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, open the document containing the main scene definition and declare the
    player character near the end of the document after all the background layers
    are declared:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开包含主场景定义的文档，并在所有背景层定义之后，在文档末尾声明玩家角色：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*What just happened?*'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The player itself is an empty item with a keyboard focus that handles presses
    of the right, left, and up arrow keys, causing them to manipulate the `x` and
    `y` coordinates of the player. The `x` property has a `Behavior` element set so
    that the player moves smoothly within the scene. Finally, anchored to the player
    item is the actual visualization of the player—our elephant friend.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家本身是一个带有键盘焦点的空项目，它处理右箭头、左箭头和上箭头的按键，使它们能够操纵玩家的`x`和`y`坐标。`x`属性设置了一个`Behavior`元素，以便玩家在场景内平滑移动。最后，与玩家项目锚定的是玩家实际的可视化——我们的象朋友。
- en: When the right or left arrow keys are pressed, a new position for the character
    will be calculated and applied. Thanks to the `Behavior` element, the item will
    travel gradually (during one second) to the new position. Keeping the key pressed
    will trigger auto-repeat and the handler will be called again. In a similar fashion,
    when the spacebar is pressed, it will activate a prepared sequential animation
    that will lift the character up by 50 pixels and then move it down again to the
    initial position.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下右箭头或左箭头键时，将计算并应用角色的新位置。多亏了`Behavior`元素，项目将逐渐（在一秒内）移动到新位置。保持按键将触发自动重复，处理程序将被再次调用。以类似的方式，当按下空格键时，它将激活一个准备好的顺序动画，将角色向上提升50像素，然后再次将其移回到初始位置。
- en: This approach works but we can do better. Let's try something different.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但我们能做得更好。让我们尝试不同的方法。
- en: Time for action – another approach to character navigation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 另一种角色导航方法
- en: 'Replace the previous key handlers with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换先前的键处理程序：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*What just happened?*'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Instead of performing actions immediately, upon pressing a key, we are now setting
    flags (in a private object) for which direction the character should be moving
    in. In our situation, the right direction has priority over the left direction.
    Setting a flag triggers an animation that tries to move the character toward an
    edge of the scene. Releasing the button will clear the flag and stop the animation.
    Before the animation is started, we are calling the `recalculateDurations()` function,
    which checks how long the animation should last for the character to move at the
    desired speed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在按下键时不是立即执行动作，而是设置（在私有对象中）表示角色应移动方向的标志。在我们的情况下，右方向优先于左方向。设置标志会触发一个尝试将角色移动到场景边缘的动画。释放按钮将清除标志并停止动画。在动画开始之前，我们调用`recalculateDurations()`函数，该函数检查动画应该持续多长时间，以便角色以期望的速度移动。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to replace keyboard-based input with something else, for example,
    accelerometer or custom buttons, the same principle can be applied. When using
    an accelerometer, you can even control the speed of the player by measuring how
    much the device is tilted. You can addtionally store the tilt in the `flags.horizontal`
    parameter and make use of that variable in the `recalculateDurations()` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用其他方式替换基于键盘的输入，例如加速度计或自定义按钮，可以应用相同的原则。当使用加速度计时，你甚至可以通过测量设备倾斜的程度来控制玩家的速度。你还可以将倾斜存储在`flags.horizontal`参数中，并在`recalculateDurations()`函数中使用该变量。
- en: Have a go hero – polishing the animation
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试 - 完善动画
- en: What we have done is sufficient for many applications. However, you can try
    controlling the movement even more. As a challenge, try modifying the system in
    such a way that during a jump, inertia keeps the current horizontal direction
    and speed of movement of the character until the end of the jump. If the player
    releases the right or left keys during a jump, the character will stop only after
    the jump is complete.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是许多应用所必需的。然而，你可以尝试控制移动得更加精细。作为一个挑战，尝试修改系统，使得在跳跃过程中，惯性保持角色的当前水平方向和移动速度直到跳跃结束。如果玩家在跳跃过程中释放左右键，角色将只在跳跃完成后停止。
- en: Despite trying to do everything in a declarative fashion, some actions will
    still require imperative code. If some action is to be executed periodically,
    you can use the `Timer` parameter to execute a function on demand. Let's go through
    the process of implementing such patterns together.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们试图以声明性方式完成所有事情，但仍然需要一些命令式代码。如果某些操作需要定期执行，你可以使用 `Timer` 参数按需执行函数。让我们一起来完成这样的模式实现过程。
- en: Time for action – generating coins
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——生成硬币
- en: The goal of the game we are trying to implement is to collect coins. We will
    spawn coins now and then in random locations of the scene.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现的游戏的目的是收集硬币。我们现在将在场景的随机位置生成硬币。
- en: 'Create a new QML Document and call it `Coin.qml`. In the editor, enter the
    following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 QML 文档，并将其命名为 `Coin.qml`。在编辑器中，输入以下代码：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, open the document where the scene is defined and enter the following
    code somewhere in the scene definition:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开定义场景的文档，并在场景定义的某个地方输入以下代码：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: First, we defined a new element type, `Coin`, consisting of a yellow circle
    with a number centered over an empty item. The rectangle has an animation applied
    that rotates the item around a vertical axis, resulting in a pseudo three-dimensional
    effect.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个新的元素类型，`Coin`，它由一个黄色圆圈组成，圆圈中心有一个数字覆盖在一个空的项目上。矩形应用了一个动画，使项目围绕垂直轴旋转，从而产生一个伪三维效果。
- en: Next, a component able to create instances of a `Coin` element is placed in
    the scene. Then, a `Timer` element is declared that fires every second and spawns
    a new coin at a random location of the scene.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将能够创建 `Coin` 元素实例的组件放置在场景中。然后，声明一个每秒触发一次的 `Timer` 元素，在场景的随机位置生成一个新的硬币。
- en: Sprite animation
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵动画
- en: The player character, as well as any other component of the game, should be
    animated. If the component is implemented using simple Qt Quick shapes, it is
    quite easy to do by changing the item's properties fluently, by way of using property
    animations (like we did with the `Coin` object). Things get more difficult if
    a component is complex enough that it is easier to draw it in a graphics program
    and use an image in the game instead of trying to recreate the object using Qt
    Quick items. Then, one needs a number of images—one for every frame of animation.
    Images would have to keep replacing one another to make a convincing animation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色以及游戏的任何其他组件都应该被动画化。如果组件使用简单的 Qt Quick 形状实现，通过流畅地更改项目的属性，使用属性动画（就像我们在 `Coin`
    对象中所做的那样）来做这件事相当容易。如果组件足够复杂，以至于在图形程序中绘制它并使用游戏中的图像比尝试使用 Qt Quick 项目重新创建对象更容易，那么就需要一系列图像——每帧动画一个。为了制作令人信服的动画，图像必须不断相互替换。
- en: Time for action – implementing simple character animation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——实现简单的角色动画
- en: Let's try to make the player character animated in a simple way. In materials
    that come with this book, you will find a number of images with different walking
    phases for Benjamin the Elephant. You can use them or you can draw or download
    some other images to be used in place of those provided by us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以简单的方式使玩家角色动画化。在本书附带的材料中，你会找到一些不同行走阶段的 Benjamin 大象的图像。你可以使用它们，或者你可以绘制或下载一些其他图像来替换我们提供的图像。
- en: Put all images in one directory (for example, `images`) and rename them so that
    they follow a pattern that contains the base animation name followed by a frame
    number, for example, `walking_01`, `walking_02`, `walking_03`, and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有图像放在一个目录中（例如，`images`），并将它们重命名，使它们遵循包含基本动画名称后跟帧编号的图案，例如，`walking_01`、`walking_02`、`walking_03`，依此类推。
- en: 'Next, open the `Player.qml` document and replace the image element showing
    "`elephant.png`" with the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `Player.qml` 文档，将显示 "`elephant.png`" 的图像元素替换为以下代码：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the root element of `Player.qml`, add the following properties:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Player.qml` 的根元素中添加以下属性：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Start the program and use the arrow keys to see Benjamin move.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 启动程序并使用箭头键查看本杰明移动。
- en: '*What just happened?*'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: A number of images were prepared following a common naming pattern containing
    a number. All the images have the same size. This allows us to replace one image
    with another just by changing the value of the `source` property to point to a
    different image. To make it easier, we introduced a property called the `currentFrame`
    element that contains the index of the image to be displayed. We used the `currentFrame`
    element in a string forming an expression bound to the `source` element of the
    image. To make substituting frames easy, a `NumberAnimation` element was declared
    to modify values of the `currentFrame` element in a loop from `1` to the number
    of animation frames available (represented by the `frameCount` property), so that
    each frame is shown for 40 miliseconds. The animation is playing if the `walking`
    property evaluates to `true` (based on the value of the `flags.horizontal` element
    in the player object). Finally, we use the `mirror` property of the `Image` parameter
    to flip the image if the character is walking left.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 准备了一系列图像，遵循一个包含数字的通用命名模式。所有图像都具有相同的大小。这使得我们只需通过更改`source`属性的值来指向不同的图像，就可以用另一个图像替换一个图像。为了简化操作，我们引入了一个名为`currentFrame`的属性，它包含要显示的图像的索引。我们使用`currentFrame`元素在一个字符串表达式中绑定到图像的`source`元素。为了使帧替换更容易，我们声明了一个`NumberAnimation`元素，在循环中从`1`到可用的动画帧数（由`frameCount`属性表示）修改`currentFrame`元素的值，这样每帧就会显示40毫秒。如果`walking`属性评估为`true`（基于玩家对象中的`flags.horizontal`元素的值），则动画正在播放。最后，我们使用`Image`参数的`mirror`属性在角色向左行走时翻转图像。
- en: The preceding approach works, but is not perfect. The complexity of the declaration
    following this pattern grows much faster than required when we want to make movement
    animation more complex (for example, if we want to introduce jumping). This is
    not the only problem, though. Loading images does not happen instantly. The first
    time a particular image is to be used, the animation can stall for a moment while
    the graphics get loaded, which might ruin the user experience. Lastly, it is simply
    messy to have a bunch of pictures here and there for every image animation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法可行，但并不完美。当我们想要使运动动画更复杂（例如，如果我们想要引入跳跃）时，遵循此模式的声明复杂性增长速度远快于所需。但这并不是唯一的问题。加载图像并不立即发生。第一次使用某个特定图像时，动画可能会因为图形加载而暂停片刻，这可能会破坏用户体验。最后，对于每个图像动画，这里那里放一堆图片实在太过杂乱。
- en: A solution to this is to use **sprites**—geometrical animated objects consisting
    of small images combined into one larger image for better performance. Qt Quick
    supports sprites through its sprite engine that handles loading sequences of images
    from a sprite field, animating them and transitioning between different sprites.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用**精灵**——由小图像组合成的一个大图像的几何动画对象，这样可以提高性能。Qt Quick通过其精灵引擎支持精灵，该引擎负责从精灵字段中加载图像序列，对它们进行动画处理，并在不同的精灵之间进行转换。
- en: 'In Qt Quick, a sprite is an image of any type supported by Qt that contains
    an image strip with all frames of the animation. Subsequent frames should form
    a contiguous line flowing from left to right and from top to bottom of the image.
    However, they do not have to start in the top-left corner of the containing image,
    nor do they have to end in its bottom-right corner—a single file can contain many
    sprites. A sprite is defined by providing the size of a single frame in pixels
    and a frame count. Optionally, one can specify an offset from the top-left corner
    where the first frame of the sprite is to be read from. The following diagram
    can be helpful in visualizing the scheme:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中，精灵是Qt支持的任何类型的图像，它包含包含动画所有帧的图像条。后续帧应形成一个从左到右、从上到下连续的线条。然而，它们不必从包含图像的左上角开始，也不必在右下角结束——一个文件可以包含多个精灵。精灵通过提供单个帧的大小（以像素为单位）和帧数来定义。可选地，可以指定一个偏移量，从该偏移量读取精灵的第一个帧，该偏移量从左上角开始。以下图表可以帮助可视化该方案：
- en: '![What just happened?](img/8874OS_10_09.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_10_09.jpg)'
- en: QML offers a `Sprite` element type with a `source` property pointing to the
    URL of the container image, a `frameWidth` and `frameHeight` element determining
    the size of each frame, and a `frameCount` element defining the number of frames
    in the sprite. Offsetting the image can be achieved by setting values of the `frameX`
    and `frameY` properties. In addition to this, some additional properties are present;
    the most important three are `frameRate`, `frameDuration,` and `duration`. All
    these serve to determine the pace of the animation. If the `frameRate` element
    is defined, it is interpreted as a number of frames to cycle through per second.
    If this property is not defined, then the `frameDuration` element kicks in and
    is treated as a period of time in which to display a single frame (thus, it is
    directly an inverse of the `frameRate` element). If this property is not defined,
    as well, the `duration` element is used, which carries the duration of the whole
    animation. You can set any of the three properties, and precedence rules (`frameRate`,
    `frameDuration`, `duration`) will determine which of them are going to be applied.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: QML 提供了一个 `Sprite` 元素类型，它有一个 `source` 属性，指向容器图像的 URL，一个 `frameWidth` 和 `frameHeight`
    元素确定每帧的大小，以及一个 `frameCount` 元素定义精灵中的帧数。通过设置 `frameX` 和 `frameY` 属性的值可以偏移图像。除此之外，还有一些额外的属性；其中最重要的三个是
    `frameRate`、`frameDuration` 和 `duration`。所有这些属性都用于确定动画的速度。如果定义了 `frameRate` 元素，它被解释为每秒循环的帧数。如果没有定义此属性，则
    `frameDuration` 元素生效，它被视为显示单帧的时间段（因此，它是 `frameRate` 元素的倒数）。如果没有定义此属性，则使用 `duration`
    元素，它包含整个动画的持续时间。你可以设置这三个属性中的任何一个，优先级规则（`frameRate`、`frameDuration`、`duration`）将决定哪些属性将被应用。
- en: Time for action – animating characters using sprites
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用精灵来动画化角色
- en: Let's wait no further. The task at hand is to replace the manual animation from
    the previous exercise with a sprite-based animation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再等待。当前的任务是将之前练习中的手动动画替换为基于精灵的动画。
- en: 'Open the `Player.qml` document, remove the whole image element responsible
    for displaying the player character:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Player.qml` 文档，移除负责显示玩家角色的整个图像元素：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*What just happened?*'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have replaced the previous static image with an ever-changing source with
    a different item. As the `Sprite` parameter is not an `Item` element but rather
    a data definition of a sprite, we cannot use it in place of the `Image` element.
    Instead, we will use the `AnimatedSprite` element, which is an item that can display
    a single animated sprite defined inline. It even has the same set of properties
    as the `Sprite` parameter. We defined a sprite embedded in `images/walking.png`
    with a width of `80` and a height of `52` pixels. The sprite consists of seven
    frames that should be displayed at a rate of 10 frames per second. The `running`
    property is set up similar to the original `Animation` element. As the `AnimatedSprite`
    element does not have a `mirror` property, we emulate it by applying a scale transformation
    that flips the item horizontally if the `player.facingLeft` element evaluates
    to `true`. Additionally, we set the `interpolate` property to `true`, which makes
    the sprite engine calculate smoother transitions between frames.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将之前的静态图像替换为不断变化的源，使用不同的项目。由于 `Sprite` 参数不是一个 `Item` 元素，而是一个精灵的数据定义，我们无法将其用作
    `Image` 元素的替代。相反，我们将使用 `AnimatedSprite` 元素，这是一个可以显示单个内联定义的动画精灵的项目。它甚至具有与 `Sprite`
    参数相同的属性集。我们定义了一个嵌入在 `images/walking.png` 中的精灵，宽度为 `80` 像素，高度为 `52` 像素。该精灵由七个帧组成，应以每秒
    10 帧的速度显示。`running` 属性的设置类似于原始的 `Animation` 元素。由于 `AnimatedSprite` 元素没有 `mirror`
    属性，我们通过应用一个水平翻转项目的缩放变换来模拟它，如果 `player.facingLeft` 元素评估为 `true`。此外，我们设置 `interpolate`
    属性为 `true`，这使得精灵引擎计算帧之间的更平滑的过渡。
- en: The result we are left with is similar to an earlier attempt, so if these two
    are similar then why bother using sprites? In many situations, you want more complex
    animation than just a single frame sequence. What if we want to animate the way
    Benjamin jumps in addition to him walking? Embedding more manual animations, although
    possible, would explode the number of internal variables required to keep the
    state of the object. Fortunately, the Qt Quick sprite engine can deal with that.
    The `AnimatedSprite` element we used provides just a subset of features of the
    whole framework. By substituting the item with the `SpriteSequence` element we
    gain access to the full power of sprites. In talking about `Sprite`, we didn't
    tell you about one additional property of the object, a property called `to` that
    contains a map of probabilities of transitioning from the current sprite to another
    one. By stating which sprites the current one migrates to, we create a state machine
    with weighted transitions to other sprites, as well as cycling back to the current
    state.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下的结果是类似于早期尝试的结果，所以如果这两个相似，为什么还要使用精灵呢？在许多情况下，你想要的动画比单个帧序列更复杂。如果我们想动画化 Benjamin
    跳跃的方式，除了他走路之外呢？虽然可能嵌入更多的手动动画，但这会爆炸性地增加保持对象状态所需的内部变量数量。幸运的是，Qt Quick 精灵引擎可以处理这种情况。我们使用的
    `AnimatedSprite` 元素只提供了整个框架功能的一个子集。通过用 `SpriteSequence` 元素替换项目，我们获得了精灵的全部功能。在谈论
    `Sprite` 时，我们没有告诉你对象的一个附加属性，即名为 `to` 的属性，它包含从当前精灵到另一个精灵的转换概率映射。通过声明当前精灵迁移到的精灵，我们创建了一个具有加权转换到其他精灵的状态机，以及循环回当前状态。
- en: Transitioning to another sprite is triggered by setting the `goalSprite` property
    on the `SpriteSequence` object. This will cause the sprite engine to traverse
    the graph until it reaches the requested state. It is a great way to fluently
    switch from one animation to another by going through a number of intermediate
    states.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `SpriteSequence` 对象上设置 `goalSprite` 属性来触发过渡到另一个精灵。这将导致精灵引擎遍历图直到达到请求的状态。这是一种通过经过多个中间状态来流畅地从一个动画切换到另一个动画的绝佳方式。
- en: Instead of asking the sprite machine to gracefully transit to a given state,
    one can ask it to force an immediate change by calling the `SpriteSequence` class's
    `jumpTo()` method and feeding it with the name of the sprite that should start
    playing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是要求精灵机优雅地过渡到某个给定状态，可以通过调用 `SpriteSequence` 类的 `jumpTo()` 方法并传入应开始播放的精灵名称来强制立即更改。
- en: The last thing that needs to be clarified is how to actually attach the sprite
    state machine to the `SpriteSequence` class. It is very easy; just assign an array
    of the `Sprite` objects to the `sprites` property.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 需要澄清的最后一件事是如何将精灵状态机实际附加到 `SpriteSequence` 类。这非常简单；只需将 `Sprite` 对象数组分配给 `sprites`
    属性。
- en: Time for action – adding jumping with sprite transitions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加带有精灵转换的跳跃
- en: Let's replace the `AnimatedSprite` class with the `SpriteSequence` class in
    the Bejamin the Elephant animation, adding a sprite to be played during the jumping
    phase.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Benjamin the Elephant 动画中将 `AnimatedSprite` 类替换为 `SpriteSequence` 类，添加一个在跳跃阶段要播放的精灵。
- en: 'Open the `Player.qml` file and replace the `AnimatedSprite` object with the
    following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Player.qml` 文件，并用以下代码替换 `AnimatedSprite` 对象：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, extend the `jumpAnim` object by adding the highlighted changes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过添加以下高亮更改来扩展 `jumpAnim` 对象：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*What just happened?*'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: '`The SpriteSequence` element we have introduced has its `Item` elements-related
    properties set up in the same way as when the `AnimatedSprite` element was used.
    Apart from that, a sprite called "still" was explicitly set as the current one.
    We defined a number of `Sprite` objects as children of the `SpriteSequence` element.
    This is equivalent to assigning those sprites to the `sprites` property of the
    object. The complete state machine that was declared is presented in the following
    diagram:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所介绍的 `The SpriteSequence` 元素，其 `Item` 元素相关的属性设置方式与使用 `AnimatedSprite` 元素时相同。除此之外，一个名为
    "still" 的精灵被明确设置为当前精灵。我们定义了一系列 `Sprite` 对象作为 `SpriteSequence` 元素的子元素。这相当于将这些精灵分配给对象的
    `sprites` 属性。所声明的完整状态机在以下图中展示：
- en: '![What just happened?](img/8874OS_10_10.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_10_10.jpg)'
- en: A sprite called "still" has just a single frame representing a situation when
    Benjamin doesn't move. The sprite keeps spinning in the same state due to the
    weighted transition back to the "still" state. The two remaining transitions from
    that state have their weights set to `0`, which means they will never trigger
    spontaneously, but they can be invoked by setting the `goalSprite` property to
    a sprite that can be reached by activating one of those transitions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 "still" 的精灵仅有一个帧，代表本杰明不动的情景。由于加权转换回 "still" 状态，该精灵保持旋转在相同的状态。从该状态剩余的两个转换的权重被设置为
    `0`，这意味着它们永远不会自发触发，但可以通过将 `goalSprite` 属性设置为可以通过激活这些转换之一到达的精灵来调用。
- en: The sequential animation was extended to trigger sprite changes when the elephant
    lifts into the air.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 连续动画被扩展到当大象升空时触发精灵变化。
- en: Have a go hero – making Benjamin wiggle his tail in anticipation
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 让本杰明在期待中摇尾巴
- en: To practice sprite transitions, your goal is to extend the state machine of
    Benjamin's `SpriteSequence` element to make him wiggle his tail when the elephant
    is standing still. You can find the appropriate sprite in the materials that come
    included with this book. The sprite field is called `wiggling.png`. Implement
    the functionality by making it probable that Benjamin spontaneously goes from
    the "still" state to "wiggling". Pay attention to ensure the animal stops wiggling
    and starts walking the moment the player activates the right or left arrow keys.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习精灵转换，你的目标是扩展本杰明 `SpriteSequence` 元素的状态机，使他在大象站立时摇尾巴。你可以在本书附带的材料中找到适当的精灵。精灵字段称为
    `wiggling.png`。通过使其可能从 "still" 状态自发地转换到 "wiggling" 来实现此功能。注意确保动物在玩家激活左右箭头键的瞬间停止摇尾巴并开始行走。
- en: Parallax scrolling
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透视滚动
- en: We already discussed the useful technique of parallax scrolling in [Chapter
    6](ch06.html "Chapter 6. Graphics View"), *Graphics View*. Just to recapitulate,
    it gives the impression of depth for 2D games by moving multiple layers of background
    at a different speed depending on the assumed distance of the layer from the viewer.
    We will now see how easy it is to apply the same technique in Qt Quick.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 6 章](ch06.html "第 6 章。图形视图") *图形视图* 中讨论了有用的透视滚动技术。为了回顾，它通过以不同的速度移动背景的多个层，根据假设的层与观察者的距离，给
    2D 游戏带来深度感。现在我们将看到在 Qt Quick 中应用相同技术是多么容易。
- en: Time for action – revisiting parallax scrolling
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 回顾透视滚动
- en: We will implement parallax scrolling with a set of layers that move in the direction
    opposite to the one the player is moving in. Therefore, we will need a definition
    of the scene and a moving layer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一组与玩家移动方向相反移动的层来实现透视滚动。因此，我们需要定义场景和移动层。
- en: 'Create a new QML Document (Qt Quick 2). Call it `ParallaxScene.qml`. The scene
    will encompass the whole game "level" and will expose the position of the player
    to the moving layers. Put the following code in the file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 QML 文档（Qt Quick 2）。命名为 `ParallaxScene.qml`。场景将涵盖整个游戏 "级别" 并将玩家的位置暴露给移动层。在文件中放入以下代码：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create another QML Document (Qt Quick 2) and call it `ParallaxLayer.qml`.
    Make it contain the following definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建另一个 QML 文档（Qt Quick 2），命名为 `ParallaxLayer.qml`。使其包含以下定义：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s use the two new element types in the main QML document. We''ll
    take elements from the earlier scene definition and make them into different parallax
    layers—the sky, the trees, and the grass:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在主 QML 文档中使用两种新的元素类型。我们将从早期的场景定义中提取元素，并将它们制作成不同的透视层——天空、树木和草地：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Time for action – revisiting parallax scrolling](img/8874OS_10_11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 回顾透视滚动](img/8874OS_10_11.jpg)'
- en: '*What just happened?*'
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The `ParallaxScene` element we implemented is a moving plane. Its horizontal
    offset depends on the character's current position and the size of the view. The
    range of scroll of the scene is determined by the difference between the scene
    size and the view size—it says how much scrolling we have to do when the character
    moves from the left edge to the right edge of the scene so that it is in view
    all the time. If we multiply that by the distance of the character from the left
    edge of the scene expressed as a fraction of the scene width, we will get the
    needed scene offset in the view (or otherwise speaking, a projection offset of
    the scene).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`ParallaxScene`元素是一个移动平面。其水平偏移量取决于角色的当前位置和视图的大小。场景滚动的范围由场景大小和视图大小的差值决定——它说明了当角色从场景的左侧移动到右侧时，我们需要滚动多少，以便它始终在视图中。如果我们用场景宽度作为分数乘以角色与场景左侧的距离，我们将得到视图中的所需场景偏移量（或者说，场景的投影偏移量）。
- en: The second type—`ParallaxLayer` is also a moving plane. It defines a distance
    factor that represents the relative distance (depth) of the layer behind the foreground,
    which influences how fast the plane should be scrolled compared to the foreground
    (scene). The value of `0` means that the layer should be moving with exactly the
    same speed as the foreground layer. The larger the value, the slower the layer
    moves compared to the character. The offset value is calculated by dividing the
    character's position in the scene by the factor. Since the foreground layer is
    also moving, we have to take it into consideration when calculating the offset
    for each parallax layer. Thus, we subtract the horizontal position of the scene
    to get the actual layer offset.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型——`ParallaxLayer`也是一个移动平面。它定义了一个距离因子，表示背景层相对于前景层的相对距离（深度），这影响了平面相对于前景（场景）应该滚动多快。`0`的值意味着该层应该以与前景层完全相同的速度移动。值越大，层相对于角色的移动速度越慢。偏移值是通过将角色在场景中的位置除以因子来计算的。由于前景层也在移动，我们必须在计算每个视差层的偏移时考虑它。因此，我们减去场景的水平位置以获得实际的层偏移。
- en: Having the layers logically defined, we can add them to the scene. Each layer
    has a physical representation, in our case, static images containing textures
    of the sky, trees, and grass. Each layer is defined separately and can live its
    own life, containing static and animated elements that have no influence on remaining
    layers. If we wanted to render a sun moving from east to west, we would put it
    on the sky layer and animate it from one edge of the layer to the other with a
    long duration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当层逻辑上定义后，我们可以将它们添加到场景中。每一层都有一个物理表示，在我们的例子中，是包含天空、树木和草地纹理的静态图像。每一层都是单独定义的，可以独立存在，包含静态和动画元素，这些元素对其他层没有影响。如果我们想要渲染一个从东向西移动的太阳，我们会将它放在天空层上，并从层的一边动画到另一边，持续时间较长。
- en: Have a go hero – vertical parallax sliding
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 垂直视差滑动
- en: As an additional exercise, you might want to implement vertical parallax sliding
    in addition to a horizontal one. Just make your scene bigger and have it expose
    the vertical scroll position in addition to the horizontal one reported by the
    `currentPos` element. Then, just repeat all the calculations for the `y` property
    of each layer and you should be done in no time. Remember that distance factors
    for `x` and `y` might be different.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，你可能还想在水平视差滑动的基础上实现垂直视差滑动。只需使你的场景更大，并使其除了报告由`currentPos`元素报告的水平滚动位置外，还暴露垂直滚动位置。然后，只需重复对每一层的`y`属性的所有计算，你很快就能完成。记住，`x`和`y`的距离因子可能不同。
- en: Collision detection
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: There is no built-in support for collision detection in Qt Quick, but there
    are three ways of providing such support. First, you can use a ready collision
    system available in a number of 2D physics engines such as Box2D. Secondly, you
    can implement a simple collision system yourself in C++. Lastly, you can do collision
    checking directly in JavaScript by comparing object coordinates and bounding boxes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick中没有内置的碰撞检测支持，但有三种提供此类支持的方法。首先，你可以使用在许多2D物理引擎中可用的现成碰撞系统，如Box2D。其次，你可以自己用C++实现一个简单的碰撞系统。最后，你可以通过比较对象坐标和边界框直接在JavaScript中执行碰撞检查。
- en: Our game is very simple; therefore, we will use the last approach. If we had
    a larger number of moving objects involved in our game, then we would probably
    choose the second approach. The first approach is best if you have an object of
    non-rectangular shapes that can rotate and bounce off other objects. In this case,
    having a physics engine at hand becomes really useful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏非常简单；因此，我们将使用最后一种方法。如果我们游戏中涉及更多的移动对象，那么我们可能会选择第二种方法。如果你有一个可以旋转并与其他对象碰撞反弹的非矩形形状的对象，第一种方法是最好的。在这种情况下，有一个物理引擎在手变得非常有用。
- en: Time for action – collecting coins
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 收集硬币
- en: 'From Qt Creator''s menu, access **File** | **New File or Project**. From **Qt
    Files And Classes**, choose the JS File template. Call the file "`collisions.js`".
    Put the following content into the document:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Qt Creator 的菜单中，访问 **文件** | **新建文件或项目**。从 **Qt 文件和类**，选择 JS 文件模板。将文件命名为 "`collisions.js`"。将以下内容放入文档中：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create another JS File and call it "`coins.js`". Enter the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个 JS 文件并命名为 "`coins.js`"。输入以下内容：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, open the main document and add the following `import` statement:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开主文档并添加以下 `import` 语句：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the player object, define the `checkCollisions()` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家对象中，定义 `checkCollisions()` 函数：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Lastly, in the same player object, trigger collision detection by handling
    the position changes of the player:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在同一个玩家对象中，通过处理玩家位置的变化来触发碰撞检测：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `Coin.qml` file, define an animation and a `hit()` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Coin.qml` 文件中，定义一个动画和一个 `hit()` 函数：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What just happened?*'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The file `collisions.js` contains functions used to do collision checking. The
    first line of the file is a pragma statement noting that this document only contains
    functions and does not contain any mutable object. This is so that we can add
    a `.pragma library` statement, which marks the document as a library that can
    be shared between documents that import it. This aids in reduced memory consumption
    and improved speed as the engine doesn't have to reparse and execute the document
    each time it is imported.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `collisions.js` 包含用于执行碰撞检查的函数。文件的第一行是一个 pragma 语句，指出该文档只包含函数，不包含任何可变对象。这样我们就可以添加一个
    `.pragma library` 语句，将文档标记为可以由导入它的文档共享的库。这有助于减少内存消耗并提高速度，因为引擎不需要每次导入时都重新解析和执行文档。
- en: The functions defined in the library are really simple. The first one returns
    a bounding rectangle of an object based on its coordinates and the size of its
    children. It assumes that the top-level item is empty and contains children that
    represent the visual aspect of the object. Children coordinates are mapped using
    the `mapToItem` element so that the rectangle returned is expressed in the parent
    item coordinates. The second function does a trivial checking of intersection
    between two bounding rectangles and returns `true` if they intersect and `false`
    otherwise.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 库中定义的函数非常简单。第一个函数根据对象的坐标和子元素的大小返回对象的边界矩形。它假设顶级项为空，并包含代表对象视觉方面的子元素。子元素坐标使用 `mapToItem`
    元素映射，以便返回的矩形以父项坐标表示。第二个函数对两个边界矩形之间的交集进行简单检查，如果它们相交则返回 `true`，否则返回 `false`。
- en: The second document keeps a definition of an array of coins. It adds two methods
    to the array object. The first one—`collisionsWith`—performs a collision check
    between any of the items in the array and the given object using functions defined
    in `collisions.js`. That's why we import the library at the start of the document.
    The method returns another array that contains objects intersecting the `player`
    argument. The other method, called `remove`, takes an object or an array of objects
    and removes them from `coins`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文档保持了一个硬币数组的定义。它向数组对象添加了两个方法。第一个方法——`collisionsWith`——使用在 `collisions.js`
    中定义的函数在数组中的任何项和给定的对象之间执行碰撞检查。这就是为什么我们在文档开头导入库的原因。该方法返回另一个包含与 `player` 参数相交的对象的数组。另一个方法，称为
    `remove`，接受一个对象或对象数组，并将它们从 `coins` 中移除。
- en: The document is not a library; therefore, each document that imports `coins.js`
    would get its own separate copy of the object. Thus, we need to ensure that `coins.js`
    is imported only once in the game so that all references to the objects defined
    in that document relate to the same instance of the object in our program memory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档不是一个库；因此，每个导入 `coins.js` 的文档都会得到该对象的一个单独副本。因此，我们需要确保在游戏中只导入一次 `coins.js`，以便该文档中定义的对象的所有引用都与程序内存中对象的同一实例相关联。
- en: Our main document imports `coins.js`, which creates the array for storing coin
    objects and makes its auxiliary functions available. This allows the defined `checkCollisions()`
    function to retrieve the list of coins colliding with the player. For each coin
    that collides with the player, we execute a `hit()` method; as a last step, all
    colliding coins are removed from the array. Since coins are stationary, collision
    can only occur when the player character enters an area occupied by a coin. Therefore,
    it is enough to trigger collision detection when the position of the player character
    changes—we use the `onXChanged` and `onYChanged` handlers.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要文档导入了`coins.js`，它创建了一个用于存储硬币对象的数组，并使其辅助函数可用。这使得定义的`checkCollisions()`函数能够检索与玩家碰撞的硬币列表。对于每个与玩家碰撞的硬币，我们执行一个`hit()`方法；作为最后一步，所有碰撞的硬币都会从数组中移除。由于硬币是静止的，碰撞只能在玩家角色进入硬币占据的区域时发生。因此，当玩家角色的位置改变时触发碰撞检测就足够了——我们使用`onXChanged`和`onYChanged`处理程序。
- en: As hitting a coin results in removing it from the array, we lose a reference
    to the object. The `hit()` method has to initiate removal of the object from the
    scene. A minimalistic implementation of this function would be to just call the
    `destroy()` function on the object, but we do more—the removal can be made smoother
    by running a fade-out animation on the coin. As a last step, the animation can
    destroy the object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于击中硬币会导致其从数组中移除，我们失去了对该对象的引用。`hit()`方法必须启动从场景中移除对象的过程。这个函数的最简实现可能只是调用对象的`destroy()`函数，但我们做得更多——通过在硬币上运行淡出动画可以使移除过程更加平滑。作为最后一步，动画可以销毁对象。
- en: Notes on collision detection
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测的注意事项
- en: The number of objects we track on the scene is really small, and we simplify
    the shape of each object to a rectangle. This lets us get away with checking collisions
    in JavaScript. For a larger amount of moving objects, custom shapes, and handling
    rotations, it is much better to have a collision system based on C++. The level
    of complexity of such a system depends on your needs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在场景中追踪的对象数量非常少，并且我们将每个对象的形状简化为矩形。这使得我们可以通过JavaScript来检查碰撞。对于大量移动对象、自定义形状和旋转处理，拥有一个基于C++的碰撞系统会更好。这样一个系统的复杂程度取决于你的需求。
- en: Eye candy
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 眼睛的甜点
- en: A game should not just be based upon an interesting idea; it should not only
    work fluently on a range of devices and give entertainment to those people playing
    it. It should also look nice and behave nicely. Whether one is choosing from a
    number of similar implementations of the same game or wants to spend money on
    another similarly priced and entertaining game, there is a good chance the game
    she or he chooses will be the one that looks the best—having a lot of animations,
    graphics, and flashy content. We already learned a number of techniques to make
    a game more pleasing to the eye, such as using animations or GLSL shaders. Here,
    we will show you a number of other techniques that can make your Qt Quick applications
    more attractive.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一款游戏不应该仅仅基于一个有趣的想法；它不仅应该在各种设备上流畅运行，为玩家提供娱乐，还应该看起来很漂亮，表现得很优雅。无论是从同一游戏的多个类似实现中选择，还是愿意为另一个价格相似且有趣的类似游戏花钱，有很大可能性，玩家选择的游戏将是看起来最好的那款——拥有大量的动画、图形和闪亮的元素。我们已经学习了许多使游戏更吸引眼球的技巧，例如使用动画或GLSL着色器。在这里，我们将向您展示一些其他可以使您的Qt
    Quick应用程序更具吸引力的技巧。
- en: Auto-scaling user interfaces
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动缩放的用户界面
- en: The first extension you might implement is making your game auto-adjust to the
    device resolution it is running on. There are basically two ways to accomplish
    this. The first is to center the user interface in the window (or screen) and
    if it doesn't fit, enable scrolling. The other approach is to scale the interface
    to always fit the window (or screen). Which to choose depends on a number of factors,
    the most important of which is whether your UI is good enough when upscaled. If
    the interface consists of text and non-image primitives (basically rectangles)
    or if it includes images but only vector ones or those with very high resolution,
    then it is probably fine to try and scale the user interface. Otherwise, if you
    use a lot of low resolution bitmap images, you will have to choose one particular
    size for the UI (optionally allowing it to downscale since the quality degradation
    should be less significant in this direction if you enable anti-aliasing).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先实现的功能是让你的游戏自动调整到它正在运行的设备分辨率。基本上有两种方法可以实现这一点。第一种是在窗口（或屏幕）中居中放置用户界面，如果它不合适，则启用滚动。另一种方法是缩放界面，使其始终适合窗口（或屏幕）。选择哪种方法取决于许多因素，其中最重要的是你的
    UI 在放大时是否足够好。如果界面由文本和非图像原语（基本上是矩形）组成，或者如果它包括图像但只有矢量图像或非常高分辨率的图像，那么尝试缩放用户界面可能是可以的。否则，如果你使用了大量低分辨率的位图图像，你将不得不为
    UI 选择一个特定的尺寸（可选地允许它降级，因为如果你启用抗锯齿，质量下降应该在这个方向上不那么明显）。
- en: 'Whether you choose to scale or to center and scroll, the basic approach is
    the same—you put your UI item in another item so that you have fine control over
    the UI geometry regardless of what happens to the top-level window. Taking the
    centered approach is quite easy—just anchor the UI to the center of the parent.
    To enable scrolling, wrap the UI in the `Flickable` item and constrain its size
    if the size of the window is not big enough to fit the whole user interface:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择缩放还是居中并滚动，基本方法都是相同的——你将你的 UI 元素放入另一个元素中，这样无论顶级窗口发生什么变化，你都可以精细控制 UI 几何形状。采用居中方法相当简单——只需将
    UI 锚定到父元素的中央。要启用滚动，将 UI 包装在 `Flickable` 元素中，并如果窗口的大小不足以容纳整个用户界面，则约束其大小：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You should probably decorate the top-level item with a nice background if the
    UI item does not occupy the full area of its parent.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 UI 元素没有占据其父元素的全部区域，你可能需要用漂亮的背景装饰顶级元素。
- en: 'Scaling seems more complicated, but with Qt Quick it is really easy. Again,
    you have two choices—either stretch or scale. Stretching is as easy as executing
    the `anchors.fill: parent` command, which effectively forces the UI to recalculate
    the geometry of all its items but possibly allows us to use the space more efficiently.
    It is, in general, very time-consuming for the developer to provide expressions
    for calculating the geometry of each and every element in the user interface as
    the size of the view changes. This is usually not worth the effort. A simpler
    approach is to just scale the UI item to fit the window, which will implicitly
    scale the contained items. In such an event, their size can be calculated relative
    to the base size of the main view of the user interface. For this to work, you
    need to calculate the scale that is to be applied to the user interface to make
    it fill the whole space available. The item has a scale of 1 when its effective
    width equals its implicit width and its effective height equals its implicit height.
    If the window is larger, we want to scale the item up until it reaches the size
    of the window. Therefore, the window''s width divided by the item''s implicit
    width will be the item''s scale in the horizontal direction. This is shown in
    the following diagram:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '缩放看起来可能更复杂，但使用 Qt Quick 真的非常简单。再次强调，你有两个选择——要么拉伸，要么缩放。拉伸就像执行 `anchors.fill:
    parent` 命令一样简单，这个命令有效地迫使 UI 重新计算所有项的几何形状，但可能使我们能够更有效地使用空间。通常，对于开发者来说，在视图大小变化时为用户界面中的每个元素提供计算几何形状的表达式是非常耗时的。这通常不值得付出努力。一个更简单的方法是将
    UI 元素缩放到适合窗口，这将隐式地缩放包含的元素。在这种情况下，它们的大小可以相对于用户界面主视图的基本大小来计算。为了使这可行，你需要计算应用于用户界面的缩放比例，使其填满整个可用空间。当元素的有效宽度等于其隐式宽度，以及其有效高度等于其隐式高度时，该元素的缩放比例为
    1。如果窗口更大，我们希望将元素缩放到达到窗口大小。因此，窗口宽度除以元素的隐式宽度将是元素在水平方向上的缩放比例。这将在以下图中展示：'
- en: '![Auto-scaling user interfaces](img/8874OS_10_12.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![自动缩放用户界面](img/8874OS_10_12.jpg)'
- en: 'The same can be applied to the vertical direction, but if the UI has a different
    aspect ratio than the window, its horizontal and vertical scale factors will be
    different. For the UI to look nice, we have to take the lower of the two values—to
    only scale up as much as the direction with less space allows, leaving a gap in
    the other direction:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于垂直方向，但如果UI的宽高比与窗口不同，其水平和垂直缩放因子也会不同。为了使UI看起来更美观，我们必须取两个值中较小的一个——只将方向扩展到较少空间允许的程度，在另一个方向上留下空白：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, it might be a good idea to put some background on the window item to
    fill in the gaps.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，给窗口项添加一些背景以填补空白可能是个好主意。
- en: 'What if you want to save some margin between the user interface and the window?
    You could, of course, take that into consideration when calculating the scale
    (`(window.width-2*margin)/width`, and so on) but there is an easier way—simply
    put an additional item inside the window, leaving an appropriate margin, and put
    the user interface item in that additional item and scale it up to the additional
    item''s size:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在用户界面和窗口之间保留一些边距怎么办？当然，你可以在计算缩放时考虑这一点（例如`(window.width-2*margin)/width`等），但有一个更简单的方法——只需在窗口内放置一个额外的项，留下适当的边距，并将用户界面项放在该额外项中，并将其缩放到额外项的大小：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you scale elements a lot, you should consider enabling anti-aliasing for
    items that can lose quality when rendered in a size different than their native
    size (for example, images). This is done very easily in Qt Quick as each `Item`
    instance has a property called `antialiasing` which, when enabled, will cause
    the rendering backend to try to reduce distortions caused by the aliasing effect.
    Remember that this comes at the cost of increased rendering complexity, so try
    to find a balance between quality and efficiency, especially on low-end hardware.
    You might provide an option to the user to globally enable or disable anti-aliasing
    for all game objects or to gradually adjust quality settings for different object
    types.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你大量缩放元素时，你应该考虑为那些在渲染为不同于其原始大小的尺寸时可能会失去质量的项启用抗锯齿（例如，图像）。在Qt Quick中，这非常容易，因为每个`Item`实例都有一个名为`antialiasing`的属性，当启用时，将导致渲染后端尝试减少由抗锯齿效果引起的失真。记住，这会带来渲染复杂性的增加，因此请尝试在质量和效率之间找到平衡，尤其是在低端硬件上。你可能可以为用户提供一个选项，全局启用或禁用所有游戏对象的抗锯齿，或者为不同类型的对象逐渐调整质量设置。
- en: Graphical effects
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形效果
- en: The basic two predefined items in Qt Quick are rectangle and image. One can
    use them in a variety of creative ways and make them more pleasant-looking by
    applying GLSL shaders. However, implementing a shader program from scratch is
    cumbersome and requires in-depth knowledge of the shader language. Luckily, a
    number of common effects are already implemented and ready to use in the form
    of the `QtGraphicalEffects` module.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick中的基本两个预定义项是矩形和图像。人们可以用各种创造性的方式使用它们，并通过应用GLSL着色器使它们看起来更愉快。然而，从头开始实现着色器程序是繁琐的，并且需要深入了解着色器语言。幸运的是，许多常见效果已经实现，并以`QtGraphicalEffects`模块的形式准备好使用。
- en: 'To add a subtle black shadow to our canvas-based heartbeat element defined
    in the `HeartBeat.qml` file, use a code similar to the following that makes use
    of the `DropShadow` effect:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要给在`HeartBeat.qml`文件中定义的基于画布的心跳元素添加微妙的黑色阴影，可以使用类似于以下代码的代码，该代码利用了`DropShadow`效果：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To apply a shadow effect, you need an existing item as the source of the effect.
    In our case, we are using an instance of the `HeartBeat` class centered in a top-level
    item. Then, the shadow effect is defined and its geometry follows that of its
    source by using the `anchors.fill` element. Just as the `DropShadow` class renders
    the original item as well as the shadow, the original item can be hidden by setting
    its `visible` property to `false`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用阴影效果，你需要一个现有的项作为效果源。在我们的例子中，我们使用了一个`HeartBeat`类的实例，它位于顶级项的中心。然后，定义阴影效果，并使用`anchors.fill`元素使其几何形状跟随其源。就像`DropShadow`类渲染原始项及其阴影一样，可以通过将原始项的`visible`属性设置为`false`来隐藏原始项。
- en: '![Graphical effects](img/8874OS_10_14.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图形效果](img/8874OS_10_14.jpg)'
- en: Most of the `DropShadow` class's properties are self-explanatory, but two properties—`radius`
    and `samples`—require some additional explanation. The shadow is drawn as a blurred
    monochromatic copy of the original item offset by a given position. The two mentioned
    properties control the amount of blur and its quality—the more samples used for
    blurring, the better the effect, but also the more demanding the computation that
    needs to be performed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `DropShadow` 类的属性都是不言自明的，但有两个属性——`radius` 和 `samples`——需要一些额外的解释。阴影是以给定位置偏移的原始项目的模糊单色副本的形式绘制的。这两个提到的属性控制模糊的程度和质量——用于模糊的样本越多，效果越好，但同时也需要执行的计算量也越大。
- en: 'Speaking of blur, the plain blurring effect is also available in the graphics
    effects module through the `GaussianBlur` element type. To apply a blur instead
    of a shadow to the last example, simply replace the occurrence of the `DropShadow`
    class with the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 说到模糊，纯模糊效果在图形效果模块中也是通过 `GaussianBlur` 元素类型提供的。要将模糊效果应用于上一个示例而不是阴影，只需将 `DropShadow`
    类的实例替换为以下代码：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![Graphical effects](img/8874OS_10_15.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图形效果](img/8874OS_10_15.jpg)'
- en: Here, you can see two earlier mentioned properties as well as a vaguely named
    `transparentBorder` one. Enabling this property fixes some artifacts on the edges
    of the blur and in general, you'll want to keep it that way.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到前面提到的两个属性以及一个名称模糊的 `transparentBorder` 属性。启用此属性可以修复模糊边缘的一些伪影，并且通常你希望保持这种方式。
- en: Have a go hero – the blur parallax scrolled game view
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——模糊视差滚动游戏视图
- en: The `blur` property is a very nice effect that can be used in many situations.
    For example, you could try to implement a feature within our elephant game whereby,
    when the user pauses the game (for example, by pressing the *P* key on the keyboard),
    the view gets blurred. Make the effect smooth by applying an animation to the
    effect's `radius` property.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`blur` 属性是一个非常棒的效果，可以在许多情况下使用。例如，你可以在我们的象形游戏中尝试实现一个功能，当用户暂停游戏时（例如，通过按键盘上的 *P*
    键），视图会变得模糊。通过应用动画到效果属性的 `radius` 上，使效果平滑。'
- en: 'Another interesting effect is `Glow`. It renders a colored and blurred copy
    of the source element. An example use case for games is highlighting some parts
    of the user interface—you can direct the user''s attention to the element (for
    example, button or badge) by making the element flash periodically:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的效果是 `Glow`。它渲染源元素的彩色和模糊副本。对于游戏的一个用例是突出显示用户界面的某些部分——你可以通过使元素周期性地闪烁来引导用户的注意力（例如，按钮或徽章）：
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The complete module contains 20 different effects. We cannot describe each effect
    in detail here. Nevertheless, you can learn about it yourself. If you clone the
    module's source git repository (found under [git://code.qt.io/qt/qtgraphicaleffects.git](http://git://code.qt.io/qt/qtgraphicaleffects.git))
    in the `tests/manual/testbed` subdirectory of the cloned repository, you will
    find a nice application for testing existing effects. To run the tool, open the
    `testBed.qml` file with `qmlscene`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 完整模块包含 20 种不同的效果。我们无法在这里详细描述每种效果。不过，你可以自己了解它们。如果你在克隆的模块源 git 仓库（位于克隆仓库的 `tests/manual/testbed`
    子目录下）中克隆了模块，你将找到一个用于测试现有效果的不错应用程序。要运行此工具，请使用 `qmlscene` 打开 `testBed.qml` 文件。
- en: '![Have a go hero – the blur parallax scrolled game view](img/8874OS_10_16.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![尝试一下英雄——模糊视差滚动游戏视图](img/8874OS_10_16.jpg)'
- en: Tip
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also access a complete list of effects and their short descriptions
    by navigating to the **GraphicalEffects** help page in the documentation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过导航到文档中的 **GraphicalEffects** 帮助页面来访问完整的效应列表及其简短描述。
- en: Particle systems
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子系统
- en: A commonly used visual effect in systems such as games is generating a large
    number of small, usually short-lived, often fast-moving, fuzzy objects such as
    stars, sparks, fumes, dust, snow, splinters, falling leaves, or the like. Placing
    these as regular items within a scene would greatly degrade performance. Instead,
    a special engine is used which keeps a registry of such objects and tracks (simulates)
    their logical attributes without having physical entities in the scene. Such objects,
    called particles, are rendered upon request in the scene using very efficient
    algorithms. This allows us to use a large number of particles without having a
    negative impact on the rest of the scene.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏等系统中，常用的视觉效果是生成大量小型、通常短暂、通常快速移动、模糊的对象，如星星、火花、烟雾、灰尘、雪、碎片、落叶等。将这些对象作为场景中的常规项目放置会大大降低性能。相反，使用一个特殊的引擎来维护此类对象的注册表，并跟踪（模拟）它们的逻辑属性，而不在场景中具有物理实体。这些称为粒子的对象，在请求时使用非常高效的算法在场景中进行渲染。这允许我们使用大量粒子，而不会对场景的其他部分产生负面影响。
- en: Qt Quick provides a particle system in the `QtQuick.Particles` import. The `ParticleSystem`
    element provides the core for the simulation, which uses the `Emitter` elements
    to spawn particles. They are then rendered according to definitions in a `ParticlePainter`
    element. Simulated entities can be manipulated using the `Affector` objects, which
    can modify the trajectory or life span of particles.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 在 `QtQuick.Particles` 导入中提供了一个粒子系统。`ParticleSystem` 元素提供了模拟的核心，它使用
    `Emitter` 元素来生成粒子。然后根据 `ParticlePainter` 元素中的定义进行渲染。可以使用 `Affector` 对象来操纵模拟实体，这些对象可以修改粒子的轨迹或生命周期。
- en: 'Let''s start with a simple example. The following code snippet declares the
    simplest possible particle system:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。以下代码片段声明了最简单的粒子系统：
- en: '[PRE51]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result can be observed in the following image:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在以下图像中观察到：
- en: '![Particle systems](img/8874OS_10_17.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/8874OS_10_17.jpg)'
- en: Let's analyze the code. After importing `QtQuick.Particles 2.0`, a `ParticleSystem`
    item is instantiated that defines the domain of the particle system. We define
    two objects within that system. The first object is the `Emitter` and defines
    an area where particles will be spawned. The area is set to encompass the whole
    domain. The second object is an object of the `ImageParticle` type, which is a
    `ParticlePainter` subclass. It determines that particles should be rendered as
    instances of a given image. By default, the `Emitter` object spawns 10 particles
    per second, each of which lives for one second and then dies and is removed from
    the scene. In the code presented, the `Emitter` and `ImageParticle` objects are
    direct children of the `ParticleSystem` class; however, this doesn't have to be
    the case. The particle system can be explicitly specified by setting the `system`
    property.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码。在导入 `QtQuick.Particles 2.0` 之后，实例化了一个 `ParticleSystem` 项目，它定义了粒子系统的域。我们在该系统中定义了两个对象。第一个对象是
    `Emitter`，它定义了粒子生成的区域。该区域设置为包含整个域。第二个对象是 `ImageParticle` 类型的对象，它是 `ParticlePainter`
    子类的实例。它确定粒子应以给定图像的实例进行渲染。默认情况下，`Emitter` 对象每秒生成 10 个粒子，每个粒子存活一秒后死亡并被从场景中移除。在所提供的代码中，`Emitter`
    和 `ImageParticle` 对象是 `ParticleSystem` 类的直接子代；然而，这不必是这种情况。可以通过设置 `system` 属性显式指定粒子系统。
- en: Tuning the emitter
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整发射器
- en: 'You can control the amount of particles being emitted by setting the `emitRate`
    property of the emitter. Another property called the `lifeSpan` determines how
    many milliseconds it takes before a particle dies. To introduce some random behavior,
    you can use the `lifeSpanVariation` property to set a maximum amount of time (in
    milliseconds) the life span can be altered by the system (in both directions).
    Increasing the emission rate and life span of particles can lead to a situation
    in which a very large number of particles have to be managed (and possibly rendered).
    This can degrade performance; thus, an upper limit of particles that can concurrently
    be alive can be set through the `maximumEmitted` property:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置发射器的 `emitRate` 属性来控制发射的粒子数量。另一个名为 `lifeSpan` 的属性决定了粒子死亡前需要多少毫秒。为了引入一些随机行为，您可以使用
    `lifeSpanVariation` 属性来设置系统可以改变生命周期（在两个方向上）的最大时间（以毫秒为单位）。增加粒子的发射率和生命周期可能导致需要管理（和可能渲染）的粒子数量非常大。这可能会降低性能；因此，可以通过
    `maximumEmitted` 属性设置可以同时存在的粒子的上限：
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Tuning the emitter](img/8874OS_10_18.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![调整发射器](img/8874OS_10_18.jpg)'
- en: 'Tweaking the life span of particles makes the system more diverse. To strengthen
    the effect, you can also manipulate the size of each particle through the `size`
    and `sizeVariation` properties:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 调整粒子的生命周期可以使系统更加多样化。为了增强效果，您还可以通过 `size` 和 `sizeVariation` 属性来操作每个粒子的尺寸：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Tuning the emitter](img/8874OS_10_19.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![调整发射器](img/8874OS_10_19.jpg)'
- en: The range of functionality presented thus far should be enough to create many
    nice-looking and useful particle systems. The limitation so far has been that
    particles are emitted from the whole area of the emitter, which is a regular `QQuickItem`
    and thus is rectangular. This doesn't have to be the case, though. The `Emitter`
    element contains a `shape` property, which is a way to declare the area that is
    to be giving birth to particles. The `QtQuick.Particles` parameter defines three
    types of custom shape that can be used— `EllipseShape`, `LineShape`, and `MaskShape`.
    The first two are very simple, defining either an empty or filled ellipse inscribed
    in the item or a line crossing one of the two diagonals of the item. The `MaskShape`
    element is more interesting as it makes it possible to use an image as a shape
    for the `Emitter` element.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止展示的功能范围应该足够创建许多看起来不错且实用的粒子系统。到目前为止的限制是粒子从发射器的整个区域发射出来，这是一个常规的 `QQuickItem`，因此是矩形的。但这不必是这种情况。`Emitter`
    元素包含一个 `shape` 属性，这是一种声明要产生粒子的区域的方式。`QtQuick.Particles` 参数定义了三种可用的自定义形状类型——`EllipseShape`、`LineShape`
    和 `MaskShape`。前两种非常简单，定义了在项目内绘制的空椭圆或填充椭圆，或者穿过项目两条对角线之一的线。`MaskShape` 元素更有趣，因为它使得可以使用图像作为
    `Emitter` 元素的形状。
- en: '[PRE54]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![Tuning the emitter](img/8874OS_10_20.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![调整发射器](img/8874OS_10_20.jpg)'
- en: Rendering particles
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染粒子
- en: Thus far, we have used a bare `ImageParticle` element to render particles. It
    is only one of three `ParticlePainters` available, with the others being `ItemParticle`
    and `CustomParticle`. But before we move on to other renderers, let's focus on
    tweaking the `ImageParticle` element to obtain some interesting effects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用裸露的 `ImageParticle` 元素来渲染粒子。它只是三种 `ParticlePainters` 之一，其他两种是 `ItemParticle`
    和 `CustomParticle`。但在我们继续探讨其他渲染器之前，让我们专注于调整 `ImageParticle` 元素以获得一些有趣的效果。
- en: The `ImageParticle` element renders each logical particle as an image. The image
    can be manipulated separately for each particle by changing its color and rotation,
    deforming its shape, or using it as a sprite animation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageParticle` 元素将每个逻辑粒子渲染为图像。可以通过改变颜色和旋转、变形形状或将其用作精灵动画来分别对每个粒子进行操作。'
- en: To influence the color of particles, you can use any of the large number of
    dedicated properties—`alpha`, `color`, `alphaVariation`, `colorVariation`, `redVariation`,
    `greenVariation`, and `blueVariation`. The first two properties define the base
    value for respective attributes and the remaining properties set the maximum deviation
    of a respective parameter from the base value. In the case of opacity, there is
    only one type of variation you can use but when defining the color, you can either
    set different values for each of the red, green, and blue channels or you can
    use the global `colorVariation` property, which is similar to setting the same
    value for all three channels. Allowed values are any between the range of 0 (no
    deviation allowed) to 1.0 (100% in either direction).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要影响粒子的颜色，您可以使用大量专用属性中的任何一个——`alpha`、`color`、`alphaVariation`、`colorVariation`、`redVariation`、`greenVariation`
    和 `blueVariation`。前两个属性定义了相应属性的基值，其余属性设置相应参数从基值出发的最大偏差。在透明度的情况下，您只能使用一种类型的偏差，但在定义颜色时，您可以为红色、绿色和蓝色通道设置不同的值，或者您可以使用全局的
    `colorVariation` 属性，这类似于为所有三个通道设置相同的值。允许的值在 0（不允许偏差）到 1.0（任一方向 100%）之间。
- en: '![Rendering particles](img/8874OS_10_21.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![渲染粒子](img/8874OS_10_21.jpg)'
- en: The properties mentioned are stationary—the particle obeys the constant value
    during its whole life. The `ImageParticle` element also exposes two properties,
    letting you control the color of particles relative to their age. First of all,
    there is a property called `entryEffect` that defines what happens with the particle
    at its birth and death. The default value is `Fade`, which makes particles fade
    in from 0 opacity at the start of their life and fades them back to 0 just before
    they die. You have already experienced this effect in all earlier particle animations
    we demonstrated. Other values for the property are `None` and `Scale`. The first
    one is obvious—there is no entry effect associated with particles. The second
    one scales particles from 0 at their birth and scales them back to 0 at the end
    of their life.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的属性是静态的——粒子在其整个生命周期中遵循恒定值。`ImageParticle` 元素还公开了两个属性，让您可以控制粒子相对于其年龄的颜色。首先，有一个名为
    `entryEffect` 的属性，它定义了粒子在其诞生和死亡时会发生什么。默认值是 `Fade`，这使得粒子在其生命开始时从0不透明度淡入，并在它们死亡前恢复到0不透明度。您已经在所有之前展示的粒子动画中体验过这种效果。该属性的其它值是
    `None` 和 `Scale`。第一个值很明显——与粒子无关的进入效果。第二个值在粒子诞生时从0开始缩放，并在生命结束时缩放回0。
- en: The other time-related property is `colorTable`. You can feed it with a URL
    of an image to be used as a one-dimensional texture determining the color of each
    particle over its life. At the beginning, the particle gets color-defined by the
    left edge of the image and then progresses right in a linear fashion. It is most
    common to set an image here containing a color gradient to achieve smooth transitions
    between colors.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与时间相关的属性是 `colorTable`。您可以向其中提供用作确定粒子在其生命周期中颜色的单维纹理的图像的URL。一开始，粒子由图像的左侧边缘定义颜色，然后以线性方式向右移动。在这里设置包含颜色渐变的图像以实现颜色之间的平滑过渡是最常见的做法。
- en: The second parameter that can be altered is the rotation of a particle. Here,
    we can also either use properties that define constant values for rotation (`rotation`
    and `rotationVariation`) specified in degrees or modify the rotation of particles
    in time with `rotationVelocity` and `rotationVelocityVariation`. The velocity
    defines the pace or rotation in degrees per second.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 可以改变的第二个参数是粒子的旋转。在这里，我们既可以使用定义旋转常量值（`rotation` 和 `rotationVariation`）的属性，这些属性以度为单位指定，也可以使用
    `rotationVelocity` 和 `rotationVelocityVariation` 在时间上修改粒子的旋转。速度定义了每秒旋转的度数。
- en: Particles can also be deformed. The properties `xVector` and `yVector` allow
    binding vectors, which define distortions in horizontal and vertical axes. We
    will describe how to set the vectors in the next section. Last but not least,
    using the `sprites` property you can define a list of sprites that will be used
    to render particles. This works in a similar fashion to `SpriteAnimation`, described
    in an earlier section of this chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子还可以变形。`xVector` 和 `yVector` 属性允许绑定向量，这些向量定义了水平和垂直轴上的扭曲。我们将在下一节中描述如何设置向量。最后但同样重要的是，使用
    `sprites` 属性，您可以定义一个将用于渲染粒子的精灵列表。这与本章早期部分中描述的 `SpriteAnimation` 的工作方式类似。
- en: Making particles move
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使粒子移动
- en: Apart from fading and rotating, the particle systems we have seen so far were
    very static. While this is useful for making star fields, it is not useful at
    all for explosions, sparks, or even falling snow. This is because particles are
    mostly about movement. Here, we will show you two aspects of making your particles
    fly.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 除了淡入淡出和旋转之外，我们迄今为止看到的粒子系统都非常静态。虽然这对于制作星系很有用，但对于爆炸、火花甚至下雪来说却毫无用处。这是因为粒子主要关于运动。在这里，我们将向您展示使您的粒子飞行的两个方面。
- en: The first aspect is modeling how the particles are born. By that, we mean the
    physical conditions of the object creating the particles. During an explosion,
    matter is pushed away from the epicenter with a very large force that causes air
    and small objects to rush outwards at an extremely high speed. Fumes from a rocket
    engine are ejected with high velocities in the direction opposite to that of the
    propelled craft. A moving comet draws along a braid of dust and gases put into
    motion by the inertia.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方面是模拟粒子的诞生方式。这意味着创建粒子的物体的物理条件。在爆炸过程中，物质以非常大的力量从震中推开，导致空气和小物体以极高的速度向外冲出。火箭发动机的烟雾以与推进器相反的方向以高速喷射。移动的彗星会拖着一缕尘埃和气体，这些尘埃和气体是由惯性引起的。
- en: All these conditions can be modeled by setting the velocity or acceleration
    of the particles. These two metrics are described by vectors determining the direction
    and amount (magnitude or length) of the given quantity. In Qt Quick, such vectors
    are represented by an element type called `StochasticDirection`, where the tail
    of the vector is attached to the object and the position of the head is calculated
    by the `StochasticDirection` instance. Since we have no means of setting attributes
    on particles because we have no objects representing them, those two attributes—`velocity`
    and `acceleration`—are applied to emitters spawning the particles. Because you
    can have many emitters in a single particle system, you can set different velocities
    and accelerations for particles of different origins.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些条件都可以通过设置粒子的速度或加速度来建模。这两个指标由确定给定数量方向和数量（大小或长度）的向量的向量来描述。在Qt Quick中，这样的向量由一个称为`StochasticDirection`的元素类型表示，其中向量的尾部连接到对象，而头部位置由`StochasticDirection`实例计算。由于我们没有设置粒子属性的方法，因为我们没有代表它们的对象，所以这两个属性——`velocity`和`acceleration`——应用于产生粒子的发射器。因为你可以在一个粒子系统中有很多发射器，所以你可以为不同来源的粒子设置不同的速度和加速度。
- en: There are four types of direction elements representing different sources of
    information about the direction. First, there is `CumulativeDirection`, which
    acts as a container for other direction types and works like a sum of directions
    contained within.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同类型的方向元素，代表关于方向的不同信息来源。首先，有`CumulativeDirection`，它作为其他方向类型的容器，并像包含在内的方向的总和一样工作。
- en: Then, there is `PointDirection`, where you can specify `x` and `y` coordinates
    of a point where the head of the vector should be attached. To avoid the unrealistic
    effect of all particles heading in the same direction, you can specify `xVariation`
    and `yVariation` to introduce allowed deviation from a given point.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有`PointDirection`，在这里你可以指定向量头部应该连接的点的`x`和`y`坐标。为了避免所有粒子朝同一方向的不现实效果，你可以指定`xVariation`和`yVariation`来引入从给定点的允许偏差。
- en: '![Making particles move](img/8874OS_10_22.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![使粒子移动](img/8874OS_10_22.jpg)'
- en: 'The third type is the most popular stochastic direction type—`AngleDirection`,
    which directly specifies the angle (in degrees clockwise from straight right)
    and magnitude (in pixels per second) of the vector. The angle can vary from the
    base by `angleVariation` and similarly, `magnitudeVariation` can be used to introduce
    variation to the length of the vector:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型是最受欢迎的随机方向类型——`AngleDirection`，它直接指定向量的角度（从正右方向顺时针计算）和大小（每秒像素数）。角度可以从基础值通过`angleVariation`变化，同样，`magnitudeVariation`可以用来引入向量大小的变化：
- en: '![Making particles move](img/8874OS_10_23.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![使粒子移动](img/8874OS_10_23.jpg)'
- en: 'The last type is similar to the previous one. The `TargetDirection` vector
    can be used to point the vector toward the center of a given Qt Quick item (set
    with the `targetItem` property). The length of the vector is calculated by giving
    the `magnitude` and `magnitudeVariation`, and both can be interpreted as pixels
    per second or multiples of distance between the source and target points (depending
    on the value of the `proportionalMagnitude` property):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型与前面的一种类似。`TargetDirection`向量可以用来将向量指向给定Qt Quick项的中心（通过`targetItem`属性设置）。向量的长度通过给出`magnitude`和`magnitudeVariation`来计算，两者都可以解释为每秒像素数或源点和目标点之间距离的倍数（取决于`proportionalMagnitude`属性的值）：
- en: '![Making particles move](img/8874OS_10_24.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![使粒子移动](img/8874OS_10_24.jpg)'
- en: 'Let''s get back to setting particle velocity. We can use the `AngleDirection`
    vector to specify that particles should be moving left, spreading at a maximum
    of 45 degrees:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到设置粒子速度。我们可以使用`AngleDirection`向量来指定粒子应该向左移动，以最大45度的角度扩散：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Making particles move](img/8874OS_10_25.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![使粒子移动](img/8874OS_10_25.jpg)'
- en: 'Setting acceleration works the same way. You can even set both the initial
    velocity and the acceleration each particle should have. It is very easy to shoot
    the particles in the left direction and start pulling them down:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 设置加速度的工作方式相同。你甚至可以设置每个粒子应该具有的初始速度和加速度。向左发射粒子并开始向下拉是非常容易的：
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![Making particles move](img/8874OS_10_26.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![使粒子移动](img/8874OS_10_26.jpg)'
- en: 'The `Emitter` element has one more nice property that is useful in the context
    of moving particles. Setting the `velocityFromMovement` parameter to a value different
    than `0` makes any movement of the `Emitter` element apply to the velocity of
    the particles. The direction of the additional vector matches the direction of
    the emitter''s movement, and the magnitude is set to the speed of the emitter
    multiplied by the value set to `velocityFromMovement`. It is a great way to generate
    fumes ejected from a rocket engine:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`元素有一个在移动粒子上下文中很有用的额外属性。将`velocityFromMovement`参数设置为不同于`0`的值，会使`Emitter`元素的任何移动都应用于粒子的速度。附加向量的方向与发射器的移动方向相匹配，其大小设置为发射器速度乘以设置为`velocityFromMovement`的值。这是一种生成火箭发动机喷出的烟雾的绝佳方式：'
- en: '[PRE57]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Making particles move](img/8874OS_10_27.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![制作粒子移动](img/8874OS_10_27.jpg)'
- en: The second way of addressing the behavior of particles is to influence their
    attributes after they are born—in any particular moment of their life. This can
    be done using affectors. These are items inheriting affector, which can modify
    some attributes of particles currently traveling though the area of the affector.
    One of the simplest affectors is `Age`. It can advance particles to a point in
    their lifetime where they only have `lifeLeft` milliseconds of their life left.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 处理粒子行为的第二种方式是在粒子出生后影响它们的属性——在任何特定的生活时刻。这可以通过使用影响者来实现。这些是继承影响者的项目，可以修改正在通过影响者区域的粒子的某些属性。最简单的影响者之一是`Age`。它可以将粒子推进到它们生命中的某个点，此时它们只剩下`lifeLeft`毫秒的生命。
- en: '[PRE58]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Setting `once` to `true` makes each affector influence a given particle only
    once. Otherwise, each particle can have its attributes modified many times.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将`once`设置为`true`使得每个影响者只对给定的粒子产生一次影响。否则，每个粒子可以多次修改其属性。
- en: Another affector type is Gravity, which can accelerate particles in a given
    angle. Friction can slow particles down, and attractor will affect the particle's
    position, velocity, or acceleration so that it starts traveling toward a given
    point. Wander is great for simulating snowflakes or butterflies flying in pseudo-random
    directions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种影响类型是重力，它可以在给定角度加速粒子。摩擦可以减慢粒子的速度，而吸引物将影响粒子的位置、速度或加速度，使其开始向一个特定点移动。漫游非常适合模拟雪花或蝴蝶以伪随机方向飞行的场景。
- en: There are also other affector types available, but we will not go into their
    details here. We would like to warn you, however, against using affectors too
    often—they can severely degrade performance.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的影响者可用，但在这里我们不会详细介绍。然而，我们想提醒您，不要过度使用影响者——它们可能会严重降低性能。
- en: Time for action – vanishing coins spawning particles
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——消失的硬币产生粒子
- en: It is time now to practice our freshly acquired skills. The task is to add a
    particle effect to the game when the player collects coins. The coin will explode
    into a sprinkle of colorful stars when collected.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候练习我们新获得的本领了。任务是当玩家收集硬币时，向游戏中添加粒子效果。当收集到硬币时，硬币会爆炸成一片五彩缤纷的星星。
- en: 'Start by declaring a particle system as filling the game scene, along with
    the particle painter definition:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个粒子系统，使其填充游戏场景，以及粒子画家定义：
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, modify the definition of Coin to include an emitter:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改硬币的定义以包括一个发射器：
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, the hit function has to be updated:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须更新击中函数：
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*What just happened?*'
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In this exercise, we defined a simple particle system that fills the whole scene.
    We defined a simple image painter for the particles where we allow particles to
    take on all the colors and start in all possible rotations. We used a star pixmap
    as our particle template.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们定义了一个简单的粒子系统，它填充了整个场景。我们为粒子定义了一个简单的图像画家，其中我们允许粒子采用所有颜色并在所有可能的旋转中开始。我们使用星形像素图作为粒子模板。
- en: Then, an `Emitter` object is attached to every coin. Its `emitRate` is set to
    `0`, which means it does not emit any particles on its own. We set a varying life
    span on particles and let them fly in all directions by setting their initial
    velocity with an angle variation of 180 degrees in both directions (giving a total
    of 360 degrees). By setting an acceleration, we give the particles a tendency
    to travel toward the bottom edge of the scene.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`Emitter`对象附加到每个硬币上。其`emitRate`设置为`0`，这意味着它不会自行发射任何粒子。我们为粒子设置了不同的生存期，并通过设置它们的初始速度，在两个方向上设置角度变化为180度（总共360度），使它们向所有方向飞行。通过设置加速度，我们给粒子一个向场景底部边缘移动的倾向。
- en: In the hit function, we call a `burst()` function on the emitter, which makes
    it give instant birth to a given number of particles.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在击中函数中，我们在发射器上调用一个 `burst()` 函数，这使得它能够立即产生一定数量的粒子。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have shown you how to extend your QML skills to make your
    applications dynamic and attractive. We've gone through the process of recreating
    and improving a game created earlier in C++ to familiarize you with such concepts
    as collision detection, state-driven objects, and time-based game loops. We also
    presented you with a tool in the form of `ShaderEffect`, which can serve as a
    means to create stunning graphics without compromising performance, and we taught
    you to use a particle system.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何扩展您的 QML 技能，使您的应用程序动态且吸引人。我们回顾并改进了之前用 C++ 创建的游戏，让您熟悉碰撞检测、状态驱动对象和时间驱动的游戏循环等概念。我们还向您介绍了一种名为
    `ShaderEffect` 的工具，它可以作为创建令人惊叹的图形而不牺牲性能的手段，并教会您使用粒子系统。
- en: Of course, Qt Quick is much richer than all this, but we had to stop somewhere.
    The set of skills we have hopefully passed on to you should be enough to develop
    many great games. However, many of the elements have more properties than we have
    described here. Whenever you want to extend your skills, you can check the reference
    manual to see if the element type has more interesting attributes.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Qt Quick 比所有这些都要丰富得多，但我们不得不在某处停下来。我们希望传授给您的技能集应该足够开发许多优秀的游戏。然而，许多元素具有比我们在这里描述的更多的属性。每当您想要扩展您的技能时，您都可以查看参考手册，看看元素类型是否有更多有趣的属性。
- en: This concludes our book on game programming using Qt. We have taught you the
    general basics of Qt, described its widget realm to you, and introduced you to
    the fascinating world of Qt Quick. Widgets (including graphics view) and Qt Quick
    are the two paths you can take when creating games using the Qt framework. We
    have also shown you ways of merging the two approaches by making use of any OpenGL
    skills you might have, going beyond what Qt already offers today. At this point,
    you should start playing around and experimenting, and if at any point you feel
    lost or simply lack the information on how to do something, the very helpful Qt
    reference manual should be the first resource you direct yourself to.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用 Qt 进行游戏编程的书籍。我们向您介绍了 Qt 的一般基础知识，描述了其小部件领域，并引入了 Qt Quick 的迷人世界。小部件（包括图形视图）和
    Qt Quick 是您在用 Qt 框架创建游戏时可以采取的两种路径。我们还向您展示了如何通过利用您可能拥有的任何 OpenGL 技能来合并这两种方法，超越
    Qt 当前的提供。此时，您应该开始尝试和实验，如果在任何时刻您感到迷茫或只是缺乏如何做某事的信息，那么非常有帮助的 Qt 参考手册应该是您首先指向的资源。
- en: Good luck and have lots of fun!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 祝您好运，玩得开心！
