- en: Chapter 10. Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we introduced you to the basics of Qt Quick and QML.
    By now, you should be fluent enough with the syntax and understand the basic concepts
    of how Qt Quick works. In this chapter, we will show you how to make your games
    stand out from the crowd by introducing different kinds of animations that make
    your applications feel more like the real world. You will also learn to treat
    Qt Quick objects as separate entities programmable using state machines. A large
    section of this chapter is devoted to making your games prettier by using OpenGL
    effects and particle systems. Another significant part of this chapter will introduce
    how to implement a number of important gaming concepts using Qt Quick. All this
    is going to be shown with the building of a simple 2D action game using the presented
    concepts.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bringing life into static user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have described so far can be called anything but "fluid." Let's change
    that now by learning how to add some dynamics into the user interfaces we create.
    Thus far, books cannot contain moving pictures, so most things we describe here
    you will have to test yourself by running the provided Qt Quick code.
  prefs: []
  type: TYPE_NORMAL
- en: Animating elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Quick provides a very extensive framework for creating animations. By that,
    we don't mean only moving items around. We define an animation as *changing an
    arbitrary value over time*. So, what can we animate? Of course, we can animate
    item geometry. But we can also animate rotation, scale, other numeric values,
    and even colors. But let's not stop here. Qt Quick also lets you animate the parent-child
    hierarchy of items or anchor assignments. Almost anything that can be represented
    by an item property can be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the changes are rarely linear—if you kick a ball in the air, it first
    gains height quickly because its initial speed was large. However, the ball is
    a physical object being pulled down by the Earth's gravity, which slows the climb
    down until the ball stops and then starts falling down, accelerating until it
    hits the ground. Depending on the properties of both the ground and ball, the
    object can bounce off the surface into the air again with less momentum, repeating
    the spring-like motion until eventually it fades away, leaving the ball on the
    ground. Qt Quick lets you model all that using easing curves that can be assigned
    to animations.
  prefs: []
  type: TYPE_NORMAL
- en: Generic animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Qt Quick provides a number of animation types derived from a generic `Animation`
    element that you will never use directly. The type exists only to provide an API
    common to different animation types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the animation framework by looking at a family of
    animation types derived from the most common animation type—`PropertyAnimation`.
    As the name implies, they provide the means to animate values of object properties.
    Despite the fact that you can use the `PropertyAnimation` element directly, it
    is usually more convenient to use one of its subclasses that are specialized in
    dealing with peculiarities of different data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic property animation type is `NumberAnimation`, which lets you
    animate all kinds of numeric values of both integral and real numbers. The simplest
    way of using it is to declare an animation, tell it to animate a specific property
    in a specific object, and then set the length of the animation and the starting
    and ending value for the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – scene for an action game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Qt Quick UI project. In the project directory, make a subdirectory
    called `images` and from the game project that we have created using Graphics
    View copy `grass.png`, `sky.png`, and `trees.png`. Then, put the following code
    into the QML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the project now, you will see a screen similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – scene for an action game](img/8874OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set up a very simple scene consisting of three images stacked up to form
    a landscape. Between the background layer (the sky) and the foreground (trees),
    we placed a yellow circle representing the sun. Since we are going to be moving
    the sun around in a moment, we anchored the center of the object to an empty item
    without physical dimensions so that we can set the sun's position relative to
    its center. We also equipped the scene with a `dayLength` property, which is going
    to hold information about the length of one day of game time. By default, we set
    it to 60 seconds so that things happen really fast and we can see the animation's
    progress without waiting. After all things are set correctly, the length of the
    day can be balanced to fit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: The graphical design lets us easily manipulate the sun while keeping it behind
    the tree line. Notice how the stacking order is implicitly determined by the order
    of elements in the document.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating the sun's horizontal movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The everyday cruise of the sun in the sky starts in the east and continues west
    to hide beneath the horizon in the evening. Let's try to replicate this horizontal
    movement by adding animation to our `sun` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the QML document of our last project. Inside the `root` item add the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program with such modifications will produce a run with a horizontal
    movement of the sun. The following image is a composition of a number of frames
    of the run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – animating the sun''s horizontal movement](img/8874OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced a `NumberAnimation` element that is set to animate the `x` property
    of the `sun` object. The animation starts at `0` and lasts until `x` reaches the
    `root` item's width (which is the right edge of the scene). The movement lasts
    for `dayLength` miliseconds. The `running` property of the animation is set to
    `true` to enable the animation. Since we didn't specify otherwise, the motion
    is linear.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that the animation runs in the wrong direction—"west"
    is on the left and "east" is on the right, yes? That's true, however, only if
    the observer faces north. If that were the case for our scene, we wouldn't be
    seeing the sun at all—at noon, it crosses the south direction.
  prefs: []
  type: TYPE_NORMAL
- en: Composing animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The animation we made in the last section looks okay but is not very realistic.
    The sun should rise in the morning, reach its peak sometime before noon, and then
    sometime later start setting toward the evening, when it should cross the horizon
    and hide beneath the landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve such an effect, we could add two more animations for the `y` property
    of the sun. The first animation would start right at the beginning and decrease
    the vertical position of the sun (remember that the vertical geometry axis points
    down, so decreasing the vertical position means the object goes up). The animation
    would be complete at one third of the day length. We would then need a way to
    wait for some time and then start a second animation that would pull the object
    down toward the ground. Starting and stopping the animation is easy—we can either
    call the `start()` and `stop()` functions on the animation item or directly alter
    the value of the `running` property. Each `Animation` object emits `started()`
    and `stopped()` signals. The delay can be implemented by using a timer. We could
    provide a signal handler for the stopped signal of the first animation to trigger
    a timer to start the other one like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even ignoring any side problems this would bring (for example, how to stop the
    animation without starting the second one), such an approach couldn't be called
    "declarative," could it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, similar to what we had in C++, Qt Quick lets us form animation
    groups that run either parallel to each other or in sequence. There are the `SequentialAnimation`
    and `ParallelAnimation` types where you can declare any number of child animation
    elements forming the group. To run two animations in parallel, we could declare
    the following hierarchy of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The same technique can be used to synchronize a larger group of animations,
    even if each component has a different duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The group presented in the snippet consists of three animations. The first
    two animations are executed together as they form a parallel subgroup. One member
    of the group runs twice as long as the other. Only after the whole subgroup completes
    is the third animation started. This can be visualized using a UML activity diagram
    where the size of each activity is proportional to the duration of that activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing animations](img/8874OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – making the sun rise and set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add vertical movement (animation of the `y` property) to our sun by adding
    a sequence of animations to the QML document. As our new animations are going
    to be running in parallel to the horizontal animation, we could enclose animations
    for both directions within a single `ParallelAnimation` group. It would work,
    but in our opinion this would unnecessarily clutter the document. Another way
    of specifying parallel animations is to declare them as separate hierarchies of
    elements, making each animation independent of the other, and that is what we
    are going to do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our document from the last exercise and right under the previous animation,
    place the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running the program will result in the light source rising in the morning and
    setting in the evening. However, the trajectory of the move seems somewhat awkward.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – making the sun rise and set](img/8874OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We declared a sequential animation group consisting of three animations, each
    taking 1/3 of the day length. The first member of the group makes the sun go up.
    The second member, which is an instance of a new element type—`PauseAnimation`—introduces
    a delay equal to its duration. This in turn lets the third component start its
    work in the afternoon to pull the sun down toward the horizon.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with such a declaration is that the sun moves in a horribly angular
    way, as can be seen in the image.
  prefs: []
  type: TYPE_NORMAL
- en: Non-linear animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason for the described problem is that our animations are linear. As we
    noted in the beginning of this chapter, linear animations rarely occur in nature,
    which usually makes their use yield a very unrealistic result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also said earlier that Qt Quick allows us to use easing curves to perform
    animations along non-linear paths. There are a large number of curves offered.
    Here is a diagram listing available non-linear easing curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Non-linear animations](img/8874OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use any of the curves on an element of the type `PropertyAnimation`
    or one derived from it (for example, `NumberAnimation`). This is done by using
    the `easing` property group, where you can set the `type` of the curve. Different
    curve types may further be tweaked by setting a number of properties in the `easing`
    property group, such as `amplitude` (for bounce and elastic curves), `overshoot`
    (for back curves), or `period` (for elastic curves).
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring an animation along an `InOutBounce` path is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – improving the path of the sun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The task at hand is going to be to improve the animation of the sun so that
    it behaves in a more realistic way. We will do this by adjusting the animations
    so that the object moves over a curved path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our QML document, replace the previous vertical animation with the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – improving the path of the sun](img/8874OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sequence of three animations (two linear ones and a pause) was replaced
    by another sequence of two animations that follow a path determined by a cubic
    function. This makes our sun rise pretty fast and then slow down to an amount
    almost unnoticeable near the moment when the sun approaches noon. When the first
    animation is finished, the second one reverses the motion, making the sun descend
    very slowly and then increase its velocity as dusk approaches. As a result, the
    further the sun is away from the ground, the slower it seems to move. At the same
    time, the horizontal animation remains linear as the speed of Earth in its motion
    around the Sun is practically constant. When we combine the horizontal and vertical
    animations, we get a path that looks very similar to what we can observe in the
    real world.
  prefs: []
  type: TYPE_NORMAL
- en: Property value sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From a QML perspective, animation and element types derived from it are something
    called *property value source*. This means they can be attached to a property
    and generate values for it. What is important is that it allows us to use animations
    using a much simpler syntax. Instead of explicitly declaring the target and property
    of an animation, one can attach the animation to a named property of the parent
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, instead of specifying `target` and `property` for `Animation`,
    use the `on` keyword followed by the name of a property name for which the animation
    is to be a value source. For example, to animate the `rotation` property of an
    object with a `NumberAnimation` object, the following code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is valid to specify more than one property value source for the same property
    of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adjusting the sun's color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at the sun at dusk or dawn, you will see that it is not yellow,
    but rather becomes red the closer it is to the horizon. Let's teach our object
    representing the sun to do the same by providing a property value source for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the QML document, find the declaration for the `sunVisual` object, and
    extend it with the highlighted part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An animation was attached to the `color` property of our rectangle modeling
    the visual aspects of the sun. The animation consists of three parts. First, we
    perform a transition from red to yellow using the `ColorAnimation` object. This
    is an `Animation` subtype dedicated to modifying colors. Since the rectangle color
    is not a number, using the `NumberAnimation` object would not have worked as the
    type cannot interpolate color values. Therefore, we either have to use the `PropertyAnimation`
    or `ColorAnimation` object. The duration for the animation is set to 20 percent
    of half the day length so that the yellow color is obtained very quickly. The
    second component is a `PauseAnimation` object to provide a delay before the third
    component is executed, which gradually changes the color back to red. For the
    last component, we do not provide a value for the `from` property. This causes
    the animation to be initiated with the value of the property current to the time
    when the animation is executed (in this case, the sun should be yellow).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we only had to specify the property name for the top-level animation.
    This particular element is what serves as the property value source, and all descendant
    animation objects "inherit" the target property from that property value source.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – furnishing sun animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The animation of the sun looks almost perfect right now. We can still improve
    it, though. If you look into the sky in the early morning and then again at noon,
    you will notice that the sun appears much bigger during sunrise or sunset compared
    to its size in zenith. We can simulate that effect by scaling the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our scene document, add another sequential animation that operates on the
    `scale` property of the sun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – furnishing sun animation](img/8874OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we just followed the path set for an earlier declaration—the
    vertical movement of the stellar body influences its perceived size; therefore,
    it seems like a good decision to bind the two animations together. Notice that
    instead of specifying a new property value source for the scale, we might have
    modified the original animation and made the scale animation parallel to that
    operate on the `y` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero – animating the sun's rays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, you should be an animation expert. If you want to try your skills,
    here is a task for you. The following code can be applied to the `sun` object
    and will display very simple red rays emitted from the sun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Have a go hero – animating the sun''s rays](img/8874OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The goal is to animate the rays so that the overall effect looks good and fits
    the tune like style of the scene. Try different animations—rotations, size changes,
    and colors. Apply them to different elements—all rays at once (for example, using
    the `sunRays` identifier) or only particular rectangles generated by the repeater.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a dashboard for a racing game where
    we had a number of clocks with needles. We could set values for each clock (for
    example, car speed) and a respective needle would immediately set itself to the
    given value. But such an approach is unrealistic—in the real world, changes of
    a value happen over time. In our example, the car accelerates from 10 mph to 50
    mph by going through 11 mph, 12 mph and so on, until after some time it reaches
    the desired value. We call this the *behavior* of a value—it is essentially a
    model that tells how the parameter reaches its destined value. Defining such models
    is a perfect use case for declarative programming. Fortunately, QML exposes a
    `Behavior` element that lets us model behaviors of property changes in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Behavior` elements let us associate an animation with a given property
    so that, every time the property value is to be changed, it is done by running
    the given animation instead of by making an immediate change to the property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code implements a simple scene with a red rectangle anchored
    to an empty item. Whenever the user clicks somewhere within the scene, the empty
    item is moved there, dragging along the rectangle. Let''s see how to use the `Behavior`
    element to smoothly change the position of the empty item. The `Behavior` element
    is a property value source just like the `Animation` element itself; thus, it
    is easiest to use on the on-property syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By adding the two marked declarations, we define behaviors for properties `x`
    and `y` that follow animations defined by `NumberAnimation`. We do not include
    start or end values for the animation as these will depend on the initial and
    final value for the property. We also don't set the property name in the animation
    because by default, the property for which the behavior is defined will be used.
    As a result, we get a linear animation of a numerical property from the original
    value to the destined value over the default duration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using linear animations for real world objects rarely looks good. Usually, you
    will get much better results if you set an easing curve for the animation so that
    it starts slowly and then gains speed and decelerates just before it is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Animations that you set on behaviors can be as complex as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The behavioral model declared in the last piece of code performs a sequential
    animation. It first changes the color of the rectangle to yellow using the `PropertyAction`
    element, which performs an immediate update of a property value (we will talk
    about this more a bit later). The color will be set back to red after, as the
    last step of the model. In the meantime, a parallel animation is performed. One
    of its components is a `NumberAnimation` class that executes the actual animation
    of the `x` property of `empty` (since the target and property of the animation
    are not explicitly set). The second component is a sequential animation of the
    `scale` property of the rectangle, which first scales the item up by 50 percent
    during the first half of the animation and then scales it back down in the second
    half of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating the car dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's employ the knowledge we just learned to improve our car dashboard so that
    it shows some realism in the way the clocks update their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the dashboard project and navigate to the `dashboard.qml` file. Find the
    declaration of the `Needle` object, which is responsible for visualizing the speed
    of the vehicle. Add the following declaration to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the process for the left clock. Set the velocity of the animation to
    `100`. Build and run the project. See how the needles behave when you modify the
    parameter values in spinboxes. Adjust the `velocity` of each animation until you
    get a realistic result.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set the property value sources on needle rotations that are triggered
    whenever a new value for the property is requested. Instead of immediately accepting
    the new value, the `Behavior` element intercepts the request and starts the `SmoothedAnimation`
    class to gradually reach the requested value. The `SmoothedAnimation` class is
    an animation type that animates numeric properties. The speed of the animation
    is not determined by its duration, but instead a `velocity` property is set. This
    property dictates how fast a value is to be changed. However, the animation is
    using a non-linear path—it first starts slowly, then accelerates to the given
    velocity and near the end of the animation, decelerates in a smooth fashion. This
    yields an animation that is attractive and realistic and at the same time, is
    of shorter or longer duration, depending on the distance between the starting
    and ending values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can implement custom property value sources by subclassing `QQmlPropertyValueSource`
    and registering the class in the QML engine.
  prefs: []
  type: TYPE_NORMAL
- en: States and transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you look at real world objects, it is often very easy to define their behavior
    by extracting a number of states the object may take and describing each of the
    states separately. A lamp can be turned either on or off. When it is "on" it is
    emitting light of a given color, but it is not doing that when in the "off" state.
    Dynamics of the object can be defined by describing what happens if the object
    leaves one of the states and enters another one. Considering our lamp example,
    if you turn the lamp on, it doesn't momentarily start emitting light with its
    full power, but rather the brightness of the light gradually increases to reach
    its final power after a very short period.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick supports *state-driven* development by letting us declare states and
    transitions between them for items. The model fits the declarative nature of Qt
    Quick very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, each item has a single anonymous state and all properties you define
    take values of the expressions you bind or assign to them imperatively based on
    different conditions. Instead of this, a set of states can be defined for the
    object and for each of the state properties of the object itself; in addition,
    the objects defined within it can be programmed with different values or expressions.
    Our example lamp definition could be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We could, of course, bind the `color` property of `lightsource` to `lamp.lampOn
    ? "yellow" : "transparent"`, but instead we can define an "on" state for the lamp
    and use a `PropertyChanges` element to modify the rectangle color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each item has a `state` property that you can read to get the current state,
    but you can also write to it to trigger transition to a given state. By default,
    the `state` property is set to an empty string that represents the anonymous state.
    Note that with the preceding definition, the item has two states—the "on" state
    and the anonymous state (which in this case is used when the lamp is off). Remember
    that state names have to be unique as the `name` parameter is what identifies
    a state in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter a state, we can, of course, use an event handler fired when the value
    of the `lampOn` parameter is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Such imperative code works, but it can be replaced with a declarative definition
    in the state itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the expression bound to the `when` property evaluates to `true`, the
    state becomes active. If the expression becomes `false`, the object will return
    to the default state or will enter a state for which its own `when` property evaluates
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define more than one custom state, it is enough to assign a list of state
    definitions to the `states` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `PropertyChanges` element is the most often used change in a state definition,
    but it is not the only one. In exactly the same way that the `ParentChange` element
    can assign a different parent to an item and the `AnchorChange` element can update
    anchor definitions, it is also possible to run a script when a state is entered
    using the `StateChangeScript` element. All these element types are used by declaring
    their instances as children in a `State` object.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the state machine framework is defining how an object transits
    from one state to another. Similar to the `states` property, all items have a
    `transitions` property, which takes a list of definitions represented by the `Transition`
    objects and provides information about animations that should be played when a
    particular transition takes place.
  prefs: []
  type: TYPE_NORMAL
- en: A transition is identified by three attributes—the source state, the destination
    state, and a set of animations. Both the source state name (set to the `from`
    property) and the target state name (set to the `to` property) can be empty, in
    which case they should be interpreted as "any". If a `Transition` exists that
    matches the current state change, its animations will be executed. A more concrete
    transition definition (which is one where `from` and/or `to` are explicitly set)
    has precedence over a more generic one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to animate the opacity of the lamp rectangle from `0`
    to `1` when the lamp is switched on. We can do it as an alternative to manipulating
    the color. Let''s update the lamp definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The transition is triggered for any source and any target state—it will be active
    when the lamp goes from the anonymous to the "on" state, as well as in the opposite
    direction. It defines a single `NumberAnimation` element that lasts for 100 miliseconds.
    The animation does not define the target object nor the property it works on;
    thus, it will be executed for any property and any object that needs updating
    as part of the transition—in the case of the lamp, it will only be the `opacity`
    property of the `lightsource` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If more than one animation is defined in a transition, all animations will
    run in parallel. If you need a sequential animation, you need to explicitly use
    a `SequentialAnimation` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: States are a feature of all `Item` types as well as its descendent types. It
    is, however, possible to use states with elements not derived from the `Item`
    object by using a `StateGroup` element, which is a self-contained functionality
    of states and transitions with exactly the same interface as what is described
    here regarding `Item` objects.
  prefs: []
  type: TYPE_NORMAL
- en: More animation types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The animation types we discussed earlier are used for modifying values of types
    that can be described using physical metrics (position, sizes, colors, angles).
    But there are more types available.
  prefs: []
  type: TYPE_NORMAL
- en: The first group of special animations consists of the `AnchorAnimation` and
    `ParentAnimation` elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `AnchorAnimation` element is useful if a state change should cause a change
    to defined anchors for an item. Without it, the item would immediately snap into
    its place. By using the `AnchorAnimation` element, we trigger all anchor changes
    to be gradually animated.
  prefs: []
  type: TYPE_NORMAL
- en: The `ParentAnimation` element, on the other hand, makes it possible to define
    animations that should be present when an item receives a new parent. This usually
    causes an item to be moved to a different position in the scene. By using the
    `ParentAnimation` element in a state transition, we can define how the item gets
    into its target position. The element can contain any number of child animation
    elements that are going to be run in parallel during a `ParentChange` element.
  prefs: []
  type: TYPE_NORMAL
- en: The second special group of animations is action animations—`PropertyAction`
    and `ScriptAction`. These animation types are not stretched in time, but rather
    perform a given one-time action.
  prefs: []
  type: TYPE_NORMAL
- en: The `PropertyAction` element is a special kind of animation that performs an
    immediate update of a property to a given value. It is usually used as part of
    a more complex animation to modify a property that is not animated. It makes sense
    to use it if a property needs to have a certain value during an animation.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScriptAction` is an element that allows the execution of an imperative
    piece of code during an animation (usually at its beginning or end).
  prefs: []
  type: TYPE_NORMAL
- en: Quick game programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will go through the process of creating a platform game using Qt Quick.
    It will be a game similar to Benjamin the Elephant from [Chapter 6](ch06.html
    "Chapter 6. Graphics View"), *Graphics View*. The player will control a character
    that will be walking through the landscape and collecting coins. The coins will
    randomly be appearing in the world. The character can access highly placed coins
    by jumping. The more the character jumps, the more tired he gets and the slower
    he begins to move and has to rest to regain speed. To make the game more difficult,
    at times moving obstacles will be generated. When the character bumps into any
    of them, he gets more and more tired. When the fatigue exceeds a certain level,
    the character dies and the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter as well as the previous one, we prepared a number of
    pieces we will be reusing for this game. The layered scene that was arranged when
    you learned about animations will serve as our game scene. The animated sun is
    going to represent the passing of time. When the sun sets, the time runs out and
    the game ends. The heartbeat diagram will be used to represent the character's
    level of fatigue—the more tired the character gets, the faster his heart beats.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways this game can be implemented and we want to give you a level
    of freedom, so this is not going to be a step-by-step guide on how to implement
    a complete game. At some points, we will be telling you to employ some skills
    you have already learned to perform some task without telling you how to do it.
    At others, we will provide broad descriptions and complete solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Game loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most games revolve around some kind of game loop. It is usually some kind of
    function that is repeatedly called at constant intervals and its task is to progress
    the game—process input events, move objects around, calculate and execute actions,
    check win conditions, and so on. Such an approach is very imperative and usually
    results in a very complex function that needs to know everything about everybody
    (This kind of anti-pattern is sometimes called a *god object* pattern). In QML
    (which powers the Qt Quick framework), we aim to separate responsibilities and
    declare well-defined behaviors for particular objects. Therefore, although it
    is possible to set up a timer which will periodically call a game loop function,
    this is not the best possible approach in a declarative world.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we suggest using a natural time-flow mechanism already present in Qt
    Quick—one that controls the consistency of animations. Remember how we defined
    the sun's travel across the sky at the beginning of this chapter? Instead of setting
    up a timer and moving the object by a calculated number of pixels, we created
    an animation, defined a total running time for it, and let Qt take care of updating
    the object. This has the great benefit of neglecting delays in function execution.
    If you used a timer and some external event introduced a significant delay before
    the timeout function was run, the animation would start lagging behind. When Qt
    Quick animations are used, the framework compensates for such delays, skipping
    some of the frame updates to ensure that the requested animation duration is respected.
    Thanks to that, you will not have to take care of it all by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the second difficult aspect of a game loop—the god anti-pattern—we
    suggest encapsulating the logic of each item directly in the item itself the using
    states and transitions framework we introduced earlier. If you define an object
    using a natural time flow describing all states it can enter during its lifetime
    and actions causing transitions between states, you will be able to just plop
    the object with its included behavior wherever it is needed and thus easily reuse
    such definitions in different games, reducing the amount of work necessary to
    make the object fit into the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for input event processing, a usual approach in games is to read input events
    and call functions responsible for actions associated with particular events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This, however, has its drawbacks, one of which is the need to check events at
    even periods of time. This might be hard and certainly is not a declarative approach.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that Qt Quick handles keyboard input via the `Keys` attached
    property. It is possible to craft QML code similar to the one just presented,
    but the problem with such an approach is that the faster the player taps keys
    on the keyboard, the more frequently the character will move, jump, or shoot.
    It isn't hard if it is done properly, though.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – character navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new QML document and call it `Player.qml`. In the document, place
    the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the document containing the main scene definition and declare the
    player character near the end of the document after all the background layers
    are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player itself is an empty item with a keyboard focus that handles presses
    of the right, left, and up arrow keys, causing them to manipulate the `x` and
    `y` coordinates of the player. The `x` property has a `Behavior` element set so
    that the player moves smoothly within the scene. Finally, anchored to the player
    item is the actual visualization of the player—our elephant friend.
  prefs: []
  type: TYPE_NORMAL
- en: When the right or left arrow keys are pressed, a new position for the character
    will be calculated and applied. Thanks to the `Behavior` element, the item will
    travel gradually (during one second) to the new position. Keeping the key pressed
    will trigger auto-repeat and the handler will be called again. In a similar fashion,
    when the spacebar is pressed, it will activate a prepared sequential animation
    that will lift the character up by 50 pixels and then move it down again to the
    initial position.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works but we can do better. Let's try something different.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – another approach to character navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Replace the previous key handlers with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of performing actions immediately, upon pressing a key, we are now setting
    flags (in a private object) for which direction the character should be moving
    in. In our situation, the right direction has priority over the left direction.
    Setting a flag triggers an animation that tries to move the character toward an
    edge of the scene. Releasing the button will clear the flag and stop the animation.
    Before the animation is started, we are calling the `recalculateDurations()` function,
    which checks how long the animation should last for the character to move at the
    desired speed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to replace keyboard-based input with something else, for example,
    accelerometer or custom buttons, the same principle can be applied. When using
    an accelerometer, you can even control the speed of the player by measuring how
    much the device is tilted. You can addtionally store the tilt in the `flags.horizontal`
    parameter and make use of that variable in the `recalculateDurations()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – polishing the animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have done is sufficient for many applications. However, you can try
    controlling the movement even more. As a challenge, try modifying the system in
    such a way that during a jump, inertia keeps the current horizontal direction
    and speed of movement of the character until the end of the jump. If the player
    releases the right or left keys during a jump, the character will stop only after
    the jump is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Despite trying to do everything in a declarative fashion, some actions will
    still require imperative code. If some action is to be executed periodically,
    you can use the `Timer` parameter to execute a function on demand. Let's go through
    the process of implementing such patterns together.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – generating coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the game we are trying to implement is to collect coins. We will
    spawn coins now and then in random locations of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new QML Document and call it `Coin.qml`. In the editor, enter the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the document where the scene is defined and enter the following
    code somewhere in the scene definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we defined a new element type, `Coin`, consisting of a yellow circle
    with a number centered over an empty item. The rectangle has an animation applied
    that rotates the item around a vertical axis, resulting in a pseudo three-dimensional
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a component able to create instances of a `Coin` element is placed in
    the scene. Then, a `Timer` element is declared that fires every second and spawns
    a new coin at a random location of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player character, as well as any other component of the game, should be
    animated. If the component is implemented using simple Qt Quick shapes, it is
    quite easy to do by changing the item's properties fluently, by way of using property
    animations (like we did with the `Coin` object). Things get more difficult if
    a component is complex enough that it is easier to draw it in a graphics program
    and use an image in the game instead of trying to recreate the object using Qt
    Quick items. Then, one needs a number of images—one for every frame of animation.
    Images would have to keep replacing one another to make a convincing animation.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing simple character animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to make the player character animated in a simple way. In materials
    that come with this book, you will find a number of images with different walking
    phases for Benjamin the Elephant. You can use them or you can draw or download
    some other images to be used in place of those provided by us.
  prefs: []
  type: TYPE_NORMAL
- en: Put all images in one directory (for example, `images`) and rename them so that
    they follow a pattern that contains the base animation name followed by a frame
    number, for example, `walking_01`, `walking_02`, `walking_03`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `Player.qml` document and replace the image element showing
    "`elephant.png`" with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the root element of `Player.qml`, add the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Start the program and use the arrow keys to see Benjamin move.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of images were prepared following a common naming pattern containing
    a number. All the images have the same size. This allows us to replace one image
    with another just by changing the value of the `source` property to point to a
    different image. To make it easier, we introduced a property called the `currentFrame`
    element that contains the index of the image to be displayed. We used the `currentFrame`
    element in a string forming an expression bound to the `source` element of the
    image. To make substituting frames easy, a `NumberAnimation` element was declared
    to modify values of the `currentFrame` element in a loop from `1` to the number
    of animation frames available (represented by the `frameCount` property), so that
    each frame is shown for 40 miliseconds. The animation is playing if the `walking`
    property evaluates to `true` (based on the value of the `flags.horizontal` element
    in the player object). Finally, we use the `mirror` property of the `Image` parameter
    to flip the image if the character is walking left.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding approach works, but is not perfect. The complexity of the declaration
    following this pattern grows much faster than required when we want to make movement
    animation more complex (for example, if we want to introduce jumping). This is
    not the only problem, though. Loading images does not happen instantly. The first
    time a particular image is to be used, the animation can stall for a moment while
    the graphics get loaded, which might ruin the user experience. Lastly, it is simply
    messy to have a bunch of pictures here and there for every image animation.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this is to use **sprites**—geometrical animated objects consisting
    of small images combined into one larger image for better performance. Qt Quick
    supports sprites through its sprite engine that handles loading sequences of images
    from a sprite field, animating them and transitioning between different sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qt Quick, a sprite is an image of any type supported by Qt that contains
    an image strip with all frames of the animation. Subsequent frames should form
    a contiguous line flowing from left to right and from top to bottom of the image.
    However, they do not have to start in the top-left corner of the containing image,
    nor do they have to end in its bottom-right corner—a single file can contain many
    sprites. A sprite is defined by providing the size of a single frame in pixels
    and a frame count. Optionally, one can specify an offset from the top-left corner
    where the first frame of the sprite is to be read from. The following diagram
    can be helpful in visualizing the scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8874OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: QML offers a `Sprite` element type with a `source` property pointing to the
    URL of the container image, a `frameWidth` and `frameHeight` element determining
    the size of each frame, and a `frameCount` element defining the number of frames
    in the sprite. Offsetting the image can be achieved by setting values of the `frameX`
    and `frameY` properties. In addition to this, some additional properties are present;
    the most important three are `frameRate`, `frameDuration,` and `duration`. All
    these serve to determine the pace of the animation. If the `frameRate` element
    is defined, it is interpreted as a number of frames to cycle through per second.
    If this property is not defined, then the `frameDuration` element kicks in and
    is treated as a period of time in which to display a single frame (thus, it is
    directly an inverse of the `frameRate` element). If this property is not defined,
    as well, the `duration` element is used, which carries the duration of the whole
    animation. You can set any of the three properties, and precedence rules (`frameRate`,
    `frameDuration`, `duration`) will determine which of them are going to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating characters using sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's wait no further. The task at hand is to replace the manual animation from
    the previous exercise with a sprite-based animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Player.qml` document, remove the whole image element responsible
    for displaying the player character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have replaced the previous static image with an ever-changing source with
    a different item. As the `Sprite` parameter is not an `Item` element but rather
    a data definition of a sprite, we cannot use it in place of the `Image` element.
    Instead, we will use the `AnimatedSprite` element, which is an item that can display
    a single animated sprite defined inline. It even has the same set of properties
    as the `Sprite` parameter. We defined a sprite embedded in `images/walking.png`
    with a width of `80` and a height of `52` pixels. The sprite consists of seven
    frames that should be displayed at a rate of 10 frames per second. The `running`
    property is set up similar to the original `Animation` element. As the `AnimatedSprite`
    element does not have a `mirror` property, we emulate it by applying a scale transformation
    that flips the item horizontally if the `player.facingLeft` element evaluates
    to `true`. Additionally, we set the `interpolate` property to `true`, which makes
    the sprite engine calculate smoother transitions between frames.
  prefs: []
  type: TYPE_NORMAL
- en: The result we are left with is similar to an earlier attempt, so if these two
    are similar then why bother using sprites? In many situations, you want more complex
    animation than just a single frame sequence. What if we want to animate the way
    Benjamin jumps in addition to him walking? Embedding more manual animations, although
    possible, would explode the number of internal variables required to keep the
    state of the object. Fortunately, the Qt Quick sprite engine can deal with that.
    The `AnimatedSprite` element we used provides just a subset of features of the
    whole framework. By substituting the item with the `SpriteSequence` element we
    gain access to the full power of sprites. In talking about `Sprite`, we didn't
    tell you about one additional property of the object, a property called `to` that
    contains a map of probabilities of transitioning from the current sprite to another
    one. By stating which sprites the current one migrates to, we create a state machine
    with weighted transitions to other sprites, as well as cycling back to the current
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to another sprite is triggered by setting the `goalSprite` property
    on the `SpriteSequence` object. This will cause the sprite engine to traverse
    the graph until it reaches the requested state. It is a great way to fluently
    switch from one animation to another by going through a number of intermediate
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of asking the sprite machine to gracefully transit to a given state,
    one can ask it to force an immediate change by calling the `SpriteSequence` class's
    `jumpTo()` method and feeding it with the name of the sprite that should start
    playing.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that needs to be clarified is how to actually attach the sprite
    state machine to the `SpriteSequence` class. It is very easy; just assign an array
    of the `Sprite` objects to the `sprites` property.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding jumping with sprite transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's replace the `AnimatedSprite` class with the `SpriteSequence` class in
    the Bejamin the Elephant animation, adding a sprite to be played during the jumping
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Player.qml` file and replace the `AnimatedSprite` object with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, extend the `jumpAnim` object by adding the highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`The SpriteSequence` element we have introduced has its `Item` elements-related
    properties set up in the same way as when the `AnimatedSprite` element was used.
    Apart from that, a sprite called "still" was explicitly set as the current one.
    We defined a number of `Sprite` objects as children of the `SpriteSequence` element.
    This is equivalent to assigning those sprites to the `sprites` property of the
    object. The complete state machine that was declared is presented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8874OS_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sprite called "still" has just a single frame representing a situation when
    Benjamin doesn't move. The sprite keeps spinning in the same state due to the
    weighted transition back to the "still" state. The two remaining transitions from
    that state have their weights set to `0`, which means they will never trigger
    spontaneously, but they can be invoked by setting the `goalSprite` property to
    a sprite that can be reached by activating one of those transitions.
  prefs: []
  type: TYPE_NORMAL
- en: The sequential animation was extended to trigger sprite changes when the elephant
    lifts into the air.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – making Benjamin wiggle his tail in anticipation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To practice sprite transitions, your goal is to extend the state machine of
    Benjamin's `SpriteSequence` element to make him wiggle his tail when the elephant
    is standing still. You can find the appropriate sprite in the materials that come
    included with this book. The sprite field is called `wiggling.png`. Implement
    the functionality by making it probable that Benjamin spontaneously goes from
    the "still" state to "wiggling". Pay attention to ensure the animal stops wiggling
    and starts walking the moment the player activates the right or left arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: Parallax scrolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already discussed the useful technique of parallax scrolling in [Chapter
    6](ch06.html "Chapter 6. Graphics View"), *Graphics View*. Just to recapitulate,
    it gives the impression of depth for 2D games by moving multiple layers of background
    at a different speed depending on the assumed distance of the layer from the viewer.
    We will now see how easy it is to apply the same technique in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – revisiting parallax scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement parallax scrolling with a set of layers that move in the direction
    opposite to the one the player is moving in. Therefore, we will need a definition
    of the scene and a moving layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new QML Document (Qt Quick 2). Call it `ParallaxScene.qml`. The scene
    will encompass the whole game "level" and will expose the position of the player
    to the moving layers. Put the following code in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create another QML Document (Qt Quick 2) and call it `ParallaxLayer.qml`.
    Make it contain the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the two new element types in the main QML document. We''ll
    take elements from the earlier scene definition and make them into different parallax
    layers—the sky, the trees, and the grass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – revisiting parallax scrolling](img/8874OS_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ParallaxScene` element we implemented is a moving plane. Its horizontal
    offset depends on the character's current position and the size of the view. The
    range of scroll of the scene is determined by the difference between the scene
    size and the view size—it says how much scrolling we have to do when the character
    moves from the left edge to the right edge of the scene so that it is in view
    all the time. If we multiply that by the distance of the character from the left
    edge of the scene expressed as a fraction of the scene width, we will get the
    needed scene offset in the view (or otherwise speaking, a projection offset of
    the scene).
  prefs: []
  type: TYPE_NORMAL
- en: The second type—`ParallaxLayer` is also a moving plane. It defines a distance
    factor that represents the relative distance (depth) of the layer behind the foreground,
    which influences how fast the plane should be scrolled compared to the foreground
    (scene). The value of `0` means that the layer should be moving with exactly the
    same speed as the foreground layer. The larger the value, the slower the layer
    moves compared to the character. The offset value is calculated by dividing the
    character's position in the scene by the factor. Since the foreground layer is
    also moving, we have to take it into consideration when calculating the offset
    for each parallax layer. Thus, we subtract the horizontal position of the scene
    to get the actual layer offset.
  prefs: []
  type: TYPE_NORMAL
- en: Having the layers logically defined, we can add them to the scene. Each layer
    has a physical representation, in our case, static images containing textures
    of the sky, trees, and grass. Each layer is defined separately and can live its
    own life, containing static and animated elements that have no influence on remaining
    layers. If we wanted to render a sun moving from east to west, we would put it
    on the sky layer and animate it from one edge of the layer to the other with a
    long duration.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – vertical parallax sliding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an additional exercise, you might want to implement vertical parallax sliding
    in addition to a horizontal one. Just make your scene bigger and have it expose
    the vertical scroll position in addition to the horizontal one reported by the
    `currentPos` element. Then, just repeat all the calculations for the `y` property
    of each layer and you should be done in no time. Remember that distance factors
    for `x` and `y` might be different.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no built-in support for collision detection in Qt Quick, but there
    are three ways of providing such support. First, you can use a ready collision
    system available in a number of 2D physics engines such as Box2D. Secondly, you
    can implement a simple collision system yourself in C++. Lastly, you can do collision
    checking directly in JavaScript by comparing object coordinates and bounding boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Our game is very simple; therefore, we will use the last approach. If we had
    a larger number of moving objects involved in our game, then we would probably
    choose the second approach. The first approach is best if you have an object of
    non-rectangular shapes that can rotate and bounce off other objects. In this case,
    having a physics engine at hand becomes really useful.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – collecting coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From Qt Creator''s menu, access **File** | **New File or Project**. From **Qt
    Files And Classes**, choose the JS File template. Call the file "`collisions.js`".
    Put the following content into the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another JS File and call it "`coins.js`". Enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open the main document and add the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the player object, define the `checkCollisions()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, in the same player object, trigger collision detection by handling
    the position changes of the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Coin.qml` file, define an animation and a `hit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file `collisions.js` contains functions used to do collision checking. The
    first line of the file is a pragma statement noting that this document only contains
    functions and does not contain any mutable object. This is so that we can add
    a `.pragma library` statement, which marks the document as a library that can
    be shared between documents that import it. This aids in reduced memory consumption
    and improved speed as the engine doesn't have to reparse and execute the document
    each time it is imported.
  prefs: []
  type: TYPE_NORMAL
- en: The functions defined in the library are really simple. The first one returns
    a bounding rectangle of an object based on its coordinates and the size of its
    children. It assumes that the top-level item is empty and contains children that
    represent the visual aspect of the object. Children coordinates are mapped using
    the `mapToItem` element so that the rectangle returned is expressed in the parent
    item coordinates. The second function does a trivial checking of intersection
    between two bounding rectangles and returns `true` if they intersect and `false`
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The second document keeps a definition of an array of coins. It adds two methods
    to the array object. The first one—`collisionsWith`—performs a collision check
    between any of the items in the array and the given object using functions defined
    in `collisions.js`. That's why we import the library at the start of the document.
    The method returns another array that contains objects intersecting the `player`
    argument. The other method, called `remove`, takes an object or an array of objects
    and removes them from `coins`.
  prefs: []
  type: TYPE_NORMAL
- en: The document is not a library; therefore, each document that imports `coins.js`
    would get its own separate copy of the object. Thus, we need to ensure that `coins.js`
    is imported only once in the game so that all references to the objects defined
    in that document relate to the same instance of the object in our program memory.
  prefs: []
  type: TYPE_NORMAL
- en: Our main document imports `coins.js`, which creates the array for storing coin
    objects and makes its auxiliary functions available. This allows the defined `checkCollisions()`
    function to retrieve the list of coins colliding with the player. For each coin
    that collides with the player, we execute a `hit()` method; as a last step, all
    colliding coins are removed from the array. Since coins are stationary, collision
    can only occur when the player character enters an area occupied by a coin. Therefore,
    it is enough to trigger collision detection when the position of the player character
    changes—we use the `onXChanged` and `onYChanged` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: As hitting a coin results in removing it from the array, we lose a reference
    to the object. The `hit()` method has to initiate removal of the object from the
    scene. A minimalistic implementation of this function would be to just call the
    `destroy()` function on the object, but we do more—the removal can be made smoother
    by running a fade-out animation on the coin. As a last step, the animation can
    destroy the object.
  prefs: []
  type: TYPE_NORMAL
- en: Notes on collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number of objects we track on the scene is really small, and we simplify
    the shape of each object to a rectangle. This lets us get away with checking collisions
    in JavaScript. For a larger amount of moving objects, custom shapes, and handling
    rotations, it is much better to have a collision system based on C++. The level
    of complexity of such a system depends on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Eye candy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A game should not just be based upon an interesting idea; it should not only
    work fluently on a range of devices and give entertainment to those people playing
    it. It should also look nice and behave nicely. Whether one is choosing from a
    number of similar implementations of the same game or wants to spend money on
    another similarly priced and entertaining game, there is a good chance the game
    she or he chooses will be the one that looks the best—having a lot of animations,
    graphics, and flashy content. We already learned a number of techniques to make
    a game more pleasing to the eye, such as using animations or GLSL shaders. Here,
    we will show you a number of other techniques that can make your Qt Quick applications
    more attractive.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-scaling user interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first extension you might implement is making your game auto-adjust to the
    device resolution it is running on. There are basically two ways to accomplish
    this. The first is to center the user interface in the window (or screen) and
    if it doesn't fit, enable scrolling. The other approach is to scale the interface
    to always fit the window (or screen). Which to choose depends on a number of factors,
    the most important of which is whether your UI is good enough when upscaled. If
    the interface consists of text and non-image primitives (basically rectangles)
    or if it includes images but only vector ones or those with very high resolution,
    then it is probably fine to try and scale the user interface. Otherwise, if you
    use a lot of low resolution bitmap images, you will have to choose one particular
    size for the UI (optionally allowing it to downscale since the quality degradation
    should be less significant in this direction if you enable anti-aliasing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you choose to scale or to center and scroll, the basic approach is
    the same—you put your UI item in another item so that you have fine control over
    the UI geometry regardless of what happens to the top-level window. Taking the
    centered approach is quite easy—just anchor the UI to the center of the parent.
    To enable scrolling, wrap the UI in the `Flickable` item and constrain its size
    if the size of the window is not big enough to fit the whole user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You should probably decorate the top-level item with a nice background if the
    UI item does not occupy the full area of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling seems more complicated, but with Qt Quick it is really easy. Again,
    you have two choices—either stretch or scale. Stretching is as easy as executing
    the `anchors.fill: parent` command, which effectively forces the UI to recalculate
    the geometry of all its items but possibly allows us to use the space more efficiently.
    It is, in general, very time-consuming for the developer to provide expressions
    for calculating the geometry of each and every element in the user interface as
    the size of the view changes. This is usually not worth the effort. A simpler
    approach is to just scale the UI item to fit the window, which will implicitly
    scale the contained items. In such an event, their size can be calculated relative
    to the base size of the main view of the user interface. For this to work, you
    need to calculate the scale that is to be applied to the user interface to make
    it fill the whole space available. The item has a scale of 1 when its effective
    width equals its implicit width and its effective height equals its implicit height.
    If the window is larger, we want to scale the item up until it reaches the size
    of the window. Therefore, the window''s width divided by the item''s implicit
    width will be the item''s scale in the horizontal direction. This is shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Auto-scaling user interfaces](img/8874OS_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same can be applied to the vertical direction, but if the UI has a different
    aspect ratio than the window, its horizontal and vertical scale factors will be
    different. For the UI to look nice, we have to take the lower of the two values—to
    only scale up as much as the direction with less space allows, leaving a gap in
    the other direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, it might be a good idea to put some background on the window item to
    fill in the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you want to save some margin between the user interface and the window?
    You could, of course, take that into consideration when calculating the scale
    (`(window.width-2*margin)/width`, and so on) but there is an easier way—simply
    put an additional item inside the window, leaving an appropriate margin, and put
    the user interface item in that additional item and scale it up to the additional
    item''s size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When you scale elements a lot, you should consider enabling anti-aliasing for
    items that can lose quality when rendered in a size different than their native
    size (for example, images). This is done very easily in Qt Quick as each `Item`
    instance has a property called `antialiasing` which, when enabled, will cause
    the rendering backend to try to reduce distortions caused by the aliasing effect.
    Remember that this comes at the cost of increased rendering complexity, so try
    to find a balance between quality and efficiency, especially on low-end hardware.
    You might provide an option to the user to globally enable or disable anti-aliasing
    for all game objects or to gradually adjust quality settings for different object
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Graphical effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic two predefined items in Qt Quick are rectangle and image. One can
    use them in a variety of creative ways and make them more pleasant-looking by
    applying GLSL shaders. However, implementing a shader program from scratch is
    cumbersome and requires in-depth knowledge of the shader language. Luckily, a
    number of common effects are already implemented and ready to use in the form
    of the `QtGraphicalEffects` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a subtle black shadow to our canvas-based heartbeat element defined
    in the `HeartBeat.qml` file, use a code similar to the following that makes use
    of the `DropShadow` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To apply a shadow effect, you need an existing item as the source of the effect.
    In our case, we are using an instance of the `HeartBeat` class centered in a top-level
    item. Then, the shadow effect is defined and its geometry follows that of its
    source by using the `anchors.fill` element. Just as the `DropShadow` class renders
    the original item as well as the shadow, the original item can be hidden by setting
    its `visible` property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical effects](img/8874OS_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the `DropShadow` class's properties are self-explanatory, but two properties—`radius`
    and `samples`—require some additional explanation. The shadow is drawn as a blurred
    monochromatic copy of the original item offset by a given position. The two mentioned
    properties control the amount of blur and its quality—the more samples used for
    blurring, the better the effect, but also the more demanding the computation that
    needs to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of blur, the plain blurring effect is also available in the graphics
    effects module through the `GaussianBlur` element type. To apply a blur instead
    of a shadow to the last example, simply replace the occurrence of the `DropShadow`
    class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![Graphical effects](img/8874OS_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see two earlier mentioned properties as well as a vaguely named
    `transparentBorder` one. Enabling this property fixes some artifacts on the edges
    of the blur and in general, you'll want to keep it that way.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – the blur parallax scrolled game view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `blur` property is a very nice effect that can be used in many situations.
    For example, you could try to implement a feature within our elephant game whereby,
    when the user pauses the game (for example, by pressing the *P* key on the keyboard),
    the view gets blurred. Make the effect smooth by applying an animation to the
    effect's `radius` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting effect is `Glow`. It renders a colored and blurred copy
    of the source element. An example use case for games is highlighting some parts
    of the user interface—you can direct the user''s attention to the element (for
    example, button or badge) by making the element flash periodically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The complete module contains 20 different effects. We cannot describe each effect
    in detail here. Nevertheless, you can learn about it yourself. If you clone the
    module's source git repository (found under [git://code.qt.io/qt/qtgraphicaleffects.git](http://git://code.qt.io/qt/qtgraphicaleffects.git))
    in the `tests/manual/testbed` subdirectory of the cloned repository, you will
    find a nice application for testing existing effects. To run the tool, open the
    `testBed.qml` file with `qmlscene`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero – the blur parallax scrolled game view](img/8874OS_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also access a complete list of effects and their short descriptions
    by navigating to the **GraphicalEffects** help page in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A commonly used visual effect in systems such as games is generating a large
    number of small, usually short-lived, often fast-moving, fuzzy objects such as
    stars, sparks, fumes, dust, snow, splinters, falling leaves, or the like. Placing
    these as regular items within a scene would greatly degrade performance. Instead,
    a special engine is used which keeps a registry of such objects and tracks (simulates)
    their logical attributes without having physical entities in the scene. Such objects,
    called particles, are rendered upon request in the scene using very efficient
    algorithms. This allows us to use a large number of particles without having a
    negative impact on the rest of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick provides a particle system in the `QtQuick.Particles` import. The `ParticleSystem`
    element provides the core for the simulation, which uses the `Emitter` elements
    to spawn particles. They are then rendered according to definitions in a `ParticlePainter`
    element. Simulated entities can be manipulated using the `Affector` objects, which
    can modify the trajectory or life span of particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example. The following code snippet declares the
    simplest possible particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be observed in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle systems](img/8874OS_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's analyze the code. After importing `QtQuick.Particles 2.0`, a `ParticleSystem`
    item is instantiated that defines the domain of the particle system. We define
    two objects within that system. The first object is the `Emitter` and defines
    an area where particles will be spawned. The area is set to encompass the whole
    domain. The second object is an object of the `ImageParticle` type, which is a
    `ParticlePainter` subclass. It determines that particles should be rendered as
    instances of a given image. By default, the `Emitter` object spawns 10 particles
    per second, each of which lives for one second and then dies and is removed from
    the scene. In the code presented, the `Emitter` and `ImageParticle` objects are
    direct children of the `ParticleSystem` class; however, this doesn't have to be
    the case. The particle system can be explicitly specified by setting the `system`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning the emitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can control the amount of particles being emitted by setting the `emitRate`
    property of the emitter. Another property called the `lifeSpan` determines how
    many milliseconds it takes before a particle dies. To introduce some random behavior,
    you can use the `lifeSpanVariation` property to set a maximum amount of time (in
    milliseconds) the life span can be altered by the system (in both directions).
    Increasing the emission rate and life span of particles can lead to a situation
    in which a very large number of particles have to be managed (and possibly rendered).
    This can degrade performance; thus, an upper limit of particles that can concurrently
    be alive can be set through the `maximumEmitted` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Tuning the emitter](img/8874OS_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Tweaking the life span of particles makes the system more diverse. To strengthen
    the effect, you can also manipulate the size of each particle through the `size`
    and `sizeVariation` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![Tuning the emitter](img/8874OS_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The range of functionality presented thus far should be enough to create many
    nice-looking and useful particle systems. The limitation so far has been that
    particles are emitted from the whole area of the emitter, which is a regular `QQuickItem`
    and thus is rectangular. This doesn't have to be the case, though. The `Emitter`
    element contains a `shape` property, which is a way to declare the area that is
    to be giving birth to particles. The `QtQuick.Particles` parameter defines three
    types of custom shape that can be used— `EllipseShape`, `LineShape`, and `MaskShape`.
    The first two are very simple, defining either an empty or filled ellipse inscribed
    in the item or a line crossing one of the two diagonals of the item. The `MaskShape`
    element is more interesting as it makes it possible to use an image as a shape
    for the `Emitter` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![Tuning the emitter](img/8874OS_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering particles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, we have used a bare `ImageParticle` element to render particles. It
    is only one of three `ParticlePainters` available, with the others being `ItemParticle`
    and `CustomParticle`. But before we move on to other renderers, let's focus on
    tweaking the `ImageParticle` element to obtain some interesting effects.
  prefs: []
  type: TYPE_NORMAL
- en: The `ImageParticle` element renders each logical particle as an image. The image
    can be manipulated separately for each particle by changing its color and rotation,
    deforming its shape, or using it as a sprite animation.
  prefs: []
  type: TYPE_NORMAL
- en: To influence the color of particles, you can use any of the large number of
    dedicated properties—`alpha`, `color`, `alphaVariation`, `colorVariation`, `redVariation`,
    `greenVariation`, and `blueVariation`. The first two properties define the base
    value for respective attributes and the remaining properties set the maximum deviation
    of a respective parameter from the base value. In the case of opacity, there is
    only one type of variation you can use but when defining the color, you can either
    set different values for each of the red, green, and blue channels or you can
    use the global `colorVariation` property, which is similar to setting the same
    value for all three channels. Allowed values are any between the range of 0 (no
    deviation allowed) to 1.0 (100% in either direction).
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering particles](img/8874OS_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The properties mentioned are stationary—the particle obeys the constant value
    during its whole life. The `ImageParticle` element also exposes two properties,
    letting you control the color of particles relative to their age. First of all,
    there is a property called `entryEffect` that defines what happens with the particle
    at its birth and death. The default value is `Fade`, which makes particles fade
    in from 0 opacity at the start of their life and fades them back to 0 just before
    they die. You have already experienced this effect in all earlier particle animations
    we demonstrated. Other values for the property are `None` and `Scale`. The first
    one is obvious—there is no entry effect associated with particles. The second
    one scales particles from 0 at their birth and scales them back to 0 at the end
    of their life.
  prefs: []
  type: TYPE_NORMAL
- en: The other time-related property is `colorTable`. You can feed it with a URL
    of an image to be used as a one-dimensional texture determining the color of each
    particle over its life. At the beginning, the particle gets color-defined by the
    left edge of the image and then progresses right in a linear fashion. It is most
    common to set an image here containing a color gradient to achieve smooth transitions
    between colors.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter that can be altered is the rotation of a particle. Here,
    we can also either use properties that define constant values for rotation (`rotation`
    and `rotationVariation`) specified in degrees or modify the rotation of particles
    in time with `rotationVelocity` and `rotationVelocityVariation`. The velocity
    defines the pace or rotation in degrees per second.
  prefs: []
  type: TYPE_NORMAL
- en: Particles can also be deformed. The properties `xVector` and `yVector` allow
    binding vectors, which define distortions in horizontal and vertical axes. We
    will describe how to set the vectors in the next section. Last but not least,
    using the `sprites` property you can define a list of sprites that will be used
    to render particles. This works in a similar fashion to `SpriteAnimation`, described
    in an earlier section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making particles move
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from fading and rotating, the particle systems we have seen so far were
    very static. While this is useful for making star fields, it is not useful at
    all for explosions, sparks, or even falling snow. This is because particles are
    mostly about movement. Here, we will show you two aspects of making your particles
    fly.
  prefs: []
  type: TYPE_NORMAL
- en: The first aspect is modeling how the particles are born. By that, we mean the
    physical conditions of the object creating the particles. During an explosion,
    matter is pushed away from the epicenter with a very large force that causes air
    and small objects to rush outwards at an extremely high speed. Fumes from a rocket
    engine are ejected with high velocities in the direction opposite to that of the
    propelled craft. A moving comet draws along a braid of dust and gases put into
    motion by the inertia.
  prefs: []
  type: TYPE_NORMAL
- en: All these conditions can be modeled by setting the velocity or acceleration
    of the particles. These two metrics are described by vectors determining the direction
    and amount (magnitude or length) of the given quantity. In Qt Quick, such vectors
    are represented by an element type called `StochasticDirection`, where the tail
    of the vector is attached to the object and the position of the head is calculated
    by the `StochasticDirection` instance. Since we have no means of setting attributes
    on particles because we have no objects representing them, those two attributes—`velocity`
    and `acceleration`—are applied to emitters spawning the particles. Because you
    can have many emitters in a single particle system, you can set different velocities
    and accelerations for particles of different origins.
  prefs: []
  type: TYPE_NORMAL
- en: There are four types of direction elements representing different sources of
    information about the direction. First, there is `CumulativeDirection`, which
    acts as a container for other direction types and works like a sum of directions
    contained within.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is `PointDirection`, where you can specify `x` and `y` coordinates
    of a point where the head of the vector should be attached. To avoid the unrealistic
    effect of all particles heading in the same direction, you can specify `xVariation`
    and `yVariation` to introduce allowed deviation from a given point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making particles move](img/8874OS_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The third type is the most popular stochastic direction type—`AngleDirection`,
    which directly specifies the angle (in degrees clockwise from straight right)
    and magnitude (in pixels per second) of the vector. The angle can vary from the
    base by `angleVariation` and similarly, `magnitudeVariation` can be used to introduce
    variation to the length of the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making particles move](img/8874OS_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last type is similar to the previous one. The `TargetDirection` vector
    can be used to point the vector toward the center of a given Qt Quick item (set
    with the `targetItem` property). The length of the vector is calculated by giving
    the `magnitude` and `magnitudeVariation`, and both can be interpreted as pixels
    per second or multiples of distance between the source and target points (depending
    on the value of the `proportionalMagnitude` property):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making particles move](img/8874OS_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s get back to setting particle velocity. We can use the `AngleDirection`
    vector to specify that particles should be moving left, spreading at a maximum
    of 45 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![Making particles move](img/8874OS_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting acceleration works the same way. You can even set both the initial
    velocity and the acceleration each particle should have. It is very easy to shoot
    the particles in the left direction and start pulling them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![Making particles move](img/8874OS_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Emitter` element has one more nice property that is useful in the context
    of moving particles. Setting the `velocityFromMovement` parameter to a value different
    than `0` makes any movement of the `Emitter` element apply to the velocity of
    the particles. The direction of the additional vector matches the direction of
    the emitter''s movement, and the magnitude is set to the speed of the emitter
    multiplied by the value set to `velocityFromMovement`. It is a great way to generate
    fumes ejected from a rocket engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![Making particles move](img/8874OS_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second way of addressing the behavior of particles is to influence their
    attributes after they are born—in any particular moment of their life. This can
    be done using affectors. These are items inheriting affector, which can modify
    some attributes of particles currently traveling though the area of the affector.
    One of the simplest affectors is `Age`. It can advance particles to a point in
    their lifetime where they only have `lifeLeft` milliseconds of their life left.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Setting `once` to `true` makes each affector influence a given particle only
    once. Otherwise, each particle can have its attributes modified many times.
  prefs: []
  type: TYPE_NORMAL
- en: Another affector type is Gravity, which can accelerate particles in a given
    angle. Friction can slow particles down, and attractor will affect the particle's
    position, velocity, or acceleration so that it starts traveling toward a given
    point. Wander is great for simulating snowflakes or butterflies flying in pseudo-random
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other affector types available, but we will not go into their
    details here. We would like to warn you, however, against using affectors too
    often—they can severely degrade performance.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – vanishing coins spawning particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time now to practice our freshly acquired skills. The task is to add a
    particle effect to the game when the player collects coins. The coin will explode
    into a sprinkle of colorful stars when collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by declaring a particle system as filling the game scene, along with
    the particle painter definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the definition of Coin to include an emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the hit function has to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we defined a simple particle system that fills the whole scene.
    We defined a simple image painter for the particles where we allow particles to
    take on all the colors and start in all possible rotations. We used a star pixmap
    as our particle template.
  prefs: []
  type: TYPE_NORMAL
- en: Then, an `Emitter` object is attached to every coin. Its `emitRate` is set to
    `0`, which means it does not emit any particles on its own. We set a varying life
    span on particles and let them fly in all directions by setting their initial
    velocity with an angle variation of 180 degrees in both directions (giving a total
    of 360 degrees). By setting an acceleration, we give the particles a tendency
    to travel toward the bottom edge of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the hit function, we call a `burst()` function on the emitter, which makes
    it give instant birth to a given number of particles.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have shown you how to extend your QML skills to make your
    applications dynamic and attractive. We've gone through the process of recreating
    and improving a game created earlier in C++ to familiarize you with such concepts
    as collision detection, state-driven objects, and time-based game loops. We also
    presented you with a tool in the form of `ShaderEffect`, which can serve as a
    means to create stunning graphics without compromising performance, and we taught
    you to use a particle system.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Qt Quick is much richer than all this, but we had to stop somewhere.
    The set of skills we have hopefully passed on to you should be enough to develop
    many great games. However, many of the elements have more properties than we have
    described here. Whenever you want to extend your skills, you can check the reference
    manual to see if the element type has more interesting attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our book on game programming using Qt. We have taught you the
    general basics of Qt, described its widget realm to you, and introduced you to
    the fascinating world of Qt Quick. Widgets (including graphics view) and Qt Quick
    are the two paths you can take when creating games using the Qt framework. We
    have also shown you ways of merging the two approaches by making use of any OpenGL
    skills you might have, going beyond what Qt already offers today. At this point,
    you should start playing around and experimenting, and if at any point you feel
    lost or simply lack the information on how to do something, the very helpful Qt
    reference manual should be the first resource you direct yourself to.
  prefs: []
  type: TYPE_NORMAL
- en: Good luck and have lots of fun!
  prefs: []
  type: TYPE_NORMAL
