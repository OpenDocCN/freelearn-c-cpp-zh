<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch13"/>Chapter 13. We Have Contact! – Networking Basics</h1></div></div></div><p>In today's world where everyone and everything is interconnected, playing games with your friends is not a new thing anymore. It has become a standard amongst many groups. Expressions such as "frag" or "camping" became buzzwords amongst gamers. Whether it's a 2-4 player LAN party or a massive multiplayer online game, networking obviously plays a huge role in the gaming circles. Introducing the element of other human players amplifies the content added, on top of making the game's universe seem much more alive and flourishing. In many instances, this sort of phenomenon actually brings people together and provides a very enjoyable experience, as long as it's not lagging. It's about time we harness the essence of multiplayer, and perhaps even propagate the six degrees of separation.</p><p>In this chapter, we're going to be covering:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fundamentals of networking applications</li><li class="listitem" style="list-style-type: disc">Utilizing threads and ensuring data safety</li><li class="listitem" style="list-style-type: disc">Implementing our own basic communication protocol</li><li class="listitem" style="list-style-type: disc">Building a simple chat client and server</li></ul></div><p>Let's break the isolation of your system and open it up to the outside world!</p><div><div><div><div><h1 class="title"><a id="ch13lvl1sec113"/>Basics of networking</h1></div></div></div><p>First <a id="id559" class="indexterm"/>things first, let's cover a term that is pretty much synonymous with networking at this point: sockets. What is a socket? In its simplest terms, a socket is just an interface that is used for network communications. When two applications are communicating, at least two sockets are involved and data is exchanged between them. When data is sent from application A to application B, it first leaves from the socket of application A, travels throughout the internet, and hopefully reaches the socket of application B:</p><div><img src="img/B04284_13_01.jpg" alt="Basics of networking"/></div><p>Each <a id="id560" class="indexterm"/>socket has to be bound to something referred to as a port, which can be imagined as a gateway to a system. Each gateway is used for different purposes and can only be used by one socket at a time. In the simplest terms, a port is just a 16-bit numerical value, which means a port number can be as high as 65535. While a service is using a specific port, another socket cannot bind to it until it's freed. The most commonly used ports are in a range of 20-1024. For example, port 80 is always used for HTTP traffic, which is what most website hosting servers operate on.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec62"/>SFML networking</h2></div></div></div><p>In <a id="id561" class="indexterm"/>order to access network constructs in SFML, we must <a id="id562" class="indexterm"/>first include the network header:</p><div><pre class="programlisting">#include &lt;SFML/Network.hpp&gt;</pre></div><p>Building a project that has networking capabilities also requires more library files in order to link properly, specifically <code class="literal">sfml-network.lib</code>, <code class="literal">ws2_32.lib</code>, and <code class="literal">winmm.lib</code>. Having these libraries included will ensure that the project compiles properly.</p><p>There are several types of sockets available out there, each with specific features, advantages, and disadvantages. SFML provides us with two basic types: TCP and UDP. <strong>TCP</strong> stands<a id="id563" class="indexterm"/> for <strong>Transmission Control Protocol</strong>, while <strong>UDP</strong> stands for <strong>User Datagram Protocol</strong>. Both of these protocols<a id="id564" class="indexterm"/> are capable of sending and receiving data, but they are fundamentally different from each other under the hood. It's fair to mention that while two sockets of the same type cannot bind to the same port, it can still be bound to by two different protocols.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec11"/>TCP sockets</h3></div></div></div><p>TCP is a <a id="id565" class="indexterm"/>connection-based protocol, which means that before data can be exchanged, a connection has to be established by having an application that attempts to initiate it (a client) connect to another application that is actively waiting for connections (a server). Let's take a look at a basic client application connection attempt:</p><div><pre class="programlisting">sf::TcpSocket socket;
sf::Socket::Status status = 
  socket.connect("192.168.1.2", 5600, sf::seconds(5.f));
if (status != sf::Socket::Done){
    // Connection failed.
}</pre></div><p>First, we <a id="id566" class="indexterm"/>create a TCP socket instance. Its <code class="literal">connect</code> method is called next, with three arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first argument is of the type <code class="literal">sf::IpAddress</code> and is exactly what it sounds like: the IP address we are trying to connect to, which has to be open and have a server accepting connections.</li><li class="listitem" style="list-style-type: disc">The second argument is the port number.</li><li class="listitem" style="list-style-type: disc">Lastly, we have the third argument, which is completely optional. It's the timeout value after which the socket should give up and throw an error. If this argument isn't provided, the default operating system time-out value is used.</li></ul></div><p>The return value of the connect method is captured and stored in a <code class="literal">sf::Socket::Status</code> type, which is just an enumeration table that has a few useful values, such as <code class="literal">Done</code>, <code class="literal">NotReady</code>, <code class="literal">Partial</code>, <code class="literal">Disconnected</code>, and <code class="literal">Error</code>. Every method of both socket types that has to do with sending or receiving data, connecting or disconnecting, returns a status that we can use for error checking.</p><p>In order to accept a connection on the server side when using TCP, a special class is used: <code class="literal">sf::TcpListener</code>. It has to be bound to a specific port and cannot send or receive any data:</p><div><pre class="programlisting">sf::TcpListener listener;
if (listener.listen(5600) != sf::Socket::Done)
{
    // Unable to bind to port.
}

sf::TcpSocket incoming;
if (listener.accept(incoming) != sf::Socket::Done)
{
    // Failed accepting an incoming connection.
}</pre></div><p>After the socket is set up, the listener's <code class="literal">accept</code> method is called. Along with <code class="literal">connect</code> and a few other methods we'll be covering down the line, it actually stops the application from continuing until a connection comes through. This is what's referred to as <code class="literal">blocking</code>. A good example of a blocking function from an STL library is <code class="literal">std::cin</code>. Why is this important? Well, to put it simply, networking operations are rather unpredictable. There<a id="id567" class="indexterm"/> is no way of knowing exactly how long a connection attempt may take, as the host on the other end could be unreachable. During that time, your application will stand still and do absolutely nothing.</p><p>After a connection finally comes through, the incoming socket can be used to communicate with the client:</p><div><pre class="programlisting">char data[100];
// ...
if (socket.send(data, 100) != sf::Socket::Done){
    // Sending data failed.
}</pre></div><p>The send method has two variations: a low-level one that allows the user to send a raw array of bytes and a higher level one that uses a specialized class we're going to be covering shortly. The low-level version takes in a <code class="literal">void</code> pointer and the number of bytes it should send.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>Keep in mind that sending data could also fail for a number of reasons. Make sure to always check the returned status for errors!</p></div></div><p>In order to receive data on the other end, a socket needs to listen:</p><div><pre class="programlisting">char data[100];
std::size_t received;

if (socket.receive(data, 100, received) != sf::Socket::Done)
{
    // Failed receiving data.
}</pre></div><p>When raw data is sent, a large-enough buffer must be provided along with the maximum size it can contain, which is the second argument of the receive method. The third argument is the number of bytes received, which is written over when data comes in. The receive method is also blocking by default. This means that it will halt the entire program until some data comes through.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec12"/>Handling multiple connections</h3></div></div></div><p>You<a id="id568" class="indexterm"/> might have noticed by now that all of the examples above focus on just one client connecting and sending data. In today's hyper-connected world that is almost never the case, so let's take a look at a way we can handle multiple TCP sockets at the same time:</p><div><pre class="programlisting">sf::TcpSocket socket;
// ...
sf::SocketSelector selector;
selector.add(socket);</pre></div><p>The <code class="literal">sf::SocketSelector </code>class provides a way for us to block on multiple sockets, instead<a id="id569" class="indexterm"/> of just one. It monitors every single socket that is added to it for incoming data, unlike the previous examples that only dealt with a single socket.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>A very important thing to keep in mind is that the socket selector does not actually store the sockets added to it, but merely points to them. This means that although a socket has been added to a selector, it still must be stored in a data container of your choosing.</p></div></div><p>To handle incoming data from multiple sockets, the <code class="literal">wait</code> method of a socket selector class is used:</p><div><pre class="programlisting">sf::SocketSelector selector;
std::vector&lt;sf::TcpSocket&gt; container;
// ...
sf::TcpSocket socket;
selector.add(socket);
container.push_back(socket);
if (selector.wait(sf::seconds(10))){
  for (auto &amp;itr : container){
    if (selector.isReady(itr)){
      // Socket received data.
      char data[100];
      std::size_t received;
      sf::Socket::Status status= itr.receive(data, 100, received);
      if (status != sf::Socket::Done){
        // Failed receiving data...
      }
    }
  }
} else {
  // Timed out...
}</pre></div><p>The argument provided in the <code class="literal">wait</code> method is, once again, optional. If one of the socket inside the selector receives something, <em>true</em> is returned and we can iterate over our data container to find the socket that received data, by using the <code class="literal">isRead</code>
<code class="literal">y</code> method.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec13"/>TCP protocol specifics</h3></div></div></div><p>One <a id="id570" class="indexterm"/>major difference between TCP and UDP is transmission reliability. The TCP protocol uses something called a three-way-handshake when establishing a connection. It looks a little something like this:</p><div><img src="img/B04284_13_02.jpg" alt="TCP protocol specifics"/></div><p>A <strong>SYN</strong> (<strong>synchronize</strong>) packet<a id="id571" class="indexterm"/> is first sent by the party <a id="id572" class="indexterm"/>attempting to establish a <a id="id573" class="indexterm"/>connection. The server responds with a <strong>SYN/ACK</strong> (<strong>synchronize-acknowledgement</strong>) packet, to which the client responds with an <strong>ACK</strong> (<strong>acknowledgement</strong>) packet. These three exchanges of data happen at the beginning of every connection. Afterwards, when actual data is being sent, it travels in a form of a SYN packet, to which the receiving party always replies with an ACK packet. If the party sending some data does not receive an ACK response, the same data is sent again after a specific time interval. All of this data being sent back and forth is also tagged with a sequence number, which enables the TCP protocol to also ensure that data arrives in order. This provides reliability, but at a price. Because of additional checks, waiting if some data got lost somewhere and additional data overhead, TCP ends up being slower and bulkier. If a packet gets lost somewhere, the receiving party has to wait until the same data is retransmitted in order to continue. For most applications and even certain types of games this difference is speed is negligible. However, some really fast-paced games that require highest possible efficiency and don't care about packet loss end up using UDP.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec14"/>User datagram protocol</h3></div></div></div><p>Both TCP <a id="id574" class="indexterm"/>and UDP sockets in SFML actually inherit from the same base class, which means a lot of the functionality that we saw with TCP carries over. One major difference, however, is that UDP is connectionless. This means that there is no such thing as a three-way-handshake for UDP and for that matter, no acknowledgement packets either. UDP is centered on data being sent. There are no order checks, no sequence numbers, no bloated packets, and no guarantee that what was sent out is going to reach its destination. This total elimination of error checking reduces the packet overhead from 20 bytes when using TCP all the way down to 8 bytes.</p><p>With all of that said, there are some limitations that UDP has, such as the maximum size of the data being sent out. Data in UDP is being sent out in datagrams instead of streams, which is how TCP handles it. The maximum imposed datagram size, which is a little less than 65536 bytes, cannot be exceeded.</p><p>Because <a id="id575" class="indexterm"/>UDP is connectionless, there is no equivalent of <code class="literal">sf::TcpListener</code> that can be used to accept incoming traffic. The socket must be bound to a specific port before it can be used though:</p><div><pre class="programlisting">sf::UdpSocket socket;

// Bind to port 5600
if (socket.bind(5600) != sf::Socket::Done)
{
    // Binding failed.
}</pre></div><p>Binding to a random port is also possible, thanks to <code class="literal">sf::Socket::AnyPort</code>, which can be passed into the bind method instead of a numerical constant. It can be retrieved later like this:</p><div><pre class="programlisting">sf::UdpSocket socket;
// ...
unsigned int port = socket.getLocalPort();</pre></div><p>Sending and receiving carries the same gist, except for having to provide additional arguments for an IP address and port that the data is being sent to or received from, on the count of UDP being connectionless:</p><div><pre class="programlisting">sf::UdpSocket socket;
// ...
char data[100];
if (socket.send(data, 100, "192.168.1.2", 5600)
  != sf::Socket::Done)
{
    // Sending failed.
}
// ...
sf::IpAddress ipAddr;
unsigned short port;
std::size_t received;
if (socket.receive(data, 100, received, ipAddr, port) 
  != sf::Socket::Done)
{
    // Receiving failed.
}</pre></div><p>Lastly, UDP sockets do work with a <code class="literal">sf::SocketSelector</code> class, but given the nature of UDP, there <a id="id576" class="indexterm"/>are fewer instances where that actually come in handy, because all data can simply be sent and received by using one or two sockets at most.</p></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec63"/>Alternative to sending raw data</h2></div></div></div><p>Simply <a id="id577" class="indexterm"/>sending raw bytes across a network can get quite tricky, not to mention problematic. The first and perhaps the biggest issue is the <strong>endianness</strong> of a machine. Some processors interpret data in a different order than others. In a big-endian family, the most significant byte is stored first, while a little-endian family machine would do the opposite. Raw data being sent from a big-endian machine to a little-endian machine would be interpreted differently and result in funky results.</p><p>On top of data being stored differently amongst all types of machines, the sizes of basic variables in C++ may vary between different machines and compilers. If that is not enough, the TCP protocol introduces additional headaches due to it not preserving message boundaries. Chunks of data being sent out can be split and combined, which can cause problems if they are not properly re-constructed by the receivers.</p><p>While all of this sounds fairly horrific, there are solutions to all of these problems. Data type size variations can be addressed by using SFML's fixed-size types, such as <code class="literal">sf::Int8</code>, <code class="literal">sf::Uint16</code>, and so on. They are simple type definitions, mapped to data types that are sure to have the expected size depending on the platform. Exchanging these types over the network instead re-assures data safety.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec15"/>SFML packets</h3></div></div></div><p>The endianness and <a id="id578" class="indexterm"/>message boundary problems require slightly more effort to resolve. Enter <code class="literal">sf::Packet</code>! It is a specialized, lightweight class that can be used to pack/extract data. SFML packets use the exact same interface as standard streams by using the <code class="literal">&lt;&lt;</code> and <code class="literal">&gt;&gt;</code> operators for data insertion and extraction, as seen here:</p><div><pre class="programlisting">sf::Int16 n = 16;
float f = 32.f;
std::string str = "Aloha";

sf::Packet packet;
packet &lt;&lt; n &lt;&lt; f &lt;&lt; str;
// ...
packet &gt;&gt; n &gt;&gt; f &gt;&gt; str;</pre></div><p>While packing data is always guaranteed to work, extracting it can in fact fail. If it does, the packet error flag is set. Checking whether the flag is set or not is similar to testing a Boolean value, which is again similar to standard streams:</p><div><pre class="programlisting">if(!(packet &gt;&gt; n)){
    // Failed extraction.
}</pre></div><p>Both<a id="id579" class="indexterm"/> TCP and UDP packets do provide overloaded send and receive methods that work with instances of <code class="literal">sf::Packet</code>:</p><div><pre class="programlisting">sf::Packet packet;
// TCP
tcpSocket.send(packet);
tcpSocket.receive(packet);
// UDP
udpSocket.send(packet, "192.168.1.2", 5600);
sf::IpAddress senderIP;
unsigned short senderPort;
udpSocket.receive(packet, senderIP, senderPort);</pre></div><p>Custom data types can also be fed into or extracted from the <code class="literal">sf::Packet</code> structure, if overloads of <code class="literal">&lt;&lt;</code> and <code class="literal">&gt;&gt;</code> operators are provided, as follows:</p><div><pre class="programlisting">struct SomeStructure{
    sf::Int32 m_int;
    std::string m_str;
};

sf::Packet&amp; operator &lt;&lt;(sf::Packet&amp; l_packet, 
  const SomeStructure&amp; l_struct)
{
    return l_packet &lt;&lt; l_struct.m_int &lt;&lt; l_struct.m_str;
}

sf::Packet&amp; operator &gt;&gt;(sf::Packet&amp; l_packet, 
  SomeStructure&amp; l_struct)
{
    return l_packet &gt;&gt; l_struct.m_int &gt;&gt; l_struct.m_str;
}</pre></div><p>This enables easy insertion and extraction of a custom data type:</p><div><pre class="programlisting">SomeStructure s;
sf::Packet packet;

packet &lt;&lt; s;
packet &gt;&gt; s;</pre></div><p>Using SFML packets with TCP sockets poses a small restriction. Due to the message boundaries having to be preserved, some extra data is sent in the packet. This means that data sent in<a id="id580" class="indexterm"/> a form of a SFML packet has to be received by using a SFML packet. UDP does not pose this restriction, as the protocol itself preserves message boundaries.</p></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec64"/>Non-blocking sockets</h2></div></div></div><p>Both<a id="id581" class="indexterm"/> TCP and UDP sockets, as well as the TCP listener, are blocking by default. Their blocking mode can be changed to return immediately:</p><div><pre class="programlisting">sf::TcpSocket tcp;
tcp.setBlocking(false);

sf::TcpListener tcpListener;
tcpListener.setBlocking(false);

sf::UdpSocket udp;
udp.setBlocking(false);</pre></div><p>Receiving on a non-blocking socket that has no data incoming would return <code class="literal">sf::Socket::NotReady</code>, as well as trying to accept a TCP connection if there are none pending. Putting your sockets in a non-blocking mode is the easiest way to not halt your program's execution by instead checking the availability of data or connections each time it is updated.</p><p>Non-blocking TCP sockets are not guaranteed to send all of the data you pass to it, even when using instances of <code class="literal">sf::Packet</code>. If a <code class="literal">sf::Socket::Partial</code> status is returned, the data must be sent again at the exact byte offset of where the last call to <code class="literal">send</code> stopped. If raw data is sent, make sure to use this <code class="literal">send</code> overload:</p><div><pre class="programlisting">send(const void* data, std::size_t size, std::size_t&amp; sent)</pre></div><p>It overwrites the third provided argument with the exact number of bytes sent out.</p><p>Sending <code class="literal">sf::Packet</code> instances does not require you to keep track of the byte offset, as it is stored in the packet itself. This means that you cannot destroy the packet instance until it has been successfully sent. Creating a new packet and filling it with the exact same data will not work, as the data offset that was stored internally inside the packet is lost.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec114"/>Letting the traffic flow</h1></div></div></div><p>There <a id="id582" class="indexterm"/>are a lot more subtleties to communicating over the internet than using the right code. As we discussed previously, the port number an application uses to send or receive data can be imagined as a gateway to your system, of which there are thousands. That gateway can either be open or closed. By default, it's more likely than not that whichever port you choose to use for your program is going to be closed on your system, which doesn't matter for local connections, but anything coming from the outside world through that particular port is not going to get through. Managing <a id="id583" class="indexterm"/>your ports can be done by visiting your router's settings page. The steps<a id="id584" class="indexterm"/> required to do so are different for each router out there. Luckily, <a class="ulink" href="http://portforward.com">http://portforward.com</a> is there to help you! By visiting it and looking up the make and model of your router on this website, you can find detailed instructions on how any port can be opened or closed.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>Sockets bound to <code class="literal">sf::Socket::AnyPort</code> will most likely end up binding to a port in a range of 49152 and 65535. Port forwarding works for ranges, as well as individual ports. Opening this particular range of ports will ensure that your SFML networking application works as intended when communicating over the World Wide Web.</p></div></div><p>Firewalls also tend to block this type of traffic by default. For example, the Windows firewall prompts users about allowing traffic to come through for an application that's being launched for the first time. Depending on your application, however, that prompt may never manifest due to the Windows firewall not being the most reliable piece of software ever written. If all of your key ports are open and a particular program still doesn't seem to be sending or receiving anything, make sure to add your client or server program to the "allowed list" of the Windows firewall, by going to <strong>Control Panel</strong>, clicking on <strong>Windows Firewall</strong>, selecting <strong>Allow a program or feature through Windows Firewall</strong> on the left side, clicking <strong>Change settings</strong>, and finally hitting the <strong>Allow another program</strong> button. This will bring up another window that can be used to add your client/server application by browsing for it and clicking on <strong>Add</strong> afterwards.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec115"/>Multi-threading</h1></div></div></div><p>Having <a id="id585" class="indexterm"/>blocking functions in your code can be a real nuisance. Listening for incoming network connections or data, asking users to input something into the console, or even loading game data, like textures, maps, or sounds, can block a program from executing until it's done. Have you ever wondered how certain games have a loading bar that actually moves while the data is being loaded? How can that be done with code that is executed sequentially? The answer to that is multi-threading. Your application runs all its code sequentially from top to bottom in something referred to as the main thread. It is not a program, as it can't exist by itself. Instead, a thread only runs within your application. The beauty of this is that multiple threads can exist and run all at once, which enables parallel code execution. Consider the following diagram:</p><div><img src="img/B04284_13_03.jpg" alt="Multi-threading"/></div><p>Let's say<a id="id586" class="indexterm"/> that the entire application space is the main thread, and all we do here is update and render the game. The example above is running three threads in addition to that. The first thread could be used to listen for incoming network connections. <strong>Thread #2</strong> is responsible for loading/unloading data when a new level is opened or closed. Lastly, thread three could be waiting for console input. Even if all three threads are blocked, the application still keeps rendering! Neat!</p><p>SFML provides us with a few fundamental types that can be used to create and control threads. Let's start by first giving a thread something to do:</p><div><pre class="programlisting">void Test(){
    for (int i = 0; i &lt; 10; ++i){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}</pre></div><p>This is just a basic function that we want to be executed in parallel to the main thread. How can that be done? By using the <code class="literal">sf::Thread</code>!</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>C++ also provides its own thread class, <code class="literal">std::thread</code>, as well its own locks and mutexes. It also provides a <code class="literal">std::future</code> class template, which is useful when accessing results of asynchronous operations.</p></div></div><p>First, it must be set up properly by providing a function or a member function pointer to its constructor:</p><div><pre class="programlisting">sf::Thread thread1(Test);</pre></div><p>The thread constructor actually provides four overloads and even takes in the return value of <code class="literal">std::bind</code> and lambda expressions, which allows us to provide any number of arguments to these functions. Once the thread is set up, it must be launched in order to execute the code:</p><div><pre class="programlisting">thread1.launch();</pre></div><p>Once the <a id="id587" class="indexterm"/>function that is executed returns, its thread is automatically stopped. The <code class="literal">sf::Thread</code> class provides a terminate method, but it really shouldn't be used unless you know what you're doing. It can produce unwanted behavior, including local variables not being destroyed on some operating systems. Instead, your code should be designed in a way that allows a thread to stop on its own when it's no longer needed. Terminating it by hand is not safe! You have been warned.</p><p>One last method that threads provide is the <code class="literal">wait</code> method:</p><div><pre class="programlisting">thread1.wait();</pre></div><p>The thread it is called on will halt until <code class="literal">thread1</code> is finished. This could be potentially dangerous. In the case of an infinite loop or a blocking function being called in <code class="literal">thread1</code> that never unblocks, the program will hang completely.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Never destroy an instance of <code class="literal">sf::Thread</code> before it's done! This will cause the main thread to halt, as the destructor of a thread invokes its <code class="literal">wait</code> method. Your application will be stuck.</p></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec65"/>Shared data protection</h2></div></div></div><p>Incidentally, the<a id="id588" class="indexterm"/> reason why threads are used is also the cause for most problems a user could potentially experience. Having chunks of code that run in parallel is great, but what happens if two threads attempt to read or modify the same data? In a scenario like that, crashes and data corruption are a distinct possibility. Imagine a scenario where the main thread holds a list of entities that are to be updated and rendered. So far, so good! Next, let's introduce a new thread that is going to be running network-specific code and has access to all of our entities. If this thread decided to remove an entity for whatever reason, there's a very good chance that it might happen during either the update or render cycle of the main thread. At this point, we all know too well what happens when an iterator you're using suddenly becomes invalid. Luckily, there are ways to ensure all operations in your code are thread-safe, by synchronizing them.</p><p>SFML provides us with an interesting little class called <code class="literal">sf::Mutex</code>. It stands for mutual exclusion and operates on a very basic principle of allowing only a single thread to execute certain bits of code, while making other threads wait until it's done. Let's take a look at a basic code example to help you better understand this idea:</p><div><pre class="programlisting">sf::Mutex mutex;

void Test(){
    mutex.lock();
    for (int i = 0; i &lt; 10; ++i){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
    mutex.unlock();
}

int main(){
    sf::Thread thread1(Test);
    thread1.launch();

    mutex.lock();
    // Do something data-sensitive here.
    mutex.unlock();
    return 0;
}</pre></div><p>The <code class="literal">mutex</code> class provides us with two methods: <code class="literal">lock</code> and <code class="literal">unlock</code>. When a mutex is locked for <a id="id589" class="indexterm"/>the first time, the thread that locked it is given priority and is allowed to continue executing the code. If another thread calls the <code class="literal">lock</code> method of the <em>same</em> mutex while it's still locked, it's not allowed to move any further until the mutex is unlocked. Once it is, the waiting is over and the second thread is allowed to continue.</p><p>Let's analyze what happens in the code example above: <code class="literal">thread1</code> is bound to the <code class="literal">Test</code> function and launched immediately. The test function locks the mutex and because it hasn't been locked yet, the loop for printing numbers begins iterating. In the meantime, our main thread reaches the <code class="literal">mutex.lock();</code> line. A few numbers may have been printed out already by this point. Because the mutex is already locked, the main thread <em>halts</em> immediately. Once the last number of the <code class="literal">Test</code> function is printed out, the <code class="literal">mutex.unlock();</code> line is reached. This enables the main thread to lock the mutex for itself and continue. If any other thread was to invoke the lock method of the shared mutex, it would have to wait until the main thread is through. Finally, the mutex is unlocked and any possible thread that was waiting in the background can now resume.</p><p>There is a corner-case scenario where this could potentially be dangerous. The mutex has to be unlocked in order for the main thread to continue. What if the function that is bound to a thread suddenly throws an exception? What if it returns a value, or has a branch of if/else statements that return separate values? The <code class="literal">unlock</code> method could be called in each branch, but that just clutters the code, not to mention it doesn't solve the exception problem. Luckily, there is a very elegant solution to that: the <code class="literal">sf::Lock</code> class. All it does is take in a reference to a mutex in its constructor, at which point it's locked, and unlocks it in its destructor. Creating an object like that on the stack would solve all of these problems, as the mutex would just get unlocked as soon as the lock object is out of scope. Let's take<a id="id590" class="indexterm"/> a look at how it can be used:</p><div><pre class="programlisting">sf::Mutex mutex;

void Test(){
    sf::Lock lock(mutex);
    for (int i = 0; i &lt; 10; ++i){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
        if (i == 5){ return; } // mutex.unlock() called.
    }
} // mutex.unlock() called.</pre></div><p>This is a much safer piece of code. Even if there was a possibility of an exception being thrown, the shared mutex would be unlocked, allowing the rest of the program to continue.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec116"/>Creating a simple communication protocol</h1></div></div></div><p>Having <a id="id591" class="indexterm"/>covered all of the basics, we're finally ready to get designing! The first choice we need to make is which protocol suits our needs better. Losing packets in a real-time application like this is not a tragedy. It's more important that data is sent and received as quickly as possible in order to update the player and all of the entities in the game. Since TCP is a slower protocol and we would not benefit from the extra measures it takes to deliver data in order, the choice is clear. User datagram protocol is the way to go.</p><p>Let's flesh out some details of the system we're going to be building by first defining some packet types that are going to be exchanged between the server and client, as well as deciding on the type of the packet identifier. This information will be held inside the <code class="literal">PacketTypes.h</code> header:</p><div><pre class="programlisting">using PacketID = sf::Int8;
enum class PacketType{
  Disconnect = -1, Connect, Heartbeat, Snapshot,
  Player_Update, Message, Hurt, OutOfBounds
};
void StampPacket(const PacketType&amp; l_type, sf::Packet&amp; l_packet);</pre></div><p>Note the very last element inside the <code class="literal">PacketType</code> enumeration. It isn't an actual packet type that will be sent or received. Instead, it simply exists for convenience when checking whether a packet type is valid or not, which we'll cover soon enough. In addition to the enumeration, we're also providing a function for attaching a type to a packet. It's implemented in the <code class="literal">PacketTypes.cpp</code> file:</p><div><pre class="programlisting">void StampPacket(const PacketType&amp; l_type, sf::Packet&amp; l_packet){
    l_packet &lt;&lt; PacketID(l_type);
}</pre></div><p>This <a id="id592" class="indexterm"/>function simply converts the provided type argument into a specific integer data type supplied by SFML prior to feeding it into the packet instance. Using a function to do it pays off in the long run, should we ever decide to change the communication protocol by adding additional data into the packet.</p><p>Next, let's create a header file that contains the most common bits of information shared between both the client and server. We'll simply call it <code class="literal">NetworkDefinitions.h</code>:</p><div><pre class="programlisting">enum class Network{
  HighestTimestamp = 2147483647, ClientTimeout = 10000,
  ServerPort = 5600, NullID = -1
};
using ClientID = int;
using PortNumber = unsigned short;</pre></div><p>These are simply all of the types and constants that both communicating sides are going to be using.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec66"/>Keeping a UDP connection alive</h2></div></div></div><p>Due to<a id="id593" class="indexterm"/> UDP sockets being connectionless, we're going to need to have a way to check if either one of the clients on the server side, or the server on the client side, has stopped responding, and therefore is <a id="id594" class="indexterm"/>deemed to have timed out. A common term for this type of mechanism is <strong>heartbeat</strong>. How it's implemented may differ from application to application, as well as your own sensibilities. In this case, we're going to cover a fairly basic strategy of not only maintaining a live connection, but also measuring the network delay between both sides.</p><p>For this purpose, it's always best to have the server initiate the heartbeat. It has two major benefits: less data being exchanged and a reduced risk of cheating. Let's take a look at the most conservative implementation of a server-client heartbeat:</p><div><img src="img/B04284_13_04.jpg" alt="Keeping a UDP connection alive"/></div><p>The server is going to keep track of when the last heartbeat to a client was sent. That combined with a predefined heartbeat interval enables us to send them at a constant rate. When it is time to send one, a heartbeat packet is constructed and the local server time is attached to it. It is then sent out to the client.</p><p>The<a id="id595" class="indexterm"/> client side of this operation is much simpler. It is always waiting for a heartbeat and when one is received, the local time of the client is updated and kept around for checking timeouts later. A response to the server is then sent back, acknowledging that a heartbeat was indeed received.</p><p>When our server receives a heartbeat response from the client, the delay between these two machines is measured by subtracting the time of when the last heartbeat packet was sent out from the current time. This delay, also known as latency, is the time it takes for data to make a round trip between two hosts.</p><p>Having a heartbeat mechanism in place ensures that we are not keeping around any clients that could've potentially disconnected and thereby wasting bandwidth by sending data to unreachable hosts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec117"/>Designing the client class</h1></div></div></div><p>With all<a id="id596" class="indexterm"/> of the things happening on the client side, be it rendering sprites or playing sounds or processing user input, it only makes sense to have all of the networking code localized inside a single class. This will allow us to communicate with the server quickly and easily. Let's begin designing that class, by first taking a look at some necessary definitions inside the <code class="literal">Client.h</code> header:</p><div><pre class="programlisting">#define CONNECT_TIMEOUT 5000 // Milliseconds.

class Client;
using PacketHandler = std::function&lt;
  void(const PacketID&amp;, sf::Packet&amp;, Client*)&gt;;</pre></div><p>The first definition is the amount of milliseconds that it takes for a client to realize that it's no longer connected to a server. This value can obviously be tweaked at any time. Following that is a definition of a function type that will be used to handle packets on the client side. We're going to be providing the client class with a pointer to a function that is responsible for handling most of the incoming information.</p><p>With that out of the way, we can begin shaping the client class:</p><div><pre class="programlisting">class Client{
public:
  Client();
  ~Client();
  bool Connect();
  bool Disconnect();
  void Listen();
  bool Send(sf::Packet&amp; l_packet);
  const sf::Time&amp; GetTime() const;
  const sf::Time&amp; GetLastHeartbeat() const;
  void SetTime(const sf::Time&amp; l_time);
  void SetServerInformation(const sf::IpAddress&amp; l_ip,
    const PortNumber&amp; l_port);

  template&lt;class T&gt;
  void Setup(void(T::*l_handler)
    (const PacketID&amp;, sf::Packet&amp;, Client*), T* l_instance)
  {
    m_packetHandler = std::bind(l_handler, l_instance,
      std::placeholders::_1, std::placeholders::_2,
      std::placeholders::_3);
  }

  void Setup(void(*l_handler)(const PacketID&amp;,
    sf::Packet&amp;, Client*));
  void UnregisterPacketHandler();
  void Update(const sf::Time&amp; l_time);
  bool IsConnected() const;
  void SetPlayerName(const std::string&amp; l_name);
  sf::Mutex&amp; GetMutex();
private:
  std::string m_playerName;

  sf::UdpSocket m_socket;
  sf::IpAddress m_serverIp;
  PortNumber m_serverPort;
  PacketHandler m_packetHandler;
  bool m_connected;
  sf::Time m_serverTime;
  sf::Time m_lastHeartbeat;

  sf::Thread m_listenThread;
  sf::Mutex m_mutex;
};</pre></div><p>There are<a id="id597" class="indexterm"/> a few things to note here. First, we're going to want to support both regular functions and member functions to serve as packet handlers, hence two <code class="literal">Setup</code> methods. The first one obviously has to be implemented in the header file due to having a template argument.</p><p>Second, this class keeps and manages its own instances of <code class="literal">sf::Mutex</code> and <code class="literal">sf::Thread</code>. This way, we<a id="id598" class="indexterm"/> can provide a common interface of thread synchronization to the outside code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec118"/>Implementing the client</h1></div></div></div><p>With<a id="id599" class="indexterm"/> the class definition covered, it's time to actually make it do something, starting with the constructor and destructor:</p><div><pre class="programlisting">Client::Client():m_listenThread(&amp;Client::Listen, this){}
Client::~Client(){ m_socket.unbind(); }</pre></div><p>In the client constructor's initializer list, we bind the listening thread to the <code class="literal">Listen</code> method of this class. Threads do not have a default empty constructor, which is why this is necessary. The destructor is simply used to unbind the socket we're using.</p><p>Now, let's take a stab at implementing the connection protocol:</p><div><pre class="programlisting">bool Client::Connect(){
  if (m_connected){ return false; }
  m_socket.bind(sf::Socket::AnyPort);
  sf::Packet p;
  StampPacket(PacketType::Connect, p);
  p &lt;&lt; m_playerName;
  if (m_socket.send(p, m_serverIp, m_serverPort) !=
    sf::Socket::Done)
  {
    m_socket.unbind();
    return false;
  }
  m_socket.setBlocking(false);
  p.clear();
  sf::IpAddress recvIP;
  PortNumber recvPORT;
  sf::Clock timer;
  timer.restart();
  while (timer.getElapsedTime().asMilliseconds()&lt;CONNECT_TIMEOUT){
    sf::Socket::Status s = m_socket.receive(p, recvIP, recvPORT);
    if (s != sf::Socket::Done){ continue; }
    if (recvIP != m_serverIp){ continue; }
    PacketID id;
    if (!(p &gt;&gt; id)){ break; }
    if ((PacketType)id != PacketType::Connect){ continue; }
    m_packetHandler(id, p, this);
    m_connected = true;
    m_socket.setBlocking(true);
    m_lastHeartbeat = m_serverTime;
    m_listenThread.launch();
    return true;
  }
  std::cout &lt;&lt; "Connection attempt failed! Server info: " 
    &lt;&lt; m_serverIp &lt;&lt; ":" &lt;&lt; m_serverPort &lt;&lt; std::endl;
  m_socket.unbind();
  m_socket.setBlocking(true);
  return false;
}</pre></div><p>The first <a id="id600" class="indexterm"/>and most obvious step is checking whether we're already connected to the server by checking out the <code class="literal">m_connected</code> data member.</p><p>Next, the socket we're using must be bound to a port. A specific port number could be used here, but that would limit the number of connections a single computer can have at the same time. You cannot bind a socket to the same port on the same protocol twice. By using <code class="literal">sf::Socket::AnyPort</code>, we're letting SFML pick a random port that isn't being used.</p><p>In order to establish a connection, the client must first send something to the server. Since SFML already provides an excellent helper class for easy data transfer, <code class="literal">sf::Packet</code>, we're going to be taking full advantage of it.</p><p>After assigning the type <code class="literal">Connect</code> to our packet, we also write in the player name and send the packet to the server.</p><p>The rest of the code is responsible for correctly handling timeouts. First, we set our socket to be in a non-blocking mode, because we're going to be handling this in a single thread. After clearing the packet we just sent out in order to use it again, a few local variables are set up in order to capture the IP address and port number of a response. Additionally, a clock is set up in order to help us determine whether we've been waiting too long for a response.</p><p>Next, the code loops as long as the timer stays underneath the predefined time-out value, <code class="literal">CONNECT_TIMEOUT</code>. In each iteration, we invoke the receive method of our socket and capture its status. If the returned status doesn't signify success or the IP address it was received from does not match that of our server, we simply skip the current iteration. Nobody wants to receive data from an unknown source!</p><p>After verifying that the packet contains an ID and that it matches <code class="literal">Connect</code>, we pass the received information to the packet handler, set the <code class="literal">m_connected </code>flag to <code class="literal">true</code>, put the socket back into blocking mode, set the last heartbeat value to the current time, launch the listening thread, and return <code class="literal">true</code> to show success. However, if the time to successfully connect runs out, the loop is ended, an error message is printed, and the socket is unbound and set to blocking mode again.</p><p>Once the client is connected to the server, the listening thread is launched. Let's take a look at <a id="id601" class="indexterm"/>what makes it tick:</p><div><pre class="programlisting">void Client::Listen(){
  sf::Packet packet;
  sf::IpAddress recvIP;
  PortNumber recvPORT;
  while (m_connected){
    packet.clear();
    sf::Socket::Status status =
      m_socket.receive(packet, recvIP, recvPORT);
    if (status != sf::Socket::Done){
      if (m_connected){
        std::cout &lt;&lt; "Failed receiving a packet from "
          &lt;&lt; recvIP &lt;&lt; ":" &lt;&lt; recvPORT &lt;&lt; ". Status: "
          &lt;&lt; status &lt;&lt; std::endl;
        continue;
      } else {
        std::cout &lt;&lt; "Socket unbound." &lt;&lt; std::endl;
        break;
      }
    }
    if (recvIP != m_serverIp){
      // Ignore packets not sent from the server.
      continue;
    }
    PacketID p_id;
    if (!(packet &gt;&gt; p_id)){
      // Non-conventional packet.
      continue;
    }
    PacketType id = (PacketType)p_id;
    if (id&lt;PacketType::Disconnect||id &gt;=PacketType::OutOfBounds){
      // Invalid packet type.
      continue;
    }

    if (id == PacketType::Heartbeat){
      sf::Packet p;
      StampPacket(PacketType::Heartbeat, p);
      if (m_socket.send(p, m_serverIp, m_serverPort) !=
        sf::Socket::Done)
      {
        std::cout &lt;&lt; "Failed sending a heartbeat!" &lt;&lt; std::endl;
      }
      sf::Int32 timestamp;
      packet &gt;&gt; timestamp;
      SetTime(sf::milliseconds(timestamp));
      m_lastHeartbeat = m_serverTime;
    } else if(m_packetHandler){
      m_packetHandler((PacketID)id, packet, this); // Handle.
    }
  }
}</pre></div><p>After setting<a id="id602" class="indexterm"/> up some local variables to hold the packet, IP, and port information, the listening thread loop is entered. It runs as long as the client is connected to the server. Each time the loop iterates, the packet instance is cleared in order to receive new data. The status of the socket receive method is stored in a local variable, <code class="literal">status</code>, and checked for success. Because the socket is in blocking mode, the listening thread will halt at the <code class="literal">m_socket.receive(...)</code> line until some data comes in.</p><p>If the returned status denotes some kind of failure, an appropriate error message is printed, presuming that the client is still connected to the server. If it's not, the socket was unbound and the loop is immediately stopped so the thread can safely terminate.</p><p>Given that some data was properly received, the originating IP address is checked. If it does not match the IP of our server, the data is discarded by skipping the current loop iteration. Similarly enough, if we're unable to extract the packet ID, or if it does not fit within our predetermined boundaries, the same outcome takes place. We don't want any malformed or unwelcome packets.</p><p>Next, we check the ID of the packet that was just received. In this particular class, we only want to worry about a single type of packets: <code class="literal">PACKET_HEARTBEAT</code>. These are little messages that the server sends to all clients for two reasons: time synchronization and maintaining a valid connection. Due to unforeseen circumstances, time on the server side and the client side can start going out of sync, which eventually can cause serious problems. Overwriting the client time with a timestamp coming from the server every so often eliminates this problem. In addition to that, this is how both the client and server keep track of whether the connection is still alive or not. In the case of our client, <code class="literal">m_lastHeartbeat</code> holds the latest timestamp received from the server, which can be checked for timeouts later.</p><p>If the packet ID is something else, it simply gets passed into the packet handler function to be processed by a different class.</p><p>Now that we have all these ways of opening and maintaining a connection to the server, let's take a look at how it can be terminated:</p><div><pre class="programlisting">bool Client::Disconnect(){
  if (!m_connected){ return false; }
  sf::Packet p;
  StampPacket(PacketType::Disconnect, p);
  sf::Socket::Status s =
    m_socket.send(p, m_serverIp, m_serverPort);
  m_connected = false;
  m_socket.unbind(); // Unbind to close the listening thread.
  if (s != sf::Socket::Done){ return false; }
  return true;
}</pre></div><p>First, the state <a id="id603" class="indexterm"/>of the client is checked. We don't need to disconnect if there is no connection to begin with. A packet instance is then constructed with a type of <code class="literal">Disconnect</code> and sent to the server. After the <code class="literal">m_connected</code> flag is set to <code class="literal">false</code>, we unbind our socket and return <code class="literal">true</code> or <code class="literal">false</code>, based on whether sending the packet was successful or not.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>When a socket is in blocking mode, its <code class="literal">receive</code> method waits until some data arrives before continuing. Having something like that happen in a separate thread would leave it running, and therefore stop our program from quitting. One way to prevent that is by unbinding a socket that is being used. It makes the <code class="literal">receive</code> method return an error, which we have handled in the <code class="literal">Listen</code> method of our client class.</p></div></div><p>Sending data to the server is quite simple, as this next method shows:</p><div><pre class="programlisting">bool Client::Send(sf::Packet&amp; l_packet){
  if (!m_connected){ return false; }
  if (m_socket.send(l_packet, m_serverIp, m_serverPort) !=
    sf::Socket::Done)
  {
    return false;
  }
  return true;
}</pre></div><p>We take in a reference to an existing packet that needs to be sent out. The method immediately returns <code class="literal">false</code> if we're not connected to the server or if the <code class="literal">send</code> method of our socket returns anything else than <code class="literal">sf::Socket::Done</code>.</p><p>We also need a way to provide a custom packet handler function that is to be used by this class. The member function version of this method was already implemented in the header file, and all that's left is handling a function pointer version:</p><div><pre class="programlisting">void Client::Setup(void(*l_handler)
  (const PacketID&amp;, sf::Packet&amp;, Client*))
{
    m_packetHandler = std::bind(l_handler,
      std::placeholders::_1, std::placeholders::_2, 
      std::placeholders::_3);
}</pre></div><p>For balance, every <a id="id604" class="indexterm"/>positive needs a negative. Let's provide a way to remove any ties to functions that may no longer exist once the code starts wrapping up: </p><div><pre class="programlisting">void Client::UnregisterPacketHandler(){
    m_packetHandler = nullptr;
}</pre></div><p>Last but not least, the update method:</p><div><pre class="programlisting">void Client::Update(const sf::Time&amp; l_time){
  if (!m_connected){ return; }
  m_serverTime += l_time;
  if (m_serverTime.asMilliseconds() &lt; 0){
    m_serverTime -= sf::milliseconds(
      sf::Int32(Network::HighestTimestamp));
    m_lastHeartbeat = m_serverTime;
    return;
  }
  if (m_serverTime.asMilliseconds() -
    m_lastHeartbeat.asMilliseconds() &gt;=
      sf::Int32(Network::ClientTimeout))
  {
    // Timeout.
    std::cout &lt;&lt; "Server connection timed out!" &lt;&lt; std::endl;
    Disconnect();
  }
}</pre></div><p>The main purpose of this method is keeping track of passing time by adding the time between updates to the server time.</p><p>Now, you might notice something strange in the next few lines. Why are we checking for the server time being below zero? Well, the amount of milliseconds that have passed since the beginning is represented by a signed 32-bit integer. Its maximum positive value is 2,147,483,647, after which it goes right to the negatives, -2,147,483,648 to be precise. Granted, this doesn't happen very often. In fact, the server would have to be running continuously for almost 25 whole days for the timestamp to reach the values we're talking about. Still, a corner-case scenario is not worthy of ignoring simply because it's unlikely to happen. Subtracting the highest possible value of a 32-bit integer from the server timestamp "wraps" the time around back into the positive realm and allows it to continue like nothing happened.</p><p>The update method is also where we check for our connection timing out. If the difference between current time and the last heartbeat received from the server is greater or equal <a id="id605" class="indexterm"/>to the timeout value in milliseconds, the <code class="literal">Disconnect</code> method is invoked.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec119"/>The server class</h1></div></div></div><p>Now, it's<a id="id606" class="indexterm"/> time to take a look at the way things are handled on the other side of the wire. Let's begin by defining some constants:</p><div><pre class="programlisting">#define HEARTBEAT_INTERVAL 1000 // Milliseconds.
#define HEARTBEAT_RETRIES 5</pre></div><p>Our server application is going to send out heartbeats every second and retry five times before it times out a client. Speaking of clients, there's additional information that we need to keep track of, which calls for a good data structure that holds it all:</p><div><pre class="programlisting">struct ClientInfo{
   sf::IpAddress m_clientIP;
   PortNumber m_clientPORT;
   sf::Time m_lastHeartbeat;
   sf::Time m_heartbeatSent;
   bool m_heartbeatWaiting;
   unsigned short m_heartbeatRetry;
   unsigned int m_latency;

   ClientInfo(const sf::IpAddress&amp; l_ip, const PortNumber&amp; l_port,
     const sf::Time&amp; l_heartbeat): m_clientIP(l_ip),
     m_clientPORT(l_port), m_lastHeartbeat(l_heartbeat), 
     m_heartbeatWaiting(false), m_heartbeatRetry(0), m_latency(0)
   {}

   ClientInfo&amp; operator=(const ClientInfo&amp; l_rhs){
      m_clientIP         = l_rhs.m_clientIP;
      m_clientPORT       = l_rhs.m_clientPORT;
      m_lastHeartbeat    = l_rhs.m_lastHeartbeat;
      m_heartbeatSent    = l_rhs.m_heartbeatSent;
      m_heartbeatWaiting = l_rhs.m_heartbeatWaiting;
      m_heartbeatRetry   = l_rhs.m_heartbeatRetry;
      m_latency          = l_rhs.m_latency;
      return *this;
   }
};</pre></div><p>Besides simply keeping track of the IP and port of a client, we also need to know when the last heartbeat was sent to them, whether the server is waiting for a heartbeat response, the number of heartbeat retries made, and the current latency the client has.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>Keeping track of latency provides tons of potential benefits, ranging from assessing quality of service and accurate matchmaking to maximizing the accuracy of a network simulation.</p></div></div><p>Next, the data types we're going to be using throughout the <code class="literal">Server</code> class deserve a look:</p><div><pre class="programlisting">using Clients = std::unordered_map&lt;ClientID, ClientInfo&gt;;
class Server;
using PacketHandler = std::function&lt;void(sf::IpAddress&amp;,
  const PortNumber&amp;, const PacketID&amp;, sf::Packet&amp;, Server*)&gt;;
using TimeoutHandler = std::function&lt;void(const ClientID&amp;)&gt;;</pre></div><p>As you <a id="id607" class="indexterm"/>can see, this class also uses a custom function that is going to be handling incoming packets. In addition to that, we're going to need to be able to process client timeouts outside of this class as well, which can also be done through means of using a function pointer.</p><p>We have everything we need, so let's write the <code class="literal">Server</code> class header:</p><div><pre class="programlisting">class Server{
public:
   template &lt;class T&gt;
   Server(void(T::*l_handler)(sf::IpAddress&amp;, const PortNumber&amp;, 
      const PacketID&amp;, sf::Packet&amp;, Server*),
      T* l_instance): m_listenThread(&amp;Server::Listen, this)
   {
      m_packetHandler = std::bind(l_handler, l_instance,
         std::placeholders::_1, std::placeholders::_2, 
         std::placeholders::_3, std::placeholders::_4, 
         std::placeholders::_5);
   }

   Server(void(*l_handler)(sf::IpAddress&amp;, const PortNumber&amp;, 
      const PacketID&amp;, sf::Packet&amp;, Server*));
   ~Server();

   template&lt;class T&gt;
   void BindTimeoutHandler(void(T::*l_handler)
      (const ClientID&amp;), T* l_instance)
   {
      m_timeoutHandler = std::bind(l_handler, l_instance, 
         std::placeholders::_1);
   }
   void BindTimeoutHandler(void(*l_handler)(const ClientID&amp;));

   bool Send(const ClientID&amp; l_id, sf::Packet&amp; l_packet);
   bool Send(sf::IpAddress&amp; l_ip, const PortNumber&amp; l_port, 
      sf::Packet&amp; l_packet);
   void Broadcast(sf::Packet&amp; l_packet, 
      const ClientID&amp; l_ignore = ClientID(Network::NullID));

   void Listen();
   void Update(const sf::Time&amp; l_time);

   ClientID AddClient(const sf::IpAddress&amp; l_ip, 
      const PortNumber&amp; l_port);
   ClientID GetClientID(const sf::IpAddress&amp; l_ip, 
      const PortNumber&amp; l_port);
   bool HasClient(const ClientID&amp; l_id);
   bool HasClient(const sf::IpAddress&amp; l_ip, 
      const PortNumber&amp; l_port);
   bool GetClientInfo(const ClientID&amp; l_id, ClientInfo&amp; l_info);
   bool RemoveClient(const ClientID&amp; l_id);
   bool RemoveClient(const sf::IpAddress&amp; l_ip, 
      const PortNumber&amp; l_port);

   void DisconnectAll();
   bool Start();
   bool Stop();

   bool IsRunning();

   unsigned int GetClientCount();
   std::string GetClientList();

   sf::Mutex&amp; GetMutex();
private:
   void Setup();
   ClientID m_lastID;

   sf::UdpSocket m_incoming;
   sf::UdpSocket m_outgoing;

   PacketHandler m_packetHandler;
   TimeoutHandler m_timeoutHandler;

   Clients m_clients;
   sf::Time m_serverTime;

   bool m_running;

   sf::Thread m_listenThread;
   sf::Mutex m_mutex;

   size_t m_totalSent;
   size_t m_totalReceived;
};</pre></div><p>Just like the <code class="literal">Client</code> class, we want to support both member functions and regular functions<a id="id608" class="indexterm"/> being bound as packet and timeout handlers. Additionally, we also need an instance of a mutex and two sockets: one for listening and one for sending data. Having two sockets on the server side provides separation between different operations, which sometimes may result in runtime errors and data corruption. For an added bonus, we're also keeping track of all data sent and received.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec120"/>Implementing server</h1></div></div></div><p>Let's start<a id="id609" class="indexterm"/> by taking a look at the second constructor and the destructor of this class:</p><div><pre class="programlisting">Server::Server(void(*l_handler)(sf::IpAddress&amp;, const PortNumber&amp;, 
   const PacketID&amp;, sf::Packet&amp;, Server*))
   : m_listenThread(&amp;Server::Listen, this)
{
   // Bind a packet handler function.
   m_packetHandler = std::bind(l_handler, 
     std::placeholders::_1, std::placeholders::_2,
     std::placeholders::_3, std::placeholders::_4,
     std::placeholders::_5);
}

Server::~Server(){ Stop(); }</pre></div><p>Nothing too interesting is happening here. The constructor simply binds the provided packet handler function, while the destructor just invokes the <code class="literal">Stop</code> method, which we are going to cover shortly. Speaking of binding, we also need a function to handle client timeouts:</p><div><pre class="programlisting">void Server::BindTimeoutHandler(void(*l_handler)
  (const ClientID&amp;))
{
   m_timeoutHandler = std::bind(l_handler, std::placeholders::_1);
}</pre></div><p>Simply having the client get disconnected is not always enough, depending on your application. One of the main ways we're going to be taking advantage of this feature is de-spawning entities in the game world.</p><p>Now, let's take <a id="id610" class="indexterm"/>a peek at how we start our server:</p><div><pre class="programlisting">bool Server::Start(){
    if (m_running){ return false; }
    if(m_incoming.bind(SERVER_PORT) != sf::Socket::Done){
        return false;
    }
    m_outgoing.bind(sf::Socket::AnyPort);
    Setup();
    std::cout &lt;&lt; "Incoming port: " &lt;&lt;
      m_incoming.getLocalPort() &lt;&lt; ". Outgoing port: " 
      &lt;&lt; m_outgoing.getLocalPort() &lt;&lt; std::endl;
    m_listenThread.launch();
    m_running = true;
    return true;
}</pre></div><p>If the server is already running, or if we failed to bind the incoming socket to the predesignated port number, <code class="literal">false</code> is returned. Otherwise, the outgoing socket is bound to a random port, a <code class="literal">Setup</code> method is invoked to set up some data members, the listening thread is launched, and the <code class="literal">m_running</code> flag is set to true. You can stop the server like this:</p><div><pre class="programlisting">bool Server::Stop(){
    if (!m_running){ return false; }
    DisconnectAll();
    m_running = false;
    m_incoming.unbind(); // Stops the listening thread.
    return true;
}</pre></div><p>If the server is actually running, a <code class="literal">DisconnectAll</code> method is invoked to drop all the clients. The running flag is then set to <code class="literal">false</code> and the incoming socket is unbound, which in turn stops the listening thread from running, as the socket is in blocking mode.</p><p>Here's a little helper method that initializes some data members to their default states:</p><div><pre class="programlisting">void Server::Setup(){
    m_lastID = 0;
    m_running = false;
    m_totalSent = 0;
    m_totalReceived = 0;
}</pre></div><p>This is invoked every time a server is started, as demonstrated previously.</p><p>Sending data to clients is fairly straightforward, as you can see here:</p><div><pre class="programlisting">bool Server::Send(const ClientID&amp; l_id, sf::Packet&amp; l_packet){
   <strong>sf::Lock lock(m_mutex);</strong>
   auto itr = m_clients.find(l_id);
   if (itr == m_clients.end()){ return false; }
   if (m_outgoing.send(l_packet, itr-&gt;second.m_clientIP, 
      itr-&gt;second.m_clientPORT) != sf::Socket::Done)
   {
      std::cout &lt;&lt; "Error sending a packet..." &lt;&lt; std::endl;
      return false;
   }
   m_totalSent += l_packet.getDataSize();
   return true;
}</pre></div><p>With <a id="id611" class="indexterm"/>a little bit of STL find magic, we retrieve the client's information from the container it's stored in and send the packet out.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Note the mutex lock in the very first line. This is done to ensure that the client isn't removed from the container right in the middle of a send operation.</p></div></div><p>As a side bonus, it's also nice to keep track of how much data was sent and received. Here, we make use of the <code class="literal">getDataSize</code> method that <code class="literal">sf::Packet</code> provides to do just that.</p><p>For convenience, we could also write an overloaded version of the <code class="literal">Send</code> method that doesn't require a client:</p><div><pre class="programlisting">bool Server::Send(sf::IpAddress&amp; l_ip,
  const PortNumber&amp; l_port, sf::Packet&amp; l_packet)
{
  if (m_outgoing.send(l_packet, l_ip, l_port) != sf::Socket::Done)
  {
    return false;
  }
  m_totalSent += l_packet.getDataSize();
  return true;
}</pre></div><p>In plenty of occasions, sending data out to only one client isn't enough. Broadcasting it to all of the clients currently connected can be useful for sending out anything from chat messages to entity states. Let's write it:</p><div><pre class="programlisting">void Server::Broadcast(sf::Packet&amp; l_packet,
  const ClientID&amp; l_ignore)
{
  <strong>sf::Lock lock(m_mutex);</strong>
  for (auto &amp;itr : m_clients)
  {
    if (itr.first != l_ignore){
      if (m_outgoing.send(l_packet, itr.second.m_clientIP,
        itr.second.m_clientPORT) != sf::Socket::Done)
      {
        std::cout &lt;&lt; "Error broadcasting a packet to client: " 
          &lt;&lt; itr.first &lt;&lt; std::endl;
        continue;
      }
      m_totalSent += l_packet.getDataSize();
    }
  }
}</pre></div><p>Once<a id="id612" class="indexterm"/> again, it's quite basic. The client container is iterated over and each client's ID is checked for matching the <code class="literal">l_ignore</code> argument, which can be used to specify a client ID that shouldn't receive the packet being broadcasted. If data is successfully sent out, its size is added to the sent data counter.</p><p>Much like the client, our server is going to need a separate thread for processing incoming data. Let's take a look at the <code class="literal">Listen</code> method:</p><div><pre class="programlisting">void Server::Listen(){
  sf::IpAddress ip;
  PortNumber port;
  sf::Packet packet;
  while (m_running){
    packet.clear();
    sf::Socket::Status status =
      m_incoming.receive(packet, ip, port);
    if (status != sf::Socket::Done){
      if (m_running){
        std::cout &lt;&lt; "Error receiving a packet from: "
          &lt;&lt; ip &lt;&lt; ":" &lt;&lt; port &lt;&lt; ". Code: " &lt;&lt;
          status &lt;&lt; std::endl;
        continue;
      } else {
        std::cout &lt;&lt; "Socket unbound." &lt;&lt; std::endl;
        break;
      }
    }

    m_totalReceived += packet.getDataSize();

    PacketID p_id;
    if (!(packet &gt;&gt; p_id)){
      continue;
    } // Non-conventional packet.
    PacketType id = (PacketType)p_id;
    if (id&lt;PacketType::Disconnect || id&gt;=PacketType::OutOfBounds){
      continue;
    } // Invalid packet type.

    if (id == PacketType::Heartbeat){
      sf::Lock lock(m_mutex);
      for (auto &amp;itr : m_clients){
        if (itr.second.m_clientIP != ip ||
          itr.second.m_clientPORT != port)
        {
          continue;
        }
        if (!itr.second.m_heartbeatWaiting){
          std::cout &lt;&lt; "Invalid heartbeat packet received!"
            &lt;&lt; std::endl;
          break;
        }
        itr.second.m_ping = m_serverTime.asMilliseconds() -
          itr.second.m_heartbeatSent.asMilliseconds();
        itr.second.m_lastHeartbeat = m_serverTime;
        itr.second.m_heartbeatWaiting = false;
        itr.second.m_heartbeatRetry = 0;
        break;
      }
    } else if (m_packetHandler){
      m_packetHandler(ip, port, (PacketID)id, packet, this);
    }
  }
}</pre></div><p>As you<a id="id613" class="indexterm"/> can see, it's quite similar to the way a client listener is implemented. After some local variables are set up for capturing incoming data, we enter a <code class="literal">while</code> loop, during which the packet is cleared and the blocking receive method of our incoming socket is invoked, capturing the status as well. Just as before, we break from the loop if the server is no longer running and the return status from the <code class="literal">receive</code> method was anything but <code class="literal">sf::Socket::Done</code>.</p><p>After all of the packet ID checks, we get to the heartbeat part of the code. A flag is set up to indicate whether a client that sent the heartbeat was located or not.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Note that we lock our mutex here, because we're about to start iterating over the list of clients in order to find the one that sent in the heartbeat response.</p></div></div><p>If the<a id="id614" class="indexterm"/> client with matching information has been found, we also check if the server is currently waiting for a heartbeat response from them. We only want clients to be able to send in heartbeat responses in order to both accurately measure latency and prevent potential cheating attempts.</p><p>Given that this is a valid heartbeat response, latency is calculated by subtracting the time a heartbeat was sent to this particular client from the current server time. The current timestamp is also stored in <code class="literal">m_lastHeartbeat</code>, which we'll be using to determine when to dispatch the next one. Afterwards, the heartbeat waiting flag is set to <code class="literal">false</code> and the retry counter is set back to 0.</p><p>Next, let's implement adding clients: </p><div><pre class="programlisting">ClientID Server::AddClient(const sf::IpAddress&amp; l_ip,
  const PortNumber&amp; l_port)
{
  <strong>sf::Lock lock(m_mutex);</strong>
  for (auto &amp;itr : m_clients){
    if (itr.second.m_clientIP == l_ip &amp;&amp;
      itr.second.m_clientPORT == l_port)
    {
      return ClientID(Network::NullID);
    }
  }
  ClientID id = m_lastID;
  ClientInfo info(l_ip, l_port, m_serverTime);
  m_clients.insert(std::make_pair(id, info));
  ++m_lastID;
  return id;
}</pre></div><p>Once again, since we're modifying client data, we want to lock our mutex to ensure no other piece of code running in another thread will attempt to read or modify the data as well. Following that, we do a quick search through the client container and return -1 if a specified IP and port combination already exists. Otherwise, a new client ID is assigned and the client information is inserted into the container, followed by an increment operation of <code class="literal">m_lastID</code>.</p><p>Sometimes, we may need to obtain the client ID of a client by providing their IP address and port number. Let's write a way to do just that:</p><div><pre class="programlisting">ClientID Server::GetClientID(const sf::IpAddress&amp; l_ip,
  const PortNumber&amp; l_port)
{
  <strong>sf::Lock lock(m_mutex);</strong>
  for (auto &amp;itr : m_clients){
    if (itr.second.m_clientIP == l_ip &amp;&amp;
      itr.second.m_clientPORT == l_port)
    {
      return itr.first;
    }
  }
  return ClientID(Network::NullID);
}</pre></div><p>As always, it <a id="id615" class="indexterm"/>simply iterates over each client and checks if their information matches the provided arguments. This is another instance where we need to lock the mutex in order to safely access this data.</p><p>Next up, we need some setters and getters:</p><div><pre class="programlisting">bool Server::HasClient(const ClientID&amp; l_id){
    return (m_clients.find(l_id) != m_clients.end());
}

bool Server::HasClient(const sf::IpAddress&amp; l_ip, 
  const PortNumber&amp; l_port)
{
    return(GetClientID(l_ip, l_port) &gt;= 0);
}

bool Server::IsRunning(){ return m_running; }
sf::Mutex&amp; Server::GetMutex(){ return m_mutex; }</pre></div><p>A way of obtaining client information from a client ID is also necessary:</p><div><pre class="programlisting">bool Server::GetClientInfo(const ClientID&amp; l_id,
  ClientInfo&amp; l_info)
{
  <strong>sf::Lock lock(m_mutex);</strong>
  for (auto &amp;itr : m_clients){
    if (itr.first == l_id){
      l_info = itr.second;
      return true;
    }
  }
  return false;
}</pre></div><p>In this case, the provided reference to a <code class="literal">ClientInfo</code> structure is simply overwritten with the located<a id="id616" class="indexterm"/> information. It can be done in a single line of code, thanks to the overloaded assignment operator that <code class="literal">ClientInfo</code> provides. Once again, the mutex is locked because we're accessing data that can be removed or overwritten in the middle of the search otherwise.</p><p>When a client is no longer needed, it must be removed. For convenience, we provide two variations of the same method:</p><div><pre class="programlisting">bool Server::RemoveClient(const ClientID&amp; l_id){
  sf::Lock lock(m_mutex);
  auto itr = m_clients.find(l_id);
  if (itr == m_clients.end()){ return false; }
  sf::Packet p;
  StampPacket(PacketType::Disconnect, p);
  Send(l_id, p);
  m_clients.erase(itr);
  return true;
}</pre></div><p>The first one simply locates client information by using the <code class="literal">find</code> method of a container it's stored in. If one was found, a disconnect packet is created and sent to the client before it gets erased. The second variation varies in its search method, but carries out the same basic idea:</p><div><pre class="programlisting">bool Server::RemoveClient(const sf::IpAddress&amp; l_ip,
  const PortNumber&amp; l_port)
{
  <strong>sf::Lock lock(m_mutex);</strong>
  for (auto itr = m_clients.begin(); 
    itr != m_clients.end(); ++itr)
  {
    if (itr-&gt;second.m_clientIP == l_ip &amp;&amp;
      itr-&gt;second.m_clientPORT == l_port)
    {
      sf::Packet p;
      StampPacket(PacketType::Disconnect , p);
      Send(itr-&gt;first, p);
      m_clients.erase(itr);
      return true;
    }
  }
  return false;
}</pre></div><p>Once again, the mutex is locked in both of them as data is being read and modified. Speaking of removing clients, how about having a method that kicks all of them out at the same time?</p><div><pre class="programlisting">void Server::DisconnectAll(){
  if (!m_running){ return; }
  sf::Packet p;
  StampPacket(PacketType::Disconnect, p);
  Broadcast(p);
  <strong>sf::Lock lock(m_mutex);</strong>
  m_clients.clear();
}</pre></div><p>It's quite a<a id="id617" class="indexterm"/> simple little bit of code. If the server is running, a disconnect packet is created, just like before, except it's broadcasted to all clients instead of just one. The mutex is then locked, right before the client container is cleared completely.</p><p>Last but definitely not least, here's the update method:</p><div><pre class="programlisting">void Server::Update(const sf::Time&amp; l_time){
  m_serverTime += l_time;
  if (m_serverTime.asMilliseconds() &lt; 0){ 
    m_serverTime -= sf::milliseconds(HIGHEST_TIMESTAMP);
    <strong>sf::Lock lock(m_mutex);</strong>
    for (auto &amp;itr : m_clients)
    {
      Itr.second.m_lastHeartbeat = 
        sf::milliseconds(std::abs(
        itr.second.m_lastHeartbeat.asMilliseconds() - 
        HIGHEST_TIMESTAMP));
    }
  }

  <strong>sf::Lock lock(m_mutex);</strong>
  for (auto itr = m_clients.begin(); itr != m_clients.end();){
    sf::Int32 elapsed = 
      m_serverTime.asMilliseconds() - 
      itr-&gt;second.m_lastHeartbeat.asMilliseconds();
    if (elapsed &gt;= HEARTBEAT_INTERVAL){
      if (elapsed &gt;= CLIENT_TIMEOUT 
        || itr-&gt;second.m_heartbeatRetry &gt; HEARTBEAT_RETRIES)
      {
        // Remove client.
        std::cout &lt;&lt; "Client " &lt;&lt; 
          itr-&gt;first &lt;&lt; " has timed out." &lt;&lt; std::endl;
        if (m_timeoutHandler){ m_timeoutHandler(itr-&gt;first); }
        itr = m_clients.erase(itr);
        continue;
      }
      if (!itr-&gt;second.m_heartbeatWaiting || (elapsed &gt;= 
        HEARTBEAT_INTERVAL * (itr-&gt;second.m_heartbeatRetry + 1)))
      {
        // Heartbeat
        if (itr-&gt;second.m_heartbeatRetry &gt;= 3){
          std::cout &lt;&lt; "Re-try(" &lt;&lt; itr-&gt;second.m_heartbeatRetry
            &lt;&lt; ") heartbeat for client " 
            &lt;&lt; itr-&gt;first &lt;&lt; std::endl;
        }
        sf::Packet Heartbeat;
        StampPacket(PACKET_HEARTBEAT, Heartbeat);
        Heartbeat &lt;&lt; m_serverTime.asMilliseconds();
        Send(itr-&gt;first, Heartbeat);
        if (itr-&gt;second.m_heartbeatRetry == 0){
          itr-&gt;second.m_heartbeatSent = m_serverTime;
        }
        itr-&gt;second.m_heartbeatWaiting = true;
        ++itr-&gt;second.m_heartbeatRetry;

        m_totalSent += Heartbeat.getDataSize();
      }
    }
    ++itr;
  }
}</pre></div><p>Similar to<a id="id618" class="indexterm"/> the client, the server also has to worry about the timestamp running out of bounds. Unlike the client, however, we need to reset the heartbeats of every client the server has, hence the mutex lock. Speaking of which, we also need to lock the mutex right before all of the update code, as it can potentially modify any of the clients, just like any other piece of code that runs in a different thread.</p><p>After the mutex lock, we begin iterating over clients and measuring the time elapsed between now and the last heartbeat. If this time exceeds or is equal to the interval we want heartbeats to be sent out at, we first check if it either also exceeds the timeout interval or if the number of heartbeat retries has exceeded the designated value. If so, the timeout handler is invoked and the client is erased from the container.</p><p>The heartbeat code itself is quite simple. If the server isn't waiting for a reply from the client, or if it's time to retry sending another heartbeat, a packet is constructed, the server time is attached to it, and it is sent out. If this is a first try sending it, the server time also gets stored inside the <code class="literal">m_heartbeatSent</code> data member of a client entry.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec121"/>A simple chat application</h1></div></div></div><p>We have<a id="id619" class="indexterm"/> the basic framework in place to handle connections, so let's build something with it! How about a neat little console-based chat program? Let's start with the server by creating a separate project and a new file called <code class="literal">Server_Main.cpp</code>. The first thing we're going to need is a packet handler:</p><div><pre class="programlisting">void Handler(sf::IpAddress&amp; l_ip, const PortNumber&amp; l_port,
  const PacketID&amp; l_id, sf::Packet&amp; l_packet, Server* l_server)
{
  ClientID id = l_server-&gt;GetClientID(l_ip, l_port);
  if (id &gt;= 0){
    if ((PacketType)l_id == PacketType::Disconnect){
      l_server-&gt;RemoveClient(l_ip, l_port);
      sf::Packet p;
      StampPacket(PacketType::Message, p);
      std::string message;
      message = "Client left! " + l_ip.toString() +
        ":" + std::to_string(l_port);
      p &lt;&lt; message;
      l_server-&gt;Broadcast(p, id);
    } else if ((PacketType)l_id == PacketType::Message){
      std::string receivedMessage;
      l_packet &gt;&gt; receivedMessage;
      std::string message = l_ip.toString() + ":" +
        std::to_string(l_port) + " :" + receivedMessage;
      sf::Packet p;
      StampPacket(PacketType::Message, p);
      p &lt;&lt; message;
      l_server-&gt;Broadcast(p, id);
    }
  } else {
    if ((PacketType)l_id == PacketType::Connect){
      ClientID id = l_server-&gt;AddClient(l_ip, l_port);
      sf::Packet packet;
      StampPacket(PacketType::Connect, packet);
      l_server-&gt;Send(id, packet);
    }
  }
}</pre></div><p>As we're going to be providing a pointer to this function to our <code class="literal">Server</code> class, the fingerprint has to match exactly. The function itself starts by first establishing whether the client ID for the provided IP address and port number exists. If it is indeed above or equal to zero, we're only interested in two types of packets: <code class="literal">Disconnect</code> and <code class="literal">Message</code>.</p><p>In a case <a id="id620" class="indexterm"/>of client disconnect, we create a message packet that is broadcasted to all clients except the one disconnecting. On the other hand, if there is an incoming message from one of the clients, it is first extracted and attached to a string that contains the client's IP address and port. We're not going to be using nicknames this time. The full message string is then attached to a message packet and broadcasted to every client, except the one that sent the message to begin with.</p><p>If a client wasn't found, however, all we care about is receiving connect packets. When one is received, the IP address and port are added and a connect packet is sent back to the client.</p><p>What kind of a server would it be if it didn't have the ability to process commands? Let's write a function that will be running in a separate thread and process user input:</p><div><pre class="programlisting">void CommandProcess(Server* l_server){
   while (l_server-&gt;IsRunning()){
      std::string str;
      std::getline(std::cin, str);
      if (str == "!quit"){
         l_server-&gt;Stop();
         break;
      } else if (str == "dc"){
         l_server-&gt;DisconnectAll();
         std::cout &lt;&lt; "DC..." &lt;&lt; std::endl;
      } else if (str == "list"){
         std::cout &lt;&lt; l_server-&gt;GetClientCount() 
            &lt;&lt; " clients online:" &lt;&lt; std::endl;
         std::cout &lt;&lt; l_server-&gt;GetClientList() &lt;&lt; std::endl;
      }
   }
}</pre></div><p>Note that <code class="literal">std::getline</code> is a blocking function. If the program stops running, the thread that this function is running on will still be blocking until some user input comes through. One way to get it to terminate is to implement a command that stops the server, which is what <code class="literal">"!quit"</code> does. Once the server <code class="literal">Stop</code> method is invoked, it also breaks the loop just to be safe.</p><p>The other two commands are pretty standard. One simply disconnects all users, while the other prints out a list of all connected clients. We haven't covered <code class="literal">GetClientCount</code> or <code class="literal">GetClientList</code>, since they're fairly basic and are not required for the server to run. You can find the implementation of these two methods in the source code of this book.</p><p>Now it's time to assemble and run our code:</p><div><pre class="programlisting">int main(){
   Server server(Handler);

   if (server.Start()){
      sf::Thread c(&amp;CommandProcess, &amp;server);
      c.launch();

      sf::Clock clock;
      clock.restart();
      while (server.IsRunning()){
         server.Update(clock.restart());
      }
      std::cout &lt;&lt; "Stopping server..." &lt;&lt; std::endl;
   }

   system("PAUSE");
   return 0;
}</pre></div><p>This is<a id="id621" class="indexterm"/> quite a basic setup for the entry point of an application like this. First, we create an instance of the <code class="literal">Server</code> class and provide a function pointer that is going to be handling packets in its constructor. We then attempt to start the server and catch the return value of that in an <code class="literal">if</code> statement. If a successful start took place, a command thread is set up and launched. An instance of <code class="literal">sf::Clock</code> is created and restarted before entering our main loop, which simply executes as long as the server is running and updates it with the elapsed time value between iterations. That's all we need to have in a chat server!</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec122"/>The chat client</h1></div></div></div><p>Our<a id="id622" class="indexterm"/> server is quite useless if we don't have the means of connecting to it and sending messages back and forth. In a separate project, let's create a file named <code class="literal">Client_Main.cpp</code> and begin writing the client portion of the code, starting with a packet handler:</p><div><pre class="programlisting">void HandlePacket(const PacketID&amp; l_id,
  sf::Packet&amp; l_packet, Client* l_client)
{
  if ((PacketType)l_id == PacketType::Message){
    std::string message;
    l_packet &gt;&gt; message;
    std::cout &lt;&lt; message &lt;&lt; std::endl;
  } else if ((PacketType)l_id == PacketType::Disconnect){
    l_client-&gt;Disconnect();
  }
}</pre></div><p>As you can see, it's really quite a simple design when we have a proper support class to fall back on. The client responds to two types of packets: messages and disconnects. In case a <a id="id623" class="indexterm"/>message pops in, it's extracted and simply printed in the console window. If a disconnect packet arrives from the server, the client's <code class="literal">Disconnect</code> method is invoked.</p><p>Next, the function that will be running in a command thread:</p><div><pre class="programlisting">void CommandProcess(Client* l_client){
   while (l_client-&gt;IsConnected()){
      std::string str;
      std::getline(std::cin, str);
      if (str != ""){
         if (str == "!quit"){
            l_client-&gt;Disconnect();
            break;
         }
         sf::Packet p;
         StampPacket(PacketType::Message, p);
         p &lt;&lt; str;
         l_client-&gt;Send(p);
      }
   }
}</pre></div><p>We're using the same basic principle of capturing console input with the <code class="literal">std::getline</code> function, except we're only going to be processing the quit command in this case. Anything else that gets entered is treated as a message and sent out to the server. Keep in mind that because the <code class="literal">std::getline</code> function is a blocking one, a user will have to press enter once if the client gets disconnected by the server, just to provide some input and get things moving again in order for the thread to be closed.</p><p>Lastly, let's put all of this code to work and implement the main loop of our chat client:</p><div><pre class="programlisting">void main(int argc, char** argv){
    sf::IpAddress ip;
    PortNumber port;
    if (argc == 1){
        std::cout &lt;&lt; "Enter Server IP: ";
        std::cin &gt;&gt; ip;
        std::cout &lt;&lt; "Enter Server Port: ";
        std::cin &gt;&gt; port;
    } else if (argc == 3){
        ip = argv[1];
        port = atoi(argv[2]);
    } else {
        return;
    }

    Client client;
    client.SetServerInformation(ip, port);
    client.Setup(&amp;HandlePacket);
    sf::Thread c(&amp;CommandProcess, &amp;client);
    if (client.Connect()){
        c.launch();
        sf::Clock clock;
        clock.restart();
        while (client.IsConnected()){
            client.Update(clock.restart());
        }
    } else {
        std::cout &lt;&lt; "Failed to connect." &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; "Quitting..." &lt;&lt; std::endl;
    sf::sleep(sf::seconds(1.f));
}</pre></div><p>We begin<a id="id624" class="indexterm"/> by setting up a few variables to hold the IP address and port of the server. For extra credit, let's add support for command line arguments. If none are provided, the user is simply prompted to enter the server information inside the console window. Otherwise, the command-line arguments are read in and used for the same purpose.</p><p>Moving further, we see that an instance of <code class="literal">Client</code> is created and set up with the server information that was provided, in addition to the packet handler function getting registered and a command thread being prepared. The client then attempts to connect to the server, and if the connection is successful, the command thread is launched, an instance of <code class="literal">sf::Clock</code> is created, and the main loop of the program is entered, where the client gets updated.</p><p>With this, we have a fairly simple yet functional chat application:</p><div><img src="img/B04284_13_05.jpg" alt="The chat client"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec123"/>Summary</h1></div></div></div><p>Congratulations on making it this far! Having covered the most important fundamentals, which includes the basics of socket programming, utilization of threads, and building the underlying layer of client-server communications, we're finally ready to tackle actual game networking! In the final chapter of this book, we're going to integrate this network code into our existing code base, turning a lonely single player RPG into an exciting arena of player versus player combat! See you there!</p></div></body></html>